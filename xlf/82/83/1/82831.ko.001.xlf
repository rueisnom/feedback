<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/82831">
    <body>
      <group id="82831">
        <trans-unit id="c57a62c684c9ba50ef4276461ac8271cc4409e22" translate="yes" xml:space="preserve">
          <source>(&lt;strong&gt;&lt;em&gt;Win&lt;/em&gt;&lt;/strong&gt; specific): Since &lt;em&gt;vcruntime*&lt;/em&gt; (&lt;em&gt;msvcr*&lt;/em&gt;) &lt;em&gt;.dll&lt;/em&gt; exports a &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=vs-2015&quot;&gt;[MS.Docs]: _access, _waccess&lt;/a&gt; function family as well, here's an example:</source>
          <target state="translated">( &lt;strong&gt;&lt;em&gt;Win&lt;/em&gt;&lt;/strong&gt; 관련) : &lt;em&gt;vcruntime *&lt;/em&gt; ( &lt;em&gt;msvcr *&lt;/em&gt; ) &lt;em&gt;.dll&lt;/em&gt; 이 &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=vs-2015&quot;&gt;[MS.Docs] : _access, _waccess&lt;/a&gt; 함수 제품군도 내보내므로 다음 예제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="40424e2404c07b5e06b147f732d917ab30140356" translate="yes" xml:space="preserve">
          <source>([Errno 2] No such file or directory:
  'whatever.txt')</source>
          <target state="translated">([Errno 2] 해당 파일이나 디렉토리가 없습니다 : 'whatever.txt')</target>
        </trans-unit>
        <trans-unit id="47357201492ecc28a3c7f77186ebaf58446769e4" translate="yes" xml:space="preserve">
          <source>...test if the invoking user has the specified access to &lt;em&gt;path&lt;/em&gt;. &lt;em&gt;mode&lt;/em&gt; should be &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.F_OK&quot;&gt;F_OK&lt;/a&gt; to test the existence of path...</source>
          <target state="translated">... 호출하는 사용자에게 &lt;em&gt;path에&lt;/em&gt; 대한 지정된 액세스 권한이 있는지 테스트하십시오. 경로의 존재를 테스트하려면 &lt;em&gt;mode&lt;/em&gt; 가 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.F_OK&quot;&gt;F_OK&lt;/a&gt; 여야합니다.</target>
        </trans-unit>
        <trans-unit id="787fad3e2ffee45a57341c551ccca124f8b07869" translate="yes" xml:space="preserve">
          <source>1.1. &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;[Python 3]: Path.&lt;strong&gt;is_file&lt;/strong&gt;()&lt;/a&gt;</source>
          <target state="translated">1.1. &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;[파이썬 3] : 경로.&lt;/a&gt; &lt;strong&gt;is_file&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="84da2f4e22fc9c7b904c3bcfae38c0e0ce23d934" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.iglob&quot;&gt;[Python 3]: glob.&lt;strong&gt;iglob&lt;/strong&gt;(&lt;em&gt;pathname, *, recursive=False&lt;/em&gt;)&lt;/a&gt; (or its predecessor: &lt;code&gt;glob.glob&lt;/code&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.iglob&quot;&gt;[파이썬 3] : glob.&lt;/a&gt; &lt;strong&gt;iglob&lt;/strong&gt; ( &lt;em&gt;pathname, *, recursive = False&lt;/em&gt; ) (또는 이전 버전 : &lt;code&gt;glob.glob&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a32d328d73882905860fd2807cd7c44ceaaa3322" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;[Python 3]: os.&lt;strong&gt;access&lt;/strong&gt;(&lt;em&gt;path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True&lt;/em&gt;)&lt;/a&gt; whose behavior is close to &lt;code&gt;os.path.exists&lt;/code&gt; (actually it's wider, mainly because of the 2&lt;sup&gt;nd&lt;/sup&gt; argument)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;[파이썬 3] : os.&lt;/a&gt; &lt;code&gt;os.path.exists&lt;/code&gt; 에 가까운 ( &lt;em&gt;path, mode, *, dir_fd = None, effective_ids = False, follow_symlinks = True&lt;/em&gt; ) (실제로는 주로 두 &lt;sup&gt;번째&lt;/sup&gt; 인수로 인해 더 넓습니다)</target>
        </trans-unit>
        <trans-unit id="4156cef8783a6c3af93cebc9154ef17488855064" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;[Python 3]: os.&lt;strong&gt;listdir&lt;/strong&gt;(&lt;em&gt;path='.'&lt;/em&gt;)&lt;/a&gt; (or &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;[Python 3]: os.&lt;strong&gt;scandir&lt;/strong&gt;(&lt;em&gt;path='.'&lt;/em&gt;)&lt;/a&gt; on &lt;em&gt;Python v&lt;strong&gt;3.5&lt;/strong&gt;&lt;/em&gt;+, backport: &lt;a href=&quot;https://pypi.org/project/scandir&quot;&gt;[PyPI]: scandir&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;[파이썬 3] : os.&lt;/a&gt; &lt;strong&gt;listdir&lt;/strong&gt; ( &lt;em&gt;path = '.'&lt;/em&gt; ) (또는 &lt;em&gt;Python v &lt;strong&gt;3.5&lt;/strong&gt;&lt;/em&gt; +의 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;[Python 3] : os. &lt;strong&gt;scandir&lt;/strong&gt; ( &lt;em&gt;path = '.'&lt;/em&gt; )&lt;/a&gt; , 백 포트 : &lt;a href=&quot;https://pypi.org/project/scandir&quot;&gt;[PyPI] : scandir&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="881c94c992f5c2704f7aea54c69305fd8520f3b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.path.html#os.path.exists&quot;&gt;[Python 3]: os.path.&lt;strong&gt;exists&lt;/strong&gt;(&lt;em&gt;path&lt;/em&gt;)&lt;/a&gt; (also check other function family members like &lt;code&gt;os.path.isfile&lt;/code&gt;, &lt;code&gt;os.path.isdir&lt;/code&gt;, &lt;code&gt;os.path.lexists&lt;/code&gt; for slightly different behaviors)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.path.html#os.path.exists&quot;&gt;[파이썬 3] : os.path.&lt;/a&gt; &lt;strong&gt;존재합니다&lt;/strong&gt; ( &lt;em&gt;path&lt;/em&gt; ) (또한 &lt;code&gt;os.path.isfile&lt;/code&gt; , &lt;code&gt;os.path.isdir&lt;/code&gt; , &lt;code&gt;os.path.lexists&lt;/code&gt; 와 같은 다른 함수 계열 구성원에서 약간 다른 동작을 확인하십시오)</target>
        </trans-unit>
        <trans-unit id="16a9582fc6e61500a615bb32272726f039a6dea9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#context-managers&quot;&gt;[Python 3]: With Statement Context Managers&lt;/a&gt;. Either:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#context-managers&quot;&gt;[Python 3] : 명령문 컨텍스트 관리자 사용&lt;/a&gt; 어느 한 쪽:</target>
        </trans-unit>
        <trans-unit id="e7facdf0dc4a8e14a1a54deddc2ccf73d6d27185" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isfile&lt;/code&gt; is actually just a helper method that internally uses &lt;code&gt;os.stat&lt;/code&gt; and &lt;code&gt;stat.S_ISREG(mode)&lt;/code&gt; underneath. This &lt;code&gt;os.stat&lt;/code&gt; is a lower-level method that will provide you with detailed information about files, directories, sockets, buffers, and more. &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.stat&quot;&gt;More about os.stat here&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;isfile&lt;/code&gt; 은 실제로 내부적으로 &lt;code&gt;os.stat&lt;/code&gt; 와 &lt;code&gt;stat.S_ISREG(mode)&lt;/code&gt; 사용하는 도우미 메소드입니다. 이 &lt;code&gt;os.stat&lt;/code&gt; 는 파일, 디렉토리, 소켓, 버퍼 등에 대한 자세한 정보를 제공하는 하위 레벨 방법입니다. &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.stat&quot;&gt;os.stat에 대한 자세한 내용은 here&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56f16f3fd911d49aaf5aa425fc05be5bcc4d128b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.path&lt;/code&gt; - &lt;em&gt;posixpath.py&lt;/em&gt; (&lt;em&gt;ntpath.py&lt;/em&gt;)</source>
          <target state="translated">&lt;em&gt;os.path-posixpath.py&lt;/em&gt; ( &lt;em&gt;ntpath.py&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="c213153b48aa1adfe737e87d17e184e0df446764" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress&lt;/code&gt; is part of Python 3.4. In older releases you can quickly write your own suppress:</source>
          <target state="translated">&lt;code&gt;suppress&lt;/code&gt; 는 Python 3.4의 일부입니다. 이전 릴리스에서는 자신 만의 억제를 빠르게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7341feac8a06399cdfbd59912dc1807dd4972e4d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nix&lt;/em&gt; (&lt;em&gt;Lnx&lt;/em&gt; (&lt;em&gt;Ubtu&lt;/em&gt;)):</source>
          <target state="translated">&lt;em&gt;닉스&lt;/em&gt; ( &lt;em&gt;Lnx&lt;/em&gt; ( &lt;em&gt;Ubtu&lt;/em&gt; )) :</target>
        </trans-unit>
        <trans-unit id="bcc27befb6f3b8f2dfa82be82a68582f296622aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nix&lt;/em&gt;: &lt;a href=&quot;http://man7.org/linux/man-pages/man2/access.2.html&quot;&gt;[man7]: ACCESS(2)&lt;/a&gt; (!!! pay attention to the note about the &lt;strong&gt;security hole&lt;/strong&gt; its usage might introduce !!!)</source>
          <target state="translated">&lt;em&gt;Nix&lt;/em&gt; : &lt;a href=&quot;http://man7.org/linux/man-pages/man2/access.2.html&quot;&gt;[man7] : ACCESS (2)&lt;/a&gt; (!!! 사용법으로 인해 발생할 수있는 &lt;strong&gt;보안 허점에&lt;/strong&gt; 주의하십시오 !!!)</target>
        </trans-unit>
        <trans-unit id="a16adeeb8960035b0fa48ff747e9036d84b7fac1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nix&lt;/em&gt;: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/opendir.3.html&quot;&gt;[man7]: OPENDIR(3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/readdir.3.html&quot;&gt;[man7]: READDIR(3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/closedir.3.html&quot;&gt;[man7]: CLOSEDIR(3)&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Nix&lt;/em&gt; : &lt;a href=&quot;http://man7.org/linux/man-pages/man3/opendir.3.html&quot;&gt;[man7] : OPENDIR (3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/readdir.3.html&quot;&gt;[man7] : READDIR (3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/closedir.3.html&quot;&gt;[man7] : CLOSEDIR (3)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e3e7e3a1bf52b57f359fffd279b3063aa9c1eab" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Win&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Win&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="672cf7faded202b7034a24292acbf961c1694c7b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Win&lt;/em&gt;: &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew&quot;&gt;[MS.Docs]: FindFirstFileW function&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew&quot;&gt;[MS.Docs]: FindNextFileW function&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose&quot;&gt;[MS.Docs]: FindClose function&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;승리&lt;/em&gt; : &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew&quot;&gt;[MS.Docs] : FindFirstFileW 함수&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew&quot;&gt;[MS.Docs] : FindNextFileW 함수&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose&quot;&gt;[MS.Docs] : FindClose 함수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="918e9fb58193867f89f5a410d74811d1771b2724" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Win&lt;/em&gt;: &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-getfileattributesw&quot;&gt;[MS.Docs]: GetFileAttributesW function&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;승리&lt;/em&gt; : &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-getfileattributesw&quot;&gt;[MS.Docs] : GetFileAttributesW 함수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d6ed7dbc3e0f962103d4c625797662e29aa9184" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;genericpath.py&lt;/em&gt;, line &lt;em&gt;~#20+&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;genericpath.py&lt;/em&gt; , &lt;em&gt;~ # 20 +&lt;/em&gt; 행</target>
        </trans-unit>
        <trans-unit id="423d8236f9dc3da510581f0ee3fbcd477ede396d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bottom line&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;결론&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="2b621694fd99fa555aa2279458b5f4cee2e246ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do&lt;/strong&gt; use &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; blocks, because they can prevent you running into a series of nasty problems. A counter-example that I can think of, is performance: such blocks are costly, so try not to place them in code that it's supposed to run hundreds of thousands times per second (but since (in most cases) it involves disk access, it won't be the case).</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; 블록을 사용하면 일련의 불쾌한 문제가 발생하지 않도록 막을 수 있습니다. 제가 생각할 수있는 반례는 성능입니다. 이러한 블록은 비용이 많이 들기 때문에 초당 수십만 번 실행되도록 코드에 배치하지 마십시오 (그러나 대부분의 경우 디스크 액세스가 필요합니다. 그렇지 않습니다).</target>
        </trans-unit>
        <trans-unit id="114c46c58943d0d3fb01ce5a2dbc7e5146a8eddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Final note(s)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;최종 메모&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4ae1be26b6f0138302a179e64d43a2067887f700" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do I check whether a file exists, without using the try statement?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;try 문을 사용하지 않고 파일이 존재하는지 어떻게 확인합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d629d8e59823d5bde2e04f68edf40981e144ca70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; However, this approach will not lock the file in any way and therefore your code can become vulnerable to &quot;&lt;strong&gt;time of check to time of use&lt;/strong&gt;&quot; (&lt;em&gt;TOCTTOU&lt;/em&gt;) bugs.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 그러나이 방법은 파일을 어떤 식 으로든 잠그지 않으므로 코드가 &quot;사용 &lt;strong&gt;시간 확인&lt;/strong&gt; &quot;( &lt;em&gt;TOCTTOU&lt;/em&gt; ) 버그에 취약해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55fac486326161bbbcc381844be9edd879071502" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: calling native &lt;em&gt;API&lt;/em&gt;s is also possible via &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;[Python 3]: &lt;em&gt;ctypes&lt;/em&gt; - A foreign function library for Python&lt;/a&gt;, but in most cases it's more complicated.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;[Python 3]을&lt;/a&gt; 통해 네이티브 &lt;em&gt;API를&lt;/em&gt; 호출 할 수도 있습니다 . &lt;em&gt;ctypes&lt;/em&gt; -Python의 외부 함수 라이브러리 이지만 대부분의 경우 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="49d34f653b3f7b18395aa530bbca320ea65fe2bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: every piece of &lt;em&gt;Python&lt;/em&gt; standard library code that I'm going to post, belongs to version &lt;strong&gt;3.5.3&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 게시 할 모든 &lt;em&gt;Python&lt;/em&gt; 표준 라이브러리 코드는 버전 &lt;strong&gt;3.5.3에&lt;/strong&gt; 속합니다.</target>
        </trans-unit>
        <trans-unit id="f69af187844f3307c7ac46ebb6a50af4199d0748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="0429ce3fc368572fdbb918ae180fcce64fed32ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Possible solutions&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;가능한 해결책&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="5fed05e805aed79ae5e47afbe0cb8a973df01183" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem statement&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;문제 설명&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="06e40dece35eaf987428ae55c6db9c12f565c3c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 3.4+&lt;/strong&gt; has an object-oriented path module: &lt;a href=&quot;http://docs.python.org/3.4/library/pathlib.html&quot;&gt;&lt;strong&gt;pathlib&lt;/strong&gt;&lt;/a&gt;.  Using this new module, you can check whether a file exists like this:</source>
          <target state="translated">&lt;strong&gt;Python 3.4+&lt;/strong&gt; 에는 객체 지향 경로 모듈 ( &lt;a href=&quot;http://docs.python.org/3.4/library/pathlib.html&quot;&gt;&lt;strong&gt;pathlib)이&lt;/strong&gt;&lt;/a&gt; 있습니다. 이 새로운 모듈을 사용하여 파일이 다음과 같이 존재하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8e849d6a4eb1c3b48df71118000704a6892341f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;isfile&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;isfile&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ccfc4989519ffe46e24bb53066a5a14a735987c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;os.access&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;os.access&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cbfe01e7936d0de4ea51c3c0558f1bb48b1f30e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;user permissions&lt;/strong&gt; might restrict the file &quot;visibility&quot; as the doc states:</source>
          <target state="translated">doc 상태에 따라 &lt;strong&gt;사용자 권한으로&lt;/strong&gt; 파일 &quot;visibility&quot;가 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa65b1dac98f13533fe2f70426ca413eff63c4b0" translate="yes" xml:space="preserve">
          <source>Adding a variant based on suggestion from Peter Wood</source>
          <target state="translated">Peter Wood의 제안을 기반으로 변형 추가</target>
        </trans-unit>
        <trans-unit id="80c015f2d056c575939357b34c73484f4d21f408" translate="yes" xml:space="preserve">
          <source>Adding a variant based on suggestion from Shahbaz</source>
          <target state="translated">Shahbaz의 제안을 기반으로 변형 추가</target>
        </trans-unit>
        <trans-unit id="8dcd1e3788c9558ded09b3960d94517b78c07f15" translate="yes" xml:space="preserve">
          <source>Adding one more slight variation which isn't exactly reflected in the other answers.</source>
          <target state="translated">다른 답변에 정확하게 반영되지 않은 약간의 변형을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d8fa576e19bc4318ac6a981c7b91c8f2cbbb0f5c" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;os.access()&lt;/code&gt;:</source>
          <target state="translated">또한 &lt;code&gt;os.access()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="77d1962860d37265160d4636c2fd603e0de75d36" translate="yes" xml:space="preserve">
          <source>All good, but if following the import tree:</source>
          <target state="translated">모두 좋지만 가져 오기 트리를 따르는 경우 :</target>
        </trans-unit>
        <trans-unit id="78f3ec46f0be71b55c60a634c5c232244a44c6d0" translate="yes" xml:space="preserve">
          <source>All it's doing is using the given path to see if it can get stats on it,  catching &lt;code&gt;OSError&lt;/code&gt; and then checking if it's a file if it didn't raise the exception.</source>
          <target state="translated">주어진 경로를 사용하여 통계를 얻을 수 있는지 확인하고 &lt;code&gt;OSError&lt;/code&gt; 를 포착 한 다음 예외가 발생하지 않은 경우 파일인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9b23ce4faf3bf6e817d02cdbe090fd916f4c40e3" translate="yes" xml:space="preserve">
          <source>Although I always recommend using &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;except&lt;/code&gt; statements, here are a few possibilities for you (my personal favourite is using &lt;code&gt;os.access&lt;/code&gt;):</source>
          <target state="translated">항상 &lt;code&gt;try&lt;/code&gt; 및 &lt;code&gt;except&lt;/code&gt; 문을 사용 하는 것이 좋지만 다음은 몇 가지 가능성입니다 (개인적으로 선호하는 것은 &lt;code&gt;os.access&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c28a1b9efeed16f3cc15a65fe06dbf2005ac95c5" translate="yes" xml:space="preserve">
          <source>Although almost every possible way has been listed in (at least one of) the existing answers (e.g. &lt;em&gt;Python 3.4&lt;/em&gt; specific stuff was added), I'll try to group everything together.</source>
          <target state="translated">거의 모든 가능한 방법이 기존 답변 (예 : &lt;em&gt;Python 3.4&lt;/em&gt; 관련 항목이 추가됨)에 나열되어 있지만 모든 것을 함께 그룹화하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="16295a749dac9ed45033fdbc3aac9a2b96843f1d" translate="yes" xml:space="preserve">
          <source>Although it's not a good practice, I'm using &lt;code&gt;os.F_OK&lt;/code&gt; in the call, but that's just for clarity (its value is &lt;strong&gt;0&lt;/strong&gt;)</source>
          <target state="translated">좋은 방법은 아니지만 호출에 &lt;code&gt;os.F_OK&lt;/code&gt; 를 사용하고 있지만 명확성을 위해 있습니다 (값은 &lt;strong&gt;0&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="3f08a8328b4d7fdf72d3c29093a5ec904d34940a" translate="yes" xml:space="preserve">
          <source>Although this targets a very specific area, &lt;strong&gt;it was not mentioned in any of the previous answers&lt;/strong&gt;</source>
          <target state="translated">이것은 매우 구체적인 영역을 목표로하지만 &lt;strong&gt;이전 답변에서는 언급되지 않았습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="78f96d0ac535b29f25a666e1fd59d59ef2274f92" translate="yes" xml:space="preserve">
          <source>An intuitive and arguable way to check if a file exists is the following:</source>
          <target state="translated">파일이 존재하는지 확인하는 직관적이고 논쟁의 여지가있는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e11bbf35099c5b98a84a5e51e2b22a25ec14116" translate="yes" xml:space="preserve">
          <source>And its usage - I'll replicate the &lt;code&gt;os.path.isfile&lt;/code&gt; behavior (note that this is just for demonstrating purposes, do &lt;strong&gt;not&lt;/strong&gt; attempt to write such code for &lt;em&gt;production&lt;/em&gt;):</source>
          <target state="translated">그리고 사용법 &lt;code&gt;os.path.isfile&lt;/code&gt; 동작을 복제합니다 (이것은 단지 설명을 목적으로 한 것이며 &lt;em&gt;생산을&lt;/em&gt; 위해 그러한 코드를 작성하려고 시도하지 &lt;strong&gt;마십시오&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="c242f95ca1e5451cdad6a7e633a8bef0a286e761" translate="yes" xml:space="preserve">
          <source>And the doc&amp;hellip;</source>
          <target state="translated">그리고 의사&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a2e22103d7193a6b3e153c897e9be19320669858" translate="yes" xml:space="preserve">
          <source>Another (lame) workaround (&lt;em&gt;gainarie&lt;/em&gt;) is (as I like to call it,) the &lt;em&gt;sysadmin&lt;/em&gt; approach: use &lt;em&gt;Python&lt;/em&gt; as a wrapper to execute shell commands</source>
          <target state="translated">또 다른 (불법적 인) 해결 방법 ( &lt;em&gt;gainarie&lt;/em&gt; )은 &lt;em&gt;sysadmin&lt;/em&gt; 접근 방식입니다 ( &lt;em&gt;파이썬&lt;/em&gt; 을 래퍼로 사용하여 쉘 명령 실행)</target>
        </trans-unit>
        <trans-unit id="9fe49da0dcd83e20fd5dd80ebdfbe1ed9a2c2eae" translate="yes" xml:space="preserve">
          <source>Another answer says this about &lt;code&gt;os.access&lt;/code&gt;:</source>
          <target state="translated">또 다른 대답은 &lt;code&gt;os.access&lt;/code&gt; 에 대해 말합니다.</target>
        </trans-unit>
        <trans-unit id="dd57f8a5f3007d7bb9aa43a930b678df495e7817" translate="yes" xml:space="preserve">
          <source>Anyway, here:</source>
          <target state="translated">어쨌든, 여기 :</target>
        </trans-unit>
        <trans-unit id="9a06af54a07db4e5735e851faae4a0df7e12350c" translate="yes" xml:space="preserve">
          <source>Assuming that the &quot;path&quot; is a valid path, this table shows what is returned by each function for files and folders:</source>
          <target state="translated">&quot;경로&quot;가 유효한 경로라고 가정하면이 표는 파일과 폴더에 대해 각 함수가 반환하는 내용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4aa4567b6cd6712a2f7dedeecffb310d4fb8efca" translate="yes" xml:space="preserve">
          <source>Available for Unix and Windows is &lt;code&gt;os.access&lt;/code&gt;, but to use you must pass flags, and it does not differentiate between files and directories. This is more used to test if the real invoking user has access in an elevated privilege environment:</source>
          <target state="translated">유닉스와 Windows에서 사용할 수있는 것은 &lt;code&gt;os.access&lt;/code&gt; 이지만 사용하려면 플래그를 전달해야하며 파일과 디렉토리를 구분하지 않습니다. 실제 호출하는 사용자가 상승 된 권한 환경에서 액세스 할 수 있는지 테스트하는 데 더 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f939845f218e32c170faf5bf6f1cac2c41d8816a" translate="yes" xml:space="preserve">
          <source>Available since Python 3.4, use the new &lt;code&gt;Path&lt;/code&gt; object in &lt;code&gt;pathlib&lt;/code&gt;. Note that &lt;code&gt;.exists&lt;/code&gt; is not quite right, because directories are not files (except in the unix sense that &lt;em&gt;everything&lt;/em&gt; is a file).</source>
          <target state="translated">Python 3.4부터 사용 가능하며 &lt;code&gt;pathlib&lt;/code&gt; 의 새 &lt;code&gt;Path&lt;/code&gt; 객체를 사용하십시오. 디렉토리는 파일이 아니기 때문에 &lt;code&gt;.exists&lt;/code&gt; 는 옳지 않습니다 (유닉스 의미에서는 &lt;em&gt;모든&lt;/em&gt; 것이 파일이라는 &lt;em&gt;것을&lt;/em&gt; 제외하고).</target>
        </trans-unit>
        <trans-unit id="afb7ff96e854e0041ec75564f5fe00e9c8f882e0" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;os.access&lt;/code&gt;. It is a low level function that has more opportunities for user error than the higher level objects and functions discussed above.</source>
          <target state="translated">&lt;code&gt;os.access&lt;/code&gt; 사용을 피하십시오. 위에서 설명한 상위 수준 개체 및 기능보다 사용자 오류 가능성이 더 낮은 하위 수준 기능입니다.</target>
        </trans-unit>
        <trans-unit id="da6dd21459c0ea82eef4c904638259335de797c6" translate="yes" xml:space="preserve">
          <source>Avoiding Race Conditions</source>
          <target state="translated">경쟁 조건 피하기</target>
        </trans-unit>
        <trans-unit id="65d799a4d67e40f1718bc28bc5741a7784d3dc98" translate="yes" xml:space="preserve">
          <source>Avoiding race conditions without a try statement: &lt;code&gt;suppress&lt;/code&gt;</source>
          <target state="translated">try 문없이 경쟁 조건 피하기 : &lt;code&gt;suppress&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16914c6434145a06ea234b60fc7371e4a7fa25c2" translate="yes" xml:space="preserve">
          <source>Because Python uses &lt;code&gt;try&lt;/code&gt; everywhere, there's really no reason to avoid an implementation that uses it.</source>
          <target state="translated">파이썬은 모든 곳에서 &lt;code&gt;try&lt;/code&gt; 사용하기 때문에 그것을 사용하는 구현을 피할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1360085308b5fa42bcc299eba73a082684f6297d" translate="yes" xml:space="preserve">
          <source>Being &lt;code&gt;R_OK&lt;/code&gt;, &lt;code&gt;W_OK&lt;/code&gt;, and &lt;code&gt;X_OK&lt;/code&gt; the flags to test for permissions (&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;doc&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;R_OK&lt;/code&gt; , &lt;code&gt;W_OK&lt;/code&gt; 및 &lt;code&gt;X_OK&lt;/code&gt; 이므로 권한을 테스트 할 플래그 ( &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;doc&lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="b5ce4b99d290844609883481eafaef7da7bec38b" translate="yes" xml:space="preserve">
          <source>But if this is your motivation, you &lt;em&gt;can&lt;/em&gt; get the value of a &lt;code&gt;try&lt;/code&gt; statement by using the &lt;code&gt;suppress&lt;/code&gt; context manager.</source>
          <target state="translated">그러나 이것이 동기 부여 인 경우 &lt;code&gt;suppress&lt;/code&gt; 컨텍스트 관리자를 사용하여 &lt;code&gt;try&lt;/code&gt; 문의 값을 얻을 &lt;em&gt;수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f386f26a018b39932ce810bfed8462f4b3a47009" translate="yes" xml:space="preserve">
          <source>But if you examine the &lt;a href=&quot;https://hg.python.org/cpython/file/tip/Lib/genericpath.py#l25&quot;&gt;source&lt;/a&gt; of this function, you'll see it actually does use a try statement:</source>
          <target state="translated">그러나이 함수의 &lt;a href=&quot;https://hg.python.org/cpython/file/tip/Lib/genericpath.py#l25&quot;&gt;소스&lt;/a&gt; 를 살펴보면 실제로 try 문을 사용하는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="892805ad4977b8e4cbbb93d3b769716f4bf55e28" translate="yes" xml:space="preserve">
          <source>But if you just wanted to rename a file if it exists, and therefore don't need to open it, do</source>
          <target state="translated">그러나 파일이 있으면 파일 이름을 바꾸고 싶을 때 열 필요가 없으면</target>
        </trans-unit>
        <trans-unit id="e6de42189ae24dbf3535041c097ece060e47ed05" translate="yes" xml:space="preserve">
          <source>But the rest of this answer attempts to consider these caveats.</source>
          <target state="translated">그러나이 답변의 나머지 부분은 이러한주의 사항을 고려하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a80baeb2d0654bc11cd6d4521f34ce4502d6e633" translate="yes" xml:space="preserve">
          <source>But, since this is more like a workaround, I'm stopping here.</source>
          <target state="translated">그러나 이것은 해결 방법과 비슷하기 때문에 여기서 멈 춥니 다.</target>
        </trans-unit>
        <trans-unit id="a4baa59ded747be901cc0484a5e9a9c22477fa86" translate="yes" xml:space="preserve">
          <source>But, they seem to be wrappers over &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; blocks, as &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#with&quot;&gt;[Python 3]: The &lt;em&gt;with&lt;/em&gt; statement&lt;/a&gt; states:</source>
          <target state="translated">그러나 그들은 &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#with&quot;&gt;[Python 3]&lt;/a&gt; 과 같이 &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; 블록을 감싸는 래퍼 인 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="3f1992230a0a514077c62160f7120bcc185acd4c" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;NamedTemporaryFile&lt;/code&gt; deletes the file when closed (and will automatically close when no more references exist to it).</source>
          <target state="translated">기본적으로 &lt;code&gt;NamedTemporaryFile&lt;/code&gt; 은 파일을 닫을 때 파일을 삭제합니다 (더 이상 참조가 없으면 자동으로 닫힙니다).</target>
        </trans-unit>
        <trans-unit id="680c3a0a04488efb0a6669d23ed46dff42487746" translate="yes" xml:space="preserve">
          <source>Check file (&lt;em&gt;arguable&lt;/em&gt;: also folder (&quot;special&quot; file) ?) existence</source>
          <target state="translated">파일 점검 ( &lt;em&gt;논쟁의 여지&lt;/em&gt; : 폴더 ( &quot;특별한&quot;파일)?) 존재</target>
        </trans-unit>
        <trans-unit id="00069321f9bac6a3e2758c45a988eb1af4ffe84c" translate="yes" xml:space="preserve">
          <source>Check file or directory exists</source>
          <target state="translated">파일 또는 디렉토리 확인</target>
        </trans-unit>
        <trans-unit id="2148c4248cab3850cba5ecc20309317f0af37946" translate="yes" xml:space="preserve">
          <source>Create one:</source>
          <target state="translated">하나를 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="23c1fa17d5809322d5e9a7c843e9604caa61cdff" translate="yes" xml:space="preserve">
          <source>Criticism of another answer:</source>
          <target state="translated">다른 답변에 대한 비판 :</target>
        </trans-unit>
        <trans-unit id="3b40241a5f2c37e0887dd4f6954b744ced57b1ec" translate="yes" xml:space="preserve">
          <source>Date:2017-12-04</source>
          <target state="translated">Date:2017-12-04</target>
        </trans-unit>
        <trans-unit id="87444639b77f489e7dc7f1684a2c815d05e6b641" translate="yes" xml:space="preserve">
          <source>Doesn't seem a traversing function &lt;em&gt;per se&lt;/em&gt; (at least in some cases), but it still uses &lt;code&gt;os.listdir&lt;/code&gt;</source>
          <target state="translated">트래버스 기능 &lt;em&gt;자체는 아니지만&lt;/em&gt; (적어도 경우에 따라) &lt;code&gt;os.listdir&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6d521195617328a431dabe6deacc4cc8e93939de" translate="yes" xml:space="preserve">
          <source>Don't take my word for it. There's plenty of support for this theory. Here's a couple:</source>
          <target state="translated">내 말을 받아들이지 마 이 이론에 대한 많은 지원이 있습니다. 몇 가지 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2df06b2d468838548ea913f49b8c7912e8ab2b96" translate="yes" xml:space="preserve">
          <source>Don't use &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; blocks</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; 블록을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="b9461aa6e4a1d297ac2448ad2f40004dd46970c5" translate="yes" xml:space="preserve">
          <source>Every possible solution has been listed in other answers.</source>
          <target state="translated">가능한 모든 솔루션이 다른 답변에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="57f676484ad86c6f592e0200b1bc9abf4d27bc4a" translate="yes" xml:space="preserve">
          <source>Filesystem traversal functions (and search the results for matching item(s))</source>
          <target state="translated">파일 시스템 탐색 기능 (및 일치하는 항목에 대한 결과 검색)</target>
        </trans-unit>
        <trans-unit id="2482b1dfd54ac893308e090998a270fa3acccec9" translate="yes" xml:space="preserve">
          <source>For earlier Pythons, you could roll your own &lt;code&gt;suppress&lt;/code&gt;, but without a &lt;code&gt;try&lt;/code&gt; will be more verbose than with. I do believe &lt;strong&gt;this actually is the only answer that doesn't use &lt;code&gt;try&lt;/code&gt; at any level in the Python&lt;/strong&gt; that can be applied to prior to Python 3.4 because it uses a context manager instead:</source>
          <target state="translated">이전 파이썬의 경우, 고유 한 &lt;code&gt;suppress&lt;/code&gt; 를 굴릴 수 있지만 &lt;code&gt;try&lt;/code&gt; 하지 않으면보다 더 장황합니다. 나는 &lt;strong&gt;이것이 실제로&lt;/strong&gt; 컨텍스트 관리자를 사용하기 때문에 파이썬 3.4 이전에 적용될 수있는 &lt;strong&gt;파이썬의 어떤 수준에서도 &lt;code&gt;try&lt;/code&gt; 를 사용하지 않는 유일한 대답&lt;/strong&gt; 이라고 생각 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="55f79bf0ba7b0375b8d3143950e1a90ab89796a4" translate="yes" xml:space="preserve">
          <source>For reference also see &lt;a href=&quot;/q/82831&quot;&gt;How to check whether a file exists using Python?&lt;/a&gt;</source>
          <target state="translated">참고로 &lt;a href=&quot;/q/82831&quot;&gt;파이썬을 사용하여 파일이 있는지 확인하는 방법&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bdeff00f3ab0a5de85d46268cc456e660f0891f" translate="yes" xml:space="preserve">
          <source>Here's a 1 line Python command for the Linux command line environment. I find this VERY HANDY since I'm not such a hot Bash guy.</source>
          <target state="translated">다음은 Linux 명령 행 환경을위한 1 행 Python 명령입니다. 나는 그렇게 뜨거운 배쉬 사람이 아니기 때문에이 HANDY를 발견합니다.</target>
        </trans-unit>
        <trans-unit id="4f2f59aeca936afd9d057519d9ef3eac5bef7ca4" translate="yes" xml:space="preserve">
          <source>Here's the help on &lt;code&gt;is_file&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;is_file&lt;/code&gt; 에 대한 도움말은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3e0db2911db163b18bf0441aa9f4ab60ce06986" translate="yes" xml:space="preserve">
          <source>How do I check whether a file exists without exceptions</source>
          <target state="translated">예외없이 파일이 있는지 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="f992ff3c06028274def0fdd00a52220dd457b417" translate="yes" xml:space="preserve">
          <source>How do I check whether a file exists, using Python, without using a try statement?</source>
          <target state="translated">try 문을 사용하지 않고 Python을 사용하여 파일이 존재하는지 어떻게 확인합니까?</target>
        </trans-unit>
        <trans-unit id="648dcb140e5c8625e8fd1d8412c1ff5f81de87f0" translate="yes" xml:space="preserve">
          <source>How do I see if a file exists or not, without using the &lt;a href=&quot;https://docs.python.org/3.6/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement?</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.6/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; 문을 사용하지 않고 파일이 있는지 여부를 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4da044c22cb2fb15a1b87e329d865c130b7299e8" translate="yes" xml:space="preserve">
          <source>I hope this is helpful.</source>
          <target state="translated">도움이 되길 바랍니다.</target>
        </trans-unit>
        <trans-unit id="ebe65250133ece313707187f5563d38f23a6029b" translate="yes" xml:space="preserve">
          <source>I made an exhaustive cheatsheet for your reference:</source>
          <target state="translated">나는 당신의 참고를 위해 철저한 치트 시트를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="c092b3bf26fda474ba2f972972deba214b2de89d" translate="yes" xml:space="preserve">
          <source>I should also mention that there are two ways that you will not be able to verify the existence of a file. Either the issue will be &lt;code&gt;permission denied&lt;/code&gt; or &lt;code&gt;no such file or directory&lt;/code&gt;. If you catch an &lt;code&gt;IOError&lt;/code&gt;, set the &lt;code&gt;IOError as e&lt;/code&gt; (like my first option), and then type in &lt;code&gt;print(e.args)&lt;/code&gt; so that you can hopefully determine your issue. I hope it helps! :)</source>
          <target state="translated">또한 파일의 존재를 확인할 수없는 두 가지 방법이 있습니다. 이 문제는 &lt;code&gt;permission denied&lt;/code&gt; 또는 해당 &lt;code&gt;no such file or directory&lt;/code&gt; . &lt;code&gt;IOError&lt;/code&gt; 가 발생 하면 &lt;code&gt;IOError as e&lt;/code&gt; ( 예 : 첫 번째 옵션) 로 설정 한 다음 &lt;code&gt;print(e.args)&lt;/code&gt; 를 입력하여 문제를 판단 할 수 있습니다. 도움이 되길 바랍니다! :)</target>
        </trans-unit>
        <trans-unit id="6bdb8ff9e404da03bb952ad7abebcc20b1ca5fbc" translate="yes" xml:space="preserve">
          <source>I will try to keep it up to date, any suggestions are welcome, I will incorporate anything useful that will come up into the answer</source>
          <target state="translated">나는 그것을 최신 상태로 유지하려고 노력할 것입니다, 어떤 제안이라도 환영합니다, 나는 대답에 올 수있는 유용한 것을 통합 할 것입니다</target>
        </trans-unit>
        <trans-unit id="71420b82d8fcd7fd47b4cff0728dfbb46cae47de" translate="yes" xml:space="preserve">
          <source>I'm the author of a package that's been around for about 10 years, and it has a function that addresses this question directly. Basically, if you are on a non-Windows system, it uses &lt;code&gt;Popen&lt;/code&gt; to access &lt;code&gt;find&lt;/code&gt;.  However, if you are on Windows, it replicates &lt;code&gt;find&lt;/code&gt; with an efficient filesystem walker.</source>
          <target state="translated">저는 약 10 년 동안 사용되어 온 패키지의 저자이며이 질문을 직접 해결하는 기능을 가지고 있습니다. 기본적으로 Windows 이외의 시스템에있는 경우 &lt;code&gt;Popen&lt;/code&gt; 을 사용하여 &lt;code&gt;find&lt;/code&gt; 에 액세스합니다. 그러나 Windows에있는 경우 효율적인 파일 시스템 워커를 사용하여 &lt;code&gt;find&lt;/code&gt; 를 복제합니다.</target>
        </trans-unit>
        <trans-unit id="8ca967716a632903489f4722e9137f4292d1cec8" translate="yes" xml:space="preserve">
          <source>I'm using &lt;em&gt;_waccess&lt;/em&gt; so that the same code works on &lt;em&gt;Python3&lt;/em&gt; and &lt;em&gt;Python2&lt;/em&gt; (in spite of &lt;em&gt;unicode&lt;/em&gt; related differences between them)</source>
          <target state="translated">동일한 코드가 &lt;em&gt;Python3&lt;/em&gt; 과 &lt;em&gt;Python2&lt;/em&gt; 에서 작동하도록 &lt;em&gt;_waccess를 사용&lt;/em&gt; 하고 &lt;em&gt;있습니다&lt;/em&gt; ( &lt;em&gt;유니 코드&lt;/em&gt; 와의 차이점이 있음에도 불구하고)</target>
        </trans-unit>
        <trans-unit id="a407e3adfd2214b7c586432d022e9ef118ddf7e0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is NULL, then the returned handle is for the main
  program.  When given to &lt;strong&gt;dlsym&lt;/strong&gt;(), this handle causes a search for a
  symbol in the main program, followed by all shared objects loaded at
  program startup, and then all shared objects loaded by &lt;strong&gt;dlopen&lt;/strong&gt;() with
  the flag &lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이 NULL이면 리턴 된 핸들은 기본 프로그램에 대한 것입니다. &lt;strong&gt;dlsym&lt;/strong&gt; ()이 주어지면이 핸들은 기본 프로그램에서 기호를 찾은 다음 프로그램 시작시로드 된 모든 공유 객체와 &lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt; 플래그로 &lt;strong&gt;dlopen&lt;/strong&gt; ()에 의해로드 된 모든 공유 객체를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="15fcbc3b264cbebf2eb4f1760bc8e1cba58236dd" translate="yes" xml:space="preserve">
          <source>If it's False, it will stop execution with an unhanded IOError
or OSError in later versions of Python. To catch the exception,
you have to use a try except clause. Of course, you can always
use a &lt;code&gt;try&lt;/code&gt; except` statement like so (thanks to &lt;a href=&quot;https://stackoverflow.com/users/3256073/hsandt&quot;&gt;hsandt&lt;/a&gt;
for making me think):</source>
          <target state="translated">False 인 경우 이후 버전의 Python에서 처리되지 않은 IOError 또는 OSError로 실행을 중지합니다. 예외를 잡으려면 try except 절을 사용해야합니다. 물론 항상 &lt;code&gt;try&lt;/code&gt; except` 문을 사용할 수 있습니다 (생각해 주셔서 감사합니다).</target>
        </trans-unit>
        <trans-unit id="c02184bc81acba7ff60734fa0276f4694047dce3" translate="yes" xml:space="preserve">
          <source>If the file is for opening you could use one of the following techniques:</source>
          <target state="translated">파일을 여는 경우 다음 기술 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f750d04a74a28d801ca980107d812cb534028797" translate="yes" xml:space="preserve">
          <source>If the reason you're checking is so you can do something like &lt;code&gt;if file_exists: open_it()&lt;/code&gt;, it's safer to use a &lt;code&gt;try&lt;/code&gt; around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.</source>
          <target state="translated">확인하는 이유 &lt;code&gt;if file_exists: open_it()&lt;/code&gt; 와 같은 방법으로 할 수 있다면 열려고 시도하는 것이 더 안전합니다. 확인 후 파일을 열면 파일을 삭제하거나 이동할 때 또는 파일을 확인할 때와 파일을 열 때 사이에 무언가 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5ff89b09fe8a6eb3f1fbb9c6d4f376565e0fe86" translate="yes" xml:space="preserve">
          <source>If you dig into &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/pathlib.py#L1318&quot;&gt;the implementation&lt;/a&gt;, though, you'll see that &lt;code&gt;is_file&lt;/code&gt; uses &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">그러나 &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/pathlib.py#L1318&quot;&gt;구현&lt;/a&gt; 을 파헤 &lt;code&gt;is_file&lt;/code&gt; 이 &lt;code&gt;try&lt;/code&gt; 를 사용한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0979e6df66fd1282fbd01cd0616f8c975b44e156" translate="yes" xml:space="preserve">
          <source>If you imported NumPy already for other purposes then there is no need to import other libraries like &lt;code&gt;pathlib&lt;/code&gt;, &lt;code&gt;os&lt;/code&gt;, &lt;code&gt;paths&lt;/code&gt;, etc.</source>
          <target state="translated">다른 목적으로 NumPy를 이미 가져온 경우 &lt;code&gt;pathlib&lt;/code&gt; , &lt;code&gt;os&lt;/code&gt; , &lt;code&gt;paths&lt;/code&gt; 등과 같은 다른 라이브러리를 가져올 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3505fa4d971cfab39c9f20bc4b27451fc35e3489" translate="yes" xml:space="preserve">
          <source>If you intend to do something with the file, I would suggest directly attempting it with a try-except to avoid a race condition:</source>
          <target state="translated">파일로 무언가를하려는 경우 경쟁 조건을 피하기 위해 시도를 제외하고 직접 시도해 보는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7dcf6a221c7d9f7451561a984e8aab1ebed8336f" translate="yes" xml:space="preserve">
          <source>If you need file locking, that's a different matter.</source>
          <target state="translated">파일 잠금이 필요한 경우 다른 문제입니다.</target>
        </trans-unit>
        <trans-unit id="08c9a05009658ae490c6ba1c13b8004939cdcd0a" translate="yes" xml:space="preserve">
          <source>If you need high-level operations, use &lt;code&gt;shutil&lt;/code&gt;.</source>
          <target state="translated">높은 수준의 작업이 필요한 경우 &lt;code&gt;shutil&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="56e17f5c3eb030308d334ae00733d23533b31d78" translate="yes" xml:space="preserve">
          <source>If you want to check that a file exists before you attempt to read it, and you might be deleting it and then you might be using multiple threads or processes, or another program knows about that file and could delete it - you risk the chance of a &lt;strong&gt;race condition&lt;/strong&gt; if you check it exists, because you are then &lt;em&gt;racing&lt;/em&gt; to open it before its &lt;em&gt;condition&lt;/em&gt; (its existence) changes.</source>
          <target state="translated">파일을 읽기 전에 파일이 존재하는지 확인하고 파일을 삭제 한 후 여러 스레드 또는 프로세스를 사용 중이거나 다른 프로그램이 해당 파일에 대해 알고이를 삭제할 수있는 경우 &lt;strong&gt;경쟁 조건&lt;/strong&gt; 이 존재하는지 확인하는 경우 &lt;strong&gt;경쟁 조건&lt;/strong&gt; 이 존재하기 전에 &lt;strong&gt;경쟁 조건&lt;/strong&gt; 을 열기 위해 &lt;em&gt;경쟁&lt;/em&gt; 하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b38cd90e47b8c32bc320b1b6ef26a7b9609fff52" translate="yes" xml:space="preserve">
          <source>If you want to read a file, if it exists, do</source>
          <target state="translated">파일을 읽으려면 파일이 있으면 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="43244157b51e40292add122e42936b5161218cbf" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, if it doesn't exist, do</source>
          <target state="translated">파일에 쓰려면 존재하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="f4f1b207aadf8f5d760de13167e89765ef728de9" translate="yes" xml:space="preserve">
          <source>If you're not planning to open the file immediately, you can use &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;&lt;code&gt;os.path.isfile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">파일을 즉시 열지 않으려는 경우 &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt; &lt;code&gt;os.path.isfile&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6070d8aef9d3e642476beafdb4d34a0fbf6fd11a" translate="yes" xml:space="preserve">
          <source>If you're on Python 2, you can backport the pathlib module from pypi, &lt;a href=&quot;https://pypi.python.org/pypi/pathlib2/&quot;&gt;&lt;code&gt;pathlib2&lt;/code&gt;&lt;/a&gt;, or otherwise check &lt;code&gt;isfile&lt;/code&gt; from the &lt;code&gt;os.path&lt;/code&gt; module:</source>
          <target state="translated">Python 2를 사용하는 경우 pypi, &lt;a href=&quot;https://pypi.python.org/pypi/pathlib2/&quot;&gt; &lt;code&gt;pathlib2&lt;/code&gt; &lt;/a&gt; 에서 pathlib 모듈을 백 포트하거나 &lt;code&gt;os.path&lt;/code&gt; 모듈에서 &lt;code&gt;isfile&lt;/code&gt; 을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="304faa8fa6b0b859ff9cf1ffd4acaeb92c2f66b7" translate="yes" xml:space="preserve">
          <source>Importing &lt;code&gt;os&lt;/code&gt; makes it easier to navigate and perform standard actions with your operating system.</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; 를 가져 오면 운영 체제에서 보다 쉽게 ​​탐색하고 표준 조치를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aeb39684e6a8d6e753f97adb8f35968468f0629" translate="yes" xml:space="preserve">
          <source>In 2016 the best way is still using &lt;code&gt;os.path.isfile&lt;/code&gt;:</source>
          <target state="translated">2016 년 가장 좋은 방법은 여전히 &lt;code&gt;os.path.isfile&lt;/code&gt; 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="63858bed5a51687e64275119d3dc78c8c0d5f146" translate="yes" xml:space="preserve">
          <source>In 2016, this is still arguably the easiest way to check if both a file exists and if it is a file:</source>
          <target state="translated">2016 년에도 파일이 존재하는지 파일인지 확인하는 가장 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="53b8bae049e83f783d679add94d8c62730294a02" translate="yes" xml:space="preserve">
          <source>Install some third-party module with filesystem capabilities</source>
          <target state="translated">파일 시스템 기능이있는 일부 타사 모듈 설치</target>
        </trans-unit>
        <trans-unit id="249f0dbd1b80d813ef272a820bd4e6ec0094f9c9" translate="yes" xml:space="preserve">
          <source>Instead hardcoding &lt;em&gt;libc&lt;/em&gt;'s path (&lt;em&gt;&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;&lt;/em&gt;) which may (and most likely, will) vary across systems, &lt;em&gt;None&lt;/em&gt; (or the empty string) can be passed to &lt;em&gt;CDLL&lt;/em&gt; constructor (&lt;strong&gt;&lt;code&gt;ctypes.CDLL(None).access(b&quot;/tmp&quot;, os.F_OK)&lt;/code&gt;&lt;/strong&gt;). According to &lt;a href=&quot;http://man7.org/linux/man-pages/man3/dlopen.3.html&quot;&gt;[man7]: DLOPEN(3)&lt;/a&gt;:</source>
          <target state="translated">대신 시스템에 따라 다를 수있는 &lt;em&gt;libc&lt;/em&gt; 의 경로 ( &lt;em&gt;&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;&lt;/em&gt; )를 하드 코딩하는 대신 &lt;em&gt;CDLL&lt;/em&gt; 생성자에 &lt;em&gt;None&lt;/em&gt; (또는 빈 문자열)을 전달할 수 있습니다. ( &lt;strong&gt; &lt;code&gt;ctypes.CDLL(None).access(b&quot;/tmp&quot;, os.F_OK)&lt;/code&gt; &lt;/strong&gt; ). &lt;a href=&quot;http://man7.org/linux/man-pages/man3/dlopen.3.html&quot;&gt;[man7]&lt;/a&gt; 에 따르면 : DLOPEN (3) :</target>
        </trans-unit>
        <trans-unit id="c2456e210fee146ed3f8241baa370ef4e417d398" translate="yes" xml:space="preserve">
          <source>It also creates a context manager which, by unconditionally returning &lt;code&gt;True&lt;/code&gt;, allows all Exceptions (including &lt;code&gt;KeyboardInterrupt&lt;/code&gt; and &lt;code&gt;SystemExit&lt;/code&gt;!) to pass silently, which is a good way to hide bugs.</source>
          <target state="translated">또한 무조건 &lt;code&gt;True&lt;/code&gt; 를 반환하여 모든 예외 ( &lt;code&gt;KeyboardInterrupt&lt;/code&gt; 및 &lt;code&gt;SystemExit&lt;/code&gt; ! 포함)가 자동으로 전달되도록하는 컨텍스트 관리자를 작성하여 버그를 숨기는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a8cd152693547cd306546c2c837671d8d018ed7f" translate="yes" xml:space="preserve">
          <source>It also suffers from the same race condition problems as &lt;code&gt;isfile&lt;/code&gt;. From the &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.access&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">또한 &lt;code&gt;isfile&lt;/code&gt; 과 동일한 경쟁 조건 문제가 있습니다 . &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.access&quot;&gt;문서에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4202a54228e33a8c91a54fe4ae0d3e882755b1c7" translate="yes" xml:space="preserve">
          <source>It doesn't seem like there's a meaningful functional difference between try/except and &lt;code&gt;isfile()&lt;/code&gt;, so you should use which one makes sense.</source>
          <target state="translated">try / except와 &lt;code&gt;isfile()&lt;/code&gt; 사이에 의미있는 기능적 차이가있는 것 같지 않으므로 어느 것이 적합한 지 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbc241143077ad988ba650982a25300f8fb789d3" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;os.listdir&lt;/code&gt; (&lt;code&gt;os.scandir&lt;/code&gt; when available)</source>
          <target state="translated">&lt;code&gt;os.listdir&lt;/code&gt; (사용 가능한 경우 &lt;code&gt;os.scandir&lt;/code&gt; ) 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="327665da0521fd7ce34669658e33594ae8ff6a15" translate="yes" xml:space="preserve">
          <source>It's a fancier (and more &lt;em&gt;python&lt;/em&gt;ic) way of handling paths, &lt;strong&gt;but&lt;/strong&gt;</source>
          <target state="translated">경로를 다루는 더 환상적인 (그리고 &lt;em&gt;파이썬&lt;/em&gt; ic) 방법 &lt;strong&gt;이지만&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0874e622984b8d8ed8d0111ced638b33c324993" translate="yes" xml:space="preserve">
          <source>Just to avoid confusion and based on the answers I got, current answer finds either a file &lt;strong&gt;or&lt;/strong&gt; a directory with the given name.</source>
          <target state="translated">혼란을 피하고 내가 얻은 답변을 기반으로 현재 답변은 파일 &lt;strong&gt;이나&lt;/strong&gt; 주어진 이름의 디렉토리를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="59f32559476324f232ad65e7d3e5c4edde71e7e4" translate="yes" xml:space="preserve">
          <source>Longer, much more pedantic answer</source>
          <target state="translated">더 길고 훨씬 더 답답한 답변</target>
        </trans-unit>
        <trans-unit id="342aaecc367b1d3941e496dfa36d36af27e2812d" translate="yes" xml:space="preserve">
          <source>Main (current) program (&lt;em&gt;python&lt;/em&gt;) is linked against &lt;em&gt;libc&lt;/em&gt;, so its symbols (including &lt;em&gt;access&lt;/em&gt;) will be loaded</source>
          <target state="translated">메인 (현재) 프로그램 ( &lt;em&gt;python&lt;/em&gt; )은 &lt;em&gt;libc에&lt;/em&gt; 연결되어 있으므로 심볼 ( &lt;em&gt;액세스&lt;/em&gt; 포함) 이로 드됩니다</target>
        </trans-unit>
        <trans-unit id="4d15ee1ab2448fa179b92a1924e831dd8f0f9a47" translate="yes" xml:space="preserve">
          <source>Most likely, will rely on one of the ways above (maybe with slight customizations).</source>
          <target state="translated">아마도 위의 방법 중 하나에 의존 할 것입니다 (약간의 사용자 정의가있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="782942b5ea6c6ad77e95b9f86f2fa9c57b44eb41" translate="yes" xml:space="preserve">
          <source>Note1: The &lt;code&gt;os.path.isfile&lt;/code&gt; used only for files</source>
          <target state="translated">참고 1 : &lt;code&gt;os.path.isfile&lt;/code&gt; 은 파일에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f4abfb7bebf2ffae4214d6fb5b83a497213ebf77" translate="yes" xml:space="preserve">
          <source>Note2: The &lt;code&gt;os.path.exists&lt;/code&gt; used for both files and directories</source>
          <target state="translated">참고 2 : &lt;code&gt;os.path.exists&lt;/code&gt; 는 파일과 디렉토리 모두에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c451b4b43107e20a1f539e1f362df3e8d96f9cf5" translate="yes" xml:space="preserve">
          <source>Note:
  Using access() to check if a user is authorized to e.g. open a file
  before actually doing so using open() creates a security hole, because
  the user might exploit the short time interval between checking and
  opening the file to manipulate it. It&amp;rsquo;s preferable to use EAFP
  techniques. For example:</source>
          <target state="translated">참고 : open ()을 사용하여 실제로 파일을 열 수있는 권한이 있는지 확인하기 위해 access ()를 사용하는 경우 사용자가 파일을 확인하고 열어서 파일을 조작하는 데 걸리는 짧은 시간 간격을 이용할 수 있으므로 보안 허점이 생깁니다. EAFP 기술을 사용하는 것이 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fed557bf7ca2300dfe5a352020d76469a9ceb724" translate="yes" xml:space="preserve">
          <source>Now available since Python 3.4, import and instantiate a &lt;code&gt;Path&lt;/code&gt; object with the file name, and check the &lt;code&gt;is_file&lt;/code&gt; method (note that this returns True for symlinks pointing to regular files as well):</source>
          <target state="translated">Python 3.4부터 사용할 수 있으므로 파일 이름으로 &lt;code&gt;Path&lt;/code&gt; 객체를 가져 와서 인스턴스화하고 &lt;code&gt;is_file&lt;/code&gt; 메소드를 확인하십시오 (정규 파일을 가리키는 심볼 링크의 경우 True를 반환합니다).</target>
        </trans-unit>
        <trans-unit id="0c2b0029788516df42324f1ddcb2a0d379462fca" translate="yes" xml:space="preserve">
          <source>Now the above is probably the best pragmatic direct answer here, but there's the possibility of a race condition (depending on what you're trying to accomplish), and the fact that the underlying implementation uses a &lt;code&gt;try&lt;/code&gt;, but Python uses &lt;code&gt;try&lt;/code&gt; everywhere in its implementation.</source>
          <target state="translated">위의 내용은 아마도 가장 실용적인 직접 답변이지만, 달성하려는 목표에 따라 경쟁 조건이 발생할 가능성이 있으며 기본 구현은 &lt;code&gt;try&lt;/code&gt; 를 사용하지만 Python은 이행.</target>
        </trans-unit>
        <trans-unit id="9f1fcb7cb0c155a214cdcbeab2ea4d318d7dd89d" translate="yes" xml:space="preserve">
          <source>One example would be (again, &lt;em&gt;Win&lt;/em&gt; specific) &lt;a href=&quot;https://github.com/mhammond/pywin32&quot;&gt;[GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions&lt;/a&gt;, which is a &lt;em&gt;Python&lt;/em&gt; wrapper over &lt;em&gt;WINAPI&lt;/em&gt;s.</source>
          <target state="translated">하나의 예는 (다시 &lt;em&gt;Win에&lt;/em&gt; 따라) &lt;a href=&quot;https://github.com/mhammond/pywin32&quot;&gt;[GitHub] : mhammond / pywin32-Windows 용 Python (pywin32) Extensions&lt;/a&gt; 는 &lt;em&gt;WINAPI&lt;/em&gt; 의 &lt;em&gt;Python&lt;/em&gt; 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="5abbf84d7258a883758c744ea8454f1c4d043654" translate="yes" xml:space="preserve">
          <source>Opening the file will always verify the existence of the file. You can make a function just like so:</source>
          <target state="translated">파일을 열면 항상 파일이 있는지 확인합니다. 다음과 같이 기능을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d75570821c532602afcda3cfc484e1ec0dd4b08" translate="yes" xml:space="preserve">
          <source>Or in Python 3 you can use &lt;code&gt;pathlib&lt;/code&gt;:</source>
          <target state="translated">또는 파이썬 3에서는 &lt;code&gt;pathlib&lt;/code&gt; 를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6162f97d9d25399c4c7f1572eade2b73d9183fc2" translate="yes" xml:space="preserve">
          <source>Other options that don't meet the ask for &quot;without try&quot;:</source>
          <target state="translated">&quot;시도없이&quot;를 요구하지 않는 다른 옵션 :</target>
        </trans-unit>
        <trans-unit id="1abe02b8870cad9e8f6a481158089cd2d79cac6d" translate="yes" xml:space="preserve">
          <source>Perhaps easier with a try:</source>
          <target state="translated">시도해 보면 더 쉬울 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9e7f16adc3452b0efdc8ccada6d3af30945b93c" translate="yes" xml:space="preserve">
          <source>Personally, I prefer this one because under the hood, it calls native APIs (via &quot;${PYTHON_SRC_DIR}/Modules/posixmodule.c&quot;), but it also opens a gate for possible user errors, and it's not as Pythonic as other variants:</source>
          <target state="translated">개인적으로 필자는 기본 API ( &quot;$ {PYTHON_SRC_DIR} /Modules/posixmodule.c&quot;를 통해)를 호출하지만 가능한 사용자 오류에 대한 문을 열며 다른 변형만큼 파이썬 적이 지 않기 때문에 이것을 선호합니다. :</target>
        </trans-unit>
        <trans-unit id="8e425b164973e8037f334709b9c9ce674d73968a" translate="yes" xml:space="preserve">
          <source>Prefer the try statement. It's considered better style and avoids race conditions.</source>
          <target state="translated">try 문을 선호하십시오. 더 나은 스타일로 간주되며 경쟁 조건을 피합니다.</target>
        </trans-unit>
        <trans-unit id="93744e02826bb08cbcaca9d0ccf769f1f6a80f48" translate="yes" xml:space="preserve">
          <source>Python 3.4 gives us the &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;&lt;code&gt;suppress&lt;/code&gt;&lt;/a&gt; context manager (previously the &lt;a href=&quot;https://bugs.python.org/issue19266&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt; context manager), which does semantically exactly the same thing in fewer lines, while also (at least superficially) meeting the original ask to avoid a &lt;code&gt;try&lt;/code&gt; statement:</source>
          <target state="translated">파이썬 3.4는 &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt; &lt;code&gt;suppress&lt;/code&gt; &lt;/a&gt; 컨텍스트 관리자 (이전의 컨텍스트 관리자 &lt;a href=&quot;https://bugs.python.org/issue19266&quot;&gt; &lt;code&gt;ignore&lt;/code&gt; &lt;/a&gt; )를 제공합니다.이 컨텍스트 관리자는 의미 상 정확히 몇 줄로 동일한 것을 수행하며 &lt;code&gt;try&lt;/code&gt; 문을 피하라는 원래의 요청을 (적어도 피상적으로) 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="88968d6bed87a24c3d5e8906af55bf32da38c015" translate="yes" xml:space="preserve">
          <source>Race Conditions: Why we like try</source>
          <target state="translated">경쟁 조건 : 우리가 시도하는 것을 좋아하는 이유</target>
        </trans-unit>
        <trans-unit id="522972b64fc54c50b69da77a6a1c4a50a9bb45a8" translate="yes" xml:space="preserve">
          <source>Race conditions are very hard to debug because there's a very small window in which they can cause your program to fail.</source>
          <target state="translated">경쟁 조건은 프로그램이 실패 할 수있는 매우 작은 창이 있으므로 디버깅하기가 매우 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="b2e1e799ac67777d3968b00f4cfe9b4b5a63a8e0" translate="yes" xml:space="preserve">
          <source>Raising exceptions is considered to be an acceptable, and Pythonic,
  approach for flow control in your program. Consider handling missing
  files with IOErrors. In this situation, an IOError exception will be
  raised if the file exists but the user does not have read permissions.</source>
          <target state="translated">예외를 발생시키는 것은 프로그램에서 흐름 제어를위한 허용 가능한 파이썬 방식으로 간주됩니다. IOError로 누락 된 파일 처리를 고려하십시오. 이 상황에서는 파일이 있지만 사용자에게 읽기 권한이 없으면 IOError 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="398f6fa810da4cd445bcd4f6196261363faad467" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;path&lt;/em&gt; refers to an existing path or an open file descriptor. Returns &lt;code&gt;False&lt;/code&gt; for broken symbolic links. On some platforms, this function may return &lt;code&gt;False&lt;/code&gt; if permission is not granted to execute &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;os.stat()&lt;/a&gt; on the requested file, even if the &lt;em&gt;path&lt;/em&gt; physically exists.</source>
          <target state="translated">&lt;em&gt;path&lt;/em&gt; 가 기존 경로 또는 열린 파일 설명자를 참조하면 &lt;code&gt;True&lt;/code&gt; 를 반환합니다. 깨진 심볼릭 링크에 대해 &lt;code&gt;False&lt;/code&gt; 를 반환합니다. 일부 플랫폼에서 물리적으로 &lt;em&gt;경로&lt;/em&gt; 가 존재하더라도 요청 된 파일에서 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;os.stat ()&lt;/a&gt; 를 실행할 권한이 부여되지 않은 경우이 함수는 &lt;code&gt;False&lt;/code&gt; 를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57fd7c3c54933cadd32199f06cbadaeaf8b6a887" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;True&lt;/code&gt; if path is an existing regular file. This follows symbolic links, so both &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.islink&quot;&gt;islink()&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;isfile()&lt;/a&gt; can be true for the same path.</source>
          <target state="translated">path가 기존 일반 파일 인 경우 &lt;code&gt;True&lt;/code&gt; 를 반환합니다. 이는 심볼릭 링크를 따르므로 동일한 경로에 대해 &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.islink&quot;&gt;islink ()&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;isfile ()&lt;/a&gt; 이 모두 참일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c416828ffe527204e9705ff84ac69c575514fa70" translate="yes" xml:space="preserve">
          <source>Return True if path is an existing regular file. This follows symbolic
  links, so both &lt;code&gt;islink()&lt;/code&gt; and &lt;code&gt;isfile()&lt;/code&gt; can be true for the same path.</source>
          <target state="translated">path가 기존 일반 파일 인 경우 True를 반환합니다. 이는 심볼릭 링크를 따르므로 동일한 경로에 대해 &lt;code&gt;islink()&lt;/code&gt; 및 &lt;code&gt;isfile()&lt;/code&gt; 이 모두 참일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="480f0d6eca70fda19ed1cfd881e8db7b38b30b6d" translate="yes" xml:space="preserve">
          <source>SRC: &lt;a href=&quot;http://www.pfinn.net/python-check-if-file-exists.html&quot;&gt;http://www.pfinn.net/python-check-if-file-exists.html&lt;/a&gt;</source>
          <target state="translated">SRC : &lt;a href=&quot;http://www.pfinn.net/python-check-if-file-exists.html&quot;&gt;http://www.pfinn.net/python-check-if-file-exists.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="418acfb7d49ae4b9747a1895a7c2c368f346ec6b" translate="yes" xml:space="preserve">
          <source>Since I also work in &lt;em&gt;C&lt;/em&gt;, I use this method as well because under the hood, it calls &lt;strong&gt;native &lt;em&gt;API&lt;/em&gt;s&lt;/strong&gt; (again, via &lt;em&gt;&quot;${PYTHON_SRC_DIR}/Modules/posixmodule.c&quot;&lt;/em&gt;), but it also opens a gate for possible &lt;strong&gt;user errors&lt;/strong&gt;, and it's not as &lt;em&gt;Python&lt;/em&gt;ic as other variants. So, as @AaronHall rightly pointed out, don't use it unless you know what you're doing:</source>
          <target state="translated">&lt;em&gt;C&lt;/em&gt; 에서도 작업하기 때문에이 방법도 사용합니다.이 방법은 &lt;strong&gt;기본 &lt;em&gt;API&lt;/em&gt;&lt;/strong&gt; ( &lt;em&gt;&quot;$ {PYTHON_SRC_DIR} /Modules/posixmodule.c&quot;&lt;/em&gt; 를 통해)를 호출하지만 가능한 &lt;strong&gt;사용자를&lt;/strong&gt; 위한 게이트를 &lt;em&gt;열기 때문에이&lt;/em&gt; 방법도 &lt;strong&gt;사용합니다 errors&lt;/strong&gt; 이며 다른 변형만큼 &lt;em&gt;Python&lt;/em&gt; ic이 아닙니다. 따라서 @AaronHall이 올바르게 지적했듯이 수행중인 작업을 모르는 경우 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4e081acedac5348eeca514bf8754f18b5a2a5859" translate="yes" xml:space="preserve">
          <source>Since these iterate over folders, (in most of the cases) they are inefficient for our problem (there are exceptions, like non wildcarded &lt;em&gt;glob&lt;/em&gt;bing - as @ShadowRanger pointed out), so I'm not going to insist on them. Not to mention that in some cases, filename processing might be required.</source>
          <target state="translated">이들은 폴더를 반복하므로 (대부분의 경우) 우리 문제에 비효율적입니다 (@ShadowRanger가 지적한 것처럼 와일드 카드가 아닌 글 로빙 빙과 같은 예외가 있습니다). 그래서 나는 그것을 고집하지 않을 것입니다. 경우에 따라 파일 이름 처리가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef8ad7d35edc8d5906794e416a2417426387ee33" translate="yes" xml:space="preserve">
          <source>So let's get a file that we know is a file:</source>
          <target state="translated">우리가 알고있는 파일을 가져 오십시오 :</target>
        </trans-unit>
        <trans-unit id="2a3bb40ae80994d030f01c5b7c25d767f5b05a5b" translate="yes" xml:space="preserve">
          <source>So raising exceptions is considered to be an acceptable, and Pythonic, approach for flow control in your program. And one should consider handling missing files with IOErrors, rather than &lt;code&gt;if&lt;/code&gt; statements (&lt;em&gt;just an advice&lt;/em&gt;).</source>
          <target state="translated">따라서 예외를 발생시키는 것은 프로그램에서 흐름 제어를 위해 허용 가능한 파이썬 방식으로 간주됩니다. 그리고 &lt;code&gt;if&lt;/code&gt; 문이 아닌 IOErrors로 누락 된 파일을 처리하는 것을 고려해야합니다 ( &lt;em&gt;단지 조언&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="fa536419723a345ff2ddb12f28c3d59d3c780110" translate="yes" xml:space="preserve">
          <source>So we need to use &lt;code&gt;is_file&lt;/code&gt;:</source>
          <target state="translated">따라서 &lt;code&gt;is_file&lt;/code&gt; 을 사용해야합니다 :</target>
        </trans-unit>
        <trans-unit id="a378bd712dd5bfae1cae597f5f9f871b3a2788bb" translate="yes" xml:space="preserve">
          <source>Starting with Python 3.4, the &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;&lt;code&gt;pathlib&lt;/code&gt; module&lt;/a&gt; offers an object-oriented approach (backported to &lt;code&gt;pathlib2&lt;/code&gt; in Python 2.7):</source>
          <target state="translated">Python 3.4부터 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt; &lt;code&gt;pathlib&lt;/code&gt; 모듈&lt;/a&gt; 은 객체 지향 접근 방식을 제공합니다 (Python 2.7의 &lt;code&gt;pathlib2&lt;/code&gt; 로 백 포트 됨).</target>
        </trans-unit>
        <trans-unit id="0411618e6c534569cfc6b8e34a18a081fb5d17d8" translate="yes" xml:space="preserve">
          <source>Style: Section &quot;Handling unusual conditions&quot; of &lt;a href=&quot;http://allendowney.com/sd/notes/notes11.txt&quot;&gt;http://allendowney.com/sd/notes/notes11.txt&lt;/a&gt;</source>
          <target state="translated">스타일 : &lt;a href=&quot;http://allendowney.com/sd/notes/notes11.txt&quot;&gt;http://allendowney.com/sd/notes/notes11.txt의&lt;/a&gt; &quot;특별한 조건 처리&quot;섹션</target>
        </trans-unit>
        <trans-unit id="cde65e3e48762cf615039585856511edabc67b5c" translate="yes" xml:space="preserve">
          <source>Testing for files and folders with &lt;code&gt;os.path.isfile()&lt;/code&gt;, &lt;code&gt;os.path.isdir()&lt;/code&gt; and &lt;code&gt;os.path.exists()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;os.path.isfile()&lt;/code&gt; , &lt;code&gt;os.path.isdir()&lt;/code&gt; 및 &lt;code&gt;os.path.exists()&lt;/code&gt; 하여 파일 및 폴더 테스트</target>
        </trans-unit>
        <trans-unit id="df18cbc4306e1fa89ca1399437058ce4f49db703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pathlib.Path&lt;/code&gt; method (included in Python 3+, installable with pip for Python 2)</source>
          <target state="translated">&lt;code&gt;pathlib.Path&lt;/code&gt; 메소드 (Python 3 이상에 포함, Python 2 용 pip로 설치 가능)</target>
        </trans-unit>
        <trans-unit id="530b364f38885f326cd1f531e7470053b4411886" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Lnx&lt;/em&gt; (&lt;em&gt;Ubtu (16 x64)&lt;/em&gt;) counterpart as well:</source>
          <target state="translated">&lt;em&gt;Lnx&lt;/em&gt; ( &lt;em&gt;Ubtu (16 x64)&lt;/em&gt; ) 대응 :</target>
        </trans-unit>
        <trans-unit id="13a09abaae156d8f74be92cfd84bbc68f9b952e1" translate="yes" xml:space="preserve">
          <source>The code itself does not use a &lt;code&gt;try&lt;/code&gt; block&amp;hellip; except in determining the operating system and thus steering you to the &quot;Unix&quot;-style &lt;code&gt;find&lt;/code&gt; or the hand-buillt &lt;code&gt;find&lt;/code&gt;. Timing tests showed that the &lt;code&gt;try&lt;/code&gt; was faster in determining the OS, so I did use one there (but nowhere else).</source>
          <target state="translated">코드 자체는 &lt;code&gt;try&lt;/code&gt; 블록을 사용하지 않습니다. 운영 체제를 결정하고 &quot;Unix&quot;스타일 &lt;code&gt;find&lt;/code&gt; 또는 수동 내장 &lt;code&gt;find&lt;/code&gt; 로 안내하는 경우를 제외하고 는 . 타이밍 테스트에 따르면 OS를 결정하는 데 더 빠른 &lt;code&gt;try&lt;/code&gt; 가 있었으므로 거기에서 사용했습니다 (그러나 다른 곳에서는 사용하지 않았습니다).</target>
        </trans-unit>
        <trans-unit id="24d50f1641bf928a4330f0d682a38d4d97ffe256" translate="yes" xml:space="preserve">
          <source>The implementation, if you care to look, is here:
&lt;a href=&quot;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190&quot;&gt;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190&lt;/a&gt;</source>
          <target state="translated">구현이 필요하다면 &lt;a href=&quot;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190&quot;&gt;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a74a8a63b22547ba3d5093ec5df9fef2c1e24790" translate="yes" xml:space="preserve">
          <source>The ouput would be:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1865aad596e6ed9eb4f9647b68658f733fae4544" translate="yes" xml:space="preserve">
          <source>The pathlib module has lots of cool stuff in it: convenient globbing, checking file's owner, easier path joining, etc.  It's worth checking out.  If you're on an older Python (version 2.6 or later), you can still install pathlib with pip:</source>
          <target state="translated">pathlib 모듈에는 편리한 글 로빙, 파일 소유자 확인, 쉬운 경로 조인 등 멋진 항목이 많이 있습니다. 체크 아웃 할 가치가 있습니다. 이전 Python (버전 2.6 이상)을 사용하는 경우 pip를 사용하여 pathlib를 계속 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86939b2f23d78f6587e8899c5fbcad699b1fca6d" translate="yes" xml:space="preserve">
          <source>Then import it as follows:</source>
          <target state="translated">그런 다음 다음과 같이 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="10cf03aad058b6e2b5effd7477540fa9d0ac3551" translate="yes" xml:space="preserve">
          <source>Then, depending on the result, your program can just keep running from there or you can code to stop it if you want.</source>
          <target state="translated">그런 다음 결과에 따라 프로그램이 계속 실행되거나 원하는 경우 중지하도록 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10303b9773cea55a7373894dca044a1fb0b21612" translate="yes" xml:space="preserve">
          <source>This allows common &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#try&quot;&gt;try&lt;/a&gt;...&lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#except&quot;&gt;except&lt;/a&gt;...&lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#finally&quot;&gt;finally&lt;/a&gt; usage patterns to be encapsulated for convenient reuse.</source>
          <target state="translated">이를 통해 일반적인 &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#try&quot;&gt;시도&lt;/a&gt; ... ... ... 사용 패턴을 캡슐화하여 편리하게 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="013b8396ae1ec7be20358e949069add1eed3da4a" translate="yes" xml:space="preserve">
          <source>This answer says it prefers a non-Pythonic, error-prone method, with no justification. It seems to encourage users to use low-level APIs without understanding them.</source>
          <target state="translated">이 답변은 정당화없이 비 피톤의 오류가 발생하기 쉬운 방법을 선호한다고 말합니다. 사용자가 이해하지 않고 저수준 API를 사용하도록 권장하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="e34e91f34043e5905acc95f65395d3f7ae45d71b" translate="yes" xml:space="preserve">
          <source>This doesn't also apply to &lt;em&gt;Win&lt;/em&gt; (but that's not such a big deal, since &lt;em&gt;msvcrt.dll&lt;/em&gt; is located in &lt;em&gt;&quot;%SystemRoot%\System32&quot;&lt;/em&gt; which is in &lt;em&gt;%PATH%&lt;/em&gt; by default). I wanted to take things further and replicate this behavior on &lt;em&gt;Win&lt;/em&gt; (and submit a patch), but as it turns out, &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress&quot;&gt;[MS.Docs]: GetProcAddress function&lt;/a&gt; only &quot;sees&quot; &lt;strong&gt;exported&lt;/strong&gt; symbols, so unless someone declares the functions in the main executable as &lt;code&gt;__declspec(dllexport)&lt;/code&gt; (why on Earth the &lt;em&gt;regular&lt;/em&gt; person would do that?), the main program is loadable but pretty much unusable</source>
          <target state="translated">이것은 &lt;em&gt;Win&lt;/em&gt; 에도 적용되지 않습니다 (그러나 &lt;em&gt;msvcrt.dll&lt;/em&gt; 은 기본적으로 &lt;em&gt;% PATH %&lt;/em&gt; 에있는 &lt;em&gt;&quot;% SystemRoot % \ System32&quot;&lt;/em&gt; 에 있기 때문에 그렇게 큰 문제는 아닙니다). 더 나아가서 &lt;em&gt;Win&lt;/em&gt; 에서이 동작을 복제하고 패치를 제출하고 &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress&quot;&gt;싶었지만&lt;/a&gt; , [MS.Docs] : GetProcAddress 함수 는 &lt;strong&gt;내 보낸&lt;/strong&gt; 심볼 만 &quot;보여&quot;, 누군가 주 실행 파일에서 함수를 선언하지 않는 한 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; (지구에서 &lt;em&gt;일반&lt;/em&gt; 사람이 그렇게하는 이유는 무엇입니까?)과 같이 주 프로그램은로드 할 수 있지만 거의 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="7d512ce20a34ce68ebd3c6ebeb6e56887b5b877e" translate="yes" xml:space="preserve">
          <source>This has to be handled with care, since functions like &lt;em&gt;main&lt;/em&gt;, &lt;em&gt;Py_Main&lt;/em&gt; and (all the) others are available; calling them could have disastrous effects (on the current program)</source>
          <target state="translated">&lt;em&gt;main&lt;/em&gt; , &lt;em&gt;Py_Main&lt;/em&gt; 및 기타 기능과 같은 기능을 사용할 수 있으므로주의해서 다루어야합니다. 그것들을 호출하면 비참한 영향을 줄 수 있습니다 (현재 프로그램에서)</target>
        </trans-unit>
        <trans-unit id="ada1dec3ed33a08f60c128b70954cbdb8457037b" translate="yes" xml:space="preserve">
          <source>This is the simplest way to check if a file exists. Just &lt;strong&gt;because&lt;/strong&gt; the file existed when you checked doesn't &lt;strong&gt;guarantee&lt;/strong&gt; that it will be there when you need to open it.</source>
          <target state="translated">파일이 존재하는지 확인하는 가장 간단한 방법입니다. 확인했을 때 파일이 존재했다고해서 파일을 열어야 할 때 파일이 있다고 &lt;strong&gt;보장&lt;/strong&gt; 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="faf24dd71990fb8b6a4f9fda6ae044c126abf438" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;True&lt;/code&gt; for both files and directories but you can instead use</source>
          <target state="translated">파일과 디렉토리 모두에 대해 &lt;code&gt;True&lt;/code&gt; 를 반환하지만 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd377f1e075e1a6762708def8e94ab1cc954e78d" translate="yes" xml:space="preserve">
          <source>This seems to encourage users to adopt poor practices.</source>
          <target state="translated">이것은 사용자가 좋지 않은 관행을 채택하도록 장려하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ebd1badf365b531b3f784e4041ddcafc927cdcf" translate="yes" xml:space="preserve">
          <source>This will check the existence of what you specify. However, it checks for files &lt;em&gt;and&lt;/em&gt; directories so beware about how you use it.</source>
          <target state="translated">지정한 내용이 있는지 확인합니다. 그러나 파일 &lt;em&gt;과&lt;/em&gt; 디렉토리를 확인하므로 사용 방법에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="599782e6dcde6e17a96f8d011122afca2b083bc5" translate="yes" xml:space="preserve">
          <source>This will check whether you have access to the file. It will check for permissions. Based on the os.py documentation, typing in &lt;code&gt;os.F_OK&lt;/code&gt;, it will check the existence of the path. However, using this will create a security hole, as someone can attack your file using the time between checking the permissions and opening the file. You should instead go directly to opening the file instead of checking its permissions. (&lt;a href=&quot;https://docs.python.org/2/glossary.html#term-eafp&quot;&gt;EAFP&lt;/a&gt; vs &lt;a href=&quot;https://docs.python.org/2/glossary.html#term-lbyl&quot;&gt;LBYP&lt;/a&gt;). If you're not going to open the file afterwards, and only checking its existence, then you can use this.</source>
          <target state="translated">파일에 액세스 할 수 있는지 확인합니다. 권한을 확인합니다. os.py 문서를 기반으로 os.F_OK를 입력하면 경로가 있는지 확인합니다. 그러나이 권한을 사용하면 권한 확인과 파일 열기 사이의 시간을 사용하여 파일을 공격 할 수 있으므로 보안 허점이 생깁니다. 대신 사용 권한을 확인하는 대신 파일을 직접 열어야합니다. ( &lt;a href=&quot;https://docs.python.org/2/glossary.html#term-eafp&quot;&gt;EAFP&lt;/a&gt; 대 &lt;a href=&quot;https://docs.python.org/2/glossary.html#term-lbyl&quot;&gt;LBYP&lt;/a&gt; ). 나중에 파일을 열지 않고 존재 여부 만 확인하는 경우이 파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b5ffcaf081dc75e6b418d427d70f91a6d9dec08" translate="yes" xml:space="preserve">
          <source>This will handle the case of the &lt;code&gt;file_path&lt;/code&gt; being &lt;code&gt;None&lt;/code&gt; or empty string.</source>
          <target state="translated">이것은 &lt;code&gt;file_path&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 이거나 빈 문자열 인 경우를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8dba64974b8642857ae28899a73df6c30d03c303" translate="yes" xml:space="preserve">
          <source>This will return true or false based on its existence.</source>
          <target state="translated">존재 여부에 따라 true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc31e69259d13bfced912cfbab7ad7e00fd46dea" translate="yes" xml:space="preserve">
          <source>To check a directory, do:</source>
          <target state="translated">디렉토리를 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3416f5cb91745acbdaae2a2dddc268e01225ffdb" translate="yes" xml:space="preserve">
          <source>To check whether a &lt;code&gt;Path&lt;/code&gt; object exists independently of whether is it a file or directory, use &lt;code&gt;exists()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 객체가 파일인지 디렉토리인지에 관계없이 존재하는지 확인하려면 &lt;code&gt;exists()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e5ffee0a503a306dd9fb72ef88ce41742e995a7" translate="yes" xml:space="preserve">
          <source>Try opening the file:</source>
          <target state="translated">파일을 열어보십시오 :</target>
        </trans-unit>
        <trans-unit id="1a4e2dce5d6775f3efc5d392dd7dcfbb9813ec34" translate="yes" xml:space="preserve">
          <source>Under the hood, both use:</source>
          <target state="translated">후드 아래에서 다음을 모두 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c78de1502fda99e6b39752620575aa8b8af55212" translate="yes" xml:space="preserve">
          <source>Under the hood, it does &lt;strong&gt;exactly&lt;/strong&gt; the same thing (&lt;em&gt;pathlib.py&lt;/em&gt;, line &lt;em&gt;~#1330&lt;/em&gt;):</source>
          <target state="translated">후드에서 &lt;strong&gt;정확히&lt;/strong&gt; 똑같은 일을합니다 ( &lt;em&gt;pathlib.py&lt;/em&gt; , line &lt;em&gt;~ # 1330&lt;/em&gt; ) :</target>
        </trans-unit>
        <trans-unit id="0c4dd154e57d3342872a767d4176641c8fc8402b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;&lt;code&gt;isfile()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;True&lt;/code&gt; for directories. So depending on if you want only plain files or also directories, you'll use &lt;code&gt;isfile()&lt;/code&gt; or &lt;code&gt;exists()&lt;/code&gt;. Here is some simple REPL output:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt; &lt;code&gt;isfile()&lt;/code&gt; &lt;/a&gt; 과는 달리 exist () 는 디렉토리에 대해 &lt;code&gt;True&lt;/code&gt; 를 반환합니다. 따라서 일반 파일 또는 디렉토리 만 원하는지 여부에 따라 &lt;code&gt;isfile()&lt;/code&gt; 또는 exist ()를 사용 &lt;code&gt;exists()&lt;/code&gt; . 다음은 간단한 REPL 출력입니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="6528187d8e91a930203288ed63867c1ae3e26091" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.isfile&quot;&gt;&lt;code&gt;os.path.isfile()&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://docs.python.org/3.3/library/os.html?highlight=os.access#os.access&quot;&gt;&lt;code&gt;os.access()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.3/library/os.html?highlight=os.access#os.access&quot;&gt; &lt;code&gt;os.access()&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;a href=&quot;https://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.isfile&quot;&gt; &lt;code&gt;os.path.isfile()&lt;/code&gt; &lt;/a&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8395433c21c6033081f4203a964dbda841229f43" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;[Python 3]: contextlib.&lt;strong&gt;suppress&lt;/strong&gt;(&lt;em&gt;*exceptions&lt;/em&gt;)&lt;/a&gt; - which was &lt;strong&gt;specifically&lt;/strong&gt; designed for selectively suppressing exceptions</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;[Python 3] : contextlib를&lt;/a&gt; 사용하십시오 . &lt;strong&gt;suppress&lt;/strong&gt; ( &lt;em&gt;* exceptions&lt;/em&gt; ) - &lt;em&gt;예외&lt;/em&gt; 를 선택적으로 억제하기 위해 &lt;strong&gt;특별히&lt;/strong&gt; 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="63dca5b17c3d20c3489afb0a2fce135a332440f1" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;os.access(path, mode)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;os.access(path, mode)&lt;/code&gt; 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="ccb25d19aa4f439e92c039f06e2c08c0d55c6044" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;os.path.exists(path)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;os.path.exists(path)&lt;/code&gt; 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="a09130d4064cb71241e9c92eb3d5f5998cbbe1e5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;scandir()&lt;/a&gt; instead of &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;listdir()&lt;/a&gt; can significantly increase the performance of code that also needs file type or file attribute information, because &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; objects expose this information if the operating system provides it when scanning a directory. All &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; methods may perform a system call, but &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_dir&quot;&gt;is_dir()&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_file&quot;&gt;is_file()&lt;/a&gt; usually only require a system call for symbolic links; &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.stat&quot;&gt;os.DirEntry.stat()&lt;/a&gt; always requires a system call on Unix but only requires one for symbolic links on Windows.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; 객체는 디렉토리를 스캔 할 때 운영 체제에서 정보를 제공하는 경우 os.DirEntry 객체가이 정보를 노출하므로 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;listdir&lt;/a&gt; &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;()&lt;/a&gt; 대신 scandir ()을 사용하면 파일 유형 또는 파일 속성 정보가 필요한 코드의 성능이 크게 향상 될 수 있습니다. 모든 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; 메소드는 시스템 호출을 수행 할 수 있지만 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_dir&quot;&gt;is_dir ()&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_file&quot;&gt;is_file ()은&lt;/a&gt; 일반적으로 기호 링크에 대한 시스템 호출 만 필요합니다. &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.stat&quot;&gt;os.DirEntry.stat ()는&lt;/a&gt; 항상 Unix에서 시스템 호출이 필요하지만 Windows에서는 기호 링크에 대한 호출 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3c602deb97ce7542bfccf83d47fe88cf36a2893d" translate="yes" xml:space="preserve">
          <source>We like &lt;code&gt;try&lt;/code&gt; because it avoids race conditions. With &lt;code&gt;try&lt;/code&gt;, you simply attempt to read your file, expecting it to be there, and if not, you catch the exception and perform whatever fallback behavior makes sense.</source>
          <target state="translated">경쟁 조건을 피하기 때문에 &lt;code&gt;try&lt;/code&gt; 좋아합니다. &lt;code&gt;try&lt;/code&gt; 를 사용하면 파일을 읽으려고 시도하고 파일이있을 것으로 예상하고 그렇지 않은 경우 예외를 포착하고 대체 동작이 의미가있는 모든 것을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="11dee24909df97ffd7167218bba605d1194d35d4" translate="yes" xml:space="preserve">
          <source>You can (and usually should) still use a &lt;code&gt;try/except&lt;/code&gt; block when opening files:</source>
          <target state="translated">파일을 열 때 &lt;code&gt;try/except&lt;/code&gt; 블록을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7784bbbe5a5c336f12d286e297f0803a9fe8d487" translate="yes" xml:space="preserve">
          <source>You can also test if a file is a certain type of file using &lt;code&gt;os.path.splitext()&lt;/code&gt; to get the extension (if you don't already know it)</source>
          <target state="translated">확장명을 얻기 위해 &lt;code&gt;os.path.splitext()&lt;/code&gt; 를 사용하여 파일이 특정 유형의 파일인지 테스트 할 수도 있습니다 ( 아직 모르는 경우)</target>
        </trans-unit>
        <trans-unit id="53df035e05c38ef007ca2b8b29347ccc17e7055d" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;resolve(strict=True)&lt;/code&gt; in a &lt;code&gt;try&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 블록에서 &lt;code&gt;resolve(strict=True)&lt;/code&gt; 를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f01e601cacd481f5c7f35810b916f8e0b34e1dd" translate="yes" xml:space="preserve">
          <source>You can follow these three ways:</source>
          <target state="translated">다음 세 가지 방법을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec8dda8508e059554be2c9405118015a0d4115f7" translate="yes" xml:space="preserve">
          <source>You can use the &quot;OS&quot; library of Python:</source>
          <target state="translated">파이썬의 &quot;OS&quot;라이브러리를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="939818830bc616c3a6efeac98f780e2a1d405b44" translate="yes" xml:space="preserve">
          <source>You can write Brian's suggestion without the &lt;code&gt;try:&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;try:&lt;/code&gt; 하지 않고 Brian의 제안을 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="286ccde47046b9cee19cb126d447184993fbb983" translate="yes" xml:space="preserve">
          <source>You could try this (safer):</source>
          <target state="translated">이것을 시도 할 수 있습니다 (safer) :</target>
        </trans-unit>
        <trans-unit id="98a04bbfd86344a14e1ecd9d2cb153c157a6b79b" translate="yes" xml:space="preserve">
          <source>You have the &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.exists&quot;&gt;&lt;code&gt;os.path.exists&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.exists&quot;&gt; &lt;code&gt;os.path.exists&lt;/code&gt; &lt;/a&gt; 함수가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ea7a34811c2492dcaa209ef15806e5b61c87b16f" translate="yes" xml:space="preserve">
          <source>[Python 3]: os.&lt;strong&gt;walk&lt;/strong&gt;(&lt;em&gt;top, topdown=True, onerror=None, followlinks=False&lt;/em&gt;)</source>
          <target state="translated">[파이썬 3] : os. &lt;strong&gt;도보&lt;/strong&gt; ( &lt;em&gt;top, topdown = True, onerror = None, followlinks = False&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="9ffb459d6d30faf56bdf32fa749719a501413758" translate="yes" xml:space="preserve">
          <source>from the &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;문서에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="be73dd7f4e02100df1866e6ae1905b8fb136de60" translate="yes" xml:space="preserve">
          <source>if you need to be sure it's a file.</source>
          <target state="translated">파일인지 확인해야하는 경우</target>
        </trans-unit>
        <trans-unit id="6adfed45fd2ed1ca17a5706197051fb6c6c02690" translate="yes" xml:space="preserve">
          <source>is better written as:</source>
          <target state="translated">다음과 같이 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="625ab49ea896effef76c5e7d9931ab9b626630f8" translate="yes" xml:space="preserve">
          <source>it's just a &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; block around &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;[Python 3]: os.&lt;strong&gt;stat&lt;/strong&gt;(&lt;em&gt;path, *, dir_fd=None, follow_symlinks=True&lt;/em&gt;)&lt;/a&gt;. So, your code is &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; free, but lower in the framestack there's (at least) &lt;strong&gt;one&lt;/strong&gt; such block. This also applies to other funcs (&lt;strong&gt;including&lt;/strong&gt;&lt;code&gt;os.path.isfile&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;[Python 3] : os&lt;/a&gt; 주변의 &lt;strong&gt;&lt;em&gt;시도&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;제외&lt;/em&gt;&lt;/strong&gt; 블록 입니다. &lt;strong&gt;stat&lt;/strong&gt; ( &lt;em&gt;path, *, dir_fd = None, follow_symlinks = True&lt;/em&gt; ) . 따라서 코드는 무료 / &lt;strong&gt;&lt;em&gt;시도를&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;제외하고&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;시도&lt;/em&gt;&lt;/strong&gt; 하지만 프레임 스택에는 (적어도) 그러한 블록이 &lt;strong&gt;하나&lt;/strong&gt; 이상 있습니다. 이것은 다른 기능 ( &lt;code&gt;os.path.isfile&lt;/code&gt; &lt;strong&gt;포함&lt;/strong&gt; )에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2425e7713a0225c18ca0b17f07467bbaaa179274" translate="yes" xml:space="preserve">
          <source>to test if it's a file specifically. It follows symlinks.</source>
          <target state="translated">구체적으로 파일인지 테스트합니다. 심볼릭 링크를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="6abf28170f947a4e00093db1c0c8dcdabc461e0d" translate="yes" xml:space="preserve">
          <source>via &lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/posixmodule.c&quot;&gt;[GitHub]: python/cpython - (master) cpython/Modules/posixmodule.c&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/posixmodule.c&quot;&gt;[GitHub]&lt;/a&gt; 를 통해 : python / cpython-(마스터) cpython / Modules / posixmodule.c</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
