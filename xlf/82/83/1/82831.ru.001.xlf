<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/82831">
    <body>
      <group id="82831">
        <trans-unit id="c57a62c684c9ba50ef4276461ac8271cc4409e22" translate="yes" xml:space="preserve">
          <source>(&lt;strong&gt;&lt;em&gt;Win&lt;/em&gt;&lt;/strong&gt; specific): Since &lt;em&gt;vcruntime*&lt;/em&gt; (&lt;em&gt;msvcr*&lt;/em&gt;) &lt;em&gt;.dll&lt;/em&gt; exports a &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=vs-2015&quot;&gt;[MS.Docs]: _access, _waccess&lt;/a&gt; function family as well, here's an example:</source>
          <target state="translated">( &lt;em&gt;Зависит от&lt;/em&gt; &lt;strong&gt;&lt;em&gt;Win&lt;/em&gt;&lt;/strong&gt; ): поскольку &lt;em&gt;vcruntime *&lt;/em&gt; ( &lt;em&gt;msvcr *&lt;/em&gt; ) &lt;em&gt;.dll также&lt;/em&gt; экспортирует семейство функций &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=vs-2015&quot;&gt;[MS.Docs]: _access, _waccess&lt;/a&gt; , вот пример:</target>
        </trans-unit>
        <trans-unit id="40424e2404c07b5e06b147f732d917ab30140356" translate="yes" xml:space="preserve">
          <source>([Errno 2] No such file or directory:
  'whatever.txt')</source>
          <target state="translated">([Errno 2]No such file or directory:'whatever.txt')</target>
        </trans-unit>
        <trans-unit id="47357201492ecc28a3c7f77186ebaf58446769e4" translate="yes" xml:space="preserve">
          <source>...test if the invoking user has the specified access to &lt;em&gt;path&lt;/em&gt;. &lt;em&gt;mode&lt;/em&gt; should be &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.F_OK&quot;&gt;F_OK&lt;/a&gt; to test the existence of path...</source>
          <target state="translated">... проверить, имеет ли вызывающий пользователь указанный доступ к &lt;em&gt;пути&lt;/em&gt; . &lt;em&gt;режим&lt;/em&gt; должен быть &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.F_OK&quot;&gt;F_OK,&lt;/a&gt; чтобы проверить существование пути ...</target>
        </trans-unit>
        <trans-unit id="787fad3e2ffee45a57341c551ccca124f8b07869" translate="yes" xml:space="preserve">
          <source>1.1. &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;[Python 3]: Path.&lt;strong&gt;is_file&lt;/strong&gt;()&lt;/a&gt;</source>
          <target state="translated">1.1. &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;[Python 3]: путь.&lt;/a&gt; &lt;strong&gt;is_file&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="84da2f4e22fc9c7b904c3bcfae38c0e0ce23d934" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.iglob&quot;&gt;[Python 3]: glob.&lt;strong&gt;iglob&lt;/strong&gt;(&lt;em&gt;pathname, *, recursive=False&lt;/em&gt;)&lt;/a&gt; (or its predecessor: &lt;code&gt;glob.glob&lt;/code&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.iglob&quot;&gt;[Python 3]: глобус&lt;/a&gt; &lt;strong&gt;iglob&lt;/strong&gt; ( &lt;em&gt;pathname, *, recursive = False&lt;/em&gt; ) (или его предшественник: &lt;code&gt;glob.glob&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a32d328d73882905860fd2807cd7c44ceaaa3322" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;[Python 3]: os.&lt;strong&gt;access&lt;/strong&gt;(&lt;em&gt;path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True&lt;/em&gt;)&lt;/a&gt; whose behavior is close to &lt;code&gt;os.path.exists&lt;/code&gt; (actually it's wider, mainly because of the 2&lt;sup&gt;nd&lt;/sup&gt; argument)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;[Python 3]: ос.&lt;/a&gt; &lt;strong&gt;access&lt;/strong&gt; ( &lt;em&gt;path, mode, *, dir_fd = None ,ffective_ids = False, follow_symlinks = True&lt;/em&gt; ) , поведение которого близко к &lt;code&gt;os.path.exists&lt;/code&gt; (на самом деле оно шире, в основном из-за второго аргумента)</target>
        </trans-unit>
        <trans-unit id="4156cef8783a6c3af93cebc9154ef17488855064" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;[Python 3]: os.&lt;strong&gt;listdir&lt;/strong&gt;(&lt;em&gt;path='.'&lt;/em&gt;)&lt;/a&gt; (or &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;[Python 3]: os.&lt;strong&gt;scandir&lt;/strong&gt;(&lt;em&gt;path='.'&lt;/em&gt;)&lt;/a&gt; on &lt;em&gt;Python v&lt;strong&gt;3.5&lt;/strong&gt;&lt;/em&gt;+, backport: &lt;a href=&quot;https://pypi.org/project/scandir&quot;&gt;[PyPI]: scandir&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;[Python 3]: ос.&lt;/a&gt; &lt;strong&gt;listdir&lt;/strong&gt; ( &lt;em&gt;путь = '.'&lt;/em&gt; ) (или &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;[Python 3]: os. &lt;strong&gt;scandir&lt;/strong&gt; ( &lt;em&gt;путь = '.'&lt;/em&gt; )&lt;/a&gt; в &lt;em&gt;Python v&lt;/em&gt; &lt;a href=&quot;https://pypi.org/project/scandir&quot;&gt;3.5+, обратный порт&lt;/a&gt; : [PyPI]: scandir )</target>
        </trans-unit>
        <trans-unit id="881c94c992f5c2704f7aea54c69305fd8520f3b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.path.html#os.path.exists&quot;&gt;[Python 3]: os.path.&lt;strong&gt;exists&lt;/strong&gt;(&lt;em&gt;path&lt;/em&gt;)&lt;/a&gt; (also check other function family members like &lt;code&gt;os.path.isfile&lt;/code&gt;, &lt;code&gt;os.path.isdir&lt;/code&gt;, &lt;code&gt;os.path.lexists&lt;/code&gt; for slightly different behaviors)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.path.html#os.path.exists&quot;&gt;[Python 3]: os.path.&lt;/a&gt; &lt;strong&gt;Существует&lt;/strong&gt; ( &lt;em&gt;путь&lt;/em&gt; ) (также проверьте другие члены семейства функций, такие как &lt;code&gt;os.path.isfile&lt;/code&gt; , &lt;code&gt;os.path.isdir&lt;/code&gt; , &lt;code&gt;os.path.lexists&lt;/code&gt; для немного другого поведения)</target>
        </trans-unit>
        <trans-unit id="16a9582fc6e61500a615bb32272726f039a6dea9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#context-managers&quot;&gt;[Python 3]: With Statement Context Managers&lt;/a&gt;. Either:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#context-managers&quot;&gt;[Python 3]: с менеджерами контекста операторов&lt;/a&gt; . Или:</target>
        </trans-unit>
        <trans-unit id="e7facdf0dc4a8e14a1a54deddc2ccf73d6d27185" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isfile&lt;/code&gt; is actually just a helper method that internally uses &lt;code&gt;os.stat&lt;/code&gt; and &lt;code&gt;stat.S_ISREG(mode)&lt;/code&gt; underneath. This &lt;code&gt;os.stat&lt;/code&gt; is a lower-level method that will provide you with detailed information about files, directories, sockets, buffers, and more. &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.stat&quot;&gt;More about os.stat here&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;isfile&lt;/code&gt; самом деле isfile - это просто вспомогательный метод, который внутри использует &lt;code&gt;os.stat&lt;/code&gt; и &lt;code&gt;stat.S_ISREG(mode)&lt;/code&gt; . Этот &lt;code&gt;os.stat&lt;/code&gt; является методом более низкого уровня, который предоставит вам подробную информацию о файлах, каталогах, сокетах, буферах и многом другом. &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.stat&quot;&gt;Больше о os.stat здесь&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56f16f3fd911d49aaf5aa425fc05be5bcc4d128b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.path&lt;/code&gt; - &lt;em&gt;posixpath.py&lt;/em&gt; (&lt;em&gt;ntpath.py&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;os.path&lt;/code&gt; - &lt;em&gt;posixpath.py&lt;/em&gt; ( &lt;em&gt;ntpath.py&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="c213153b48aa1adfe737e87d17e184e0df446764" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress&lt;/code&gt; is part of Python 3.4. In older releases you can quickly write your own suppress:</source>
          <target state="translated">&lt;code&gt;suppress&lt;/code&gt; является частью Python 3.4. В старых версиях вы можете быстро написать свой собственный подавитель:</target>
        </trans-unit>
        <trans-unit id="7341feac8a06399cdfbd59912dc1807dd4972e4d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nix&lt;/em&gt; (&lt;em&gt;Lnx&lt;/em&gt; (&lt;em&gt;Ubtu&lt;/em&gt;)):</source>
          <target state="translated">&lt;em&gt;Никс&lt;/em&gt; ( &lt;em&gt;Lnx&lt;/em&gt; ( &lt;em&gt;Убту&lt;/em&gt; )):</target>
        </trans-unit>
        <trans-unit id="bcc27befb6f3b8f2dfa82be82a68582f296622aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nix&lt;/em&gt;: &lt;a href=&quot;http://man7.org/linux/man-pages/man2/access.2.html&quot;&gt;[man7]: ACCESS(2)&lt;/a&gt; (!!! pay attention to the note about the &lt;strong&gt;security hole&lt;/strong&gt; its usage might introduce !!!)</source>
          <target state="translated">&lt;em&gt;Nix&lt;/em&gt; : &lt;a href=&quot;http://man7.org/linux/man-pages/man2/access.2.html&quot;&gt;[man7]: ACCESS (2)&lt;/a&gt; (!!! обратите внимание на примечание о &lt;strong&gt;дыре&lt;/strong&gt; в &lt;strong&gt;безопасности, которую&lt;/strong&gt; может привести к его использованию !!!)</target>
        </trans-unit>
        <trans-unit id="a16adeeb8960035b0fa48ff747e9036d84b7fac1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nix&lt;/em&gt;: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/opendir.3.html&quot;&gt;[man7]: OPENDIR(3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/readdir.3.html&quot;&gt;[man7]: READDIR(3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/closedir.3.html&quot;&gt;[man7]: CLOSEDIR(3)&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Nix&lt;/em&gt; : &lt;a href=&quot;http://man7.org/linux/man-pages/man3/opendir.3.html&quot;&gt;[man7]: OPENDIR (3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/readdir.3.html&quot;&gt;[man7]: READDIR (3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/closedir.3.html&quot;&gt;[man7]: CLOSEDIR (3)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e3e7e3a1bf52b57f359fffd279b3063aa9c1eab" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Win&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Win&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="672cf7faded202b7034a24292acbf961c1694c7b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Win&lt;/em&gt;: &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew&quot;&gt;[MS.Docs]: FindFirstFileW function&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew&quot;&gt;[MS.Docs]: FindNextFileW function&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose&quot;&gt;[MS.Docs]: FindClose function&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Win&lt;/em&gt; : &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew&quot;&gt;[MS.Docs]: функция FindFirstFileW&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew&quot;&gt;[MS.Docs]: функция FindNextFileW&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose&quot;&gt;[MS.Docs]: функция FindClose&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="918e9fb58193867f89f5a410d74811d1771b2724" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Win&lt;/em&gt;: &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-getfileattributesw&quot;&gt;[MS.Docs]: GetFileAttributesW function&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Win&lt;/em&gt; : &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-getfileattributesw&quot;&gt;[MS.Docs]: функция GetFileAttributesW&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d6ed7dbc3e0f962103d4c625797662e29aa9184" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;genericpath.py&lt;/em&gt;, line &lt;em&gt;~#20+&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;genericpath.py&lt;/em&gt; , строка &lt;em&gt;~ # 20 +&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="423d8236f9dc3da510581f0ee3fbcd477ede396d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bottom line&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Итог&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="2b621694fd99fa555aa2279458b5f4cee2e246ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do&lt;/strong&gt; use &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; blocks, because they can prevent you running into a series of nasty problems. A counter-example that I can think of, is performance: such blocks are costly, so try not to place them in code that it's supposed to run hundreds of thousands times per second (but since (in most cases) it involves disk access, it won't be the case).</source>
          <target state="translated">Используйте блоки &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;исключением&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; , поскольку они могут предотвратить возникновение ряда неприятных проблем. Контр-пример, о котором я могу подумать, - это производительность: такие блоки являются дорогостоящими, поэтому постарайтесь не помещать их в код, который предполагается запускать сотни тысяч раз в секунду (но поскольку (в большинстве случаев) он предполагает доступ к диску, это не будет так).</target>
        </trans-unit>
        <trans-unit id="114c46c58943d0d3fb01ce5a2dbc7e5146a8eddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Final note(s)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Финальные заметки&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4ae1be26b6f0138302a179e64d43a2067887f700" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do I check whether a file exists, without using the try statement?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как проверить, существует ли файл, без использования оператора try?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d629d8e59823d5bde2e04f68edf40981e144ca70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; However, this approach will not lock the file in any way and therefore your code can become vulnerable to &quot;&lt;strong&gt;time of check to time of use&lt;/strong&gt;&quot; (&lt;em&gt;TOCTTOU&lt;/em&gt;) bugs.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Однако этот подход никоим образом не блокирует файл, и поэтому ваш код может стать уязвимым к &lt;em&gt;ошибкам&lt;/em&gt; &amp;laquo; &lt;strong&gt;время проверки на время использования&lt;/strong&gt; &amp;raquo; ( &lt;em&gt;TOCTTOU&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="55fac486326161bbbcc381844be9edd879071502" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: calling native &lt;em&gt;API&lt;/em&gt;s is also possible via &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;[Python 3]: &lt;em&gt;ctypes&lt;/em&gt; - A foreign function library for Python&lt;/a&gt;, but in most cases it's more complicated.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : вызов нативных &lt;em&gt;API&lt;/em&gt; также возможен через &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;[Python 3]: &lt;em&gt;ctypes&lt;/em&gt; - библиотека &lt;em&gt;сторонних&lt;/em&gt; функций для Python&lt;/a&gt; , но в большинстве случаев она более сложная.</target>
        </trans-unit>
        <trans-unit id="49d34f653b3f7b18395aa530bbca320ea65fe2bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: every piece of &lt;em&gt;Python&lt;/em&gt; standard library code that I'm going to post, belongs to version &lt;strong&gt;3.5.3&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; : каждый фрагмент кода стандартной библиотеки &lt;em&gt;Python,&lt;/em&gt; который я собираюсь опубликовать, относится к версии &lt;strong&gt;3.5.3&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f69af187844f3307c7ac46ebb6a50af4199d0748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="0429ce3fc368572fdbb918ae180fcce64fed32ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Possible solutions&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Возможные решения&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="5fed05e805aed79ae5e47afbe0cb8a973df01183" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem statement&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Постановка проблемы&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="06e40dece35eaf987428ae55c6db9c12f565c3c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 3.4+&lt;/strong&gt; has an object-oriented path module: &lt;a href=&quot;http://docs.python.org/3.4/library/pathlib.html&quot;&gt;&lt;strong&gt;pathlib&lt;/strong&gt;&lt;/a&gt;.  Using this new module, you can check whether a file exists like this:</source>
          <target state="translated">&lt;strong&gt;В Python 3.4+&lt;/strong&gt; есть объектно-ориентированный модуль пути: &lt;a href=&quot;http://docs.python.org/3.4/library/pathlib.html&quot;&gt;&lt;strong&gt;pathlib&lt;/strong&gt;&lt;/a&gt; . Используя этот новый модуль, вы можете проверить, существует ли файл следующим образом:</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8e849d6a4eb1c3b48df71118000704a6892341f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;isfile&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;isfile&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ccfc4989519ffe46e24bb53066a5a14a735987c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;os.access&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;os.access&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cbfe01e7936d0de4ea51c3c0558f1bb48b1f30e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;user permissions&lt;/strong&gt; might restrict the file &quot;visibility&quot; as the doc states:</source>
          <target state="translated">&lt;strong&gt;пользовательские разрешения&lt;/strong&gt; могут ограничивать &quot;видимость&quot; файла, как указано в документе:</target>
        </trans-unit>
        <trans-unit id="aa65b1dac98f13533fe2f70426ca413eff63c4b0" translate="yes" xml:space="preserve">
          <source>Adding a variant based on suggestion from Peter Wood</source>
          <target state="translated">Добавление варианта,основанного на предложении Питера Вуда.</target>
        </trans-unit>
        <trans-unit id="80c015f2d056c575939357b34c73484f4d21f408" translate="yes" xml:space="preserve">
          <source>Adding a variant based on suggestion from Shahbaz</source>
          <target state="translated">Добавление варианта по предложению Шахбаза</target>
        </trans-unit>
        <trans-unit id="8dcd1e3788c9558ded09b3960d94517b78c07f15" translate="yes" xml:space="preserve">
          <source>Adding one more slight variation which isn't exactly reflected in the other answers.</source>
          <target state="translated">Добавление еще одного небольшого изменения,которое неточно отражено в других ответах.</target>
        </trans-unit>
        <trans-unit id="d8fa576e19bc4318ac6a981c7b91c8f2cbbb0f5c" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;os.access()&lt;/code&gt;:</source>
          <target state="translated">Кроме того, &lt;code&gt;os.access()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="77d1962860d37265160d4636c2fd603e0de75d36" translate="yes" xml:space="preserve">
          <source>All good, but if following the import tree:</source>
          <target state="translated">Все хорошо,но если следовать за деревом импорта:</target>
        </trans-unit>
        <trans-unit id="78f3ec46f0be71b55c60a634c5c232244a44c6d0" translate="yes" xml:space="preserve">
          <source>All it's doing is using the given path to see if it can get stats on it,  catching &lt;code&gt;OSError&lt;/code&gt; and then checking if it's a file if it didn't raise the exception.</source>
          <target state="translated">Все, что он делает, - использует заданный путь, чтобы посмотреть, сможет ли он получить статистику, &lt;code&gt;OSError&lt;/code&gt; и затем проверяет, является ли это файл, если он не вызывает исключение.</target>
        </trans-unit>
        <trans-unit id="9b23ce4faf3bf6e817d02cdbe090fd916f4c40e3" translate="yes" xml:space="preserve">
          <source>Although I always recommend using &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;except&lt;/code&gt; statements, here are a few possibilities for you (my personal favourite is using &lt;code&gt;os.access&lt;/code&gt;):</source>
          <target state="translated">Несмотря на то, что я всегда рекомендую использовать операторы &lt;code&gt;try&lt;/code&gt; и &lt;code&gt;except&lt;/code&gt; утверждений, вот несколько вариантов для вас (мой личный фаворит - использование &lt;code&gt;os.access&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="c28a1b9efeed16f3cc15a65fe06dbf2005ac95c5" translate="yes" xml:space="preserve">
          <source>Although almost every possible way has been listed in (at least one of) the existing answers (e.g. &lt;em&gt;Python 3.4&lt;/em&gt; specific stuff was added), I'll try to group everything together.</source>
          <target state="translated">Хотя почти все возможные способы были перечислены в (по крайней мере, одном из) существующих ответов (например, добавлен материал, специфичный для &lt;em&gt;Python 3.4&lt;/em&gt; ), я постараюсь сгруппировать все вместе.</target>
        </trans-unit>
        <trans-unit id="16295a749dac9ed45033fdbc3aac9a2b96843f1d" translate="yes" xml:space="preserve">
          <source>Although it's not a good practice, I'm using &lt;code&gt;os.F_OK&lt;/code&gt; in the call, but that's just for clarity (its value is &lt;strong&gt;0&lt;/strong&gt;)</source>
          <target state="translated">Хотя это не очень хорошая практика, я использую &lt;code&gt;os.F_OK&lt;/code&gt; в вызове, но это только для ясности (его значение равно &lt;strong&gt;0&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="3f08a8328b4d7fdf72d3c29093a5ec904d34940a" translate="yes" xml:space="preserve">
          <source>Although this targets a very specific area, &lt;strong&gt;it was not mentioned in any of the previous answers&lt;/strong&gt;</source>
          <target state="translated">Хотя это относится к очень конкретной области, &lt;strong&gt;она не упоминалась ни в одном из предыдущих ответов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="78f96d0ac535b29f25a666e1fd59d59ef2274f92" translate="yes" xml:space="preserve">
          <source>An intuitive and arguable way to check if a file exists is the following:</source>
          <target state="translated">Интуитивно понятным и аргументированным способом проверки существования файла является следующее:</target>
        </trans-unit>
        <trans-unit id="5e11bbf35099c5b98a84a5e51e2b22a25ec14116" translate="yes" xml:space="preserve">
          <source>And its usage - I'll replicate the &lt;code&gt;os.path.isfile&lt;/code&gt; behavior (note that this is just for demonstrating purposes, do &lt;strong&gt;not&lt;/strong&gt; attempt to write such code for &lt;em&gt;production&lt;/em&gt;):</source>
          <target state="translated">И его использование - я &lt;code&gt;os.path.isfile&lt;/code&gt; поведение os.path.isfile (обратите внимание, что это только для демонстрации, &lt;strong&gt;не&lt;/strong&gt; пытайтесь писать такой код для &lt;em&gt;производства&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="c242f95ca1e5451cdad6a7e633a8bef0a286e761" translate="yes" xml:space="preserve">
          <source>And the doc&amp;hellip;</source>
          <target state="translated">И док ...</target>
        </trans-unit>
        <trans-unit id="a2e22103d7193a6b3e153c897e9be19320669858" translate="yes" xml:space="preserve">
          <source>Another (lame) workaround (&lt;em&gt;gainarie&lt;/em&gt;) is (as I like to call it,) the &lt;em&gt;sysadmin&lt;/em&gt; approach: use &lt;em&gt;Python&lt;/em&gt; as a wrapper to execute shell commands</source>
          <target state="translated">Другой ( &lt;em&gt;слабый&lt;/em&gt; ) обходной путь ( &lt;em&gt;gainarie&lt;/em&gt; ) - это (как я это называю) подход &lt;em&gt;sysadmin&lt;/em&gt; : использование &lt;em&gt;Python&lt;/em&gt; в качестве оболочки для выполнения команд оболочки</target>
        </trans-unit>
        <trans-unit id="9fe49da0dcd83e20fd5dd80ebdfbe1ed9a2c2eae" translate="yes" xml:space="preserve">
          <source>Another answer says this about &lt;code&gt;os.access&lt;/code&gt;:</source>
          <target state="translated">Другой ответ говорит об &lt;code&gt;os.access&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dd57f8a5f3007d7bb9aa43a930b678df495e7817" translate="yes" xml:space="preserve">
          <source>Anyway, here:</source>
          <target state="translated">В любом случае,здесь:</target>
        </trans-unit>
        <trans-unit id="9a06af54a07db4e5735e851faae4a0df7e12350c" translate="yes" xml:space="preserve">
          <source>Assuming that the &quot;path&quot; is a valid path, this table shows what is returned by each function for files and folders:</source>
          <target state="translated">Предполагая,что &quot;путь&quot; является правильным,эта таблица показывает,что возвращается каждой функцией для файлов и папок:</target>
        </trans-unit>
        <trans-unit id="4aa4567b6cd6712a2f7dedeecffb310d4fb8efca" translate="yes" xml:space="preserve">
          <source>Available for Unix and Windows is &lt;code&gt;os.access&lt;/code&gt;, but to use you must pass flags, and it does not differentiate between files and directories. This is more used to test if the real invoking user has access in an elevated privilege environment:</source>
          <target state="translated">Для Unix и Windows &lt;code&gt;os.access&lt;/code&gt; , но для его использования необходимо указать флаги, и он не различает файлы и каталоги. Это больше используется для проверки, имеет ли реальный вызывающий пользователь доступ в среде с повышенными привилегиями:</target>
        </trans-unit>
        <trans-unit id="f939845f218e32c170faf5bf6f1cac2c41d8816a" translate="yes" xml:space="preserve">
          <source>Available since Python 3.4, use the new &lt;code&gt;Path&lt;/code&gt; object in &lt;code&gt;pathlib&lt;/code&gt;. Note that &lt;code&gt;.exists&lt;/code&gt; is not quite right, because directories are not files (except in the unix sense that &lt;em&gt;everything&lt;/em&gt; is a file).</source>
          <target state="translated">Доступный начиная с Python 3.4, используйте новый объект &lt;code&gt;Path&lt;/code&gt; в &lt;code&gt;pathlib&lt;/code&gt; . Обратите внимание, что &lt;code&gt;.exists&lt;/code&gt; не совсем прав, потому что каталоги не являются файлами (за исключением того, что Unix означает, что &lt;em&gt;все&lt;/em&gt; является файлом).</target>
        </trans-unit>
        <trans-unit id="afb7ff96e854e0041ec75564f5fe00e9c8f882e0" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;os.access&lt;/code&gt;. It is a low level function that has more opportunities for user error than the higher level objects and functions discussed above.</source>
          <target state="translated">Избегайте использования &lt;code&gt;os.access&lt;/code&gt; . Это функция низкого уровня, которая имеет больше возможностей для ошибок пользователя, чем объекты и функции более высокого уровня, описанные выше.</target>
        </trans-unit>
        <trans-unit id="da6dd21459c0ea82eef4c904638259335de797c6" translate="yes" xml:space="preserve">
          <source>Avoiding Race Conditions</source>
          <target state="translated">Избегание условий гонки</target>
        </trans-unit>
        <trans-unit id="65d799a4d67e40f1718bc28bc5741a7784d3dc98" translate="yes" xml:space="preserve">
          <source>Avoiding race conditions without a try statement: &lt;code&gt;suppress&lt;/code&gt;</source>
          <target state="translated">Избегать условий гонки без попытки заявления: &lt;code&gt;suppress&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16914c6434145a06ea234b60fc7371e4a7fa25c2" translate="yes" xml:space="preserve">
          <source>Because Python uses &lt;code&gt;try&lt;/code&gt; everywhere, there's really no reason to avoid an implementation that uses it.</source>
          <target state="translated">Поскольку Python использует &lt;code&gt;try&lt;/code&gt; везде, на самом деле нет причин избегать реализации, которая его использует.</target>
        </trans-unit>
        <trans-unit id="1360085308b5fa42bcc299eba73a082684f6297d" translate="yes" xml:space="preserve">
          <source>Being &lt;code&gt;R_OK&lt;/code&gt;, &lt;code&gt;W_OK&lt;/code&gt;, and &lt;code&gt;X_OK&lt;/code&gt; the flags to test for permissions (&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;doc&lt;/a&gt;).</source>
          <target state="translated">Будучи &lt;code&gt;R_OK&lt;/code&gt; , &lt;code&gt;W_OK&lt;/code&gt; и &lt;code&gt;X_OK&lt;/code&gt; , флаги для проверки прав доступа ( &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;doc&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5ce4b99d290844609883481eafaef7da7bec38b" translate="yes" xml:space="preserve">
          <source>But if this is your motivation, you &lt;em&gt;can&lt;/em&gt; get the value of a &lt;code&gt;try&lt;/code&gt; statement by using the &lt;code&gt;suppress&lt;/code&gt; context manager.</source>
          <target state="translated">Но если это ваша мотивация, вы &lt;em&gt;можете&lt;/em&gt; получить значение оператора &lt;code&gt;try&lt;/code&gt; с помощью диспетчера &lt;code&gt;suppress&lt;/code&gt; контекста.</target>
        </trans-unit>
        <trans-unit id="f386f26a018b39932ce810bfed8462f4b3a47009" translate="yes" xml:space="preserve">
          <source>But if you examine the &lt;a href=&quot;https://hg.python.org/cpython/file/tip/Lib/genericpath.py#l25&quot;&gt;source&lt;/a&gt; of this function, you'll see it actually does use a try statement:</source>
          <target state="translated">Но если вы изучите &lt;a href=&quot;https://hg.python.org/cpython/file/tip/Lib/genericpath.py#l25&quot;&gt;источник&lt;/a&gt; этой функции, вы увидите, что она действительно использует оператор try:</target>
        </trans-unit>
        <trans-unit id="892805ad4977b8e4cbbb93d3b769716f4bf55e28" translate="yes" xml:space="preserve">
          <source>But if you just wanted to rename a file if it exists, and therefore don't need to open it, do</source>
          <target state="translated">Но если вы просто хотите переименовать файл,если он существует,и,следовательно,вам не нужно его открывать,сделайте следующее</target>
        </trans-unit>
        <trans-unit id="e6de42189ae24dbf3535041c097ece060e47ed05" translate="yes" xml:space="preserve">
          <source>But the rest of this answer attempts to consider these caveats.</source>
          <target state="translated">Но остальная часть ответа пытается учесть эти предостережения.</target>
        </trans-unit>
        <trans-unit id="a80baeb2d0654bc11cd6d4521f34ce4502d6e633" translate="yes" xml:space="preserve">
          <source>But, since this is more like a workaround, I'm stopping here.</source>
          <target state="translated">Но,так как это больше похоже на обходной приём,я останавливаюсь здесь.</target>
        </trans-unit>
        <trans-unit id="a4baa59ded747be901cc0484a5e9a9c22477fa86" translate="yes" xml:space="preserve">
          <source>But, they seem to be wrappers over &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; blocks, as &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#with&quot;&gt;[Python 3]: The &lt;em&gt;with&lt;/em&gt; statement&lt;/a&gt; states:</source>
          <target state="translated">Но они, похоже, являются обертками над блоками &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;исключением&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; , как &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#with&quot;&gt;[Python 3]: Оператор &lt;em&gt;with&lt;/em&gt;&lt;/a&gt; гласит:</target>
        </trans-unit>
        <trans-unit id="3f1992230a0a514077c62160f7120bcc185acd4c" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;NamedTemporaryFile&lt;/code&gt; deletes the file when closed (and will automatically close when no more references exist to it).</source>
          <target state="translated">По умолчанию &lt;code&gt;NamedTemporaryFile&lt;/code&gt; удаляет файл при закрытии (и автоматически закрывается, когда на него больше нет ссылок).</target>
        </trans-unit>
        <trans-unit id="680c3a0a04488efb0a6669d23ed46dff42487746" translate="yes" xml:space="preserve">
          <source>Check file (&lt;em&gt;arguable&lt;/em&gt;: also folder (&quot;special&quot; file) ?) existence</source>
          <target state="translated">Проверить наличие файла ( &lt;em&gt;спорный&lt;/em&gt; : также папка (&amp;laquo;специальный&amp;raquo; файл)?)</target>
        </trans-unit>
        <trans-unit id="00069321f9bac6a3e2758c45a988eb1af4ffe84c" translate="yes" xml:space="preserve">
          <source>Check file or directory exists</source>
          <target state="translated">Контрольный файл или каталог существует</target>
        </trans-unit>
        <trans-unit id="2148c4248cab3850cba5ecc20309317f0af37946" translate="yes" xml:space="preserve">
          <source>Create one:</source>
          <target state="translated">Создай одну:</target>
        </trans-unit>
        <trans-unit id="23c1fa17d5809322d5e9a7c843e9604caa61cdff" translate="yes" xml:space="preserve">
          <source>Criticism of another answer:</source>
          <target state="translated">Критика другого ответа:</target>
        </trans-unit>
        <trans-unit id="3b40241a5f2c37e0887dd4f6954b744ced57b1ec" translate="yes" xml:space="preserve">
          <source>Date:2017-12-04</source>
          <target state="translated">Date:2017-12-04</target>
        </trans-unit>
        <trans-unit id="87444639b77f489e7dc7f1684a2c815d05e6b641" translate="yes" xml:space="preserve">
          <source>Doesn't seem a traversing function &lt;em&gt;per se&lt;/em&gt; (at least in some cases), but it still uses &lt;code&gt;os.listdir&lt;/code&gt;</source>
          <target state="translated">Сама по себе функция обхода не выглядит (по крайней мере, в некоторых случаях), но она все еще использует &lt;code&gt;os.listdir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d521195617328a431dabe6deacc4cc8e93939de" translate="yes" xml:space="preserve">
          <source>Don't take my word for it. There's plenty of support for this theory. Here's a couple:</source>
          <target state="translated">Не верь мне на слово.Эта теория пользуется широкой поддержкой.Вот пара:</target>
        </trans-unit>
        <trans-unit id="2df06b2d468838548ea913f49b8c7912e8ab2b96" translate="yes" xml:space="preserve">
          <source>Don't use &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; blocks</source>
          <target state="translated">Не используйте блоки &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;исключением&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9461aa6e4a1d297ac2448ad2f40004dd46970c5" translate="yes" xml:space="preserve">
          <source>Every possible solution has been listed in other answers.</source>
          <target state="translated">Все возможные решения перечислены в других ответах.</target>
        </trans-unit>
        <trans-unit id="57f676484ad86c6f592e0200b1bc9abf4d27bc4a" translate="yes" xml:space="preserve">
          <source>Filesystem traversal functions (and search the results for matching item(s))</source>
          <target state="translated">Функции обхода файловой системы (и поиск по результатам поиска подходящего элемента (элементов))</target>
        </trans-unit>
        <trans-unit id="2482b1dfd54ac893308e090998a270fa3acccec9" translate="yes" xml:space="preserve">
          <source>For earlier Pythons, you could roll your own &lt;code&gt;suppress&lt;/code&gt;, but without a &lt;code&gt;try&lt;/code&gt; will be more verbose than with. I do believe &lt;strong&gt;this actually is the only answer that doesn't use &lt;code&gt;try&lt;/code&gt; at any level in the Python&lt;/strong&gt; that can be applied to prior to Python 3.4 because it uses a context manager instead:</source>
          <target state="translated">Для более ранних Pythons, вы можете бросить свой собственный &lt;code&gt;suppress&lt;/code&gt; , но без &lt;code&gt;try&lt;/code&gt; будет более многословным, чем с. Я действительно считаю, &lt;strong&gt;что на самом деле это единственный ответ, который не использует &lt;code&gt;try&lt;/code&gt; на любом уровне в Python,&lt;/strong&gt; который может быть применен до Python 3.4, потому что вместо него используется менеджер контекста:</target>
        </trans-unit>
        <trans-unit id="55f79bf0ba7b0375b8d3143950e1a90ab89796a4" translate="yes" xml:space="preserve">
          <source>For reference also see &lt;a href=&quot;/q/82831&quot;&gt;How to check whether a file exists using Python?&lt;/a&gt;</source>
          <target state="translated">Для справки также см. &lt;a href=&quot;/q/82831&quot;&gt;Как проверить, существует ли файл с использованием Python?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0bdeff00f3ab0a5de85d46268cc456e660f0891f" translate="yes" xml:space="preserve">
          <source>Here's a 1 line Python command for the Linux command line environment. I find this VERY HANDY since I'm not such a hot Bash guy.</source>
          <target state="translated">Вот 1-строчная команда Python для командной строки Linux.Я нахожу это ОЧЕНЬ ХАНДИ,так как я не такой уж и горячий Бэш.</target>
        </trans-unit>
        <trans-unit id="4f2f59aeca936afd9d057519d9ef3eac5bef7ca4" translate="yes" xml:space="preserve">
          <source>Here's the help on &lt;code&gt;is_file&lt;/code&gt;:</source>
          <target state="translated">Вот справка по &lt;code&gt;is_file&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d3e0db2911db163b18bf0441aa9f4ab60ce06986" translate="yes" xml:space="preserve">
          <source>How do I check whether a file exists without exceptions</source>
          <target state="translated">Как проверить,существует ли файл без исключений.</target>
        </trans-unit>
        <trans-unit id="f992ff3c06028274def0fdd00a52220dd457b417" translate="yes" xml:space="preserve">
          <source>How do I check whether a file exists, using Python, without using a try statement?</source>
          <target state="translated">Как проверить,существует ли файл,используя Python,без использования пробного утверждения?</target>
        </trans-unit>
        <trans-unit id="648dcb140e5c8625e8fd1d8412c1ff5f81de87f0" translate="yes" xml:space="preserve">
          <source>How do I see if a file exists or not, without using the &lt;a href=&quot;https://docs.python.org/3.6/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement?</source>
          <target state="translated">Как узнать, существует файл или нет, без использования оператора &lt;a href=&quot;https://docs.python.org/3.6/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="4da044c22cb2fb15a1b87e329d865c130b7299e8" translate="yes" xml:space="preserve">
          <source>I hope this is helpful.</source>
          <target state="translated">Надеюсь,это поможет.</target>
        </trans-unit>
        <trans-unit id="ebe65250133ece313707187f5563d38f23a6029b" translate="yes" xml:space="preserve">
          <source>I made an exhaustive cheatsheet for your reference:</source>
          <target state="translated">Я сделал исчерпывающую шпаргалку для твоей справки:</target>
        </trans-unit>
        <trans-unit id="c092b3bf26fda474ba2f972972deba214b2de89d" translate="yes" xml:space="preserve">
          <source>I should also mention that there are two ways that you will not be able to verify the existence of a file. Either the issue will be &lt;code&gt;permission denied&lt;/code&gt; or &lt;code&gt;no such file or directory&lt;/code&gt;. If you catch an &lt;code&gt;IOError&lt;/code&gt;, set the &lt;code&gt;IOError as e&lt;/code&gt; (like my first option), and then type in &lt;code&gt;print(e.args)&lt;/code&gt; so that you can hopefully determine your issue. I hope it helps! :)</source>
          <target state="translated">Я должен также упомянуть, что есть два способа, которыми вы не сможете проверить существование файла. Либо проблема будет &lt;code&gt;permission denied&lt;/code&gt; либо &lt;code&gt;no such file or directory&lt;/code&gt; . Если вы поймаете &lt;code&gt;IOError&lt;/code&gt; , установите &lt;code&gt;IOError as e&lt;/code&gt; (как мой первый вариант), а затем введите &lt;code&gt;print(e.args)&lt;/code&gt; чтобы вы могли надеяться определить вашу проблему. Я надеюсь, что это помогает! :)</target>
        </trans-unit>
        <trans-unit id="6bdb8ff9e404da03bb952ad7abebcc20b1ca5fbc" translate="yes" xml:space="preserve">
          <source>I will try to keep it up to date, any suggestions are welcome, I will incorporate anything useful that will come up into the answer</source>
          <target state="translated">Я постараюсь держать его в курсе,любые предложения приветствуются,я включу все полезное,что появится в ответе</target>
        </trans-unit>
        <trans-unit id="71420b82d8fcd7fd47b4cff0728dfbb46cae47de" translate="yes" xml:space="preserve">
          <source>I'm the author of a package that's been around for about 10 years, and it has a function that addresses this question directly. Basically, if you are on a non-Windows system, it uses &lt;code&gt;Popen&lt;/code&gt; to access &lt;code&gt;find&lt;/code&gt;.  However, if you are on Windows, it replicates &lt;code&gt;find&lt;/code&gt; with an efficient filesystem walker.</source>
          <target state="translated">Я являюсь автором пакета, который существует уже около 10 лет, и у него есть функция, которая решает этот вопрос напрямую. В основном, если вы работаете не в системе Windows, она использует &lt;code&gt;Popen&lt;/code&gt; для доступа к &lt;code&gt;find&lt;/code&gt; . Однако, если вы работаете в Windows, он копирует &lt;code&gt;find&lt;/code&gt; с эффективным обходчиком файловой системы.</target>
        </trans-unit>
        <trans-unit id="8ca967716a632903489f4722e9137f4292d1cec8" translate="yes" xml:space="preserve">
          <source>I'm using &lt;em&gt;_waccess&lt;/em&gt; so that the same code works on &lt;em&gt;Python3&lt;/em&gt; and &lt;em&gt;Python2&lt;/em&gt; (in spite of &lt;em&gt;unicode&lt;/em&gt; related differences between them)</source>
          <target state="translated">Я использую &lt;em&gt;_waccess,&lt;/em&gt; чтобы один и тот же код работал на &lt;em&gt;Python3&lt;/em&gt; и &lt;em&gt;Python2&lt;/em&gt; (несмотря на различия между ними, связанные с &lt;em&gt;юникодом&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="a407e3adfd2214b7c586432d022e9ef118ddf7e0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is NULL, then the returned handle is for the main
  program.  When given to &lt;strong&gt;dlsym&lt;/strong&gt;(), this handle causes a search for a
  symbol in the main program, followed by all shared objects loaded at
  program startup, and then all shared objects loaded by &lt;strong&gt;dlopen&lt;/strong&gt;() with
  the flag &lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;.</source>
          <target state="translated">Если &lt;em&gt;имя файла&lt;/em&gt; NULL, то возвращаемый дескриптор для основной программы. При &lt;strong&gt;передаче dlsym&lt;/strong&gt; () этот дескриптор вызывает поиск символа в основной программе, за которым следуют все общие объекты, загружаемые при запуске программы, а затем все общие объекты, загружаемые &lt;strong&gt;dlopen&lt;/strong&gt; () с флагом &lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="15fcbc3b264cbebf2eb4f1760bc8e1cba58236dd" translate="yes" xml:space="preserve">
          <source>If it's False, it will stop execution with an unhanded IOError
or OSError in later versions of Python. To catch the exception,
you have to use a try except clause. Of course, you can always
use a &lt;code&gt;try&lt;/code&gt; except` statement like so (thanks to &lt;a href=&quot;https://stackoverflow.com/users/3256073/hsandt&quot;&gt;hsandt&lt;/a&gt;
for making me think):</source>
          <target state="translated">Если это значение False, оно прекратит выполнение с неуправляемым IOError или OSError в более поздних версиях Python. Чтобы поймать исключение, вы должны использовать предложение try, кроме. Конечно, вы всегда можете использовать оператор &lt;code&gt;try&lt;/code&gt; кроме `` следующим образом (спасибо &lt;a href=&quot;https://stackoverflow.com/users/3256073/hsandt&quot;&gt;hsandt&lt;/a&gt; за то, что заставил меня задуматься):</target>
        </trans-unit>
        <trans-unit id="c02184bc81acba7ff60734fa0276f4694047dce3" translate="yes" xml:space="preserve">
          <source>If the file is for opening you could use one of the following techniques:</source>
          <target state="translated">Если файл предназначен для открытия,можно воспользоваться одним из следующих способов:</target>
        </trans-unit>
        <trans-unit id="f750d04a74a28d801ca980107d812cb534028797" translate="yes" xml:space="preserve">
          <source>If the reason you're checking is so you can do something like &lt;code&gt;if file_exists: open_it()&lt;/code&gt;, it's safer to use a &lt;code&gt;try&lt;/code&gt; around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.</source>
          <target state="translated">Если причина, по которой вы проверяете, заключается в том, что вы можете сделать что-то вроде &lt;code&gt;if file_exists: open_it()&lt;/code&gt; , безопаснее использовать &lt;code&gt;try&lt;/code&gt; при попытке открыть его. Проверка и последующее открытие может привести к удалению или перемещению файла, а также к тому, что вы проверяете и когда пытаетесь открыть его.</target>
        </trans-unit>
        <trans-unit id="c5ff89b09fe8a6eb3f1fbb9c6d4f376565e0fe86" translate="yes" xml:space="preserve">
          <source>If you dig into &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/pathlib.py#L1318&quot;&gt;the implementation&lt;/a&gt;, though, you'll see that &lt;code&gt;is_file&lt;/code&gt; uses &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">Если вы углубитесь в &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/pathlib.py#L1318&quot;&gt;реализацию&lt;/a&gt; , то увидите, что &lt;code&gt;is_file&lt;/code&gt; использует &lt;code&gt;try&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0979e6df66fd1282fbd01cd0616f8c975b44e156" translate="yes" xml:space="preserve">
          <source>If you imported NumPy already for other purposes then there is no need to import other libraries like &lt;code&gt;pathlib&lt;/code&gt;, &lt;code&gt;os&lt;/code&gt;, &lt;code&gt;paths&lt;/code&gt;, etc.</source>
          <target state="translated">Если вы уже импортировали NumPy для других целей, то нет необходимости импортировать другие библиотеки, такие как &lt;code&gt;pathlib&lt;/code&gt; , &lt;code&gt;os&lt;/code&gt; , &lt;code&gt;paths&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="3505fa4d971cfab39c9f20bc4b27451fc35e3489" translate="yes" xml:space="preserve">
          <source>If you intend to do something with the file, I would suggest directly attempting it with a try-except to avoid a race condition:</source>
          <target state="translated">Если вы собираетесь что-то сделать с этим файлом,я бы посоветовал попробовать напрямую,за исключением случаев,когда это необходимо,чтобы избежать состояния гонки:</target>
        </trans-unit>
        <trans-unit id="7dcf6a221c7d9f7451561a984e8aab1ebed8336f" translate="yes" xml:space="preserve">
          <source>If you need file locking, that's a different matter.</source>
          <target state="translated">Если тебе нужна блокировка файлов,это другое дело.</target>
        </trans-unit>
        <trans-unit id="08c9a05009658ae490c6ba1c13b8004939cdcd0a" translate="yes" xml:space="preserve">
          <source>If you need high-level operations, use &lt;code&gt;shutil&lt;/code&gt;.</source>
          <target state="translated">Если вам нужны операции высокого уровня, используйте &lt;code&gt;shutil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56e17f5c3eb030308d334ae00733d23533b31d78" translate="yes" xml:space="preserve">
          <source>If you want to check that a file exists before you attempt to read it, and you might be deleting it and then you might be using multiple threads or processes, or another program knows about that file and could delete it - you risk the chance of a &lt;strong&gt;race condition&lt;/strong&gt; if you check it exists, because you are then &lt;em&gt;racing&lt;/em&gt; to open it before its &lt;em&gt;condition&lt;/em&gt; (its existence) changes.</source>
          <target state="translated">Если вы хотите проверить, что файл существует, прежде чем пытаться его прочитать, и, возможно, вы удаляете его, и тогда вы можете использовать несколько потоков или процессов, или другая программа знает об этом файле и может удалить его - вы рискуете состояние &lt;strong&gt;гонки,&lt;/strong&gt; если вы проверяете, существует ли оно, потому что вы &lt;em&gt;стремитесь&lt;/em&gt; открыть его до того, как его &lt;em&gt;состояние&lt;/em&gt; (его существование) изменится.</target>
        </trans-unit>
        <trans-unit id="b38cd90e47b8c32bc320b1b6ef26a7b9609fff52" translate="yes" xml:space="preserve">
          <source>If you want to read a file, if it exists, do</source>
          <target state="translated">Если вы хотите прочитать файл,если он существует,сделайте следующее.</target>
        </trans-unit>
        <trans-unit id="43244157b51e40292add122e42936b5161218cbf" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, if it doesn't exist, do</source>
          <target state="translated">Если вы хотите записать в файл,если его не существует,сделайте следующее.</target>
        </trans-unit>
        <trans-unit id="f4f1b207aadf8f5d760de13167e89765ef728de9" translate="yes" xml:space="preserve">
          <source>If you're not planning to open the file immediately, you can use &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;&lt;code&gt;os.path.isfile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Если вы не планируете открывать файл немедленно, вы можете использовать &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt; &lt;code&gt;os.path.isfile&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6070d8aef9d3e642476beafdb4d34a0fbf6fd11a" translate="yes" xml:space="preserve">
          <source>If you're on Python 2, you can backport the pathlib module from pypi, &lt;a href=&quot;https://pypi.python.org/pypi/pathlib2/&quot;&gt;&lt;code&gt;pathlib2&lt;/code&gt;&lt;/a&gt;, or otherwise check &lt;code&gt;isfile&lt;/code&gt; from the &lt;code&gt;os.path&lt;/code&gt; module:</source>
          <target state="translated">Если вы работаете на Python 2, вы можете перенести модуль pathlib &lt;a href=&quot;https://pypi.python.org/pypi/pathlib2/&quot;&gt; &lt;code&gt;pathlib2&lt;/code&gt; &lt;/a&gt; из pypi, pathlib2 или иначе проверить &lt;code&gt;isfile&lt;/code&gt; из модуля &lt;code&gt;os.path&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="304faa8fa6b0b859ff9cf1ffd4acaeb92c2f66b7" translate="yes" xml:space="preserve">
          <source>Importing &lt;code&gt;os&lt;/code&gt; makes it easier to navigate and perform standard actions with your operating system.</source>
          <target state="translated">Импорт ОС облегчает навигацию и выполнение стандартных действий с вашей операционной системой.</target>
        </trans-unit>
        <trans-unit id="6aeb39684e6a8d6e753f97adb8f35968468f0629" translate="yes" xml:space="preserve">
          <source>In 2016 the best way is still using &lt;code&gt;os.path.isfile&lt;/code&gt;:</source>
          <target state="translated">В 2016 году лучшим способом по-прежнему является использование &lt;code&gt;os.path.isfile&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="63858bed5a51687e64275119d3dc78c8c0d5f146" translate="yes" xml:space="preserve">
          <source>In 2016, this is still arguably the easiest way to check if both a file exists and if it is a file:</source>
          <target state="translated">В 2016 году это все еще,пожалуй,самый простой способ проверить,существует ли файл и является ли он файлом:</target>
        </trans-unit>
        <trans-unit id="53b8bae049e83f783d679add94d8c62730294a02" translate="yes" xml:space="preserve">
          <source>Install some third-party module with filesystem capabilities</source>
          <target state="translated">Установите сторонний модуль с возможностями файловой системы</target>
        </trans-unit>
        <trans-unit id="249f0dbd1b80d813ef272a820bd4e6ec0094f9c9" translate="yes" xml:space="preserve">
          <source>Instead hardcoding &lt;em&gt;libc&lt;/em&gt;'s path (&lt;em&gt;&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;&lt;/em&gt;) which may (and most likely, will) vary across systems, &lt;em&gt;None&lt;/em&gt; (or the empty string) can be passed to &lt;em&gt;CDLL&lt;/em&gt; constructor (&lt;strong&gt;&lt;code&gt;ctypes.CDLL(None).access(b&quot;/tmp&quot;, os.F_OK)&lt;/code&gt;&lt;/strong&gt;). According to &lt;a href=&quot;http://man7.org/linux/man-pages/man3/dlopen.3.html&quot;&gt;[man7]: DLOPEN(3)&lt;/a&gt;:</source>
          <target state="translated">Вместо этого, &lt;em&gt;жестко запрограммировав&lt;/em&gt; путь к &lt;em&gt;libc&lt;/em&gt; ( &lt;em&gt;&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;&lt;/em&gt; ), который может (и, скорее всего, будет) различаться в разных системах, &lt;em&gt;None&lt;/em&gt; (или пустая строка) можно &lt;em&gt;передать&lt;/em&gt; конструктору &lt;em&gt;CDLL&lt;/em&gt; ( &lt;strong&gt; &lt;code&gt;ctypes.CDLL(None).access(b&quot;/tmp&quot;, os.F_OK)&lt;/code&gt; &lt;/strong&gt; ). Согласно &lt;a href=&quot;http://man7.org/linux/man-pages/man3/dlopen.3.html&quot;&gt;[man7]: DLOPEN (3)&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c2456e210fee146ed3f8241baa370ef4e417d398" translate="yes" xml:space="preserve">
          <source>It also creates a context manager which, by unconditionally returning &lt;code&gt;True&lt;/code&gt;, allows all Exceptions (including &lt;code&gt;KeyboardInterrupt&lt;/code&gt; and &lt;code&gt;SystemExit&lt;/code&gt;!) to pass silently, which is a good way to hide bugs.</source>
          <target state="translated">Он также создает менеджер контекста, который, безоговорочно возвращая &lt;code&gt;True&lt;/code&gt; , позволяет всем исключениям (включая &lt;code&gt;KeyboardInterrupt&lt;/code&gt; и &lt;code&gt;SystemExit&lt;/code&gt; !) Проходить без вывода сообщений, что является хорошим способом скрыть ошибки.</target>
        </trans-unit>
        <trans-unit id="a8cd152693547cd306546c2c837671d8d018ed7f" translate="yes" xml:space="preserve">
          <source>It also suffers from the same race condition problems as &lt;code&gt;isfile&lt;/code&gt;. From the &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.access&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">Он также страдает от тех же проблем состояния гонки, что и &lt;code&gt;isfile&lt;/code&gt; . Из &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.access&quot;&gt;документов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4202a54228e33a8c91a54fe4ae0d3e882755b1c7" translate="yes" xml:space="preserve">
          <source>It doesn't seem like there's a meaningful functional difference between try/except and &lt;code&gt;isfile()&lt;/code&gt;, so you should use which one makes sense.</source>
          <target state="translated">Не похоже, что между try / исключением и &lt;code&gt;isfile()&lt;/code&gt; есть существенное функциональное различие, поэтому вы должны использовать, какой из них имеет смысл.</target>
        </trans-unit>
        <trans-unit id="dbc241143077ad988ba650982a25300f8fb789d3" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;os.listdir&lt;/code&gt; (&lt;code&gt;os.scandir&lt;/code&gt; when available)</source>
          <target state="translated">Он использует &lt;code&gt;os.listdir&lt;/code&gt; ( &lt;code&gt;os.scandir&lt;/code&gt; , когда доступно)</target>
        </trans-unit>
        <trans-unit id="327665da0521fd7ce34669658e33594ae8ff6a15" translate="yes" xml:space="preserve">
          <source>It's a fancier (and more &lt;em&gt;python&lt;/em&gt;ic) way of handling paths, &lt;strong&gt;but&lt;/strong&gt;</source>
          <target state="translated">Это более изящный (и более питонский) способ обработки путей, &lt;strong&gt;но&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0874e622984b8d8ed8d0111ced638b33c324993" translate="yes" xml:space="preserve">
          <source>Just to avoid confusion and based on the answers I got, current answer finds either a file &lt;strong&gt;or&lt;/strong&gt; a directory with the given name.</source>
          <target state="translated">Просто чтобы избежать путаницы и основываясь на полученных мной ответах, текущий ответ находит либо файл, &lt;strong&gt;либо&lt;/strong&gt; каталог с заданным именем.</target>
        </trans-unit>
        <trans-unit id="59f32559476324f232ad65e7d3e5c4edde71e7e4" translate="yes" xml:space="preserve">
          <source>Longer, much more pedantic answer</source>
          <target state="translated">Более длинный,гораздо более педантичный ответ</target>
        </trans-unit>
        <trans-unit id="342aaecc367b1d3941e496dfa36d36af27e2812d" translate="yes" xml:space="preserve">
          <source>Main (current) program (&lt;em&gt;python&lt;/em&gt;) is linked against &lt;em&gt;libc&lt;/em&gt;, so its symbols (including &lt;em&gt;access&lt;/em&gt;) will be loaded</source>
          <target state="translated">Основная (текущая) программа ( &lt;em&gt;python&lt;/em&gt; ) связана с &lt;em&gt;libc&lt;/em&gt; , поэтому ее символы (включая &lt;em&gt;доступ&lt;/em&gt; ) будут загружены</target>
        </trans-unit>
        <trans-unit id="4d15ee1ab2448fa179b92a1924e831dd8f0f9a47" translate="yes" xml:space="preserve">
          <source>Most likely, will rely on one of the ways above (maybe with slight customizations).</source>
          <target state="translated">Скорее всего,будет опираться на один из вышеперечисленных способов (возможно,с небольшими настройками).</target>
        </trans-unit>
        <trans-unit id="782942b5ea6c6ad77e95b9f86f2fa9c57b44eb41" translate="yes" xml:space="preserve">
          <source>Note1: The &lt;code&gt;os.path.isfile&lt;/code&gt; used only for files</source>
          <target state="translated">Примечание 1: &lt;code&gt;os.path.isfile&lt;/code&gt; используется только для файлов</target>
        </trans-unit>
        <trans-unit id="f4abfb7bebf2ffae4214d6fb5b83a497213ebf77" translate="yes" xml:space="preserve">
          <source>Note2: The &lt;code&gt;os.path.exists&lt;/code&gt; used for both files and directories</source>
          <target state="translated">Примечание 2: &lt;code&gt;os.path.exists&lt;/code&gt; используется как для файлов, так и для каталогов.</target>
        </trans-unit>
        <trans-unit id="c451b4b43107e20a1f539e1f362df3e8d96f9cf5" translate="yes" xml:space="preserve">
          <source>Note:
  Using access() to check if a user is authorized to e.g. open a file
  before actually doing so using open() creates a security hole, because
  the user might exploit the short time interval between checking and
  opening the file to manipulate it. It&amp;rsquo;s preferable to use EAFP
  techniques. For example:</source>
          <target state="translated">Примечание. Использование access () для проверки того, авторизован ли пользователь, например, открыть файл перед тем, как на самом деле это сделать, с помощью open () создает дыру в безопасности, поскольку пользователь может использовать короткий промежуток времени между проверкой и открытием файла для манипулирования им. Желательно использовать методики EAFP. Например:</target>
        </trans-unit>
        <trans-unit id="fed557bf7ca2300dfe5a352020d76469a9ceb724" translate="yes" xml:space="preserve">
          <source>Now available since Python 3.4, import and instantiate a &lt;code&gt;Path&lt;/code&gt; object with the file name, and check the &lt;code&gt;is_file&lt;/code&gt; method (note that this returns True for symlinks pointing to regular files as well):</source>
          <target state="translated">Доступный начиная с Python 3.4, импортируйте и создайте экземпляр объекта &lt;code&gt;Path&lt;/code&gt; с именем файла и проверьте метод &lt;code&gt;is_file&lt;/code&gt; (обратите внимание, что он возвращает True для символических ссылок, также указывающих на обычные файлы):</target>
        </trans-unit>
        <trans-unit id="0c2b0029788516df42324f1ddcb2a0d379462fca" translate="yes" xml:space="preserve">
          <source>Now the above is probably the best pragmatic direct answer here, but there's the possibility of a race condition (depending on what you're trying to accomplish), and the fact that the underlying implementation uses a &lt;code&gt;try&lt;/code&gt;, but Python uses &lt;code&gt;try&lt;/code&gt; everywhere in its implementation.</source>
          <target state="translated">Вышеприведенное, вероятно, является лучшим прагматическим прямым ответом здесь, но есть возможность условия гонки (в зависимости от того, что вы пытаетесь выполнить) и тот факт, что базовая реализация использует &lt;code&gt;try&lt;/code&gt; , но Python использует &lt;code&gt;try&lt;/code&gt; везде в своем реализация.</target>
        </trans-unit>
        <trans-unit id="9f1fcb7cb0c155a214cdcbeab2ea4d318d7dd89d" translate="yes" xml:space="preserve">
          <source>One example would be (again, &lt;em&gt;Win&lt;/em&gt; specific) &lt;a href=&quot;https://github.com/mhammond/pywin32&quot;&gt;[GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions&lt;/a&gt;, which is a &lt;em&gt;Python&lt;/em&gt; wrapper over &lt;em&gt;WINAPI&lt;/em&gt;s.</source>
          <target state="translated">Одним примером может быть (опять же, специфичный для &lt;em&gt;Win&lt;/em&gt; ) &lt;a href=&quot;https://github.com/mhammond/pywin32&quot;&gt;[GitHub]: mhammond / pywin32 - расширения Python для Windows (pywin32)&lt;/a&gt; , которые являются оболочкой &lt;em&gt;Python&lt;/em&gt; поверх &lt;em&gt;WINAPI&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5abbf84d7258a883758c744ea8454f1c4d043654" translate="yes" xml:space="preserve">
          <source>Opening the file will always verify the existence of the file. You can make a function just like so:</source>
          <target state="translated">При открытии файла всегда будет проверяться его существование.Вы можете сделать такую же функцию:</target>
        </trans-unit>
        <trans-unit id="3d75570821c532602afcda3cfc484e1ec0dd4b08" translate="yes" xml:space="preserve">
          <source>Or in Python 3 you can use &lt;code&gt;pathlib&lt;/code&gt;:</source>
          <target state="translated">Или в Python 3 вы можете использовать &lt;code&gt;pathlib&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6162f97d9d25399c4c7f1572eade2b73d9183fc2" translate="yes" xml:space="preserve">
          <source>Other options that don't meet the ask for &quot;without try&quot;:</source>
          <target state="translated">Другие варианты,которые не отвечают на просьбу &quot;без попытки&quot;:</target>
        </trans-unit>
        <trans-unit id="1abe02b8870cad9e8f6a481158089cd2d79cac6d" translate="yes" xml:space="preserve">
          <source>Perhaps easier with a try:</source>
          <target state="translated">Возможно,проще с попыткой:</target>
        </trans-unit>
        <trans-unit id="d9e7f16adc3452b0efdc8ccada6d3af30945b93c" translate="yes" xml:space="preserve">
          <source>Personally, I prefer this one because under the hood, it calls native APIs (via &quot;${PYTHON_SRC_DIR}/Modules/posixmodule.c&quot;), but it also opens a gate for possible user errors, and it's not as Pythonic as other variants:</source>
          <target state="translated">Лично я предпочитаю этот,потому что под капотом он вызывает нативные API (через &quot;${PYTHON_SRC_DIR}Modulesposixmodule.c&quot;),но также открывает ворота для возможных пользовательских ошибок,и он не такой Pythonic,как другие варианты:</target>
        </trans-unit>
        <trans-unit id="8e425b164973e8037f334709b9c9ce674d73968a" translate="yes" xml:space="preserve">
          <source>Prefer the try statement. It's considered better style and avoids race conditions.</source>
          <target state="translated">Предпочитаю попробовать.Считается лучшим стилем и избегает условий гонки.</target>
        </trans-unit>
        <trans-unit id="93744e02826bb08cbcaca9d0ccf769f1f6a80f48" translate="yes" xml:space="preserve">
          <source>Python 3.4 gives us the &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;&lt;code&gt;suppress&lt;/code&gt;&lt;/a&gt; context manager (previously the &lt;a href=&quot;https://bugs.python.org/issue19266&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt; context manager), which does semantically exactly the same thing in fewer lines, while also (at least superficially) meeting the original ask to avoid a &lt;code&gt;try&lt;/code&gt; statement:</source>
          <target state="translated">Python 3.4 предоставляет нам менеджер &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt; &lt;code&gt;suppress&lt;/code&gt; &lt;/a&gt; контекста (ранее менеджер &lt;a href=&quot;https://bugs.python.org/issue19266&quot;&gt; &lt;code&gt;ignore&lt;/code&gt; &lt;/a&gt; контекста), который выполняет семантически точно то же самое в меньшем количестве строк, а также (по крайней мере, поверхностно) отвечает первоначальному запросу, чтобы избежать оператора &lt;code&gt;try&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="88968d6bed87a24c3d5e8906af55bf32da38c015" translate="yes" xml:space="preserve">
          <source>Race Conditions: Why we like try</source>
          <target state="translated">Условия гонки:Почему мы любим пробовать</target>
        </trans-unit>
        <trans-unit id="522972b64fc54c50b69da77a6a1c4a50a9bb45a8" translate="yes" xml:space="preserve">
          <source>Race conditions are very hard to debug because there's a very small window in which they can cause your program to fail.</source>
          <target state="translated">Условия гонки очень трудно отлаживать,потому что есть очень маленькое окно,в котором они могут привести к сбою вашей программы.</target>
        </trans-unit>
        <trans-unit id="b2e1e799ac67777d3968b00f4cfe9b4b5a63a8e0" translate="yes" xml:space="preserve">
          <source>Raising exceptions is considered to be an acceptable, and Pythonic,
  approach for flow control in your program. Consider handling missing
  files with IOErrors. In this situation, an IOError exception will be
  raised if the file exists but the user does not have read permissions.</source>
          <target state="translated">Повышение исключений считается приемлемым,и Pythonic,подход для управления потоком в вашей программе.Рассмотрим обработку отсутствующих файлов с помощью IOErrors.В этой ситуации будет поднято исключение IOError,если файл существует,но у пользователя нет прав на чтение.</target>
        </trans-unit>
        <trans-unit id="398f6fa810da4cd445bcd4f6196261363faad467" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;path&lt;/em&gt; refers to an existing path or an open file descriptor. Returns &lt;code&gt;False&lt;/code&gt; for broken symbolic links. On some platforms, this function may return &lt;code&gt;False&lt;/code&gt; if permission is not granted to execute &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;os.stat()&lt;/a&gt; on the requested file, even if the &lt;em&gt;path&lt;/em&gt; physically exists.</source>
          <target state="translated">Верните &lt;code&gt;True&lt;/code&gt; , если &lt;em&gt;путь&lt;/em&gt; ссылается на существующий путь или дескриптор открытого файла. Возвращает &lt;code&gt;False&lt;/code&gt; для неработающих символических ссылок. На некоторых платформах эта функция может возвращать &lt;code&gt;False&lt;/code&gt; , если не предоставлено разрешение на выполнение &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;os.stat ()&lt;/a&gt; для запрошенного файла, даже если &lt;em&gt;путь&lt;/em&gt; физически существует.</target>
        </trans-unit>
        <trans-unit id="57fd7c3c54933cadd32199f06cbadaeaf8b6a887" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;True&lt;/code&gt; if path is an existing regular file. This follows symbolic links, so both &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.islink&quot;&gt;islink()&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;isfile()&lt;/a&gt; can be true for the same path.</source>
          <target state="translated">Верните &lt;code&gt;True&lt;/code&gt; , если путь - это существующий обычный файл. Это следует за символическими ссылками, поэтому и &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.islink&quot;&gt;islink (),&lt;/a&gt; и &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;isfile ()&lt;/a&gt; могут быть истинными для одного и того же пути.</target>
        </trans-unit>
        <trans-unit id="c416828ffe527204e9705ff84ac69c575514fa70" translate="yes" xml:space="preserve">
          <source>Return True if path is an existing regular file. This follows symbolic
  links, so both &lt;code&gt;islink()&lt;/code&gt; and &lt;code&gt;isfile()&lt;/code&gt; can be true for the same path.</source>
          <target state="translated">Верните True, если путь - это существующий обычный файл. Это следует за символическими ссылками, поэтому и &lt;code&gt;islink()&lt;/code&gt; и &lt;code&gt;isfile()&lt;/code&gt; могут быть истинными для одного и того же пути.</target>
        </trans-unit>
        <trans-unit id="480f0d6eca70fda19ed1cfd881e8db7b38b30b6d" translate="yes" xml:space="preserve">
          <source>SRC: &lt;a href=&quot;http://www.pfinn.net/python-check-if-file-exists.html&quot;&gt;http://www.pfinn.net/python-check-if-file-exists.html&lt;/a&gt;</source>
          <target state="translated">SRC: &lt;a href=&quot;http://www.pfinn.net/python-check-if-file-exists.html&quot;&gt;http://www.pfinn.net/python-check-if-file-exists.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="418acfb7d49ae4b9747a1895a7c2c368f346ec6b" translate="yes" xml:space="preserve">
          <source>Since I also work in &lt;em&gt;C&lt;/em&gt;, I use this method as well because under the hood, it calls &lt;strong&gt;native &lt;em&gt;API&lt;/em&gt;s&lt;/strong&gt; (again, via &lt;em&gt;&quot;${PYTHON_SRC_DIR}/Modules/posixmodule.c&quot;&lt;/em&gt;), but it also opens a gate for possible &lt;strong&gt;user errors&lt;/strong&gt;, and it's not as &lt;em&gt;Python&lt;/em&gt;ic as other variants. So, as @AaronHall rightly pointed out, don't use it unless you know what you're doing:</source>
          <target state="translated">Так как я также работаю в &lt;em&gt;C&lt;/em&gt; , я также использую этот метод, потому что внутри он вызывает &lt;strong&gt;собственные &lt;em&gt;API-интерфейсы&lt;/em&gt;&lt;/strong&gt; (опять же, через &lt;em&gt;&quot;$ {PYTHON_SRC_DIR} /Modules/posixmodule.c&quot;&lt;/em&gt; ), но он также открывает ворота для возможного &lt;strong&gt;пользователя. ошибки&lt;/strong&gt; , и это не так, как &lt;em&gt;Python&lt;/em&gt; ic, как другие варианты. Итак, как правильно заметил @AaronHall, не используйте его, если не знаете, что делаете:</target>
        </trans-unit>
        <trans-unit id="4e081acedac5348eeca514bf8754f18b5a2a5859" translate="yes" xml:space="preserve">
          <source>Since these iterate over folders, (in most of the cases) they are inefficient for our problem (there are exceptions, like non wildcarded &lt;em&gt;glob&lt;/em&gt;bing - as @ShadowRanger pointed out), so I'm not going to insist on them. Not to mention that in some cases, filename processing might be required.</source>
          <target state="translated">Так как они перебирают папки, (в большинстве случаев) они неэффективны для нашей проблемы (есть исключения, такие как глобальные переменные без подстановочных знаков - как указывал @ShadowRanger), поэтому я не буду настаивать на них. Не говоря уже о том, что в некоторых случаях может потребоваться обработка имени файла.</target>
        </trans-unit>
        <trans-unit id="ef8ad7d35edc8d5906794e416a2417426387ee33" translate="yes" xml:space="preserve">
          <source>So let's get a file that we know is a file:</source>
          <target state="translated">Так что давайте получим файл,который,как мы знаем,является файлом:</target>
        </trans-unit>
        <trans-unit id="2a3bb40ae80994d030f01c5b7c25d767f5b05a5b" translate="yes" xml:space="preserve">
          <source>So raising exceptions is considered to be an acceptable, and Pythonic, approach for flow control in your program. And one should consider handling missing files with IOErrors, rather than &lt;code&gt;if&lt;/code&gt; statements (&lt;em&gt;just an advice&lt;/em&gt;).</source>
          <target state="translated">Поэтому повышение исключений считается приемлемым и питонским подходом для управления потоком в вашей программе. И нужно рассмотреть обработку отсутствующих файлов с ошибками ввода-вывода, а не операторы &lt;code&gt;if&lt;/code&gt; ( &lt;em&gt;просто совет&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="fa536419723a345ff2ddb12f28c3d59d3c780110" translate="yes" xml:space="preserve">
          <source>So we need to use &lt;code&gt;is_file&lt;/code&gt;:</source>
          <target state="translated">Итак, нам нужно использовать &lt;code&gt;is_file&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a378bd712dd5bfae1cae597f5f9f871b3a2788bb" translate="yes" xml:space="preserve">
          <source>Starting with Python 3.4, the &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;&lt;code&gt;pathlib&lt;/code&gt; module&lt;/a&gt; offers an object-oriented approach (backported to &lt;code&gt;pathlib2&lt;/code&gt; in Python 2.7):</source>
          <target state="translated">Начиная с Python 3.4, &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;модуль &lt;code&gt;pathlib&lt;/code&gt; &lt;/a&gt; предлагает объектно-ориентированный подход ( &lt;code&gt;pathlib2&lt;/code&gt; в pathlib2 в Python 2.7):</target>
        </trans-unit>
        <trans-unit id="0411618e6c534569cfc6b8e34a18a081fb5d17d8" translate="yes" xml:space="preserve">
          <source>Style: Section &quot;Handling unusual conditions&quot; of &lt;a href=&quot;http://allendowney.com/sd/notes/notes11.txt&quot;&gt;http://allendowney.com/sd/notes/notes11.txt&lt;/a&gt;</source>
          <target state="translated">Стиль: раздел &amp;laquo;Работа с необычными условиями&amp;raquo; &lt;a href=&quot;http://allendowney.com/sd/notes/notes11.txt&quot;&gt;http://allendowney.com/sd/notes/notes11.txt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cde65e3e48762cf615039585856511edabc67b5c" translate="yes" xml:space="preserve">
          <source>Testing for files and folders with &lt;code&gt;os.path.isfile()&lt;/code&gt;, &lt;code&gt;os.path.isdir()&lt;/code&gt; and &lt;code&gt;os.path.exists()&lt;/code&gt;</source>
          <target state="translated">Тестирование файлов и папок с помощью &lt;code&gt;os.path.isfile()&lt;/code&gt; , &lt;code&gt;os.path.isdir()&lt;/code&gt; и &lt;code&gt;os.path.exists()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df18cbc4306e1fa89ca1399437058ce4f49db703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pathlib.Path&lt;/code&gt; method (included in Python 3+, installable with pip for Python 2)</source>
          <target state="translated">Метод &lt;code&gt;pathlib.Path&lt;/code&gt; (включен в Python 3+, устанавливается с помощью pip для Python 2)</target>
        </trans-unit>
        <trans-unit id="530b364f38885f326cd1f531e7470053b4411886" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Lnx&lt;/em&gt; (&lt;em&gt;Ubtu (16 x64)&lt;/em&gt;) counterpart as well:</source>
          <target state="translated">&lt;em&gt;Аналог Lnx&lt;/em&gt; ( &lt;em&gt;Ubtu (16 x64)&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="13a09abaae156d8f74be92cfd84bbc68f9b952e1" translate="yes" xml:space="preserve">
          <source>The code itself does not use a &lt;code&gt;try&lt;/code&gt; block&amp;hellip; except in determining the operating system and thus steering you to the &quot;Unix&quot;-style &lt;code&gt;find&lt;/code&gt; or the hand-buillt &lt;code&gt;find&lt;/code&gt;. Timing tests showed that the &lt;code&gt;try&lt;/code&gt; was faster in determining the OS, so I did use one there (but nowhere else).</source>
          <target state="translated">Сам код не использует блок &lt;code&gt;try&lt;/code&gt; &amp;hellip; за исключением определения операционной системы и, следовательно, перехода к &lt;code&gt;find&lt;/code&gt; стиле &amp;laquo;Unix&amp;raquo; или &amp;laquo;hand-buillt&amp;raquo;. Временные тесты показали, что &lt;code&gt;try&lt;/code&gt; была быстрее при определении ОС, поэтому я использовал ее там (но больше нигде).</target>
        </trans-unit>
        <trans-unit id="24d50f1641bf928a4330f0d682a38d4d97ffe256" translate="yes" xml:space="preserve">
          <source>The implementation, if you care to look, is here:
&lt;a href=&quot;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190&quot;&gt;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190&lt;/a&gt;</source>
          <target state="translated">Реализация, если вы хотите посмотреть, здесь: &lt;a href=&quot;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190&quot;&gt;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a74a8a63b22547ba3d5093ec5df9fef2c1e24790" translate="yes" xml:space="preserve">
          <source>The ouput would be:</source>
          <target state="translated">Упут будет:</target>
        </trans-unit>
        <trans-unit id="1865aad596e6ed9eb4f9647b68658f733fae4544" translate="yes" xml:space="preserve">
          <source>The pathlib module has lots of cool stuff in it: convenient globbing, checking file's owner, easier path joining, etc.  It's worth checking out.  If you're on an older Python (version 2.6 or later), you can still install pathlib with pip:</source>
          <target state="translated">В модуле pathlib много интересного:удобный глобус,проверка владельца файла,более легкое присоединение к пути и т.д.Это стоит проверить.Если вы находитесь на старом Python (версия 2.6 или более поздняя),вы всё равно можете установить pathlib с помощью pip:</target>
        </trans-unit>
        <trans-unit id="86939b2f23d78f6587e8899c5fbcad699b1fca6d" translate="yes" xml:space="preserve">
          <source>Then import it as follows:</source>
          <target state="translated">Затем импортируйте его следующим образом:</target>
        </trans-unit>
        <trans-unit id="10cf03aad058b6e2b5effd7477540fa9d0ac3551" translate="yes" xml:space="preserve">
          <source>Then, depending on the result, your program can just keep running from there or you can code to stop it if you want.</source>
          <target state="translated">Тогда,в зависимости от результата,ваша программа может просто продолжать работать оттуда или вы можете кодировать,чтобы остановить ее,если хотите.</target>
        </trans-unit>
        <trans-unit id="10303b9773cea55a7373894dca044a1fb0b21612" translate="yes" xml:space="preserve">
          <source>This allows common &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#try&quot;&gt;try&lt;/a&gt;...&lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#except&quot;&gt;except&lt;/a&gt;...&lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#finally&quot;&gt;finally&lt;/a&gt; usage patterns to be encapsulated for convenient reuse.</source>
          <target state="translated">Это позволяет инкапсулировать обычные &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#try&quot;&gt;попытки&lt;/a&gt; ... &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#except&quot;&gt;кроме&lt;/a&gt; ... &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#finally&quot;&gt;наконец,&lt;/a&gt; шаблонов использования для удобного повторного использования.</target>
        </trans-unit>
        <trans-unit id="013b8396ae1ec7be20358e949069add1eed3da4a" translate="yes" xml:space="preserve">
          <source>This answer says it prefers a non-Pythonic, error-prone method, with no justification. It seems to encourage users to use low-level APIs without understanding them.</source>
          <target state="translated">В этом ответе говорится,что он предпочитает непитонический,склонный к ошибкам метод,без всякого обоснования.Похоже,что он поощряет пользователей использовать низкоуровневые API,не понимая их.</target>
        </trans-unit>
        <trans-unit id="e34e91f34043e5905acc95f65395d3f7ae45d71b" translate="yes" xml:space="preserve">
          <source>This doesn't also apply to &lt;em&gt;Win&lt;/em&gt; (but that's not such a big deal, since &lt;em&gt;msvcrt.dll&lt;/em&gt; is located in &lt;em&gt;&quot;%SystemRoot%\System32&quot;&lt;/em&gt; which is in &lt;em&gt;%PATH%&lt;/em&gt; by default). I wanted to take things further and replicate this behavior on &lt;em&gt;Win&lt;/em&gt; (and submit a patch), but as it turns out, &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress&quot;&gt;[MS.Docs]: GetProcAddress function&lt;/a&gt; only &quot;sees&quot; &lt;strong&gt;exported&lt;/strong&gt; symbols, so unless someone declares the functions in the main executable as &lt;code&gt;__declspec(dllexport)&lt;/code&gt; (why on Earth the &lt;em&gt;regular&lt;/em&gt; person would do that?), the main program is loadable but pretty much unusable</source>
          <target state="translated">Это также не относится к &lt;em&gt;Win&lt;/em&gt; (но это не такая уж большая проблема, поскольку &lt;em&gt;msvcrt.dll&lt;/em&gt; находится в &lt;em&gt;&quot;% SystemRoot% \ System32&quot;,&lt;/em&gt; который по умолчанию находится в &lt;em&gt;% PATH%&lt;/em&gt; ). Я хотел пойти дальше и повторить это поведение на &lt;em&gt;Win&lt;/em&gt; (и отправить патч), но, как оказалось, &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress&quot;&gt;[MS.Docs]: функция GetProcAddress&lt;/a&gt; только &amp;laquo;видит&amp;raquo; &lt;strong&gt;экспортированные&lt;/strong&gt; символы, поэтому, если кто-то не объявит функции в основном исполняемом файле как &lt;code&gt;__declspec(dllexport)&lt;/code&gt; (почему на Земле &lt;em&gt;обычный&lt;/em&gt; человек будет делать это?), основная программа загружаема, но в значительной степени непригодна для использования</target>
        </trans-unit>
        <trans-unit id="7d512ce20a34ce68ebd3c6ebeb6e56887b5b877e" translate="yes" xml:space="preserve">
          <source>This has to be handled with care, since functions like &lt;em&gt;main&lt;/em&gt;, &lt;em&gt;Py_Main&lt;/em&gt; and (all the) others are available; calling them could have disastrous effects (on the current program)</source>
          <target state="translated">С этим нужно обращаться осторожно, так как &lt;em&gt;доступны&lt;/em&gt; такие функции, как &lt;em&gt;main&lt;/em&gt; , &lt;em&gt;Py_Main&lt;/em&gt; и (все остальные); их вызов может иметь катастрофические последствия (для текущей программы)</target>
        </trans-unit>
        <trans-unit id="ada1dec3ed33a08f60c128b70954cbdb8457037b" translate="yes" xml:space="preserve">
          <source>This is the simplest way to check if a file exists. Just &lt;strong&gt;because&lt;/strong&gt; the file existed when you checked doesn't &lt;strong&gt;guarantee&lt;/strong&gt; that it will be there when you need to open it.</source>
          <target state="translated">Это самый простой способ проверить, существует ли файл. Тот факт, &lt;strong&gt;что&lt;/strong&gt; файл существовал при проверке, не &lt;strong&gt;гарантирует,&lt;/strong&gt; что он будет там, когда вам нужно его открыть.</target>
        </trans-unit>
        <trans-unit id="faf24dd71990fb8b6a4f9fda6ae044c126abf438" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;True&lt;/code&gt; for both files and directories but you can instead use</source>
          <target state="translated">Это возвращает &lt;code&gt;True&lt;/code&gt; как для файлов, так и для каталогов, но вместо этого вы можете использовать</target>
        </trans-unit>
        <trans-unit id="dd377f1e075e1a6762708def8e94ab1cc954e78d" translate="yes" xml:space="preserve">
          <source>This seems to encourage users to adopt poor practices.</source>
          <target state="translated">Это,по-видимому,побуждает пользователей перенимать некачественную практику.</target>
        </trans-unit>
        <trans-unit id="1ebd1badf365b531b3f784e4041ddcafc927cdcf" translate="yes" xml:space="preserve">
          <source>This will check the existence of what you specify. However, it checks for files &lt;em&gt;and&lt;/em&gt; directories so beware about how you use it.</source>
          <target state="translated">Это проверит наличие того, что вы укажете. Тем не менее, он проверяет файлы &lt;em&gt;и&lt;/em&gt; каталоги, поэтому будьте осторожны с тем, как вы его используете.</target>
        </trans-unit>
        <trans-unit id="599782e6dcde6e17a96f8d011122afca2b083bc5" translate="yes" xml:space="preserve">
          <source>This will check whether you have access to the file. It will check for permissions. Based on the os.py documentation, typing in &lt;code&gt;os.F_OK&lt;/code&gt;, it will check the existence of the path. However, using this will create a security hole, as someone can attack your file using the time between checking the permissions and opening the file. You should instead go directly to opening the file instead of checking its permissions. (&lt;a href=&quot;https://docs.python.org/2/glossary.html#term-eafp&quot;&gt;EAFP&lt;/a&gt; vs &lt;a href=&quot;https://docs.python.org/2/glossary.html#term-lbyl&quot;&gt;LBYP&lt;/a&gt;). If you're not going to open the file afterwards, and only checking its existence, then you can use this.</source>
          <target state="translated">Это проверит, есть ли у вас доступ к файлу. Он проверит разрешения. На основании документации os.py, введя &lt;code&gt;os.F_OK&lt;/code&gt; , он проверит наличие пути. Однако использование этого создаст дыру в безопасности, поскольку кто-то может атаковать ваш файл, используя время между проверкой прав доступа и открытием файла. Вместо этого вам следует перейти непосредственно к открытию файла вместо проверки его прав доступа. ( &lt;a href=&quot;https://docs.python.org/2/glossary.html#term-lbyl&quot;&gt;EAFP&lt;/a&gt; против LBYP ). Если вы не собираетесь открывать файл впоследствии, а только проверяете его существование, то вы можете использовать это.</target>
        </trans-unit>
        <trans-unit id="5b5ffcaf081dc75e6b418d427d70f91a6d9dec08" translate="yes" xml:space="preserve">
          <source>This will handle the case of the &lt;code&gt;file_path&lt;/code&gt; being &lt;code&gt;None&lt;/code&gt; or empty string.</source>
          <target state="translated">Это будет обрабатывать случай, когда &lt;code&gt;file_path&lt;/code&gt; является &lt;code&gt;None&lt;/code&gt; или пустой строкой.</target>
        </trans-unit>
        <trans-unit id="8dba64974b8642857ae28899a73df6c30d03c303" translate="yes" xml:space="preserve">
          <source>This will return true or false based on its existence.</source>
          <target state="translated">Это вернёт истину или ложь,основанную на её существовании.</target>
        </trans-unit>
        <trans-unit id="fc31e69259d13bfced912cfbab7ad7e00fd46dea" translate="yes" xml:space="preserve">
          <source>To check a directory, do:</source>
          <target state="translated">Чтобы проверить каталог,сделайте:</target>
        </trans-unit>
        <trans-unit id="3416f5cb91745acbdaae2a2dddc268e01225ffdb" translate="yes" xml:space="preserve">
          <source>To check whether a &lt;code&gt;Path&lt;/code&gt; object exists independently of whether is it a file or directory, use &lt;code&gt;exists()&lt;/code&gt;:</source>
          <target state="translated">Чтобы проверить, существует ли объект &lt;code&gt;Path&lt;/code&gt; независимо от того, является ли он файлом или каталогом, используйте &lt;code&gt;exists()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e5ffee0a503a306dd9fb72ef88ce41742e995a7" translate="yes" xml:space="preserve">
          <source>Try opening the file:</source>
          <target state="translated">Попробуйте открыть файл:</target>
        </trans-unit>
        <trans-unit id="1a4e2dce5d6775f3efc5d392dd7dcfbb9813ec34" translate="yes" xml:space="preserve">
          <source>Under the hood, both use:</source>
          <target state="translated">Под капотом,оба используют:</target>
        </trans-unit>
        <trans-unit id="c78de1502fda99e6b39752620575aa8b8af55212" translate="yes" xml:space="preserve">
          <source>Under the hood, it does &lt;strong&gt;exactly&lt;/strong&gt; the same thing (&lt;em&gt;pathlib.py&lt;/em&gt;, line &lt;em&gt;~#1330&lt;/em&gt;):</source>
          <target state="translated">Под капотом он делает то же самое ( &lt;em&gt;pathlib.py&lt;/em&gt; , строка &lt;em&gt;~ # 1330&lt;/em&gt; ):</target>
        </trans-unit>
        <trans-unit id="0c4dd154e57d3342872a767d4176641c8fc8402b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;&lt;code&gt;isfile()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;True&lt;/code&gt; for directories. So depending on if you want only plain files or also directories, you'll use &lt;code&gt;isfile()&lt;/code&gt; or &lt;code&gt;exists()&lt;/code&gt;. Here is some simple REPL output:</source>
          <target state="translated">В отличие от &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt; &lt;code&gt;isfile()&lt;/code&gt; &lt;/a&gt; , exist () вернет &lt;code&gt;True&lt;/code&gt; для каталогов. Таким образом, в зависимости от того, хотите ли вы только простые файлы или каталоги, вы будете использовать &lt;code&gt;isfile()&lt;/code&gt; или exist &lt;code&gt;exists()&lt;/code&gt; . Вот простой вывод REPL:</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="6528187d8e91a930203288ed63867c1ae3e26091" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.isfile&quot;&gt;&lt;code&gt;os.path.isfile()&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://docs.python.org/3.3/library/os.html?highlight=os.access#os.access&quot;&gt;&lt;code&gt;os.access()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Используйте &lt;a href=&quot;https://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.isfile&quot;&gt; &lt;code&gt;os.path.isfile()&lt;/code&gt; &lt;/a&gt; с &lt;a href=&quot;https://docs.python.org/3.3/library/os.html?highlight=os.access#os.access&quot;&gt; &lt;code&gt;os.access()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8395433c21c6033081f4203a964dbda841229f43" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;[Python 3]: contextlib.&lt;strong&gt;suppress&lt;/strong&gt;(&lt;em&gt;*exceptions&lt;/em&gt;)&lt;/a&gt; - which was &lt;strong&gt;specifically&lt;/strong&gt; designed for selectively suppressing exceptions</source>
          <target state="translated">Используйте &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;[Python 3]: contextlib.&lt;/a&gt; &lt;strong&gt;подавить&lt;/strong&gt; ( &lt;em&gt;* исключения&lt;/em&gt; ) - который был &lt;strong&gt;специально&lt;/strong&gt; разработан для выборочного подавления исключений</target>
        </trans-unit>
        <trans-unit id="63dca5b17c3d20c3489afb0a2fce135a332440f1" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;os.access(path, mode)&lt;/code&gt;:</source>
          <target state="translated">Используйте &lt;code&gt;os.access(path, mode)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ccb25d19aa4f439e92c039f06e2c08c0d55c6044" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;os.path.exists(path)&lt;/code&gt;:</source>
          <target state="translated">Используйте &lt;code&gt;os.path.exists(path)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a09130d4064cb71241e9c92eb3d5f5998cbbe1e5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;scandir()&lt;/a&gt; instead of &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;listdir()&lt;/a&gt; can significantly increase the performance of code that also needs file type or file attribute information, because &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; objects expose this information if the operating system provides it when scanning a directory. All &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; methods may perform a system call, but &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_dir&quot;&gt;is_dir()&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_file&quot;&gt;is_file()&lt;/a&gt; usually only require a system call for symbolic links; &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.stat&quot;&gt;os.DirEntry.stat()&lt;/a&gt; always requires a system call on Unix but only requires one for symbolic links on Windows.</source>
          <target state="translated">Использование &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;scandir ()&lt;/a&gt; вместо &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;listdir ()&lt;/a&gt; может значительно повысить производительность кода, который также нуждается в информации о типе файла или атрибуте файла, поскольку объекты &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; предоставляют эту информацию, если операционная система предоставляет ее при сканировании каталога. Все методы &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; могут выполнять системный вызов, но для &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_dir&quot;&gt;is_dir ()&lt;/a&gt; и &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_file&quot;&gt;is_file ()&lt;/a&gt; обычно требуется только системный вызов для символических ссылок; &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.stat&quot;&gt;os.DirEntry.stat ()&lt;/a&gt; всегда требует системного вызова в Unix, но требует только одного для символических ссылок в Windows.</target>
        </trans-unit>
        <trans-unit id="3c602deb97ce7542bfccf83d47fe88cf36a2893d" translate="yes" xml:space="preserve">
          <source>We like &lt;code&gt;try&lt;/code&gt; because it avoids race conditions. With &lt;code&gt;try&lt;/code&gt;, you simply attempt to read your file, expecting it to be there, and if not, you catch the exception and perform whatever fallback behavior makes sense.</source>
          <target state="translated">Нам нравится &lt;code&gt;try&lt;/code&gt; потому что это избегает условий гонки. С помощью &lt;code&gt;try&lt;/code&gt; вы просто пытаетесь прочитать свой файл, ожидая, что он будет там, а если нет, то перехватываете исключение и выполняете любое резервное поведение, которое имеет смысл.</target>
        </trans-unit>
        <trans-unit id="11dee24909df97ffd7167218bba605d1194d35d4" translate="yes" xml:space="preserve">
          <source>You can (and usually should) still use a &lt;code&gt;try/except&lt;/code&gt; block when opening files:</source>
          <target state="translated">Вы можете (и обычно должны) по-прежнему использовать блок &lt;code&gt;try/except&lt;/code&gt; при открытии файлов:</target>
        </trans-unit>
        <trans-unit id="7784bbbe5a5c336f12d286e297f0803a9fe8d487" translate="yes" xml:space="preserve">
          <source>You can also test if a file is a certain type of file using &lt;code&gt;os.path.splitext()&lt;/code&gt; to get the extension (if you don't already know it)</source>
          <target state="translated">Вы также можете проверить, является ли файл файлом определенного типа, используя &lt;code&gt;os.path.splitext()&lt;/code&gt; чтобы получить расширение (если вы его еще не знаете)</target>
        </trans-unit>
        <trans-unit id="53df035e05c38ef007ca2b8b29347ccc17e7055d" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;resolve(strict=True)&lt;/code&gt; in a &lt;code&gt;try&lt;/code&gt; block:</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;resolve(strict=True)&lt;/code&gt; в блоке &lt;code&gt;try&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f01e601cacd481f5c7f35810b916f8e0b34e1dd" translate="yes" xml:space="preserve">
          <source>You can follow these three ways:</source>
          <target state="translated">Ты можешь следовать этим трем путям:</target>
        </trans-unit>
        <trans-unit id="ec8dda8508e059554be2c9405118015a0d4115f7" translate="yes" xml:space="preserve">
          <source>You can use the &quot;OS&quot; library of Python:</source>
          <target state="translated">Вы можете использовать библиотеку &quot;OS&quot; на Python:</target>
        </trans-unit>
        <trans-unit id="939818830bc616c3a6efeac98f780e2a1d405b44" translate="yes" xml:space="preserve">
          <source>You can write Brian's suggestion without the &lt;code&gt;try:&lt;/code&gt;.</source>
          <target state="translated">Вы можете написать предложение Брайана без &lt;code&gt;try:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="286ccde47046b9cee19cb126d447184993fbb983" translate="yes" xml:space="preserve">
          <source>You could try this (safer):</source>
          <target state="translated">Ты можешь попробовать это (безопаснее):</target>
        </trans-unit>
        <trans-unit id="98a04bbfd86344a14e1ecd9d2cb153c157a6b79b" translate="yes" xml:space="preserve">
          <source>You have the &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.exists&quot;&gt;&lt;code&gt;os.path.exists&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">У вас есть функция &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.exists&quot;&gt; &lt;code&gt;os.path.exists&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ea7a34811c2492dcaa209ef15806e5b61c87b16f" translate="yes" xml:space="preserve">
          <source>[Python 3]: os.&lt;strong&gt;walk&lt;/strong&gt;(&lt;em&gt;top, topdown=True, onerror=None, followlinks=False&lt;/em&gt;)</source>
          <target state="translated">[Python 3]: ос. &lt;strong&gt;ходьба&lt;/strong&gt; ( &lt;em&gt;top, topdown = True, onerror = None, последующие ссылки = False&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="9ffb459d6d30faf56bdf32fa749719a501413758" translate="yes" xml:space="preserve">
          <source>from the &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">из &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;документов&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="be73dd7f4e02100df1866e6ae1905b8fb136de60" translate="yes" xml:space="preserve">
          <source>if you need to be sure it's a file.</source>
          <target state="translated">если тебе нужно быть уверенным,что это файл.</target>
        </trans-unit>
        <trans-unit id="6adfed45fd2ed1ca17a5706197051fb6c6c02690" translate="yes" xml:space="preserve">
          <source>is better written as:</source>
          <target state="translated">лучше написано как:</target>
        </trans-unit>
        <trans-unit id="625ab49ea896effef76c5e7d9931ab9b626630f8" translate="yes" xml:space="preserve">
          <source>it's just a &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; block around &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;[Python 3]: os.&lt;strong&gt;stat&lt;/strong&gt;(&lt;em&gt;path, *, dir_fd=None, follow_symlinks=True&lt;/em&gt;)&lt;/a&gt;. So, your code is &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; free, but lower in the framestack there's (at least) &lt;strong&gt;one&lt;/strong&gt; such block. This also applies to other funcs (&lt;strong&gt;including&lt;/strong&gt;&lt;code&gt;os.path.isfile&lt;/code&gt;).</source>
          <target state="translated">это просто блок &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;исключением&lt;/em&gt;&lt;/strong&gt; &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;[Python 3]: os.&lt;/a&gt; &lt;strong&gt;stat&lt;/strong&gt; ( &lt;em&gt;путь, *, dir_fd = нет, follow_symlinks = True&lt;/em&gt; ) . Итак, ваш код &lt;strong&gt;&lt;em&gt;попробуйте&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;за исключением&lt;/em&gt;&lt;/strong&gt; бесплатного, но ниже в стеке фреймов есть (по крайней мере) &lt;strong&gt;один&lt;/strong&gt; такой блок. Это также относится к другим функциям ( &lt;strong&gt;включая&lt;/strong&gt; &lt;code&gt;os.path.isfile&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2425e7713a0225c18ca0b17f07467bbaaa179274" translate="yes" xml:space="preserve">
          <source>to test if it's a file specifically. It follows symlinks.</source>
          <target state="translated">чтобы проверить,если это именно файл.Он следует за симлинками.</target>
        </trans-unit>
        <trans-unit id="6abf28170f947a4e00093db1c0c8dcdabc461e0d" translate="yes" xml:space="preserve">
          <source>via &lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/posixmodule.c&quot;&gt;[GitHub]: python/cpython - (master) cpython/Modules/posixmodule.c&lt;/a&gt;</source>
          <target state="translated">через &lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/posixmodule.c&quot;&gt;[GitHub]: python / cpython - (основной) cpython / Modules / posixmodule.c&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
