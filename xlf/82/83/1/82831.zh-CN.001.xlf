<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/82831">
    <body>
      <group id="82831">
        <trans-unit id="c57a62c684c9ba50ef4276461ac8271cc4409e22" translate="yes" xml:space="preserve">
          <source>(&lt;strong&gt;&lt;em&gt;Win&lt;/em&gt;&lt;/strong&gt; specific): Since &lt;em&gt;vcruntime*&lt;/em&gt; (&lt;em&gt;msvcr*&lt;/em&gt;) &lt;em&gt;.dll&lt;/em&gt; exports a &lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=vs-2015&quot;&gt;[MS.Docs]: _access, _waccess&lt;/a&gt; function family as well, here's an example:</source>
          <target state="translated">（特定于&lt;strong&gt;&lt;em&gt;Win&lt;/em&gt;&lt;/strong&gt; ）：由于&lt;em&gt;vcruntime *&lt;/em&gt; （ &lt;em&gt;msvcr *&lt;/em&gt; ）. &lt;em&gt;dll&lt;/em&gt;导出&lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/access-waccess?view=vs-2015&quot;&gt;[MS.Docs]：_access，_waccess&lt;/a&gt;函数族，因此以下示例：</target>
        </trans-unit>
        <trans-unit id="40424e2404c07b5e06b147f732d917ab30140356" translate="yes" xml:space="preserve">
          <source>([Errno 2] No such file or directory:
  'whatever.txt')</source>
          <target state="translated">([Errno 2]没有这样的文件或目录:'whatever.txt')</target>
        </trans-unit>
        <trans-unit id="47357201492ecc28a3c7f77186ebaf58446769e4" translate="yes" xml:space="preserve">
          <source>...test if the invoking user has the specified access to &lt;em&gt;path&lt;/em&gt;. &lt;em&gt;mode&lt;/em&gt; should be &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.F_OK&quot;&gt;F_OK&lt;/a&gt; to test the existence of path...</source>
          <target state="translated">...测试调用用户是否具有对&lt;em&gt;path&lt;/em&gt;的指定访问权限。 &lt;em&gt;模式&lt;/em&gt;应该为&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.F_OK&quot;&gt;F_OK&lt;/a&gt;以测试路径的存在...</target>
        </trans-unit>
        <trans-unit id="787fad3e2ffee45a57341c551ccca124f8b07869" translate="yes" xml:space="preserve">
          <source>1.1. &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;[Python 3]: Path.&lt;strong&gt;is_file&lt;/strong&gt;()&lt;/a&gt;</source>
          <target state="translated">1.1。 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;[Python 3]：路径。&lt;/a&gt; &lt;strong&gt;is_file&lt;/strong&gt; （）</target>
        </trans-unit>
        <trans-unit id="84da2f4e22fc9c7b904c3bcfae38c0e0ce23d934" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.iglob&quot;&gt;[Python 3]: glob.&lt;strong&gt;iglob&lt;/strong&gt;(&lt;em&gt;pathname, *, recursive=False&lt;/em&gt;)&lt;/a&gt; (or its predecessor: &lt;code&gt;glob.glob&lt;/code&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/glob.html#glob.iglob&quot;&gt;[Python 3]：glob。&lt;/a&gt; &lt;strong&gt;iglob&lt;/strong&gt; （ &lt;em&gt;pathname，*，recursive = False&lt;/em&gt; ） （或其前身： &lt;code&gt;glob.glob&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a32d328d73882905860fd2807cd7c44ceaaa3322" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;[Python 3]: os.&lt;strong&gt;access&lt;/strong&gt;(&lt;em&gt;path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True&lt;/em&gt;)&lt;/a&gt; whose behavior is close to &lt;code&gt;os.path.exists&lt;/code&gt; (actually it's wider, mainly because of the 2&lt;sup&gt;nd&lt;/sup&gt; argument)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;[Python 3]：操作系统。&lt;/a&gt; 行为接近 &lt;code&gt;os.path.exists&lt;/code&gt; 的 &lt;strong&gt;访问&lt;/strong&gt; （ &lt;em&gt;path，mode，*，dir_fd = None，Effective_ids = False，follow_symlinks = True&lt;/em&gt; ） （实际上它更宽，主要是由于&lt;sup&gt;第二个&lt;/sup&gt;参数）</target>
        </trans-unit>
        <trans-unit id="4156cef8783a6c3af93cebc9154ef17488855064" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;[Python 3]: os.&lt;strong&gt;listdir&lt;/strong&gt;(&lt;em&gt;path='.'&lt;/em&gt;)&lt;/a&gt; (or &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;[Python 3]: os.&lt;strong&gt;scandir&lt;/strong&gt;(&lt;em&gt;path='.'&lt;/em&gt;)&lt;/a&gt; on &lt;em&gt;Python v&lt;strong&gt;3.5&lt;/strong&gt;&lt;/em&gt;+, backport: &lt;a href=&quot;https://pypi.org/project/scandir&quot;&gt;[PyPI]: scandir&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;[Python 3]：操作系统。&lt;/a&gt; &lt;strong&gt;listdir&lt;/strong&gt; （ &lt;em&gt;path ='。'&lt;/em&gt; ） （或在&lt;em&gt;Python v &lt;strong&gt;3.5&lt;/strong&gt;&lt;/em&gt; +上的&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;[Python 3]：操作系统&lt;strong&gt;scandir&lt;/strong&gt; （ &lt;em&gt;path ='。'&lt;/em&gt; ）&lt;/a&gt; ，向后移植： &lt;a href=&quot;https://pypi.org/project/scandir&quot;&gt;[PyPI]：scandir&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="881c94c992f5c2704f7aea54c69305fd8520f3b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/os.path.html#os.path.exists&quot;&gt;[Python 3]: os.path.&lt;strong&gt;exists&lt;/strong&gt;(&lt;em&gt;path&lt;/em&gt;)&lt;/a&gt; (also check other function family members like &lt;code&gt;os.path.isfile&lt;/code&gt;, &lt;code&gt;os.path.isdir&lt;/code&gt;, &lt;code&gt;os.path.lexists&lt;/code&gt; for slightly different behaviors)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.path.html#os.path.exists&quot;&gt;[Python 3]：os.path。&lt;/a&gt; &lt;strong&gt;存在&lt;/strong&gt; （ &lt;em&gt;path&lt;/em&gt; ） （也请检查其他函数族成员，例如 &lt;code&gt;os.path.isfile&lt;/code&gt; ， &lt;code&gt;os.path.isdir&lt;/code&gt; 和 &lt;code&gt;os.path.lexists&lt;/code&gt; 的行为是否稍有不同）</target>
        </trans-unit>
        <trans-unit id="16a9582fc6e61500a615bb32272726f039a6dea9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#context-managers&quot;&gt;[Python 3]: With Statement Context Managers&lt;/a&gt;. Either:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#context-managers&quot;&gt;[Python 3]：使用语句上下文管理器&lt;/a&gt; 。 要么：</target>
        </trans-unit>
        <trans-unit id="e7facdf0dc4a8e14a1a54deddc2ccf73d6d27185" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isfile&lt;/code&gt; is actually just a helper method that internally uses &lt;code&gt;os.stat&lt;/code&gt; and &lt;code&gt;stat.S_ISREG(mode)&lt;/code&gt; underneath. This &lt;code&gt;os.stat&lt;/code&gt; is a lower-level method that will provide you with detailed information about files, directories, sockets, buffers, and more. &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.stat&quot;&gt;More about os.stat here&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;isfile&lt;/code&gt; 实际上只是一个内部使用 &lt;code&gt;os.stat&lt;/code&gt; 和 &lt;code&gt;stat.S_ISREG(mode)&lt;/code&gt; 的辅助方法。 此 &lt;code&gt;os.stat&lt;/code&gt; 是一个较低层的方法，它将为您提供有关文件，目录，套接字，缓冲区等的详细信息。 &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.stat&quot;&gt;有关os.stat的更多信息，请点击此处&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56f16f3fd911d49aaf5aa425fc05be5bcc4d128b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os.path&lt;/code&gt; - &lt;em&gt;posixpath.py&lt;/em&gt; (&lt;em&gt;ntpath.py&lt;/em&gt;)</source>
          <target state="translated">&lt;em&gt;os.path-posixpath.py&lt;/em&gt; （ &lt;em&gt;ntpath.py&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="c213153b48aa1adfe737e87d17e184e0df446764" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suppress&lt;/code&gt; is part of Python 3.4. In older releases you can quickly write your own suppress:</source>
          <target state="translated">&lt;code&gt;suppress&lt;/code&gt; 是Python 3.4的一部分。 在较早的发行版中，您可以快速编写自己的隐匿：</target>
        </trans-unit>
        <trans-unit id="7341feac8a06399cdfbd59912dc1807dd4972e4d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nix&lt;/em&gt; (&lt;em&gt;Lnx&lt;/em&gt; (&lt;em&gt;Ubtu&lt;/em&gt;)):</source>
          <target state="translated">&lt;em&gt;尼克斯&lt;/em&gt; （ &lt;em&gt;Lnx&lt;/em&gt; （ &lt;em&gt;Ubtu&lt;/em&gt; ））：</target>
        </trans-unit>
        <trans-unit id="bcc27befb6f3b8f2dfa82be82a68582f296622aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nix&lt;/em&gt;: &lt;a href=&quot;http://man7.org/linux/man-pages/man2/access.2.html&quot;&gt;[man7]: ACCESS(2)&lt;/a&gt; (!!! pay attention to the note about the &lt;strong&gt;security hole&lt;/strong&gt; its usage might introduce !!!)</source>
          <target state="translated">&lt;em&gt;Nix&lt;/em&gt; ： &lt;a href=&quot;http://man7.org/linux/man-pages/man2/access.2.html&quot;&gt;[man7]：ACCESS（2）&lt;/a&gt; （!!!请注意有关其用法可能引入的&lt;strong&gt;安全漏洞&lt;/strong&gt;的注意事项！！！）</target>
        </trans-unit>
        <trans-unit id="a16adeeb8960035b0fa48ff747e9036d84b7fac1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nix&lt;/em&gt;: &lt;a href=&quot;http://man7.org/linux/man-pages/man3/opendir.3.html&quot;&gt;[man7]: OPENDIR(3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/readdir.3.html&quot;&gt;[man7]: READDIR(3)&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/closedir.3.html&quot;&gt;[man7]: CLOSEDIR(3)&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Nix&lt;/em&gt; ： &lt;a href=&quot;http://man7.org/linux/man-pages/man3/opendir.3.html&quot;&gt;[man7]：OPENDIR（3）&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/readdir.3.html&quot;&gt;[man7]：READDIR（3）&lt;/a&gt; / &lt;a href=&quot;http://man7.org/linux/man-pages/man3/closedir.3.html&quot;&gt;[man7]：CLOSEDIR（3）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e3e7e3a1bf52b57f359fffd279b3063aa9c1eab" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Win&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Win&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="672cf7faded202b7034a24292acbf961c1694c7b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Win&lt;/em&gt;: &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew&quot;&gt;[MS.Docs]: FindFirstFileW function&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew&quot;&gt;[MS.Docs]: FindNextFileW function&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose&quot;&gt;[MS.Docs]: FindClose function&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Win&lt;/em&gt; ： &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findfirstfilew&quot;&gt;[MS.Docs]：FindFirstFileW函数&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findnextfilew&quot;&gt;[MS.Docs]：FindNextFileW函数&lt;/a&gt; / &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-findclose&quot;&gt;[MS.Docs]：FindClose函数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="918e9fb58193867f89f5a410d74811d1771b2724" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Win&lt;/em&gt;: &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-getfileattributesw&quot;&gt;[MS.Docs]: GetFileAttributesW function&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;赢&lt;/em&gt; ： &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/fileapi/nf-fileapi-getfileattributesw&quot;&gt;[MS.Docs]：GetFileAttributesW函数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d6ed7dbc3e0f962103d4c625797662e29aa9184" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;genericpath.py&lt;/em&gt;, line &lt;em&gt;~#20+&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;genericpath.py&lt;/em&gt; ，第&lt;em&gt;〜＃20 +行&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="423d8236f9dc3da510581f0ee3fbcd477ede396d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bottom line&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;底线&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="2b621694fd99fa555aa2279458b5f4cee2e246ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do&lt;/strong&gt; use &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; blocks, because they can prevent you running into a series of nasty problems. A counter-example that I can think of, is performance: such blocks are costly, so try not to place them in code that it's supposed to run hundreds of thousands times per second (but since (in most cases) it involves disk access, it won't be the case).</source>
          <target state="translated">&lt;strong&gt;请&lt;/strong&gt;使用&lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt;块，因为它们可以防止您遇到一系列令人讨厌的问题。 我可以想到的一个反例是性能：此类块非常昂贵，因此请不要将它们放在应该每秒运行数十万次的代码中（但是（在大多数情况下，由于它涉及磁盘访问，事实并非如此）。</target>
        </trans-unit>
        <trans-unit id="114c46c58943d0d3fb01ce5a2dbc7e5146a8eddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Final note(s)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;最后说明&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="4ae1be26b6f0138302a179e64d43a2067887f700" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do I check whether a file exists, without using the try statement?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如何在不使用try语句的情况下检查文件是否存在？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d629d8e59823d5bde2e04f68edf40981e144ca70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; However, this approach will not lock the file in any way and therefore your code can become vulnerable to &quot;&lt;strong&gt;time of check to time of use&lt;/strong&gt;&quot; (&lt;em&gt;TOCTTOU&lt;/em&gt;) bugs.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;但是，这种方法不会以任何方式锁定文件，因此您的代码可能容易受到&amp;ldquo; &lt;strong&gt;检查时间到使用时间&lt;/strong&gt; &amp;rdquo;（ &lt;em&gt;TOCTTOU&lt;/em&gt; ）错误的&lt;em&gt;攻击&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="55fac486326161bbbcc381844be9edd879071502" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: calling native &lt;em&gt;API&lt;/em&gt;s is also possible via &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;[Python 3]: &lt;em&gt;ctypes&lt;/em&gt; - A foreign function library for Python&lt;/a&gt;, but in most cases it's more complicated.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：也可以通过&lt;a href=&quot;https://docs.python.org/3/library/ctypes.html#module-ctypes&quot;&gt;[Python 3]&lt;/a&gt;调用本地&lt;em&gt;API&lt;/em&gt; ： &lt;em&gt;ctypes&lt;/em&gt; -Python的外部函数库 ，但是在大多数情况下，它更为复杂。</target>
        </trans-unit>
        <trans-unit id="49d34f653b3f7b18395aa530bbca320ea65fe2bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: every piece of &lt;em&gt;Python&lt;/em&gt; standard library code that I'm going to post, belongs to version &lt;strong&gt;3.5.3&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：我要发布的每个&lt;em&gt;Python&lt;/em&gt;标准库代码都属于&lt;strong&gt;3.5.3&lt;/strong&gt;版。</target>
        </trans-unit>
        <trans-unit id="f69af187844f3307c7ac46ebb6a50af4199d0748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="0429ce3fc368572fdbb918ae180fcce64fed32ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Possible solutions&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;可能的解决方案&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="5fed05e805aed79ae5e47afbe0cb8a973df01183" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem statement&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;问题陈述&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="06e40dece35eaf987428ae55c6db9c12f565c3c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 3.4+&lt;/strong&gt; has an object-oriented path module: &lt;a href=&quot;http://docs.python.org/3.4/library/pathlib.html&quot;&gt;&lt;strong&gt;pathlib&lt;/strong&gt;&lt;/a&gt;.  Using this new module, you can check whether a file exists like this:</source>
          <target state="translated">&lt;strong&gt;Python 3.4+&lt;/strong&gt;具有一个面向对象的路径模块： &lt;a href=&quot;http://docs.python.org/3.4/library/pathlib.html&quot;&gt;&lt;strong&gt;pathlib&lt;/strong&gt;&lt;/a&gt; 。 使用这个新模块，您可以检查文件是否存在，如下所示：</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8e849d6a4eb1c3b48df71118000704a6892341f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;isfile&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;isfile&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ccfc4989519ffe46e24bb53066a5a14a735987c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;os.access&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;os.access&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cbfe01e7936d0de4ea51c3c0558f1bb48b1f30e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;user permissions&lt;/strong&gt; might restrict the file &quot;visibility&quot; as the doc states:</source>
          <target state="translated">&lt;strong&gt;用户权限&lt;/strong&gt;可能会限制文件&amp;ldquo;可见性&amp;rdquo;，如doc所述：</target>
        </trans-unit>
        <trans-unit id="aa65b1dac98f13533fe2f70426ca413eff63c4b0" translate="yes" xml:space="preserve">
          <source>Adding a variant based on suggestion from Peter Wood</source>
          <target state="translated">根据Peter Wood的建议增加一个变体</target>
        </trans-unit>
        <trans-unit id="80c015f2d056c575939357b34c73484f4d21f408" translate="yes" xml:space="preserve">
          <source>Adding a variant based on suggestion from Shahbaz</source>
          <target state="translated">根据Shahbaz的建议增加了一个变体。</target>
        </trans-unit>
        <trans-unit id="8dcd1e3788c9558ded09b3960d94517b78c07f15" translate="yes" xml:space="preserve">
          <source>Adding one more slight variation which isn't exactly reflected in the other answers.</source>
          <target state="translated">再加一个不完全反映在其他答案中的细微变化。</target>
        </trans-unit>
        <trans-unit id="d8fa576e19bc4318ac6a981c7b91c8f2cbbb0f5c" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;os.access()&lt;/code&gt;:</source>
          <target state="translated">另外， &lt;code&gt;os.access()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="77d1962860d37265160d4636c2fd603e0de75d36" translate="yes" xml:space="preserve">
          <source>All good, but if following the import tree:</source>
          <target state="translated">都是好的,但如果按照进口树的说法,。</target>
        </trans-unit>
        <trans-unit id="78f3ec46f0be71b55c60a634c5c232244a44c6d0" translate="yes" xml:space="preserve">
          <source>All it's doing is using the given path to see if it can get stats on it,  catching &lt;code&gt;OSError&lt;/code&gt; and then checking if it's a file if it didn't raise the exception.</source>
          <target state="translated">它所做的就是使用给定的路径查看它是否可以获取统计信息，捕获 &lt;code&gt;OSError&lt;/code&gt; ，然后检查它是否是文件（如果未引发异常）。</target>
        </trans-unit>
        <trans-unit id="9b23ce4faf3bf6e817d02cdbe090fd916f4c40e3" translate="yes" xml:space="preserve">
          <source>Although I always recommend using &lt;code&gt;try&lt;/code&gt; and &lt;code&gt;except&lt;/code&gt; statements, here are a few possibilities for you (my personal favourite is using &lt;code&gt;os.access&lt;/code&gt;):</source>
          <target state="translated">尽管我总是建议使用 &lt;code&gt;try&lt;/code&gt; 和 &lt;code&gt;except&lt;/code&gt; 语句，但是您可以使用以下 &lt;code&gt;os.access&lt;/code&gt; （我个人最喜欢使用os.access ）：</target>
        </trans-unit>
        <trans-unit id="c28a1b9efeed16f3cc15a65fe06dbf2005ac95c5" translate="yes" xml:space="preserve">
          <source>Although almost every possible way has been listed in (at least one of) the existing answers (e.g. &lt;em&gt;Python 3.4&lt;/em&gt; specific stuff was added), I'll try to group everything together.</source>
          <target state="translated">尽管在（至少一个）现有答案中已经列出了几乎所有可能的方式（例如，添加了&lt;em&gt;Python 3.4&lt;/em&gt;特定的内容），但我将尝试将所有内容组合在一起。</target>
        </trans-unit>
        <trans-unit id="16295a749dac9ed45033fdbc3aac9a2b96843f1d" translate="yes" xml:space="preserve">
          <source>Although it's not a good practice, I'm using &lt;code&gt;os.F_OK&lt;/code&gt; in the call, but that's just for clarity (its value is &lt;strong&gt;0&lt;/strong&gt;)</source>
          <target state="translated">尽管这不是一个好习惯，但我在调用中使用了 &lt;code&gt;os.F_OK&lt;/code&gt; ，但这只是为了清楚起见（其值为&lt;strong&gt;0&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="3f08a8328b4d7fdf72d3c29093a5ec904d34940a" translate="yes" xml:space="preserve">
          <source>Although this targets a very specific area, &lt;strong&gt;it was not mentioned in any of the previous answers&lt;/strong&gt;</source>
          <target state="translated">尽管这是针对非常特定的领域， &lt;strong&gt;但之前的任何答案都未提及&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="78f96d0ac535b29f25a666e1fd59d59ef2274f92" translate="yes" xml:space="preserve">
          <source>An intuitive and arguable way to check if a file exists is the following:</source>
          <target state="translated">检查一个文件是否存在的直观的、可商榷的方法如下。</target>
        </trans-unit>
        <trans-unit id="5e11bbf35099c5b98a84a5e51e2b22a25ec14116" translate="yes" xml:space="preserve">
          <source>And its usage - I'll replicate the &lt;code&gt;os.path.isfile&lt;/code&gt; behavior (note that this is just for demonstrating purposes, do &lt;strong&gt;not&lt;/strong&gt; attempt to write such code for &lt;em&gt;production&lt;/em&gt;):</source>
          <target state="translated">及其用法-我将复制 &lt;code&gt;os.path.isfile&lt;/code&gt; 行为（请注意，这只是出于演示目的，请勿尝试为&lt;em&gt;生产&lt;/em&gt;编写此类代码）：</target>
        </trans-unit>
        <trans-unit id="c242f95ca1e5451cdad6a7e633a8bef0a286e761" translate="yes" xml:space="preserve">
          <source>And the doc&amp;hellip;</source>
          <target state="translated">还有文件</target>
        </trans-unit>
        <trans-unit id="a2e22103d7193a6b3e153c897e9be19320669858" translate="yes" xml:space="preserve">
          <source>Another (lame) workaround (&lt;em&gt;gainarie&lt;/em&gt;) is (as I like to call it,) the &lt;em&gt;sysadmin&lt;/em&gt; approach: use &lt;em&gt;Python&lt;/em&gt; as a wrapper to execute shell commands</source>
          <target state="translated">另一个（ &lt;em&gt;lam&lt;/em&gt; ）解决方法（ &lt;em&gt;gainarie&lt;/em&gt; ）是（我喜欢这样称呼） &lt;em&gt;sysadmin&lt;/em&gt;方法：使用&lt;em&gt;Python&lt;/em&gt;作为包装器执行Shell命令</target>
        </trans-unit>
        <trans-unit id="9fe49da0dcd83e20fd5dd80ebdfbe1ed9a2c2eae" translate="yes" xml:space="preserve">
          <source>Another answer says this about &lt;code&gt;os.access&lt;/code&gt;:</source>
          <target state="translated">另一个答案是关于 &lt;code&gt;os.access&lt;/code&gt; 的 ：</target>
        </trans-unit>
        <trans-unit id="dd57f8a5f3007d7bb9aa43a930b678df495e7817" translate="yes" xml:space="preserve">
          <source>Anyway, here:</source>
          <target state="translated">总之,这里。</target>
        </trans-unit>
        <trans-unit id="9a06af54a07db4e5735e851faae4a0df7e12350c" translate="yes" xml:space="preserve">
          <source>Assuming that the &quot;path&quot; is a valid path, this table shows what is returned by each function for files and folders:</source>
          <target state="translated">假设 &quot;路径 &quot;是有效路径,本表显示了每个函数返回的文件和文件夹的内容。</target>
        </trans-unit>
        <trans-unit id="4aa4567b6cd6712a2f7dedeecffb310d4fb8efca" translate="yes" xml:space="preserve">
          <source>Available for Unix and Windows is &lt;code&gt;os.access&lt;/code&gt;, but to use you must pass flags, and it does not differentiate between files and directories. This is more used to test if the real invoking user has access in an elevated privilege environment:</source>
          <target state="translated">&lt;code&gt;os.access&lt;/code&gt; 可用于Unix和Windows，但要使用它，必须传递标志，并且不能区分文件和目录。 这更可用于测试真正的调用用户是否在提升的特权环境中具有访问权限：</target>
        </trans-unit>
        <trans-unit id="f939845f218e32c170faf5bf6f1cac2c41d8816a" translate="yes" xml:space="preserve">
          <source>Available since Python 3.4, use the new &lt;code&gt;Path&lt;/code&gt; object in &lt;code&gt;pathlib&lt;/code&gt;. Note that &lt;code&gt;.exists&lt;/code&gt; is not quite right, because directories are not files (except in the unix sense that &lt;em&gt;everything&lt;/em&gt; is a file).</source>
          <target state="translated">从Python 3.4开始可用，请在 &lt;code&gt;pathlib&lt;/code&gt; 中使用新的 &lt;code&gt;Path&lt;/code&gt; 对象。 请注意， &lt;code&gt;.exists&lt;/code&gt; 不太正确，因为目录不是文件（从Unix的意义上讲， &lt;em&gt;一切&lt;/em&gt;都是文件）。</target>
        </trans-unit>
        <trans-unit id="afb7ff96e854e0041ec75564f5fe00e9c8f882e0" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;os.access&lt;/code&gt;. It is a low level function that has more opportunities for user error than the higher level objects and functions discussed above.</source>
          <target state="translated">避免使用 &lt;code&gt;os.access&lt;/code&gt; 。 它是一个低级功能，与上面讨论的高级对象和功能相比，它有更多的用户错误机会。</target>
        </trans-unit>
        <trans-unit id="da6dd21459c0ea82eef4c904638259335de797c6" translate="yes" xml:space="preserve">
          <source>Avoiding Race Conditions</source>
          <target state="translated">避开比赛条件</target>
        </trans-unit>
        <trans-unit id="65d799a4d67e40f1718bc28bc5741a7784d3dc98" translate="yes" xml:space="preserve">
          <source>Avoiding race conditions without a try statement: &lt;code&gt;suppress&lt;/code&gt;</source>
          <target state="translated">在没有try语句的情况下避免竞争条件： &lt;code&gt;suppress&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16914c6434145a06ea234b60fc7371e4a7fa25c2" translate="yes" xml:space="preserve">
          <source>Because Python uses &lt;code&gt;try&lt;/code&gt; everywhere, there's really no reason to avoid an implementation that uses it.</source>
          <target state="translated">由于Python在任何地方都使用 &lt;code&gt;try&lt;/code&gt; ，因此实际上没有理由避免使用它的实现。</target>
        </trans-unit>
        <trans-unit id="1360085308b5fa42bcc299eba73a082684f6297d" translate="yes" xml:space="preserve">
          <source>Being &lt;code&gt;R_OK&lt;/code&gt;, &lt;code&gt;W_OK&lt;/code&gt;, and &lt;code&gt;X_OK&lt;/code&gt; the flags to test for permissions (&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;doc&lt;/a&gt;).</source>
          <target state="translated">作为 &lt;code&gt;R_OK&lt;/code&gt; ， &lt;code&gt;W_OK&lt;/code&gt; 和 &lt;code&gt;X_OK&lt;/code&gt; 的标志来测试权限（ &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.access&quot;&gt;doc&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b5ce4b99d290844609883481eafaef7da7bec38b" translate="yes" xml:space="preserve">
          <source>But if this is your motivation, you &lt;em&gt;can&lt;/em&gt; get the value of a &lt;code&gt;try&lt;/code&gt; statement by using the &lt;code&gt;suppress&lt;/code&gt; context manager.</source>
          <target state="translated">但是，如果这是您的动力，则&lt;em&gt;可以&lt;/em&gt;通过使用 &lt;code&gt;suppress&lt;/code&gt; 上下文管理器&lt;em&gt;来&lt;/em&gt;获得 &lt;code&gt;try&lt;/code&gt; 语句的价值。</target>
        </trans-unit>
        <trans-unit id="f386f26a018b39932ce810bfed8462f4b3a47009" translate="yes" xml:space="preserve">
          <source>But if you examine the &lt;a href=&quot;https://hg.python.org/cpython/file/tip/Lib/genericpath.py#l25&quot;&gt;source&lt;/a&gt; of this function, you'll see it actually does use a try statement:</source>
          <target state="translated">但是，如果您检查此函数的&lt;a href=&quot;https://hg.python.org/cpython/file/tip/Lib/genericpath.py#l25&quot;&gt;来源&lt;/a&gt; ，您会发现它确实使用了try语句：</target>
        </trans-unit>
        <trans-unit id="892805ad4977b8e4cbbb93d3b769716f4bf55e28" translate="yes" xml:space="preserve">
          <source>But if you just wanted to rename a file if it exists, and therefore don't need to open it, do</source>
          <target state="translated">但是,如果你只是想重命名一个文件,如果它存在的话,因此不需要打开它,那就去做</target>
        </trans-unit>
        <trans-unit id="e6de42189ae24dbf3535041c097ece060e47ed05" translate="yes" xml:space="preserve">
          <source>But the rest of this answer attempts to consider these caveats.</source>
          <target state="translated">但本回答的其余部分试图考虑这些注意事项。</target>
        </trans-unit>
        <trans-unit id="a80baeb2d0654bc11cd6d4521f34ce4502d6e633" translate="yes" xml:space="preserve">
          <source>But, since this is more like a workaround, I'm stopping here.</source>
          <target state="translated">但是,因为这更像是一种变通,所以我就不说了。</target>
        </trans-unit>
        <trans-unit id="a4baa59ded747be901cc0484a5e9a9c22477fa86" translate="yes" xml:space="preserve">
          <source>But, they seem to be wrappers over &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; blocks, as &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#with&quot;&gt;[Python 3]: The &lt;em&gt;with&lt;/em&gt; statement&lt;/a&gt; states:</source>
          <target state="translated">但是，它们似乎是&lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt;块的包装，如&lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#with&quot;&gt;[Python 3]： &lt;em&gt;with&lt;/em&gt;语句&lt;/a&gt;指出：</target>
        </trans-unit>
        <trans-unit id="3f1992230a0a514077c62160f7120bcc185acd4c" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;NamedTemporaryFile&lt;/code&gt; deletes the file when closed (and will automatically close when no more references exist to it).</source>
          <target state="translated">默认情况下， &lt;code&gt;NamedTemporaryFile&lt;/code&gt; 在关闭时删除文件（并且在不再有引用时会自动关闭）。</target>
        </trans-unit>
        <trans-unit id="680c3a0a04488efb0a6669d23ed46dff42487746" translate="yes" xml:space="preserve">
          <source>Check file (&lt;em&gt;arguable&lt;/em&gt;: also folder (&quot;special&quot; file) ?) existence</source>
          <target state="translated">检查文件（ &lt;em&gt;可以争论&lt;/em&gt; ：也是文件夹（&amp;ldquo;特殊&amp;rdquo;文件）吗？）是否存在</target>
        </trans-unit>
        <trans-unit id="00069321f9bac6a3e2758c45a988eb1af4ffe84c" translate="yes" xml:space="preserve">
          <source>Check file or directory exists</source>
          <target state="translated">检查文件或目录是否存在</target>
        </trans-unit>
        <trans-unit id="2148c4248cab3850cba5ecc20309317f0af37946" translate="yes" xml:space="preserve">
          <source>Create one:</source>
          <target state="translated">创建一个。</target>
        </trans-unit>
        <trans-unit id="23c1fa17d5809322d5e9a7c843e9604caa61cdff" translate="yes" xml:space="preserve">
          <source>Criticism of another answer:</source>
          <target state="translated">对另一个答案的批评。</target>
        </trans-unit>
        <trans-unit id="3b40241a5f2c37e0887dd4f6954b744ced57b1ec" translate="yes" xml:space="preserve">
          <source>Date:2017-12-04</source>
          <target state="translated">Date:2017-12-04</target>
        </trans-unit>
        <trans-unit id="87444639b77f489e7dc7f1684a2c815d05e6b641" translate="yes" xml:space="preserve">
          <source>Doesn't seem a traversing function &lt;em&gt;per se&lt;/em&gt; (at least in some cases), but it still uses &lt;code&gt;os.listdir&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;本身&lt;/em&gt;似乎没有遍历功能（至少在某些情况下），但仍使用 &lt;code&gt;os.listdir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d521195617328a431dabe6deacc4cc8e93939de" translate="yes" xml:space="preserve">
          <source>Don't take my word for it. There's plenty of support for this theory. Here's a couple:</source>
          <target state="translated">不要相信我的话。这个理论有很多支持。这里有几个例子。</target>
        </trans-unit>
        <trans-unit id="2df06b2d468838548ea913f49b8c7912e8ab2b96" translate="yes" xml:space="preserve">
          <source>Don't use &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt; blocks</source>
          <target state="translated">不要使用&lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;finally&lt;/em&gt;&lt;/strong&gt;块</target>
        </trans-unit>
        <trans-unit id="b9461aa6e4a1d297ac2448ad2f40004dd46970c5" translate="yes" xml:space="preserve">
          <source>Every possible solution has been listed in other answers.</source>
          <target state="translated">每一个可能的解决方案都已经在其他答案中列出了。</target>
        </trans-unit>
        <trans-unit id="57f676484ad86c6f592e0200b1bc9abf4d27bc4a" translate="yes" xml:space="preserve">
          <source>Filesystem traversal functions (and search the results for matching item(s))</source>
          <target state="translated">文件系统遍历函数(并搜索匹配项的结果)。</target>
        </trans-unit>
        <trans-unit id="2482b1dfd54ac893308e090998a270fa3acccec9" translate="yes" xml:space="preserve">
          <source>For earlier Pythons, you could roll your own &lt;code&gt;suppress&lt;/code&gt;, but without a &lt;code&gt;try&lt;/code&gt; will be more verbose than with. I do believe &lt;strong&gt;this actually is the only answer that doesn't use &lt;code&gt;try&lt;/code&gt; at any level in the Python&lt;/strong&gt; that can be applied to prior to Python 3.4 because it uses a context manager instead:</source>
          <target state="translated">对于较早的Python，您可以使用自己的 &lt;code&gt;suppress&lt;/code&gt; ，但是如果不 &lt;code&gt;try&lt;/code&gt; 则比使用它们更冗长。 我确实相信&lt;strong&gt;这实际上是唯一&lt;/strong&gt;可以在Python 3.4之前的版本&lt;strong&gt;中不使用 &lt;code&gt;try&lt;/code&gt; 的答案，&lt;/strong&gt;因为它使用了上下文管理器代替：</target>
        </trans-unit>
        <trans-unit id="55f79bf0ba7b0375b8d3143950e1a90ab89796a4" translate="yes" xml:space="preserve">
          <source>For reference also see &lt;a href=&quot;/q/82831&quot;&gt;How to check whether a file exists using Python?&lt;/a&gt;</source>
          <target state="translated">供参考，请参阅&lt;a href=&quot;/q/82831&quot;&gt;如何使用Python检查文件是否存在？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0bdeff00f3ab0a5de85d46268cc456e660f0891f" translate="yes" xml:space="preserve">
          <source>Here's a 1 line Python command for the Linux command line environment. I find this VERY HANDY since I'm not such a hot Bash guy.</source>
          <target state="translated">这里有一个用于Linux命令行环境的1行Python命令。我觉得这个非常简单,因为我不是一个热衷于Bash的人。</target>
        </trans-unit>
        <trans-unit id="4f2f59aeca936afd9d057519d9ef3eac5bef7ca4" translate="yes" xml:space="preserve">
          <source>Here's the help on &lt;code&gt;is_file&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;is_file&lt;/code&gt; 的帮助：</target>
        </trans-unit>
        <trans-unit id="d3e0db2911db163b18bf0441aa9f4ab60ce06986" translate="yes" xml:space="preserve">
          <source>How do I check whether a file exists without exceptions</source>
          <target state="translated">如何检查一个文件是否无异常地存在?</target>
        </trans-unit>
        <trans-unit id="f992ff3c06028274def0fdd00a52220dd457b417" translate="yes" xml:space="preserve">
          <source>How do I check whether a file exists, using Python, without using a try statement?</source>
          <target state="translated">如何使用Python检查一个文件是否存在,而不使用try语句?</target>
        </trans-unit>
        <trans-unit id="648dcb140e5c8625e8fd1d8412c1ff5f81de87f0" translate="yes" xml:space="preserve">
          <source>How do I see if a file exists or not, without using the &lt;a href=&quot;https://docs.python.org/3.6/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement?</source>
          <target state="translated">不使用&lt;a href=&quot;https://docs.python.org/3.6/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt;语句如何查看文件是否存在？</target>
        </trans-unit>
        <trans-unit id="4da044c22cb2fb15a1b87e329d865c130b7299e8" translate="yes" xml:space="preserve">
          <source>I hope this is helpful.</source>
          <target state="translated">希望对你有帮助。</target>
        </trans-unit>
        <trans-unit id="ebe65250133ece313707187f5563d38f23a6029b" translate="yes" xml:space="preserve">
          <source>I made an exhaustive cheatsheet for your reference:</source>
          <target state="translated">我做了一个详尽的小结,供大家参考。</target>
        </trans-unit>
        <trans-unit id="c092b3bf26fda474ba2f972972deba214b2de89d" translate="yes" xml:space="preserve">
          <source>I should also mention that there are two ways that you will not be able to verify the existence of a file. Either the issue will be &lt;code&gt;permission denied&lt;/code&gt; or &lt;code&gt;no such file or directory&lt;/code&gt;. If you catch an &lt;code&gt;IOError&lt;/code&gt;, set the &lt;code&gt;IOError as e&lt;/code&gt; (like my first option), and then type in &lt;code&gt;print(e.args)&lt;/code&gt; so that you can hopefully determine your issue. I hope it helps! :)</source>
          <target state="translated">我还应该提到，有两种方法将无法验证文件的存在。 要么是问题被 &lt;code&gt;permission denied&lt;/code&gt; 要么是 &lt;code&gt;no such file or directory&lt;/code&gt; 。 如果捕获到 &lt;code&gt;IOError&lt;/code&gt; ，请将IOError设置 &lt;code&gt;IOError as e&lt;/code&gt; （就像我的第一个选项一样），然后键入 &lt;code&gt;print(e.args)&lt;/code&gt; 以便希望确定问题。 希望对您有所帮助！ :)</target>
        </trans-unit>
        <trans-unit id="6bdb8ff9e404da03bb952ad7abebcc20b1ca5fbc" translate="yes" xml:space="preserve">
          <source>I will try to keep it up to date, any suggestions are welcome, I will incorporate anything useful that will come up into the answer</source>
          <target state="translated">我会尽量保持更新,欢迎任何建议,我将会把任何有用的东西纳入到答案中。</target>
        </trans-unit>
        <trans-unit id="71420b82d8fcd7fd47b4cff0728dfbb46cae47de" translate="yes" xml:space="preserve">
          <source>I'm the author of a package that's been around for about 10 years, and it has a function that addresses this question directly. Basically, if you are on a non-Windows system, it uses &lt;code&gt;Popen&lt;/code&gt; to access &lt;code&gt;find&lt;/code&gt;.  However, if you are on Windows, it replicates &lt;code&gt;find&lt;/code&gt; with an efficient filesystem walker.</source>
          <target state="translated">我是一个已经存在大约十年的软件包的作者，它的功能可以直接解决这个问题。 基本上，如果您使用的是非Windows系统，它将使用 &lt;code&gt;Popen&lt;/code&gt; 访问 &lt;code&gt;find&lt;/code&gt; 。 但是，如果您使用的是Windows，它将使用高效的文件系统walker复制 &lt;code&gt;find&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ca967716a632903489f4722e9137f4292d1cec8" translate="yes" xml:space="preserve">
          <source>I'm using &lt;em&gt;_waccess&lt;/em&gt; so that the same code works on &lt;em&gt;Python3&lt;/em&gt; and &lt;em&gt;Python2&lt;/em&gt; (in spite of &lt;em&gt;unicode&lt;/em&gt; related differences between them)</source>
          <target state="translated">我正在使用&lt;em&gt;_waccess，&lt;/em&gt;以便相同的代码可在&lt;em&gt;Python3&lt;/em&gt;和&lt;em&gt;Python2上使用&lt;/em&gt; （尽管它们之间存在与&lt;em&gt;Unicode&lt;/em&gt;相关的区别）</target>
        </trans-unit>
        <trans-unit id="a407e3adfd2214b7c586432d022e9ef118ddf7e0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is NULL, then the returned handle is for the main
  program.  When given to &lt;strong&gt;dlsym&lt;/strong&gt;(), this handle causes a search for a
  symbol in the main program, followed by all shared objects loaded at
  program startup, and then all shared objects loaded by &lt;strong&gt;dlopen&lt;/strong&gt;() with
  the flag &lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;.</source>
          <target state="translated">如果&lt;em&gt;filename&lt;/em&gt;为NULL，则返回的句柄用于主程序。 当赋予&lt;strong&gt;dlsym&lt;/strong&gt; （）时，此句柄将在主程序中搜索符号，然后在程序启动时加载所有共享对象，然后在&lt;strong&gt;dlopen&lt;/strong&gt; （）中加载带有标志&lt;strong&gt;RTLD_GLOBAL的&lt;/strong&gt;所有共享对象。</target>
        </trans-unit>
        <trans-unit id="15fcbc3b264cbebf2eb4f1760bc8e1cba58236dd" translate="yes" xml:space="preserve">
          <source>If it's False, it will stop execution with an unhanded IOError
or OSError in later versions of Python. To catch the exception,
you have to use a try except clause. Of course, you can always
use a &lt;code&gt;try&lt;/code&gt; except` statement like so (thanks to &lt;a href=&quot;https://stackoverflow.com/users/3256073/hsandt&quot;&gt;hsandt&lt;/a&gt;
for making me think):</source>
          <target state="translated">如果为False，它将在更高版本的Python中以未处理的IOError或OSError停止执行。 要捕获异常，您必须使用tryexcept子句。 当然，您总是可以像这样使用 &lt;code&gt;try&lt;/code&gt; try`语句（感谢&lt;a href=&quot;https://stackoverflow.com/users/3256073/hsandt&quot;&gt;hsandt&lt;/a&gt;让我思考）：</target>
        </trans-unit>
        <trans-unit id="c02184bc81acba7ff60734fa0276f4694047dce3" translate="yes" xml:space="preserve">
          <source>If the file is for opening you could use one of the following techniques:</source>
          <target state="translated">如果文件是用来打开的,你可以使用以下技术之一。</target>
        </trans-unit>
        <trans-unit id="f750d04a74a28d801ca980107d812cb534028797" translate="yes" xml:space="preserve">
          <source>If the reason you're checking is so you can do something like &lt;code&gt;if file_exists: open_it()&lt;/code&gt;, it's safer to use a &lt;code&gt;try&lt;/code&gt; around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.</source>
          <target state="translated">如果您要检查的原因是可以执行 &lt;code&gt;if file_exists: open_it()&lt;/code&gt; ，则 &lt;code&gt;try&lt;/code&gt; 尝试打开它更安全。 检查然后打开可能会导致文件被删除或移动，或者介于检查和尝试打开文件之间。</target>
        </trans-unit>
        <trans-unit id="c5ff89b09fe8a6eb3f1fbb9c6d4f376565e0fe86" translate="yes" xml:space="preserve">
          <source>If you dig into &lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/pathlib.py#L1318&quot;&gt;the implementation&lt;/a&gt;, though, you'll see that &lt;code&gt;is_file&lt;/code&gt; uses &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">但是，如果深入研究&lt;a href=&quot;https://github.com/python/cpython/blob/master/Lib/pathlib.py#L1318&quot;&gt;实现&lt;/a&gt; ，您将看到 &lt;code&gt;is_file&lt;/code&gt; 使用 &lt;code&gt;try&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0979e6df66fd1282fbd01cd0616f8c975b44e156" translate="yes" xml:space="preserve">
          <source>If you imported NumPy already for other purposes then there is no need to import other libraries like &lt;code&gt;pathlib&lt;/code&gt;, &lt;code&gt;os&lt;/code&gt;, &lt;code&gt;paths&lt;/code&gt;, etc.</source>
          <target state="translated">如果您已经导入NumPy用于其他目的，则无需导入其他库，例如 &lt;code&gt;pathlib&lt;/code&gt; ， &lt;code&gt;os&lt;/code&gt; ， &lt;code&gt;paths&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="3505fa4d971cfab39c9f20bc4b27451fc35e3489" translate="yes" xml:space="preserve">
          <source>If you intend to do something with the file, I would suggest directly attempting it with a try-except to avoid a race condition:</source>
          <target state="translated">如果你打算对这个文件做一些事情,我建议直接用try-except来进行尝试,避免出现竞赛条件。</target>
        </trans-unit>
        <trans-unit id="7dcf6a221c7d9f7451561a984e8aab1ebed8336f" translate="yes" xml:space="preserve">
          <source>If you need file locking, that's a different matter.</source>
          <target state="translated">如果你需要文件锁定,那是另一回事。</target>
        </trans-unit>
        <trans-unit id="08c9a05009658ae490c6ba1c13b8004939cdcd0a" translate="yes" xml:space="preserve">
          <source>If you need high-level operations, use &lt;code&gt;shutil&lt;/code&gt;.</source>
          <target state="translated">如果您需要高级操作，请使用 &lt;code&gt;shutil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56e17f5c3eb030308d334ae00733d23533b31d78" translate="yes" xml:space="preserve">
          <source>If you want to check that a file exists before you attempt to read it, and you might be deleting it and then you might be using multiple threads or processes, or another program knows about that file and could delete it - you risk the chance of a &lt;strong&gt;race condition&lt;/strong&gt; if you check it exists, because you are then &lt;em&gt;racing&lt;/em&gt; to open it before its &lt;em&gt;condition&lt;/em&gt; (its existence) changes.</source>
          <target state="translated">如果要在尝试读取文件之前检查文件是否存在，并且可能要删除它，然后使用多个线程或进程，或者另一个程序知道该文件并可能将其删除，则可能会有以下风险：如果您检查它是否存在，则为&lt;strong&gt;竞赛条件&lt;/strong&gt; ，因为您随后在其&lt;em&gt;条件&lt;/em&gt; （存在）改变之前就&lt;em&gt;竞相&lt;/em&gt;打开它。</target>
        </trans-unit>
        <trans-unit id="b38cd90e47b8c32bc320b1b6ef26a7b9609fff52" translate="yes" xml:space="preserve">
          <source>If you want to read a file, if it exists, do</source>
          <target state="translated">如果你想读取一个文件,如果它存在,请执行</target>
        </trans-unit>
        <trans-unit id="43244157b51e40292add122e42936b5161218cbf" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, if it doesn't exist, do</source>
          <target state="translated">如果你想写到一个文件,如果它不存在的话,请执行</target>
        </trans-unit>
        <trans-unit id="f4f1b207aadf8f5d760de13167e89765ef728de9" translate="yes" xml:space="preserve">
          <source>If you're not planning to open the file immediately, you can use &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;&lt;code&gt;os.path.isfile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">如果您不打算立即打开文件，则可以使用&lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt; &lt;code&gt;os.path.isfile&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6070d8aef9d3e642476beafdb4d34a0fbf6fd11a" translate="yes" xml:space="preserve">
          <source>If you're on Python 2, you can backport the pathlib module from pypi, &lt;a href=&quot;https://pypi.python.org/pypi/pathlib2/&quot;&gt;&lt;code&gt;pathlib2&lt;/code&gt;&lt;/a&gt;, or otherwise check &lt;code&gt;isfile&lt;/code&gt; from the &lt;code&gt;os.path&lt;/code&gt; module:</source>
          <target state="translated">如果您使用的是Python 2，则可以从pypi， &lt;a href=&quot;https://pypi.python.org/pypi/pathlib2/&quot;&gt; &lt;code&gt;pathlib2&lt;/code&gt; 反向&lt;/a&gt;移植pathlib模块，或者通过 &lt;code&gt;os.path&lt;/code&gt; 模块检查 &lt;code&gt;isfile&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="304faa8fa6b0b859ff9cf1ffd4acaeb92c2f66b7" translate="yes" xml:space="preserve">
          <source>Importing &lt;code&gt;os&lt;/code&gt; makes it easier to navigate and perform standard actions with your operating system.</source>
          <target state="translated">导入 &lt;code&gt;os&lt;/code&gt; 可以更轻松地在操作系统中导航和执行标准操作。</target>
        </trans-unit>
        <trans-unit id="6aeb39684e6a8d6e753f97adb8f35968468f0629" translate="yes" xml:space="preserve">
          <source>In 2016 the best way is still using &lt;code&gt;os.path.isfile&lt;/code&gt;:</source>
          <target state="translated">在2016年，最好的方法仍然是使用 &lt;code&gt;os.path.isfile&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="63858bed5a51687e64275119d3dc78c8c0d5f146" translate="yes" xml:space="preserve">
          <source>In 2016, this is still arguably the easiest way to check if both a file exists and if it is a file:</source>
          <target state="translated">在2016年,这可以说仍然是最简单的方法,既要检查一个文件是否存在,又要检查它是否是一个文件。</target>
        </trans-unit>
        <trans-unit id="53b8bae049e83f783d679add94d8c62730294a02" translate="yes" xml:space="preserve">
          <source>Install some third-party module with filesystem capabilities</source>
          <target state="translated">安装一些具有文件系统功能的第三方模块</target>
        </trans-unit>
        <trans-unit id="249f0dbd1b80d813ef272a820bd4e6ec0094f9c9" translate="yes" xml:space="preserve">
          <source>Instead hardcoding &lt;em&gt;libc&lt;/em&gt;'s path (&lt;em&gt;&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;&lt;/em&gt;) which may (and most likely, will) vary across systems, &lt;em&gt;None&lt;/em&gt; (or the empty string) can be passed to &lt;em&gt;CDLL&lt;/em&gt; constructor (&lt;strong&gt;&lt;code&gt;ctypes.CDLL(None).access(b&quot;/tmp&quot;, os.F_OK)&lt;/code&gt;&lt;/strong&gt;). According to &lt;a href=&quot;http://man7.org/linux/man-pages/man3/dlopen.3.html&quot;&gt;[man7]: DLOPEN(3)&lt;/a&gt;:</source>
          <target state="translated">而是硬编码&lt;em&gt;libc&lt;/em&gt;的路径（ &lt;em&gt;&amp;ldquo; /lib/x86_64-linux-gnu/libc.so.6&amp;rdquo;&lt;/em&gt; ），该路径在整个系统之间可能（而且很可能会有所不同）， &lt;em&gt;无&lt;/em&gt; （或空字符串）可以传递给&lt;em&gt;CDLL&lt;/em&gt;构造函数（ &lt;strong&gt; &lt;code&gt;ctypes.CDLL(None).access(b&quot;/tmp&quot;, os.F_OK)&lt;/code&gt; &lt;/strong&gt; ）。 根据&lt;a href=&quot;http://man7.org/linux/man-pages/man3/dlopen.3.html&quot;&gt;[man7]：DLOPEN（3）&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c2456e210fee146ed3f8241baa370ef4e417d398" translate="yes" xml:space="preserve">
          <source>It also creates a context manager which, by unconditionally returning &lt;code&gt;True&lt;/code&gt;, allows all Exceptions (including &lt;code&gt;KeyboardInterrupt&lt;/code&gt; and &lt;code&gt;SystemExit&lt;/code&gt;!) to pass silently, which is a good way to hide bugs.</source>
          <target state="translated">它还创建了一个上下文管理器，通过无条件返回 &lt;code&gt;True&lt;/code&gt; ，允许所有异常（包括 &lt;code&gt;KeyboardInterrupt&lt;/code&gt; 和 &lt;code&gt;SystemExit&lt;/code&gt; ！）以静默方式传递，这是隐藏错误的好方法。</target>
        </trans-unit>
        <trans-unit id="a8cd152693547cd306546c2c837671d8d018ed7f" translate="yes" xml:space="preserve">
          <source>It also suffers from the same race condition problems as &lt;code&gt;isfile&lt;/code&gt;. From the &lt;a href=&quot;https://docs.python.org/2/library/os.html#os.access&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">它也遭受与 &lt;code&gt;isfile&lt;/code&gt; 相同的竞争条件问题。 从&lt;a href=&quot;https://docs.python.org/2/library/os.html#os.access&quot;&gt;文档&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="4202a54228e33a8c91a54fe4ae0d3e882755b1c7" translate="yes" xml:space="preserve">
          <source>It doesn't seem like there's a meaningful functional difference between try/except and &lt;code&gt;isfile()&lt;/code&gt;, so you should use which one makes sense.</source>
          <target state="translated">在try / except和 &lt;code&gt;isfile()&lt;/code&gt; 之间似乎没有有意义的功能差异，因此您应该使用哪个才有意义。</target>
        </trans-unit>
        <trans-unit id="dbc241143077ad988ba650982a25300f8fb789d3" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;os.listdir&lt;/code&gt; (&lt;code&gt;os.scandir&lt;/code&gt; when available)</source>
          <target state="translated">它使用 &lt;code&gt;os.listdir&lt;/code&gt; （ &lt;code&gt;os.scandir&lt;/code&gt; 时为os.scandir ）</target>
        </trans-unit>
        <trans-unit id="327665da0521fd7ce34669658e33594ae8ff6a15" translate="yes" xml:space="preserve">
          <source>It's a fancier (and more &lt;em&gt;python&lt;/em&gt;ic) way of handling paths, &lt;strong&gt;but&lt;/strong&gt;</source>
          <target state="translated">这是一种处理路径的更好的方式（以及更多的&lt;em&gt;python&lt;/em&gt; ic）， &lt;strong&gt;但是&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0874e622984b8d8ed8d0111ced638b33c324993" translate="yes" xml:space="preserve">
          <source>Just to avoid confusion and based on the answers I got, current answer finds either a file &lt;strong&gt;or&lt;/strong&gt; a directory with the given name.</source>
          <target state="translated">为了避免混淆，并根据我得到的答案，当前答案会找到具有给定名称的文件&lt;strong&gt;或&lt;/strong&gt;目录。</target>
        </trans-unit>
        <trans-unit id="59f32559476324f232ad65e7d3e5c4edde71e7e4" translate="yes" xml:space="preserve">
          <source>Longer, much more pedantic answer</source>
          <target state="translated">更长,更迂腐的答案</target>
        </trans-unit>
        <trans-unit id="342aaecc367b1d3941e496dfa36d36af27e2812d" translate="yes" xml:space="preserve">
          <source>Main (current) program (&lt;em&gt;python&lt;/em&gt;) is linked against &lt;em&gt;libc&lt;/em&gt;, so its symbols (including &lt;em&gt;access&lt;/em&gt;) will be loaded</source>
          <target state="translated">主（当前）程序（ &lt;em&gt;python&lt;/em&gt; ）与&lt;em&gt;libc&lt;/em&gt;链接，因此将加载其符号（包括&lt;em&gt;access&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="4d15ee1ab2448fa179b92a1924e831dd8f0f9a47" translate="yes" xml:space="preserve">
          <source>Most likely, will rely on one of the ways above (maybe with slight customizations).</source>
          <target state="translated">最有可能的是,将依靠上述方式之一(也许有轻微的自定义)。</target>
        </trans-unit>
        <trans-unit id="782942b5ea6c6ad77e95b9f86f2fa9c57b44eb41" translate="yes" xml:space="preserve">
          <source>Note1: The &lt;code&gt;os.path.isfile&lt;/code&gt; used only for files</source>
          <target state="translated">注意1： &lt;code&gt;os.path.isfile&lt;/code&gt; 仅用于文件</target>
        </trans-unit>
        <trans-unit id="f4abfb7bebf2ffae4214d6fb5b83a497213ebf77" translate="yes" xml:space="preserve">
          <source>Note2: The &lt;code&gt;os.path.exists&lt;/code&gt; used for both files and directories</source>
          <target state="translated">注意2： &lt;code&gt;os.path.exists&lt;/code&gt; 用于文件和目录</target>
        </trans-unit>
        <trans-unit id="c451b4b43107e20a1f539e1f362df3e8d96f9cf5" translate="yes" xml:space="preserve">
          <source>Note:
  Using access() to check if a user is authorized to e.g. open a file
  before actually doing so using open() creates a security hole, because
  the user might exploit the short time interval between checking and
  opening the file to manipulate it. It&amp;rsquo;s preferable to use EAFP
  techniques. For example:</source>
          <target state="translated">注意：在实际使用open（）之前，使用access（）检查用户是否被授权例如打开文件会造成安全漏洞，因为用户可能会利用检查和打开文件之间的较短时间间隔来操作它。 最好使用EAFP技术。 例如：</target>
        </trans-unit>
        <trans-unit id="fed557bf7ca2300dfe5a352020d76469a9ceb724" translate="yes" xml:space="preserve">
          <source>Now available since Python 3.4, import and instantiate a &lt;code&gt;Path&lt;/code&gt; object with the file name, and check the &lt;code&gt;is_file&lt;/code&gt; method (note that this returns True for symlinks pointing to regular files as well):</source>
          <target state="translated">从Python 3.4开始可用，导入并实例化具有文件名的 &lt;code&gt;Path&lt;/code&gt; 对象，并检查 &lt;code&gt;is_file&lt;/code&gt; 方法（请注意，对于指向常规文件的符号链接，该方法也返回True）：</target>
        </trans-unit>
        <trans-unit id="0c2b0029788516df42324f1ddcb2a0d379462fca" translate="yes" xml:space="preserve">
          <source>Now the above is probably the best pragmatic direct answer here, but there's the possibility of a race condition (depending on what you're trying to accomplish), and the fact that the underlying implementation uses a &lt;code&gt;try&lt;/code&gt;, but Python uses &lt;code&gt;try&lt;/code&gt; everywhere in its implementation.</source>
          <target state="translated">现在，上面可能是这里最好的实用直接答案，但是有可能出现竞态条件（取决于您要完成的工作），并且底层实现使用 &lt;code&gt;try&lt;/code&gt; ，但Python在其各处都使用 &lt;code&gt;try&lt;/code&gt; 的事实实施。</target>
        </trans-unit>
        <trans-unit id="9f1fcb7cb0c155a214cdcbeab2ea4d318d7dd89d" translate="yes" xml:space="preserve">
          <source>One example would be (again, &lt;em&gt;Win&lt;/em&gt; specific) &lt;a href=&quot;https://github.com/mhammond/pywin32&quot;&gt;[GitHub]: mhammond/pywin32 - Python for Windows (pywin32) Extensions&lt;/a&gt;, which is a &lt;em&gt;Python&lt;/em&gt; wrapper over &lt;em&gt;WINAPI&lt;/em&gt;s.</source>
          <target state="translated">一个示例是（再次，特定于&lt;em&gt;Win&lt;/em&gt; ） &lt;a href=&quot;https://github.com/mhammond/pywin32&quot;&gt;[GitHub]：mhammond / pywin32-Windows专用的Python（pywin32）Extensions&lt;/a&gt; ，它是&lt;em&gt;WINAPI&lt;/em&gt;的&lt;em&gt;Python&lt;/em&gt;包装器。</target>
        </trans-unit>
        <trans-unit id="5abbf84d7258a883758c744ea8454f1c4d043654" translate="yes" xml:space="preserve">
          <source>Opening the file will always verify the existence of the file. You can make a function just like so:</source>
          <target state="translated">打开文件总是会验证文件的存在。你可以像这样做一个功能。</target>
        </trans-unit>
        <trans-unit id="3d75570821c532602afcda3cfc484e1ec0dd4b08" translate="yes" xml:space="preserve">
          <source>Or in Python 3 you can use &lt;code&gt;pathlib&lt;/code&gt;:</source>
          <target state="translated">或者在Python 3中，您可以使用 &lt;code&gt;pathlib&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6162f97d9d25399c4c7f1572eade2b73d9183fc2" translate="yes" xml:space="preserve">
          <source>Other options that don't meet the ask for &quot;without try&quot;:</source>
          <target state="translated">其他不符合要求 &quot;不试 &quot;的选项。</target>
        </trans-unit>
        <trans-unit id="1abe02b8870cad9e8f6a481158089cd2d79cac6d" translate="yes" xml:space="preserve">
          <source>Perhaps easier with a try:</source>
          <target state="translated">也许是试一试更容易。</target>
        </trans-unit>
        <trans-unit id="d9e7f16adc3452b0efdc8ccada6d3af30945b93c" translate="yes" xml:space="preserve">
          <source>Personally, I prefer this one because under the hood, it calls native APIs (via &quot;${PYTHON_SRC_DIR}/Modules/posixmodule.c&quot;), but it also opens a gate for possible user errors, and it's not as Pythonic as other variants:</source>
          <target state="translated">我个人更喜欢这个,因为在引擎盖下,它可以调用原生API(通过&quot;${PYTHON_SRC_DIR}Modulesposixmodule.c&quot;),但它也为用户可能的错误打开了一扇门,而且它不像其他变体那样Pythonic。</target>
        </trans-unit>
        <trans-unit id="8e425b164973e8037f334709b9c9ce674d73968a" translate="yes" xml:space="preserve">
          <source>Prefer the try statement. It's considered better style and avoids race conditions.</source>
          <target state="translated">更喜欢尝试的说法。这被认为是比较好的风格,避免了比赛的情况。</target>
        </trans-unit>
        <trans-unit id="93744e02826bb08cbcaca9d0ccf769f1f6a80f48" translate="yes" xml:space="preserve">
          <source>Python 3.4 gives us the &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;&lt;code&gt;suppress&lt;/code&gt;&lt;/a&gt; context manager (previously the &lt;a href=&quot;https://bugs.python.org/issue19266&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt; context manager), which does semantically exactly the same thing in fewer lines, while also (at least superficially) meeting the original ask to avoid a &lt;code&gt;try&lt;/code&gt; statement:</source>
          <target state="translated">Python 3.4为我们提供了&lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt; &lt;code&gt;suppress&lt;/code&gt; &lt;/a&gt;上下文管理器（以前为&lt;a href=&quot;https://bugs.python.org/issue19266&quot;&gt; &lt;code&gt;ignore&lt;/code&gt; &lt;/a&gt;上下文管理器），它在较少的行中在语义上完全相同，而也（至少表面上）满足了避免 &lt;code&gt;try&lt;/code&gt; 语句的原始要求：</target>
        </trans-unit>
        <trans-unit id="88968d6bed87a24c3d5e8906af55bf32da38c015" translate="yes" xml:space="preserve">
          <source>Race Conditions: Why we like try</source>
          <target state="translated">比赛条件。为什么我们喜欢尝试</target>
        </trans-unit>
        <trans-unit id="522972b64fc54c50b69da77a6a1c4a50a9bb45a8" translate="yes" xml:space="preserve">
          <source>Race conditions are very hard to debug because there's a very small window in which they can cause your program to fail.</source>
          <target state="translated">竞赛条件是很难调试的,因为有一个非常小的窗口,在这个窗口中,它们会导致你的程序失败。</target>
        </trans-unit>
        <trans-unit id="b2e1e799ac67777d3968b00f4cfe9b4b5a63a8e0" translate="yes" xml:space="preserve">
          <source>Raising exceptions is considered to be an acceptable, and Pythonic,
  approach for flow control in your program. Consider handling missing
  files with IOErrors. In this situation, an IOError exception will be
  raised if the file exists but the user does not have read permissions.</source>
          <target state="translated">提出异常被认为是一种可以接受的,也是Pythonic的程序流控制方法。可以考虑用IOErrors来处理缺失文件。在这种情况下,如果文件存在但用户没有读取权限,就会引发IOError异常。</target>
        </trans-unit>
        <trans-unit id="398f6fa810da4cd445bcd4f6196261363faad467" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;path&lt;/em&gt; refers to an existing path or an open file descriptor. Returns &lt;code&gt;False&lt;/code&gt; for broken symbolic links. On some platforms, this function may return &lt;code&gt;False&lt;/code&gt; if permission is not granted to execute &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;os.stat()&lt;/a&gt; on the requested file, even if the &lt;em&gt;path&lt;/em&gt; physically exists.</source>
          <target state="translated">如果&lt;em&gt;path&lt;/em&gt;引用现有路径或打开的文件描述符，则返回 &lt;code&gt;True&lt;/code&gt; 。 对于断开的符号链接返回 &lt;code&gt;False&lt;/code&gt; 。 在某些平台上，即使未实际执行&lt;em&gt;路径&lt;/em&gt; ，如果未授予在请求的文件上执行&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;os.stat（）的&lt;/a&gt;权限，此函数也可能返回 &lt;code&gt;False&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57fd7c3c54933cadd32199f06cbadaeaf8b6a887" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;True&lt;/code&gt; if path is an existing regular file. This follows symbolic links, so both &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.islink&quot;&gt;islink()&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;isfile()&lt;/a&gt; can be true for the same path.</source>
          <target state="translated">如果path是现有的常规文件，则返回 &lt;code&gt;True&lt;/code&gt; 。 这遵循符号链接，因此，对于同一路径， &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.islink&quot;&gt;islink（）&lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;isfile（）&lt;/a&gt;都可以为true。</target>
        </trans-unit>
        <trans-unit id="c416828ffe527204e9705ff84ac69c575514fa70" translate="yes" xml:space="preserve">
          <source>Return True if path is an existing regular file. This follows symbolic
  links, so both &lt;code&gt;islink()&lt;/code&gt; and &lt;code&gt;isfile()&lt;/code&gt; can be true for the same path.</source>
          <target state="translated">如果path是现有的常规文件，则返回True。 这遵循符号链接，因此，对于同一路径， &lt;code&gt;islink()&lt;/code&gt; 和 &lt;code&gt;isfile()&lt;/code&gt; 都可以为true。</target>
        </trans-unit>
        <trans-unit id="480f0d6eca70fda19ed1cfd881e8db7b38b30b6d" translate="yes" xml:space="preserve">
          <source>SRC: &lt;a href=&quot;http://www.pfinn.net/python-check-if-file-exists.html&quot;&gt;http://www.pfinn.net/python-check-if-file-exists.html&lt;/a&gt;</source>
          <target state="translated">SRC： &lt;a href=&quot;http://www.pfinn.net/python-check-if-file-exists.html&quot;&gt;http&lt;/a&gt; ： //www.pfinn.net/python-check-if-file-exists.html</target>
        </trans-unit>
        <trans-unit id="418acfb7d49ae4b9747a1895a7c2c368f346ec6b" translate="yes" xml:space="preserve">
          <source>Since I also work in &lt;em&gt;C&lt;/em&gt;, I use this method as well because under the hood, it calls &lt;strong&gt;native &lt;em&gt;API&lt;/em&gt;s&lt;/strong&gt; (again, via &lt;em&gt;&quot;${PYTHON_SRC_DIR}/Modules/posixmodule.c&quot;&lt;/em&gt;), but it also opens a gate for possible &lt;strong&gt;user errors&lt;/strong&gt;, and it's not as &lt;em&gt;Python&lt;/em&gt;ic as other variants. So, as @AaronHall rightly pointed out, don't use it unless you know what you're doing:</source>
          <target state="translated">由于我也使用&lt;em&gt;C语言&lt;/em&gt; ，因此我也使用此方法，因为在&lt;em&gt;后台&lt;/em&gt;它调用了&lt;strong&gt;本机&lt;em&gt;API&lt;/em&gt;&lt;/strong&gt; （同样通过&lt;em&gt;&amp;ldquo; $ {PYTHON_SRC_DIR} /Modules/posixmodule.c&amp;rdquo;&lt;/em&gt; ），但它也为可能的&lt;strong&gt;用户&lt;/strong&gt;打开了一扇门&lt;strong&gt;errors&lt;/strong&gt; ，它不像其他变体那样像&lt;em&gt;Python&lt;/em&gt; ic。 因此，正如@AaronHall正确指出的那样，除非您知道自己在做什么，否则不要使用它：</target>
        </trans-unit>
        <trans-unit id="4e081acedac5348eeca514bf8754f18b5a2a5859" translate="yes" xml:space="preserve">
          <source>Since these iterate over folders, (in most of the cases) they are inefficient for our problem (there are exceptions, like non wildcarded &lt;em&gt;glob&lt;/em&gt;bing - as @ShadowRanger pointed out), so I'm not going to insist on them. Not to mention that in some cases, filename processing might be required.</source>
          <target state="translated">由于这些遍历文件夹，（在大多数情况下）它们对于我们的问题效率不高（有一些例外，例如非通配&lt;em&gt;glob&lt;/em&gt; bing-如@ShadowRanger所指出），因此我不再坚持使用它们。 更不用说在某些情况下，可能需要文件名处理。</target>
        </trans-unit>
        <trans-unit id="ef8ad7d35edc8d5906794e416a2417426387ee33" translate="yes" xml:space="preserve">
          <source>So let's get a file that we know is a file:</source>
          <target state="translated">所以,让我们得到一个我们知道是文件的文件。</target>
        </trans-unit>
        <trans-unit id="2a3bb40ae80994d030f01c5b7c25d767f5b05a5b" translate="yes" xml:space="preserve">
          <source>So raising exceptions is considered to be an acceptable, and Pythonic, approach for flow control in your program. And one should consider handling missing files with IOErrors, rather than &lt;code&gt;if&lt;/code&gt; statements (&lt;em&gt;just an advice&lt;/em&gt;).</source>
          <target state="translated">因此，引发异常被认为是程序中流控制的可接受且Pythonic的方法。 并且应该考虑使用IOErrors处理丢失的文件，而不是 &lt;code&gt;if&lt;/code&gt; 语句（ &lt;em&gt;只是建议&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fa536419723a345ff2ddb12f28c3d59d3c780110" translate="yes" xml:space="preserve">
          <source>So we need to use &lt;code&gt;is_file&lt;/code&gt;:</source>
          <target state="translated">因此，我们需要使用 &lt;code&gt;is_file&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a378bd712dd5bfae1cae597f5f9f871b3a2788bb" translate="yes" xml:space="preserve">
          <source>Starting with Python 3.4, the &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;&lt;code&gt;pathlib&lt;/code&gt; module&lt;/a&gt; offers an object-oriented approach (backported to &lt;code&gt;pathlib2&lt;/code&gt; in Python 2.7):</source>
          <target state="translated">从Python 3.4开始， &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt; &lt;code&gt;pathlib&lt;/code&gt; 模块&lt;/a&gt;提供了一种面向对象的方法（在Python 2.7中 &lt;code&gt;pathlib2&lt;/code&gt; 移植到pathlib2 ）：</target>
        </trans-unit>
        <trans-unit id="0411618e6c534569cfc6b8e34a18a081fb5d17d8" translate="yes" xml:space="preserve">
          <source>Style: Section &quot;Handling unusual conditions&quot; of &lt;a href=&quot;http://allendowney.com/sd/notes/notes11.txt&quot;&gt;http://allendowney.com/sd/notes/notes11.txt&lt;/a&gt;</source>
          <target state="translated">样式： &lt;a href=&quot;http://allendowney.com/sd/notes/notes11.txt&quot;&gt;http&lt;/a&gt; ：//allendowney.com/sd/notes/notes11.txt的&amp;ldquo;处理异常情况&amp;rdquo;部分</target>
        </trans-unit>
        <trans-unit id="cde65e3e48762cf615039585856511edabc67b5c" translate="yes" xml:space="preserve">
          <source>Testing for files and folders with &lt;code&gt;os.path.isfile()&lt;/code&gt;, &lt;code&gt;os.path.isdir()&lt;/code&gt; and &lt;code&gt;os.path.exists()&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;os.path.isfile()&lt;/code&gt; ， &lt;code&gt;os.path.isdir()&lt;/code&gt; 和 &lt;code&gt;os.path.exists()&lt;/code&gt; 测试文件和文件夹</target>
        </trans-unit>
        <trans-unit id="df18cbc4306e1fa89ca1399437058ce4f49db703" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pathlib.Path&lt;/code&gt; method (included in Python 3+, installable with pip for Python 2)</source>
          <target state="translated">&lt;code&gt;pathlib.Path&lt;/code&gt; 方法（包含在Python 3+中，可通过pip安装在Python 2中）</target>
        </trans-unit>
        <trans-unit id="530b364f38885f326cd1f531e7470053b4411886" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Lnx&lt;/em&gt; (&lt;em&gt;Ubtu (16 x64)&lt;/em&gt;) counterpart as well:</source>
          <target state="translated">&lt;em&gt;Lnx&lt;/em&gt; （ &lt;em&gt;Ubtu（16 x64）&lt;/em&gt; ）对应项也是如此：</target>
        </trans-unit>
        <trans-unit id="13a09abaae156d8f74be92cfd84bbc68f9b952e1" translate="yes" xml:space="preserve">
          <source>The code itself does not use a &lt;code&gt;try&lt;/code&gt; block&amp;hellip; except in determining the operating system and thus steering you to the &quot;Unix&quot;-style &lt;code&gt;find&lt;/code&gt; or the hand-buillt &lt;code&gt;find&lt;/code&gt;. Timing tests showed that the &lt;code&gt;try&lt;/code&gt; was faster in determining the OS, so I did use one there (but nowhere else).</source>
          <target state="translated">该代码本身不使用 &lt;code&gt;try&lt;/code&gt; 块&amp;hellip;&amp;hellip;除非确定操作系统，然后使您转向&amp;ldquo; Unix&amp;rdquo;风格的 &lt;code&gt;find&lt;/code&gt; 或手动编译 &lt;code&gt;find&lt;/code&gt; 。 时序测试表明， &lt;code&gt;try&lt;/code&gt; 确定操作系统的速度更快，因此我确实在那里使用了操作系统（但没有其他地方使用）。</target>
        </trans-unit>
        <trans-unit id="24d50f1641bf928a4330f0d682a38d4d97ffe256" translate="yes" xml:space="preserve">
          <source>The implementation, if you care to look, is here:
&lt;a href=&quot;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190&quot;&gt;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190&lt;/a&gt;</source>
          <target state="translated">如果您愿意看的话，可以在这里找到实现： &lt;a href=&quot;https://github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190&quot;&gt;https&lt;/a&gt; : //github.com/uqfoundation/pox/blob/89f90fb308f285ca7a62eabe2c38acb87e89dad9/pox/shutils.py#L190</target>
        </trans-unit>
        <trans-unit id="a74a8a63b22547ba3d5093ec5df9fef2c1e24790" translate="yes" xml:space="preserve">
          <source>The ouput would be:</source>
          <target state="translated">产量将是:</target>
        </trans-unit>
        <trans-unit id="1865aad596e6ed9eb4f9647b68658f733fae4544" translate="yes" xml:space="preserve">
          <source>The pathlib module has lots of cool stuff in it: convenient globbing, checking file's owner, easier path joining, etc.  It's worth checking out.  If you're on an older Python (version 2.6 or later), you can still install pathlib with pip:</source>
          <target state="translated">pathlib模块有很多很酷的东西:方便的globbing,检查文件的所有者,更方便的路径连接等等。它值得一试。如果你使用的是旧的 Python (2.6 或更高版本),你仍然可以用 pip 安装 pathlib。</target>
        </trans-unit>
        <trans-unit id="86939b2f23d78f6587e8899c5fbcad699b1fca6d" translate="yes" xml:space="preserve">
          <source>Then import it as follows:</source>
          <target state="translated">然后按以下方法导入。</target>
        </trans-unit>
        <trans-unit id="10cf03aad058b6e2b5effd7477540fa9d0ac3551" translate="yes" xml:space="preserve">
          <source>Then, depending on the result, your program can just keep running from there or you can code to stop it if you want.</source>
          <target state="translated">然后,根据结果,你的程序可以从那里继续运行,或者如果你想的话,你可以用代码来停止它。</target>
        </trans-unit>
        <trans-unit id="10303b9773cea55a7373894dca044a1fb0b21612" translate="yes" xml:space="preserve">
          <source>This allows common &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#try&quot;&gt;try&lt;/a&gt;...&lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#except&quot;&gt;except&lt;/a&gt;...&lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#finally&quot;&gt;finally&lt;/a&gt; usage patterns to be encapsulated for convenient reuse.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#except&quot;&gt;除了&lt;/a&gt; &lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#finally&quot;&gt;最终&lt;/a&gt;使用模式外，这可以封装常见的&lt;a href=&quot;https://docs.python.org/3/reference/compound_stmts.html#try&quot;&gt;尝试&lt;/a&gt;模式，以便方便重用。</target>
        </trans-unit>
        <trans-unit id="013b8396ae1ec7be20358e949069add1eed3da4a" translate="yes" xml:space="preserve">
          <source>This answer says it prefers a non-Pythonic, error-prone method, with no justification. It seems to encourage users to use low-level APIs without understanding them.</source>
          <target state="translated">这个回答说它更喜欢用非Pythonic,容易出错的方法,没有任何理由。这似乎是在鼓励用户在不了解API的情况下使用低级API。</target>
        </trans-unit>
        <trans-unit id="e34e91f34043e5905acc95f65395d3f7ae45d71b" translate="yes" xml:space="preserve">
          <source>This doesn't also apply to &lt;em&gt;Win&lt;/em&gt; (but that's not such a big deal, since &lt;em&gt;msvcrt.dll&lt;/em&gt; is located in &lt;em&gt;&quot;%SystemRoot%\System32&quot;&lt;/em&gt; which is in &lt;em&gt;%PATH%&lt;/em&gt; by default). I wanted to take things further and replicate this behavior on &lt;em&gt;Win&lt;/em&gt; (and submit a patch), but as it turns out, &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress&quot;&gt;[MS.Docs]: GetProcAddress function&lt;/a&gt; only &quot;sees&quot; &lt;strong&gt;exported&lt;/strong&gt; symbols, so unless someone declares the functions in the main executable as &lt;code&gt;__declspec(dllexport)&lt;/code&gt; (why on Earth the &lt;em&gt;regular&lt;/em&gt; person would do that?), the main program is loadable but pretty much unusable</source>
          <target state="translated">这也不适用于&lt;em&gt;Win&lt;/em&gt; （但是这没什么大不了的，因为&lt;em&gt;msvcrt.dll&lt;/em&gt;位于&lt;em&gt;&amp;ldquo;％SystemRoot％\ System32&amp;rdquo;中&lt;/em&gt; ，默认情况下位于&lt;em&gt;％PATH％中&lt;/em&gt; ）。 我想更进一步，在&lt;em&gt;Win&lt;/em&gt;上复制此行为（并提交补丁），但事实证明， &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress&quot;&gt;[MS.Docs]：GetProcAddress函数&lt;/a&gt;仅&amp;ldquo;看到&amp;rdquo; &lt;strong&gt;导出的&lt;/strong&gt;符号，因此除非有人在主可执行文件中声明该函数就像 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; （为什么普通人会这样做？），主程序是可加载的，但是几乎不可用</target>
        </trans-unit>
        <trans-unit id="7d512ce20a34ce68ebd3c6ebeb6e56887b5b877e" translate="yes" xml:space="preserve">
          <source>This has to be handled with care, since functions like &lt;em&gt;main&lt;/em&gt;, &lt;em&gt;Py_Main&lt;/em&gt; and (all the) others are available; calling them could have disastrous effects (on the current program)</source>
          <target state="translated">这必须谨慎处理，因为像&lt;em&gt;main&lt;/em&gt; ， &lt;em&gt;Py_Main&lt;/em&gt;和（所有）其他函数都可用。 打电话给他们可能会造成灾难性的影响（对当前程序）</target>
        </trans-unit>
        <trans-unit id="ada1dec3ed33a08f60c128b70954cbdb8457037b" translate="yes" xml:space="preserve">
          <source>This is the simplest way to check if a file exists. Just &lt;strong&gt;because&lt;/strong&gt; the file existed when you checked doesn't &lt;strong&gt;guarantee&lt;/strong&gt; that it will be there when you need to open it.</source>
          <target state="translated">这是检查文件是否存在的最简单方法。 仅仅&lt;strong&gt;因为&lt;/strong&gt;文件在您检查时存在并不&lt;strong&gt;保证&lt;/strong&gt;在您需要打开文件时该文件就会存在。</target>
        </trans-unit>
        <trans-unit id="faf24dd71990fb8b6a4f9fda6ae044c126abf438" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;True&lt;/code&gt; for both files and directories but you can instead use</source>
          <target state="translated">这对文件和目录都返回 &lt;code&gt;True&lt;/code&gt; ，但是您可以改用</target>
        </trans-unit>
        <trans-unit id="dd377f1e075e1a6762708def8e94ab1cc954e78d" translate="yes" xml:space="preserve">
          <source>This seems to encourage users to adopt poor practices.</source>
          <target state="translated">这似乎是在鼓励用户采用不良的做法。</target>
        </trans-unit>
        <trans-unit id="1ebd1badf365b531b3f784e4041ddcafc927cdcf" translate="yes" xml:space="preserve">
          <source>This will check the existence of what you specify. However, it checks for files &lt;em&gt;and&lt;/em&gt; directories so beware about how you use it.</source>
          <target state="translated">这将检查您指定的内容是否存在。 但是，它会检查文件&lt;em&gt;和&lt;/em&gt;目录，因此请注意如何使用它们。</target>
        </trans-unit>
        <trans-unit id="599782e6dcde6e17a96f8d011122afca2b083bc5" translate="yes" xml:space="preserve">
          <source>This will check whether you have access to the file. It will check for permissions. Based on the os.py documentation, typing in &lt;code&gt;os.F_OK&lt;/code&gt;, it will check the existence of the path. However, using this will create a security hole, as someone can attack your file using the time between checking the permissions and opening the file. You should instead go directly to opening the file instead of checking its permissions. (&lt;a href=&quot;https://docs.python.org/2/glossary.html#term-eafp&quot;&gt;EAFP&lt;/a&gt; vs &lt;a href=&quot;https://docs.python.org/2/glossary.html#term-lbyl&quot;&gt;LBYP&lt;/a&gt;). If you're not going to open the file afterwards, and only checking its existence, then you can use this.</source>
          <target state="translated">这将检查您是否有权访问该文件。 它将检查权限。 根据os.py文档，输入 &lt;code&gt;os.F_OK&lt;/code&gt; ，它将检查路径的存在。 但是，使用此选项将创建一个安全漏洞，因为有人可以使用检查权限到打开文件之间的时间来攻击您的文件。 相反，您应该直接打开文件而不是检查其权限。 （ &lt;a href=&quot;https://docs.python.org/2/glossary.html#term-eafp&quot;&gt;EAFP&lt;/a&gt;与&lt;a href=&quot;https://docs.python.org/2/glossary.html#term-lbyl&quot;&gt;LBYP&lt;/a&gt; ）。 如果您以后不打算打开文件，而仅检查其存在，则可以使用它。</target>
        </trans-unit>
        <trans-unit id="5b5ffcaf081dc75e6b418d427d70f91a6d9dec08" translate="yes" xml:space="preserve">
          <source>This will handle the case of the &lt;code&gt;file_path&lt;/code&gt; being &lt;code&gt;None&lt;/code&gt; or empty string.</source>
          <target state="translated">这将处理 &lt;code&gt;file_path&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; 或为空字符串的情况。</target>
        </trans-unit>
        <trans-unit id="8dba64974b8642857ae28899a73df6c30d03c303" translate="yes" xml:space="preserve">
          <source>This will return true or false based on its existence.</source>
          <target state="translated">这将根据它的存在返回真或假。</target>
        </trans-unit>
        <trans-unit id="fc31e69259d13bfced912cfbab7ad7e00fd46dea" translate="yes" xml:space="preserve">
          <source>To check a directory, do:</source>
          <target state="translated">要检查一个目录,要做。</target>
        </trans-unit>
        <trans-unit id="3416f5cb91745acbdaae2a2dddc268e01225ffdb" translate="yes" xml:space="preserve">
          <source>To check whether a &lt;code&gt;Path&lt;/code&gt; object exists independently of whether is it a file or directory, use &lt;code&gt;exists()&lt;/code&gt;:</source>
          <target state="translated">要检查 &lt;code&gt;Path&lt;/code&gt; 对象是否独立于文件还是目录而 &lt;code&gt;exists()&lt;/code&gt; ，请使用exist（） ：</target>
        </trans-unit>
        <trans-unit id="7e5ffee0a503a306dd9fb72ef88ce41742e995a7" translate="yes" xml:space="preserve">
          <source>Try opening the file:</source>
          <target state="translated">试着打开文件。</target>
        </trans-unit>
        <trans-unit id="1a4e2dce5d6775f3efc5d392dd7dcfbb9813ec34" translate="yes" xml:space="preserve">
          <source>Under the hood, both use:</source>
          <target state="translated">罩下,都用。</target>
        </trans-unit>
        <trans-unit id="c78de1502fda99e6b39752620575aa8b8af55212" translate="yes" xml:space="preserve">
          <source>Under the hood, it does &lt;strong&gt;exactly&lt;/strong&gt; the same thing (&lt;em&gt;pathlib.py&lt;/em&gt;, line &lt;em&gt;~#1330&lt;/em&gt;):</source>
          <target state="translated">在&lt;em&gt;后台&lt;/em&gt; ，它做的&lt;strong&gt;完全&lt;/strong&gt;一样（ &lt;em&gt;pathlib.py&lt;/em&gt; ，行&lt;em&gt;〜＃1330&lt;/em&gt; ）：</target>
        </trans-unit>
        <trans-unit id="0c4dd154e57d3342872a767d4176641c8fc8402b" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;&lt;code&gt;isfile()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;True&lt;/code&gt; for directories. So depending on if you want only plain files or also directories, you'll use &lt;code&gt;isfile()&lt;/code&gt; or &lt;code&gt;exists()&lt;/code&gt;. Here is some simple REPL output:</source>
          <target state="translated">与&lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt; &lt;code&gt;isfile()&lt;/code&gt; &lt;/a&gt;不同， exist（）对于目录将返回 &lt;code&gt;True&lt;/code&gt; 。 因此，取决于您只需要纯文件还是目录，您将使用 &lt;code&gt;isfile()&lt;/code&gt; 或exist &lt;code&gt;exists()&lt;/code&gt; 。 这是一些简单的REPL输出：</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="6528187d8e91a930203288ed63867c1ae3e26091" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.isfile&quot;&gt;&lt;code&gt;os.path.isfile()&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://docs.python.org/3.3/library/os.html?highlight=os.access#os.access&quot;&gt;&lt;code&gt;os.access()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">将&lt;a href=&quot;https://docs.python.org/3.3/library/os.path.html?highlight=os.path#os.path.isfile&quot;&gt; &lt;code&gt;os.path.isfile()&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;https://docs.python.org/3.3/library/os.html?highlight=os.access#os.access&quot;&gt; &lt;code&gt;os.access()&lt;/code&gt; 结合使用&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="8395433c21c6033081f4203a964dbda841229f43" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;[Python 3]: contextlib.&lt;strong&gt;suppress&lt;/strong&gt;(&lt;em&gt;*exceptions&lt;/em&gt;)&lt;/a&gt; - which was &lt;strong&gt;specifically&lt;/strong&gt; designed for selectively suppressing exceptions</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;[Python 3]：contextlib。&lt;/a&gt; &lt;strong&gt;抑制&lt;/strong&gt; （ &lt;em&gt;* exceptions&lt;/em&gt; ） -专为选择性抑制异常而设计</target>
        </trans-unit>
        <trans-unit id="63dca5b17c3d20c3489afb0a2fce135a332440f1" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;os.access(path, mode)&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;os.access(path, mode)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ccb25d19aa4f439e92c039f06e2c08c0d55c6044" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;os.path.exists(path)&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;os.path.exists(path)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a09130d4064cb71241e9c92eb3d5f5998cbbe1e5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;scandir()&lt;/a&gt; instead of &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;listdir()&lt;/a&gt; can significantly increase the performance of code that also needs file type or file attribute information, because &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; objects expose this information if the operating system provides it when scanning a directory. All &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt; methods may perform a system call, but &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_dir&quot;&gt;is_dir()&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_file&quot;&gt;is_file()&lt;/a&gt; usually only require a system call for symbolic links; &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.stat&quot;&gt;os.DirEntry.stat()&lt;/a&gt; always requires a system call on Unix but only requires one for symbolic links on Windows.</source>
          <target state="translated">使用&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.scandir&quot;&gt;scandir（）&lt;/a&gt;而不是&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.listdir&quot;&gt;listdir（）&lt;/a&gt;可以大大提高还需要文件类型或文件属性信息的代码的性能，因为如果操作系统在扫描目录时提供了&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt;对象，则os.DirEntry对象将公开此信息。 所有&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry&quot;&gt;os.DirEntry&lt;/a&gt;方法都可以执行系统调用，但是&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_dir&quot;&gt;is_dir（）&lt;/a&gt;和&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.is_file&quot;&gt;is_file（）&lt;/a&gt;通常只需要系统调用即可进行符号链接。 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.DirEntry.stat&quot;&gt;os.DirEntry.stat（）&lt;/a&gt;在Unix上始终需要系统调用，而在Windows上只需要一个系统调用即可。</target>
        </trans-unit>
        <trans-unit id="3c602deb97ce7542bfccf83d47fe88cf36a2893d" translate="yes" xml:space="preserve">
          <source>We like &lt;code&gt;try&lt;/code&gt; because it avoids race conditions. With &lt;code&gt;try&lt;/code&gt;, you simply attempt to read your file, expecting it to be there, and if not, you catch the exception and perform whatever fallback behavior makes sense.</source>
          <target state="translated">我们喜欢 &lt;code&gt;try&lt;/code&gt; 因为它避免了比赛条件。 使用 &lt;code&gt;try&lt;/code&gt; ，您只需尝试读取文件，期望它在那里，否则，您将捕获异常并执行有意义的后备行为。</target>
        </trans-unit>
        <trans-unit id="11dee24909df97ffd7167218bba605d1194d35d4" translate="yes" xml:space="preserve">
          <source>You can (and usually should) still use a &lt;code&gt;try/except&lt;/code&gt; block when opening files:</source>
          <target state="translated">您可以（通常应该）在打开文件时仍然使用 &lt;code&gt;try/except&lt;/code&gt; 块：</target>
        </trans-unit>
        <trans-unit id="7784bbbe5a5c336f12d286e297f0803a9fe8d487" translate="yes" xml:space="preserve">
          <source>You can also test if a file is a certain type of file using &lt;code&gt;os.path.splitext()&lt;/code&gt; to get the extension (if you don't already know it)</source>
          <target state="translated">您还可以使用 &lt;code&gt;os.path.splitext()&lt;/code&gt; 来获取扩展名（如果您尚不知道），以测试文件是否为某种文件类型</target>
        </trans-unit>
        <trans-unit id="53df035e05c38ef007ca2b8b29347ccc17e7055d" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;resolve(strict=True)&lt;/code&gt; in a &lt;code&gt;try&lt;/code&gt; block:</source>
          <target state="translated">您也可以在 &lt;code&gt;try&lt;/code&gt; 块中使用 &lt;code&gt;resolve(strict=True)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4f01e601cacd481f5c7f35810b916f8e0b34e1dd" translate="yes" xml:space="preserve">
          <source>You can follow these three ways:</source>
          <target state="translated">你可以按照这三种方式进行。</target>
        </trans-unit>
        <trans-unit id="ec8dda8508e059554be2c9405118015a0d4115f7" translate="yes" xml:space="preserve">
          <source>You can use the &quot;OS&quot; library of Python:</source>
          <target state="translated">你可以使用Python的 &quot;OS &quot;库。</target>
        </trans-unit>
        <trans-unit id="939818830bc616c3a6efeac98f780e2a1d405b44" translate="yes" xml:space="preserve">
          <source>You can write Brian's suggestion without the &lt;code&gt;try:&lt;/code&gt;.</source>
          <target state="translated">您无需 &lt;code&gt;try:&lt;/code&gt; 即可撰写Brian的建议： 。</target>
        </trans-unit>
        <trans-unit id="286ccde47046b9cee19cb126d447184993fbb983" translate="yes" xml:space="preserve">
          <source>You could try this (safer):</source>
          <target state="translated">你可以试试这个(更安全)。</target>
        </trans-unit>
        <trans-unit id="98a04bbfd86344a14e1ecd9d2cb153c157a6b79b" translate="yes" xml:space="preserve">
          <source>You have the &lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.exists&quot;&gt;&lt;code&gt;os.path.exists&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">您具有&lt;a href=&quot;https://docs.python.org/2/library/os.path.html#os.path.exists&quot;&gt; &lt;code&gt;os.path.exists&lt;/code&gt; &lt;/a&gt;函数：</target>
        </trans-unit>
        <trans-unit id="ea7a34811c2492dcaa209ef15806e5b61c87b16f" translate="yes" xml:space="preserve">
          <source>[Python 3]: os.&lt;strong&gt;walk&lt;/strong&gt;(&lt;em&gt;top, topdown=True, onerror=None, followlinks=False&lt;/em&gt;)</source>
          <target state="translated">[Python 3]：操作系统。 &lt;strong&gt;步行&lt;/strong&gt; （ &lt;em&gt;top，topdown = True，onerror = None，followlinks = False&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="9ffb459d6d30faf56bdf32fa749719a501413758" translate="yes" xml:space="preserve">
          <source>from the &lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;docs&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;https://docs.python.org/library/os.path.html#os.path.isfile&quot;&gt;文档&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="be73dd7f4e02100df1866e6ae1905b8fb136de60" translate="yes" xml:space="preserve">
          <source>if you need to be sure it's a file.</source>
          <target state="translated">如果你需要确定它是一个文件。</target>
        </trans-unit>
        <trans-unit id="6adfed45fd2ed1ca17a5706197051fb6c6c02690" translate="yes" xml:space="preserve">
          <source>is better written as:</source>
          <target state="translated">最好写成:</target>
        </trans-unit>
        <trans-unit id="625ab49ea896effef76c5e7d9931ab9b626630f8" translate="yes" xml:space="preserve">
          <source>it's just a &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; block around &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;[Python 3]: os.&lt;strong&gt;stat&lt;/strong&gt;(&lt;em&gt;path, *, dir_fd=None, follow_symlinks=True&lt;/em&gt;)&lt;/a&gt;. So, your code is &lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt; free, but lower in the framestack there's (at least) &lt;strong&gt;one&lt;/strong&gt; such block. This also applies to other funcs (&lt;strong&gt;including&lt;/strong&gt;&lt;code&gt;os.path.isfile&lt;/code&gt;).</source>
          <target state="translated">它只是&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.stat&quot;&gt;[Python 3]&lt;/a&gt; &lt;strong&gt;&lt;em&gt;之外&lt;/em&gt;&lt;/strong&gt;的&lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;except&lt;/em&gt;&lt;/strong&gt;块：os。 &lt;strong&gt;stat&lt;/strong&gt; （ &lt;em&gt;path，*，dir_fd = None，follow_symlinks = True&lt;/em&gt; ） 。 因此，您的代码是&lt;strong&gt;&lt;em&gt;try&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;除外（&lt;/em&gt;&lt;/strong&gt;免费），但是在帧堆栈中的（至少） &lt;strong&gt;一个&lt;/strong&gt;这样的块较低。 这也适用于其他功能（ &lt;strong&gt;包括&lt;/strong&gt; &lt;code&gt;os.path.isfile&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2425e7713a0225c18ca0b17f07467bbaaa179274" translate="yes" xml:space="preserve">
          <source>to test if it's a file specifically. It follows symlinks.</source>
          <target state="translated">来测试它是否是专门的文件。它遵循的是symlinks。</target>
        </trans-unit>
        <trans-unit id="6abf28170f947a4e00093db1c0c8dcdabc461e0d" translate="yes" xml:space="preserve">
          <source>via &lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/posixmodule.c&quot;&gt;[GitHub]: python/cpython - (master) cpython/Modules/posixmodule.c&lt;/a&gt;</source>
          <target state="translated">通过&lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/posixmodule.c&quot;&gt;[GitHub]：python / cpython-（master）cpython / Modules / posixmodule.c&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
