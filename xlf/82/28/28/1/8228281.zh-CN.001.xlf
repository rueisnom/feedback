<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/8228281">
    <body>
      <group id="8228281">
        <trans-unit id="9dadaa9496929c84c3ab6989b1c844585b555e1d" translate="yes" xml:space="preserve">
          <source>- During execution (Execution Context - Execute phase), the funtion object is created on the fly (&lt;strong&gt;its not executed yet&lt;/strong&gt;), gets assigned to 'greet' variable and it can be invoked using 'greet('somename')'.</source>
          <target state="translated">-在执行过程中（执行上下文-执行阶段），将动态创建功能对象（ &lt;strong&gt;尚未执行&lt;/strong&gt; ），将其分配给'greet'变量，并可以使用'greet（'somename'）'进行调用。</target>
        </trans-unit>
        <trans-unit id="6a158b11158c99a0df72e82df408cf783123c9ff" translate="yes" xml:space="preserve">
          <source>- IIFE, being a function, has its own execution context, meaning all the variables created inside it are local to this function and are not shared with the global execution context.</source>
          <target state="translated">-IIFE作为一个函数,它有自己的执行上下文,这意味着在它内部创建的所有变量都是这个函数的本地变量,不与全局执行上下文共享。</target>
        </trans-unit>
        <trans-unit id="ad28c57779ed69eaee3b61747f53357c4dd296f6" translate="yes" xml:space="preserve">
          <source>- Notice the '()' immediately after the function declaration. Every funtion object has a 'CODE' property attached to it which is callable. And we can call it (or invoke it) using '()' braces.</source>
          <target state="translated">-注意在函数声明后面的'()'。每个funtion对象都有一个'CODE'属性,它是可调用的。我们可以用'()''()'括号来调用它(或调用它)。</target>
        </trans-unit>
        <trans-unit id="7b549f1532a5f31afc5bc29127c287e5f5a88a77" translate="yes" xml:space="preserve">
          <source>- So here, during the execution (Execution Context - Execute Phase), &lt;strong&gt;the function object is created and its executed at the same time&lt;/strong&gt;
- So now, the greeting variable, instead of having the funtion object, has its return value ( a string )</source>
          <target state="translated">-因此，在执行过程中（执行上下文-执行阶段）， &lt;strong&gt;将同时创建并执行功能对象&lt;/strong&gt; -因此，现在，问候变量（而不是funtion对象）具有其返回值（字符串）</target>
        </trans-unit>
        <trans-unit id="f2d32b6c54b2eea7b4f08964506c4a14da8bb30d" translate="yes" xml:space="preserve">
          <source>- When JS engine runs for the first time (Execution Context - Create Phase), this function (on the right side of = above) does not get executed or stored in the memory. Variable 'greet' is assigned 'undefined' value by the JS engine.</source>
          <target state="translated">-当JS引擎第一次运行时(执行上下文-创建阶段),这个函数(在=的右侧)不会被执行或存储在内存中。变量 &quot;greet &quot;被JS引擎分配了 &quot;undefined &quot;值。</target>
        </trans-unit>
        <trans-unit id="ef59722e8ed96066e8f649d55ddc705002e2bbbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Immediately Invoked Funtion Expression:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.立即调用功能表达式：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c57cca2ae891930962d46154d0cdd7701cf2ca8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;So this function gets created and executed at the same time (IIFE).&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;因此，该函数可以同时创建和执行（IIFE）。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c3e8c29c460f778fb10c68b7b5f483c3b0d796f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Correction suggested by &lt;a href=&quot;https://stackoverflow.com/users/69083/guffa&quot;&gt;Guffa&lt;/a&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/users/69083/guffa&quot;&gt;Guffa&lt;/a&gt;建议的更正 ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2ed48c31f74161c223bba47f878a789f77b5069" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Alternative (Recommended)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6替代品（推荐）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47754a1062d962b6ce15d48457bec71b3f369e46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expression&lt;/strong&gt;: Something that returns a value</source>
          <target state="translated">&lt;strong&gt;表达式&lt;/strong&gt; ：返回值的东西</target>
        </trans-unit>
        <trans-unit id="46b1b6e1b44f3520e2793cb8255547db860a73db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Expression&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;函数表达式&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="50eff3e72b9320085e3583c9fee5aae42ebfd0b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How IIFE works&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;IIFE如何运作&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="804eeffad7b4e11fec563767c8bf6ee40edfb082" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How function expression works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;函数表达式的工作原理：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="315b05a17b0a236580165cfed17571d5661f8e8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IIFE keeps our code safe.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IIFE使我们的代码安全。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e21af655815475d3a776d89c71bee90a334352e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important usecase for IIFE: &lt;br/&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IIFE的重要用例：&lt;/strong&gt; &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="733ad654e28f5f19e0ccacbd5bd074cd18bf34ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Most Common Use-case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最常见的用例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e719c6166298c86686ad285062a762b144fe333" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typical usecase of IIFE in JS:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JS中IIFE的典型用例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd4b667e7450fd1da7be97c55c23d9054c910440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;
Since this is a pretty popular topic, it's worth mentioning that IIFE's can also be written with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES6's arrow function&lt;/a&gt; (like &lt;a href=&quot;https://stackoverflow.com/users/368691/gajus&quot;&gt;Gajus&lt;/a&gt; has pointed out &lt;a href=&quot;https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript/8228308#comment43521302_8228308&quot;&gt;in a comment&lt;/a&gt;) :</source>
          <target state="translated">&lt;strong&gt;更新&lt;/strong&gt;由于这是一个非常受欢迎的话题，值得一提的是，IIFE也可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES6的arrow函数&lt;/a&gt;编写（就像&lt;a href=&quot;https://stackoverflow.com/users/368691/gajus&quot;&gt;Gajus&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript/8228308#comment43521302_8228308&quot;&gt;在评论中&lt;/a&gt;指出的那样）：</target>
        </trans-unit>
        <trans-unit id="f4c3381f63f3402e4c893d3819f4639fcfc1cafd" translate="yes" xml:space="preserve">
          <source>A self-invoking expression is invoked (started) automatically, without
  being called.</source>
          <target state="translated">自动调用(启动)一个自我激励的表达方式,不需要被调用。</target>
        </trans-unit>
        <trans-unit id="47c2a38385c0fcf1a4d905bdef7a2aae0eec35d8" translate="yes" xml:space="preserve">
          <source>After we have an expression which evaluates to a function object we then can immediately &lt;strong&gt;invoke&lt;/strong&gt; the function object with the &lt;code&gt;()&lt;/code&gt; operator. For example:</source>
          <target state="translated">在获得一个计算结果为函数对象的表达式之后，我们可以立即使用 &lt;code&gt;()&lt;/code&gt; 运算符&lt;strong&gt;调用&lt;/strong&gt;该函数对象。 例如：</target>
        </trans-unit>
        <trans-unit id="7f06afd34a563714ec314b68da3f205e40cda76f" translate="yes" xml:space="preserve">
          <source>Alternatively, it can be:</source>
          <target state="translated">另外,也可以是:</target>
        </trans-unit>
        <trans-unit id="ef9203bbedd9adb33629bea17c2eb428a0a6054a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IIFE&lt;/code&gt; can also be described as a self-invoking anonymous function. Its most common usage is to limit the scope of a variable made via var or to encapsulate context to avoid name collisions.</source>
          <target state="translated">&lt;code&gt;IIFE&lt;/code&gt; 也可以描述为自调用匿名函数。 它最常见的用法是限制通过var生成的变量的范围，或封装上下文以避免名称冲突。</target>
        </trans-unit>
        <trans-unit id="6054fe82da32385b7ed0dbfbae9f67f812a1d185" translate="yes" xml:space="preserve">
          <source>An expression is simply a bunch of code which can be evaluated to &lt;strong&gt;a single value&lt;/strong&gt;. In case of the expressions in the above example this value was a &lt;strong&gt;single function object&lt;/strong&gt;.</source>
          <target state="translated">表达式只是一堆可以评估为&lt;strong&gt;单个值&lt;/strong&gt;的代码。 对于上述示例中的表达式，此值为&lt;strong&gt;单个函数对象&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b232444188015e33e960e2241dffbfda478d3cb" translate="yes" xml:space="preserve">
          <source>An immediately invoked function expression (IIFE) is a function that's executed as soon as it's created. It has no connection with any events or asynchronous execution. You can define an IIFE as shown below:</source>
          <target state="translated">一个立即调用的函数表达式(IIFE)是一个函数一旦被创建就会被执行。它与任何事件或异步执行没有关系。你可以定义一个IIFE,如下图所示。</target>
        </trans-unit>
        <trans-unit id="0cd1fb5aec37c798839c8d1d191684f280e2a7bc" translate="yes" xml:space="preserve">
          <source>An immediately-invoked function expression (IIFE) immediately calls a function. This simply means that the function is executed immediately after the completion of the definition.</source>
          <target state="translated">一个立即触发的函数表达式(IIFE)会立即调用一个函数。这简单地说,就是在定义完成后立即执行该函数。</target>
        </trans-unit>
        <trans-unit id="e23b647b429bf20b9259177559b651dd7775b8c6" translate="yes" xml:space="preserve">
          <source>And the explanation of the syntax is: The function within the first &lt;code&gt;()&lt;/code&gt; parenthesis is the function which has no name and by the next &lt;code&gt;();&lt;/code&gt; parenthesis you can understand that it is called at the time it is defined. And you can pass any argument in this second &lt;code&gt;()&lt;/code&gt; parenthesis which will be grabbed in the function which is in the first parenthesis. See this example:</source>
          <target state="translated">语法的解释是：first &lt;code&gt;()&lt;/code&gt; 括号内的函数是没有名称的函数，next &lt;code&gt;();&lt;/code&gt; 后面是该函数； 括号中，您可以理解它在定义时即被调用。 您可以在第二个 &lt;code&gt;()&lt;/code&gt; 括号中传递任何参数，该参数将在第一个括号中的函数中获取。 请参阅以下示例：</target>
        </trans-unit>
        <trans-unit id="2a08b6d6216c318f07a63ce64ce5e83f1c1d8bf5" translate="yes" xml:space="preserve">
          <source>But the above two construct are not &lt;strong&gt;IIFE&lt;/strong&gt;.</source>
          <target state="translated">但是以上两个构造不是&lt;strong&gt;IIFE&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ee3f501ca67bbeb5c059c6705b2167b219acadc" translate="yes" xml:space="preserve">
          <source>By using this syntax you avoid colliding with global variables declared elsewhere in your JavaScript code.</source>
          <target state="translated">通过使用这个语法,可以避免与JavaScript代码中其他地方声明的全局变量碰撞。</target>
        </trans-unit>
        <trans-unit id="fe1b40c8fab9f166a675bd98799bd55d26f8fea3" translate="yes" xml:space="preserve">
          <source>Call the function immediately -- oops:</source>
          <target state="translated">立即调用该函数 ----Oops:</target>
        </trans-unit>
        <trans-unit id="bed0e00f9fc23279ca684a1d493bc0948fd61a7d" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;http://www.w3schools.com/js/js_function_definition.asp&quot;&gt;W3Schools explanation of a self-invoking function&lt;/a&gt;.</source>
          <target state="translated">查看&lt;a href=&quot;http://www.w3schools.com/js/js_function_definition.asp&quot;&gt;W3Schools关于自调用功能的说明&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="555c6fb5b44d531f9e53fcbc10a3a35e96167dd6" translate="yes" xml:space="preserve">
          <source>Consider the function below written in a file named iife.js</source>
          <target state="translated">考虑一下下面写在一个名为iife.js的文件中的函数。</target>
        </trans-unit>
        <trans-unit id="dfb3b4ee9c5d621bdda0a0d76975d4708fc3ac9d" translate="yes" xml:space="preserve">
          <source>Consider the part within the first pair of parentheses: &lt;code&gt;(&lt;b&gt;function(){}&lt;/b&gt;)();&lt;/code&gt;....it is a regular function expression. Then look at the last pair &lt;code&gt;(function(){})&lt;b&gt;()&lt;/b&gt;;&lt;/code&gt;, this is normally added to an expression to call a function; in this case, our prior expression.</source>
          <target state="translated">考虑第一对括号中的部分： &lt;code&gt;(&lt;b&gt;function(){}&lt;/b&gt;)();&lt;/code&gt; ....这是一个正则函数表达式。 然后查看最后一对 &lt;code&gt;(function(){})&lt;b&gt;()&lt;/b&gt;;&lt;/code&gt; ，通常将其添加到表达式中以调用函数； 在这种情况下，我们的先前表达。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7ac36349dda560270779b789cbf43d471f646ee7" translate="yes" xml:space="preserve">
          <source>Example: Try out following in chrome console. These are expressions in JS.</source>
          <target state="translated">例子。在chrome控制台中试着用下面这些表达式。这些是JS中的表达式。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="a16fbf4816018018ce84d149cfed2d3768185a11" translate="yes" xml:space="preserve">
          <source>Fiddle: &lt;a href=&quot;http://jsfiddle.net/maniator/LqvpQ/&quot;&gt;http://jsfiddle.net/maniator/LqvpQ/&lt;/a&gt;</source>
          <target state="translated">小提琴： &lt;a href=&quot;http://jsfiddle.net/maniator/LqvpQ/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/maniator/LqvpQ/</target>
        </trans-unit>
        <trans-unit id="3adf70295ac336ffda7f66d5b40c9b5b7da8682d" translate="yes" xml:space="preserve">
          <source>For a Detailed explanation see &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Immediately-Invoked Function Expression (IIFE)&lt;/a&gt;</source>
          <target state="translated">有关详细说明，请参见&lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;立即调用函数表达式（IIFE）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c6fccf633b8091e55000dd559026cd3b58ab04e" translate="yes" xml:space="preserve">
          <source>Function expressions can be made &quot;self-invoking&quot;.</source>
          <target state="translated">函数表达式可以实现 &quot;自我激励&quot;。</target>
        </trans-unit>
        <trans-unit id="26db9da6beae79b61580102af1a1cae9c9752e6a" translate="yes" xml:space="preserve">
          <source>Function expressions will execute automatically if the expression is
  followed by ().</source>
          <target state="translated">如果表达式后面有(),函数表达式将自动执行。</target>
        </trans-unit>
        <trans-unit id="93cc4de26d2f9c0383f0e9df26c846aef1578f8e" translate="yes" xml:space="preserve">
          <source>Here the 'object' you are passing will be accessible within the function by 'obj', as you are grabbing it in the function signature.</source>
          <target state="translated">这里你要传递的 &quot;对象 &quot;将在函数中用 &quot;obj &quot;来访问,因为你在函数签名中抓取了它。</target>
        </trans-unit>
        <trans-unit id="310dbc9ededfe37d2f49c2fae2cfedca9bb3170d" translate="yes" xml:space="preserve">
          <source>I call it a &lt;code&gt;Curly Jail&lt;/code&gt;.</source>
          <target state="translated">我称它为 &lt;code&gt;Curly Jail&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc657204917761bd8680e03ced88ddf4b0d2f99e" translate="yes" xml:space="preserve">
          <source>I think the 2 sets of brackets makes it a bit confusing but I saw another usage in googles example, they used something similar, I hope this will help you understand better:</source>
          <target state="translated">我认为2组括号让人有点困惑,但我在googles的例子中看到了另一个用法,他们用了类似的东西,希望这能帮助你更好地理解。</target>
        </trans-unit>
        <trans-unit id="da90c222860bf1dca29f728207fcaa3217f05ea7" translate="yes" xml:space="preserve">
          <source>I used to know what this meant, but I'm struggling now...</source>
          <target state="translated">我以前知道这是什么意思,但我现在很纠结........</target>
        </trans-unit>
        <trans-unit id="1adaf50c667f60887370ba409da371b6afb75b21" translate="yes" xml:space="preserve">
          <source>IIFE (Immediately invoked function expression) is a function which executes as soon as the script loads and goes away.</source>
          <target state="translated">IIFE(Immediate invoked function expression)是一个在脚本加载后立即执行的函数表达式。</target>
        </trans-unit>
        <trans-unit id="2dbc909f43d9178cbccc47855c456cf4752621ef" translate="yes" xml:space="preserve">
          <source>If there are no special requirements for its return value, then we can write:</source>
          <target state="translated">如果对其返回值没有特殊要求,那么我们可以写。</target>
        </trans-unit>
        <trans-unit id="3bf309c08d49299b6010eb01372d2db6695104c5" translate="yes" xml:space="preserve">
          <source>In ES6 syntax (posting for myself, as I keep landing on this page looking for a quick example):</source>
          <target state="translated">在ES6语法中(为自己发帖,因为我一直在这个页面上寻找一个快速的例子)。</target>
        </trans-unit>
        <trans-unit id="b5f54c58ea6a05bfe712cb33b673358aba022076" translate="yes" xml:space="preserve">
          <source>In ES6, we now can have variables created via &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Both of them are block-scoped (unlike &lt;code&gt;var&lt;/code&gt; which is a function-scoped).</source>
          <target state="translated">在ES6中，我们现在可以通过 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 创建变量。 它们都是块作用域的（不同于 &lt;code&gt;var&lt;/code&gt; 是函数作用域的）。</target>
        </trans-unit>
        <trans-unit id="16f5da42d75b65b9cb3a9aa47149d04a1c65df9a" translate="yes" xml:space="preserve">
          <source>In following example, count will not be available outside the immediately invoked function i.e. Scope of &lt;code&gt;count&lt;/code&gt; will not leak out of the function. You should get a &lt;code&gt;Reference Error&lt;/code&gt;, should you try to access it outside of the immediately invoked function anyway.</source>
          <target state="translated">在下面的示例中，在立即调用的函数之外无法使用 &lt;code&gt;count&lt;/code&gt; ,即count的范围不会泄漏出该函数。 无论如何，如果您尝试在立即调用的函数之外访问它，都应该得到一个 &lt;code&gt;Reference Error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed59eaac2704626c5d7967c3ef0bd1a82cf33639" translate="yes" xml:space="preserve">
          <source>In jQuery there is a similar construct that you might be thinking of:</source>
          <target state="translated">在jQuery中有一个类似的构造,你可能会想到。</target>
        </trans-unit>
        <trans-unit id="3285fe005e794f8056d470509f3d977dcccbf1a1" translate="yes" xml:space="preserve">
          <source>In other words, they are like programs that &quot;make classes', at the beginning of program. After they are instantiated (automatically), the only functions that are available are the ones returned in by the anonymous function. However, all the other 'hidden' functions are still there, along with any state (variables set during scope creation).</source>
          <target state="translated">换句话说,它们就像程序 &quot;做类 &quot;一样,在程序开始的时候。当它们被实例化后(自动),唯一可用的函数是由匿名函数返回的函数。然而,所有其他的 &quot;隐藏 &quot;函数和任何状态(在创建作用域时设置的变量)都还在那里。</target>
        </trans-unit>
        <trans-unit id="2246f55eec4876f796cbcd0d31de04ec8a5653b5" translate="yes" xml:space="preserve">
          <source>In the code snippet above, &amp;ldquo;&lt;em&gt;var app&lt;/em&gt;&amp;rdquo; is a local variable now.</source>
          <target state="translated">在上面的代码片段中，&amp;ldquo; &lt;em&gt;var app&lt;/em&gt; &amp;rdquo;现在是一个局部变量。</target>
        </trans-unit>
        <trans-unit id="c65f76b1db4bba18bb99168719c858dda4d4fb91" translate="yes" xml:space="preserve">
          <source>In this example, we used &lt;code&gt;let&lt;/code&gt; to define a &lt;code&gt;count&lt;/code&gt; variable which makes &lt;code&gt;count&lt;/code&gt; limited to the block of code, we created with the curly brackets &lt;code&gt;{...}&lt;/code&gt;.</source>
          <target state="translated">在此示例中，我们使用 &lt;code&gt;let&lt;/code&gt; 来定义一个 &lt;code&gt;count&lt;/code&gt; 变量，该变量使 &lt;code&gt;count&lt;/code&gt; 限于使用大括号 &lt;code&gt;{...}&lt;/code&gt; 创建的代码块。</target>
        </trans-unit>
        <trans-unit id="17e4ba3bf69d8e68d6b4400bea5fc5f6ee728362" translate="yes" xml:space="preserve">
          <source>Is this basically saying &lt;code&gt;document.onload&lt;/code&gt;?</source>
          <target state="translated">这基本上是在说 &lt;code&gt;document.onload&lt;/code&gt; 吗？</target>
        </trans-unit>
        <trans-unit id="fd185ef785c5b04bd70812f4d46089d0eb0fa051" translate="yes" xml:space="preserve">
          <source>It declares an anonymous function, then calls it:</source>
          <target state="translated">它声明了一个匿名函数,然后调用它。</target>
        </trans-unit>
        <trans-unit id="82e817152a0385d95b61dff4c870bac1a4884074" translate="yes" xml:space="preserve">
          <source>It doesn't need to be any more complicated than that.</source>
          <target state="translated">不需要比这更复杂了。</target>
        </trans-unit>
        <trans-unit id="d46472342d72627637ee258e3d6fdccc6199cf72" translate="yes" xml:space="preserve">
          <source>It has nothing to do with any event-handler for any events (such as &lt;code&gt;document.onload&lt;/code&gt;).</source>
          <target state="translated">它与任何事件的任何事件处理程序无关（例如 &lt;code&gt;document.onload&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7c65f9349f5c5e98740e05bb18a002d20447896d" translate="yes" xml:space="preserve">
          <source>It is called IIFE - Immediately Invoked Function Expression. Here is an example to show it's syntax and usage. It is used to scope the use of variables only till the function and not beyond.</source>
          <target state="translated">它被称为IIFE-立即调用函数表达式。下面是一个例子来说明它的语法和用法。它只用于范围化使用变量,直到函数之前,而不是超越函数。</target>
        </trans-unit>
        <trans-unit id="2b232da97c45835910b21510560d717bf4925972" translate="yes" xml:space="preserve">
          <source>It is called a function expression because the &lt;code&gt;( yourcode )&lt;/code&gt; operator in Javascript force it into an expression. The difference between a &lt;strong&gt;function expression&lt;/strong&gt; and a &lt;strong&gt;function declaration&lt;/strong&gt; is the following:</source>
          <target state="translated">之所以称为函数表达式，是因为Javascript中的 &lt;code&gt;( yourcode )&lt;/code&gt; 运算符将其强制为表达式。 &lt;strong&gt;函数表达式&lt;/strong&gt;和&lt;strong&gt;函数声明&lt;/strong&gt;之间的区别如下：</target>
        </trans-unit>
        <trans-unit id="a1cc8fef367a1d081643d3e45d670fa0885cf488" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Immediately-Invoked Function Expression&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;&lt;strong&gt;IIFE&lt;/strong&gt;&lt;/a&gt; for short. It executes immediately after it&amp;rsquo;s created.</source>
          <target state="translated">它是&lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;立即调用的函数表达式&lt;/a&gt; ，简称&lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;&lt;strong&gt;IIFE&lt;/strong&gt;&lt;/a&gt; 。 它在创建后立即执行。</target>
        </trans-unit>
        <trans-unit id="5b9bc8fdc31871ad312f7674abc5335932340a6a" translate="yes" xml:space="preserve">
          <source>It's just an anonymous function that is executed right after it's created.</source>
          <target state="translated">它只是一个匿名的函数,在创建后立即执行。</target>
        </trans-unit>
        <trans-unit id="6a701e3ab7c285721f76ef5ce5480d80f7f9c81f" translate="yes" xml:space="preserve">
          <source>It's just as if you assigned it to a variable, and used it right after, only without the variable:</source>
          <target state="translated">就像你把它分配给一个变量,然后马上使用,只是没有了变量一样。</target>
        </trans-unit>
        <trans-unit id="cb9f7eca5141640b0ea0732a3094579501b0966b" translate="yes" xml:space="preserve">
          <source>JavaScript prior to ECMAScript 6 used lexical scoping, so IIFE was used for simulating block scoping. (With ECMAScript 6 block scoping is possible with the introduction of the &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords.)
&lt;a href=&quot;https://gist.github.com/gurucharanmk/5071d37bb5af61a93562fbe024a975de&quot;&gt;Reference for issue with lexical scoping&lt;/a&gt;</source>
          <target state="translated">ECMAScript 6之前的JavaScript使用词法作用域，因此IIFE用于模拟块作用域。 （通过引入 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 关键字，可以使用ECMAScript 6进行块范围界定。） &lt;a href=&quot;https://gist.github.com/gurucharanmk/5071d37bb5af61a93562fbe024a975de&quot;&gt;词汇范围界定的参考&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e19d95ce34c23849a24e90884cd6e222319e0a3d" translate="yes" xml:space="preserve">
          <source>No, this construct just creates a scope for naming. If you break it in parts you can see that you have an external</source>
          <target state="translated">不,这个构造只是创建了一个命名的范围。如果你把它分成几个部分,你可以看到你有一个外部的</target>
        </trans-unit>
        <trans-unit id="9ec030aac7f160c37131b600f5a5340267908578" translate="yes" xml:space="preserve">
          <source>Normally, JavaScript code has global scope in the application. When we declare global variable in it, there is a chance for using the same duplicate variable  in some other area of the development for some other purpose. Because of this duplication there may happen some error. So we can avoid this global variables by using immediately invoking function expression , this expression is self-executing expression.When we make our code inside this &lt;strong&gt;IIFE&lt;/strong&gt; expression global variable will be like local scope and local variable.</source>
          <target state="translated">通常，JavaScript代码在应用程序中具有全局作用域。 当我们在其中声明全局变量时，就有可能在开发的其他区域中将相同的重复变量用于其他目的。 由于此重复，可能会发生一些错误。 因此我们可以通过立即调用函数expression来避免使用该全局变量，该表达式是自执行表达式。当我们在该&lt;strong&gt;IIFE&lt;/strong&gt;表达式中编写代码时，全局变量将类似于局部作用域和局部变量。</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="f38bd5ec2c8a5dc7ab5e02966ee53d71fa6c0fb1" translate="yes" xml:space="preserve">
          <source>One more use case is memoization where a cache object is not global:</source>
          <target state="translated">还有一个用例是备忘录化,其中缓存对象不是全局的。</target>
        </trans-unit>
        <trans-unit id="c5723cd187bdd3a60686abb0d8678a7f72126e0f" translate="yes" xml:space="preserve">
          <source>One of its most common use case is to limit the scope of a variable made via &lt;code&gt;var&lt;/code&gt;. Variables created via &lt;code&gt;var&lt;/code&gt; have a scope limited to a function so this construct (which is a function wrapper around certain code) will make sure that your variable scope doesn't leak out of that function.</source>
          <target state="translated">它最常见的用例之一是限制通过 &lt;code&gt;var&lt;/code&gt; 生成的变量的范围。 通过 &lt;code&gt;var&lt;/code&gt; 创建的变量的作用域仅限于函数，因此此构造（某些代码的函数包装）将确保您的变量作用域不会从该函数中泄漏出来。</target>
        </trans-unit>
        <trans-unit id="649fbe17413aa58c3db75fce30b2af7a47324cda" translate="yes" xml:space="preserve">
          <source>One short and dummy example where this is useful is:</source>
          <target state="translated">一个短小精悍的例子是:</target>
        </trans-unit>
        <trans-unit id="9f973b4d9d4883553f635f032543ac59fc9d3b69" translate="yes" xml:space="preserve">
          <source>Put it in a function and it is &lt;em&gt;no longer global&lt;/em&gt; -- your primary goal.</source>
          <target state="translated">将其放在函数中，它&lt;em&gt;不再是全局的&lt;/em&gt; ，而是您的主要目标。</target>
        </trans-unit>
        <trans-unit id="0d8b8fae40a82cc964b67a458b02dc9260b9c93e" translate="yes" xml:space="preserve">
          <source>Second Example:</source>
          <target state="translated">第二个例子。</target>
        </trans-unit>
        <trans-unit id="625b147902424ef9a991e2305153920d948e7261" translate="yes" xml:space="preserve">
          <source>Self-executing anonymous function. It's executed as soon as it is created.</source>
          <target state="translated">自动执行的匿名函数。只要创建了它就会被执行。</target>
        </trans-unit>
        <trans-unit id="70bd652cdc2b1167028d4ac8199834817346bc4e" translate="yes" xml:space="preserve">
          <source>Self-executing functions are typically used to encapsulate context and avoid name collusions. Any variable that you define inside the (function(){..})() are not global.</source>
          <target state="translated">自执行函数通常被用来封装上下文,避免名称碰撞。你在(function(){...})()中定义的任何变量都不是全局的。</target>
        </trans-unit>
        <trans-unit id="29c3122b24cc9e30c85129f7fd8c2d244d9dfdd2" translate="yes" xml:space="preserve">
          <source>Simulate block scoping with IIFE</source>
          <target state="translated">用IIFE模拟块范围化</target>
        </trans-unit>
        <trans-unit id="7a54357ff5057e04bccd7aaac33c16801b6fda73" translate="yes" xml:space="preserve">
          <source>So IIFE helps us to &lt;strong&gt;write safe code where we are not colliding with the global objects unintentionally.&lt;/strong&gt;</source>
          <target state="translated">因此，IIFE可以帮助我们&lt;strong&gt;编写安全的代码，而不会在无意间与全局对象发生冲突。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6335b000f7e2f11bed39166ec0a6f5ed56142e5" translate="yes" xml:space="preserve">
          <source>So instead of creating a list each time, you create it only once (less overhead).</source>
          <target state="translated">所以,你不需要每次创建一个列表,而是只创建一次(少开销)。</target>
        </trans-unit>
        <trans-unit id="9a744001432e37728d3828edbc68f295cc3a7f66" translate="yes" xml:space="preserve">
          <source>Start here:</source>
          <target state="translated">从这里开始。</target>
        </trans-unit>
        <trans-unit id="10358ef11702b06b5cb27eb8e15a2ecaf6c95eef" translate="yes" xml:space="preserve">
          <source>Suppose I've another JS file (test1.js) used in my applicaiton along with iife.js (see below).</source>
          <target state="translated">假设我有另一个JS文件(test1.js)和iife.js(见下图)一起使用在我的应用程序中。</target>
        </trans-unit>
        <trans-unit id="5805911a132b44cbaa119ab669c316445b6aad4c" translate="yes" xml:space="preserve">
          <source>That construct is called &lt;strong&gt;Immediately Invoked Function Expression (IIFE)&lt;/strong&gt; which means it gets executed immediately. Think of it as a function getting called automatically when the interpreter reaches that function.</source>
          <target state="translated">该构造称为&lt;strong&gt;立即调用函数表达式（IIFE）&lt;/strong&gt; ，这意味着它可以立即执行。 可以将其视为当解释器到达该函数时自动调用的函数。</target>
        </trans-unit>
        <trans-unit id="a18c6eaa532f587838670adc0ddd14b1e92311b6" translate="yes" xml:space="preserve">
          <source>That is a &lt;strong&gt;self-invoking anonymous function&lt;/strong&gt;.</source>
          <target state="translated">那是一个&lt;strong&gt;自调用的匿名函数&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="94f48842d979fe68c1a11afee92b8fe237e29013" translate="yes" xml:space="preserve">
          <source>That is a function invocation. Inside the parenthesis you have:</source>
          <target state="translated">那是一个函数调用。在括号里面,你有。</target>
        </trans-unit>
        <trans-unit id="8dc326bd0d30e0a8db56ac629c606c11b2a1c545" translate="yes" xml:space="preserve">
          <source>That is an anonymous function. Everything that is declared with &lt;strong&gt;var&lt;/strong&gt; inside the construct will be visible only inside the same construct and will not pollute the global namespace.</source>
          <target state="translated">那是一个匿名函数。 在构造内部使用&lt;strong&gt;var&lt;/strong&gt;声明的所有内容仅在同一构造内部可见，并且不会污染全局名称空间。</target>
        </trans-unit>
        <trans-unit id="8380108f1e1cb790902e70f48d87cc68895f11ac" translate="yes" xml:space="preserve">
          <source>That is saying execute immediately.</source>
          <target state="translated">那是说立即执行。</target>
        </trans-unit>
        <trans-unit id="0cfe61a50bbbb22ef9c2d6a0589f1ebe1efc25e6" translate="yes" xml:space="preserve">
          <source>That is the short form of binding the &lt;code&gt;ready&lt;/code&gt; event:</source>
          <target state="translated">这是绑定 &lt;code&gt;ready&lt;/code&gt; 事件的简写形式：</target>
        </trans-unit>
        <trans-unit id="32e3ee7a8f238c3dc42124d9afe27b0f78dc70db" translate="yes" xml:space="preserve">
          <source>The code</source>
          <target state="translated">代码</target>
        </trans-unit>
        <trans-unit id="620d6ef1f9bea2f810b9b61a7131bfe9d5e2804f" translate="yes" xml:space="preserve">
          <source>The first pair of parentheses function(){...} converts the code inside the parentheses into an expression.The second pair of parentheses calls the function resulting from the expression.</source>
          <target state="translated">第一对括号中的函数(){...}将括号中的代码转换为表达式,第二对括号中的函数调用表达式所产生的函数。</target>
        </trans-unit>
        <trans-unit id="ea2dbcd87ff712d37a5e7773d759f85a11564ba0" translate="yes" xml:space="preserve">
          <source>The following IIFE pattern is quite commonly used.</source>
          <target state="translated">以下是比较常用的IIFE模式:</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">下面的代码是:</target>
        </trans-unit>
        <trans-unit id="e7bbda963d845e557f51712e433c51a15b6fe29c" translate="yes" xml:space="preserve">
          <source>The function is executed right after it's created, not after it is parsed. The entire script block is parsed before any code in it is executed. Also, parsing code doesn't automatically mean that it's executed, if for example the IIFE is inside a function then it won't be executed until the function is called.</source>
          <target state="translated">函数是在创建后立即执行,而不是在解析后执行。整个脚本块在执行任何代码之前都会被解析。另外,解析代码并不意味着自动执行,比如说IIFE在函数里面,那么在函数被调用之前,它不会被执行。</target>
        </trans-unit>
        <trans-unit id="6ca3ff5213c318e3b9ec03433344ff34245ae349" translate="yes" xml:space="preserve">
          <source>The performance benefit of using IIFE&amp;rsquo;s is the ability to pass commonly used global objects like &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt;, etc. as an argument by reducing the scope lookup. (Remember JavaScript looks for properties in local scope and way up the chain until global scope). So accessing global objects in local scope reduces the lookup time like below.</source>
          <target state="translated">使用IIFE的性能优势是能够通过减少范围查找来将常用的全局对象（例如 &lt;code&gt;window&lt;/code&gt; ， &lt;code&gt;document&lt;/code&gt; 等）作为参数传递。 （请记住，JavaScript在本地范围内查找属性，并在整个范围内一直查找直到全局范围）。 因此，在本地范围内访问全局对象可以减少查找时间，如下所示。</target>
        </trans-unit>
        <trans-unit id="288fa7b05c269acc1a5c03c13d3ac79fce530f66" translate="yes" xml:space="preserve">
          <source>The reason self-evoking anonymous functions are used is they should never be called by other code since they &quot;set up&quot; the code which IS meant to be called (along with giving scope to functions and variables).</source>
          <target state="translated">使用自发的匿名函数的原因是,它们不应该被其他代码调用,因为它们 &quot;设置 &quot;了要被调用的代码(连同给函数和变量的作用域)。</target>
        </trans-unit>
        <trans-unit id="24e31faeedc1c433bb3b9e8c9d599d3d544b30be" translate="yes" xml:space="preserve">
          <source>Therefore, instead of using that complex construct of IIFE for the use case I mentioned above, you can now write much, much simpler code to make sure that a variable's scope does not leak out of your desired block.</source>
          <target state="translated">因此,你现在可以写出更多、更简单的代码来确保变量的作用域不会从你所希望的块中泄露出来,而不是使用我上面提到的那个复杂的IIFE构造的用例。</target>
        </trans-unit>
        <trans-unit id="f757a6a5f520f7c84d83fdf2c6f0a73f17baf005" translate="yes" xml:space="preserve">
          <source>This code above will execute as soon as you load iife.js and will print '&lt;em&gt;Hello Stackoverflow!&lt;/em&gt;' on the developer tools' console.</source>
          <target state="translated">上面的代码将在您加载iife.js后立即执行，并显示&amp;ldquo; &lt;em&gt;Hello Stackoverflow！&lt;/em&gt; 在开发人员工具的控制台上。</target>
        </trans-unit>
        <trans-unit id="1b7900604a551b4491f3627f5f85daa451838595" translate="yes" xml:space="preserve">
          <source>This is an Immediately Invoked Function Expression in Javascript:</source>
          <target state="translated">这是Javascript中的一个立即调用的函数表达式。</target>
        </trans-unit>
        <trans-unit id="60fca009bce50f0f52bdaae51ab0767f17cf922c" translate="yes" xml:space="preserve">
          <source>This is called IIFE (Immediately Invoked Function Expression). One of the famous JavaScript design patterns, it is the heart and soul of the modern day Module pattern. As the name suggests it executes immediately after it is created. This pattern creates an isolated or private scope of execution.</source>
          <target state="translated">这就是所谓的IIFE(Immediate Invoked Function Expression)。是著名的JavaScript设计模式之一,它是现代模块模式的核心和灵魂。顾名思义,它在创建后立即执行。这个模式创建了一个孤立的或私有的执行范围。</target>
        </trans-unit>
        <trans-unit id="05397156e7479340c0e62d149e3f317e55817dd5" translate="yes" xml:space="preserve">
          <source>This is the self-invoking anonymous function. It is executed while it is defined. Which means this function is defined and invokes itself immediate after the definition.</source>
          <target state="translated">这就是自引式匿名函数。它是在定义的同时执行的。这意味着这个函数在定义后立即调用自己。</target>
        </trans-unit>
        <trans-unit id="aa5eeda16874ed79c3a0bf338d464e2c9e434f2d" translate="yes" xml:space="preserve">
          <source>This is why, maybe, you confused this construction with an event-handler for &lt;code&gt;window.onload&lt;/code&gt;, because it&amp;rsquo;s often used as this:</source>
          <target state="translated">这就是为什么您可能将此构造与 &lt;code&gt;window.onload&lt;/code&gt; 的事件处理程序混淆的原因，因为它经常被这样使用：</target>
        </trans-unit>
        <trans-unit id="a43a0884e808455e619c5e39b5f6305cd32b762b" translate="yes" xml:space="preserve">
          <source>This pattern is often used when trying to avoid polluting the global namespace, because all the variables used inside the IIFE (like in any other &lt;em&gt;normal&lt;/em&gt; function) are not visible outside its scope.</source>
          <target state="translated">当试图避免污染全局名称空间时，通常使用此模式，因为IIFE内部使用的所有变量（如在任何其他&lt;em&gt;常规&lt;/em&gt;函数中一样）在其范围之外都不可见。</target>
        </trans-unit>
        <trans-unit id="e5250168d0e420ea15ffcae2855451c4b761867b" translate="yes" xml:space="preserve">
          <source>Three more common wordings:</source>
          <target state="translated">三个比较常见的词。</target>
        </trans-unit>
        <trans-unit id="119c79105d25740edafd02ae5b6f7eec36e65e3a" translate="yes" xml:space="preserve">
          <source>To understand IIFE in JS, lets break it down:</source>
          <target state="translated">要理解JS中的IIFE,我们来分解一下。</target>
        </trans-unit>
        <trans-unit id="d6b77b85dccd745a3fe0ec9e1915b8ec0a8ad02c" translate="yes" xml:space="preserve">
          <source>Two ways we can create &lt;strong&gt;IIFE&lt;/strong&gt;</source>
          <target state="translated">创建&lt;strong&gt;IIFE的&lt;/strong&gt;两种方法</target>
        </trans-unit>
        <trans-unit id="7fcbaaaf9b6840e78103bf684f0bdd12dcbede43" translate="yes" xml:space="preserve">
          <source>Use the parentheses to avoid a syntax error:</source>
          <target state="translated">使用括号,避免出现语法错误。</target>
        </trans-unit>
        <trans-unit id="9b1aacb25d4d7569574ad43074d0946d45db2a84" translate="yes" xml:space="preserve">
          <source>Usually, we don't invoke a function immediately after we write it in the program. 
In extremely simple terms, when you call a function right after its creation, it is called IIFE - a fancy name.</source>
          <target state="translated">通常情况下,我们在程序中写完函数后,不会立即调用函数。用极其简单的话来说,当你在创建一个函数后立即调用它时,就会被称为IIFE--一个花哨的名字。</target>
        </trans-unit>
        <trans-unit id="14a0e82e7bb0518d267319e1cbab5b31ff6842ec" translate="yes" xml:space="preserve">
          <source>Very cool.</source>
          <target state="translated">非常酷。</target>
        </trans-unit>
        <trans-unit id="8ac9ae8ffa3d3c2849f98072d24c38d7af8d342b" translate="yes" xml:space="preserve">
          <source>What is the (function() { } )() construct in JavaScript</source>
          <target state="translated">JavaScript中的(function(){})()构造是什么?</target>
        </trans-unit>
        <trans-unit id="231d04fc5024ad157d8b00b3dbb591e327427435" translate="yes" xml:space="preserve">
          <source>When we are dealing with a large code base and/or when we are importing various libraries the chance of naming conflicts increases. When we are writing certain parts of our code which is related (and thus is using the same variables) inside an IIFE all of the &lt;strong&gt;variables and function names are scoped to the function brackets of the IIFE&lt;/strong&gt;. This reduces chances of naming conflicts and lets you name them more careless (e.g. you don't have to prefix them).</source>
          <target state="translated">当我们处理大型代码库和/或导入各种库时，命名冲突的机会就会增加。 当我们在IIFE内编写代码的某些相关部分（并因此使用相同的变量）时，所有&lt;strong&gt;变量和函数名称的作用域都在IIFE的函数括号内&lt;/strong&gt; 。 这减少了命名冲突的机会，并使您更不小心地命名它们（例如，您不必给它们加上前缀）。</target>
        </trans-unit>
        <trans-unit id="d6ee7a9da24cd817643c34a656eca9b71e280cb0" translate="yes" xml:space="preserve">
          <source>Why is this useful?</source>
          <target state="translated">为什么会有这样的作用?</target>
        </trans-unit>
        <trans-unit id="c55517152e7cc3243eca3932069c2820ebe391fe" translate="yes" xml:space="preserve">
          <source>You can even write:</source>
          <target state="translated">你甚至可以写。</target>
        </trans-unit>
        <trans-unit id="9896d74e8f60c2be315cd9b2c7f1cb80c597ad0c" translate="yes" xml:space="preserve">
          <source>You can leave off the function name:</source>
          <target state="translated">你可以省去功能名称。</target>
        </trans-unit>
        <trans-unit id="0470cb63114ace850d7c50d5c5d0512a46149f43" translate="yes" xml:space="preserve">
          <source>You cannot self-invoke a function declaration.</source>
          <target state="translated">你不能自我调用函数声明。</target>
        </trans-unit>
        <trans-unit id="80b55755751b78dc96e2105d875ad62fc884571a" translate="yes" xml:space="preserve">
          <source>b) We are invoking this funtion at the same time using the () at the end of it.</source>
          <target state="translated">b)我们在调用这个funtion的同时,在它的末尾使用()。</target>
        </trans-unit>
        <trans-unit id="5a0f90b8e1bc3acdf41aed42023e812c2c303c71" translate="yes" xml:space="preserve">
          <source>is called an &lt;strong&gt;immediately invoked function expression&lt;/strong&gt; (IIFE).</source>
          <target state="translated">被称为&lt;strong&gt;立即调用函数表达式&lt;/strong&gt; （IIFE）。</target>
        </trans-unit>
        <trans-unit id="e24ae834b8fdc0300d07f73f952ddbc3aedb8af4" translate="yes" xml:space="preserve">
          <source>produces this output:</source>
          <target state="translated">产生这种输出。</target>
        </trans-unit>
        <trans-unit id="537c7047f37c2eecdd1daa181117234bdf353f51" translate="yes" xml:space="preserve">
          <source>so if &lt;code&gt;windows.app&lt;/code&gt; is not defined, then &lt;code&gt;window.app = {}&lt;/code&gt; is immediately executed, so &lt;code&gt;window.app&lt;/code&gt; is assigned with &lt;code&gt;{}&lt;/code&gt; during the condition evaluation, so the result is both &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;window.app&lt;/code&gt; now become &lt;code&gt;{}&lt;/code&gt;, so console output is:</source>
          <target state="translated">因此，如果未定义 &lt;code&gt;windows.app&lt;/code&gt; ，则将立即执行 &lt;code&gt;window.app = {}&lt;/code&gt; ，因此在条件评估期间将 &lt;code&gt;window.app&lt;/code&gt; 分配给 &lt;code&gt;{}&lt;/code&gt; ，因此结果是 &lt;code&gt;app&lt;/code&gt; 和 &lt;code&gt;window.app&lt;/code&gt; 现在都变成 &lt;code&gt;{}&lt;/code&gt; ，所以控制台输出为：</target>
        </trans-unit>
        <trans-unit id="feb062cf00888ada37d37ce1300e60f61e961935" translate="yes" xml:space="preserve">
          <source>so if I do:</source>
          <target state="translated">所以,如果我这样做。</target>
        </trans-unit>
        <trans-unit id="172e222242f37744f300767d18cc0b7b1beaa362" translate="yes" xml:space="preserve">
          <source>we are doing two things over here.
a) Wrapping our function expression inside braces (). This goes to tell the syntax parser the whatever placed inside the () is an expression (function expression in this case) and is a valid code.</source>
          <target state="translated">a)将我们的函数表达式封装在大括号()中。这样做是为了告诉语法解析器,无论放在()里面的东西是一个表达式(本例中的函数表达式),是一个有效的代码。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
