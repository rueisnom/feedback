<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/8228281">
    <body>
      <group id="8228281">
        <trans-unit id="9dadaa9496929c84c3ab6989b1c844585b555e1d" translate="yes" xml:space="preserve">
          <source>- During execution (Execution Context - Execute phase), the funtion object is created on the fly (&lt;strong&gt;its not executed yet&lt;/strong&gt;), gets assigned to 'greet' variable and it can be invoked using 'greet('somename')'.</source>
          <target state="translated">- Durante la ejecuci&amp;oacute;n (contexto de ejecuci&amp;oacute;n - fase de ejecuci&amp;oacute;n), el objeto de funci&amp;oacute;n se crea sobre la marcha ( &lt;strong&gt;a&amp;uacute;n no se ha ejecutado&lt;/strong&gt; ), se asigna a la variable 'saludar' y se puede invocar usando 'saludar (' nombre de pila ')'.</target>
        </trans-unit>
        <trans-unit id="6a158b11158c99a0df72e82df408cf783123c9ff" translate="yes" xml:space="preserve">
          <source>- IIFE, being a function, has its own execution context, meaning all the variables created inside it are local to this function and are not shared with the global execution context.</source>
          <target state="translated">-El IIFE,al ser una función,tiene su propio contexto de ejecución,lo que significa que todas las variables creadas dentro de él son locales a esta función y no son compartidas con el contexto de ejecución global.</target>
        </trans-unit>
        <trans-unit id="ad28c57779ed69eaee3b61747f53357c4dd296f6" translate="yes" xml:space="preserve">
          <source>- Notice the '()' immediately after the function declaration. Every funtion object has a 'CODE' property attached to it which is callable. And we can call it (or invoke it) using '()' braces.</source>
          <target state="translated">-Fíjese en la '()' inmediatamente después de la declaración de la función.Cada objeto de función tiene una propiedad &quot;CODE&quot; adjunta que puede ser llamada.Y podemos llamarla (o invocarla)usando llaves '()'.</target>
        </trans-unit>
        <trans-unit id="7b549f1532a5f31afc5bc29127c287e5f5a88a77" translate="yes" xml:space="preserve">
          <source>- So here, during the execution (Execution Context - Execute Phase), &lt;strong&gt;the function object is created and its executed at the same time&lt;/strong&gt;
- So now, the greeting variable, instead of having the funtion object, has its return value ( a string )</source>
          <target state="translated">- Entonces, aqu&amp;iacute;, durante la ejecuci&amp;oacute;n (Contexto de ejecuci&amp;oacute;n - Fase de ejecuci&amp;oacute;n), &lt;strong&gt;se crea el objeto de funci&amp;oacute;n y se ejecuta al mismo tiempo&lt;/strong&gt; - Entonces, ahora, la variable de saludo, en lugar de tener el objeto de funci&amp;oacute;n, tiene su valor de retorno (una cadena)</target>
        </trans-unit>
        <trans-unit id="f2d32b6c54b2eea7b4f08964506c4a14da8bb30d" translate="yes" xml:space="preserve">
          <source>- When JS engine runs for the first time (Execution Context - Create Phase), this function (on the right side of = above) does not get executed or stored in the memory. Variable 'greet' is assigned 'undefined' value by the JS engine.</source>
          <target state="translated">-Cuando el motor JS se ejecuta por primera vez (Contexto de Ejecución-Fase de Creación),esta función (en el lado derecho de=arriba)no se ejecuta ni se almacena en la memoria.A la variable &quot;greet&quot; se le asigna el valor &quot;undefined&quot; por el motor JS.</target>
        </trans-unit>
        <trans-unit id="ef59722e8ed96066e8f649d55ddc705002e2bbbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Immediately Invoked Funtion Expression:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. Expresi&amp;oacute;n de la funci&amp;oacute;n invocada inmediatamente:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c57cca2ae891930962d46154d0cdd7701cf2ca8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;So this function gets created and executed at the same time (IIFE).&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Entonces, esta funci&amp;oacute;n se crea y ejecuta al mismo tiempo (IIFE).&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c3e8c29c460f778fb10c68b7b5f483c3b0d796f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Correction suggested by &lt;a href=&quot;https://stackoverflow.com/users/69083/guffa&quot;&gt;Guffa&lt;/a&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Correcci&amp;oacute;n sugerida por &lt;a href=&quot;https://stackoverflow.com/users/69083/guffa&quot;&gt;Guffa&lt;/a&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2ed48c31f74161c223bba47f878a789f77b5069" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Alternative (Recommended)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Alternativa ES6 (recomendada)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47754a1062d962b6ce15d48457bec71b3f369e46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expression&lt;/strong&gt;: Something that returns a value</source>
          <target state="translated">&lt;strong&gt;Expresi&amp;oacute;n&lt;/strong&gt; : algo que devuelve un valor</target>
        </trans-unit>
        <trans-unit id="46b1b6e1b44f3520e2793cb8255547db860a73db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Expression&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Expresi&amp;oacute;n de funciones&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="50eff3e72b9320085e3583c9fee5aae42ebfd0b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How IIFE works&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;C&amp;oacute;mo funciona IIFE&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="804eeffad7b4e11fec563767c8bf6ee40edfb082" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How function expression works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C&amp;oacute;mo funciona la expresi&amp;oacute;n de funci&amp;oacute;n:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="315b05a17b0a236580165cfed17571d5661f8e8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IIFE keeps our code safe.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IIFE mantiene nuestro c&amp;oacute;digo seguro.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e21af655815475d3a776d89c71bee90a334352e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important usecase for IIFE: &lt;br/&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Caso de uso importante para IIFE:&lt;/strong&gt; &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="733ad654e28f5f19e0ccacbd5bd074cd18bf34ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Most Common Use-case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Caso de uso m&amp;aacute;s com&amp;uacute;n:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e719c6166298c86686ad285062a762b144fe333" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typical usecase of IIFE in JS:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Caso de uso t&amp;iacute;pico de IIFE en JS:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd4b667e7450fd1da7be97c55c23d9054c910440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;
Since this is a pretty popular topic, it's worth mentioning that IIFE's can also be written with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES6's arrow function&lt;/a&gt; (like &lt;a href=&quot;https://stackoverflow.com/users/368691/gajus&quot;&gt;Gajus&lt;/a&gt; has pointed out &lt;a href=&quot;https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript/8228308#comment43521302_8228308&quot;&gt;in a comment&lt;/a&gt;) :</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n&lt;/strong&gt; Dado que este es un tema bastante popular, vale la pena mencionar que los IIFE tambi&amp;eacute;n se pueden escribir con &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;la funci&amp;oacute;n de flecha de ES6&lt;/a&gt; (como &lt;a href=&quot;https://stackoverflow.com/users/368691/gajus&quot;&gt;Gajus&lt;/a&gt; ha se&amp;ntilde;alado &lt;a href=&quot;https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript/8228308#comment43521302_8228308&quot;&gt;en un comentario&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="f4c3381f63f3402e4c893d3819f4639fcfc1cafd" translate="yes" xml:space="preserve">
          <source>A self-invoking expression is invoked (started) automatically, without
  being called.</source>
          <target state="translated">Una expresión autoinvocable es invocada (iniciada)automáticamente,sin ser llamada.</target>
        </trans-unit>
        <trans-unit id="47c2a38385c0fcf1a4d905bdef7a2aae0eec35d8" translate="yes" xml:space="preserve">
          <source>After we have an expression which evaluates to a function object we then can immediately &lt;strong&gt;invoke&lt;/strong&gt; the function object with the &lt;code&gt;()&lt;/code&gt; operator. For example:</source>
          <target state="translated">Despu&amp;eacute;s de tener una expresi&amp;oacute;n que se eval&amp;uacute;a como un objeto de funci&amp;oacute;n, podemos &lt;strong&gt;invocar&lt;/strong&gt; inmediatamente el objeto de funci&amp;oacute;n con el operador &lt;code&gt;()&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="7f06afd34a563714ec314b68da3f205e40cda76f" translate="yes" xml:space="preserve">
          <source>Alternatively, it can be:</source>
          <target state="translated">Alternativamente,puede ser:</target>
        </trans-unit>
        <trans-unit id="ef9203bbedd9adb33629bea17c2eb428a0a6054a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IIFE&lt;/code&gt; can also be described as a self-invoking anonymous function. Its most common usage is to limit the scope of a variable made via var or to encapsulate context to avoid name collisions.</source>
          <target state="translated">Un &lt;code&gt;IIFE&lt;/code&gt; tambi&amp;eacute;n se puede describir como una funci&amp;oacute;n an&amp;oacute;nima autoinvocatoria . Su uso m&amp;aacute;s com&amp;uacute;n es limitar el alcance de una variable hecha a trav&amp;eacute;s de var o encapsular el contexto para evitar colisiones de nombres.</target>
        </trans-unit>
        <trans-unit id="6054fe82da32385b7ed0dbfbae9f67f812a1d185" translate="yes" xml:space="preserve">
          <source>An expression is simply a bunch of code which can be evaluated to &lt;strong&gt;a single value&lt;/strong&gt;. In case of the expressions in the above example this value was a &lt;strong&gt;single function object&lt;/strong&gt;.</source>
          <target state="translated">Una expresi&amp;oacute;n es simplemente un mont&amp;oacute;n de c&amp;oacute;digo que se puede evaluar con &lt;strong&gt;un solo valor&lt;/strong&gt; . En el caso de las expresiones en el ejemplo anterior, este valor era un &lt;strong&gt;objeto de funci&amp;oacute;n &amp;uacute;nica&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1b232444188015e33e960e2241dffbfda478d3cb" translate="yes" xml:space="preserve">
          <source>An immediately invoked function expression (IIFE) is a function that's executed as soon as it's created. It has no connection with any events or asynchronous execution. You can define an IIFE as shown below:</source>
          <target state="translated">Una expresión de función inmediatamente invocada (IIFE)es una función que se ejecuta tan pronto como se crea.No tiene conexión con ningún evento o ejecución asincrónica.Puede definir una IIFE como se muestra a continuación:</target>
        </trans-unit>
        <trans-unit id="0cd1fb5aec37c798839c8d1d191684f280e2a7bc" translate="yes" xml:space="preserve">
          <source>An immediately-invoked function expression (IIFE) immediately calls a function. This simply means that the function is executed immediately after the completion of the definition.</source>
          <target state="translated">Una expresión de función inmediatamente invocada (IIFE)llama inmediatamente a una función.Esto significa simplemente que la función se ejecuta inmediatamente después de la finalización de la definición.</target>
        </trans-unit>
        <trans-unit id="e23b647b429bf20b9259177559b651dd7775b8c6" translate="yes" xml:space="preserve">
          <source>And the explanation of the syntax is: The function within the first &lt;code&gt;()&lt;/code&gt; parenthesis is the function which has no name and by the next &lt;code&gt;();&lt;/code&gt; parenthesis you can understand that it is called at the time it is defined. And you can pass any argument in this second &lt;code&gt;()&lt;/code&gt; parenthesis which will be grabbed in the function which is in the first parenthesis. See this example:</source>
          <target state="translated">Y la explicaci&amp;oacute;n de la sintaxis es: La funci&amp;oacute;n dentro del par&amp;eacute;ntesis first &lt;code&gt;()&lt;/code&gt; es la funci&amp;oacute;n que no tiene nombre y por next &lt;code&gt;();&lt;/code&gt; entre par&amp;eacute;ntesis puede entender que se llama en el momento en que se define. Y puede pasar cualquier argumento en este segundo par&amp;eacute;ntesis &lt;code&gt;()&lt;/code&gt; que se tomar&amp;aacute; en la funci&amp;oacute;n que est&amp;aacute; en el primer par&amp;eacute;ntesis. Ver este ejemplo:</target>
        </trans-unit>
        <trans-unit id="2a08b6d6216c318f07a63ce64ce5e83f1c1d8bf5" translate="yes" xml:space="preserve">
          <source>But the above two construct are not &lt;strong&gt;IIFE&lt;/strong&gt;.</source>
          <target state="translated">Pero las dos construcciones anteriores no son &lt;strong&gt;IIFE&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee3f501ca67bbeb5c059c6705b2167b219acadc" translate="yes" xml:space="preserve">
          <source>By using this syntax you avoid colliding with global variables declared elsewhere in your JavaScript code.</source>
          <target state="translated">Usando esta sintaxis evitas colisionar con las variables globales declaradas en otra parte de tu código JavaScript.</target>
        </trans-unit>
        <trans-unit id="fe1b40c8fab9f166a675bd98799bd55d26f8fea3" translate="yes" xml:space="preserve">
          <source>Call the function immediately -- oops:</source>
          <target state="translated">Llama a la función inmediatamente...oops:</target>
        </trans-unit>
        <trans-unit id="bed0e00f9fc23279ca684a1d493bc0948fd61a7d" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;http://www.w3schools.com/js/js_function_definition.asp&quot;&gt;W3Schools explanation of a self-invoking function&lt;/a&gt;.</source>
          <target state="translated">Consulte la &lt;a href=&quot;http://www.w3schools.com/js/js_function_definition.asp&quot;&gt;explicaci&amp;oacute;n de W3Schools de una funci&amp;oacute;n de auto invocaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="555c6fb5b44d531f9e53fcbc10a3a35e96167dd6" translate="yes" xml:space="preserve">
          <source>Consider the function below written in a file named iife.js</source>
          <target state="translated">Considere la función abajo escrita en un archivo llamado iife.js</target>
        </trans-unit>
        <trans-unit id="dfb3b4ee9c5d621bdda0a0d76975d4708fc3ac9d" translate="yes" xml:space="preserve">
          <source>Consider the part within the first pair of parentheses: &lt;code&gt;(&lt;b&gt;function(){}&lt;/b&gt;)();&lt;/code&gt;....it is a regular function expression. Then look at the last pair &lt;code&gt;(function(){})&lt;b&gt;()&lt;/b&gt;;&lt;/code&gt;, this is normally added to an expression to call a function; in this case, our prior expression.</source>
          <target state="translated">Considere la parte dentro del primer par de par&amp;eacute;ntesis: &lt;code&gt;(&lt;b&gt;function(){}&lt;/b&gt;)();&lt;/code&gt; .... es una expresi&amp;oacute;n de funci&amp;oacute;n regular. Luego mira el &amp;uacute;ltimo par &lt;code&gt;(function(){})&lt;b&gt;()&lt;/b&gt;;&lt;/code&gt; , esto normalmente se agrega a una expresi&amp;oacute;n para llamar a una funci&amp;oacute;n; En este caso, nuestra expresi&amp;oacute;n previa.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7ac36349dda560270779b789cbf43d471f646ee7" translate="yes" xml:space="preserve">
          <source>Example: Try out following in chrome console. These are expressions in JS.</source>
          <target state="translated">Ejemplo:Pruebe lo siguiente en la consola cromada.Estas son expresiones en JS.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="a16fbf4816018018ce84d149cfed2d3768185a11" translate="yes" xml:space="preserve">
          <source>Fiddle: &lt;a href=&quot;http://jsfiddle.net/maniator/LqvpQ/&quot;&gt;http://jsfiddle.net/maniator/LqvpQ/&lt;/a&gt;</source>
          <target state="translated">Viol&amp;iacute;n: &lt;a href=&quot;http://jsfiddle.net/maniator/LqvpQ/&quot;&gt;http://jsfiddle.net/maniator/LqvpQ/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3adf70295ac336ffda7f66d5b40c9b5b7da8682d" translate="yes" xml:space="preserve">
          <source>For a Detailed explanation see &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Immediately-Invoked Function Expression (IIFE)&lt;/a&gt;</source>
          <target state="translated">Para obtener una explicaci&amp;oacute;n detallada, consulte &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Expresi&amp;oacute;n de funci&amp;oacute;n invocada inmediatamente (IIFE)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c6fccf633b8091e55000dd559026cd3b58ab04e" translate="yes" xml:space="preserve">
          <source>Function expressions can be made &quot;self-invoking&quot;.</source>
          <target state="translated">Las expresiones de función pueden hacerse &quot;autoinvocables&quot;.</target>
        </trans-unit>
        <trans-unit id="26db9da6beae79b61580102af1a1cae9c9752e6a" translate="yes" xml:space="preserve">
          <source>Function expressions will execute automatically if the expression is
  followed by ().</source>
          <target state="translated">Las expresiones de la función se ejecutarán automáticamente si la expresión va seguida de ().</target>
        </trans-unit>
        <trans-unit id="93cc4de26d2f9c0383f0e9df26c846aef1578f8e" translate="yes" xml:space="preserve">
          <source>Here the 'object' you are passing will be accessible within the function by 'obj', as you are grabbing it in the function signature.</source>
          <target state="translated">Aquí el &quot;objeto&quot; que estás pasando será accesible dentro de la función por &quot;obj&quot;,ya que lo estás agarrando en la firma de la función.</target>
        </trans-unit>
        <trans-unit id="310dbc9ededfe37d2f49c2fae2cfedca9bb3170d" translate="yes" xml:space="preserve">
          <source>I call it a &lt;code&gt;Curly Jail&lt;/code&gt;.</source>
          <target state="translated">Yo lo llamo una &lt;code&gt;Curly Jail&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc657204917761bd8680e03ced88ddf4b0d2f99e" translate="yes" xml:space="preserve">
          <source>I think the 2 sets of brackets makes it a bit confusing but I saw another usage in googles example, they used something similar, I hope this will help you understand better:</source>
          <target state="translated">Creo que los dos juegos de paréntesis lo hacen un poco confuso pero vi otro uso en el ejemplo de los googles,usaban algo similar,espero que esto te ayude a entender mejor:</target>
        </trans-unit>
        <trans-unit id="da90c222860bf1dca29f728207fcaa3217f05ea7" translate="yes" xml:space="preserve">
          <source>I used to know what this meant, but I'm struggling now...</source>
          <target state="translated">Solía saber lo que esto significaba,pero ahora estoy luchando...</target>
        </trans-unit>
        <trans-unit id="1adaf50c667f60887370ba409da371b6afb75b21" translate="yes" xml:space="preserve">
          <source>IIFE (Immediately invoked function expression) is a function which executes as soon as the script loads and goes away.</source>
          <target state="translated">IIFE (Immediately invoked function expression)es una función que se ejecuta tan pronto como el guión se carga y desaparece.</target>
        </trans-unit>
        <trans-unit id="2dbc909f43d9178cbccc47855c456cf4752621ef" translate="yes" xml:space="preserve">
          <source>If there are no special requirements for its return value, then we can write:</source>
          <target state="translated">Si no hay requisitos especiales para su valor de retorno,entonces podemos escribir:</target>
        </trans-unit>
        <trans-unit id="3bf309c08d49299b6010eb01372d2db6695104c5" translate="yes" xml:space="preserve">
          <source>In ES6 syntax (posting for myself, as I keep landing on this page looking for a quick example):</source>
          <target state="translated">En la sintaxis ES6 (posteando para mí,ya que sigo aterrizando en esta página buscando un ejemplo rápido):</target>
        </trans-unit>
        <trans-unit id="b5f54c58ea6a05bfe712cb33b673358aba022076" translate="yes" xml:space="preserve">
          <source>In ES6, we now can have variables created via &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Both of them are block-scoped (unlike &lt;code&gt;var&lt;/code&gt; which is a function-scoped).</source>
          <target state="translated">En ES6, ahora podemos tener variables creadas mediante &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; . Ambos tienen un alcance de bloque (a diferencia de &lt;code&gt;var&lt;/code&gt; , que tiene un alcance de funci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="16f5da42d75b65b9cb3a9aa47149d04a1c65df9a" translate="yes" xml:space="preserve">
          <source>In following example, count will not be available outside the immediately invoked function i.e. Scope of &lt;code&gt;count&lt;/code&gt; will not leak out of the function. You should get a &lt;code&gt;Reference Error&lt;/code&gt;, should you try to access it outside of the immediately invoked function anyway.</source>
          <target state="translated">En el siguiente ejemplo, el recuento no estar&amp;aacute; disponible fuera de la funci&amp;oacute;n invocada inmediatamente, es decir, el alcance del &lt;code&gt;count&lt;/code&gt; no se escapar&amp;aacute; de la funci&amp;oacute;n. Deber&amp;iacute;a obtener un &lt;code&gt;Reference Error&lt;/code&gt; , si intenta acceder a &amp;eacute;l fuera de la funci&amp;oacute;n invocada inmediatamente de todos modos.</target>
        </trans-unit>
        <trans-unit id="ed59eaac2704626c5d7967c3ef0bd1a82cf33639" translate="yes" xml:space="preserve">
          <source>In jQuery there is a similar construct that you might be thinking of:</source>
          <target state="translated">En jQuery hay una construcción similar en la que podrías estar pensando:</target>
        </trans-unit>
        <trans-unit id="3285fe005e794f8056d470509f3d977dcccbf1a1" translate="yes" xml:space="preserve">
          <source>In other words, they are like programs that &quot;make classes', at the beginning of program. After they are instantiated (automatically), the only functions that are available are the ones returned in by the anonymous function. However, all the other 'hidden' functions are still there, along with any state (variables set during scope creation).</source>
          <target state="translated">En otras palabras,son como programas que &quot;hacen clases&quot;,al principio del programa.Después de que son instanciados (automáticamente),las únicas funciones disponibles son las devueltas por la función anónima.Sin embargo,todas las demás funciones &quot;ocultas&quot; siguen estando ahí,junto con cualquier estado (variables establecidas durante la creación del alcance).</target>
        </trans-unit>
        <trans-unit id="2246f55eec4876f796cbcd0d31de04ec8a5653b5" translate="yes" xml:space="preserve">
          <source>In the code snippet above, &amp;ldquo;&lt;em&gt;var app&lt;/em&gt;&amp;rdquo; is a local variable now.</source>
          <target state="translated">En el fragmento de c&amp;oacute;digo anterior, &quot; &lt;em&gt;aplicaci&amp;oacute;n var&lt;/em&gt; &quot; es una variable local ahora.</target>
        </trans-unit>
        <trans-unit id="c65f76b1db4bba18bb99168719c858dda4d4fb91" translate="yes" xml:space="preserve">
          <source>In this example, we used &lt;code&gt;let&lt;/code&gt; to define a &lt;code&gt;count&lt;/code&gt; variable which makes &lt;code&gt;count&lt;/code&gt; limited to the block of code, we created with the curly brackets &lt;code&gt;{...}&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, usamos &lt;code&gt;let&lt;/code&gt; para definir una variable de &lt;code&gt;count&lt;/code&gt; que hace que el &lt;code&gt;count&lt;/code&gt; limite al bloque de c&amp;oacute;digo que creamos con las llaves &lt;code&gt;{...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17e4ba3bf69d8e68d6b4400bea5fc5f6ee728362" translate="yes" xml:space="preserve">
          <source>Is this basically saying &lt;code&gt;document.onload&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Esto es b&amp;aacute;sicamente decir &lt;code&gt;document.onload&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="fd185ef785c5b04bd70812f4d46089d0eb0fa051" translate="yes" xml:space="preserve">
          <source>It declares an anonymous function, then calls it:</source>
          <target state="translated">Declara una función anónima,y luego la llama:</target>
        </trans-unit>
        <trans-unit id="82e817152a0385d95b61dff4c870bac1a4884074" translate="yes" xml:space="preserve">
          <source>It doesn't need to be any more complicated than that.</source>
          <target state="translated">No tiene que ser más complicado que eso.</target>
        </trans-unit>
        <trans-unit id="d46472342d72627637ee258e3d6fdccc6199cf72" translate="yes" xml:space="preserve">
          <source>It has nothing to do with any event-handler for any events (such as &lt;code&gt;document.onload&lt;/code&gt;).</source>
          <target state="translated">No tiene nada que ver con ning&amp;uacute;n controlador de eventos para ning&amp;uacute;n evento (como &lt;code&gt;document.onload&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7c65f9349f5c5e98740e05bb18a002d20447896d" translate="yes" xml:space="preserve">
          <source>It is called IIFE - Immediately Invoked Function Expression. Here is an example to show it's syntax and usage. It is used to scope the use of variables only till the function and not beyond.</source>
          <target state="translated">Se llama IIFE-Expresión de la Función Inmediatamente Invocada.Aquí hay un ejemplo para mostrar su sintaxis y uso.Se utiliza para ampliar el uso de las variables sólo hasta la función y no más allá.</target>
        </trans-unit>
        <trans-unit id="2b232da97c45835910b21510560d717bf4925972" translate="yes" xml:space="preserve">
          <source>It is called a function expression because the &lt;code&gt;( yourcode )&lt;/code&gt; operator in Javascript force it into an expression. The difference between a &lt;strong&gt;function expression&lt;/strong&gt; and a &lt;strong&gt;function declaration&lt;/strong&gt; is the following:</source>
          <target state="translated">Se llama una expresi&amp;oacute;n de funci&amp;oacute;n porque el operador &lt;code&gt;( yourcode )&lt;/code&gt; en Javascript lo fuerza a una expresi&amp;oacute;n. La diferencia entre una &lt;strong&gt;expresi&amp;oacute;n de funci&amp;oacute;n&lt;/strong&gt; y una &lt;strong&gt;declaraci&amp;oacute;n de funci&amp;oacute;n&lt;/strong&gt; es la siguiente:</target>
        </trans-unit>
        <trans-unit id="a1cc8fef367a1d081643d3e45d670fa0885cf488" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Immediately-Invoked Function Expression&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;&lt;strong&gt;IIFE&lt;/strong&gt;&lt;/a&gt; for short. It executes immediately after it&amp;rsquo;s created.</source>
          <target state="translated">Es una &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;expresi&amp;oacute;n de funci&amp;oacute;n invocada inmediatamente&lt;/a&gt; , o &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;&lt;strong&gt;IIFE&lt;/strong&gt;&lt;/a&gt; para abreviar. Se ejecuta inmediatamente despu&amp;eacute;s de su creaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5b9bc8fdc31871ad312f7674abc5335932340a6a" translate="yes" xml:space="preserve">
          <source>It's just an anonymous function that is executed right after it's created.</source>
          <target state="translated">Es sólo una función anónima que se ejecuta justo después de ser creada.</target>
        </trans-unit>
        <trans-unit id="6a701e3ab7c285721f76ef5ce5480d80f7f9c81f" translate="yes" xml:space="preserve">
          <source>It's just as if you assigned it to a variable, and used it right after, only without the variable:</source>
          <target state="translated">Es como si lo asignaras a una variable,y lo usaras justo después,sólo que sin la variable:</target>
        </trans-unit>
        <trans-unit id="cb9f7eca5141640b0ea0732a3094579501b0966b" translate="yes" xml:space="preserve">
          <source>JavaScript prior to ECMAScript 6 used lexical scoping, so IIFE was used for simulating block scoping. (With ECMAScript 6 block scoping is possible with the introduction of the &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords.)
&lt;a href=&quot;https://gist.github.com/gurucharanmk/5071d37bb5af61a93562fbe024a975de&quot;&gt;Reference for issue with lexical scoping&lt;/a&gt;</source>
          <target state="translated">JavaScript anterior a ECMAScript 6 usaba el alcance l&amp;eacute;xico, por lo tanto, IIFE se usaba para simular el alcance del bloque. (Con el alcance del bloque ECMAScript 6 es posible con la introducci&amp;oacute;n de las palabras clave &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; .) &lt;a href=&quot;https://gist.github.com/gurucharanmk/5071d37bb5af61a93562fbe024a975de&quot;&gt;Referencia para el problema con el alcance l&amp;eacute;xico&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e19d95ce34c23849a24e90884cd6e222319e0a3d" translate="yes" xml:space="preserve">
          <source>No, this construct just creates a scope for naming. If you break it in parts you can see that you have an external</source>
          <target state="translated">No,esta construcción sólo crea un ámbito para el nombramiento.Si lo rompes en partes puedes ver que tienes una</target>
        </trans-unit>
        <trans-unit id="9ec030aac7f160c37131b600f5a5340267908578" translate="yes" xml:space="preserve">
          <source>Normally, JavaScript code has global scope in the application. When we declare global variable in it, there is a chance for using the same duplicate variable  in some other area of the development for some other purpose. Because of this duplication there may happen some error. So we can avoid this global variables by using immediately invoking function expression , this expression is self-executing expression.When we make our code inside this &lt;strong&gt;IIFE&lt;/strong&gt; expression global variable will be like local scope and local variable.</source>
          <target state="translated">Normalmente, el c&amp;oacute;digo JavaScript tiene un alcance global en la aplicaci&amp;oacute;n. Cuando declaramos la variable global en &amp;eacute;l, existe la posibilidad de usar la misma variable duplicada en alguna otra &amp;aacute;rea del desarrollo para alg&amp;uacute;n otro prop&amp;oacute;sito. Debido a esta duplicaci&amp;oacute;n, puede ocurrir alg&amp;uacute;n error. Por lo tanto, podemos evitar estas variables globales utilizando la expresi&amp;oacute;n de funci&amp;oacute;n de invocaci&amp;oacute;n inmediata, esta expresi&amp;oacute;n es una expresi&amp;oacute;n de ejecuci&amp;oacute;n autom&amp;aacute;tica. Cuando hacemos que nuestro c&amp;oacute;digo dentro de esta expresi&amp;oacute;n global &lt;strong&gt;IIFE&lt;/strong&gt; , la variable global ser&amp;aacute; como el alcance local y la variable local.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="f38bd5ec2c8a5dc7ab5e02966ee53d71fa6c0fb1" translate="yes" xml:space="preserve">
          <source>One more use case is memoization where a cache object is not global:</source>
          <target state="translated">Otro caso de uso es la memorización,en la que un objeto de caché no es global:</target>
        </trans-unit>
        <trans-unit id="c5723cd187bdd3a60686abb0d8678a7f72126e0f" translate="yes" xml:space="preserve">
          <source>One of its most common use case is to limit the scope of a variable made via &lt;code&gt;var&lt;/code&gt;. Variables created via &lt;code&gt;var&lt;/code&gt; have a scope limited to a function so this construct (which is a function wrapper around certain code) will make sure that your variable scope doesn't leak out of that function.</source>
          <target state="translated">Uno de sus casos de uso m&amp;aacute;s comunes es limitar el alcance de una variable hecha a trav&amp;eacute;s de &lt;code&gt;var&lt;/code&gt; . Las variables creadas a trav&amp;eacute;s de &lt;code&gt;var&lt;/code&gt; tienen un alcance limitado a una funci&amp;oacute;n, por lo que esta construcci&amp;oacute;n (que es un envoltorio de funci&amp;oacute;n alrededor de cierto c&amp;oacute;digo) se asegurar&amp;aacute; de que su alcance variable no se filtre fuera de esa funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="649fbe17413aa58c3db75fce30b2af7a47324cda" translate="yes" xml:space="preserve">
          <source>One short and dummy example where this is useful is:</source>
          <target state="translated">Un ejemplo corto y ficticio en el que esto es útil es:</target>
        </trans-unit>
        <trans-unit id="9f973b4d9d4883553f635f032543ac59fc9d3b69" translate="yes" xml:space="preserve">
          <source>Put it in a function and it is &lt;em&gt;no longer global&lt;/em&gt; -- your primary goal.</source>
          <target state="translated">P&amp;oacute;ngalo en una funci&amp;oacute;n y ya &lt;em&gt;no es global&lt;/em&gt; : su objetivo principal.</target>
        </trans-unit>
        <trans-unit id="0d8b8fae40a82cc964b67a458b02dc9260b9c93e" translate="yes" xml:space="preserve">
          <source>Second Example:</source>
          <target state="translated">Segundo ejemplo:</target>
        </trans-unit>
        <trans-unit id="625b147902424ef9a991e2305153920d948e7261" translate="yes" xml:space="preserve">
          <source>Self-executing anonymous function. It's executed as soon as it is created.</source>
          <target state="translated">Función anónima autoejecutable.Se ejecuta tan pronto como se crea.</target>
        </trans-unit>
        <trans-unit id="70bd652cdc2b1167028d4ac8199834817346bc4e" translate="yes" xml:space="preserve">
          <source>Self-executing functions are typically used to encapsulate context and avoid name collusions. Any variable that you define inside the (function(){..})() are not global.</source>
          <target state="translated">Las funciones autoejecutables se utilizan normalmente para encapsular el contexto y evitar colusiones de nombres.Cualquier variable que defina dentro de la (function(){..})()no es global.</target>
        </trans-unit>
        <trans-unit id="29c3122b24cc9e30c85129f7fd8c2d244d9dfdd2" translate="yes" xml:space="preserve">
          <source>Simulate block scoping with IIFE</source>
          <target state="translated">Simular el alcance del bloque con IIFE</target>
        </trans-unit>
        <trans-unit id="7a54357ff5057e04bccd7aaac33c16801b6fda73" translate="yes" xml:space="preserve">
          <source>So IIFE helps us to &lt;strong&gt;write safe code where we are not colliding with the global objects unintentionally.&lt;/strong&gt;</source>
          <target state="translated">Entonces, IIFE nos ayuda a &lt;strong&gt;escribir c&amp;oacute;digo seguro donde no estamos colisionando con los objetos globales sin querer.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6335b000f7e2f11bed39166ec0a6f5ed56142e5" translate="yes" xml:space="preserve">
          <source>So instead of creating a list each time, you create it only once (less overhead).</source>
          <target state="translated">Así que en lugar de crear una lista cada vez,la creas sólo una vez (menos gastos generales).</target>
        </trans-unit>
        <trans-unit id="9a744001432e37728d3828edbc68f295cc3a7f66" translate="yes" xml:space="preserve">
          <source>Start here:</source>
          <target state="translated">Empieza aquí:</target>
        </trans-unit>
        <trans-unit id="10358ef11702b06b5cb27eb8e15a2ecaf6c95eef" translate="yes" xml:space="preserve">
          <source>Suppose I've another JS file (test1.js) used in my applicaiton along with iife.js (see below).</source>
          <target state="translated">Supongamos que tengo otro archivo JS (test1.js)usado en mi aplicación junto con iife.js (ver abajo).</target>
        </trans-unit>
        <trans-unit id="5805911a132b44cbaa119ab669c316445b6aad4c" translate="yes" xml:space="preserve">
          <source>That construct is called &lt;strong&gt;Immediately Invoked Function Expression (IIFE)&lt;/strong&gt; which means it gets executed immediately. Think of it as a function getting called automatically when the interpreter reaches that function.</source>
          <target state="translated">Esa construcci&amp;oacute;n se llama &lt;strong&gt;Expresi&amp;oacute;n de funci&amp;oacute;n invocada inmediatamente (IIFE), lo&lt;/strong&gt; que significa que se ejecuta de inmediato. Piense en ello como una funci&amp;oacute;n que se llama autom&amp;aacute;ticamente cuando el int&amp;eacute;rprete llega a esa funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a18c6eaa532f587838670adc0ddd14b1e92311b6" translate="yes" xml:space="preserve">
          <source>That is a &lt;strong&gt;self-invoking anonymous function&lt;/strong&gt;.</source>
          <target state="translated">Esa es una &lt;strong&gt;funci&amp;oacute;n an&amp;oacute;nima autoinvocatoria&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="94f48842d979fe68c1a11afee92b8fe237e29013" translate="yes" xml:space="preserve">
          <source>That is a function invocation. Inside the parenthesis you have:</source>
          <target state="translated">Esa es una invocación de función.Dentro del paréntesis tienes:</target>
        </trans-unit>
        <trans-unit id="8dc326bd0d30e0a8db56ac629c606c11b2a1c545" translate="yes" xml:space="preserve">
          <source>That is an anonymous function. Everything that is declared with &lt;strong&gt;var&lt;/strong&gt; inside the construct will be visible only inside the same construct and will not pollute the global namespace.</source>
          <target state="translated">Esa es una funci&amp;oacute;n an&amp;oacute;nima. Todo lo que se declare con &lt;strong&gt;var&lt;/strong&gt; dentro de la construcci&amp;oacute;n ser&amp;aacute; visible solo dentro de la misma construcci&amp;oacute;n y no contaminar&amp;aacute; el espacio de nombres global.</target>
        </trans-unit>
        <trans-unit id="8380108f1e1cb790902e70f48d87cc68895f11ac" translate="yes" xml:space="preserve">
          <source>That is saying execute immediately.</source>
          <target state="translated">Eso es decir ejecutar inmediatamente.</target>
        </trans-unit>
        <trans-unit id="0cfe61a50bbbb22ef9c2d6a0589f1ebe1efc25e6" translate="yes" xml:space="preserve">
          <source>That is the short form of binding the &lt;code&gt;ready&lt;/code&gt; event:</source>
          <target state="translated">Esa es la forma abreviada de vincular el evento &lt;code&gt;ready&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="32e3ee7a8f238c3dc42124d9afe27b0f78dc70db" translate="yes" xml:space="preserve">
          <source>The code</source>
          <target state="translated">El código</target>
        </trans-unit>
        <trans-unit id="620d6ef1f9bea2f810b9b61a7131bfe9d5e2804f" translate="yes" xml:space="preserve">
          <source>The first pair of parentheses function(){...} converts the code inside the parentheses into an expression.The second pair of parentheses calls the function resulting from the expression.</source>
          <target state="translated">El primer par de paréntesis function(){...}convierte el código dentro de los paréntesis en una expresión.El segundo par de paréntesis llama a la función resultante de la expresión.</target>
        </trans-unit>
        <trans-unit id="ea2dbcd87ff712d37a5e7773d759f85a11564ba0" translate="yes" xml:space="preserve">
          <source>The following IIFE pattern is quite commonly used.</source>
          <target state="translated">El siguiente patrón de IIFE es bastante común.</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">El siguiente código:</target>
        </trans-unit>
        <trans-unit id="e7bbda963d845e557f51712e433c51a15b6fe29c" translate="yes" xml:space="preserve">
          <source>The function is executed right after it's created, not after it is parsed. The entire script block is parsed before any code in it is executed. Also, parsing code doesn't automatically mean that it's executed, if for example the IIFE is inside a function then it won't be executed until the function is called.</source>
          <target state="translated">La función se ejecuta justo después de ser creada,no después de ser analizada.Todo el bloque de guión es analizado antes de que se ejecute cualquier código en él.Además,analizar el código no significa automáticamente que se ejecute,si por ejemplo el IIFE está dentro de una función,entonces no se ejecutará hasta que la función sea llamada.</target>
        </trans-unit>
        <trans-unit id="6ca3ff5213c318e3b9ec03433344ff34245ae349" translate="yes" xml:space="preserve">
          <source>The performance benefit of using IIFE&amp;rsquo;s is the ability to pass commonly used global objects like &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt;, etc. as an argument by reducing the scope lookup. (Remember JavaScript looks for properties in local scope and way up the chain until global scope). So accessing global objects in local scope reduces the lookup time like below.</source>
          <target state="translated">El beneficio de rendimiento del uso de IIFE es la capacidad de pasar objetos globales de uso com&amp;uacute;n como &lt;code&gt;window&lt;/code&gt; , &lt;code&gt;document&lt;/code&gt; os , etc. como argumento al reducir la b&amp;uacute;squeda del alcance. (Recuerde que JavaScript busca propiedades en el &amp;aacute;mbito local y en la cadena hasta el alcance global). Por lo tanto, acceder a objetos globales en el &amp;aacute;mbito local reduce el tiempo de b&amp;uacute;squeda como se muestra a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="288fa7b05c269acc1a5c03c13d3ac79fce530f66" translate="yes" xml:space="preserve">
          <source>The reason self-evoking anonymous functions are used is they should never be called by other code since they &quot;set up&quot; the code which IS meant to be called (along with giving scope to functions and variables).</source>
          <target state="translated">La razón por la que se utilizan las funciones anónimas autoevocadas es que nunca deben ser llamadas por otro código,ya que &quot;configuran&quot; el código que debe ser llamado (junto con dar alcance a las funciones y variables).</target>
        </trans-unit>
        <trans-unit id="24e31faeedc1c433bb3b9e8c9d599d3d544b30be" translate="yes" xml:space="preserve">
          <source>Therefore, instead of using that complex construct of IIFE for the use case I mentioned above, you can now write much, much simpler code to make sure that a variable's scope does not leak out of your desired block.</source>
          <target state="translated">Por lo tanto,en lugar de usar esa compleja construcción de IIFE para el caso de uso que mencioné anteriormente,ahora puede escribir un código mucho,mucho más simple para asegurarse de que el alcance de una variable no se escape de su bloque deseado.</target>
        </trans-unit>
        <trans-unit id="f757a6a5f520f7c84d83fdf2c6f0a73f17baf005" translate="yes" xml:space="preserve">
          <source>This code above will execute as soon as you load iife.js and will print '&lt;em&gt;Hello Stackoverflow!&lt;/em&gt;' on the developer tools' console.</source>
          <target state="translated">Este c&amp;oacute;digo anterior se ejecutar&amp;aacute; tan pronto como cargue iife.js e imprimir&amp;aacute; ' &lt;em&gt;Hello Stackoverflow!&lt;/em&gt; consola 'en las herramientas del desarrollador'.</target>
        </trans-unit>
        <trans-unit id="1b7900604a551b4491f3627f5f85daa451838595" translate="yes" xml:space="preserve">
          <source>This is an Immediately Invoked Function Expression in Javascript:</source>
          <target state="translated">Esta es una expresión de función inmediatamente invocada en Javascript:</target>
        </trans-unit>
        <trans-unit id="60fca009bce50f0f52bdaae51ab0767f17cf922c" translate="yes" xml:space="preserve">
          <source>This is called IIFE (Immediately Invoked Function Expression). One of the famous JavaScript design patterns, it is the heart and soul of the modern day Module pattern. As the name suggests it executes immediately after it is created. This pattern creates an isolated or private scope of execution.</source>
          <target state="translated">Esto se llama IIFE (Expresión de Función Inmediatamente Invocada).Uno de los famosos patrones de diseño de JavaScript,es el corazón y el alma del patrón del Módulo de hoy en día.Como su nombre lo sugiere,se ejecuta inmediatamente después de ser creado.Este patrón crea un ámbito de ejecución aislado o privado.</target>
        </trans-unit>
        <trans-unit id="05397156e7479340c0e62d149e3f317e55817dd5" translate="yes" xml:space="preserve">
          <source>This is the self-invoking anonymous function. It is executed while it is defined. Which means this function is defined and invokes itself immediate after the definition.</source>
          <target state="translated">Esta es la función anónima autoinvocable.Se ejecuta mientras está definida.Lo que significa que esta función está definida y se invoca a sí misma inmediatamente después de la definición.</target>
        </trans-unit>
        <trans-unit id="aa5eeda16874ed79c3a0bf338d464e2c9e434f2d" translate="yes" xml:space="preserve">
          <source>This is why, maybe, you confused this construction with an event-handler for &lt;code&gt;window.onload&lt;/code&gt;, because it&amp;rsquo;s often used as this:</source>
          <target state="translated">Esta es la raz&amp;oacute;n por la que, tal vez, confundiste esta construcci&amp;oacute;n con un controlador de eventos para &lt;code&gt;window.onload&lt;/code&gt; , porque a menudo se usa as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="a43a0884e808455e619c5e39b5f6305cd32b762b" translate="yes" xml:space="preserve">
          <source>This pattern is often used when trying to avoid polluting the global namespace, because all the variables used inside the IIFE (like in any other &lt;em&gt;normal&lt;/em&gt; function) are not visible outside its scope.</source>
          <target state="translated">Este patr&amp;oacute;n a menudo se usa cuando se intenta evitar contaminar el espacio de nombres global, porque todas las variables utilizadas dentro del IIFE (como en cualquier otra funci&amp;oacute;n &lt;em&gt;normal&lt;/em&gt; ) no son visibles fuera de su alcance.</target>
        </trans-unit>
        <trans-unit id="e5250168d0e420ea15ffcae2855451c4b761867b" translate="yes" xml:space="preserve">
          <source>Three more common wordings:</source>
          <target state="translated">Tres formulaciones más comunes:</target>
        </trans-unit>
        <trans-unit id="119c79105d25740edafd02ae5b6f7eec36e65e3a" translate="yes" xml:space="preserve">
          <source>To understand IIFE in JS, lets break it down:</source>
          <target state="translated">Para entender la VIDA en JS,vamos a desglosarla:</target>
        </trans-unit>
        <trans-unit id="d6b77b85dccd745a3fe0ec9e1915b8ec0a8ad02c" translate="yes" xml:space="preserve">
          <source>Two ways we can create &lt;strong&gt;IIFE&lt;/strong&gt;</source>
          <target state="translated">Dos formas de crear &lt;strong&gt;IIFE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fcbaaaf9b6840e78103bf684f0bdd12dcbede43" translate="yes" xml:space="preserve">
          <source>Use the parentheses to avoid a syntax error:</source>
          <target state="translated">Use los paréntesis para evitar un error de sintaxis:</target>
        </trans-unit>
        <trans-unit id="9b1aacb25d4d7569574ad43074d0946d45db2a84" translate="yes" xml:space="preserve">
          <source>Usually, we don't invoke a function immediately after we write it in the program. 
In extremely simple terms, when you call a function right after its creation, it is called IIFE - a fancy name.</source>
          <target state="translated">Normalmente,no invocamos una función inmediatamente después de escribirla en el programa.En términos extremadamente simples,cuando se llama a una función justo después de su creación,se llama IIFE-un nombre de fantasía.</target>
        </trans-unit>
        <trans-unit id="14a0e82e7bb0518d267319e1cbab5b31ff6842ec" translate="yes" xml:space="preserve">
          <source>Very cool.</source>
          <target state="translated">Muy bien.</target>
        </trans-unit>
        <trans-unit id="8ac9ae8ffa3d3c2849f98072d24c38d7af8d342b" translate="yes" xml:space="preserve">
          <source>What is the (function() { } )() construct in JavaScript</source>
          <target state="translated">¿Cuál es la construcción de (function(){})()en JavaScript</target>
        </trans-unit>
        <trans-unit id="231d04fc5024ad157d8b00b3dbb591e327427435" translate="yes" xml:space="preserve">
          <source>When we are dealing with a large code base and/or when we are importing various libraries the chance of naming conflicts increases. When we are writing certain parts of our code which is related (and thus is using the same variables) inside an IIFE all of the &lt;strong&gt;variables and function names are scoped to the function brackets of the IIFE&lt;/strong&gt;. This reduces chances of naming conflicts and lets you name them more careless (e.g. you don't have to prefix them).</source>
          <target state="translated">Cuando tratamos con una base de c&amp;oacute;digo grande y / o cuando importamos varias bibliotecas, aumenta la posibilidad de conflictos de nombres. Cuando estamos escribiendo ciertas partes de nuestro c&amp;oacute;digo que est&amp;aacute; relacionado (y por lo tanto est&amp;aacute; usando las mismas variables) dentro de un IIFE, todas las &lt;strong&gt;variables y nombres de funciones est&amp;aacute;n dentro de los par&amp;eacute;ntesis de funciones del IIFE&lt;/strong&gt; . Esto reduce las posibilidades de nombrar conflictos y le permite nombrarlos de forma m&amp;aacute;s descuidada (por ejemplo, no es necesario que los prefije).</target>
        </trans-unit>
        <trans-unit id="d6ee7a9da24cd817643c34a656eca9b71e280cb0" translate="yes" xml:space="preserve">
          <source>Why is this useful?</source>
          <target state="translated">¿Por qué es esto útil?</target>
        </trans-unit>
        <trans-unit id="c55517152e7cc3243eca3932069c2820ebe391fe" translate="yes" xml:space="preserve">
          <source>You can even write:</source>
          <target state="translated">Incluso puedes escribir:</target>
        </trans-unit>
        <trans-unit id="9896d74e8f60c2be315cd9b2c7f1cb80c597ad0c" translate="yes" xml:space="preserve">
          <source>You can leave off the function name:</source>
          <target state="translated">Puedes dejar el nombre de la función:</target>
        </trans-unit>
        <trans-unit id="0470cb63114ace850d7c50d5c5d0512a46149f43" translate="yes" xml:space="preserve">
          <source>You cannot self-invoke a function declaration.</source>
          <target state="translated">No puedes autoinvocar una declaración de función.</target>
        </trans-unit>
        <trans-unit id="80b55755751b78dc96e2105d875ad62fc884571a" translate="yes" xml:space="preserve">
          <source>b) We are invoking this funtion at the same time using the () at the end of it.</source>
          <target state="translated">b)Estamos invocando esta función al mismo tiempo usando la ()al final de la misma.</target>
        </trans-unit>
        <trans-unit id="5a0f90b8e1bc3acdf41aed42023e812c2c303c71" translate="yes" xml:space="preserve">
          <source>is called an &lt;strong&gt;immediately invoked function expression&lt;/strong&gt; (IIFE).</source>
          <target state="translated">se llama una &lt;strong&gt;expresi&amp;oacute;n de funci&amp;oacute;n invocada inmediatamente&lt;/strong&gt; (IIFE).</target>
        </trans-unit>
        <trans-unit id="e24ae834b8fdc0300d07f73f952ddbc3aedb8af4" translate="yes" xml:space="preserve">
          <source>produces this output:</source>
          <target state="translated">produce esta salida:</target>
        </trans-unit>
        <trans-unit id="537c7047f37c2eecdd1daa181117234bdf353f51" translate="yes" xml:space="preserve">
          <source>so if &lt;code&gt;windows.app&lt;/code&gt; is not defined, then &lt;code&gt;window.app = {}&lt;/code&gt; is immediately executed, so &lt;code&gt;window.app&lt;/code&gt; is assigned with &lt;code&gt;{}&lt;/code&gt; during the condition evaluation, so the result is both &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;window.app&lt;/code&gt; now become &lt;code&gt;{}&lt;/code&gt;, so console output is:</source>
          <target state="translated">as&amp;iacute; que si &lt;code&gt;windows.app&lt;/code&gt; no est&amp;aacute; definido, entonces &lt;code&gt;window.app = {}&lt;/code&gt; se ejecuta inmediatamente, por lo que &lt;code&gt;window.app&lt;/code&gt; se asigna con &lt;code&gt;{}&lt;/code&gt; durante la evaluaci&amp;oacute;n de la condici&amp;oacute;n, por lo que el resultado es que la &lt;code&gt;app&lt;/code&gt; y &lt;code&gt;window.app&lt;/code&gt; ahora se convierten en &lt;code&gt;{}&lt;/code&gt; , entonces la salida de la consola es:</target>
        </trans-unit>
        <trans-unit id="feb062cf00888ada37d37ce1300e60f61e961935" translate="yes" xml:space="preserve">
          <source>so if I do:</source>
          <target state="translated">así que si lo hago:</target>
        </trans-unit>
        <trans-unit id="172e222242f37744f300767d18cc0b7b1beaa362" translate="yes" xml:space="preserve">
          <source>we are doing two things over here.
a) Wrapping our function expression inside braces (). This goes to tell the syntax parser the whatever placed inside the () is an expression (function expression in this case) and is a valid code.</source>
          <target state="translated">estamos haciendo dos cosas aquí.a)Envolver nuestra expresión de función dentro de los frenos ().Esto va a decirle al analizador de sintaxis que lo que sea que esté colocado dentro de la ()es una expresión (expresión de la función en este caso)y es un código válido.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
