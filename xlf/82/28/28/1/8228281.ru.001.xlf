<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/8228281">
    <body>
      <group id="8228281">
        <trans-unit id="9dadaa9496929c84c3ab6989b1c844585b555e1d" translate="yes" xml:space="preserve">
          <source>- During execution (Execution Context - Execute phase), the funtion object is created on the fly (&lt;strong&gt;its not executed yet&lt;/strong&gt;), gets assigned to 'greet' variable and it can be invoked using 'greet('somename')'.</source>
          <target state="translated">- Во время выполнения (контекст выполнения - фаза выполнения) объект функции создается &amp;laquo;на лету&amp;raquo; ( &lt;strong&gt;он еще не выполнен&lt;/strong&gt; ), ему присваивается переменная &amp;laquo;greet&amp;raquo;, и его можно вызывать с помощью &amp;laquo;greet (&amp;laquo; somename &amp;raquo;)&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6a158b11158c99a0df72e82df408cf783123c9ff" translate="yes" xml:space="preserve">
          <source>- IIFE, being a function, has its own execution context, meaning all the variables created inside it are local to this function and are not shared with the global execution context.</source>
          <target state="translated">-IIFE,будучи функцией,имеет свой собственный контекст выполнения,то есть все переменные,созданные внутри нее,локальны для этой функции и не разделяются с глобальным контекстом выполнения.</target>
        </trans-unit>
        <trans-unit id="ad28c57779ed69eaee3b61747f53357c4dd296f6" translate="yes" xml:space="preserve">
          <source>- Notice the '()' immediately after the function declaration. Every funtion object has a 'CODE' property attached to it which is callable. And we can call it (or invoke it) using '()' braces.</source>
          <target state="translated">-Обратите внимание на &quot;()&quot; сразу после объявления функции.Каждый объект функции имеет свойство 'CODE',которое является вызываемым.И мы можем вызывать его (или вызывать)с помощью скобок '()'.</target>
        </trans-unit>
        <trans-unit id="7b549f1532a5f31afc5bc29127c287e5f5a88a77" translate="yes" xml:space="preserve">
          <source>- So here, during the execution (Execution Context - Execute Phase), &lt;strong&gt;the function object is created and its executed at the same time&lt;/strong&gt;
- So now, the greeting variable, instead of having the funtion object, has its return value ( a string )</source>
          <target state="translated">- Таким образом, здесь, во время выполнения (Контекст выполнения - Фаза выполнения), &lt;strong&gt;объект функции создается и выполняется одновременно&lt;/strong&gt; - Итак, теперь переменная приветствия вместо объекта функции имеет возвращаемое значение (строку)</target>
        </trans-unit>
        <trans-unit id="f2d32b6c54b2eea7b4f08964506c4a14da8bb30d" translate="yes" xml:space="preserve">
          <source>- When JS engine runs for the first time (Execution Context - Create Phase), this function (on the right side of = above) does not get executed or stored in the memory. Variable 'greet' is assigned 'undefined' value by the JS engine.</source>
          <target state="translated">-При первом запуске JS-движка (Execution Context-Create Phase)эта функция (справа от=выше)не выполняется и не сохраняется в памяти.Переменной 'greet' JS-движок присваивает 'неопределенное' значение.</target>
        </trans-unit>
        <trans-unit id="ef59722e8ed96066e8f649d55ddc705002e2bbbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Immediately Invoked Funtion Expression:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. Сразу же вызванное выражение функции:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c57cca2ae891930962d46154d0cdd7701cf2ca8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;So this function gets created and executed at the same time (IIFE).&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Таким образом, эта функция создается и выполняется одновременно (IIFE).&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c3e8c29c460f778fb10c68b7b5f483c3b0d796f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Correction suggested by &lt;a href=&quot;https://stackoverflow.com/users/69083/guffa&quot;&gt;Guffa&lt;/a&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Исправление, предложенное &lt;a href=&quot;https://stackoverflow.com/users/69083/guffa&quot;&gt;Гуффой&lt;/a&gt; :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2ed48c31f74161c223bba47f878a789f77b5069" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Alternative (Recommended)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 Альтернатива (рекомендуется)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47754a1062d962b6ce15d48457bec71b3f369e46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expression&lt;/strong&gt;: Something that returns a value</source>
          <target state="translated">&lt;strong&gt;Выражение&lt;/strong&gt; : что-то, что возвращает значение</target>
        </trans-unit>
        <trans-unit id="46b1b6e1b44f3520e2793cb8255547db860a73db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Expression&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Выражение функции&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="50eff3e72b9320085e3583c9fee5aae42ebfd0b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How IIFE works&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Как работает IIFE&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="804eeffad7b4e11fec563767c8bf6ee40edfb082" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How function expression works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как работает выражение функции:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="315b05a17b0a236580165cfed17571d5661f8e8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IIFE keeps our code safe.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IIFE сохраняет наш код в безопасности.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e21af655815475d3a776d89c71bee90a334352e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important usecase for IIFE: &lt;br/&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Важный сценарий использования IIFE:&lt;/strong&gt; &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="733ad654e28f5f19e0ccacbd5bd074cd18bf34ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Most Common Use-case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Наиболее распространенный вариант использования:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e719c6166298c86686ad285062a762b144fe333" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typical usecase of IIFE in JS:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Типичный пример использования IIFE в JS:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd4b667e7450fd1da7be97c55c23d9054c910440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;
Since this is a pretty popular topic, it's worth mentioning that IIFE's can also be written with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES6's arrow function&lt;/a&gt; (like &lt;a href=&quot;https://stackoverflow.com/users/368691/gajus&quot;&gt;Gajus&lt;/a&gt; has pointed out &lt;a href=&quot;https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript/8228308#comment43521302_8228308&quot;&gt;in a comment&lt;/a&gt;) :</source>
          <target state="translated">&lt;strong&gt;Обновление&lt;/strong&gt; Поскольку это довольно популярная тема, стоит упомянуть, что IIFE также может быть написано с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;помощью функции стрелки ES6&lt;/a&gt; (как &lt;a href=&quot;https://stackoverflow.com/users/368691/gajus&quot;&gt;Гаджус&lt;/a&gt; указал &lt;a href=&quot;https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript/8228308#comment43521302_8228308&quot;&gt;в комментарии&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="f4c3381f63f3402e4c893d3819f4639fcfc1cafd" translate="yes" xml:space="preserve">
          <source>A self-invoking expression is invoked (started) automatically, without
  being called.</source>
          <target state="translated">Самозваное выражение вызывается (запускается)автоматически,без вызова.</target>
        </trans-unit>
        <trans-unit id="47c2a38385c0fcf1a4d905bdef7a2aae0eec35d8" translate="yes" xml:space="preserve">
          <source>After we have an expression which evaluates to a function object we then can immediately &lt;strong&gt;invoke&lt;/strong&gt; the function object with the &lt;code&gt;()&lt;/code&gt; operator. For example:</source>
          <target state="translated">После того, как у нас есть выражение, которое оценивает функциональный объект, мы можем немедленно &lt;strong&gt;вызвать&lt;/strong&gt; функциональный объект с помощью оператора &lt;code&gt;()&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="7f06afd34a563714ec314b68da3f205e40cda76f" translate="yes" xml:space="preserve">
          <source>Alternatively, it can be:</source>
          <target state="translated">Или может быть:</target>
        </trans-unit>
        <trans-unit id="ef9203bbedd9adb33629bea17c2eb428a0a6054a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IIFE&lt;/code&gt; can also be described as a self-invoking anonymous function. Its most common usage is to limit the scope of a variable made via var or to encapsulate context to avoid name collisions.</source>
          <target state="translated">&lt;code&gt;IIFE&lt;/code&gt; также может быть описан как вызывающая себя анонимная функция. Его наиболее распространенное использование - ограничить область действия переменной, создаваемой через var, или инкапсулировать контекст, чтобы избежать конфликтов имен.</target>
        </trans-unit>
        <trans-unit id="6054fe82da32385b7ed0dbfbae9f67f812a1d185" translate="yes" xml:space="preserve">
          <source>An expression is simply a bunch of code which can be evaluated to &lt;strong&gt;a single value&lt;/strong&gt;. In case of the expressions in the above example this value was a &lt;strong&gt;single function object&lt;/strong&gt;.</source>
          <target state="translated">Выражение - это просто набор кода, который может быть оценен до &lt;strong&gt;одного значения&lt;/strong&gt; . В случае выражений в вышеприведенном примере это значение было &lt;strong&gt;единственным объектом функции&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1b232444188015e33e960e2241dffbfda478d3cb" translate="yes" xml:space="preserve">
          <source>An immediately invoked function expression (IIFE) is a function that's executed as soon as it's created. It has no connection with any events or asynchronous execution. You can define an IIFE as shown below:</source>
          <target state="translated">Немедленно вызываемое выражение функции (IIFE)-это функция,которая выполняется сразу после ее создания.Оно не связано ни с какими событиями,ни с асинхронным выполнением.Вы можете определить IIFE,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="0cd1fb5aec37c798839c8d1d191684f280e2a7bc" translate="yes" xml:space="preserve">
          <source>An immediately-invoked function expression (IIFE) immediately calls a function. This simply means that the function is executed immediately after the completion of the definition.</source>
          <target state="translated">Немедленно вызываемое выражение функции (IIFE)немедленно вызывает функцию.Это просто означает,что функция выполняется сразу после завершения определения.</target>
        </trans-unit>
        <trans-unit id="e23b647b429bf20b9259177559b651dd7775b8c6" translate="yes" xml:space="preserve">
          <source>And the explanation of the syntax is: The function within the first &lt;code&gt;()&lt;/code&gt; parenthesis is the function which has no name and by the next &lt;code&gt;();&lt;/code&gt; parenthesis you can understand that it is called at the time it is defined. And you can pass any argument in this second &lt;code&gt;()&lt;/code&gt; parenthesis which will be grabbed in the function which is in the first parenthesis. See this example:</source>
          <target state="translated">И объяснение синтаксиса таково: функция в круглых скобках first &lt;code&gt;()&lt;/code&gt; - это функция, которая не имеет имени и next &lt;code&gt;();&lt;/code&gt; в скобках вы можете понять, что он вызывается во время его определения. И вы можете передать любой аргумент в этой скобке second &lt;code&gt;()&lt;/code&gt; , который будет взят в функции, которая находится в первой скобке. Смотрите этот пример:</target>
        </trans-unit>
        <trans-unit id="2a08b6d6216c318f07a63ce64ce5e83f1c1d8bf5" translate="yes" xml:space="preserve">
          <source>But the above two construct are not &lt;strong&gt;IIFE&lt;/strong&gt;.</source>
          <target state="translated">Но две вышеупомянутые конструкции не являются &lt;strong&gt;IIFE&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee3f501ca67bbeb5c059c6705b2167b219acadc" translate="yes" xml:space="preserve">
          <source>By using this syntax you avoid colliding with global variables declared elsewhere in your JavaScript code.</source>
          <target state="translated">Используя этот синтаксис,вы избегаете столкновения с глобальными переменными,объявленными где-либо в вашем JavaScript-коде.</target>
        </trans-unit>
        <trans-unit id="fe1b40c8fab9f166a675bd98799bd55d26f8fea3" translate="yes" xml:space="preserve">
          <source>Call the function immediately -- oops:</source>
          <target state="translated">Немедленно вызовите функцию...Упс:</target>
        </trans-unit>
        <trans-unit id="bed0e00f9fc23279ca684a1d493bc0948fd61a7d" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;http://www.w3schools.com/js/js_function_definition.asp&quot;&gt;W3Schools explanation of a self-invoking function&lt;/a&gt;.</source>
          <target state="translated">Ознакомьтесь с &lt;a href=&quot;http://www.w3schools.com/js/js_function_definition.asp&quot;&gt;объяснением W3Schools о функции самовозбуждения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="555c6fb5b44d531f9e53fcbc10a3a35e96167dd6" translate="yes" xml:space="preserve">
          <source>Consider the function below written in a file named iife.js</source>
          <target state="translated">Рассмотрим функцию,описанную ниже,записанную в файле с именем iife.js</target>
        </trans-unit>
        <trans-unit id="dfb3b4ee9c5d621bdda0a0d76975d4708fc3ac9d" translate="yes" xml:space="preserve">
          <source>Consider the part within the first pair of parentheses: &lt;code&gt;(&lt;b&gt;function(){}&lt;/b&gt;)();&lt;/code&gt;....it is a regular function expression. Then look at the last pair &lt;code&gt;(function(){})&lt;b&gt;()&lt;/b&gt;;&lt;/code&gt;, this is normally added to an expression to call a function; in this case, our prior expression.</source>
          <target state="translated">Рассмотрим часть в первой паре скобок: &lt;code&gt;(&lt;b&gt;function(){}&lt;/b&gt;)();&lt;/code&gt; .... это регулярное выражение функции. Затем посмотрите на последнюю пару &lt;code&gt;(function(){})&lt;b&gt;()&lt;/b&gt;;&lt;/code&gt; обычно это добавляется к выражению для вызова функции; в этом случае наше предыдущее выражение.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7ac36349dda560270779b789cbf43d471f646ee7" translate="yes" xml:space="preserve">
          <source>Example: Try out following in chrome console. These are expressions in JS.</source>
          <target state="translated">Пример:Попробуйте следующее в хромированной консоли.Это выражения в JS.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="a16fbf4816018018ce84d149cfed2d3768185a11" translate="yes" xml:space="preserve">
          <source>Fiddle: &lt;a href=&quot;http://jsfiddle.net/maniator/LqvpQ/&quot;&gt;http://jsfiddle.net/maniator/LqvpQ/&lt;/a&gt;</source>
          <target state="translated">Скрипка: &lt;a href=&quot;http://jsfiddle.net/maniator/LqvpQ/&quot;&gt;http://jsfiddle.net/maniator/LqvpQ/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3adf70295ac336ffda7f66d5b40c9b5b7da8682d" translate="yes" xml:space="preserve">
          <source>For a Detailed explanation see &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Immediately-Invoked Function Expression (IIFE)&lt;/a&gt;</source>
          <target state="translated">Подробное объяснение см. В разделе &amp;laquo; &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Вызов функции с немедленным вызовом&amp;raquo; (IIFE).&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c6fccf633b8091e55000dd559026cd3b58ab04e" translate="yes" xml:space="preserve">
          <source>Function expressions can be made &quot;self-invoking&quot;.</source>
          <target state="translated">Функциональные выражения могут быть сделаны &quot;самозваными&quot;.</target>
        </trans-unit>
        <trans-unit id="26db9da6beae79b61580102af1a1cae9c9752e6a" translate="yes" xml:space="preserve">
          <source>Function expressions will execute automatically if the expression is
  followed by ().</source>
          <target state="translated">Выражения функций будут выполняться автоматически,если за выражением следует ().</target>
        </trans-unit>
        <trans-unit id="93cc4de26d2f9c0383f0e9df26c846aef1578f8e" translate="yes" xml:space="preserve">
          <source>Here the 'object' you are passing will be accessible within the function by 'obj', as you are grabbing it in the function signature.</source>
          <target state="translated">Здесь передаваемый &quot;объект&quot; будет доступен внутри функции с помощью 'obj',так как вы захватываете его в сигнатуре функции.</target>
        </trans-unit>
        <trans-unit id="310dbc9ededfe37d2f49c2fae2cfedca9bb3170d" translate="yes" xml:space="preserve">
          <source>I call it a &lt;code&gt;Curly Jail&lt;/code&gt;.</source>
          <target state="translated">Я называю это &lt;code&gt;Curly Jail&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc657204917761bd8680e03ced88ddf4b0d2f99e" translate="yes" xml:space="preserve">
          <source>I think the 2 sets of brackets makes it a bit confusing but I saw another usage in googles example, they used something similar, I hope this will help you understand better:</source>
          <target state="translated">Я думаю,что 2 набора скобок немного сбивают с толку,но я видел еще одно использование в примере гугла,они использовали что-то похожее,я надеюсь,что это поможет вам лучше понять:</target>
        </trans-unit>
        <trans-unit id="da90c222860bf1dca29f728207fcaa3217f05ea7" translate="yes" xml:space="preserve">
          <source>I used to know what this meant, but I'm struggling now...</source>
          <target state="translated">Раньше я знал,что это значит,но сейчас я борюсь...</target>
        </trans-unit>
        <trans-unit id="1adaf50c667f60887370ba409da371b6afb75b21" translate="yes" xml:space="preserve">
          <source>IIFE (Immediately invoked function expression) is a function which executes as soon as the script loads and goes away.</source>
          <target state="translated">IIFE (выражение функции немедленного вызова)-это функция,которая выполняется,как только скрипт загружается и исчезает.</target>
        </trans-unit>
        <trans-unit id="2dbc909f43d9178cbccc47855c456cf4752621ef" translate="yes" xml:space="preserve">
          <source>If there are no special requirements for its return value, then we can write:</source>
          <target state="translated">Если нет специальных требований к его возвращаемому значению,то мы можем написать:</target>
        </trans-unit>
        <trans-unit id="3bf309c08d49299b6010eb01372d2db6695104c5" translate="yes" xml:space="preserve">
          <source>In ES6 syntax (posting for myself, as I keep landing on this page looking for a quick example):</source>
          <target state="translated">В синтаксисе ES6 (размещаю для себя,так как продолжаю приземляться на эту страницу в поисках быстрого примера):</target>
        </trans-unit>
        <trans-unit id="b5f54c58ea6a05bfe712cb33b673358aba022076" translate="yes" xml:space="preserve">
          <source>In ES6, we now can have variables created via &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Both of them are block-scoped (unlike &lt;code&gt;var&lt;/code&gt; which is a function-scoped).</source>
          <target state="translated">В ES6 у нас теперь могут быть переменные, созданные с помощью &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; . Оба они имеют блочную область (в отличие от &lt;code&gt;var&lt;/code&gt; , который является функциональной областью).</target>
        </trans-unit>
        <trans-unit id="16f5da42d75b65b9cb3a9aa47149d04a1c65df9a" translate="yes" xml:space="preserve">
          <source>In following example, count will not be available outside the immediately invoked function i.e. Scope of &lt;code&gt;count&lt;/code&gt; will not leak out of the function. You should get a &lt;code&gt;Reference Error&lt;/code&gt;, should you try to access it outside of the immediately invoked function anyway.</source>
          <target state="translated">В следующем примере подсчет не будет доступен вне немедленно вызванной функции, т.е. область &lt;code&gt;count&lt;/code&gt; не будет вытекать из функции. Вы должны получить &lt;code&gt;Reference Error&lt;/code&gt; , если в любом случае попытаетесь получить доступ к ней вне немедленно вызванной функции.</target>
        </trans-unit>
        <trans-unit id="ed59eaac2704626c5d7967c3ef0bd1a82cf33639" translate="yes" xml:space="preserve">
          <source>In jQuery there is a similar construct that you might be thinking of:</source>
          <target state="translated">В jQuery есть похожая конструкция,о которой вы,возможно,думаете:</target>
        </trans-unit>
        <trans-unit id="3285fe005e794f8056d470509f3d977dcccbf1a1" translate="yes" xml:space="preserve">
          <source>In other words, they are like programs that &quot;make classes', at the beginning of program. After they are instantiated (automatically), the only functions that are available are the ones returned in by the anonymous function. However, all the other 'hidden' functions are still there, along with any state (variables set during scope creation).</source>
          <target state="translated">Другими словами,они похожи на программы,которые &quot;делают классы&quot;,в начале программы.После того,как они инстанцируются (автоматически),единственными доступными функциями являются те,которые возвращаются анонимной функцией.Однако все остальные &quot;скрытые&quot; функции все еще остаются там,наряду с любым состоянием (переменные,заданные при создании области видимости).</target>
        </trans-unit>
        <trans-unit id="2246f55eec4876f796cbcd0d31de04ec8a5653b5" translate="yes" xml:space="preserve">
          <source>In the code snippet above, &amp;ldquo;&lt;em&gt;var app&lt;/em&gt;&amp;rdquo; is a local variable now.</source>
          <target state="translated">В приведенном выше фрагменте кода &amp;laquo; &lt;em&gt;var app&lt;/em&gt; &amp;raquo; теперь является локальной переменной.</target>
        </trans-unit>
        <trans-unit id="c65f76b1db4bba18bb99168719c858dda4d4fb91" translate="yes" xml:space="preserve">
          <source>In this example, we used &lt;code&gt;let&lt;/code&gt; to define a &lt;code&gt;count&lt;/code&gt; variable which makes &lt;code&gt;count&lt;/code&gt; limited to the block of code, we created with the curly brackets &lt;code&gt;{...}&lt;/code&gt;.</source>
          <target state="translated">В этом примере мы использовали &lt;code&gt;let&lt;/code&gt; , чтобы определить переменную &lt;code&gt;count&lt;/code&gt; , которая ограничивает &lt;code&gt;count&lt;/code&gt; блоком кода, который мы создали с помощью фигурных скобок &lt;code&gt;{...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17e4ba3bf69d8e68d6b4400bea5fc5f6ee728362" translate="yes" xml:space="preserve">
          <source>Is this basically saying &lt;code&gt;document.onload&lt;/code&gt;?</source>
          <target state="translated">Это в основном говорит &lt;code&gt;document.onload&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="fd185ef785c5b04bd70812f4d46089d0eb0fa051" translate="yes" xml:space="preserve">
          <source>It declares an anonymous function, then calls it:</source>
          <target state="translated">Он объявляет анонимную функцию,а затем вызывает ее:</target>
        </trans-unit>
        <trans-unit id="82e817152a0385d95b61dff4c870bac1a4884074" translate="yes" xml:space="preserve">
          <source>It doesn't need to be any more complicated than that.</source>
          <target state="translated">Это не должно быть сложнее,чем это.</target>
        </trans-unit>
        <trans-unit id="d46472342d72627637ee258e3d6fdccc6199cf72" translate="yes" xml:space="preserve">
          <source>It has nothing to do with any event-handler for any events (such as &lt;code&gt;document.onload&lt;/code&gt;).</source>
          <target state="translated">Он не имеет никакого отношения к любому обработчику событий (например, &lt;code&gt;document.onload&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7c65f9349f5c5e98740e05bb18a002d20447896d" translate="yes" xml:space="preserve">
          <source>It is called IIFE - Immediately Invoked Function Expression. Here is an example to show it's syntax and usage. It is used to scope the use of variables only till the function and not beyond.</source>
          <target state="translated">Она называется IIFE-Выражение Немедленно Вызванных Функций.Вот пример,чтобы показать его синтаксис и использование.Он используется для обозначения использования переменных только до функции,а не за ее пределами.</target>
        </trans-unit>
        <trans-unit id="2b232da97c45835910b21510560d717bf4925972" translate="yes" xml:space="preserve">
          <source>It is called a function expression because the &lt;code&gt;( yourcode )&lt;/code&gt; operator in Javascript force it into an expression. The difference between a &lt;strong&gt;function expression&lt;/strong&gt; and a &lt;strong&gt;function declaration&lt;/strong&gt; is the following:</source>
          <target state="translated">Это называется выражением функции, потому что оператор &lt;code&gt;( yourcode )&lt;/code&gt; в Javascript принудительно превращает его в выражение. Разница между &lt;strong&gt;выражением&lt;/strong&gt; &lt;strong&gt;функции и объявлением функции&lt;/strong&gt; заключается в следующем:</target>
        </trans-unit>
        <trans-unit id="a1cc8fef367a1d081643d3e45d670fa0885cf488" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Immediately-Invoked Function Expression&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;&lt;strong&gt;IIFE&lt;/strong&gt;&lt;/a&gt; for short. It executes immediately after it&amp;rsquo;s created.</source>
          <target state="translated">Это выражение с &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;немедленным вызовом функции&lt;/a&gt; , или &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;&lt;strong&gt;сокращенно IIFE&lt;/strong&gt;&lt;/a&gt; . Он выполняется сразу после его создания.</target>
        </trans-unit>
        <trans-unit id="5b9bc8fdc31871ad312f7674abc5335932340a6a" translate="yes" xml:space="preserve">
          <source>It's just an anonymous function that is executed right after it's created.</source>
          <target state="translated">Это просто анонимная функция,которая выполняется сразу после ее создания.</target>
        </trans-unit>
        <trans-unit id="6a701e3ab7c285721f76ef5ce5480d80f7f9c81f" translate="yes" xml:space="preserve">
          <source>It's just as if you assigned it to a variable, and used it right after, only without the variable:</source>
          <target state="translated">Это как если бы вы присвоили ее переменной,и использовали сразу после этого,только без переменной:</target>
        </trans-unit>
        <trans-unit id="cb9f7eca5141640b0ea0732a3094579501b0966b" translate="yes" xml:space="preserve">
          <source>JavaScript prior to ECMAScript 6 used lexical scoping, so IIFE was used for simulating block scoping. (With ECMAScript 6 block scoping is possible with the introduction of the &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords.)
&lt;a href=&quot;https://gist.github.com/gurucharanmk/5071d37bb5af61a93562fbe024a975de&quot;&gt;Reference for issue with lexical scoping&lt;/a&gt;</source>
          <target state="translated">В JavaScript до ECMAScript 6 использовалась лексическая область видимости, поэтому IIFE использовался для моделирования блоковой области видимости. (С помощью ECMAScript 6 можно определить область видимости, введя ключевые слова &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; .) &lt;a href=&quot;https://gist.github.com/gurucharanmk/5071d37bb5af61a93562fbe024a975de&quot;&gt;Ссылка на проблему с лексической областью видимости&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e19d95ce34c23849a24e90884cd6e222319e0a3d" translate="yes" xml:space="preserve">
          <source>No, this construct just creates a scope for naming. If you break it in parts you can see that you have an external</source>
          <target state="translated">Нет,эта конструкция просто создает возможности для именования.Если вы разобьёте её на части,вы увидите,что у вас есть внешнее</target>
        </trans-unit>
        <trans-unit id="9ec030aac7f160c37131b600f5a5340267908578" translate="yes" xml:space="preserve">
          <source>Normally, JavaScript code has global scope in the application. When we declare global variable in it, there is a chance for using the same duplicate variable  in some other area of the development for some other purpose. Because of this duplication there may happen some error. So we can avoid this global variables by using immediately invoking function expression , this expression is self-executing expression.When we make our code inside this &lt;strong&gt;IIFE&lt;/strong&gt; expression global variable will be like local scope and local variable.</source>
          <target state="translated">Обычно код JavaScript имеет глобальную область видимости в приложении. Когда мы объявляем глобальную переменную в ней, есть шанс использовать ту же самую дублирующую переменную в какой-то другой области разработки для какой-то другой цели. Из-за этого дублирования может произойти какая-то ошибка. Таким образом, мы можем избежать этих глобальных переменных, используя немедленно вызывающее выражение функции, это выражение является &lt;strong&gt;самоисполняющимся&lt;/strong&gt; выражением. &lt;strong&gt;Когда&lt;/strong&gt; мы сделаем наш код внутри этого выражения &lt;strong&gt;IIFE,&lt;/strong&gt; глобальная переменная будет похожа на локальную область видимости и локальную переменную.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="f38bd5ec2c8a5dc7ab5e02966ee53d71fa6c0fb1" translate="yes" xml:space="preserve">
          <source>One more use case is memoization where a cache object is not global:</source>
          <target state="translated">Еще одним случаем использования является запоминание,когда объект кэша не является глобальным:</target>
        </trans-unit>
        <trans-unit id="c5723cd187bdd3a60686abb0d8678a7f72126e0f" translate="yes" xml:space="preserve">
          <source>One of its most common use case is to limit the scope of a variable made via &lt;code&gt;var&lt;/code&gt;. Variables created via &lt;code&gt;var&lt;/code&gt; have a scope limited to a function so this construct (which is a function wrapper around certain code) will make sure that your variable scope doesn't leak out of that function.</source>
          <target state="translated">Одним из наиболее распространенных вариантов использования является ограничение области действия переменной, создаваемой с помощью &lt;code&gt;var&lt;/code&gt; . Переменные, созданные с помощью &lt;code&gt;var&lt;/code&gt; , имеют область видимости, ограниченную функцией, поэтому эта конструкция (которая является оберткой функции вокруг определенного кода) будет следить за тем, чтобы область видимости вашей переменной не просочилась из этой функции.</target>
        </trans-unit>
        <trans-unit id="649fbe17413aa58c3db75fce30b2af7a47324cda" translate="yes" xml:space="preserve">
          <source>One short and dummy example where this is useful is:</source>
          <target state="translated">Один короткий и фиктивный пример,где это полезно:</target>
        </trans-unit>
        <trans-unit id="9f973b4d9d4883553f635f032543ac59fc9d3b69" translate="yes" xml:space="preserve">
          <source>Put it in a function and it is &lt;em&gt;no longer global&lt;/em&gt; -- your primary goal.</source>
          <target state="translated">Поместите это в функцию, и она &lt;em&gt;больше не будет глобальной&lt;/em&gt; - ваша основная цель.</target>
        </trans-unit>
        <trans-unit id="0d8b8fae40a82cc964b67a458b02dc9260b9c93e" translate="yes" xml:space="preserve">
          <source>Second Example:</source>
          <target state="translated">Второй пример:</target>
        </trans-unit>
        <trans-unit id="625b147902424ef9a991e2305153920d948e7261" translate="yes" xml:space="preserve">
          <source>Self-executing anonymous function. It's executed as soon as it is created.</source>
          <target state="translated">Самоисполняющаяся анонимная функция.Она выполняется сразу же после ее создания.</target>
        </trans-unit>
        <trans-unit id="70bd652cdc2b1167028d4ac8199834817346bc4e" translate="yes" xml:space="preserve">
          <source>Self-executing functions are typically used to encapsulate context and avoid name collusions. Any variable that you define inside the (function(){..})() are not global.</source>
          <target state="translated">Функции самоисполнения обычно используются для инкапсуляции контекста и избежания сговора имен.Любая переменная,которую вы определяете внутри (function(){...})(),не является глобальной.</target>
        </trans-unit>
        <trans-unit id="29c3122b24cc9e30c85129f7fd8c2d244d9dfdd2" translate="yes" xml:space="preserve">
          <source>Simulate block scoping with IIFE</source>
          <target state="translated">Моделирование блочного сканирования с помощью IIFE</target>
        </trans-unit>
        <trans-unit id="7a54357ff5057e04bccd7aaac33c16801b6fda73" translate="yes" xml:space="preserve">
          <source>So IIFE helps us to &lt;strong&gt;write safe code where we are not colliding with the global objects unintentionally.&lt;/strong&gt;</source>
          <target state="translated">Таким образом, IIFE помогает нам &lt;strong&gt;писать безопасный код, в котором мы не случайно сталкиваемся с глобальными объектами.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6335b000f7e2f11bed39166ec0a6f5ed56142e5" translate="yes" xml:space="preserve">
          <source>So instead of creating a list each time, you create it only once (less overhead).</source>
          <target state="translated">Таким образом,вместо того,чтобы создавать список каждый раз,вы создаете его только один раз (меньше накладных расходов).</target>
        </trans-unit>
        <trans-unit id="9a744001432e37728d3828edbc68f295cc3a7f66" translate="yes" xml:space="preserve">
          <source>Start here:</source>
          <target state="translated">Начни с этого:</target>
        </trans-unit>
        <trans-unit id="10358ef11702b06b5cb27eb8e15a2ecaf6c95eef" translate="yes" xml:space="preserve">
          <source>Suppose I've another JS file (test1.js) used in my applicaiton along with iife.js (see below).</source>
          <target state="translated">Предположим,у меня есть другой JS-файл (test1.js),используемый в моем приложении вместе с iife.js (см.ниже).</target>
        </trans-unit>
        <trans-unit id="5805911a132b44cbaa119ab669c316445b6aad4c" translate="yes" xml:space="preserve">
          <source>That construct is called &lt;strong&gt;Immediately Invoked Function Expression (IIFE)&lt;/strong&gt; which means it gets executed immediately. Think of it as a function getting called automatically when the interpreter reaches that function.</source>
          <target state="translated">Эта конструкция называется &lt;strong&gt;выражением немедленного вызова функции (IIFE),&lt;/strong&gt; что означает, что она выполняется немедленно. Думайте об этом как о функции, вызываемой автоматически, когда интерпретатор достигает этой функции.</target>
        </trans-unit>
        <trans-unit id="a18c6eaa532f587838670adc0ddd14b1e92311b6" translate="yes" xml:space="preserve">
          <source>That is a &lt;strong&gt;self-invoking anonymous function&lt;/strong&gt;.</source>
          <target state="translated">Это &lt;strong&gt;вызывающая себя анонимная функция&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="94f48842d979fe68c1a11afee92b8fe237e29013" translate="yes" xml:space="preserve">
          <source>That is a function invocation. Inside the parenthesis you have:</source>
          <target state="translated">Это вызов функции.Внутри скобки:</target>
        </trans-unit>
        <trans-unit id="8dc326bd0d30e0a8db56ac629c606c11b2a1c545" translate="yes" xml:space="preserve">
          <source>That is an anonymous function. Everything that is declared with &lt;strong&gt;var&lt;/strong&gt; inside the construct will be visible only inside the same construct and will not pollute the global namespace.</source>
          <target state="translated">Это анонимная функция. Все, что объявлено с помощью &lt;strong&gt;var&lt;/strong&gt; внутри конструкции, будет видно только внутри той же конструкции и не будет загрязнять глобальное пространство имен.</target>
        </trans-unit>
        <trans-unit id="8380108f1e1cb790902e70f48d87cc68895f11ac" translate="yes" xml:space="preserve">
          <source>That is saying execute immediately.</source>
          <target state="translated">То есть,немедленно казнить.</target>
        </trans-unit>
        <trans-unit id="0cfe61a50bbbb22ef9c2d6a0589f1ebe1efc25e6" translate="yes" xml:space="preserve">
          <source>That is the short form of binding the &lt;code&gt;ready&lt;/code&gt; event:</source>
          <target state="translated">Это краткая форма привязки &lt;code&gt;ready&lt;/code&gt; события:</target>
        </trans-unit>
        <trans-unit id="32e3ee7a8f238c3dc42124d9afe27b0f78dc70db" translate="yes" xml:space="preserve">
          <source>The code</source>
          <target state="translated">Код</target>
        </trans-unit>
        <trans-unit id="620d6ef1f9bea2f810b9b61a7131bfe9d5e2804f" translate="yes" xml:space="preserve">
          <source>The first pair of parentheses function(){...} converts the code inside the parentheses into an expression.The second pair of parentheses calls the function resulting from the expression.</source>
          <target state="translated">Первая пара скобок function(){...}преобразует код внутри скобок в выражение.Вторая пара скобок вызывает функцию,полученную из этого выражения.</target>
        </trans-unit>
        <trans-unit id="ea2dbcd87ff712d37a5e7773d759f85a11564ba0" translate="yes" xml:space="preserve">
          <source>The following IIFE pattern is quite commonly used.</source>
          <target state="translated">Довольно часто используется следующий шаблон IIFE.</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">Следующий код:</target>
        </trans-unit>
        <trans-unit id="e7bbda963d845e557f51712e433c51a15b6fe29c" translate="yes" xml:space="preserve">
          <source>The function is executed right after it's created, not after it is parsed. The entire script block is parsed before any code in it is executed. Also, parsing code doesn't automatically mean that it's executed, if for example the IIFE is inside a function then it won't be executed until the function is called.</source>
          <target state="translated">Функция выполняется сразу после создания,а не после разбора.Весь блок скрипта анализируется перед выполнением любого кода в нем.Кроме того,синтаксический разбор кода не означает,что он выполняется автоматически,если,например,IIFE находится внутри функции,то он не будет выполняться до вызова функции.</target>
        </trans-unit>
        <trans-unit id="6ca3ff5213c318e3b9ec03433344ff34245ae349" translate="yes" xml:space="preserve">
          <source>The performance benefit of using IIFE&amp;rsquo;s is the ability to pass commonly used global objects like &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt;, etc. as an argument by reducing the scope lookup. (Remember JavaScript looks for properties in local scope and way up the chain until global scope). So accessing global objects in local scope reduces the lookup time like below.</source>
          <target state="translated">Преимущество производительности при использовании IIFE заключается в возможности передавать широко используемые глобальные объекты, такие как &lt;code&gt;window&lt;/code&gt; , &lt;code&gt;document&lt;/code&gt; и т. Д., В качестве аргумента за счет сокращения поиска в области видимости. (Помните, что JavaScript ищет свойства в локальной области видимости и поднимается по цепочке до глобальной области видимости). Таким образом, доступ к глобальным объектам в локальной области сокращает время поиска, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="288fa7b05c269acc1a5c03c13d3ac79fce530f66" translate="yes" xml:space="preserve">
          <source>The reason self-evoking anonymous functions are used is they should never be called by other code since they &quot;set up&quot; the code which IS meant to be called (along with giving scope to functions and variables).</source>
          <target state="translated">Причина,по которой используются самозваные анонимные функции,заключается в том,что они никогда не должны вызываться другим кодом,так как они &quot;настраивают&quot; код,который должен быть вызван (наряду с предоставлением области видимости функциям и переменным).</target>
        </trans-unit>
        <trans-unit id="24e31faeedc1c433bb3b9e8c9d599d3d544b30be" translate="yes" xml:space="preserve">
          <source>Therefore, instead of using that complex construct of IIFE for the use case I mentioned above, you can now write much, much simpler code to make sure that a variable's scope does not leak out of your desired block.</source>
          <target state="translated">Поэтому вместо того,чтобы использовать эту сложную конструкцию IIFE для упомянутого выше случая использования,теперь можно написать намного,гораздо более простой код,чтобы область видимости переменной не утекла из нужного вам блока.</target>
        </trans-unit>
        <trans-unit id="f757a6a5f520f7c84d83fdf2c6f0a73f17baf005" translate="yes" xml:space="preserve">
          <source>This code above will execute as soon as you load iife.js and will print '&lt;em&gt;Hello Stackoverflow!&lt;/em&gt;' on the developer tools' console.</source>
          <target state="translated">Приведенный выше код будет выполнен, как только вы загрузите iife.js, и напечатает &amp;laquo; &lt;em&gt;Hello Stackoverflow!&amp;raquo;.&lt;/em&gt; на консоли разработчика.</target>
        </trans-unit>
        <trans-unit id="1b7900604a551b4491f3627f5f85daa451838595" translate="yes" xml:space="preserve">
          <source>This is an Immediately Invoked Function Expression in Javascript:</source>
          <target state="translated">Это выражение с немедленным вызовом функции в Javascript:</target>
        </trans-unit>
        <trans-unit id="60fca009bce50f0f52bdaae51ab0767f17cf922c" translate="yes" xml:space="preserve">
          <source>This is called IIFE (Immediately Invoked Function Expression). One of the famous JavaScript design patterns, it is the heart and soul of the modern day Module pattern. As the name suggests it executes immediately after it is created. This pattern creates an isolated or private scope of execution.</source>
          <target state="translated">Это называется IIFE (выражение функций с немедленным вызовом).Один из знаменитых шаблонов дизайна JavaScript,это сердце и душа современного шаблона Module.Как следует из названия,он выполняется сразу после его создания.Этот шаблон создает изолированную или приватную область выполнения.</target>
        </trans-unit>
        <trans-unit id="05397156e7479340c0e62d149e3f317e55817dd5" translate="yes" xml:space="preserve">
          <source>This is the self-invoking anonymous function. It is executed while it is defined. Which means this function is defined and invokes itself immediate after the definition.</source>
          <target state="translated">Это самозваная анонимная функция.Она выполняется во время определения.Что означает,что эта функция определяется и вызывает себя сразу после определения.</target>
        </trans-unit>
        <trans-unit id="aa5eeda16874ed79c3a0bf338d464e2c9e434f2d" translate="yes" xml:space="preserve">
          <source>This is why, maybe, you confused this construction with an event-handler for &lt;code&gt;window.onload&lt;/code&gt;, because it&amp;rsquo;s often used as this:</source>
          <target state="translated">Вот почему, может быть, вы перепутали эту конструкцию с обработчиком событий для &lt;code&gt;window.onload&lt;/code&gt; , потому что он часто используется так:</target>
        </trans-unit>
        <trans-unit id="a43a0884e808455e619c5e39b5f6305cd32b762b" translate="yes" xml:space="preserve">
          <source>This pattern is often used when trying to avoid polluting the global namespace, because all the variables used inside the IIFE (like in any other &lt;em&gt;normal&lt;/em&gt; function) are not visible outside its scope.</source>
          <target state="translated">Этот шаблон часто используется при попытке избежать загрязнения глобального пространства имен, потому что все переменные, используемые внутри IIFE (как и в любой другой &lt;em&gt;нормальной&lt;/em&gt; функции), не видны за пределами его области видимости.</target>
        </trans-unit>
        <trans-unit id="e5250168d0e420ea15ffcae2855451c4b761867b" translate="yes" xml:space="preserve">
          <source>Three more common wordings:</source>
          <target state="translated">Еще три общих слова:</target>
        </trans-unit>
        <trans-unit id="119c79105d25740edafd02ae5b6f7eec36e65e3a" translate="yes" xml:space="preserve">
          <source>To understand IIFE in JS, lets break it down:</source>
          <target state="translated">Чтобы понять IIFE в JS,давайте разберемся:</target>
        </trans-unit>
        <trans-unit id="d6b77b85dccd745a3fe0ec9e1915b8ec0a8ad02c" translate="yes" xml:space="preserve">
          <source>Two ways we can create &lt;strong&gt;IIFE&lt;/strong&gt;</source>
          <target state="translated">Мы можем создать &lt;strong&gt;IIFE&lt;/strong&gt; двумя способами</target>
        </trans-unit>
        <trans-unit id="7fcbaaaf9b6840e78103bf684f0bdd12dcbede43" translate="yes" xml:space="preserve">
          <source>Use the parentheses to avoid a syntax error:</source>
          <target state="translated">Используйте круглые скобки,чтобы избежать синтаксической ошибки:</target>
        </trans-unit>
        <trans-unit id="9b1aacb25d4d7569574ad43074d0946d45db2a84" translate="yes" xml:space="preserve">
          <source>Usually, we don't invoke a function immediately after we write it in the program. 
In extremely simple terms, when you call a function right after its creation, it is called IIFE - a fancy name.</source>
          <target state="translated">Обычно мы не вызываем функцию сразу после ее написания в программе.В предельно простых выражениях,когда вы вызываете функцию сразу после ее создания,она называется IIFE-причудливое имя.</target>
        </trans-unit>
        <trans-unit id="14a0e82e7bb0518d267319e1cbab5b31ff6842ec" translate="yes" xml:space="preserve">
          <source>Very cool.</source>
          <target state="translated">Очень круто.</target>
        </trans-unit>
        <trans-unit id="8ac9ae8ffa3d3c2849f98072d24c38d7af8d342b" translate="yes" xml:space="preserve">
          <source>What is the (function() { } )() construct in JavaScript</source>
          <target state="translated">Что такое конструкция (функция(){})()в JavaScript</target>
        </trans-unit>
        <trans-unit id="231d04fc5024ad157d8b00b3dbb591e327427435" translate="yes" xml:space="preserve">
          <source>When we are dealing with a large code base and/or when we are importing various libraries the chance of naming conflicts increases. When we are writing certain parts of our code which is related (and thus is using the same variables) inside an IIFE all of the &lt;strong&gt;variables and function names are scoped to the function brackets of the IIFE&lt;/strong&gt;. This reduces chances of naming conflicts and lets you name them more careless (e.g. you don't have to prefix them).</source>
          <target state="translated">Когда мы имеем дело с большой кодовой базой и / или когда мы импортируем различные библиотеки, вероятность конфликта имен увеличивается. Когда мы пишем определенные части нашего кода, которые связаны (и, следовательно, используют одни и те же переменные) внутри IIFE, все &lt;strong&gt;переменные и имена функций попадают в скобки функций IIFE&lt;/strong&gt; . Это уменьшает шансы на конфликты имен и позволяет вам назвать их более небрежно (например, вам не нужно ставить перед ними префикс).</target>
        </trans-unit>
        <trans-unit id="d6ee7a9da24cd817643c34a656eca9b71e280cb0" translate="yes" xml:space="preserve">
          <source>Why is this useful?</source>
          <target state="translated">Почему это полезно?</target>
        </trans-unit>
        <trans-unit id="c55517152e7cc3243eca3932069c2820ebe391fe" translate="yes" xml:space="preserve">
          <source>You can even write:</source>
          <target state="translated">Ты даже можешь писать:</target>
        </trans-unit>
        <trans-unit id="9896d74e8f60c2be315cd9b2c7f1cb80c597ad0c" translate="yes" xml:space="preserve">
          <source>You can leave off the function name:</source>
          <target state="translated">Вы можете оставить название функции:</target>
        </trans-unit>
        <trans-unit id="0470cb63114ace850d7c50d5c5d0512a46149f43" translate="yes" xml:space="preserve">
          <source>You cannot self-invoke a function declaration.</source>
          <target state="translated">Вы не можете самостоятельно вызывать декларацию функций.</target>
        </trans-unit>
        <trans-unit id="80b55755751b78dc96e2105d875ad62fc884571a" translate="yes" xml:space="preserve">
          <source>b) We are invoking this funtion at the same time using the () at the end of it.</source>
          <target state="translated">б)Мы ссылаемся на эту забаву в то же время,используя ()в конце.</target>
        </trans-unit>
        <trans-unit id="5a0f90b8e1bc3acdf41aed42023e812c2c303c71" translate="yes" xml:space="preserve">
          <source>is called an &lt;strong&gt;immediately invoked function expression&lt;/strong&gt; (IIFE).</source>
          <target state="translated">&lt;strong&gt;вызывается выражением функции, вызываемой немедленно&lt;/strong&gt; (IIFE).</target>
        </trans-unit>
        <trans-unit id="e24ae834b8fdc0300d07f73f952ddbc3aedb8af4" translate="yes" xml:space="preserve">
          <source>produces this output:</source>
          <target state="translated">производит эту продукцию:</target>
        </trans-unit>
        <trans-unit id="537c7047f37c2eecdd1daa181117234bdf353f51" translate="yes" xml:space="preserve">
          <source>so if &lt;code&gt;windows.app&lt;/code&gt; is not defined, then &lt;code&gt;window.app = {}&lt;/code&gt; is immediately executed, so &lt;code&gt;window.app&lt;/code&gt; is assigned with &lt;code&gt;{}&lt;/code&gt; during the condition evaluation, so the result is both &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;window.app&lt;/code&gt; now become &lt;code&gt;{}&lt;/code&gt;, so console output is:</source>
          <target state="translated">поэтому, если &lt;code&gt;windows.app&lt;/code&gt; не определен, то сразу &lt;code&gt;window.app = {}&lt;/code&gt; , поэтому &lt;code&gt;window.app&lt;/code&gt; присваивается &lt;code&gt;{}&lt;/code&gt; во время оценки состояния, поэтому в результате &lt;code&gt;app&lt;/code&gt; и &lt;code&gt;window.app&lt;/code&gt; теперь становятся &lt;code&gt;{}&lt;/code&gt; , поэтому консольный вывод:</target>
        </trans-unit>
        <trans-unit id="feb062cf00888ada37d37ce1300e60f61e961935" translate="yes" xml:space="preserve">
          <source>so if I do:</source>
          <target state="translated">так что если я это сделаю:</target>
        </trans-unit>
        <trans-unit id="172e222242f37744f300767d18cc0b7b1beaa362" translate="yes" xml:space="preserve">
          <source>we are doing two things over here.
a) Wrapping our function expression inside braces (). This goes to tell the syntax parser the whatever placed inside the () is an expression (function expression in this case) and is a valid code.</source>
          <target state="translated">мы делаем две вещи здесь.a)Обертываем наше выражение функции внутри скобок ().Это делается для того,чтобы сказать синтаксическому анализатору,что то,что находится внутри фигурной скобки (),является выражением (в данном случае выражением функции)и является допустимым кодом.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
