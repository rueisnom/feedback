<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/8228281">
    <body>
      <group id="8228281">
        <trans-unit id="9dadaa9496929c84c3ab6989b1c844585b555e1d" translate="yes" xml:space="preserve">
          <source>- During execution (Execution Context - Execute phase), the funtion object is created on the fly (&lt;strong&gt;its not executed yet&lt;/strong&gt;), gets assigned to 'greet' variable and it can be invoked using 'greet('somename')'.</source>
          <target state="translated">-실행 (실행 컨텍스트-실행 단계) 중에 funtion 오브젝트가 즉시 작성되고 ( &lt;strong&gt;아직 실행되지 않음&lt;/strong&gt; ) 'greet'변수에 지정되며 'greet ('somename ')'을 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a158b11158c99a0df72e82df408cf783123c9ff" translate="yes" xml:space="preserve">
          <source>- IIFE, being a function, has its own execution context, meaning all the variables created inside it are local to this function and are not shared with the global execution context.</source>
          <target state="translated">-함수 인 IIFE에는 자체 실행 컨텍스트가 있습니다. 즉, 함수 내에 작성된 모든 변수는이 함수에 로컬이며 전역 실행 컨텍스트와 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad28c57779ed69eaee3b61747f53357c4dd296f6" translate="yes" xml:space="preserve">
          <source>- Notice the '()' immediately after the function declaration. Every funtion object has a 'CODE' property attached to it which is callable. And we can call it (or invoke it) using '()' braces.</source>
          <target state="translated">-함수 선언 직후 '()'에 주목하십시오. 모든 funtion 객체에는 호출 가능한 'CODE'속성이 있습니다. 그리고 '()'중괄호를 사용하여 호출하거나 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b549f1532a5f31afc5bc29127c287e5f5a88a77" translate="yes" xml:space="preserve">
          <source>- So here, during the execution (Execution Context - Execute Phase), &lt;strong&gt;the function object is created and its executed at the same time&lt;/strong&gt;
- So now, the greeting variable, instead of having the funtion object, has its return value ( a string )</source>
          <target state="translated">-여기서, 실행 (Execution Context-Execute Phase) &lt;strong&gt;중에 함수 객체가 생성되고 동시에 실행됩니다&lt;/strong&gt; .-이제 funtion 객체를 사용하는 대신 인사말 변수는 반환 값 (string)을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f2d32b6c54b2eea7b4f08964506c4a14da8bb30d" translate="yes" xml:space="preserve">
          <source>- When JS engine runs for the first time (Execution Context - Create Phase), this function (on the right side of = above) does not get executed or stored in the memory. Variable 'greet' is assigned 'undefined' value by the JS engine.</source>
          <target state="translated">-JS 엔진이 처음 실행될 때 (실행 컨텍스트-작성 단계)이 기능 (오른쪽 = 위)은 메모리에서 실행되거나 저장되지 않습니다. 변수 'greet'에는 JS 엔진에 의해 '정의되지 않은'값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="ef59722e8ed96066e8f649d55ddc705002e2bbbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Immediately Invoked Funtion Expression:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. 즉시 호출 된 Funtion Expression :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c57cca2ae891930962d46154d0cdd7701cf2ca8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;So this function gets created and executed at the same time (IIFE).&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;따라서이 함수는 동시에 생성되고 실행됩니다 (IIFE).&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c3e8c29c460f778fb10c68b7b5f483c3b0d796f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Correction suggested by &lt;a href=&quot;https://stackoverflow.com/users/69083/guffa&quot;&gt;Guffa&lt;/a&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/users/69083/guffa&quot;&gt;Guffa가&lt;/a&gt; 제안한 수정 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e2ed48c31f74161c223bba47f878a789f77b5069" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES6 Alternative (Recommended)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES6 대안 (권장)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47754a1062d962b6ce15d48457bec71b3f369e46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expression&lt;/strong&gt;: Something that returns a value</source>
          <target state="translated">&lt;strong&gt;표현&lt;/strong&gt; : 값을 돌려주는 것</target>
        </trans-unit>
        <trans-unit id="46b1b6e1b44f3520e2793cb8255547db860a73db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Expression&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;함수 표현&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="50eff3e72b9320085e3583c9fee5aae42ebfd0b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How IIFE works&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;IIFE 작동 방식&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="804eeffad7b4e11fec563767c8bf6ee40edfb082" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How function expression works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;함수 표현식 작동 방식 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="315b05a17b0a236580165cfed17571d5661f8e8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;IIFE keeps our code safe.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IIFE는 코드를 안전하게 유지합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e21af655815475d3a776d89c71bee90a334352e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important usecase for IIFE: &lt;br/&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IIFE의 중요한 사용 사례 :&lt;/strong&gt; &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="733ad654e28f5f19e0ccacbd5bd074cd18bf34ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Most Common Use-case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가장 일반적인 사용 사례 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e719c6166298c86686ad285062a762b144fe333" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Typical usecase of IIFE in JS:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JS에서 IIFE의 일반적인 사용 사례 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd4b667e7450fd1da7be97c55c23d9054c910440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;
Since this is a pretty popular topic, it's worth mentioning that IIFE's can also be written with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES6's arrow function&lt;/a&gt; (like &lt;a href=&quot;https://stackoverflow.com/users/368691/gajus&quot;&gt;Gajus&lt;/a&gt; has pointed out &lt;a href=&quot;https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript/8228308#comment43521302_8228308&quot;&gt;in a comment&lt;/a&gt;) :</source>
          <target state="translated">&lt;strong&gt;업데이트&lt;/strong&gt; 이것은 매우 인기있는 주제이므로 IIFE는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES6의 화살표 기능으로&lt;/a&gt; 도 작성할 수 있습니다 ( &lt;a href=&quot;https://stackoverflow.com/users/368691/gajus&quot;&gt;Gajus&lt;/a&gt; 가 &lt;a href=&quot;https://stackoverflow.com/questions/8228281/what-is-the-function-construct-in-javascript/8228308#comment43521302_8228308&quot;&gt;주석에서&lt;/a&gt; 지적한 것처럼).</target>
        </trans-unit>
        <trans-unit id="f4c3381f63f3402e4c893d3819f4639fcfc1cafd" translate="yes" xml:space="preserve">
          <source>A self-invoking expression is invoked (started) automatically, without
  being called.</source>
          <target state="translated">자체 호출 표현식은 호출되지 않고 자동으로 호출 (시작)됩니다.</target>
        </trans-unit>
        <trans-unit id="47c2a38385c0fcf1a4d905bdef7a2aae0eec35d8" translate="yes" xml:space="preserve">
          <source>After we have an expression which evaluates to a function object we then can immediately &lt;strong&gt;invoke&lt;/strong&gt; the function object with the &lt;code&gt;()&lt;/code&gt; operator. For example:</source>
          <target state="translated">함수 객체로 평가되는 표현식이 있으면 즉시 &lt;code&gt;()&lt;/code&gt; 연산자로 함수 객체를 &lt;strong&gt;호출&lt;/strong&gt; 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f06afd34a563714ec314b68da3f205e40cda76f" translate="yes" xml:space="preserve">
          <source>Alternatively, it can be:</source>
          <target state="translated">또는 다음이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef9203bbedd9adb33629bea17c2eb428a0a6054a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IIFE&lt;/code&gt; can also be described as a self-invoking anonymous function. Its most common usage is to limit the scope of a variable made via var or to encapsulate context to avoid name collisions.</source>
          <target state="translated">&lt;code&gt;IIFE&lt;/code&gt; 는 자체 호출 익명 기능으로 설명 될 수도 있습니다. 가장 일반적인 사용법은 var를 통해 만들어진 변수의 범위를 제한하거나 이름 충돌을 피하기 위해 컨텍스트를 캡슐화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6054fe82da32385b7ed0dbfbae9f67f812a1d185" translate="yes" xml:space="preserve">
          <source>An expression is simply a bunch of code which can be evaluated to &lt;strong&gt;a single value&lt;/strong&gt;. In case of the expressions in the above example this value was a &lt;strong&gt;single function object&lt;/strong&gt;.</source>
          <target state="translated">식은 단순히 &lt;strong&gt;단일 값&lt;/strong&gt; 으로 평가 될 수있는 코드 묶음입니다. 위 예제의 표현식의 경우이 값은 &lt;strong&gt;단일 함수 객체&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b232444188015e33e960e2241dffbfda478d3cb" translate="yes" xml:space="preserve">
          <source>An immediately invoked function expression (IIFE) is a function that's executed as soon as it's created. It has no connection with any events or asynchronous execution. You can define an IIFE as shown below:</source>
          <target state="translated">IIFE (즉시 호출 된 함수 표현식)는 작성 되 자마자 실행되는 함수입니다. 이벤트 또는 비동기 실행과 연결되어 있지 않습니다. 아래와 같이 IIFE를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cd1fb5aec37c798839c8d1d191684f280e2a7bc" translate="yes" xml:space="preserve">
          <source>An immediately-invoked function expression (IIFE) immediately calls a function. This simply means that the function is executed immediately after the completion of the definition.</source>
          <target state="translated">IIFE (즉시 호출 된 함수 표현식)는 즉시 함수를 호출합니다. 이는 정의가 완료된 직후 함수가 실행됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e23b647b429bf20b9259177559b651dd7775b8c6" translate="yes" xml:space="preserve">
          <source>And the explanation of the syntax is: The function within the first &lt;code&gt;()&lt;/code&gt; parenthesis is the function which has no name and by the next &lt;code&gt;();&lt;/code&gt; parenthesis you can understand that it is called at the time it is defined. And you can pass any argument in this second &lt;code&gt;()&lt;/code&gt; parenthesis which will be grabbed in the function which is in the first parenthesis. See this example:</source>
          <target state="translated">구문에 대한 설명은 다음과 같습니다. 첫 번째 &lt;code&gt;()&lt;/code&gt; 괄호 안의 함수는 이름이없고 다음 &lt;code&gt;();&lt;/code&gt; 의 함수입니다 . 괄호 정의시 정의되어 있음을 이해할 수 있습니다. 그리고 첫 번째 괄호 안에있는 함수에서이 두 번째 괄호 안에 인수를 전달할 수 있습니다. 이 예제를보십시오 :</target>
        </trans-unit>
        <trans-unit id="2a08b6d6216c318f07a63ce64ce5e83f1c1d8bf5" translate="yes" xml:space="preserve">
          <source>But the above two construct are not &lt;strong&gt;IIFE&lt;/strong&gt;.</source>
          <target state="translated">그러나 위의 두 구성은 &lt;strong&gt;IIFE&lt;/strong&gt; 가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0ee3f501ca67bbeb5c059c6705b2167b219acadc" translate="yes" xml:space="preserve">
          <source>By using this syntax you avoid colliding with global variables declared elsewhere in your JavaScript code.</source>
          <target state="translated">이 구문을 사용하면 JavaScript 코드의 다른 곳에서 선언 된 전역 변수와 충돌하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="fe1b40c8fab9f166a675bd98799bd55d26f8fea3" translate="yes" xml:space="preserve">
          <source>Call the function immediately -- oops:</source>
          <target state="translated">함수를 즉시 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="bed0e00f9fc23279ca684a1d493bc0948fd61a7d" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;http://www.w3schools.com/js/js_function_definition.asp&quot;&gt;W3Schools explanation of a self-invoking function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3schools.com/js/js_function_definition.asp&quot;&gt;자체 호출 기능에 대한 W3Schools 설명을&lt;/a&gt; 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="555c6fb5b44d531f9e53fcbc10a3a35e96167dd6" translate="yes" xml:space="preserve">
          <source>Consider the function below written in a file named iife.js</source>
          <target state="translated">iife.js라는 파일로 작성된 아래 함수를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="dfb3b4ee9c5d621bdda0a0d76975d4708fc3ac9d" translate="yes" xml:space="preserve">
          <source>Consider the part within the first pair of parentheses: &lt;code&gt;(&lt;b&gt;function(){}&lt;/b&gt;)();&lt;/code&gt;....it is a regular function expression. Then look at the last pair &lt;code&gt;(function(){})&lt;b&gt;()&lt;/b&gt;;&lt;/code&gt;, this is normally added to an expression to call a function; in this case, our prior expression.</source>
          <target state="translated">첫 번째 괄호 쌍 내의 부분을 고려하십시오. &lt;code&gt;(&lt;b&gt;function(){}&lt;/b&gt;)();&lt;/code&gt; .... 정규 함수 표현입니다. 그런 다음 마지막 쌍을보십시오 &lt;code&gt;(function(){})&lt;b&gt;()&lt;/b&gt;;&lt;/code&gt; , 이것은 일반적으로 함수를 호출하기 위해 표현식에 추가됩니다. 이 경우, 우리의 이전 표현.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="7ac36349dda560270779b789cbf43d471f646ee7" translate="yes" xml:space="preserve">
          <source>Example: Try out following in chrome console. These are expressions in JS.</source>
          <target state="translated">예 : 크롬 콘솔에서 다음을 시도하십시오. 이것들은 JS의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="a16fbf4816018018ce84d149cfed2d3768185a11" translate="yes" xml:space="preserve">
          <source>Fiddle: &lt;a href=&quot;http://jsfiddle.net/maniator/LqvpQ/&quot;&gt;http://jsfiddle.net/maniator/LqvpQ/&lt;/a&gt;</source>
          <target state="translated">피들 : &lt;a href=&quot;http://jsfiddle.net/maniator/LqvpQ/&quot;&gt;http://jsfiddle.net/maniator/LqvpQ/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3adf70295ac336ffda7f66d5b40c9b5b7da8682d" translate="yes" xml:space="preserve">
          <source>For a Detailed explanation see &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Immediately-Invoked Function Expression (IIFE)&lt;/a&gt;</source>
          <target state="translated">자세한 설명은 &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;즉시 호출 된 함수 식 (IIFE)을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4c6fccf633b8091e55000dd559026cd3b58ab04e" translate="yes" xml:space="preserve">
          <source>Function expressions can be made &quot;self-invoking&quot;.</source>
          <target state="translated">함수 표현은 &quot;자기 호출&quot;이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26db9da6beae79b61580102af1a1cae9c9752e6a" translate="yes" xml:space="preserve">
          <source>Function expressions will execute automatically if the expression is
  followed by ().</source>
          <target state="translated">표현식 뒤에 ()가 있으면 함수 표현식이 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="93cc4de26d2f9c0383f0e9df26c846aef1578f8e" translate="yes" xml:space="preserve">
          <source>Here the 'object' you are passing will be accessible within the function by 'obj', as you are grabbing it in the function signature.</source>
          <target state="translated">여기서 전달하는 '객체'는 함수 시그니처에서 잡아서 'obj'로 함수 내에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="310dbc9ededfe37d2f49c2fae2cfedca9bb3170d" translate="yes" xml:space="preserve">
          <source>I call it a &lt;code&gt;Curly Jail&lt;/code&gt;.</source>
          <target state="translated">나는 그것을 &lt;code&gt;Curly Jail&lt;/code&gt; 이라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="bc657204917761bd8680e03ced88ddf4b0d2f99e" translate="yes" xml:space="preserve">
          <source>I think the 2 sets of brackets makes it a bit confusing but I saw another usage in googles example, they used something similar, I hope this will help you understand better:</source>
          <target state="translated">나는 2 세트의 대괄호가 약간 혼란 스럽지만 Google 예제에서 다른 사용법을 보았습니다. 비슷한 것을 사용했습니다. 이것이 더 잘 이해하는 데 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="da90c222860bf1dca29f728207fcaa3217f05ea7" translate="yes" xml:space="preserve">
          <source>I used to know what this meant, but I'm struggling now...</source>
          <target state="translated">나는 이것이 무엇을 의미하는지 알고 있었지만 지금은 어려움을 겪고 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="1adaf50c667f60887370ba409da371b6afb75b21" translate="yes" xml:space="preserve">
          <source>IIFE (Immediately invoked function expression) is a function which executes as soon as the script loads and goes away.</source>
          <target state="translated">IIFE (즉시 호출 된 함수 표현식)는 스크립트가로드되고 사라지는 즉시 실행되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2dbc909f43d9178cbccc47855c456cf4752621ef" translate="yes" xml:space="preserve">
          <source>If there are no special requirements for its return value, then we can write:</source>
          <target state="translated">반환 값에 대한 특별한 요구 사항이 없으면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bf309c08d49299b6010eb01372d2db6695104c5" translate="yes" xml:space="preserve">
          <source>In ES6 syntax (posting for myself, as I keep landing on this page looking for a quick example):</source>
          <target state="translated">ES6 구문에서 (이 페이지에 계속 방문하면서 빠른 예를 찾기 위해 직접 게시) :</target>
        </trans-unit>
        <trans-unit id="b5f54c58ea6a05bfe712cb33b673358aba022076" translate="yes" xml:space="preserve">
          <source>In ES6, we now can have variables created via &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Both of them are block-scoped (unlike &lt;code&gt;var&lt;/code&gt; which is a function-scoped).</source>
          <target state="translated">ES6에서는 &lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 를 통해 변수를 만들 수 있습니다. 둘 다 블록 범위입니다 (함수 범위 인 &lt;code&gt;var&lt;/code&gt; 와 달리).</target>
        </trans-unit>
        <trans-unit id="16f5da42d75b65b9cb3a9aa47149d04a1c65df9a" translate="yes" xml:space="preserve">
          <source>In following example, count will not be available outside the immediately invoked function i.e. Scope of &lt;code&gt;count&lt;/code&gt; will not leak out of the function. You should get a &lt;code&gt;Reference Error&lt;/code&gt;, should you try to access it outside of the immediately invoked function anyway.</source>
          <target state="translated">다음 예에서, 즉시 호출 된 함수 외부에서 카운트를 사용할 수 없습니다. 즉 &lt;code&gt;count&lt;/code&gt; 범위가 함수에서 누출되지 않습니다. 어쨌든 즉시 호출 된 함수 외부에서 액세스하려고하면 &lt;code&gt;Reference Error&lt;/code&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed59eaac2704626c5d7967c3ef0bd1a82cf33639" translate="yes" xml:space="preserve">
          <source>In jQuery there is a similar construct that you might be thinking of:</source>
          <target state="translated">jQuery에는 비슷한 구조가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3285fe005e794f8056d470509f3d977dcccbf1a1" translate="yes" xml:space="preserve">
          <source>In other words, they are like programs that &quot;make classes', at the beginning of program. After they are instantiated (automatically), the only functions that are available are the ones returned in by the anonymous function. However, all the other 'hidden' functions are still there, along with any state (variables set during scope creation).</source>
          <target state="translated">즉, 프로그램 시작시 &quot;클래스를 만드는&quot;프로그램과 같습니다. 인스턴스화 (자동으로) 된 후 사용할 수있는 유일한 기능은 익명 함수에 의해 반환되는 기능뿐입니다. 숨겨진 상태의 함수는 모든 상태 (범위 작성 중에 설정된 변수)와 함께 여전히 있습니다.</target>
        </trans-unit>
        <trans-unit id="2246f55eec4876f796cbcd0d31de04ec8a5653b5" translate="yes" xml:space="preserve">
          <source>In the code snippet above, &amp;ldquo;&lt;em&gt;var app&lt;/em&gt;&amp;rdquo; is a local variable now.</source>
          <target state="translated">위의 코드 스 니펫에서 &quot; &lt;em&gt;var app&lt;/em&gt; &quot;은 이제 지역 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c65f76b1db4bba18bb99168719c858dda4d4fb91" translate="yes" xml:space="preserve">
          <source>In this example, we used &lt;code&gt;let&lt;/code&gt; to define a &lt;code&gt;count&lt;/code&gt; variable which makes &lt;code&gt;count&lt;/code&gt; limited to the block of code, we created with the curly brackets &lt;code&gt;{...}&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 &lt;code&gt;count&lt;/code&gt; 를 코드 블록으로 제한하는 &lt;code&gt;count&lt;/code&gt; 변수를 정의하고 중괄호 &lt;code&gt;{...}&lt;/code&gt; 로 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="17e4ba3bf69d8e68d6b4400bea5fc5f6ee728362" translate="yes" xml:space="preserve">
          <source>Is this basically saying &lt;code&gt;document.onload&lt;/code&gt;?</source>
          <target state="translated">이것이 기본적으로 &lt;code&gt;document.onload&lt;/code&gt; 입니까?</target>
        </trans-unit>
        <trans-unit id="fd185ef785c5b04bd70812f4d46089d0eb0fa051" translate="yes" xml:space="preserve">
          <source>It declares an anonymous function, then calls it:</source>
          <target state="translated">익명 함수를 선언 한 다음 호출합니다.</target>
        </trans-unit>
        <trans-unit id="82e817152a0385d95b61dff4c870bac1a4884074" translate="yes" xml:space="preserve">
          <source>It doesn't need to be any more complicated than that.</source>
          <target state="translated">그보다 더 복잡 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d46472342d72627637ee258e3d6fdccc6199cf72" translate="yes" xml:space="preserve">
          <source>It has nothing to do with any event-handler for any events (such as &lt;code&gt;document.onload&lt;/code&gt;).</source>
          <target state="translated">모든 이벤트 (예 : &lt;code&gt;document.onload&lt;/code&gt; )에 대한 이벤트 핸들러와 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c65f9349f5c5e98740e05bb18a002d20447896d" translate="yes" xml:space="preserve">
          <source>It is called IIFE - Immediately Invoked Function Expression. Here is an example to show it's syntax and usage. It is used to scope the use of variables only till the function and not beyond.</source>
          <target state="translated">이를 IIFE-즉시 호출 된 함수식이라고합니다. 다음은 구문과 사용법을 보여주는 예입니다. 변수를 사용하지 않고 기능까지만 사용하도록 범위를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b232da97c45835910b21510560d717bf4925972" translate="yes" xml:space="preserve">
          <source>It is called a function expression because the &lt;code&gt;( yourcode )&lt;/code&gt; operator in Javascript force it into an expression. The difference between a &lt;strong&gt;function expression&lt;/strong&gt; and a &lt;strong&gt;function declaration&lt;/strong&gt; is the following:</source>
          <target state="translated">Javascript의 &lt;code&gt;( yourcode )&lt;/code&gt; 연산자가이를 표현식으로 강제 실행하므로 함수 표현식이라고합니다. &lt;strong&gt;함수 표현식&lt;/strong&gt; 과 &lt;strong&gt;함수 선언&lt;/strong&gt; 의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1cc8fef367a1d081643d3e45d670fa0885cf488" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an &lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;Immediately-Invoked Function Expression&lt;/a&gt;, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;&lt;strong&gt;IIFE&lt;/strong&gt;&lt;/a&gt; for short. It executes immediately after it&amp;rsquo;s created.</source>
          <target state="translated">&lt;a href=&quot;http://benalman.com/news/2010/11/immediately-invoked-function-expression/&quot;&gt;즉석에서 호출되는&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Immediately-invoked_function_expression&quot;&gt;&lt;strong&gt;함수식&lt;/strong&gt;&lt;/a&gt; 또는 &lt;strong&gt;IIFE&lt;/strong&gt; 입니다. 생성 된 직후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5b9bc8fdc31871ad312f7674abc5335932340a6a" translate="yes" xml:space="preserve">
          <source>It's just an anonymous function that is executed right after it's created.</source>
          <target state="translated">그것은 생성 된 직후에 실행되는 익명 함수입니다.</target>
        </trans-unit>
        <trans-unit id="6a701e3ab7c285721f76ef5ce5480d80f7f9c81f" translate="yes" xml:space="preserve">
          <source>It's just as if you assigned it to a variable, and used it right after, only without the variable:</source>
          <target state="translated">마치 변수에 변수를 할당하고 변수없이 만 바로 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb9f7eca5141640b0ea0732a3094579501b0966b" translate="yes" xml:space="preserve">
          <source>JavaScript prior to ECMAScript 6 used lexical scoping, so IIFE was used for simulating block scoping. (With ECMAScript 6 block scoping is possible with the introduction of the &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords.)
&lt;a href=&quot;https://gist.github.com/gurucharanmk/5071d37bb5af61a93562fbe024a975de&quot;&gt;Reference for issue with lexical scoping&lt;/a&gt;</source>
          <target state="translated">ECMAScript 6 이전의 JavaScript는 어휘 범위를 사용 했으므로 IIFE는 블록 범위를 시뮬레이션하는 데 사용되었습니다. &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 키워드를 도입하면 ECMAScript 6 블록 범위를 지정할 수 있습니다. &lt;a href=&quot;https://gist.github.com/gurucharanmk/5071d37bb5af61a93562fbe024a975de&quot;&gt;어휘 범위 문제에 대한 참조&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e19d95ce34c23849a24e90884cd6e222319e0a3d" translate="yes" xml:space="preserve">
          <source>No, this construct just creates a scope for naming. If you break it in parts you can see that you have an external</source>
          <target state="translated">아니요,이 구조는 단지 명명의 범위를 만듭니다. 부품이 파손되면 외부가 있음을 알 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9ec030aac7f160c37131b600f5a5340267908578" translate="yes" xml:space="preserve">
          <source>Normally, JavaScript code has global scope in the application. When we declare global variable in it, there is a chance for using the same duplicate variable  in some other area of the development for some other purpose. Because of this duplication there may happen some error. So we can avoid this global variables by using immediately invoking function expression , this expression is self-executing expression.When we make our code inside this &lt;strong&gt;IIFE&lt;/strong&gt; expression global variable will be like local scope and local variable.</source>
          <target state="translated">일반적으로 JavaScript 코드는 응용 프로그램에서 전체 범위를 갖습니다. 전역 변수를 선언하면 개발의 다른 영역에서 다른 목적으로 동일한 복제 변수를 사용할 가능성이 있습니다. 이 중복으로 인해 약간의 오류가 발생할 수 있습니다. 따라서 우리는 즉시 function expression을 호출 하여이 전역 변수를 피할 수 있습니다.이 표현식은 자체 실행 표현식입니다.이 &lt;strong&gt;IIFE&lt;/strong&gt; 표현식 안에 코드를 만들면 전역 변수는 로컬 범위 및 로컬 변수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="f38bd5ec2c8a5dc7ab5e02966ee53d71fa6c0fb1" translate="yes" xml:space="preserve">
          <source>One more use case is memoization where a cache object is not global:</source>
          <target state="translated">또 하나의 유스 케이스는 캐시 오브젝트가 전역이 아닌 메모리 화입니다.</target>
        </trans-unit>
        <trans-unit id="c5723cd187bdd3a60686abb0d8678a7f72126e0f" translate="yes" xml:space="preserve">
          <source>One of its most common use case is to limit the scope of a variable made via &lt;code&gt;var&lt;/code&gt;. Variables created via &lt;code&gt;var&lt;/code&gt; have a scope limited to a function so this construct (which is a function wrapper around certain code) will make sure that your variable scope doesn't leak out of that function.</source>
          <target state="translated">가장 일반적인 사용 사례 중 하나는 &lt;code&gt;var&lt;/code&gt; 를 통해 만들어진 변수의 범위를 제한하는 것입니다. &lt;code&gt;var&lt;/code&gt; 를 통해 생성 된 변수는 범위가 함수로 제한 되므로이 구문 (특정 코드 주위의 함수 래퍼)은 변수 범위가 해당 함수에서 누출되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="649fbe17413aa58c3db75fce30b2af7a47324cda" translate="yes" xml:space="preserve">
          <source>One short and dummy example where this is useful is:</source>
          <target state="translated">이것이 유용한 하나의 짧고 더미 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f973b4d9d4883553f635f032543ac59fc9d3b69" translate="yes" xml:space="preserve">
          <source>Put it in a function and it is &lt;em&gt;no longer global&lt;/em&gt; -- your primary goal.</source>
          <target state="translated">그것을 기능에 넣으면 &lt;em&gt;더 이상 전 세계&lt;/em&gt; 가 &lt;em&gt;아닙니다&lt;/em&gt; -기본 목표.</target>
        </trans-unit>
        <trans-unit id="0d8b8fae40a82cc964b67a458b02dc9260b9c93e" translate="yes" xml:space="preserve">
          <source>Second Example:</source>
          <target state="translated">두 번째 예 :</target>
        </trans-unit>
        <trans-unit id="625b147902424ef9a991e2305153920d948e7261" translate="yes" xml:space="preserve">
          <source>Self-executing anonymous function. It's executed as soon as it is created.</source>
          <target state="translated">자체 실행 익명 기능. 생성 되 자마자 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="70bd652cdc2b1167028d4ac8199834817346bc4e" translate="yes" xml:space="preserve">
          <source>Self-executing functions are typically used to encapsulate context and avoid name collusions. Any variable that you define inside the (function(){..})() are not global.</source>
          <target state="translated">자체 실행 기능은 일반적으로 컨텍스트를 캡슐화하고 이름 충돌을 피하는 데 사용됩니다. (function () {..}) () 안에서 정의한 변수는 전역 변수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="29c3122b24cc9e30c85129f7fd8c2d244d9dfdd2" translate="yes" xml:space="preserve">
          <source>Simulate block scoping with IIFE</source>
          <target state="translated">IIFE로 블록 범위 시뮬레이션</target>
        </trans-unit>
        <trans-unit id="7a54357ff5057e04bccd7aaac33c16801b6fda73" translate="yes" xml:space="preserve">
          <source>So IIFE helps us to &lt;strong&gt;write safe code where we are not colliding with the global objects unintentionally.&lt;/strong&gt;</source>
          <target state="translated">따라서 IIFE를 사용하면 &lt;strong&gt;실수로 전역 객체와 충돌하지 않는 안전한 코드&lt;/strong&gt; 를 &lt;strong&gt;작성할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6335b000f7e2f11bed39166ec0a6f5ed56142e5" translate="yes" xml:space="preserve">
          <source>So instead of creating a list each time, you create it only once (less overhead).</source>
          <target state="translated">따라서 매번 목록을 작성하는 대신 한 번만 작성하십시오 (오버 헤드가 적음).</target>
        </trans-unit>
        <trans-unit id="9a744001432e37728d3828edbc68f295cc3a7f66" translate="yes" xml:space="preserve">
          <source>Start here:</source>
          <target state="translated">여기에서 시작하십시오 :</target>
        </trans-unit>
        <trans-unit id="10358ef11702b06b5cb27eb8e15a2ecaf6c95eef" translate="yes" xml:space="preserve">
          <source>Suppose I've another JS file (test1.js) used in my applicaiton along with iife.js (see below).</source>
          <target state="translated">iife.js와 함께 내 응용 프로그램에 사용 된 다른 JS 파일 (test1.js)이 있다고 가정합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="5805911a132b44cbaa119ab669c316445b6aad4c" translate="yes" xml:space="preserve">
          <source>That construct is called &lt;strong&gt;Immediately Invoked Function Expression (IIFE)&lt;/strong&gt; which means it gets executed immediately. Think of it as a function getting called automatically when the interpreter reaches that function.</source>
          <target state="translated">이 구문을 &lt;strong&gt;IIFE (즉시 호출 함수 식&lt;/strong&gt; )라고하며 &lt;strong&gt;즉시&lt;/strong&gt; 실행됩니다. 인터프리터가 해당 함수에 도달하면 자동으로 호출되는 함수로 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="a18c6eaa532f587838670adc0ddd14b1e92311b6" translate="yes" xml:space="preserve">
          <source>That is a &lt;strong&gt;self-invoking anonymous function&lt;/strong&gt;.</source>
          <target state="translated">그것은 &lt;strong&gt;자체 호출 익명 함수&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="94f48842d979fe68c1a11afee92b8fe237e29013" translate="yes" xml:space="preserve">
          <source>That is a function invocation. Inside the parenthesis you have:</source>
          <target state="translated">이것이 함수 호출입니다. 괄호 안에는 다음이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dc326bd0d30e0a8db56ac629c606c11b2a1c545" translate="yes" xml:space="preserve">
          <source>That is an anonymous function. Everything that is declared with &lt;strong&gt;var&lt;/strong&gt; inside the construct will be visible only inside the same construct and will not pollute the global namespace.</source>
          <target state="translated">그것은 익명의 기능입니다. 구문 내에서 &lt;strong&gt;var&lt;/strong&gt; 로 선언 된 모든 것은 동일한 구문 내에서만 볼 수 있으며 전역 네임 스페이스를 오염시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8380108f1e1cb790902e70f48d87cc68895f11ac" translate="yes" xml:space="preserve">
          <source>That is saying execute immediately.</source>
          <target state="translated">즉, 즉시 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0cfe61a50bbbb22ef9c2d6a0589f1ebe1efc25e6" translate="yes" xml:space="preserve">
          <source>That is the short form of binding the &lt;code&gt;ready&lt;/code&gt; event:</source>
          <target state="translated">이것이 &lt;code&gt;ready&lt;/code&gt; 이벤트를 바인딩하는 짧은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="32e3ee7a8f238c3dc42124d9afe27b0f78dc70db" translate="yes" xml:space="preserve">
          <source>The code</source>
          <target state="translated">코드</target>
        </trans-unit>
        <trans-unit id="620d6ef1f9bea2f810b9b61a7131bfe9d5e2804f" translate="yes" xml:space="preserve">
          <source>The first pair of parentheses function(){...} converts the code inside the parentheses into an expression.The second pair of parentheses calls the function resulting from the expression.</source>
          <target state="translated">첫 번째 괄호 쌍 function () {...}은 괄호 안의 코드를 표현식으로 변환합니다. 두 번째 괄호 쌍은 표현식의 결과 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ea2dbcd87ff712d37a5e7773d759f85a11564ba0" translate="yes" xml:space="preserve">
          <source>The following IIFE pattern is quite commonly used.</source>
          <target state="translated">다음 IIFE 패턴이 매우 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d491fd2b65326bcc2d9548ada2c065f112cca208" translate="yes" xml:space="preserve">
          <source>The following code:</source>
          <target state="translated">다음 코드 :</target>
        </trans-unit>
        <trans-unit id="e7bbda963d845e557f51712e433c51a15b6fe29c" translate="yes" xml:space="preserve">
          <source>The function is executed right after it's created, not after it is parsed. The entire script block is parsed before any code in it is executed. Also, parsing code doesn't automatically mean that it's executed, if for example the IIFE is inside a function then it won't be executed until the function is called.</source>
          <target state="translated">함수는 구문 분석 된 후가 아니라 작성된 직후에 실행됩니다. 코드가 실행되기 전에 전체 스크립트 블록이 구문 분석됩니다. 또한 구문 분석 코드는 자동으로 실행되는 것을 의미하지는 않습니다. 예를 들어 IIFE가 함수 안에 있으면 함수가 호출 될 때까지 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ca3ff5213c318e3b9ec03433344ff34245ae349" translate="yes" xml:space="preserve">
          <source>The performance benefit of using IIFE&amp;rsquo;s is the ability to pass commonly used global objects like &lt;code&gt;window&lt;/code&gt;, &lt;code&gt;document&lt;/code&gt;, etc. as an argument by reducing the scope lookup. (Remember JavaScript looks for properties in local scope and way up the chain until global scope). So accessing global objects in local scope reduces the lookup time like below.</source>
          <target state="translated">IIFE를 사용함으로써 얻을 수있는 성능상의 이점은 스코프 조회를 줄여서 &lt;code&gt;window&lt;/code&gt; , &lt;code&gt;document&lt;/code&gt; 등과 같은 일반적으로 사용되는 전역 객체를 인수로 전달할 수 있다는 것입니다. JavaScript는 로컬 범위에서 속성을 찾고 전역 범위까지 체인을 확장합니다. 따라서 로컬 범위에서 전역 객체에 액세스하면 아래와 같이 조회 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="288fa7b05c269acc1a5c03c13d3ac79fce530f66" translate="yes" xml:space="preserve">
          <source>The reason self-evoking anonymous functions are used is they should never be called by other code since they &quot;set up&quot; the code which IS meant to be called (along with giving scope to functions and variables).</source>
          <target state="translated">자체 호출 익명 함수가 사용되는 이유는 호출하려는 IS 코드 (함수 및 변수에 범위를 부여 함)를 &quot;설정&quot;하기 때문에 다른 코드에서 호출해서는 안되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="24e31faeedc1c433bb3b9e8c9d599d3d544b30be" translate="yes" xml:space="preserve">
          <source>Therefore, instead of using that complex construct of IIFE for the use case I mentioned above, you can now write much, much simpler code to make sure that a variable's scope does not leak out of your desired block.</source>
          <target state="translated">따라서 위에서 언급 한 유스 케이스에 IIFE의 복잡한 구성을 사용하는 대신 변수 범위가 원하는 블록에서 누출되지 않도록 훨씬 더 간단한 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f757a6a5f520f7c84d83fdf2c6f0a73f17baf005" translate="yes" xml:space="preserve">
          <source>This code above will execute as soon as you load iife.js and will print '&lt;em&gt;Hello Stackoverflow!&lt;/em&gt;' on the developer tools' console.</source>
          <target state="translated">위의 코드는 iife.js를로드하자마자 실행되며 ' &lt;em&gt;Hello Stackoverflow!&lt;/em&gt; '는 개발자 도구'콘솔에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b7900604a551b4491f3627f5f85daa451838595" translate="yes" xml:space="preserve">
          <source>This is an Immediately Invoked Function Expression in Javascript:</source>
          <target state="translated">이것은 자바 스크립트에서 즉시 호출되는 함수 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="60fca009bce50f0f52bdaae51ab0767f17cf922c" translate="yes" xml:space="preserve">
          <source>This is called IIFE (Immediately Invoked Function Expression). One of the famous JavaScript design patterns, it is the heart and soul of the modern day Module pattern. As the name suggests it executes immediately after it is created. This pattern creates an isolated or private scope of execution.</source>
          <target state="translated">이를 IIFE (즉시 호출 함수 표현식)라고합니다. 유명한 JavaScript 디자인 패턴 중 하나는 현대 모듈 패턴의 핵심입니다. 이름에서 알 수 있듯이 이름은 생성 된 직후에 실행됩니다. 이 패턴은 격리 또는 개인 실행 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="05397156e7479340c0e62d149e3f317e55817dd5" translate="yes" xml:space="preserve">
          <source>This is the self-invoking anonymous function. It is executed while it is defined. Which means this function is defined and invokes itself immediate after the definition.</source>
          <target state="translated">이것은 자체 호출 익명 기능입니다. 정의되는 동안 실행됩니다. 이는이 함수가 정의되고 정의 직후에 자신을 호출 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="aa5eeda16874ed79c3a0bf338d464e2c9e434f2d" translate="yes" xml:space="preserve">
          <source>This is why, maybe, you confused this construction with an event-handler for &lt;code&gt;window.onload&lt;/code&gt;, because it&amp;rsquo;s often used as this:</source>
          <target state="translated">이것이 아마도이 구성을 &lt;code&gt;window.onload&lt;/code&gt; 의 이벤트 핸들러와 혼동하는 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a43a0884e808455e619c5e39b5f6305cd32b762b" translate="yes" xml:space="preserve">
          <source>This pattern is often used when trying to avoid polluting the global namespace, because all the variables used inside the IIFE (like in any other &lt;em&gt;normal&lt;/em&gt; function) are not visible outside its scope.</source>
          <target state="translated">IIFE 내부에 사용 된 모든 변수 (다른 &lt;em&gt;일반&lt;/em&gt; 함수에서와 같이)가 해당 범위 외부에 표시되지 않기 때문에이 패턴은 전역 네임 스페이스의 오염을 피하려고 할 때 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e5250168d0e420ea15ffcae2855451c4b761867b" translate="yes" xml:space="preserve">
          <source>Three more common wordings:</source>
          <target state="translated">세 가지 더 일반적인 표현 :</target>
        </trans-unit>
        <trans-unit id="119c79105d25740edafd02ae5b6f7eec36e65e3a" translate="yes" xml:space="preserve">
          <source>To understand IIFE in JS, lets break it down:</source>
          <target state="translated">JS의 IIFE를 이해하려면 다음과 같이 분류하십시오.</target>
        </trans-unit>
        <trans-unit id="d6b77b85dccd745a3fe0ec9e1915b8ec0a8ad02c" translate="yes" xml:space="preserve">
          <source>Two ways we can create &lt;strong&gt;IIFE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;IIFE&lt;/strong&gt; 를 만들 수있는 두 가지 방법</target>
        </trans-unit>
        <trans-unit id="7fcbaaaf9b6840e78103bf684f0bdd12dcbede43" translate="yes" xml:space="preserve">
          <source>Use the parentheses to avoid a syntax error:</source>
          <target state="translated">구문 오류를 피하려면 괄호를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9b1aacb25d4d7569574ad43074d0946d45db2a84" translate="yes" xml:space="preserve">
          <source>Usually, we don't invoke a function immediately after we write it in the program. 
In extremely simple terms, when you call a function right after its creation, it is called IIFE - a fancy name.</source>
          <target state="translated">일반적으로 프로그램에서 작성한 직후에는 함수를 호출하지 않습니다. 아주 간단한 용어로, 함수를 생성 한 직후에 호출 할 때 IIFE라고합니다.</target>
        </trans-unit>
        <trans-unit id="14a0e82e7bb0518d267319e1cbab5b31ff6842ec" translate="yes" xml:space="preserve">
          <source>Very cool.</source>
          <target state="translated">매우 시원합니다.</target>
        </trans-unit>
        <trans-unit id="8ac9ae8ffa3d3c2849f98072d24c38d7af8d342b" translate="yes" xml:space="preserve">
          <source>What is the (function() { } )() construct in JavaScript</source>
          <target state="translated">JavaScript에서 (function () {}) () 구문은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="231d04fc5024ad157d8b00b3dbb591e327427435" translate="yes" xml:space="preserve">
          <source>When we are dealing with a large code base and/or when we are importing various libraries the chance of naming conflicts increases. When we are writing certain parts of our code which is related (and thus is using the same variables) inside an IIFE all of the &lt;strong&gt;variables and function names are scoped to the function brackets of the IIFE&lt;/strong&gt;. This reduces chances of naming conflicts and lets you name them more careless (e.g. you don't have to prefix them).</source>
          <target state="translated">큰 코드 기반을 다루거나 다양한 라이브러리를 가져올 때 이름 충돌의 가능성이 높아집니다. IIFE 내부에 관련된 (따라서 동일한 변수를 사용하는) 코드의 특정 부분을 작성할 때 모든 &lt;strong&gt;변수와 함수 이름은 IIFE의 함수 괄호로 범위가 지정됩니다&lt;/strong&gt; . 이렇게하면 이름 충돌의 가능성이 줄어들고보다 부주의하게 이름을 지정할 수 있습니다 (예 : 접두사를 붙일 필요가 없습니다).</target>
        </trans-unit>
        <trans-unit id="d6ee7a9da24cd817643c34a656eca9b71e280cb0" translate="yes" xml:space="preserve">
          <source>Why is this useful?</source>
          <target state="translated">이것이 왜 유용한가요?</target>
        </trans-unit>
        <trans-unit id="c55517152e7cc3243eca3932069c2820ebe391fe" translate="yes" xml:space="preserve">
          <source>You can even write:</source>
          <target state="translated">당신은 쓸 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9896d74e8f60c2be315cd9b2c7f1cb80c597ad0c" translate="yes" xml:space="preserve">
          <source>You can leave off the function name:</source>
          <target state="translated">기능 이름을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0470cb63114ace850d7c50d5c5d0512a46149f43" translate="yes" xml:space="preserve">
          <source>You cannot self-invoke a function declaration.</source>
          <target state="translated">함수 선언을 자체 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="80b55755751b78dc96e2105d875ad62fc884571a" translate="yes" xml:space="preserve">
          <source>b) We are invoking this funtion at the same time using the () at the end of it.</source>
          <target state="translated">b) 우리는 마지막에 ()를 사용 하여이 기능을 동시에 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5a0f90b8e1bc3acdf41aed42023e812c2c303c71" translate="yes" xml:space="preserve">
          <source>is called an &lt;strong&gt;immediately invoked function expression&lt;/strong&gt; (IIFE).</source>
          <target state="translated">&lt;strong&gt;즉시 호출 함수 식&lt;/strong&gt; (IIFE)이라고합니다.</target>
        </trans-unit>
        <trans-unit id="e24ae834b8fdc0300d07f73f952ddbc3aedb8af4" translate="yes" xml:space="preserve">
          <source>produces this output:</source>
          <target state="translated">이 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="537c7047f37c2eecdd1daa181117234bdf353f51" translate="yes" xml:space="preserve">
          <source>so if &lt;code&gt;windows.app&lt;/code&gt; is not defined, then &lt;code&gt;window.app = {}&lt;/code&gt; is immediately executed, so &lt;code&gt;window.app&lt;/code&gt; is assigned with &lt;code&gt;{}&lt;/code&gt; during the condition evaluation, so the result is both &lt;code&gt;app&lt;/code&gt; and &lt;code&gt;window.app&lt;/code&gt; now become &lt;code&gt;{}&lt;/code&gt;, so console output is:</source>
          <target state="translated">따라서 &lt;code&gt;windows.app&lt;/code&gt; 가 정의되지 않은 경우 &lt;code&gt;window.app = {}&lt;/code&gt; 이 즉시 실행되므로 조건 평가 중에 &lt;code&gt;window.app&lt;/code&gt; 에 &lt;code&gt;{}&lt;/code&gt; 가 할당되므로 결과는 &lt;code&gt;app&lt;/code&gt; 및 &lt;code&gt;window.app&lt;/code&gt; 가 모두 &lt;code&gt;{}&lt;/code&gt; 가됩니다 . 콘솔 출력은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="feb062cf00888ada37d37ce1300e60f61e961935" translate="yes" xml:space="preserve">
          <source>so if I do:</source>
          <target state="translated">그래서 내가하면 :</target>
        </trans-unit>
        <trans-unit id="172e222242f37744f300767d18cc0b7b1beaa362" translate="yes" xml:space="preserve">
          <source>we are doing two things over here.
a) Wrapping our function expression inside braces (). This goes to tell the syntax parser the whatever placed inside the () is an expression (function expression in this case) and is a valid code.</source>
          <target state="translated">우리는 여기서 두 가지 일을하고 있습니다. a) 함수 표현식을 중괄호 ()로 묶습니다. 이것은 구문 파서에게 () 안에 배치 된 모든 것이 표현식 (이 경우 함수 표현식)이며 유효한 코드임을 알려줍니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
