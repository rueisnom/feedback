<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/67699">
    <body>
      <group id="67699">
        <trans-unit id="301f531ca75450cb2f7d1c557ac897795fde2749" translate="yes" xml:space="preserve">
          <source>$ git checkout -b experimental origin/experimental</source>
          <target state="translated">$ git checkout -b 실험적 기원 / 실험</target>
        </trans-unit>
        <trans-unit id="d9b845f965377efd496762792467b7956a67a199" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git branch --all&lt;/code&gt; or &lt;code&gt;git branch -a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git branch --all&lt;/code&gt; 또는 &lt;code&gt;git branch -a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="808f46ea8b6d7e40866821ee5a7a7591793b75de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git branch -a&lt;/code&gt; This will show you all the remote branches.</source>
          <target state="translated">&lt;code&gt;git branch -a&lt;/code&gt; 모든 원격 브랜치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4fe1973e7baebc3ae59caf3db9d6713e6b005cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git branch -a&lt;/code&gt; shows all branches, &lt;em&gt;including remote branches&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;git branch -a&lt;/code&gt; 는 &lt;em&gt;원격 브랜치를 포함한&lt;/em&gt; 모든 브랜치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ca562b4f001393db3334c499f5188be181ef8d4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git clone --mirror&lt;/code&gt; on the original repo works well for this.</source>
          <target state="translated">원래 &lt;code&gt;git clone --mirror&lt;/code&gt; 작업에 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="ca3e908b3d20e92f2a7f0cedb0c75a20647fdc54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git clone&lt;/code&gt; downloads all remote branches but still considers them &quot;remote&quot;, even though the files are located in your new repository. There's one exception to this, which is that the cloning process creates a local branch called &quot;master&quot; from the remote branch called &quot;master&quot;. By default, &lt;code&gt;git branch&lt;/code&gt; only shows local branches, which is why you only see &quot;master&quot;.</source>
          <target state="translated">&lt;code&gt;git clone&lt;/code&gt; 은 모든 원격 브랜치를 다운로드하지만 파일이 새 저장소에 있더라도 여전히 &quot;원격&quot;으로 간주합니다. 이에 대한 한 가지 예외가 있습니다. 복제 프로세스는 &quot;master&quot;라는 원격 지점에서 &quot;master&quot;라는 로컬 지점을 만듭니다. 기본적으로 &lt;code&gt;git branch&lt;/code&gt; 는 로컬 브랜치 만 표시 하므로 &quot;master&quot;만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="42547dc1981659d5cdfe3f986d8b011690b7ca9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch &amp;lt;origin-name&amp;gt; &amp;lt;branch-name&amp;gt;&lt;/code&gt; brings the branch down for you. While this doesn't pull all branches at once, you can singularly execute this per-branch.</source>
          <target state="translated">&lt;code&gt;git fetch &amp;lt;origin-name&amp;gt; &amp;lt;branch-name&amp;gt;&lt;/code&gt; 은 분기를 대신합니다. 이렇게하면 모든 분기가 한 번에 당겨지지는 않지만 분기별로이 분기를 개별적으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03a6f011d01355055fa890cf01f210adbfa6711c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch origin&lt;/code&gt; This will bring all the remote branches to your local.</source>
          <target state="translated">&lt;code&gt;git fetch origin&lt;/code&gt; 모든 원격 브랜치를 로컬로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3bb4c311efdde40b7d503b32e15584c5ca07cc2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Based on &lt;a href=&quot;https://stackoverflow.com/a/6300386/1998046&quot;&gt;answer&lt;/a&gt; of &lt;a href=&quot;https://stackoverflow.com/users/6309/vonc&quot;&gt;VonC&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/users/6309/vonc&quot;&gt;VonC의&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/6300386/1998046&quot;&gt;답변&lt;/a&gt; 을 기반으로합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a4841f998170893a1dfedec0a375be9bc995367" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Credits for one-liner go to user cfi&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;원 라이너 크레딧은 사용자 cfi로 이동&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d371a375635dead23e71c6018c06fc0b2d6bcf0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;방법 1 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39ba8b2d14f80c96148df898ae74111bfba336f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;방법 2 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b85f5fd3a37f8f6b212f361fd9f2d33e32cff56d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OK,&lt;/strong&gt; when you clone your repo, you have all branches there...</source>
          <target state="translated">&lt;strong&gt;좋아,&lt;/strong&gt; 레포를 복제하면 거기에 모든 가지가 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="f9b7fc59ec32619b7362f2d4e28752a85f1aa324" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;One liner&lt;/strong&gt;: &lt;code&gt;git branch -a | grep -v HEAD | perl -ne 'chomp($_); s|^\*?\s*||; if (m|(.+)/(.+)| &amp;amp;&amp;amp; not $d{$2}) {print qq(git branch --track $2 $1/$2\n)} else {$d{$_}=1}' | csh -xfs&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;하나의 라이너&lt;/strong&gt; : &lt;code&gt;git branch -a | grep -v HEAD | perl -ne 'chomp($_); s|^\*?\s*||; if (m|(.+)/(.+)| &amp;amp;&amp;amp; not $d{$2}) {print qq(git branch --track $2 $1/$2\n)} else {$d{$_}=1}' | csh -xfs&lt;/code&gt; grep -v 헤드 | perl -ne 'chomp ($ _); s | ^ \ *? \ s * ||; if (m | (. +) / (. +) | &amp;amp;&amp;amp; $ d {$ 2}) {print qq (git branch --track $ 2 $ 1 / $ 2 \ n)} 그렇지 않으면 {$ d {$ _} = 1} '| csh -xfs</target>
        </trans-unit>
        <trans-unit id="03fd26efb0ba8ef0fdfafb13fc8b44b41f652951" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;check out&lt;/strong&gt; branch from the remote</source>
          <target state="translated">리모컨에서 지점을 &lt;strong&gt;확인하십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d6f5f2b0449257fbe75cf43896bdff0962fa55a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;delete&lt;/strong&gt; local branch (so that we can check out force-updated branches)</source>
          <target state="translated">로컬 분기 &lt;strong&gt;삭제&lt;/strong&gt; (강제 업데이트 된 분기를 확인할 수 있도록)</target>
        </trans-unit>
        <trans-unit id="4c47ed8880cad9add68ee96040fa21eec8f95d77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;loop through all branches&lt;/strong&gt; of the remote except master and HEAD</source>
          <target state="translated">마스터 및 HEAD를 제외한 &lt;strong&gt;모든&lt;/strong&gt; 원격 &lt;strong&gt;분기&lt;/strong&gt; 를 &lt;strong&gt;반복합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c223e83979e975fbe477cefcf74a83291e1a259" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;select remote&lt;/strong&gt; to checkout (change it to whatever remote you have)</source>
          <target state="translated">체크 아웃 &lt;strong&gt;하려면 원격&lt;/strong&gt; 을 &lt;strong&gt;선택하십시오 (원격&lt;/strong&gt; 으로 변경하십시오)</target>
        </trans-unit>
        <trans-unit id="678c308bcd70afd312c9a957d86adebf91647e2e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Reference: &lt;a href=&quot;https://git.wiki.kernel.org/index.php/Git_FAQ#How_do_I_clone_a_repository_with_all_remotely_tracked_branches.3F&quot;&gt;Git FAQ: How do I clone a repository with all remotely tracked branches? &lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;참조 : &lt;a href=&quot;https://git.wiki.kernel.org/index.php/Git_FAQ#How_do_I_clone_a_repository_with_all_remotely_tracked_branches.3F&quot;&gt;힘내 FAQ : 원격으로 추적 된 모든 분기가있는 저장소를 어떻게 복제합니까?&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="da421b8657c21a03119727b7aa7e0479c605bee1" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;The &lt;code&gt;--depth=10000&lt;/code&gt; parameter may help if you've shallowed repository.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;저장소를 얕은 경우 &lt;code&gt;--depth=10000&lt;/code&gt; 매개 변수가 도움이 될 수 있습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ce8674470a57f633143963be8ef90127307f848" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;git clone&lt;/code&gt; is supposed to copy the entire repository.  Try cloning it, and then run &lt;code&gt;git branch -a&lt;/code&gt;.  It should list all the branches.  If then you want to switch to branch &quot;foo&quot; instead of &quot;master&quot;, use &lt;code&gt;git checkout foo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git clone&lt;/code&gt; 은 전체 저장소를 복사해야합니다. 복제를 시도한 다음 &lt;code&gt;git branch -a&lt;/code&gt; 를 실행하십시오. 모든 가지를 나열해야합니다. 그런 다음 &quot;master&quot;대신 &quot;foo&quot;분기로 전환하려면 &lt;code&gt;git checkout foo&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c10ce513d40dc2073d4c0536211efc2089159cf7" translate="yes" xml:space="preserve">
          <source>Also created the image below for you to simplify what I said:</source>
          <target state="translated">또한 내가 말한 것을 단순화하기 위해 아래 이미지를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="ffceac6103511230790137fcafeafda4a719a87f" translate="yes" xml:space="preserve">
          <source>Alternatively we can specify the remote branch instead.  This is based on &lt;a href=&quot;https://stackoverflow.com/users/144330/murphytalk&quot;&gt;murphytalk&lt;/a&gt;'s &lt;a href=&quot;https://stackoverflow.com/a/1186645/445221&quot;&gt;answer&lt;/a&gt;.</source>
          <target state="translated">또는 대신 원격 브랜치를 지정할 수 있습니다. 이것은 &lt;a href=&quot;https://stackoverflow.com/users/144330/murphytalk&quot;&gt;murphytalk&lt;/a&gt; 의 &lt;a href=&quot;https://stackoverflow.com/a/1186645/445221&quot;&gt;답변을&lt;/a&gt; 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="0f9df9d68e055253c086cab88c8be5d115c5a626" translate="yes" xml:space="preserve">
          <source>And you can switch to any branch which you already have.</source>
          <target state="translated">이미 가지고있는 지점으로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="593ef78e51c436cd66a563e6883dc4e210f64ca0" translate="yes" xml:space="preserve">
          <source>As of early 2017, the answer &lt;a href=&quot;https://stackoverflow.com/questions/67699/how-to-clone-all-remote-branches-in-git#comment2170694_72156&quot;&gt;in this comment&lt;/a&gt; works:</source>
          <target state="translated">2017 년 초 현재이 &lt;a href=&quot;https://stackoverflow.com/questions/67699/how-to-clone-all-remote-branches-in-git#comment2170694_72156&quot;&gt;의견&lt;/a&gt; 의 답변 은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12bebcaa76fddb944d1aca23f1b83d2c24722670" translate="yes" xml:space="preserve">
          <source>As usual: test in your setup before copying rm -rf universe as we know it</source>
          <target state="translated">평소와 같이 : rm -rf 유니버스를 복사하기 전에 설정에서 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="b2aaac0b957edd419ddc600021d5573eec4db5b9" translate="yes" xml:space="preserve">
          <source>At this point you have a complete copy of the remote repo with all of it's branches (verify with &lt;code&gt;git branch&lt;/code&gt;).  You can use &lt;code&gt;--mirror&lt;/code&gt; instead of &lt;code&gt;--bare&lt;/code&gt; if your remote repo has remotes of its own.</source>
          <target state="translated">이 시점에서 모든 원격 브랜치 ( &lt;code&gt;git branch&lt;/code&gt; 로 확인)와 함께 완전한 원격 리포지토리를 갖게됩니다. 원격 저장소에 자체 리모컨이있는 경우 &lt;code&gt;--mirror&lt;/code&gt; 대신 --mirror 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99fc7b688162413079b41c3407b8f0c9ca8deff2" translate="yes" xml:space="preserve">
          <source>At this point, things are getting pretty crazy, so run &lt;code&gt;gitk&lt;/code&gt; to see what's going on:</source>
          <target state="translated">이 시점에서 상황이 매우 미쳤으므로 &lt;code&gt;gitk&lt;/code&gt; 를 실행하여 진행중인 작업을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8c7875ace5025aaed734115d52f10ab9596ff44a" translate="yes" xml:space="preserve">
          <source>Better late than never, but here is the best way to do this:</source>
          <target state="translated">결코 늦지 않는 것이 낫지 만 여기에 가장 좋은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7fd99d2b1b9780441b6d0342458b5d033d2802b" translate="yes" xml:space="preserve">
          <source>Both commands can be aliased.</source>
          <target state="translated">두 명령 모두 별명을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53159098c758a6cdb6866692e1b8e8c61cbdc83e" translate="yes" xml:space="preserve">
          <source>But beware, if one of remote branches is named as e.g. admin_master  it won't get downloaded!</source>
          <target state="translated">그러나 원격 브랜치 중 하나의 이름이 admin_master로 지정되면 다운로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79fbe1fe23d00e363fc9210e6a012f7c01d8cdcd" translate="yes" xml:space="preserve">
          <source>But how about if the branch created by someone else after you clone?</source>
          <target state="translated">그러나 복제 후 다른 사람이 만든 분기는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="ea949a51fa8e944ca95850f1619f2d002c43c4ce" translate="yes" xml:space="preserve">
          <source>But if you want to work on that branch, you'll need to create a local tracking branch which is done automatically by:</source>
          <target state="translated">그러나 해당 지점에서 작업하려면 다음을 통해 자동으로 수행되는 로컬 추적 지점을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="c2591533a4fdf6f2da04b4b946423631176f7190" translate="yes" xml:space="preserve">
          <source>But there are other branches hiding in your repository! You can see these using the &lt;code&gt;-a&lt;/code&gt; flag:</source>
          <target state="translated">그러나 저장소에 다른 지점이 숨겨져 있습니다! &lt;code&gt;-a&lt;/code&gt; 플래그를 사용하여 다음을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ea87432285cb01210d2713146ec738d85831a62" translate="yes" xml:space="preserve">
          <source>Check if &lt;code&gt;origin&lt;/code&gt; points to the right URL via: &lt;code&gt;git remote show origin&lt;/code&gt; (see this &lt;a href=&quot;https://stackoverflow.com/q/5243231/55075&quot;&gt;post&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;git remote show origin&lt;/code&gt; (이 &lt;a href=&quot;https://stackoverflow.com/q/5243231/55075&quot;&gt;게시물&lt;/a&gt; 참조)을 통해 &lt;code&gt;origin&lt;/code&gt; 이 올바른 URL을 가리키는 지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="80816ffb31404735fc035cde7ba8c26445d825df" translate="yes" xml:space="preserve">
          <source>Cloning from a local repo will not work with git clone &amp;amp; git fetch: a lot of branches/tags will remain unfetched.</source>
          <target state="translated">로컬 리포지토리에서 복제하면 git clone &amp;amp; git fetch에서 작동하지 않습니다. 많은 분기 / 태그가 페치되지 않은 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="930286fefe00a0578e0de03873d6ee913f35a292" translate="yes" xml:space="preserve">
          <source>Don't worry that after you &quot;git clone&quot;, you don't need to connect with the remote repo, &quot;git branch -a&quot; and &quot;git checkout &quot; can be run successfully when you close your wifi. So it is proved that when you do &quot;git clone&quot;, it already has copied all branches from the remote repo. After that, you don't need the remote repo, your local already has all branches' codes.</source>
          <target state="translated">&quot;git clone&quot;후에 원격 저장소에 연결할 필요가 없습니다. Wi-Fi를 닫을 때 &quot;git branch -a&quot;및 &quot;git checkout&quot;을 성공적으로 실행할 수 있습니다. 따라서 &quot;git clone&quot;을 수행하면 이미 원격 저장소에서 모든 분기를 복사 한 것으로 판명되었습니다. 그 후에는 원격 저장소가 필요하지 않으며 로컬에는 이미 모든 지점 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fe3c5578d2022b9e801ad93a15fe2d4ea59e81b" translate="yes" xml:space="preserve">
          <source>Double check your remotes (&lt;code&gt;git remote -v&lt;/code&gt;), e.g.</source>
          <target state="translated">리모컨을 다시 확인하십시오 ( &lt;code&gt;git remote -v&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ef8ae25204b888689faeec56a121a1bfeb35cd8a" translate="yes" xml:space="preserve">
          <source>Each time it does an operation on your behalf, it prints it in red at the console. Over time, they finally stick into your brain :-)</source>
          <target state="translated">사용자를 대신하여 작업을 수행 할 때마다 콘솔에서 빨간색으로 인쇄됩니다. 시간이 지남에 따라 그들은 마침내 당신의 두뇌에 달라 붙습니다 :-)</target>
        </trans-unit>
        <trans-unit id="299f3e5211d43bbd5573ce814ba530f5c1d6a4c5" translate="yes" xml:space="preserve">
          <source>Even though you only see master branch, you can use &quot;git branch -a&quot; to see all branches.</source>
          <target state="translated">마스터 브랜치 만 보더라도 &quot;git branch -a&quot;를 사용하여 모든 브랜치를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26c3acfafa7b99822d5ac1cb02f37c83f54d3066" translate="yes" xml:space="preserve">
          <source>Existing branches will simply be checked out, or declared as already in it, but filters can be added to avoid the conflicts.</source>
          <target state="translated">기존 브랜치는 단순히 체크 아웃되거나 이미 이미 선언되어 있지만 충돌을 피하기 위해 필터를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5795a17b25798899d631807c8f04285e59bb24d" translate="yes" xml:space="preserve">
          <source>Finally, all commands have aliases, to make memorization easier.</source>
          <target state="translated">마지막으로, 모든 명령에는 더 쉽게 기억할 수 있도록 별칭이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb6c4941136ed90befe7375c3458e03e31e29e8b" translate="yes" xml:space="preserve">
          <source>First step</source>
          <target state="translated">첫 번째 단계</target>
        </trans-unit>
        <trans-unit id="1056dc406c6a2e988deef61bb7fb07283a39b216" translate="yes" xml:space="preserve">
          <source>First, clone a remote &lt;a href=&quot;http://en.wikipedia.org/wiki/Git_%28software%29&quot;&gt;Git&lt;/a&gt; repository and &lt;a href=&quot;http://en.wikipedia.org/wiki/Cd_%28command%29&quot;&gt;cd&lt;/a&gt; into it:</source>
          <target state="translated">먼저 원격 &lt;a href=&quot;http://en.wikipedia.org/wiki/Git_%28software%29&quot;&gt;Git&lt;/a&gt; 리포지토리를 복제하고 &lt;a href=&quot;http://en.wikipedia.org/wiki/Cd_%28command%29&quot;&gt;CD&lt;/a&gt; 로 넣습니다.</target>
        </trans-unit>
        <trans-unit id="776056333d0cb52b81767959d68e4640de0d93e3" translate="yes" xml:space="preserve">
          <source>For copy-paste into command line:</source>
          <target state="translated">명령 행에 복사하여 붙여 넣기 :</target>
        </trans-unit>
        <trans-unit id="f05a911df776c9209ed3927e38cdb6d3801e48f0" translate="yes" xml:space="preserve">
          <source>For more readibility:</source>
          <target state="translated">가독성을 높이려면 :</target>
        </trans-unit>
        <trans-unit id="21592b13daebfb6dea667bb7386f3f2965c0e42f" translate="yes" xml:space="preserve">
          <source>Git usually (when not specified) fetches all branches and/or tags (refs, see: &lt;code&gt;git ls-refs&lt;/code&gt;) from one or more other repositories along with the objects necessary to complete their histories. In other words it fetches the objects which are reachable by the objects that are already downloaded. See: &lt;a href=&quot;https://stackoverflow.com/a/36243207/55075&quot;&gt;What does &lt;code&gt;git fetch&lt;/code&gt; really do?&lt;/a&gt;</source>
          <target state="translated">힘내 (일반적으로 지정되지 않은 경우)는 기록을 완료하는 데 필요한 객체와 함께 하나 이상의 다른 저장소에서 모든 분기 및 / 또는 태그 (참조 : &lt;code&gt;git ls-refs&lt;/code&gt; 참조)를 가져옵니다. 즉, 이미 다운로드 한 객체가 접근 할 수있는 객체를 가져옵니다. 참조 : &lt;a href=&quot;https://stackoverflow.com/a/36243207/55075&quot;&gt; &lt;code&gt;git fetch&lt;/code&gt; 는 실제로 무엇을합니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b76ded2f402752f0ab4fc335b07322fbd203f05e" translate="yes" xml:space="preserve">
          <source>Git will automatically do the right thing:</source>
          <target state="translated">힘내 자동으로 올바른 일을 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="de23286b6837b41ad300e659bca5ffebe6385833" translate="yes" xml:space="preserve">
          <source>Git will check whether a branch with the same name exists in exactly one remote, and if it does, it tracks it the same way as if you had explicitly specified that it's a remote branch. From the git-checkout man page of Git 1.8.2.1:</source>
          <target state="translated">Git은 동일한 이름의 브랜치가 정확히 하나의 원격지에 존재하는지 확인하고, 존재한다면 원격 브랜치임을 명시 적으로 지정한 것과 같은 방식으로 추적합니다. Git 1.8.2.1의 git-checkout 매뉴얼 페이지에서 :</target>
        </trans-unit>
        <trans-unit id="31573bf9b35d67abc5c3ace961e3e3495517b5bd" translate="yes" xml:space="preserve">
          <source>Grab everything that inside the current folder and create all the branches on the local machine, therefore making this a normal repo.</source>
          <target state="translated">현재 폴더 안에있는 모든 것을 잡고 로컬 머신에 모든 브랜치를 생성하여 정상적인 리포지토리로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e08642655ee9705f1e63e0d7d13c6436ae6dabb2" translate="yes" xml:space="preserve">
          <source>Here is another short one-liner command which
creates local branches for all remote branches:</source>
          <target state="translated">다음은 모든 원격 브랜치에 대한 로컬 브랜치를 만드는 또 다른 짧은 한 줄 명령입니다.</target>
        </trans-unit>
        <trans-unit id="b34ecef9b36ef720971249f23ad287ed2c275185" translate="yes" xml:space="preserve">
          <source>Here's an answer that uses awk.  This method should suffice if used on a new repo.</source>
          <target state="translated">다음은 awk를 사용하는 답변입니다. 이 방법은 새로운 저장소에 사용하면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="20542ef656654b246f76f23e268c9c3d9a9ad2c5" translate="yes" xml:space="preserve">
          <source>Here's the help when you run grb help:</source>
          <target state="translated">grb help를 실행할 때의 도움말은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9b277456b96b95cf266b621fee07552a5bb7870" translate="yes" xml:space="preserve">
          <source>How to clone all remote branches in Git</source>
          <target state="translated">Git에서 모든 원격 브랜치를 복제하는 방법</target>
        </trans-unit>
        <trans-unit id="b5ab89c3f6e60702c0e43530b82f887c582f2ca4" translate="yes" xml:space="preserve">
          <source>How to get local branches</source>
          <target state="translated">현지 지점을 얻는 방법</target>
        </trans-unit>
        <trans-unit id="ff185a323114a5fcd49149360a6d7c9a7b503ef0" translate="yes" xml:space="preserve">
          <source>However, when you want to clone a repo with a lot of branches all the ways illustrated are above are lengthy and tedious in respect to a much cleaner and quicker way that I am going to show, though it's a bit complicated. You need three steps to accomplish this:</source>
          <target state="translated">그러나 많은 지점으로 리포를 복제하려는 경우 위에 표시된 모든 방법은 조금 더 복잡하지만 더 명확하고 빠른 방법과 관련하여 길고 지루합니다. 이를 위해서는 세 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4372151be6cd5728bd559cabd9d12e7b23ef8f97" translate="yes" xml:space="preserve">
          <source>I have a &lt;code&gt;master&lt;/code&gt; and a &lt;code&gt;development&lt;/code&gt; branch, both pushed to &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub&lt;/a&gt;. I've &lt;code&gt;clone&lt;/code&gt;d, &lt;code&gt;pull&lt;/code&gt;ed, and &lt;code&gt;fetch&lt;/code&gt;ed, but I remain unable to get anything other than the &lt;code&gt;master&lt;/code&gt; branch back.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 와 &lt;code&gt;development&lt;/code&gt; 지점이 있는데 둘 다 &lt;a href=&quot;http://en.wikipedia.org/wiki/GitHub&quot;&gt;GitHub로&lt;/a&gt; 푸시되었습니다. d를 &lt;code&gt;clone&lt;/code&gt; 하고, &lt;code&gt;fetch&lt;/code&gt; , 가져 왔습니다. 그러나 &lt;code&gt;master&lt;/code&gt; 브랜치 이외의 다른 것을 다시 얻을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="969752d323845a8628eec1919fa3b8d9cf76f42e" translate="yes" xml:space="preserve">
          <source>I needed to do exactly the same. Here is my &lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_%28programming_language%29&quot;&gt;Ruby&lt;/a&gt; script.</source>
          <target state="translated">나는 정확히 똑같이해야했습니다. 여기 내 &lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_%28programming_language%29&quot;&gt;루비&lt;/a&gt; 스크립트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4292b32834aeb0ec76fb6efd8da8a9e0d8e35dd" translate="yes" xml:space="preserve">
          <source>I was having trouble with moving a repo from one server/system to another. When I cloned the repo, it only created a local branch for master so when I pushed to the new remote, only master branch was pushed.</source>
          <target state="translated">한 서버 / 시스템에서 다른 서버 / 시스템으로 리포지를 이동하는 데 문제가있었습니다. 리포지토리를 복제 할 때 마스터의 로컬 분기 만 만들었으므로 새 원격으로 푸시하면 마스터 분기 만 푸시되었습니다.</target>
        </trans-unit>
        <trans-unit id="f74da9fefce5a6552c2becb1f5200a5efd6e1130" translate="yes" xml:space="preserve">
          <source>I wrote this small &lt;strong&gt;Powershell&lt;/strong&gt; functions to be able to checkout all my git branches, that are on origin remote.</source>
          <target state="translated">나는이 작은 &lt;strong&gt;Powershell&lt;/strong&gt; 함수를 작성하여 원점 원격에있는 모든 자식 분기를 체크 아웃 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="d42f1310a09bd0f27b7120964a57f59d3155c0d5" translate="yes" xml:space="preserve">
          <source>I'm sure I'm missing something obvious, but I have read the manual and I'm getting no joy at all.</source>
          <target state="translated">나는 분명한 것을 놓치고 있다고 확신하지만 매뉴얼을 읽었으며 전혀 기쁨을 얻지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="d234afa8d7c49dd35161a362bf35d9a55739662f" translate="yes" xml:space="preserve">
          <source>If &amp;lt;branch&amp;gt; is not found but there does exist a tracking branch in
  exactly one remote (call it &amp;lt;remote&amp;gt;) with a matching name, treat as
  equivalent to</source>
          <target state="translated">&amp;lt;branch&amp;gt;를 찾을 수 없지만 일치하는 이름을 가진 정확히 하나의 원격에 추적 분기가있는 경우 (&amp;lt;remote&amp;gt;라고 함)</target>
        </trans-unit>
        <trans-unit id="25faa613652f37fb764c40d08e5ccb4b1035abec" translate="yes" xml:space="preserve">
          <source>If above won't help, you need to add missing branches manually to the tracked list (as they got lost somehow):</source>
          <target state="translated">위의 방법으로 도움이되지 않으면 누락 된 분기를 추적 목록에 수동으로 추가해야합니다 (어쨌든 손실 됨).</target>
        </trans-unit>
        <trans-unit id="1a14359df5526c8866b54bcdd94f5b679c0e138d" translate="yes" xml:space="preserve">
          <source>If you actually want to work on a branch, you'll probably want a &quot;local&quot; version of it. To simply create local branches from remote branches &lt;em&gt;(without checking them out and thereby changing the contents of your working directory)&lt;/em&gt;, you can do that like this:</source>
          <target state="translated">실제로 지점에서 작업하려면 &quot;로컬&quot;버전이 필요할 것입니다. 원격 브랜치에서 로컬 브랜치를 만들려면 &lt;em&gt;(이를 체크 아웃하지 않고 작업 디렉토리의 내용을 변경하지 않고)&lt;/em&gt; 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4437e4612310d6856b546b4f56c5dcd4513d260c" translate="yes" xml:space="preserve">
          <source>If you do not need to have &lt;code&gt;master&lt;/code&gt; branch checked out after cloning, use</source>
          <target state="translated">복제 후 &lt;code&gt;master&lt;/code&gt; 브랜치를 체크 아웃 할 필요가없는 경우</target>
        </trans-unit>
        <trans-unit id="da914ab2547bb422c2c4e467c515df7a14f8a389" translate="yes" xml:space="preserve">
          <source>If you don't want grb to run commands on your behalf, just use the 'explain' feature. The commands will be printed to your console instead of executed for you.</source>
          <target state="translated">grb가 사용자 대신 명령을 실행하지 못하게하려면 'explain'기능을 사용하십시오. 명령이 실행되는 대신 콘솔에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1df53534155e15120a376ae4cb28a9f588e7a1f4" translate="yes" xml:space="preserve">
          <source>If you have many remote branches that you want to fetch at once, do:</source>
          <target state="translated">한 번에 가져 오려는 원격 분기가 많은 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cc3b083a56fe1fb412680ed10c66fbe4af734503" translate="yes" xml:space="preserve">
          <source>If you just checkout to the branch, you get all you need.</source>
          <target state="translated">지점에 체크 아웃하면 필요한 모든 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5534e19d892d0e286c9a619c4893b78305b4b1b7" translate="yes" xml:space="preserve">
          <source>If you just do &lt;code&gt;git branch&lt;/code&gt;, they are kind of hidden...</source>
          <target state="translated">&lt;code&gt;git branch&lt;/code&gt; 만하면 숨겨져 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="38c5c163571026b7685a448acac703e023a9ae11" translate="yes" xml:space="preserve">
          <source>If you just want to take a quick peek at an upstream branch, you can check it out directly:</source>
          <target state="translated">업스트림 지점에서 간단히 살펴보고 싶다면 직접 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c03b69f363d8bf1f2dcfe450a25553020cd16960" translate="yes" xml:space="preserve">
          <source>If you like to fetch and checkout at the same time, you can do:</source>
          <target state="translated">동시에 페치 및 체크 아웃하려는 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81bd5d25d136c008fe0dd2dc4a9c268f29383d87" translate="yes" xml:space="preserve">
          <source>If you still cannot get anything other than the master branch, check the followings:</source>
          <target state="translated">여전히 마스터 브랜치 이외의 것을 얻을 수 없으면 다음을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="28b33bd4d48a46b7ed8cb6551abcd866e7721073" translate="yes" xml:space="preserve">
          <source>In order to work on top of a specific remote branch, assuming it's the origin remote:</source>
          <target state="translated">원점 리모트라고 가정하고 특정 리모트 브랜치 위에서 작업하려면 :</target>
        </trans-unit>
        <trans-unit id="1d0072897a7357e3ee9d2fd0675a8fcd514a3db7" translate="yes" xml:space="preserve">
          <source>In this case, just do:</source>
          <target state="translated">이 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3459c77ae7c5c24c59f8271356fa156298488ad4" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;branchone&lt;/code&gt; is the name of a local branch you're creating based on &lt;code&gt;origin/branchone&lt;/code&gt;; if you instead want to create local branches with different names, you can do this:</source>
          <target state="translated">이 예에서 &lt;code&gt;branchone&lt;/code&gt; 은 &lt;code&gt;origin/branchone&lt;/code&gt; 을 기반으로 생성하는 로컬 지점의 이름입니다. 다른 이름으로 로컬 브랜치를 만들려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="62e28de059a281efc8c9d2b1435590e6c9816ad9" translate="yes" xml:space="preserve">
          <source>It can also be modified so it calls an explicit &lt;code&gt;git checkout -b &amp;lt;branch&amp;gt; -t &amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&lt;/code&gt; command.</source>
          <target state="translated">명시적인 &lt;code&gt;git checkout -b &amp;lt;branch&amp;gt; -t &amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&lt;/code&gt; 명령을 호출하도록 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8d289cf33cf01f1a01e7b5e112c7f50087b4784" translate="yes" xml:space="preserve">
          <source>It throws fatal error messages on conflicts but I see them harmless.</source>
          <target state="translated">충돌시 치명적인 오류 메시지가 표시되지만 무해합니다.</target>
        </trans-unit>
        <trans-unit id="7b11f2e763d832fcde8fb41e48bbdbca4559197e" translate="yes" xml:space="preserve">
          <source>It will create tracking branches for all remote branches, except master (which you probably got from the original clone command). I think you might still need to do a</source>
          <target state="translated">마스터를 제외한 모든 원격 브랜치에 대한 추적 브랜치를 생성합니다 (원래 복제 명령에서 얻은 것임). 아직도해야 할 것 같아요</target>
        </trans-unit>
        <trans-unit id="08157d13fce8f2cc30ac676bad8a23a7f9089dc5" translate="yes" xml:space="preserve">
          <source>It works also properly if tracking local branches are already created.
You can call it after the first &lt;code&gt;git clone&lt;/code&gt; or any time later.</source>
          <target state="translated">로컬 지점 추적이 이미 생성 된 경우에도 올바르게 작동합니다. 첫 번째 &lt;code&gt;git clone&lt;/code&gt; 이후 또는 나중에 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edad9a82d9dba1609376dbbcd049f80b32fbb705" translate="yes" xml:space="preserve">
          <source>Just do this:</source>
          <target state="translated">그냥 이렇게 :</target>
        </trans-unit>
        <trans-unit id="bb5415c2bb23bb4629b3b5f76a5f0e04440efb16" translate="yes" xml:space="preserve">
          <source>Looking at one of answers to the question I noticed that it's possible to shorten it:</source>
          <target state="translated">질문에 대한 답변 중 하나를 살펴보면 질문을 줄이는 것이 가능하다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="e11d591b7e8e36d20f6c470e79c8f196f46d3067" translate="yes" xml:space="preserve">
          <source>More git functions can be found on &lt;a href=&quot;https://github.com/aburok/mysettings/blob/master/PowerShell/config/git-alias.ps1&quot;&gt;my git settings repo&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/aburok/mysettings/blob/master/PowerShell/config/git-alias.ps1&quot;&gt;내 자식 설정 저장소&lt;/a&gt; 에서 더 많은 자식 기능을 찾을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fda7d0c53ead03d7a617ca22b7b9968b4c38228f" translate="yes" xml:space="preserve">
          <source>Next, look at the local branches in your repository:</source>
          <target state="translated">다음으로 저장소의 로컬 브랜치를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="d31445656d6ad5b4ae57150f44f708711d0cc85a" translate="yes" xml:space="preserve">
          <source>None of these answers cut it, except user nobody is on the right track.</source>
          <target state="translated">사용자가 올바른 길을 가고 있지 않다는 것을 제외하고는 이러한 답변 중 어느 것도 그것을 잘랐습니다.</target>
        </trans-unit>
        <trans-unit id="620ff77c38debe97aeffdd621f6178c52e8a6248" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;a href=&quot;http://programblings.com/2008/08/06/time-to-git-collaborating-with-git_remote_branch/&quot;&gt;alpha software&lt;/a&gt; ;-)</source>
          <target state="translated">이것은 &lt;a href=&quot;http://programblings.com/2008/08/06/time-to-git-collaborating-with-git_remote_branch/&quot;&gt;알파 소프트웨어입니다&lt;/a&gt; ;-)</target>
        </trans-unit>
        <trans-unit id="13b662f96dc05a55957e72aca6e62d8e95673d8e" translate="yes" xml:space="preserve">
          <source>Notice the * sign that denotes the current branch.</source>
          <target state="translated">현재 분기를 나타내는 * 기호를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5961922ec547b8dad92b80187ad353f2eafffd7a" translate="yes" xml:space="preserve">
          <source>Now you can checkout any branch as you need to, without hitting the remote repository.</source>
          <target state="translated">이제 원격 리포지토리에 충돌하지 않고 필요한 지점을 체크 아웃 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e7eefbf7f29d706c05433be74b13e007b531221" translate="yes" xml:space="preserve">
          <source>Now, if you look at your local branches, this is what you'll see:</source>
          <target state="translated">이제 현지 지점을 보면 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7ef0fa65d8e00ab7e4c7afb9fe208f44c76d0b51" translate="yes" xml:space="preserve">
          <source>Now, when you are on the dev branch, &quot;git pull&quot; will update your local dev to the same point as the remote dev branch.  Note that it will fetch all branches, but only pull the one you are on to the top of the tree.</source>
          <target state="translated">이제 개발자 브랜치에있을 때 &quot;git pull&quot;은 로컬 개발자를 원격 개발자 브랜치와 같은 지점으로 업데이트합니다. 모든 브랜치를 가져 오지만 트리의 맨 위에있는 브랜치를 당겨야합니다.</target>
        </trans-unit>
        <trans-unit id="50e1fde6ec99f0c25dc7e679426e55e9aa717370" translate="yes" xml:space="preserve">
          <source>Once you've created a local branch, you can see it with &lt;code&gt;git branch&lt;/code&gt; (remember, you don't need &lt;code&gt;-a&lt;/code&gt; to see local branches).</source>
          <target state="translated">로컬 브랜치를 만든 후에는 &lt;code&gt;git branch&lt;/code&gt; 로 볼 수 있습니다 (로컬 브랜치를 보려면 &lt;code&gt;-a&lt;/code&gt; 가 필요하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="c8ea076decc01c52eb7e6ef603451913e28b26ce" translate="yes" xml:space="preserve">
          <source>Personally I'd use &lt;code&gt;track-all&lt;/code&gt; or &lt;code&gt;track-all-branches&lt;/code&gt;.</source>
          <target state="translated">개인적으로 &lt;code&gt;track-all&lt;/code&gt; 또는 &lt;code&gt;track-all-branches&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="78661573440759b79a8f231bcc4014f9cc208dc2" translate="yes" xml:space="preserve">
          <source>Regarding,</source>
          <target state="translated">Regarding,</target>
        </trans-unit>
        <trans-unit id="472249ab326172c712293505899f939961ecabc5" translate="yes" xml:space="preserve">
          <source>Second step</source>
          <target state="translated">두번째 단계</target>
        </trans-unit>
        <trans-unit id="bdda1441221b896dba833cb84c0e6e22be619aad" translate="yes" xml:space="preserve">
          <source>So I found these two methods VERY useful. Hope they help someone else.</source>
          <target state="translated">그래서이 두 가지 방법이 매우 유용하다는 것을 알았습니다. 그들이 다른 사람을 돕기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="c80c8aec2de465af54e7f390fcfdcde0497f6ae1" translate="yes" xml:space="preserve">
          <source>So if you'd like to see all branches name, just simply add &lt;code&gt;--all&lt;/code&gt; flag like this:</source>
          <target state="translated">따라서 모든 지점 이름을 보려면 다음과 같이 &lt;code&gt;--all&lt;/code&gt; 플래그를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1bbaa234799e1d39395f0f9e989811e094db7b3f" translate="yes" xml:space="preserve">
          <source>So now you can just type the command &quot;git branch&quot; and you can see that all the branches are downloaded.</source>
          <target state="translated">이제 &quot;git branch&quot;명령을 입력하면 모든 브랜치가 다운로드되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a842aa3da102a1c9a8a4173222d37f1bc67be144" translate="yes" xml:space="preserve">
          <source>So to &lt;strong&gt;fetch them all&lt;/strong&gt;, try:</source>
          <target state="translated">따라서 &lt;strong&gt;모두 가져 오려면 다음을&lt;/strong&gt; 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="7e9ee1431137dc10474a236583c516762f0c52f8" translate="yes" xml:space="preserve">
          <source>Sometimes you may have branches/tags which aren't directly connected to the current one, so &lt;code&gt;git pull --all&lt;/code&gt;/&lt;code&gt;git fetch --all&lt;/code&gt; won't help in that case, but you can list them by:</source>
          <target state="translated">때로는 현재 분기에 직접 연결되지 않은 분기 / 태그가있을 수 있으므로 &lt;code&gt;git pull --all&lt;/code&gt; / &lt;code&gt;git fetch --all&lt;/code&gt; 은 도움이되지 않지만 다음과 같이 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a30e548dfcbb2eea59e05a9ae91634ecd39863fe" translate="yes" xml:space="preserve">
          <source>Thanks to bigfish for original idea</source>
          <target state="translated">독창적 인 아이디어를위한 bigfish 덕분에</target>
        </trans-unit>
        <trans-unit id="00497e6863251261eab340cd362291173675bac1" translate="yes" xml:space="preserve">
          <source>That last line throws some people: &quot;New branch&quot; - huh?
What it really means is that the branch is taken from the index and created locally for you.  The &lt;em&gt;previous&lt;/em&gt; line is actually more informative as it tells you that the branch is being set up to track the remote branch, which usually means the origin/branch_name branch</source>
          <target state="translated">그 마지막 줄은 어떤 사람들을 던졌습니다 : &quot;새로운 지점&quot;-응? 실제로 의미하는 것은 지점에서 인덱스를 가져 와서 로컬로 생성한다는 것입니다. &lt;em&gt;이전&lt;/em&gt; 줄은 실제로 지점이 원격 지점을 추적하도록 설정되어 있기 때문에 실제로 더 유익합니다. 이는 일반적으로 origin / branch_name 지점을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="eb2301e071497dc9ced7147bb2e1df9aee7d0cc4" translate="yes" xml:space="preserve">
          <source>The fetch that you are doing should get all the remote branches, but it won't create local branches for them. If you use gitk, you should see the remote branches described as &quot;remotes/origin/dev&quot; or something similar.</source>
          <target state="translated">가져 오는 페치는 모든 원격 브랜치를 가져와야하지만 로컬 브랜치를 만들지는 않습니다. gitk를 사용한다면, &quot;remotes / origin / dev&quot;또는 이와 유사한 것으로 기술 된 원격 브랜치를 볼 수있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="6855b6ff6eb4777534819fd8d8a0b570d7f78e1a" translate="yes" xml:space="preserve">
          <source>The output will like this;</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5e2c2d9d615bdce4c4810af3a2860b858e38623" translate="yes" xml:space="preserve">
          <source>Then check all your branches again:</source>
          <target state="translated">그런 다음 모든 지점을 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7425a5d18582c1acbc601b57740bcb0a00f9798a" translate="yes" xml:space="preserve">
          <source>These code will pull all remote branches code to local repo.</source>
          <target state="translated">이 코드는 모든 원격 브랜치 코드를 로컬 리포지토리로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3342d5c5367d84612ab97657956aa20e618ae7d0" translate="yes" xml:space="preserve">
          <source>Third Step</source>
          <target state="translated">세 번째 단계</target>
        </trans-unit>
        <trans-unit id="a6793ef1dad62e88bf4b177329a886201177aad0" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; script helped me out:</source>
          <target state="translated">이 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; 스크립트가 도움이되었습니다.</target>
        </trans-unit>
        <trans-unit id="f8dabde90c9fee0597297bc22424492125fa364d" translate="yes" xml:space="preserve">
          <source>This answer follows &lt;a href=&quot;https://stackoverflow.com/users/856199/nikos-c&quot;&gt;Nikos C.&lt;/a&gt;'s &lt;a href=&quot;https://stackoverflow.com/a/10563611/445221&quot;&gt;idea&lt;/a&gt;.</source>
          <target state="translated">이 답변은 &lt;a href=&quot;https://stackoverflow.com/users/856199/nikos-c&quot;&gt;Nikos C.&lt;/a&gt; 의 &lt;a href=&quot;https://stackoverflow.com/a/10563611/445221&quot;&gt;아이디어를&lt;/a&gt; 따릅니다.</target>
        </trans-unit>
        <trans-unit id="261e90f1e3af2f822792c202c79e89f411a57034" translate="yes" xml:space="preserve">
          <source>This is the quick way in which you can clone a git repository with all the branches at once, but it's not something you wanna do for every single project in this way.</source>
          <target state="translated">이것은 모든 브랜치를 사용하여 git 저장소를 한 번에 복제 할 수있는 빠른 방법이지만,이 방법으로 모든 단일 프로젝트에 대해 수행하려는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ab5e91411dd9f26c97228c52a101ee830f876ca9" translate="yes" xml:space="preserve">
          <source>This isn't too much complicated, very simple and straight forward steps are as follows;</source>
          <target state="translated">이것은 너무 복잡하지 않으며 매우 간단하고 간단한 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a291220bace82fc699106fdc0c78b94804985569" translate="yes" xml:space="preserve">
          <source>This will:</source>
          <target state="translated">이것은 :</target>
        </trans-unit>
        <trans-unit id="3dc2f854808ea3dad01c452a9c607100f4eab7a0" translate="yes" xml:space="preserve">
          <source>To create a local branch based on a remote branch, do something like:</source>
          <target state="translated">원격 지점을 기반으로 로컬 지점을 만들려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="95c36f856b6800415b5fa6fb30e5412a082b979e" translate="yes" xml:space="preserve">
          <source>To get a clone with all branches and tags but also with a working copy:</source>
          <target state="translated">모든 브랜치 및 태그와 함께 작업 복사본으로 복제본을 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="1e8f88ebad2ccc24959462baa31698636b7ec42a" translate="yes" xml:space="preserve">
          <source>To get a clone with all branches and tags.</source>
          <target state="translated">모든 브랜치 및 태그가있는 복제본을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="8ce69806e0744fa9e3a09ae5301ae119695b37d0" translate="yes" xml:space="preserve">
          <source>Use aliases. Though there aren't any native Git one-liners, you can define your own as</source>
          <target state="translated">별명을 사용하십시오. 기본 Git one-liner는 없지만 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a833ccc6264658a8a599cc4b11f2b141d7c47979" translate="yes" xml:space="preserve">
          <source>Use my tool &lt;a href=&quot;http://programblings.com/2008/08/06/time-to-git-collaborating-with-git_remote_branch/&quot;&gt;git_remote_branch&lt;/a&gt; (you need Ruby installed on your machine). It's built specifically to make remote branch manipulations dead easy.</source>
          <target state="translated">내 도구 &lt;a href=&quot;http://programblings.com/2008/08/06/time-to-git-collaborating-with-git_remote_branch/&quot;&gt;git_remote_branch를&lt;/a&gt; 사용하십시오 (시스템에 Ruby가 설치되어 있어야 함). 원격 브랜치 조작을 쉽게하기 위해 특별히 제작되었습니다.</target>
        </trans-unit>
        <trans-unit id="3bc19fcfb95afa56c9c0dadf40520dbb1f0a59d5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://stackoverflow.com/users/2383918/nobody&quot;&gt;nobody&lt;/a&gt;'s &lt;a href=&quot;https://stackoverflow.com/a/16563327/445221&quot;&gt;answer&lt;/a&gt; as reference, we can have the following commands to create the aliases:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/2383918/nobody&quot;&gt;nobody&lt;/a&gt; 의 &lt;a href=&quot;https://stackoverflow.com/a/16563327/445221&quot;&gt;답변&lt;/a&gt; 을 참조로 사용하여 다음 명령을 사용하여 별칭을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1773acfb1a5b1250da63e75db924bddbba366aaa" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--mirror&lt;/code&gt; option seems to copy the &lt;code&gt;remote&lt;/code&gt; tracking branches properly.
However, it sets up the repository as a bare repository, so you have to turn it back into a normal repository afterwards.</source>
          <target state="translated">&lt;code&gt;--mirror&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;remote&lt;/code&gt; 추적 분기를 올바르게 복사하는 것 같습니다. 그러나 저장소를 기본 저장소로 설정하므로 나중에 일반 저장소로 다시 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="35cfd145ad7d3f17d8f064c74e56f78d5a5fd272" translate="yes" xml:space="preserve">
          <source>Validate that &lt;code&gt;git config branch.master.remote&lt;/code&gt; is &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git config branch.master.remote&lt;/code&gt; 가 &lt;code&gt;origin&lt;/code&gt; 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="74cbedaadf9f59b649aaff3c74143aa7a5832b96" translate="yes" xml:space="preserve">
          <source>Verify whether you are in the desired branch by the following command;</source>
          <target state="translated">다음 명령으로 원하는 분기에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="74cb7eec03a23ae2553a813034fc41c457179fa8" translate="yes" xml:space="preserve">
          <source>When you clone a repository all the information of the branches is actually downloaded but the branches are hidden. With the command</source>
          <target state="translated">리포지토리를 복제하면 분기의 모든 정보가 실제로 다운로드되지만 분기는 숨겨집니다. 명령으로</target>
        </trans-unit>
        <trans-unit id="edaf5ac1fa3f07ce16d86f8e784d6e989678d290" translate="yes" xml:space="preserve">
          <source>When you do &quot;git clone git://location&quot;, all branches and tags are fetched.</source>
          <target state="translated">&quot;git clone git : // location&quot;을 수행하면 모든 브랜치와 태그가 페치됩니다.</target>
        </trans-unit>
        <trans-unit id="acccf42b8e873d5db5f0d9e0fa9d01abbc24b21e" translate="yes" xml:space="preserve">
          <source>Which should return something like:</source>
          <target state="translated">다음과 같은 것을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3cc07b5a4565837fd0c94b1042ef5c8f01572213" translate="yes" xml:space="preserve">
          <source>Why you only see &quot;master&quot;</source>
          <target state="translated">&quot;마스터&quot;만 보이는 이유</target>
        </trans-unit>
        <trans-unit id="599416f2bfc34cec6b2286335ae339fee9f3ba1d" translate="yes" xml:space="preserve">
          <source>You can actually track more than one remote repository using &lt;code&gt;git remote&lt;/code&gt;.</source>
          <target state="translated">실제로 &lt;code&gt;git remote&lt;/code&gt; 를 사용하여 둘 이상의 원격 저장소를 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e17208f2a61b55ddd7f6bff2f5d111a2f2d15e" translate="yes" xml:space="preserve">
          <source>You can easily switch to a branch without using the fancy &quot;git checkout -b somebranch origin/somebranch&quot; syntax.  You can just do:</source>
          <target state="translated">멋진 &quot;git checkout -b somebranch origin / somebranch&quot;구문을 사용하지 않고 분기로 쉽게 전환 할 수 있습니다. 당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ff1c1e662deac14b0ec579efc11eebb4264b38bb" translate="yes" xml:space="preserve">
          <source>You only need to use &quot;git clone&quot; to get all branches.</source>
          <target state="translated">모든 분기를 가져 오려면 &quot;git clone&quot;만 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="faf5b6aec65a13cec421dcae0ea195e5abd1c470" translate="yes" xml:space="preserve">
          <source>You see, 'git clone git://example.com/myprojectt' fetches everything, even the branches, you just have to checkout them, then your local branch will be created.</source>
          <target state="translated">'git clone git : //example.com/myprojectt'는 브랜치를 포함하여 모든 것을 가져오고 체크 아웃하면 로컬 브랜치가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a3f8ac5eca8f606c25754e8bc8ca3bb624b42e61" translate="yes" xml:space="preserve">
          <source>all the answers I saw here are valid but there is a much cleaner way to clone a repository and to pull all the branches at once.</source>
          <target state="translated">내가 본 모든 대답은 유효하지만 저장소를 복제하고 모든 분기를 한 번에 가져 오는 훨씬 깨끗한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b651cdf28b86b10dbfe9991c53832a4cd260bf13" translate="yes" xml:space="preserve">
          <source>and check all branches again...</source>
          <target state="translated">모든 지점을 다시 확인하십시오 ...</target>
        </trans-unit>
        <trans-unit id="e8233383c2f197cb243bee10b8f2e06e597d83af" translate="yes" xml:space="preserve">
          <source>and fetch them manually by knowing the ref names.</source>
          <target state="translated">참조 이름을 알고 수동으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f200dac23cbfd780612a0446217b60ada118534c" translate="yes" xml:space="preserve">
          <source>and then use it as</source>
          <target state="translated">그런 다음</target>
        </trans-unit>
        <trans-unit id="abfdb0f896f8dc2ec024de13627b9635a8296b2b" translate="yes" xml:space="preserve">
          <source>and you will see</source>
          <target state="translated">그리고 당신은 볼 것이다</target>
        </trans-unit>
        <trans-unit id="cfd42c2d8f36d6d1f6bb96ee4840313ebd9568f6" translate="yes" xml:space="preserve">
          <source>by &lt;code&gt;git remote set-branches&lt;/code&gt; like:</source>
          <target state="translated">&lt;code&gt;git remote set-branches&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7ac42d872ae211b768eeaddce90f3cc9eb60f628" translate="yes" xml:space="preserve">
          <source>check out master (for the sake of it)</source>
          <target state="translated">마스터 확인 (그것을 위해)</target>
        </trans-unit>
        <trans-unit id="32cc7371d8ab3f6d436ba08a6170c7fd3cadde8d" translate="yes" xml:space="preserve">
          <source>check out master (so that we can delete branch we are on)</source>
          <target state="translated">마스터 체크 아웃 (우리가있는 지점을 삭제할 수 있도록)</target>
        </trans-unit>
        <trans-unit id="9590d8978d109761c8eb1143ff14df15719b2da5" translate="yes" xml:space="preserve">
          <source>create a new empty folder on your machine and clone a mirror copy of the .git folder from the repository:</source>
          <target state="translated">머신에 비어있는 새 폴더를 만들고 저장소에서 .git 폴더의 미러 사본을 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="db6162f14163082d71e98f21a1ca78f1a06ca2db" translate="yes" xml:space="preserve">
          <source>might be better, in terms of tracking a remote repository.</source>
          <target state="translated">원격 저장소 추적 측면에서 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="02e4e388b02f55b4b75cc79864d49d1a33b564bc" translate="yes" xml:space="preserve">
          <source>or the more verbose but easier to remember</source>
          <target state="translated">더 장황하지만 기억하기 쉬운</target>
        </trans-unit>
        <trans-unit id="dd3a5032cc67d17d0a229a6741c66e2552cb9f27" translate="yes" xml:space="preserve">
          <source>so it may appear under &lt;code&gt;remotes/origin&lt;/code&gt; after fetch:</source>
          <target state="translated">가져 오기 후에 &lt;code&gt;remotes/origin&lt;/code&gt; 아래에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e8d4241b88ff268043f86b1c2c0d1961627cc58" translate="yes" xml:space="preserve">
          <source>switch this repository from an empty (bare) repository to a regular repository by switching the boolean value &quot;bare&quot; of the git configurations to false:</source>
          <target state="translated">git 구성의 boolean 값 &quot;bare&quot;를 false로 전환하여이 저장소를 빈 저장소에서 일반 저장소로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="ac9b542420c95a107f17e647038e5aeeb8338fb3" translate="yes" xml:space="preserve">
          <source>the local repository inside the folder my_repo_folder is still empty, there is just a hidden .git folder now that you can see with a &quot;ls -alt&quot; command from the terminal.</source>
          <target state="translated">my_repo_folder 폴더 내의 로컬 저장소가 여전히 비어 있으면 터미널에서 &quot;ls -alt&quot;명령으로 볼 수있는 숨겨진 .git 폴더 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ee68b3a2cfa9518c399656cfb58c7a62f733b30" translate="yes" xml:space="preserve">
          <source>to be sure.</source>
          <target state="translated">확인하기.</target>
        </trans-unit>
        <trans-unit id="92bd75ebd8fd2b0179172217b15350cc6d4002f0" translate="yes" xml:space="preserve">
          <source>using</source>
          <target state="translated">using</target>
        </trans-unit>
        <trans-unit id="3e6ccb76f79e6850f1acfebc7ac926f5cb9061e4" translate="yes" xml:space="preserve">
          <source>you can show all the branches of the repository, and with the command</source>
          <target state="translated">저장소의 모든 브랜치를 표시하고 명령을 사용하여</target>
        </trans-unit>
        <trans-unit id="2daa6e36fdfa4b70b796e2becaf433447bc65917" translate="yes" xml:space="preserve">
          <source>you can then &quot;download&quot; them manually one at a time.</source>
          <target state="translated">그런 다음 한 번에 하나씩 수동으로 &quot;다운로드&quot;할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
