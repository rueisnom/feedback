<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/671118">
    <body>
      <group id="671118">
        <trans-unit id="4b5f371d067d57adebce0c867d054ff2d3400ab5" translate="yes" xml:space="preserve">
          <source>(This answer has been the subject of a fair amount of criticism for missing the point. For the most part, that has been a fair critique. What I originally described was more in line with how REST was usually implemented a few years ago when I first wrote this, rather than its true meaning. I've revised the answer to better represent the real meaning.)</source>
          <target state="translated">(这个回答因为漏掉了重点而受到了不少批评。在大多数情况下,这是一个公平的批评。我最初描述的内容更符合几年前我第一次写这篇文章时,REST通常是如何实现的,而不是它的真正含义。我修改了答案,以便更好地表达真实的含义)。</target>
        </trans-unit>
        <trans-unit id="d38acde6c0a007c814e7a8e62db3e40f8b9a8c5d" translate="yes" xml:space="preserve">
          <source>1) There is no such a thing as restful programing, without a big joint and lots of beer :)</source>
          <target state="translated">1)没有大块头和大量的啤酒,就没有所谓的安分守己的程序,没有大块头和大量的啤酒 :)</target>
        </trans-unit>
        <trans-unit id="16ed7b2a6cdbe5d413738c42d0ff5485bb59700c" translate="yes" xml:space="preserve">
          <source>2) &lt;strong&gt;Representational State Transfer (REST) is an architectural style specified in &lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;the dissertation of Roy Fielding&lt;/a&gt;.
It has a number of constraints.  If your Service/Client respect those then it is RESTful.&lt;/strong&gt; This is it.</source>
          <target state="translated">2） &lt;strong&gt;代表性状态转移（REST）是&lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Roy Fielding论文中&lt;/a&gt;指定的一种建筑风格。&lt;/strong&gt; &lt;strong&gt;它有很多限制。&lt;/strong&gt; &lt;strong&gt;如果您的服务/客户端尊重这些原则，那么它就是RESTful的。&lt;/strong&gt; 就是这个。</target>
        </trans-unit>
        <trans-unit id="27e5dbfce4b7ee29196f5fd4dafe3ca1c0624c58" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;Unique global identifier&lt;/a&gt; (all resources are unique identified by &lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;唯一的全局标识符&lt;/a&gt; （所有资源均由&lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI&lt;/a&gt;唯一标识）。</target>
        </trans-unit>
        <trans-unit id="1fd9999d07a7fc62861689de4b2bdf6a8fc86768" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;RESTful&lt;/a&gt; (Representational state transfer) API programming is writing web applications in any programming language by following 5 basic software &lt;a href=&quot;http://en.wikipedia.org/wiki/Architectural_style&quot;&gt;architectural style&lt;/a&gt; principles:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;RESTful&lt;/a&gt; （表示状态传输）API编程通过遵循以下5种基本软件&lt;a href=&quot;http://en.wikipedia.org/wiki/Architectural_style&quot;&gt;体系结构样式&lt;/a&gt;原则，以任何编程语言编写Web应用程序：</target>
        </trans-unit>
        <trans-unit id="68ce364743640c5c8da066039ef67fefbcdfea99" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface&quot;&gt;Uniform interface&lt;/a&gt; - use simple and standard interface (HTTP).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface&quot;&gt;统一接口&lt;/a&gt; -使用简单和标准接口（HTTP）。</target>
        </trans-unit>
        <trans-unit id="fc1b3e08e8f98d28090f1f9117f6298bc58e4d4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Stateless_protocol&quot;&gt;Stateless&lt;/a&gt; (every request happens in complete isolation, it's easier to cache and load-balance),</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Stateless_protocol&quot;&gt;无状态的&lt;/a&gt; （每个请求都是完全隔离的，因此更易于缓存和负载均衡），</target>
        </trans-unit>
        <trans-unit id="129cb3c37d52f357725b109610381bd678a81b64" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://herbjorn.wordpress.com/2010/11/19/rest-versus-soap-for-the-public-cloud/&quot;&gt;REST versus SOAP for the Public Cloud&lt;/a&gt; discusses the current levels of REST usage.</source>
          <target state="translated">&lt;a href=&quot;http://herbjorn.wordpress.com/2010/11/19/rest-versus-soap-for-the-public-cloud/&quot;&gt;REST与SOAP for Public Cloud&lt;/a&gt;讨论了REST使用的当前级别。</target>
        </trans-unit>
        <trans-unit id="01d4ccbe57dba207b3756864c380f7e8c5cec68f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://kinderman.net/2010/06/23/approaching-pure-rest-learning-to-love-hateoas&quot;&gt;Approaching pure REST: Learning to love HATEOAS&lt;/a&gt; is a good collection of links.</source>
          <target state="translated">&lt;a href=&quot;http://kinderman.net/2010/06/23/approaching-pure-rest-learning-to-love-hateoas&quot;&gt;接近纯REST：学会爱HATEOAS&lt;/a&gt;是一个很好的链接集合。</target>
        </trans-unit>
        <trans-unit id="71c672309538bece163ea3ed6fdde78bae549263" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;The term RESTful was created because ppl exhausted the word REST by calling their non-REST application as REST.&lt;/a&gt; After that the term RESTful was exhausted as well. &lt;a href=&quot;http://www.markus-lanthaler.com/research/third-generation-web-apis-bridging-the-gap-between-rest-and-linked-data.pdf&quot;&gt;Nowadays we are talking about Web APIs and Hypermedia APIs&lt;/a&gt;, because the most of the so called REST applications did not fulfill the HATEOAS part of the uniform interface constraint.</source>
          <target state="translated">&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;之所以创建RESTful是因为ppl通过将非REST应用程序称为REST来用尽REST一词。&lt;/a&gt; 之后，RESTful一词也被用尽。 &lt;a href=&quot;http://www.markus-lanthaler.com/research/third-generation-web-apis-bridging-the-gap-between-rest-and-linked-data.pdf&quot;&gt;如今，我们正在谈论Web API和Hypermedia API&lt;/a&gt; ，因为大多数所谓的REST应用程序并未满足统一接口约束的HATEOAS部分。</target>
        </trans-unit>
        <trans-unit id="ee92cfd1a1d0fac1b4085c977902cee08a3f0004" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife&quot;&gt;How I explained REST to my wife&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife&quot;&gt;我如何向妻子解释REST&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fd6a95880b9724e9be2ebb234578d30f5200563" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.innoq.com/blog/st/2010/07/rest_litmus_test_for_web_frame.html&quot;&gt;REST Litmus Test for Web Frameworks&lt;/a&gt; is a similar maturity test for web frameworks.</source>
          <target state="translated">&lt;a href=&quot;http://www.innoq.com/blog/st/2010/07/rest_litmus_test_for_web_frame.html&quot;&gt;针对Web框架的REST Litmus Test是针对Web框架&lt;/a&gt;的类似成熟度测试。</target>
        </trans-unit>
        <trans-unit id="b82de9194c2626af47b20dbf29253c8eab541c11" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.xfront.com/REST.ppt&quot;&gt;http://www.xfront.com/REST.ppt&lt;/a&gt; or &lt;a href=&quot;http://www.xfront.com/REST.html&quot;&gt;http://www.xfront.com/REST.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.xfront.com/REST.ppt&quot;&gt;http://www.xfront.com/REST.ppt&lt;/a&gt;或&lt;a href=&quot;http://www.xfront.com/REST.html&quot;&gt;http://www.xfront.com/REST.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="581df4eb5c8f47005fba4eaff2c31e62dc854f5b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.google.com/present/view?id=dd4bk538_182f55p5x3f&amp;amp;ndplr=1&quot;&gt;REST and versioning&lt;/a&gt; discusses Extensibility, Versioning, Evolvability, etc.
 through Modifiability</source>
          <target state="translated">&lt;a href=&quot;https://docs.google.com/present/view?id=dd4bk538_182f55p5x3f&amp;amp;ndplr=1&quot;&gt;REST和版本&lt;/a&gt;控制通过可修改性讨论了可扩展性，版本控制，可扩展性等。</target>
        </trans-unit>
        <trans-unit id="38b751418200783443a4e1aa6fb491b6a5b8367d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;From Wikipedia&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;从维基百科&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="b092bbc5dae2d2facc4cdcbac80f4fca0862b1a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;REST&lt;/em&gt; is the underlying architectural principle of the web. The amazing thing about the web is the fact that clients (browsers) and servers can interact in complex ways without the client knowing anything beforehand about the server and the resources it hosts. The key constraint is that the server and client must both agree on the &lt;em&gt;media&lt;/em&gt; used, which in the case of the web is &lt;em&gt;HTML&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;REST&lt;/em&gt;是Web的基础架构原理。 关于Web的神奇之处在于，客户端（浏览器）和服务器可以以复杂的方式进行交互，而无需客户端事先了解有关服务器及其托管资源的任何信息。 关键约束是服务器和客户端都必须在所使用的&lt;em&gt;媒体&lt;/em&gt;上达成共识，在网络上为&lt;em&gt;HTML&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="75836654a91c2003a610250aa33fea51aed04694" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Talking&lt;/em&gt; is more than simply &lt;em&gt;exchanging information&lt;/em&gt;. A Protocol is actually designed so that no talking has to occur. Each party knows what their particular job is because it is specified in the protocol. Protocols allow for pure information exchange at the expense of having any changes in the possible actions. Talking, on the other hand, allows for one party to ask what further actions can be taken from the other party. They can even ask the same question twice and get two different answers, since the State of the other party may have changed in the interim. &lt;strong&gt;Talking is RESTful architecture&lt;/strong&gt;. Fielding's thesis specifies the architecture that one would have to follow if one wanted to allow machines to &lt;em&gt;talk&lt;/em&gt; to one another rather than simply &lt;em&gt;communicate&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;谈话&lt;/em&gt;不只是&lt;em&gt;交换信息&lt;/em&gt; 。 实际上，设计了一个协议，因此不必讲话。 各方都知道他们的特定工作是什么，因为它是在协议中指定的。 协议允许进行纯信息交换，但要以可能的动作进行任何更改为代价。 另一方面，交谈允许一方询问可以从另一方采取什么进一步的措施。 他们甚至可以问同样的问题两次，并得到两个不同的答案，因为在此期间对方的国家可能已经改变。 &lt;strong&gt;谈论的是RESTful体系结构&lt;/strong&gt; 。 菲尔丁的论文详细说明了如果要允许机器彼此&lt;em&gt;通信&lt;/em&gt;而不是简单地进行&lt;em&gt;通信&lt;/em&gt; ，就必须遵循的体系结构。</target>
        </trans-unit>
        <trans-unit id="047b453da1539c81d5d318bedbdeb493589d50ab" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;a href=&quot;http://www.looah.com/source/view/2284&quot;&gt;How I explained REST to my wife&lt;/a&gt;.&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;&lt;a href=&quot;http://www.looah.com/source/view/2284&quot;&gt;我如何向妻子解释REST&lt;/a&gt; 。&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="a5cbf477e28c39bdfd209ebf60137a160a48aa33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4 Commonly Used API Methods:-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4种常用的API方法：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a292b42aebab7e4f8f0a4cef5109e82538c81c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTTP methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTTP方法：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c887aa651a0b1255f5b4be4a6d0d7111e108eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Idempotence&lt;/strong&gt;: &lt;a href=&quot;http://programmers.stackexchange.com/questions/23386/pros-and-cons-of-restful-architecture&quot;&gt;An often-overlooked part of REST is the idempotency of most verbs. That leads to &lt;strong&gt;robust systems and less interdependency&lt;/strong&gt; of exact interpretations of the semantics&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;幂等&lt;/strong&gt; ： &lt;a href=&quot;http://programmers.stackexchange.com/questions/23386/pros-and-cons-of-restful-architecture&quot;&gt;REST中经常被忽略的部分是大多数动词的幂等。&lt;/a&gt; 这导致了&lt;strong&gt;健壮的系统，并减少&lt;/strong&gt;了语义精确解释的&lt;strong&gt;相互依赖&lt;/strong&gt;性 。</target>
        </trans-unit>
        <trans-unit id="e19e144b463c1477631bed87f6cf59ac2feabcb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST API&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;REST API&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4016ad50e00a712f9fc46d47dae34627a47b0c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST&lt;/strong&gt; is an architectural style which is based on web-standards and the HTTP protocol (introduced in 2000).</source>
          <target state="translated">&lt;strong&gt;REST&lt;/strong&gt;是一种基于Web标准和HTTP协议（于2000年引入）的体系结构样式。</target>
        </trans-unit>
        <trans-unit id="f470c92afeb4f87674886ef73e25bccf93d40bda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST&lt;/strong&gt; stands for &lt;strong&gt;Representational state transfer&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;REST&lt;/strong&gt;代表&lt;strong&gt;代表性状态转移&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c34758fefce5857b0652a67c95f80db96a7e9ace" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Request&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Request&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8301b7897b69c57632cd67112cbd903a929c2bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Response&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Response&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9026e434b313962901c5fd34080061d3114f6c95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, how does this apply to &lt;em&gt;HTTP&lt;/em&gt;, and how can it be implemented in practice?&lt;/strong&gt; HTTP is oriented around verbs and resources. The two verbs in mainstream usage are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;, which I think everyone will recognize. However, the HTTP standard defines several others such as &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt;. These verbs are then applied to resources, according to the instructions provided by the server.</source>
          <target state="translated">&lt;strong&gt;那么，这如何适用于&lt;em&gt;HTTP&lt;/em&gt;以及如何在实践中实现？&lt;/strong&gt; HTTP围绕动词和资源。 主流用法中的两个动词是 &lt;code&gt;GET&lt;/code&gt; 和 &lt;code&gt;POST&lt;/code&gt; ，我想每个人都会意识到。 但是，HTTP标准定义了其他几种，例如 &lt;code&gt;PUT&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 。 然后根据服务器提供的指示将这些动词应用于资源。</target>
        </trans-unit>
        <trans-unit id="63a42af1bd9b39bddf0ce1be8356d0a2fdb888e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Statelessness&lt;/strong&gt; is misleading. It is about the restful API, not the application or system. The system needs to be stateful. Restful design is about designing a stateful system based on a stateless API. Some &lt;a href=&quot;http://programmers.stackexchange.com/questions/120716/difference-between-rest-and-crud&quot;&gt;quotes from another QA&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;无国籍&lt;/strong&gt;是一种误导。 它与宁静的API有关，与应用程序或系统无关。 系统必须是有状态的。 宁静的设计是关于基于无状态API设计有状态系统。 &lt;a href=&quot;http://programmers.stackexchange.com/questions/120716/difference-between-rest-and-crud&quot;&gt;来自其他质量检查的&lt;/a&gt;一些报价 ：</target>
        </trans-unit>
        <trans-unit id="4c1222e90317ba27d02c65621a259eda932152bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Steps to Test API Manually:-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;手动测试API的步骤：-&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a168c28310824470d0a6b65e2fc1846ae47767c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is another &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;very good post&lt;/a&gt; which explains things nicely.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;还有一个&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;很好的帖子&lt;/a&gt; ，很好地解释了事情。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f23059a3c1ff462600affe32ac77f6c06e198cd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is &lt;a href=&quot;http://testingalert.com/api-testing/api-manual/&quot;&gt;API Testing&lt;/a&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么是&lt;a href=&quot;http://testingalert.com/api-testing/api-manual/&quot;&gt;API测试&lt;/a&gt; ？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bdfd2ece2c06305906caea45c528dd7bf39e1081" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is REST?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么是REST？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34c0a9562e8fed523993c8b4e5719d3ee3daa073" translate="yes" xml:space="preserve">
          <source>A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user&amp;rsquo;s manipulation of those representations. The transitions may be determined (or limited by) the client&amp;rsquo;s knowledge of media types and resource communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand).</source>
          <target state="translated">在输入REST API之前，除了初始URI（书签）和适合目标受众（即，可能会使用该API的任何客户端都希望理解）的一组标准化媒体类型外，应该没有其他任何知识。 从那时起，所有应用程序状态转换必须由客户端选择服务器提供的选择来驱动，这些选择出现在接收到的表示中或由用户对这些表示的操纵来暗示。 过渡可以由客户端对媒体类型和资源通信机制的了解来确定（或受其限制），这两者都可以动态地（例如，按需编码）进行改进。</target>
        </trans-unit>
        <trans-unit id="1036e82ff72398f19dae7159de008a4b11524acc" translate="yes" xml:space="preserve">
          <source>A REST API should spend almost all of its descriptive effort in
  defining the media type(s) used for representing resources and driving
  application state, or in defining extended relation names and/or
  hypertext-enabled mark-up for existing standard media types.</source>
          <target state="translated">一个REST API应该把几乎所有的描述性工作都花在定义用于表示资源和驱动应用状态的媒体类型上,或者定义扩展的关系名称和现有标准媒体类型的超文本标记上。</target>
        </trans-unit>
        <trans-unit id="091580d9e598bff76e8f95009cca43640abadd8b" translate="yes" xml:space="preserve">
          <source>A client of a RESTful application need
  only know a single fixed URL to access
  it. All future actions should be
  discoverable dynamically from
  hypermedia links included in the
  representations of the resources that
  are returned from that URL.
  Standardized media types are also
  expected to be understood by any
  client that might use a RESTful API. 
  (From Wikipedia, the free encyclopedia)</source>
          <target state="translated">一个RESTful应用程序的客户端只需要知道一个固定的URL就可以访问它。未来的所有操作都应该可以从该URL返回的资源表示中包含的超媒体链接中动态发现。任何可能使用RESTful API的客户端也应该能够理解标准化的媒体类型。(摘自维基百科,自由百科全书)</target>
        </trans-unit>
        <trans-unit id="b199b8ec3c349cace004db8b56b1161860b9581b" translate="yes" xml:space="preserve">
          <source>A great book on REST is &lt;a href=&quot;http://www.amazon.co.uk/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829&quot;&gt;REST in Practice&lt;/a&gt;.</source>
          <target state="translated">关于REST的一本很棒的书是&lt;a href=&quot;http://www.amazon.co.uk/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829&quot;&gt;REST in Practice&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbbdec192b31adde0e04c6c1e638a22c1c3a0509" translate="yes" xml:space="preserve">
          <source>A lot of answers copy/pasted valid information mixing it and adding some confusion. People talk here about levels, about RESTFul URIs(there is not such a thing!), apply HTTP methods GET,POST,PUT ... REST is not about that or not only about that.</source>
          <target state="translated">很多答案抄袭了很多有效的信息,将其混合在一起,增加了一些混乱。人们在这里谈论水平,谈论RESTFul URIs(没有这样的事情!),应用HTTP方法GET,POST,PUT......REST不是关于这一点,也不只是关于这一点。</target>
        </trans-unit>
        <trans-unit id="a9672fbb5a371857625bda2ec07f4fc2c459d533" translate="yes" xml:space="preserve">
          <source>A request for the base resource &lt;code&gt;/&lt;/code&gt; might return something like this:</source>
          <target state="translated">对基本资源的请求 &lt;code&gt;/&lt;/code&gt; 可能返回以下内容：</target>
        </trans-unit>
        <trans-unit id="33311414a6f85a0d4549f88e6f929e587d140695" translate="yes" xml:space="preserve">
          <source>API testing utilizes programming to send calls to the API and get the yield. It testing regards the segment under test as a black box. The objective of API testing is to confirm right execution and blunder treatment of the part preceding its coordination into an application.</source>
          <target state="translated">API测试利用编程向API发送调用并获得收益。它的测试将被测部分视为一个黑匣子。API测试的目的是确认该部分的正确执行和错误处理,然后再将其协调到应用程序中。</target>
        </trans-unit>
        <trans-unit id="17e11e3bc87a626545bcd3ae4e73a6dc9b979e5b" translate="yes" xml:space="preserve">
          <source>After reading the examples, I could see why Ken is saying that REST is hypertext-driven. I'm not actually sure that he's right though, because that /user/123 is a URI that points to a resource, and it's not clear to me that it's unRESTful just because the client knows about it &quot;out-of-band.&quot;</source>
          <target state="translated">看完这些例子,我可以理解为什么Ken说REST是超文本驱动的。其实我不确定他说的是对的,因为那个user123是一个指向资源的URI,而我不清楚,仅仅因为客户端知道它是 &quot;带外 &quot;的,所以它是不REST的。</target>
        </trans-unit>
        <trans-unit id="0ff162ae131fa2cf274f6632a56e1f9816c868de" translate="yes" xml:space="preserve">
          <source>After that, it's easy to fall into debates about adaptations, coding conventions, and best practices.</source>
          <target state="translated">之后,很容易陷入关于改编、编码惯例和最佳实践的争论。</target>
        </trans-unit>
        <trans-unit id="e6213f65245bee16c30cf6760d609e28bd445103" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;architectural style&lt;/strong&gt; called &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;&lt;strong&gt;REST (Representational State Transfer)&lt;/strong&gt;&lt;/a&gt; advocates that web applications should use HTTP as it was &lt;strong&gt;originally envisioned&lt;/strong&gt;. Lookups should use &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; requests. &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; requests&lt;/a&gt; should be used for &lt;strong&gt;mutation, creation, and deletion respectively&lt;/strong&gt;.</source>
          <target state="translated">一种称为&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;&lt;strong&gt;REST（代表性状态传输）&lt;/strong&gt;&lt;/a&gt;的&lt;strong&gt;架构风格&lt;/strong&gt;主张Web应用程序应使用&lt;strong&gt;最初设想的&lt;/strong&gt; HTTP。 查找应使用&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;请求。 &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; ， &lt;code&gt;POST&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 请求&lt;/a&gt;应分别用于&lt;strong&gt;突变，创建和删除&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="23f9e629acbf7586515e2525e29805b2378876e7" translate="yes" xml:space="preserve">
          <source>An API that adheres to the principles of &lt;em&gt;REST&lt;/em&gt; does not require the client to know anything about the structure of the API. Rather, the server needs to provide whatever information the client needs to interact with the service. An &lt;em&gt;HTML form&lt;/em&gt; is an example of this: The server specifies the location of the resource and the required fields. &lt;strong&gt;The browser doesn't know in advance where to submit the information, and it doesn't know in advance what information to submit. Both forms of information are entirely supplied by the server.&lt;/strong&gt; (This principle is called &lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot;&gt;&lt;em&gt;HATEOAS&lt;/em&gt;: Hypermedia As The Engine Of Application State&lt;/a&gt;.)</source>
          <target state="translated">遵循&lt;em&gt;REST&lt;/em&gt;原理的API不需要客户端了解有关API结构的任何信息。 相反，服务器需要提供客户端与服务交互所需的任何信息。 &lt;em&gt;HTML表单&lt;/em&gt;就是这样的一个示例：服务器指定资源的位置和必填字段。 &lt;strong&gt;浏览器不预先知道在哪里提交信息，也不知道要提交什么信息。&lt;/strong&gt; &lt;strong&gt;两种形式的信息完全由服务器提供。&lt;/strong&gt; （此原理称为&lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot;&gt;&lt;em&gt;HATEOAS&lt;/em&gt; ：作为应用程序状态引擎的超媒体&lt;/a&gt; 。）</target>
        </trans-unit>
        <trans-unit id="0572ba17f943d7fd5fc5bebd5022f2239451cc72" translate="yes" xml:space="preserve">
          <source>An application is restful if it provides resources (being the combination of data + state transitions controls) in a media type the client understands</source>
          <target state="translated">如果一个应用程序以客户端能够理解的媒体类型提供资源(数据+状态转换控件的组合),那么它就是安闲的应用程序。</target>
        </trans-unit>
        <trans-unit id="5bd054a830a9ec163da9832cb1d2afde20a52654" translate="yes" xml:space="preserve">
          <source>An excerpt from my talk is about the often referred to richardson maturity model, i don't believe in the levels, you either are RESTful (level 3) or you are not, but what i like to call out about it is what each level does for you on your way to RESTful</source>
          <target state="translated">我演讲中的一个节选是关于经常被提到的Richardson成熟度模型,我不相信等级,你要么是RESTful(第3级),要么不是,但我喜欢指出的是每一个等级对你在通往RESTful的道路上的作用。</target>
        </trans-unit>
        <trans-unit id="2610e51a62b1a490881eef55051e2f6be573a983" translate="yes" xml:space="preserve">
          <source>And even better, there's a clean explanation with simple examples here (the powerpoint is more comprehensive, but you can get most of it in the html version):</source>
          <target state="translated">而且更棒的是,这里有简洁的讲解和简单的例子(powerpoint比较全面,但你可以在html版中得到大部分)。</target>
        </trans-unit>
        <trans-unit id="200c5e79bfe63bed7ea90d31d59e4814bd38015a" translate="yes" xml:space="preserve">
          <source>Bonus answer: No. Unless you're studying software architecture as an academic or designing web services, there's really no reason to have heard the term.</source>
          <target state="translated">奖励答案:不。没有,除非你是学软件架构的,或者是设计Web服务的,否则真的没有理由听过这个词。</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="8db50296564fcc14b8370fbfb576cb5f7a3364bb" translate="yes" xml:space="preserve">
          <source>But the REST architecture doesn&amp;rsquo;t end there! While the above fulfills the basic needs of what we want, we also want to have an architecture that supports high volume traffic since any given server usually handles responses from a number of clients. Thus, we don&amp;rsquo;t want to overwhelm the server by having it remember information about previous requests.</source>
          <target state="translated">但是REST架构还不止于此！ 尽管以上内容满足了我们所需的基本需求，但我们也希望拥有一种支持高流量的体系结构，因为任何给定的服务器通常都处理来自多个客户端的响应。 因此，我们不想让服务器记住有关先前请求的信息而使服务器不堪重负。</target>
        </trans-unit>
        <trans-unit id="c0e841fccec5e52e207c5f9f8aedc87617de3151" translate="yes" xml:space="preserve">
          <source>But to find any given resource and then tell the client where that resource lives, there needs to be a universal way of pointing at resources. This is where Universal Resource Identifiers (URIs) come in; they are basically unique addresses to find the resources.</source>
          <target state="translated">但是,要找到任何给定的资源,然后告诉客户端该资源在哪里,需要有一种通用的方式来指向资源。这就是通用资源标识符(URI)的由来;它们基本上是唯一的地址来寻找资源。</target>
        </trans-unit>
        <trans-unit id="ab9c8d4b22f42d6e20f2de04cee4a87194c9b2ff" translate="yes" xml:space="preserve">
          <source>Cacheable</source>
          <target state="translated">Cacheable</target>
        </trans-unit>
        <trans-unit id="ebdaf0dc221196d242550c9fdcc355ae34b62243" translate="yes" xml:space="preserve">
          <source>Click on send</source>
          <target state="translated">点击发送</target>
        </trans-unit>
        <trans-unit id="85e79360e824842c6393ab95bc2ed066d468e1c8" translate="yes" xml:space="preserve">
          <source>Client&amp;ndash;server</source>
          <target state="translated">Client&amp;ndash;server</target>
        </trans-unit>
        <trans-unit id="9e1c7ac80552b301d4a9e2e0aad43db3dc88701b" translate="yes" xml:space="preserve">
          <source>Code on demand (optional)</source>
          <target state="translated">按需编码(可选)</target>
        </trans-unit>
        <trans-unit id="09134846ea28241f35e0dd02fce269a9982bea7f" translate="yes" xml:space="preserve">
          <source>Create a user with three properties:</source>
          <target state="translated">创建一个有三个属性的用户。</target>
        </trans-unit>
        <trans-unit id="4b2835cc754c6984e507206155e739a1564f8450" translate="yes" xml:space="preserve">
          <source>DELETE removes the resources. The operations are idempotent. They can get repeated without leading to different results.</source>
          <target state="translated">DELETE删除资源。这些操作都是同义词。它们可以得到重复操作,而不会导致不同的结果。</target>
        </trans-unit>
        <trans-unit id="03419256ac96b83abfd7066f861a5015d2ba0ed0" translate="yes" xml:space="preserve">
          <source>DELETE: &amp;ndash; It is used to remove a resource.</source>
          <target state="translated">删除：&amp;ndash;用于删除资源。</target>
        </trans-unit>
        <trans-unit id="5e5b459d45380b093202121fad6f6675d370930c" translate="yes" xml:space="preserve">
          <source>Despite being simple, REST is fully-featured; there's basically
  nothing you can do in Web Services that can't be done with a RESTful
  architecture. REST is not a &quot;standard&quot;. There will never be a W3C
  recommendataion for REST, for example. And while there are REST
  programming frameworks, working with REST is so simple that you can
  often &quot;roll your own&quot; with standard library features in languages like
  Perl, Java, or C#.</source>
          <target state="translated">尽管REST很简单,但它的功能很齐全;在Web Services中,基本上没有什么事情是RESTful架构做不到的。REST不是一个 &quot;标准&quot;。比如说,永远不会有一个W3C推荐的REST标准。虽然有REST编程框架,但使用REST工作是非常简单的,你往往可以用Perl、Java或C#等语言中的标准库功能 &quot;卷起你自己的&quot;。</target>
        </trans-unit>
        <trans-unit id="b8d49819767eebe1ba51b6e1ff800c7bff7f706e" translate="yes" xml:space="preserve">
          <source>Edit: Two more important aspects:</source>
          <target state="translated">编辑:还有两个重要的方面。</target>
        </trans-unit>
        <trans-unit id="cc4bbb1317907e63ed80955856990adc8e7cbbe4" translate="yes" xml:space="preserve">
          <source>Enter Request JSON (POST)</source>
          <target state="translated">输入 Request JSON (POST)</target>
        </trans-unit>
        <trans-unit id="ab911d488e200ceacb5e406e1fe7b3000216de7c" translate="yes" xml:space="preserve">
          <source>Enter the API URL</source>
          <target state="translated">输入API URL</target>
        </trans-unit>
        <trans-unit id="800300af0e99da4a9ab4e50e0ad740ebb248a62c" translate="yes" xml:space="preserve">
          <source>Every resource should support the HTTP common operations. Resources are identified by global IDs (which are typically URIs).</source>
          <target state="translated">每个资源都应该支持HTTP通用操作。资源通过全局ID(通常是URI)来识别资源。</target>
        </trans-unit>
        <trans-unit id="ae6c811f24cef30ab608149e77398fe7dc2aa93f" translate="yes" xml:space="preserve">
          <source>Explaining REST and Hypertext: Spam-E the Spam Cleaning Robot</source>
          <target state="translated">解释REST和超文本。Spam-E-垃圾邮件清理机器人</target>
        </trans-unit>
        <trans-unit id="4c2e0eda7987cd96af30a22725f03cbbfc4b115a" translate="yes" xml:space="preserve">
          <source>For example links - it is nice to have a beautifully looking API but at the end the client/server does not really care of the links you get/send it is the content that matters.</source>
          <target state="translated">例如链接----有一个漂亮的API是很好的,但最后客户端服务器并不关心你得到的链接,重要的是内容。</target>
        </trans-unit>
        <trans-unit id="040c10648e6eb948c9d8e9d90c4d5f137fae46d2" translate="yes" xml:space="preserve">
          <source>For example there is a client layer which contains the clients and below that there is a service layer which contains a single service. Now you can add a client side cache between them. After that you can add another service instance and a load balancer, and so on... The client code and the service code won't change.</source>
          <target state="translated">比如说有一个客户机层,其中包含了客户机,下面是服务层,包含一个服务。现在,你可以在它们之间添加一个客户端缓存。之后你可以添加另一个服务实例和负载均衡器,以此类推...。客户端代码和服务代码不会改变。</target>
        </trans-unit>
        <trans-unit id="4edba5a49c7a4414557ee46319d87498dbeae513" translate="yes" xml:space="preserve">
          <source>For example when a client wants to send an order to a webshop, then it have to check the hyperlinks in the responses sent by the webshop. By checking the links it founds one described with the &lt;a href=&quot;http://schema.org/OrderAction&quot;&gt;http://schema.org/OrderAction&lt;/a&gt;. The client know the schema.org vocab, so it understands that by activating this hyperlink it will send the order. So it activates the hyperlink and sends a &lt;code&gt;POST https://example.com/api/v1/order&lt;/code&gt; message with the proper body. After that the service processes the message and responds with the result having the proper HTTP status header, for example &lt;code&gt;201 - created&lt;/code&gt; by success. To annotate messages with detailed metadata the standard solution to use an RDF format, for example &lt;a href=&quot;http://json-ld.org/&quot;&gt;JSON-LD&lt;/a&gt; with a REST vocab, for example &lt;a href=&quot;http://www.markus-lanthaler.com/hydra/&quot;&gt;Hydra&lt;/a&gt; and domain specific vocabs like &lt;a href=&quot;http://schema.org/&quot;&gt;schema.org&lt;/a&gt; or any other &lt;a href=&quot;http://lov.okfn.org/dataset/lov/&quot;&gt;linked data vocab&lt;/a&gt; and maybe a custom application specific vocab if needed. Now this is not easy, that's why most ppl use HAL and other simple formats which usually provide only a REST vocab, but no linked data support.</source>
          <target state="translated">例如，当客户想要向网上商店发送订单时，则必须检查网上商店发送的响应中的超链接。 通过检查链接，它找到了一个用&lt;a href=&quot;http://schema.org/OrderAction&quot;&gt;http://schema.org/OrderAction&lt;/a&gt;描述的链接。 客户端知道schema.org vocab，因此它了解通过激活此超链接将发送订单。 因此，它将激活超链接并发送带有适当正文的 &lt;code&gt;POST https://example.com/api/v1/order&lt;/code&gt; 消息。 此后，服务将处理该消息，并以具有正确HTTP状态标头（例如成功 &lt;code&gt;201 - created&lt;/code&gt; 的201）的结果进行响应。 为了用详细的元数据注释消息，使用RDF格式的标准解决方案，例如使用REST词汇的&lt;a href=&quot;http://json-ld.org/&quot;&gt;JSON-LD&lt;/a&gt; ，例如&lt;a href=&quot;http://www.markus-lanthaler.com/hydra/&quot;&gt;Hydra&lt;/a&gt;和特定于域的词汇，例如&lt;a href=&quot;http://schema.org/&quot;&gt;schema.org&lt;/a&gt;或任何其他&lt;a href=&quot;http://lov.okfn.org/dataset/lov/&quot;&gt;链接的数据词汇&lt;/a&gt; ，如果可能的话，还可以定制特定于应用程序的词汇需要。 现在这并不容易，这就是为什么大多数ppl使用HAL和其他简单格式（通常仅提供REST vocab，但不提供链接数据支持）的原因。</target>
        </trans-unit>
        <trans-unit id="519a503f187cd31038f7706dcd1d8a0887042f78" translate="yes" xml:space="preserve">
          <source>For example, Let's imagine that we have a user database that is managed by a web service. Our service uses a custom hypermedia based on JSON, for which we assign the mimetype &lt;code&gt;application/json+userdb&lt;/code&gt; (There might also be an &lt;code&gt;application/xml+userdb&lt;/code&gt; and &lt;code&gt;application/whatever+userdb&lt;/code&gt; - many media types may be supported). The client and the server have both been programmed to understand this format, but they don't know anything about each other. As &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Roy Fielding&lt;/a&gt; points out:</source>
          <target state="translated">例如，假设我们有一个由Web服务管理的用户数据库。 我们的服务使用基于JSON的自定义超媒体，为此我们为其分配了mimetype &lt;code&gt;application/json+userdb&lt;/code&gt; （可能还有 &lt;code&gt;application/xml+userdb&lt;/code&gt; 和 &lt;code&gt;application/whatever+userdb&lt;/code&gt; -可能支持许多媒体类型）。 客户端和服务器都经过编程可以理解这种格式，但是彼此之间一无所知。 正如&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Roy Fielding&lt;/a&gt;指出的那样：</target>
        </trans-unit>
        <trans-unit id="29ff533a59385e46befeb9d1d442ce81cde883fb" translate="yes" xml:space="preserve">
          <source>For example, instead a set of URLs which might look like some of the following..</source>
          <target state="translated">例如,相反,一组URL可能看起来像下面的一些URL......</target>
        </trans-unit>
        <trans-unit id="ce3d305d56ec5c6ee26c71725d770976054d26b3" translate="yes" xml:space="preserve">
          <source>For sending and receiving messages, it involves using HTTP methods, and it does not require a strict message definition, unlike Web services.</source>
          <target state="translated">对于消息的发送和接收,它涉及到使用HTTP方法,与Web服务不同,它不需要严格的消息定义。</target>
        </trans-unit>
        <trans-unit id="096bafb1ad02c5e340fc0cffb7efac1d03c6fdd6" translate="yes" xml:space="preserve">
          <source>Further reading:</source>
          <target state="translated">进一步阅读:</target>
        </trans-unit>
        <trans-unit id="ae09a97e20415e22fe1f93eb6fbb98ed8d14de81" translate="yes" xml:space="preserve">
          <source>GET defines a reading access of the resource without side-effects. The resource is never changed via a GET request, e.g., the request has no side effects (idempotent).</source>
          <target state="translated">GET定义了对资源的读取访问,没有副作用。该资源永远不会通过GET请求改变,例如,该请求没有副作用(idempotent)。</target>
        </trans-unit>
        <trans-unit id="c4c41d24d5f2a151608ed14ff7819f6f47a5271f" translate="yes" xml:space="preserve">
          <source>GET: &amp;ndash; It provides read only access to a resource.</source>
          <target state="translated">GET：&amp;ndash;它提供对资源的只读访问。</target>
        </trans-unit>
        <trans-unit id="5e04d05de713337d37ea8308533c814f117ef859" translate="yes" xml:space="preserve">
          <source>Given this view point, the rest style is not really tied to internet or web application. It's a fundamental solution to many of the programming situations. It is not simple either, it just makes the interface really simple, and copes with other technologies amazingly well.</source>
          <target state="translated">考虑到这个观点,休息风格其实和互联网或Web应用并没有什么关系。它可以从根本上解决很多编程的情况。它也不简单,它只是把界面做得真的很简单,而且应对其他技术的能力也很惊人。</target>
        </trans-unit>
        <trans-unit id="413e85dd36b6612ff8f3b552ddd4ae973747eb10" translate="yes" xml:space="preserve">
          <source>Here is my basic outline of REST. I tried to demonstrate the thinking behind each of the components in a RESTful architecture so that understanding the concept is more intuitive. Hopefully this helps demystify REST for some people!</source>
          <target state="translated">以下是我对REST的基本概述。我尝试着演示了RESTful架构中每个组件背后的思想,这样理解这个概念会更直观。希望这能帮助一些人解开REST的神秘面纱!</target>
        </trans-unit>
        <trans-unit id="c419bb60824d17f1c8fc3f5f0378842579d5c500" translate="yes" xml:space="preserve">
          <source>I apologize if I'm not answering the question directly, but it's easier to understand all this with more detailed examples. Fielding is not easy to understand due to all the abstraction and terminology.</source>
          <target state="translated">如果我没有直接回答这个问题,我很抱歉,但如果有了更详细的例子,就会更容易理解这一切。Fielding因为有很多抽象和专业术语,所以不容易理解。</target>
        </trans-unit>
        <trans-unit id="087ec8b5ab0cac5efee7be73a08f41b5611d251f" translate="yes" xml:space="preserve">
          <source>I define restful programming as</source>
          <target state="translated">我将restful编程定义为</target>
        </trans-unit>
        <trans-unit id="ee52bb4671d83e94060d7610bdd9bf819906adce" translate="yes" xml:space="preserve">
          <source>I don't think you should feel stupid for not hearing about REST outside Stack Overflow..., I would be in the same situation!; answers to this other SO question on &lt;a href=&quot;https://stackoverflow.com/q/243388/463478&quot;&gt;Why is REST getting big now&lt;/a&gt; could ease some feelings.</source>
          <target state="translated">我不认为您没有在Stack Overflow之外没有听说过REST会感到愚蠢&amp;hellip;&amp;hellip;我会处于同样的情况！ 关于&lt;a href=&quot;https://stackoverflow.com/q/243388/463478&quot;&gt;REST为什么现在变得如此庞大的&lt;/a&gt;另一个SO问题的答案可能会缓解一些感觉。</target>
        </trans-unit>
        <trans-unit id="6c76368a522ebb58d381771d2b88fa3b274443e2" translate="yes" xml:space="preserve">
          <source>I found this fantastic, short, and easy to understand tutorial about REST by Dr. M. Elkstein and quoting the essential part that would answer your question for the most part:</source>
          <target state="translated">我发现这个神奇的、简短的、容易理解的REST教程由M.Elkstein博士撰写,并引用了最基本的部分,可以回答你的问题。</target>
        </trans-unit>
        <trans-unit id="6d8108db9657b6e64ef934ab59dc6f7fa01dcc70" translate="yes" xml:space="preserve">
          <source>I see a bunch of answers that say putting everything about user 123 at resource &quot;/user/123&quot; is RESTful.</source>
          <target state="translated">我看到一堆答案说,把关于用户123的一切都放在资源 &quot;user123 &quot;是RESTful。</target>
        </trans-unit>
        <trans-unit id="763841bd5f36269041a09b4b998b89fbb9e2caff" translate="yes" xml:space="preserve">
          <source>I think that the most important trick to understanding the architectural importance and performance implications of a RESTful and &lt;a href=&quot;http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf&quot;&gt;Shared Nothing&lt;/a&gt; architectures is to avoid getting hung up on the technology and implementation details. Concentrate on who owns resources, who is responsible for creating/maintaining them, etc. Then think about the representations, protocols, and technologies.</source>
          <target state="translated">我认为理解RESTful和无&lt;a href=&quot;http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf&quot;&gt;共享&lt;/a&gt;架构的体系结构重要性和性能含义的最重要技巧是避免陷入技术和实现细节上。 专注于谁拥有资源，谁负责创建/维护资源等，然后考虑表示形式，协议和技术。</target>
        </trans-unit>
        <trans-unit id="d0530a0292feea24c4a9346fcd870c5d42a8ef18" translate="yes" xml:space="preserve">
          <source>I think the point of restful is the &lt;strong&gt;separation of the statefulness into a higher layer&lt;/strong&gt; while making use of the internet (protocol) as a &lt;strong&gt;stateless transport layer&lt;/strong&gt;. Most other approaches mix things up.</source>
          <target state="translated">我认为，重点在于&lt;strong&gt;将有状态性分离到更高的层，&lt;/strong&gt;同时利用互联网（协议）作为&lt;strong&gt;无状态传输层&lt;/strong&gt; 。 大多数其他方法将事情混在一起。</target>
        </trans-unit>
        <trans-unit id="c322421456d9bf2c2db73cb8c6cdc0e978e2f5ea" translate="yes" xml:space="preserve">
          <source>I would say RESTful programming would be about creating systems (API) that follow the REST architectural style.</source>
          <target state="translated">我想说的是,RESTful编程是关于创建遵循REST架构风格的系统(API)。</target>
        </trans-unit>
        <trans-unit id="7efc17b40148a3f7a450c659d22a107b0159fbac" translate="yes" xml:space="preserve">
          <source>I would say that an important building block in understanding REST lies in the endpoints or mappings, such as &lt;code&gt;/customers/{id}/balance&lt;/code&gt;.</source>
          <target state="translated">我想说，理解REST的重要组成部分在于端点或映射，例如 &lt;code&gt;/customers/{id}/balance&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00c15a6f862dfb4e67e15e8fab5e3217684aa057" translate="yes" xml:space="preserve">
          <source>I'm not looking to self promote, but i expand on these ideas to great depth in my talk &lt;a href=&quot;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&quot;&gt;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&lt;/a&gt; .</source>
          <target state="translated">我不想自我提升，但我会在我的演讲&lt;a href=&quot;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&quot;&gt;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html中&lt;/a&gt;深入探讨这些想法。</target>
        </trans-unit>
        <trans-unit id="c54b01044e3ae27d309c48efbe56fe8b30a02fdb" translate="yes" xml:space="preserve">
          <source>IMO:</source>
          <target state="translated">IMO:</target>
        </trans-unit>
        <trans-unit id="528e227c40908c4c76424c153287878418391881" translate="yes" xml:space="preserve">
          <source>If I had to reduce the original dissertation on REST to just 3 short sentences, I think the following captures its essence:</source>
          <target state="translated">如果非要我把原来关于REST的论文缩减为3个短句,我想下面这句话能抓住它的精髓。</target>
        </trans-unit>
        <trans-unit id="3e4a789505499d4ebc9acf09affff2580e66a8db" translate="yes" xml:space="preserve">
          <source>If you are really interested in what a RESTful architecture is and why it works, read &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;his thesis&lt;/a&gt; a few times and read the &lt;strong&gt;whole thing&lt;/strong&gt; not just Chapter 5! Next look into &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;why DNS works&lt;/a&gt;. Read about the hierarchical organization of DNS and how referrals work. Then read and consider how DNS caching works. Finally, read the HTTP specifications (&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; in particular) and consider how and why the caching works the way that it does. Eventually, it will just click. The final revelation for me was when I saw the similarity between DNS and HTTP. After this, understanding why SOA and Message Passing Interfaces are scalable starts to click.</source>
          <target state="translated">如果您真的对RESTful架构是什么以及它为什么起作用感兴趣，请阅读&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;他的论文&lt;/a&gt;几次，并完整地阅读&lt;strong&gt;整个内容，&lt;/strong&gt;而不仅仅是第5章！ 接下来研究&lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;DNS为什么起作用&lt;/a&gt; 。 阅读有关DNS的层次结构以及引用如何工作的信息。 然后阅读并考虑DNS缓存如何工作。 最后，阅读HTTP规范（特别是&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;和&lt;a href=&quot;http://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; ），并考虑缓存如何以及为什么以这种方式工作。 最终，它只会单击。 对我来说，最后的启示是当我看到DNS和HTTP之间的相似之处时。 此后，开始理解为什么可以扩展SOA和消息传递接口。</target>
        </trans-unit>
        <trans-unit id="5c9c0f1f96e6c661dd2c0857fa65fd08bb396af3" translate="yes" xml:space="preserve">
          <source>In a REST based architecture you have a REST server which provides
  access to the resources. A REST client can access and modify the REST
  resources.</source>
          <target state="translated">在一个基于REST的架构中,你有一个REST服务器,它提供对资源的访问。一个REST客户端可以访问和修改REST资源。</target>
        </trans-unit>
        <trans-unit id="2a7fcadf01fdd539dc00964a4063d163ad342bf9" translate="yes" xml:space="preserve">
          <source>In a REST based architecture, everything is a resource(Users, Orders, Comments). A resource is accessed via a common interface based on the HTTP standard methods(GET, PUT, PATCH, DELETE etc).</source>
          <target state="translated">在一个基于REST的架构中,所有的东西都是一个资源(用户、订单、评论)。资源是通过一个基于HTTP标准方法(GET、PUT、PATCH、DELETE等)的通用接口访问的。</target>
        </trans-unit>
        <trans-unit id="81af6a9f5471cbc482ac157847e6af8a50d7537f" translate="yes" xml:space="preserve">
          <source>In computing, representational state transfer (REST) is an
  architectural style used for web development.</source>
          <target state="translated">在计算中,表示式状态转移(REST)是一种用于Web开发的架构风格。</target>
        </trans-unit>
        <trans-unit id="508381eb480015bf82a7312e0cfb8e350127a358" translate="yes" xml:space="preserve">
          <source>In many ways, the World Wide Web itself, based on HTTP, can be viewed
  as a REST-based architecture. RESTful applications use HTTP requests
  to post data (create and/or update), read data (e.g., make queries),
  and delete data. Thus, REST uses HTTP for all four CRUD
  (Create/Read/Update/Delete) operations.</source>
          <target state="translated">在许多方面,基于HTTP的万维网本身,可以看成是一个基于REST的架构。RESTful应用程序使用HTTP请求来发布数据(创建和或更新)、读取数据(例如,进行查询)和删除数据。因此,REST使用HTTP进行所有四种CRUD(CreateReadUpdateDelete)操作。</target>
        </trans-unit>
        <trans-unit id="9afec0b39286ce35f8ff306c75875ec463e27211" translate="yes" xml:space="preserve">
          <source>In many ways, the World Wide Web itself, based on HTTP, can be viewed    as a REST-based architecture.</source>
          <target state="translated">在很多方面,基于HTTP的万维网本身,可以看成是一种基于REST的架构。</target>
        </trans-unit>
        <trans-unit id="d7d9b177727972b7bd403cb1d9830e8972f6ccaf" translate="yes" xml:space="preserve">
          <source>In other words you're writing simple point-to-point network applications over HTTP which uses verbs such as GET, POST, PUT or DELETE by implementing RESTful architecture which proposes standardization of the interface each &amp;ldquo;resource&amp;rdquo; exposes. It is nothing that using current features of the web in a simple and effective way (highly successful, proven and distributed architecture). It is an alternative to more complex mechanisms like &lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture&quot;&gt;CORBA&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt;.</source>
          <target state="translated">换句话说，您正在通过HTTP编写简单的点对点网络应用程序，该应用程序通过实现RESTful体系结构来使用GET，POST，PUT或DELETE等动词，该体系结构建议了每个&amp;ldquo;资源&amp;rdquo;公开的接口的标准化。 以简单有效的方式（高度成功，经过验证的分布式架构）使用Web的当前功能并不是什么。 它是诸如&lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt; ， &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture&quot;&gt;CORBA&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC之&lt;/a&gt;类的更复杂机制的替代方法。</target>
        </trans-unit>
        <trans-unit id="9075c88ba609ac32ad4853adceff80a57b9c8848" translate="yes" xml:space="preserve">
          <source>In the end &lt;strong&gt;any RESTful client should be able to consume to any RESTful service as long as the content format is known.&lt;/strong&gt;</source>
          <target state="translated">最后&lt;strong&gt;，只要知道内容格式，任何RESTful客户端都应该能够使用任何RESTful服务。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6435852cb4e96cc87686e94b5374a8056f393527" translate="yes" xml:space="preserve">
          <source>In the future, you can then retrieve the user information:</source>
          <target state="translated">日后,就可以检索到用户信息了。</target>
        </trans-unit>
        <trans-unit id="d6ecb449599f6dd2f5e9713553e3cd31fe1f0435" translate="yes" xml:space="preserve">
          <source>Install POSTMAN(Chrome) / REST(Firefox) plugin</source>
          <target state="translated">安装POSTMAN(Chrome)REST(Firefox)插件</target>
        </trans-unit>
        <trans-unit id="6a6d9700ec195facf4fac9e8b95e37072828dc22" translate="yes" xml:space="preserve">
          <source>Interestingly, there is no mention of HTTP POST, GET, DELETE, or PUT operations in the dissertation. That must be someone's later interpretation of a &quot;best practice&quot; for a &quot;uniform interface&quot;.</source>
          <target state="translated">有趣的是,论文中并没有提到HTTP的POST、GET、DELET、PUT操作。这一定是后来有人对 &quot;统一接口 &quot;的 &quot;最佳实践 &quot;的解释。</target>
        </trans-unit>
        <trans-unit id="f9de0a4336192b307d47a7bd6e45e0eaef080436" translate="yes" xml:space="preserve">
          <source>Introduction about Rest</source>
          <target state="translated">关于休息的介绍</target>
        </trans-unit>
        <trans-unit id="b9c999a74770669b9c8ffb4ad17078f65b2cda93" translate="yes" xml:space="preserve">
          <source>It relies on a stateless, client-server, cacheable communications protocol -- and in virtually all cases, the HTTP protocol is used.</source>
          <target state="translated">它依赖于一个无状态、客户端-服务器、可缓存的通信协议---几乎在所有情况下,都使用了HTTP协议。</target>
        </trans-unit>
        <trans-unit id="1117236a998be55f80d560abd424de90ea9e2991" translate="yes" xml:space="preserve">
          <source>It will return output response</source>
          <target state="translated">它将返回输出响应</target>
        </trans-unit>
        <trans-unit id="c89e148b7af16b441451c1995bfe2abaf6361908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an arrangement of functions on which the testers performs requests and receive responses. In REST API interactions are made via HTTP protocol.</source>
          <target state="translated">测试人员在此功能上执行请求并接收响应。 在REST API中，交互是通过HTTP协议进行的。</target>
        </trans-unit>
        <trans-unit id="f0fc1358f601de6b260eab812260ed0430f7e282" translate="yes" xml:space="preserve">
          <source>It's been the best practical approach to handle the fundamental changes of programming in internet era. Regarding the fundamental changes, Erik Meijer has a discussion on show here: &lt;a href=&quot;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&quot;&gt;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&lt;/a&gt; . He summarizes it as the five effects, and presents a solution by designing the solution into a programming language. The solution, could also be achieved in the platform or system level, regardless of the language. The restful could be seen as one of the solutions that has been very successful in the current practice.</source>
          <target state="translated">这是处理互联网时代编程的根本变化的最佳实践方法。 关于基本更改，Erik Meijer在此处进行了一场讨论： &lt;a href=&quot;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&quot;&gt;http&lt;/a&gt; : //www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197 。 他将其概括为五个效果，并通过将解决方案设计为编程语言来提出解决方案。 无论使用哪种语言，都可以在平台或系统级别上实现该解决方案。 宁静可被视为当前实践中非常成功的解决方案之一。</target>
        </trans-unit>
        <trans-unit id="d4929d90be24c95c993943d45502f80422e27a62" translate="yes" xml:space="preserve">
          <source>It's programming where the architecture of your system fits the &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;REST style&lt;/a&gt; laid out by Roy Fielding in &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;his thesis&lt;/a&gt;. Since this is the architectural style that describes the web (more or less), lots of people are interested in it.</source>
          <target state="translated">在程序设计中，系统的体系结构适合Roy Fielding在&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;其论文中提出&lt;/a&gt;的&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;REST风格&lt;/a&gt; 。 由于这是描述Web的建筑风格（或多或少），因此许多人对此感兴趣。</target>
        </trans-unit>
        <trans-unit id="9e58b34ecd5fe46f5c7fac142a7753476a694f3e" translate="yes" xml:space="preserve">
          <source>JSON is not restful programming</source>
          <target state="translated">JSON不是安逸的编程</target>
        </trans-unit>
        <trans-unit id="a6b85e0f041b2c7697f401797ec1377054a290db" translate="yes" xml:space="preserve">
          <source>Just my 2c.</source>
          <target state="translated">只是我的2c。</target>
        </trans-unit>
        <trans-unit id="bbe8d64fcde25a40febca185bf5ef63d774333ce" translate="yes" xml:space="preserve">
          <source>Keep in mind that GET requests should never be used for updating information. For example, a GET request for adding an item to a cart</source>
          <target state="translated">请记住,GET请求绝对不能用于更新信息。例如,在购物车中添加一个项目的GET请求</target>
        </trans-unit>
        <trans-unit id="5f82e7663dd4156cb07776cb1cea89dd1aba1b01" translate="yes" xml:space="preserve">
          <source>Layered system</source>
          <target state="translated">分层系统</target>
        </trans-unit>
        <trans-unit id="133b041c9729c525d972a67420b5a147370536ad" translate="yes" xml:space="preserve">
          <source>Learn REST: A Tutorial</source>
          <target state="translated">学习REST。教程</target>
        </trans-unit>
        <trans-unit id="d48495a4077a6c79d43f781b565680695cf2d342" translate="yes" xml:space="preserve">
          <source>Martin Fowler's
thoughts</source>
          <target state="translated">Martin Fowler的想法</target>
        </trans-unit>
        <trans-unit id="de83e0aeb9afb13ea59f9bf7102b93ccfae94aaa" translate="yes" xml:space="preserve">
          <source>Metadata is passed as name-value pairs (post data and query string parameters).</source>
          <target state="translated">元数据作为名-值对(post数据和查询字符串参数)传递。</target>
        </trans-unit>
        <trans-unit id="b45afbd2f6f71f5bbf40bc713d36b1cb5591272d" translate="yes" xml:space="preserve">
          <source>Must reads are &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Representational State Transfer (REST)&lt;/a&gt; and &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIs must be hypertext-driven&lt;/a&gt;</source>
          <target state="translated">必须读取的是&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;代表性状态传输（REST），&lt;/a&gt;并且&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST API必须是超文本驱动的&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75117da5ea6dd4a55238ac032ebaaa4e06e4091c" translate="yes" xml:space="preserve">
          <source>Notice that we are using different HTTP verbs (&lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; etc.) to manipulate these resources, and that the only knowledge we presume on the client's part is our media definition.</source>
          <target state="translated">请注意，我们正在使用不同的HTTP动词（ &lt;code&gt;GET&lt;/code&gt; ， &lt;code&gt;PUT&lt;/code&gt; ， &lt;code&gt;POST&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; 等）来操纵这些资源，并且我们假定客户端唯一的知识就是媒体定义。</target>
        </trans-unit>
        <trans-unit id="83b061b2a63b8f2183eb1bdcdd47faa9c5345256" translate="yes" xml:space="preserve">
          <source>Now, if all of this sounds familiar, then great. The Hypertext Transfer Protocol (HTTP), which defines the communication protocol via the World Wide Web is an implementation of the abstract notion of RESTful architecture (or an instance of the REST class if you're an OOP fanatic like me). In this implementation of REST, the client and server interact via GET, POST, PUT, DELETE, etc., which are part of the universal language and the resources can be pointed to using URLs.</source>
          <target state="translated">现在,如果这些听起来都很熟悉,那就太好了。超文本传输协议(HTTP),它定义了通过万维网的通信协议,是RESTful架构(如果你是像我这样的OOP狂热者,那么就是REST类的一个实例)的抽象概念的实现。在这种REST的实现中,客户端和服务器通过GET、POST、PUT、DELETE等方式进行交互,这些都是通用语言的一部分,资源可以使用URL来指向。</target>
        </trans-unit>
        <trans-unit id="e1a9621fd53f3f752aff5f25b313a5a3c60c684e" translate="yes" xml:space="preserve">
          <source>Old question, newish way of answering.  There's a lot of misconception out there about this concept.  I always try to remember:</source>
          <target state="translated">老问题,新的回答方式。外面有很多关于这个概念的误区。我一直在努力记住。</target>
        </trans-unit>
        <trans-unit id="438027d47ce1c5a96c385f53eecd236c425fb2b5" translate="yes" xml:space="preserve">
          <source>One of the best reference I found when I try to find the simple real meaning of rest.</source>
          <target state="translated">这是我在努力寻找休息的简单真实意义时,发现的最好的参考之一。</target>
        </trans-unit>
        <trans-unit id="c6f2d9e5ea80ff9b7b9ded9e2a81fb5f446691e1" translate="yes" xml:space="preserve">
          <source>POST updates an existing resource or creates a new resource.</source>
          <target state="translated">POST更新现有资源或创建新资源。</target>
        </trans-unit>
        <trans-unit id="d742711b2a6bd7b769816a15fa5a239a2c74f940" translate="yes" xml:space="preserve">
          <source>POST: &amp;ndash; It is used to create or update a new resource.</source>
          <target state="translated">POST：&amp;ndash;用于创建或更新新资源。</target>
        </trans-unit>
        <trans-unit id="37e0818cbbbc83b5f7771a4d5dfae0eb226e31e7" translate="yes" xml:space="preserve">
          <source>PUT creates a new resource. It must also be idempotent.</source>
          <target state="translated">PUT创建一个新资源。它也必须是同质化的。</target>
        </trans-unit>
        <trans-unit id="ada2743b893defbc7c8ab2a60424b669dd79a22b" translate="yes" xml:space="preserve">
          <source>PUT: &amp;ndash; It is used to update or replace an existing resource or create a new resource.</source>
          <target state="translated">PUT：&amp;ndash;用于更新或替换现有资源或创建新资源。</target>
        </trans-unit>
        <trans-unit id="675a94eb09e6d971c2a74e502df85b0396498a6f" translate="yes" xml:space="preserve">
          <source>PayPal's API has hypermedia controls</source>
          <target state="translated">PayPal的API有超媒体控制</target>
        </trans-unit>
        <trans-unit id="330809f2cc51f1c140e1980086142c16a9addb97" translate="yes" xml:space="preserve">
          <source>Principle 1: Everything is a Resource
In the REST architectural style, data and functionality are considered resources and are accessed using Uniform Resource Identifiers (URIs), typically links on the Web.</source>
          <target state="translated">原则1:一切都是资源 在REST的架构风格中,数据和功能被认为是资源,并使用统一资源标识符(URI)进行访问,通常是Web上的链接。</target>
        </trans-unit>
        <trans-unit id="8c699adbd41e9b331e5fbd3c027ab2582737eb63" translate="yes" xml:space="preserve">
          <source>Principle 2: Every Resource is Identified by a Unique Identifier (URI)</source>
          <target state="translated">原则2:每一种资源都有一个唯一的标识符(URI)来识别。</target>
        </trans-unit>
        <trans-unit id="b612f5757ab3b67dcdf0fc959e4a1f2295c39bfc" translate="yes" xml:space="preserve">
          <source>Principle 3: Use Simple and Uniform Interfaces</source>
          <target state="translated">原则3:使用简单、统一的界面</target>
        </trans-unit>
        <trans-unit id="1c4054641d8394bb16320893dba0d8f48d910d14" translate="yes" xml:space="preserve">
          <source>Principle 4: Communication is Done by Representation</source>
          <target state="translated">原则4:沟通是通过代表来完成的</target>
        </trans-unit>
        <trans-unit id="52e149151dd57ddc7a1edcf0a393bb8fc2cc1dc9" translate="yes" xml:space="preserve">
          <source>Principle 5: Be Stateless</source>
          <target state="translated">原则5:无状态</target>
        </trans-unit>
        <trans-unit id="3b6ad19884af654ebfaa84e23196de80335cb4c9" translate="yes" xml:space="preserve">
          <source>Protocols are limited to what you can communicate by using URLs.</source>
          <target state="translated">协议限制了你使用URL所能通信的内容。</target>
        </trans-unit>
        <trans-unit id="ea0905504dfdf615e0862b8f2c6ac34fbc396c3b" translate="yes" xml:space="preserve">
          <source>REST (Representational State Transfer) is a design architecture that outlines how networked resources (i.e. nodes that share information) are designed and addressed. In general, a RESTful architecture makes it so that the client (the requesting machine) and the server (the responding machine) can request to read, write, and update data without the client having to know how the server operates and the server can pass it back without needing to know anything about the client. Okay, cool...but how do we do this in practice?</source>
          <target state="translated">REST(Representational State Transfer)是一种设计架构,概述了网络资源(即共享信息的节点)的设计和处理方式。一般来说,RESTful架构使得客户端(请求机)和服务器(响应机)可以请求读取、写入和更新数据,而客户端不需要知道服务器是如何操作的,服务器也不需要知道客户端的任何事情就可以把数据传回来。好吧,很酷...........但是在实际操作中,我们该怎么做呢?</target>
        </trans-unit>
        <trans-unit id="700c9dae20f56bed7f78e92f023ff70ce8630a9f" translate="yes" xml:space="preserve">
          <source>REST === HTTP analogy is not correct until you do not stress to the fact that it &quot;MUST&quot; be &lt;a href=&quot;http://restfulapi.net/hateoas/&quot;&gt;HATEOAS&lt;/a&gt; driven.</source>
          <target state="translated">REST === HTTP类比是不正确的，除非您不强调它&amp;ldquo;必须&amp;rdquo;由&lt;a href=&quot;http://restfulapi.net/hateoas/&quot;&gt;HATEOAS&lt;/a&gt;驱动。</target>
        </trans-unit>
        <trans-unit id="8d900533fc0307874766ce99858e2dca6a98b0ed" translate="yes" xml:space="preserve">
          <source>REST allows that resources have different representations, e.g., text, XML, JSON etc. The REST client can ask for a specific representation via the HTTP protocol (content negotiation).</source>
          <target state="translated">REST允许资源有不同的表示方式,如文本、XML、JSON等。REST客户端可以通过HTTP协议(内容协商)请求特定的表示方式。</target>
        </trans-unit>
        <trans-unit id="d7e35d79a67bcd2fd91ce8bbd613ef5c12223b40" translate="yes" xml:space="preserve">
          <source>REST also permits communication between computers with each other over a network.</source>
          <target state="translated">REST还允许计算机之间通过网络相互通信。</target>
        </trans-unit>
        <trans-unit id="7bebea77f381f6a449770f9552c88ba86e2ca2da" translate="yes" xml:space="preserve">
          <source>REST constraints result a highly scalable system in where the clients are decoupled from the implementations of the services. So the clients can be reusable, general just like the browsers on the web. The clients and the services share the same standards and vocabs, so they can understand each other despite the fact that the client does not know the implementation details of the service. This makes possible to create automated clients which can find and utilize REST services to achieve their goals. In long term these clients can communicate to each other and trust each other with tasks, just like humans do. If we add learning patterns to such clients, then the result will be one or more AI using the web of machines instead of a single server park. So at the end the dream of Berners Lee: the semantic web and the artificial intelligence will be reality. So in 2030 we end up terminated by the Skynet. Until then ... ;-)</source>
          <target state="translated">REST约束产生了一个高度可扩展的系统,在这个系统中,客户机与服务的实现是解耦的。因此,客户端可以重用,就像网络上的浏览器一样。客户端和服务共享相同的标准和词汇表,所以尽管客户端不知道服务的实现细节,但它们可以相互理解。这使得创建自动客户端成为可能,这些客户端可以找到并利用REST服务来实现他们的目标。从长远来看,这些客户端可以像人类一样,相互之间进行交流,并信任对方的任务。如果我们在这样的客户端中加入学习模式,那么结果将是一个或多个AI使用机器网络,而不是单一的服务器园区。所以最终伯纳斯-李的梦想:语义网和人工智能将成为现实。所以在2030年,我们最终会被天网终结。在那之前....;-)</target>
        </trans-unit>
        <trans-unit id="34698ed4c6b87bbba6909fe832abf0a97a18c1e4" translate="yes" xml:space="preserve">
          <source>REST defines 6 architectural constraints which make any web service &amp;ndash; a &lt;strong&gt;true RESTful API&lt;/strong&gt;.</source>
          <target state="translated">REST定义了6种架构约束，这些约束使得任何Web服务都成为&lt;strong&gt;真正的RESTful API&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b8ff55c8c9a0ce9cfafc137b16baaa14a81abbf" translate="yes" xml:space="preserve">
          <source>REST in official words, REST is an architectural style built on certain principles using the current &amp;ldquo;Web&amp;rdquo; fundamentals.
There are 5 basic fundamentals of web which are leveraged to create REST services.</source>
          <target state="translated">用REST的官方术语来说，REST是一种使用当前&amp;ldquo; Web&amp;rdquo;基础知识以某些原则为基础的建筑风格。 Web具有5个基本基础，可用于创建REST服务。</target>
        </trans-unit>
        <trans-unit id="24e5aabd86f26882f23d01381f1a89f3a170449f" translate="yes" xml:space="preserve">
          <source>REST is a lightweight alternative to mechanisms like RPC (Remote
  Procedure Calls) and Web Services (SOAP, WSDL, et al.). Later, we will
  see how much more simple REST is.</source>
          <target state="translated">REST是RPC(远程过程调用)和Web服务(SOAP、WSDL等)等机制的轻量级替代方案。稍后,我们将看到REST到底有多简单。</target>
        </trans-unit>
        <trans-unit id="41d578dc3834d7de2f8d99a70b26c5ce81a848f5" translate="yes" xml:space="preserve">
          <source>REST is an &lt;em&gt;architecture style&lt;/em&gt; for designing networked applications.
  The idea is that, rather than using complex mechanisms such as CORBA,
  RPC or SOAP to connect between machines, simple HTTP is used to make
  calls between machines.</source>
          <target state="translated">REST是用于设计网络应用程序的&lt;em&gt;体系结构样式&lt;/em&gt; 。 这个想法是，与其使用诸如CORBA，RPC或SOAP之类的复杂机制在机器之间进行连接，不如使用简单的HTTP来在机器之间进行调用。</target>
        </trans-unit>
        <trans-unit id="81954ff90e3db76a59f3feac17fcae16db3073fb" translate="yes" xml:space="preserve">
          <source>REST is an architectural pattern and style of writing distributed applications. It is not a programming style in the narrow sense.</source>
          <target state="translated">REST是一种编写分布式应用的架构模式和风格。它不是一种狭义的编程风格。</target>
        </trans-unit>
        <trans-unit id="6e3584ec485599f05ec62cb2d6b674b68d8c649a" translate="yes" xml:space="preserve">
          <source>REST is an architecture style for designing networked applications.
  The idea is that, rather than using complex mechanisms such as CORBA,
  RPC or SOAP to connect between machines, simple HTTP is used to make
  calls between machines.</source>
          <target state="translated">REST是一种用于设计网络化应用的架构风格。其思想是,与其使用复杂的机制,如CORBA、RPC或SOAP来连接机器之间,不如使用简单的HTTP来进行机器之间的调用。</target>
        </trans-unit>
        <trans-unit id="6663bc679f3ecc9321597d4c451eda8a030d5e82" translate="yes" xml:space="preserve">
          <source>REST is often used in mobile applications, social networking Web sites, mashup tools and automated business processes. The REST style emphasizes that interactions between clients and services is enhanced by having a limited number of operations (verbs). Flexibility is provided by assigning resources (nouns) their own unique universal resource indicators (URIs).</source>
          <target state="translated">REST经常被用于移动应用、社交网络网站、混搭工具和自动化业务流程中。REST 风格强调客户和服务之间的交互,通过有限的操作(动词)来增强客户和服务之间的交互。通过给资源(名词)分配自己独特的通用资源指标(URI),提供了灵活性。</target>
        </trans-unit>
        <trans-unit id="801d3af1b3e139b50282c4fab565cd444620074b" translate="yes" xml:space="preserve">
          <source>REST is using the various HTTP methods (mainly GET/PUT/DELETE) to manipulate data.</source>
          <target state="translated">REST是利用各种HTTP方法(主要是GETPUTDELETE)来操作数据。</target>
        </trans-unit>
        <trans-unit id="3a544da22b9e3f4d834aba2d28e038cfc7c394d2" translate="yes" xml:space="preserve">
          <source>REST messages often accepts the form either in form of XML, or JavaScript Object Notation (JSON).</source>
          <target state="translated">REST消息通常以XML或JavaScript Object Notation(JSON)的形式接受。</target>
        </trans-unit>
        <trans-unit id="ec356ddaca2bf110584184b56abbca5c18c7f324" translate="yes" xml:space="preserve">
          <source>REST proponents tend to favor URLs, such as</source>
          <target state="translated">REST的拥护者倾向于使用URL,如</target>
        </trans-unit>
        <trans-unit id="cdaffecf9a4b409c44dd9af81374c459b9474d48" translate="yes" xml:space="preserve">
          <source>REST stands for &quot;representational state transfer&quot;, which means it's all about communicating and modifying &lt;strong&gt;the state&lt;/strong&gt; of some resource in a system.</source>
          <target state="translated">REST代表&amp;ldquo;代表性状态转移&amp;rdquo;，这意味着它全部与通信和修改系统中某些资源&lt;strong&gt;的状态&lt;/strong&gt;有关。</target>
        </trans-unit>
        <trans-unit id="9451e5791b00a17503496c3f9586128ae49e1831" translate="yes" xml:space="preserve">
          <source>REST stands for Representational State Transfer. (It is sometimes
  spelled &quot;ReST&quot;.) It relies on a stateless, client-server, cacheable
  communications protocol -- and in virtually all cases, the HTTP
  protocol is used.</source>
          <target state="translated">REST是Representational State Transfer的缩写。它依赖于一个无状态、客户端-服务器、可缓存的通信协议 ----几乎在所有情况下,都使用HTTP协议。</target>
        </trans-unit>
        <trans-unit id="3d1d7194413fe6b5bd76ca3ce8b73781e5ea0578" translate="yes" xml:space="preserve">
          <source>REST unlike home styles has had a tough time being consistently and practically applied. This may have been intentional. Leaving its actual implementation up to the designer. So you are free to do what you want so as long as you meet the constraints set out in the dissertation you are creating REST Systems.</source>
          <target state="translated">REST不像家居风格,一直以来都很难被坚持和实际应用。这可能是有意为之。把它的实际实现留给了设计者。因此,只要你在创建REST系统时满足论文中规定的约束条件,你可以自由地做你想做的事情。</target>
        </trans-unit>
        <trans-unit id="4ac191e5aa73c941d92cf5c5a7bdc101ccf17488" translate="yes" xml:space="preserve">
          <source>REST, operates on resource representations, each one identified by an URL. These are typically not data objects, but &lt;strong&gt;complex objects abstractions&lt;/strong&gt;.</source>
          <target state="translated">REST对资源表示进行操作，每个资源表示由一个URL标识。 这些通常不是数据对象，而是&lt;strong&gt;复杂的对象抽象&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="20bbdde9c5678f79d072b94099e0cd21aa108d71" translate="yes" xml:space="preserve">
          <source>REST: Representational State Transfer.</source>
          <target state="translated">REST。代表性国家转移。</target>
        </trans-unit>
        <trans-unit id="0b418318f4f02e384e5a14b7c46def85c5fbf491" translate="yes" xml:space="preserve">
          <source>RESTful applications use HTTP requests to post data (create and/or
  update), read data (e.g., make queries), and delete data. Thus, REST
  uses HTTP for all four CRUD (Create/Read/Update/Delete) operations.</source>
          <target state="translated">RESTful应用程序使用HTTP请求来发布数据(创建和或更新)、读取数据(例如,进行查询)和删除数据。因此,REST使用HTTP进行所有四种CRUD(CreateReadUpdateDelete)操作。</target>
        </trans-unit>
        <trans-unit id="d1feb4628e89cf3c408102d8d1c78190e38e6958" translate="yes" xml:space="preserve">
          <source>RESTful programming conforms to Web architecture design and, if properly implemented, it allows you to take the full advantage of scalable Web infrastructure.</source>
          <target state="translated">RESTful编程符合Web架构设计,如果实施得当,它可以让你充分利用可扩展的Web基础设施。</target>
        </trans-unit>
        <trans-unit id="606ada79ad1420f9107ba76e74d9a5b5dc8a1dc1" translate="yes" xml:space="preserve">
          <source>RESTful programming is about:</source>
          <target state="translated">RESTful编程是关于。</target>
        </trans-unit>
        <trans-unit id="95c224223718abd56088ba177080385db881b4c6" translate="yes" xml:space="preserve">
          <source>RESTful programming is not for APIs</source>
          <target state="translated">RESTful编程不适合API</target>
        </trans-unit>
        <trans-unit id="1b6a739654e06f630f96467756d48d1acd0d09d0" translate="yes" xml:space="preserve">
          <source>Rather than using a specific URL to delete a method (say, &lt;code&gt;/user/123/delete&lt;/code&gt;), you would send a DELETE request to the &lt;code&gt;/user/[id]&lt;/code&gt; URL, to edit a user, to retrieve info on a user you send a GET request to &lt;code&gt;/user/[id]&lt;/code&gt;</source>
          <target state="translated">您无需使用特定的URL来删除方法（例如 &lt;code&gt;/user/123/delete&lt;/code&gt; ），而是向 &lt;code&gt;/user/[id]&lt;/code&gt; URL发送一个DELETE请求，以编辑用户，检索有关您发送的用户的信息。对 &lt;code&gt;/user/[id]&lt;/code&gt; 的GET请求</target>
        </trans-unit>
        <trans-unit id="7d997a652dd80f71fb70e3ef43e6973ddd897ea7" translate="yes" xml:space="preserve">
          <source>Representation - all communication is done by representation (e.g. &lt;a href=&quot;http://en.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;)</source>
          <target state="translated">表示-所有通信均通过表示（例如&lt;a href=&quot;http://en.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; ）完成</target>
        </trans-unit>
        <trans-unit id="2cd1d833a928d3195b51e6cfbe331c8c09c671dd" translate="yes" xml:space="preserve">
          <source>Resource (data, information).</source>
          <target state="translated">资源(数据、信息):</target>
        </trans-unit>
        <trans-unit id="688688c5509b4d381bf4bce90f16794ddee6aacb" translate="yes" xml:space="preserve">
          <source>Resources are requested via URLs.</source>
          <target state="translated">资源是通过URL请求的。</target>
        </trans-unit>
        <trans-unit id="c171c3ae71443c15b078bb93540e67b075abe63a" translate="yes" xml:space="preserve">
          <source>Richardson's Maturity Model</source>
          <target state="translated">理查德森的成熟度模型</target>
        </trans-unit>
        <trans-unit id="07bef3db6d8f0a971b46410592e99f25edb3d822" translate="yes" xml:space="preserve">
          <source>Roy Fielding, who coined the term, says &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIs must be hypertext-driven&lt;/a&gt;.  In particular, &quot;A REST API must not define fixed resource names or hierarchies&quot;.</source>
          <target state="translated">创造了该术语的Roy Fielding说， &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST API必须是超文本驱动的&lt;/a&gt; 。 特别是，&amp;ldquo; REST API不得定义固定的资源名称或层次结构&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="4ed7f7fd296ad882c584b68eec97a766f06c9204" translate="yes" xml:space="preserve">
          <source>Roy himself cleared it &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">罗伊本人&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;在这里&lt;/a&gt;清除了它。</target>
        </trans-unit>
        <trans-unit id="ea8f1dff43bf90df7c15069182244296157f5ccf" translate="yes" xml:space="preserve">
          <source>Saying that Rest is just a syntactic change from using GET requests with an action parameter to using the available http verbs makes it look like it has no benefits and is purely cosmetic. The point is to use a language that can be understood and optimized by every part of the chain. If your GET operation has an action with side effects, you have to skip all HTTP caching or you'll end up with inconsistent results.</source>
          <target state="translated">说Rest只是语法上的改变,从使用带动作参数的GET请求到使用可用的http动词,这让人觉得它看起来没有任何好处,纯粹是表面文章。问题的关键是使用一种可以被链上的每一个部分理解和优化的语言。如果你的GET操作有一个带副作用的动作,那么你必须跳过所有的HTTP缓存,否则最终的结果会不一致。</target>
        </trans-unit>
        <trans-unit id="c4a2bd1212341d753b25f32677d4e7adf44e6015" translate="yes" xml:space="preserve">
          <source>Saying you use the REST style is similar to saying that you built a house in a particular style: for example Tudor or Victorian.  Both REST as an software style and Tudor or Victorian as a home style can be defined by the qualities and constraints that make them up. For example REST must have Client Server separation where messages are self-describing. Tudor style homes have Overlapping gables and Roofs that are steeply pitched with front facing gables. You can read Roy's dissertation to learn more about the constraints and qualities that make up REST.</source>
          <target state="translated">说你用REST风格,就好比说你用特定的风格建造了一栋房子:比如说都铎式或维多利亚式。作为软件风格的REST和作为家居风格的都铎式或维多利亚式都可以由构成它们的特质和约束来定义。例如REST必须有Client Server分离,其中消息是自我描述的。Tudor风格的住宅有重叠的檐口和屋顶,屋顶是陡峭的坡度,正面朝向的檐口。你可以阅读Roy的论文,了解更多关于构成REST的约束和素质。</target>
        </trans-unit>
        <trans-unit id="8e446171e587e12eabf8b79616dc1eb91a5a4557" translate="yes" xml:space="preserve">
          <source>See Martin Fowlers article the &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;Richardson Maturity Model&lt;/a&gt; (RMM) for an explanation on what an RESTful service is.</source>
          <target state="translated">有关什么是RESTful服务的说明，请参阅Martin Fowlers的&lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;Richardson成熟度模型&lt;/a&gt; （RMM）文章。</target>
        </trans-unit>
        <trans-unit id="fbe751100f5c892656ce1ca4a6009c25fbfc7f4b" translate="yes" xml:space="preserve">
          <source>Select content-Header</source>
          <target state="translated">选择内容-标题</target>
        </trans-unit>
        <trans-unit id="16ed5c31752ac3f8db0119aea87a82b307c230ed" translate="yes" xml:space="preserve">
          <source>Select the REST method</source>
          <target state="translated">选择REST方法</target>
        </trans-unit>
        <trans-unit id="c0c99a62016d0168acb95e1b7c7865a1070d884a" translate="yes" xml:space="preserve">
          <source>So if your &quot;/user/123&quot; path is hardcoded on the client, it's not really RESTful.  A good use of HTTP, maybe, maybe not.  But not RESTful.  It has to come from hypertext.</source>
          <target state="translated">所以,如果你的 &quot;user123 &quot;路径在客户端硬编码了,那就不是真正的RESTful。一个很好的HTTP的使用,也许,也许不是。但不是RESTful。它必须来自于超文本。</target>
        </trans-unit>
        <trans-unit id="536946ca2831340799bf33cd36af457db31978e1" translate="yes" xml:space="preserve">
          <source>So it does not work with for example PUB/SUB sockets, it is based on REQ/REP.</source>
          <target state="translated">因此,它不能与例如PUBSUB插座一起工作,它是基于REQREP。</target>
        </trans-unit>
        <trans-unit id="cb3acf66e66e8ac82b059d304608e2b649d07fd9" translate="yes" xml:space="preserve">
          <source>So the server does not maintain the states of the clients. This means that you cannot use server a side session storage and you have to authenticate every request. Your clients possibly send basic auth headers through an encrypted connection. (By large applications it is hard to maintain many sessions.)</source>
          <target state="translated">所以服务器不维护客户端的状态。这意味着你不能使用服务器端会话存储,你必须对每个请求进行身份验证。你的客户端可能会通过加密连接发送基本的认证头。(通过大型应用很难维护很多会话)。</target>
        </trans-unit>
        <trans-unit id="9607344c01bb579773361b71bbb45cde205cc658" translate="yes" xml:space="preserve">
          <source>So you don't have to serve the same requests again and again.</source>
          <target state="translated">所以,你不必一而再、再而三地服务于同样的要求。</target>
        </trans-unit>
        <trans-unit id="6755df0f56ac5cee70d67ea5c025e47782da8d98" translate="yes" xml:space="preserve">
          <source>State transition controls only make sense if the client and server agree upon a media type representation of the resource.  Otherwise there's no way to know what's a control and what isn't and how to execute a control.  IE if browsers didn't know &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags in html then there'd be nothing for you to submit to transition state in your browser.</source>
          <target state="translated">仅当客户端和服务器同意资源的媒体类型表示形式时，状态转换控件才有意义。 否则，就无法知道什么是控件，什么不是控件以及如何执行控件。 IE，如果浏览器不知道html中的 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 标记，则您无需提交任何内容即可进入浏览器的过渡状态。</target>
        </trans-unit>
        <trans-unit id="cc782a4dc89d3cf79cc09c506daf5966811372c9" translate="yes" xml:space="preserve">
          <source>Stateless</source>
          <target state="translated">Stateless</target>
        </trans-unit>
        <trans-unit id="c2fa7bc4bb797a9f80155f336549e20f8ae9f995" translate="yes" xml:space="preserve">
          <source>Steps to Automate REST API</source>
          <target state="translated">自动化REST API的步骤</target>
        </trans-unit>
        <trans-unit id="266d1df5b50f526d563a69c1948ed69ee2a31597" translate="yes" xml:space="preserve">
          <source>Structured URLs and Http Methods/Verbs are not the definition of
restful programming.</source>
          <target state="translated">结构化URLs和Http MethodsVerbs不是restful编程的定义。</target>
        </trans-unit>
        <trans-unit id="8f7198c3c2d3db3f7cabeab606f0ec990cba16f4" translate="yes" xml:space="preserve">
          <source>That xfront document explains the difference between REST and SOAP, and this is really helpful too. When Fielding says, &quot;&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;That is RPC. It screams RPC.&lt;/a&gt;&quot;, it's clear that RPC is not RESTful, so it's useful to see the exact reasons for this. (SOAP is a type of RPC.)</source>
          <target state="translated">该xfront文档解释了REST和SOAP之间的区别，这确实也很有帮助。 当Fielding说&amp;ldquo; &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;那是RPC。它尖叫着RPC。&lt;/a&gt; &amp;rdquo;时，很明显RPC不是RESTful的，因此了解确切的原因很有用。 （SOAP是一种RPC。）</target>
        </trans-unit>
        <trans-unit id="11640c3d32a9a0b61aeecdb5c9ad7a185581310a" translate="yes" xml:space="preserve">
          <source>The HATEOAS constraint is an acronym
  for Hypermedia as the Engine of
  Application State. This principle is
  the key differentiator between a REST
  and most other forms of client server
  system.</source>
          <target state="translated">HATEOAS约束是Hypermedia as the Engine of Application State的缩写。这个原则是REST和大多数其他形式的客户端服务器系统的关键区别。</target>
        </trans-unit>
        <trans-unit id="6a4c43170c5294cf2068284ddf81b0942eff7050" translate="yes" xml:space="preserve">
          <source>The PUT, GET, POST and DELETE methods are typical used in REST based architectures. The following table gives an explanation of these operations.</source>
          <target state="translated">PUT、GET、POST和DELETE方法是基于REST架构的典型操作。下表给出了这些操作的解释。</target>
        </trans-unit>
        <trans-unit id="debfff33bf7e7352ae30422dd3def567e5f7259f" translate="yes" xml:space="preserve">
          <source>The REST constraints are the following:</source>
          <target state="translated">REST的约束条件如下:</target>
        </trans-unit>
        <trans-unit id="363845c5633e5276f4ad26162098f583201cc8cf" translate="yes" xml:space="preserve">
          <source>The REST system is composed of hierarchical layers. Each layer contains components which use the services of components which are in the next layer below. So you can add new layers and components effortless.</source>
          <target state="translated">REST系统是由分层组成的。每一层都包含了使用下一层组件的服务的组件。所以你可以毫不费力地添加新的层和组件。</target>
        </trans-unit>
        <trans-unit id="5aaa535e7837eae3a4f80e39cfc9d687c46ea8d0" translate="yes" xml:space="preserve">
          <source>The answer is very simple, there is a &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;dissertation&lt;/a&gt; written by Roy Fielding.]&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;1&lt;/a&gt; In that dissertation he defines the REST principles. If an application fulfills all of those principles, then that is a REST application.</source>
          <target state="translated">答案很简单，有Roy Fielding撰写的&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;一篇论文&lt;/a&gt; 。] &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;1&lt;/a&gt;在那篇论文中，他定义了REST原理。 如果一个应用程序满足所有这些原则，那么这就是一个REST应用程序。</target>
        </trans-unit>
        <trans-unit id="4f20d992e77c2fef0f2a4c004149838f65239268" translate="yes" xml:space="preserve">
          <source>The contract between the client and the server is not maintained by the server. In other words the client must be decoupled from the implementation of the service. You can reach this state by using standard solutions, like the IRI (URI) standard to identify resources, the HTTP standard to exchange messages, standard MIME types to describe the body serialization format, metadata (possibly RDF vocabs, microformats, etc.) to describe the semantics of different parts of the message body. To decouple the IRI structure from the client, you have to send hyperlinks to the clients in hypermedia formats like (HTML, JSON-LD, HAL, etc.). So a client can use the metadata (possibly link relations, RDF vocabs) assigned to the hyperlinks to navigate the state machine of the application through the proper state transitions in order to achieve its current goal.</source>
          <target state="translated">客户端和服务器之间的契约不由服务器维护。换句话说,客户端必须与服务的实现解耦。你可以通过使用标准的解决方案来达到这种状态,比如用IRI(URI)标准来标识资源,用HTTP标准来交换消息,用标准的MIME类型来描述体序列化格式,用元数据(可能是RDF vocabs、微格式等)来描述消息体不同部分的语义。为了将IRI结构与客户端解耦,你必须以超媒体格式(HTML、JSON-LD、HAL等)发送超链接给客户端。所以客户端可以使用分配给超链接的元数据(可能是链接关系、RDF vocabs),通过适当的状态转换来导航应用程序的状态机,以实现当前目标。</target>
        </trans-unit>
        <trans-unit id="5eac8561aeea8b795c8a15b197b4655d18a46b3e" translate="yes" xml:space="preserve">
          <source>The entire web is based on REST (or REST was based on the web). Therefore as a web developer you might want aware of that although it's not necessary to write good web apps.</source>
          <target state="translated">整个Web是基于REST(或者说REST是基于Web的)。因此,作为一个web开发者,你可能要意识到这一点,虽然这并不是写出好的web应用的必要条件。</target>
        </trans-unit>
        <trans-unit id="c7820ce4adf25178f490423f73f586fe8480e441" translate="yes" xml:space="preserve">
          <source>The last one is probably the most important in terms of consequences and overall effectiveness of REST. Overall, most of the RESTful discussions seem to center on HTTP and its usage from a browser and what not. I understand that R. Fielding coined the term when he described the architecture and decisions that lead to HTTP. His thesis is more about the architecture and cache-ability of resources than it is about HTTP.</source>
          <target state="translated">从REST的后果和整体效果来看,最后一个可能是最重要的。总的来说,大多数的RESTful讨论似乎都是围绕着HTTP和它的使用情况,从浏览器和其他方面来说。据我了解,R.Fielding在描述导致HTTP的架构和决定的时候,创造了这个词。他的论文更多的是关于资源的架构和缓存能力,而不是HTTP。</target>
        </trans-unit>
        <trans-unit id="b32979991407cd39a66f760547c127248522b7ba" translate="yes" xml:space="preserve">
          <source>The last thing that you&amp;rsquo;ll often here about RESTful architectures is that they are layered. We have actually already been implicitly discussing this requirement in our discussion of the interaction between the client and server. Basically, this means that each layer in our system interacts only with adjacent layers. So in our discussion, the client layer interacts with our server layer (and vice versa), but there might be other server layers that help the primary server process a request that the client does not directly communicate with. Rather, the server passes on the request as necessary.</source>
          <target state="translated">关于RESTful架构，您经常会碰到的最后一件事是它们是分层的。 在讨论客户端和服务器之间的交互时，我们实际上已经在隐式讨论此要求。 基本上，这意味着我们系统中的每一层仅与相邻层交互。 因此，在我们的讨论中，客户端层与服务器层进行交互（反之亦然），但是可能还有其他服务器层可以帮助主服务器处理客户端不直接与之通信的请求。 而是，服务器根据需要传递请求。</target>
        </trans-unit>
        <trans-unit id="3ad594a4eee6f4393aea9d6f9c591653f6d82996" translate="yes" xml:space="preserve">
          <source>The many much better answers on this very page.</source>
          <target state="translated">在这个页面上有很多更好的答案。</target>
        </trans-unit>
        <trans-unit id="f34a56b5b9cc5fb499cc45ca49da52dec1ae7242" translate="yes" xml:space="preserve">
          <source>The most obvious requirement is that there needs to be a universal language of some sort so that the server can tell the client what it is trying to do with the request and for the server to respond.</source>
          <target state="translated">最明显的要求是,需要有一种通用的语言,这样服务器就可以告诉客户端它要对请求做什么,服务器就可以响应。</target>
        </trans-unit>
        <trans-unit id="c1949f81259fdfb5a99b7b1901beff7c9ea4dc3c" translate="yes" xml:space="preserve">
          <source>The point of rest is that if we agree to use a common language for basic operations (the http verbs), the infrastructure can be configured to understand them and optimize them properly, for example, by making use of caching headers to implement caching at all levels.</source>
          <target state="translated">休息的要点是,如果我们同意使用通用的语言来进行基本操作(http动词),那么基础设施就可以通过配置来理解它们,并对它们进行适当的优化,例如,利用缓存头来实现各级缓存。</target>
        </trans-unit>
        <trans-unit id="adcd5a6756875181e58c7a89806bd16236c307a3" translate="yes" xml:space="preserve">
          <source>The server responds:</source>
          <target state="translated">服务器响应。</target>
        </trans-unit>
        <trans-unit id="d84fe7aa11f8f900fefc9b179edc3003cd01912b" translate="yes" xml:space="preserve">
          <source>There is not such notion as &quot;RESTful programming&quot; per se. It would be better called RESTful paradigm or even better RESTful architecture. It is not a programming language. It is a paradigm.</source>
          <target state="translated">没有 &quot;RESTful编程 &quot;这个概念本身。它最好被称为RESTful paradigm,甚至更好的是RESTful architecture。它不是一种编程语言,而是一种范式。它是一种范式。</target>
        </trans-unit>
        <trans-unit id="86c7098a4bc3a5c3742a2441c8884a81a07a366c" translate="yes" xml:space="preserve">
          <source>There's a fairly good example here:</source>
          <target state="translated">这里有一个相当好的例子。</target>
        </trans-unit>
        <trans-unit id="905d4728fcc1cb89a5cb1a3e73d508f59109d989" translate="yes" xml:space="preserve">
          <source>Therefore, we impose the restriction that each request-response pair between the client and the server is independent, meaning that the server doesn&amp;rsquo;t have to remember anything about previous requests (previous states of the client-server interaction) to respond to a new request. This means that we want our interactions to be stateless.</source>
          <target state="translated">因此，我们施加了以下限制：客户端和服务器之间的每个请求-响应对都是独立的，这意味着服务器不必记住有关先前请求（客户端-服务器交互的先前状态）的任何内容即可响应新请求。请求。 这意味着我们希望我们的交互是无状态的。</target>
        </trans-unit>
        <trans-unit id="2a100f405ce7bcd9b4b68b83fcd25889ccf5143e" translate="yes" xml:space="preserve">
          <source>This constraint is optional. For example you can send a parser for a specific media type to the client, and so on... In order to do this you might need a standard plugin loader system in the client, or your client will be coupled to the plugin loader solution.</source>
          <target state="translated">这个约束是可选的。例如你可以给客户端发送一个特定媒体类型的解析器,以此类推.....。为了做到这一点,你可能需要在客户端中安装一个标准的插件加载器系统,或者你的客户端将被耦合到插件加载器方案中。</target>
        </trans-unit>
        <trans-unit id="a433790865d58bd8f02ff1f47ffaf65f408a91fa" translate="yes" xml:space="preserve">
          <source>This is amazingly long &quot;discussion&quot; and yet quite confusing to say the least.</source>
          <target state="translated">这是一个令人惊讶的长篇 &quot;讨论&quot;,但至少也是相当令人困惑的。</target>
        </trans-unit>
        <trans-unit id="03de43a18514c80205249c972ff6f45137f701c5" translate="yes" xml:space="preserve">
          <source>This is taken from the excellent book &lt;em&gt;Core JavaServer faces&lt;/em&gt; book by David M. Geary.</source>
          <target state="translated">这摘自David M. Geary的出色著作《 &lt;em&gt;Core JavaServer Faces&lt;/em&gt; 》。</target>
        </trans-unit>
        <trans-unit id="f84a19d4bf6f78ec8c5e5044a550ad4a25f94cc7" translate="yes" xml:space="preserve">
          <source>This is very less mentioned everywhere but the &lt;strong&gt;Richardson's Maturity Model&lt;/strong&gt; is one of the best methods to actually judge how Restful is one's API. More about it here:</source>
          <target state="translated">这在每个地方都很少被提及，但是&lt;strong&gt;理查森的成熟度模型&lt;/strong&gt;是实际判断一个人的API有多宁静的最佳方法之一。 有关此的更多信息：</target>
        </trans-unit>
        <trans-unit id="d0c1d3305c31f371cda13faed5816c6263e72163" translate="yes" xml:space="preserve">
          <source>This is what it might look like.</source>
          <target state="translated">这可能就是它的样子。</target>
        </trans-unit>
        <trans-unit id="d9c095fa6595fd926bd9860ca44ab7d426923a2d" translate="yes" xml:space="preserve">
          <source>To be RESTful a Service needs to fulfill the &lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot;&gt;Hypermedia as the Engine of Application State. (HATEOAS)&lt;/a&gt;, that is, it needs to reach level 3 in the RMM, &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;read the article&lt;/a&gt; for details or the &lt;a href=&quot;http://www.crummy.com/writing/speaking/2008-QCon/act3.html&quot;&gt;slides from the qcon talk&lt;/a&gt;.</source>
          <target state="translated">为了实现RESTful，服务需要实现&lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot;&gt;Hypermedia作为应用程序状态引擎。&lt;/a&gt; （HATEOAS） ，也就是说，它需要达到RMM中&lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;的第&lt;/a&gt; 3级，请阅读文章以了解详细信息或&lt;a href=&quot;http://www.crummy.com/writing/speaking/2008-QCon/act3.html&quot;&gt;qcon演讲中&lt;/a&gt;的幻灯片 。</target>
        </trans-unit>
        <trans-unit id="43e0b98e4c9a963450bac2bcfe7ffa0f28070108" translate="yes" xml:space="preserve">
          <source>To be a restful programmer you must be trying to build applications that allow actors to do things.  Not just exposing the database.</source>
          <target state="translated">要成为一个安分守己的程序员,你必须努力构建能够让行动者做事的应用程序。而不仅仅是暴露数据库。</target>
        </trans-unit>
        <trans-unit id="88f5ecedd3cc21540bbf662f89334d1c596c1065" translate="yes" xml:space="preserve">
          <source>To further ease the strain on our server from redoing computations that have already been recently done for a given client, REST also allows caching. Basically, caching means to take a snapshot of the initial response provided to the client. If the client makes the same request again, the server can provide the client with the snapshot rather than redo all of the computations that were necessary to create the initial response. However, since it is a snapshot, if the snapshot has not expired--the server sets an expiration time in advance--and the response has been updated since the initial cache (i.e. the request would give a different answer than the cached response), the client will not see the updates until the cache expires (or the cache is cleared) and the response is rendered from scratch again.</source>
          <target state="translated">为了进一步减轻我们的服务器因重做最近已经为某个客户端做的计算而造成的压力,REST还允许缓存。基本上,缓存的意思是对提供给客户端的初始响应进行快照。如果客户端再次提出同样的请求,服务器可以向客户端提供快照,而不是重做所有创建初始响应所需的计算。但是,由于是快照,如果快照还没有过期----服务器提前设置了一个过期时间----而响应在初始缓存后已经被更新了(即请求给出的答案与缓存中的响应不同),那么客户端将不会看到更新,直到缓存过期(或者缓存被清除),并且响应从头开始重新呈现。</target>
        </trans-unit>
        <trans-unit id="3cda008b284e93ee83d27ce556b7f274c5401681" translate="yes" xml:space="preserve">
          <source>To modify the record (&lt;code&gt;lname&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; will remain unchanged):</source>
          <target state="translated">修改记录（ &lt;code&gt;lname&lt;/code&gt; 和 &lt;code&gt;age&lt;/code&gt; 将保持不变）：</target>
        </trans-unit>
        <trans-unit id="2d8872fdf4d794b725b02d84014a91227ec2afee" translate="yes" xml:space="preserve">
          <source>To update the record (and consequently &lt;code&gt;lname&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; will be NULL):</source>
          <target state="translated">要更新记录（因此， &lt;code&gt;lname&lt;/code&gt; 和 &lt;code&gt;age&lt;/code&gt; 将为NULL）：</target>
        </trans-unit>
        <trans-unit id="749827b57c3b48ad912ed3c35f6d888c6b320fd8" translate="yes" xml:space="preserve">
          <source>To use API manually, we can use browser based REST API plugins.</source>
          <target state="translated">要手动使用API,我们可以使用基于浏览器的REST API插件。</target>
        </trans-unit>
        <trans-unit id="cd51d0a7c8a456561603688f8e9d8841d8aeb252" translate="yes" xml:space="preserve">
          <source>Uniform interface</source>
          <target state="translated">统一界面</target>
        </trans-unit>
        <trans-unit id="36445d1f62b3461271018e22e6c63b0da668d74c" translate="yes" xml:space="preserve">
          <source>We also know that we can change existing data:</source>
          <target state="translated">我们也知道,我们可以改变现有的数据。</target>
        </trans-unit>
        <trans-unit id="2da0745a731ffea22c1d0cd224d20dec310fb399" translate="yes" xml:space="preserve">
          <source>We can tell a lot from this response. For instance, we now know we can create a new user by &lt;code&gt;POST&lt;/code&gt;ing to &lt;code&gt;/user&lt;/code&gt;:</source>
          <target state="translated">从这个回应中我们可以看出很多。 例如，我们现在知道可以通过 &lt;code&gt;POST&lt;/code&gt; 到 &lt;code&gt;/user&lt;/code&gt; 创建一个新用户 ：</target>
        </trans-unit>
        <trans-unit id="5441c7839fa6d73dff04b1a5f493f5e5d31a22e7" translate="yes" xml:space="preserve">
          <source>We know from the description of our media that we can find information about related resources from sections called &quot;links&quot;. This is called &lt;em&gt;Hypermedia controls&lt;/em&gt;. In this case, we can tell from such a section that we can find a user list by making another request for &lt;code&gt;/user&lt;/code&gt;:</source>
          <target state="translated">从对媒体的描述中我们知道，我们可以从称为&amp;ldquo;链接&amp;rdquo;的部分中找到有关相关资源的信息。 这称为&lt;em&gt;超媒体控件&lt;/em&gt; 。 在这种情况下，我们可以从这样的部分告诉我们可以通过再次请求 &lt;code&gt;/user&lt;/code&gt; 来找到用户列表：</target>
        </trans-unit>
        <trans-unit id="dbe152bcc052ff53fb476d5537d8e4e55bdd8dee" translate="yes" xml:space="preserve">
          <source>What exactly is RESTful programming</source>
          <target state="translated">究竟什么是RESTful编程</target>
        </trans-unit>
        <trans-unit id="600b595c92145112ec54443d94bd4487770f5001" translate="yes" xml:space="preserve">
          <source>What exactly is RESTful programming?</source>
          <target state="translated">RESTful编程到底是什么?</target>
        </trans-unit>
        <trans-unit id="de97001a3f45e1ab272ba3e7e1ff70234ac18284" translate="yes" xml:space="preserve">
          <source>What is REST?</source>
          <target state="translated">什么是REST?</target>
        </trans-unit>
        <trans-unit id="eda640f0d9d8732bb4f5934942e07911d12c78f5" translate="yes" xml:space="preserve">
          <source>When it comes to web services, it seems that we need some way of distinguishing WSDL and SOAP based architectures which add considerable overhead and arguably much unnecessary complexity to the interface. They also require additional frameworks and developer tools in order to implement. I'm not sure if REST is the best term to distinguish between common-sense interfaces and overly engineered interfaces such as WSDL and SOAP. But we need something.</source>
          <target state="translated">当谈到Web服务时,我们似乎需要某种方式来区分WSDL和SOAP架构,这两种架构会增加大量的开销,而且可以说是给接口增加了很多不必要的复杂性。它们还需要额外的框架和开发者工具来实现。我不确定REST是否是区分常识接口和过度工程化的接口(如WSDL和SOAP)的最佳术语。但是,我们需要一些东西。</target>
        </trans-unit>
        <trans-unit id="a973bdebdbe9ce0f6dcc094fe7f29c9ec500ddfd" translate="yes" xml:space="preserve">
          <source>With a properly implemented restful GET operation, it shouldn't matter if the information comes from your server's DB, your server's memcache, a CDN, a proxy's cache, your browser's cache or your browser's local storage. The fasted, most readily available up to date source can be used.</source>
          <target state="translated">通过一个正确实现的restful GET操作,信息来自于服务器的DB、服务器的memcache、CDN、代理的缓存、浏览器的缓存或浏览器的本地存储,都不重要。可以使用最快、最容易获得的最新信息源。</target>
        </trans-unit>
        <trans-unit id="9516144747f958d35f414712742a6a2ce6a57b18" translate="yes" xml:space="preserve">
          <source>With restful style, you get and manipulate the state of the application across an unreliable internet. If it fails the current operation to get the correct and current state, it needs the zero-validation principal to help the application to continue. If it fails to manipulate the state, it usually uses multiple stages of confirmation to keep things correct. In this sense, rest is not itself a whole solution, it needs the functions in other part of the web application stack to support its working.</source>
          <target state="translated">通过restful风格,你可以通过不可靠的互联网获取和操纵应用程序的状态。如果它在当前操作中失败,无法获得正确的、当前的状态,那么它就需要零确认本钱来帮助应用继续进行。如果操作失败,它通常会使用多个阶段的确认来保持事情的正确性。从这个意义上说,休息本身并不是一个整体的解决方案,它需要Web应用栈中其他部分的函数来支持它的工作。</target>
        </trans-unit>
        <trans-unit id="9be308c8cf75a9d22350774cf74e2e3a25a8019f" translate="yes" xml:space="preserve">
          <source>You can imagine such an endpoint as being the connecting pipeline from the website (front-end) to your database/server (back-end). Using them, the front-end can perform back-end operations which are defined in the corresponding methods of any REST mapping in your application.</source>
          <target state="translated">你可以把这样一个端点想象成从网站(前端)到数据库服务器(后端)的连接管道。使用它们,前端可以执行后端操作,这些操作在你的应用程序中的任何REST映射的相应方法中定义。</target>
        </trans-unit>
        <trans-unit id="908a7dfd19709fb34c01bfe487f5ebb9c2ca9cf8" translate="yes" xml:space="preserve">
          <source>You can summarize(significantly) the constraints to :</source>
          <target state="translated">你可以总结出(显着)的制约因素来。</target>
        </trans-unit>
        <trans-unit id="feb921fa13db1c181a291f33573dbc491b591ad9" translate="yes" xml:space="preserve">
          <source>You use the HTTP &quot;verbs&quot; and have..</source>
          <target state="translated">您使用HTTP的 &quot;动词 &quot;并有.....</target>
        </trans-unit>
        <trans-unit id="3aed90f826f40c49f9ad0c3f63e16bed6d13bf70" translate="yes" xml:space="preserve">
          <source>[Failure here implies that out-of-band information is driving interaction instead of hypertext.]</source>
          <target state="translated">[这里的失败意味着带外信息的驱动力是互动,而不是超文本]。</target>
        </trans-unit>
        <trans-unit id="8e00d08a441958c5870f45fa22543b3d6a03678e" translate="yes" xml:space="preserve">
          <source>build a layered system to increase scalability</source>
          <target state="translated">构建分层系统,提高可扩展性</target>
        </trans-unit>
        <trans-unit id="59c8c8c5991afe8d0a6e42545c71d93e3bff395d" translate="yes" xml:space="preserve">
          <source>but the REST architecture does not require these &quot;pretty URLs&quot;. A GET request with a parameter</source>
          <target state="translated">但REST架构不需要这些 &quot;漂亮的URL&quot;。一个带有参数的GET请求</target>
        </trans-unit>
        <trans-unit id="9f5d22e3a30a84cbccefeb4bd8e5dd35213aaaef" translate="yes" xml:space="preserve">
          <source>clearly communicates the content formats transmitted</source>
          <target state="translated">清楚地传递内容格式</target>
        </trans-unit>
        <trans-unit id="aa2c820849be6fbcb2031a6127c1665b0464c324" translate="yes" xml:space="preserve">
          <source>client-server architecture</source>
          <target state="translated">客户端-服务器架构</target>
        </trans-unit>
        <trans-unit id="8de0a9bc31c843fae99c5bff4c8a379f92283e8b" translate="yes" xml:space="preserve">
          <source>code on demand to extend client functionality</source>
          <target state="translated">点播代码,扩展客户端功能</target>
        </trans-unit>
        <trans-unit id="b275617b42e241876e72514b35301555695e7037" translate="yes" xml:space="preserve">
          <source>is every bit as RESTful.</source>
          <target state="translated">是每个人的RESTful。</target>
        </trans-unit>
        <trans-unit id="0d4997d446840ee0c979e316123915b0a24c6d51" translate="yes" xml:space="preserve">
          <source>maintaining the state in the object and representing the state in the representation</source>
          <target state="translated">维护对象中的状态,并在表征中表示状态</target>
        </trans-unit>
        <trans-unit id="979f4334840cfaebedb96eacee97565f5bf001e6" translate="yes" xml:space="preserve">
          <source>representing the relationships between resources in the representation of the resource: the links between objects are embedded directly in the representation</source>
          <target state="translated">表示资源的表征中的资源之间的关系:对象之间的联系直接嵌入表征中</target>
        </trans-unit>
        <trans-unit id="5e48ef6a8e54320faa23115ae33b087ac321ebec" translate="yes" xml:space="preserve">
          <source>resource representations describe how the representation can be used and under what circumstances it should be discarded/refetched in a consistent manner: usage of HTTP Cache-Control headers</source>
          <target state="translated">资源表示法描述了如何使用表示法,以及在什么情况下应该以一致的方式丢弃refetched:HTTP Cache-Control头的使用方法</target>
        </trans-unit>
        <trans-unit id="e33527bfb73b976a097d9714161c7a07da95577a" translate="yes" xml:space="preserve">
          <source>resources being identified by a persistent identifier: URIs are the ubiquitous choice of identifier these days</source>
          <target state="translated">资源由一个持久性标识符来识别。URI是如今无处不在的标识符选择。</target>
        </trans-unit>
        <trans-unit id="a51e6d20a959c6055335a93c972efc9d39c00a75" translate="yes" xml:space="preserve">
          <source>resources being manipulated using a common set of verbs: HTTP methods are the commonly seen case - the venerable &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Retrieve&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt; becomes &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. But REST is not limited to HTTP, it is just the most commonly used transport right now.</source>
          <target state="translated">使用一组常见的动词来操纵资源：HTTP方法是常见的情况-古老的 &lt;code&gt;Create&lt;/code&gt; ， &lt;code&gt;Retrieve&lt;/code&gt; ， &lt;code&gt;Update&lt;/code&gt; ， &lt;code&gt;Delete&lt;/code&gt; 变为 &lt;code&gt;POST&lt;/code&gt; ， &lt;code&gt;GET&lt;/code&gt; ， &lt;code&gt;PUT&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 。 但是REST不限于HTTP，它只是目前最常用的传输方式。</target>
        </trans-unit>
        <trans-unit id="98b5c511b1e5b3b77e9275fb4452cc5fef44489b" translate="yes" xml:space="preserve">
          <source>respect HTTP specs (if HTTP is used)</source>
          <target state="translated">尊重HTTP规范</target>
        </trans-unit>
        <trans-unit id="c4931fde74816a610a063dd06bd59538b02802b8" translate="yes" xml:space="preserve">
          <source>stateless communication</source>
          <target state="translated">无状态通信</target>
        </trans-unit>
        <trans-unit id="3b878062f43e3c640f44bd52081d0d0dc4278065" translate="yes" xml:space="preserve">
          <source>the actual representation retrieved for a resource is dependent on the request and not the identifier: use Accept headers to control whether you want XML, HTTP, or even a Java Object representing the resource</source>
          <target state="translated">检索到的资源的实际表示方式取决于请求而不是标识符:使用Accept头来控制你是否需要XML、HTTP,甚至是代表资源的Java对象,而不是标识符。</target>
        </trans-unit>
        <trans-unit id="1462755612fc240043fdb2325bffe48c8d0f3f08" translate="yes" xml:space="preserve">
          <source>uniform interface as common contract between client and server</source>
          <target state="translated">统一接口,作为客户和服务器的共同契约</target>
        </trans-unit>
        <trans-unit id="3766fe2c2822ed2ec2c43384fd93c708aa87dded" translate="yes" xml:space="preserve">
          <source>usage of cache if you can</source>
          <target state="translated">缓存的使用,如果可以的话</target>
        </trans-unit>
        <trans-unit id="f96087a197542f55a4ef257f73c9f1cfd69fffd2" translate="yes" xml:space="preserve">
          <source>use hypermedia as the engine of application state</source>
          <target state="translated">使用超媒体作为应用状态的引擎</target>
        </trans-unit>
        <trans-unit id="2626c215ef69fa721ddf1168a1db9e9f9a723d4c" translate="yes" xml:space="preserve">
          <source>would not be appropriate. GET requests should be &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Idempotence&quot;&gt;idempotent&lt;/a&gt;. That is, issuing a request twice should be no different from issuing it once. That's what makes the requests cacheable. An &quot;add to cart&quot; request is not idempotent&amp;mdash;issuing it twice adds two copies of the item to the cart. A POST request is clearly appropriate in this context. Thus, even a &lt;strong&gt;RESTful web application&lt;/strong&gt; needs its share of POST requests.</source>
          <target state="translated">不合适。 GET请求应该是&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Idempotence&quot;&gt;幂等的&lt;/a&gt; 。 也就是说，两次发出请求应该与一次发出请求没有什么不同。 这就是使请求可缓存的原因。 &amp;ldquo;添加到购物车&amp;rdquo;请求不是幂等的-发出两次请求会将该商品的两个副本添加到购物车。 在这种情况下，POST请求显然是合适的。 因此，即使是&lt;strong&gt;RESTful Web应用程序也&lt;/strong&gt;需要其POST请求共享。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
