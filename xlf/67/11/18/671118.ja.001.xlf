<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/671118">
    <body>
      <group id="671118">
        <trans-unit id="4b5f371d067d57adebce0c867d054ff2d3400ab5" translate="yes" xml:space="preserve">
          <source>(This answer has been the subject of a fair amount of criticism for missing the point. For the most part, that has been a fair critique. What I originally described was more in line with how REST was usually implemented a few years ago when I first wrote this, rather than its true meaning. I've revised the answer to better represent the real meaning.)</source>
          <target state="translated">(この回答は、ポイントを外しているということで、かなりの批判の対象となっています。ほとんどの部分では、それは公平な批判でした。私が最初に説明したことは、本当の意味というよりも、私が最初にこれを書いた数年前にRESTがどのように実装されていたかに沿ったものでした。本当の意味をより良く表現するために、回答を修正しました)。</target>
        </trans-unit>
        <trans-unit id="d38acde6c0a007c814e7a8e62db3e40f8b9a8c5d" translate="yes" xml:space="preserve">
          <source>1) There is no such a thing as restful programing, without a big joint and lots of beer :)</source>
          <target state="translated">1)大きなジョッキとたくさんのビールなしでは、安らかなプログラムなんてあり得ない :)</target>
        </trans-unit>
        <trans-unit id="16ed7b2a6cdbe5d413738c42d0ff5485bb59700c" translate="yes" xml:space="preserve">
          <source>2) &lt;strong&gt;Representational State Transfer (REST) is an architectural style specified in &lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;the dissertation of Roy Fielding&lt;/a&gt;.
It has a number of constraints.  If your Service/Client respect those then it is RESTful.&lt;/strong&gt; This is it.</source>
          <target state="translated">2） &lt;strong&gt;Representational State Transfer（REST）は、 &lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Roy Fieldingの論文で&lt;/a&gt;指定された建築スタイルです。&lt;/strong&gt; &lt;strong&gt;これにはいくつかの制約があります。&lt;/strong&gt; &lt;strong&gt;サービス/クライアントがそれらを尊重する場合、それはRESTfulです。&lt;/strong&gt; これです。</target>
        </trans-unit>
        <trans-unit id="27e5dbfce4b7ee29196f5fd4dafe3ca1c0624c58" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;Unique global identifier&lt;/a&gt; (all resources are unique identified by &lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;一意のグローバル識別子&lt;/a&gt; （すべてのリソースは&lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI&lt;/a&gt;によって一意に識別されます）。</target>
        </trans-unit>
        <trans-unit id="1fd9999d07a7fc62861689de4b2bdf6a8fc86768" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;RESTful&lt;/a&gt; (Representational state transfer) API programming is writing web applications in any programming language by following 5 basic software &lt;a href=&quot;http://en.wikipedia.org/wiki/Architectural_style&quot;&gt;architectural style&lt;/a&gt; principles:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;RESTful&lt;/a&gt; （Representational State Transfer ）APIプログラミングは、5つの基本的なソフトウェア&lt;a href=&quot;http://en.wikipedia.org/wiki/Architectural_style&quot;&gt;アーキテクチャスタイルの&lt;/a&gt;原則に従って、任意のプログラミング言語でWebアプリケーションを作成します。</target>
        </trans-unit>
        <trans-unit id="68ce364743640c5c8da066039ef67fefbcdfea99" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface&quot;&gt;Uniform interface&lt;/a&gt; - use simple and standard interface (HTTP).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface&quot;&gt;統一インターフェース&lt;/a&gt; -シンプルで標準的なインターフェース（HTTP）を使用します。</target>
        </trans-unit>
        <trans-unit id="fc1b3e08e8f98d28090f1f9117f6298bc58e4d4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Stateless_protocol&quot;&gt;Stateless&lt;/a&gt; (every request happens in complete isolation, it's easier to cache and load-balance),</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Stateless_protocol&quot;&gt;ステートレス&lt;/a&gt; （すべてのリクエストは完全に分離して発生し、キャッシュと負荷分散が容易です）、</target>
        </trans-unit>
        <trans-unit id="129cb3c37d52f357725b109610381bd678a81b64" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://herbjorn.wordpress.com/2010/11/19/rest-versus-soap-for-the-public-cloud/&quot;&gt;REST versus SOAP for the Public Cloud&lt;/a&gt; discusses the current levels of REST usage.</source>
          <target state="translated">&lt;a href=&quot;http://herbjorn.wordpress.com/2010/11/19/rest-versus-soap-for-the-public-cloud/&quot;&gt;パブリッククラウドのRESTとSOAP&lt;/a&gt;の比較では、RESTの現在の使用レベルについて説明しています。</target>
        </trans-unit>
        <trans-unit id="01d4ccbe57dba207b3756864c380f7e8c5cec68f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://kinderman.net/2010/06/23/approaching-pure-rest-learning-to-love-hateoas&quot;&gt;Approaching pure REST: Learning to love HATEOAS&lt;/a&gt; is a good collection of links.</source>
          <target state="translated">&lt;a href=&quot;http://kinderman.net/2010/06/23/approaching-pure-rest-learning-to-love-hateoas&quot;&gt;純粋なRESTへのアプローチ：HATEOASを愛することを学ぶこと&lt;/a&gt;は、リンクの良いコレクションです。</target>
        </trans-unit>
        <trans-unit id="71c672309538bece163ea3ed6fdde78bae549263" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;The term RESTful was created because ppl exhausted the word REST by calling their non-REST application as REST.&lt;/a&gt; After that the term RESTful was exhausted as well. &lt;a href=&quot;http://www.markus-lanthaler.com/research/third-generation-web-apis-bridging-the-gap-between-rest-and-linked-data.pdf&quot;&gt;Nowadays we are talking about Web APIs and Hypermedia APIs&lt;/a&gt;, because the most of the so called REST applications did not fulfill the HATEOAS part of the uniform interface constraint.</source>
          <target state="translated">&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;RESTfulという用語は、pplがREST以外のアプリケーションをRESTとして呼び出すことによってRESTという単語を使い果たしたために作成されました。&lt;/a&gt; その後、RESTfulという用語も使い果たされました。 いわゆるRESTアプリケーションのほとんどが、統一されたインターフェース制約のHATEOASの部分を満たしていないため、 &lt;a href=&quot;http://www.markus-lanthaler.com/research/third-generation-web-apis-bridging-the-gap-between-rest-and-linked-data.pdf&quot;&gt;現在はWeb APIとハイパーメディアAPIについて話している&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee92cfd1a1d0fac1b4085c977902cee08a3f0004" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife&quot;&gt;How I explained REST to my wife&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife&quot;&gt;RESTを妻に説明した方法&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fd6a95880b9724e9be2ebb234578d30f5200563" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.innoq.com/blog/st/2010/07/rest_litmus_test_for_web_frame.html&quot;&gt;REST Litmus Test for Web Frameworks&lt;/a&gt; is a similar maturity test for web frameworks.</source>
          <target state="translated">&lt;a href=&quot;http://www.innoq.com/blog/st/2010/07/rest_litmus_test_for_web_frame.html&quot;&gt;REST Litmus Test for Web Frameworks&lt;/a&gt;は、 Webフレームワークの同様の成熟度テストです。</target>
        </trans-unit>
        <trans-unit id="b82de9194c2626af47b20dbf29253c8eab541c11" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.xfront.com/REST.ppt&quot;&gt;http://www.xfront.com/REST.ppt&lt;/a&gt; or &lt;a href=&quot;http://www.xfront.com/REST.html&quot;&gt;http://www.xfront.com/REST.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.xfront.com/REST.ppt&quot;&gt;http://www.xfront.com/REST.ppt&lt;/a&gt;または&lt;a href=&quot;http://www.xfront.com/REST.html&quot;&gt;http://www.xfront.com/REST.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="581df4eb5c8f47005fba4eaff2c31e62dc854f5b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.google.com/present/view?id=dd4bk538_182f55p5x3f&amp;amp;ndplr=1&quot;&gt;REST and versioning&lt;/a&gt; discusses Extensibility, Versioning, Evolvability, etc.
 through Modifiability</source>
          <target state="translated">&lt;a href=&quot;https://docs.google.com/present/view?id=dd4bk538_182f55p5x3f&amp;amp;ndplr=1&quot;&gt;RESTとバージョン管理で&lt;/a&gt;は、変更可能性を通じて拡張性、バージョン管理、進化可能性などについて説明します</target>
        </trans-unit>
        <trans-unit id="38b751418200783443a4e1aa6fb491b6a5b8367d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;From Wikipedia&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;ウィキペディアから&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="b092bbc5dae2d2facc4cdcbac80f4fca0862b1a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;REST&lt;/em&gt; is the underlying architectural principle of the web. The amazing thing about the web is the fact that clients (browsers) and servers can interact in complex ways without the client knowing anything beforehand about the server and the resources it hosts. The key constraint is that the server and client must both agree on the &lt;em&gt;media&lt;/em&gt; used, which in the case of the web is &lt;em&gt;HTML&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;REST&lt;/em&gt;は、Webの基盤となるアーキテクチャの原則です。 Webの驚くべき点は、クライアント（ブラウザ）とサーバーが複雑な方法で対話できることです。クライアントがサーバーとサーバーがホストするリソースについて事前に何も知る必要はありません。 重要な制約は、サーバーとクライアントの両方が、使用される&lt;em&gt;メディア（&lt;/em&gt; Webの場合は&lt;em&gt;HTML）に&lt;/em&gt;同意する必要があることです。</target>
        </trans-unit>
        <trans-unit id="75836654a91c2003a610250aa33fea51aed04694" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Talking&lt;/em&gt; is more than simply &lt;em&gt;exchanging information&lt;/em&gt;. A Protocol is actually designed so that no talking has to occur. Each party knows what their particular job is because it is specified in the protocol. Protocols allow for pure information exchange at the expense of having any changes in the possible actions. Talking, on the other hand, allows for one party to ask what further actions can be taken from the other party. They can even ask the same question twice and get two different answers, since the State of the other party may have changed in the interim. &lt;strong&gt;Talking is RESTful architecture&lt;/strong&gt;. Fielding's thesis specifies the architecture that one would have to follow if one wanted to allow machines to &lt;em&gt;talk&lt;/em&gt; to one another rather than simply &lt;em&gt;communicate&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;話すこと&lt;/em&gt;は単に&lt;em&gt;情報を交換する&lt;/em&gt;だけではありません。 プロトコルは、実際に話が発生する必要がないように設計されています。 プロトコルで指定されているため、各当事者は特定のジョブが何であるかを知っています。 プロトコルは、可能なアクションに変更を加える代わりに、純粋な情報交換を可能にします。 一方、話すことにより、一方の当事者が他方の当事者からどのようなアクションを実行できるかを尋ねることができます。 相手の州が暫定的に変更された可能性があるため、同じ質問を2回行って2つの異なる回答を得ることができます。 &lt;strong&gt;話すことはRESTfulなアーキテクチャ&lt;/strong&gt;です。 フィールディングの論文では、単に&lt;em&gt;通信する&lt;/em&gt;だけでなく、マシン同士が&lt;em&gt;通信&lt;/em&gt;できるようにしたい場合に従う必要のあるアーキテクチャを指定しています。</target>
        </trans-unit>
        <trans-unit id="047b453da1539c81d5d318bedbdeb493589d50ab" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;a href=&quot;http://www.looah.com/source/view/2284&quot;&gt;How I explained REST to my wife&lt;/a&gt;.&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;&lt;a href=&quot;http://www.looah.com/source/view/2284&quot;&gt;RESTを妻に説明した方法&lt;/a&gt; 。&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="a5cbf477e28c39bdfd209ebf60137a160a48aa33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4 Commonly Used API Methods:-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4一般的に使用されるAPIメソッド：-&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a292b42aebab7e4f8f0a4cef5109e82538c81c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTTP methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTTPメソッド：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c887aa651a0b1255f5b4be4a6d0d7111e108eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Idempotence&lt;/strong&gt;: &lt;a href=&quot;http://programmers.stackexchange.com/questions/23386/pros-and-cons-of-restful-architecture&quot;&gt;An often-overlooked part of REST is the idempotency of most verbs. That leads to &lt;strong&gt;robust systems and less interdependency&lt;/strong&gt; of exact interpretations of the semantics&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;べき等&lt;/strong&gt; ： &lt;a href=&quot;http://programmers.stackexchange.com/questions/23386/pros-and-cons-of-restful-architecture&quot;&gt;RESTで見過ごされがちな部分は、ほとんどの動詞のべき等です。&lt;/a&gt; これにより、 &lt;strong&gt;堅牢なシステム&lt;/strong&gt;が実現し、セマンティクスの正確な解釈の&lt;strong&gt;相互依存性&lt;/strong&gt;が&lt;strong&gt;低下し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e19e144b463c1477631bed87f6cf59ac2feabcb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST API&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;REST API&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4016ad50e00a712f9fc46d47dae34627a47b0c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST&lt;/strong&gt; is an architectural style which is based on web-standards and the HTTP protocol (introduced in 2000).</source>
          <target state="translated">&lt;strong&gt;REST&lt;/strong&gt;は、Web標準とHTTPプロトコル（2000年に導入）に基づくアーキテクチャスタイルです。</target>
        </trans-unit>
        <trans-unit id="f470c92afeb4f87674886ef73e25bccf93d40bda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST&lt;/strong&gt; stands for &lt;strong&gt;Representational state transfer&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;REST&lt;/strong&gt;は、 &lt;strong&gt;Representational State&lt;/strong&gt; &lt;strong&gt;Transferの&lt;/strong&gt;略です。</target>
        </trans-unit>
        <trans-unit id="c34758fefce5857b0652a67c95f80db96a7e9ace" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Request&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Request&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8301b7897b69c57632cd67112cbd903a929c2bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Response&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Response&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9026e434b313962901c5fd34080061d3114f6c95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, how does this apply to &lt;em&gt;HTTP&lt;/em&gt;, and how can it be implemented in practice?&lt;/strong&gt; HTTP is oriented around verbs and resources. The two verbs in mainstream usage are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;, which I think everyone will recognize. However, the HTTP standard defines several others such as &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt;. These verbs are then applied to resources, according to the instructions provided by the server.</source>
          <target state="translated">&lt;strong&gt;では、これは&lt;em&gt;HTTP&lt;/em&gt;にどのように当てはまり、実際にどのように実装できますか？&lt;/strong&gt; HTTPは動詞とリソースを中心としています。 主流の使用法の2つの動詞は &lt;code&gt;GET&lt;/code&gt; と &lt;code&gt;POST&lt;/code&gt; です。 ただし、HTTP標準では、 &lt;code&gt;PUT&lt;/code&gt; や &lt;code&gt;DELETE&lt;/code&gt; などの他のいくつかが定義されています。 次に、サーバーから提供される指示に従って、これらの動詞がリソースに適用されます。</target>
        </trans-unit>
        <trans-unit id="63a42af1bd9b39bddf0ce1be8356d0a2fdb888e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Statelessness&lt;/strong&gt; is misleading. It is about the restful API, not the application or system. The system needs to be stateful. Restful design is about designing a stateful system based on a stateless API. Some &lt;a href=&quot;http://programmers.stackexchange.com/questions/120716/difference-between-rest-and-crud&quot;&gt;quotes from another QA&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;無国籍&lt;/strong&gt;は誤解を招くものです。 これは、アプリケーションやシステムではなく、Restful APIに関するものです。 システムはステートフルである必要があります。 安静設計とは、ステートレスAPIに基づいてステートフルシステムを設計することです。 &lt;a href=&quot;http://programmers.stackexchange.com/questions/120716/difference-between-rest-and-crud&quot;&gt;別のQAからの引用&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="4c1222e90317ba27d02c65621a259eda932152bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Steps to Test API Manually:-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;APIを手動でテストする手順：-&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a168c28310824470d0a6b65e2fc1846ae47767c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is another &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;very good post&lt;/a&gt; which explains things nicely.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;物事をうまく説明する別の&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;非常に良い投稿が&lt;/a&gt;あります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f23059a3c1ff462600affe32ac77f6c06e198cd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is &lt;a href=&quot;http://testingalert.com/api-testing/api-manual/&quot;&gt;API Testing&lt;/a&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://testingalert.com/api-testing/api-manual/&quot;&gt;APIテスト&lt;/a&gt;とは何ですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bdfd2ece2c06305906caea45c528dd7bf39e1081" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is REST?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESTとは何ですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34c0a9562e8fed523993c8b4e5719d3ee3daa073" translate="yes" xml:space="preserve">
          <source>A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user&amp;rsquo;s manipulation of those representations. The transitions may be determined (or limited by) the client&amp;rsquo;s knowledge of media types and resource communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand).</source>
          <target state="translated">REST APIは、最初のURI（ブックマーク）と、対象とする対象者に適した標準化されたメディアタイプのセット（APIを使用する可能性のあるクライアントによって理解されることが期待される）以外に事前知識なしで入力する必要があります。 その時点から、すべてのアプリケーションの状態遷移は、受信した表現に存在する、またはユーザーによるそれらの表現の操作によって暗示される、サーバー提供の選択肢のクライアント選択によって駆動される必要があります。 遷移は、メディアタイプとリソース通信メカニズムに関するクライアントの知識を決定（または制限）できます。どちらもオンザフライで改善できます（たとえば、コードオンデマンド）。</target>
        </trans-unit>
        <trans-unit id="1036e82ff72398f19dae7159de008a4b11524acc" translate="yes" xml:space="preserve">
          <source>A REST API should spend almost all of its descriptive effort in
  defining the media type(s) used for representing resources and driving
  application state, or in defining extended relation names and/or
  hypertext-enabled mark-up for existing standard media types.</source>
          <target state="translated">REST APIは、リソースの表現やアプリケーションの状態を駆動するために使用されるメディアタイプの定義や、既存の標準メディアタイプのための拡張リレーション名やハイパーテキスト対応のマークアップの定義に、その記述的な努力のほとんどすべてを費やすべきです。</target>
        </trans-unit>
        <trans-unit id="091580d9e598bff76e8f95009cca43640abadd8b" translate="yes" xml:space="preserve">
          <source>A client of a RESTful application need
  only know a single fixed URL to access
  it. All future actions should be
  discoverable dynamically from
  hypermedia links included in the
  representations of the resources that
  are returned from that URL.
  Standardized media types are also
  expected to be understood by any
  client that might use a RESTful API. 
  (From Wikipedia, the free encyclopedia)</source>
          <target state="translated">RESTful アプリケーションのクライアントは、アクセスするために単一の固定 URL を知る必要があるだけです。将来のすべてのアクションは、そのURLから返されるリソースの表現に含まれるハイパーメディアリンクから動的に発見可能でなければなりません。標準化されたメディアタイプは、RESTful APIを使用する可能性のあるクライアントにも理解されることが期待されています。(フリー百科事典「ウィキペディア」より)</target>
        </trans-unit>
        <trans-unit id="b199b8ec3c349cace004db8b56b1161860b9581b" translate="yes" xml:space="preserve">
          <source>A great book on REST is &lt;a href=&quot;http://www.amazon.co.uk/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829&quot;&gt;REST in Practice&lt;/a&gt;.</source>
          <target state="translated">RESTに関するすばらしい本は&lt;a href=&quot;http://www.amazon.co.uk/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829&quot;&gt;REST in Practice&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="bbbdec192b31adde0e04c6c1e638a22c1c3a0509" translate="yes" xml:space="preserve">
          <source>A lot of answers copy/pasted valid information mixing it and adding some confusion. People talk here about levels, about RESTFul URIs(there is not such a thing!), apply HTTP methods GET,POST,PUT ... REST is not about that or not only about that.</source>
          <target state="translated">回答の多くは、それを混合し、いくつかの混乱を追加する有効な情報をコピペしました。人々はRESTFul URIについて、レベルについてここで話をする(そのようなものはありません!)、HTTPメソッドGET,POST,PUTを適用する...RESTは、そのことについて、またはそのことについてだけではありません。</target>
        </trans-unit>
        <trans-unit id="a9672fbb5a371857625bda2ec07f4fc2c459d533" translate="yes" xml:space="preserve">
          <source>A request for the base resource &lt;code&gt;/&lt;/code&gt; might return something like this:</source>
          <target state="translated">基本リソース &lt;code&gt;/&lt;/code&gt; に対するリクエストは、次のようなものを返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="33311414a6f85a0d4549f88e6f929e587d140695" translate="yes" xml:space="preserve">
          <source>API testing utilizes programming to send calls to the API and get the yield. It testing regards the segment under test as a black box. The objective of API testing is to confirm right execution and blunder treatment of the part preceding its coordination into an application.</source>
          <target state="translated">APIのテストでは、APIにコールを送信して収量を取得するためにプログラミングを利用します。それはテストの対象となるセグメントをブラックボックスとみなしてテストします。APIテストの目的は、アプリケーションへの連携に先立って、その部分が正しく実行されているかどうかを確認することと、その部分の不備処理を確認することです。</target>
        </trans-unit>
        <trans-unit id="17e11e3bc87a626545bcd3ae4e73a6dc9b979e5b" translate="yes" xml:space="preserve">
          <source>After reading the examples, I could see why Ken is saying that REST is hypertext-driven. I'm not actually sure that he's right though, because that /user/123 is a URI that points to a resource, and it's not clear to me that it's unRESTful just because the client knows about it &quot;out-of-band.&quot;</source>
          <target state="translated">例を読んだ後、KenがRESTはハイパーテキスト駆動だと言っている理由がわかりました。しかし、実際には彼が正しいかどうかはわかりません。なぜなら、user123はリソースを指すURIであり、クライアントがそれを &quot;帯域外 &quot;で知っているからといって、それがRESTfulではないというのは私には明確ではありません。</target>
        </trans-unit>
        <trans-unit id="0ff162ae131fa2cf274f6632a56e1f9816c868de" translate="yes" xml:space="preserve">
          <source>After that, it's easy to fall into debates about adaptations, coding conventions, and best practices.</source>
          <target state="translated">その後、適応、コーディング規約、ベストプラクティスについての議論に陥りがちです。</target>
        </trans-unit>
        <trans-unit id="e6213f65245bee16c30cf6760d609e28bd445103" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;architectural style&lt;/strong&gt; called &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;&lt;strong&gt;REST (Representational State Transfer)&lt;/strong&gt;&lt;/a&gt; advocates that web applications should use HTTP as it was &lt;strong&gt;originally envisioned&lt;/strong&gt;. Lookups should use &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; requests. &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; requests&lt;/a&gt; should be used for &lt;strong&gt;mutation, creation, and deletion respectively&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;&lt;strong&gt;REST（Representational State Transfer）&lt;/strong&gt;&lt;/a&gt;と呼ばれる&lt;strong&gt;アーキテクチャスタイルで&lt;/strong&gt;は、Webアプリケーションは&lt;strong&gt;当初想定さ&lt;/strong&gt;れていた&lt;strong&gt;とおりに&lt;/strong&gt; HTTPを使用する必要があると主張しています。 ルックアップは&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;リクエストを使用する必要があります。 &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; 、 &lt;code&gt;POST&lt;/code&gt; 、および &lt;code&gt;DELETE&lt;/code&gt; 要求&lt;/a&gt;は&lt;strong&gt;、それぞれ、変更、作成、および削除に&lt;/strong&gt;使用する必要が&lt;strong&gt;あります&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="23f9e629acbf7586515e2525e29805b2378876e7" translate="yes" xml:space="preserve">
          <source>An API that adheres to the principles of &lt;em&gt;REST&lt;/em&gt; does not require the client to know anything about the structure of the API. Rather, the server needs to provide whatever information the client needs to interact with the service. An &lt;em&gt;HTML form&lt;/em&gt; is an example of this: The server specifies the location of the resource and the required fields. &lt;strong&gt;The browser doesn't know in advance where to submit the information, and it doesn't know in advance what information to submit. Both forms of information are entirely supplied by the server.&lt;/strong&gt; (This principle is called &lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot;&gt;&lt;em&gt;HATEOAS&lt;/em&gt;: Hypermedia As The Engine Of Application State&lt;/a&gt;.)</source>
          <target state="translated">&lt;em&gt;REST&lt;/em&gt;の原則に準拠しているAPIでは、クライアントがAPIの構造について何も知る必要はありません。 むしろ、サーバーは、クライアントがサービスと対話するために必要なあらゆる情報を提供する必要があります。 &lt;em&gt;HTMLフォーム&lt;/em&gt;はこの例です。サーバーは、リソースの場所と必須フィールドを指定します。 &lt;strong&gt;ブラウザーは、情報をどこに送信するかを事前に認識しておらず、どの情報を送信するかを事前に認識していません。&lt;/strong&gt; &lt;strong&gt;どちらの形式の情報も完全にサーバーから提供されます。&lt;/strong&gt; （この原則は&lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot;&gt;&lt;em&gt;HATEOAS&lt;/em&gt; ：アプリケーション状態のエンジンとしてのハイパーメディア&lt;/a&gt;と呼ばれます。）</target>
        </trans-unit>
        <trans-unit id="0572ba17f943d7fd5fc5bebd5022f2239451cc72" translate="yes" xml:space="preserve">
          <source>An application is restful if it provides resources (being the combination of data + state transitions controls) in a media type the client understands</source>
          <target state="translated">アプリケーションは、クライアントが理解できるメディアタイプでリソース(データと状態遷移コントロールの組み合わせ)を提供している場合には、restfulとなります。</target>
        </trans-unit>
        <trans-unit id="5bd054a830a9ec163da9832cb1d2afde20a52654" translate="yes" xml:space="preserve">
          <source>An excerpt from my talk is about the often referred to richardson maturity model, i don't believe in the levels, you either are RESTful (level 3) or you are not, but what i like to call out about it is what each level does for you on your way to RESTful</source>
          <target state="translated">私の話からの抜粋は、しばしば言及されているリチャードソン成熟度モデルについてです、私はレベルを信じていない、あなたはどちらかのRESTful(レベル3)であるかどうかではありませんが、私はそれについて呼び出すのが好きなのは、各レベルがRESTfulにあなたの方法であなたのために何をするのかです。</target>
        </trans-unit>
        <trans-unit id="2610e51a62b1a490881eef55051e2f6be573a983" translate="yes" xml:space="preserve">
          <source>And even better, there's a clean explanation with simple examples here (the powerpoint is more comprehensive, but you can get most of it in the html version):</source>
          <target state="translated">さらに良いのは、ここに簡単な例を挙げてすっきりとした説明があることです(パワーポイントの方が充実していますが、html版では大抵のことは手に入ります)。</target>
        </trans-unit>
        <trans-unit id="200c5e79bfe63bed7ea90d31d59e4814bd38015a" translate="yes" xml:space="preserve">
          <source>Bonus answer: No. Unless you're studying software architecture as an academic or designing web services, there's really no reason to have heard the term.</source>
          <target state="translated">ボーナスアンサー。あなたがアカデミックにソフトウェアアーキテクチャを勉強しているか、ウェブサービスを設計しているのでなければ、この言葉を聞いたことがある理由はありません。</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="8db50296564fcc14b8370fbfb576cb5f7a3364bb" translate="yes" xml:space="preserve">
          <source>But the REST architecture doesn&amp;rsquo;t end there! While the above fulfills the basic needs of what we want, we also want to have an architecture that supports high volume traffic since any given server usually handles responses from a number of clients. Thus, we don&amp;rsquo;t want to overwhelm the server by having it remember information about previous requests.</source>
          <target state="translated">しかし、RESTアーキテクチャはそこで終わりません！ 上記は私たちが望む基本的なニーズを満たしますが、特定のサーバーは通常複数のクライアントからの応答を処理するため、大量のトラフィックをサポートするアーキテクチャも必要です。 したがって、以前のリクエストに関する情報をサーバーに記憶させることでサーバーを圧倒したくありません。</target>
        </trans-unit>
        <trans-unit id="c0e841fccec5e52e207c5f9f8aedc87617de3151" translate="yes" xml:space="preserve">
          <source>But to find any given resource and then tell the client where that resource lives, there needs to be a universal way of pointing at resources. This is where Universal Resource Identifiers (URIs) come in; they are basically unique addresses to find the resources.</source>
          <target state="translated">しかし、与えられたリソースを見つけて、そのリソースがどこにあるのかをクライアントに伝えるためには、リソースを指す普遍的な方法が必要です。そこで登場するのが URI (Universal Resource Identifiers)で、これは基本的にリソースを見つけるためのユニークなアドレスです。</target>
        </trans-unit>
        <trans-unit id="ab9c8d4b22f42d6e20f2de04cee4a87194c9b2ff" translate="yes" xml:space="preserve">
          <source>Cacheable</source>
          <target state="translated">Cacheable</target>
        </trans-unit>
        <trans-unit id="ebdaf0dc221196d242550c9fdcc355ae34b62243" translate="yes" xml:space="preserve">
          <source>Click on send</source>
          <target state="translated">送信をクリックしてください</target>
        </trans-unit>
        <trans-unit id="85e79360e824842c6393ab95bc2ed066d468e1c8" translate="yes" xml:space="preserve">
          <source>Client&amp;ndash;server</source>
          <target state="translated">Client&amp;ndash;server</target>
        </trans-unit>
        <trans-unit id="9e1c7ac80552b301d4a9e2e0aad43db3dc88701b" translate="yes" xml:space="preserve">
          <source>Code on demand (optional)</source>
          <target state="translated">コード・オン・デマンド(オプション</target>
        </trans-unit>
        <trans-unit id="09134846ea28241f35e0dd02fce269a9982bea7f" translate="yes" xml:space="preserve">
          <source>Create a user with three properties:</source>
          <target state="translated">3つのプロパティを持つユーザーを作成します。</target>
        </trans-unit>
        <trans-unit id="4b2835cc754c6984e507206155e739a1564f8450" translate="yes" xml:space="preserve">
          <source>DELETE removes the resources. The operations are idempotent. They can get repeated without leading to different results.</source>
          <target state="translated">DELETEはリソースを削除します。これらの操作は偶像性があります。これらの操作は、異なる結果になることなく繰り返すことができます。</target>
        </trans-unit>
        <trans-unit id="03419256ac96b83abfd7066f861a5015d2ba0ed0" translate="yes" xml:space="preserve">
          <source>DELETE: &amp;ndash; It is used to remove a resource.</source>
          <target state="translated">DELETE：&amp;ndash;リソースを削除するために使用されます。</target>
        </trans-unit>
        <trans-unit id="5e5b459d45380b093202121fad6f6675d370930c" translate="yes" xml:space="preserve">
          <source>Despite being simple, REST is fully-featured; there's basically
  nothing you can do in Web Services that can't be done with a RESTful
  architecture. REST is not a &quot;standard&quot;. There will never be a W3C
  recommendataion for REST, for example. And while there are REST
  programming frameworks, working with REST is so simple that you can
  often &quot;roll your own&quot; with standard library features in languages like
  Perl, Java, or C#.</source>
          <target state="translated">シンプルであるにもかかわらず、RESTは完全に機能を備えています。RESTは「標準」ではありません。例えば、W3CがRESTを推奨することは決してありません。また、REST プログラミングフレームワークはありますが、REST での作業は非常にシンプルなので、Perl、Java、または C#などの言語の標準ライブラリ機能を使用して「独自にロールする」ことができます。</target>
        </trans-unit>
        <trans-unit id="b8d49819767eebe1ba51b6e1ff800c7bff7f706e" translate="yes" xml:space="preserve">
          <source>Edit: Two more important aspects:</source>
          <target state="translated">編集:さらに2つの重要な側面があります。</target>
        </trans-unit>
        <trans-unit id="cc4bbb1317907e63ed80955856990adc8e7cbbe4" translate="yes" xml:space="preserve">
          <source>Enter Request JSON (POST)</source>
          <target state="translated">リクエストJSON(POST)を入力してください。</target>
        </trans-unit>
        <trans-unit id="ab911d488e200ceacb5e406e1fe7b3000216de7c" translate="yes" xml:space="preserve">
          <source>Enter the API URL</source>
          <target state="translated">APIのURLを入力してください。</target>
        </trans-unit>
        <trans-unit id="800300af0e99da4a9ab4e50e0ad740ebb248a62c" translate="yes" xml:space="preserve">
          <source>Every resource should support the HTTP common operations. Resources are identified by global IDs (which are typically URIs).</source>
          <target state="translated">すべてのリソースは HTTP の共通操作をサポートしなければなりません。リソースはグローバル ID (通常は URI)によって識別されます。</target>
        </trans-unit>
        <trans-unit id="ae6c811f24cef30ab608149e77398fe7dc2aa93f" translate="yes" xml:space="preserve">
          <source>Explaining REST and Hypertext: Spam-E the Spam Cleaning Robot</source>
          <target state="translated">RESTとハイパーテキストを解説。スパム掃除ロボットSpam-E</target>
        </trans-unit>
        <trans-unit id="4c2e0eda7987cd96af30a22725f03cbbfc4b115a" translate="yes" xml:space="preserve">
          <source>For example links - it is nice to have a beautifully looking API but at the end the client/server does not really care of the links you get/send it is the content that matters.</source>
          <target state="translated">例えばリンク-美しく見えるAPIを持っているのは良いことですが、最後にクライアントサーバはリンクを気にしません。</target>
        </trans-unit>
        <trans-unit id="040c10648e6eb948c9d8e9d90c4d5f137fae46d2" translate="yes" xml:space="preserve">
          <source>For example there is a client layer which contains the clients and below that there is a service layer which contains a single service. Now you can add a client side cache between them. After that you can add another service instance and a load balancer, and so on... The client code and the service code won't change.</source>
          <target state="translated">例えば、クライアントを含むクライアント層と、その下に1つのサービスを含むサービス層があります。その間にクライアント側のキャッシュを追加することができます。その後、別のサービスインスタンスやロードバランサなどを追加することができます。クライアントコードとサービスコードは変わりません。</target>
        </trans-unit>
        <trans-unit id="4edba5a49c7a4414557ee46319d87498dbeae513" translate="yes" xml:space="preserve">
          <source>For example when a client wants to send an order to a webshop, then it have to check the hyperlinks in the responses sent by the webshop. By checking the links it founds one described with the &lt;a href=&quot;http://schema.org/OrderAction&quot;&gt;http://schema.org/OrderAction&lt;/a&gt;. The client know the schema.org vocab, so it understands that by activating this hyperlink it will send the order. So it activates the hyperlink and sends a &lt;code&gt;POST https://example.com/api/v1/order&lt;/code&gt; message with the proper body. After that the service processes the message and responds with the result having the proper HTTP status header, for example &lt;code&gt;201 - created&lt;/code&gt; by success. To annotate messages with detailed metadata the standard solution to use an RDF format, for example &lt;a href=&quot;http://json-ld.org/&quot;&gt;JSON-LD&lt;/a&gt; with a REST vocab, for example &lt;a href=&quot;http://www.markus-lanthaler.com/hydra/&quot;&gt;Hydra&lt;/a&gt; and domain specific vocabs like &lt;a href=&quot;http://schema.org/&quot;&gt;schema.org&lt;/a&gt; or any other &lt;a href=&quot;http://lov.okfn.org/dataset/lov/&quot;&gt;linked data vocab&lt;/a&gt; and maybe a custom application specific vocab if needed. Now this is not easy, that's why most ppl use HAL and other simple formats which usually provide only a REST vocab, but no linked data support.</source>
          <target state="translated">たとえば、クライアントが注文をWebショップに送信する場合、Webショップから送信された応答のハイパーリンクを確認する必要があります。 リンクをチェックすると、 &lt;a href=&quot;http://schema.org/OrderAction&quot;&gt;http:&lt;/a&gt; //schema.org/OrderActionで記述されたリンクが見つかります。 クライアントはschema.org語彙を知っているので、このハイパーリンクをアクティブにすることで注文が送信されることを理解しています。 したがって、ハイパーリンクをアクティブにし、適切な本文を含む &lt;code&gt;POST https://example.com/api/v1/order&lt;/code&gt; メッセージを送信します 。 その後、サービスはメッセージを処理し、適切なHTTPステータスヘッダー（例： &lt;code&gt;201 - created&lt;/code&gt; 成功によって作成された）を持つ結果で応答します。 詳細なメタデータでメッセージに注釈を付けるには、RDF形式を使用するための標準ソリューション、たとえば、REST語彙を使用した&lt;a href=&quot;http://json-ld.org/&quot;&gt;JSON-LD&lt;/a&gt; 、たとえば、 &lt;a href=&quot;http://www.markus-lanthaler.com/hydra/&quot;&gt;Hydra&lt;/a&gt;やschema.orgなどのドメイン固有の&lt;a href=&quot;http://schema.org/&quot;&gt;語彙&lt;/a&gt;やその他の&lt;a href=&quot;http://lov.okfn.org/dataset/lov/&quot;&gt;リンクされたデータ&lt;/a&gt; 語彙 、そして場合によってはカスタムアプリケーション固有の語彙必要。 これは簡単ではありません。そのため、ほとんどのpplはHALおよびその他の単純なフォーマットを使用するので、通常REST語彙のみが提供され、リンクされたデータはサポートされません。</target>
        </trans-unit>
        <trans-unit id="519a503f187cd31038f7706dcd1d8a0887042f78" translate="yes" xml:space="preserve">
          <source>For example, Let's imagine that we have a user database that is managed by a web service. Our service uses a custom hypermedia based on JSON, for which we assign the mimetype &lt;code&gt;application/json+userdb&lt;/code&gt; (There might also be an &lt;code&gt;application/xml+userdb&lt;/code&gt; and &lt;code&gt;application/whatever+userdb&lt;/code&gt; - many media types may be supported). The client and the server have both been programmed to understand this format, but they don't know anything about each other. As &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Roy Fielding&lt;/a&gt; points out:</source>
          <target state="translated">たとえば、Webサービスによって管理されているユーザーデータベースがあるとします。 私たちのサービスは、JSONに基づくカスタムハイパーメディアを使用します。それには、mimetype &lt;code&gt;application/json+userdb&lt;/code&gt; を割り当てます （ &lt;code&gt;application/xml+userdb&lt;/code&gt; および &lt;code&gt;application/whatever+userdb&lt;/code&gt; もある可能性があります-多くのメディアタイプがサポートされている場合があります）。 クライアントとサーバーはどちらもこの形式を理解するようにプログラムされていますが、お互いについては何も知りません。 &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;ロイ・フィールディングが&lt;/a&gt;指摘するように：</target>
        </trans-unit>
        <trans-unit id="29ff533a59385e46befeb9d1d442ce81cde883fb" translate="yes" xml:space="preserve">
          <source>For example, instead a set of URLs which might look like some of the following..</source>
          <target state="translated">例えば、以下のようなURLのセットの代わりに...</target>
        </trans-unit>
        <trans-unit id="ce3d305d56ec5c6ee26c71725d770976054d26b3" translate="yes" xml:space="preserve">
          <source>For sending and receiving messages, it involves using HTTP methods, and it does not require a strict message definition, unlike Web services.</source>
          <target state="translated">メッセージの送受信にはHTTPメソッドを使用し、Webサービスのように厳密なメッセージ定義を必要としません。</target>
        </trans-unit>
        <trans-unit id="096bafb1ad02c5e340fc0cffb7efac1d03c6fdd6" translate="yes" xml:space="preserve">
          <source>Further reading:</source>
          <target state="translated">続きを読む</target>
        </trans-unit>
        <trans-unit id="ae09a97e20415e22fe1f93eb6fbb98ed8d14de81" translate="yes" xml:space="preserve">
          <source>GET defines a reading access of the resource without side-effects. The resource is never changed via a GET request, e.g., the request has no side effects (idempotent).</source>
          <target state="translated">GETは、副作用のないリソースの読み込みアクセスを定義します。リソースはGETリクエストによって変更されることはありません。</target>
        </trans-unit>
        <trans-unit id="c4c41d24d5f2a151608ed14ff7819f6f47a5271f" translate="yes" xml:space="preserve">
          <source>GET: &amp;ndash; It provides read only access to a resource.</source>
          <target state="translated">GET：&amp;ndash;リソースへの読み取り専用アクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="5e04d05de713337d37ea8308533c814f117ef859" translate="yes" xml:space="preserve">
          <source>Given this view point, the rest style is not really tied to internet or web application. It's a fundamental solution to many of the programming situations. It is not simple either, it just makes the interface really simple, and copes with other technologies amazingly well.</source>
          <target state="translated">このビューポイントを考えると、残りのスタイルは、インターネットやウェブアプリケーションとはあまり関係がありません。それはプログラミングの多くの状況に対する根本的な解決策です。それはどちらも単純ではありません、それは単にインターフェイスを本当にシンプルにし、他の技術に驚くほどうまく対処します。</target>
        </trans-unit>
        <trans-unit id="413e85dd36b6612ff8f3b552ddd4ae973747eb10" translate="yes" xml:space="preserve">
          <source>Here is my basic outline of REST. I tried to demonstrate the thinking behind each of the components in a RESTful architecture so that understanding the concept is more intuitive. Hopefully this helps demystify REST for some people!</source>
          <target state="translated">ここでは、RESTの基本的な概要を説明します。RESTfulアーキテクチャの各コンポーネントの背後にある考え方を示すことで、コンセプトをより直感的に理解できるようにしました。うまくいけば、これが何人かの人のためにRESTを説明するのに役立つことを願っています。</target>
        </trans-unit>
        <trans-unit id="c419bb60824d17f1c8fc3f5f0378842579d5c500" translate="yes" xml:space="preserve">
          <source>I apologize if I'm not answering the question directly, but it's easier to understand all this with more detailed examples. Fielding is not easy to understand due to all the abstraction and terminology.</source>
          <target state="translated">直接の回答になっていなかったら申し訳ありませんが、もっと詳しい例を挙げていただいた方が全て理解しやすいと思います。フィールディングは抽象度や専門用語が多くてわかりにくいです。</target>
        </trans-unit>
        <trans-unit id="087ec8b5ab0cac5efee7be73a08f41b5611d251f" translate="yes" xml:space="preserve">
          <source>I define restful programming as</source>
          <target state="translated">私はレストフルプログラミングを次のように定義しています。</target>
        </trans-unit>
        <trans-unit id="ee52bb4671d83e94060d7610bdd9bf819906adce" translate="yes" xml:space="preserve">
          <source>I don't think you should feel stupid for not hearing about REST outside Stack Overflow..., I would be in the same situation!; answers to this other SO question on &lt;a href=&quot;https://stackoverflow.com/q/243388/463478&quot;&gt;Why is REST getting big now&lt;/a&gt; could ease some feelings.</source>
          <target state="translated">スタックオーバーフローの外でRESTについて聞いていないのはばかげていると思わないでください。私も同じ状況になります。; &lt;a href=&quot;https://stackoverflow.com/q/243388/463478&quot;&gt;なぜRESTが大きくなっ&lt;/a&gt;ているのかという、この別のSOの質問に対する答えは、いくつかの感情を和らげることができます。</target>
        </trans-unit>
        <trans-unit id="6c76368a522ebb58d381771d2b88fa3b274443e2" translate="yes" xml:space="preserve">
          <source>I found this fantastic, short, and easy to understand tutorial about REST by Dr. M. Elkstein and quoting the essential part that would answer your question for the most part:</source>
          <target state="translated">Dr.M.ElksteinによるRESTについてのチュートリアルを見つけ、あなたの質問に答えるために必要不可欠な部分を引用しました。</target>
        </trans-unit>
        <trans-unit id="6d8108db9657b6e64ef934ab59dc6f7fa01dcc70" translate="yes" xml:space="preserve">
          <source>I see a bunch of answers that say putting everything about user 123 at resource &quot;/user/123&quot; is RESTful.</source>
          <target state="translated">リソース &quot;user123 &quot;にユーザー123に関するすべての情報を置くことがRESTfulであるという回答を多く見かけます。</target>
        </trans-unit>
        <trans-unit id="763841bd5f36269041a09b4b998b89fbb9e2caff" translate="yes" xml:space="preserve">
          <source>I think that the most important trick to understanding the architectural importance and performance implications of a RESTful and &lt;a href=&quot;http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf&quot;&gt;Shared Nothing&lt;/a&gt; architectures is to avoid getting hung up on the technology and implementation details. Concentrate on who owns resources, who is responsible for creating/maintaining them, etc. Then think about the representations, protocols, and technologies.</source>
          <target state="translated">RESTfulアーキテクチャと&lt;a href=&quot;http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf&quot;&gt;Shared Nothing&lt;/a&gt;アーキテクチャのアーキテクチャの重要性とパフォーマンスへの影響を理解するための最も重要なトリックは、テクノロジーと実装の詳細にこだわらないようにすることだと思います。 誰がリソースを所有し、誰がリソースの作成/保守を担当するかなどに集中します。次に、表現、プロトコル、テクノロジーについて考えます。</target>
        </trans-unit>
        <trans-unit id="d0530a0292feea24c4a9346fcd870c5d42a8ef18" translate="yes" xml:space="preserve">
          <source>I think the point of restful is the &lt;strong&gt;separation of the statefulness into a higher layer&lt;/strong&gt; while making use of the internet (protocol) as a &lt;strong&gt;stateless transport layer&lt;/strong&gt;. Most other approaches mix things up.</source>
          <target state="translated">安らぎのポイントは、 &lt;strong&gt;ステートレスなトランスポート層&lt;/strong&gt;としてインターネット（プロトコル）を利用しながら&lt;strong&gt;、ステートフルネスを上位層に分離&lt;/strong&gt;することだと思います。 他のほとんどのアプローチは物事を混同します。</target>
        </trans-unit>
        <trans-unit id="c322421456d9bf2c2db73cb8c6cdc0e978e2f5ea" translate="yes" xml:space="preserve">
          <source>I would say RESTful programming would be about creating systems (API) that follow the REST architectural style.</source>
          <target state="translated">RESTfulプログラミングとは、RESTアーキテクチャのスタイルに沿ったシステム(API)を作ることだと言ってもいいでしょう。</target>
        </trans-unit>
        <trans-unit id="7efc17b40148a3f7a450c659d22a107b0159fbac" translate="yes" xml:space="preserve">
          <source>I would say that an important building block in understanding REST lies in the endpoints or mappings, such as &lt;code&gt;/customers/{id}/balance&lt;/code&gt;.</source>
          <target state="translated">RESTを理解する上で重要な構成要素は、 &lt;code&gt;/customers/{id}/balance&lt;/code&gt; などのエンドポイントまたはマッピングにあると思います。</target>
        </trans-unit>
        <trans-unit id="00c15a6f862dfb4e67e15e8fab5e3217684aa057" translate="yes" xml:space="preserve">
          <source>I'm not looking to self promote, but i expand on these ideas to great depth in my talk &lt;a href=&quot;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&quot;&gt;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&lt;/a&gt; .</source>
          <target state="translated">私は自分で宣伝するつもりはありませんが、これらのアイデアを自分の講演&lt;a href=&quot;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&quot;&gt;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.htmlで&lt;/a&gt;深く掘り下げます。</target>
        </trans-unit>
        <trans-unit id="c54b01044e3ae27d309c48efbe56fe8b30a02fdb" translate="yes" xml:space="preserve">
          <source>IMO:</source>
          <target state="translated">IMO:</target>
        </trans-unit>
        <trans-unit id="528e227c40908c4c76424c153287878418391881" translate="yes" xml:space="preserve">
          <source>If I had to reduce the original dissertation on REST to just 3 short sentences, I think the following captures its essence:</source>
          <target state="translated">RESTに関する元の論文を3つの短い文章に絞るとすれば、以下のようなものが本質を捉えていると思います。</target>
        </trans-unit>
        <trans-unit id="3e4a789505499d4ebc9acf09affff2580e66a8db" translate="yes" xml:space="preserve">
          <source>If you are really interested in what a RESTful architecture is and why it works, read &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;his thesis&lt;/a&gt; a few times and read the &lt;strong&gt;whole thing&lt;/strong&gt; not just Chapter 5! Next look into &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;why DNS works&lt;/a&gt;. Read about the hierarchical organization of DNS and how referrals work. Then read and consider how DNS caching works. Finally, read the HTTP specifications (&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; in particular) and consider how and why the caching works the way that it does. Eventually, it will just click. The final revelation for me was when I saw the similarity between DNS and HTTP. After this, understanding why SOA and Message Passing Interfaces are scalable starts to click.</source>
          <target state="translated">RESTfulアーキテクチャとは何か、なぜそれが機能するのかに本当に興味がある場合は、 &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;彼の論文&lt;/a&gt;を数回読み、第5章だけでなく&lt;strong&gt;全体&lt;/strong&gt;を読んでください！ 次に&lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;DNSが機能&lt;/a&gt;する理由を調べます。 DNSの階層構造と紹介の仕組みについて読んでください。 次に、DNSキャッシュのしくみを読んで検討します。 最後に、HTTP仕様（特に&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;および&lt;a href=&quot;http://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; ）を読み、キャッシングがどのように、そしてなぜキャッシングが機能するのかを検討します。 最終的には、クリックするだけです。 私にとっての最後の啓示は、DNSとHTTPの類似点を見たときでした。 この後、SOAとメッセージパッシングインターフェースがスケーラブルである理由を理解することから始めます。</target>
        </trans-unit>
        <trans-unit id="5c9c0f1f96e6c661dd2c0857fa65fd08bb396af3" translate="yes" xml:space="preserve">
          <source>In a REST based architecture you have a REST server which provides
  access to the resources. A REST client can access and modify the REST
  resources.</source>
          <target state="translated">REST ベースのアーキテクチャでは、リソースへのアクセスを提供する REST サーバーがあります。REST クライアントは、REST リソースにアクセスして変更することができます。</target>
        </trans-unit>
        <trans-unit id="2a7fcadf01fdd539dc00964a4063d163ad342bf9" translate="yes" xml:space="preserve">
          <source>In a REST based architecture, everything is a resource(Users, Orders, Comments). A resource is accessed via a common interface based on the HTTP standard methods(GET, PUT, PATCH, DELETE etc).</source>
          <target state="translated">RESTベースのアーキテクチャでは、すべてがリソース(ユーザー、注文、コメント)です。リソースは、HTTP標準メソッド(GET,PUT,PATCH,DELETEなど)に基づいた共通のインターフェースを介してアクセスされます。</target>
        </trans-unit>
        <trans-unit id="81af6a9f5471cbc482ac157847e6af8a50d7537f" translate="yes" xml:space="preserve">
          <source>In computing, representational state transfer (REST) is an
  architectural style used for web development.</source>
          <target state="translated">コンピューティングでは、REST(Representational State Transfer)はWeb開発に使用されるアーキテクチャスタイルです。</target>
        </trans-unit>
        <trans-unit id="508381eb480015bf82a7312e0cfb8e350127a358" translate="yes" xml:space="preserve">
          <source>In many ways, the World Wide Web itself, based on HTTP, can be viewed
  as a REST-based architecture. RESTful applications use HTTP requests
  to post data (create and/or update), read data (e.g., make queries),
  and delete data. Thus, REST uses HTTP for all four CRUD
  (Create/Read/Update/Delete) operations.</source>
          <target state="translated">多くの点で、HTTP をベースにした World Wide Web 自体は、REST ベースのアーキテクチャとして見ることができます。RESTfulアプリケーションは、データの投稿(作成や更新)、データの読み込み(クエリの作成など)、データの削除のためにHTTPリクエストを使用します。このように、RESTはCRUD(CreateReadUpdateDelete)の4つの操作すべてにHTTPを使用しています。</target>
        </trans-unit>
        <trans-unit id="9afec0b39286ce35f8ff306c75875ec463e27211" translate="yes" xml:space="preserve">
          <source>In many ways, the World Wide Web itself, based on HTTP, can be viewed    as a REST-based architecture.</source>
          <target state="translated">多くの点で、HTTPをベースにしたWorld Wide Web自体は、RESTベースのアーキテクチャとして見ることができます。</target>
        </trans-unit>
        <trans-unit id="d7d9b177727972b7bd403cb1d9830e8972f6ccaf" translate="yes" xml:space="preserve">
          <source>In other words you're writing simple point-to-point network applications over HTTP which uses verbs such as GET, POST, PUT or DELETE by implementing RESTful architecture which proposes standardization of the interface each &amp;ldquo;resource&amp;rdquo; exposes. It is nothing that using current features of the web in a simple and effective way (highly successful, proven and distributed architecture). It is an alternative to more complex mechanisms like &lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture&quot;&gt;CORBA&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt;.</source>
          <target state="translated">言い換えると、GET、POST、PUT、DELETEなどの動詞を使用するHTTP経由のシンプルなポイントツーポイントネットワークアプリケーションを作成し、各「リソース」が公開するインターフェースの標準化を提案するRESTfulアーキテクチャを実装します。 シンプルで効果的な方法でWebの現在の機能を使用することは何もありません（非常に成功し、実績のある分散アーキテクチャー）。 これは、 &lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt; 、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture&quot;&gt;CORBA&lt;/a&gt; 、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt;などのより複雑なメカニズムの代替手段です。</target>
        </trans-unit>
        <trans-unit id="9075c88ba609ac32ad4853adceff80a57b9c8848" translate="yes" xml:space="preserve">
          <source>In the end &lt;strong&gt;any RESTful client should be able to consume to any RESTful service as long as the content format is known.&lt;/strong&gt;</source>
          <target state="translated">結局のところ&lt;strong&gt;、RESTfulクライアントは、コンテンツ形式がわかっている限り、RESTfulサービスを利用できる必要があります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6435852cb4e96cc87686e94b5374a8056f393527" translate="yes" xml:space="preserve">
          <source>In the future, you can then retrieve the user information:</source>
          <target state="translated">将来的には、ユーザー情報を取得することができます。</target>
        </trans-unit>
        <trans-unit id="d6ecb449599f6dd2f5e9713553e3cd31fe1f0435" translate="yes" xml:space="preserve">
          <source>Install POSTMAN(Chrome) / REST(Firefox) plugin</source>
          <target state="translated">POSTMAN(Chrome)REST(Firefox)プラグインのインストール</target>
        </trans-unit>
        <trans-unit id="6a6d9700ec195facf4fac9e8b95e37072828dc22" translate="yes" xml:space="preserve">
          <source>Interestingly, there is no mention of HTTP POST, GET, DELETE, or PUT operations in the dissertation. That must be someone's later interpretation of a &quot;best practice&quot; for a &quot;uniform interface&quot;.</source>
          <target state="translated">興味深いことに、論文にはHTTP POST、GET、DELETE、PUT操作についての言及がありません。これは「統一されたインターフェース」のための「ベストプラクティス」を後から解釈したものに違いありません。</target>
        </trans-unit>
        <trans-unit id="f9de0a4336192b307d47a7bd6e45e0eaef080436" translate="yes" xml:space="preserve">
          <source>Introduction about Rest</source>
          <target state="translated">休息についての紹介</target>
        </trans-unit>
        <trans-unit id="b9c999a74770669b9c8ffb4ad17078f65b2cda93" translate="yes" xml:space="preserve">
          <source>It relies on a stateless, client-server, cacheable communications protocol -- and in virtually all cases, the HTTP protocol is used.</source>
          <target state="translated">これは、ステートレス、クライアント・サーバ、キャッシュ可能な通信プロトコルに依存しており、事実上すべてのケースで HTTP プロトコルが使用されています。</target>
        </trans-unit>
        <trans-unit id="1117236a998be55f80d560abd424de90ea9e2991" translate="yes" xml:space="preserve">
          <source>It will return output response</source>
          <target state="translated">出力レスポンスを返します。</target>
        </trans-unit>
        <trans-unit id="c89e148b7af16b441451c1995bfe2abaf6361908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an arrangement of functions on which the testers performs requests and receive responses. In REST API interactions are made via HTTP protocol.</source>
          <target state="translated">これは、テスターが要求を実行して応答を受け取る機能の配置です。 REST APIでは、対話はHTTPプロトコルを介して行われます。</target>
        </trans-unit>
        <trans-unit id="f0fc1358f601de6b260eab812260ed0430f7e282" translate="yes" xml:space="preserve">
          <source>It's been the best practical approach to handle the fundamental changes of programming in internet era. Regarding the fundamental changes, Erik Meijer has a discussion on show here: &lt;a href=&quot;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&quot;&gt;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&lt;/a&gt; . He summarizes it as the five effects, and presents a solution by designing the solution into a programming language. The solution, could also be achieved in the platform or system level, regardless of the language. The restful could be seen as one of the solutions that has been very successful in the current practice.</source>
          <target state="translated">これは、インターネット時代のプログラミングの根本的な変化を処理するための最良の実践的アプローチでした。 根本的な変更に関して、エリックマイヤーはショーに関するディスカッションをここに持っています： &lt;a href=&quot;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&quot;&gt;http&lt;/a&gt; : //www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197 。 彼はそれを5つの効果として要約し、ソリューションをプログラミング言語に設計することによってソリューションを提示します。 ソリューションは、言語に関係なく、プラットフォームまたはシステムレベルでも実現できます。 安静は、現在のプラクティスで非常に成功しているソリューションの1つと見なすことができます。</target>
        </trans-unit>
        <trans-unit id="d4929d90be24c95c993943d45502f80422e27a62" translate="yes" xml:space="preserve">
          <source>It's programming where the architecture of your system fits the &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;REST style&lt;/a&gt; laid out by Roy Fielding in &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;his thesis&lt;/a&gt;. Since this is the architectural style that describes the web (more or less), lots of people are interested in it.</source>
          <target state="translated">これは、システムのアーキテクチャが、Roy Fieldingが&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;論文&lt;/a&gt;で設計した&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;RESTスタイルに&lt;/a&gt;適合するプログラミングです。 これは（多かれ少なかれ）Webを説明するアーキテクチャスタイルであるため、多くの人がそれに興味を持っています。</target>
        </trans-unit>
        <trans-unit id="9e58b34ecd5fe46f5c7fac142a7753476a694f3e" translate="yes" xml:space="preserve">
          <source>JSON is not restful programming</source>
          <target state="translated">JSONは安静なプログラミングではない</target>
        </trans-unit>
        <trans-unit id="a6b85e0f041b2c7697f401797ec1377054a290db" translate="yes" xml:space="preserve">
          <source>Just my 2c.</source>
          <target state="translated">私の2Cだけです。</target>
        </trans-unit>
        <trans-unit id="bbe8d64fcde25a40febca185bf5ef63d774333ce" translate="yes" xml:space="preserve">
          <source>Keep in mind that GET requests should never be used for updating information. For example, a GET request for adding an item to a cart</source>
          <target state="translated">GETリクエストは決して情報を更新するために使用すべきではないことを覚えておいてください。例えば、カートにアイテムを追加するための GET リクエストは、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5f82e7663dd4156cb07776cb1cea89dd1aba1b01" translate="yes" xml:space="preserve">
          <source>Layered system</source>
          <target state="translated">レイヤードシステム</target>
        </trans-unit>
        <trans-unit id="133b041c9729c525d972a67420b5a147370536ad" translate="yes" xml:space="preserve">
          <source>Learn REST: A Tutorial</source>
          <target state="translated">REST を学ぶ。チュートリアル</target>
        </trans-unit>
        <trans-unit id="d48495a4077a6c79d43f781b565680695cf2d342" translate="yes" xml:space="preserve">
          <source>Martin Fowler's
thoughts</source>
          <target state="translated">マーティン・ファウラーの感想</target>
        </trans-unit>
        <trans-unit id="de83e0aeb9afb13ea59f9bf7102b93ccfae94aaa" translate="yes" xml:space="preserve">
          <source>Metadata is passed as name-value pairs (post data and query string parameters).</source>
          <target state="translated">メタデータは、名前と値のペア(ポストデータとクエリ文字列パラメータ)として渡されます。</target>
        </trans-unit>
        <trans-unit id="b45afbd2f6f71f5bbf40bc713d36b1cb5591272d" translate="yes" xml:space="preserve">
          <source>Must reads are &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Representational State Transfer (REST)&lt;/a&gt; and &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIs must be hypertext-driven&lt;/a&gt;</source>
          <target state="translated">読み取りは、 &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Representational State Transfer（REST）で&lt;/a&gt;あり、 &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIはハイパーテキスト駆動である必要があります&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75117da5ea6dd4a55238ac032ebaaa4e06e4091c" translate="yes" xml:space="preserve">
          <source>Notice that we are using different HTTP verbs (&lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; etc.) to manipulate these resources, and that the only knowledge we presume on the client's part is our media definition.</source>
          <target state="translated">これらのリソースを操作するためにさまざまなHTTP動詞（ &lt;code&gt;GET&lt;/code&gt; 、 &lt;code&gt;PUT&lt;/code&gt; 、 &lt;code&gt;POST&lt;/code&gt; 、 &lt;code&gt;DELETE&lt;/code&gt; など）を使用しており、クライアント側で推測している唯一の知識はメディア定義であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="83b061b2a63b8f2183eb1bdcdd47faa9c5345256" translate="yes" xml:space="preserve">
          <source>Now, if all of this sounds familiar, then great. The Hypertext Transfer Protocol (HTTP), which defines the communication protocol via the World Wide Web is an implementation of the abstract notion of RESTful architecture (or an instance of the REST class if you're an OOP fanatic like me). In this implementation of REST, the client and server interact via GET, POST, PUT, DELETE, etc., which are part of the universal language and the resources can be pointed to using URLs.</source>
          <target state="translated">さて、このすべてが聞き覚えがあるように聞こえるならば、それは素晴らしいことです。ワールドワイドウェブを介して通信プロトコルを定義するハイパーテキスト転送プロトコル (HTTP)は、RESTful アーキテクチャの抽象的な概念の実装です (私のような OOP 狂信的な人は REST クラスのインスタンス)。RESTのこの実装では、クライアントとサーバーはGET、POST、PUT、DELETEなどを介して相互作用し、ユニバーサル言語の一部であり、URLを使用してリソースを指すことができます。</target>
        </trans-unit>
        <trans-unit id="e1a9621fd53f3f752aff5f25b313a5a3c60c684e" translate="yes" xml:space="preserve">
          <source>Old question, newish way of answering.  There's a lot of misconception out there about this concept.  I always try to remember:</source>
          <target state="translated">古い質問、新しい答え方。この概念には多くの誤解があります 常に覚えておくようにしています。</target>
        </trans-unit>
        <trans-unit id="438027d47ce1c5a96c385f53eecd236c425fb2b5" translate="yes" xml:space="preserve">
          <source>One of the best reference I found when I try to find the simple real meaning of rest.</source>
          <target state="translated">休息のシンプルな本当の意味を探そうとした時に見つけた最高の参考の一つです。</target>
        </trans-unit>
        <trans-unit id="c6f2d9e5ea80ff9b7b9ded9e2a81fb5f446691e1" translate="yes" xml:space="preserve">
          <source>POST updates an existing resource or creates a new resource.</source>
          <target state="translated">POSTは既存のリソースを更新したり、新しいリソースを作成したりします。</target>
        </trans-unit>
        <trans-unit id="d742711b2a6bd7b769816a15fa5a239a2c74f940" translate="yes" xml:space="preserve">
          <source>POST: &amp;ndash; It is used to create or update a new resource.</source>
          <target state="translated">POST：&amp;ndash;新しいリソースを作成または更新するために使用されます。</target>
        </trans-unit>
        <trans-unit id="37e0818cbbbc83b5f7771a4d5dfae0eb226e31e7" translate="yes" xml:space="preserve">
          <source>PUT creates a new resource. It must also be idempotent.</source>
          <target state="translated">PUTは新しいリソースを作成します。また、アイドempotentでなければなりません。</target>
        </trans-unit>
        <trans-unit id="ada2743b893defbc7c8ab2a60424b669dd79a22b" translate="yes" xml:space="preserve">
          <source>PUT: &amp;ndash; It is used to update or replace an existing resource or create a new resource.</source>
          <target state="translated">PUT：&amp;ndash;既存のリソースを更新または置換するか、新しいリソースを作成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="675a94eb09e6d971c2a74e502df85b0396498a6f" translate="yes" xml:space="preserve">
          <source>PayPal's API has hypermedia controls</source>
          <target state="translated">PayPalのAPIにはハイパーメディアコントロールがある</target>
        </trans-unit>
        <trans-unit id="330809f2cc51f1c140e1980086142c16a9addb97" translate="yes" xml:space="preserve">
          <source>Principle 1: Everything is a Resource
In the REST architectural style, data and functionality are considered resources and are accessed using Uniform Resource Identifiers (URIs), typically links on the Web.</source>
          <target state="translated">原則 1:すべてがリソース REST アーキテクチャスタイルでは、データと機能はリソースとみなされ、URI(Uniform Resource Identifiers)を使用してアクセスされます。</target>
        </trans-unit>
        <trans-unit id="8c699adbd41e9b331e5fbd3c027ab2582737eb63" translate="yes" xml:space="preserve">
          <source>Principle 2: Every Resource is Identified by a Unique Identifier (URI)</source>
          <target state="translated">原則2:すべてのリソースは一意の識別子(URI)で識別される</target>
        </trans-unit>
        <trans-unit id="b612f5757ab3b67dcdf0fc959e4a1f2295c39bfc" translate="yes" xml:space="preserve">
          <source>Principle 3: Use Simple and Uniform Interfaces</source>
          <target state="translated">原則3:シンプルで統一されたインターフェースを使用する</target>
        </trans-unit>
        <trans-unit id="1c4054641d8394bb16320893dba0d8f48d910d14" translate="yes" xml:space="preserve">
          <source>Principle 4: Communication is Done by Representation</source>
          <target state="translated">原則4:コミュニケーションは表現によって行われる</target>
        </trans-unit>
        <trans-unit id="52e149151dd57ddc7a1edcf0a393bb8fc2cc1dc9" translate="yes" xml:space="preserve">
          <source>Principle 5: Be Stateless</source>
          <target state="translated">原則5:無国籍であること</target>
        </trans-unit>
        <trans-unit id="3b6ad19884af654ebfaa84e23196de80335cb4c9" translate="yes" xml:space="preserve">
          <source>Protocols are limited to what you can communicate by using URLs.</source>
          <target state="translated">プロトコルは、URLを利用して通信できるものが限られています。</target>
        </trans-unit>
        <trans-unit id="ea0905504dfdf615e0862b8f2c6ac34fbc396c3b" translate="yes" xml:space="preserve">
          <source>REST (Representational State Transfer) is a design architecture that outlines how networked resources (i.e. nodes that share information) are designed and addressed. In general, a RESTful architecture makes it so that the client (the requesting machine) and the server (the responding machine) can request to read, write, and update data without the client having to know how the server operates and the server can pass it back without needing to know anything about the client. Okay, cool...but how do we do this in practice?</source>
          <target state="translated">REST (Representational State Transfer)は、ネットワーク化されたリソース(情報を共有するノード)がどのように設計され、対処されるかを概説する設計アーキテクチャです。一般的に、RESTfulアーキテクチャは、クライアント(要求するマシン)とサーバ(応答するマシン)が、クライアントがサーバの動作を知らなくてもデータの読み取り、書き込み、更新を要求でき、サーバはクライアントについて何も知らなくてもデータを受け渡すことができるようにします。いいですね。しかし、実際にはどうやってこれを行うのでしょうか?</target>
        </trans-unit>
        <trans-unit id="700c9dae20f56bed7f78e92f023ff70ce8630a9f" translate="yes" xml:space="preserve">
          <source>REST === HTTP analogy is not correct until you do not stress to the fact that it &quot;MUST&quot; be &lt;a href=&quot;http://restfulapi.net/hateoas/&quot;&gt;HATEOAS&lt;/a&gt; driven.</source>
          <target state="translated">REST === HTTPの類推は、 &lt;a href=&quot;http://restfulapi.net/hateoas/&quot;&gt;HATEOAS&lt;/a&gt;駆動である必要があるという事実を強調しない限り、正しくありません。</target>
        </trans-unit>
        <trans-unit id="8d900533fc0307874766ce99858e2dca6a98b0ed" translate="yes" xml:space="preserve">
          <source>REST allows that resources have different representations, e.g., text, XML, JSON etc. The REST client can ask for a specific representation via the HTTP protocol (content negotiation).</source>
          <target state="translated">REST では、リソースがテキスト、XML、JSON などの異なる表現を持つことができます。REST クライアントは、HTTP プロトコル (content negotiation)を介して特定の表現を要求することができます。</target>
        </trans-unit>
        <trans-unit id="d7e35d79a67bcd2fd91ce8bbd613ef5c12223b40" translate="yes" xml:space="preserve">
          <source>REST also permits communication between computers with each other over a network.</source>
          <target state="translated">また、RESTは、ネットワークを介してコンピュータ同士の通信を可能にします。</target>
        </trans-unit>
        <trans-unit id="7bebea77f381f6a449770f9552c88ba86e2ca2da" translate="yes" xml:space="preserve">
          <source>REST constraints result a highly scalable system in where the clients are decoupled from the implementations of the services. So the clients can be reusable, general just like the browsers on the web. The clients and the services share the same standards and vocabs, so they can understand each other despite the fact that the client does not know the implementation details of the service. This makes possible to create automated clients which can find and utilize REST services to achieve their goals. In long term these clients can communicate to each other and trust each other with tasks, just like humans do. If we add learning patterns to such clients, then the result will be one or more AI using the web of machines instead of a single server park. So at the end the dream of Berners Lee: the semantic web and the artificial intelligence will be reality. So in 2030 we end up terminated by the Skynet. Until then ... ;-)</source>
          <target state="translated">REST制約は、クライアントがサービスの実装から切り離された高度にスケーラブルなシステムをもたらします。そのため、クライアントは、ウェブ上のブラウザのように、再利用可能な一般的なものにすることができます。クライアントとサービスは同じ標準とボキャブラを共有しているので、クライアントがサービスの実装の詳細を知らなくても、お互いを理解することができます。これにより、目的を達成するためにRESTサービスを見つけて利用することができる自動化されたクライアントを作成することが可能になります。長期的には、これらのクライアントは、人間と同じように、お互いにコミュニケーションをとり、タスクを信頼し合うことができます。このようなクライアントに学習パターンを追加すれば、その結果、単一のサーバーパークではなく、機械のウェブを利用した1つ以上のAIが誕生することになるだろう。そうすれば、最後にはバーナーズ・リーの夢であるセマンティック・ウェブと人工知能が現実のものとなるだろう。だから2030年に我々はスカイネットによって終了してしまう。それまでは...;-)</target>
        </trans-unit>
        <trans-unit id="34698ed4c6b87bbba6909fe832abf0a97a18c1e4" translate="yes" xml:space="preserve">
          <source>REST defines 6 architectural constraints which make any web service &amp;ndash; a &lt;strong&gt;true RESTful API&lt;/strong&gt;.</source>
          <target state="translated">RESTは、あらゆるWebサービスを実現する6つのアーキテクチャ上の制約、つまり&lt;strong&gt;真のRESTful APIを&lt;/strong&gt;定義してい&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b8ff55c8c9a0ce9cfafc137b16baaa14a81abbf" translate="yes" xml:space="preserve">
          <source>REST in official words, REST is an architectural style built on certain principles using the current &amp;ldquo;Web&amp;rdquo; fundamentals.
There are 5 basic fundamentals of web which are leveraged to create REST services.</source>
          <target state="translated">RESTは公式に言えば、RESTは現在の「Web」の基礎を使用した特定の原則に基づいて構築されたアーキテクチャスタイルです。 RESTサービスを作成するために活用されるWebの5つの基本的な基本があります。</target>
        </trans-unit>
        <trans-unit id="24e5aabd86f26882f23d01381f1a89f3a170449f" translate="yes" xml:space="preserve">
          <source>REST is a lightweight alternative to mechanisms like RPC (Remote
  Procedure Calls) and Web Services (SOAP, WSDL, et al.). Later, we will
  see how much more simple REST is.</source>
          <target state="translated">RESTは、RPC(Remote Procedure Calls)やWebサービス(SOAP、WSDLなど)のような仕組みに代わる軽量なものです。後に、RESTがどれだけシンプルなものかを見ていきましょう。</target>
        </trans-unit>
        <trans-unit id="41d578dc3834d7de2f8d99a70b26c5ce81a848f5" translate="yes" xml:space="preserve">
          <source>REST is an &lt;em&gt;architecture style&lt;/em&gt; for designing networked applications.
  The idea is that, rather than using complex mechanisms such as CORBA,
  RPC or SOAP to connect between machines, simple HTTP is used to make
  calls between machines.</source>
          <target state="translated">RESTは、ネットワークアプリケーションを設計するための&lt;em&gt;アーキテクチャスタイル&lt;/em&gt;です。 考え方は、CORBA、RPC、SOAPなどの複雑なメカニズムを使用してマシン間を接続するのではなく、単純なHTTPを使用してマシン間で呼び出しを行うというものです。</target>
        </trans-unit>
        <trans-unit id="81954ff90e3db76a59f3feac17fcae16db3073fb" translate="yes" xml:space="preserve">
          <source>REST is an architectural pattern and style of writing distributed applications. It is not a programming style in the narrow sense.</source>
          <target state="translated">RESTは、分散型アプリケーションを書くためのアーキテクチャパターンであり、スタイルです。狭義のプログラミングスタイルではありません。</target>
        </trans-unit>
        <trans-unit id="6e3584ec485599f05ec62cb2d6b674b68d8c649a" translate="yes" xml:space="preserve">
          <source>REST is an architecture style for designing networked applications.
  The idea is that, rather than using complex mechanisms such as CORBA,
  RPC or SOAP to connect between machines, simple HTTP is used to make
  calls between machines.</source>
          <target state="translated">RESTは、ネットワーク化されたアプリケーションを設計するためのアーキテクチャスタイルです。これは、CORBA、RPC、SOAPなどの複雑なメカニズムを使ってマシン間を接続するのではなく、シンプルなHTTPを使ってマシン間の呼び出しを行うという考え方です。</target>
        </trans-unit>
        <trans-unit id="6663bc679f3ecc9321597d4c451eda8a030d5e82" translate="yes" xml:space="preserve">
          <source>REST is often used in mobile applications, social networking Web sites, mashup tools and automated business processes. The REST style emphasizes that interactions between clients and services is enhanced by having a limited number of operations (verbs). Flexibility is provided by assigning resources (nouns) their own unique universal resource indicators (URIs).</source>
          <target state="translated">RESTは、モバイルアプリケーション、ソーシャルネットワーキングのWebサイト、マッシュアップツール、自動化されたビジネスプロセスなどでよく使われています。RESTスタイルでは、クライアントとサービス間の相互作用が、限られた数の操作(動詞)を持つことで強化されることを強調しています。柔軟性は、リソース(名詞)に独自の普遍的なリソース指標(URI)を割り当てることで提供されます。</target>
        </trans-unit>
        <trans-unit id="801d3af1b3e139b50282c4fab565cd444620074b" translate="yes" xml:space="preserve">
          <source>REST is using the various HTTP methods (mainly GET/PUT/DELETE) to manipulate data.</source>
          <target state="translated">RESTでは、各種HTTPメソッド(主にGETPUTDELETE)を使ってデータを操作しています。</target>
        </trans-unit>
        <trans-unit id="3a544da22b9e3f4d834aba2d28e038cfc7c394d2" translate="yes" xml:space="preserve">
          <source>REST messages often accepts the form either in form of XML, or JavaScript Object Notation (JSON).</source>
          <target state="translated">REST メッセージは、XML または JavaScript Object Notation (JSON)のどちらかの形式で受け取ることが多いです。</target>
        </trans-unit>
        <trans-unit id="ec356ddaca2bf110584184b56abbca5c18c7f324" translate="yes" xml:space="preserve">
          <source>REST proponents tend to favor URLs, such as</source>
          <target state="translated">REST推進派は、次のようなURLを好む傾向があります。</target>
        </trans-unit>
        <trans-unit id="cdaffecf9a4b409c44dd9af81374c459b9474d48" translate="yes" xml:space="preserve">
          <source>REST stands for &quot;representational state transfer&quot;, which means it's all about communicating and modifying &lt;strong&gt;the state&lt;/strong&gt; of some resource in a system.</source>
          <target state="translated">RESTは「表現状態転送」を意味します。これは、システム内のリソース&lt;strong&gt;の状態&lt;/strong&gt;を通信および変更する&lt;strong&gt;こと&lt;/strong&gt;に関するすべてです。</target>
        </trans-unit>
        <trans-unit id="9451e5791b00a17503496c3f9586128ae49e1831" translate="yes" xml:space="preserve">
          <source>REST stands for Representational State Transfer. (It is sometimes
  spelled &quot;ReST&quot;.) It relies on a stateless, client-server, cacheable
  communications protocol -- and in virtually all cases, the HTTP
  protocol is used.</source>
          <target state="translated">RESTはRepresentational State Transferの略です(「ReST」と表記されることもあります)。(ReSTと綴られることもあります。)これは、ステートレス、クライアント・サーバ、キャッシュ可能な通信プロトコルに依存しており、事実上すべてのケースでHTTPプロトコルが使用されます。</target>
        </trans-unit>
        <trans-unit id="3d1d7194413fe6b5bd76ca3ce8b73781e5ea0578" translate="yes" xml:space="preserve">
          <source>REST unlike home styles has had a tough time being consistently and practically applied. This may have been intentional. Leaving its actual implementation up to the designer. So you are free to do what you want so as long as you meet the constraints set out in the dissertation you are creating REST Systems.</source>
          <target state="translated">RESTはホームスタイルとは異なり、一貫して実践的に適用されるのに苦労してきました。これは意図的なものかもしれません。実際の実装はデザイナーに委ねられています。だから、あなたがRESTシステムを作成している論文に定められた制約を満たす限り、あなたが望むことを自由に行うことができます。</target>
        </trans-unit>
        <trans-unit id="4ac191e5aa73c941d92cf5c5a7bdc101ccf17488" translate="yes" xml:space="preserve">
          <source>REST, operates on resource representations, each one identified by an URL. These are typically not data objects, but &lt;strong&gt;complex objects abstractions&lt;/strong&gt;.</source>
          <target state="translated">RESTは、それぞれがURLで識別されるリソース表現で動作します。 これらは通常、データオブジェクトではなく、 &lt;strong&gt;複雑なオブジェクトの抽象化&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="20bbdde9c5678f79d072b94099e0cd21aa108d71" translate="yes" xml:space="preserve">
          <source>REST: Representational State Transfer.</source>
          <target state="translated">RESTです。代表的な状態遷移。</target>
        </trans-unit>
        <trans-unit id="0b418318f4f02e384e5a14b7c46def85c5fbf491" translate="yes" xml:space="preserve">
          <source>RESTful applications use HTTP requests to post data (create and/or
  update), read data (e.g., make queries), and delete data. Thus, REST
  uses HTTP for all four CRUD (Create/Read/Update/Delete) operations.</source>
          <target state="translated">RESTful アプリケーションは、データの投稿(作成や更新)、データの読み込み(クエリの作成など)、データの削除に HTTP リクエストを使用します。このように、RESTは4つのCRUD(CreateReadUpdateDelete)操作すべてにHTTPを使用します。</target>
        </trans-unit>
        <trans-unit id="d1feb4628e89cf3c408102d8d1c78190e38e6958" translate="yes" xml:space="preserve">
          <source>RESTful programming conforms to Web architecture design and, if properly implemented, it allows you to take the full advantage of scalable Web infrastructure.</source>
          <target state="translated">RESTfulプログラミングはWebアーキテクチャの設計に準拠しており、適切に実装されていれば、スケーラブルなWebインフラを最大限に活用することができます。</target>
        </trans-unit>
        <trans-unit id="606ada79ad1420f9107ba76e74d9a5b5dc8a1dc1" translate="yes" xml:space="preserve">
          <source>RESTful programming is about:</source>
          <target state="translated">RESTfulなプログラミングとは</target>
        </trans-unit>
        <trans-unit id="95c224223718abd56088ba177080385db881b4c6" translate="yes" xml:space="preserve">
          <source>RESTful programming is not for APIs</source>
          <target state="translated">RESTfulプログラミングはAPIのためのものではない</target>
        </trans-unit>
        <trans-unit id="1b6a739654e06f630f96467756d48d1acd0d09d0" translate="yes" xml:space="preserve">
          <source>Rather than using a specific URL to delete a method (say, &lt;code&gt;/user/123/delete&lt;/code&gt;), you would send a DELETE request to the &lt;code&gt;/user/[id]&lt;/code&gt; URL, to edit a user, to retrieve info on a user you send a GET request to &lt;code&gt;/user/[id]&lt;/code&gt;</source>
          <target state="translated">特定のURLを使用してメソッド（たとえば、 &lt;code&gt;/user/123/delete&lt;/code&gt; ）を削除するのではなく、DELETEリクエストを &lt;code&gt;/user/[id]&lt;/code&gt; URLに送信して、ユーザーを編集し、送信したユーザーの情報を取得します &lt;code&gt;/user/[id]&lt;/code&gt; へのGETリクエスト</target>
        </trans-unit>
        <trans-unit id="7d997a652dd80f71fb70e3ef43e6973ddd897ea7" translate="yes" xml:space="preserve">
          <source>Representation - all communication is done by representation (e.g. &lt;a href=&quot;http://en.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;)</source>
          <target state="translated">表現-すべての通信は表現（ &lt;a href=&quot;http://en.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSONなど&lt;/a&gt; ）によって行われます</target>
        </trans-unit>
        <trans-unit id="2cd1d833a928d3195b51e6cfbe331c8c09c671dd" translate="yes" xml:space="preserve">
          <source>Resource (data, information).</source>
          <target state="translated">リソース(データ、情報)。</target>
        </trans-unit>
        <trans-unit id="688688c5509b4d381bf4bce90f16794ddee6aacb" translate="yes" xml:space="preserve">
          <source>Resources are requested via URLs.</source>
          <target state="translated">リソースはURLでリクエストします。</target>
        </trans-unit>
        <trans-unit id="c171c3ae71443c15b078bb93540e67b075abe63a" translate="yes" xml:space="preserve">
          <source>Richardson's Maturity Model</source>
          <target state="translated">リチャードソンの成熟度モデル</target>
        </trans-unit>
        <trans-unit id="07bef3db6d8f0a971b46410592e99f25edb3d822" translate="yes" xml:space="preserve">
          <source>Roy Fielding, who coined the term, says &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIs must be hypertext-driven&lt;/a&gt;.  In particular, &quot;A REST API must not define fixed resource names or hierarchies&quot;.</source>
          <target state="translated">この用語を作り出したロイフィールディング氏は、 &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIはハイパーテキスト駆動である必要がある&lt;/a&gt;と述べています 。 特に、「REST APIは固定のリソース名または階層を定義してはなりません」。</target>
        </trans-unit>
        <trans-unit id="4ed7f7fd296ad882c584b68eec97a766f06c9204" translate="yes" xml:space="preserve">
          <source>Roy himself cleared it &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">ロイ自身が&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;ここで&lt;/a&gt;それをクリアしました 。</target>
        </trans-unit>
        <trans-unit id="ea8f1dff43bf90df7c15069182244296157f5ccf" translate="yes" xml:space="preserve">
          <source>Saying that Rest is just a syntactic change from using GET requests with an action parameter to using the available http verbs makes it look like it has no benefits and is purely cosmetic. The point is to use a language that can be understood and optimized by every part of the chain. If your GET operation has an action with side effects, you have to skip all HTTP caching or you'll end up with inconsistent results.</source>
          <target state="translated">Restはアクションパラメータを持つGETリクエストを使用していたのを、利用可能なhttp動詞を使用するように構文的に変更しただけだと言うことは、何のメリットもなく、純粋に化粧品のように見えてしまいます。重要なのは、チェーンのすべての部分で理解され、最適化された言語を使うことです。もし GET 操作に副作用のあるアクションがある場合は、すべての HTTP キャッシングをスキップしなければならず、一貫性のない結果になってしまいます。</target>
        </trans-unit>
        <trans-unit id="c4a2bd1212341d753b25f32677d4e7adf44e6015" translate="yes" xml:space="preserve">
          <source>Saying you use the REST style is similar to saying that you built a house in a particular style: for example Tudor or Victorian.  Both REST as an software style and Tudor or Victorian as a home style can be defined by the qualities and constraints that make them up. For example REST must have Client Server separation where messages are self-describing. Tudor style homes have Overlapping gables and Roofs that are steeply pitched with front facing gables. You can read Roy's dissertation to learn more about the constraints and qualities that make up REST.</source>
          <target state="translated">RESTスタイルを使用していると言うことは、特定のスタイルで家を建てたと言うことに似ています。ソフトウェアのスタイルとしてのRESTも、家のスタイルとしてのチューダーやヴィクトリア朝のスタイルも、それらを構成する品質や制約によって定義することができます。例えば、RESTは、メッセージが自己記述されているクライアント・サーバ分離をしなければなりません。チューダー様式の住宅は、重なり合う切妻と急勾配の屋根を持ち、正面に面した切妻がある。RESTを構成する制約や品質については、Royさんの論文を読んでみてください。</target>
        </trans-unit>
        <trans-unit id="8e446171e587e12eabf8b79616dc1eb91a5a4557" translate="yes" xml:space="preserve">
          <source>See Martin Fowlers article the &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;Richardson Maturity Model&lt;/a&gt; (RMM) for an explanation on what an RESTful service is.</source>
          <target state="translated">RESTfulサービスとは何かについての説明は、Martin Fowlersの記事&lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;Richardson Maturity Model&lt;/a&gt; （RMM）を参照してください。</target>
        </trans-unit>
        <trans-unit id="fbe751100f5c892656ce1ca4a6009c25fbfc7f4b" translate="yes" xml:space="preserve">
          <source>Select content-Header</source>
          <target state="translated">コンテンツヘッダーを選択</target>
        </trans-unit>
        <trans-unit id="16ed5c31752ac3f8db0119aea87a82b307c230ed" translate="yes" xml:space="preserve">
          <source>Select the REST method</source>
          <target state="translated">REST メソッドを選択します。</target>
        </trans-unit>
        <trans-unit id="c0c99a62016d0168acb95e1b7c7865a1070d884a" translate="yes" xml:space="preserve">
          <source>So if your &quot;/user/123&quot; path is hardcoded on the client, it's not really RESTful.  A good use of HTTP, maybe, maybe not.  But not RESTful.  It has to come from hypertext.</source>
          <target state="translated">つまり、&quot;user123 &quot;のパスがクライアントでハードコードされている場合、それは本当の意味でのRESTfulではないということです。HTTPの良い使い方かもしれませんが、そうではないかもしれません。しかし、RESTfulではありません。ハイパーテキストから来ている必要があります。</target>
        </trans-unit>
        <trans-unit id="536946ca2831340799bf33cd36af457db31978e1" translate="yes" xml:space="preserve">
          <source>So it does not work with for example PUB/SUB sockets, it is based on REQ/REP.</source>
          <target state="translated">そのため、例えばPUBSUBソケットでは動作せず、REQREPをベースにしています。</target>
        </trans-unit>
        <trans-unit id="cb3acf66e66e8ac82b059d304608e2b649d07fd9" translate="yes" xml:space="preserve">
          <source>So the server does not maintain the states of the clients. This means that you cannot use server a side session storage and you have to authenticate every request. Your clients possibly send basic auth headers through an encrypted connection. (By large applications it is hard to maintain many sessions.)</source>
          <target state="translated">そのため、サーバはクライアントの状態を保持しません。これは、サーバサイドのセッションストレージを使用することができず、すべてのリクエストを認証しなければならないことを意味します。クライアントは暗号化された接続を介して基本的な認証ヘッダを送信するかもしれません。(大規模なアプリケーションでは、多くのセッションを維持することは困難です。)</target>
        </trans-unit>
        <trans-unit id="9607344c01bb579773361b71bbb45cde205cc658" translate="yes" xml:space="preserve">
          <source>So you don't have to serve the same requests again and again.</source>
          <target state="translated">なので、何度も同じ要望を出す必要はありません。</target>
        </trans-unit>
        <trans-unit id="6755df0f56ac5cee70d67ea5c025e47782da8d98" translate="yes" xml:space="preserve">
          <source>State transition controls only make sense if the client and server agree upon a media type representation of the resource.  Otherwise there's no way to know what's a control and what isn't and how to execute a control.  IE if browsers didn't know &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags in html then there'd be nothing for you to submit to transition state in your browser.</source>
          <target state="translated">状態遷移制御は、クライアントとサーバーがリソースのメディアタイプ表現について合意した場合にのみ意味があります。 それ以外の場合は、コントロールとは何か、そうでないものと、コントロールを実行する方法を知る方法はありません。 IEがブラウザーでhtmlの &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; タグを認識していなかった場合、ブラウザーの遷移状態に送信するものは何もありません。</target>
        </trans-unit>
        <trans-unit id="cc782a4dc89d3cf79cc09c506daf5966811372c9" translate="yes" xml:space="preserve">
          <source>Stateless</source>
          <target state="translated">Stateless</target>
        </trans-unit>
        <trans-unit id="c2fa7bc4bb797a9f80155f336549e20f8ae9f995" translate="yes" xml:space="preserve">
          <source>Steps to Automate REST API</source>
          <target state="translated">REST APIを自動化するためのステップ</target>
        </trans-unit>
        <trans-unit id="266d1df5b50f526d563a69c1948ed69ee2a31597" translate="yes" xml:space="preserve">
          <source>Structured URLs and Http Methods/Verbs are not the definition of
restful programming.</source>
          <target state="translated">構造化 URL や Http Methods 動詞は restful プログラミングの定義ではありません。</target>
        </trans-unit>
        <trans-unit id="8f7198c3c2d3db3f7cabeab606f0ec990cba16f4" translate="yes" xml:space="preserve">
          <source>That xfront document explains the difference between REST and SOAP, and this is really helpful too. When Fielding says, &quot;&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;That is RPC. It screams RPC.&lt;/a&gt;&quot;, it's clear that RPC is not RESTful, so it's useful to see the exact reasons for this. (SOAP is a type of RPC.)</source>
          <target state="translated">そのxfrontドキュメントはRESTとSOAPの違いを説明しており、これも非常に役立ちます。 フィールディングが「 &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;RPCだ&lt;/a&gt; 。RPCは悲鳴を上げる 」と言ったとき、RPCがRESTfulではないことは明らかなので、これの正確な理由を確認することは有用です。 （SOAPはRPCの一種です。）</target>
        </trans-unit>
        <trans-unit id="11640c3d32a9a0b61aeecdb5c9ad7a185581310a" translate="yes" xml:space="preserve">
          <source>The HATEOAS constraint is an acronym
  for Hypermedia as the Engine of
  Application State. This principle is
  the key differentiator between a REST
  and most other forms of client server
  system.</source>
          <target state="translated">HATEOAS制約は、Hypermedia as the Engine of Application Stateの頭文字をとったものです。この原則は、REST と他のほとんどの形式のクライアントサーバシステムとの間の重要な差別化要因です。</target>
        </trans-unit>
        <trans-unit id="6a4c43170c5294cf2068284ddf81b0942eff7050" translate="yes" xml:space="preserve">
          <source>The PUT, GET, POST and DELETE methods are typical used in REST based architectures. The following table gives an explanation of these operations.</source>
          <target state="translated">REST ベースのアーキテクチャでは、PUT、GET、POST、DELETE メソッドが典型的に使用されています。次の表は、これらの操作について説明しています。</target>
        </trans-unit>
        <trans-unit id="debfff33bf7e7352ae30422dd3def567e5f7259f" translate="yes" xml:space="preserve">
          <source>The REST constraints are the following:</source>
          <target state="translated">REST制約は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="363845c5633e5276f4ad26162098f583201cc8cf" translate="yes" xml:space="preserve">
          <source>The REST system is composed of hierarchical layers. Each layer contains components which use the services of components which are in the next layer below. So you can add new layers and components effortless.</source>
          <target state="translated">RESTシステムは、階層的なレイヤーで構成されています。各レイヤーには、次のレイヤーにあるコンポーネントのサービスを利用するコンポーネントが含まれています。そのため、新しいレイヤーやコンポーネントを簡単に追加することができます。</target>
        </trans-unit>
        <trans-unit id="5aaa535e7837eae3a4f80e39cfc9d687c46ea8d0" translate="yes" xml:space="preserve">
          <source>The answer is very simple, there is a &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;dissertation&lt;/a&gt; written by Roy Fielding.]&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;1&lt;/a&gt; In that dissertation he defines the REST principles. If an application fulfills all of those principles, then that is a REST application.</source>
          <target state="translated">答えは非常に簡単です&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;。RoyFielding&lt;/a&gt;によって書かれた論文があります。] &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;1&lt;/a&gt;その論文で、彼はRESTの原則を定義しています。 アプリケーションがこれらの原則のすべてを満たしている場合、それはRESTアプリケーションです。</target>
        </trans-unit>
        <trans-unit id="4f20d992e77c2fef0f2a4c004149838f65239268" translate="yes" xml:space="preserve">
          <source>The contract between the client and the server is not maintained by the server. In other words the client must be decoupled from the implementation of the service. You can reach this state by using standard solutions, like the IRI (URI) standard to identify resources, the HTTP standard to exchange messages, standard MIME types to describe the body serialization format, metadata (possibly RDF vocabs, microformats, etc.) to describe the semantics of different parts of the message body. To decouple the IRI structure from the client, you have to send hyperlinks to the clients in hypermedia formats like (HTML, JSON-LD, HAL, etc.). So a client can use the metadata (possibly link relations, RDF vocabs) assigned to the hyperlinks to navigate the state machine of the application through the proper state transitions in order to achieve its current goal.</source>
          <target state="translated">クライアントとサーバの間の契約は、サーバによって維持されません。言い換えれば、クライアントはサービスの実装から切り離されなければなりません。リソースを識別するための IRI (URI)標準、メッセージを交換するための HTTP 標準、ボディのシリアライズ形式を記述するための標準 MIME タイプ、メッセージボディのさまざまな部分のセマンティクスを記述するためのメタデータ (おそらく RDF ボキャブラ、マイクロフォーマットなど)などの標準的なソリューションを使用することで、この状態に到達することができます。IRI 構造をクライアントから切り離すには、ハイパーリンクを (HTML,JSON-LD,HAL など)ハイパーメディア形式でクライアントに送らなければなりません。クライアントはハイパーリンクに割り当てられたメタデータ(リンク関係、RDFボキャブラ)を使って、現在の目標を達成するために、アプリケーションのステートマシンを適切な状態遷移を通してナビゲートすることができます。</target>
        </trans-unit>
        <trans-unit id="5eac8561aeea8b795c8a15b197b4655d18a46b3e" translate="yes" xml:space="preserve">
          <source>The entire web is based on REST (or REST was based on the web). Therefore as a web developer you might want aware of that although it's not necessary to write good web apps.</source>
          <target state="translated">ウェブ全体はRESTをベースにしています(あるいはRESTはウェブをベースにしていました)。そのため、良いWebアプリを書く必要はありませんが、Web開発者としてはその点を意識しておくと良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="c7820ce4adf25178f490423f73f586fe8480e441" translate="yes" xml:space="preserve">
          <source>The last one is probably the most important in terms of consequences and overall effectiveness of REST. Overall, most of the RESTful discussions seem to center on HTTP and its usage from a browser and what not. I understand that R. Fielding coined the term when he described the architecture and decisions that lead to HTTP. His thesis is more about the architecture and cache-ability of resources than it is about HTTP.</source>
          <target state="translated">最後の1つは、RESTの結果や全体的な有効性という点で、おそらく最も重要なものです。全体的に、RESTfulな議論のほとんどは、HTTPとそのブラウザからの利用方法などが中心になっているように思います。R.Fielding氏がHTTPにつながるアーキテクチャと決定を述べたときにこの言葉を造語したと理解しています。彼の論文は、HTTPについてというよりも、リソースのアーキテクチャやキャッシュアビリティについてのものです。</target>
        </trans-unit>
        <trans-unit id="b32979991407cd39a66f760547c127248522b7ba" translate="yes" xml:space="preserve">
          <source>The last thing that you&amp;rsquo;ll often here about RESTful architectures is that they are layered. We have actually already been implicitly discussing this requirement in our discussion of the interaction between the client and server. Basically, this means that each layer in our system interacts only with adjacent layers. So in our discussion, the client layer interacts with our server layer (and vice versa), but there might be other server layers that help the primary server process a request that the client does not directly communicate with. Rather, the server passes on the request as necessary.</source>
          <target state="translated">RESTfulアーキテクチャーについてここでよく目にする最後のことは、それらが階層化されていることです。 この要件については、クライアントとサーバー間の相互作用についての議論で既に暗黙のうちに議論されています。 基本的に、これは、システムの各レイヤーが隣接するレイヤーとのみ相互作用することを意味します。 したがって、私たちの議論では、クライアント層はサーバー層と相互に作用します（逆も同様です）が、クライアントが直接通信しない要求をプライマリサーバーが処理するのを助ける他のサーバー層があるかもしれません。 むしろ、サーバーは必要に応じてリクエストを渡します。</target>
        </trans-unit>
        <trans-unit id="3ad594a4eee6f4393aea9d6f9c591653f6d82996" translate="yes" xml:space="preserve">
          <source>The many much better answers on this very page.</source>
          <target state="translated">このページの多くのはるかに良い答え。</target>
        </trans-unit>
        <trans-unit id="f34a56b5b9cc5fb499cc45ca49da52dec1ae7242" translate="yes" xml:space="preserve">
          <source>The most obvious requirement is that there needs to be a universal language of some sort so that the server can tell the client what it is trying to do with the request and for the server to respond.</source>
          <target state="translated">最も明白な要件は、ある種の普遍的な言語が必要であるということです。</target>
        </trans-unit>
        <trans-unit id="c1949f81259fdfb5a99b7b1901beff7c9ea4dc3c" translate="yes" xml:space="preserve">
          <source>The point of rest is that if we agree to use a common language for basic operations (the http verbs), the infrastructure can be configured to understand them and optimize them properly, for example, by making use of caching headers to implement caching at all levels.</source>
          <target state="translated">休みのポイントは、基本的な操作(http動詞)に共通言語を使うことに合意すれば、それを理解して適切に最適化するためのインフラストラクチャを構成することができ、例えば、キャッシュヘッダを利用してすべてのレベルでキャッシュを実装することができるということです。</target>
        </trans-unit>
        <trans-unit id="adcd5a6756875181e58c7a89806bd16236c307a3" translate="yes" xml:space="preserve">
          <source>The server responds:</source>
          <target state="translated">サーバーが応答します。</target>
        </trans-unit>
        <trans-unit id="d84fe7aa11f8f900fefc9b179edc3003cd01912b" translate="yes" xml:space="preserve">
          <source>There is not such notion as &quot;RESTful programming&quot; per se. It would be better called RESTful paradigm or even better RESTful architecture. It is not a programming language. It is a paradigm.</source>
          <target state="translated">RESTful プログラミング」という概念はありません。RESTfulパラダイム、あるいはRESTfulアーキテクチャと呼んだ方が良いでしょう。これはプログラミング言語ではありません。パラダイムです。</target>
        </trans-unit>
        <trans-unit id="86c7098a4bc3a5c3742a2441c8884a81a07a366c" translate="yes" xml:space="preserve">
          <source>There's a fairly good example here:</source>
          <target state="translated">ここにはかなり良い例があります。</target>
        </trans-unit>
        <trans-unit id="905d4728fcc1cb89a5cb1a3e73d508f59109d989" translate="yes" xml:space="preserve">
          <source>Therefore, we impose the restriction that each request-response pair between the client and the server is independent, meaning that the server doesn&amp;rsquo;t have to remember anything about previous requests (previous states of the client-server interaction) to respond to a new request. This means that we want our interactions to be stateless.</source>
          <target state="translated">したがって、クライアントとサーバー間の各要求と応答のペアは独立しているという制限を課します。これは、サーバーが新しい要求に応答するために、以前の要求（クライアントとサーバーの相互作用の以前の状態）について何も覚えておく必要がないことを意味します。リクエスト。 これは、相互作用がステートレスであることを望んでいることを意味します。</target>
        </trans-unit>
        <trans-unit id="2a100f405ce7bcd9b4b68b83fcd25889ccf5143e" translate="yes" xml:space="preserve">
          <source>This constraint is optional. For example you can send a parser for a specific media type to the client, and so on... In order to do this you might need a standard plugin loader system in the client, or your client will be coupled to the plugin loader solution.</source>
          <target state="translated">この制約はオプションです。例えば、特定のメディアタイプのパーサをクライアントに送ることができます。これを行うには、クライアントに標準的なプラグインローダーシステムが必要になるかもしれませんし、クライアントはプラグインローダーソリューションに結合されます。</target>
        </trans-unit>
        <trans-unit id="a433790865d58bd8f02ff1f47ffaf65f408a91fa" translate="yes" xml:space="preserve">
          <source>This is amazingly long &quot;discussion&quot; and yet quite confusing to say the least.</source>
          <target state="translated">これは驚くほど長い「議論」であるが、控えめに言ってもかなり混乱している。</target>
        </trans-unit>
        <trans-unit id="03de43a18514c80205249c972ff6f45137f701c5" translate="yes" xml:space="preserve">
          <source>This is taken from the excellent book &lt;em&gt;Core JavaServer faces&lt;/em&gt; book by David M. Geary.</source>
          <target state="translated">これは、David M. Gearyによる著書&lt;em&gt;Core JavaServer faces&lt;/em&gt; bookから抜粋したものです。</target>
        </trans-unit>
        <trans-unit id="f84a19d4bf6f78ec8c5e5044a550ad4a25f94cc7" translate="yes" xml:space="preserve">
          <source>This is very less mentioned everywhere but the &lt;strong&gt;Richardson's Maturity Model&lt;/strong&gt; is one of the best methods to actually judge how Restful is one's API. More about it here:</source>
          <target state="translated">これについてはあまり言及されていませんが、 &lt;strong&gt;Richardsonの成熟度モデル&lt;/strong&gt;は、RestfulがAPIであるかどうかを実際に判断するための最良の方法の1つです。 詳細はこちら：</target>
        </trans-unit>
        <trans-unit id="d0c1d3305c31f371cda13faed5816c6263e72163" translate="yes" xml:space="preserve">
          <source>This is what it might look like.</source>
          <target state="translated">こんな感じになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="d9c095fa6595fd926bd9860ca44ab7d426923a2d" translate="yes" xml:space="preserve">
          <source>To be RESTful a Service needs to fulfill the &lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot;&gt;Hypermedia as the Engine of Application State. (HATEOAS)&lt;/a&gt;, that is, it needs to reach level 3 in the RMM, &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;read the article&lt;/a&gt; for details or the &lt;a href=&quot;http://www.crummy.com/writing/speaking/2008-QCon/act3.html&quot;&gt;slides from the qcon talk&lt;/a&gt;.</source>
          <target state="translated">RESTfulであるためには、サービス&lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot;&gt;はアプリケーション状態のエンジンとしてハイパーメディア&lt;/a&gt;を満たす必要があります。 （HATEOAS） 、つまり、RMMでレベル3に到達する必要があります。詳細については&lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;、記事&lt;/a&gt;または&lt;a href=&quot;http://www.crummy.com/writing/speaking/2008-QCon/act3.html&quot;&gt;qconトークのスライド&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="43e0b98e4c9a963450bac2bcfe7ffa0f28070108" translate="yes" xml:space="preserve">
          <source>To be a restful programmer you must be trying to build applications that allow actors to do things.  Not just exposing the database.</source>
          <target state="translated">安静なプログラマーになるためには、アクターが何かをすることを可能にするアプリケーションを構築しようとしなければなりません。データベースを公開するだけではありません。</target>
        </trans-unit>
        <trans-unit id="88f5ecedd3cc21540bbf662f89334d1c596c1065" translate="yes" xml:space="preserve">
          <source>To further ease the strain on our server from redoing computations that have already been recently done for a given client, REST also allows caching. Basically, caching means to take a snapshot of the initial response provided to the client. If the client makes the same request again, the server can provide the client with the snapshot rather than redo all of the computations that were necessary to create the initial response. However, since it is a snapshot, if the snapshot has not expired--the server sets an expiration time in advance--and the response has been updated since the initial cache (i.e. the request would give a different answer than the cached response), the client will not see the updates until the cache expires (or the cache is cleared) and the response is rendered from scratch again.</source>
          <target state="translated">特定のクライアントに対して既に最近行われた計算をやり直すことによるサーバーへの負担をさらに軽減するために、RESTではキャッシングも可能にしています。基本的に、キャッシングとは、クライアントに提供された最初のレスポンスのスナップショットを取ることを意味します。クライアントが再び同じリクエストをした場合、最初のレスポンスを作成するために必要だった計算をすべてやり直すのではなく、サーバはスナップショットをクライアントに提供することができます。しかしながら、スナップショットなので、スナップショットが有効期限切れになっていない場合(サーバーは事前に有効期限を設定しています)、最初のキャッシュ以降にレスポンスが更新されている場合(つまり、リクエストがキャッシュされたレスポンスとは異なる答えを与えることになります)、キャッシュが有効期限切れ(またはキャッシュがクリアされる)になり、レスポンスが再びゼロからレンダリングされるまで、クライアントは更新を見ることができません。</target>
        </trans-unit>
        <trans-unit id="3cda008b284e93ee83d27ce556b7f274c5401681" translate="yes" xml:space="preserve">
          <source>To modify the record (&lt;code&gt;lname&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; will remain unchanged):</source>
          <target state="translated">レコードを変更するには（ &lt;code&gt;lname&lt;/code&gt; と &lt;code&gt;age&lt;/code&gt; は変更されません）：</target>
        </trans-unit>
        <trans-unit id="2d8872fdf4d794b725b02d84014a91227ec2afee" translate="yes" xml:space="preserve">
          <source>To update the record (and consequently &lt;code&gt;lname&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; will be NULL):</source>
          <target state="translated">レコードを更新するには（その結果、 &lt;code&gt;lname&lt;/code&gt; と &lt;code&gt;age&lt;/code&gt; はNULLになります）：</target>
        </trans-unit>
        <trans-unit id="749827b57c3b48ad912ed3c35f6d888c6b320fd8" translate="yes" xml:space="preserve">
          <source>To use API manually, we can use browser based REST API plugins.</source>
          <target state="translated">APIを手動で使用するには、ブラウザベースのREST APIプラグインを使用します。</target>
        </trans-unit>
        <trans-unit id="cd51d0a7c8a456561603688f8e9d8841d8aeb252" translate="yes" xml:space="preserve">
          <source>Uniform interface</source>
          <target state="translated">均一なインターフェース</target>
        </trans-unit>
        <trans-unit id="36445d1f62b3461271018e22e6c63b0da668d74c" translate="yes" xml:space="preserve">
          <source>We also know that we can change existing data:</source>
          <target state="translated">既存のデータを変更できることもわかっています。</target>
        </trans-unit>
        <trans-unit id="2da0745a731ffea22c1d0cd224d20dec310fb399" translate="yes" xml:space="preserve">
          <source>We can tell a lot from this response. For instance, we now know we can create a new user by &lt;code&gt;POST&lt;/code&gt;ing to &lt;code&gt;/user&lt;/code&gt;:</source>
          <target state="translated">この反応から多くのことがわかります。 たとえば、 &lt;code&gt;/user&lt;/code&gt; に &lt;code&gt;POST&lt;/code&gt; することで新しいユーザーを作成できることがわかりました。</target>
        </trans-unit>
        <trans-unit id="5441c7839fa6d73dff04b1a5f493f5e5d31a22e7" translate="yes" xml:space="preserve">
          <source>We know from the description of our media that we can find information about related resources from sections called &quot;links&quot;. This is called &lt;em&gt;Hypermedia controls&lt;/em&gt;. In this case, we can tell from such a section that we can find a user list by making another request for &lt;code&gt;/user&lt;/code&gt;:</source>
          <target state="translated">メディアの説明から、「リンク」というセクションから関連リソースに関する情報を見つけることができます。 これは&lt;em&gt;ハイパーメディアコントロール&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt; 。 この場合、そのようなセクションから &lt;code&gt;/user&lt;/code&gt; に別のリクエストを行うことでユーザーリストを見つけることができることがわかります 。</target>
        </trans-unit>
        <trans-unit id="dbe152bcc052ff53fb476d5537d8e4e55bdd8dee" translate="yes" xml:space="preserve">
          <source>What exactly is RESTful programming</source>
          <target state="translated">RESTfulプログラミングとは</target>
        </trans-unit>
        <trans-unit id="600b595c92145112ec54443d94bd4487770f5001" translate="yes" xml:space="preserve">
          <source>What exactly is RESTful programming?</source>
          <target state="translated">RESTfulプログラミングとは具体的に何か?</target>
        </trans-unit>
        <trans-unit id="de97001a3f45e1ab272ba3e7e1ff70234ac18284" translate="yes" xml:space="preserve">
          <source>What is REST?</source>
          <target state="translated">RESTとは?</target>
        </trans-unit>
        <trans-unit id="eda640f0d9d8732bb4f5934942e07911d12c78f5" translate="yes" xml:space="preserve">
          <source>When it comes to web services, it seems that we need some way of distinguishing WSDL and SOAP based architectures which add considerable overhead and arguably much unnecessary complexity to the interface. They also require additional frameworks and developer tools in order to implement. I'm not sure if REST is the best term to distinguish between common-sense interfaces and overly engineered interfaces such as WSDL and SOAP. But we need something.</source>
          <target state="translated">ウェブサービスに関して言えば、WSDL と SOAP ベースのアーキテクチャを区別する何らかの方法が必要なようです。また、それらは実装するために追加のフレームワークや開発者ツールを必要とします。REST が常識的なインターフェースと WSDL や SOAP のような過剰に設計されたインターフェースを区別するための最良の用語であるかどうかはわかりません。しかし、私たちには何かが必要です。</target>
        </trans-unit>
        <trans-unit id="a973bdebdbe9ce0f6dcc094fe7f29c9ec500ddfd" translate="yes" xml:space="preserve">
          <source>With a properly implemented restful GET operation, it shouldn't matter if the information comes from your server's DB, your server's memcache, a CDN, a proxy's cache, your browser's cache or your browser's local storage. The fasted, most readily available up to date source can be used.</source>
          <target state="translated">適切に実装されたrestful GET操作では、情報がサーバのDB、サーバのmemcache、CDN、プロキシのキャッシュ、ブラウザのキャッシュ、ブラウザのローカルストレージから来ていても問題にならないはずです。高速で最新のソースを利用することができます。</target>
        </trans-unit>
        <trans-unit id="9516144747f958d35f414712742a6a2ce6a57b18" translate="yes" xml:space="preserve">
          <source>With restful style, you get and manipulate the state of the application across an unreliable internet. If it fails the current operation to get the correct and current state, it needs the zero-validation principal to help the application to continue. If it fails to manipulate the state, it usually uses multiple stages of confirmation to keep things correct. In this sense, rest is not itself a whole solution, it needs the functions in other part of the web application stack to support its working.</source>
          <target state="translated">restfulスタイルでは、信頼できないインターネットをまたいでアプリケーションの状態を取得し、操作します。正しい状態と現在の状態を取得するための現在の操作に失敗した場合、アプリケーションが継続するのを助けるためにゼロ検証プリンシパルが必要です。状態を操作するのに失敗した場合、通常は正しい状態を維持するために複数の段階の確認を使用します。この意味で、レストはそれ自体が全体の解決策ではなく、ウェブアプリケーションスタックの他の部分の機能を必要とし、その動作をサポートします。</target>
        </trans-unit>
        <trans-unit id="9be308c8cf75a9d22350774cf74e2e3a25a8019f" translate="yes" xml:space="preserve">
          <source>You can imagine such an endpoint as being the connecting pipeline from the website (front-end) to your database/server (back-end). Using them, the front-end can perform back-end operations which are defined in the corresponding methods of any REST mapping in your application.</source>
          <target state="translated">このようなエンドポイントは、ウェブサイト(フロントエンド)からデータベースサーバ(バックエンド)への接続パイプラインであると想像できます。これらを使用して、フロントエンドはアプリケーション内のRESTマッピングの対応するメソッドで定義されているバックエンド操作を実行することができます。</target>
        </trans-unit>
        <trans-unit id="908a7dfd19709fb34c01bfe487f5ebb9c2ca9cf8" translate="yes" xml:space="preserve">
          <source>You can summarize(significantly) the constraints to :</source>
          <target state="translated">.NETの制約をまとめることができます。</target>
        </trans-unit>
        <trans-unit id="feb921fa13db1c181a291f33573dbc491b591ad9" translate="yes" xml:space="preserve">
          <source>You use the HTTP &quot;verbs&quot; and have..</source>
          <target state="translated">HTTPの「動詞」を使っていて、持っている...</target>
        </trans-unit>
        <trans-unit id="3aed90f826f40c49f9ad0c3f63e16bed6d13bf70" translate="yes" xml:space="preserve">
          <source>[Failure here implies that out-of-band information is driving interaction instead of hypertext.]</source>
          <target state="translated">ここでの失敗は、ハイパーテキストではなく帯域外の情報が相互作用の原動力になっていることを示唆している]。</target>
        </trans-unit>
        <trans-unit id="8e00d08a441958c5870f45fa22543b3d6a03678e" translate="yes" xml:space="preserve">
          <source>build a layered system to increase scalability</source>
          <target state="translated">レイヤードシステムを構築して拡張性を高める</target>
        </trans-unit>
        <trans-unit id="59c8c8c5991afe8d0a6e42545c71d93e3bff395d" translate="yes" xml:space="preserve">
          <source>but the REST architecture does not require these &quot;pretty URLs&quot;. A GET request with a parameter</source>
          <target state="translated">を使用していますが、REST アーキテクチャではこれらの「きれいな URL」は必要ありません。パラメータ</target>
        </trans-unit>
        <trans-unit id="9f5d22e3a30a84cbccefeb4bd8e5dd35213aaaef" translate="yes" xml:space="preserve">
          <source>clearly communicates the content formats transmitted</source>
          <target state="translated">送信するコンテンツの形式を明確に伝える</target>
        </trans-unit>
        <trans-unit id="aa2c820849be6fbcb2031a6127c1665b0464c324" translate="yes" xml:space="preserve">
          <source>client-server architecture</source>
          <target state="translated">クライアントサーバアーキテクチャ</target>
        </trans-unit>
        <trans-unit id="8de0a9bc31c843fae99c5bff4c8a379f92283e8b" translate="yes" xml:space="preserve">
          <source>code on demand to extend client functionality</source>
          <target state="translated">クライアント機能を拡張するオンデマンドコード</target>
        </trans-unit>
        <trans-unit id="b275617b42e241876e72514b35301555695e7037" translate="yes" xml:space="preserve">
          <source>is every bit as RESTful.</source>
          <target state="translated">は、RESTful と同じようにすべての点で優れています。</target>
        </trans-unit>
        <trans-unit id="0d4997d446840ee0c979e316123915b0a24c6d51" translate="yes" xml:space="preserve">
          <source>maintaining the state in the object and representing the state in the representation</source>
          <target state="translated">オブジェクトの状態を維持し、表現の中で状態を表現する。</target>
        </trans-unit>
        <trans-unit id="979f4334840cfaebedb96eacee97565f5bf001e6" translate="yes" xml:space="preserve">
          <source>representing the relationships between resources in the representation of the resource: the links between objects are embedded directly in the representation</source>
          <target state="translated">リソースの表現でリソース間の関係を表現する:オブジェクト間のリンクは表現に直接埋め込まれる</target>
        </trans-unit>
        <trans-unit id="5e48ef6a8e54320faa23115ae33b087ac321ebec" translate="yes" xml:space="preserve">
          <source>resource representations describe how the representation can be used and under what circumstances it should be discarded/refetched in a consistent manner: usage of HTTP Cache-Control headers</source>
          <target state="translated">リソース表現は、表現がどのように使用できるか、どのような状況下で破棄されるべきかを一貫した方法で記述します。</target>
        </trans-unit>
        <trans-unit id="e33527bfb73b976a097d9714161c7a07da95577a" translate="yes" xml:space="preserve">
          <source>resources being identified by a persistent identifier: URIs are the ubiquitous choice of identifier these days</source>
          <target state="translated">リソースは永続的な識別子によって識別されます。URI は最近ではユビキタスな識別子です。</target>
        </trans-unit>
        <trans-unit id="a51e6d20a959c6055335a93c972efc9d39c00a75" translate="yes" xml:space="preserve">
          <source>resources being manipulated using a common set of verbs: HTTP methods are the commonly seen case - the venerable &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Retrieve&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt; becomes &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. But REST is not limited to HTTP, it is just the most commonly used transport right now.</source>
          <target state="translated">動詞の共通セットを使用して操作されるリソース：HTTPメソッドは一般的に見られるケースです-由緒ある &lt;code&gt;Create&lt;/code&gt; 、 &lt;code&gt;Retrieve&lt;/code&gt; 、 &lt;code&gt;Update&lt;/code&gt; 、 &lt;code&gt;Delete&lt;/code&gt; は &lt;code&gt;POST&lt;/code&gt; 、 &lt;code&gt;GET&lt;/code&gt; 、 &lt;code&gt;PUT&lt;/code&gt; 、および &lt;code&gt;DELETE&lt;/code&gt; になります。 ただし、RESTはHTTPに限定されず、現在最も一般的に使用されているトランスポートです。</target>
        </trans-unit>
        <trans-unit id="98b5c511b1e5b3b77e9275fb4452cc5fef44489b" translate="yes" xml:space="preserve">
          <source>respect HTTP specs (if HTTP is used)</source>
          <target state="translated">HTTP の仕様を尊重する (HTTP が使用されている場合)</target>
        </trans-unit>
        <trans-unit id="c4931fde74816a610a063dd06bd59538b02802b8" translate="yes" xml:space="preserve">
          <source>stateless communication</source>
          <target state="translated">ステートレス通信</target>
        </trans-unit>
        <trans-unit id="3b878062f43e3c640f44bd52081d0d0dc4278065" translate="yes" xml:space="preserve">
          <source>the actual representation retrieved for a resource is dependent on the request and not the identifier: use Accept headers to control whether you want XML, HTTP, or even a Java Object representing the resource</source>
          <target state="translated">リソースに対して取得される実際の表現はリクエストに依存し、識別子に依存しません。</target>
        </trans-unit>
        <trans-unit id="1462755612fc240043fdb2325bffe48c8d0f3f08" translate="yes" xml:space="preserve">
          <source>uniform interface as common contract between client and server</source>
          <target state="translated">クライアントとサーバ間の共通契約としての統一インターフェース</target>
        </trans-unit>
        <trans-unit id="3766fe2c2822ed2ec2c43384fd93c708aa87dded" translate="yes" xml:space="preserve">
          <source>usage of cache if you can</source>
          <target state="translated">可能であればキャッシュの使用量</target>
        </trans-unit>
        <trans-unit id="f96087a197542f55a4ef257f73c9f1cfd69fffd2" translate="yes" xml:space="preserve">
          <source>use hypermedia as the engine of application state</source>
          <target state="translated">ハイパーメディアをアプリケーション状態のエンジンとして使用する</target>
        </trans-unit>
        <trans-unit id="2626c215ef69fa721ddf1168a1db9e9f9a723d4c" translate="yes" xml:space="preserve">
          <source>would not be appropriate. GET requests should be &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Idempotence&quot;&gt;idempotent&lt;/a&gt;. That is, issuing a request twice should be no different from issuing it once. That's what makes the requests cacheable. An &quot;add to cart&quot; request is not idempotent&amp;mdash;issuing it twice adds two copies of the item to the cart. A POST request is clearly appropriate in this context. Thus, even a &lt;strong&gt;RESTful web application&lt;/strong&gt; needs its share of POST requests.</source>
          <target state="translated">適切ではありません。 GETリクエストはべき&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Idempotence&quot;&gt;等である&lt;/a&gt;必要があります。 つまり、リクエストを2回発行することは、1回発行することと同じです。 これにより、リクエストがキャッシュ可能になります。 「カートに追加」リクエストはべき等ではありません。2回発行すると、アイテムの2つのコピーがカートに追加されます。 この状況では、POSTリクエストが明らかに適切です。 したがって、 &lt;strong&gt;RESTful Webアプリケーション&lt;/strong&gt;でさえ、POSTリクエストの共有が必要です。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
