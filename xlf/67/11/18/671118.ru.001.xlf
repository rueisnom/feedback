<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/671118">
    <body>
      <group id="671118">
        <trans-unit id="4b5f371d067d57adebce0c867d054ff2d3400ab5" translate="yes" xml:space="preserve">
          <source>(This answer has been the subject of a fair amount of criticism for missing the point. For the most part, that has been a fair critique. What I originally described was more in line with how REST was usually implemented a few years ago when I first wrote this, rather than its true meaning. I've revised the answer to better represent the real meaning.)</source>
          <target state="translated">(Этот ответ вызвал немало критики за упущенную возможность.По большей части,это была справедливая критика.То,что я первоначально описал,больше соответствовало тому,как REST обычно реализуется несколько лет назад,когда я впервые написал это,а не его истинному значению.Я пересмотрел ответ,чтобы лучше отразить реальный смысл).</target>
        </trans-unit>
        <trans-unit id="d38acde6c0a007c814e7a8e62db3e40f8b9a8c5d" translate="yes" xml:space="preserve">
          <source>1) There is no such a thing as restful programing, without a big joint and lots of beer :)</source>
          <target state="translated">1)Нет такой вещи,как спокойное программирование,без большого косяка и большого количества пива :)</target>
        </trans-unit>
        <trans-unit id="16ed7b2a6cdbe5d413738c42d0ff5485bb59700c" translate="yes" xml:space="preserve">
          <source>2) &lt;strong&gt;Representational State Transfer (REST) is an architectural style specified in &lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;the dissertation of Roy Fielding&lt;/a&gt;.
It has a number of constraints.  If your Service/Client respect those then it is RESTful.&lt;/strong&gt; This is it.</source>
          <target state="translated">2) &lt;strong&gt;Передача представительского состояния (REST) ​​- архитектурный стиль, указанный в &lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;диссертации Роя Филдинга&lt;/a&gt; .&lt;/strong&gt; &lt;strong&gt;Это имеет ряд ограничений.&lt;/strong&gt; &lt;strong&gt;Если ваш Сервис / Клиент уважает их, тогда это RESTful.&lt;/strong&gt; Это оно.</target>
        </trans-unit>
        <trans-unit id="27e5dbfce4b7ee29196f5fd4dafe3ca1c0624c58" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;Unique global identifier&lt;/a&gt; (all resources are unique identified by &lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;Уникальный глобальный идентификатор&lt;/a&gt; (все ресурсы уникально идентифицируются по &lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1fd9999d07a7fc62861689de4b2bdf6a8fc86768" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;RESTful&lt;/a&gt; (Representational state transfer) API programming is writing web applications in any programming language by following 5 basic software &lt;a href=&quot;http://en.wikipedia.org/wiki/Architectural_style&quot;&gt;architectural style&lt;/a&gt; principles:</source>
          <target state="translated">API-программирование &lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;RESTful&lt;/a&gt; (передача состояния представления) - это написание веб-приложений на любом языке программирования с использованием следующих 5 основных принципов &lt;a href=&quot;http://en.wikipedia.org/wiki/Architectural_style&quot;&gt;архитектурного стиля&lt;/a&gt; программного обеспечения:</target>
        </trans-unit>
        <trans-unit id="68ce364743640c5c8da066039ef67fefbcdfea99" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface&quot;&gt;Uniform interface&lt;/a&gt; - use simple and standard interface (HTTP).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface&quot;&gt;Единый интерфейс&lt;/a&gt; - используйте простой и стандартный интерфейс (HTTP).</target>
        </trans-unit>
        <trans-unit id="fc1b3e08e8f98d28090f1f9117f6298bc58e4d4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Stateless_protocol&quot;&gt;Stateless&lt;/a&gt; (every request happens in complete isolation, it's easier to cache and load-balance),</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Stateless_protocol&quot;&gt;Без сохранения состояния&lt;/a&gt; (каждый запрос происходит в полной изоляции, кеширование и балансировка нагрузки легче),</target>
        </trans-unit>
        <trans-unit id="129cb3c37d52f357725b109610381bd678a81b64" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://herbjorn.wordpress.com/2010/11/19/rest-versus-soap-for-the-public-cloud/&quot;&gt;REST versus SOAP for the Public Cloud&lt;/a&gt; discusses the current levels of REST usage.</source>
          <target state="translated">&lt;a href=&quot;http://herbjorn.wordpress.com/2010/11/19/rest-versus-soap-for-the-public-cloud/&quot;&gt;REST и SOAP для публичного облака&lt;/a&gt; обсуждают текущие уровни использования REST.</target>
        </trans-unit>
        <trans-unit id="01d4ccbe57dba207b3756864c380f7e8c5cec68f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://kinderman.net/2010/06/23/approaching-pure-rest-learning-to-love-hateoas&quot;&gt;Approaching pure REST: Learning to love HATEOAS&lt;/a&gt; is a good collection of links.</source>
          <target state="translated">&lt;a href=&quot;http://kinderman.net/2010/06/23/approaching-pure-rest-learning-to-love-hateoas&quot;&gt;Приближаемся к чистому REST: Учимся любить HATEOAS&lt;/a&gt; - это хорошая коллекция ссылок.</target>
        </trans-unit>
        <trans-unit id="71c672309538bece163ea3ed6fdde78bae549263" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;The term RESTful was created because ppl exhausted the word REST by calling their non-REST application as REST.&lt;/a&gt; After that the term RESTful was exhausted as well. &lt;a href=&quot;http://www.markus-lanthaler.com/research/third-generation-web-apis-bridging-the-gap-between-rest-and-linked-data.pdf&quot;&gt;Nowadays we are talking about Web APIs and Hypermedia APIs&lt;/a&gt;, because the most of the so called REST applications did not fulfill the HATEOAS part of the uniform interface constraint.</source>
          <target state="translated">&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Термин RESTful был создан, потому что ppl исчерпал слово REST, назвав их не REST-приложение REST.&lt;/a&gt; После этого термин RESTful также был исчерпан. &lt;a href=&quot;http://www.markus-lanthaler.com/research/third-generation-web-apis-bridging-the-gap-between-rest-and-linked-data.pdf&quot;&gt;В настоящее время мы говорим о веб-API и гипермедиа-API&lt;/a&gt; , потому что большинство так называемых REST-приложений не удовлетворяли HATEOAS-части ограничения унифицированного интерфейса.</target>
        </trans-unit>
        <trans-unit id="ee92cfd1a1d0fac1b4085c977902cee08a3f0004" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife&quot;&gt;How I explained REST to my wife&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife&quot;&gt;Как я объяснил REST моей жене&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd6a95880b9724e9be2ebb234578d30f5200563" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.innoq.com/blog/st/2010/07/rest_litmus_test_for_web_frame.html&quot;&gt;REST Litmus Test for Web Frameworks&lt;/a&gt; is a similar maturity test for web frameworks.</source>
          <target state="translated">&lt;a href=&quot;http://www.innoq.com/blog/st/2010/07/rest_litmus_test_for_web_frame.html&quot;&gt;REST Litmus Test для веб-фреймворков&lt;/a&gt; - это аналогичный тест на зрелость для веб-фреймворков.</target>
        </trans-unit>
        <trans-unit id="b82de9194c2626af47b20dbf29253c8eab541c11" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.xfront.com/REST.ppt&quot;&gt;http://www.xfront.com/REST.ppt&lt;/a&gt; or &lt;a href=&quot;http://www.xfront.com/REST.html&quot;&gt;http://www.xfront.com/REST.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.xfront.com/REST.ppt&quot;&gt;http://www.xfront.com/REST.ppt&lt;/a&gt; или &lt;a href=&quot;http://www.xfront.com/REST.html&quot;&gt;http://www.xfront.com/REST.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="581df4eb5c8f47005fba4eaff2c31e62dc854f5b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.google.com/present/view?id=dd4bk538_182f55p5x3f&amp;amp;ndplr=1&quot;&gt;REST and versioning&lt;/a&gt; discusses Extensibility, Versioning, Evolvability, etc.
 through Modifiability</source>
          <target state="translated">&lt;a href=&quot;https://docs.google.com/present/view?id=dd4bk538_182f55p5x3f&amp;amp;ndplr=1&quot;&gt;REST и управление версиями&lt;/a&gt; обсуждают расширяемость, управление версиями, эволюционируемость и т. Д. Через модифицируемость</target>
        </trans-unit>
        <trans-unit id="38b751418200783443a4e1aa6fb491b6a5b8367d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;From Wikipedia&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;Из Википедии&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b092bbc5dae2d2facc4cdcbac80f4fca0862b1a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;REST&lt;/em&gt; is the underlying architectural principle of the web. The amazing thing about the web is the fact that clients (browsers) and servers can interact in complex ways without the client knowing anything beforehand about the server and the resources it hosts. The key constraint is that the server and client must both agree on the &lt;em&gt;media&lt;/em&gt; used, which in the case of the web is &lt;em&gt;HTML&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;REST&lt;/em&gt; - это основной архитектурный принцип сети. Удивительным моментом в Интернете является тот факт, что клиенты (браузеры) и серверы могут взаимодействовать сложным образом, и клиент ничего не знает заранее о сервере и размещенных на нем ресурсах. Ключевым ограничением является то, что сервер и клиент должны согласовать используемое &lt;em&gt;мультимедиа&lt;/em&gt; , которое в случае с Интернетом является &lt;em&gt;HTML&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="75836654a91c2003a610250aa33fea51aed04694" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Talking&lt;/em&gt; is more than simply &lt;em&gt;exchanging information&lt;/em&gt;. A Protocol is actually designed so that no talking has to occur. Each party knows what their particular job is because it is specified in the protocol. Protocols allow for pure information exchange at the expense of having any changes in the possible actions. Talking, on the other hand, allows for one party to ask what further actions can be taken from the other party. They can even ask the same question twice and get two different answers, since the State of the other party may have changed in the interim. &lt;strong&gt;Talking is RESTful architecture&lt;/strong&gt;. Fielding's thesis specifies the architecture that one would have to follow if one wanted to allow machines to &lt;em&gt;talk&lt;/em&gt; to one another rather than simply &lt;em&gt;communicate&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Разговор&lt;/em&gt; - это не просто &lt;em&gt;обмен информацией&lt;/em&gt; . Протокол на самом деле разработан таким образом, чтобы не было разговоров. Каждая сторона знает, какова их конкретная работа, потому что это указано в протоколе. Протоколы позволяют осуществлять чистый обмен информацией за счет каких-либо изменений возможных действий. Разговор, с другой стороны, позволяет одной стороне спросить, какие дальнейшие действия могут быть предприняты другой стороной. Они могут даже задать один и тот же вопрос дважды и получить два разных ответа, поскольку за это время состояние другой стороны могло измениться. &lt;strong&gt;Разговор - это ОТЛИЧНАЯ архитектура&lt;/strong&gt; . Тезис Филдинга определяет архитектуру, которой нужно было бы следовать, если бы человек хотел, чтобы машины &lt;em&gt;общались&lt;/em&gt; друг с другом, а не просто &lt;em&gt;общались&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="047b453da1539c81d5d318bedbdeb493589d50ab" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;a href=&quot;http://www.looah.com/source/view/2284&quot;&gt;How I explained REST to my wife&lt;/a&gt;.&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;&lt;a href=&quot;http://www.looah.com/source/view/2284&quot;&gt;Как я объяснил REST моей жене&lt;/a&gt; .&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="a5cbf477e28c39bdfd209ebf60137a160a48aa33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4 Commonly Used API Methods:-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4 Обычно используемые методы API: -&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a292b42aebab7e4f8f0a4cef5109e82538c81c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTTP methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTTP методы:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c887aa651a0b1255f5b4be4a6d0d7111e108eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Idempotence&lt;/strong&gt;: &lt;a href=&quot;http://programmers.stackexchange.com/questions/23386/pros-and-cons-of-restful-architecture&quot;&gt;An often-overlooked part of REST is the idempotency of most verbs. That leads to &lt;strong&gt;robust systems and less interdependency&lt;/strong&gt; of exact interpretations of the semantics&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Идемпотентность&lt;/strong&gt; : &lt;a href=&quot;http://programmers.stackexchange.com/questions/23386/pros-and-cons-of-restful-architecture&quot;&gt;часто пропускаемая часть REST - идемпотентность большинства глаголов.&lt;/a&gt; Это приводит к &lt;strong&gt;надежным системам и меньшей взаимозависимости&lt;/strong&gt; точных интерпретаций семантики .</target>
        </trans-unit>
        <trans-unit id="e19e144b463c1477631bed87f6cf59ac2feabcb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST API&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;REST API&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4016ad50e00a712f9fc46d47dae34627a47b0c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST&lt;/strong&gt; is an architectural style which is based on web-standards and the HTTP protocol (introduced in 2000).</source>
          <target state="translated">&lt;strong&gt;REST&lt;/strong&gt; - это архитектурный стиль, основанный на веб-стандартах и ​​протоколе HTTP (представлен в 2000 году).</target>
        </trans-unit>
        <trans-unit id="f470c92afeb4f87674886ef73e25bccf93d40bda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST&lt;/strong&gt; stands for &lt;strong&gt;Representational state transfer&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;REST&lt;/strong&gt; расшифровывается как &lt;strong&gt;представительский государственный перевод&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c34758fefce5857b0652a67c95f80db96a7e9ace" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Request&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Request&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8301b7897b69c57632cd67112cbd903a929c2bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Response&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Response&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9026e434b313962901c5fd34080061d3114f6c95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, how does this apply to &lt;em&gt;HTTP&lt;/em&gt;, and how can it be implemented in practice?&lt;/strong&gt; HTTP is oriented around verbs and resources. The two verbs in mainstream usage are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;, which I think everyone will recognize. However, the HTTP standard defines several others such as &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt;. These verbs are then applied to resources, according to the instructions provided by the server.</source>
          <target state="translated">&lt;strong&gt;Итак, как это относится к &lt;em&gt;HTTP&lt;/em&gt; и как это может быть реализовано на практике?&lt;/strong&gt; HTTP ориентирован на глаголы и ресурсы. Два основных глагола в употреблении - это &lt;code&gt;GET&lt;/code&gt; и &lt;code&gt;POST&lt;/code&gt; , которые, я думаю, все узнают. Однако стандарт HTTP определяет несколько других, таких как &lt;code&gt;PUT&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; . Эти глаголы затем применяются к ресурсам в соответствии с инструкциями, предоставленными сервером.</target>
        </trans-unit>
        <trans-unit id="63a42af1bd9b39bddf0ce1be8356d0a2fdb888e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Statelessness&lt;/strong&gt; is misleading. It is about the restful API, not the application or system. The system needs to be stateful. Restful design is about designing a stateful system based on a stateless API. Some &lt;a href=&quot;http://programmers.stackexchange.com/questions/120716/difference-between-rest-and-crud&quot;&gt;quotes from another QA&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;Безгражданство&lt;/strong&gt; вводит в заблуждение. Речь идет об остальном API, а не о приложении или системе. Система должна быть с состоянием. Restful design - это проектирование системы с сохранением состояния на основе API без сохранения состояния. Некоторые &lt;a href=&quot;http://programmers.stackexchange.com/questions/120716/difference-between-rest-and-crud&quot;&gt;цитаты из другого QA&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4c1222e90317ba27d02c65621a259eda932152bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Steps to Test API Manually:-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Шаги для тестирования API вручную: -&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a168c28310824470d0a6b65e2fc1846ae47767c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is another &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;very good post&lt;/a&gt; which explains things nicely.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Есть еще один &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;очень хороший пост,&lt;/a&gt; который хорошо объясняет вещи.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f23059a3c1ff462600affe32ac77f6c06e198cd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is &lt;a href=&quot;http://testingalert.com/api-testing/api-manual/&quot;&gt;API Testing&lt;/a&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что такое &lt;a href=&quot;http://testingalert.com/api-testing/api-manual/&quot;&gt;API-тестирование&lt;/a&gt; ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bdfd2ece2c06305906caea45c528dd7bf39e1081" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is REST?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что такое ОТДЫХ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34c0a9562e8fed523993c8b4e5719d3ee3daa073" translate="yes" xml:space="preserve">
          <source>A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user&amp;rsquo;s manipulation of those representations. The transitions may be determined (or limited by) the client&amp;rsquo;s knowledge of media types and resource communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand).</source>
          <target state="translated">API REST следует вводить без каких-либо предварительных знаний, кроме начального URI (закладки) и набора стандартизированных типов мультимедиа, подходящих для целевой аудитории (то есть ожидается, что их поймет любой клиент, который может использовать API). С этого момента все переходы состояния приложения должны определяться выбором клиентом предоставленных сервером вариантов, которые присутствуют в полученных представлениях или подразумеваются манипуляциями пользователя с этими представлениями. Переходы могут быть определены (или ограничены) знаниями клиента о типах медиа и механизмах связи с ресурсами, которые могут быть улучшены на лету (например, код по запросу).</target>
        </trans-unit>
        <trans-unit id="1036e82ff72398f19dae7159de008a4b11524acc" translate="yes" xml:space="preserve">
          <source>A REST API should spend almost all of its descriptive effort in
  defining the media type(s) used for representing resources and driving
  application state, or in defining extended relation names and/or
  hypertext-enabled mark-up for existing standard media types.</source>
          <target state="translated">API REST должен потратить почти все свои описательные усилия на определение типа(ов)носителя(ов),используемого(ых)для представления ресурсов и приведения в движение состояния приложения,или на определение имен расширенных отношений и или гипертекстовой разметки для существующих стандартных типов носителей.</target>
        </trans-unit>
        <trans-unit id="091580d9e598bff76e8f95009cca43640abadd8b" translate="yes" xml:space="preserve">
          <source>A client of a RESTful application need
  only know a single fixed URL to access
  it. All future actions should be
  discoverable dynamically from
  hypermedia links included in the
  representations of the resources that
  are returned from that URL.
  Standardized media types are also
  expected to be understood by any
  client that might use a RESTful API. 
  (From Wikipedia, the free encyclopedia)</source>
          <target state="translated">Клиент RESTful приложения должен знать только один фиксированный URL для доступа к нему.Все будущие действия должны быть динамически открыты по гипермедиа ссылкам,включенным в представления ресурсов,которые возвращаются с этого URL.Стандартизированные типы медиа также должны быть понятны любому клиенту,который может использовать API RESTful.(Из Википедии,бесплатной энциклопедии).</target>
        </trans-unit>
        <trans-unit id="b199b8ec3c349cace004db8b56b1161860b9581b" translate="yes" xml:space="preserve">
          <source>A great book on REST is &lt;a href=&quot;http://www.amazon.co.uk/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829&quot;&gt;REST in Practice&lt;/a&gt;.</source>
          <target state="translated">Отличная книга о ОТДЫХЕ - &lt;a href=&quot;http://www.amazon.co.uk/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829&quot;&gt;ОТДЫХ на практике&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbbdec192b31adde0e04c6c1e638a22c1c3a0509" translate="yes" xml:space="preserve">
          <source>A lot of answers copy/pasted valid information mixing it and adding some confusion. People talk here about levels, about RESTFul URIs(there is not such a thing!), apply HTTP methods GET,POST,PUT ... REST is not about that or not only about that.</source>
          <target state="translated">Многие ответы копируют достоверную информацию,смешивая ее и добавляя некоторую путаницу.Здесь говорят об уровнях,о RESTFul URI (нет такого понятия!),о применении HTTP методов GET,POST,PUT...REST не об этом или не только об этом.</target>
        </trans-unit>
        <trans-unit id="a9672fbb5a371857625bda2ec07f4fc2c459d533" translate="yes" xml:space="preserve">
          <source>A request for the base resource &lt;code&gt;/&lt;/code&gt; might return something like this:</source>
          <target state="translated">Запрос на базовый ресурс &lt;code&gt;/&lt;/code&gt; может вернуть что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="33311414a6f85a0d4549f88e6f929e587d140695" translate="yes" xml:space="preserve">
          <source>API testing utilizes programming to send calls to the API and get the yield. It testing regards the segment under test as a black box. The objective of API testing is to confirm right execution and blunder treatment of the part preceding its coordination into an application.</source>
          <target state="translated">Тестирование API использует программирование для отправки звонков в API и получения доходности.Тестирование рассматривает тестируемый сегмент как черный ящик.Целью тестирования API является подтверждение правильности выполнения и ошибки обработки участка,предшествующего его согласованию в приложение.</target>
        </trans-unit>
        <trans-unit id="17e11e3bc87a626545bcd3ae4e73a6dc9b979e5b" translate="yes" xml:space="preserve">
          <source>After reading the examples, I could see why Ken is saying that REST is hypertext-driven. I'm not actually sure that he's right though, because that /user/123 is a URI that points to a resource, and it's not clear to me that it's unRESTful just because the client knows about it &quot;out-of-band.&quot;</source>
          <target state="translated">Прочитав примеры,я понял,почему Кен говорит,что REST управляется гипертекстом.На самом деле я не уверен,что он прав,потому что этот пользователь123 является URI,который указывает на ресурс,и мне неясно,что это неREST только потому,что клиент знает об этом &quot;внеполосно&quot;.</target>
        </trans-unit>
        <trans-unit id="0ff162ae131fa2cf274f6632a56e1f9816c868de" translate="yes" xml:space="preserve">
          <source>After that, it's easy to fall into debates about adaptations, coding conventions, and best practices.</source>
          <target state="translated">После этого легко впасть в дебаты об адаптации,кодировании конвенций и передовой практики.</target>
        </trans-unit>
        <trans-unit id="e6213f65245bee16c30cf6760d609e28bd445103" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;architectural style&lt;/strong&gt; called &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;&lt;strong&gt;REST (Representational State Transfer)&lt;/strong&gt;&lt;/a&gt; advocates that web applications should use HTTP as it was &lt;strong&gt;originally envisioned&lt;/strong&gt;. Lookups should use &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; requests. &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; requests&lt;/a&gt; should be used for &lt;strong&gt;mutation, creation, and deletion respectively&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Архитектурный стиль,&lt;/strong&gt; называемый &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;&lt;strong&gt;REST (представление состояния передачи)&lt;/strong&gt;&lt;/a&gt; , &lt;strong&gt;предусматривает,&lt;/strong&gt; что веб-приложения должны использовать HTTP, как это &lt;strong&gt;первоначально предполагалось&lt;/strong&gt; . Поиски должны использовать запросы &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;Запросы &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; должны использоваться для &lt;strong&gt;мутации, создания и удаления соответственно&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="23f9e629acbf7586515e2525e29805b2378876e7" translate="yes" xml:space="preserve">
          <source>An API that adheres to the principles of &lt;em&gt;REST&lt;/em&gt; does not require the client to know anything about the structure of the API. Rather, the server needs to provide whatever information the client needs to interact with the service. An &lt;em&gt;HTML form&lt;/em&gt; is an example of this: The server specifies the location of the resource and the required fields. &lt;strong&gt;The browser doesn't know in advance where to submit the information, and it doesn't know in advance what information to submit. Both forms of information are entirely supplied by the server.&lt;/strong&gt; (This principle is called &lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot;&gt;&lt;em&gt;HATEOAS&lt;/em&gt;: Hypermedia As The Engine Of Application State&lt;/a&gt;.)</source>
          <target state="translated">API, который придерживается принципов &lt;em&gt;REST&lt;/em&gt; , не требует от клиента ничего знать о структуре API. Скорее, сервер должен предоставить любую информацию, необходимую клиенту для взаимодействия со службой. &lt;em&gt;HTML-форма&lt;/em&gt; является примером этого: сервер указывает местоположение ресурса и обязательные поля. &lt;strong&gt;Браузер не знает заранее, куда отправить информацию, и он не знает заранее, какую информацию отправлять.&lt;/strong&gt; &lt;strong&gt;Обе формы информации полностью предоставляются сервером.&lt;/strong&gt; (Этот принцип называется &lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot;&gt;&lt;em&gt;HATEOAS&lt;/em&gt; : гипермедиа как двигатель состояния приложения&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="0572ba17f943d7fd5fc5bebd5022f2239451cc72" translate="yes" xml:space="preserve">
          <source>An application is restful if it provides resources (being the combination of data + state transitions controls) in a media type the client understands</source>
          <target state="translated">Приложение успокаивает,если оно предоставляет ресурсы (являясь комбинацией данных+элементы управления переходами состояния)в медиа-типе,который клиент понимает.</target>
        </trans-unit>
        <trans-unit id="5bd054a830a9ec163da9832cb1d2afde20a52654" translate="yes" xml:space="preserve">
          <source>An excerpt from my talk is about the often referred to richardson maturity model, i don't believe in the levels, you either are RESTful (level 3) or you are not, but what i like to call out about it is what each level does for you on your way to RESTful</source>
          <target state="translated">Отрывок из моего разговора касается часто упоминаемой модели зрелости Ричардсона,я не верю в уровни,вы либо Отдыхаете (уровень 3),либо нет,но то,что я люблю называть по этому поводу,это то,что каждый уровень делает для вас на вашем пути к RESTful</target>
        </trans-unit>
        <trans-unit id="2610e51a62b1a490881eef55051e2f6be573a983" translate="yes" xml:space="preserve">
          <source>And even better, there's a clean explanation with simple examples here (the powerpoint is more comprehensive, but you can get most of it in the html version):</source>
          <target state="translated">А еще лучше,здесь есть чистое объяснение с простыми примерами (powerpoint более полный,но большую его часть можно получить в html-версии):</target>
        </trans-unit>
        <trans-unit id="200c5e79bfe63bed7ea90d31d59e4814bd38015a" translate="yes" xml:space="preserve">
          <source>Bonus answer: No. Unless you're studying software architecture as an academic or designing web services, there's really no reason to have heard the term.</source>
          <target state="translated">Бонусный ответ:Нет.Если вы изучаете архитектуру программного обеспечения как академическую или проектируете веб-сервисы,то нет причин слышать этот термин.</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="8db50296564fcc14b8370fbfb576cb5f7a3364bb" translate="yes" xml:space="preserve">
          <source>But the REST architecture doesn&amp;rsquo;t end there! While the above fulfills the basic needs of what we want, we also want to have an architecture that supports high volume traffic since any given server usually handles responses from a number of clients. Thus, we don&amp;rsquo;t want to overwhelm the server by having it remember information about previous requests.</source>
          <target state="translated">Но архитектура REST на этом не заканчивается! Хотя вышеперечисленное удовлетворяет основные потребности того, что мы хотим, мы также хотим иметь архитектуру, которая поддерживает большой объем трафика, поскольку любой данный сервер обычно обрабатывает ответы от ряда клиентов. Таким образом, мы не хотим перегружать сервер, заставляя его запоминать информацию о предыдущих запросах.</target>
        </trans-unit>
        <trans-unit id="c0e841fccec5e52e207c5f9f8aedc87617de3151" translate="yes" xml:space="preserve">
          <source>But to find any given resource and then tell the client where that resource lives, there needs to be a universal way of pointing at resources. This is where Universal Resource Identifiers (URIs) come in; they are basically unique addresses to find the resources.</source>
          <target state="translated">Но чтобы найти любой данный ресурс и затем сказать клиенту,где он живет,должен быть универсальный способ указать на ресурсы.Именно сюда приходят универсальные идентификаторы ресурсов (URI);в основном это уникальные адреса для поиска ресурсов.</target>
        </trans-unit>
        <trans-unit id="ab9c8d4b22f42d6e20f2de04cee4a87194c9b2ff" translate="yes" xml:space="preserve">
          <source>Cacheable</source>
          <target state="translated">Cacheable</target>
        </trans-unit>
        <trans-unit id="ebdaf0dc221196d242550c9fdcc355ae34b62243" translate="yes" xml:space="preserve">
          <source>Click on send</source>
          <target state="translated">Нажмите кнопку отправить</target>
        </trans-unit>
        <trans-unit id="85e79360e824842c6393ab95bc2ed066d468e1c8" translate="yes" xml:space="preserve">
          <source>Client&amp;ndash;server</source>
          <target state="translated">Client&amp;ndash;server</target>
        </trans-unit>
        <trans-unit id="9e1c7ac80552b301d4a9e2e0aad43db3dc88701b" translate="yes" xml:space="preserve">
          <source>Code on demand (optional)</source>
          <target state="translated">Код по запросу (необязательно)</target>
        </trans-unit>
        <trans-unit id="09134846ea28241f35e0dd02fce269a9982bea7f" translate="yes" xml:space="preserve">
          <source>Create a user with three properties:</source>
          <target state="translated">Создайте пользователя с тремя свойствами:</target>
        </trans-unit>
        <trans-unit id="4b2835cc754c6984e507206155e739a1564f8450" translate="yes" xml:space="preserve">
          <source>DELETE removes the resources. The operations are idempotent. They can get repeated without leading to different results.</source>
          <target state="translated">DELETE удаляет ресурсы.Операции являются идолопоклонными.Они могут повторяться,не приводя к различным результатам.</target>
        </trans-unit>
        <trans-unit id="03419256ac96b83abfd7066f861a5015d2ba0ed0" translate="yes" xml:space="preserve">
          <source>DELETE: &amp;ndash; It is used to remove a resource.</source>
          <target state="translated">УДАЛИТЬ: - Используется для удаления ресурса.</target>
        </trans-unit>
        <trans-unit id="5e5b459d45380b093202121fad6f6675d370930c" translate="yes" xml:space="preserve">
          <source>Despite being simple, REST is fully-featured; there's basically
  nothing you can do in Web Services that can't be done with a RESTful
  architecture. REST is not a &quot;standard&quot;. There will never be a W3C
  recommendataion for REST, for example. And while there are REST
  programming frameworks, working with REST is so simple that you can
  often &quot;roll your own&quot; with standard library features in languages like
  Perl, Java, or C#.</source>
          <target state="translated">Несмотря на простоту,REST является полнофункциональным;по сути,нет ничего,что можно было бы сделать в веб-службах,что нельзя было бы сделать с RESTful архитектурой.REST не является &quot;стандартом&quot;.Никогда не будет рекомендованного W3C каталога для REST,например.И хотя существуют фреймворки программирования REST,работа с REST настолько проста,что вы часто можете &quot;свернуть свой&quot; со стандартными функциями библиотек на таких языках,как Perl,Java или C#.</target>
        </trans-unit>
        <trans-unit id="b8d49819767eebe1ba51b6e1ff800c7bff7f706e" translate="yes" xml:space="preserve">
          <source>Edit: Two more important aspects:</source>
          <target state="translated">Редакция:Еще два важных аспекта:</target>
        </trans-unit>
        <trans-unit id="cc4bbb1317907e63ed80955856990adc8e7cbbe4" translate="yes" xml:space="preserve">
          <source>Enter Request JSON (POST)</source>
          <target state="translated">Введите JSON запрос (POST)</target>
        </trans-unit>
        <trans-unit id="ab911d488e200ceacb5e406e1fe7b3000216de7c" translate="yes" xml:space="preserve">
          <source>Enter the API URL</source>
          <target state="translated">Введите API URL</target>
        </trans-unit>
        <trans-unit id="800300af0e99da4a9ab4e50e0ad740ebb248a62c" translate="yes" xml:space="preserve">
          <source>Every resource should support the HTTP common operations. Resources are identified by global IDs (which are typically URIs).</source>
          <target state="translated">Каждый ресурс должен поддерживать общие операции HTTP.Ресурсы идентифицируются по глобальным идентификаторам (которые,как правило,являются URI).</target>
        </trans-unit>
        <trans-unit id="ae6c811f24cef30ab608149e77398fe7dc2aa93f" translate="yes" xml:space="preserve">
          <source>Explaining REST and Hypertext: Spam-E the Spam Cleaning Robot</source>
          <target state="translated">Объясняя REST и Гипертекст:Робот для очистки спама-спам.</target>
        </trans-unit>
        <trans-unit id="4c2e0eda7987cd96af30a22725f03cbbfc4b115a" translate="yes" xml:space="preserve">
          <source>For example links - it is nice to have a beautifully looking API but at the end the client/server does not really care of the links you get/send it is the content that matters.</source>
          <target state="translated">Например,ссылки-приятно иметь красиво выглядящий API,но в конце концов клиентскому серверу наплевать на ссылки,которые вы получаете,а важен только их контент.</target>
        </trans-unit>
        <trans-unit id="040c10648e6eb948c9d8e9d90c4d5f137fae46d2" translate="yes" xml:space="preserve">
          <source>For example there is a client layer which contains the clients and below that there is a service layer which contains a single service. Now you can add a client side cache between them. After that you can add another service instance and a load balancer, and so on... The client code and the service code won't change.</source>
          <target state="translated">Например,есть клиентский уровень,который содержит клиентов,а ниже-сервисный уровень,который содержит одну службу.Теперь вы можете добавить кэш на стороне клиента между ними.После этого можно добавить еще один экземпляр службы и балансировщик нагрузки,и так далее...Код клиента и код службы не изменятся.</target>
        </trans-unit>
        <trans-unit id="4edba5a49c7a4414557ee46319d87498dbeae513" translate="yes" xml:space="preserve">
          <source>For example when a client wants to send an order to a webshop, then it have to check the hyperlinks in the responses sent by the webshop. By checking the links it founds one described with the &lt;a href=&quot;http://schema.org/OrderAction&quot;&gt;http://schema.org/OrderAction&lt;/a&gt;. The client know the schema.org vocab, so it understands that by activating this hyperlink it will send the order. So it activates the hyperlink and sends a &lt;code&gt;POST https://example.com/api/v1/order&lt;/code&gt; message with the proper body. After that the service processes the message and responds with the result having the proper HTTP status header, for example &lt;code&gt;201 - created&lt;/code&gt; by success. To annotate messages with detailed metadata the standard solution to use an RDF format, for example &lt;a href=&quot;http://json-ld.org/&quot;&gt;JSON-LD&lt;/a&gt; with a REST vocab, for example &lt;a href=&quot;http://www.markus-lanthaler.com/hydra/&quot;&gt;Hydra&lt;/a&gt; and domain specific vocabs like &lt;a href=&quot;http://schema.org/&quot;&gt;schema.org&lt;/a&gt; or any other &lt;a href=&quot;http://lov.okfn.org/dataset/lov/&quot;&gt;linked data vocab&lt;/a&gt; and maybe a custom application specific vocab if needed. Now this is not easy, that's why most ppl use HAL and other simple formats which usually provide only a REST vocab, but no linked data support.</source>
          <target state="translated">Например, когда клиент хочет отправить заказ в интернет-магазин, он должен проверить гиперссылки в ответах, отправленных интернет-магазином. Проверяя ссылки, он находит ссылку, описанную с помощью &lt;a href=&quot;http://schema.org/OrderAction&quot;&gt;http://schema.org/OrderAction&lt;/a&gt; . Клиент знает вокабу schema.org, поэтому он понимает, что, активировав эту гиперссылку, он отправит заказ. Поэтому он активирует гиперссылку и отправляет сообщение &lt;code&gt;POST https://example.com/api/v1/order&lt;/code&gt; с соответствующим телом. После этого служба обрабатывает сообщение и отвечает результатом, имеющим надлежащий заголовок статуса HTTP, например &lt;code&gt;201 - created&lt;/code&gt; результате успеха. Для аннотирования сообщений подробными метаданными стандартное решение использовать формат RDF, например, &lt;a href=&quot;http://json-ld.org/&quot;&gt;JSON-LD&lt;/a&gt; с вокабом REST, например, &lt;a href=&quot;http://www.markus-lanthaler.com/hydra/&quot;&gt;Hydra&lt;/a&gt; и специфичные для домена вокабы, такие как &lt;a href=&quot;http://schema.org/&quot;&gt;schema.org,&lt;/a&gt; или любой другой &lt;a href=&quot;http://lov.okfn.org/dataset/lov/&quot;&gt;связанный&lt;/a&gt; каталог данных, и, возможно, пользовательский специфичный для приложения словарь, если необходимо. Теперь это непросто, поэтому большинство пользователей используют HAL и другие простые форматы, которые обычно предоставляют только REST vocab, но не поддерживают связанные данные.</target>
        </trans-unit>
        <trans-unit id="519a503f187cd31038f7706dcd1d8a0887042f78" translate="yes" xml:space="preserve">
          <source>For example, Let's imagine that we have a user database that is managed by a web service. Our service uses a custom hypermedia based on JSON, for which we assign the mimetype &lt;code&gt;application/json+userdb&lt;/code&gt; (There might also be an &lt;code&gt;application/xml+userdb&lt;/code&gt; and &lt;code&gt;application/whatever+userdb&lt;/code&gt; - many media types may be supported). The client and the server have both been programmed to understand this format, but they don't know anything about each other. As &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Roy Fielding&lt;/a&gt; points out:</source>
          <target state="translated">Например, давайте представим, что у нас есть пользовательская база данных, которая управляется веб-службой. Наш сервис использует пользовательскую гипермедиа на основе JSON, для которой мы назначаем mimetype &lt;code&gt;application/json+userdb&lt;/code&gt; (может также существовать &lt;code&gt;application/xml+userdb&lt;/code&gt; и &lt;code&gt;application/whatever+userdb&lt;/code&gt; - могут поддерживаться многие типы мультимедиа). Клиент и сервер были запрограммированы для понимания этого формата, но они ничего не знают друг о друге. Как отмечает &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Рой Филдинг&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="29ff533a59385e46befeb9d1d442ce81cde883fb" translate="yes" xml:space="preserve">
          <source>For example, instead a set of URLs which might look like some of the following..</source>
          <target state="translated">Например,вместо этого набор URL,который может выглядеть,как некоторые из следующих...</target>
        </trans-unit>
        <trans-unit id="ce3d305d56ec5c6ee26c71725d770976054d26b3" translate="yes" xml:space="preserve">
          <source>For sending and receiving messages, it involves using HTTP methods, and it does not require a strict message definition, unlike Web services.</source>
          <target state="translated">Для отправки и получения сообщений,в отличие от Web-служб,он предполагает использование HTTP-методов и не требует строгого определения сообщения.</target>
        </trans-unit>
        <trans-unit id="096bafb1ad02c5e340fc0cffb7efac1d03c6fdd6" translate="yes" xml:space="preserve">
          <source>Further reading:</source>
          <target state="translated">Дальнейшее чтение:</target>
        </trans-unit>
        <trans-unit id="ae09a97e20415e22fe1f93eb6fbb98ed8d14de81" translate="yes" xml:space="preserve">
          <source>GET defines a reading access of the resource without side-effects. The resource is never changed via a GET request, e.g., the request has no side effects (idempotent).</source>
          <target state="translated">GET определяет доступ на чтение ресурса без побочных эффектов.Ресурс никогда не изменяется через GET-запрос,например,запрос не имеет побочных эффектов (idempotent).</target>
        </trans-unit>
        <trans-unit id="c4c41d24d5f2a151608ed14ff7819f6f47a5271f" translate="yes" xml:space="preserve">
          <source>GET: &amp;ndash; It provides read only access to a resource.</source>
          <target state="translated">GET: - Предоставляет доступ только для чтения к ресурсу.</target>
        </trans-unit>
        <trans-unit id="5e04d05de713337d37ea8308533c814f117ef859" translate="yes" xml:space="preserve">
          <source>Given this view point, the rest style is not really tied to internet or web application. It's a fundamental solution to many of the programming situations. It is not simple either, it just makes the interface really simple, and copes with other technologies amazingly well.</source>
          <target state="translated">С учетом этой точки зрения,стиль остального на самом деле не привязан к интернету или веб-приложениям.Это фундаментальное решение для многих ситуаций программирования.Он также не прост,он просто делает интерфейс действительно простым и удивительно хорошо справляется с другими технологиями.</target>
        </trans-unit>
        <trans-unit id="413e85dd36b6612ff8f3b552ddd4ae973747eb10" translate="yes" xml:space="preserve">
          <source>Here is my basic outline of REST. I tried to demonstrate the thinking behind each of the components in a RESTful architecture so that understanding the concept is more intuitive. Hopefully this helps demystify REST for some people!</source>
          <target state="translated">Вот мои основные принципы REST.Я попытался продемонстрировать мышление каждого из компонентов в RESTful архитектуре,чтобы понимание концепции было более интуитивным.Надеюсь,это поможет некоторым людям демистифицировать REST!</target>
        </trans-unit>
        <trans-unit id="c419bb60824d17f1c8fc3f5f0378842579d5c500" translate="yes" xml:space="preserve">
          <source>I apologize if I'm not answering the question directly, but it's easier to understand all this with more detailed examples. Fielding is not easy to understand due to all the abstraction and terminology.</source>
          <target state="translated">Приношу свои извинения,если я не отвечаю на вопрос напрямую,но все это легче понять на более подробных примерах.Полевая работа нелегка для понимания из-за всей абстракции и терминологии.</target>
        </trans-unit>
        <trans-unit id="087ec8b5ab0cac5efee7be73a08f41b5611d251f" translate="yes" xml:space="preserve">
          <source>I define restful programming as</source>
          <target state="translated">Я определяю умиротворяющее программирование как</target>
        </trans-unit>
        <trans-unit id="ee52bb4671d83e94060d7610bdd9bf819906adce" translate="yes" xml:space="preserve">
          <source>I don't think you should feel stupid for not hearing about REST outside Stack Overflow..., I would be in the same situation!; answers to this other SO question on &lt;a href=&quot;https://stackoverflow.com/q/243388/463478&quot;&gt;Why is REST getting big now&lt;/a&gt; could ease some feelings.</source>
          <target state="translated">Я не думаю, что вы должны чувствовать себя глупо, если не слышите о REST вне переполнения стека ..., я бы попал в ту же ситуацию !; Ответы на этот другой вопрос о том, &lt;a href=&quot;https://stackoverflow.com/q/243388/463478&quot;&gt;почему REST становится больше,&lt;/a&gt; могут ослабить некоторые чувства.</target>
        </trans-unit>
        <trans-unit id="6c76368a522ebb58d381771d2b88fa3b274443e2" translate="yes" xml:space="preserve">
          <source>I found this fantastic, short, and easy to understand tutorial about REST by Dr. M. Elkstein and quoting the essential part that would answer your question for the most part:</source>
          <target state="translated">Я нашла это фантастическое,короткое и легкое для понимания руководство по REST от доктора М.Элкштейна и цитирую существенную часть,которая бы ответила на ваш вопрос по большей части:</target>
        </trans-unit>
        <trans-unit id="6d8108db9657b6e64ef934ab59dc6f7fa01dcc70" translate="yes" xml:space="preserve">
          <source>I see a bunch of answers that say putting everything about user 123 at resource &quot;/user/123&quot; is RESTful.</source>
          <target state="translated">Я вижу кучу ответов,в которых говорится,что помещение всего о пользователе 123 на ресурс &quot;user123&quot; является RESTful.</target>
        </trans-unit>
        <trans-unit id="763841bd5f36269041a09b4b998b89fbb9e2caff" translate="yes" xml:space="preserve">
          <source>I think that the most important trick to understanding the architectural importance and performance implications of a RESTful and &lt;a href=&quot;http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf&quot;&gt;Shared Nothing&lt;/a&gt; architectures is to avoid getting hung up on the technology and implementation details. Concentrate on who owns resources, who is responsible for creating/maintaining them, etc. Then think about the representations, protocols, and technologies.</source>
          <target state="translated">Я думаю, что самый важный трюк для понимания важности архитектуры и влияний на производительность архитектур RESTful и &lt;a href=&quot;http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf&quot;&gt;Shared Nothing&lt;/a&gt; - это не зацикливаться на деталях технологии и реализации. Сконцентрируйтесь на том, кому принадлежат ресурсы, кто отвечает за их создание / обслуживание и т. Д. Затем подумайте о представлениях, протоколах и технологиях.</target>
        </trans-unit>
        <trans-unit id="d0530a0292feea24c4a9346fcd870c5d42a8ef18" translate="yes" xml:space="preserve">
          <source>I think the point of restful is the &lt;strong&gt;separation of the statefulness into a higher layer&lt;/strong&gt; while making use of the internet (protocol) as a &lt;strong&gt;stateless transport layer&lt;/strong&gt;. Most other approaches mix things up.</source>
          <target state="translated">Я думаю, что смысл restful - это &lt;strong&gt;разделение состояния на более высокий уровень&lt;/strong&gt; при использовании Интернета (протокола) в качестве &lt;strong&gt;транспортного уровня без сохранения состояния&lt;/strong&gt; . Большинство других подходов перемешивают.</target>
        </trans-unit>
        <trans-unit id="c322421456d9bf2c2db73cb8c6cdc0e978e2f5ea" translate="yes" xml:space="preserve">
          <source>I would say RESTful programming would be about creating systems (API) that follow the REST architectural style.</source>
          <target state="translated">Я бы сказал,что RESTful программирование-это создание систем (API),которые следуют архитектурному стилю REST.</target>
        </trans-unit>
        <trans-unit id="7efc17b40148a3f7a450c659d22a107b0159fbac" translate="yes" xml:space="preserve">
          <source>I would say that an important building block in understanding REST lies in the endpoints or mappings, such as &lt;code&gt;/customers/{id}/balance&lt;/code&gt;.</source>
          <target state="translated">Я бы сказал, что важным строительным блоком в понимании REST являются конечные точки или сопоставления, такие как &lt;code&gt;/customers/{id}/balance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00c15a6f862dfb4e67e15e8fab5e3217684aa057" translate="yes" xml:space="preserve">
          <source>I'm not looking to self promote, but i expand on these ideas to great depth in my talk &lt;a href=&quot;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&quot;&gt;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&lt;/a&gt; .</source>
          <target state="translated">Я не стремлюсь к саморекламе, но я углубляюсь в эти идеи в своем выступлении &lt;a href=&quot;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&quot;&gt;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c54b01044e3ae27d309c48efbe56fe8b30a02fdb" translate="yes" xml:space="preserve">
          <source>IMO:</source>
          <target state="translated">IMO:</target>
        </trans-unit>
        <trans-unit id="528e227c40908c4c76424c153287878418391881" translate="yes" xml:space="preserve">
          <source>If I had to reduce the original dissertation on REST to just 3 short sentences, I think the following captures its essence:</source>
          <target state="translated">Если бы мне пришлось сократить первоначальную диссертацию по REST всего до 3-х коротких предложений,то,думаю,следующее захватывает ее суть:</target>
        </trans-unit>
        <trans-unit id="3e4a789505499d4ebc9acf09affff2580e66a8db" translate="yes" xml:space="preserve">
          <source>If you are really interested in what a RESTful architecture is and why it works, read &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;his thesis&lt;/a&gt; a few times and read the &lt;strong&gt;whole thing&lt;/strong&gt; not just Chapter 5! Next look into &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;why DNS works&lt;/a&gt;. Read about the hierarchical organization of DNS and how referrals work. Then read and consider how DNS caching works. Finally, read the HTTP specifications (&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; in particular) and consider how and why the caching works the way that it does. Eventually, it will just click. The final revelation for me was when I saw the similarity between DNS and HTTP. After this, understanding why SOA and Message Passing Interfaces are scalable starts to click.</source>
          <target state="translated">Если вы действительно заинтересованы в том, что такое архитектура RESTful и почему она работает, прочитайте &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;его тезис&lt;/a&gt; несколько раз и прочитайте &lt;strong&gt;все это, а&lt;/strong&gt; не только главу 5! Далее рассмотрим, &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;почему работает DNS&lt;/a&gt; . Прочитайте об иерархической организации DNS и о том, как работают рефералы. Затем прочитайте и рассмотрите, как работает DNS-кэширование. Наконец, прочтите спецификации HTTP (в частности &lt;a href=&quot;http://tools.ietf.org/html/rfc3040&quot;&gt;RFC2616&lt;/a&gt; и RFC3040 ) и подумайте, как и почему кэширование работает так, как оно работает. В конце концов, он просто щелкнет. Последнее откровение для меня было, когда я увидел сходство между DNS и HTTP. После этого начинается понимание того, почему интерфейсы SOA и Message Passing масштабируемы.</target>
        </trans-unit>
        <trans-unit id="5c9c0f1f96e6c661dd2c0857fa65fd08bb396af3" translate="yes" xml:space="preserve">
          <source>In a REST based architecture you have a REST server which provides
  access to the resources. A REST client can access and modify the REST
  resources.</source>
          <target state="translated">В архитектуре на основе REST у вас есть REST сервер,который обеспечивает доступ к ресурсам.Клиент REST может получить доступ к ресурсам REST и модифицировать их.</target>
        </trans-unit>
        <trans-unit id="2a7fcadf01fdd539dc00964a4063d163ad342bf9" translate="yes" xml:space="preserve">
          <source>In a REST based architecture, everything is a resource(Users, Orders, Comments). A resource is accessed via a common interface based on the HTTP standard methods(GET, PUT, PATCH, DELETE etc).</source>
          <target state="translated">В архитектуре,основанной на REST,все является ресурсом (Пользователи,Заказы,Комментарии).Доступ к ресурсу осуществляется через общий интерфейс,основанный на стандартных методах HTTP (GET,PUT,PATCH,DELETE и т.д.).</target>
        </trans-unit>
        <trans-unit id="81af6a9f5471cbc482ac157847e6af8a50d7537f" translate="yes" xml:space="preserve">
          <source>In computing, representational state transfer (REST) is an
  architectural style used for web development.</source>
          <target state="translated">В вычислительной технике,передача репрезентативного состояния (REST)является архитектурным стилем,используемым для веб-разработки.</target>
        </trans-unit>
        <trans-unit id="508381eb480015bf82a7312e0cfb8e350127a358" translate="yes" xml:space="preserve">
          <source>In many ways, the World Wide Web itself, based on HTTP, can be viewed
  as a REST-based architecture. RESTful applications use HTTP requests
  to post data (create and/or update), read data (e.g., make queries),
  and delete data. Thus, REST uses HTTP for all four CRUD
  (Create/Read/Update/Delete) operations.</source>
          <target state="translated">Во многих отношениях саму всемирную паутину,основанную на HTTP,можно рассматривать как архитектуру,основанную на REST.Приложения,работающие в режиме REST,используют HTTP-запросы для размещения данных (создания и обновления андор),чтения данных (например,выполнения запросов)и удаления данных.Таким образом,REST использует HTTP для всех четырех операций CRUD (CreateReadUpdateDelete).</target>
        </trans-unit>
        <trans-unit id="9afec0b39286ce35f8ff306c75875ec463e27211" translate="yes" xml:space="preserve">
          <source>In many ways, the World Wide Web itself, based on HTTP, can be viewed    as a REST-based architecture.</source>
          <target state="translated">Во многих отношениях саму всемирную паутину,основанную на HTTP,можно рассматривать как архитектуру,основанную на REST.</target>
        </trans-unit>
        <trans-unit id="d7d9b177727972b7bd403cb1d9830e8972f6ccaf" translate="yes" xml:space="preserve">
          <source>In other words you're writing simple point-to-point network applications over HTTP which uses verbs such as GET, POST, PUT or DELETE by implementing RESTful architecture which proposes standardization of the interface each &amp;ldquo;resource&amp;rdquo; exposes. It is nothing that using current features of the web in a simple and effective way (highly successful, proven and distributed architecture). It is an alternative to more complex mechanisms like &lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture&quot;&gt;CORBA&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt;.</source>
          <target state="translated">Другими словами, вы пишете простые двухточечные сетевые приложения по HTTP, которые используют глаголы, такие как GET, POST, PUT или DELETE, реализуя архитектуру RESTful, которая предлагает стандартизацию интерфейса, предоставляемого каждым &amp;laquo;ресурсом&amp;raquo;. Это ничто иное, как использование текущих возможностей Интернета простым и эффективным способом (очень успешная, проверенная и распределенная архитектура). Это альтернатива более сложным механизмам, таким как &lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture&quot;&gt;CORBA&lt;/a&gt; и &lt;a href=&quot;http://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9075c88ba609ac32ad4853adceff80a57b9c8848" translate="yes" xml:space="preserve">
          <source>In the end &lt;strong&gt;any RESTful client should be able to consume to any RESTful service as long as the content format is known.&lt;/strong&gt;</source>
          <target state="translated">В конце концов, &lt;strong&gt;любой клиент RESTful должен иметь возможность использовать любой сервис RESTful, пока известен формат контента.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6435852cb4e96cc87686e94b5374a8056f393527" translate="yes" xml:space="preserve">
          <source>In the future, you can then retrieve the user information:</source>
          <target state="translated">В дальнейшем вы можете получить информацию о пользователе:</target>
        </trans-unit>
        <trans-unit id="d6ecb449599f6dd2f5e9713553e3cd31fe1f0435" translate="yes" xml:space="preserve">
          <source>Install POSTMAN(Chrome) / REST(Firefox) plugin</source>
          <target state="translated">Установить POSTMAN (Хром)REST (Firefox)плагин</target>
        </trans-unit>
        <trans-unit id="6a6d9700ec195facf4fac9e8b95e37072828dc22" translate="yes" xml:space="preserve">
          <source>Interestingly, there is no mention of HTTP POST, GET, DELETE, or PUT operations in the dissertation. That must be someone's later interpretation of a &quot;best practice&quot; for a &quot;uniform interface&quot;.</source>
          <target state="translated">Интересно,что в диссертации нет упоминания об операциях HTTP POST,GET,DELETE или PUT.Это должно быть чьей-то более поздней трактовкой &quot;передовой практики&quot; для &quot;единого интерфейса&quot;.</target>
        </trans-unit>
        <trans-unit id="f9de0a4336192b307d47a7bd6e45e0eaef080436" translate="yes" xml:space="preserve">
          <source>Introduction about Rest</source>
          <target state="translated">Введение в Отдых</target>
        </trans-unit>
        <trans-unit id="b9c999a74770669b9c8ffb4ad17078f65b2cda93" translate="yes" xml:space="preserve">
          <source>It relies on a stateless, client-server, cacheable communications protocol -- and in virtually all cases, the HTTP protocol is used.</source>
          <target state="translated">Он полагается на протокол &quot;без гражданства&quot;,&quot;клиент-сервер&quot;,кэшируемый протокол связи-и практически во всех случаях используется протокол HTTP.</target>
        </trans-unit>
        <trans-unit id="1117236a998be55f80d560abd424de90ea9e2991" translate="yes" xml:space="preserve">
          <source>It will return output response</source>
          <target state="translated">Он вернет выходной отклик</target>
        </trans-unit>
        <trans-unit id="c89e148b7af16b441451c1995bfe2abaf6361908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an arrangement of functions on which the testers performs requests and receive responses. In REST API interactions are made via HTTP protocol.</source>
          <target state="translated">Это набор функций, по которым тестеры выполняют запросы и получают ответы. В REST API взаимодействие осуществляется по протоколу HTTP.</target>
        </trans-unit>
        <trans-unit id="f0fc1358f601de6b260eab812260ed0430f7e282" translate="yes" xml:space="preserve">
          <source>It's been the best practical approach to handle the fundamental changes of programming in internet era. Regarding the fundamental changes, Erik Meijer has a discussion on show here: &lt;a href=&quot;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&quot;&gt;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&lt;/a&gt; . He summarizes it as the five effects, and presents a solution by designing the solution into a programming language. The solution, could also be achieved in the platform or system level, regardless of the language. The restful could be seen as one of the solutions that has been very successful in the current practice.</source>
          <target state="translated">Это был лучший практический подход, чтобы справиться с фундаментальными изменениями программирования в эпоху Интернета. Что касается фундаментальных изменений, Эрик Мейер обсуждает это здесь: &lt;a href=&quot;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&quot;&gt;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&lt;/a&gt; . Он суммирует его как пять эффектов и представляет решение, разработав решение на языке программирования. Решение также может быть достигнуто на уровне платформы или системы, независимо от языка. Отдых может рассматриваться как одно из решений, которое было очень успешным в современной практике.</target>
        </trans-unit>
        <trans-unit id="d4929d90be24c95c993943d45502f80422e27a62" translate="yes" xml:space="preserve">
          <source>It's programming where the architecture of your system fits the &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;REST style&lt;/a&gt; laid out by Roy Fielding in &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;his thesis&lt;/a&gt;. Since this is the architectural style that describes the web (more or less), lots of people are interested in it.</source>
          <target state="translated">Это программирование, в котором архитектура вашей системы соответствует &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;стилю REST,&lt;/a&gt; изложенному Роем Филдингом в &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;его диссертации&lt;/a&gt; . Поскольку это архитектурный стиль, который описывает сеть (более или менее), многие люди заинтересованы в этом.</target>
        </trans-unit>
        <trans-unit id="9e58b34ecd5fe46f5c7fac142a7753476a694f3e" translate="yes" xml:space="preserve">
          <source>JSON is not restful programming</source>
          <target state="translated">JSON не является успокаивающим программированием</target>
        </trans-unit>
        <trans-unit id="a6b85e0f041b2c7697f401797ec1377054a290db" translate="yes" xml:space="preserve">
          <source>Just my 2c.</source>
          <target state="translated">Всего лишь мои 2c.</target>
        </trans-unit>
        <trans-unit id="bbe8d64fcde25a40febca185bf5ef63d774333ce" translate="yes" xml:space="preserve">
          <source>Keep in mind that GET requests should never be used for updating information. For example, a GET request for adding an item to a cart</source>
          <target state="translated">Помните,что GET-запросы никогда не должны использоваться для обновления информации.Например,GET-запрос на добавление элемента в корзину</target>
        </trans-unit>
        <trans-unit id="5f82e7663dd4156cb07776cb1cea89dd1aba1b01" translate="yes" xml:space="preserve">
          <source>Layered system</source>
          <target state="translated">многоуровневая система</target>
        </trans-unit>
        <trans-unit id="133b041c9729c525d972a67420b5a147370536ad" translate="yes" xml:space="preserve">
          <source>Learn REST: A Tutorial</source>
          <target state="translated">Учись REST:Учебное пособие</target>
        </trans-unit>
        <trans-unit id="d48495a4077a6c79d43f781b565680695cf2d342" translate="yes" xml:space="preserve">
          <source>Martin Fowler's
thoughts</source>
          <target state="translated">мысли Мартина Фаулера</target>
        </trans-unit>
        <trans-unit id="de83e0aeb9afb13ea59f9bf7102b93ccfae94aaa" translate="yes" xml:space="preserve">
          <source>Metadata is passed as name-value pairs (post data and query string parameters).</source>
          <target state="translated">Метаданные передаются в виде пар имя-значение (параметры пост-данных и строки запроса).</target>
        </trans-unit>
        <trans-unit id="b45afbd2f6f71f5bbf40bc713d36b1cb5591272d" translate="yes" xml:space="preserve">
          <source>Must reads are &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Representational State Transfer (REST)&lt;/a&gt; and &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIs must be hypertext-driven&lt;/a&gt;</source>
          <target state="translated">Должны быть чтения &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Передача состояния представления (REST),&lt;/a&gt; а &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;API REST должны управляться гипертекстом&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75117da5ea6dd4a55238ac032ebaaa4e06e4091c" translate="yes" xml:space="preserve">
          <source>Notice that we are using different HTTP verbs (&lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; etc.) to manipulate these resources, and that the only knowledge we presume on the client's part is our media definition.</source>
          <target state="translated">Обратите внимание, что мы используем различные HTTP-глаголы ( &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; и т. Д.) Для манипулирования этими ресурсами, и что единственное знание, которое мы предполагаем со стороны клиента, - это наше определение медиа.</target>
        </trans-unit>
        <trans-unit id="83b061b2a63b8f2183eb1bdcdd47faa9c5345256" translate="yes" xml:space="preserve">
          <source>Now, if all of this sounds familiar, then great. The Hypertext Transfer Protocol (HTTP), which defines the communication protocol via the World Wide Web is an implementation of the abstract notion of RESTful architecture (or an instance of the REST class if you're an OOP fanatic like me). In this implementation of REST, the client and server interact via GET, POST, PUT, DELETE, etc., which are part of the universal language and the resources can be pointed to using URLs.</source>
          <target state="translated">Если все это звучит знакомо,то отлично.Протокол передачи гипертекста (HTTP),определяющий протокол взаимодействия через всемирную паутину,является реализацией абстрактного представления о RESTful архитектуре (или примером класса REST,если вы,как и я,фанатик ООП).В этой реализации REST клиент и сервер взаимодействуют через GET,POST,PUT,DELETE и т.д.,которые являются частью универсального языка,и на ресурсы можно указывать с помощью URL.</target>
        </trans-unit>
        <trans-unit id="e1a9621fd53f3f752aff5f25b313a5a3c60c684e" translate="yes" xml:space="preserve">
          <source>Old question, newish way of answering.  There's a lot of misconception out there about this concept.  I always try to remember:</source>
          <target state="translated">Старый вопрос,новый способ ответа.Там много заблуждений по поводу этой концепции.Я всегда стараюсь вспомнить:</target>
        </trans-unit>
        <trans-unit id="438027d47ce1c5a96c385f53eecd236c425fb2b5" translate="yes" xml:space="preserve">
          <source>One of the best reference I found when I try to find the simple real meaning of rest.</source>
          <target state="translated">Одна из лучших ссылок,которую я нашел,когда пытался найти простой реальный смысл отдыха.</target>
        </trans-unit>
        <trans-unit id="c6f2d9e5ea80ff9b7b9ded9e2a81fb5f446691e1" translate="yes" xml:space="preserve">
          <source>POST updates an existing resource or creates a new resource.</source>
          <target state="translated">POST обновляет существующий ресурс или создает новый ресурс.</target>
        </trans-unit>
        <trans-unit id="d742711b2a6bd7b769816a15fa5a239a2c74f940" translate="yes" xml:space="preserve">
          <source>POST: &amp;ndash; It is used to create or update a new resource.</source>
          <target state="translated">POST: - Он используется для создания или обновления нового ресурса.</target>
        </trans-unit>
        <trans-unit id="37e0818cbbbc83b5f7771a4d5dfae0eb226e31e7" translate="yes" xml:space="preserve">
          <source>PUT creates a new resource. It must also be idempotent.</source>
          <target state="translated">PUT создает новый ресурс.Он также должен быть идолопоклонным.</target>
        </trans-unit>
        <trans-unit id="ada2743b893defbc7c8ab2a60424b669dd79a22b" translate="yes" xml:space="preserve">
          <source>PUT: &amp;ndash; It is used to update or replace an existing resource or create a new resource.</source>
          <target state="translated">PUT: - Он используется для обновления или замены существующего ресурса или создания нового ресурса.</target>
        </trans-unit>
        <trans-unit id="675a94eb09e6d971c2a74e502df85b0396498a6f" translate="yes" xml:space="preserve">
          <source>PayPal's API has hypermedia controls</source>
          <target state="translated">API PayPal имеет контроль гипермедиа</target>
        </trans-unit>
        <trans-unit id="330809f2cc51f1c140e1980086142c16a9addb97" translate="yes" xml:space="preserve">
          <source>Principle 1: Everything is a Resource
In the REST architectural style, data and functionality are considered resources and are accessed using Uniform Resource Identifiers (URIs), typically links on the Web.</source>
          <target state="translated">Принцип 1:Все является ресурсом В архитектурном стиле REST данные и функциональность считаются ресурсами и доступ к ним осуществляется с помощью Унифицированных Идентификаторов Ресурсов (URI),как правило,ссылок в Интернете.</target>
        </trans-unit>
        <trans-unit id="8c699adbd41e9b331e5fbd3c027ab2582737eb63" translate="yes" xml:space="preserve">
          <source>Principle 2: Every Resource is Identified by a Unique Identifier (URI)</source>
          <target state="translated">Принцип 2:Каждый ресурс идентифицируется с помощью уникального идентификатора (УИ).</target>
        </trans-unit>
        <trans-unit id="b612f5757ab3b67dcdf0fc959e4a1f2295c39bfc" translate="yes" xml:space="preserve">
          <source>Principle 3: Use Simple and Uniform Interfaces</source>
          <target state="translated">Принцип 3:Использование простых и унифицированных интерфейсов</target>
        </trans-unit>
        <trans-unit id="1c4054641d8394bb16320893dba0d8f48d910d14" translate="yes" xml:space="preserve">
          <source>Principle 4: Communication is Done by Representation</source>
          <target state="translated">Принцип 4:Коммуникация осуществляется посредством представительства.</target>
        </trans-unit>
        <trans-unit id="52e149151dd57ddc7a1edcf0a393bb8fc2cc1dc9" translate="yes" xml:space="preserve">
          <source>Principle 5: Be Stateless</source>
          <target state="translated">Принцип 5:Быть без гражданства</target>
        </trans-unit>
        <trans-unit id="3b6ad19884af654ebfaa84e23196de80335cb4c9" translate="yes" xml:space="preserve">
          <source>Protocols are limited to what you can communicate by using URLs.</source>
          <target state="translated">Протоколы ограничены тем,что вы можете общаться с помощью URL-адресов.</target>
        </trans-unit>
        <trans-unit id="ea0905504dfdf615e0862b8f2c6ac34fbc396c3b" translate="yes" xml:space="preserve">
          <source>REST (Representational State Transfer) is a design architecture that outlines how networked resources (i.e. nodes that share information) are designed and addressed. In general, a RESTful architecture makes it so that the client (the requesting machine) and the server (the responding machine) can request to read, write, and update data without the client having to know how the server operates and the server can pass it back without needing to know anything about the client. Okay, cool...but how do we do this in practice?</source>
          <target state="translated">REST (Representational State Transfer-Передача состояния представления)-это архитектура проектирования,которая описывает то,как проектируются сетевые ресурсы (т.е.узлы,которые совместно используют информацию)и как с ними обращаются.В общем,RESTful архитектура делает ее такой,что клиент (запрашивающая машина)и сервер (отвечающая машина)могут запрашивать чтение,запись и обновление данных,при этом клиенту не нужно знать,как работает сервер,а сервер может передавать их обратно без необходимости знать что-либо о клиенте.Хорошо,круто...но как это сделать на практике?</target>
        </trans-unit>
        <trans-unit id="700c9dae20f56bed7f78e92f023ff70ce8630a9f" translate="yes" xml:space="preserve">
          <source>REST === HTTP analogy is not correct until you do not stress to the fact that it &quot;MUST&quot; be &lt;a href=&quot;http://restfulapi.net/hateoas/&quot;&gt;HATEOAS&lt;/a&gt; driven.</source>
          <target state="translated">REST === HTTP-аналог не верен до тех пор, пока вы не подчеркнете, что он &amp;laquo;ДОЛЖЕН&amp;raquo; управляться &lt;a href=&quot;http://restfulapi.net/hateoas/&quot;&gt;HATEOAS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d900533fc0307874766ce99858e2dca6a98b0ed" translate="yes" xml:space="preserve">
          <source>REST allows that resources have different representations, e.g., text, XML, JSON etc. The REST client can ask for a specific representation via the HTTP protocol (content negotiation).</source>
          <target state="translated">REST позволяет,чтобы ресурсы имели различные представления,например,текст,XML,JSON и т.д.Клиент REST может запросить определенное представление через протокол HTTP (согласование содержания).</target>
        </trans-unit>
        <trans-unit id="d7e35d79a67bcd2fd91ce8bbd613ef5c12223b40" translate="yes" xml:space="preserve">
          <source>REST also permits communication between computers with each other over a network.</source>
          <target state="translated">REST также позволяет обмениваться данными между компьютерами по сети.</target>
        </trans-unit>
        <trans-unit id="7bebea77f381f6a449770f9552c88ba86e2ca2da" translate="yes" xml:space="preserve">
          <source>REST constraints result a highly scalable system in where the clients are decoupled from the implementations of the services. So the clients can be reusable, general just like the browsers on the web. The clients and the services share the same standards and vocabs, so they can understand each other despite the fact that the client does not know the implementation details of the service. This makes possible to create automated clients which can find and utilize REST services to achieve their goals. In long term these clients can communicate to each other and trust each other with tasks, just like humans do. If we add learning patterns to such clients, then the result will be one or more AI using the web of machines instead of a single server park. So at the end the dream of Berners Lee: the semantic web and the artificial intelligence will be reality. So in 2030 we end up terminated by the Skynet. Until then ... ;-)</source>
          <target state="translated">В результате ограничений REST получается высокомасштабируемая система,в которой клиенты отделены от реализации услуг.Таким образом,клиенты могут быть многократно использованы,как и браузеры в сети.Клиенты и сервисы имеют одинаковые стандарты и словарь,поэтому они могут понимать друг друга,несмотря на то,что клиент не знает деталей реализации сервиса.Это позволяет создавать автоматизированных клиентов,которые могут найти и использовать REST услуги для достижения своих целей.В долгосрочной перспективе эти клиенты могут общаться друг с другом и доверять друг другу в выполнении задач,как это делают люди.Если мы добавим обучающие шаблоны для таких клиентов,то результатом будет один или более ИИ,использующих паутину машин вместо одного парка серверов.Так что в конце мечта Бернера Ли:семантическая паутина и искусственный интеллект станут реальностью.Итак,в 2030 году мы заканчиваем &quot;Скайнет&quot;.А до тех пор...)</target>
        </trans-unit>
        <trans-unit id="34698ed4c6b87bbba6909fe832abf0a97a18c1e4" translate="yes" xml:space="preserve">
          <source>REST defines 6 architectural constraints which make any web service &amp;ndash; a &lt;strong&gt;true RESTful API&lt;/strong&gt;.</source>
          <target state="translated">REST определяет 6 архитектурных ограничений, которые делают любой веб-сервис - &lt;strong&gt;настоящий RESTful API&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2b8ff55c8c9a0ce9cfafc137b16baaa14a81abbf" translate="yes" xml:space="preserve">
          <source>REST in official words, REST is an architectural style built on certain principles using the current &amp;ldquo;Web&amp;rdquo; fundamentals.
There are 5 basic fundamentals of web which are leveraged to create REST services.</source>
          <target state="translated">REST, по официальным словам, REST - это архитектурный стиль, построенный на определенных принципах с использованием современных принципов &amp;laquo;Интернета&amp;raquo;. Существует 5 основных веб-основ, которые используются для создания сервисов REST.</target>
        </trans-unit>
        <trans-unit id="24e5aabd86f26882f23d01381f1a89f3a170449f" translate="yes" xml:space="preserve">
          <source>REST is a lightweight alternative to mechanisms like RPC (Remote
  Procedure Calls) and Web Services (SOAP, WSDL, et al.). Later, we will
  see how much more simple REST is.</source>
          <target state="translated">REST является легкой альтернативой таким механизмам,как RPC (удаленные вызовы процедур)и Web Services (SOAP,WSDL и др.).Позже мы увидим,насколько более простое REST.</target>
        </trans-unit>
        <trans-unit id="41d578dc3834d7de2f8d99a70b26c5ce81a848f5" translate="yes" xml:space="preserve">
          <source>REST is an &lt;em&gt;architecture style&lt;/em&gt; for designing networked applications.
  The idea is that, rather than using complex mechanisms such as CORBA,
  RPC or SOAP to connect between machines, simple HTTP is used to make
  calls between machines.</source>
          <target state="translated">REST - это &lt;em&gt;архитектурный стиль&lt;/em&gt; для проектирования сетевых приложений. Идея состоит в том, что вместо использования сложных механизмов, таких как CORBA, RPC или SOAP, для соединения между машинами, простой HTTP используется для выполнения вызовов между машинами.</target>
        </trans-unit>
        <trans-unit id="81954ff90e3db76a59f3feac17fcae16db3073fb" translate="yes" xml:space="preserve">
          <source>REST is an architectural pattern and style of writing distributed applications. It is not a programming style in the narrow sense.</source>
          <target state="translated">REST является архитектурным образцом и стилем написания распределенных приложений.Это не стиль программирования в узком смысле.</target>
        </trans-unit>
        <trans-unit id="6e3584ec485599f05ec62cb2d6b674b68d8c649a" translate="yes" xml:space="preserve">
          <source>REST is an architecture style for designing networked applications.
  The idea is that, rather than using complex mechanisms such as CORBA,
  RPC or SOAP to connect between machines, simple HTTP is used to make
  calls between machines.</source>
          <target state="translated">REST-это архитектурный стиль для проектирования сетевых приложений.Идея заключается в том,что вместо использования сложных механизмов,таких как CORBA,RPC или SOAP,для соединения между машинами используется простой HTTP для совершения звонков между машинами.</target>
        </trans-unit>
        <trans-unit id="6663bc679f3ecc9321597d4c451eda8a030d5e82" translate="yes" xml:space="preserve">
          <source>REST is often used in mobile applications, social networking Web sites, mashup tools and automated business processes. The REST style emphasizes that interactions between clients and services is enhanced by having a limited number of operations (verbs). Flexibility is provided by assigning resources (nouns) their own unique universal resource indicators (URIs).</source>
          <target state="translated">REST часто используется в мобильных приложениях,сайтах социальных сетей,инструментах мэшапа и автоматизированных бизнес-процессах.Стиль REST подчеркивает,что взаимодействие между клиентами и услугами улучшается за счет ограниченного количества операций (глаголов).Гибкость обеспечивается за счет присвоения ресурсам (существительным)собственных уникальных универсальных индикаторов ресурсов (URI).</target>
        </trans-unit>
        <trans-unit id="801d3af1b3e139b50282c4fab565cd444620074b" translate="yes" xml:space="preserve">
          <source>REST is using the various HTTP methods (mainly GET/PUT/DELETE) to manipulate data.</source>
          <target state="translated">REST использует различные методы HTTP (в основном GETPUTDELETE)для манипулирования данными.</target>
        </trans-unit>
        <trans-unit id="3a544da22b9e3f4d834aba2d28e038cfc7c394d2" translate="yes" xml:space="preserve">
          <source>REST messages often accepts the form either in form of XML, or JavaScript Object Notation (JSON).</source>
          <target state="translated">REST-сообщения часто принимают форму в виде XML или JavaScript Object Notation (JSON).</target>
        </trans-unit>
        <trans-unit id="ec356ddaca2bf110584184b56abbca5c18c7f324" translate="yes" xml:space="preserve">
          <source>REST proponents tend to favor URLs, such as</source>
          <target state="translated">Сторонники REST склонны отдавать предпочтение URL-адресам,таким как</target>
        </trans-unit>
        <trans-unit id="cdaffecf9a4b409c44dd9af81374c459b9474d48" translate="yes" xml:space="preserve">
          <source>REST stands for &quot;representational state transfer&quot;, which means it's all about communicating and modifying &lt;strong&gt;the state&lt;/strong&gt; of some resource in a system.</source>
          <target state="translated">REST расшифровывается как &amp;laquo;передача состояния репрезентации&amp;raquo;, что означает, что речь идет о передаче и изменении &lt;strong&gt;состояния&lt;/strong&gt; некоторого ресурса в системе.</target>
        </trans-unit>
        <trans-unit id="9451e5791b00a17503496c3f9586128ae49e1831" translate="yes" xml:space="preserve">
          <source>REST stands for Representational State Transfer. (It is sometimes
  spelled &quot;ReST&quot;.) It relies on a stateless, client-server, cacheable
  communications protocol -- and in virtually all cases, the HTTP
  protocol is used.</source>
          <target state="translated">REST означает Representational State Transfer.(Иногда это пишется как &quot;ReST&quot;.)Он опирается на протокол связи &quot;без гражданства&quot;,&quot;клиент-сервер&quot;,кэшируемый протокол связи-и практически во всех случаях используется протокол HTTP.</target>
        </trans-unit>
        <trans-unit id="3d1d7194413fe6b5bd76ca3ce8b73781e5ea0578" translate="yes" xml:space="preserve">
          <source>REST unlike home styles has had a tough time being consistently and practically applied. This may have been intentional. Leaving its actual implementation up to the designer. So you are free to do what you want so as long as you meet the constraints set out in the dissertation you are creating REST Systems.</source>
          <target state="translated">REST,в отличие от домашнего стиля,было непросто последовательно и практически применять.Это могло быть преднамеренным.Оставив его фактическое воплощение на усмотрение дизайнера.Таким образом,вы вольны делать то,что хотите,до тех пор,пока вы отвечаете ограничениям,изложенным в диссертации,которую вы создаете REST Systems.</target>
        </trans-unit>
        <trans-unit id="4ac191e5aa73c941d92cf5c5a7bdc101ccf17488" translate="yes" xml:space="preserve">
          <source>REST, operates on resource representations, each one identified by an URL. These are typically not data objects, but &lt;strong&gt;complex objects abstractions&lt;/strong&gt;.</source>
          <target state="translated">REST работает с представлениями ресурсов, каждое из которых идентифицируется URL-адресом. Обычно это не объекты данных, а &lt;strong&gt;абстракции сложных объектов&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="20bbdde9c5678f79d072b94099e0cd21aa108d71" translate="yes" xml:space="preserve">
          <source>REST: Representational State Transfer.</source>
          <target state="translated">ОТДЫХАЙ:Представительский государственный трансфер.</target>
        </trans-unit>
        <trans-unit id="0b418318f4f02e384e5a14b7c46def85c5fbf491" translate="yes" xml:space="preserve">
          <source>RESTful applications use HTTP requests to post data (create and/or
  update), read data (e.g., make queries), and delete data. Thus, REST
  uses HTTP for all four CRUD (Create/Read/Update/Delete) operations.</source>
          <target state="translated">RESTful приложения используют HTTP-запросы для отправки данных (создание и обновление андор),чтения данных (например,выполнение запросов)и удаления данных.Таким образом,REST использует HTTP для всех четырех операций CRUD (CreateReadUpdateDelete).</target>
        </trans-unit>
        <trans-unit id="d1feb4628e89cf3c408102d8d1c78190e38e6958" translate="yes" xml:space="preserve">
          <source>RESTful programming conforms to Web architecture design and, if properly implemented, it allows you to take the full advantage of scalable Web infrastructure.</source>
          <target state="translated">RESTful программирование соответствует дизайну веб-архитектуры и,при правильной реализации,позволяет в полной мере использовать преимущества масштабируемой веб-инфраструктуры.</target>
        </trans-unit>
        <trans-unit id="606ada79ad1420f9107ba76e74d9a5b5dc8a1dc1" translate="yes" xml:space="preserve">
          <source>RESTful programming is about:</source>
          <target state="translated">Очень интересное программирование:</target>
        </trans-unit>
        <trans-unit id="95c224223718abd56088ba177080385db881b4c6" translate="yes" xml:space="preserve">
          <source>RESTful programming is not for APIs</source>
          <target state="translated">Отдыхающее программирование не для API</target>
        </trans-unit>
        <trans-unit id="1b6a739654e06f630f96467756d48d1acd0d09d0" translate="yes" xml:space="preserve">
          <source>Rather than using a specific URL to delete a method (say, &lt;code&gt;/user/123/delete&lt;/code&gt;), you would send a DELETE request to the &lt;code&gt;/user/[id]&lt;/code&gt; URL, to edit a user, to retrieve info on a user you send a GET request to &lt;code&gt;/user/[id]&lt;/code&gt;</source>
          <target state="translated">Вместо того, чтобы использовать определенный URL для удаления метода (скажем, &lt;code&gt;/user/123/delete&lt;/code&gt; ), вы бы отправили запрос DELETE на URL &lt;code&gt;/user/[id]&lt;/code&gt; , чтобы отредактировать пользователя, чтобы получить информацию о пользователе, которого вы отправили запрос GET для &lt;code&gt;/user/[id]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d997a652dd80f71fb70e3ef43e6973ddd897ea7" translate="yes" xml:space="preserve">
          <source>Representation - all communication is done by representation (e.g. &lt;a href=&quot;http://en.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;)</source>
          <target state="translated">Представление - все общение осуществляется представлением (например, &lt;a href=&quot;http://en.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="2cd1d833a928d3195b51e6cfbe331c8c09c671dd" translate="yes" xml:space="preserve">
          <source>Resource (data, information).</source>
          <target state="translated">Ресурс (данные,информация).</target>
        </trans-unit>
        <trans-unit id="688688c5509b4d381bf4bce90f16794ddee6aacb" translate="yes" xml:space="preserve">
          <source>Resources are requested via URLs.</source>
          <target state="translated">Ресурсы запрашиваются по URL-адресам.</target>
        </trans-unit>
        <trans-unit id="c171c3ae71443c15b078bb93540e67b075abe63a" translate="yes" xml:space="preserve">
          <source>Richardson's Maturity Model</source>
          <target state="translated">Модель зрелости Ричардсона</target>
        </trans-unit>
        <trans-unit id="07bef3db6d8f0a971b46410592e99f25edb3d822" translate="yes" xml:space="preserve">
          <source>Roy Fielding, who coined the term, says &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIs must be hypertext-driven&lt;/a&gt;.  In particular, &quot;A REST API must not define fixed resource names or hierarchies&quot;.</source>
          <target state="translated">Рой Филдинг, который придумал этот термин, говорит, что &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;API-интерфейсы REST должны управляться гипертекстом&lt;/a&gt; . В частности, &amp;laquo;REST API не должен определять фиксированные имена ресурсов или иерархии&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4ed7f7fd296ad882c584b68eec97a766f06c9204" translate="yes" xml:space="preserve">
          <source>Roy himself cleared it &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Рой сам очистил это &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea8f1dff43bf90df7c15069182244296157f5ccf" translate="yes" xml:space="preserve">
          <source>Saying that Rest is just a syntactic change from using GET requests with an action parameter to using the available http verbs makes it look like it has no benefits and is purely cosmetic. The point is to use a language that can be understood and optimized by every part of the chain. If your GET operation has an action with side effects, you have to skip all HTTP caching or you'll end up with inconsistent results.</source>
          <target state="translated">Сказание,что Rest-это просто синтаксическое изменение от использования GET-запросов с параметром действия к использованию доступных http-глаголов,делает это выглядеть так,как будто у него нет никаких преимуществ,и является чисто косметическим.Суть в том,чтобы использовать язык,который может быть понятен и оптимизирован для каждой части цепочки.Если ваша GET-операция имеет действие с побочными эффектами,вам придется пропустить все HTTP-кэширование,иначе вы получите непоследовательные результаты.</target>
        </trans-unit>
        <trans-unit id="c4a2bd1212341d753b25f32677d4e7adf44e6015" translate="yes" xml:space="preserve">
          <source>Saying you use the REST style is similar to saying that you built a house in a particular style: for example Tudor or Victorian.  Both REST as an software style and Tudor or Victorian as a home style can be defined by the qualities and constraints that make them up. For example REST must have Client Server separation where messages are self-describing. Tudor style homes have Overlapping gables and Roofs that are steeply pitched with front facing gables. You can read Roy's dissertation to learn more about the constraints and qualities that make up REST.</source>
          <target state="translated">Говорить,что вы используете стиль REST-это то же самое,что сказать,что вы построили дом в определенном стиле:например,в стиле Тюдора или викторианской эпохи.И REST как стиль программного обеспечения,и стиль Тюдоров или викторианский как стиль дома могут быть определены качествами и ограничениями,которые их составляют.Например,REST должен иметь разделение клиентского сервера,где сообщения саморасписываются.Дома в стиле Тюдоров имеют перекрывающиеся фронтоны и крыши,которые круто наклонены на фронтоны.Вы можете прочитать диссертацию Роя,чтобы узнать больше об ограничениях и качествах,которые составляют REST.</target>
        </trans-unit>
        <trans-unit id="8e446171e587e12eabf8b79616dc1eb91a5a4557" translate="yes" xml:space="preserve">
          <source>See Martin Fowlers article the &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;Richardson Maturity Model&lt;/a&gt; (RMM) for an explanation on what an RESTful service is.</source>
          <target state="translated">См. Статью Мартина Фаулерса &amp;laquo; &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;Модель зрелости Ричардсона&amp;raquo;&lt;/a&gt; (RMM) для объяснения того, что такое сервис RESTful.</target>
        </trans-unit>
        <trans-unit id="fbe751100f5c892656ce1ca4a6009c25fbfc7f4b" translate="yes" xml:space="preserve">
          <source>Select content-Header</source>
          <target state="translated">Выбрать контент-Гидер</target>
        </trans-unit>
        <trans-unit id="16ed5c31752ac3f8db0119aea87a82b307c230ed" translate="yes" xml:space="preserve">
          <source>Select the REST method</source>
          <target state="translated">Выберите метод REST</target>
        </trans-unit>
        <trans-unit id="c0c99a62016d0168acb95e1b7c7865a1070d884a" translate="yes" xml:space="preserve">
          <source>So if your &quot;/user/123&quot; path is hardcoded on the client, it's not really RESTful.  A good use of HTTP, maybe, maybe not.  But not RESTful.  It has to come from hypertext.</source>
          <target state="translated">Так что если ваш путь &quot;user123&quot; жестко закодирован на клиенте,это не совсем RESTful.Хорошее использование HTTP,может быть,а может и нет.Но не RESTful.Он должен исходить из гипертекста.</target>
        </trans-unit>
        <trans-unit id="536946ca2831340799bf33cd36af457db31978e1" translate="yes" xml:space="preserve">
          <source>So it does not work with for example PUB/SUB sockets, it is based on REQ/REP.</source>
          <target state="translated">Поэтому он не работает,например,с PUBSUB сокетами,он основан на REQREP.</target>
        </trans-unit>
        <trans-unit id="cb3acf66e66e8ac82b059d304608e2b649d07fd9" translate="yes" xml:space="preserve">
          <source>So the server does not maintain the states of the clients. This means that you cannot use server a side session storage and you have to authenticate every request. Your clients possibly send basic auth headers through an encrypted connection. (By large applications it is hard to maintain many sessions.)</source>
          <target state="translated">Поэтому сервер не поддерживает состояния клиентов.Это означает,что вы не можете использовать сервер для хранения боковых сеансов и должны аутентифицировать каждый запрос.Ваши клиенты,возможно,посылают основные заголовки автозаголовков через зашифрованное соединение.(Для больших приложений сложно поддерживать множество сеансов).</target>
        </trans-unit>
        <trans-unit id="9607344c01bb579773361b71bbb45cde205cc658" translate="yes" xml:space="preserve">
          <source>So you don't have to serve the same requests again and again.</source>
          <target state="translated">Так что вам не придется снова и снова обслуживать одни и те же запросы.</target>
        </trans-unit>
        <trans-unit id="6755df0f56ac5cee70d67ea5c025e47782da8d98" translate="yes" xml:space="preserve">
          <source>State transition controls only make sense if the client and server agree upon a media type representation of the resource.  Otherwise there's no way to know what's a control and what isn't and how to execute a control.  IE if browsers didn't know &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags in html then there'd be nothing for you to submit to transition state in your browser.</source>
          <target state="translated">Элементы управления переходом между состояниями имеют смысл только в том случае, если клиент и сервер договариваются о представлении медиа-типа ресурса. В противном случае нет способа узнать, что такое элемент управления, а что нет, и как выполнить элемент управления. То есть, если браузеры не знают тегов &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; в html, вам нечего будет отправлять в переходное состояние в вашем браузере.</target>
        </trans-unit>
        <trans-unit id="cc782a4dc89d3cf79cc09c506daf5966811372c9" translate="yes" xml:space="preserve">
          <source>Stateless</source>
          <target state="translated">Stateless</target>
        </trans-unit>
        <trans-unit id="c2fa7bc4bb797a9f80155f336549e20f8ae9f995" translate="yes" xml:space="preserve">
          <source>Steps to Automate REST API</source>
          <target state="translated">Шаги по автоматизации API REST</target>
        </trans-unit>
        <trans-unit id="266d1df5b50f526d563a69c1948ed69ee2a31597" translate="yes" xml:space="preserve">
          <source>Structured URLs and Http Methods/Verbs are not the definition of
restful programming.</source>
          <target state="translated">Структурированные URL и Http MethodsVerbs не являются определением спокойного программирования.</target>
        </trans-unit>
        <trans-unit id="8f7198c3c2d3db3f7cabeab606f0ec990cba16f4" translate="yes" xml:space="preserve">
          <source>That xfront document explains the difference between REST and SOAP, and this is really helpful too. When Fielding says, &quot;&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;That is RPC. It screams RPC.&lt;/a&gt;&quot;, it's clear that RPC is not RESTful, so it's useful to see the exact reasons for this. (SOAP is a type of RPC.)</source>
          <target state="translated">Этот документ xfront объясняет разницу между REST и SOAP, и это тоже очень полезно. Когда Филдинг говорит: &amp;laquo; &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Это RPC. Он кричит RPC&lt;/a&gt; &amp;raquo;, становится ясно, что RPC не RESTful, поэтому полезно выяснить точные причины этого. (SOAP - это тип RPC.)</target>
        </trans-unit>
        <trans-unit id="11640c3d32a9a0b61aeecdb5c9ad7a185581310a" translate="yes" xml:space="preserve">
          <source>The HATEOAS constraint is an acronym
  for Hypermedia as the Engine of
  Application State. This principle is
  the key differentiator between a REST
  and most other forms of client server
  system.</source>
          <target state="translated">Ограничение HATEOAS является аббревиатурой для Hypermedia как двигатель состояния приложения.Этот принцип является ключевым отличием REST от большинства других форм клиентских серверных систем.</target>
        </trans-unit>
        <trans-unit id="6a4c43170c5294cf2068284ddf81b0942eff7050" translate="yes" xml:space="preserve">
          <source>The PUT, GET, POST and DELETE methods are typical used in REST based architectures. The following table gives an explanation of these operations.</source>
          <target state="translated">Методы PUT,GET,POST и DELETE типичны для архитектур на основе REST.В следующей таблице приведено объяснение этих операций.</target>
        </trans-unit>
        <trans-unit id="debfff33bf7e7352ae30422dd3def567e5f7259f" translate="yes" xml:space="preserve">
          <source>The REST constraints are the following:</source>
          <target state="translated">Ограничения на REST являются следующими:</target>
        </trans-unit>
        <trans-unit id="363845c5633e5276f4ad26162098f583201cc8cf" translate="yes" xml:space="preserve">
          <source>The REST system is composed of hierarchical layers. Each layer contains components which use the services of components which are in the next layer below. So you can add new layers and components effortless.</source>
          <target state="translated">Система REST состоит из иерархических слоев.Каждый слой содержит компоненты,которые используют службы компонентов,которые находятся в следующем слое ниже.Таким образом,вы можете добавлять новые слои и компоненты без особых усилий.</target>
        </trans-unit>
        <trans-unit id="5aaa535e7837eae3a4f80e39cfc9d687c46ea8d0" translate="yes" xml:space="preserve">
          <source>The answer is very simple, there is a &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;dissertation&lt;/a&gt; written by Roy Fielding.]&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;1&lt;/a&gt; In that dissertation he defines the REST principles. If an application fulfills all of those principles, then that is a REST application.</source>
          <target state="translated">Ответ очень прост, есть &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;диссертация,&lt;/a&gt; написанная Роем Филдингом.] &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;1&lt;/a&gt; В этой диссертации он определяет принципы REST. Если приложение удовлетворяет всем этим принципам, то это приложение REST.</target>
        </trans-unit>
        <trans-unit id="4f20d992e77c2fef0f2a4c004149838f65239268" translate="yes" xml:space="preserve">
          <source>The contract between the client and the server is not maintained by the server. In other words the client must be decoupled from the implementation of the service. You can reach this state by using standard solutions, like the IRI (URI) standard to identify resources, the HTTP standard to exchange messages, standard MIME types to describe the body serialization format, metadata (possibly RDF vocabs, microformats, etc.) to describe the semantics of different parts of the message body. To decouple the IRI structure from the client, you have to send hyperlinks to the clients in hypermedia formats like (HTML, JSON-LD, HAL, etc.). So a client can use the metadata (possibly link relations, RDF vocabs) assigned to the hyperlinks to navigate the state machine of the application through the proper state transitions in order to achieve its current goal.</source>
          <target state="translated">Договор между клиентом и сервером не поддерживается сервером.Другими словами,клиент должен быть отделен от реализации услуги.Вы можете достичь этого состояния,используя стандартные решения,такие как стандарт IRI (URI)для идентификации ресурсов,стандарт HTTP для обмена сообщениями,стандартные MIME типы для описания формата сериализации тела,метаданные (возможно RDF словари,микроформаты и т.д.)для описания семантики различных частей тела сообщения.Чтобы отделить структуру IRI от клиента,необходимо отправить гиперссылки клиентам в гипермедийных форматах,таких как (HTML,JSON-LD,HAL и т.д.).Таким образом,клиент может использовать метаданные (возможно,связующие отношения,RDF словари),назначенные гиперссылкам,для навигации по государственной машине приложения через соответствующие переходы состояний,чтобы достичь своей текущей цели.</target>
        </trans-unit>
        <trans-unit id="5eac8561aeea8b795c8a15b197b4655d18a46b3e" translate="yes" xml:space="preserve">
          <source>The entire web is based on REST (or REST was based on the web). Therefore as a web developer you might want aware of that although it's not necessary to write good web apps.</source>
          <target state="translated">Вся сеть основана на REST (или REST была основана на сети).Поэтому,как веб-разработчик,вы,возможно,захотите знать об этом,хотя в написании хороших веб-приложений нет необходимости.</target>
        </trans-unit>
        <trans-unit id="c7820ce4adf25178f490423f73f586fe8480e441" translate="yes" xml:space="preserve">
          <source>The last one is probably the most important in terms of consequences and overall effectiveness of REST. Overall, most of the RESTful discussions seem to center on HTTP and its usage from a browser and what not. I understand that R. Fielding coined the term when he described the architecture and decisions that lead to HTTP. His thesis is more about the architecture and cache-ability of resources than it is about HTTP.</source>
          <target state="translated">Последнее,пожалуй,самое важное с точки зрения последствий и общей эффективности REST.В целом,большинство обсуждений REST,кажется,сосредоточено на HTTP и его использовании из браузера,а что нет.Я понимаю,что Р.Филдинг придумал этот термин,когда описал архитектуру и решения,которые приводят к HTTP.Его диссертация больше касается архитектуры и кэшируемости ресурсов,чем HTTP.</target>
        </trans-unit>
        <trans-unit id="b32979991407cd39a66f760547c127248522b7ba" translate="yes" xml:space="preserve">
          <source>The last thing that you&amp;rsquo;ll often here about RESTful architectures is that they are layered. We have actually already been implicitly discussing this requirement in our discussion of the interaction between the client and server. Basically, this means that each layer in our system interacts only with adjacent layers. So in our discussion, the client layer interacts with our server layer (and vice versa), but there might be other server layers that help the primary server process a request that the client does not directly communicate with. Rather, the server passes on the request as necessary.</source>
          <target state="translated">Последнее, что вы часто будете здесь о архитектурах RESTful, - это их многоуровневость. На самом деле мы уже неявно обсуждали это требование в нашем обсуждении взаимодействия между клиентом и сервером. По сути, это означает, что каждый слой в нашей системе взаимодействует только с соседними слоями. Таким образом, в нашем обсуждении уровень клиента взаимодействует с уровнем нашего сервера (и наоборот), но могут быть и другие уровни сервера, которые помогают основному серверу обрабатывать запрос, с которым клиент не связывается напрямую. Скорее, сервер передает запрос по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="3ad594a4eee6f4393aea9d6f9c591653f6d82996" translate="yes" xml:space="preserve">
          <source>The many much better answers on this very page.</source>
          <target state="translated">Гораздо лучшие ответы на этой самой странице.</target>
        </trans-unit>
        <trans-unit id="f34a56b5b9cc5fb499cc45ca49da52dec1ae7242" translate="yes" xml:space="preserve">
          <source>The most obvious requirement is that there needs to be a universal language of some sort so that the server can tell the client what it is trying to do with the request and for the server to respond.</source>
          <target state="translated">Самое очевидное требование заключается в том,что должен быть какой-то универсальный язык,чтобы сервер мог сказать клиенту,что он пытается сделать с запросом,и чтобы сервер ответил.</target>
        </trans-unit>
        <trans-unit id="c1949f81259fdfb5a99b7b1901beff7c9ea4dc3c" translate="yes" xml:space="preserve">
          <source>The point of rest is that if we agree to use a common language for basic operations (the http verbs), the infrastructure can be configured to understand them and optimize them properly, for example, by making use of caching headers to implement caching at all levels.</source>
          <target state="translated">Смысл остального в том,что если мы согласимся использовать общий язык для основных операций (глаголы http),то инфраструктуру можно настроить так,чтобы она понимала их и оптимизировала должным образом,например,используя заголовки кэширования для реализации кэширования на всех уровнях.</target>
        </trans-unit>
        <trans-unit id="adcd5a6756875181e58c7a89806bd16236c307a3" translate="yes" xml:space="preserve">
          <source>The server responds:</source>
          <target state="translated">Сервер отвечает:</target>
        </trans-unit>
        <trans-unit id="d84fe7aa11f8f900fefc9b179edc3003cd01912b" translate="yes" xml:space="preserve">
          <source>There is not such notion as &quot;RESTful programming&quot; per se. It would be better called RESTful paradigm or even better RESTful architecture. It is not a programming language. It is a paradigm.</source>
          <target state="translated">Нет такого понятия,как &quot;RESTful programming&quot; как такового.Лучше бы его назвали парадигмой RESTful или даже лучшей RESTful архитектурой.Это не язык программирования.Это парадигма.</target>
        </trans-unit>
        <trans-unit id="86c7098a4bc3a5c3742a2441c8884a81a07a366c" translate="yes" xml:space="preserve">
          <source>There's a fairly good example here:</source>
          <target state="translated">Здесь есть довольно хороший пример:</target>
        </trans-unit>
        <trans-unit id="905d4728fcc1cb89a5cb1a3e73d508f59109d989" translate="yes" xml:space="preserve">
          <source>Therefore, we impose the restriction that each request-response pair between the client and the server is independent, meaning that the server doesn&amp;rsquo;t have to remember anything about previous requests (previous states of the client-server interaction) to respond to a new request. This means that we want our interactions to be stateless.</source>
          <target state="translated">Поэтому мы налагаем ограничение на то, что каждая пара запрос-ответ между клиентом и сервером является независимой, что означает, что серверу не нужно ничего запоминать о предыдущих запросах (предыдущих состояниях взаимодействия клиент-сервер), чтобы ответить на новый запрос. Это означает, что мы хотим, чтобы наши взаимодействия не имели состояния.</target>
        </trans-unit>
        <trans-unit id="2a100f405ce7bcd9b4b68b83fcd25889ccf5143e" translate="yes" xml:space="preserve">
          <source>This constraint is optional. For example you can send a parser for a specific media type to the client, and so on... In order to do this you might need a standard plugin loader system in the client, or your client will be coupled to the plugin loader solution.</source>
          <target state="translated">Это ограничение необязательно.Например,вы можете отправить клиенту парсер для конкретного типа носителя и так далее....Для этого вам может понадобиться стандартная система загрузки плагинов в клиенте,или ваш клиент будет подключен к решению загрузчика плагинов.</target>
        </trans-unit>
        <trans-unit id="a433790865d58bd8f02ff1f47ffaf65f408a91fa" translate="yes" xml:space="preserve">
          <source>This is amazingly long &quot;discussion&quot; and yet quite confusing to say the least.</source>
          <target state="translated">Это удивительно длинная &quot;дискуссия&quot;,но,мягко говоря,довольно запутанная.</target>
        </trans-unit>
        <trans-unit id="03de43a18514c80205249c972ff6f45137f701c5" translate="yes" xml:space="preserve">
          <source>This is taken from the excellent book &lt;em&gt;Core JavaServer faces&lt;/em&gt; book by David M. Geary.</source>
          <target state="translated">Это взято из превосходной книги &lt;em&gt;Core JavaServer Faces&lt;/em&gt; книги Дэвида М. Гири.</target>
        </trans-unit>
        <trans-unit id="f84a19d4bf6f78ec8c5e5044a550ad4a25f94cc7" translate="yes" xml:space="preserve">
          <source>This is very less mentioned everywhere but the &lt;strong&gt;Richardson's Maturity Model&lt;/strong&gt; is one of the best methods to actually judge how Restful is one's API. More about it here:</source>
          <target state="translated">Это очень редко упоминается повсюду, но &lt;strong&gt;модель зрелости Ричардсона&lt;/strong&gt; - один из лучших методов, чтобы на самом деле судить, насколько Restful является API. Подробнее об этом здесь:</target>
        </trans-unit>
        <trans-unit id="d0c1d3305c31f371cda13faed5816c6263e72163" translate="yes" xml:space="preserve">
          <source>This is what it might look like.</source>
          <target state="translated">Вот как это может выглядеть.</target>
        </trans-unit>
        <trans-unit id="d9c095fa6595fd926bd9860ca44ab7d426923a2d" translate="yes" xml:space="preserve">
          <source>To be RESTful a Service needs to fulfill the &lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot;&gt;Hypermedia as the Engine of Application State. (HATEOAS)&lt;/a&gt;, that is, it needs to reach level 3 in the RMM, &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;read the article&lt;/a&gt; for details or the &lt;a href=&quot;http://www.crummy.com/writing/speaking/2008-QCon/act3.html&quot;&gt;slides from the qcon talk&lt;/a&gt;.</source>
          <target state="translated">Чтобы быть RESTful, Служба должна удовлетворять требованиям &lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot;&gt;Гипермедиа как Механизма Состояния Приложения.&lt;/a&gt; (HATEOAS) , то есть он должен достичь уровня 3 в RMM, &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;читайте статью&lt;/a&gt; для подробностей или &lt;a href=&quot;http://www.crummy.com/writing/speaking/2008-QCon/act3.html&quot;&gt;слайды из выступления qcon&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43e0b98e4c9a963450bac2bcfe7ffa0f28070108" translate="yes" xml:space="preserve">
          <source>To be a restful programmer you must be trying to build applications that allow actors to do things.  Not just exposing the database.</source>
          <target state="translated">Чтобы быть спокойным программистом,вы должны пытаться собирать приложения,которые позволяют актерам делать вещи.А не просто разоблачать базу данных.</target>
        </trans-unit>
        <trans-unit id="88f5ecedd3cc21540bbf662f89334d1c596c1065" translate="yes" xml:space="preserve">
          <source>To further ease the strain on our server from redoing computations that have already been recently done for a given client, REST also allows caching. Basically, caching means to take a snapshot of the initial response provided to the client. If the client makes the same request again, the server can provide the client with the snapshot rather than redo all of the computations that were necessary to create the initial response. However, since it is a snapshot, if the snapshot has not expired--the server sets an expiration time in advance--and the response has been updated since the initial cache (i.e. the request would give a different answer than the cached response), the client will not see the updates until the cache expires (or the cache is cleared) and the response is rendered from scratch again.</source>
          <target state="translated">Чтобы еще больше облегчить нагрузку на наш сервер от повторных вычислений,которые уже были сделаны недавно для данного клиента,REST также позволяет кэшировать.В основном,кэширование означает получение моментального снимка первоначального ответа,предоставленного клиенту.Если клиент делает тот же самый запрос снова,сервер может предоставить клиенту снимок,а не повторять все вычисления,которые были необходимы для создания первоначального ответа.Однако,поскольку это снимок,если срок действия снимка не истек-сервер заранее устанавливает срок действия-и ответ был обновлен,так как исходный кэш (т.е.запрос даст другой ответ,чем кэшированный ответ),клиент не увидит обновлений до тех пор,пока кэш не истечет (или кэш не будет очищен)и ответ не будет выдан с нуля снова.</target>
        </trans-unit>
        <trans-unit id="3cda008b284e93ee83d27ce556b7f274c5401681" translate="yes" xml:space="preserve">
          <source>To modify the record (&lt;code&gt;lname&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; will remain unchanged):</source>
          <target state="translated">Чтобы изменить запись ( &lt;code&gt;lname&lt;/code&gt; и &lt;code&gt;age&lt;/code&gt; останутся без изменений):</target>
        </trans-unit>
        <trans-unit id="2d8872fdf4d794b725b02d84014a91227ec2afee" translate="yes" xml:space="preserve">
          <source>To update the record (and consequently &lt;code&gt;lname&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; will be NULL):</source>
          <target state="translated">Чтобы обновить запись (и, следовательно, &lt;code&gt;lname&lt;/code&gt; и &lt;code&gt;age&lt;/code&gt; будут NULL):</target>
        </trans-unit>
        <trans-unit id="749827b57c3b48ad912ed3c35f6d888c6b320fd8" translate="yes" xml:space="preserve">
          <source>To use API manually, we can use browser based REST API plugins.</source>
          <target state="translated">Для использования API вручную,мы можем использовать браузерные REST API плагины.</target>
        </trans-unit>
        <trans-unit id="cd51d0a7c8a456561603688f8e9d8841d8aeb252" translate="yes" xml:space="preserve">
          <source>Uniform interface</source>
          <target state="translated">Единый интерфейс</target>
        </trans-unit>
        <trans-unit id="36445d1f62b3461271018e22e6c63b0da668d74c" translate="yes" xml:space="preserve">
          <source>We also know that we can change existing data:</source>
          <target state="translated">Мы также знаем,что можем изменить существующие данные:</target>
        </trans-unit>
        <trans-unit id="2da0745a731ffea22c1d0cd224d20dec310fb399" translate="yes" xml:space="preserve">
          <source>We can tell a lot from this response. For instance, we now know we can create a new user by &lt;code&gt;POST&lt;/code&gt;ing to &lt;code&gt;/user&lt;/code&gt;:</source>
          <target state="translated">Мы можем многое сказать из этого ответа. Например, теперь мы знаем, что можем создать нового пользователя, &lt;code&gt;POST&lt;/code&gt; сообщение в &lt;code&gt;/user&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5441c7839fa6d73dff04b1a5f493f5e5d31a22e7" translate="yes" xml:space="preserve">
          <source>We know from the description of our media that we can find information about related resources from sections called &quot;links&quot;. This is called &lt;em&gt;Hypermedia controls&lt;/em&gt;. In this case, we can tell from such a section that we can find a user list by making another request for &lt;code&gt;/user&lt;/code&gt;:</source>
          <target state="translated">Из описания наших средств массовой информации мы знаем, что мы можем найти информацию о связанных ресурсах в разделах, называемых &amp;laquo;ссылками&amp;raquo;. Это называется &lt;em&gt;гипермедиа управления&lt;/em&gt; . В этом случае мы можем сказать из такого раздела, что мы можем найти список пользователей, сделав еще один запрос для &lt;code&gt;/user&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dbe152bcc052ff53fb476d5537d8e4e55bdd8dee" translate="yes" xml:space="preserve">
          <source>What exactly is RESTful programming</source>
          <target state="translated">Что именно такое RESTful программирование</target>
        </trans-unit>
        <trans-unit id="600b595c92145112ec54443d94bd4487770f5001" translate="yes" xml:space="preserve">
          <source>What exactly is RESTful programming?</source>
          <target state="translated">Что такое RESTful программирование?</target>
        </trans-unit>
        <trans-unit id="de97001a3f45e1ab272ba3e7e1ff70234ac18284" translate="yes" xml:space="preserve">
          <source>What is REST?</source>
          <target state="translated">Что такое REST?</target>
        </trans-unit>
        <trans-unit id="eda640f0d9d8732bb4f5934942e07911d12c78f5" translate="yes" xml:space="preserve">
          <source>When it comes to web services, it seems that we need some way of distinguishing WSDL and SOAP based architectures which add considerable overhead and arguably much unnecessary complexity to the interface. They also require additional frameworks and developer tools in order to implement. I'm not sure if REST is the best term to distinguish between common-sense interfaces and overly engineered interfaces such as WSDL and SOAP. But we need something.</source>
          <target state="translated">Когда речь заходит о веб-сервисах,кажется,что нам нужен какой-то способ различать архитектуры на основе WSDL и SOAP,которые добавляют значительные накладные расходы и,возможно,много ненужной сложности интерфейсу.Для их реализации также требуются дополнительные фреймворки и инструменты разработчика.Я не уверен,что REST-это лучший термин для разграничения интерфейсов,основанных на здравых смыслах,и чрезмерно разработанных интерфейсов,таких как WSDL и SOAP.Но нам что-то нужно.</target>
        </trans-unit>
        <trans-unit id="a973bdebdbe9ce0f6dcc094fe7f29c9ec500ddfd" translate="yes" xml:space="preserve">
          <source>With a properly implemented restful GET operation, it shouldn't matter if the information comes from your server's DB, your server's memcache, a CDN, a proxy's cache, your browser's cache or your browser's local storage. The fasted, most readily available up to date source can be used.</source>
          <target state="translated">При правильно реализованной перезагрузке GET не имеет значения,поступает ли информация из БД вашего сервера,из memcache вашего сервера,CDN,кэша прокси-сервера,кэша вашего браузера или из локального хранилища вашего браузера.Можно использовать быстрый,наиболее доступный и современный источник.</target>
        </trans-unit>
        <trans-unit id="9516144747f958d35f414712742a6a2ce6a57b18" translate="yes" xml:space="preserve">
          <source>With restful style, you get and manipulate the state of the application across an unreliable internet. If it fails the current operation to get the correct and current state, it needs the zero-validation principal to help the application to continue. If it fails to manipulate the state, it usually uses multiple stages of confirmation to keep things correct. In this sense, rest is not itself a whole solution, it needs the functions in other part of the web application stack to support its working.</source>
          <target state="translated">При спокойном стиле вы получаете и манипулируете состоянием приложения через ненадежный интернет.Если он не удается текущей операции,чтобы получить правильное и текущее состояние,он нуждается в нулевой проверки принципа,чтобы помочь приложению,чтобы продолжить.Если он не может манипулировать состоянием,он обычно использует несколько этапов подтверждения,чтобы сохранить все правильно.В этом смысле отдых сам по себе не является целым решением,ему нужны функции в другой части стека веб-приложений для поддержки его работы.</target>
        </trans-unit>
        <trans-unit id="9be308c8cf75a9d22350774cf74e2e3a25a8019f" translate="yes" xml:space="preserve">
          <source>You can imagine such an endpoint as being the connecting pipeline from the website (front-end) to your database/server (back-end). Using them, the front-end can perform back-end operations which are defined in the corresponding methods of any REST mapping in your application.</source>
          <target state="translated">Вы можете представить себе такую конечную точку,как соединительный трубопровод от веб-сайта (front-end)до вашего сервера баз данных (back-end).Используя их,front-end может выполнять back-end операции,которые определяются соответствующими методами любого REST отображения в вашем приложении.</target>
        </trans-unit>
        <trans-unit id="908a7dfd19709fb34c01bfe487f5ebb9c2ca9cf8" translate="yes" xml:space="preserve">
          <source>You can summarize(significantly) the constraints to :</source>
          <target state="translated">Вы можете суммировать (значительно)ограничения к :</target>
        </trans-unit>
        <trans-unit id="feb921fa13db1c181a291f33573dbc491b591ad9" translate="yes" xml:space="preserve">
          <source>You use the HTTP &quot;verbs&quot; and have..</source>
          <target state="translated">Вы используете HTTP &quot;глаголы&quot; и имеете...</target>
        </trans-unit>
        <trans-unit id="3aed90f826f40c49f9ad0c3f63e16bed6d13bf70" translate="yes" xml:space="preserve">
          <source>[Failure here implies that out-of-band information is driving interaction instead of hypertext.]</source>
          <target state="translated">[Неудача здесь подразумевает,что внеполосная информация ведет к взаимодействию,а не гипертексту.]</target>
        </trans-unit>
        <trans-unit id="8e00d08a441958c5870f45fa22543b3d6a03678e" translate="yes" xml:space="preserve">
          <source>build a layered system to increase scalability</source>
          <target state="translated">построить многоуровневую систему для увеличения масштабируемости</target>
        </trans-unit>
        <trans-unit id="59c8c8c5991afe8d0a6e42545c71d93e3bff395d" translate="yes" xml:space="preserve">
          <source>but the REST architecture does not require these &quot;pretty URLs&quot;. A GET request with a parameter</source>
          <target state="translated">но архитектура REST не требует этих &quot;красивых URL&quot;.GET-запрос с параметром</target>
        </trans-unit>
        <trans-unit id="9f5d22e3a30a84cbccefeb4bd8e5dd35213aaaef" translate="yes" xml:space="preserve">
          <source>clearly communicates the content formats transmitted</source>
          <target state="translated">чётко передаёт передаваемые форматы контента</target>
        </trans-unit>
        <trans-unit id="aa2c820849be6fbcb2031a6127c1665b0464c324" translate="yes" xml:space="preserve">
          <source>client-server architecture</source>
          <target state="translated">клиент-серверная архитектура</target>
        </trans-unit>
        <trans-unit id="8de0a9bc31c843fae99c5bff4c8a379f92283e8b" translate="yes" xml:space="preserve">
          <source>code on demand to extend client functionality</source>
          <target state="translated">код по запросу для расширения функциональности клиента</target>
        </trans-unit>
        <trans-unit id="b275617b42e241876e72514b35301555695e7037" translate="yes" xml:space="preserve">
          <source>is every bit as RESTful.</source>
          <target state="translated">это все так же отдохнуло.</target>
        </trans-unit>
        <trans-unit id="0d4997d446840ee0c979e316123915b0a24c6d51" translate="yes" xml:space="preserve">
          <source>maintaining the state in the object and representing the state in the representation</source>
          <target state="translated">сохранение состояния в объекте и представление состояния в представлении</target>
        </trans-unit>
        <trans-unit id="979f4334840cfaebedb96eacee97565f5bf001e6" translate="yes" xml:space="preserve">
          <source>representing the relationships between resources in the representation of the resource: the links between objects are embedded directly in the representation</source>
          <target state="translated">представление отношений между ресурсами в представлении ресурса:связи между объектами встраиваются непосредственно в представление</target>
        </trans-unit>
        <trans-unit id="5e48ef6a8e54320faa23115ae33b087ac321ebec" translate="yes" xml:space="preserve">
          <source>resource representations describe how the representation can be used and under what circumstances it should be discarded/refetched in a consistent manner: usage of HTTP Cache-Control headers</source>
          <target state="translated">представления ресурсов описывают,как представление может быть использовано и при каких обстоятельствах оно должно быть отброшено последовательным образом:использование заголовков HTTP Cache-Control</target>
        </trans-unit>
        <trans-unit id="e33527bfb73b976a097d9714161c7a07da95577a" translate="yes" xml:space="preserve">
          <source>resources being identified by a persistent identifier: URIs are the ubiquitous choice of identifier these days</source>
          <target state="translated">ресурсы идентифицируются по постоянному идентификатору:URL-адреса являются в наши дни повсеместным выбором идентификатора.</target>
        </trans-unit>
        <trans-unit id="a51e6d20a959c6055335a93c972efc9d39c00a75" translate="yes" xml:space="preserve">
          <source>resources being manipulated using a common set of verbs: HTTP methods are the commonly seen case - the venerable &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Retrieve&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt; becomes &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. But REST is not limited to HTTP, it is just the most commonly used transport right now.</source>
          <target state="translated">управление ресурсами осуществляется с помощью общего набора глаголов: наиболее часто встречающийся метод HTTP - почтенные &lt;code&gt;Create&lt;/code&gt; , &lt;code&gt;Retrieve&lt;/code&gt; , &lt;code&gt;Update&lt;/code&gt; , &lt;code&gt;Delete&lt;/code&gt; становятся &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; и &lt;code&gt;DELETE&lt;/code&gt; . Но REST не ограничивается HTTP, это просто наиболее часто используемый транспорт на данный момент.</target>
        </trans-unit>
        <trans-unit id="98b5c511b1e5b3b77e9275fb4452cc5fef44489b" translate="yes" xml:space="preserve">
          <source>respect HTTP specs (if HTTP is used)</source>
          <target state="translated">уважать спецификации HTTP (если используется HTTP)</target>
        </trans-unit>
        <trans-unit id="c4931fde74816a610a063dd06bd59538b02802b8" translate="yes" xml:space="preserve">
          <source>stateless communication</source>
          <target state="translated">связь без гражданства</target>
        </trans-unit>
        <trans-unit id="3b878062f43e3c640f44bd52081d0d0dc4278065" translate="yes" xml:space="preserve">
          <source>the actual representation retrieved for a resource is dependent on the request and not the identifier: use Accept headers to control whether you want XML, HTTP, or even a Java Object representing the resource</source>
          <target state="translated">фактическое представление,полученное для ресурса,зависит от запроса,а не от идентификатора:используйте заголовки Accept,чтобы контролировать,хотите ли вы XML,HTTP или даже Java-объект,представляющий ресурс.</target>
        </trans-unit>
        <trans-unit id="1462755612fc240043fdb2325bffe48c8d0f3f08" translate="yes" xml:space="preserve">
          <source>uniform interface as common contract between client and server</source>
          <target state="translated">единый интерфейс в качестве общего договора между клиентом и сервером</target>
        </trans-unit>
        <trans-unit id="3766fe2c2822ed2ec2c43384fd93c708aa87dded" translate="yes" xml:space="preserve">
          <source>usage of cache if you can</source>
          <target state="translated">использование кэша,если можно</target>
        </trans-unit>
        <trans-unit id="f96087a197542f55a4ef257f73c9f1cfd69fffd2" translate="yes" xml:space="preserve">
          <source>use hypermedia as the engine of application state</source>
          <target state="translated">использовать гипермедиа в качестве двигателя состояния приложения</target>
        </trans-unit>
        <trans-unit id="2626c215ef69fa721ddf1168a1db9e9f9a723d4c" translate="yes" xml:space="preserve">
          <source>would not be appropriate. GET requests should be &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Idempotence&quot;&gt;idempotent&lt;/a&gt;. That is, issuing a request twice should be no different from issuing it once. That's what makes the requests cacheable. An &quot;add to cart&quot; request is not idempotent&amp;mdash;issuing it twice adds two copies of the item to the cart. A POST request is clearly appropriate in this context. Thus, even a &lt;strong&gt;RESTful web application&lt;/strong&gt; needs its share of POST requests.</source>
          <target state="translated">не будет уместным. GET-запросы должны быть &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Idempotence&quot;&gt;идемпотентными&lt;/a&gt; . То есть выдача запроса дважды не должна отличаться от его выдачи один раз. Вот что делает запросы кешируемыми. Запрос &amp;laquo;добавить в корзину&amp;raquo; не идемпотентен - при его повторном добавлении в корзину добавляется две копии элемента. Запрос POST явно уместен в этом контексте. Таким образом, даже &lt;strong&gt;веб-приложению RESTful&lt;/strong&gt; нужна доля запросов POST.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
