<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/671118">
    <body>
      <group id="671118">
        <trans-unit id="4b5f371d067d57adebce0c867d054ff2d3400ab5" translate="yes" xml:space="preserve">
          <source>(This answer has been the subject of a fair amount of criticism for missing the point. For the most part, that has been a fair critique. What I originally described was more in line with how REST was usually implemented a few years ago when I first wrote this, rather than its true meaning. I've revised the answer to better represent the real meaning.)</source>
          <target state="translated">(Esta respuesta ha sido objeto de una gran cantidad de críticas por no entender el punto.En su mayor parte,ha sido una crítica justa.Lo que describí originalmente estaba más en línea con la forma en que REST se implementó normalmente hace unos años cuando escribí esto por primera vez,en lugar de su verdadero significado.He revisado la respuesta para representar mejor el verdadero significado).</target>
        </trans-unit>
        <trans-unit id="d38acde6c0a007c814e7a8e62db3e40f8b9a8c5d" translate="yes" xml:space="preserve">
          <source>1) There is no such a thing as restful programing, without a big joint and lots of beer :)</source>
          <target state="translated">1)No hay tal cosa como la programación de descanso,sin un gran porro y mucha cerveza :)</target>
        </trans-unit>
        <trans-unit id="16ed7b2a6cdbe5d413738c42d0ff5485bb59700c" translate="yes" xml:space="preserve">
          <source>2) &lt;strong&gt;Representational State Transfer (REST) is an architectural style specified in &lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;the dissertation of Roy Fielding&lt;/a&gt;.
It has a number of constraints.  If your Service/Client respect those then it is RESTful.&lt;/strong&gt; This is it.</source>
          <target state="translated">2) &lt;strong&gt;La transferencia de estado representacional (REST) ​​es un estilo arquitect&amp;oacute;nico especificado en &lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;la disertaci&amp;oacute;n de Roy Fielding&lt;/a&gt; .&lt;/strong&gt; &lt;strong&gt;Tiene una serie de restricciones.&lt;/strong&gt; &lt;strong&gt;Si su Servicio / Cliente los respeta, entonces es RESTful.&lt;/strong&gt; Eso es todo.</target>
        </trans-unit>
        <trans-unit id="27e5dbfce4b7ee29196f5fd4dafe3ca1c0624c58" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;Unique global identifier&lt;/a&gt; (all resources are unique identified by &lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;Identificador global &amp;uacute;nico&lt;/a&gt; (todos los recursos son identificados de forma &amp;uacute;nica por &lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1fd9999d07a7fc62861689de4b2bdf6a8fc86768" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;RESTful&lt;/a&gt; (Representational state transfer) API programming is writing web applications in any programming language by following 5 basic software &lt;a href=&quot;http://en.wikipedia.org/wiki/Architectural_style&quot;&gt;architectural style&lt;/a&gt; principles:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;La&lt;/a&gt; programaci&amp;oacute;n API RESTful (transferencia de estado representativa) est&amp;aacute; escribiendo aplicaciones web en cualquier lenguaje de programaci&amp;oacute;n siguiendo 5 principios b&amp;aacute;sicos de &lt;a href=&quot;http://en.wikipedia.org/wiki/Architectural_style&quot;&gt;estilo arquitect&amp;oacute;nico de&lt;/a&gt; software:</target>
        </trans-unit>
        <trans-unit id="68ce364743640c5c8da066039ef67fefbcdfea99" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface&quot;&gt;Uniform interface&lt;/a&gt; - use simple and standard interface (HTTP).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface&quot;&gt;Interfaz uniforme&lt;/a&gt; : use una interfaz simple y est&amp;aacute;ndar (HTTP).</target>
        </trans-unit>
        <trans-unit id="fc1b3e08e8f98d28090f1f9117f6298bc58e4d4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Stateless_protocol&quot;&gt;Stateless&lt;/a&gt; (every request happens in complete isolation, it's easier to cache and load-balance),</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Stateless_protocol&quot;&gt;Sin estado&lt;/a&gt; (cada solicitud se realiza de forma completamente aislada, es m&amp;aacute;s f&amp;aacute;cil almacenar en cach&amp;eacute; y equilibrar la carga),</target>
        </trans-unit>
        <trans-unit id="129cb3c37d52f357725b109610381bd678a81b64" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://herbjorn.wordpress.com/2010/11/19/rest-versus-soap-for-the-public-cloud/&quot;&gt;REST versus SOAP for the Public Cloud&lt;/a&gt; discusses the current levels of REST usage.</source>
          <target state="translated">&lt;a href=&quot;http://herbjorn.wordpress.com/2010/11/19/rest-versus-soap-for-the-public-cloud/&quot;&gt;REST versus SOAP para la nube p&amp;uacute;blica&lt;/a&gt; discute los niveles actuales de uso de REST.</target>
        </trans-unit>
        <trans-unit id="01d4ccbe57dba207b3756864c380f7e8c5cec68f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://kinderman.net/2010/06/23/approaching-pure-rest-learning-to-love-hateoas&quot;&gt;Approaching pure REST: Learning to love HATEOAS&lt;/a&gt; is a good collection of links.</source>
          <target state="translated">&lt;a href=&quot;http://kinderman.net/2010/06/23/approaching-pure-rest-learning-to-love-hateoas&quot;&gt;Acercarse al DESCANSO puro: aprender a amar HATEOAS&lt;/a&gt; es una buena colecci&amp;oacute;n de enlaces.</target>
        </trans-unit>
        <trans-unit id="71c672309538bece163ea3ed6fdde78bae549263" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;The term RESTful was created because ppl exhausted the word REST by calling their non-REST application as REST.&lt;/a&gt; After that the term RESTful was exhausted as well. &lt;a href=&quot;http://www.markus-lanthaler.com/research/third-generation-web-apis-bridging-the-gap-between-rest-and-linked-data.pdf&quot;&gt;Nowadays we are talking about Web APIs and Hypermedia APIs&lt;/a&gt;, because the most of the so called REST applications did not fulfill the HATEOAS part of the uniform interface constraint.</source>
          <target state="translated">&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;El t&amp;eacute;rmino RESTful se cre&amp;oacute; porque ppl agot&amp;oacute; la palabra REST llamando a su aplicaci&amp;oacute;n no REST como REST.&lt;/a&gt; Despu&amp;eacute;s de eso, el t&amp;eacute;rmino RESTful tambi&amp;eacute;n se agot&amp;oacute;. &lt;a href=&quot;http://www.markus-lanthaler.com/research/third-generation-web-apis-bridging-the-gap-between-rest-and-linked-data.pdf&quot;&gt;Hoy en d&amp;iacute;a estamos hablando de API web y API de hipermedia&lt;/a&gt; , porque la mayor&amp;iacute;a de las llamadas aplicaciones REST no cumpl&amp;iacute;an con la parte HATEOAS de la restricci&amp;oacute;n de interfaz uniforme.</target>
        </trans-unit>
        <trans-unit id="ee92cfd1a1d0fac1b4085c977902cee08a3f0004" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife&quot;&gt;How I explained REST to my wife&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife&quot;&gt;C&amp;oacute;mo le expliqu&amp;eacute; RESTO a mi esposa&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd6a95880b9724e9be2ebb234578d30f5200563" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.innoq.com/blog/st/2010/07/rest_litmus_test_for_web_frame.html&quot;&gt;REST Litmus Test for Web Frameworks&lt;/a&gt; is a similar maturity test for web frameworks.</source>
          <target state="translated">&lt;a href=&quot;http://www.innoq.com/blog/st/2010/07/rest_litmus_test_for_web_frame.html&quot;&gt;REST Litmus Test para Web Frameworks&lt;/a&gt; es una prueba de madurez similar para frameworks web.</target>
        </trans-unit>
        <trans-unit id="b82de9194c2626af47b20dbf29253c8eab541c11" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.xfront.com/REST.ppt&quot;&gt;http://www.xfront.com/REST.ppt&lt;/a&gt; or &lt;a href=&quot;http://www.xfront.com/REST.html&quot;&gt;http://www.xfront.com/REST.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.xfront.com/REST.ppt&quot;&gt;http://www.xfront.com/REST.ppt&lt;/a&gt; o &lt;a href=&quot;http://www.xfront.com/REST.html&quot;&gt;http://www.xfront.com/REST.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="581df4eb5c8f47005fba4eaff2c31e62dc854f5b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.google.com/present/view?id=dd4bk538_182f55p5x3f&amp;amp;ndplr=1&quot;&gt;REST and versioning&lt;/a&gt; discusses Extensibility, Versioning, Evolvability, etc.
 through Modifiability</source>
          <target state="translated">&lt;a href=&quot;https://docs.google.com/present/view?id=dd4bk538_182f55p5x3f&amp;amp;ndplr=1&quot;&gt;REST y el control de versiones&lt;/a&gt; analiza la extensibilidad, el control de versiones, la capacidad de evoluci&amp;oacute;n, etc. a trav&amp;eacute;s de la modificabilidad</target>
        </trans-unit>
        <trans-unit id="38b751418200783443a4e1aa6fb491b6a5b8367d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;From Wikipedia&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;De Wikipedia&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b092bbc5dae2d2facc4cdcbac80f4fca0862b1a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;REST&lt;/em&gt; is the underlying architectural principle of the web. The amazing thing about the web is the fact that clients (browsers) and servers can interact in complex ways without the client knowing anything beforehand about the server and the resources it hosts. The key constraint is that the server and client must both agree on the &lt;em&gt;media&lt;/em&gt; used, which in the case of the web is &lt;em&gt;HTML&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;REST&lt;/em&gt; es el principio arquitect&amp;oacute;nico subyacente de la web. Lo sorprendente de la web es el hecho de que los clientes (navegadores) y los servidores pueden interactuar de manera compleja sin que el cliente sepa de antemano nada sobre el servidor y los recursos que alberga. La restricci&amp;oacute;n clave es que tanto el servidor como el cliente deben acordar los &lt;em&gt;medios&lt;/em&gt; utilizados, que en el caso de la web es &lt;em&gt;HTML&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="75836654a91c2003a610250aa33fea51aed04694" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Talking&lt;/em&gt; is more than simply &lt;em&gt;exchanging information&lt;/em&gt;. A Protocol is actually designed so that no talking has to occur. Each party knows what their particular job is because it is specified in the protocol. Protocols allow for pure information exchange at the expense of having any changes in the possible actions. Talking, on the other hand, allows for one party to ask what further actions can be taken from the other party. They can even ask the same question twice and get two different answers, since the State of the other party may have changed in the interim. &lt;strong&gt;Talking is RESTful architecture&lt;/strong&gt;. Fielding's thesis specifies the architecture that one would have to follow if one wanted to allow machines to &lt;em&gt;talk&lt;/em&gt; to one another rather than simply &lt;em&gt;communicate&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Hablar&lt;/em&gt; es m&amp;aacute;s que simplemente &lt;em&gt;intercambiar informaci&amp;oacute;n&lt;/em&gt; . En realidad, un protocolo est&amp;aacute; dise&amp;ntilde;ado para que no haya que hablar. Cada parte sabe cu&amp;aacute;l es su trabajo particular porque est&amp;aacute; especificado en el protocolo. Los protocolos permiten el intercambio de informaci&amp;oacute;n pura a expensas de tener cambios en las posibles acciones. Hablar, por otro lado, permite que una de las partes pregunte qu&amp;eacute; acciones adicionales se pueden tomar de la otra parte. Incluso pueden hacer la misma pregunta dos veces y obtener dos respuestas diferentes, ya que el estado de la otra parte puede haber cambiado en el &amp;iacute;nterin. &lt;strong&gt;Hablar es una arquitectura RESTful&lt;/strong&gt; . La tesis de Fielding especifica la arquitectura que habr&amp;iacute;a que seguir si quisiera permitir que las m&amp;aacute;quinas se &lt;em&gt;comuniquen&lt;/em&gt; entre s&amp;iacute; en lugar de simplemente &lt;em&gt;comunicarse&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="047b453da1539c81d5d318bedbdeb493589d50ab" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;a href=&quot;http://www.looah.com/source/view/2284&quot;&gt;How I explained REST to my wife&lt;/a&gt;.&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;&lt;a href=&quot;http://www.looah.com/source/view/2284&quot;&gt;C&amp;oacute;mo le expliqu&amp;eacute; RESTO a mi esposa&lt;/a&gt; .&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="a5cbf477e28c39bdfd209ebf60137a160a48aa33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4 Commonly Used API Methods:-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4 m&amp;eacute;todos API com&amp;uacute;nmente utilizados: -&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a292b42aebab7e4f8f0a4cef5109e82538c81c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTTP methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todos HTTP:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c887aa651a0b1255f5b4be4a6d0d7111e108eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Idempotence&lt;/strong&gt;: &lt;a href=&quot;http://programmers.stackexchange.com/questions/23386/pros-and-cons-of-restful-architecture&quot;&gt;An often-overlooked part of REST is the idempotency of most verbs. That leads to &lt;strong&gt;robust systems and less interdependency&lt;/strong&gt; of exact interpretations of the semantics&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Idempotencia&lt;/strong&gt; : &lt;a href=&quot;http://programmers.stackexchange.com/questions/23386/pros-and-cons-of-restful-architecture&quot;&gt;una parte a menudo pasada por alto de REST es la idempotencia de la mayor&amp;iacute;a de los verbos.&lt;/a&gt; Eso lleva a &lt;strong&gt;sistemas robustos y menos interdependencia&lt;/strong&gt; de interpretaciones exactas de la sem&amp;aacute;ntica .</target>
        </trans-unit>
        <trans-unit id="e19e144b463c1477631bed87f6cf59ac2feabcb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST API&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;API REST&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4016ad50e00a712f9fc46d47dae34627a47b0c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST&lt;/strong&gt; is an architectural style which is based on web-standards and the HTTP protocol (introduced in 2000).</source>
          <target state="translated">&lt;strong&gt;REST&lt;/strong&gt; es un estilo arquitect&amp;oacute;nico que se basa en est&amp;aacute;ndares web y el protocolo HTTP (introducido en 2000).</target>
        </trans-unit>
        <trans-unit id="f470c92afeb4f87674886ef73e25bccf93d40bda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST&lt;/strong&gt; stands for &lt;strong&gt;Representational state transfer&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;REST&lt;/strong&gt; significa &lt;strong&gt;transferencia de estado representativa&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c34758fefce5857b0652a67c95f80db96a7e9ace" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Request&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Request&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8301b7897b69c57632cd67112cbd903a929c2bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Response&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Response&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9026e434b313962901c5fd34080061d3114f6c95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, how does this apply to &lt;em&gt;HTTP&lt;/em&gt;, and how can it be implemented in practice?&lt;/strong&gt; HTTP is oriented around verbs and resources. The two verbs in mainstream usage are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;, which I think everyone will recognize. However, the HTTP standard defines several others such as &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt;. These verbs are then applied to resources, according to the instructions provided by the server.</source>
          <target state="translated">&lt;strong&gt;Entonces, &amp;iquest;c&amp;oacute;mo se aplica esto a &lt;em&gt;HTTP&lt;/em&gt; y c&amp;oacute;mo se puede implementar en la pr&amp;aacute;ctica?&lt;/strong&gt; HTTP est&amp;aacute; orientado a verbos y recursos. Los dos verbos en el uso principal son &lt;code&gt;GET&lt;/code&gt; y &lt;code&gt;POST&lt;/code&gt; , que creo que todos reconocer&amp;aacute;n. Sin embargo, el est&amp;aacute;ndar HTTP define varios otros, como &lt;code&gt;PUT&lt;/code&gt; y &lt;code&gt;DELETE&lt;/code&gt; . Estos verbos se aplican a los recursos, de acuerdo con las instrucciones proporcionadas por el servidor.</target>
        </trans-unit>
        <trans-unit id="63a42af1bd9b39bddf0ce1be8356d0a2fdb888e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Statelessness&lt;/strong&gt; is misleading. It is about the restful API, not the application or system. The system needs to be stateful. Restful design is about designing a stateful system based on a stateless API. Some &lt;a href=&quot;http://programmers.stackexchange.com/questions/120716/difference-between-rest-and-crud&quot;&gt;quotes from another QA&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;La apatridia&lt;/strong&gt; es enga&amp;ntilde;osa. Se trata de la API tranquila, no de la aplicaci&amp;oacute;n o el sistema. El sistema necesita ser con estado. El dise&amp;ntilde;o reparador consiste en dise&amp;ntilde;ar un sistema con estado basado en una API sin estado. Algunas &lt;a href=&quot;http://programmers.stackexchange.com/questions/120716/difference-between-rest-and-crud&quot;&gt;citas de otro control de calidad&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4c1222e90317ba27d02c65621a259eda932152bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Steps to Test API Manually:-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pasos para probar la API manualmente: -&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a168c28310824470d0a6b65e2fc1846ae47767c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is another &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;very good post&lt;/a&gt; which explains things nicely.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hay otra &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;publicaci&amp;oacute;n muy buena&lt;/a&gt; que explica muy bien las cosas.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f23059a3c1ff462600affe32ac77f6c06e198cd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is &lt;a href=&quot;http://testingalert.com/api-testing/api-manual/&quot;&gt;API Testing&lt;/a&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Qu&amp;eacute; son &lt;a href=&quot;http://testingalert.com/api-testing/api-manual/&quot;&gt;las pruebas de API&lt;/a&gt; ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bdfd2ece2c06305906caea45c528dd7bf39e1081" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is REST?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Qu&amp;eacute; es REST?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34c0a9562e8fed523993c8b4e5719d3ee3daa073" translate="yes" xml:space="preserve">
          <source>A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user&amp;rsquo;s manipulation of those representations. The transitions may be determined (or limited by) the client&amp;rsquo;s knowledge of media types and resource communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand).</source>
          <target state="translated">Se debe ingresar una API REST sin conocimiento previo m&amp;aacute;s all&amp;aacute; del URI inicial (marcador) y un conjunto de tipos de medios estandarizados que sean apropiados para la audiencia prevista (es decir, se espera que cualquier cliente que pueda usar la API entienda). A partir de ese momento, todas las transiciones de estado de la aplicaci&amp;oacute;n deben ser conducidas por la selecci&amp;oacute;n del cliente de opciones proporcionadas por el servidor que est&amp;eacute;n presentes en las representaciones recibidas o impl&amp;iacute;citas por la manipulaci&amp;oacute;n del usuario de esas representaciones. Las transiciones pueden estar determinadas (o limitadas por) el conocimiento del cliente sobre los tipos de medios y los mecanismos de comunicaci&amp;oacute;n de recursos, los cuales pueden mejorarse sobre la marcha (por ejemplo, c&amp;oacute;digo bajo demanda).</target>
        </trans-unit>
        <trans-unit id="1036e82ff72398f19dae7159de008a4b11524acc" translate="yes" xml:space="preserve">
          <source>A REST API should spend almost all of its descriptive effort in
  defining the media type(s) used for representing resources and driving
  application state, or in defining extended relation names and/or
  hypertext-enabled mark-up for existing standard media types.</source>
          <target state="translated">Una API REST debería dedicar casi todo su esfuerzo descriptivo a definir el/los tipo(s)de medio(s)utilizado(s)para representar los recursos y el estado de la aplicación de conducción,o a definir los nombres de relaciones extendidas y/o el marcado habilitado para hipertexto para los tipos de medio estándar existentes.</target>
        </trans-unit>
        <trans-unit id="091580d9e598bff76e8f95009cca43640abadd8b" translate="yes" xml:space="preserve">
          <source>A client of a RESTful application need
  only know a single fixed URL to access
  it. All future actions should be
  discoverable dynamically from
  hypermedia links included in the
  representations of the resources that
  are returned from that URL.
  Standardized media types are also
  expected to be understood by any
  client that might use a RESTful API. 
  (From Wikipedia, the free encyclopedia)</source>
          <target state="translated">Un cliente de una aplicación RESTful sólo necesita saber una única URL fija para acceder a ella.Todas las acciones futuras deben ser descubiertas dinámicamente a partir de los enlaces hipermedia incluidos en las representaciones de los recursos que se devuelven desde esa URL.También se espera que los tipos de medios estandarizados sean entendidos por cualquier cliente que pueda usar una API de RESTful.(De Wikipedia,la enciclopedia libre)</target>
        </trans-unit>
        <trans-unit id="b199b8ec3c349cace004db8b56b1161860b9581b" translate="yes" xml:space="preserve">
          <source>A great book on REST is &lt;a href=&quot;http://www.amazon.co.uk/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829&quot;&gt;REST in Practice&lt;/a&gt;.</source>
          <target state="translated">Un gran libro sobre REST es &lt;a href=&quot;http://www.amazon.co.uk/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829&quot;&gt;REST en la pr&amp;aacute;ctica&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbbdec192b31adde0e04c6c1e638a22c1c3a0509" translate="yes" xml:space="preserve">
          <source>A lot of answers copy/pasted valid information mixing it and adding some confusion. People talk here about levels, about RESTFul URIs(there is not such a thing!), apply HTTP methods GET,POST,PUT ... REST is not about that or not only about that.</source>
          <target state="translated">Muchas respuestas copiaron información válida mezclándola y añadiendo algo de confusión.La gente habla aquí de niveles,de URIs RESTABLES (¡no existe tal cosa!),aplican métodos HTTP GET,POST,PUT...El RESTO no es sobre eso o no sólo sobre eso.</target>
        </trans-unit>
        <trans-unit id="a9672fbb5a371857625bda2ec07f4fc2c459d533" translate="yes" xml:space="preserve">
          <source>A request for the base resource &lt;code&gt;/&lt;/code&gt; might return something like this:</source>
          <target state="translated">Una solicitud para el recurso base &lt;code&gt;/&lt;/code&gt; podr&amp;iacute;a devolver algo como esto:</target>
        </trans-unit>
        <trans-unit id="33311414a6f85a0d4549f88e6f929e587d140695" translate="yes" xml:space="preserve">
          <source>API testing utilizes programming to send calls to the API and get the yield. It testing regards the segment under test as a black box. The objective of API testing is to confirm right execution and blunder treatment of the part preceding its coordination into an application.</source>
          <target state="translated">La prueba de la API utiliza la programación para enviar llamadas a la API y obtener el rendimiento.Las pruebas consideran el segmento bajo prueba como una caja negra.El objetivo de la prueba del API es confirmar la correcta ejecución y el tratamiento erróneo de la parte que precede a su coordinación en una aplicación.</target>
        </trans-unit>
        <trans-unit id="17e11e3bc87a626545bcd3ae4e73a6dc9b979e5b" translate="yes" xml:space="preserve">
          <source>After reading the examples, I could see why Ken is saying that REST is hypertext-driven. I'm not actually sure that he's right though, because that /user/123 is a URI that points to a resource, and it's not clear to me that it's unRESTful just because the client knows about it &quot;out-of-band.&quot;</source>
          <target state="translated">Después de leer los ejemplos,pude ver por qué Ken dice que REST es impulsado por el hipertexto.Sin embargo,no estoy seguro de que esté en lo cierto,porque ese usuario123 es un URI que apunta a un recurso,y no está claro para mí que sea intranquilo sólo porque el cliente lo sepa &quot;fuera de banda&quot;.</target>
        </trans-unit>
        <trans-unit id="0ff162ae131fa2cf274f6632a56e1f9816c868de" translate="yes" xml:space="preserve">
          <source>After that, it's easy to fall into debates about adaptations, coding conventions, and best practices.</source>
          <target state="translated">Después de eso,es fácil caer en debates sobre adaptaciones,convenciones de codificación y mejores prácticas.</target>
        </trans-unit>
        <trans-unit id="e6213f65245bee16c30cf6760d609e28bd445103" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;architectural style&lt;/strong&gt; called &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;&lt;strong&gt;REST (Representational State Transfer)&lt;/strong&gt;&lt;/a&gt; advocates that web applications should use HTTP as it was &lt;strong&gt;originally envisioned&lt;/strong&gt;. Lookups should use &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; requests. &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; requests&lt;/a&gt; should be used for &lt;strong&gt;mutation, creation, and deletion respectively&lt;/strong&gt;.</source>
          <target state="translated">Un &lt;strong&gt;estilo arquitect&amp;oacute;nico&lt;/strong&gt; llamado &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;&lt;strong&gt;REST (Representational State Transfer)&lt;/strong&gt;&lt;/a&gt; defiende que las aplicaciones web deben usar HTTP como se &lt;strong&gt;concibi&amp;oacute; originalmente&lt;/strong&gt; . Las b&amp;uacute;squedas deben usar solicitudes &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;code&gt;POST&lt;/code&gt; PUT , POST y &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; deben usarse para &lt;strong&gt;mutaci&amp;oacute;n, creaci&amp;oacute;n y eliminaci&amp;oacute;n, respectivamente&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="23f9e629acbf7586515e2525e29805b2378876e7" translate="yes" xml:space="preserve">
          <source>An API that adheres to the principles of &lt;em&gt;REST&lt;/em&gt; does not require the client to know anything about the structure of the API. Rather, the server needs to provide whatever information the client needs to interact with the service. An &lt;em&gt;HTML form&lt;/em&gt; is an example of this: The server specifies the location of the resource and the required fields. &lt;strong&gt;The browser doesn't know in advance where to submit the information, and it doesn't know in advance what information to submit. Both forms of information are entirely supplied by the server.&lt;/strong&gt; (This principle is called &lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot;&gt;&lt;em&gt;HATEOAS&lt;/em&gt;: Hypermedia As The Engine Of Application State&lt;/a&gt;.)</source>
          <target state="translated">Una API que se adhiere a los principios de &lt;em&gt;REST&lt;/em&gt; no requiere que el cliente sepa nada sobre la estructura de la API. M&amp;aacute;s bien, el servidor necesita proporcionar cualquier informaci&amp;oacute;n que el cliente necesite para interactuar con el servicio. Un &lt;em&gt;formulario HTML&lt;/em&gt; es un ejemplo de esto: el servidor especifica la ubicaci&amp;oacute;n del recurso y los campos obligatorios. &lt;strong&gt;El navegador no sabe de antemano d&amp;oacute;nde enviar la informaci&amp;oacute;n, y no sabe de antemano qu&amp;eacute; informaci&amp;oacute;n enviar.&lt;/strong&gt; &lt;strong&gt;Ambas formas de informaci&amp;oacute;n son suministradas en su totalidad por el servidor.&lt;/strong&gt; (Este principio se llama &lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot;&gt;&lt;em&gt;HATEOAS&lt;/em&gt; : Hypermedia como el motor del estado de la aplicaci&amp;oacute;n&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0572ba17f943d7fd5fc5bebd5022f2239451cc72" translate="yes" xml:space="preserve">
          <source>An application is restful if it provides resources (being the combination of data + state transitions controls) in a media type the client understands</source>
          <target state="translated">Una aplicación es descansada si provee recursos (siendo la combinación de datos+controles de transiciones de estado)en un tipo de medio que el cliente entienda</target>
        </trans-unit>
        <trans-unit id="5bd054a830a9ec163da9832cb1d2afde20a52654" translate="yes" xml:space="preserve">
          <source>An excerpt from my talk is about the often referred to richardson maturity model, i don't believe in the levels, you either are RESTful (level 3) or you are not, but what i like to call out about it is what each level does for you on your way to RESTful</source>
          <target state="translated">Un extracto de mi charla es sobre el a menudo referido modelo de madurez de Richardson,no creo en los niveles,o eres RESTIVO (nivel 3)o no lo eres,pero lo que me gusta decir al respecto es lo que cada nivel hace por ti en tu camino a RESTIVO</target>
        </trans-unit>
        <trans-unit id="2610e51a62b1a490881eef55051e2f6be573a983" translate="yes" xml:space="preserve">
          <source>And even better, there's a clean explanation with simple examples here (the powerpoint is more comprehensive, but you can get most of it in the html version):</source>
          <target state="translated">Y aún mejor,hay una explicación clara con ejemplos simples aquí (el powerpoint es más completo,pero se puede obtener la mayor parte en la versión html):</target>
        </trans-unit>
        <trans-unit id="200c5e79bfe63bed7ea90d31d59e4814bd38015a" translate="yes" xml:space="preserve">
          <source>Bonus answer: No. Unless you're studying software architecture as an academic or designing web services, there's really no reason to have heard the term.</source>
          <target state="translated">Respuesta extra:No.A menos que estés estudiando arquitectura de software como académico o diseñando servicios web,realmente no hay razón para haber escuchado el término.</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="8db50296564fcc14b8370fbfb576cb5f7a3364bb" translate="yes" xml:space="preserve">
          <source>But the REST architecture doesn&amp;rsquo;t end there! While the above fulfills the basic needs of what we want, we also want to have an architecture that supports high volume traffic since any given server usually handles responses from a number of clients. Thus, we don&amp;rsquo;t want to overwhelm the server by having it remember information about previous requests.</source>
          <target state="translated">&amp;iexcl;Pero la arquitectura REST no termina ah&amp;iacute;! Si bien lo anterior satisface las necesidades b&amp;aacute;sicas de lo que queremos, tambi&amp;eacute;n queremos tener una arquitectura que admita tr&amp;aacute;fico de alto volumen ya que cualquier servidor determinado generalmente maneja las respuestas de varios clientes. Por lo tanto, no queremos abrumar al servidor haciendo que recuerde informaci&amp;oacute;n sobre solicitudes anteriores.</target>
        </trans-unit>
        <trans-unit id="c0e841fccec5e52e207c5f9f8aedc87617de3151" translate="yes" xml:space="preserve">
          <source>But to find any given resource and then tell the client where that resource lives, there needs to be a universal way of pointing at resources. This is where Universal Resource Identifiers (URIs) come in; they are basically unique addresses to find the resources.</source>
          <target state="translated">Pero para encontrar un recurso determinado y luego decirle al cliente dónde vive ese recurso,debe haber una forma universal de señalar los recursos.Aquí es donde entran los Identificadores Universales de Recursos (URI);son básicamente direcciones únicas para encontrar los recursos.</target>
        </trans-unit>
        <trans-unit id="ab9c8d4b22f42d6e20f2de04cee4a87194c9b2ff" translate="yes" xml:space="preserve">
          <source>Cacheable</source>
          <target state="translated">Cacheable</target>
        </trans-unit>
        <trans-unit id="ebdaf0dc221196d242550c9fdcc355ae34b62243" translate="yes" xml:space="preserve">
          <source>Click on send</source>
          <target state="translated">Haga clic en enviar</target>
        </trans-unit>
        <trans-unit id="85e79360e824842c6393ab95bc2ed066d468e1c8" translate="yes" xml:space="preserve">
          <source>Client&amp;ndash;server</source>
          <target state="translated">Client&amp;ndash;server</target>
        </trans-unit>
        <trans-unit id="9e1c7ac80552b301d4a9e2e0aad43db3dc88701b" translate="yes" xml:space="preserve">
          <source>Code on demand (optional)</source>
          <target state="translated">Código a la carta (opcional)</target>
        </trans-unit>
        <trans-unit id="09134846ea28241f35e0dd02fce269a9982bea7f" translate="yes" xml:space="preserve">
          <source>Create a user with three properties:</source>
          <target state="translated">Crear un usuario con tres propiedades:</target>
        </trans-unit>
        <trans-unit id="4b2835cc754c6984e507206155e739a1564f8450" translate="yes" xml:space="preserve">
          <source>DELETE removes the resources. The operations are idempotent. They can get repeated without leading to different results.</source>
          <target state="translated">BORRAR elimina los recursos.Las operaciones son idependientes.Pueden repetirse sin que se obtengan resultados diferentes.</target>
        </trans-unit>
        <trans-unit id="03419256ac96b83abfd7066f861a5015d2ba0ed0" translate="yes" xml:space="preserve">
          <source>DELETE: &amp;ndash; It is used to remove a resource.</source>
          <target state="translated">BORRAR: - Se utiliza para eliminar un recurso.</target>
        </trans-unit>
        <trans-unit id="5e5b459d45380b093202121fad6f6675d370930c" translate="yes" xml:space="preserve">
          <source>Despite being simple, REST is fully-featured; there's basically
  nothing you can do in Web Services that can't be done with a RESTful
  architecture. REST is not a &quot;standard&quot;. There will never be a W3C
  recommendataion for REST, for example. And while there are REST
  programming frameworks, working with REST is so simple that you can
  often &quot;roll your own&quot; with standard library features in languages like
  Perl, Java, or C#.</source>
          <target state="translated">A pesar de ser simple,REST tiene todas las características;básicamente no hay nada que puedas hacer en los Servicios Web que no se pueda hacer con una arquitectura REST.REST no es un &quot;estándar&quot;.Nunca habrá una recomendación del W3C para REST,por ejemplo.Y aunque hay marcos de programación REST,trabajar con REST es tan simple que a menudo puedes &quot;rodar tu propio&quot; con las características de la biblioteca estándar en lenguajes como Perl,Java,o C#.</target>
        </trans-unit>
        <trans-unit id="b8d49819767eebe1ba51b6e1ff800c7bff7f706e" translate="yes" xml:space="preserve">
          <source>Edit: Two more important aspects:</source>
          <target state="translated">Edición:Dos aspectos más importantes:</target>
        </trans-unit>
        <trans-unit id="cc4bbb1317907e63ed80955856990adc8e7cbbe4" translate="yes" xml:space="preserve">
          <source>Enter Request JSON (POST)</source>
          <target state="translated">Introduzca la solicitud JSON (POST)</target>
        </trans-unit>
        <trans-unit id="ab911d488e200ceacb5e406e1fe7b3000216de7c" translate="yes" xml:space="preserve">
          <source>Enter the API URL</source>
          <target state="translated">Introduce la URL de la API</target>
        </trans-unit>
        <trans-unit id="800300af0e99da4a9ab4e50e0ad740ebb248a62c" translate="yes" xml:space="preserve">
          <source>Every resource should support the HTTP common operations. Resources are identified by global IDs (which are typically URIs).</source>
          <target state="translated">Todos los recursos deberían apoyar las operaciones comunes del HTTP.Los recursos se identifican mediante identificaciones globales (que suelen ser URI).</target>
        </trans-unit>
        <trans-unit id="ae6c811f24cef30ab608149e77398fe7dc2aa93f" translate="yes" xml:space="preserve">
          <source>Explaining REST and Hypertext: Spam-E the Spam Cleaning Robot</source>
          <target state="translated">Explicando el REST y el hipertexto:Spam-E el robot limpiador de spam</target>
        </trans-unit>
        <trans-unit id="4c2e0eda7987cd96af30a22725f03cbbfc4b115a" translate="yes" xml:space="preserve">
          <source>For example links - it is nice to have a beautifully looking API but at the end the client/server does not really care of the links you get/send it is the content that matters.</source>
          <target state="translated">Por ejemplo,los enlaces-es agradable tener una API de aspecto agradable,pero al final el cliente-servidor no se preocupa realmente de los enlaces que recibe-lo que importa es el contenido.</target>
        </trans-unit>
        <trans-unit id="040c10648e6eb948c9d8e9d90c4d5f137fae46d2" translate="yes" xml:space="preserve">
          <source>For example there is a client layer which contains the clients and below that there is a service layer which contains a single service. Now you can add a client side cache between them. After that you can add another service instance and a load balancer, and so on... The client code and the service code won't change.</source>
          <target state="translated">Por ejemplo,hay una capa de clientes que contiene los clientes y debajo de ella hay una capa de servicios que contiene un solo servicio.Ahora puedes añadir una caché del lado del cliente entre ellos.Después de eso puedes añadir otra instancia de servicio y un balanceador de carga,y así sucesivamente...El código de cliente y el código de servicio no cambiarán.</target>
        </trans-unit>
        <trans-unit id="4edba5a49c7a4414557ee46319d87498dbeae513" translate="yes" xml:space="preserve">
          <source>For example when a client wants to send an order to a webshop, then it have to check the hyperlinks in the responses sent by the webshop. By checking the links it founds one described with the &lt;a href=&quot;http://schema.org/OrderAction&quot;&gt;http://schema.org/OrderAction&lt;/a&gt;. The client know the schema.org vocab, so it understands that by activating this hyperlink it will send the order. So it activates the hyperlink and sends a &lt;code&gt;POST https://example.com/api/v1/order&lt;/code&gt; message with the proper body. After that the service processes the message and responds with the result having the proper HTTP status header, for example &lt;code&gt;201 - created&lt;/code&gt; by success. To annotate messages with detailed metadata the standard solution to use an RDF format, for example &lt;a href=&quot;http://json-ld.org/&quot;&gt;JSON-LD&lt;/a&gt; with a REST vocab, for example &lt;a href=&quot;http://www.markus-lanthaler.com/hydra/&quot;&gt;Hydra&lt;/a&gt; and domain specific vocabs like &lt;a href=&quot;http://schema.org/&quot;&gt;schema.org&lt;/a&gt; or any other &lt;a href=&quot;http://lov.okfn.org/dataset/lov/&quot;&gt;linked data vocab&lt;/a&gt; and maybe a custom application specific vocab if needed. Now this is not easy, that's why most ppl use HAL and other simple formats which usually provide only a REST vocab, but no linked data support.</source>
          <target state="translated">Por ejemplo, cuando un cliente desea enviar un pedido a una tienda web, entonces debe verificar los hiperv&amp;iacute;nculos en las respuestas enviadas por la tienda web. Al revisar los enlaces, encuentra uno descrito en &lt;a href=&quot;http://schema.org/OrderAction&quot;&gt;http://schema.org/OrderAction&lt;/a&gt; . El cliente conoce el vocabulario de schema.org, por lo que entiende que al activar este hiperv&amp;iacute;nculo enviar&amp;aacute; el pedido. Por lo tanto, activa el hiperv&amp;iacute;nculo y env&amp;iacute;a un mensaje &lt;code&gt;POST https://example.com/api/v1/order&lt;/code&gt; con el cuerpo adecuado. Despu&amp;eacute;s de eso, el servicio procesa el mensaje y responde con el resultado que tiene el encabezado de estado HTTP adecuado, por ejemplo &lt;code&gt;201 - created&lt;/code&gt; por el &amp;eacute;xito. Para anotar mensajes con metadatos detallados, la soluci&amp;oacute;n est&amp;aacute;ndar para usar un formato RDF, por ejemplo, &lt;a href=&quot;http://json-ld.org/&quot;&gt;JSON-LD&lt;/a&gt; con un vocabulario REST, por ejemplo, vocablos espec&amp;iacute;ficos de &lt;a href=&quot;http://www.markus-lanthaler.com/hydra/&quot;&gt;Hydra&lt;/a&gt; y dominios como schema.org o cualquier otro &lt;a href=&quot;http://lov.okfn.org/dataset/lov/&quot;&gt;vocabulario de datos vinculados&lt;/a&gt; y tal vez un vocabulario espec&amp;iacute;fico de aplicaci&amp;oacute;n personalizada si necesario. Ahora, esto no es f&amp;aacute;cil, es por eso que la mayor&amp;iacute;a de las personas usan HAL y otros formatos simples que generalmente proporcionan solo un vocabulario REST, pero no admiten datos vinculados.</target>
        </trans-unit>
        <trans-unit id="519a503f187cd31038f7706dcd1d8a0887042f78" translate="yes" xml:space="preserve">
          <source>For example, Let's imagine that we have a user database that is managed by a web service. Our service uses a custom hypermedia based on JSON, for which we assign the mimetype &lt;code&gt;application/json+userdb&lt;/code&gt; (There might also be an &lt;code&gt;application/xml+userdb&lt;/code&gt; and &lt;code&gt;application/whatever+userdb&lt;/code&gt; - many media types may be supported). The client and the server have both been programmed to understand this format, but they don't know anything about each other. As &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Roy Fielding&lt;/a&gt; points out:</source>
          <target state="translated">Por ejemplo, imaginemos que tenemos una base de datos de usuarios administrada por un servicio web. Nuestro servicio utiliza un hipermedia personalizado basado en JSON, para el cual asignamos la &lt;code&gt;application/json+userdb&lt;/code&gt; mimetype / json + userdb (tambi&amp;eacute;n puede haber una &lt;code&gt;application/xml+userdb&lt;/code&gt; y una &lt;code&gt;application/whatever+userdb&lt;/code&gt; ; muchos tipos de medios pueden ser compatibles). El cliente y el servidor han sido programados para comprender este formato, pero no saben nada el uno del otro. Como &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Roy Fielding&lt;/a&gt; se&amp;ntilde;ala:</target>
        </trans-unit>
        <trans-unit id="29ff533a59385e46befeb9d1d442ce81cde883fb" translate="yes" xml:space="preserve">
          <source>For example, instead a set of URLs which might look like some of the following..</source>
          <target state="translated">Por ejemplo,en lugar de un conjunto de URLs que podrían parecerse a algunos de los siguientes...</target>
        </trans-unit>
        <trans-unit id="ce3d305d56ec5c6ee26c71725d770976054d26b3" translate="yes" xml:space="preserve">
          <source>For sending and receiving messages, it involves using HTTP methods, and it does not require a strict message definition, unlike Web services.</source>
          <target state="translated">Para enviar y recibir mensajes,implica el uso de métodos HTTP,y no requiere una definición estricta de los mensajes,a diferencia de los servicios web.</target>
        </trans-unit>
        <trans-unit id="096bafb1ad02c5e340fc0cffb7efac1d03c6fdd6" translate="yes" xml:space="preserve">
          <source>Further reading:</source>
          <target state="translated">Más lecturas:</target>
        </trans-unit>
        <trans-unit id="ae09a97e20415e22fe1f93eb6fbb98ed8d14de81" translate="yes" xml:space="preserve">
          <source>GET defines a reading access of the resource without side-effects. The resource is never changed via a GET request, e.g., the request has no side effects (idempotent).</source>
          <target state="translated">GET define un acceso de lectura del recurso sin efectos secundarios.El recurso nunca se cambia a través de una petición GET,por ejemplo,la petición no tiene efectos secundarios (idempotent).</target>
        </trans-unit>
        <trans-unit id="c4c41d24d5f2a151608ed14ff7819f6f47a5271f" translate="yes" xml:space="preserve">
          <source>GET: &amp;ndash; It provides read only access to a resource.</source>
          <target state="translated">OBTENER: - Proporciona acceso de solo lectura a un recurso.</target>
        </trans-unit>
        <trans-unit id="5e04d05de713337d37ea8308533c814f117ef859" translate="yes" xml:space="preserve">
          <source>Given this view point, the rest style is not really tied to internet or web application. It's a fundamental solution to many of the programming situations. It is not simple either, it just makes the interface really simple, and copes with other technologies amazingly well.</source>
          <target state="translated">Dado este punto de vista,el estilo de descanso no está realmente ligado a internet o a la aplicación web.Es una solución fundamental para muchas de las situaciones de programación.Tampoco es simple,sólo hace que la interfaz sea realmente simple,y se adapta a otras tecnologías sorprendentemente bien.</target>
        </trans-unit>
        <trans-unit id="413e85dd36b6612ff8f3b552ddd4ae973747eb10" translate="yes" xml:space="preserve">
          <source>Here is my basic outline of REST. I tried to demonstrate the thinking behind each of the components in a RESTful architecture so that understanding the concept is more intuitive. Hopefully this helps demystify REST for some people!</source>
          <target state="translated">Aquí está mi esquema básico de REST.Traté de demostrar el pensamiento detrás de cada uno de los componentes de una arquitectura REST para que la comprensión del concepto sea más intuitiva.¡Esperemos que esto ayude a desmitificar REST para algunas personas!</target>
        </trans-unit>
        <trans-unit id="c419bb60824d17f1c8fc3f5f0378842579d5c500" translate="yes" xml:space="preserve">
          <source>I apologize if I'm not answering the question directly, but it's easier to understand all this with more detailed examples. Fielding is not easy to understand due to all the abstraction and terminology.</source>
          <target state="translated">Me disculpo si no respondo a la pregunta directamente,pero es más fácil entender todo esto con ejemplos más detallados.Fielding no es fácil de entender debido a toda la abstracción y la terminología.</target>
        </trans-unit>
        <trans-unit id="087ec8b5ab0cac5efee7be73a08f41b5611d251f" translate="yes" xml:space="preserve">
          <source>I define restful programming as</source>
          <target state="translated">Yo defino la programación de descanso como</target>
        </trans-unit>
        <trans-unit id="ee52bb4671d83e94060d7610bdd9bf819906adce" translate="yes" xml:space="preserve">
          <source>I don't think you should feel stupid for not hearing about REST outside Stack Overflow..., I would be in the same situation!; answers to this other SO question on &lt;a href=&quot;https://stackoverflow.com/q/243388/463478&quot;&gt;Why is REST getting big now&lt;/a&gt; could ease some feelings.</source>
          <target state="translated">No creo que debas sentirte est&amp;uacute;pido por no haber escuchado sobre REST fuera de Stack Overflow ..., &amp;iexcl;estar&amp;iacute;a en la misma situaci&amp;oacute;n !; Las respuestas a esta otra pregunta SO sobre por &lt;a href=&quot;https://stackoverflow.com/q/243388/463478&quot;&gt;qu&amp;eacute; REST se est&amp;aacute; haciendo grande ahora&lt;/a&gt; podr&amp;iacute;an aliviar algunos sentimientos.</target>
        </trans-unit>
        <trans-unit id="6c76368a522ebb58d381771d2b88fa3b274443e2" translate="yes" xml:space="preserve">
          <source>I found this fantastic, short, and easy to understand tutorial about REST by Dr. M. Elkstein and quoting the essential part that would answer your question for the most part:</source>
          <target state="translated">Encontré este fantástico,corto y fácil de entender tutorial sobre REST del Dr.M.Elkstein y citando la parte esencial que respondería a su pregunta en su mayor parte:</target>
        </trans-unit>
        <trans-unit id="6d8108db9657b6e64ef934ab59dc6f7fa01dcc70" translate="yes" xml:space="preserve">
          <source>I see a bunch of answers that say putting everything about user 123 at resource &quot;/user/123&quot; is RESTful.</source>
          <target state="translated">Veo un montón de respuestas que dicen que poner todo sobre el usuario 123 en el recurso &quot;usuario123&quot; es RESTITUCIONABLE.</target>
        </trans-unit>
        <trans-unit id="763841bd5f36269041a09b4b998b89fbb9e2caff" translate="yes" xml:space="preserve">
          <source>I think that the most important trick to understanding the architectural importance and performance implications of a RESTful and &lt;a href=&quot;http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf&quot;&gt;Shared Nothing&lt;/a&gt; architectures is to avoid getting hung up on the technology and implementation details. Concentrate on who owns resources, who is responsible for creating/maintaining them, etc. Then think about the representations, protocols, and technologies.</source>
          <target state="translated">Creo que el truco m&amp;aacute;s importante para comprender la importancia arquitect&amp;oacute;nica y las implicaciones de rendimiento de las arquitecturas RESTful y &lt;a href=&quot;http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf&quot;&gt;Shared Nothing&lt;/a&gt; es evitar obsesionarse con la tecnolog&amp;iacute;a y los detalles de implementaci&amp;oacute;n. Conc&amp;eacute;ntrese en qui&amp;eacute;n posee los recursos, qui&amp;eacute;n es responsable de crearlos / mantenerlos, etc. Luego piense en las representaciones, protocolos y tecnolog&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="d0530a0292feea24c4a9346fcd870c5d42a8ef18" translate="yes" xml:space="preserve">
          <source>I think the point of restful is the &lt;strong&gt;separation of the statefulness into a higher layer&lt;/strong&gt; while making use of the internet (protocol) as a &lt;strong&gt;stateless transport layer&lt;/strong&gt;. Most other approaches mix things up.</source>
          <target state="translated">Creo que el punto de descanso es la &lt;strong&gt;separaci&amp;oacute;n de la capacidad de estado en una capa superior&lt;/strong&gt; mientras se hace uso de Internet (protocolo) como una &lt;strong&gt;capa de transporte sin estado&lt;/strong&gt; . La mayor&amp;iacute;a de los otros enfoques mezclan las cosas.</target>
        </trans-unit>
        <trans-unit id="c322421456d9bf2c2db73cb8c6cdc0e978e2f5ea" translate="yes" xml:space="preserve">
          <source>I would say RESTful programming would be about creating systems (API) that follow the REST architectural style.</source>
          <target state="translated">Yo diría que la programación de RESTful sería sobre la creación de sistemas (API)que siguen el estilo arquitectónico de REST.</target>
        </trans-unit>
        <trans-unit id="7efc17b40148a3f7a450c659d22a107b0159fbac" translate="yes" xml:space="preserve">
          <source>I would say that an important building block in understanding REST lies in the endpoints or mappings, such as &lt;code&gt;/customers/{id}/balance&lt;/code&gt;.</source>
          <target state="translated">Dir&amp;iacute;a que un componente importante para comprender REST reside en los puntos finales o las asignaciones, como &lt;code&gt;/customers/{id}/balance&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00c15a6f862dfb4e67e15e8fab5e3217684aa057" translate="yes" xml:space="preserve">
          <source>I'm not looking to self promote, but i expand on these ideas to great depth in my talk &lt;a href=&quot;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&quot;&gt;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&lt;/a&gt; .</source>
          <target state="translated">No estoy buscando auto promocionarme, pero ampl&amp;iacute;o estas ideas con gran profundidad en mi charla &lt;a href=&quot;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&quot;&gt;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c54b01044e3ae27d309c48efbe56fe8b30a02fdb" translate="yes" xml:space="preserve">
          <source>IMO:</source>
          <target state="translated">IMO:</target>
        </trans-unit>
        <trans-unit id="528e227c40908c4c76424c153287878418391881" translate="yes" xml:space="preserve">
          <source>If I had to reduce the original dissertation on REST to just 3 short sentences, I think the following captures its essence:</source>
          <target state="translated">Si tuviera que reducir la disertación original sobre DESCANSO a sólo 3 frases cortas,creo que la siguiente captura su esencia:</target>
        </trans-unit>
        <trans-unit id="3e4a789505499d4ebc9acf09affff2580e66a8db" translate="yes" xml:space="preserve">
          <source>If you are really interested in what a RESTful architecture is and why it works, read &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;his thesis&lt;/a&gt; a few times and read the &lt;strong&gt;whole thing&lt;/strong&gt; not just Chapter 5! Next look into &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;why DNS works&lt;/a&gt;. Read about the hierarchical organization of DNS and how referrals work. Then read and consider how DNS caching works. Finally, read the HTTP specifications (&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; in particular) and consider how and why the caching works the way that it does. Eventually, it will just click. The final revelation for me was when I saw the similarity between DNS and HTTP. After this, understanding why SOA and Message Passing Interfaces are scalable starts to click.</source>
          <target state="translated">Si est&amp;aacute; realmente interesado en qu&amp;eacute; es una arquitectura RESTful y por qu&amp;eacute; funciona, lea &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;su tesis&lt;/a&gt; varias veces y lea &lt;strong&gt;todo, &amp;iexcl;&lt;/strong&gt; no solo el Cap&amp;iacute;tulo 5! A continuaci&amp;oacute;n, analice por &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;qu&amp;eacute; funciona DNS&lt;/a&gt; . Lea sobre la organizaci&amp;oacute;n jer&amp;aacute;rquica de DNS y c&amp;oacute;mo funcionan las referencias. Luego lea y considere c&amp;oacute;mo funciona el almacenamiento en cach&amp;eacute; de DNS. Finalmente, lea las especificaciones HTTP ( &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; y &lt;a href=&quot;http://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; en particular) y considere c&amp;oacute;mo y por qu&amp;eacute; el almacenamiento en cach&amp;eacute; funciona de la manera en que lo hace. Finalmente, solo har&amp;aacute; clic. La revelaci&amp;oacute;n final para m&amp;iacute; fue cuando vi la similitud entre DNS y HTTP. Despu&amp;eacute;s de esto, entender por qu&amp;eacute; las interfaces de paso de mensajes y SOA son escalables comienza a hacer clic.</target>
        </trans-unit>
        <trans-unit id="5c9c0f1f96e6c661dd2c0857fa65fd08bb396af3" translate="yes" xml:space="preserve">
          <source>In a REST based architecture you have a REST server which provides
  access to the resources. A REST client can access and modify the REST
  resources.</source>
          <target state="translated">En una arquitectura basada en REST tienes un servidor REST que proporciona acceso a los recursos.Un cliente REST puede acceder y modificar los recursos REST.</target>
        </trans-unit>
        <trans-unit id="2a7fcadf01fdd539dc00964a4063d163ad342bf9" translate="yes" xml:space="preserve">
          <source>In a REST based architecture, everything is a resource(Users, Orders, Comments). A resource is accessed via a common interface based on the HTTP standard methods(GET, PUT, PATCH, DELETE etc).</source>
          <target state="translated">En una arquitectura basada en REST,todo es un recurso (Usuarios,Pedidos,Comentarios).Se accede a un recurso a través de una interfaz común basada en los métodos estándar de HTTP (GET,PUT,PATCH,DELETE etc.).</target>
        </trans-unit>
        <trans-unit id="81af6a9f5471cbc482ac157847e6af8a50d7537f" translate="yes" xml:space="preserve">
          <source>In computing, representational state transfer (REST) is an
  architectural style used for web development.</source>
          <target state="translated">En informática,la transferencia de estados representativos (REST)es un estilo arquitectónico utilizado para el desarrollo de la web.</target>
        </trans-unit>
        <trans-unit id="508381eb480015bf82a7312e0cfb8e350127a358" translate="yes" xml:space="preserve">
          <source>In many ways, the World Wide Web itself, based on HTTP, can be viewed
  as a REST-based architecture. RESTful applications use HTTP requests
  to post data (create and/or update), read data (e.g., make queries),
  and delete data. Thus, REST uses HTTP for all four CRUD
  (Create/Read/Update/Delete) operations.</source>
          <target state="translated">En muchos sentidos,la propia World Wide Web,basada en HTTP,puede ser vista como una arquitectura basada en REST.Las aplicaciones REST utilizan las peticiones HTTP para publicar datos (crear ando o actualizar),leer datos (por ejemplo,hacer consultas)y borrar datos.Así,REST utiliza HTTP para las cuatro operaciones CRUD (CreateReadUpdateDelete).</target>
        </trans-unit>
        <trans-unit id="9afec0b39286ce35f8ff306c75875ec463e27211" translate="yes" xml:space="preserve">
          <source>In many ways, the World Wide Web itself, based on HTTP, can be viewed    as a REST-based architecture.</source>
          <target state="translated">En muchos sentidos,la propia World Wide Web,basada en HTTP,puede ser vista como una arquitectura basada en REST.</target>
        </trans-unit>
        <trans-unit id="d7d9b177727972b7bd403cb1d9830e8972f6ccaf" translate="yes" xml:space="preserve">
          <source>In other words you're writing simple point-to-point network applications over HTTP which uses verbs such as GET, POST, PUT or DELETE by implementing RESTful architecture which proposes standardization of the interface each &amp;ldquo;resource&amp;rdquo; exposes. It is nothing that using current features of the web in a simple and effective way (highly successful, proven and distributed architecture). It is an alternative to more complex mechanisms like &lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture&quot;&gt;CORBA&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt;.</source>
          <target state="translated">En otras palabras, est&amp;aacute; escribiendo aplicaciones simples de red punto a punto sobre HTTP que utiliza verbos como GET, POST, PUT o DELETE mediante la implementaci&amp;oacute;n de una arquitectura RESTful que propone la estandarizaci&amp;oacute;n de la interfaz que expone cada &quot;recurso&quot;. No es nada que utilice las caracter&amp;iacute;sticas actuales de la web de una manera simple y efectiva (arquitectura altamente exitosa, probada y distribuida). Es una alternativa a mecanismos m&amp;aacute;s complejos como &lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture&quot;&gt;CORBA&lt;/a&gt; y &lt;a href=&quot;http://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9075c88ba609ac32ad4853adceff80a57b9c8848" translate="yes" xml:space="preserve">
          <source>In the end &lt;strong&gt;any RESTful client should be able to consume to any RESTful service as long as the content format is known.&lt;/strong&gt;</source>
          <target state="translated">Al final, &lt;strong&gt;cualquier cliente RESTful deber&amp;iacute;a poder consumir cualquier servicio RESTful siempre que se conozca el formato del contenido.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6435852cb4e96cc87686e94b5374a8056f393527" translate="yes" xml:space="preserve">
          <source>In the future, you can then retrieve the user information:</source>
          <target state="translated">En el futuro,podrás recuperar la información del usuario:</target>
        </trans-unit>
        <trans-unit id="d6ecb449599f6dd2f5e9713553e3cd31fe1f0435" translate="yes" xml:space="preserve">
          <source>Install POSTMAN(Chrome) / REST(Firefox) plugin</source>
          <target state="translated">Instalar el plugin POSTMAN(Chrome)REST(Firefox)</target>
        </trans-unit>
        <trans-unit id="6a6d9700ec195facf4fac9e8b95e37072828dc22" translate="yes" xml:space="preserve">
          <source>Interestingly, there is no mention of HTTP POST, GET, DELETE, or PUT operations in the dissertation. That must be someone's later interpretation of a &quot;best practice&quot; for a &quot;uniform interface&quot;.</source>
          <target state="translated">Curiosamente,no se mencionan las operaciones HTTP POST,GET,DELETE o PUT en la tesis.Esa debe ser la interpretación posterior de alguien de una &quot;mejor práctica&quot; para una &quot;interfaz uniforme&quot;.</target>
        </trans-unit>
        <trans-unit id="f9de0a4336192b307d47a7bd6e45e0eaef080436" translate="yes" xml:space="preserve">
          <source>Introduction about Rest</source>
          <target state="translated">Introducción sobre el descanso</target>
        </trans-unit>
        <trans-unit id="b9c999a74770669b9c8ffb4ad17078f65b2cda93" translate="yes" xml:space="preserve">
          <source>It relies on a stateless, client-server, cacheable communications protocol -- and in virtually all cases, the HTTP protocol is used.</source>
          <target state="translated">Se basa en un protocolo de comunicaciones sin estado,cliente-servidor y en caché,y en casi todos los casos se utiliza el protocolo HTTP.</target>
        </trans-unit>
        <trans-unit id="1117236a998be55f80d560abd424de90ea9e2991" translate="yes" xml:space="preserve">
          <source>It will return output response</source>
          <target state="translated">Devolverá la respuesta de salida</target>
        </trans-unit>
        <trans-unit id="c89e148b7af16b441451c1995bfe2abaf6361908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an arrangement of functions on which the testers performs requests and receive responses. In REST API interactions are made via HTTP protocol.</source>
          <target state="translated">Es una disposici&amp;oacute;n de funciones en la que los evaluadores realizan solicitudes y reciben respuestas. En REST API las interacciones se realizan a trav&amp;eacute;s del protocolo HTTP.</target>
        </trans-unit>
        <trans-unit id="f0fc1358f601de6b260eab812260ed0430f7e282" translate="yes" xml:space="preserve">
          <source>It's been the best practical approach to handle the fundamental changes of programming in internet era. Regarding the fundamental changes, Erik Meijer has a discussion on show here: &lt;a href=&quot;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&quot;&gt;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&lt;/a&gt; . He summarizes it as the five effects, and presents a solution by designing the solution into a programming language. The solution, could also be achieved in the platform or system level, regardless of the language. The restful could be seen as one of the solutions that has been very successful in the current practice.</source>
          <target state="translated">Ha sido el mejor enfoque pr&amp;aacute;ctico para manejar los cambios fundamentales de la programaci&amp;oacute;n en la era de Internet. Con respecto a los cambios fundamentales, Erik Meijer tiene una discusi&amp;oacute;n en el programa aqu&amp;iacute;: &lt;a href=&quot;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&quot;&gt;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&lt;/a&gt; . Lo resume como los cinco efectos y presenta una soluci&amp;oacute;n dise&amp;ntilde;ando la soluci&amp;oacute;n en un lenguaje de programaci&amp;oacute;n. La soluci&amp;oacute;n tambi&amp;eacute;n podr&amp;iacute;a lograrse a nivel de plataforma o sistema, independientemente del idioma. El descanso podr&amp;iacute;a verse como una de las soluciones que ha tenido mucho &amp;eacute;xito en la pr&amp;aacute;ctica actual.</target>
        </trans-unit>
        <trans-unit id="d4929d90be24c95c993943d45502f80422e27a62" translate="yes" xml:space="preserve">
          <source>It's programming where the architecture of your system fits the &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;REST style&lt;/a&gt; laid out by Roy Fielding in &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;his thesis&lt;/a&gt;. Since this is the architectural style that describes the web (more or less), lots of people are interested in it.</source>
          <target state="translated">Es la programaci&amp;oacute;n donde la arquitectura de su sistema se ajusta al &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;estilo REST&lt;/a&gt; presentado por Roy Fielding en &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;su tesis&lt;/a&gt; . Dado que este es el estilo arquitect&amp;oacute;nico que describe la web (m&amp;aacute;s o menos), mucha gente est&amp;aacute; interesada en ella.</target>
        </trans-unit>
        <trans-unit id="9e58b34ecd5fe46f5c7fac142a7753476a694f3e" translate="yes" xml:space="preserve">
          <source>JSON is not restful programming</source>
          <target state="translated">JSON no es una programación tranquila</target>
        </trans-unit>
        <trans-unit id="a6b85e0f041b2c7697f401797ec1377054a290db" translate="yes" xml:space="preserve">
          <source>Just my 2c.</source>
          <target state="translated">Sólo mi 2c.</target>
        </trans-unit>
        <trans-unit id="bbe8d64fcde25a40febca185bf5ef63d774333ce" translate="yes" xml:space="preserve">
          <source>Keep in mind that GET requests should never be used for updating information. For example, a GET request for adding an item to a cart</source>
          <target state="translated">Tenga en cuenta que las solicitudes de GET nunca deben utilizarse para actualizar la información.Por ejemplo,una solicitud GET para añadir un artículo a un carrito</target>
        </trans-unit>
        <trans-unit id="5f82e7663dd4156cb07776cb1cea89dd1aba1b01" translate="yes" xml:space="preserve">
          <source>Layered system</source>
          <target state="translated">Sistema de capas</target>
        </trans-unit>
        <trans-unit id="133b041c9729c525d972a67420b5a147370536ad" translate="yes" xml:space="preserve">
          <source>Learn REST: A Tutorial</source>
          <target state="translated">Aprende a descansar:Un Tutorial</target>
        </trans-unit>
        <trans-unit id="d48495a4077a6c79d43f781b565680695cf2d342" translate="yes" xml:space="preserve">
          <source>Martin Fowler's
thoughts</source>
          <target state="translated">Los pensamientos de Martin Fowler</target>
        </trans-unit>
        <trans-unit id="de83e0aeb9afb13ea59f9bf7102b93ccfae94aaa" translate="yes" xml:space="preserve">
          <source>Metadata is passed as name-value pairs (post data and query string parameters).</source>
          <target state="translated">Los metadatos se pasan como pares nombre/valor (post datos y parámetros de cadena de consulta).</target>
        </trans-unit>
        <trans-unit id="b45afbd2f6f71f5bbf40bc713d36b1cb5591272d" translate="yes" xml:space="preserve">
          <source>Must reads are &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Representational State Transfer (REST)&lt;/a&gt; and &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIs must be hypertext-driven&lt;/a&gt;</source>
          <target state="translated">Las lecturas &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;obligatorias&lt;/a&gt; son &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Transferencia de estado representacional (REST)&lt;/a&gt; y las API REST deben ser impulsadas por hipertexto</target>
        </trans-unit>
        <trans-unit id="75117da5ea6dd4a55238ac032ebaaa4e06e4091c" translate="yes" xml:space="preserve">
          <source>Notice that we are using different HTTP verbs (&lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; etc.) to manipulate these resources, and that the only knowledge we presume on the client's part is our media definition.</source>
          <target state="translated">Observe que estamos usando diferentes verbos HTTP ( &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , etc.) para manipular estos recursos, y que el &amp;uacute;nico conocimiento que suponemos por parte del cliente es nuestra definici&amp;oacute;n de medios.</target>
        </trans-unit>
        <trans-unit id="83b061b2a63b8f2183eb1bdcdd47faa9c5345256" translate="yes" xml:space="preserve">
          <source>Now, if all of this sounds familiar, then great. The Hypertext Transfer Protocol (HTTP), which defines the communication protocol via the World Wide Web is an implementation of the abstract notion of RESTful architecture (or an instance of the REST class if you're an OOP fanatic like me). In this implementation of REST, the client and server interact via GET, POST, PUT, DELETE, etc., which are part of the universal language and the resources can be pointed to using URLs.</source>
          <target state="translated">Ahora,si todo esto te suena familiar,entonces genial.El Protocolo de Transferencia de Hipertexto (HTTP),que define el protocolo de comunicación a través de la World Wide Web es una implementación de la noción abstracta de la arquitectura REST (o una instancia de la clase REST si eres un fanático de la OOP como yo).En esta implementación de REST,el cliente y el servidor interactúan vía GET,POST,PUT,DELETE,etc.,que son parte del lenguaje universal y los recursos pueden ser apuntados usando URLs.</target>
        </trans-unit>
        <trans-unit id="e1a9621fd53f3f752aff5f25b313a5a3c60c684e" translate="yes" xml:space="preserve">
          <source>Old question, newish way of answering.  There's a lot of misconception out there about this concept.  I always try to remember:</source>
          <target state="translated">Vieja pregunta,nueva forma de responder.Hay muchas ideas equivocadas sobre este concepto.Siempre trato de recordar:</target>
        </trans-unit>
        <trans-unit id="438027d47ce1c5a96c385f53eecd236c425fb2b5" translate="yes" xml:space="preserve">
          <source>One of the best reference I found when I try to find the simple real meaning of rest.</source>
          <target state="translated">Una de las mejores referencias que encontré cuando trato de encontrar el simple significado real del descanso.</target>
        </trans-unit>
        <trans-unit id="c6f2d9e5ea80ff9b7b9ded9e2a81fb5f446691e1" translate="yes" xml:space="preserve">
          <source>POST updates an existing resource or creates a new resource.</source>
          <target state="translated">POST actualiza un recurso existente o crea uno nuevo.</target>
        </trans-unit>
        <trans-unit id="d742711b2a6bd7b769816a15fa5a239a2c74f940" translate="yes" xml:space="preserve">
          <source>POST: &amp;ndash; It is used to create or update a new resource.</source>
          <target state="translated">POST: - Se utiliza para crear o actualizar un nuevo recurso.</target>
        </trans-unit>
        <trans-unit id="37e0818cbbbc83b5f7771a4d5dfae0eb226e31e7" translate="yes" xml:space="preserve">
          <source>PUT creates a new resource. It must also be idempotent.</source>
          <target state="translated">PUT crea un nuevo recurso.También debe ser idempotente.</target>
        </trans-unit>
        <trans-unit id="ada2743b893defbc7c8ab2a60424b669dd79a22b" translate="yes" xml:space="preserve">
          <source>PUT: &amp;ndash; It is used to update or replace an existing resource or create a new resource.</source>
          <target state="translated">PUT: - Se utiliza para actualizar o reemplazar un recurso existente o crear un nuevo recurso.</target>
        </trans-unit>
        <trans-unit id="675a94eb09e6d971c2a74e502df85b0396498a6f" translate="yes" xml:space="preserve">
          <source>PayPal's API has hypermedia controls</source>
          <target state="translated">La API de PayPal tiene controles de hipermedia</target>
        </trans-unit>
        <trans-unit id="330809f2cc51f1c140e1980086142c16a9addb97" translate="yes" xml:space="preserve">
          <source>Principle 1: Everything is a Resource
In the REST architectural style, data and functionality are considered resources and are accessed using Uniform Resource Identifiers (URIs), typically links on the Web.</source>
          <target state="translated">Principio 1:Todo es un recurso En el estilo arquitectónico REST,los datos y la funcionalidad se consideran recursos y se accede a ellos mediante los Identificadores Uniformes de Recursos (URI),típicamente enlaces en la Web.</target>
        </trans-unit>
        <trans-unit id="8c699adbd41e9b331e5fbd3c027ab2582737eb63" translate="yes" xml:space="preserve">
          <source>Principle 2: Every Resource is Identified by a Unique Identifier (URI)</source>
          <target state="translated">Principio 2:Cada recurso es identificado por un identificador único (URI)</target>
        </trans-unit>
        <trans-unit id="b612f5757ab3b67dcdf0fc959e4a1f2295c39bfc" translate="yes" xml:space="preserve">
          <source>Principle 3: Use Simple and Uniform Interfaces</source>
          <target state="translated">Principio 3:Usar interfaces simples y uniformes</target>
        </trans-unit>
        <trans-unit id="1c4054641d8394bb16320893dba0d8f48d910d14" translate="yes" xml:space="preserve">
          <source>Principle 4: Communication is Done by Representation</source>
          <target state="translated">Principio 4:La comunicación se hace por representación</target>
        </trans-unit>
        <trans-unit id="52e149151dd57ddc7a1edcf0a393bb8fc2cc1dc9" translate="yes" xml:space="preserve">
          <source>Principle 5: Be Stateless</source>
          <target state="translated">Principio 5:Ser apátrida</target>
        </trans-unit>
        <trans-unit id="3b6ad19884af654ebfaa84e23196de80335cb4c9" translate="yes" xml:space="preserve">
          <source>Protocols are limited to what you can communicate by using URLs.</source>
          <target state="translated">Los protocolos se limitan a lo que se puede comunicar mediante el uso de URL.</target>
        </trans-unit>
        <trans-unit id="ea0905504dfdf615e0862b8f2c6ac34fbc396c3b" translate="yes" xml:space="preserve">
          <source>REST (Representational State Transfer) is a design architecture that outlines how networked resources (i.e. nodes that share information) are designed and addressed. In general, a RESTful architecture makes it so that the client (the requesting machine) and the server (the responding machine) can request to read, write, and update data without the client having to know how the server operates and the server can pass it back without needing to know anything about the client. Okay, cool...but how do we do this in practice?</source>
          <target state="translated">REST (Representational State Transfer)es una arquitectura de diseño que describe cómo se diseñan y se abordan los recursos en red (es decir,los nodos que comparten información).En general,una arquitectura REST hace que el cliente (la máquina solicitante)y el servidor (la máquina que responde)puedan solicitar leer,escribir y actualizar datos sin que el cliente tenga que saber cómo funciona el servidor y éste pueda pasarlos de vuelta sin necesidad de saber nada sobre el cliente.Vale,genial...pero ¿cómo hacemos esto en la práctica?</target>
        </trans-unit>
        <trans-unit id="700c9dae20f56bed7f78e92f023ff70ce8630a9f" translate="yes" xml:space="preserve">
          <source>REST === HTTP analogy is not correct until you do not stress to the fact that it &quot;MUST&quot; be &lt;a href=&quot;http://restfulapi.net/hateoas/&quot;&gt;HATEOAS&lt;/a&gt; driven.</source>
          <target state="translated">REST === La analog&amp;iacute;a HTTP no es correcta hasta que no se enfatice en el hecho de que &quot;DEBE&quot; ser impulsado por &lt;a href=&quot;http://restfulapi.net/hateoas/&quot;&gt;HATEOAS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d900533fc0307874766ce99858e2dca6a98b0ed" translate="yes" xml:space="preserve">
          <source>REST allows that resources have different representations, e.g., text, XML, JSON etc. The REST client can ask for a specific representation via the HTTP protocol (content negotiation).</source>
          <target state="translated">REST permite que los recursos tengan diferentes representaciones,por ejemplo,texto,XML,JSON,etc.El cliente REST puede pedir una representación específica a través del protocolo HTTP (negociación de contenido).</target>
        </trans-unit>
        <trans-unit id="d7e35d79a67bcd2fd91ce8bbd613ef5c12223b40" translate="yes" xml:space="preserve">
          <source>REST also permits communication between computers with each other over a network.</source>
          <target state="translated">REST también permite la comunicación entre computadoras a través de una red.</target>
        </trans-unit>
        <trans-unit id="7bebea77f381f6a449770f9552c88ba86e2ca2da" translate="yes" xml:space="preserve">
          <source>REST constraints result a highly scalable system in where the clients are decoupled from the implementations of the services. So the clients can be reusable, general just like the browsers on the web. The clients and the services share the same standards and vocabs, so they can understand each other despite the fact that the client does not know the implementation details of the service. This makes possible to create automated clients which can find and utilize REST services to achieve their goals. In long term these clients can communicate to each other and trust each other with tasks, just like humans do. If we add learning patterns to such clients, then the result will be one or more AI using the web of machines instead of a single server park. So at the end the dream of Berners Lee: the semantic web and the artificial intelligence will be reality. So in 2030 we end up terminated by the Skynet. Until then ... ;-)</source>
          <target state="translated">Las restricciones de REST dan como resultado un sistema altamente escalable en el que los clientes están desvinculados de las implementaciones de los servicios.Así que los clientes pueden ser reutilizables,en general como los navegadores de la web.Los clientes y los servicios comparten los mismos estándares y vocabs,por lo que pueden entenderse entre sí a pesar de que el cliente no conozca los detalles de implementación del servicio.Esto hace posible crear clientes automatizados que pueden encontrar y utilizar los servicios REST para lograr sus objetivos.A largo plazo,estos clientes pueden comunicarse entre sí y confiarse mutuamente las tareas,al igual que los humanos.Si añadimos patrones de aprendizaje a estos clientes,el resultado será una o más IA usando la red de máquinas en lugar de un único parque de servidores.Así que al final el sueño de Berners Lee:la web semántica y la inteligencia artificial será una realidad.Así que en el 2030 terminaremos terminados por el Skynet.Hasta entonces...;-)</target>
        </trans-unit>
        <trans-unit id="34698ed4c6b87bbba6909fe832abf0a97a18c1e4" translate="yes" xml:space="preserve">
          <source>REST defines 6 architectural constraints which make any web service &amp;ndash; a &lt;strong&gt;true RESTful API&lt;/strong&gt;.</source>
          <target state="translated">REST define 6 restricciones arquitect&amp;oacute;nicas que hacen que cualquier servicio web sea una &lt;strong&gt;verdadera API RESTful&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2b8ff55c8c9a0ce9cfafc137b16baaa14a81abbf" translate="yes" xml:space="preserve">
          <source>REST in official words, REST is an architectural style built on certain principles using the current &amp;ldquo;Web&amp;rdquo; fundamentals.
There are 5 basic fundamentals of web which are leveraged to create REST services.</source>
          <target state="translated">REST en palabras oficiales, REST es un estilo arquitect&amp;oacute;nico construido sobre ciertos principios utilizando los fundamentos actuales de la &quot;Web&quot;. Hay 5 fundamentos b&amp;aacute;sicos de la web que se aprovechan para crear servicios REST.</target>
        </trans-unit>
        <trans-unit id="24e5aabd86f26882f23d01381f1a89f3a170449f" translate="yes" xml:space="preserve">
          <source>REST is a lightweight alternative to mechanisms like RPC (Remote
  Procedure Calls) and Web Services (SOAP, WSDL, et al.). Later, we will
  see how much more simple REST is.</source>
          <target state="translated">REST es una alternativa ligera a mecanismos como RPC (Remote Procedure Calls)y Web Services (SOAP,WSDL,et al.).Más tarde,veremos lo mucho más simple que es REST.</target>
        </trans-unit>
        <trans-unit id="41d578dc3834d7de2f8d99a70b26c5ce81a848f5" translate="yes" xml:space="preserve">
          <source>REST is an &lt;em&gt;architecture style&lt;/em&gt; for designing networked applications.
  The idea is that, rather than using complex mechanisms such as CORBA,
  RPC or SOAP to connect between machines, simple HTTP is used to make
  calls between machines.</source>
          <target state="translated">REST es un &lt;em&gt;estilo de arquitectura&lt;/em&gt; para dise&amp;ntilde;ar aplicaciones en red. La idea es que, en lugar de utilizar mecanismos complejos como CORBA, RPC o SOAP para conectarse entre m&amp;aacute;quinas, se use HTTP simple para hacer llamadas entre m&amp;aacute;quinas.</target>
        </trans-unit>
        <trans-unit id="81954ff90e3db76a59f3feac17fcae16db3073fb" translate="yes" xml:space="preserve">
          <source>REST is an architectural pattern and style of writing distributed applications. It is not a programming style in the narrow sense.</source>
          <target state="translated">REST es un patrón arquitectónico y un estilo de escribir aplicaciones distribuidas.No es un estilo de programación en el sentido estricto.</target>
        </trans-unit>
        <trans-unit id="6e3584ec485599f05ec62cb2d6b674b68d8c649a" translate="yes" xml:space="preserve">
          <source>REST is an architecture style for designing networked applications.
  The idea is that, rather than using complex mechanisms such as CORBA,
  RPC or SOAP to connect between machines, simple HTTP is used to make
  calls between machines.</source>
          <target state="translated">REST es un estilo de arquitectura para diseñar aplicaciones en red.La idea es que,en lugar de utilizar mecanismos complejos como CORBA,RPC o SOAP para conectar entre máquinas,se utiliza un simple HTTP para hacer llamadas entre máquinas.</target>
        </trans-unit>
        <trans-unit id="6663bc679f3ecc9321597d4c451eda8a030d5e82" translate="yes" xml:space="preserve">
          <source>REST is often used in mobile applications, social networking Web sites, mashup tools and automated business processes. The REST style emphasizes that interactions between clients and services is enhanced by having a limited number of operations (verbs). Flexibility is provided by assigning resources (nouns) their own unique universal resource indicators (URIs).</source>
          <target state="translated">El REST se utiliza a menudo en aplicaciones móviles,sitios web de redes sociales,herramientas de &quot;mashup&quot; y procesos comerciales automatizados.El estilo REST hace hincapié en que la interacción entre los clientes y los servicios se mejora mediante un número limitado de operaciones (verbos).La flexibilidad se obtiene asignando a los recursos (sustantivos)sus propios y exclusivos indicadores universales de recursos (URI).</target>
        </trans-unit>
        <trans-unit id="801d3af1b3e139b50282c4fab565cd444620074b" translate="yes" xml:space="preserve">
          <source>REST is using the various HTTP methods (mainly GET/PUT/DELETE) to manipulate data.</source>
          <target state="translated">REST utiliza los diversos métodos HTTP (principalmente GETPUTDELETE)para manipular los datos.</target>
        </trans-unit>
        <trans-unit id="3a544da22b9e3f4d834aba2d28e038cfc7c394d2" translate="yes" xml:space="preserve">
          <source>REST messages often accepts the form either in form of XML, or JavaScript Object Notation (JSON).</source>
          <target state="translated">Los mensajes REST a menudo aceptan la forma ya sea en forma de XML,o de JavaScript Object Notation (JSON).</target>
        </trans-unit>
        <trans-unit id="ec356ddaca2bf110584184b56abbca5c18c7f324" translate="yes" xml:space="preserve">
          <source>REST proponents tend to favor URLs, such as</source>
          <target state="translated">Los partidarios de REST tienden a favorecer los URLs,tales como</target>
        </trans-unit>
        <trans-unit id="cdaffecf9a4b409c44dd9af81374c459b9474d48" translate="yes" xml:space="preserve">
          <source>REST stands for &quot;representational state transfer&quot;, which means it's all about communicating and modifying &lt;strong&gt;the state&lt;/strong&gt; of some resource in a system.</source>
          <target state="translated">REST significa &quot;transferencia de estado representacional&quot;, lo que significa que se trata de comunicar y modificar &lt;strong&gt;el estado&lt;/strong&gt; de alg&amp;uacute;n recurso en un sistema.</target>
        </trans-unit>
        <trans-unit id="9451e5791b00a17503496c3f9586128ae49e1831" translate="yes" xml:space="preserve">
          <source>REST stands for Representational State Transfer. (It is sometimes
  spelled &quot;ReST&quot;.) It relies on a stateless, client-server, cacheable
  communications protocol -- and in virtually all cases, the HTTP
  protocol is used.</source>
          <target state="translated">REST es la sigla de Representational State Transfer.(A veces se escribe &quot;ReST&quot;.)Se basa en un protocolo de comunicaciones sin estado,cliente-servidor,en caché-y en casi todos los casos,se utiliza el protocolo HTTP.</target>
        </trans-unit>
        <trans-unit id="3d1d7194413fe6b5bd76ca3ce8b73781e5ea0578" translate="yes" xml:space="preserve">
          <source>REST unlike home styles has had a tough time being consistently and practically applied. This may have been intentional. Leaving its actual implementation up to the designer. So you are free to do what you want so as long as you meet the constraints set out in the dissertation you are creating REST Systems.</source>
          <target state="translated">El descanso,a diferencia de los estilos caseros,ha sido difícil de aplicar de forma consistente y práctica.Esto puede haber sido intencional.Dejando su implementación real al diseñador.Así que es libre de hacer lo que quiera siempre y cuando cumpla con las restricciones establecidas en la disertación que está creando REST Systems.</target>
        </trans-unit>
        <trans-unit id="4ac191e5aa73c941d92cf5c5a7bdc101ccf17488" translate="yes" xml:space="preserve">
          <source>REST, operates on resource representations, each one identified by an URL. These are typically not data objects, but &lt;strong&gt;complex objects abstractions&lt;/strong&gt;.</source>
          <target state="translated">REST, opera en representaciones de recursos, cada una identificada por una URL. Por lo general, no son objetos de datos, sino &lt;strong&gt;abstracciones de objetos complejos&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="20bbdde9c5678f79d072b94099e0cd21aa108d71" translate="yes" xml:space="preserve">
          <source>REST: Representational State Transfer.</source>
          <target state="translated">DESCANSA:Transferencia del Estado Representativo.</target>
        </trans-unit>
        <trans-unit id="0b418318f4f02e384e5a14b7c46def85c5fbf491" translate="yes" xml:space="preserve">
          <source>RESTful applications use HTTP requests to post data (create and/or
  update), read data (e.g., make queries), and delete data. Thus, REST
  uses HTTP for all four CRUD (Create/Read/Update/Delete) operations.</source>
          <target state="translated">Las aplicaciones RESTful utilizan las solicitudes HTTP para publicar datos (crear ando o actualizar),leer datos (por ejemplo,hacer consultas)y eliminar datos.Así,REST usa HTTP para las cuatro operaciones CRUD (CreateReadUpdateDelete).</target>
        </trans-unit>
        <trans-unit id="d1feb4628e89cf3c408102d8d1c78190e38e6958" translate="yes" xml:space="preserve">
          <source>RESTful programming conforms to Web architecture design and, if properly implemented, it allows you to take the full advantage of scalable Web infrastructure.</source>
          <target state="translated">La programación RESTful se ajusta al diseño de la arquitectura de la Web y,si se implementa correctamente,permite aprovechar al máximo la infraestructura escalable de la Web.</target>
        </trans-unit>
        <trans-unit id="606ada79ad1420f9107ba76e74d9a5b5dc8a1dc1" translate="yes" xml:space="preserve">
          <source>RESTful programming is about:</source>
          <target state="translated">La programación de RESTful está a punto:</target>
        </trans-unit>
        <trans-unit id="95c224223718abd56088ba177080385db881b4c6" translate="yes" xml:space="preserve">
          <source>RESTful programming is not for APIs</source>
          <target state="translated">La programación RESTful no es para las APIs</target>
        </trans-unit>
        <trans-unit id="1b6a739654e06f630f96467756d48d1acd0d09d0" translate="yes" xml:space="preserve">
          <source>Rather than using a specific URL to delete a method (say, &lt;code&gt;/user/123/delete&lt;/code&gt;), you would send a DELETE request to the &lt;code&gt;/user/[id]&lt;/code&gt; URL, to edit a user, to retrieve info on a user you send a GET request to &lt;code&gt;/user/[id]&lt;/code&gt;</source>
          <target state="translated">En lugar de utilizar una URL espec&amp;iacute;fica para eliminar un m&amp;eacute;todo (por ejemplo, &lt;code&gt;/user/123/delete&lt;/code&gt; ), debe enviar una solicitud DELETE a la URL &lt;code&gt;/user/[id]&lt;/code&gt; , para editar un usuario, para recuperar informaci&amp;oacute;n sobre un usuario que env&amp;iacute;e una solicitud GET a &lt;code&gt;/user/[id]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d997a652dd80f71fb70e3ef43e6973ddd897ea7" translate="yes" xml:space="preserve">
          <source>Representation - all communication is done by representation (e.g. &lt;a href=&quot;http://en.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;)</source>
          <target state="translated">Representaci&amp;oacute;n: toda la comunicaci&amp;oacute;n se realiza por representaci&amp;oacute;n (por ejemplo, &lt;a href=&quot;http://en.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="2cd1d833a928d3195b51e6cfbe331c8c09c671dd" translate="yes" xml:space="preserve">
          <source>Resource (data, information).</source>
          <target state="translated">Recurso (datos,información).</target>
        </trans-unit>
        <trans-unit id="688688c5509b4d381bf4bce90f16794ddee6aacb" translate="yes" xml:space="preserve">
          <source>Resources are requested via URLs.</source>
          <target state="translated">Los recursos se solicitan a través de los URL.</target>
        </trans-unit>
        <trans-unit id="c171c3ae71443c15b078bb93540e67b075abe63a" translate="yes" xml:space="preserve">
          <source>Richardson's Maturity Model</source>
          <target state="translated">El modelo de madurez de Richardson</target>
        </trans-unit>
        <trans-unit id="07bef3db6d8f0a971b46410592e99f25edb3d822" translate="yes" xml:space="preserve">
          <source>Roy Fielding, who coined the term, says &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIs must be hypertext-driven&lt;/a&gt;.  In particular, &quot;A REST API must not define fixed resource names or hierarchies&quot;.</source>
          <target state="translated">Roy Fielding, quien acu&amp;ntilde;&amp;oacute; el t&amp;eacute;rmino, dice que las &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;API REST deben estar impulsadas por el hipertexto&lt;/a&gt; . En particular, &quot;Una API REST no debe definir nombres de recursos fijos o jerarqu&amp;iacute;as&quot;.</target>
        </trans-unit>
        <trans-unit id="4ed7f7fd296ad882c584b68eec97a766f06c9204" translate="yes" xml:space="preserve">
          <source>Roy himself cleared it &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Roy mismo lo aclar&amp;oacute; &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea8f1dff43bf90df7c15069182244296157f5ccf" translate="yes" xml:space="preserve">
          <source>Saying that Rest is just a syntactic change from using GET requests with an action parameter to using the available http verbs makes it look like it has no benefits and is purely cosmetic. The point is to use a language that can be understood and optimized by every part of the chain. If your GET operation has an action with side effects, you have to skip all HTTP caching or you'll end up with inconsistent results.</source>
          <target state="translated">Decir que el Descanso es sólo un cambio sintáctico de usar peticiones GET con un parámetro de acción a usar los verbos http disponibles hace que parezca que no tiene beneficios y es puramente cosmético.El punto es usar un lenguaje que pueda ser entendido y optimizado por cada parte de la cadena.Si tu operación GET tiene una acción con efectos secundarios,tienes que saltarte todo el caching HTTP o acabarás con resultados inconsistentes.</target>
        </trans-unit>
        <trans-unit id="c4a2bd1212341d753b25f32677d4e7adf44e6015" translate="yes" xml:space="preserve">
          <source>Saying you use the REST style is similar to saying that you built a house in a particular style: for example Tudor or Victorian.  Both REST as an software style and Tudor or Victorian as a home style can be defined by the qualities and constraints that make them up. For example REST must have Client Server separation where messages are self-describing. Tudor style homes have Overlapping gables and Roofs that are steeply pitched with front facing gables. You can read Roy's dissertation to learn more about the constraints and qualities that make up REST.</source>
          <target state="translated">Decir que usas el estilo REST es similar a decir que construiste una casa en un estilo particular:por ejemplo Tudor o Victoriano.Tanto el estilo REST como estilo de software como el Tudor o Victoriano como estilo de casa pueden ser definidos por las cualidades y restricciones que los componen.Por ejemplo,REST debe tener una separación entre el Cliente y el Servidor,donde los mensajes se describen a sí mismos.Las casas de estilo Tudor tienen gabletes superpuestos y techos que están empinadas con gabletes orientados hacia el frente.Puedes leer la disertación de Roy para aprender más sobre las restricciones y cualidades que componen REST.</target>
        </trans-unit>
        <trans-unit id="8e446171e587e12eabf8b79616dc1eb91a5a4557" translate="yes" xml:space="preserve">
          <source>See Martin Fowlers article the &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;Richardson Maturity Model&lt;/a&gt; (RMM) for an explanation on what an RESTful service is.</source>
          <target state="translated">Consulte el art&amp;iacute;culo de Martin Fowlers, el &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;Modelo de madurez de Richardson&lt;/a&gt; (RMM) para obtener una explicaci&amp;oacute;n sobre qu&amp;eacute; es un servicio RESTful.</target>
        </trans-unit>
        <trans-unit id="fbe751100f5c892656ce1ca4a6009c25fbfc7f4b" translate="yes" xml:space="preserve">
          <source>Select content-Header</source>
          <target state="translated">Selecciona el contenido del encabezado</target>
        </trans-unit>
        <trans-unit id="16ed5c31752ac3f8db0119aea87a82b307c230ed" translate="yes" xml:space="preserve">
          <source>Select the REST method</source>
          <target state="translated">Seleccione el método REST</target>
        </trans-unit>
        <trans-unit id="c0c99a62016d0168acb95e1b7c7865a1070d884a" translate="yes" xml:space="preserve">
          <source>So if your &quot;/user/123&quot; path is hardcoded on the client, it's not really RESTful.  A good use of HTTP, maybe, maybe not.  But not RESTful.  It has to come from hypertext.</source>
          <target state="translated">Así que si tu ruta &quot;user123&quot; está codificada en el cliente,no es realmente RESTANTE.Un buen uso de HTTP,tal vez,tal vez no.Pero no es RESTful.Tiene que venir del hipertexto.</target>
        </trans-unit>
        <trans-unit id="536946ca2831340799bf33cd36af457db31978e1" translate="yes" xml:space="preserve">
          <source>So it does not work with for example PUB/SUB sockets, it is based on REQ/REP.</source>
          <target state="translated">Así que no funciona con,por ejemplo,los enchufes PUBSUB,se basa en REQREP.</target>
        </trans-unit>
        <trans-unit id="cb3acf66e66e8ac82b059d304608e2b649d07fd9" translate="yes" xml:space="preserve">
          <source>So the server does not maintain the states of the clients. This means that you cannot use server a side session storage and you have to authenticate every request. Your clients possibly send basic auth headers through an encrypted connection. (By large applications it is hard to maintain many sessions.)</source>
          <target state="translated">Así que el servidor no mantiene los estados de los clientes.Esto significa que no puede utilizar el servidor un almacenamiento de sesión lateral y tiene que autenticar cada solicitud.Tus clientes posiblemente envían cabeceras de autenticación básicas a través de una conexión encriptada.(Por las grandes aplicaciones es difícil mantener muchas sesiones).</target>
        </trans-unit>
        <trans-unit id="9607344c01bb579773361b71bbb45cde205cc658" translate="yes" xml:space="preserve">
          <source>So you don't have to serve the same requests again and again.</source>
          <target state="translated">Así que no tienes que servir las mismas peticiones una y otra vez.</target>
        </trans-unit>
        <trans-unit id="6755df0f56ac5cee70d67ea5c025e47782da8d98" translate="yes" xml:space="preserve">
          <source>State transition controls only make sense if the client and server agree upon a media type representation of the resource.  Otherwise there's no way to know what's a control and what isn't and how to execute a control.  IE if browsers didn't know &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags in html then there'd be nothing for you to submit to transition state in your browser.</source>
          <target state="translated">Los controles de transici&amp;oacute;n de estado solo tienen sentido si el cliente y el servidor acuerdan una representaci&amp;oacute;n de tipo de medio del recurso. De lo contrario, no hay forma de saber qu&amp;eacute; es un control y qu&amp;eacute; no lo es, y c&amp;oacute;mo ejecutar un control. Es decir, si los navegadores no conoc&amp;iacute;an las etiquetas &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; en html, entonces no habr&amp;iacute;a nada que enviar al estado de transici&amp;oacute;n en su navegador.</target>
        </trans-unit>
        <trans-unit id="cc782a4dc89d3cf79cc09c506daf5966811372c9" translate="yes" xml:space="preserve">
          <source>Stateless</source>
          <target state="translated">Stateless</target>
        </trans-unit>
        <trans-unit id="c2fa7bc4bb797a9f80155f336549e20f8ae9f995" translate="yes" xml:space="preserve">
          <source>Steps to Automate REST API</source>
          <target state="translated">Pasos para automatizar la API de REST</target>
        </trans-unit>
        <trans-unit id="266d1df5b50f526d563a69c1948ed69ee2a31597" translate="yes" xml:space="preserve">
          <source>Structured URLs and Http Methods/Verbs are not the definition of
restful programming.</source>
          <target state="translated">Las URLs estructuradas y los métodos HttpVerbs no son la definición de una programación descansada.</target>
        </trans-unit>
        <trans-unit id="8f7198c3c2d3db3f7cabeab606f0ec990cba16f4" translate="yes" xml:space="preserve">
          <source>That xfront document explains the difference between REST and SOAP, and this is really helpful too. When Fielding says, &quot;&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;That is RPC. It screams RPC.&lt;/a&gt;&quot;, it's clear that RPC is not RESTful, so it's useful to see the exact reasons for this. (SOAP is a type of RPC.)</source>
          <target state="translated">Ese documento de xfront explica la diferencia entre REST y SOAP, y esto tambi&amp;eacute;n es realmente &amp;uacute;til. Cuando Fielding dice: &quot; &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Eso es RPC. Grita RPC&lt;/a&gt; &quot;, est&amp;aacute; claro que RPC no es RESTful, por lo que es &amp;uacute;til ver las razones exactas de esto. (SOAP es un tipo de RPC).</target>
        </trans-unit>
        <trans-unit id="11640c3d32a9a0b61aeecdb5c9ad7a185581310a" translate="yes" xml:space="preserve">
          <source>The HATEOAS constraint is an acronym
  for Hypermedia as the Engine of
  Application State. This principle is
  the key differentiator between a REST
  and most other forms of client server
  system.</source>
          <target state="translated">La restricción HATEOAS es un acrónimo de Hypermedia como el motor del estado de aplicación.Este principio es el diferenciador clave entre un sistema REST y la mayoría de las otras formas de sistema cliente-servidor.</target>
        </trans-unit>
        <trans-unit id="6a4c43170c5294cf2068284ddf81b0942eff7050" translate="yes" xml:space="preserve">
          <source>The PUT, GET, POST and DELETE methods are typical used in REST based architectures. The following table gives an explanation of these operations.</source>
          <target state="translated">Los métodos PUT,GET,POST y DELETE son típicos de las arquitecturas basadas en REST.La siguiente tabla da una explicación de estas operaciones.</target>
        </trans-unit>
        <trans-unit id="debfff33bf7e7352ae30422dd3def567e5f7259f" translate="yes" xml:space="preserve">
          <source>The REST constraints are the following:</source>
          <target state="translated">Las restricciones de REST son las siguientes:</target>
        </trans-unit>
        <trans-unit id="363845c5633e5276f4ad26162098f583201cc8cf" translate="yes" xml:space="preserve">
          <source>The REST system is composed of hierarchical layers. Each layer contains components which use the services of components which are in the next layer below. So you can add new layers and components effortless.</source>
          <target state="translated">El sistema REST está compuesto de capas jerárquicas.Cada capa contiene componentes que utilizan los servicios de los componentes que están en la siguiente capa.Así que puedes añadir nuevas capas y componentes sin esfuerzo.</target>
        </trans-unit>
        <trans-unit id="5aaa535e7837eae3a4f80e39cfc9d687c46ea8d0" translate="yes" xml:space="preserve">
          <source>The answer is very simple, there is a &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;dissertation&lt;/a&gt; written by Roy Fielding.]&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;1&lt;/a&gt; In that dissertation he defines the REST principles. If an application fulfills all of those principles, then that is a REST application.</source>
          <target state="translated">La respuesta es muy simple, hay una &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;disertaci&amp;oacute;n&lt;/a&gt; escrita por Roy Fielding.] &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;1&lt;/a&gt; En esa disertaci&amp;oacute;n define los principios REST. Si una aplicaci&amp;oacute;n cumple con todos esos principios, entonces es una aplicaci&amp;oacute;n REST.</target>
        </trans-unit>
        <trans-unit id="4f20d992e77c2fef0f2a4c004149838f65239268" translate="yes" xml:space="preserve">
          <source>The contract between the client and the server is not maintained by the server. In other words the client must be decoupled from the implementation of the service. You can reach this state by using standard solutions, like the IRI (URI) standard to identify resources, the HTTP standard to exchange messages, standard MIME types to describe the body serialization format, metadata (possibly RDF vocabs, microformats, etc.) to describe the semantics of different parts of the message body. To decouple the IRI structure from the client, you have to send hyperlinks to the clients in hypermedia formats like (HTML, JSON-LD, HAL, etc.). So a client can use the metadata (possibly link relations, RDF vocabs) assigned to the hyperlinks to navigate the state machine of the application through the proper state transitions in order to achieve its current goal.</source>
          <target state="translated">El contrato entre el cliente y el servidor no es mantenido por el servidor.En otras palabras,el cliente debe ser desacoplado de la implementación del servicio.Se puede llegar a este estado utilizando soluciones estándar,como el estándar IRI (URI)para identificar recursos,el estándar HTTP para intercambiar mensajes,los tipos MIME estándar para describir el formato de serialización del cuerpo,los metadatos (posiblemente RDF vocabs,microformatos,etc.)para describir la semántica de las diferentes partes del cuerpo del mensaje.Para desacoplar la estructura del IRI del cliente,hay que enviar hipervínculos a los clientes en formatos hipermedia como (HTML,JSON-LD,HAL,etc.).Así,un cliente puede utilizar los metadatos (posiblemente relaciones de enlace,vocabs RDF)asignados a los hipervínculos para navegar por la máquina de estado de la aplicación a través de las transiciones de estado adecuadas para lograr su objetivo actual.</target>
        </trans-unit>
        <trans-unit id="5eac8561aeea8b795c8a15b197b4655d18a46b3e" translate="yes" xml:space="preserve">
          <source>The entire web is based on REST (or REST was based on the web). Therefore as a web developer you might want aware of that although it's not necessary to write good web apps.</source>
          <target state="translated">Toda la web está basada en REST (o REST se basó en la web).Por lo tanto,como desarrollador web,deberías saber que aunque no es necesario escribir buenas aplicaciones web.</target>
        </trans-unit>
        <trans-unit id="c7820ce4adf25178f490423f73f586fe8480e441" translate="yes" xml:space="preserve">
          <source>The last one is probably the most important in terms of consequences and overall effectiveness of REST. Overall, most of the RESTful discussions seem to center on HTTP and its usage from a browser and what not. I understand that R. Fielding coined the term when he described the architecture and decisions that lead to HTTP. His thesis is more about the architecture and cache-ability of resources than it is about HTTP.</source>
          <target state="translated">La última es probablemente la más importante en términos de consecuencias y eficacia general de REST.En general,la mayoría de las discusiones sobre REST parecen centrarse en el HTTP y su uso desde un navegador y lo que no.Entiendo que R.Fielding acuñó el término cuando describió la arquitectura y las decisiones que conducen a HTTP.Su tesis es más sobre la arquitectura y la capacidad de almacenamiento de los recursos que sobre HTTP.</target>
        </trans-unit>
        <trans-unit id="b32979991407cd39a66f760547c127248522b7ba" translate="yes" xml:space="preserve">
          <source>The last thing that you&amp;rsquo;ll often here about RESTful architectures is that they are layered. We have actually already been implicitly discussing this requirement in our discussion of the interaction between the client and server. Basically, this means that each layer in our system interacts only with adjacent layers. So in our discussion, the client layer interacts with our server layer (and vice versa), but there might be other server layers that help the primary server process a request that the client does not directly communicate with. Rather, the server passes on the request as necessary.</source>
          <target state="translated">Lo &amp;uacute;ltimo que a menudo encontrar&amp;aacute;s aqu&amp;iacute; sobre las arquitecturas RESTful es que est&amp;aacute;n en capas. De hecho, ya hemos estado discutiendo impl&amp;iacute;citamente este requisito en nuestra discusi&amp;oacute;n sobre la interacci&amp;oacute;n entre el cliente y el servidor. B&amp;aacute;sicamente, esto significa que cada capa en nuestro sistema interact&amp;uacute;a solo con capas adyacentes. Entonces, en nuestra discusi&amp;oacute;n, la capa del cliente interact&amp;uacute;a con nuestra capa del servidor (y viceversa), pero puede haber otras capas del servidor que ayudan al servidor primario a procesar una solicitud con la que el cliente no se comunica directamente. Por el contrario, el servidor pasa la solicitud seg&amp;uacute;n sea necesario.</target>
        </trans-unit>
        <trans-unit id="3ad594a4eee6f4393aea9d6f9c591653f6d82996" translate="yes" xml:space="preserve">
          <source>The many much better answers on this very page.</source>
          <target state="translated">Las muchas y mejores respuestas en esta misma página.</target>
        </trans-unit>
        <trans-unit id="f34a56b5b9cc5fb499cc45ca49da52dec1ae7242" translate="yes" xml:space="preserve">
          <source>The most obvious requirement is that there needs to be a universal language of some sort so that the server can tell the client what it is trying to do with the request and for the server to respond.</source>
          <target state="translated">El requisito más obvio es que debe existir un lenguaje universal de algún tipo para que el servidor pueda decirle al cliente lo que está tratando de hacer con la solicitud y para que el servidor responda.</target>
        </trans-unit>
        <trans-unit id="c1949f81259fdfb5a99b7b1901beff7c9ea4dc3c" translate="yes" xml:space="preserve">
          <source>The point of rest is that if we agree to use a common language for basic operations (the http verbs), the infrastructure can be configured to understand them and optimize them properly, for example, by making use of caching headers to implement caching at all levels.</source>
          <target state="translated">El punto de partida es que si acordamos utilizar un lenguaje común para las operaciones básicas (los verbos http),la infraestructura puede configurarse para entenderlas y optimizarlas adecuadamente,por ejemplo,haciendo uso de los encabezamientos de cacheo para implementar el cacheo a todos los niveles.</target>
        </trans-unit>
        <trans-unit id="adcd5a6756875181e58c7a89806bd16236c307a3" translate="yes" xml:space="preserve">
          <source>The server responds:</source>
          <target state="translated">El servidor responde:</target>
        </trans-unit>
        <trans-unit id="d84fe7aa11f8f900fefc9b179edc3003cd01912b" translate="yes" xml:space="preserve">
          <source>There is not such notion as &quot;RESTful programming&quot; per se. It would be better called RESTful paradigm or even better RESTful architecture. It is not a programming language. It is a paradigm.</source>
          <target state="translated">No existe la noción de &quot;programación descansada&quot; per se.Sería mejor llamarlo paradigma RESTful o incluso mejor arquitectura RESTful.No es un lenguaje de programación.Es un paradigma.</target>
        </trans-unit>
        <trans-unit id="86c7098a4bc3a5c3742a2441c8884a81a07a366c" translate="yes" xml:space="preserve">
          <source>There's a fairly good example here:</source>
          <target state="translated">Hay un ejemplo bastante bueno aquí:</target>
        </trans-unit>
        <trans-unit id="905d4728fcc1cb89a5cb1a3e73d508f59109d989" translate="yes" xml:space="preserve">
          <source>Therefore, we impose the restriction that each request-response pair between the client and the server is independent, meaning that the server doesn&amp;rsquo;t have to remember anything about previous requests (previous states of the client-server interaction) to respond to a new request. This means that we want our interactions to be stateless.</source>
          <target state="translated">Por lo tanto, imponemos la restricci&amp;oacute;n de que cada par de solicitud-respuesta entre el cliente y el servidor es independiente, lo que significa que el servidor no tiene que recordar nada sobre solicitudes anteriores (estados anteriores de la interacci&amp;oacute;n cliente-servidor) para responder a un nuevo solicitud. Esto significa que queremos que nuestras interacciones sean ap&amp;aacute;tridas.</target>
        </trans-unit>
        <trans-unit id="2a100f405ce7bcd9b4b68b83fcd25889ccf5143e" translate="yes" xml:space="preserve">
          <source>This constraint is optional. For example you can send a parser for a specific media type to the client, and so on... In order to do this you might need a standard plugin loader system in the client, or your client will be coupled to the plugin loader solution.</source>
          <target state="translated">Esta restricción es opcional.Por ejemplo,puede enviar un analizador para un tipo de medio específico al cliente,y así sucesivamente...Para hacer esto puede que necesites un sistema de carga de plugins estándar en el cliente,o tu cliente se acoplará a la solución de carga de plugins.</target>
        </trans-unit>
        <trans-unit id="a433790865d58bd8f02ff1f47ffaf65f408a91fa" translate="yes" xml:space="preserve">
          <source>This is amazingly long &quot;discussion&quot; and yet quite confusing to say the least.</source>
          <target state="translated">Esta es una &quot;discusión&quot; sorprendentemente larga y sin embargo bastante confusa,por decir algo.</target>
        </trans-unit>
        <trans-unit id="03de43a18514c80205249c972ff6f45137f701c5" translate="yes" xml:space="preserve">
          <source>This is taken from the excellent book &lt;em&gt;Core JavaServer faces&lt;/em&gt; book by David M. Geary.</source>
          <target state="translated">Esto est&amp;aacute; tomado del excelente libro &lt;em&gt;Core JavaServer enfrenta el&lt;/em&gt; libro de David M. Geary.</target>
        </trans-unit>
        <trans-unit id="f84a19d4bf6f78ec8c5e5044a550ad4a25f94cc7" translate="yes" xml:space="preserve">
          <source>This is very less mentioned everywhere but the &lt;strong&gt;Richardson's Maturity Model&lt;/strong&gt; is one of the best methods to actually judge how Restful is one's API. More about it here:</source>
          <target state="translated">Esto se menciona mucho menos en todas partes, pero el &lt;strong&gt;Modelo de madurez de Richardson&lt;/strong&gt; es uno de los mejores m&amp;eacute;todos para juzgar qu&amp;eacute; tan relajante es la API de uno. M&amp;aacute;s sobre esto aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="d0c1d3305c31f371cda13faed5816c6263e72163" translate="yes" xml:space="preserve">
          <source>This is what it might look like.</source>
          <target state="translated">Esto es lo que podría parecer.</target>
        </trans-unit>
        <trans-unit id="d9c095fa6595fd926bd9860ca44ab7d426923a2d" translate="yes" xml:space="preserve">
          <source>To be RESTful a Service needs to fulfill the &lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot;&gt;Hypermedia as the Engine of Application State. (HATEOAS)&lt;/a&gt;, that is, it needs to reach level 3 in the RMM, &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;read the article&lt;/a&gt; for details or the &lt;a href=&quot;http://www.crummy.com/writing/speaking/2008-QCon/act3.html&quot;&gt;slides from the qcon talk&lt;/a&gt;.</source>
          <target state="translated">Para estar RESTANTE, un Servicio necesita cumplir con el &lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot;&gt;Hypermedia como el Motor del Estado de la Aplicaci&amp;oacute;n.&lt;/a&gt; (HATEOAS) , es decir, necesita alcanzar el nivel 3 en el RMM, &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;lea el art&amp;iacute;culo&lt;/a&gt; para obtener detalles o las &lt;a href=&quot;http://www.crummy.com/writing/speaking/2008-QCon/act3.html&quot;&gt;diapositivas de la charla de qcon&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43e0b98e4c9a963450bac2bcfe7ffa0f28070108" translate="yes" xml:space="preserve">
          <source>To be a restful programmer you must be trying to build applications that allow actors to do things.  Not just exposing the database.</source>
          <target state="translated">Para ser un programador tranquilo debes intentar construir aplicaciones que permitan a los actores hacer cosas.No sólo exponiendo la base de datos.</target>
        </trans-unit>
        <trans-unit id="88f5ecedd3cc21540bbf662f89334d1c596c1065" translate="yes" xml:space="preserve">
          <source>To further ease the strain on our server from redoing computations that have already been recently done for a given client, REST also allows caching. Basically, caching means to take a snapshot of the initial response provided to the client. If the client makes the same request again, the server can provide the client with the snapshot rather than redo all of the computations that were necessary to create the initial response. However, since it is a snapshot, if the snapshot has not expired--the server sets an expiration time in advance--and the response has been updated since the initial cache (i.e. the request would give a different answer than the cached response), the client will not see the updates until the cache expires (or the cache is cleared) and the response is rendered from scratch again.</source>
          <target state="translated">Para aliviar aún más la tensión en nuestro servidor de rehacer los cálculos que ya se han hecho recientemente para un cliente determinado,REST también permite el caching.Básicamente,el caching significa tomar una instantánea de la respuesta inicial proporcionada al cliente.Si el cliente vuelve a hacer la misma petición,el servidor puede proporcionarle la instantánea en lugar de rehacer todos los cálculos que fueron necesarios para crear la respuesta inicial.Sin embargo,como se trata de una instantánea,si la instantánea no ha caducado -el servidor establece un tiempo de caducidad por anticipado-y la respuesta se ha actualizado desde el caché inicial (es decir,la solicitud daría una respuesta diferente a la respuesta almacenada en caché),el cliente no verá las actualizaciones hasta que el caché caduque (o se vacíe el caché)y se vuelva a dar la respuesta desde cero.</target>
        </trans-unit>
        <trans-unit id="3cda008b284e93ee83d27ce556b7f274c5401681" translate="yes" xml:space="preserve">
          <source>To modify the record (&lt;code&gt;lname&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; will remain unchanged):</source>
          <target state="translated">Para modificar el registro ( &lt;code&gt;lname&lt;/code&gt; y &lt;code&gt;age&lt;/code&gt; permanecer&amp;aacute;n sin cambios):</target>
        </trans-unit>
        <trans-unit id="2d8872fdf4d794b725b02d84014a91227ec2afee" translate="yes" xml:space="preserve">
          <source>To update the record (and consequently &lt;code&gt;lname&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; will be NULL):</source>
          <target state="translated">Para actualizar el registro (y, en consecuencia, &lt;code&gt;lname&lt;/code&gt; y &lt;code&gt;age&lt;/code&gt; ser&amp;aacute;n NULL):</target>
        </trans-unit>
        <trans-unit id="749827b57c3b48ad912ed3c35f6d888c6b320fd8" translate="yes" xml:space="preserve">
          <source>To use API manually, we can use browser based REST API plugins.</source>
          <target state="translated">Para usar la API de forma manual,podemos usar los plugins de la API de REST basados en el navegador.</target>
        </trans-unit>
        <trans-unit id="cd51d0a7c8a456561603688f8e9d8841d8aeb252" translate="yes" xml:space="preserve">
          <source>Uniform interface</source>
          <target state="translated">Interfaz uniforme</target>
        </trans-unit>
        <trans-unit id="36445d1f62b3461271018e22e6c63b0da668d74c" translate="yes" xml:space="preserve">
          <source>We also know that we can change existing data:</source>
          <target state="translated">También sabemos que podemos cambiar los datos existentes:</target>
        </trans-unit>
        <trans-unit id="2da0745a731ffea22c1d0cd224d20dec310fb399" translate="yes" xml:space="preserve">
          <source>We can tell a lot from this response. For instance, we now know we can create a new user by &lt;code&gt;POST&lt;/code&gt;ing to &lt;code&gt;/user&lt;/code&gt;:</source>
          <target state="translated">Podemos decir mucho de esta respuesta. Por ejemplo, ahora sabemos que podemos crear un nuevo usuario &lt;code&gt;POST&lt;/code&gt; en &lt;code&gt;/user&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5441c7839fa6d73dff04b1a5f493f5e5d31a22e7" translate="yes" xml:space="preserve">
          <source>We know from the description of our media that we can find information about related resources from sections called &quot;links&quot;. This is called &lt;em&gt;Hypermedia controls&lt;/em&gt;. In this case, we can tell from such a section that we can find a user list by making another request for &lt;code&gt;/user&lt;/code&gt;:</source>
          <target state="translated">Sabemos por la descripci&amp;oacute;n de nuestros medios que podemos encontrar informaci&amp;oacute;n sobre recursos relacionados en secciones llamadas &quot;enlaces&quot;. Esto se llama &lt;em&gt;controles hipermedia&lt;/em&gt; . En este caso, podemos deducir de dicha secci&amp;oacute;n que podemos encontrar una lista de usuarios haciendo otra solicitud para &lt;code&gt;/user&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dbe152bcc052ff53fb476d5537d8e4e55bdd8dee" translate="yes" xml:space="preserve">
          <source>What exactly is RESTful programming</source>
          <target state="translated">¿Qué es exactamente la programación de RESTful</target>
        </trans-unit>
        <trans-unit id="600b595c92145112ec54443d94bd4487770f5001" translate="yes" xml:space="preserve">
          <source>What exactly is RESTful programming?</source>
          <target state="translated">¿Qué es exactamente la programación de RESTful?</target>
        </trans-unit>
        <trans-unit id="de97001a3f45e1ab272ba3e7e1ff70234ac18284" translate="yes" xml:space="preserve">
          <source>What is REST?</source>
          <target state="translated">¿Qué es REST?</target>
        </trans-unit>
        <trans-unit id="eda640f0d9d8732bb4f5934942e07911d12c78f5" translate="yes" xml:space="preserve">
          <source>When it comes to web services, it seems that we need some way of distinguishing WSDL and SOAP based architectures which add considerable overhead and arguably much unnecessary complexity to the interface. They also require additional frameworks and developer tools in order to implement. I'm not sure if REST is the best term to distinguish between common-sense interfaces and overly engineered interfaces such as WSDL and SOAP. But we need something.</source>
          <target state="translated">Cuando se trata de servicios web,parece que necesitamos alguna forma de distinguir entre las arquitecturas basadas en WSDL y SOAP,que añaden considerables gastos generales y posiblemente mucha complejidad innecesaria a la interfaz.También requieren de marcos adicionales y herramientas de desarrollo para su implementación.No estoy seguro de que REST sea el mejor término para distinguir entre las interfaces de sentido común y las interfaces excesivamente diseñadas como WSDL y SOAP.Pero necesitamos algo.</target>
        </trans-unit>
        <trans-unit id="a973bdebdbe9ce0f6dcc094fe7f29c9ec500ddfd" translate="yes" xml:space="preserve">
          <source>With a properly implemented restful GET operation, it shouldn't matter if the information comes from your server's DB, your server's memcache, a CDN, a proxy's cache, your browser's cache or your browser's local storage. The fasted, most readily available up to date source can be used.</source>
          <target state="translated">Con una operación GET reposada implementada adecuadamente,no debería importar si la información proviene de la base de datos de tu servidor,el memcache de tu servidor,un CDN,el caché de un proxy,el caché de tu navegador o el almacenamiento local de tu navegador.Se puede utilizar la fuente más rápida y actualizada disponible.</target>
        </trans-unit>
        <trans-unit id="9516144747f958d35f414712742a6a2ce6a57b18" translate="yes" xml:space="preserve">
          <source>With restful style, you get and manipulate the state of the application across an unreliable internet. If it fails the current operation to get the correct and current state, it needs the zero-validation principal to help the application to continue. If it fails to manipulate the state, it usually uses multiple stages of confirmation to keep things correct. In this sense, rest is not itself a whole solution, it needs the functions in other part of the web application stack to support its working.</source>
          <target state="translated">Con un estilo tranquilo,consigues y manipulas el estado de la aplicación a través de una Internet poco fiable.Si falla la operación actual para obtener el estado correcto y actual,necesita el principio de validación cero para ayudar a la aplicación a continuar.Si falla en manipular el estado,normalmente utiliza múltiples etapas de confirmación para mantener las cosas correctas.En este sentido,el descanso no es en sí mismo una solución completa,necesita las funciones en otra parte de la pila de la aplicación web para apoyar su funcionamiento.</target>
        </trans-unit>
        <trans-unit id="9be308c8cf75a9d22350774cf74e2e3a25a8019f" translate="yes" xml:space="preserve">
          <source>You can imagine such an endpoint as being the connecting pipeline from the website (front-end) to your database/server (back-end). Using them, the front-end can perform back-end operations which are defined in the corresponding methods of any REST mapping in your application.</source>
          <target state="translated">Puede imaginarse que tal punto final sea la tubería de conexión desde el sitio web (front-end)hasta su servidor de base de datos (back-end).Utilizándolos,el front-end puede realizar operaciones de back-end que se definen en los métodos correspondientes de cualquier mapeo REST en su aplicación.</target>
        </trans-unit>
        <trans-unit id="908a7dfd19709fb34c01bfe487f5ebb9c2ca9cf8" translate="yes" xml:space="preserve">
          <source>You can summarize(significantly) the constraints to :</source>
          <target state="translated">Se pueden resumir (significativamente)las restricciones a..:</target>
        </trans-unit>
        <trans-unit id="feb921fa13db1c181a291f33573dbc491b591ad9" translate="yes" xml:space="preserve">
          <source>You use the HTTP &quot;verbs&quot; and have..</source>
          <target state="translated">Usas los &quot;verbos&quot; HTTP y tienes...</target>
        </trans-unit>
        <trans-unit id="3aed90f826f40c49f9ad0c3f63e16bed6d13bf70" translate="yes" xml:space="preserve">
          <source>[Failure here implies that out-of-band information is driving interaction instead of hypertext.]</source>
          <target state="translated">[El fallo aquí implica que la información fuera de banda está impulsando la interacción en lugar del hipertexto.]</target>
        </trans-unit>
        <trans-unit id="8e00d08a441958c5870f45fa22543b3d6a03678e" translate="yes" xml:space="preserve">
          <source>build a layered system to increase scalability</source>
          <target state="translated">construir un sistema de capas para aumentar la escalabilidad</target>
        </trans-unit>
        <trans-unit id="59c8c8c5991afe8d0a6e42545c71d93e3bff395d" translate="yes" xml:space="preserve">
          <source>but the REST architecture does not require these &quot;pretty URLs&quot;. A GET request with a parameter</source>
          <target state="translated">pero la arquitectura REST no requiere estas &quot;bonitas URL&quot;.Una petición GET con un parámetro</target>
        </trans-unit>
        <trans-unit id="9f5d22e3a30a84cbccefeb4bd8e5dd35213aaaef" translate="yes" xml:space="preserve">
          <source>clearly communicates the content formats transmitted</source>
          <target state="translated">comunica claramente los formatos de contenido transmitidos</target>
        </trans-unit>
        <trans-unit id="aa2c820849be6fbcb2031a6127c1665b0464c324" translate="yes" xml:space="preserve">
          <source>client-server architecture</source>
          <target state="translated">arquitectura cliente-servidor</target>
        </trans-unit>
        <trans-unit id="8de0a9bc31c843fae99c5bff4c8a379f92283e8b" translate="yes" xml:space="preserve">
          <source>code on demand to extend client functionality</source>
          <target state="translated">código a petición para ampliar la funcionalidad del cliente</target>
        </trans-unit>
        <trans-unit id="b275617b42e241876e72514b35301555695e7037" translate="yes" xml:space="preserve">
          <source>is every bit as RESTful.</source>
          <target state="translated">es igual de descansado.</target>
        </trans-unit>
        <trans-unit id="0d4997d446840ee0c979e316123915b0a24c6d51" translate="yes" xml:space="preserve">
          <source>maintaining the state in the object and representing the state in the representation</source>
          <target state="translated">manteniendo el estado en el objeto y representando el estado en la representación</target>
        </trans-unit>
        <trans-unit id="979f4334840cfaebedb96eacee97565f5bf001e6" translate="yes" xml:space="preserve">
          <source>representing the relationships between resources in the representation of the resource: the links between objects are embedded directly in the representation</source>
          <target state="translated">representando las relaciones entre los recursos en la representación del recurso:los vínculos entre los objetos están incrustados directamente en la representación</target>
        </trans-unit>
        <trans-unit id="5e48ef6a8e54320faa23115ae33b087ac321ebec" translate="yes" xml:space="preserve">
          <source>resource representations describe how the representation can be used and under what circumstances it should be discarded/refetched in a consistent manner: usage of HTTP Cache-Control headers</source>
          <target state="translated">Las representaciones de recursos describen cómo se puede utilizar la representación y bajo qué circunstancias debe ser descartada -revisada de manera consistente:uso de los encabezados de HTTP Cache-Control</target>
        </trans-unit>
        <trans-unit id="e33527bfb73b976a097d9714161c7a07da95577a" translate="yes" xml:space="preserve">
          <source>resources being identified by a persistent identifier: URIs are the ubiquitous choice of identifier these days</source>
          <target state="translated">recursos que se identifican mediante un identificador persistente:Los URI son la elección ubicua de identificador en estos días</target>
        </trans-unit>
        <trans-unit id="a51e6d20a959c6055335a93c972efc9d39c00a75" translate="yes" xml:space="preserve">
          <source>resources being manipulated using a common set of verbs: HTTP methods are the commonly seen case - the venerable &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Retrieve&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt; becomes &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. But REST is not limited to HTTP, it is just the most commonly used transport right now.</source>
          <target state="translated">los recursos que se manipulan utilizando un conjunto com&amp;uacute;n de verbos: los m&amp;eacute;todos HTTP son el caso m&amp;aacute;s com&amp;uacute;n: el venerable &lt;code&gt;Create&lt;/code&gt; , &lt;code&gt;Retrieve&lt;/code&gt; , &lt;code&gt;Update&lt;/code&gt; , &lt;code&gt;Delete&lt;/code&gt; convierte en &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; y &lt;code&gt;DELETE&lt;/code&gt; . Pero REST no se limita a HTTP, es solo el transporte m&amp;aacute;s utilizado en este momento.</target>
        </trans-unit>
        <trans-unit id="98b5c511b1e5b3b77e9275fb4452cc5fef44489b" translate="yes" xml:space="preserve">
          <source>respect HTTP specs (if HTTP is used)</source>
          <target state="translated">respetar las especificaciones de HTTP (si se utiliza HTTP)</target>
        </trans-unit>
        <trans-unit id="c4931fde74816a610a063dd06bd59538b02802b8" translate="yes" xml:space="preserve">
          <source>stateless communication</source>
          <target state="translated">comunicación apátrida</target>
        </trans-unit>
        <trans-unit id="3b878062f43e3c640f44bd52081d0d0dc4278065" translate="yes" xml:space="preserve">
          <source>the actual representation retrieved for a resource is dependent on the request and not the identifier: use Accept headers to control whether you want XML, HTTP, or even a Java Object representing the resource</source>
          <target state="translated">la representación real recuperada para un recurso depende de la solicitud y no del identificador:utilice los encabezados de aceptación para controlar si desea XML,HTTP o incluso un objeto Java que represente el recurso</target>
        </trans-unit>
        <trans-unit id="1462755612fc240043fdb2325bffe48c8d0f3f08" translate="yes" xml:space="preserve">
          <source>uniform interface as common contract between client and server</source>
          <target state="translated">interfaz uniforme como contrato común entre el cliente y el servidor</target>
        </trans-unit>
        <trans-unit id="3766fe2c2822ed2ec2c43384fd93c708aa87dded" translate="yes" xml:space="preserve">
          <source>usage of cache if you can</source>
          <target state="translated">uso de la caché si se puede</target>
        </trans-unit>
        <trans-unit id="f96087a197542f55a4ef257f73c9f1cfd69fffd2" translate="yes" xml:space="preserve">
          <source>use hypermedia as the engine of application state</source>
          <target state="translated">utilizar los hipermedios como el motor del estado de aplicación</target>
        </trans-unit>
        <trans-unit id="2626c215ef69fa721ddf1168a1db9e9f9a723d4c" translate="yes" xml:space="preserve">
          <source>would not be appropriate. GET requests should be &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Idempotence&quot;&gt;idempotent&lt;/a&gt;. That is, issuing a request twice should be no different from issuing it once. That's what makes the requests cacheable. An &quot;add to cart&quot; request is not idempotent&amp;mdash;issuing it twice adds two copies of the item to the cart. A POST request is clearly appropriate in this context. Thus, even a &lt;strong&gt;RESTful web application&lt;/strong&gt; needs its share of POST requests.</source>
          <target state="translated">No ser&amp;iacute;a apropiado. Las solicitudes GET deben ser &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Idempotence&quot;&gt;idempotentes&lt;/a&gt; . Es decir, emitir una solicitud dos veces no deber&amp;iacute;a ser diferente de emitirla una vez. Eso es lo que hace que las solicitudes se puedan almacenar en cach&amp;eacute;. Una solicitud de &quot;agregar al carrito&quot; no es idempotente: emitirla dos veces agrega dos copias del art&amp;iacute;culo al carrito. Una solicitud POST es claramente apropiada en este contexto. Por lo tanto, incluso una &lt;strong&gt;aplicaci&amp;oacute;n web RESTful&lt;/strong&gt; necesita su parte de solicitudes POST.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
