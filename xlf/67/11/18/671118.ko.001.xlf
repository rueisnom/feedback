<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/671118">
    <body>
      <group id="671118">
        <trans-unit id="4b5f371d067d57adebce0c867d054ff2d3400ab5" translate="yes" xml:space="preserve">
          <source>(This answer has been the subject of a fair amount of criticism for missing the point. For the most part, that has been a fair critique. What I originally described was more in line with how REST was usually implemented a few years ago when I first wrote this, rather than its true meaning. I've revised the answer to better represent the real meaning.)</source>
          <target state="translated">(이 답변은 요점을 놓친 것에 대한 상당한 양의 비판의 대상이었습니다. 대부분의 경우, 그것은 비평이었습니다. 제가 원래 설명한 것은 몇 년 전 제가 REST를 구현 한 방식과 더 관련이있었습니다. 처음에는 이것이 진정한 의미가 아니라 이것을 썼습니다. 나는 실제 의미를 더 잘 표현하기 위해 답을 수정했습니다.)</target>
        </trans-unit>
        <trans-unit id="d38acde6c0a007c814e7a8e62db3e40f8b9a8c5d" translate="yes" xml:space="preserve">
          <source>1) There is no such a thing as restful programing, without a big joint and lots of beer :)</source>
          <target state="translated">1) 큰 조인트와 많은 맥주가 없으면 편안한 프로그래밍과 같은 것은 없습니다 :)</target>
        </trans-unit>
        <trans-unit id="16ed7b2a6cdbe5d413738c42d0ff5485bb59700c" translate="yes" xml:space="preserve">
          <source>2) &lt;strong&gt;Representational State Transfer (REST) is an architectural style specified in &lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;the dissertation of Roy Fielding&lt;/a&gt;.
It has a number of constraints.  If your Service/Client respect those then it is RESTful.&lt;/strong&gt; This is it.</source>
          <target state="translated">2) &lt;strong&gt;REST (Representational State Transfer)는 &lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Roy Fielding 논문에&lt;/a&gt; 지정된 아키텍처 스타일입니다.&lt;/strong&gt; &lt;strong&gt;많은 제약이 있습니다.&lt;/strong&gt; &lt;strong&gt;서비스 / 클라이언트가이를 존중한다면 RESTful입니다.&lt;/strong&gt; 이거 야.</target>
        </trans-unit>
        <trans-unit id="27e5dbfce4b7ee29196f5fd4dafe3ca1c0624c58" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;Unique global identifier&lt;/a&gt; (all resources are unique identified by &lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;고유 한 글로벌 식별자입니다&lt;/a&gt; (모든 자원은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Uniform_resource_identifier&quot;&gt;URI로&lt;/a&gt; 식별됩니다).</target>
        </trans-unit>
        <trans-unit id="1fd9999d07a7fc62861689de4b2bdf6a8fc86768" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;RESTful&lt;/a&gt; (Representational state transfer) API programming is writing web applications in any programming language by following 5 basic software &lt;a href=&quot;http://en.wikipedia.org/wiki/Architectural_style&quot;&gt;architectural style&lt;/a&gt; principles:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;RESTful&lt;/a&gt; (Representational State Transfer) API 프로그래밍은 5 가지 기본 소프트웨어 &lt;a href=&quot;http://en.wikipedia.org/wiki/Architectural_style&quot;&gt;아키텍처 스타일&lt;/a&gt; 원칙에 따라 모든 프로그래밍 언어로 웹 애플리케이션을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="68ce364743640c5c8da066039ef67fefbcdfea99" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface&quot;&gt;Uniform interface&lt;/a&gt; - use simple and standard interface (HTTP).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface&quot;&gt;균일 한 인터페이스&lt;/a&gt; -단순하고 표준적인 인터페이스 (HTTP)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc1b3e08e8f98d28090f1f9117f6298bc58e4d4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Stateless_protocol&quot;&gt;Stateless&lt;/a&gt; (every request happens in complete isolation, it's easier to cache and load-balance),</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Stateless_protocol&quot;&gt;상태 비 저장&lt;/a&gt; (모든 요청은 완전 격리에서 발생하며 캐시 및로드 밸런싱이 더 쉬움)</target>
        </trans-unit>
        <trans-unit id="129cb3c37d52f357725b109610381bd678a81b64" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://herbjorn.wordpress.com/2010/11/19/rest-versus-soap-for-the-public-cloud/&quot;&gt;REST versus SOAP for the Public Cloud&lt;/a&gt; discusses the current levels of REST usage.</source>
          <target state="translated">&lt;a href=&quot;http://herbjorn.wordpress.com/2010/11/19/rest-versus-soap-for-the-public-cloud/&quot;&gt;퍼블릭 클라우드의 REST 대 SOAP&lt;/a&gt; 는 현재 레벨의 REST 사용량에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="01d4ccbe57dba207b3756864c380f7e8c5cec68f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://kinderman.net/2010/06/23/approaching-pure-rest-learning-to-love-hateoas&quot;&gt;Approaching pure REST: Learning to love HATEOAS&lt;/a&gt; is a good collection of links.</source>
          <target state="translated">&lt;a href=&quot;http://kinderman.net/2010/06/23/approaching-pure-rest-learning-to-love-hateoas&quot;&gt;순수한 REST에 접근하기 : HATEOAS를 사랑하는 법&lt;/a&gt; 은 훌륭한 링크 모음입니다.</target>
        </trans-unit>
        <trans-unit id="71c672309538bece163ea3ed6fdde78bae549263" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;The term RESTful was created because ppl exhausted the word REST by calling their non-REST application as REST.&lt;/a&gt; After that the term RESTful was exhausted as well. &lt;a href=&quot;http://www.markus-lanthaler.com/research/third-generation-web-apis-bridging-the-gap-between-rest-and-linked-data.pdf&quot;&gt;Nowadays we are talking about Web APIs and Hypermedia APIs&lt;/a&gt;, because the most of the so called REST applications did not fulfill the HATEOAS part of the uniform interface constraint.</source>
          <target state="translated">&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;ppl은 REST가 아닌 응용 프로그램을 REST로 호출하여 REST라는 단어를 소진했기 때문에 RESTful이라는 용어가 만들어졌습니다.&lt;/a&gt; 그 후 RESTful이라는 용어도 소진되었습니다. &lt;a href=&quot;http://www.markus-lanthaler.com/research/third-generation-web-apis-bridging-the-gap-between-rest-and-linked-data.pdf&quot;&gt;요즘 우리는&lt;/a&gt; 소위 REST 애플리케이션의 대부분이 균일 한 인터페이스 제약 조건의 HATEOAS 부분을 충족시키지 못하기 때문에 웹 API 및 하이퍼 미디어 API에 대해 이야기하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee92cfd1a1d0fac1b4085c977902cee08a3f0004" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife&quot;&gt;How I explained REST to my wife&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://web.archive.org/web/20130116005443/http://tomayko.com/writings/rest-to-my-wife&quot;&gt;내가 아내에게 REST를 설명하는 방법&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd6a95880b9724e9be2ebb234578d30f5200563" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.innoq.com/blog/st/2010/07/rest_litmus_test_for_web_frame.html&quot;&gt;REST Litmus Test for Web Frameworks&lt;/a&gt; is a similar maturity test for web frameworks.</source>
          <target state="translated">&lt;a href=&quot;http://www.innoq.com/blog/st/2010/07/rest_litmus_test_for_web_frame.html&quot;&gt;웹 프레임 워크 용 REST Litmus 테스트는 웹 프레임 워크&lt;/a&gt; 에 대한 유사한 성숙도 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="b82de9194c2626af47b20dbf29253c8eab541c11" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.xfront.com/REST.ppt&quot;&gt;http://www.xfront.com/REST.ppt&lt;/a&gt; or &lt;a href=&quot;http://www.xfront.com/REST.html&quot;&gt;http://www.xfront.com/REST.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.xfront.com/REST.ppt&quot;&gt;http://www.xfront.com/REST.ppt&lt;/a&gt; 또는 &lt;a href=&quot;http://www.xfront.com/REST.html&quot;&gt;http://www.xfront.com/REST.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="581df4eb5c8f47005fba4eaff2c31e62dc854f5b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.google.com/present/view?id=dd4bk538_182f55p5x3f&amp;amp;ndplr=1&quot;&gt;REST and versioning&lt;/a&gt; discusses Extensibility, Versioning, Evolvability, etc.
 through Modifiability</source>
          <target state="translated">&lt;a href=&quot;https://docs.google.com/present/view?id=dd4bk538_182f55p5x3f&amp;amp;ndplr=1&quot;&gt;REST 및 버전 관리&lt;/a&gt; 는 수정 가능성을 통해 확장 성, 버전 관리, 진 화성 등에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="38b751418200783443a4e1aa6fb491b6a5b8367d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;From Wikipedia&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;Wikipedia에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b092bbc5dae2d2facc4cdcbac80f4fca0862b1a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;REST&lt;/em&gt; is the underlying architectural principle of the web. The amazing thing about the web is the fact that clients (browsers) and servers can interact in complex ways without the client knowing anything beforehand about the server and the resources it hosts. The key constraint is that the server and client must both agree on the &lt;em&gt;media&lt;/em&gt; used, which in the case of the web is &lt;em&gt;HTML&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;REST&lt;/em&gt; 는 웹의 기본 아키텍처 원칙입니다. 웹의 놀라운 점은 클라이언트 (브라우저)와 서버가 클라이언트가 서버와 서버가 호스팅하는 리소스에 대해 미리 알 필요없이 복잡한 방식으로 상호 작용할 수 있다는 것입니다. 주요 제약 조건은 서버와 클라이언트가 사용되는 &lt;em&gt;미디어에&lt;/em&gt; 동의해야한다는 것입니다 (웹의 경우 &lt;em&gt;HTML)&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="75836654a91c2003a610250aa33fea51aed04694" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Talking&lt;/em&gt; is more than simply &lt;em&gt;exchanging information&lt;/em&gt;. A Protocol is actually designed so that no talking has to occur. Each party knows what their particular job is because it is specified in the protocol. Protocols allow for pure information exchange at the expense of having any changes in the possible actions. Talking, on the other hand, allows for one party to ask what further actions can be taken from the other party. They can even ask the same question twice and get two different answers, since the State of the other party may have changed in the interim. &lt;strong&gt;Talking is RESTful architecture&lt;/strong&gt;. Fielding's thesis specifies the architecture that one would have to follow if one wanted to allow machines to &lt;em&gt;talk&lt;/em&gt; to one another rather than simply &lt;em&gt;communicate&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;말하는&lt;/em&gt; 것은 단순히 &lt;em&gt;정보&lt;/em&gt; 를 &lt;em&gt;교환하는&lt;/em&gt; 것 이상입니다. 프로토콜은 실제로 대화가 발생하지 않도록 설계되었습니다. 각 당사자는 프로토콜에 지정되어 있기 때문에 자신의 특정 직업이 무엇인지 알고 있습니다. 프로토콜은 가능한 조치에 변화가 생겨도 순수한 정보 교환을 허용합니다. 반면에 말하는 것은 한 당사자가 다른 당사자로부터 어떤 추가 조치를 취할 수 있는지 물어볼 수있게합니다. 상대방의 상태가 중간에 변경되었을 수 있으므로 동일한 질문을 두 번 요청하고 서로 다른 두 가지 답변을 얻을 수도 있습니다. &lt;strong&gt;말하기는 RESTful 아키텍처&lt;/strong&gt; 입니다. Fielding의 논문은 기계가 단순히 &lt;em&gt;의사 소통&lt;/em&gt; 하기보다는 서로 &lt;em&gt;대화&lt;/em&gt; 할 수있게하려면 따라야 할 아키텍처를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="047b453da1539c81d5d318bedbdeb493589d50ab" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;a href=&quot;http://www.looah.com/source/view/2284&quot;&gt;How I explained REST to my wife&lt;/a&gt;.&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;&lt;a href=&quot;http://www.looah.com/source/view/2284&quot;&gt;내가 아내에게 REST를 설명하는 방법&lt;/a&gt; .&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="a5cbf477e28c39bdfd209ebf60137a160a48aa33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4 Commonly Used API Methods:-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4 일반적으로 사용되는 API 방법 :-&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a292b42aebab7e4f8f0a4cef5109e82538c81c4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;HTTP methods:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTTP 메소드 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c887aa651a0b1255f5b4be4a6d0d7111e108eb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Idempotence&lt;/strong&gt;: &lt;a href=&quot;http://programmers.stackexchange.com/questions/23386/pros-and-cons-of-restful-architecture&quot;&gt;An often-overlooked part of REST is the idempotency of most verbs. That leads to &lt;strong&gt;robust systems and less interdependency&lt;/strong&gt; of exact interpretations of the semantics&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;dem 등증&lt;/strong&gt; : &lt;a href=&quot;http://programmers.stackexchange.com/questions/23386/pros-and-cons-of-restful-architecture&quot;&gt;REST에서 자주 간과되는 부분은 대부분 동사의 dem 등성입니다.&lt;/a&gt; 이는 의미 체계의 정확한 해석에 대한 &lt;strong&gt;강력한 시스템과 상호 의존성&lt;/strong&gt; 을 &lt;strong&gt;떨어 뜨린다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e19e144b463c1477631bed87f6cf59ac2feabcb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST API&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;REST API&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4016ad50e00a712f9fc46d47dae34627a47b0c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST&lt;/strong&gt; is an architectural style which is based on web-standards and the HTTP protocol (introduced in 2000).</source>
          <target state="translated">&lt;strong&gt;REST&lt;/strong&gt; 는 웹 표준과 HTTP 프로토콜 (2000 년에 도입)을 기반으로하는 아키텍처 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="f470c92afeb4f87674886ef73e25bccf93d40bda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;REST&lt;/strong&gt; stands for &lt;strong&gt;Representational state transfer&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;REST&lt;/strong&gt; 는 &lt;strong&gt;표현 상태 전송을&lt;/strong&gt; 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c34758fefce5857b0652a67c95f80db96a7e9ace" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Request&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Request&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8301b7897b69c57632cd67112cbd903a929c2bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Response&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Response&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9026e434b313962901c5fd34080061d3114f6c95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So, how does this apply to &lt;em&gt;HTTP&lt;/em&gt;, and how can it be implemented in practice?&lt;/strong&gt; HTTP is oriented around verbs and resources. The two verbs in mainstream usage are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;, which I think everyone will recognize. However, the HTTP standard defines several others such as &lt;code&gt;PUT&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt;. These verbs are then applied to resources, according to the instructions provided by the server.</source>
          <target state="translated">&lt;strong&gt;그렇다면 이것이 &lt;em&gt;HTTP&lt;/em&gt; 에 어떻게 적용되며 실제로 어떻게 구현할 수 있습니까?&lt;/strong&gt; HTTP는 동사와 리소스를 중심으로합니다. 주류 사용의 두 동사는 &lt;code&gt;GET&lt;/code&gt; 과 &lt;code&gt;POST&lt;/code&gt; 입니다. 그러나 HTTP 표준은 &lt;code&gt;PUT&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 와 같은 다른 여러 가지를 정의합니다. 그런 다음이 동사는 서버에서 제공 한 지침에 따라 리소스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="63a42af1bd9b39bddf0ce1be8356d0a2fdb888e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Statelessness&lt;/strong&gt; is misleading. It is about the restful API, not the application or system. The system needs to be stateful. Restful design is about designing a stateful system based on a stateless API. Some &lt;a href=&quot;http://programmers.stackexchange.com/questions/120716/difference-between-rest-and-crud&quot;&gt;quotes from another QA&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;무국적자&lt;/strong&gt; 는 오도의 소지가 있습니다. 응용 프로그램이나 시스템이 아닌 편안한 API에 관한 것입니다. 시스템은 상태 저장이 필요합니다. 안정된 디자인은 상태 비 저장 API를 기반으로 상태 저장 시스템을 설계하는 것입니다. &lt;a href=&quot;http://programmers.stackexchange.com/questions/120716/difference-between-rest-and-crud&quot;&gt;다른 QA의 인용문&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4c1222e90317ba27d02c65621a259eda932152bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Steps to Test API Manually:-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;API를 수동으로 테스트하는 단계 :-&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a168c28310824470d0a6b65e2fc1846ae47767c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There is another &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;very good post&lt;/a&gt; which explains things nicely.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;일을 잘 설명하는 또 다른 &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;아주 좋은 게시물&lt;/a&gt; 이 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f23059a3c1ff462600affe32ac77f6c06e198cd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is &lt;a href=&quot;http://testingalert.com/api-testing/api-manual/&quot;&gt;API Testing&lt;/a&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://testingalert.com/api-testing/api-manual/&quot;&gt;API 테스팅&lt;/a&gt; 이란 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bdfd2ece2c06305906caea45c528dd7bf39e1081" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is REST?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;REST 란 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34c0a9562e8fed523993c8b4e5719d3ee3daa073" translate="yes" xml:space="preserve">
          <source>A REST API should be entered with no prior knowledge beyond the initial URI (bookmark) and set of standardized media types that are appropriate for the intended audience (i.e., expected to be understood by any client that might use the API). From that point on, all application state transitions must be driven by client selection of server-provided choices that are present in the received representations or implied by the user&amp;rsquo;s manipulation of those representations. The transitions may be determined (or limited by) the client&amp;rsquo;s knowledge of media types and resource communication mechanisms, both of which may be improved on-the-fly (e.g., code-on-demand).</source>
          <target state="translated">REST API는 의도 된 대상에 적합한 초기 URI (책갈피) 및 표준화 된 미디어 유형 세트를 넘어 사전 지식없이 입력해야합니다 (즉, API를 사용하는 모든 클라이언트가 이해할 수 있음). 그 시점부터 모든 응용 프로그램 상태 전환은 수신 된 표현에 있거나 사용자가 해당 표현을 조작하여 암시하는 서버 제공 선택 사항에 대한 클라이언트 선택에 의해 구동되어야합니다. 전이는 미디어 유형 및 리소스 통신 메커니즘에 대한 클라이언트의 지식에 의해 결정 (또는 제한 될 수 있음) 될 수 있으며, 이들 모두는 즉석에서 개선 될 수있다 (예를 들어, 주문형 코드).</target>
        </trans-unit>
        <trans-unit id="1036e82ff72398f19dae7159de008a4b11524acc" translate="yes" xml:space="preserve">
          <source>A REST API should spend almost all of its descriptive effort in
  defining the media type(s) used for representing resources and driving
  application state, or in defining extended relation names and/or
  hypertext-enabled mark-up for existing standard media types.</source>
          <target state="translated">REST API는 리소스를 표현하고 애플리케이션 상태를 구동하는 데 사용되는 미디어 유형을 정의하거나 기존 표준 미디어 유형에 대한 확장 관계 이름 및 / 또는 하이퍼 텍스트 가능 마크 업을 정의하는 데 거의 모든 노력을 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="091580d9e598bff76e8f95009cca43640abadd8b" translate="yes" xml:space="preserve">
          <source>A client of a RESTful application need
  only know a single fixed URL to access
  it. All future actions should be
  discoverable dynamically from
  hypermedia links included in the
  representations of the resources that
  are returned from that URL.
  Standardized media types are also
  expected to be understood by any
  client that might use a RESTful API. 
  (From Wikipedia, the free encyclopedia)</source>
          <target state="translated">RESTful 애플리케이션의 클라이언트는 액세스하기 위해 단일 고정 URL 만 알고 있으면됩니다. 해당 URL에서 반환되는 리소스 표현에 포함 된 하이퍼 미디어 링크에서 향후 모든 작업을 동적으로 검색 할 수 있어야합니다. 표준화 된 미디어 유형은 RESTful API를 사용하는 모든 클라이언트에 의해 이해 될 것으로 예상됩니다. (무료 백과 사전, 위키피디아에서)</target>
        </trans-unit>
        <trans-unit id="b199b8ec3c349cace004db8b56b1161860b9581b" translate="yes" xml:space="preserve">
          <source>A great book on REST is &lt;a href=&quot;http://www.amazon.co.uk/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829&quot;&gt;REST in Practice&lt;/a&gt;.</source>
          <target state="translated">REST에 대한 훌륭한 책 &lt;a href=&quot;http://www.amazon.co.uk/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829&quot;&gt;은 실습&lt;/a&gt; 에서 REST입니다.</target>
        </trans-unit>
        <trans-unit id="bbbdec192b31adde0e04c6c1e638a22c1c3a0509" translate="yes" xml:space="preserve">
          <source>A lot of answers copy/pasted valid information mixing it and adding some confusion. People talk here about levels, about RESTFul URIs(there is not such a thing!), apply HTTP methods GET,POST,PUT ... REST is not about that or not only about that.</source>
          <target state="translated">많은 답변이 유효한 정보를 복사 / 붙여 넣기하여 혼합하고 혼란을 더합니다. 사람들은 레벨, RESTFul URI (이런 것은 아닙니다!)에 대해 이야기하고 HTTP 메소드를 적용합니다 .GET, POST, PUT ... REST는 그것에 관한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a9672fbb5a371857625bda2ec07f4fc2c459d533" translate="yes" xml:space="preserve">
          <source>A request for the base resource &lt;code&gt;/&lt;/code&gt; might return something like this:</source>
          <target state="translated">기본 리소스에 대한 요청은 다음과 같이 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33311414a6f85a0d4549f88e6f929e587d140695" translate="yes" xml:space="preserve">
          <source>API testing utilizes programming to send calls to the API and get the yield. It testing regards the segment under test as a black box. The objective of API testing is to confirm right execution and blunder treatment of the part preceding its coordination into an application.</source>
          <target state="translated">API 테스트는 프로그래밍을 사용하여 API에 호출을 보내고 수율을 얻습니다. 이 테스트는 테스트중인 세그먼트를 블랙 박스로 간주합니다. API 테스트의 목적은 조정을 앞둔 부분이 응용 프로그램으로 올바르게 실행되고 실수로 처리되는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="17e11e3bc87a626545bcd3ae4e73a6dc9b979e5b" translate="yes" xml:space="preserve">
          <source>After reading the examples, I could see why Ken is saying that REST is hypertext-driven. I'm not actually sure that he's right though, because that /user/123 is a URI that points to a resource, and it's not clear to me that it's unRESTful just because the client knows about it &quot;out-of-band.&quot;</source>
          <target state="translated">예제를 읽은 후, Ken이 왜 REST가 하이퍼 텍스트 중심임을 말하고 있는지 알 수있었습니다. 나는 / user / 123이 리소스를 가리키는 URI이기 때문에 실제로 그가 옳다는 것을 확신하지 못하며, 클라이언트가 &quot;대역 외&quot;에 대해 알고 있기 때문에 그것이 신뢰할 수 없다는 것은 분명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ff162ae131fa2cf274f6632a56e1f9816c868de" translate="yes" xml:space="preserve">
          <source>After that, it's easy to fall into debates about adaptations, coding conventions, and best practices.</source>
          <target state="translated">그 후에는 적응, 코딩 규칙 및 모범 사례에 대한 토론에 쉽게 참여할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6213f65245bee16c30cf6760d609e28bd445103" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;architectural style&lt;/strong&gt; called &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;&lt;strong&gt;REST (Representational State Transfer)&lt;/strong&gt;&lt;/a&gt; advocates that web applications should use HTTP as it was &lt;strong&gt;originally envisioned&lt;/strong&gt;. Lookups should use &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; requests. &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt; requests&lt;/a&gt; should be used for &lt;strong&gt;mutation, creation, and deletion respectively&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Representational_state_transfer&quot;&gt;&lt;strong&gt;REST (Representational State Transfer)&lt;/strong&gt;&lt;/a&gt; 라는 &lt;strong&gt;아키텍처 스타일&lt;/strong&gt; 은 웹 애플리케이션이 &lt;strong&gt;원래 계획&lt;/strong&gt; 했던 &lt;strong&gt;대로&lt;/strong&gt; HTTP를 사용해야한다고 주장합니다. 조회는 &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 요청을 사용해야합니다. &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 요청&lt;/a&gt; 은 &lt;strong&gt;각각 돌연변이, 생성 및 삭제에&lt;/strong&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="23f9e629acbf7586515e2525e29805b2378876e7" translate="yes" xml:space="preserve">
          <source>An API that adheres to the principles of &lt;em&gt;REST&lt;/em&gt; does not require the client to know anything about the structure of the API. Rather, the server needs to provide whatever information the client needs to interact with the service. An &lt;em&gt;HTML form&lt;/em&gt; is an example of this: The server specifies the location of the resource and the required fields. &lt;strong&gt;The browser doesn't know in advance where to submit the information, and it doesn't know in advance what information to submit. Both forms of information are entirely supplied by the server.&lt;/strong&gt; (This principle is called &lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot;&gt;&lt;em&gt;HATEOAS&lt;/em&gt;: Hypermedia As The Engine Of Application State&lt;/a&gt;.)</source>
          <target state="translated">&lt;em&gt;REST&lt;/em&gt; 원칙을 준수하는 API는 클라이언트가 API 구조에 대해 아무것도 알 필요가 없습니다. 오히려 서버는 클라이언트가 서비스와 상호 작용하는 데 필요한 정보를 제공해야합니다. &lt;em&gt;HTML 형식&lt;/em&gt; 의 예는 다음과 같습니다. 서버는 리소스의 위치와 필수 필드를 지정합니다. &lt;strong&gt;브라우저는 정보를 제출할 위치를 미리 알지 못하며 제출할 정보를 미리 알지 못합니다.&lt;/strong&gt; &lt;strong&gt;두 형태의 정보는 전적으로 서버에 의해 제공됩니다.&lt;/strong&gt; (이 원칙을 &lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot;&gt;&lt;em&gt;HATEOAS&lt;/em&gt; : 응용 프로그램 엔진 상태의 하이퍼 미디어&lt;/a&gt; 라고합니다.)</target>
        </trans-unit>
        <trans-unit id="0572ba17f943d7fd5fc5bebd5022f2239451cc72" translate="yes" xml:space="preserve">
          <source>An application is restful if it provides resources (being the combination of data + state transitions controls) in a media type the client understands</source>
          <target state="translated">클라이언트가 이해하는 미디어 유형으로 리소스 (데이터 + 상태 전이 제어의 조합 임)를 제공하면 애플리케이션이 편안합니다.</target>
        </trans-unit>
        <trans-unit id="5bd054a830a9ec163da9832cb1d2afde20a52654" translate="yes" xml:space="preserve">
          <source>An excerpt from my talk is about the often referred to richardson maturity model, i don't believe in the levels, you either are RESTful (level 3) or you are not, but what i like to call out about it is what each level does for you on your way to RESTful</source>
          <target state="translated">내 이야기에서 발췌 한 내용은 종종 richardson 성숙 모델에 대한 것입니다. 레벨을 믿지 않습니다. 당신은 RESTful (레벨 3)이거나 그렇지 않습니다. 그러나 그것에 대해 부르고 싶은 것은 각 레벨입니다 RESTful로가는 길에 당신을 위해</target>
        </trans-unit>
        <trans-unit id="2610e51a62b1a490881eef55051e2f6be573a983" translate="yes" xml:space="preserve">
          <source>And even better, there's a clean explanation with simple examples here (the powerpoint is more comprehensive, but you can get most of it in the html version):</source>
          <target state="translated">더 좋은 점은 여기에 간단한 예제로 깔끔한 설명이 있습니다 (파워 포인트는보다 포괄적이지만 HTML 버전으로 대부분 얻을 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="200c5e79bfe63bed7ea90d31d59e4814bd38015a" translate="yes" xml:space="preserve">
          <source>Bonus answer: No. Unless you're studying software architecture as an academic or designing web services, there's really no reason to have heard the term.</source>
          <target state="translated">보너스 답변 : 아니요. 아카데믹 또는 웹 서비스 디자인으로 소프트웨어 아키텍처를 연구하지 않는 한이 용어를 들어야 할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="8db50296564fcc14b8370fbfb576cb5f7a3364bb" translate="yes" xml:space="preserve">
          <source>But the REST architecture doesn&amp;rsquo;t end there! While the above fulfills the basic needs of what we want, we also want to have an architecture that supports high volume traffic since any given server usually handles responses from a number of clients. Thus, we don&amp;rsquo;t want to overwhelm the server by having it remember information about previous requests.</source>
          <target state="translated">그러나 REST 아키텍처는 여기서 끝나지 않습니다! 위의 내용은 우리가 원하는 것의 기본 요구 사항을 충족시키는 반면, 특정 서버는 일반적으로 여러 클라이언트의 응답을 처리하므로 대량 트래픽을 지원하는 아키텍처를 원합니다. 따라서 이전 요청에 대한 정보를 기억하여 서버를 압도하고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0e841fccec5e52e207c5f9f8aedc87617de3151" translate="yes" xml:space="preserve">
          <source>But to find any given resource and then tell the client where that resource lives, there needs to be a universal way of pointing at resources. This is where Universal Resource Identifiers (URIs) come in; they are basically unique addresses to find the resources.</source>
          <target state="translated">그러나 주어진 리소스를 찾은 다음 클라이언트에게 해당 리소스가 어디에 있는지 알려주려면 리소스를 가리키는 일반적인 방법이 필요합니다. 여기에서 URI (Universal Resource Identifier)가 사용됩니다. 기본적으로 리소스를 찾기위한 고유 한 주소입니다.</target>
        </trans-unit>
        <trans-unit id="ab9c8d4b22f42d6e20f2de04cee4a87194c9b2ff" translate="yes" xml:space="preserve">
          <source>Cacheable</source>
          <target state="translated">Cacheable</target>
        </trans-unit>
        <trans-unit id="ebdaf0dc221196d242550c9fdcc355ae34b62243" translate="yes" xml:space="preserve">
          <source>Click on send</source>
          <target state="translated">보내기를 클릭하십시오</target>
        </trans-unit>
        <trans-unit id="85e79360e824842c6393ab95bc2ed066d468e1c8" translate="yes" xml:space="preserve">
          <source>Client&amp;ndash;server</source>
          <target state="translated">Client&amp;ndash;server</target>
        </trans-unit>
        <trans-unit id="9e1c7ac80552b301d4a9e2e0aad43db3dc88701b" translate="yes" xml:space="preserve">
          <source>Code on demand (optional)</source>
          <target state="translated">주문형 코드 (선택 사항)</target>
        </trans-unit>
        <trans-unit id="09134846ea28241f35e0dd02fce269a9982bea7f" translate="yes" xml:space="preserve">
          <source>Create a user with three properties:</source>
          <target state="translated">세 가지 속성을 가진 사용자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4b2835cc754c6984e507206155e739a1564f8450" translate="yes" xml:space="preserve">
          <source>DELETE removes the resources. The operations are idempotent. They can get repeated without leading to different results.</source>
          <target state="translated">DELETE는 자원을 제거합니다. 작업은 dem 등원입니다. 다른 결과로 이어지지 않고 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03419256ac96b83abfd7066f861a5015d2ba0ed0" translate="yes" xml:space="preserve">
          <source>DELETE: &amp;ndash; It is used to remove a resource.</source>
          <target state="translated">삭제 : &amp;ndash; 리소스를 제거하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e5b459d45380b093202121fad6f6675d370930c" translate="yes" xml:space="preserve">
          <source>Despite being simple, REST is fully-featured; there's basically
  nothing you can do in Web Services that can't be done with a RESTful
  architecture. REST is not a &quot;standard&quot;. There will never be a W3C
  recommendataion for REST, for example. And while there are REST
  programming frameworks, working with REST is so simple that you can
  often &quot;roll your own&quot; with standard library features in languages like
  Perl, Java, or C#.</source>
          <target state="translated">단순함에도 불구하고 REST는 모든 기능을 갖추고 있습니다. RESTful 아키텍처로는 수행 할 수없는 웹 서비스에서 기본적으로 수행 할 수있는 작업이 없습니다. REST는 &quot;표준&quot;이 아닙니다. 예를 들어 REST에 대한 W3C 권장 사항은 없습니다. REST 프로그래밍 프레임 워크가 있지만 REST 작업은 매우 간단하여 Perl, Java 또는 C #과 같은 언어의 표준 라이브러리 기능을 사용하여 &quot;자신의 롤&quot;을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8d49819767eebe1ba51b6e1ff800c7bff7f706e" translate="yes" xml:space="preserve">
          <source>Edit: Two more important aspects:</source>
          <target state="translated">편집 : 두 가지 중요한 측면 :</target>
        </trans-unit>
        <trans-unit id="cc4bbb1317907e63ed80955856990adc8e7cbbe4" translate="yes" xml:space="preserve">
          <source>Enter Request JSON (POST)</source>
          <target state="translated">요청 JSON (POST) 입력</target>
        </trans-unit>
        <trans-unit id="ab911d488e200ceacb5e406e1fe7b3000216de7c" translate="yes" xml:space="preserve">
          <source>Enter the API URL</source>
          <target state="translated">API URL을 입력하십시오</target>
        </trans-unit>
        <trans-unit id="800300af0e99da4a9ab4e50e0ad740ebb248a62c" translate="yes" xml:space="preserve">
          <source>Every resource should support the HTTP common operations. Resources are identified by global IDs (which are typically URIs).</source>
          <target state="translated">모든 리소스는 HTTP 공통 작업을 지원해야합니다. 리소스는 전역 ID (일반적으로 URI)로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="ae6c811f24cef30ab608149e77398fe7dc2aa93f" translate="yes" xml:space="preserve">
          <source>Explaining REST and Hypertext: Spam-E the Spam Cleaning Robot</source>
          <target state="translated">REST 및 하이퍼 텍스트 설명 : Spam-E 스팸 청소 로봇</target>
        </trans-unit>
        <trans-unit id="4c2e0eda7987cd96af30a22725f03cbbfc4b115a" translate="yes" xml:space="preserve">
          <source>For example links - it is nice to have a beautifully looking API but at the end the client/server does not really care of the links you get/send it is the content that matters.</source>
          <target state="translated">예를 들어 링크-아름답게 보이는 API를 사용하는 것이 좋지만 결국 클라이언트 / 서버는 실제로 링크를 얻지 못하고 보내지는 링크는 중요합니다.</target>
        </trans-unit>
        <trans-unit id="040c10648e6eb948c9d8e9d90c4d5f137fae46d2" translate="yes" xml:space="preserve">
          <source>For example there is a client layer which contains the clients and below that there is a service layer which contains a single service. Now you can add a client side cache between them. After that you can add another service instance and a load balancer, and so on... The client code and the service code won't change.</source>
          <target state="translated">예를 들어 클라이언트를 포함하는 클라이언트 계층이 있고 그 아래에는 단일 서비스를 포함하는 서비스 계층이 있습니다. 이제 그들 사이에 클라이언트 측 캐시를 추가 할 수 있습니다. 그 후 다른 서비스 인스턴스와로드 밸런서 등을 추가 할 수 있습니다. 클라이언트 코드와 서비스 코드는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4edba5a49c7a4414557ee46319d87498dbeae513" translate="yes" xml:space="preserve">
          <source>For example when a client wants to send an order to a webshop, then it have to check the hyperlinks in the responses sent by the webshop. By checking the links it founds one described with the &lt;a href=&quot;http://schema.org/OrderAction&quot;&gt;http://schema.org/OrderAction&lt;/a&gt;. The client know the schema.org vocab, so it understands that by activating this hyperlink it will send the order. So it activates the hyperlink and sends a &lt;code&gt;POST https://example.com/api/v1/order&lt;/code&gt; message with the proper body. After that the service processes the message and responds with the result having the proper HTTP status header, for example &lt;code&gt;201 - created&lt;/code&gt; by success. To annotate messages with detailed metadata the standard solution to use an RDF format, for example &lt;a href=&quot;http://json-ld.org/&quot;&gt;JSON-LD&lt;/a&gt; with a REST vocab, for example &lt;a href=&quot;http://www.markus-lanthaler.com/hydra/&quot;&gt;Hydra&lt;/a&gt; and domain specific vocabs like &lt;a href=&quot;http://schema.org/&quot;&gt;schema.org&lt;/a&gt; or any other &lt;a href=&quot;http://lov.okfn.org/dataset/lov/&quot;&gt;linked data vocab&lt;/a&gt; and maybe a custom application specific vocab if needed. Now this is not easy, that's why most ppl use HAL and other simple formats which usually provide only a REST vocab, but no linked data support.</source>
          <target state="translated">예를 들어, 고객이 주문을 웹샵에 보내려면 웹숍에서 보낸 응답의 하이퍼 링크를 확인해야합니다. 링크를 확인하면 &lt;a href=&quot;http://schema.org/OrderAction&quot;&gt;http://schema.org/OrderAction에&lt;/a&gt; 설명 된 링크가 있습니다. 클라이언트는 schema.org vocab을 알고 있으므로이 하이퍼 링크를 활성화하면 주문을 전송한다는 것을 이해합니다. 따라서 하이퍼 링크를 활성화하고 적절한 본문과 함께 &lt;code&gt;POST https://example.com/api/v1/order&lt;/code&gt; 메시지를 보냅니다. 그 후 서비스는 메시지를 처리하고 성공으로 &lt;code&gt;201 - created&lt;/code&gt; 된 적절한 HTTP 상태 헤더 (예 : 201) 가있는 결과로 응답합니다. 상세한 메타 데이터로 메시지에 주석을 달기 위해 RDF 형식을 사용하는 표준 솔루션 (예 : REST vocab이있는 &lt;a href=&quot;http://json-ld.org/&quot;&gt;JSON-LD) (&lt;/a&gt; 예 : &lt;a href=&quot;http://schema.org/&quot;&gt;schema.org&lt;/a&gt; 또는 기타 &lt;a href=&quot;http://lov.okfn.org/dataset/lov/&quot;&gt;링크 된 데이터 vocab&lt;/a&gt; 과 같은 도메인 특정 vocab 및 사용자 정의 응용 프로그램 특정 vocab) 필요합니다. 이것은 쉬운 일이 아니기 때문에 대부분의 ppl은 일반적으로 REST vocab 만 제공하지만 링크 된 데이터는 지원하지 않는 HAL 및 기타 간단한 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="519a503f187cd31038f7706dcd1d8a0887042f78" translate="yes" xml:space="preserve">
          <source>For example, Let's imagine that we have a user database that is managed by a web service. Our service uses a custom hypermedia based on JSON, for which we assign the mimetype &lt;code&gt;application/json+userdb&lt;/code&gt; (There might also be an &lt;code&gt;application/xml+userdb&lt;/code&gt; and &lt;code&gt;application/whatever+userdb&lt;/code&gt; - many media types may be supported). The client and the server have both been programmed to understand this format, but they don't know anything about each other. As &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Roy Fielding&lt;/a&gt; points out:</source>
          <target state="translated">예를 들어, 웹 서비스에서 관리하는 사용자 데이터베이스가 있다고 가정 해 봅시다. 우리의 서비스는 mimetype &lt;code&gt;application/json+userdb&lt;/code&gt; 를 할당하기 위해 JSON 기반의 사용자 정의 하이퍼 미디어를 사용합니다 ( &lt;code&gt;application/xml+userdb&lt;/code&gt; 및 &lt;code&gt;application/whatever+userdb&lt;/code&gt; 도 있을 수 있으며 많은 미디어 유형이 지원 될 수 있음). 클라이언트와 서버는이 형식을 이해하도록 프로그래밍되었지만 서로에 대해 아무것도 모릅니다. &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;Roy Fielding이&lt;/a&gt; 지적한 바와 같이 :</target>
        </trans-unit>
        <trans-unit id="29ff533a59385e46befeb9d1d442ce81cde883fb" translate="yes" xml:space="preserve">
          <source>For example, instead a set of URLs which might look like some of the following..</source>
          <target state="translated">예를 들어, 다음 중 일부와 유사한 URL 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce3d305d56ec5c6ee26c71725d770976054d26b3" translate="yes" xml:space="preserve">
          <source>For sending and receiving messages, it involves using HTTP methods, and it does not require a strict message definition, unlike Web services.</source>
          <target state="translated">메시지를 보내고 받으려면 HTTP 메소드를 사용해야하며 웹 서비스와 달리 엄격한 메시지 정의가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="096bafb1ad02c5e340fc0cffb7efac1d03c6fdd6" translate="yes" xml:space="preserve">
          <source>Further reading:</source>
          <target state="translated">더 읽을 거리 :</target>
        </trans-unit>
        <trans-unit id="ae09a97e20415e22fe1f93eb6fbb98ed8d14de81" translate="yes" xml:space="preserve">
          <source>GET defines a reading access of the resource without side-effects. The resource is never changed via a GET request, e.g., the request has no side effects (idempotent).</source>
          <target state="translated">GET은 부작용없이 리소스에 대한 읽기 액세스를 정의합니다. 리소스는 GET 요청을 통해 절대 변경되지 않습니다. 예를 들어 요청에 부작용이 없습니다 (등전위).</target>
        </trans-unit>
        <trans-unit id="c4c41d24d5f2a151608ed14ff7819f6f47a5271f" translate="yes" xml:space="preserve">
          <source>GET: &amp;ndash; It provides read only access to a resource.</source>
          <target state="translated">GET : &amp;ndash; 리소스에 대한 읽기 전용 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5e04d05de713337d37ea8308533c814f117ef859" translate="yes" xml:space="preserve">
          <source>Given this view point, the rest style is not really tied to internet or web application. It's a fundamental solution to many of the programming situations. It is not simple either, it just makes the interface really simple, and copes with other technologies amazingly well.</source>
          <target state="translated">이러한 관점에서 볼 때 나머지 스타일은 실제로 인터넷이나 웹 응용 프로그램과 관련이 없습니다. 많은 프로그래밍 상황에 대한 근본적인 솔루션입니다. 또한 간단하지 않고 인터페이스를 정말 단순하게 만들고 다른 기술에 놀라 울 정도로 잘 대처합니다.</target>
        </trans-unit>
        <trans-unit id="413e85dd36b6612ff8f3b552ddd4ae973747eb10" translate="yes" xml:space="preserve">
          <source>Here is my basic outline of REST. I tried to demonstrate the thinking behind each of the components in a RESTful architecture so that understanding the concept is more intuitive. Hopefully this helps demystify REST for some people!</source>
          <target state="translated">다음은 REST에 대한 기본 개요입니다. RESTful 아키텍처의 각 구성 요소에 대한 생각을 보여 주어 개념을 이해하는 것이 더 직관적입니다. 바라건대 이것은 일부 사람들의 REST를 이해하는 데 도움이됩니다!</target>
        </trans-unit>
        <trans-unit id="c419bb60824d17f1c8fc3f5f0378842579d5c500" translate="yes" xml:space="preserve">
          <source>I apologize if I'm not answering the question directly, but it's easier to understand all this with more detailed examples. Fielding is not easy to understand due to all the abstraction and terminology.</source>
          <target state="translated">질문에 직접 대답하지 않으면 사과하지만 더 자세한 예를 통해이 모든 것을 이해하는 것이 더 쉽습니다. 모든 추상화와 용어로 인해 수비를 이해하기가 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="087ec8b5ab0cac5efee7be73a08f41b5611d251f" translate="yes" xml:space="preserve">
          <source>I define restful programming as</source>
          <target state="translated">나는 편안한 프로그래밍을</target>
        </trans-unit>
        <trans-unit id="ee52bb4671d83e94060d7610bdd9bf819906adce" translate="yes" xml:space="preserve">
          <source>I don't think you should feel stupid for not hearing about REST outside Stack Overflow..., I would be in the same situation!; answers to this other SO question on &lt;a href=&quot;https://stackoverflow.com/q/243388/463478&quot;&gt;Why is REST getting big now&lt;/a&gt; could ease some feelings.</source>
          <target state="translated">스택 오버플로 외부의 REST에 대해 듣지 못한다고 멍청하다고 생각하지는 않습니다. 같은 상황에 처할 것입니다.; &lt;a href=&quot;https://stackoverflow.com/q/243388/463478&quot;&gt;왜 REST가 지금 커지는가&lt;/a&gt; 에 대한 다른 SO 질문에 대한 대답 은 어떤 감정을 완화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c76368a522ebb58d381771d2b88fa3b274443e2" translate="yes" xml:space="preserve">
          <source>I found this fantastic, short, and easy to understand tutorial about REST by Dr. M. Elkstein and quoting the essential part that would answer your question for the most part:</source>
          <target state="translated">M. Elkstein 박사의 REST에 대한 환상적이고 짧고 이해하기 쉬운 튜토리얼을 발견했으며 대부분의 질문에 대답 할 수있는 필수 부분을 인용했습니다.</target>
        </trans-unit>
        <trans-unit id="6d8108db9657b6e64ef934ab59dc6f7fa01dcc70" translate="yes" xml:space="preserve">
          <source>I see a bunch of answers that say putting everything about user 123 at resource &quot;/user/123&quot; is RESTful.</source>
          <target state="translated">리소스 &quot;/ user / 123&quot;에 사용자 123에 관한 모든 것을 넣는 것이 많은 답변이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="763841bd5f36269041a09b4b998b89fbb9e2caff" translate="yes" xml:space="preserve">
          <source>I think that the most important trick to understanding the architectural importance and performance implications of a RESTful and &lt;a href=&quot;http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf&quot;&gt;Shared Nothing&lt;/a&gt; architectures is to avoid getting hung up on the technology and implementation details. Concentrate on who owns resources, who is responsible for creating/maintaining them, etc. Then think about the representations, protocols, and technologies.</source>
          <target state="translated">RESTful 및 &lt;a href=&quot;http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf&quot;&gt;Shared Nothing&lt;/a&gt; 아키텍처의 아키텍처 중요성 및 성능 영향을 이해하는 가장 중요한 트릭은 기술 및 구현 세부 사항에 얽매이지 않는 것입니다. 자원을 소유 한 사람, 자원을 작성 / 유지 관리하는 담당자 등에 집중하십시오. 그런 다음 표현, 프로토콜 및 기술에 대해 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="d0530a0292feea24c4a9346fcd870c5d42a8ef18" translate="yes" xml:space="preserve">
          <source>I think the point of restful is the &lt;strong&gt;separation of the statefulness into a higher layer&lt;/strong&gt; while making use of the internet (protocol) as a &lt;strong&gt;stateless transport layer&lt;/strong&gt;. Most other approaches mix things up.</source>
          <target state="translated">편안한 점은 인터넷 (프로토콜)을 &lt;strong&gt;상태 비 저장 전송 계층&lt;/strong&gt; 으로 사용하면서 &lt;strong&gt;상태 저장을 상위 계층으로 분리&lt;/strong&gt; 하는 것입니다. 대부분의 다른 접근법은 사물을 혼합합니다.</target>
        </trans-unit>
        <trans-unit id="c322421456d9bf2c2db73cb8c6cdc0e978e2f5ea" translate="yes" xml:space="preserve">
          <source>I would say RESTful programming would be about creating systems (API) that follow the REST architectural style.</source>
          <target state="translated">RESTful 프로그래밍은 REST 아키텍처 스타일을 따르는 시스템 (API)을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7efc17b40148a3f7a450c659d22a107b0159fbac" translate="yes" xml:space="preserve">
          <source>I would say that an important building block in understanding REST lies in the endpoints or mappings, such as &lt;code&gt;/customers/{id}/balance&lt;/code&gt;.</source>
          <target state="translated">REST를 이해하는 데 중요한 빌딩 블록은 엔드 포인트 또는 매핑 (예 : &lt;code&gt;/customers/{id}/balance&lt;/code&gt; )에 있습니다.</target>
        </trans-unit>
        <trans-unit id="00c15a6f862dfb4e67e15e8fab5e3217684aa057" translate="yes" xml:space="preserve">
          <source>I'm not looking to self promote, but i expand on these ideas to great depth in my talk &lt;a href=&quot;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&quot;&gt;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&lt;/a&gt; .</source>
          <target state="translated">나는 스스로 홍보하고 싶지는 않지만 내 아이디어 &lt;a href=&quot;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&quot;&gt;http://techblog.bodybuilding.com/2016/01/video-what-is-restful-200.html&lt;/a&gt; 에서 이러한 아이디어를 심도있게 확장합니다.</target>
        </trans-unit>
        <trans-unit id="c54b01044e3ae27d309c48efbe56fe8b30a02fdb" translate="yes" xml:space="preserve">
          <source>IMO:</source>
          <target state="translated">IMO:</target>
        </trans-unit>
        <trans-unit id="528e227c40908c4c76424c153287878418391881" translate="yes" xml:space="preserve">
          <source>If I had to reduce the original dissertation on REST to just 3 short sentences, I think the following captures its essence:</source>
          <target state="translated">REST의 원래 논문을 단 3 문장으로 줄여야한다면 다음 내용이 본질이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="3e4a789505499d4ebc9acf09affff2580e66a8db" translate="yes" xml:space="preserve">
          <source>If you are really interested in what a RESTful architecture is and why it works, read &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;his thesis&lt;/a&gt; a few times and read the &lt;strong&gt;whole thing&lt;/strong&gt; not just Chapter 5! Next look into &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;why DNS works&lt;/a&gt;. Read about the hierarchical organization of DNS and how referrals work. Then read and consider how DNS caching works. Finally, read the HTTP specifications (&lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; and &lt;a href=&quot;http://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; in particular) and consider how and why the caching works the way that it does. Eventually, it will just click. The final revelation for me was when I saw the similarity between DNS and HTTP. After this, understanding why SOA and Message Passing Interfaces are scalable starts to click.</source>
          <target state="translated">RESTful 아키텍처가 무엇이고 왜 작동하는지에 정말로 관심이 있다면, &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf&quot;&gt;그의 논문&lt;/a&gt; 을 몇 번 읽고 5 장뿐만 아니라 &lt;strong&gt;전체&lt;/strong&gt; 내용을 읽으십시오! 다음으로 &lt;a href=&quot;http://tools.ietf.org/html/rfc1034&quot;&gt;DNS가 작동하는 이유를&lt;/a&gt; 살펴보십시오. DNS의 계층 적 구성 및 조회 작동 방식에 대해 읽으십시오. 그런 다음 DNS 캐싱 작동 방식을 읽고 고려하십시오. 마지막으로 HTTP 사양 (특히 &lt;a href=&quot;http://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; 및 &lt;a href=&quot;http://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; )을 읽고 캐싱이 작동하는 방식과 이유를 고려하십시오. 결국 클릭 만하면됩니다. 마지막 계시는 DNS와 HTTP의 유사성을 보았을 때였습니다. 그런 다음 SOA와 메시지 전달 인터페이스가 확장 가능한 이유를 이해하면 클릭이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5c9c0f1f96e6c661dd2c0857fa65fd08bb396af3" translate="yes" xml:space="preserve">
          <source>In a REST based architecture you have a REST server which provides
  access to the resources. A REST client can access and modify the REST
  resources.</source>
          <target state="translated">REST 기반 아키텍처에는 자원에 대한 액세스를 제공하는 REST 서버가 있습니다. REST 클라이언트는 REST 자원에 액세스하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7fcadf01fdd539dc00964a4063d163ad342bf9" translate="yes" xml:space="preserve">
          <source>In a REST based architecture, everything is a resource(Users, Orders, Comments). A resource is accessed via a common interface based on the HTTP standard methods(GET, PUT, PATCH, DELETE etc).</source>
          <target state="translated">REST 기반 아키텍처에서 모든 것은 리소스 (사용자, 주문, 의견)입니다. HTTP 표준 방법 (GET, PUT, PATCH, DELETE 등)을 기반으로 공통 인터페이스를 통해 리소스에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="81af6a9f5471cbc482ac157847e6af8a50d7537f" translate="yes" xml:space="preserve">
          <source>In computing, representational state transfer (REST) is an
  architectural style used for web development.</source>
          <target state="translated">컴퓨팅에서 REST (Representational State Transfer)는 웹 개발에 사용되는 아키텍처 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="508381eb480015bf82a7312e0cfb8e350127a358" translate="yes" xml:space="preserve">
          <source>In many ways, the World Wide Web itself, based on HTTP, can be viewed
  as a REST-based architecture. RESTful applications use HTTP requests
  to post data (create and/or update), read data (e.g., make queries),
  and delete data. Thus, REST uses HTTP for all four CRUD
  (Create/Read/Update/Delete) operations.</source>
          <target state="translated">여러 가지면에서 HTTP 기반의 월드 와이드 웹 자체는 REST 기반 아키텍처로 볼 수 있습니다. RESTful 애플리케이션은 HTTP 요청을 사용하여 데이터 게시 (생성 및 / 또는 업데이트), 데이터 읽기 (예 : 쿼리 작성) 및 데이터 삭제를 수행합니다. 따라서 REST는 4 개의 CRUD (작성 / 읽기 / 업데이트 / 삭제) 오퍼레이션 모두에 HTTP를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9afec0b39286ce35f8ff306c75875ec463e27211" translate="yes" xml:space="preserve">
          <source>In many ways, the World Wide Web itself, based on HTTP, can be viewed    as a REST-based architecture.</source>
          <target state="translated">여러 가지면에서 HTTP 기반의 월드 와이드 웹 자체는 REST 기반 아키텍처로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d9b177727972b7bd403cb1d9830e8972f6ccaf" translate="yes" xml:space="preserve">
          <source>In other words you're writing simple point-to-point network applications over HTTP which uses verbs such as GET, POST, PUT or DELETE by implementing RESTful architecture which proposes standardization of the interface each &amp;ldquo;resource&amp;rdquo; exposes. It is nothing that using current features of the web in a simple and effective way (highly successful, proven and distributed architecture). It is an alternative to more complex mechanisms like &lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture&quot;&gt;CORBA&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt;.</source>
          <target state="translated">다시 말해, 각&amp;ldquo;리소스&amp;rdquo;가 제공하는 인터페이스의 표준화를 제안하는 RESTful 아키텍처를 구현하여 GET, POST, PUT 또는 DELETE와 같은 동사를 사용하는 HTTP를 통해 간단한 지점 간 네트워크 애플리케이션을 작성하고 있습니다. 웹의 현재 기능을 간단하고 효과적인 방식 (고 성공, 입증 및 분산 아키텍처)으로 사용하는 것은 아닙니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture&quot;&gt;CORBA&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt; 와 같은보다 복잡한 메커니즘에 대한 대안입니다.</target>
        </trans-unit>
        <trans-unit id="9075c88ba609ac32ad4853adceff80a57b9c8848" translate="yes" xml:space="preserve">
          <source>In the end &lt;strong&gt;any RESTful client should be able to consume to any RESTful service as long as the content format is known.&lt;/strong&gt;</source>
          <target state="translated">결국 &lt;strong&gt;컨텐츠 형식을 알고있는 한 RESTful 클라이언트는 모든 RESTful 서비스를 사용할 수 있어야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6435852cb4e96cc87686e94b5374a8056f393527" translate="yes" xml:space="preserve">
          <source>In the future, you can then retrieve the user information:</source>
          <target state="translated">나중에 사용자 정보를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6ecb449599f6dd2f5e9713553e3cd31fe1f0435" translate="yes" xml:space="preserve">
          <source>Install POSTMAN(Chrome) / REST(Firefox) plugin</source>
          <target state="translated">POSTMAN (Chrome) / REST (Firefox) 플러그인 설치</target>
        </trans-unit>
        <trans-unit id="6a6d9700ec195facf4fac9e8b95e37072828dc22" translate="yes" xml:space="preserve">
          <source>Interestingly, there is no mention of HTTP POST, GET, DELETE, or PUT operations in the dissertation. That must be someone's later interpretation of a &quot;best practice&quot; for a &quot;uniform interface&quot;.</source>
          <target state="translated">흥미롭게도 논문에 HTTP POST, GET, DELETE 또는 PUT 작업에 대한 언급은 없습니다. 그것은 나중에 &quot;균일 한 인터페이스&quot;에 대한 &quot;모범 사례&quot;에 대한 누군가의 해석이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f9de0a4336192b307d47a7bd6e45e0eaef080436" translate="yes" xml:space="preserve">
          <source>Introduction about Rest</source>
          <target state="translated">휴식에 대한 소개</target>
        </trans-unit>
        <trans-unit id="b9c999a74770669b9c8ffb4ad17078f65b2cda93" translate="yes" xml:space="preserve">
          <source>It relies on a stateless, client-server, cacheable communications protocol -- and in virtually all cases, the HTTP protocol is used.</source>
          <target state="translated">상태 비 저장 클라이언트 서버 캐시 가능 통신 프로토콜에 의존하며 사실상 모든 경우에 HTTP 프로토콜이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1117236a998be55f80d560abd424de90ea9e2991" translate="yes" xml:space="preserve">
          <source>It will return output response</source>
          <target state="translated">출력 응답을 반환합니다</target>
        </trans-unit>
        <trans-unit id="c89e148b7af16b441451c1995bfe2abaf6361908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an arrangement of functions on which the testers performs requests and receive responses. In REST API interactions are made via HTTP protocol.</source>
          <target state="translated">테스터가 요청을 수행하고 응답을받는 기능의 배열입니다. REST API 상호 작용은 HTTP 프로토콜을 통해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="f0fc1358f601de6b260eab812260ed0430f7e282" translate="yes" xml:space="preserve">
          <source>It's been the best practical approach to handle the fundamental changes of programming in internet era. Regarding the fundamental changes, Erik Meijer has a discussion on show here: &lt;a href=&quot;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&quot;&gt;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&lt;/a&gt; . He summarizes it as the five effects, and presents a solution by designing the solution into a programming language. The solution, could also be achieved in the platform or system level, regardless of the language. The restful could be seen as one of the solutions that has been very successful in the current practice.</source>
          <target state="translated">인터넷 시대의 프로그래밍의 근본적인 변화를 처리하는 가장 실용적인 접근 방식이었습니다. 근본적인 변화와 관련하여 Erik Meijer는 &lt;a href=&quot;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&quot;&gt;http://www.infoq.com/interviews/erik-meijer-programming-language-design-effects-purity#view_93197&lt;/a&gt; 에 대한 토론을 진행했습니다. 그는이를 5 가지 효과로 요약하고 솔루션을 프로그래밍 언어로 디자인하여 솔루션을 제시합니다. 솔루션은 언어에 관계없이 플랫폼 또는 시스템 수준에서 달성 될 수도 있습니다. 나머지는 현재의 실습에서 매우 성공적인 솔루션 중 하나로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4929d90be24c95c993943d45502f80422e27a62" translate="yes" xml:space="preserve">
          <source>It's programming where the architecture of your system fits the &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;REST style&lt;/a&gt; laid out by Roy Fielding in &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;his thesis&lt;/a&gt;. Since this is the architectural style that describes the web (more or less), lots of people are interested in it.</source>
          <target state="translated">시스템의 아키텍처가 Roy Fielding이 &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;그의 논문&lt;/a&gt; 에서 제시 한 &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;REST 스타일&lt;/a&gt; 에 맞는 프로그래밍입니다. 이것은 웹을 묘사하는 건축 스타일이기 때문에 (많거나 적음) 많은 사람들이 웹에 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e58b34ecd5fe46f5c7fac142a7753476a694f3e" translate="yes" xml:space="preserve">
          <source>JSON is not restful programming</source>
          <target state="translated">JSON은 편안한 프로그래밍이 아닙니다</target>
        </trans-unit>
        <trans-unit id="a6b85e0f041b2c7697f401797ec1377054a290db" translate="yes" xml:space="preserve">
          <source>Just my 2c.</source>
          <target state="translated">그냥 내 2c.</target>
        </trans-unit>
        <trans-unit id="bbe8d64fcde25a40febca185bf5ef63d774333ce" translate="yes" xml:space="preserve">
          <source>Keep in mind that GET requests should never be used for updating information. For example, a GET request for adding an item to a cart</source>
          <target state="translated">GET 요청은 정보를 업데이트하는 데 사용해서는 안됩니다. 예를 들어 장바구니에 상품을 추가하기위한 GET 요청</target>
        </trans-unit>
        <trans-unit id="5f82e7663dd4156cb07776cb1cea89dd1aba1b01" translate="yes" xml:space="preserve">
          <source>Layered system</source>
          <target state="translated">계층화 된 시스템</target>
        </trans-unit>
        <trans-unit id="133b041c9729c525d972a67420b5a147370536ad" translate="yes" xml:space="preserve">
          <source>Learn REST: A Tutorial</source>
          <target state="translated">REST 배우기 : 튜토리얼</target>
        </trans-unit>
        <trans-unit id="d48495a4077a6c79d43f781b565680695cf2d342" translate="yes" xml:space="preserve">
          <source>Martin Fowler's
thoughts</source>
          <target state="translated">마틴 파울러의 생각</target>
        </trans-unit>
        <trans-unit id="de83e0aeb9afb13ea59f9bf7102b93ccfae94aaa" translate="yes" xml:space="preserve">
          <source>Metadata is passed as name-value pairs (post data and query string parameters).</source>
          <target state="translated">메타 데이터는 이름-값 쌍 (포스트 데이터 및 쿼리 문자열 매개 변수)으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b45afbd2f6f71f5bbf40bc713d36b1cb5591272d" translate="yes" xml:space="preserve">
          <source>Must reads are &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;Representational State Transfer (REST)&lt;/a&gt; and &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIs must be hypertext-driven&lt;/a&gt;</source>
          <target state="translated">읽기는 &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&quot;&gt;REST (Representational State Transfer)&lt;/a&gt; &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;여야&lt;/a&gt; 하고 REST API는 하이퍼 텍스트 중심이어야합니다.</target>
        </trans-unit>
        <trans-unit id="75117da5ea6dd4a55238ac032ebaaa4e06e4091c" translate="yes" xml:space="preserve">
          <source>Notice that we are using different HTTP verbs (&lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; etc.) to manipulate these resources, and that the only knowledge we presume on the client's part is our media definition.</source>
          <target state="translated">이러한 리소스를 조작하기 위해 서로 다른 HTTP 동사 ( &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 등)를 사용하고 있으며 클라이언트 측에서 추정하는 지식은 미디어 정의뿐입니다.</target>
        </trans-unit>
        <trans-unit id="83b061b2a63b8f2183eb1bdcdd47faa9c5345256" translate="yes" xml:space="preserve">
          <source>Now, if all of this sounds familiar, then great. The Hypertext Transfer Protocol (HTTP), which defines the communication protocol via the World Wide Web is an implementation of the abstract notion of RESTful architecture (or an instance of the REST class if you're an OOP fanatic like me). In this implementation of REST, the client and server interact via GET, POST, PUT, DELETE, etc., which are part of the universal language and the resources can be pointed to using URLs.</source>
          <target state="translated">이 모든 것이 친숙하게 들린다면 훌륭합니다. 월드 와이드 웹을 통해 통신 프로토콜을 정의하는 HTTP (Hypertext Transfer Protocol)는 RESTful 아키텍처 (또는 OOP 광신자 인 경우 REST 클래스의 인스턴스)의 추상 개념을 구현 한 것입니다. 이 REST 구현에서 클라이언트와 서버는 GET, POST, PUT, DELETE 등을 통해 상호 작용하며, 이는 범용 언어의 일부이며 URL을 사용하여 리소스를 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1a9621fd53f3f752aff5f25b313a5a3c60c684e" translate="yes" xml:space="preserve">
          <source>Old question, newish way of answering.  There's a lot of misconception out there about this concept.  I always try to remember:</source>
          <target state="translated">오래된 질문, 새로운 답변 방법. 이 개념에 대해 많은 오해가 있습니다. 나는 항상 기억하려고합니다 :</target>
        </trans-unit>
        <trans-unit id="438027d47ce1c5a96c385f53eecd236c425fb2b5" translate="yes" xml:space="preserve">
          <source>One of the best reference I found when I try to find the simple real meaning of rest.</source>
          <target state="translated">내가 쉬는 것의 단순한 진정한 의미를 찾으려고 할 때 내가 찾은 최고의 참고 문헌 중 하나.</target>
        </trans-unit>
        <trans-unit id="c6f2d9e5ea80ff9b7b9ded9e2a81fb5f446691e1" translate="yes" xml:space="preserve">
          <source>POST updates an existing resource or creates a new resource.</source>
          <target state="translated">POST는 기존 리소스를 업데이트하거나 새 리소스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d742711b2a6bd7b769816a15fa5a239a2c74f940" translate="yes" xml:space="preserve">
          <source>POST: &amp;ndash; It is used to create or update a new resource.</source>
          <target state="translated">POST : &amp;ndash; 새 자원을 작성하거나 업데이트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="37e0818cbbbc83b5f7771a4d5dfae0eb226e31e7" translate="yes" xml:space="preserve">
          <source>PUT creates a new resource. It must also be idempotent.</source>
          <target state="translated">PUT은 새로운 자원을 작성합니다. 또한 dem 등원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ada2743b893defbc7c8ab2a60424b669dd79a22b" translate="yes" xml:space="preserve">
          <source>PUT: &amp;ndash; It is used to update or replace an existing resource or create a new resource.</source>
          <target state="translated">PUT : &amp;ndash; 기존 리소스를 업데이트 또는 교체하거나 새 리소스를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="675a94eb09e6d971c2a74e502df85b0396498a6f" translate="yes" xml:space="preserve">
          <source>PayPal's API has hypermedia controls</source>
          <target state="translated">PayPal의 API에는 하이퍼 미디어 컨트롤이 있습니다</target>
        </trans-unit>
        <trans-unit id="330809f2cc51f1c140e1980086142c16a9addb97" translate="yes" xml:space="preserve">
          <source>Principle 1: Everything is a Resource
In the REST architectural style, data and functionality are considered resources and are accessed using Uniform Resource Identifiers (URIs), typically links on the Web.</source>
          <target state="translated">원칙 1 : 모든 것이 하나의 리소스 REST 아키텍처 스타일에서 데이터와 기능은 리소스로 간주되며 일반적으로 웹의 링크 인 URI (Uniform Resource Identifier)를 사용하여 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="8c699adbd41e9b331e5fbd3c027ab2582737eb63" translate="yes" xml:space="preserve">
          <source>Principle 2: Every Resource is Identified by a Unique Identifier (URI)</source>
          <target state="translated">원칙 2 : 모든 리소스는 고유 식별자 (URI)로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="b612f5757ab3b67dcdf0fc959e4a1f2295c39bfc" translate="yes" xml:space="preserve">
          <source>Principle 3: Use Simple and Uniform Interfaces</source>
          <target state="translated">원칙 3 : 단순하고 균일 한 인터페이스 사용</target>
        </trans-unit>
        <trans-unit id="1c4054641d8394bb16320893dba0d8f48d910d14" translate="yes" xml:space="preserve">
          <source>Principle 4: Communication is Done by Representation</source>
          <target state="translated">원칙 4 : 의사 소통은 대표자에 의해 이루어짐</target>
        </trans-unit>
        <trans-unit id="52e149151dd57ddc7a1edcf0a393bb8fc2cc1dc9" translate="yes" xml:space="preserve">
          <source>Principle 5: Be Stateless</source>
          <target state="translated">원칙 5 : 무국적자</target>
        </trans-unit>
        <trans-unit id="3b6ad19884af654ebfaa84e23196de80335cb4c9" translate="yes" xml:space="preserve">
          <source>Protocols are limited to what you can communicate by using URLs.</source>
          <target state="translated">프로토콜은 URL을 사용하여 통신 할 수있는 대상으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="ea0905504dfdf615e0862b8f2c6ac34fbc396c3b" translate="yes" xml:space="preserve">
          <source>REST (Representational State Transfer) is a design architecture that outlines how networked resources (i.e. nodes that share information) are designed and addressed. In general, a RESTful architecture makes it so that the client (the requesting machine) and the server (the responding machine) can request to read, write, and update data without the client having to know how the server operates and the server can pass it back without needing to know anything about the client. Okay, cool...but how do we do this in practice?</source>
          <target state="translated">REST (Representational State Transfer)는 네트워크 리소스 (예 : 정보를 공유하는 노드)를 설계하고 해결하는 방법을 간략하게 설명하는 설계 아키텍처입니다. 일반적으로 RESTful 아키텍처는 클라이언트 (요청 시스템) 및 서버 (응답 시스템)가 서버 작동 방식 및 서버 전달 방법을 몰라도 클라이언트가 데이터 읽기, 쓰기 및 업데이트를 요청할 수 있도록합니다. 클라이언트에 대해 알 필요없이 다시 돌아옵니다. 좋아, 근사하지만 우리는 실제로 어떻게 이것을 하는가?</target>
        </trans-unit>
        <trans-unit id="700c9dae20f56bed7f78e92f023ff70ce8630a9f" translate="yes" xml:space="preserve">
          <source>REST === HTTP analogy is not correct until you do not stress to the fact that it &quot;MUST&quot; be &lt;a href=&quot;http://restfulapi.net/hateoas/&quot;&gt;HATEOAS&lt;/a&gt; driven.</source>
          <target state="translated">REST === HTTP 유사성은 &quot;MUST&quot;가 &lt;a href=&quot;http://restfulapi.net/hateoas/&quot;&gt;HATEOAS&lt;/a&gt; 기반이라는 사실을 강조하지 않으면 정확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d900533fc0307874766ce99858e2dca6a98b0ed" translate="yes" xml:space="preserve">
          <source>REST allows that resources have different representations, e.g., text, XML, JSON etc. The REST client can ask for a specific representation via the HTTP protocol (content negotiation).</source>
          <target state="translated">REST는 자원이 텍스트, XML, JSON 등과 같은 다른 표현을 가질 수 있도록합니다. REST 클라이언트는 HTTP 프로토콜 (콘텐츠 협상)을 통해 특정 표현을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e35d79a67bcd2fd91ce8bbd613ef5c12223b40" translate="yes" xml:space="preserve">
          <source>REST also permits communication between computers with each other over a network.</source>
          <target state="translated">REST는 또한 네트워크를 통해 서로 컴퓨터 간의 통신을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7bebea77f381f6a449770f9552c88ba86e2ca2da" translate="yes" xml:space="preserve">
          <source>REST constraints result a highly scalable system in where the clients are decoupled from the implementations of the services. So the clients can be reusable, general just like the browsers on the web. The clients and the services share the same standards and vocabs, so they can understand each other despite the fact that the client does not know the implementation details of the service. This makes possible to create automated clients which can find and utilize REST services to achieve their goals. In long term these clients can communicate to each other and trust each other with tasks, just like humans do. If we add learning patterns to such clients, then the result will be one or more AI using the web of machines instead of a single server park. So at the end the dream of Berners Lee: the semantic web and the artificial intelligence will be reality. So in 2030 we end up terminated by the Skynet. Until then ... ;-)</source>
          <target state="translated">REST 제약 조건은 클라이언트가 서비스 구현에서 분리되는 확장 성이 뛰어난 시스템입니다. 따라서 웹 브라우저와 마찬가지로 클라이언트를 재사용 할 수 있습니다. 클라이언트와 서비스는 동일한 표준과 어휘를 공유하므로 클라이언트가 서비스의 구현 세부 사항을 모른다는 사실에도 불구하고 서로를 이해할 수 있습니다. 이를 통해 REST 서비스를 찾고 활용하여 목표를 달성 할 수있는 자동화 된 클라이언트를 작성할 수 있습니다. 장기적으로 이러한 고객은 인간과 마찬가지로 서로 의사 소통하고 업무를 통해 서로를 신뢰할 수 있습니다. 이러한 클라이언트에 학습 패턴을 추가하면 단일 서버 파크 대신 머신 웹을 사용하여 하나 이상의 AI가 생성됩니다. 결국 Berners Lee의 꿈은 시맨틱 웹과 인공 지능이 현실이 될 것입니다. 그래서 2030 년에 우리는 스카이 넷에 의해 종료되었습니다. 그때까지 ... ;-)</target>
        </trans-unit>
        <trans-unit id="34698ed4c6b87bbba6909fe832abf0a97a18c1e4" translate="yes" xml:space="preserve">
          <source>REST defines 6 architectural constraints which make any web service &amp;ndash; a &lt;strong&gt;true RESTful API&lt;/strong&gt;.</source>
          <target state="translated">REST는 웹 서비스를 &lt;strong&gt;진정한 RESTful API로&lt;/strong&gt; 만드는 6 가지 아키텍처 제약 조건을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2b8ff55c8c9a0ce9cfafc137b16baaa14a81abbf" translate="yes" xml:space="preserve">
          <source>REST in official words, REST is an architectural style built on certain principles using the current &amp;ldquo;Web&amp;rdquo; fundamentals.
There are 5 basic fundamentals of web which are leveraged to create REST services.</source>
          <target state="translated">공식적으로 말하면 REST는 현재 &quot;웹&quot;기본을 사용하는 특정 원칙을 기반으로하는 아키텍처 스타일입니다. REST 서비스를 생성하기 위해 활용되는 5 가지 기본 기본 웹 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="24e5aabd86f26882f23d01381f1a89f3a170449f" translate="yes" xml:space="preserve">
          <source>REST is a lightweight alternative to mechanisms like RPC (Remote
  Procedure Calls) and Web Services (SOAP, WSDL, et al.). Later, we will
  see how much more simple REST is.</source>
          <target state="translated">REST는 RPC (Remote Procedure Calls) 및 웹 서비스 (SOAP, WSDL 등)와 같은 메커니즘에 대한 간단한 대안입니다. 나중에 REST가 얼마나 간단한 지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="41d578dc3834d7de2f8d99a70b26c5ce81a848f5" translate="yes" xml:space="preserve">
          <source>REST is an &lt;em&gt;architecture style&lt;/em&gt; for designing networked applications.
  The idea is that, rather than using complex mechanisms such as CORBA,
  RPC or SOAP to connect between machines, simple HTTP is used to make
  calls between machines.</source>
          <target state="translated">REST는 네트워크 애플리케이션을 설계하기위한 &lt;em&gt;아키텍처 스타일&lt;/em&gt; 입니다. 아이디어는 CORBA, RPC 또는 SOAP와 같은 복잡한 메커니즘을 사용하여 시스템간에 연결하는 대신 간단한 HTTP를 사용하여 시스템간에 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="81954ff90e3db76a59f3feac17fcae16db3073fb" translate="yes" xml:space="preserve">
          <source>REST is an architectural pattern and style of writing distributed applications. It is not a programming style in the narrow sense.</source>
          <target state="translated">REST는 분산 애플리케이션을 작성하는 아키텍처 패턴 및 스타일입니다. 좁은 의미에서 프로그래밍 스타일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6e3584ec485599f05ec62cb2d6b674b68d8c649a" translate="yes" xml:space="preserve">
          <source>REST is an architecture style for designing networked applications.
  The idea is that, rather than using complex mechanisms such as CORBA,
  RPC or SOAP to connect between machines, simple HTTP is used to make
  calls between machines.</source>
          <target state="translated">REST는 네트워크 애플리케이션을 설계하기위한 아키텍처 스타일입니다. 아이디어는 CORBA, RPC 또는 SOAP와 같은 복잡한 메커니즘을 사용하여 시스템간에 연결하는 대신 간단한 HTTP를 사용하여 시스템간에 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6663bc679f3ecc9321597d4c451eda8a030d5e82" translate="yes" xml:space="preserve">
          <source>REST is often used in mobile applications, social networking Web sites, mashup tools and automated business processes. The REST style emphasizes that interactions between clients and services is enhanced by having a limited number of operations (verbs). Flexibility is provided by assigning resources (nouns) their own unique universal resource indicators (URIs).</source>
          <target state="translated">REST는 종종 모바일 애플리케이션, 소셜 네트워킹 웹 사이트, 매시업 도구 및 자동화 된 비즈니스 프로세스에서 사용됩니다. REST 스타일은 제한된 수의 연산 (동사)을 사용하여 클라이언트와 서비스 간의 상호 작용이 향상됨을 강조합니다. 자원 (명사)에 고유 한 URI (Universal Resource Indicator)를 지정하여 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="801d3af1b3e139b50282c4fab565cd444620074b" translate="yes" xml:space="preserve">
          <source>REST is using the various HTTP methods (mainly GET/PUT/DELETE) to manipulate data.</source>
          <target state="translated">REST는 다양한 HTTP 메소드 (주로 GET / PUT / DELETE)를 사용하여 데이터를 조작합니다.</target>
        </trans-unit>
        <trans-unit id="3a544da22b9e3f4d834aba2d28e038cfc7c394d2" translate="yes" xml:space="preserve">
          <source>REST messages often accepts the form either in form of XML, or JavaScript Object Notation (JSON).</source>
          <target state="translated">REST 메시지는 종종 XML 또는 JSON (JavaScript Object Notation) 형식으로 양식을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="ec356ddaca2bf110584184b56abbca5c18c7f324" translate="yes" xml:space="preserve">
          <source>REST proponents tend to favor URLs, such as</source>
          <target state="translated">REST 제안자는 다음과 같은 URL을 선호하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdaffecf9a4b409c44dd9af81374c459b9474d48" translate="yes" xml:space="preserve">
          <source>REST stands for &quot;representational state transfer&quot;, which means it's all about communicating and modifying &lt;strong&gt;the state&lt;/strong&gt; of some resource in a system.</source>
          <target state="translated">REST는 &quot;표현 상태 전송&quot;을 나타내며, 이는 시스템에서 일부 자원 &lt;strong&gt;의 상태&lt;/strong&gt; 를 통신하고 수정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9451e5791b00a17503496c3f9586128ae49e1831" translate="yes" xml:space="preserve">
          <source>REST stands for Representational State Transfer. (It is sometimes
  spelled &quot;ReST&quot;.) It relies on a stateless, client-server, cacheable
  communications protocol -- and in virtually all cases, the HTTP
  protocol is used.</source>
          <target state="translated">REST는 Representational State Transfer를 나타냅니다. &quot;ReST&quot;라고도합니다. 상태 비 저장 클라이언트 서버 캐시 가능한 통신 프로토콜을 사용하며 거의 모든 경우 HTTP 프로토콜이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d1d7194413fe6b5bd76ca3ce8b73781e5ea0578" translate="yes" xml:space="preserve">
          <source>REST unlike home styles has had a tough time being consistently and practically applied. This may have been intentional. Leaving its actual implementation up to the designer. So you are free to do what you want so as long as you meet the constraints set out in the dissertation you are creating REST Systems.</source>
          <target state="translated">홈 스타일과 달리 REST는 일관되고 실용적으로 힘든 시간을 보냈습니다. 의도적 인 것일 수 있습니다. 실제 구현을 디자이너에게 맡기십시오. 따라서 REST 시스템을 작성중인 논문에 설정된 제한 조건을 충족하는 한 원하는대로 자유롭게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ac191e5aa73c941d92cf5c5a7bdc101ccf17488" translate="yes" xml:space="preserve">
          <source>REST, operates on resource representations, each one identified by an URL. These are typically not data objects, but &lt;strong&gt;complex objects abstractions&lt;/strong&gt;.</source>
          <target state="translated">REST는 URL로 식별되는 각각의 리소스 표현에 대해 작동합니다. 이들은 일반적으로 데이터 객체가 아니라 &lt;strong&gt;복잡한 객체 추상화&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20bbdde9c5678f79d072b94099e0cd21aa108d71" translate="yes" xml:space="preserve">
          <source>REST: Representational State Transfer.</source>
          <target state="translated">REST : 대표 상태 이전.</target>
        </trans-unit>
        <trans-unit id="0b418318f4f02e384e5a14b7c46def85c5fbf491" translate="yes" xml:space="preserve">
          <source>RESTful applications use HTTP requests to post data (create and/or
  update), read data (e.g., make queries), and delete data. Thus, REST
  uses HTTP for all four CRUD (Create/Read/Update/Delete) operations.</source>
          <target state="translated">RESTful 애플리케이션은 HTTP 요청을 사용하여 데이터 게시 (생성 및 / 또는 업데이트), 데이터 읽기 (예 : 쿼리 작성) 및 데이터 삭제를 수행합니다. 따라서 REST는 4 개의 CRUD (작성 / 읽기 / 업데이트 / 삭제) 오퍼레이션 모두에 HTTP를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d1feb4628e89cf3c408102d8d1c78190e38e6958" translate="yes" xml:space="preserve">
          <source>RESTful programming conforms to Web architecture design and, if properly implemented, it allows you to take the full advantage of scalable Web infrastructure.</source>
          <target state="translated">RESTful 프로그래밍은 웹 아키텍처 디자인을 준수하며 올바르게 구현 된 경우 확장 가능한 웹 인프라를 최대한 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="606ada79ad1420f9107ba76e74d9a5b5dc8a1dc1" translate="yes" xml:space="preserve">
          <source>RESTful programming is about:</source>
          <target state="translated">RESTful 프로그래밍은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95c224223718abd56088ba177080385db881b4c6" translate="yes" xml:space="preserve">
          <source>RESTful programming is not for APIs</source>
          <target state="translated">RESTful 프로그래밍은 API 용이 아닙니다</target>
        </trans-unit>
        <trans-unit id="1b6a739654e06f630f96467756d48d1acd0d09d0" translate="yes" xml:space="preserve">
          <source>Rather than using a specific URL to delete a method (say, &lt;code&gt;/user/123/delete&lt;/code&gt;), you would send a DELETE request to the &lt;code&gt;/user/[id]&lt;/code&gt; URL, to edit a user, to retrieve info on a user you send a GET request to &lt;code&gt;/user/[id]&lt;/code&gt;</source>
          <target state="translated">특정 URL을 사용하여 메소드를 삭제하는 대신 (예 : &lt;code&gt;/user/123/delete&lt;/code&gt; ), &lt;code&gt;/user/[id]&lt;/code&gt; URL에 DELETE 요청을 보내 사용자 를 편집하고 보내는 사용자의 정보를 검색합니다 &lt;code&gt;/user/[id]&lt;/code&gt; 에 GET 요청</target>
        </trans-unit>
        <trans-unit id="7d997a652dd80f71fb70e3ef43e6973ddd897ea7" translate="yes" xml:space="preserve">
          <source>Representation - all communication is done by representation (e.g. &lt;a href=&quot;http://en.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt;/&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt;)</source>
          <target state="translated">표현-모든 통신은 표현에 의해 수행됩니다 (예 : &lt;a href=&quot;http://en.wikipedia.org/wiki/XML&quot;&gt;XML&lt;/a&gt; / &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON&quot;&gt;JSON&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="2cd1d833a928d3195b51e6cfbe331c8c09c671dd" translate="yes" xml:space="preserve">
          <source>Resource (data, information).</source>
          <target state="translated">자원 (데이터, 정보).</target>
        </trans-unit>
        <trans-unit id="688688c5509b4d381bf4bce90f16794ddee6aacb" translate="yes" xml:space="preserve">
          <source>Resources are requested via URLs.</source>
          <target state="translated">리소스는 URL을 통해 요청됩니다.</target>
        </trans-unit>
        <trans-unit id="c171c3ae71443c15b078bb93540e67b075abe63a" translate="yes" xml:space="preserve">
          <source>Richardson's Maturity Model</source>
          <target state="translated">리차드슨의 성숙 모형</target>
        </trans-unit>
        <trans-unit id="07bef3db6d8f0a971b46410592e99f25edb3d822" translate="yes" xml:space="preserve">
          <source>Roy Fielding, who coined the term, says &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST APIs must be hypertext-driven&lt;/a&gt;.  In particular, &quot;A REST API must not define fixed resource names or hierarchies&quot;.</source>
          <target state="translated">이 용어를 만든 Roy Fielding은 &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;REST API가 하이퍼 텍스트 중심이어야&lt;/a&gt; 한다고 말합니다. 특히, &quot;A REST API는 고정 자원 이름 또는 계층을 정의해서는 안됩니다&quot;.</target>
        </trans-unit>
        <trans-unit id="4ed7f7fd296ad882c584b68eec97a766f06c9204" translate="yes" xml:space="preserve">
          <source>Roy himself cleared it &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">로이 자신이 &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;여기서&lt;/a&gt; 그것을 정리했다.</target>
        </trans-unit>
        <trans-unit id="ea8f1dff43bf90df7c15069182244296157f5ccf" translate="yes" xml:space="preserve">
          <source>Saying that Rest is just a syntactic change from using GET requests with an action parameter to using the available http verbs makes it look like it has no benefits and is purely cosmetic. The point is to use a language that can be understood and optimized by every part of the chain. If your GET operation has an action with side effects, you have to skip all HTTP caching or you'll end up with inconsistent results.</source>
          <target state="translated">Rest는 action 매개 변수와 함께 GET 요청을 사용하는 것에서 사용 가능한 http 동사를 사용하는 것까지의 구문상의 변화라고 말하면 그것이 이점이 없으며 순전히 미용적인 것처럼 보입니다. 요점은 체인의 모든 부분에서 이해하고 최적화 할 수있는 언어를 사용하는 것입니다. GET 조작에 부작용이있는 조치가있는 경우 모든 HTTP 캐싱을 건너 뛰어야합니다. 그렇지 않으면 결과가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4a2bd1212341d753b25f32677d4e7adf44e6015" translate="yes" xml:space="preserve">
          <source>Saying you use the REST style is similar to saying that you built a house in a particular style: for example Tudor or Victorian.  Both REST as an software style and Tudor or Victorian as a home style can be defined by the qualities and constraints that make them up. For example REST must have Client Server separation where messages are self-describing. Tudor style homes have Overlapping gables and Roofs that are steeply pitched with front facing gables. You can read Roy's dissertation to learn more about the constraints and qualities that make up REST.</source>
          <target state="translated">REST 스타일을 사용한다고 말하는 것은 Tudor 또는 Victorian과 같은 특정 스타일로 집을 지었다고 말하는 것과 유사합니다. 소프트웨어 스타일의 REST와 홈 스타일의 Tudor 또는 Victorian은 모두이를 구성하는 특성과 제한 조건으로 정의 할 수 있습니다. 예를 들어 REST에는 메시지가 자체 설명되는 클라이언트 서버 분리가 있어야합니다. 튜더 스타일 주택에는 겹치는 박공과 지붕이 있으며 앞면을 향한 박공으로 가파르게 구부러집니다. Roy의 논문을 읽고 REST를 구성하는 제약 조건과 품질에 대해 자세히 알아볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e446171e587e12eabf8b79616dc1eb91a5a4557" translate="yes" xml:space="preserve">
          <source>See Martin Fowlers article the &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;Richardson Maturity Model&lt;/a&gt; (RMM) for an explanation on what an RESTful service is.</source>
          <target state="translated">RESTful 서비스가 무엇인지에 대한 설명은 Martin Fowlers 기사 &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;Richardson Maturity Model&lt;/a&gt; (RMM)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbe751100f5c892656ce1ca4a6009c25fbfc7f4b" translate="yes" xml:space="preserve">
          <source>Select content-Header</source>
          <target state="translated">컨텐츠 헤더 선택</target>
        </trans-unit>
        <trans-unit id="16ed5c31752ac3f8db0119aea87a82b307c230ed" translate="yes" xml:space="preserve">
          <source>Select the REST method</source>
          <target state="translated">REST 방법을 선택하십시오</target>
        </trans-unit>
        <trans-unit id="c0c99a62016d0168acb95e1b7c7865a1070d884a" translate="yes" xml:space="preserve">
          <source>So if your &quot;/user/123&quot; path is hardcoded on the client, it's not really RESTful.  A good use of HTTP, maybe, maybe not.  But not RESTful.  It has to come from hypertext.</source>
          <target state="translated">따라서 &quot;/ user / 123&quot;경로가 클라이언트에서 하드 코딩 된 경우 실제로 RESTful하지 않습니다. HTTP를 잘 사용하면 어쩌면 아닐 수도 있습니다. 그러나 RESTful하지 않습니다. 하이퍼 텍스트에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="536946ca2831340799bf33cd36af457db31978e1" translate="yes" xml:space="preserve">
          <source>So it does not work with for example PUB/SUB sockets, it is based on REQ/REP.</source>
          <target state="translated">따라서 예를 들어 PUB / SUB 소켓에서는 작동하지 않으며 REQ / REP를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="cb3acf66e66e8ac82b059d304608e2b649d07fd9" translate="yes" xml:space="preserve">
          <source>So the server does not maintain the states of the clients. This means that you cannot use server a side session storage and you have to authenticate every request. Your clients possibly send basic auth headers through an encrypted connection. (By large applications it is hard to maintain many sessions.)</source>
          <target state="translated">따라서 서버는 클라이언트의 상태를 유지하지 않습니다. 즉, 서버 측 세션 저장소를 사용할 수 없으며 모든 요청을 인증해야합니다. 클라이언트는 암호화 된 연결을 통해 기본 인증 헤더를 보낼 수 있습니다. 큰 응용 프로그램에서는 많은 세션을 유지하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="9607344c01bb579773361b71bbb45cde205cc658" translate="yes" xml:space="preserve">
          <source>So you don't have to serve the same requests again and again.</source>
          <target state="translated">따라서 동일한 요청을 반복해서 제공 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6755df0f56ac5cee70d67ea5c025e47782da8d98" translate="yes" xml:space="preserve">
          <source>State transition controls only make sense if the client and server agree upon a media type representation of the resource.  Otherwise there's no way to know what's a control and what isn't and how to execute a control.  IE if browsers didn't know &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags in html then there'd be nothing for you to submit to transition state in your browser.</source>
          <target state="translated">상태 전이 제어는 클라이언트와 서버가 자원의 매체 유형 표시에 동의하는 경우에만 의미가 있습니다. 그렇지 않으면 컨트롤이 무엇인지, 컨트롤이 무엇인지, 컨트롤을 실행하는 방법을 알 수있는 방법이 없습니다. 브라우저가 html의 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그를 모르는 경우 브라우저에서 전환 상태로 제출할 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc782a4dc89d3cf79cc09c506daf5966811372c9" translate="yes" xml:space="preserve">
          <source>Stateless</source>
          <target state="translated">Stateless</target>
        </trans-unit>
        <trans-unit id="c2fa7bc4bb797a9f80155f336549e20f8ae9f995" translate="yes" xml:space="preserve">
          <source>Steps to Automate REST API</source>
          <target state="translated">REST API를 자동화하는 단계</target>
        </trans-unit>
        <trans-unit id="266d1df5b50f526d563a69c1948ed69ee2a31597" translate="yes" xml:space="preserve">
          <source>Structured URLs and Http Methods/Verbs are not the definition of
restful programming.</source>
          <target state="translated">구조화 된 URL과 Http Methods / Verbs는 편안한 프로그래밍의 정의가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8f7198c3c2d3db3f7cabeab606f0ec990cba16f4" translate="yes" xml:space="preserve">
          <source>That xfront document explains the difference between REST and SOAP, and this is really helpful too. When Fielding says, &quot;&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;That is RPC. It screams RPC.&lt;/a&gt;&quot;, it's clear that RPC is not RESTful, so it's useful to see the exact reasons for this. (SOAP is a type of RPC.)</source>
          <target state="translated">이 xfront 문서는 REST와 SOAP의 차이점을 설명하며 실제로 도움이됩니다. Fielding이 &quot; &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;RPC입니다. RPC를 비명을 지 릅니다.&lt;/a&gt; &quot;라고 말하면 RPC가 RESTful이 아니라는 것이 분명하므로 정확한 이유를 확인하는 것이 좋습니다. (SOAP는 RPC 유형입니다.)</target>
        </trans-unit>
        <trans-unit id="11640c3d32a9a0b61aeecdb5c9ad7a185581310a" translate="yes" xml:space="preserve">
          <source>The HATEOAS constraint is an acronym
  for Hypermedia as the Engine of
  Application State. This principle is
  the key differentiator between a REST
  and most other forms of client server
  system.</source>
          <target state="translated">HATEOAS 제약 조건은 응용 프로그램 엔진 상태 인 Hypermedia의 약어입니다. 이 원칙은 REST와 대부분의 다른 형태의 클라이언트 서버 시스템을 구분하는 주요 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="6a4c43170c5294cf2068284ddf81b0942eff7050" translate="yes" xml:space="preserve">
          <source>The PUT, GET, POST and DELETE methods are typical used in REST based architectures. The following table gives an explanation of these operations.</source>
          <target state="translated">PUT, GET, POST 및 DELETE 메소드는 REST 기반 아키텍처에서 일반적으로 사용됩니다. 다음 표는 이러한 작업에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="debfff33bf7e7352ae30422dd3def567e5f7259f" translate="yes" xml:space="preserve">
          <source>The REST constraints are the following:</source>
          <target state="translated">REST 제약 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="363845c5633e5276f4ad26162098f583201cc8cf" translate="yes" xml:space="preserve">
          <source>The REST system is composed of hierarchical layers. Each layer contains components which use the services of components which are in the next layer below. So you can add new layers and components effortless.</source>
          <target state="translated">REST 시스템은 계층 적 계층으로 구성됩니다. 각 계층에는 다음 계층에있는 구성 요소 서비스를 사용하는 구성 요소가 포함됩니다. 따라서 새로운 레이어와 구성 요소를 손쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aaa535e7837eae3a4f80e39cfc9d687c46ea8d0" translate="yes" xml:space="preserve">
          <source>The answer is very simple, there is a &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;dissertation&lt;/a&gt; written by Roy Fielding.]&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;1&lt;/a&gt; In that dissertation he defines the REST principles. If an application fulfills all of those principles, then that is a REST application.</source>
          <target state="translated">대답은 매우 간단합니다. Roy Fielding이 작성한 &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;논문&lt;/a&gt; 이 있습니다.] &lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;1&lt;/a&gt; 이 논문에서 그는 REST 원칙을 정의합니다. 애플리케이션이 이러한 원칙을 모두 충족하는 경우 REST 애플리케이션입니다.</target>
        </trans-unit>
        <trans-unit id="4f20d992e77c2fef0f2a4c004149838f65239268" translate="yes" xml:space="preserve">
          <source>The contract between the client and the server is not maintained by the server. In other words the client must be decoupled from the implementation of the service. You can reach this state by using standard solutions, like the IRI (URI) standard to identify resources, the HTTP standard to exchange messages, standard MIME types to describe the body serialization format, metadata (possibly RDF vocabs, microformats, etc.) to describe the semantics of different parts of the message body. To decouple the IRI structure from the client, you have to send hyperlinks to the clients in hypermedia formats like (HTML, JSON-LD, HAL, etc.). So a client can use the metadata (possibly link relations, RDF vocabs) assigned to the hyperlinks to navigate the state machine of the application through the proper state transitions in order to achieve its current goal.</source>
          <target state="translated">클라이언트와 서버 간의 계약은 서버에서 유지 관리하지 않습니다. 즉, 클라이언트는 서비스 구현에서 분리되어야합니다. 자원을 식별하는 IRI (URI) 표준, 메시지를 교환하는 HTTP 표준, 본문 직렬화 형식을 설명하는 표준 MIME 유형, 메타 데이터 (RDF vocab, microformats 등)를 사용하여이 상태에 도달 할 수 있습니다. 메시지 본문의 다른 부분의 의미를 설명합니다. 클라이언트에서 IRI 구조를 분리하려면 HTML, JSON-LD, HAL 등과 같은 하이퍼 미디어 형식으로 클라이언트에 하이퍼 링크를 보내야합니다. 따라서 클라이언트는 하이퍼 링크에 할당 된 메타 데이터 (아마도 링크 관계, RDF vocab)를 사용하여 현재 목표를 달성하기 위해 적절한 상태 전환을 통해 응용 프로그램의 상태 시스템을 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eac8561aeea8b795c8a15b197b4655d18a46b3e" translate="yes" xml:space="preserve">
          <source>The entire web is based on REST (or REST was based on the web). Therefore as a web developer you might want aware of that although it's not necessary to write good web apps.</source>
          <target state="translated">전체 웹은 REST를 기반으로합니다 (또는 REST는 웹을 기반으로 함). 따라서 웹 개발자는 훌륭한 웹 앱을 작성할 필요는 없지만 알고 있어야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7820ce4adf25178f490423f73f586fe8480e441" translate="yes" xml:space="preserve">
          <source>The last one is probably the most important in terms of consequences and overall effectiveness of REST. Overall, most of the RESTful discussions seem to center on HTTP and its usage from a browser and what not. I understand that R. Fielding coined the term when he described the architecture and decisions that lead to HTTP. His thesis is more about the architecture and cache-ability of resources than it is about HTTP.</source>
          <target state="translated">마지막 것은 아마도 REST의 결과 및 전반적인 효과면에서 가장 중요합니다. 전반적으로, RESTful 토론의 대부분은 HTTP와 브라우저에서의 사용법 및 그렇지 않은 것에 중점을 둔 것으로 보입니다. 필자는 R. Fielding이 HTTP로 이끄는 아키텍처와 결정을 설명 할 때이 용어를 만들었다는 것을 이해합니다. 그의 논문은 HTTP보다는 리소스의 아키텍처와 캐시 가능성에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b32979991407cd39a66f760547c127248522b7ba" translate="yes" xml:space="preserve">
          <source>The last thing that you&amp;rsquo;ll often here about RESTful architectures is that they are layered. We have actually already been implicitly discussing this requirement in our discussion of the interaction between the client and server. Basically, this means that each layer in our system interacts only with adjacent layers. So in our discussion, the client layer interacts with our server layer (and vice versa), but there might be other server layers that help the primary server process a request that the client does not directly communicate with. Rather, the server passes on the request as necessary.</source>
          <target state="translated">RESTful 아키텍처에 대해 자주 여기에서 마지막으로 다루는 것은 계층화되어 있다는 것입니다. 실제로 클라이언트와 서버 간의 상호 작용에 대한 논의에서이 요구 사항을 이미 암시 적으로 설명했습니다. 기본적으로 이는 시스템의 각 레이어가 인접한 레이어와 만 상호 작용한다는 것을 의미합니다. 따라서 논의에서 클라이언트 계층은 서버 계층과 상호 작용하지만 그 반대의 경우도 있지만 주 서버가 클라이언트와 직접 통신하지 않는 요청을 처리하는 데 도움이되는 다른 서버 계층이있을 수 있습니다. 대신 서버는 필요에 따라 요청을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="3ad594a4eee6f4393aea9d6f9c591653f6d82996" translate="yes" xml:space="preserve">
          <source>The many much better answers on this very page.</source>
          <target state="translated">이 페이지에서 훨씬 더 나은 답변.</target>
        </trans-unit>
        <trans-unit id="f34a56b5b9cc5fb499cc45ca49da52dec1ae7242" translate="yes" xml:space="preserve">
          <source>The most obvious requirement is that there needs to be a universal language of some sort so that the server can tell the client what it is trying to do with the request and for the server to respond.</source>
          <target state="translated">가장 명백한 요구 사항은 서버가 클라이언트에게 요청과 관련하여 수행하려는 작업과 서버가 응답 할 수 있도록 어떤 종류의 범용 언어가 필요하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1949f81259fdfb5a99b7b1901beff7c9ea4dc3c" translate="yes" xml:space="preserve">
          <source>The point of rest is that if we agree to use a common language for basic operations (the http verbs), the infrastructure can be configured to understand them and optimize them properly, for example, by making use of caching headers to implement caching at all levels.</source>
          <target state="translated">휴식의 요점은 기본 작업 (http 동사)에 공통 언어를 사용하기로 동의하는 경우, 캐싱 헤더를 사용하여 캐싱을 전혀 구현하여 인프라를 이해하고 올바르게 최적화하도록 인프라를 구성 할 수 있다는 것입니다. 레벨.</target>
        </trans-unit>
        <trans-unit id="adcd5a6756875181e58c7a89806bd16236c307a3" translate="yes" xml:space="preserve">
          <source>The server responds:</source>
          <target state="translated">서버는 다음과 같이 응답합니다.</target>
        </trans-unit>
        <trans-unit id="d84fe7aa11f8f900fefc9b179edc3003cd01912b" translate="yes" xml:space="preserve">
          <source>There is not such notion as &quot;RESTful programming&quot; per se. It would be better called RESTful paradigm or even better RESTful architecture. It is not a programming language. It is a paradigm.</source>
          <target state="translated">&quot;RESTful programming&quot;자체와 같은 개념은 없습니다. RESTful 패러다임 또는 더 나은 RESTful 아키텍처라고합니다. 프로그래밍 언어가 아닙니다. 패러다임입니다.</target>
        </trans-unit>
        <trans-unit id="86c7098a4bc3a5c3742a2441c8884a81a07a366c" translate="yes" xml:space="preserve">
          <source>There's a fairly good example here:</source>
          <target state="translated">여기에 상당히 좋은 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="905d4728fcc1cb89a5cb1a3e73d508f59109d989" translate="yes" xml:space="preserve">
          <source>Therefore, we impose the restriction that each request-response pair between the client and the server is independent, meaning that the server doesn&amp;rsquo;t have to remember anything about previous requests (previous states of the client-server interaction) to respond to a new request. This means that we want our interactions to be stateless.</source>
          <target state="translated">따라서 클라이언트와 서버 간의 각 요청-응답 쌍이 독립적이라는 제한을 적용합니다. 즉, 서버는 새로운 요청에 응답하기 위해 이전 요청 (이전 클라이언트-서버 상호 작용 상태)에 대해 아무것도 기억할 필요가 없습니다. 의뢰. 이것은 우리의 상호 작용이 무국적자가되기를 원한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2a100f405ce7bcd9b4b68b83fcd25889ccf5143e" translate="yes" xml:space="preserve">
          <source>This constraint is optional. For example you can send a parser for a specific media type to the client, and so on... In order to do this you might need a standard plugin loader system in the client, or your client will be coupled to the plugin loader solution.</source>
          <target state="translated">이 제약 조건은 선택 사항입니다. 예를 들어 특정 미디어 유형에 대한 파서를 클라이언트에 전송할 수 있습니다. 이렇게하려면 클라이언트에 표준 플러그인 로더 시스템이 필요하거나 클라이언트가 플러그인 로더 솔루션에 연결됩니다. .</target>
        </trans-unit>
        <trans-unit id="a433790865d58bd8f02ff1f47ffaf65f408a91fa" translate="yes" xml:space="preserve">
          <source>This is amazingly long &quot;discussion&quot; and yet quite confusing to say the least.</source>
          <target state="translated">이것은 놀랍게도 긴 &quot;토론&quot;이지만 가장 적게 말하기는 상당히 혼란 스럽다.</target>
        </trans-unit>
        <trans-unit id="03de43a18514c80205249c972ff6f45137f701c5" translate="yes" xml:space="preserve">
          <source>This is taken from the excellent book &lt;em&gt;Core JavaServer faces&lt;/em&gt; book by David M. Geary.</source>
          <target state="translated">이것은 David M. Geary의 &lt;em&gt;Core JavaServer faces&lt;/em&gt; 책에서 발췌 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f84a19d4bf6f78ec8c5e5044a550ad4a25f94cc7" translate="yes" xml:space="preserve">
          <source>This is very less mentioned everywhere but the &lt;strong&gt;Richardson's Maturity Model&lt;/strong&gt; is one of the best methods to actually judge how Restful is one's API. More about it here:</source>
          <target state="translated">이것은 거의 모든 곳에서 언급되지 않지만 &lt;strong&gt;Richardson의 성숙도 모델&lt;/strong&gt; 은 실제로 Restful이 API인지 판단하는 가장 좋은 방법 중 하나입니다. 여기에 대한 자세한 내용 :</target>
        </trans-unit>
        <trans-unit id="d0c1d3305c31f371cda13faed5816c6263e72163" translate="yes" xml:space="preserve">
          <source>This is what it might look like.</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9c095fa6595fd926bd9860ca44ab7d426923a2d" translate="yes" xml:space="preserve">
          <source>To be RESTful a Service needs to fulfill the &lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot;&gt;Hypermedia as the Engine of Application State. (HATEOAS)&lt;/a&gt;, that is, it needs to reach level 3 in the RMM, &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;read the article&lt;/a&gt; for details or the &lt;a href=&quot;http://www.crummy.com/writing/speaking/2008-QCon/act3.html&quot;&gt;slides from the qcon talk&lt;/a&gt;.</source>
          <target state="translated">RESTful 상태가 되려면 서비스 &lt;a href=&quot;http://en.wikipedia.org/wiki/HATEOAS&quot;&gt;상태 엔진으로서 Hypermedia&lt;/a&gt; 를 이행해야합니다 . 즉, RMM에서 레벨 3에 도달해야합니다. 자세한 내용 또는 &lt;a href=&quot;http://www.crummy.com/writing/speaking/2008-QCon/act3.html&quot;&gt;qcon talk 슬라이드를 보려면&lt;/a&gt; &lt;a href=&quot;http://martinfowler.com/articles/richardsonMaturityModel.html&quot;&gt;기사&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="43e0b98e4c9a963450bac2bcfe7ffa0f28070108" translate="yes" xml:space="preserve">
          <source>To be a restful programmer you must be trying to build applications that allow actors to do things.  Not just exposing the database.</source>
          <target state="translated">편안한 프로그래머가 되려면 행위자가 할 수있는 응용 프로그램을 작성해야합니다. 데이터베이스를 노출시키는 것만이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="88f5ecedd3cc21540bbf662f89334d1c596c1065" translate="yes" xml:space="preserve">
          <source>To further ease the strain on our server from redoing computations that have already been recently done for a given client, REST also allows caching. Basically, caching means to take a snapshot of the initial response provided to the client. If the client makes the same request again, the server can provide the client with the snapshot rather than redo all of the computations that were necessary to create the initial response. However, since it is a snapshot, if the snapshot has not expired--the server sets an expiration time in advance--and the response has been updated since the initial cache (i.e. the request would give a different answer than the cached response), the client will not see the updates until the cache expires (or the cache is cleared) and the response is rendered from scratch again.</source>
          <target state="translated">REST는 주어진 클라이언트에 대해 최근에 이미 수행 된 계산을 다시 실행함으로써 서버의 부담을 더욱 완화시키기 위해 캐싱을 허용합니다. 기본적으로 캐싱은 클라이언트에 제공되는 초기 응답의 스냅 샷을 만드는 것을 의미합니다. 클라이언트가 동일한 요청을 다시 수행하면 서버는 초기 응답을 작성하는 데 필요한 모든 계산을 다시 실행하지 않고 클라이언트에 스냅 샷을 제공 할 수 있습니다. 그러나 스냅 샷이므로 스냅 샷이 만료되지 않은 경우 (서버가 만료 시간을 미리 설정) 초기 캐시 이후 응답이 업데이트 된 경우 (즉, 요청이 캐시 된 응답과 다른 응답을 제공함) 클라이언트는 캐시가 만료되거나 캐시가 지워지고 응답이 처음부터 다시 렌더링 될 때까지 업데이트를 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cda008b284e93ee83d27ce556b7f274c5401681" translate="yes" xml:space="preserve">
          <source>To modify the record (&lt;code&gt;lname&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; will remain unchanged):</source>
          <target state="translated">레코드를 수정하려면 (이름과 &lt;code&gt;age&lt;/code&gt; 은 변경되지 않음) :</target>
        </trans-unit>
        <trans-unit id="2d8872fdf4d794b725b02d84014a91227ec2afee" translate="yes" xml:space="preserve">
          <source>To update the record (and consequently &lt;code&gt;lname&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; will be NULL):</source>
          <target state="translated">레코드를 업데이트하려면 (결과적으로 &lt;code&gt;lname&lt;/code&gt; 및 &lt;code&gt;age&lt;/code&gt; 는 NULL이 됨)</target>
        </trans-unit>
        <trans-unit id="749827b57c3b48ad912ed3c35f6d888c6b320fd8" translate="yes" xml:space="preserve">
          <source>To use API manually, we can use browser based REST API plugins.</source>
          <target state="translated">API를 수동으로 사용하기 위해 브라우저 기반 REST API 플러그인을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd51d0a7c8a456561603688f8e9d8841d8aeb252" translate="yes" xml:space="preserve">
          <source>Uniform interface</source>
          <target state="translated">균일 한 인터페이스</target>
        </trans-unit>
        <trans-unit id="36445d1f62b3461271018e22e6c63b0da668d74c" translate="yes" xml:space="preserve">
          <source>We also know that we can change existing data:</source>
          <target state="translated">또한 기존 데이터를 변경할 수 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da0745a731ffea22c1d0cd224d20dec310fb399" translate="yes" xml:space="preserve">
          <source>We can tell a lot from this response. For instance, we now know we can create a new user by &lt;code&gt;POST&lt;/code&gt;ing to &lt;code&gt;/user&lt;/code&gt;:</source>
          <target state="translated">이 답변에서 많은 것을 알 수 있습니다. 예를 들어, 우리는 &lt;code&gt;/user&lt;/code&gt; 에 &lt;code&gt;POST&lt;/code&gt; 함으로써 새로운 사용자를 만들 수 있다는 것을 알고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5441c7839fa6d73dff04b1a5f493f5e5d31a22e7" translate="yes" xml:space="preserve">
          <source>We know from the description of our media that we can find information about related resources from sections called &quot;links&quot;. This is called &lt;em&gt;Hypermedia controls&lt;/em&gt;. In this case, we can tell from such a section that we can find a user list by making another request for &lt;code&gt;/user&lt;/code&gt;:</source>
          <target state="translated">우리는 미디어 설명에서 &quot;링크&quot;라는 섹션에서 관련 리소스에 대한 정보를 찾을 수 있음을 알고 있습니다. 이를 &lt;em&gt;하이퍼 미디어 컨트롤&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 이 경우, 우리는 &lt;code&gt;/user&lt;/code&gt; 에 대한 다른 요청을함으로써 사용자 목록을 찾을 수 있음을 해당 섹션에서 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbe152bcc052ff53fb476d5537d8e4e55bdd8dee" translate="yes" xml:space="preserve">
          <source>What exactly is RESTful programming</source>
          <target state="translated">RESTful 프로그래밍이란 무엇입니까</target>
        </trans-unit>
        <trans-unit id="600b595c92145112ec54443d94bd4487770f5001" translate="yes" xml:space="preserve">
          <source>What exactly is RESTful programming?</source>
          <target state="translated">RESTful 프로그래밍이란 정확히 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="de97001a3f45e1ab272ba3e7e1ff70234ac18284" translate="yes" xml:space="preserve">
          <source>What is REST?</source>
          <target state="translated">REST 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="eda640f0d9d8732bb4f5934942e07911d12c78f5" translate="yes" xml:space="preserve">
          <source>When it comes to web services, it seems that we need some way of distinguishing WSDL and SOAP based architectures which add considerable overhead and arguably much unnecessary complexity to the interface. They also require additional frameworks and developer tools in order to implement. I'm not sure if REST is the best term to distinguish between common-sense interfaces and overly engineered interfaces such as WSDL and SOAP. But we need something.</source>
          <target state="translated">웹 서비스와 관련하여 인터페이스에 상당한 오버 헤드와 불필요한 복잡성을 추가하는 WSDL과 SOAP 기반 아키텍처를 구별 할 수있는 방법이 필요한 것 같습니다. 또한 구현하려면 추가 프레임 워크와 개발자 도구가 필요합니다. REST가 공통 감지 인터페이스와 WSDL 및 SOAP와 같이 과도하게 엔지니어링 된 인터페이스를 구별하는 가장 좋은 용어인지 확실하지 않습니다. 그러나 우리는 무언가가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a973bdebdbe9ce0f6dcc094fe7f29c9ec500ddfd" translate="yes" xml:space="preserve">
          <source>With a properly implemented restful GET operation, it shouldn't matter if the information comes from your server's DB, your server's memcache, a CDN, a proxy's cache, your browser's cache or your browser's local storage. The fasted, most readily available up to date source can be used.</source>
          <target state="translated">적절하게 구현 된 편안한 GET 작업을 통해 정보가 서버의 DB, 서버의 memcache, CDN, 프록시 캐시, 브라우저 캐시 또는 브라우저의 로컬 스토리지에서 제공되는지 여부는 중요하지 않습니다. 최신의 가장 빠른 소스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9516144747f958d35f414712742a6a2ce6a57b18" translate="yes" xml:space="preserve">
          <source>With restful style, you get and manipulate the state of the application across an unreliable internet. If it fails the current operation to get the correct and current state, it needs the zero-validation principal to help the application to continue. If it fails to manipulate the state, it usually uses multiple stages of confirmation to keep things correct. In this sense, rest is not itself a whole solution, it needs the functions in other part of the web application stack to support its working.</source>
          <target state="translated">편안한 스타일을 사용하면 신뢰할 수없는 인터넷을 통해 응용 프로그램의 상태를 얻고 조작 할 수 있습니다. 현재 작업이 올바른 현재 상태를 얻는 데 실패하면 응용 프로그램을 계속 진행할 수 있도록 유효성을 검사하는 주체가 필요합니다. 상태를 조작하지 못하면 일반적으로 여러 단계의 확인을 사용하여 상황을 올바르게 유지합니다. 이런 의미에서 휴식은 그 자체가 전체 솔루션이 아니며, 작업을 지원하기 위해 웹 응용 프로그램 스택의 다른 부분에있는 기능이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9be308c8cf75a9d22350774cf74e2e3a25a8019f" translate="yes" xml:space="preserve">
          <source>You can imagine such an endpoint as being the connecting pipeline from the website (front-end) to your database/server (back-end). Using them, the front-end can perform back-end operations which are defined in the corresponding methods of any REST mapping in your application.</source>
          <target state="translated">이러한 엔드 포인트가 웹 사이트 (프런트 엔드)에서 데이터베이스 / 서버 (백 엔드)로 연결되는 파이프 라인이라고 생각할 수 있습니다. 이를 사용하여 프론트 엔드는 애플리케이션에서 REST 맵핑의 해당 메소드에 정의 된 백엔드 조작을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="908a7dfd19709fb34c01bfe487f5ebb9c2ca9cf8" translate="yes" xml:space="preserve">
          <source>You can summarize(significantly) the constraints to :</source>
          <target state="translated">제약 조건을 요약하면 다음과 같이 요약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feb921fa13db1c181a291f33573dbc491b591ad9" translate="yes" xml:space="preserve">
          <source>You use the HTTP &quot;verbs&quot; and have..</source>
          <target state="translated">HTTP &quot;동사&quot;를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aed90f826f40c49f9ad0c3f63e16bed6d13bf70" translate="yes" xml:space="preserve">
          <source>[Failure here implies that out-of-band information is driving interaction instead of hypertext.]</source>
          <target state="translated">[여기서의 실패는 대역 외 정보가 하이퍼 텍스트 대신 상호 작용을 주도하고 있음을 의미합니다.]</target>
        </trans-unit>
        <trans-unit id="8e00d08a441958c5870f45fa22543b3d6a03678e" translate="yes" xml:space="preserve">
          <source>build a layered system to increase scalability</source>
          <target state="translated">확장 성을 높이기 위해 계층화 된 시스템 구축</target>
        </trans-unit>
        <trans-unit id="59c8c8c5991afe8d0a6e42545c71d93e3bff395d" translate="yes" xml:space="preserve">
          <source>but the REST architecture does not require these &quot;pretty URLs&quot;. A GET request with a parameter</source>
          <target state="translated">그러나 REST 아키텍처에는 이러한 &quot;예쁜 URL&quot;이 필요하지 않습니다. 매개 변수가있는 GET 요청</target>
        </trans-unit>
        <trans-unit id="9f5d22e3a30a84cbccefeb4bd8e5dd35213aaaef" translate="yes" xml:space="preserve">
          <source>clearly communicates the content formats transmitted</source>
          <target state="translated">전송 된 컨텐츠 형식을 명확하게 전달</target>
        </trans-unit>
        <trans-unit id="aa2c820849be6fbcb2031a6127c1665b0464c324" translate="yes" xml:space="preserve">
          <source>client-server architecture</source>
          <target state="translated">클라이언트-서버 아키텍처</target>
        </trans-unit>
        <trans-unit id="8de0a9bc31c843fae99c5bff4c8a379f92283e8b" translate="yes" xml:space="preserve">
          <source>code on demand to extend client functionality</source>
          <target state="translated">클라이언트 기능을 확장하기 위해 주문형 코드</target>
        </trans-unit>
        <trans-unit id="b275617b42e241876e72514b35301555695e7037" translate="yes" xml:space="preserve">
          <source>is every bit as RESTful.</source>
          <target state="translated">RESTful만큼 모든 비트입니다.</target>
        </trans-unit>
        <trans-unit id="0d4997d446840ee0c979e316123915b0a24c6d51" translate="yes" xml:space="preserve">
          <source>maintaining the state in the object and representing the state in the representation</source>
          <target state="translated">객체에서 상태를 유지하고 표현에서 상태를 나타냄</target>
        </trans-unit>
        <trans-unit id="979f4334840cfaebedb96eacee97565f5bf001e6" translate="yes" xml:space="preserve">
          <source>representing the relationships between resources in the representation of the resource: the links between objects are embedded directly in the representation</source>
          <target state="translated">자원 표현에서 자원들 간의 관계를 나타내는 것 : 객체들 사이의 링크는 표현에 직접 포함된다</target>
        </trans-unit>
        <trans-unit id="5e48ef6a8e54320faa23115ae33b087ac321ebec" translate="yes" xml:space="preserve">
          <source>resource representations describe how the representation can be used and under what circumstances it should be discarded/refetched in a consistent manner: usage of HTTP Cache-Control headers</source>
          <target state="translated">자원 표현은 표현을 사용하는 방법과 어떤 상황에서 일관된 방식으로 폐기 / 다시 가져와야 하는지를 설명합니다. HTTP Cache-Control 헤더 사용</target>
        </trans-unit>
        <trans-unit id="e33527bfb73b976a097d9714161c7a07da95577a" translate="yes" xml:space="preserve">
          <source>resources being identified by a persistent identifier: URIs are the ubiquitous choice of identifier these days</source>
          <target state="translated">영구 식별자로 식별되는 자원 : 요즘 URI는 유비쿼터스의 식별자 선택입니다.</target>
        </trans-unit>
        <trans-unit id="a51e6d20a959c6055335a93c972efc9d39c00a75" translate="yes" xml:space="preserve">
          <source>resources being manipulated using a common set of verbs: HTTP methods are the commonly seen case - the venerable &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;Retrieve&lt;/code&gt;, &lt;code&gt;Update&lt;/code&gt;, &lt;code&gt;Delete&lt;/code&gt; becomes &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, and &lt;code&gt;DELETE&lt;/code&gt;. But REST is not limited to HTTP, it is just the most commonly used transport right now.</source>
          <target state="translated">일반적인 동사 집합을 사용하여 조작되는 리소스 : HTTP 메서드는 일반적으로 많이 사용되는 경우입니다. 예를 들어 &lt;code&gt;Create&lt;/code&gt; , &lt;code&gt;Retrieve&lt;/code&gt; , &lt;code&gt;Update&lt;/code&gt; , &lt;code&gt;Delete&lt;/code&gt; 는 &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; 및 &lt;code&gt;DELETE&lt;/code&gt; 가 됩니다. 그러나 REST는 HTTP로 제한되지 않으며 현재 가장 일반적으로 사용되는 전송입니다.</target>
        </trans-unit>
        <trans-unit id="98b5c511b1e5b3b77e9275fb4452cc5fef44489b" translate="yes" xml:space="preserve">
          <source>respect HTTP specs (if HTTP is used)</source>
          <target state="translated">HTTP 스펙 존중 (HTTP가 사용되는 경우)</target>
        </trans-unit>
        <trans-unit id="c4931fde74816a610a063dd06bd59538b02802b8" translate="yes" xml:space="preserve">
          <source>stateless communication</source>
          <target state="translated">무국적 통신</target>
        </trans-unit>
        <trans-unit id="3b878062f43e3c640f44bd52081d0d0dc4278065" translate="yes" xml:space="preserve">
          <source>the actual representation retrieved for a resource is dependent on the request and not the identifier: use Accept headers to control whether you want XML, HTTP, or even a Java Object representing the resource</source>
          <target state="translated">자원에 대해 검색된 실제 표현은 식별자가 아닌 요청에 따라 다릅니다. Accept 헤더를 사용하여 XML, HTTP 또는 자원을 나타내는 Java 오브젝트를 원하는지 여부를 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="1462755612fc240043fdb2325bffe48c8d0f3f08" translate="yes" xml:space="preserve">
          <source>uniform interface as common contract between client and server</source>
          <target state="translated">클라이언트와 서버 간의 공통 계약으로서의 균일 한 인터페이스</target>
        </trans-unit>
        <trans-unit id="3766fe2c2822ed2ec2c43384fd93c708aa87dded" translate="yes" xml:space="preserve">
          <source>usage of cache if you can</source>
          <target state="translated">가능한 경우 캐시 사용</target>
        </trans-unit>
        <trans-unit id="f96087a197542f55a4ef257f73c9f1cfd69fffd2" translate="yes" xml:space="preserve">
          <source>use hypermedia as the engine of application state</source>
          <target state="translated">응용 프로그램 상태 엔진으로 하이퍼 미디어 사용</target>
        </trans-unit>
        <trans-unit id="2626c215ef69fa721ddf1168a1db9e9f9a723d4c" translate="yes" xml:space="preserve">
          <source>would not be appropriate. GET requests should be &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Idempotence&quot;&gt;idempotent&lt;/a&gt;. That is, issuing a request twice should be no different from issuing it once. That's what makes the requests cacheable. An &quot;add to cart&quot; request is not idempotent&amp;mdash;issuing it twice adds two copies of the item to the cart. A POST request is clearly appropriate in this context. Thus, even a &lt;strong&gt;RESTful web application&lt;/strong&gt; needs its share of POST requests.</source>
          <target state="translated">적절하지 않습니다. GET 요청은 &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Idempotence&quot;&gt;dem 등원&lt;/a&gt; 이어야합니다. 즉, 요청을 두 번 발행하는 것이 요청을 한 번 발행하는 것과 다르지 않아야합니다. 그것이 요청을 캐시 가능하게 만드는 것입니다. &quot;장바구니에 추가&quot;요청은 dem 등성이 아닙니다. 두 번 발행하면 두 부의 품목 사본이 카트에 추가됩니다. 이 상황에서는 POST 요청이 분명히 적합합니다. 따라서 &lt;strong&gt;RESTful 웹 애플리케이션&lt;/strong&gt; 조차도 POST 요청을 공유해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
