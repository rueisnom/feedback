<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/500431">
    <body>
      <group id="500431">
        <trans-unit id="b2b80089f01682b9f7777a6969b9faaa80407f05" translate="yes" xml:space="preserve">
          <source>(I'm sure there are many subtleties that real JavaScript programmers will be able to point out in other answers. In particular I came across &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;this page&lt;/a&gt; about what exactly &lt;code&gt;this&lt;/code&gt; means at any time. Hopefully &lt;a href=&quot;http://bowles.byethost3.com/javascript/section6/lesson6.htm#part4&quot;&gt;this more introductory link&lt;/a&gt; is enough to get you started though.)</source>
          <target state="translated">（我敢肯定，真正的JavaScript程序员可以在其他答案中指出很多细节。特别是我在任何时候都碰到了&lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;这个页面&lt;/a&gt; ， &lt;code&gt;this&lt;/code&gt; 含义是什么。希望&lt;a href=&quot;http://bowles.byethost3.com/javascript/section6/lesson6.htm#part4&quot;&gt;这个介绍性链接&lt;/a&gt;足以使您入门虽然。）</target>
        </trans-unit>
        <trans-unit id="2b079c997f6e9e9f11e2b8533c11a4cdefaf6c17" translate="yes" xml:space="preserve">
          <source>...because of this behavior you need to be careful about closing over variables declared using &lt;code&gt;var&lt;/code&gt; in loops. There is only one instance of variable &lt;code&gt;x&lt;/code&gt; declared here, and it sits logically outside of the loop.</source>
          <target state="translated">...由于这种行为，您需要谨慎使用循环中使用 &lt;code&gt;var&lt;/code&gt; 声明的变量。 此处声明的变量 &lt;code&gt;x&lt;/code&gt; 只有一个实例，并且在逻辑上位于循环之外。</target>
        </trans-unit>
        <trans-unit id="c2a9084e5d3eb2e4718aab6268e78f5823849081" translate="yes" xml:space="preserve">
          <source>1) There is a global scope, a function scope, and the with and catch scopes. There is no 'block' level scope in general for variable's -- the with and the catch statements add names to their blocks.</source>
          <target state="translated">1)有一个全局作用域,一个函数作用域,还有with和catch作用域。一般情况下,变量的 &quot;块 &quot;级作用域是没有的----with和catch语句会把名字添加到它们的块中。</target>
        </trans-unit>
        <trans-unit id="a7c489f0a7142c687da2af2321ca060655d7e2f8" translate="yes" xml:space="preserve">
          <source>2) Scopes are nested by functions all the way to the global scope.</source>
          <target state="translated">2)作用域被函数嵌套,一直到全局作用域。</target>
        </trans-unit>
        <trans-unit id="d749b9c70cd3d6ec5a37f9e5c4bb7316601c2a74" translate="yes" xml:space="preserve">
          <source>3) Properties are resolved by going through the prototype chain.  The with statement brings object property names into the lexical scope defined by the with block.</source>
          <target state="translated">3)属性通过原型链来解决。with语句将对象的属性名带入到with块定义的词法范围内。</target>
        </trans-unit>
        <trans-unit id="08b17079c570142726687fb2c5c9bb253783c20e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES5&lt;/code&gt; and earlier:</source>
          <target state="translated">&lt;code&gt;ES5&lt;/code&gt; 及更早版本：</target>
        </trans-unit>
        <trans-unit id="2ac152d0029db3c7cd7c3a77df7bfef8ae5d4c57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES6&lt;/code&gt; (ES 2015) and older:</source>
          <target state="translated">&lt;code&gt;ES6&lt;/code&gt; （ES 2015）及更早版本：</target>
        </trans-unit>
        <trans-unit id="c4c1a80bcfde13b5ffe96bdafa9c43b74b195f4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; should be used for &lt;strong&gt;95% of cases&lt;/strong&gt;. It makes it so the variable &lt;em&gt;reference&lt;/em&gt; can't change. Array, object, and DOM node properties can change and should likely be &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 应该用于&lt;strong&gt;95％的情况&lt;/strong&gt; 。 它使得变量&lt;em&gt;引用&lt;/em&gt;无法更改。 数组，对象和DOM节点属性可以更改，并且可能应该是 &lt;code&gt;const&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dcf0ad05684411d0af52e47d334a793a1d346e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;: creates a block scoped variable which has to be initialized and cannot be reassigned</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; ：创建一个块范围的变量，该变量必须初始化并且不能重新分配</target>
        </trans-unit>
        <trans-unit id="84d33e7ec01dc28120ceea7d7d07bb9ccda0bdcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="f378613076c429aa47b0bc460bdfb9fd805b2aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; in the global context do not add properties to the global object, but still have global scope:</source>
          <target state="translated">全局上下文中的 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 不会向全局对象添加属性，但仍具有全局范围：</target>
        </trans-unit>
        <trans-unit id="23ddb5e06f75a482ff3a507bfea2c6482c39eb0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; should be be used for any variable expecting to be reassigned. This includes within a for loop. If you ever change value beyond initialization, use &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 应该用于期望重新分配的任何变量。 这包括在for循环中。 如果您在初始化后更改了值，请使用 &lt;code&gt;let&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39836bea22536ebe1993a1b9a30ed5062e7fc910" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;: creates a block scoped variable</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; ：创建一个块范围变量</target>
        </trans-unit>
        <trans-unit id="f86a4d006feac6327fadfafd72bedb4b3013db57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23a7586104558b94ef7294bd102a26a3fee7bc25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;hoisted&lt;/strong&gt;&lt;/a&gt;.&lt;/em&gt; This means that declarations are always much to the top of the scope.</source>
          <target state="translated">&lt;em&gt;（*）因为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;提升了&lt;/strong&gt;&lt;/a&gt; JavaScript变量，所以可以在声明全局和功能范围的变量之前对其进行初始化和使用。&lt;/em&gt; 这意味着声明始终在作用域的顶部。</target>
        </trans-unit>
        <trans-unit id="f1f37e4dcff2ea462372b5383bfff8d1536133fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Whenever a function is called, a variable scope object is created (and included in scope chain) which is followed by variables in JavaScript.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;每当调用函数时，都会创建变量作用域对象（并将其包含在作用域链中），然后在JavaScript中跟随变量。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b4f1e280e8a84dd1613867f45aea9b5a09b5e95c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;i&lt;/em&gt;) The outer context. It has a variable environment of a = 1</source>
          <target state="translated">&lt;em&gt;i&lt;/em&gt; ）外部环境。 它具有a = 1的可变环境</target>
        </trans-unit>
        <trans-unit id="27dcebcb7c447ec33f3b94ab4786b7e8986fc48a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ii&lt;/em&gt;) The IIFE context, it has a lexical environment of a = 1, but a variable environment of a = 6 which takes precedence in the stack</source>
          <target state="translated">&lt;em&gt;ii&lt;/em&gt; ）IIFE上下文，它的词法环境为a = 1，但变量环境为a = 6，该环境在堆栈中优先</target>
        </trans-unit>
        <trans-unit id="f2d982053f1a3fa4551447f1adedd54422f021ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;iii&lt;/em&gt;) The returned function context, it has a lexical environment of a = 6 and that is the value referenced in the alert when called.</source>
          <target state="translated">&lt;em&gt;iii&lt;/em&gt; ）返回的函数上下文，它的词法环境为a = 6，这是调用时警报中引用的值。</target>
        </trans-unit>
        <trans-unit id="f56505ee4c5ecc9846d96be13e7dc0c3c70dfa98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Android browser 4&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Android浏览器4&lt;/strong&gt;及更低版本</target>
        </trans-unit>
        <trans-unit id="55a8f93e956bc391290a79206606d9be4627b589" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Block Scope&lt;/strong&gt; : Identifiers are &quot;known&quot; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;from the top of the scope they are declared within&lt;/a&gt;, but they cannot be assigned to or dereferenced (read) until after the line of their declaration. This interim period is called the &quot;temporal dead zone.&quot;</source>
          <target state="translated">&lt;strong&gt;块作用域&lt;/strong&gt; ：标识符&lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;从它们在其中声明的作用域的顶部开始&lt;/a&gt;是&amp;ldquo;已知的&amp;rdquo;，但是只有在其声明行之后才能将它们分配或取消引用（读取）。 该过渡期称为&amp;ldquo;时间死区&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2f05c56877d8601614fa63855f086a2652e865c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Chome 40&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;丁丁40岁&lt;/strong&gt;及以下</target>
        </trans-unit>
        <trans-unit id="d99cf4a17169c81d37ec13856f6710a2a76cbbad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Firefox 43&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Firefox 43&lt;/strong&gt;及以下</target>
        </trans-unit>
        <trans-unit id="08cd2fc5597977a2613daeb7f079fd9fa0eb16b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional Scope&lt;/strong&gt; : Variable declared within a function with &lt;code&gt;var&lt;/code&gt; keyword has functional scope.</source>
          <target state="translated">&lt;strong&gt;功能范围&lt;/strong&gt; ：在具有 &lt;code&gt;var&lt;/code&gt; 关键字的函数中声明的变量具有功能范围。</target>
        </trans-unit>
        <trans-unit id="a13963dd31b44d28a808a5e2917cae4be7b837de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional Scope&lt;/strong&gt; : Variables are known within &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;the function&lt;/strong&gt;&lt;/a&gt; they are declared in, from the start of the function &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;功能范围&lt;/strong&gt; ：从函数开头&lt;em&gt;（*）&lt;/em&gt;开始，变量在&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;函数中&lt;/strong&gt;&lt;/a&gt;是已知&lt;strong&gt;的&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7298e7a71a2f69245853e050c4bdee749e978e9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional scope or Local scope&lt;/strong&gt;: variable declared in this scope can be used in its own function only. For example:</source>
          <target state="translated">&lt;strong&gt;功能范围或局部范围&lt;/strong&gt; ：在此范围中声明的变量只能在其自己的函数中使用。 例如：</target>
        </trans-unit>
        <trans-unit id="89e21e149d0d0dc547601ca86291fe92f9273963" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Scope&lt;/strong&gt; : Global is nothing but a window level scope.Here, variable present throughout the application.</source>
          <target state="translated">&lt;strong&gt;全局范围全局范围&lt;/strong&gt;不过是一个窗口级范围。这里，整个应用程序中都存在变量。</target>
        </trans-unit>
        <trans-unit id="f3a549a4e99a97eff2b34e0f09263cffa683cccd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Scope&lt;/strong&gt; : Variables are known throughout the application, from the start of the application &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;全局范围&lt;/strong&gt; ：从应用程序的开始就在整个应用程序中知道变量&lt;em&gt;（*）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1f34e4a5bfcdc48aa26833768f67160bd571124" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global scope&lt;/strong&gt;: variable which is announced in global scope can be used anywhere in the program very smoothly. For example:</source>
          <target state="translated">&lt;strong&gt;全局范围&lt;/strong&gt; ：在全局范围内声明的变量可以在程序中的任何位置非常平稳地使用。 例如：</target>
        </trans-unit>
        <trans-unit id="a7ca3efb97c36b6d88809b25331124fb1fffa069" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internet explorer 10&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Internet Explorer 10&lt;/strong&gt;及以下</target>
        </trans-unit>
        <trans-unit id="f68d935bfb76269d4c30258cf31d26f604040556" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opera 27&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Opera 27&lt;/strong&gt;以下</target>
        </trans-unit>
        <trans-unit id="050f7cc7d0dc2635f8b52903f766a2c3db495862" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Safari 9&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Safari 9&lt;/strong&gt;及以下</target>
        </trans-unit>
        <trans-unit id="44e5d520bd9d0fb39f77e303b90adad358405de1" translate="yes" xml:space="preserve">
          <source>A lexical environment is a mapping between identifier names and the values associated with them.</source>
          <target state="translated">词法环境是标识符名称和与之相关的值之间的映射。</target>
        </trans-unit>
        <trans-unit id="8fd51b0bd0e4f91009d0f3343c699212c3d96c96" translate="yes" xml:space="preserve">
          <source>A variable declared at the top of a &lt;code&gt;for&lt;/code&gt; loop using &lt;code&gt;let&lt;/code&gt; is scoped to the body of the loop:</source>
          <target state="translated">使用 &lt;code&gt;let&lt;/code&gt; 在 &lt;code&gt;for&lt;/code&gt; 循环顶部声明的变量的作用域为循环的主体：</target>
        </trans-unit>
        <trans-unit id="48faefee4b09b7b96e9ee196462af3f716e8b8de" translate="yes" xml:space="preserve">
          <source>A very common issue not described yet that front-end coders often run into is the scope that is visible to an inline event handler in the HTML - for example, with</source>
          <target state="translated">前端程序员经常遇到的一个非常常见的问题还没有描述,那就是HTML中的内联事件处理程序所能看到的范围--例如,用</target>
        </trans-unit>
        <trans-unit id="60fc03a08e44792e776e9738812c0a4cd623a464" translate="yes" xml:space="preserve">
          <source>ANY version of &lt;strong&gt;Opera Mini&lt;/strong&gt; &amp;amp; &lt;strong&gt;Blackberry Browser&lt;/strong&gt;</source>
          <target state="translated">任何版本的&lt;strong&gt;Opera Mini&lt;/strong&gt;和&lt;strong&gt;Blackberry浏览器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae46cf4abc73a3b9c1f4dfacc1b829774476ba1e" translate="yes" xml:space="preserve">
          <source>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</source>
          <target state="translated">另外,要考虑到块范围变量在声明之前是不知道的,因为块范围变量是不被挂起的。你也不允许在同一个区块内重新声明同一个区块范围内的变量。这使得块范围化变量比全局或函数范围化变量更不容易出错,因为全局或函数范围化变量是被挂起的,在多次声明的情况下不会产生任何错误。</target>
        </trans-unit>
        <trans-unit id="cb95f617fd60bdb566772a3a947b9cf56a0e0ee3" translate="yes" xml:space="preserve">
          <source>An element in the scope chain is basically a Map with a pointer to its parent scope.</source>
          <target state="translated">作用域链中的元素基本上是一个带有指向其父作用域的指针的Map。</target>
        </trans-unit>
        <trans-unit id="2f14bc627ff3b593b8ed5e4441d9f45b15ddec5c" translate="yes" xml:space="preserve">
          <source>Applying this to one of the previous examples (5. &quot;Closure&quot;) on this page, it is possible to follow the stack of execution contexts. In this example there are three contexts in the stack. They are defined by the outer context, the context in the immediately invoked function called by var six, and the context in the returned function inside of var six's immediately invoked function.</source>
          <target state="translated">将其应用到本页面上的前一个例子(5.&quot;Closure&quot;)中,就可以按照执行上下文的堆栈来执行。在这个例子中,栈中有三个上下文。它们分别是由外部上下文、var六所调用的立即调用的函数中的上下文和var六的立即调用的函数内部返回的函数中的上下文所定义的。</target>
        </trans-unit>
        <trans-unit id="425a5e8573ac9d1f6ad5077097cd879a85500359" translate="yes" xml:space="preserve">
          <source>Block - visible within a block (and its sub-blocks)</source>
          <target state="translated">块----在一个块中可见(及其子块)。</target>
        </trans-unit>
        <trans-unit id="b268d619791c64ad9a437793c6df4e96c3bea47e" translate="yes" xml:space="preserve">
          <source>Block scope means that the variable will only be available within the brackets in which it is declared. This extends to internal scopes, including anonymous functions created within your scope.</source>
          <target state="translated">块作用域意味着变量只在其声明的括号内可用。这延伸到了内部作用域,包括在你的作用域内创建的匿名函数。</target>
        </trans-unit>
        <trans-unit id="6ad05cf476194af6ae4eab02f3b9ae25d3fe726e" translate="yes" xml:space="preserve">
          <source>Block scope variables are created like this :</source>
          <target state="translated">块范围变量是这样创建的。</target>
        </trans-unit>
        <trans-unit id="d4734d382405fe72442dafef31013eff2bc92678" translate="yes" xml:space="preserve">
          <source>But the top level of an ES6 module is &lt;em&gt;not&lt;/em&gt; global. A variable declared at the top of an ES6 module will only be visible inside that module, unless the variable is explicitly &lt;code&gt;export&lt;/code&gt;ed, or unless it's assigned to a property of the global object.</source>
          <target state="translated">但是，ES6模块的顶层&lt;em&gt;不是&lt;/em&gt;全局的。 在ES6模块顶部声明的变量仅在该模块内部可见，除非该变量被显式 &lt;code&gt;export&lt;/code&gt; ，或者除非已将其分配给全局对象的属性。</target>
        </trans-unit>
        <trans-unit id="c4d272ff3f7fc4237376ed64dc233b59d9966000" translate="yes" xml:space="preserve">
          <source>Catch block parameter</source>
          <target state="translated">捕捉块参数</target>
        </trans-unit>
        <trans-unit id="32c3db15ba22df73876c55e60996667cba034b0c" translate="yes" xml:space="preserve">
          <source>Catch block parameters are scoped to the catch-block body:</source>
          <target state="translated">捕捉块的参数范围到捕捉块主体。</target>
        </trans-unit>
        <trans-unit id="6fe813611dd6d84d9a1d26977566960643817c11" translate="yes" xml:space="preserve">
          <source>Check this article for in-depth understanding of scope</source>
          <target state="translated">查看此文,深入了解范围</target>
        </trans-unit>
        <trans-unit id="806b84e63f4442df339c4262199841634c53b286" translate="yes" xml:space="preserve">
          <source>Contexts form a stack of environments where variables are stored</source>
          <target state="translated">上下文形成了一个环境堆栈,在这个环境中存储变量</target>
        </trans-unit>
        <trans-unit id="3b76905c4fef521cd5b87dffcd70e8f6c5497e77" translate="yes" xml:space="preserve">
          <source>Control structure body</source>
          <target state="translated">控制结构体</target>
        </trans-unit>
        <trans-unit id="9145c9f2f97356d62bd24da8388b2b38acf59902" translate="yes" xml:space="preserve">
          <source>Currently the feature offers support for a depth of 16 nested functions, but currently does not color global variables.</source>
          <target state="translated">目前该功能提供了对16个深度嵌套函数的支持,但目前不对全局变量进行着色。</target>
        </trans-unit>
        <trans-unit id="65fff7fa8d3c3b1a1f3c9528a2264bd097d68887" translate="yes" xml:space="preserve">
          <source>Declaration Styles</source>
          <target state="translated">声明风格</target>
        </trans-unit>
        <trans-unit id="a8fbe250f6e0a7b427bb5ef03aadced5ed432e98" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword. Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.</source>
          <target state="translated">ECMAScript 6引入了let和const关键字。这些关键字可以用来代替var关键字。与var关键字相反,let和const关键字支持在块语句中声明局部作用域。</target>
        </trans-unit>
        <trans-unit id="e4c8806859640baf11f724a1eec52c4f7c4afcf5" translate="yes" xml:space="preserve">
          <source>EDIT: Based on Benjamin's pointing out of the with and catch statements in the comments, I've edited the post, and added more.  Both the with and the catch statements introduce variables into their respective blocks, and that &lt;em&gt;is&lt;/em&gt; a block scope. These variables are aliased to the properties of the objects passed into them.</source>
          <target state="translated">编辑：基于本杰明在评论中指出with和catch语句，我编辑了帖子，并添加了更多内容。 with和catch语句都将变量引入其各自的块中，这&lt;em&gt;就是&lt;/em&gt;块作用域。 这些变量是传递给它们的对象的属性的别名。</target>
        </trans-unit>
        <trans-unit id="e6021de7d4da167c9d1924fe6e9b51d156cf4a9a" translate="yes" xml:space="preserve">
          <source>EDIT: Clarifying example:</source>
          <target state="translated">EDIT:澄清的例子。</target>
        </trans-unit>
        <trans-unit id="409777b6233f21776478ec8ae63313ad04d136b2" translate="yes" xml:space="preserve">
          <source>EDIT: ECMAAScript 6 (Harmony) is spec'ed to support let, and I know chrome allows a 'harmony' flag, so perhaps it does support it..</source>
          <target state="translated">EDIT:ECMAAScript 6 (Harmony)是支持let的,我知道chrome允许 &quot;和谐 &quot;标志,所以也许它确实支持.....</target>
        </trans-unit>
        <trans-unit id="35e06056ed8896626ffd136476a7dd3ee396b131" translate="yes" xml:space="preserve">
          <source>Each function creates an execution context (but not always a new this binding)</source>
          <target state="translated">每个函数都会创建一个执行上下文(但不一定是新的这个绑定)。</target>
        </trans-unit>
        <trans-unit id="a6992c03e5f9e7f14a3502886f2fe8726fe41373" translate="yes" xml:space="preserve">
          <source>Every variable declared with the &lt;code&gt;var&lt;/code&gt; keyword is scoped to the function. However, if other function are declared within that function those functions will have access to the variables of the outer functions. This is called a &lt;strong&gt;scope chain&lt;/strong&gt;. It works in the following manner:</source>
          <target state="translated">用 &lt;code&gt;var&lt;/code&gt; 关键字声明的每个变量都作用于该函数。 但是，如果在该函数中声明了其他函数，则这些函数将有权访问外部函数的变量。 这称为&lt;strong&gt;范围链&lt;/strong&gt; 。 它以以下方式工作：</target>
        </trans-unit>
        <trans-unit id="be91cfda712a2aa2bbaed218f5da3f4f20ced37f" translate="yes" xml:space="preserve">
          <source>Example of block scope is :-</source>
          <target state="translated">块的范围示例是:-</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="13c2c628d0e65d9c75a59c080f5bcf4a585ac61e" translate="yes" xml:space="preserve">
          <source>Find out &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures&quot;&gt;more&lt;/a&gt;.</source>
          <target state="translated">了解&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures&quot;&gt;更多&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3e52c062915c2a123c8f3e107bb729e5edb24b0" translate="yes" xml:space="preserve">
          <source>For an up-to-date overview of which browsers support the &lt;code&gt;let&lt;/code&gt; statement at the time of your reading this answer, see &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;this &lt;code&gt;Can I Use&lt;/code&gt; page&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">有关在阅读此答案时哪些浏览器支持 &lt;code&gt;let&lt;/code&gt; 语句的最新概述，请参见&lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt; &lt;code&gt;Can I Use&lt;/code&gt; 页面&lt;/strong&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f759fff65c16814ccf2912386bb55ea2f49f07e2" translate="yes" xml:space="preserve">
          <source>For those that believe there is only global and local scope, please explain why Mozilla would have an entire page describing the nuances of block scope in JS.</source>
          <target state="translated">对于那些认为只有全局范围和局部范围的人,请解释一下为什么Mozilla会有一整个页面来描述JS中块范围的细微差别。</target>
        </trans-unit>
        <trans-unit id="b3a281d3e09d661ffef9d575955e9402e9acd1b7" translate="yes" xml:space="preserve">
          <source>Function - visible within a function (and its sub-functions and blocks)</source>
          <target state="translated">函数----在一个函数中可见(及其子函数和块)。</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">职能机构</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">函数声明</target>
        </trans-unit>
        <trans-unit id="54098e1a6688516674ee45e3b3d0d1327b43c770" translate="yes" xml:space="preserve">
          <source>Function declarations have block scope in strict mode and function scope in non-strict mode. Note: non-strict mode is a complicated set of emergent rules based on the quirky historical implementations of different browsers.</source>
          <target state="translated">函数声明在严格模式下有块范围,在非严格模式下有函数范围。注:非严格模式是基于不同浏览器的离奇的历史实现而产生的一套复杂的规则。</target>
        </trans-unit>
        <trans-unit id="7f91e1a8edc0e34ea3bca466ca46d82f7465d0d6" translate="yes" xml:space="preserve">
          <source>Function parameter names</source>
          <target state="translated">函数参数名称</target>
        </trans-unit>
        <trans-unit id="9b10b98fb2db663a6af8871104c108ef004b25fd" translate="yes" xml:space="preserve">
          <source>Function parameter names are scoped to the function body.</source>
          <target state="translated">函数参数名称的范围是函数主体。</target>
        </trans-unit>
        <trans-unit id="1e0d99529d66efa9e16b2a37d29fa7405450d6fd" translate="yes" xml:space="preserve">
          <source>Function parameters</source>
          <target state="translated">功能参数</target>
        </trans-unit>
        <trans-unit id="f0919c6e7316ed9e8e640c9b80f7609cc7dbc45b" translate="yes" xml:space="preserve">
          <source>Function parameters can be considered to be declared in the function body:</source>
          <target state="translated">函数参数可以认为是在函数体中声明的。</target>
        </trans-unit>
        <trans-unit id="cc0841f2f77bf09c47bd5cbb83dd0f40e14bf028" translate="yes" xml:space="preserve">
          <source>Global - visible by everything</source>
          <target state="translated">全球性的-----------------------------一切都能看到</target>
        </trans-unit>
        <trans-unit id="ab9be0bed756d5b31a5365140ba111b3a60a2123" translate="yes" xml:space="preserve">
          <source>Global Scope :</source>
          <target state="translated">全球范围:</target>
        </trans-unit>
        <trans-unit id="9c1d41d613e2de602e0cfbbc37dd6fb38c9598e2" translate="yes" xml:space="preserve">
          <source>Global context</source>
          <target state="translated">全球背景</target>
        </trans-unit>
        <trans-unit id="1fd666f0db8baac461a523eb3696c9d6cf767ffc" translate="yes" xml:space="preserve">
          <source>Global scope</source>
          <target state="translated">全球范围</target>
        </trans-unit>
        <trans-unit id="1db5edb9fb9b116986bc02c1af9c99d7780ec95f" translate="yes" xml:space="preserve">
          <source>Global variables are exactly like global stars (Jackie Chan, Nelson Mandela). You can access them (get or set the value), from any part of your application. Global functions are like global events (New Year, Christmas). You can execute (call) them from any part of your application.</source>
          <target state="translated">全局变量就像全局明星一样(成龙,纳尔逊-曼德拉)。你可以从你的应用程序的任何部分访问它们(获取或设置值)。全局函数就像全局事件(新年、圣诞节)。你可以从你的应用程序的任何部分执行(调用)它们。</target>
        </trans-unit>
        <trans-unit id="b6c6545a0afcd35503cd3889c2e63ae786e74d3d" translate="yes" xml:space="preserve">
          <source>Here is a good article on the subject.</source>
          <target state="translated">下面是一篇关于这个问题的好文章。</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="36b16afa86f01c1ed6ed7ee0985634679d23724b" translate="yes" xml:space="preserve">
          <source>Here, we can see that our variable &lt;code&gt;j&lt;/code&gt; is only known in the first for loop, but not before and after. Yet, our variable &lt;code&gt;i&lt;/code&gt; is known in the entire function.</source>
          <target state="translated">在这里，我们可以看到我们的变量 &lt;code&gt;j&lt;/code&gt; 仅在第一个for循环中已知，而在之前和之后都不知道。 但是，我们的变量 &lt;code&gt;i&lt;/code&gt; 在整个函数中是已知的。</target>
        </trans-unit>
        <trans-unit id="6197c902dc9a969800bbc1f43aa78895c0f511c1" translate="yes" xml:space="preserve">
          <source>How an identifier was declared</source>
          <target state="translated">识别器是如何申报的</target>
        </trans-unit>
        <trans-unit id="fd84c93e786da583023283e8e6b544cc15f8a544" translate="yes" xml:space="preserve">
          <source>How do I create block scope variables?</source>
          <target state="translated">如何创建块范围变量?</target>
        </trans-unit>
        <trans-unit id="6523732fcc8d20544777c08d98cafcd3a527d5d8" translate="yes" xml:space="preserve">
          <source>How it works under the hood</source>
          <target state="translated">它是如何在引擎盖下工作的</target>
        </trans-unit>
        <trans-unit id="9bccab4e65ebb124be42a79a1ea8250f796b3a9e" translate="yes" xml:space="preserve">
          <source>How to keep track of browser support</source>
          <target state="translated">如何跟踪浏览器的支持情况</target>
        </trans-unit>
        <trans-unit id="12e28ac9e5aec52d743e292f0a6d97a79a4481d9" translate="yes" xml:space="preserve">
          <source>I found that many people new to JavaScript have trouble understanding that inheritance is available by default in the language and that function scope is the only scope, so far. I provided an extension to a beautifier I wrote at the end of last year called JSPretty. The feature colors function scope in the code and always associates a color to all variables declared in that scope. Closure is visually demonstrated when a variable with a color from one scope is used in a different scope.</source>
          <target state="translated">我发现很多刚接触JavaScript的人都很难理解,在语言中,继承是默认的,而函数作用域是唯一的作用域,到目前为止,继承是唯一的作用域。我在去年年底写的一个叫JSPretty的美化器上提供了一个扩展。该功能为代码中的函数作用域着色,并总是将一个颜色关联到该作用域中声明的所有变量。当一个作用域中的颜色的变量在不同的作用域中使用时,就会直观地表现出封闭性。</target>
        </trans-unit>
        <trans-unit id="cdf8b31fb66ebedcd5a01dafdc4d2f5c826f3323" translate="yes" xml:space="preserve">
          <source>I will not elaborate on this, since there are already many other answers explaining the difference.</source>
          <target state="translated">这一点我就不细说了,因为已经有很多其他的答案解释了。</target>
        </trans-unit>
        <trans-unit id="eadac369b069051bb3496882603cd8c18a6245be" translate="yes" xml:space="preserve">
          <source>Identifier resolution only occurs in one direction: outwards. In this way, outer lexical environments cannot &quot;see&quot; into inner lexical environments.</source>
          <target state="translated">识别器的解析只发生在一个方向:向外。这样一来,外部词性环境就不能 &quot;看 &quot;到内部词性环境。</target>
        </trans-unit>
        <trans-unit id="bac671b2d31df9b17566a019bb6eec35764631e1" translate="yes" xml:space="preserve">
          <source>Identifiers declared using &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;&lt;strong&gt;have block scope&lt;/strong&gt;, apart from when they are declared directly in the global context, in which case they have global scope.</source>
          <target state="translated">使用 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 声明的标识符&lt;strong&gt;具有块作用域&lt;/strong&gt; ，除了直接在全局上下文中声明时（在这种情况下，它们具有全局作用域）。</target>
        </trans-unit>
        <trans-unit id="26eb35e5d6c55c98bf781bbeb4741c6d644d48f6" translate="yes" xml:space="preserve">
          <source>Identifiers declared using &lt;code&gt;var&lt;/code&gt;&lt;strong&gt;have function scope&lt;/strong&gt;, apart from when they are declared directly in the global context, in which case they are added as properties on the global object and have global scope. There are separate rules for their use in &lt;code&gt;eval&lt;/code&gt; functions.</source>
          <target state="translated">使用 &lt;code&gt;var&lt;/code&gt; 声明的标识符&lt;strong&gt;具有函数scope&lt;/strong&gt; ，除了直接在全局上下文中声明它们时，在这种情况下，它们被添加为全局对象的属性并具有全局范围。 在 &lt;code&gt;eval&lt;/code&gt; 函数中有单独的使用规则。</target>
        </trans-unit>
        <trans-unit id="f36a64720f58b77b1ccc6c4e4747411d14a62208" translate="yes" xml:space="preserve">
          <source>If it cannot find the variable inside the the function body it &lt;strong&gt;will climb up to the chain&lt;/strong&gt; and look at the variable scope in the function in &lt;strong&gt;where the function was defined&lt;/strong&gt;. This is what is meant with lexical scope, we can see in the code where this function was defined and thus can determine the scope chain by merely looking at the code.</source>
          <target state="translated">如果在函数体内找不到变量， &lt;strong&gt;它将爬到链上，&lt;/strong&gt;并在&lt;strong&gt;定义&lt;/strong&gt;函数的&lt;strong&gt;位置&lt;/strong&gt;查看函数中的变量范围。 这就是词汇作用域的含义，我们可以在代码中看到定义此函数的位置，因此仅查看代码即可确定作用域链。</target>
        </trans-unit>
        <trans-unit id="745abb411c5db9b98fe9940dfa7c7e42d66969dd" translate="yes" xml:space="preserve">
          <source>If you are in the USA, you may know Kim Kardashian, infamous celebrity ( she somehow manages to make the tabloids). But people outside of the USA will not recognize her. She is a local star, bound to her territory.</source>
          <target state="translated">如果你在美国,你可能知道Kim Kardashian,臭名昭著的名人(她莫名其妙的上了小报)。但是,美国以外的人不会认识她。她是一个本土明星,受制于她的领地。</target>
        </trans-unit>
        <trans-unit id="db4ede529a33a6d48b929256007928a838c5c68c" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</source>
          <target state="translated">如果你正在编写客户端的JavaScript代码,并且没有使用转码器,你需要考虑浏览器的支持。</target>
        </trans-unit>
        <trans-unit id="8dcd2b2b003bbf8ee33318bcf617bf8c5934526f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a Node based transpiler (like the &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell script&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.</source>
          <target state="translated">如果您正在编写客户端JavaScript代码并使用基于Node的编译器（例如&lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell脚本&lt;/strong&gt;&lt;/a&gt;或&lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt; ），则可以安全地使用 &lt;code&gt;let&lt;/code&gt; 语句。 并且由于您的浏览器仅会了解已转译的代码，因此应限制性能方面的弊端。</target>
        </trans-unit>
        <trans-unit id="78db1b0537f209bbe9cabb545f633294560d8d7f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a browser based transpiler (like &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement, however your code is likely to be anything but optimal with respect to performance.</source>
          <target state="translated">如果您正在编写客户端JavaScript代码并使用基于浏览器的编译器（例如&lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt;或&lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt; ），则可以安全地使用 &lt;code&gt;let&lt;/code&gt; 语句，但是就性能而言，代码可能不是最佳选择。</target>
        </trans-unit>
        <trans-unit id="4730b8ff337fd5e9541397578300f0622cd1031f" translate="yes" xml:space="preserve">
          <source>If you're writing server-side JavaScript code (&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement.</source>
          <target state="translated">如果要编写服务器端JavaScript代码（ &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt; ），则可以安全地使用 &lt;code&gt;let&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="e76b9230322e627054331e7b9ae49ba5c423394b" translate="yes" xml:space="preserve">
          <source>Implicit variable declarations</source>
          <target state="translated">隐含变量声明</target>
        </trans-unit>
        <trans-unit id="45efcccf469aa7800be7436a4b8905d5812288f9" translate="yes" xml:space="preserve">
          <source>In &quot;Javascript 1.7&quot; (Mozilla's extension to Javascript) one can also declare block-scope variables with &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt;:</source>
          <target state="translated">在&amp;ldquo; Javascript 1.7&amp;rdquo;（Mozilla对Javascript的扩展）中，还可以使用&lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11&quot;&gt; &lt;code&gt;let&lt;/code&gt; 语句&lt;/a&gt;声明块范围变量：</target>
        </trans-unit>
        <trans-unit id="df791ba6a19c022e5fd42c64ae7d2edc9a0401c4" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;eval&lt;/code&gt; strings, variables declared using &lt;code&gt;var&lt;/code&gt; will be placed in the current scope, or, if &lt;code&gt;eval&lt;/code&gt; is used indirectly, as properties on the global object.</source>
          <target state="translated">在 &lt;code&gt;eval&lt;/code&gt; 字符串中，使用 &lt;code&gt;var&lt;/code&gt; 声明的变量将放置在当前作用域中，或者，如果间接使用 &lt;code&gt;eval&lt;/code&gt; ，则将其作为全局对象的属性。</target>
        </trans-unit>
        <trans-unit id="b205565c9d304960cff99be6d6bb359de2add3f5" translate="yes" xml:space="preserve">
          <source>In EcmaScript5, there are mainly two scopes, &lt;strong&gt;local scope&lt;/strong&gt; and &lt;strong&gt;global scope&lt;/strong&gt; but in EcmaScript6 we have mainly three scopes, local scope, global scope and a new scope called &lt;strong&gt;block scope&lt;/strong&gt;.</source>
          <target state="translated">在EcmaScript5中，主要有两个范围， &lt;strong&gt;本地范围&lt;/strong&gt;和&lt;strong&gt;全局范围，&lt;/strong&gt;但是在EcmaScript6中，我们主要有三个范围，本地范围，全局范围和称为&lt;strong&gt;块范围&lt;/strong&gt;的新&lt;strong&gt;范围&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="524ef03338ba6373ff8442de44d3525db236f6ed" translate="yes" xml:space="preserve">
          <source>In JavaScript there are two types of scope:</source>
          <target state="translated">在JavaScript中,有两种类型的作用域。</target>
        </trans-unit>
        <trans-unit id="49f24e5b3ac83ce8f7d46f9b0b5fbf42b56fef59" translate="yes" xml:space="preserve">
          <source>In JavaScript, every function-object has a hidden &lt;code&gt;[[Environment]]&lt;/code&gt; reference that is a reference to the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;lexical environment&lt;/a&gt; of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;execution context&lt;/a&gt; (stack frame) within which it was created.</source>
          <target state="translated">在JavaScript中，每个功能对象都有一个隐藏的 &lt;code&gt;[[Environment]]&lt;/code&gt; 引用，该引用是对在其中创建它的&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;执行上下文&lt;/a&gt; （堆栈框架）的&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;词汇环境&lt;/a&gt;的引用。</target>
        </trans-unit>
        <trans-unit id="101098685b4ef4c5fe8ddde1f6b84cd946e6cda9" translate="yes" xml:space="preserve">
          <source>In non-strict mode, function declarations have function scope. In strict mode they have block scope.</source>
          <target state="translated">在非严格模式下,函数声明具有函数范围。在严格模式下,它们有块范围。</target>
        </trans-unit>
        <trans-unit id="517fb1c6e1e082360f7bfc6a062cddd34106ba21" translate="yes" xml:space="preserve">
          <source>In non-strict mode, implicit variable declarations are globally scoped. In strict mode you get an error.</source>
          <target state="translated">在非严格模式下,隐含变量声明是全局范围的。在严格模式下,你会得到一个错误。</target>
        </trans-unit>
        <trans-unit id="c530a0f6e7c617894a5240c8ce5b620b9c103965" translate="yes" xml:space="preserve">
          <source>In non-strict mode, implicit variable declarations have global scope. In strict mode these are not permitted.</source>
          <target state="translated">在非严格模式下,隐含变量声明具有全局范围。在严格模式下,不允许使用这些变量声明。</target>
        </trans-unit>
        <trans-unit id="5f6bfeda81e0e8b51ad8697f031e39feead1aa2e" translate="yes" xml:space="preserve">
          <source>In the above example letVar logs the value global because variables declared with &lt;code&gt;let&lt;/code&gt; are block scoped. They cease to exist outside their respective block, so the variable can't be accessed outside the if block.</source>
          <target state="translated">在上面的示例中，letVar记录全局值，因为用 &lt;code&gt;let&lt;/code&gt; 声明的变量是块作用域的。 它们不再在各自的块外存在，因此无法在if块外访问变量。</target>
        </trans-unit>
        <trans-unit id="f75a76f8d36110fb25053c596b58acad7a1e7f42" translate="yes" xml:space="preserve">
          <source>In the first example, there was no block scope, so the initially declared variables were overwritten. In the second example, there was a new scope due to the function, so the initially declared variables were SHADOWED, and not overwritten.</source>
          <target state="translated">在第一个例子中,没有块作用域,所以最初声明的变量被覆盖了。在第二个例子中,由于函数产生了一个新的作用域,所以最初声明的变量被SHADOWED,没有被覆盖。</target>
        </trans-unit>
        <trans-unit id="70b614f546808637e2d6bda4b19e2a55f0206cd8" translate="yes" xml:space="preserve">
          <source>In the following, &lt;code&gt;x&lt;/code&gt; is visible outside of the loop because &lt;code&gt;var&lt;/code&gt; has function scope:</source>
          <target state="translated">在下面的代码中，由于 &lt;code&gt;var&lt;/code&gt; 具有函数作用域，因此 &lt;code&gt;x&lt;/code&gt; 在循环外部是可见的：</target>
        </trans-unit>
        <trans-unit id="d512dd946ae9252d40645adc648a80ba866281e8" translate="yes" xml:space="preserve">
          <source>In this language, the displays were done similar to a stack of index cards. There was a master card referred to as the background. It was transparent and can be seen as the bottom card. Any content on this base card was shared with cards placed on top of it. Each card placed on top had its own content which took precedence over the previous card, but still had access to the prior cards if desired.</source>
          <target state="translated">在这种语言中,显示的方式类似于一叠索引卡。有一张主卡被称为底牌。它是透明的,可以看成是底卡。这张底卡上的任何内容都是与放置在上面的卡片共享的。放在上面的每一张卡片都有自己的内容,它比前一张卡片的内容优先,但如果需要的话,仍然可以访问前面的卡片。</target>
        </trans-unit>
        <trans-unit id="597c9aea5b3298abab060a8929051c7f5d129292" translate="yes" xml:space="preserve">
          <source>Is it safe to use block scope variables today?</source>
          <target state="translated">现在使用区块范围变量安全吗?</target>
        </trans-unit>
        <trans-unit id="bed514e2588665341497d11ae432c1980024650f" translate="yes" xml:space="preserve">
          <source>JavaScript has lexical (also called static) scoping and closures. This means you can tell the scope of an identifier by looking at the source code.</source>
          <target state="translated">JavaScript有词法(也叫静态)范围和闭包。这意味着你可以通过查看源代码来判断一个标识符的范围。</target>
        </trans-unit>
        <trans-unit id="4452aeeb557996248e57cd5ff1bf92ebc44de21c" translate="yes" xml:space="preserve">
          <source>JavaScript have only two type of scope :</source>
          <target state="translated">JavaScript只有两种类型的作用域。</target>
        </trans-unit>
        <trans-unit id="34dae96f32e8c613581daf8160bc2454a1788290" translate="yes" xml:space="preserve">
          <source>Javascript uses scope chains to establish the scope for a given function. There is typically one global scope, and each function defined has its own nested scope. Any function defined within another function has a local scope which is linked to the outer function. It's always the position in the source that defines the scope.</source>
          <target state="translated">Javascript使用作用域链来为给定函数建立作用域。通常有一个全局作用域,每个定义的函数都有自己的嵌套作用域。在另一个函数内定义的任何函数都有一个局部作用域,这个作用域与外部函数相连。定义作用域的总是源中的位置。</target>
        </trans-unit>
        <trans-unit id="aaccd2b14cae60b4870ad3ae5d1483bf95f1cc7f" translate="yes" xml:space="preserve">
          <source>Just to add to the other answers, scope is a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.  This look-up may be for the purposes of assigning to the variable, which is an LHS (lefthand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. These look-ups are what the JavaScript engine is doing internally when it's compiling and executing the code.</source>
          <target state="translated">只是为了补充其他答案,作用域是一个查询列表,它是所有声明的标识符(变量)的查询列表,并对当前执行的代码如何访问这些标识符(变量)执行一套严格的规则。这个查找可能是为了分配给变量,这是一个LHS(左手边的)引用,也可能是为了检索它的值,这是一个RHS(右手边的)引用。这些查找是JavaScript引擎在编译和执行代码时,内部所做的事情。</target>
        </trans-unit>
        <trans-unit id="6e76cdd0f809219e814e41d1445bb5906bf62b65" translate="yes" xml:space="preserve">
          <source>Let would be a support for block level scoping, but you have to use the keyword to make it happen.</source>
          <target state="translated">让将是对块级范围化的支持,但你必须使用关键字来实现它。</target>
        </trans-unit>
        <trans-unit id="8e18f18ab1ca156d4e71dc6cde7b4aa86040a968" translate="yes" xml:space="preserve">
          <source>Local Scope :</source>
          <target state="translated">当地范围:</target>
        </trans-unit>
        <trans-unit id="ca1be526eefc4c0c9a3b41b14b0b70782146069f" translate="yes" xml:space="preserve">
          <source>Local scope</source>
          <target state="translated">当地范围</target>
        </trans-unit>
        <trans-unit id="a5d58a53fe2af24df0c1d2967e48151aa15ad00d" translate="yes" xml:space="preserve">
          <source>Local variables are like local stars. You can only access them (get or set the value) inside the scope. A local function is like local events - you can execute only (celebrate) inside that scope. If you want to access them from outside of the scope, you will get a reference error</source>
          <target state="translated">本地变量就像本地星一样。你只能在作用域内访问它们(获取或设置值)。本地函数就像本地事件一样--你只能在该作用域内执行(庆祝)。如果你想从作用域外访问它们,你会得到一个参考错误</target>
        </trans-unit>
        <trans-unit id="4136eb8081368e099724a9eb455093c190198113" translate="yes" xml:space="preserve">
          <source>Modern JavaScript</source>
          <target state="translated">现代JavaScript</target>
        </trans-unit>
        <trans-unit id="7616704e501c489cb1ada1999f1307d7d34894df" translate="yes" xml:space="preserve">
          <source>Modern Js, ES6+, '&lt;code&gt;const&lt;/code&gt;' and '&lt;code&gt;let&lt;/code&gt;'</source>
          <target state="translated">现代Js，ES6 +，&amp;ldquo; &lt;code&gt;const&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;let&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="aad38a0f6cdff42e1f74357a58c635fc618d1ed1" translate="yes" xml:space="preserve">
          <source>Module - visible within a module</source>
          <target state="translated">模块-在模块内可见</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="003bc7d27503c7802bcadc1da058ded6bae30f8e" translate="yes" xml:space="preserve">
          <source>My understanding is that there are 3 scopes: global scope, available globally; local scope, available to an entire function regardless of blocks; and block scope, only available to the block, statement, or expression on which it was used. Global and local scope are indicated with the keyword 'var', either within a function or outside, and block scope is indicated with the keyword 'let'.</source>
          <target state="translated">我的理解是,有3个作用域:全局作用域,全局可用;局部作用域,对整个函数不分块,对整个函数可用;块作用域,只对使用它的块、语句或表达式可用。全局作用域和局部作用域用关键字 &quot;var &quot;表示,可以在函数内,也可以在函数外,块作用域用关键字 &quot;let &quot;表示。</target>
        </trans-unit>
        <trans-unit id="ebc5769ecf05a1a2a40ee3c38b9f80c576a2506b" translate="yes" xml:space="preserve">
          <source>Named function expressions</source>
          <target state="translated">命名的函数表达式</target>
        </trans-unit>
        <trans-unit id="eaab883a49ed3ddf47b830ade67ddd95c8b8889b" translate="yes" xml:space="preserve">
          <source>Named function expressions are scooped only to the expression itself:</source>
          <target state="translated">命名的函数表达式只舀到表达式本身。</target>
        </trans-unit>
        <trans-unit id="7e130810bfbd11725f532879f063fa5c57ae9625" translate="yes" xml:space="preserve">
          <source>Named function expressions are scoped to themselves (eg. for the purpose of recursion).</source>
          <target state="translated">命名的函数表达式是对自己的范围化(例如,为了递归的目的)。</target>
        </trans-unit>
        <trans-unit id="0f5c3a674d3ca00ddc3c16a5c7583524970181f2" translate="yes" xml:space="preserve">
          <source>Note that this link between the new execution context and the lexical environment of the function object is called a &lt;a href=&quot;https://stackoverflow.com/a/111114/38522&quot;&gt;closure&lt;/a&gt;.</source>
          <target state="translated">注意，新执行上下文和函数对象的词法环境之间的这种链接称为&lt;a href=&quot;https://stackoverflow.com/a/111114/38522&quot;&gt;闭包&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f243cfe125f58adb4304f18257f0d057d6f2352" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;are all hoisted&lt;/a&gt;. This means that their logical position of definition is the top of their enclosing scope (block or function). However, variables declared useing &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; cannot be read or assigned to until control has passed the point of declaration in the source code. The interim period is known as the temporal dead zone.</source>
          <target state="translated">注意： &lt;code&gt;let&lt;/code&gt; ， &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;var&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;都已挂起&lt;/a&gt; 。 这意味着它们的逻辑定义位置是其包围范围（模块或功能）的顶部。 但是，在控制通过源代码中的声明点之前，无法读取或分配使用 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;const&lt;/code&gt; 声明的变量。 过渡期称为时间盲区。</target>
        </trans-unit>
        <trans-unit id="52c316d760a2406f9de3c2dfe34c168873a682d6" translate="yes" xml:space="preserve">
          <source>Now when a variable &lt;code&gt;a&lt;/code&gt; required it first searches for nearest variable scope and if variable is not there than it move's to next object of variable scope chain.which is in this case is window level.</source>
          <target state="translated">现在，当需要一个变量时，它首先搜索最近的变量范围，如果不存在变量，则将其移到变量范围链的下一个对象。</target>
        </trans-unit>
        <trans-unit id="07cc61cfbd5542be1dbdf3df9337149c96b1472d" translate="yes" xml:space="preserve">
          <source>Old school JavaScript</source>
          <target state="translated">老派的JavaScript</target>
        </trans-unit>
        <trans-unit id="d143a89c1211786baeac1937b212ea01195019e5" translate="yes" xml:space="preserve">
          <source>On a different note, unlike normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, which run on the top level, code inside ES6 modules runs in its own private scope. A variable defined at the top of a normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is global, so you can reference it in other &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, like this:</source>
          <target state="translated">另外，与在顶层运行的普通 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记不同，ES6模块内部的代码在其自己的私有范围内运行。 在常规 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记顶部定义的变量是全局变量，因此您可以在其他 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标记中引用它，如下所示：</target>
        </trans-unit>
        <trans-unit id="d03a95004161c654858d132f7f32b4344e85bba0" translate="yes" xml:space="preserve">
          <source>One thing of note that is worth mentioning, &quot;Scope look-up stops once it finds the first match&quot;.</source>
          <target state="translated">值得一提的是,有一点值得一提的是,&quot;一旦找到第一场比赛,范围查询就会停止&quot;。</target>
        </trans-unit>
        <trans-unit id="39d115a82e8ca46b1e1da4cb77b8126173035ef2" translate="yes" xml:space="preserve">
          <source>Ordinary block</source>
          <target state="translated">普通块</target>
        </trans-unit>
        <trans-unit id="3e7192956deaab738bd72c8783df974fd557d341" translate="yes" xml:space="preserve">
          <source>Otherwise, you'll get a ReferenceError when the handler is invoked. So, for example, if the inline handler references a function which is defined &lt;em&gt;inside&lt;/em&gt;&lt;code&gt;window.onload&lt;/code&gt; or &lt;code&gt;$(function() {&lt;/code&gt;, the reference will fail, because the inline handler may only reference variables in the global scope, and the function is not global:</source>
          <target state="translated">否则，在调用处理程序时会收到ReferenceError。 因此，例如，如果内联处理程序引用&lt;em&gt;在&lt;/em&gt; &lt;code&gt;window.onload&lt;/code&gt; 或 &lt;code&gt;$(function() {&lt;/code&gt; &lt;em&gt;内&lt;/em&gt;定义的函数 ，则引用将失败，因为内联处理程序只能引用全局范围内的变量，而该函数不会全球：</target>
        </trans-unit>
        <trans-unit id="b0f7eac222c33234d6b1ce96f288537ff995de59" translate="yes" xml:space="preserve">
          <source>Outside of the special cases of global and module scope, variables are declared using &lt;code&gt;var&lt;/code&gt; (function scope), &lt;code&gt;let&lt;/code&gt; (block scope) and &lt;code&gt;const&lt;/code&gt; (block scope). Most other forms of identifier declaration have block scope in strict mode.</source>
          <target state="translated">在全局范围和模块范围的特殊情况之外，使用 &lt;code&gt;var&lt;/code&gt; （函数范围）， &lt;code&gt;let&lt;/code&gt; （块范围）和 &lt;code&gt;const&lt;/code&gt; （块范围）声明变量。 标识符声明的大多数其他形式在严格模式下具有块作用域。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="4d2fae3746da9a4ac50d19572acc01ad9fa90618" translate="yes" xml:space="preserve">
          <source>Properties of the &lt;code&gt;document&lt;/code&gt; and properties of the element the handler is attached to may also be referenced as standalone variables inside inline handlers because inline handlers are invoked &lt;a href=&quot;https://i.stack.imgur.com/dTDB0.png&quot;&gt;&lt;em&gt;inside&lt;/em&gt; of two &lt;code&gt;with&lt;/code&gt; blocks&lt;/a&gt;, one for the &lt;code&gt;document&lt;/code&gt;, one for the element. The scope chain of variables inside these handlers is &lt;a href=&quot;https://stackoverflow.com/a/57048067&quot;&gt;extremely unintuitive&lt;/a&gt;, and a working event handler will &lt;em&gt;probably&lt;/em&gt; require a function to be global (and unnecessary global pollution &lt;a href=&quot;https://softwareengineering.stackexchange.com/q/148108&quot;&gt;should probably be avoided&lt;/a&gt;).</source>
          <target state="translated">内联处理程序中的 &lt;code&gt;document&lt;/code&gt; 属性和附加到处理程序的元素的属性也可以称为独立变量，因为内联处理程序&lt;a href=&quot;https://i.stack.imgur.com/dTDB0.png&quot;&gt;&lt;em&gt;在&lt;/em&gt;两个 &lt;code&gt;with&lt;/code&gt; 块的&lt;em&gt;内部&lt;/em&gt;&lt;/a&gt;调用，一个用于 &lt;code&gt;document&lt;/code&gt; ，一个用于元素。 这些处理程序中的变量作用域链是&lt;a href=&quot;https://stackoverflow.com/a/57048067&quot;&gt;非常不直观的&lt;/a&gt; ，并且工作事件处理程序&lt;em&gt;可能会&lt;/em&gt;要求函数是全局的（并且&lt;a href=&quot;https://softwareengineering.stackexchange.com/q/148108&quot;&gt;应该避免&lt;/a&gt;不必要的全局污染）。</target>
        </trans-unit>
        <trans-unit id="358bcd9d5d263dcf0acf4e412ac146d3ec1cbcef" translate="yes" xml:space="preserve">
          <source>Quoting from his ebook:</source>
          <target state="translated">引述他的电子书中的内容。</target>
        </trans-unit>
        <trans-unit id="a23997220606bd14c55eafa62be1140a4157f6e3" translate="yes" xml:space="preserve">
          <source>Scope chain --&amp;gt;</source>
          <target state="translated">范围链-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="960f638fe475e770a8e797654ca9cc8ebe41b2a9" translate="yes" xml:space="preserve">
          <source>Scope is defined as the &lt;a href=&quot;https://stackoverflow.com/a/1047479/38522&quot;&gt;lexical&lt;/a&gt; region of code over which an identifier is valid.</source>
          <target state="translated">范围定义为标识符在其上有效的代码的&lt;a href=&quot;https://stackoverflow.com/a/1047479/38522&quot;&gt;词法&lt;/a&gt;区域。</target>
        </trans-unit>
        <trans-unit id="0001dde1682d4a228cca759a547c5f895b3d0836" translate="yes" xml:space="preserve">
          <source>Scope is formed of a linked nesting of lexical environments, with each level in the nesting corresponding to a lexical environment of an ancestor execution context.</source>
          <target state="translated">范围是由词法环境的链接嵌套形成的,嵌套中的每一级对应于一个祖先执行语境的词法环境。</target>
        </trans-unit>
        <trans-unit id="03fc8d42427c442b2a752ef4c9a4f0079386dd0a" translate="yes" xml:space="preserve">
          <source>Scope is the region of the codebase over which an identifier is valid.</source>
          <target state="translated">范围是指标识符在代码库中有效的区域。</target>
        </trans-unit>
        <trans-unit id="d9e69c5319ff44dd0f7e6cd91e381690e40b15e1" translate="yes" xml:space="preserve">
          <source>Scopes are technically &quot;Execution Contexts&quot;</source>
          <target state="translated">严格说来,作用域是 &quot;执行上下文&quot;</target>
        </trans-unit>
        <trans-unit id="8014aa999f8e9f357a908dec6565c42cc7afe011" translate="yes" xml:space="preserve">
          <source>See a demo at:</source>
          <target state="translated">看一个演示,在。</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">显示代码片段</target>
        </trans-unit>
        <trans-unit id="4a2982e515416ff8974a0e226abce538efa699bf" translate="yes" xml:space="preserve">
          <source>Since the scope chain inside inline handlers is &lt;em&gt;so weird&lt;/em&gt;, and since inline handlers require global pollution to work, and since inline handlers sometimes require ugly string escaping when passing arguments, it's probably easier to avoid them. Instead, attach event handlers using Javascript (like with &lt;code&gt;addEventListener&lt;/code&gt;), rather than with HTML markup.</source>
          <target state="translated">由于内联处理程序中的作用域链是&lt;em&gt;如此奇怪&lt;/em&gt; ，并且内联处理程序需要全局污染才能正常工作，并且内联处理程序在传递参数时有时需要丑陋的字符串转义，因此避免它们可能更容易。 而是使用Javascript（例如，使用 &lt;code&gt;addEventListener&lt;/code&gt; ）而不是HTML标记附加事件处理程序。</target>
        </trans-unit>
        <trans-unit id="d7b8f215615eb4f7e16592cd68df7d8300b6ec09" translate="yes" xml:space="preserve">
          <source>So from this perspective, I think that a picture would help that I found in the Scopes and Closures ebook by Kyle Simpson:</source>
          <target state="translated">所以,从这个角度来说,我觉得在凯尔-辛普森的《范围与封闭》电子书中找到的一张图片会有帮助。</target>
        </trans-unit>
        <trans-unit id="260b57030b2b60bb30906c7875f28bf2c6a9202e" translate="yes" xml:space="preserve">
          <source>So that is the technical explanation. In practice, it is important to remember that in JavaScript</source>
          <target state="translated">所以这就是技术上的解释。在实际工作中,要记住,在JavaScript中</target>
        </trans-unit>
        <trans-unit id="6eeb8f5239adbcf206f276fe0178d507b944531b" translate="yes" xml:space="preserve">
          <source>So this code:</source>
          <target state="translated">所以这个代码。</target>
        </trans-unit>
        <trans-unit id="9149eb7ca4536bbe4c6e7d579b916628507a6c43" translate="yes" xml:space="preserve">
          <source>So what is the difference between functional scope and block scope?</source>
          <target state="translated">那么,功能范围和块范围有什么区别呢?</target>
        </trans-unit>
        <trans-unit id="de0115ead2817c9e584c804563ac34e1a02cf494" translate="yes" xml:space="preserve">
          <source>So you can see JavaScript scoping is actually extremely simple, albeit not always intuitive. A few things to be aware of:</source>
          <target state="translated">所以你可以看到,JavaScript scoping实际上是非常简单的,尽管并不总是很直观。有几件事需要注意。</target>
        </trans-unit>
        <trans-unit id="3812cb403a9ffcb176a50c641ea80b4719348646" translate="yes" xml:space="preserve">
          <source>So, any blocks other than functions do not create a new scope. That explains why for-loops overwrite outer scoped variables:</source>
          <target state="translated">所以,除了函数以外的任何块都不会创建一个新的作用域。这就解释了为什么for-loop会覆盖外部作用域变量。</target>
        </trans-unit>
        <trans-unit id="77ce19117cbf62e9aa83a0e9daa5eda964f91d46" translate="yes" xml:space="preserve">
          <source>Some of the locations identifiers can be declared:</source>
          <target state="translated">可以申报一些位置标识符。</target>
        </trans-unit>
        <trans-unit id="6c1737e3aa3de31e28974c1c8d07d17beab8ca24" translate="yes" xml:space="preserve">
          <source>Some of the ways identifiers can be declared:</source>
          <target state="translated">识别器的一些声明方式。</target>
        </trans-unit>
        <trans-unit id="de99e0fa995db074a346a8fd3d2e19d830b3b47e" translate="yes" xml:space="preserve">
          <source>TLDR</source>
          <target state="translated">TLDR</target>
        </trans-unit>
        <trans-unit id="eb94aded85eb85135c48677af15bf3ac1f75c26f" translate="yes" xml:space="preserve">
          <source>That's almost all you need to know in terms of JavaScript scoping, except:</source>
          <target state="translated">这几乎是你需要知道的关于JavaScript范围的所有内容,除了。</target>
        </trans-unit>
        <trans-unit id="20ea4c65a85f13a0f7d5880b871c092105665952" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/&quot;&gt;&lt;strong&gt;most recent JavaScript specs&lt;/strong&gt;&lt;/a&gt; now also allow a third scope :</source>
          <target state="translated">现在， &lt;a href=&quot;https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/&quot;&gt;&lt;strong&gt;最新的JavaScript规范&lt;/strong&gt;&lt;/a&gt;还提供了第三个范围：</target>
        </trans-unit>
        <trans-unit id="551aa169f58fce36618019678db10f4c0b8c35c3" translate="yes" xml:space="preserve">
          <source>The Below Class has a Global scope variable &lt;code&gt;carName&lt;/code&gt;. And this variable is accessible from everywhere in the class.</source>
          <target state="translated">以下类具有全局范围变量 &lt;code&gt;carName&lt;/code&gt; 。 而且该变量可从类中的任何地方访问。</target>
        </trans-unit>
        <trans-unit id="6f2e6a008008ebd7c8f8b0790fa024387f5103ae" translate="yes" xml:space="preserve">
          <source>The Below function has a local scope variable &lt;code&gt;carName&lt;/code&gt;. And this variable is not accessible from outside of the function.</source>
          <target state="translated">以下函数具有局部范围的变量 &lt;code&gt;carName&lt;/code&gt; 。 而且该变量不能从函数外部访问。</target>
        </trans-unit>
        <trans-unit id="1c6297960ee1326cc0b6ece03b632419c8697d63" translate="yes" xml:space="preserve">
          <source>The biggest difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; is that &lt;code&gt;var&lt;/code&gt; is function scoped whereas &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; are block scoped. Here is an example to illustrate this:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 之间的最大区别是 &lt;code&gt;var&lt;/code&gt; 是函数范围的，而 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 是块范围的。 这是说明此的示例：</target>
        </trans-unit>
        <trans-unit id="dcadd2f97f65d20e36f2d943423cf05c3a58f7a2" translate="yes" xml:space="preserve">
          <source>The building represents our program&amp;rsquo;s nested scope ruleset. The first
  floor of the building represents your currently executing scope,
  wherever you are. The top level of the building is the global scope.
  You resolve LHS and RHS references by looking on your current floor,
  and if you don&amp;rsquo;t find it, taking the elevator to the next floor,
  looking there, then the next, and so on. Once you get to the top floor
  (the global scope), you either find what you&amp;rsquo;re looking for, or you
  don&amp;rsquo;t. But you have to stop regardless.</source>
          <target state="translated">该建筑物表示我们程序的嵌套范围规则集。 无论您身在何处，建筑物的第一层都代表您当前正在执行的范围。 该建筑的顶层是全球范围。 您可以通过查看当前楼层来解析LHS和RHS参考，如果找不到，则将电梯带到下一层，在那儿查看，然后在下一层，依此类推。 一旦到达顶层（全局范围），您就可以找到所需的内容，也可以不找到所需的内容。 但是无论如何你都必须停下来。</target>
        </trans-unit>
        <trans-unit id="cdc0afcc10d38d1828b1ade5ac3c30395d6075f9" translate="yes" xml:space="preserve">
          <source>The following prints &lt;code&gt;5&lt;/code&gt;, five times, and then prints &lt;code&gt;5&lt;/code&gt; for an sixth time for the &lt;code&gt;console.log&lt;/code&gt; outside the loop:</source>
          <target state="translated">以下内容将循环打印 &lt;code&gt;5&lt;/code&gt; 次，五次，然后在循环外为 &lt;code&gt;console.log&lt;/code&gt; 打印第六次5 。</target>
        </trans-unit>
        <trans-unit id="f640071ac23c5f0d26b8e3ca4e3b7d965b5b7397" translate="yes" xml:space="preserve">
          <source>The following prints &lt;code&gt;undefined&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is block-scoped. The callbacks are run one by one asynchronously. New behavior for &lt;code&gt;let&lt;/code&gt; variables means that each anonymous function closed over a different variable named &lt;code&gt;x&lt;/code&gt; (unlike it would have done with &lt;code&gt;var&lt;/code&gt;), and so integers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt; are printed.:</source>
          <target state="translated">由于 &lt;code&gt;x&lt;/code&gt; 是块作用域，因此以下打印 &lt;code&gt;undefined&lt;/code&gt; 。 回调是异步进行的。 &lt;code&gt;let&lt;/code&gt; 变量的新行为意味着每个匿名函数都关闭一个名为 &lt;code&gt;x&lt;/code&gt; 的变量（与 &lt;code&gt;var&lt;/code&gt; 不同 ），因此将输出 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;4&lt;/code&gt; 的整数。</target>
        </trans-unit>
        <trans-unit id="07a69d238d156e701c5a367c6a5485165dd070e3" translate="yes" xml:space="preserve">
          <source>The following will NOT throw a &lt;code&gt;ReferenceError&lt;/code&gt; because the visibility of &lt;code&gt;x&lt;/code&gt; is not constrained by the block; it will, however, print &lt;code&gt;undefined&lt;/code&gt; because the variable has not been initialised (because of the &lt;code&gt;if&lt;/code&gt; statement).</source>
          <target state="translated">以下内容将不会引发 &lt;code&gt;ReferenceError&lt;/code&gt; ,因为 &lt;code&gt;x&lt;/code&gt; 的可见性不受该块的限制； 但是，由于变量尚未初始化（由于 &lt;code&gt;if&lt;/code&gt; 语句），它将打印 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05ba3ae9dd9b32ddf42ae7069862c90654d442fa" translate="yes" xml:space="preserve">
          <source>The following will declare a property on the global object, because variables declared using &lt;code&gt;var&lt;/code&gt; within the global context, are added as properties to the global object:</source>
          <target state="translated">以下将在全局对象上声明属性，因为在全局上下文中使用 &lt;code&gt;var&lt;/code&gt; 声明的变量将作为属性添加到全局对象：</target>
        </trans-unit>
        <trans-unit id="56e352b3854a340ef82e660d524c84e0929a85f3" translate="yes" xml:space="preserve">
          <source>The following will throw a &lt;code&gt;ReferenceError&lt;/code&gt; because the visibility of &lt;code&gt;x&lt;/code&gt; is constrained by the block:</source>
          <target state="translated">以下内容将引发 &lt;code&gt;ReferenceError&lt;/code&gt; ,因为 &lt;code&gt;x&lt;/code&gt; 的可见性受块限制：</target>
        </trans-unit>
        <trans-unit id="916178c1871c4ad706738ee8325f52860cf80126" translate="yes" xml:space="preserve">
          <source>The following will throw a ReferenceError because the names&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; have no meaning outside of the function &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">以下内容将引发ReferenceError，因为名称 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 在函数 &lt;code&gt;f&lt;/code&gt; 之外没有任何意义。</target>
        </trans-unit>
        <trans-unit id="c15f36c25910e782b2fb893c1b27cfa365282f76" translate="yes" xml:space="preserve">
          <source>The following will throw a ReferenceError for &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;, but not for &lt;code&gt;x&lt;/code&gt;, because the visibility of &lt;code&gt;x&lt;/code&gt; is not constrained by the block. Blocks that define the bodies of control structures like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;, behave similarly.</source>
          <target state="translated">以下内容将为 &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 抛出ReferenceError，但不会为 &lt;code&gt;x&lt;/code&gt; 抛出ReferenceError，因为x的可见性不受该块的限制。 定义控制结构主体（如 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; 和 &lt;code&gt;while&lt;/code&gt; ）的块的行为类似。</target>
        </trans-unit>
        <trans-unit id="35ea475fa01e3a75809f9d5a47ee4846fc35e629" translate="yes" xml:space="preserve">
          <source>The four scopes are:</source>
          <target state="translated">这四个范围是:</target>
        </trans-unit>
        <trans-unit id="667c33893d889bc80fd5ed9df2f266c2588c1bb5" translate="yes" xml:space="preserve">
          <source>The idea of scoping in JavaScript when originally designed by &lt;a href=&quot;https://en.wikipedia.org/wiki/Brendan_Eich&quot;&gt;Brendan Eich&lt;/a&gt; came from the &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperCard&quot;&gt;HyperCard&lt;/a&gt; scripting language &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperTalk&quot;&gt;HyperTalk&lt;/a&gt;.</source>
          <target state="translated">最初由&lt;a href=&quot;https://en.wikipedia.org/wiki/Brendan_Eich&quot;&gt;Brendan Eich&lt;/a&gt;设计的JavaScript范围定义思想来自&lt;a href=&quot;https://en.wikipedia.org/wiki/HyperCard&quot;&gt;HyperCard&lt;/a&gt;脚本语言&lt;a href=&quot;https://en.wikipedia.org/wiki/HyperTalk&quot;&gt;HyperTalk&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f6410942035541f508ed90e604fa26f865ffb4a" translate="yes" xml:space="preserve">
          <source>The key, as I understand it, is that Javascript has function level scoping vs the more common C block scoping.</source>
          <target state="translated">根据我的理解,关键是Javascript具有函数级的覆盖范围,而不是更常见的C块覆盖范围。</target>
        </trans-unit>
        <trans-unit id="baa8f0251c2ad4e18b3c034ad72ce894cbff4fc8" translate="yes" xml:space="preserve">
          <source>The same concepts of lexically scope and scopechain still apply in &lt;code&gt;ES6&lt;/code&gt;. However a new ways to declare variables were introduced. There are the following:</source>
          <target state="translated">词汇范围和范围链的相同概念仍适用于 &lt;code&gt;ES6&lt;/code&gt; 。 但是，引入了一种声明变量的新方法。 有以下几种：</target>
        </trans-unit>
        <trans-unit id="1facbc7c1c1f813cff549c1dd5c9ee65e8b26f21" translate="yes" xml:space="preserve">
          <source>The scope of the variables that an &lt;code&gt;on*&lt;/code&gt; attribute can reference &lt;em&gt;must&lt;/em&gt; be either:</source>
          <target state="translated">&lt;code&gt;on*&lt;/code&gt; 属性可以引用的变量的范围&lt;em&gt;必须&lt;/em&gt;为：</target>
        </trans-unit>
        <trans-unit id="a525d3c4347396db376dab57fb2b417bb3d3c520" translate="yes" xml:space="preserve">
          <source>The this binding will point to the containing object. Sometimes scopes or execution contexts change without the containing object changing, such as in a declared function where the containing object may be &lt;code&gt;window&lt;/code&gt; or a constructor function.</source>
          <target state="translated">此绑定将指向包含的对象。 有时范围或执行上下文会在不更改包含对象的情况下发生变化，例如在声明的函数中，包含对象可能是 &lt;code&gt;window&lt;/code&gt; 或构造函数。</target>
        </trans-unit>
        <trans-unit id="2d36f4ed020b3d4b8edb17fc4c526b8cb4fb6d80" translate="yes" xml:space="preserve">
          <source>The top level of an ES6 module is similar to that of the inside of an IIFE on the top level in a normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;. The module can reference any variables which are global, and nothing can reference anything inside the module unless the module is explicitly designed for it.</source>
          <target state="translated">ES6模块的顶层与普通 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 中顶层IIFE的内部相似。 该模块可以引用任何全局变量，除非该模块是专门为其设计的，否则任何模块都不能引用该模块中的任何内容。</target>
        </trans-unit>
        <trans-unit id="7125f4b24be7f56c5a5737818cdbed770efa08f5" translate="yes" xml:space="preserve">
          <source>The top of a control structure (eg. loop, if, while etc)</source>
          <target state="translated">控制结构的顶部(如循环、如果、同时等)。</target>
        </trans-unit>
        <trans-unit id="ec84a003493d5f7ad27772f7fadcf69a38c15e22" translate="yes" xml:space="preserve">
          <source>The top of the stack takes precedence (the bottom being the global context)</source>
          <target state="translated">栈的顶部优先(底部为全局上下文)。</target>
        </trans-unit>
        <trans-unit id="e5147662f95f20c6a0a89a3a7abbdb020dd6c0a5" translate="yes" xml:space="preserve">
          <source>There are ALMOST only two types of JavaScript scopes:</source>
          <target state="translated">几乎只有两种类型的JavaScript作用域。</target>
        </trans-unit>
        <trans-unit id="eb06dfbee4e2593fde4a86d0b540f447341e7d7e" translate="yes" xml:space="preserve">
          <source>There are only function scopes in JS. Not block scopes!
You can see what is hoisting too.</source>
          <target state="translated">JS中只有功能scope,只有功能scope。而不是块的作用域! 你也可以看到葫芦里的东西。</target>
        </trans-unit>
        <trans-unit id="06ad5b6a8156a5d1e0ba464b34addb7c1635409b" translate="yes" xml:space="preserve">
          <source>There are three pertinent factors in deciding the &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_(computer_science)&quot;&gt;scope&lt;/a&gt; of an &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords&quot;&gt;identifier&lt;/a&gt; in JavaScript:</source>
          <target state="translated">&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords&quot;&gt;确定&lt;/a&gt; JavaScript中标识符 &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_(computer_science)&quot;&gt;范围&lt;/a&gt;的三个相关因素：</target>
        </trans-unit>
        <trans-unit id="9f972bb206c8387750ed69130eeb77040dd103a2" translate="yes" xml:space="preserve">
          <source>There are two types of scopes in JavaScript.</source>
          <target state="translated">JavaScript中的作用域有两种类型。</target>
        </trans-unit>
        <trans-unit id="e1a1af2ae159fa99a59c517a33be2803648d6f2f" translate="yes" xml:space="preserve">
          <source>These are some browsers that don't support &lt;code&gt;let&lt;/code&gt; at all :</source>
          <target state="translated">以下是一些根本不支持 &lt;code&gt;let&lt;/code&gt; 的浏览器：</target>
        </trans-unit>
        <trans-unit id="4157cf90189663de2f2e49ae60f774e33bc5176b" translate="yes" xml:space="preserve">
          <source>These execution contexts are created any time control is transferred. Control is transferred when code begins to execute, and this is primarily done from function execution.</source>
          <target state="translated">这些执行上下文是在控制权转移时创建的。当代码开始执行时,控制权就会被转移,这主要是从函数执行开始的。</target>
        </trans-unit>
        <trans-unit id="fcd7046418deb6ee5f24a080449c0d25ed0ec8aa" translate="yes" xml:space="preserve">
          <source>These linked lexical environments form a scope &quot;chain&quot;. Identifier resolution is the process of searching along this chain for a matching identifier.</source>
          <target state="translated">这些相连的词库环境形成了一个范围 &quot;链&quot;。识别符解析是沿着这个链子寻找匹配的识别符的过程。</target>
        </trans-unit>
        <trans-unit id="523f7d75f219807a90812d1a03a76d634bd34fc6" translate="yes" xml:space="preserve">
          <source>This idea of &quot;scope levels&quot; explains why &quot;this&quot; can be changed with a newly created scope, if it's being looked up in a nested function.
Here is a link that goes into all these details, &lt;a href=&quot;https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/&quot;&gt;Everything you wanted to know about javascript scope&lt;/a&gt;</source>
          <target state="translated">&amp;ldquo;作用域级别&amp;rdquo;的概念解释了为什么如果在嵌套函数中查找&amp;ldquo; this&amp;rdquo;可以用新创建的作用域进行更改。 这是进入所有这些详细信息的链接， &lt;a href=&quot;https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/&quot;&gt;您想了解有关javascript范围的一切&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88c46fe2afcb6c5ec1d4bbaa556544f6c35d6851" translate="yes" xml:space="preserve">
          <source>This is exactly how the JavaScript scoping system is designed. It just has different names. The cards in JavaScript are known as &lt;strong&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;Execution Contexts&lt;sup&gt;ECMA&lt;/sup&gt;&lt;/a&gt;&lt;/strong&gt;. Each one of these contexts contains three main parts. A variable environment, a lexical environment, and a this binding. Going back to the cards reference, the lexical environment contains all of the content from prior cards lower in the stack. The current context is at the top of the stack and any content declared there will be stored in the variable environment. The variable environment will take precedence in the case of naming collisions.</source>
          <target state="translated">这正是JavaScript作用域定义系统的设计方式。 它只是具有不同的名称。 JavaScript中的卡称为&lt;strong&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;执行上下文&lt;sup&gt;ECMA&lt;/sup&gt;&lt;/a&gt;&lt;/strong&gt; 。 这些上下文中的每一个都包含三个主要部分。 可变环境，词法环境和this绑定。 回到卡片参考，词法环境包含堆栈中较低位置的先前卡片的所有内容。 当前上下文位于堆栈的顶部，声明的所有内容都将存储在变量环境中。 在命名冲突的情况下，可变环境将优先。</target>
        </trans-unit>
        <trans-unit id="f86bca7d7675134768be73474570815258963447" translate="yes" xml:space="preserve">
          <source>This may seem counter intuitive, but it makes sense from the perspective of a imperative language designer.</source>
          <target state="translated">这似乎是反直觉的,但从命令式语言设计者的角度来看,是有道理的。</target>
        </trans-unit>
        <trans-unit id="9569372657d997762301d2a05e690ebc258d5cc1" translate="yes" xml:space="preserve">
          <source>Thus, in JavaScript, scope is implemented via lexical environments linked together in a &quot;chain&quot; by outer references. This chain of lexical environments is called the scope chain, and identifier resolution occurs by &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference&quot;&gt;searching up the chain&lt;/a&gt; for a matching identifier.</source>
          <target state="translated">因此，在JavaScript中，作用域是通过外部引用在&amp;ldquo;链&amp;rdquo;中链接在一起的词法环境实现的。 这种词汇环境链称为作用域链，并且通过&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference&quot;&gt;在链中搜索&lt;/a&gt;匹配的标识符来进行标识符解析。</target>
        </trans-unit>
        <trans-unit id="bb6c7e872133e98aeb218ad6ea9c62cee6491672" translate="yes" xml:space="preserve">
          <source>To understand the difference between functional scope and block scope, consider the following code :</source>
          <target state="translated">为了理解功能范围和块范围的区别,请考虑以下代码。</target>
        </trans-unit>
        <trans-unit id="0163360cc80ec2993c1c8f16533f6de416e326dd" translate="yes" xml:space="preserve">
          <source>Traditionally, JavaScript really only has two types of scope :</source>
          <target state="translated">传统上,JavaScript真的只有两种类型的作用域。</target>
        </trans-unit>
        <trans-unit id="87b058d74fbe7f22fbb0efb4d9425bc6faa878b9" translate="yes" xml:space="preserve">
          <source>Traditionally, you create your variables like this :</source>
          <target state="translated">传统上,你可以像这样创建你的变量。</target>
        </trans-unit>
        <trans-unit id="ad29238d291882475644003da99e61f8bc49a03b" translate="yes" xml:space="preserve">
          <source>Try the feature at:</source>
          <target state="translated">试试这个功能在。</target>
        </trans-unit>
        <trans-unit id="2c33461d5cae3061ba752f33725ddcdee0745df3" translate="yes" xml:space="preserve">
          <source>Try this curious example. In the example below if a were a numeric initialized at 0, you'd see 0 and then 1. Except a is an object and javascript will pass f1 a pointer of a rather than a copy of it. The result is that you get the same alert both times.</source>
          <target state="translated">试试这个奇怪的例子。在下面的例子中,如果a是一个初始化为0的数字,你会看到0,然后是1,但是a是一个对象,而javascript会传递给f1一个指针,而不是它的副本。结果就是两次都会得到同样的警报。</target>
        </trans-unit>
        <trans-unit id="9a31c380e5d5713a5b5f2cac2a38ce95810e231c" translate="yes" xml:space="preserve">
          <source>Using functions instead:</source>
          <target state="translated">用函数代替。</target>
        </trans-unit>
        <trans-unit id="09e07e786d7ad2ec030bf960813f71d135a77b77" translate="yes" xml:space="preserve">
          <source>Variables declared globally have a global scope. Variables declared within a function are scoped to that function, and shadow global variables of the same name.</source>
          <target state="translated">全局声明的变量有一个全局范围。在一个函数中声明的变量是在该函数中的范围内,同名的全局变量也是影子变量。</target>
        </trans-unit>
        <trans-unit id="83f6135eb31f7889cc2bae9bf00eaae24a2268d7" translate="yes" xml:space="preserve">
          <source>Variables declared using &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; are all scoped to modules:</source>
          <target state="translated">使用 &lt;code&gt;var&lt;/code&gt; ， &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;const&lt;/code&gt; 声明的变量都作用于模块：</target>
        </trans-unit>
        <trans-unit id="e63da6c1c1854a483ec37bd48437243581e43830" translate="yes" xml:space="preserve">
          <source>Variables in Javascript were initially (pre &lt;code&gt;ES6&lt;/code&gt;) lexically function scoped. The term lexically scoped means that you can see the scope of the variables by 'looking' at the code.</source>
          <target state="translated">Javascript中的变量最初（在 &lt;code&gt;ES6&lt;/code&gt; 之前 ）在词法函数范围内。 词法范围的术语意味着您可以通过&amp;ldquo;查看&amp;rdquo;代码来查看变量的范围。</target>
        </trans-unit>
        <trans-unit id="79b5a1ec62a5c78bf7572a8c6548c2e713ed3a8a" translate="yes" xml:space="preserve">
          <source>View the code at:</source>
          <target state="translated">查看代码在。</target>
        </trans-unit>
        <trans-unit id="d113eb702e389cf7c505ecfecd3bb29698f276f3" translate="yes" xml:space="preserve">
          <source>We try to log bar to the console, bar cannot be found inside the function &lt;code&gt;innerFunc&lt;/code&gt; itself. Therefore, we need to &lt;strong&gt;climb the scope chain&lt;/strong&gt;. We first look in the outer function in which the function &lt;code&gt;innerFunc&lt;/code&gt; was defined. This is the function &lt;code&gt;outerFunc&lt;/code&gt;. In the scope of &lt;code&gt;outerFunc&lt;/code&gt; we can find the variable bar, which holds the string 'outerFunc'.</source>
          <target state="translated">我们尝试将bar登录到控制台，在功能 &lt;code&gt;innerFunc&lt;/code&gt; 本身内部找不到bar 。 因此，我们需要&lt;strong&gt;攀登范围链&lt;/strong&gt; 。 我们首先来看定义函数 &lt;code&gt;innerFunc&lt;/code&gt; 的外部函数。 这是函数 &lt;code&gt;outerFunc&lt;/code&gt; 。 在 &lt;code&gt;outerFunc&lt;/code&gt; 的范围内，我们可以找到变量栏，该栏包含字符串&amp;ldquo; outerFunc&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="33483a29e47769decbe475c651c75e62bcc26c1d" translate="yes" xml:space="preserve">
          <source>We try to log foo to the console, foo can be found inside the function &lt;code&gt;innerFunc&lt;/code&gt; itself. Therefore, the value of foo is resolved to the string &lt;code&gt;innerFunc&lt;/code&gt;.</source>
          <target state="translated">我们尝试将foo登录到控制台，可以在函数 &lt;code&gt;innerFunc&lt;/code&gt; 本身内找到foo。 因此，foo的值将解析为字符串 &lt;code&gt;innerFunc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f557bb3c7aec4df772e0ff73b2192b0c2d60c84e" translate="yes" xml:space="preserve">
          <source>What happens when we are trying to log the variables &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;foobar&lt;/code&gt; to the console is the following:</source>
          <target state="translated">当我们尝试将变量 &lt;code&gt;foo&lt;/code&gt; ， &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;foobar&lt;/code&gt; 到控制台时，将发生以下情况：</target>
        </trans-unit>
        <trans-unit id="9b903fe3f970849861b225b53f498c1947e65555" translate="yes" xml:space="preserve">
          <source>What is the scope of variables in JavaScript</source>
          <target state="translated">JavaScript中的变量的范围是什么</target>
        </trans-unit>
        <trans-unit id="c23272951273b7fc083d376b564db88d3610470d" translate="yes" xml:space="preserve">
          <source>What is the scope of variables in javascript? Do they have the same scope inside as opposed to outside a function? Or does it even matter? Also, where are the variables stored if they are defined globally?</source>
          <target state="translated">javascript中变量的作用域是什么?它们在函数内部的作用域和在函数外部的作用域是一样的吗?或者说这有什么关系吗?另外,如果变量是全局定义的,那么变量存储在哪里?</target>
        </trans-unit>
        <trans-unit id="8bd7003d51c50f3c8761d33449fe913c8f8cac5b" translate="yes" xml:space="preserve">
          <source>When a function look to resolve a variable value it first looks at its own scope. This is the function body, i.e. everything between curly brackets {} (except for variables inside &lt;strong&gt;other&lt;/strong&gt;&lt;strong&gt;functions&lt;/strong&gt; which are in this scope).</source>
          <target state="translated">当一个函数要解析一个变量值时，它首先要看其自身的作用域。 这是函数主体，即大括号{}之间的所有内容（此&lt;strong&gt;函数&lt;/strong&gt;范围内&lt;strong&gt;其他&lt;/strong&gt; &lt;strong&gt;函数&lt;/strong&gt;内部的变量除外）。</target>
        </trans-unit>
        <trans-unit id="7b320f88c37b5d9ddd50505ed7068dbeb83bd406" translate="yes" xml:space="preserve">
          <source>When resolving a variable, javascript starts at the innermost scope and searches outwards.</source>
          <target state="translated">当解析一个变量时,javascript从最内侧的作用域开始,向外搜索。</target>
        </trans-unit>
        <trans-unit id="d7cb4beab01b349af01d024bbaf1102dfb872104" translate="yes" xml:space="preserve">
          <source>When you invoke a function, the hidden &lt;code&gt;[[Call]]&lt;/code&gt; method is called. This method creates a new execution context and establishes a link between the new execution context and the lexical environment of the function-object. It does this by copying the &lt;code&gt;[[Environment]]&lt;/code&gt; value on the function-object, into an &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;outer reference&lt;/a&gt; field on the lexical environment of the new execution context.</source>
          <target state="translated">调用函数时，将调用隐藏的 &lt;code&gt;[[Call]]&lt;/code&gt; 方法。 此方法创建一个新的执行上下文，并在新的执行上下文和功能对象的词法环境之间建立链接。 通过将功能对象上的 &lt;code&gt;[[Environment]]&lt;/code&gt; 值复制到新执行上下文的词法环境上的&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;外部引用&lt;/a&gt;字段中，可以完成此操作。</target>
        </trans-unit>
        <trans-unit id="c96ef28eb7eabf77773b3a19be2f5414a421175a" translate="yes" xml:space="preserve">
          <source>Where an identifier was declared</source>
          <target state="translated">已申报的标识符</target>
        </trans-unit>
        <trans-unit id="db4779584d083e695bd0cf37cd44aa1429a309bc" translate="yes" xml:space="preserve">
          <source>Whether or not it is safe to use today, depends on your environment :</source>
          <target state="translated">现在使用是否安全,要看你所处的环境。</target>
        </trans-unit>
        <trans-unit id="98f46dd1a1ed53e1e44f3ab136ef987e105853e9" translate="yes" xml:space="preserve">
          <source>Whether you are in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;strict mode&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode&quot;&gt;non-strict mode&lt;/a&gt;</source>
          <target state="translated">处于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;严格模式&lt;/a&gt;还是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode&quot;&gt;非严格模式&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="866faa243c8cb14d4f4502051230db635e4581a1" translate="yes" xml:space="preserve">
          <source>Window level - &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;outer&lt;/code&gt; function are at top level in scope chain.</source>
          <target state="translated">窗口级别-a和 &lt;code&gt;outer&lt;/code&gt; 函数在范围链中处于顶层。</target>
        </trans-unit>
        <trans-unit id="61285999208212a66bb8fb8f69cb29c51fc58afb" translate="yes" xml:space="preserve">
          <source>Yikes!  Be careful using 'with' -- just like var is a noop if the variable is already defined in the function, it is also a noop with respect to names imported from the object!  A little heads up on the name already being defined would make this much safer.  I personally will never use with because of this.</source>
          <target state="translated">呀! 要小心使用'with'----就像var在函数中已经定义了变量是一个noop一样,对于从对象中导入的名字也是一个noop! 如果在已经定义好的名称上提个醒,那就更安全了。我个人永远不会因为这一点而使用with。</target>
        </trans-unit>
        <trans-unit id="653677cec5274421cb19c2c9eb0bf04f82dca290" translate="yes" xml:space="preserve">
          <source>You should be using block scoping for every variable you create, just like most other major languages. &lt;code&gt;var&lt;/code&gt; is &lt;em&gt;obsolete&lt;/em&gt;. This makes your code safer and more maintainable.</source>
          <target state="translated">就像大多数其他主要语言一样，您应该对创建的每个变量使用块作用域。 &lt;code&gt;var&lt;/code&gt; 已&lt;em&gt;过时&lt;/em&gt; 。 这使您的代码更安全，更可维护。</target>
        </trans-unit>
        <trans-unit id="98d045c503931bcf6ef7f9b40c8422ec1ba5b590" translate="yes" xml:space="preserve">
          <source>You'll want to investigate closures, and how to use them to make &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;private members&lt;/a&gt;.</source>
          <target state="translated">您将要研究闭包，以及如何使用它们来成为&lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;私有成员&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b63f2d6c0c543f4dd14dae138ce110ce4819bafe" translate="yes" xml:space="preserve">
          <source>a property of the document (eg, &lt;code&gt;querySelector&lt;/code&gt; as a standalone variable will point to &lt;code&gt;document.querySelector&lt;/code&gt;; rare)</source>
          <target state="translated">文档的属性（例如， &lt;code&gt;querySelector&lt;/code&gt; 作为独立变量将指向 &lt;code&gt;document.querySelector&lt;/code&gt; ；很少见）</target>
        </trans-unit>
        <trans-unit id="fceff746a314cc08e9d118ad4bd96fa755c80556" translate="yes" xml:space="preserve">
          <source>a property of the element the handler is attached to (like above; rare)</source>
          <target state="translated">处理程序所连接的元素的一个属性(如上图所示;很少见</target>
        </trans-unit>
        <trans-unit id="822bc13e2d55b402eb4233cb23c9d414a7a03bc1" translate="yes" xml:space="preserve">
          <source>eval</source>
          <target state="translated">eval</target>
        </trans-unit>
        <trans-unit id="48a783d527b12bb1b6d12822df507e3056d403cb" translate="yes" xml:space="preserve">
          <source>foobar cannot be found in innerFunc. . Therefore, we need to &lt;strong&gt;climb the scope chain&lt;/strong&gt; to the innerFunc scope. It also cannot be found here, we climb another level to the &lt;strong&gt;global scope&lt;/strong&gt; (i.e. the outermost scope). We find the variable foobar here which holds the string 'global'. If it wouldnot have found the variable after climbing the scope chain the JS engine would throw a &lt;strong&gt;referenceError&lt;/strong&gt;.</source>
          <target state="translated">在innerFunc中找不到foobar。 。 因此，我们需要&lt;strong&gt;将范围链爬到&lt;/strong&gt; innerFunc范围。 在这里也找不到它，我们将&lt;strong&gt;范围&lt;/strong&gt;扩展到了&lt;strong&gt;全局范围&lt;/strong&gt; （即最外部的范围）。 我们在这里找到变量foobar，其中包含字符串&amp;ldquo; global&amp;rdquo;。 如果在爬取作用域链之后找不到变量，则JS引擎将抛出&lt;strong&gt;referenceError&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="887ec4e4d84f875ed30e16b3b555dc44c974324c" translate="yes" xml:space="preserve">
          <source>global (working inline handlers almost always reference global variables)</source>
          <target state="translated">全局(工作中的内联处理程序几乎总是引用全局变量</target>
        </trans-unit>
        <trans-unit id="7344f99b192214421819b3d6d5d5eb925e77386f" translate="yes" xml:space="preserve">
          <source>if there is no enclosing function for a var declaration, it is global scope</source>
          <target state="translated">如果var声明中没有包围函数,则为全局作用域</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="fb722bbe2d7de5616bde8841cec1f7151c36e813" translate="yes" xml:space="preserve">
          <source>let and const</source>
          <target state="translated">沰和</target>
        </trans-unit>
        <trans-unit id="ff9c22082a2b010df2415de1fe69a90317ccdf1c" translate="yes" xml:space="preserve">
          <source>multiple var declarations within the same scope are combined</source>
          <target state="translated">同一作用域内的多个var声明被合并</target>
        </trans-unit>
        <trans-unit id="222f16742f8432d094b140df773f638f634a3fe5" translate="yes" xml:space="preserve">
          <source>run the code. hope this will give an idea about scoping</source>
          <target state="translated">运行代码,希望这能给你一个关于范围化的想法。</target>
        </trans-unit>
        <trans-unit id="e50c3161b714f4fa46bad3943d0cfb3418bf98a5" translate="yes" xml:space="preserve">
          <source>test1 is scoped to the with block, but is aliased to a.test1.  'Var test1' creates a new variable test1 in the upper lexical context (function, or global), unless it is a property of a -- which it is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5e5564e501683f6afb89ae0a4affd1e86cdeb1" translate="yes" xml:space="preserve">
          <source>the scope of each var declaration is associated with the most immediately enclosing function</source>
          <target state="translated">每一个var声明的范围都与紧邻的函数相关联。</target>
        </trans-unit>
        <trans-unit id="a4ebaeeee765207f3a08fde4e0bf36e28958ad9a" translate="yes" xml:space="preserve">
          <source>try/catch introduce new scope ONLY for the exception variable itself, other variables do not have new scope</source>
          <target state="translated">trycatch只为异常变量本身引入新的作用域,其他变量没有新的作用域。</target>
        </trans-unit>
        <trans-unit id="e5b4e786e382d03c28e9edfab2d8149378ae69df" translate="yes" xml:space="preserve">
          <source>var</source>
          <target state="translated">var</target>
        </trans-unit>
        <trans-unit id="7357ecfa390afc2fce34c3167335bf743c442659" translate="yes" xml:space="preserve">
          <source>var declarations are hoisted to the top of the scope. This means no matter where the var declaration happens, to the compiler it is as if the var itself happens at the top</source>
          <target state="translated">var声明被提升到作用域的顶部。这意味着无论var声明发生在哪里,对编译器来说,就像var本身发生在顶部一样。</target>
        </trans-unit>
        <trans-unit id="80e40e219ee78a38babf8cce499fd3cb0f6182af" translate="yes" xml:space="preserve">
          <source>when outer function called a new &lt;code&gt;variable scope object&lt;/code&gt;(and included in scope chain) added with variable &lt;code&gt;b&lt;/code&gt; inside it.</source>
          <target state="translated">当外部函数调用一个新的 &lt;code&gt;variable scope object&lt;/code&gt; （并包含在作用域链中）并在其中添加了变量 &lt;code&gt;b&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="5b3cb00aa7dfc23400daf50a18606b8161567f7b" translate="yes" xml:space="preserve">
          <source>with-clause apparently is another exception, but using with-clause it highly discouraged (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&lt;/a&gt;)</source>
          <target state="translated">显然，with-clause是另一个例外，但是强烈反对使用with-clause（ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&lt;/a&gt; ）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
