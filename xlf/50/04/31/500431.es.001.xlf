<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/500431">
    <body>
      <group id="500431">
        <trans-unit id="b2b80089f01682b9f7777a6969b9faaa80407f05" translate="yes" xml:space="preserve">
          <source>(I'm sure there are many subtleties that real JavaScript programmers will be able to point out in other answers. In particular I came across &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;this page&lt;/a&gt; about what exactly &lt;code&gt;this&lt;/code&gt; means at any time. Hopefully &lt;a href=&quot;http://bowles.byethost3.com/javascript/section6/lesson6.htm#part4&quot;&gt;this more introductory link&lt;/a&gt; is enough to get you started though.)</source>
          <target state="translated">(Estoy seguro de que hay muchas sutilezas que los programadores reales de JavaScript podr&amp;aacute;n se&amp;ntilde;alar en otras respuestas. En particular, me encontr&amp;eacute; con &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;esta p&amp;aacute;gina&lt;/a&gt; sobre lo que &lt;code&gt;this&lt;/code&gt; significa exactamente en cualquier momento. Espero que &lt;a href=&quot;http://bowles.byethost3.com/javascript/section6/lesson6.htm#part4&quot;&gt;este enlace m&amp;aacute;s introductorio&lt;/a&gt; sea ​​suficiente para comenzar) aunque.)</target>
        </trans-unit>
        <trans-unit id="2b079c997f6e9e9f11e2b8533c11a4cdefaf6c17" translate="yes" xml:space="preserve">
          <source>...because of this behavior you need to be careful about closing over variables declared using &lt;code&gt;var&lt;/code&gt; in loops. There is only one instance of variable &lt;code&gt;x&lt;/code&gt; declared here, and it sits logically outside of the loop.</source>
          <target state="translated">... debido a este comportamiento, debe tener cuidado al cerrar las variables declaradas utilizando &lt;code&gt;var&lt;/code&gt; en bucles. Aqu&amp;iacute; solo se declara una instancia de la variable &lt;code&gt;x&lt;/code&gt; , y se ubica l&amp;oacute;gicamente fuera del bucle.</target>
        </trans-unit>
        <trans-unit id="c2a9084e5d3eb2e4718aab6268e78f5823849081" translate="yes" xml:space="preserve">
          <source>1) There is a global scope, a function scope, and the with and catch scopes. There is no 'block' level scope in general for variable's -- the with and the catch statements add names to their blocks.</source>
          <target state="translated">1)Hay un ámbito global,un ámbito de funciones,y los ámbitos de con y de captura.No hay un ámbito de nivel de &quot;bloque&quot; en general para las variables...los enunciados de con y captura añaden nombres a sus bloques.</target>
        </trans-unit>
        <trans-unit id="a7c489f0a7142c687da2af2321ca060655d7e2f8" translate="yes" xml:space="preserve">
          <source>2) Scopes are nested by functions all the way to the global scope.</source>
          <target state="translated">2)Los alcances están anidados por funciones hasta el alcance global.</target>
        </trans-unit>
        <trans-unit id="d749b9c70cd3d6ec5a37f9e5c4bb7316601c2a74" translate="yes" xml:space="preserve">
          <source>3) Properties are resolved by going through the prototype chain.  The with statement brings object property names into the lexical scope defined by the with block.</source>
          <target state="translated">3)Las propiedades se resuelven atravesando la cadena de prototipos.La declaración con lleva los nombres de las propiedades de los objetos al ámbito léxico definido por el bloque con.</target>
        </trans-unit>
        <trans-unit id="08b17079c570142726687fb2c5c9bb253783c20e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES5&lt;/code&gt; and earlier:</source>
          <target state="translated">&lt;code&gt;ES5&lt;/code&gt; y anterior:</target>
        </trans-unit>
        <trans-unit id="2ac152d0029db3c7cd7c3a77df7bfef8ae5d4c57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES6&lt;/code&gt; (ES 2015) and older:</source>
          <target state="translated">&lt;code&gt;ES6&lt;/code&gt; (ES 2015) y anteriores:</target>
        </trans-unit>
        <trans-unit id="c4c1a80bcfde13b5ffe96bdafa9c43b74b195f4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; should be used for &lt;strong&gt;95% of cases&lt;/strong&gt;. It makes it so the variable &lt;em&gt;reference&lt;/em&gt; can't change. Array, object, and DOM node properties can change and should likely be &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; debe usarse para el &lt;strong&gt;95% de los casos&lt;/strong&gt; . Hace que la &lt;em&gt;referencia&lt;/em&gt; variable no pueda cambiar. Las propiedades de matriz, objeto y nodo DOM pueden cambiar y probablemente deber&amp;iacute;an ser &lt;code&gt;const&lt;/code&gt; antes .</target>
        </trans-unit>
        <trans-unit id="dcf0ad05684411d0af52e47d334a793a1d346e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;: creates a block scoped variable which has to be initialized and cannot be reassigned</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; : crea una variable de &amp;aacute;mbito de bloque que debe inicializarse y no puede reasignarse</target>
        </trans-unit>
        <trans-unit id="84d33e7ec01dc28120ceea7d7d07bb9ccda0bdcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; statements</source>
          <target state="translated">declaraciones de &lt;code&gt;import&lt;/code&gt; aci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="f378613076c429aa47b0bc460bdfb9fd805b2aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; in the global context do not add properties to the global object, but still have global scope:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; en el contexto global no agrega propiedades al objeto global, pero a&amp;uacute;n tiene un alcance global:</target>
        </trans-unit>
        <trans-unit id="23ddb5e06f75a482ff3a507bfea2c6482c39eb0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; should be be used for any variable expecting to be reassigned. This includes within a for loop. If you ever change value beyond initialization, use &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; debe usarse para cualquier variable que se espera reasignar. Esto incluye dentro de un bucle for. Si alguna vez cambia el valor m&amp;aacute;s all&amp;aacute; de la inicializaci&amp;oacute;n, use &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39836bea22536ebe1993a1b9a30ed5062e7fc910" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;: creates a block scoped variable</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; : crea una variable de &amp;aacute;mbito de bloque</target>
        </trans-unit>
        <trans-unit id="f86a4d006feac6327fadfafd72bedb4b3013db57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23a7586104558b94ef7294bd102a26a3fee7bc25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;hoisted&lt;/strong&gt;&lt;/a&gt;.&lt;/em&gt; This means that declarations are always much to the top of the scope.</source>
          <target state="translated">&lt;em&gt;(*) Las variables de &amp;aacute;mbito global y funcional pueden inicializarse y utilizarse antes de declararse porque las variables de JavaScript est&amp;aacute;n &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;izadas&lt;/strong&gt;&lt;/a&gt; .&lt;/em&gt; Esto significa que las declaraciones siempre est&amp;aacute;n en lo m&amp;aacute;s alto del alcance.</target>
        </trans-unit>
        <trans-unit id="f1f37e4dcff2ea462372b5383bfff8d1536133fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Whenever a function is called, a variable scope object is created (and included in scope chain) which is followed by variables in JavaScript.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Cada vez que se llama a una funci&amp;oacute;n, se crea un objeto de alcance variable (y se incluye en la cadena de alcance) seguido de variables en JavaScript.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b4f1e280e8a84dd1613867f45aea9b5a09b5e95c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;i&lt;/em&gt;) The outer context. It has a variable environment of a = 1</source>
          <target state="translated">&lt;em&gt;i&lt;/em&gt; ) El contexto externo. Tiene un entorno variable de a = 1</target>
        </trans-unit>
        <trans-unit id="27dcebcb7c447ec33f3b94ab4786b7e8986fc48a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ii&lt;/em&gt;) The IIFE context, it has a lexical environment of a = 1, but a variable environment of a = 6 which takes precedence in the stack</source>
          <target state="translated">&lt;em&gt;ii&lt;/em&gt; ) El contexto IIFE, tiene un entorno l&amp;eacute;xico de a = 1, pero un entorno variable de a = 6 que tiene prioridad en la pila</target>
        </trans-unit>
        <trans-unit id="f2d982053f1a3fa4551447f1adedd54422f021ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;iii&lt;/em&gt;) The returned function context, it has a lexical environment of a = 6 and that is the value referenced in the alert when called.</source>
          <target state="translated">&lt;em&gt;iii&lt;/em&gt; ) El contexto de la funci&amp;oacute;n devuelta, tiene un entorno l&amp;eacute;xico de a = 6 y ese es el valor referenciado en la alerta cuando se llama.</target>
        </trans-unit>
        <trans-unit id="f56505ee4c5ecc9846d96be13e7dc0c3c70dfa98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Android browser 4&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Navegador de Android 4&lt;/strong&gt; y menos</target>
        </trans-unit>
        <trans-unit id="55a8f93e956bc391290a79206606d9be4627b589" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Block Scope&lt;/strong&gt; : Identifiers are &quot;known&quot; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;from the top of the scope they are declared within&lt;/a&gt;, but they cannot be assigned to or dereferenced (read) until after the line of their declaration. This interim period is called the &quot;temporal dead zone.&quot;</source>
          <target state="translated">&lt;strong&gt;Alcance de bloque&lt;/strong&gt; : los identificadores se &quot;conocen&quot; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;desde la parte superior del alcance dentro del cual se declaran&lt;/a&gt; , pero no se pueden asignar ni desreferenciar (leer) hasta despu&amp;eacute;s de la l&amp;iacute;nea de su declaraci&amp;oacute;n. Este per&amp;iacute;odo intermedio se denomina &quot;zona muerta temporal&quot;.</target>
        </trans-unit>
        <trans-unit id="2f05c56877d8601614fa63855f086a2652e865c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Chome 40&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Chome 40&lt;/strong&gt; y menos</target>
        </trans-unit>
        <trans-unit id="d99cf4a17169c81d37ec13856f6710a2a76cbbad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Firefox 43&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Firefox 43&lt;/strong&gt; y menos</target>
        </trans-unit>
        <trans-unit id="08cd2fc5597977a2613daeb7f079fd9fa0eb16b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional Scope&lt;/strong&gt; : Variable declared within a function with &lt;code&gt;var&lt;/code&gt; keyword has functional scope.</source>
          <target state="translated">&lt;strong&gt;Alcance funcional&lt;/strong&gt; : la variable declarada dentro de una funci&amp;oacute;n con la palabra clave &lt;code&gt;var&lt;/code&gt; tiene alcance funcional.</target>
        </trans-unit>
        <trans-unit id="a13963dd31b44d28a808a5e2917cae4be7b837de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional Scope&lt;/strong&gt; : Variables are known within &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;the function&lt;/strong&gt;&lt;/a&gt; they are declared in, from the start of the function &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Alcance funcional&lt;/strong&gt; : las variables se conocen dentro de &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;la funci&amp;oacute;n en la&lt;/strong&gt;&lt;/a&gt; que se declaran, desde el inicio de la funci&amp;oacute;n &lt;em&gt;(*)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7298e7a71a2f69245853e050c4bdee749e978e9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional scope or Local scope&lt;/strong&gt;: variable declared in this scope can be used in its own function only. For example:</source>
          <target state="translated">&lt;strong&gt;&amp;Aacute;mbito funcional o &amp;aacute;mbito local&lt;/strong&gt; : la variable declarada en este &amp;aacute;mbito solo se puede utilizar en su propia funci&amp;oacute;n. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="89e21e149d0d0dc547601ca86291fe92f9273963" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Scope&lt;/strong&gt; : Global is nothing but a window level scope.Here, variable present throughout the application.</source>
          <target state="translated">&lt;strong&gt;Alcance global&lt;/strong&gt; : Global no es m&amp;aacute;s que un alcance a nivel de ventana. Aqu&amp;iacute;, variable presente en toda la aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f3a549a4e99a97eff2b34e0f09263cffa683cccd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Scope&lt;/strong&gt; : Variables are known throughout the application, from the start of the application &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Alcance global&lt;/strong&gt; : las variables son conocidas en toda la aplicaci&amp;oacute;n, desde el inicio de la aplicaci&amp;oacute;n &lt;em&gt;(*)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1f34e4a5bfcdc48aa26833768f67160bd571124" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global scope&lt;/strong&gt;: variable which is announced in global scope can be used anywhere in the program very smoothly. For example:</source>
          <target state="translated">&lt;strong&gt;Alcance global&lt;/strong&gt; : la variable que se anuncia en el alcance global se puede usar en cualquier parte del programa sin problemas. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="a7ca3efb97c36b6d88809b25331124fb1fffa069" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internet explorer 10&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Internet Explorer 10&lt;/strong&gt; y menos</target>
        </trans-unit>
        <trans-unit id="f68d935bfb76269d4c30258cf31d26f604040556" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opera 27&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Opera 27&lt;/strong&gt; y menos</target>
        </trans-unit>
        <trans-unit id="050f7cc7d0dc2635f8b52903f766a2c3db495862" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Safari 9&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Safari 9&lt;/strong&gt; y menos</target>
        </trans-unit>
        <trans-unit id="44e5d520bd9d0fb39f77e303b90adad358405de1" translate="yes" xml:space="preserve">
          <source>A lexical environment is a mapping between identifier names and the values associated with them.</source>
          <target state="translated">Un entorno léxico es un mapeo entre los nombres de los identificadores y los valores asociados a ellos.</target>
        </trans-unit>
        <trans-unit id="8fd51b0bd0e4f91009d0f3343c699212c3d96c96" translate="yes" xml:space="preserve">
          <source>A variable declared at the top of a &lt;code&gt;for&lt;/code&gt; loop using &lt;code&gt;let&lt;/code&gt; is scoped to the body of the loop:</source>
          <target state="translated">Una variable declarada en la parte superior de un bucle &lt;code&gt;for&lt;/code&gt; que usa &lt;code&gt;let&lt;/code&gt; tiene un alcance en el cuerpo del bucle:</target>
        </trans-unit>
        <trans-unit id="48faefee4b09b7b96e9ee196462af3f716e8b8de" translate="yes" xml:space="preserve">
          <source>A very common issue not described yet that front-end coders often run into is the scope that is visible to an inline event handler in the HTML - for example, with</source>
          <target state="translated">Una cuestión muy común que aún no se ha descrito y con la que se topan a menudo los codificadores del front-end es el alcance que es visible para un manejador de eventos en línea en el HTML-por ejemplo,con</target>
        </trans-unit>
        <trans-unit id="60fc03a08e44792e776e9738812c0a4cd623a464" translate="yes" xml:space="preserve">
          <source>ANY version of &lt;strong&gt;Opera Mini&lt;/strong&gt; &amp;amp; &lt;strong&gt;Blackberry Browser&lt;/strong&gt;</source>
          <target state="translated">CUALQUIER versi&amp;oacute;n de &lt;strong&gt;Opera Mini&lt;/strong&gt; y &lt;strong&gt;Blackberry Browser&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae46cf4abc73a3b9c1f4dfacc1b829774476ba1e" translate="yes" xml:space="preserve">
          <source>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</source>
          <target state="translated">Además,considere que las variables de ámbito de bloque no se conocen antes de ser declaradas porque no se izan.Tampoco se permite redeclarar la misma variable de ámbito de bloque dentro del mismo bloque.Esto hace que las variables de ámbito de bloque sean menos propensas a errores que las variables de ámbito global o funcional,que se elevan y que no producen ningún error en caso de declaraciones múltiples.</target>
        </trans-unit>
        <trans-unit id="cb95f617fd60bdb566772a3a947b9cf56a0e0ee3" translate="yes" xml:space="preserve">
          <source>An element in the scope chain is basically a Map with a pointer to its parent scope.</source>
          <target state="translated">Un elemento en la cadena del telescopio es básicamente un mapa con un puntero a su telescopio padre.</target>
        </trans-unit>
        <trans-unit id="2f14bc627ff3b593b8ed5e4441d9f45b15ddec5c" translate="yes" xml:space="preserve">
          <source>Applying this to one of the previous examples (5. &quot;Closure&quot;) on this page, it is possible to follow the stack of execution contexts. In this example there are three contexts in the stack. They are defined by the outer context, the context in the immediately invoked function called by var six, and the context in the returned function inside of var six's immediately invoked function.</source>
          <target state="translated">Aplicando esto a uno de los ejemplos anteriores (5.&quot;Cierre&quot;)de esta página,es posible seguir la pila de contextos de ejecución.En este ejemplo hay tres contextos en la pila.Están definidos por el contexto externo,el contexto en la función inmediatamente invocada llamada por var seis,y el contexto en la función devuelta dentro de la función inmediatamente invocada de var seis.</target>
        </trans-unit>
        <trans-unit id="425a5e8573ac9d1f6ad5077097cd879a85500359" translate="yes" xml:space="preserve">
          <source>Block - visible within a block (and its sub-blocks)</source>
          <target state="translated">Bloque-visible dentro de un bloque (y sus sub-bloques)</target>
        </trans-unit>
        <trans-unit id="b268d619791c64ad9a437793c6df4e96c3bea47e" translate="yes" xml:space="preserve">
          <source>Block scope means that the variable will only be available within the brackets in which it is declared. This extends to internal scopes, including anonymous functions created within your scope.</source>
          <target state="translated">El alcance del bloque significa que la variable sólo estará disponible dentro de los paréntesis en los que se declara.Esto se extiende a los alcances internos,incluyendo las funciones anónimas creadas dentro de su alcance.</target>
        </trans-unit>
        <trans-unit id="6ad05cf476194af6ae4eab02f3b9ae25d3fe726e" translate="yes" xml:space="preserve">
          <source>Block scope variables are created like this :</source>
          <target state="translated">Las variables de alcance de los bloques se crean así:</target>
        </trans-unit>
        <trans-unit id="d4734d382405fe72442dafef31013eff2bc92678" translate="yes" xml:space="preserve">
          <source>But the top level of an ES6 module is &lt;em&gt;not&lt;/em&gt; global. A variable declared at the top of an ES6 module will only be visible inside that module, unless the variable is explicitly &lt;code&gt;export&lt;/code&gt;ed, or unless it's assigned to a property of the global object.</source>
          <target state="translated">Pero el nivel superior de un m&amp;oacute;dulo ES6 &lt;em&gt;no&lt;/em&gt; es global. Una variable declarada en la parte superior de un m&amp;oacute;dulo ES6 solo ser&amp;aacute; visible dentro de ese m&amp;oacute;dulo, a menos que la variable se &lt;code&gt;export&lt;/code&gt; e expl&amp;iacute;citamente o que se asigne a una propiedad del objeto global.</target>
        </trans-unit>
        <trans-unit id="c4d272ff3f7fc4237376ed64dc233b59d9966000" translate="yes" xml:space="preserve">
          <source>Catch block parameter</source>
          <target state="translated">Parámetro de bloqueo de captura</target>
        </trans-unit>
        <trans-unit id="32c3db15ba22df73876c55e60996667cba034b0c" translate="yes" xml:space="preserve">
          <source>Catch block parameters are scoped to the catch-block body:</source>
          <target state="translated">Los parámetros de los bloques de captura se amplían al cuerpo del bloque de captura:</target>
        </trans-unit>
        <trans-unit id="6fe813611dd6d84d9a1d26977566960643817c11" translate="yes" xml:space="preserve">
          <source>Check this article for in-depth understanding of scope</source>
          <target state="translated">Consulte este artículo para una comprensión más profunda del alcance</target>
        </trans-unit>
        <trans-unit id="806b84e63f4442df339c4262199841634c53b286" translate="yes" xml:space="preserve">
          <source>Contexts form a stack of environments where variables are stored</source>
          <target state="translated">Los contextos forman una pila de ambientes donde se almacenan las variables</target>
        </trans-unit>
        <trans-unit id="3b76905c4fef521cd5b87dffcd70e8f6c5497e77" translate="yes" xml:space="preserve">
          <source>Control structure body</source>
          <target state="translated">Estructura de control del cuerpo</target>
        </trans-unit>
        <trans-unit id="9145c9f2f97356d62bd24da8388b2b38acf59902" translate="yes" xml:space="preserve">
          <source>Currently the feature offers support for a depth of 16 nested functions, but currently does not color global variables.</source>
          <target state="translated">Actualmente la característica ofrece soporte para una profundidad de 16 funciones anidadas,pero actualmente no colorea las variables globales.</target>
        </trans-unit>
        <trans-unit id="65fff7fa8d3c3b1a1f3c9528a2264bd097d68887" translate="yes" xml:space="preserve">
          <source>Declaration Styles</source>
          <target state="translated">Estilos de declaración</target>
        </trans-unit>
        <trans-unit id="a8fbe250f6e0a7b427bb5ef03aadced5ed432e98" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword. Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.</source>
          <target state="translated">ECMAScript 6 introdujo las palabras clave let y const.Estas palabras clave pueden ser usadas en lugar de la palabra clave var.Al contrario de la palabra clave var,las palabras clave let y const apoyan la declaración de alcance local dentro de las declaraciones de bloque.</target>
        </trans-unit>
        <trans-unit id="e4c8806859640baf11f724a1eec52c4f7c4afcf5" translate="yes" xml:space="preserve">
          <source>EDIT: Based on Benjamin's pointing out of the with and catch statements in the comments, I've edited the post, and added more.  Both the with and the catch statements introduce variables into their respective blocks, and that &lt;em&gt;is&lt;/em&gt; a block scope. These variables are aliased to the properties of the objects passed into them.</source>
          <target state="translated">EDITAR: Bas&amp;aacute;ndome en que Benjamin se&amp;ntilde;al&amp;oacute; las declaraciones con y en los comentarios, edit&amp;eacute; la publicaci&amp;oacute;n y agregu&amp;eacute; m&amp;aacute;s. Tanto las sentencias con como las capturas introducen variables en sus bloques respectivos, y ese &lt;em&gt;es&lt;/em&gt; un alcance de bloque. Estas variables tienen un alias a las propiedades de los objetos que se les pasan.</target>
        </trans-unit>
        <trans-unit id="e6021de7d4da167c9d1924fe6e9b51d156cf4a9a" translate="yes" xml:space="preserve">
          <source>EDIT: Clarifying example:</source>
          <target state="translated">EDITORIAL:Aclarando el ejemplo:</target>
        </trans-unit>
        <trans-unit id="409777b6233f21776478ec8ae63313ad04d136b2" translate="yes" xml:space="preserve">
          <source>EDIT: ECMAAScript 6 (Harmony) is spec'ed to support let, and I know chrome allows a 'harmony' flag, so perhaps it does support it..</source>
          <target state="translated">EDITORIAL:ECMAAScript 6 (Harmony)se especifica para apoyar a Let,y sé que el cromo permite una bandera de &quot;Harmony&quot;,así que tal vez la apoye...</target>
        </trans-unit>
        <trans-unit id="35e06056ed8896626ffd136476a7dd3ee396b131" translate="yes" xml:space="preserve">
          <source>Each function creates an execution context (but not always a new this binding)</source>
          <target state="translated">Cada función crea un contexto de ejecución (pero no siempre un nuevo esta vinculante)</target>
        </trans-unit>
        <trans-unit id="a6992c03e5f9e7f14a3502886f2fe8726fe41373" translate="yes" xml:space="preserve">
          <source>Every variable declared with the &lt;code&gt;var&lt;/code&gt; keyword is scoped to the function. However, if other function are declared within that function those functions will have access to the variables of the outer functions. This is called a &lt;strong&gt;scope chain&lt;/strong&gt;. It works in the following manner:</source>
          <target state="translated">Cada variable declarada con la palabra clave &lt;code&gt;var&lt;/code&gt; tiene un alcance de la funci&amp;oacute;n. Sin embargo, si se declara otra funci&amp;oacute;n dentro de esa funci&amp;oacute;n, esas funciones tendr&amp;aacute;n acceso a las variables de las funciones externas. Esto se llama una &lt;strong&gt;cadena de alcance&lt;/strong&gt; . Funciona de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="be91cfda712a2aa2bbaed218f5da3f4f20ced37f" translate="yes" xml:space="preserve">
          <source>Example of block scope is :-</source>
          <target state="translated">El ejemplo del alcance del bloque es :-</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="13c2c628d0e65d9c75a59c080f5bcf4a585ac61e" translate="yes" xml:space="preserve">
          <source>Find out &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures&quot;&gt;more&lt;/a&gt;.</source>
          <target state="translated">Descubre &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures&quot;&gt;m&amp;aacute;s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3e52c062915c2a123c8f3e107bb729e5edb24b0" translate="yes" xml:space="preserve">
          <source>For an up-to-date overview of which browsers support the &lt;code&gt;let&lt;/code&gt; statement at the time of your reading this answer, see &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;this &lt;code&gt;Can I Use&lt;/code&gt; page&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">Para obtener una descripci&amp;oacute;n actualizada de los navegadores que admiten la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; al momento de leer esta respuesta, consulte &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;esta p&amp;aacute;gina &lt;code&gt;Can I Use&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="f759fff65c16814ccf2912386bb55ea2f49f07e2" translate="yes" xml:space="preserve">
          <source>For those that believe there is only global and local scope, please explain why Mozilla would have an entire page describing the nuances of block scope in JS.</source>
          <target state="translated">Para aquellos que creen que sólo hay un alcance global y local,por favor,expliquen por qué Mozilla tendría una página entera describiendo los matices del alcance de los bloques en JS.</target>
        </trans-unit>
        <trans-unit id="b3a281d3e09d661ffef9d575955e9402e9acd1b7" translate="yes" xml:space="preserve">
          <source>Function - visible within a function (and its sub-functions and blocks)</source>
          <target state="translated">Función-visible dentro de una función (y sus subfunciones y bloques)</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">Función del cuerpo</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">Declaraciones de función</target>
        </trans-unit>
        <trans-unit id="54098e1a6688516674ee45e3b3d0d1327b43c770" translate="yes" xml:space="preserve">
          <source>Function declarations have block scope in strict mode and function scope in non-strict mode. Note: non-strict mode is a complicated set of emergent rules based on the quirky historical implementations of different browsers.</source>
          <target state="translated">Las declaraciones de función tienen un alcance de bloqueo en el modo estricto y un alcance de función en el modo no estricto.Nota:el modo no estricto es un complicado conjunto de reglas emergentes basadas en las extravagantes implementaciones históricas de diferentes navegadores.</target>
        </trans-unit>
        <trans-unit id="7f91e1a8edc0e34ea3bca466ca46d82f7465d0d6" translate="yes" xml:space="preserve">
          <source>Function parameter names</source>
          <target state="translated">Nombres de los parámetros de la función</target>
        </trans-unit>
        <trans-unit id="9b10b98fb2db663a6af8871104c108ef004b25fd" translate="yes" xml:space="preserve">
          <source>Function parameter names are scoped to the function body.</source>
          <target state="translated">Los nombres de los parámetros de la función se amplían al cuerpo de la función.</target>
        </trans-unit>
        <trans-unit id="1e0d99529d66efa9e16b2a37d29fa7405450d6fd" translate="yes" xml:space="preserve">
          <source>Function parameters</source>
          <target state="translated">Parámetros de la función</target>
        </trans-unit>
        <trans-unit id="f0919c6e7316ed9e8e640c9b80f7609cc7dbc45b" translate="yes" xml:space="preserve">
          <source>Function parameters can be considered to be declared in the function body:</source>
          <target state="translated">Los parámetros de la función pueden considerarse declarados en el cuerpo de la función:</target>
        </trans-unit>
        <trans-unit id="cc0841f2f77bf09c47bd5cbb83dd0f40e14bf028" translate="yes" xml:space="preserve">
          <source>Global - visible by everything</source>
          <target state="translated">Global-visible por todo</target>
        </trans-unit>
        <trans-unit id="ab9be0bed756d5b31a5365140ba111b3a60a2123" translate="yes" xml:space="preserve">
          <source>Global Scope :</source>
          <target state="translated">Alcance global :</target>
        </trans-unit>
        <trans-unit id="9c1d41d613e2de602e0cfbbc37dd6fb38c9598e2" translate="yes" xml:space="preserve">
          <source>Global context</source>
          <target state="translated">Contexto mundial</target>
        </trans-unit>
        <trans-unit id="1fd666f0db8baac461a523eb3696c9d6cf767ffc" translate="yes" xml:space="preserve">
          <source>Global scope</source>
          <target state="translated">Alcance global</target>
        </trans-unit>
        <trans-unit id="1db5edb9fb9b116986bc02c1af9c99d7780ec95f" translate="yes" xml:space="preserve">
          <source>Global variables are exactly like global stars (Jackie Chan, Nelson Mandela). You can access them (get or set the value), from any part of your application. Global functions are like global events (New Year, Christmas). You can execute (call) them from any part of your application.</source>
          <target state="translated">Las variables globales son exactamente como las estrellas globales (Jackie Chan,Nelson Mandela).Puedes acceder a ellas (obtener o establecer el valor),desde cualquier parte de tu aplicación.Las funciones globales son como los eventos globales (Año Nuevo,Navidad).Puedes ejecutarlas (llamarlas),desde cualquier parte de tu aplicación.</target>
        </trans-unit>
        <trans-unit id="b6c6545a0afcd35503cd3889c2e63ae786e74d3d" translate="yes" xml:space="preserve">
          <source>Here is a good article on the subject.</source>
          <target state="translated">Aquí hay un buen artículo sobre el tema.</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">Aquí hay un ejemplo:</target>
        </trans-unit>
        <trans-unit id="36b16afa86f01c1ed6ed7ee0985634679d23724b" translate="yes" xml:space="preserve">
          <source>Here, we can see that our variable &lt;code&gt;j&lt;/code&gt; is only known in the first for loop, but not before and after. Yet, our variable &lt;code&gt;i&lt;/code&gt; is known in the entire function.</source>
          <target state="translated">Aqu&amp;iacute;, podemos ver que nuestra variable &lt;code&gt;j&lt;/code&gt; solo se conoce en el primer bucle for, pero no antes y despu&amp;eacute;s. Sin embargo, nuestra variable &lt;code&gt;i&lt;/code&gt; es conocida en toda la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6197c902dc9a969800bbc1f43aa78895c0f511c1" translate="yes" xml:space="preserve">
          <source>How an identifier was declared</source>
          <target state="translated">Cómo se declaró un identificador</target>
        </trans-unit>
        <trans-unit id="fd84c93e786da583023283e8e6b544cc15f8a544" translate="yes" xml:space="preserve">
          <source>How do I create block scope variables?</source>
          <target state="translated">¿Cómo puedo crear variables de alcance de bloque?</target>
        </trans-unit>
        <trans-unit id="6523732fcc8d20544777c08d98cafcd3a527d5d8" translate="yes" xml:space="preserve">
          <source>How it works under the hood</source>
          <target state="translated">Cómo funciona bajo el capó</target>
        </trans-unit>
        <trans-unit id="9bccab4e65ebb124be42a79a1ea8250f796b3a9e" translate="yes" xml:space="preserve">
          <source>How to keep track of browser support</source>
          <target state="translated">Cómo hacer un seguimiento del soporte de los navegadores</target>
        </trans-unit>
        <trans-unit id="12e28ac9e5aec52d743e292f0a6d97a79a4481d9" translate="yes" xml:space="preserve">
          <source>I found that many people new to JavaScript have trouble understanding that inheritance is available by default in the language and that function scope is the only scope, so far. I provided an extension to a beautifier I wrote at the end of last year called JSPretty. The feature colors function scope in the code and always associates a color to all variables declared in that scope. Closure is visually demonstrated when a variable with a color from one scope is used in a different scope.</source>
          <target state="translated">Descubrí que mucha gente nueva en JavaScript tiene problemas para entender que la herencia está disponible por defecto en el lenguaje y que el alcance de la función es el único alcance,hasta ahora.Proporcioné una extensión a un embellecedor que escribí a finales del año pasado llamado JSPretty.La característica colorea el ámbito de la función en el código y siempre asocia un color a todas las variables declaradas en ese ámbito.El cierre se demuestra visualmente cuando una variable con un color de un ámbito se utiliza en un ámbito diferente.</target>
        </trans-unit>
        <trans-unit id="cdf8b31fb66ebedcd5a01dafdc4d2f5c826f3323" translate="yes" xml:space="preserve">
          <source>I will not elaborate on this, since there are already many other answers explaining the difference.</source>
          <target state="translated">No me explayaré sobre esto,ya que hay muchas otras respuestas que explican la diferencia.</target>
        </trans-unit>
        <trans-unit id="eadac369b069051bb3496882603cd8c18a6245be" translate="yes" xml:space="preserve">
          <source>Identifier resolution only occurs in one direction: outwards. In this way, outer lexical environments cannot &quot;see&quot; into inner lexical environments.</source>
          <target state="translated">La resolución del identificador sólo ocurre en una dirección:hacia afuera.De esta manera,los entornos léxicos externos no pueden &quot;ver&quot; dentro de los entornos léxicos internos.</target>
        </trans-unit>
        <trans-unit id="bac671b2d31df9b17566a019bb6eec35764631e1" translate="yes" xml:space="preserve">
          <source>Identifiers declared using &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;&lt;strong&gt;have block scope&lt;/strong&gt;, apart from when they are declared directly in the global context, in which case they have global scope.</source>
          <target state="translated">Los identificadores declarados usando &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; &lt;strong&gt;tienen un alcance de bloque&lt;/strong&gt; , aparte de cuando se declaran directamente en el contexto global, en cuyo caso tienen un alcance global.</target>
        </trans-unit>
        <trans-unit id="26eb35e5d6c55c98bf781bbeb4741c6d644d48f6" translate="yes" xml:space="preserve">
          <source>Identifiers declared using &lt;code&gt;var&lt;/code&gt;&lt;strong&gt;have function scope&lt;/strong&gt;, apart from when they are declared directly in the global context, in which case they are added as properties on the global object and have global scope. There are separate rules for their use in &lt;code&gt;eval&lt;/code&gt; functions.</source>
          <target state="translated">Los identificadores declarados usando &lt;code&gt;var&lt;/code&gt; &lt;strong&gt;tienen alcance de funci&amp;oacute;n&lt;/strong&gt; , aparte de cuando se declaran directamente en el contexto global, en cuyo caso se agregan como propiedades en el objeto global y tienen alcance global. Hay reglas separadas para su uso en las funciones de &lt;code&gt;eval&lt;/code&gt; uaci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="f36a64720f58b77b1ccc6c4e4747411d14a62208" translate="yes" xml:space="preserve">
          <source>If it cannot find the variable inside the the function body it &lt;strong&gt;will climb up to the chain&lt;/strong&gt; and look at the variable scope in the function in &lt;strong&gt;where the function was defined&lt;/strong&gt;. This is what is meant with lexical scope, we can see in the code where this function was defined and thus can determine the scope chain by merely looking at the code.</source>
          <target state="translated">Si no puede encontrar la variable dentro del cuerpo de la funci&amp;oacute;n &lt;strong&gt;, subir&amp;aacute; a la cadena&lt;/strong&gt; y observar&amp;aacute; el alcance de la variable en la funci&amp;oacute;n en &lt;strong&gt;la que se defini&amp;oacute; la funci&amp;oacute;n&lt;/strong&gt; . Esto es lo que se entiende con alcance l&amp;eacute;xico, podemos ver en el c&amp;oacute;digo d&amp;oacute;nde se defini&amp;oacute; esta funci&amp;oacute;n y, por lo tanto, podemos determinar la cadena de alcance simplemente mirando el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="745abb411c5db9b98fe9940dfa7c7e42d66969dd" translate="yes" xml:space="preserve">
          <source>If you are in the USA, you may know Kim Kardashian, infamous celebrity ( she somehow manages to make the tabloids). But people outside of the USA will not recognize her. She is a local star, bound to her territory.</source>
          <target state="translated">Si estás en los EE.UU.,puede que conozcas a Kim Kardashian,una famosa celebridad (de alguna manera se las arregla para salir en los tabloides).Pero la gente de fuera de los EE.UU.no la reconocerá.Ella es una estrella local,ligada a su territorio.</target>
        </trans-unit>
        <trans-unit id="db4ede529a33a6d48b929256007928a838c5c68c" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</source>
          <target state="translated">Si estás escribiendo código JavaScript del lado del cliente y no usas un transpilador,debes considerar el soporte del navegador.</target>
        </trans-unit>
        <trans-unit id="8dcd2b2b003bbf8ee33318bcf617bf8c5934526f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a Node based transpiler (like the &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell script&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.</source>
          <target state="translated">Si est&amp;aacute; escribiendo c&amp;oacute;digo JavaScript del lado del cliente y usa un transpilador basado en Nodo (como el &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;script de shell traceur&lt;/strong&gt;&lt;/a&gt; o &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt; ), puede usar de manera segura la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; . Y debido a que su navegador solo sabr&amp;aacute; sobre el c&amp;oacute;digo transpilado, los inconvenientes de rendimiento deben ser limitados.</target>
        </trans-unit>
        <trans-unit id="78db1b0537f209bbe9cabb545f633294560d8d7f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a browser based transpiler (like &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement, however your code is likely to be anything but optimal with respect to performance.</source>
          <target state="translated">Si est&amp;aacute; escribiendo c&amp;oacute;digo JavaScript del lado del cliente y usa un transpilador basado en navegador (como &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; o &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt; ), puede usar de manera segura la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; , sin embargo, es probable que su c&amp;oacute;digo sea todo menos &amp;oacute;ptimo con respecto al rendimiento.</target>
        </trans-unit>
        <trans-unit id="4730b8ff337fd5e9541397578300f0622cd1031f" translate="yes" xml:space="preserve">
          <source>If you're writing server-side JavaScript code (&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement.</source>
          <target state="translated">Si est&amp;aacute; escribiendo c&amp;oacute;digo JavaScript del lado del servidor ( &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt; ), puede usar de manera segura la declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e76b9230322e627054331e7b9ae49ba5c423394b" translate="yes" xml:space="preserve">
          <source>Implicit variable declarations</source>
          <target state="translated">Declaraciones variables implícitas</target>
        </trans-unit>
        <trans-unit id="45efcccf469aa7800be7436a4b8905d5812288f9" translate="yes" xml:space="preserve">
          <source>In &quot;Javascript 1.7&quot; (Mozilla's extension to Javascript) one can also declare block-scope variables with &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt;:</source>
          <target state="translated">En &quot;Javascript 1.7&quot; (extensi&amp;oacute;n de Mozilla a Javascript) tambi&amp;eacute;n se pueden declarar variables de alcance de bloque con la &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11&quot;&gt;declaraci&amp;oacute;n &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="df791ba6a19c022e5fd42c64ae7d2edc9a0401c4" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;eval&lt;/code&gt; strings, variables declared using &lt;code&gt;var&lt;/code&gt; will be placed in the current scope, or, if &lt;code&gt;eval&lt;/code&gt; is used indirectly, as properties on the global object.</source>
          <target state="translated">En las cadenas de &lt;code&gt;eval&lt;/code&gt; uaci&amp;oacute;n , las variables declaradas usando &lt;code&gt;var&lt;/code&gt; se colocar&amp;aacute;n en el alcance actual o, si se usa &lt;code&gt;eval&lt;/code&gt; indirectamente, como propiedades en el objeto global.</target>
        </trans-unit>
        <trans-unit id="b205565c9d304960cff99be6d6bb359de2add3f5" translate="yes" xml:space="preserve">
          <source>In EcmaScript5, there are mainly two scopes, &lt;strong&gt;local scope&lt;/strong&gt; and &lt;strong&gt;global scope&lt;/strong&gt; but in EcmaScript6 we have mainly three scopes, local scope, global scope and a new scope called &lt;strong&gt;block scope&lt;/strong&gt;.</source>
          <target state="translated">En EcmaScript5, existen principalmente dos &amp;aacute;mbitos, &lt;strong&gt;&amp;aacute;mbito local&lt;/strong&gt; y &lt;strong&gt;&amp;aacute;mbito&lt;/strong&gt; &lt;strong&gt;global,&lt;/strong&gt; pero en EcmaScript6 tenemos principalmente tres &amp;aacute;mbitos, &amp;aacute;mbito local, &amp;aacute;mbito global y un nuevo &amp;aacute;mbito denominado &lt;strong&gt;&amp;aacute;mbito de bloque&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="524ef03338ba6373ff8442de44d3525db236f6ed" translate="yes" xml:space="preserve">
          <source>In JavaScript there are two types of scope:</source>
          <target state="translated">En JavaScript hay dos tipos de alcance:</target>
        </trans-unit>
        <trans-unit id="49f24e5b3ac83ce8f7d46f9b0b5fbf42b56fef59" translate="yes" xml:space="preserve">
          <source>In JavaScript, every function-object has a hidden &lt;code&gt;[[Environment]]&lt;/code&gt; reference that is a reference to the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;lexical environment&lt;/a&gt; of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;execution context&lt;/a&gt; (stack frame) within which it was created.</source>
          <target state="translated">En JavaScript, cada objeto de funci&amp;oacute;n tiene una referencia &lt;code&gt;[[Environment]]&lt;/code&gt; oculta que es una referencia al &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;entorno l&amp;eacute;xico&lt;/a&gt; del &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;contexto de ejecuci&amp;oacute;n&lt;/a&gt; (marco de pila) dentro del cual se cre&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="101098685b4ef4c5fe8ddde1f6b84cd946e6cda9" translate="yes" xml:space="preserve">
          <source>In non-strict mode, function declarations have function scope. In strict mode they have block scope.</source>
          <target state="translated">En el modo no estricto,las declaraciones de función tienen un alcance de función.En el modo estricto tienen un alcance de bloque.</target>
        </trans-unit>
        <trans-unit id="517fb1c6e1e082360f7bfc6a062cddd34106ba21" translate="yes" xml:space="preserve">
          <source>In non-strict mode, implicit variable declarations are globally scoped. In strict mode you get an error.</source>
          <target state="translated">En el modo no estricto,las declaraciones variables implícitas son de alcance global.En el modo estricto se obtiene un error.</target>
        </trans-unit>
        <trans-unit id="c530a0f6e7c617894a5240c8ce5b620b9c103965" translate="yes" xml:space="preserve">
          <source>In non-strict mode, implicit variable declarations have global scope. In strict mode these are not permitted.</source>
          <target state="translated">En el modo no estricto,las declaraciones variables implícitas tienen un alcance global.En el modo estricto no están permitidas.</target>
        </trans-unit>
        <trans-unit id="5f6bfeda81e0e8b51ad8697f031e39feead1aa2e" translate="yes" xml:space="preserve">
          <source>In the above example letVar logs the value global because variables declared with &lt;code&gt;let&lt;/code&gt; are block scoped. They cease to exist outside their respective block, so the variable can't be accessed outside the if block.</source>
          <target state="translated">En el ejemplo anterior, letVar registra el valor global porque las variables declaradas con &lt;code&gt;let&lt;/code&gt; tienen un alcance de bloque. Dejan de existir fuera de su bloque respectivo, por lo que no se puede acceder a la variable fuera del bloque if.</target>
        </trans-unit>
        <trans-unit id="f75a76f8d36110fb25053c596b58acad7a1e7f42" translate="yes" xml:space="preserve">
          <source>In the first example, there was no block scope, so the initially declared variables were overwritten. In the second example, there was a new scope due to the function, so the initially declared variables were SHADOWED, and not overwritten.</source>
          <target state="translated">En el primer ejemplo,no había un ámbito de bloqueo,por lo que las variables declaradas inicialmente fueron sobrescritas.En el segundo ejemplo,había un nuevo alcance debido a la función,por lo que las variables inicialmente declaradas fueron SOMBRADAS,y no sobrescritas.</target>
        </trans-unit>
        <trans-unit id="70b614f546808637e2d6bda4b19e2a55f0206cd8" translate="yes" xml:space="preserve">
          <source>In the following, &lt;code&gt;x&lt;/code&gt; is visible outside of the loop because &lt;code&gt;var&lt;/code&gt; has function scope:</source>
          <target state="translated">A continuaci&amp;oacute;n, &lt;code&gt;x&lt;/code&gt; es visible fuera del ciclo porque &lt;code&gt;var&lt;/code&gt; tiene alcance de funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="d512dd946ae9252d40645adc648a80ba866281e8" translate="yes" xml:space="preserve">
          <source>In this language, the displays were done similar to a stack of index cards. There was a master card referred to as the background. It was transparent and can be seen as the bottom card. Any content on this base card was shared with cards placed on top of it. Each card placed on top had its own content which took precedence over the previous card, but still had access to the prior cards if desired.</source>
          <target state="translated">En este lenguaje,las visualizaciones se hicieron de manera similar a una pila de tarjetas de índice.Había una tarjeta maestra llamada fondo.Era transparente y se puede ver como la tarjeta del fondo.Cualquier contenido de esta tarjeta base se compartía con las tarjetas colocadas en la parte superior.Cada tarjeta colocada en la parte superior tenía su propio contenido que tenía prioridad sobre la tarjeta anterior,pero aún así tenía acceso a las tarjetas anteriores si así lo deseaba.</target>
        </trans-unit>
        <trans-unit id="597c9aea5b3298abab060a8929051c7f5d129292" translate="yes" xml:space="preserve">
          <source>Is it safe to use block scope variables today?</source>
          <target state="translated">¿Es seguro usar variables de alcance de bloque hoy en día?</target>
        </trans-unit>
        <trans-unit id="bed514e2588665341497d11ae432c1980024650f" translate="yes" xml:space="preserve">
          <source>JavaScript has lexical (also called static) scoping and closures. This means you can tell the scope of an identifier by looking at the source code.</source>
          <target state="translated">JavaScript tiene un alcance léxico (también llamado estático)y cierres.Esto significa que puedes saber el alcance de un identificador mirando el código fuente.</target>
        </trans-unit>
        <trans-unit id="4452aeeb557996248e57cd5ff1bf92ebc44de21c" translate="yes" xml:space="preserve">
          <source>JavaScript have only two type of scope :</source>
          <target state="translated">JavaScript sólo tiene dos tipos de alcance:</target>
        </trans-unit>
        <trans-unit id="34dae96f32e8c613581daf8160bc2454a1788290" translate="yes" xml:space="preserve">
          <source>Javascript uses scope chains to establish the scope for a given function. There is typically one global scope, and each function defined has its own nested scope. Any function defined within another function has a local scope which is linked to the outer function. It's always the position in the source that defines the scope.</source>
          <target state="translated">Javascript utiliza cadenas de alcance para establecer el alcance de una función determinada.Típicamente hay un alcance global,y cada función definida tiene su propio alcance anidado.Cualquier función definida dentro de otra función tiene un alcance local que está vinculado a la función externa.Siempre es la posición en la fuente la que define el alcance.</target>
        </trans-unit>
        <trans-unit id="aaccd2b14cae60b4870ad3ae5d1483bf95f1cc7f" translate="yes" xml:space="preserve">
          <source>Just to add to the other answers, scope is a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.  This look-up may be for the purposes of assigning to the variable, which is an LHS (lefthand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. These look-ups are what the JavaScript engine is doing internally when it's compiling and executing the code.</source>
          <target state="translated">Sólo para añadir a las otras respuestas,el alcance es una lista de búsqueda de todos los identificadores (variables)declarados,y hace cumplir un estricto conjunto de reglas sobre cómo son accesibles para el código en ejecución.Esta búsqueda puede ser con el propósito de asignar a la variable,que es una referencia LHS (lado izquierdo),o puede ser con el propósito de recuperar su valor,que es una referencia RHS (lado derecho).Estas búsquedas son lo que el motor de JavaScript hace internamente cuando está compilando y ejecutando el código.</target>
        </trans-unit>
        <trans-unit id="6e76cdd0f809219e814e41d1445bb5906bf62b65" translate="yes" xml:space="preserve">
          <source>Let would be a support for block level scoping, but you have to use the keyword to make it happen.</source>
          <target state="translated">Seríamos un apoyo para el alcance del nivel de bloque,pero hay que usar la palabra clave para que suceda.</target>
        </trans-unit>
        <trans-unit id="8e18f18ab1ca156d4e71dc6cde7b4aa86040a968" translate="yes" xml:space="preserve">
          <source>Local Scope :</source>
          <target state="translated">Alcance local :</target>
        </trans-unit>
        <trans-unit id="ca1be526eefc4c0c9a3b41b14b0b70782146069f" translate="yes" xml:space="preserve">
          <source>Local scope</source>
          <target state="translated">Alcance local</target>
        </trans-unit>
        <trans-unit id="a5d58a53fe2af24df0c1d2967e48151aa15ad00d" translate="yes" xml:space="preserve">
          <source>Local variables are like local stars. You can only access them (get or set the value) inside the scope. A local function is like local events - you can execute only (celebrate) inside that scope. If you want to access them from outside of the scope, you will get a reference error</source>
          <target state="translated">Las variables locales son como las estrellas locales.Sólo se puede acceder a ellas (obtener o establecer el valor)dentro del ámbito.Una función local es como los eventos locales-sólo puedes ejecutar (celebrar)dentro de ese ámbito.Si quieres acceder a ellas desde fuera del ámbito,obtendrás un error de referencia</target>
        </trans-unit>
        <trans-unit id="4136eb8081368e099724a9eb455093c190198113" translate="yes" xml:space="preserve">
          <source>Modern JavaScript</source>
          <target state="translated">Javascript moderno</target>
        </trans-unit>
        <trans-unit id="7616704e501c489cb1ada1999f1307d7d34894df" translate="yes" xml:space="preserve">
          <source>Modern Js, ES6+, '&lt;code&gt;const&lt;/code&gt;' and '&lt;code&gt;let&lt;/code&gt;'</source>
          <target state="translated">Js moderno, ES6 +, ' &lt;code&gt;const&lt;/code&gt; ' y ' &lt;code&gt;let&lt;/code&gt; '</target>
        </trans-unit>
        <trans-unit id="aad38a0f6cdff42e1f74357a58c635fc618d1ed1" translate="yes" xml:space="preserve">
          <source>Module - visible within a module</source>
          <target state="translated">Módulo-visible dentro de un módulo</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="003bc7d27503c7802bcadc1da058ded6bae30f8e" translate="yes" xml:space="preserve">
          <source>My understanding is that there are 3 scopes: global scope, available globally; local scope, available to an entire function regardless of blocks; and block scope, only available to the block, statement, or expression on which it was used. Global and local scope are indicated with the keyword 'var', either within a function or outside, and block scope is indicated with the keyword 'let'.</source>
          <target state="translated">Mi entendimiento es que hay 3 alcances:alcance global,disponible a nivel mundial;alcance local,disponible para una función entera sin importar los bloques;y alcance de bloque,disponible sólo para el bloque,declaración o expresión en la que se utilizó.El alcance global y local se indican con la palabra clave 'var',ya sea dentro o fuera de una función,y el alcance de bloque se indica con la palabra clave 'let'.</target>
        </trans-unit>
        <trans-unit id="ebc5769ecf05a1a2a40ee3c38b9f80c576a2506b" translate="yes" xml:space="preserve">
          <source>Named function expressions</source>
          <target state="translated">Expresiones de funciones nombradas</target>
        </trans-unit>
        <trans-unit id="eaab883a49ed3ddf47b830ade67ddd95c8b8889b" translate="yes" xml:space="preserve">
          <source>Named function expressions are scooped only to the expression itself:</source>
          <target state="translated">Las expresiones de funciones nombradas son sacadas sólo a la expresión en sí misma:</target>
        </trans-unit>
        <trans-unit id="7e130810bfbd11725f532879f063fa5c57ae9625" translate="yes" xml:space="preserve">
          <source>Named function expressions are scoped to themselves (eg. for the purpose of recursion).</source>
          <target state="translated">Las expresiones de funciones nombradas se amplían a sí mismas (por ejemplo,para el propósito de la recursión).</target>
        </trans-unit>
        <trans-unit id="0f5c3a674d3ca00ddc3c16a5c7583524970181f2" translate="yes" xml:space="preserve">
          <source>Note that this link between the new execution context and the lexical environment of the function object is called a &lt;a href=&quot;https://stackoverflow.com/a/111114/38522&quot;&gt;closure&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que este v&amp;iacute;nculo entre el nuevo contexto de ejecuci&amp;oacute;n y el entorno l&amp;eacute;xico del objeto de funci&amp;oacute;n se denomina &lt;a href=&quot;https://stackoverflow.com/a/111114/38522&quot;&gt;cierre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f243cfe125f58adb4304f18257f0d057d6f2352" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;are all hoisted&lt;/a&gt;. This means that their logical position of definition is the top of their enclosing scope (block or function). However, variables declared useing &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; cannot be read or assigned to until control has passed the point of declaration in the source code. The interim period is known as the temporal dead zone.</source>
          <target state="translated">Nota: &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; y &lt;code&gt;var&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;est&amp;aacute;n todos izados&lt;/a&gt; . Esto significa que su posici&amp;oacute;n l&amp;oacute;gica de definici&amp;oacute;n es la parte superior de su alcance (bloque o funci&amp;oacute;n). Sin embargo, las variables declaradas usando &lt;code&gt;let&lt;/code&gt; y &lt;code&gt;const&lt;/code&gt; no pueden leerse ni asignarse hasta que el control haya pasado el punto de declaraci&amp;oacute;n en el c&amp;oacute;digo fuente. El per&amp;iacute;odo intermedio se conoce como zona muerta temporal.</target>
        </trans-unit>
        <trans-unit id="52c316d760a2406f9de3c2dfe34c168873a682d6" translate="yes" xml:space="preserve">
          <source>Now when a variable &lt;code&gt;a&lt;/code&gt; required it first searches for nearest variable scope and if variable is not there than it move's to next object of variable scope chain.which is in this case is window level.</source>
          <target state="translated">Ahora, cuando se requiere una variable, primero busca el alcance de la variable m&amp;aacute;s cercana y, si la variable no est&amp;aacute; all&amp;iacute;, se mueve al siguiente objeto de la cadena del alcance de la variable.</target>
        </trans-unit>
        <trans-unit id="07cc61cfbd5542be1dbdf3df9337149c96b1472d" translate="yes" xml:space="preserve">
          <source>Old school JavaScript</source>
          <target state="translated">Old school JavaScript</target>
        </trans-unit>
        <trans-unit id="d143a89c1211786baeac1937b212ea01195019e5" translate="yes" xml:space="preserve">
          <source>On a different note, unlike normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, which run on the top level, code inside ES6 modules runs in its own private scope. A variable defined at the top of a normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is global, so you can reference it in other &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, like this:</source>
          <target state="translated">En una nota diferente, a diferencia de las etiquetas &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; normales, que se ejecutan en el nivel superior, el c&amp;oacute;digo dentro de los m&amp;oacute;dulos ES6 se ejecuta en su propio &amp;aacute;mbito privado. Una variable definida en la parte superior de una etiqueta &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; normal es global, por lo que puede hacer referencia a ella en otras etiquetas &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; , como esta:</target>
        </trans-unit>
        <trans-unit id="d03a95004161c654858d132f7f32b4344e85bba0" translate="yes" xml:space="preserve">
          <source>One thing of note that is worth mentioning, &quot;Scope look-up stops once it finds the first match&quot;.</source>
          <target state="translated">Una cosa que vale la pena mencionar es que la búsqueda del telescopio se detiene una vez que encuentra la primera coincidencia.</target>
        </trans-unit>
        <trans-unit id="39d115a82e8ca46b1e1da4cb77b8126173035ef2" translate="yes" xml:space="preserve">
          <source>Ordinary block</source>
          <target state="translated">Bloqueo ordinario</target>
        </trans-unit>
        <trans-unit id="3e7192956deaab738bd72c8783df974fd557d341" translate="yes" xml:space="preserve">
          <source>Otherwise, you'll get a ReferenceError when the handler is invoked. So, for example, if the inline handler references a function which is defined &lt;em&gt;inside&lt;/em&gt;&lt;code&gt;window.onload&lt;/code&gt; or &lt;code&gt;$(function() {&lt;/code&gt;, the reference will fail, because the inline handler may only reference variables in the global scope, and the function is not global:</source>
          <target state="translated">De lo contrario, obtendr&amp;aacute; un ReferenceError cuando se invoque el controlador. Entonces, por ejemplo, si el controlador en l&amp;iacute;nea hace referencia a una funci&amp;oacute;n que se define &lt;em&gt;dentro de&lt;/em&gt; &lt;code&gt;window.onload&lt;/code&gt; o &lt;code&gt;$(function() {&lt;/code&gt; , la referencia fallar&amp;aacute;, porque el controlador en l&amp;iacute;nea solo puede hacer referencia a variables en el &amp;aacute;mbito global, y la funci&amp;oacute;n no es global:</target>
        </trans-unit>
        <trans-unit id="b0f7eac222c33234d6b1ce96f288537ff995de59" translate="yes" xml:space="preserve">
          <source>Outside of the special cases of global and module scope, variables are declared using &lt;code&gt;var&lt;/code&gt; (function scope), &lt;code&gt;let&lt;/code&gt; (block scope) and &lt;code&gt;const&lt;/code&gt; (block scope). Most other forms of identifier declaration have block scope in strict mode.</source>
          <target state="translated">Fuera de los casos especiales de alcance global y de m&amp;oacute;dulo, las variables se declaran usando &lt;code&gt;var&lt;/code&gt; (alcance de funci&amp;oacute;n), &lt;code&gt;let&lt;/code&gt; (alcance de bloque) y &lt;code&gt;const&lt;/code&gt; (alcance de bloque). La mayor&amp;iacute;a de las otras formas de declaraci&amp;oacute;n de identificador tienen alcance de bloque en modo estricto.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="4d2fae3746da9a4ac50d19572acc01ad9fa90618" translate="yes" xml:space="preserve">
          <source>Properties of the &lt;code&gt;document&lt;/code&gt; and properties of the element the handler is attached to may also be referenced as standalone variables inside inline handlers because inline handlers are invoked &lt;a href=&quot;https://i.stack.imgur.com/dTDB0.png&quot;&gt;&lt;em&gt;inside&lt;/em&gt; of two &lt;code&gt;with&lt;/code&gt; blocks&lt;/a&gt;, one for the &lt;code&gt;document&lt;/code&gt;, one for the element. The scope chain of variables inside these handlers is &lt;a href=&quot;https://stackoverflow.com/a/57048067&quot;&gt;extremely unintuitive&lt;/a&gt;, and a working event handler will &lt;em&gt;probably&lt;/em&gt; require a function to be global (and unnecessary global pollution &lt;a href=&quot;https://softwareengineering.stackexchange.com/q/148108&quot;&gt;should probably be avoided&lt;/a&gt;).</source>
          <target state="translated">Las propiedades del &lt;code&gt;document&lt;/code&gt; o y las propiedades del elemento al que est&amp;aacute; asociado el controlador tambi&amp;eacute;n se pueden referenciar como variables independientes dentro de los controladores en l&amp;iacute;nea porque los controladores en l&amp;iacute;nea se invocan &lt;a href=&quot;https://i.stack.imgur.com/dTDB0.png&quot;&gt;&lt;em&gt;dentro&lt;/em&gt; de dos &lt;code&gt;with&lt;/code&gt; bloques&lt;/a&gt; , uno para el &lt;code&gt;document&lt;/code&gt; o y otro para el elemento. La cadena de variables de alcance dentro de estos manejadores es &lt;a href=&quot;https://stackoverflow.com/a/57048067&quot;&gt;extremadamente poco intuitiva&lt;/a&gt; , y un manejador de eventos de trabajo &lt;em&gt;probablemente&lt;/em&gt; requerir&amp;aacute; que una funci&amp;oacute;n sea global (y &lt;a href=&quot;https://softwareengineering.stackexchange.com/q/148108&quot;&gt;probablemente se deber&amp;iacute;a evitar&lt;/a&gt; la contaminaci&amp;oacute;n global innecesaria).</target>
        </trans-unit>
        <trans-unit id="358bcd9d5d263dcf0acf4e412ac146d3ec1cbcef" translate="yes" xml:space="preserve">
          <source>Quoting from his ebook:</source>
          <target state="translated">Citando su libro electrónico:</target>
        </trans-unit>
        <trans-unit id="a23997220606bd14c55eafa62be1140a4157f6e3" translate="yes" xml:space="preserve">
          <source>Scope chain --&amp;gt;</source>
          <target state="translated">Cadena de alcance -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="960f638fe475e770a8e797654ca9cc8ebe41b2a9" translate="yes" xml:space="preserve">
          <source>Scope is defined as the &lt;a href=&quot;https://stackoverflow.com/a/1047479/38522&quot;&gt;lexical&lt;/a&gt; region of code over which an identifier is valid.</source>
          <target state="translated">El alcance se define como la regi&amp;oacute;n &lt;a href=&quot;https://stackoverflow.com/a/1047479/38522&quot;&gt;l&amp;eacute;xica&lt;/a&gt; del c&amp;oacute;digo sobre la cual un identificador es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="0001dde1682d4a228cca759a547c5f895b3d0836" translate="yes" xml:space="preserve">
          <source>Scope is formed of a linked nesting of lexical environments, with each level in the nesting corresponding to a lexical environment of an ancestor execution context.</source>
          <target state="translated">El ámbito de aplicación está formado por un anidamiento vinculado de entornos léxicos,correspondiendo cada nivel del anidamiento a un entorno léxico de un contexto de ejecución de un antepasado.</target>
        </trans-unit>
        <trans-unit id="03fc8d42427c442b2a752ef4c9a4f0079386dd0a" translate="yes" xml:space="preserve">
          <source>Scope is the region of the codebase over which an identifier is valid.</source>
          <target state="translated">El alcance es la región de la base de código sobre la que es válido un identificador.</target>
        </trans-unit>
        <trans-unit id="d9e69c5319ff44dd0f7e6cd91e381690e40b15e1" translate="yes" xml:space="preserve">
          <source>Scopes are technically &quot;Execution Contexts&quot;</source>
          <target state="translated">Los alcances son técnicamente &quot;Contextos de ejecución&quot;</target>
        </trans-unit>
        <trans-unit id="8014aa999f8e9f357a908dec6565c42cc7afe011" translate="yes" xml:space="preserve">
          <source>See a demo at:</source>
          <target state="translated">Vea una demostración en:</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Mostrar fragmento de código</target>
        </trans-unit>
        <trans-unit id="4a2982e515416ff8974a0e226abce538efa699bf" translate="yes" xml:space="preserve">
          <source>Since the scope chain inside inline handlers is &lt;em&gt;so weird&lt;/em&gt;, and since inline handlers require global pollution to work, and since inline handlers sometimes require ugly string escaping when passing arguments, it's probably easier to avoid them. Instead, attach event handlers using Javascript (like with &lt;code&gt;addEventListener&lt;/code&gt;), rather than with HTML markup.</source>
          <target state="translated">Dado que la cadena de alcance dentro de los controladores en l&amp;iacute;nea es &lt;em&gt;muy extra&amp;ntilde;a&lt;/em&gt; , y dado que los controladores en l&amp;iacute;nea requieren contaminaci&amp;oacute;n global para funcionar, y dado que los controladores en l&amp;iacute;nea a veces requieren un escape de cadena feo al pasar argumentos, probablemente sea m&amp;aacute;s f&amp;aacute;cil evitarlos. En su lugar, adjunte controladores de eventos usando Javascript (como con &lt;code&gt;addEventListener&lt;/code&gt; ), en lugar de con el marcado HTML.</target>
        </trans-unit>
        <trans-unit id="d7b8f215615eb4f7e16592cd68df7d8300b6ec09" translate="yes" xml:space="preserve">
          <source>So from this perspective, I think that a picture would help that I found in the Scopes and Closures ebook by Kyle Simpson:</source>
          <target state="translated">Así que desde esta perspectiva,creo que ayudaría una imagen que encontré en el ebook de Alcances y Cierres de Kyle Simpson:</target>
        </trans-unit>
        <trans-unit id="260b57030b2b60bb30906c7875f28bf2c6a9202e" translate="yes" xml:space="preserve">
          <source>So that is the technical explanation. In practice, it is important to remember that in JavaScript</source>
          <target state="translated">Así que esa es la explicación técnica.En la práctica,es importante recordar que en JavaScript</target>
        </trans-unit>
        <trans-unit id="6eeb8f5239adbcf206f276fe0178d507b944531b" translate="yes" xml:space="preserve">
          <source>So this code:</source>
          <target state="translated">Así que este código:</target>
        </trans-unit>
        <trans-unit id="9149eb7ca4536bbe4c6e7d579b916628507a6c43" translate="yes" xml:space="preserve">
          <source>So what is the difference between functional scope and block scope?</source>
          <target state="translated">Entonces,¿cuál es la diferencia entre el alcance funcional y el alcance de bloque?</target>
        </trans-unit>
        <trans-unit id="de0115ead2817c9e584c804563ac34e1a02cf494" translate="yes" xml:space="preserve">
          <source>So you can see JavaScript scoping is actually extremely simple, albeit not always intuitive. A few things to be aware of:</source>
          <target state="translated">Así que puedes ver que el alcance de JavaScript es en realidad extremadamente simple,aunque no siempre intuitivo.Hay algunas cosas que hay que tener en cuenta:</target>
        </trans-unit>
        <trans-unit id="3812cb403a9ffcb176a50c641ea80b4719348646" translate="yes" xml:space="preserve">
          <source>So, any blocks other than functions do not create a new scope. That explains why for-loops overwrite outer scoped variables:</source>
          <target state="translated">Por lo tanto,cualquier bloqueo que no sea de funciones no crea un nuevo alcance.Eso explica por qué los bucles for-loops sobrescriben las variables del alcance exterior:</target>
        </trans-unit>
        <trans-unit id="77ce19117cbf62e9aa83a0e9daa5eda964f91d46" translate="yes" xml:space="preserve">
          <source>Some of the locations identifiers can be declared:</source>
          <target state="translated">Se pueden declarar algunos de los identificadores de las ubicaciones:</target>
        </trans-unit>
        <trans-unit id="6c1737e3aa3de31e28974c1c8d07d17beab8ca24" translate="yes" xml:space="preserve">
          <source>Some of the ways identifiers can be declared:</source>
          <target state="translated">Algunas de las formas en que se pueden declarar los identificadores:</target>
        </trans-unit>
        <trans-unit id="de99e0fa995db074a346a8fd3d2e19d830b3b47e" translate="yes" xml:space="preserve">
          <source>TLDR</source>
          <target state="translated">TLDR</target>
        </trans-unit>
        <trans-unit id="eb94aded85eb85135c48677af15bf3ac1f75c26f" translate="yes" xml:space="preserve">
          <source>That's almost all you need to know in terms of JavaScript scoping, except:</source>
          <target state="translated">Eso es casi todo lo que necesitas saber en términos de alcance de JavaScript,excepto:</target>
        </trans-unit>
        <trans-unit id="20ea4c65a85f13a0f7d5880b871c092105665952" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/&quot;&gt;&lt;strong&gt;most recent JavaScript specs&lt;/strong&gt;&lt;/a&gt; now also allow a third scope :</source>
          <target state="translated">Las &lt;a href=&quot;https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/&quot;&gt;&lt;strong&gt;especificaciones de JavaScript m&amp;aacute;s recientes&lt;/strong&gt;&lt;/a&gt; ahora tambi&amp;eacute;n permiten un tercer alcance:</target>
        </trans-unit>
        <trans-unit id="551aa169f58fce36618019678db10f4c0b8c35c3" translate="yes" xml:space="preserve">
          <source>The Below Class has a Global scope variable &lt;code&gt;carName&lt;/code&gt;. And this variable is accessible from everywhere in the class.</source>
          <target state="translated">La siguiente clase tiene una variable de alcance global &lt;code&gt;carName&lt;/code&gt; . Y esta variable es accesible desde cualquier lugar de la clase.</target>
        </trans-unit>
        <trans-unit id="6f2e6a008008ebd7c8f8b0790fa024387f5103ae" translate="yes" xml:space="preserve">
          <source>The Below function has a local scope variable &lt;code&gt;carName&lt;/code&gt;. And this variable is not accessible from outside of the function.</source>
          <target state="translated">La siguiente funci&amp;oacute;n tiene una variable de alcance local &lt;code&gt;carName&lt;/code&gt; . Y esta variable no es accesible desde fuera de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1c6297960ee1326cc0b6ece03b632419c8697d63" translate="yes" xml:space="preserve">
          <source>The biggest difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; is that &lt;code&gt;var&lt;/code&gt; is function scoped whereas &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; are block scoped. Here is an example to illustrate this:</source>
          <target state="translated">La mayor diferencia entre &lt;code&gt;var&lt;/code&gt; y &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; es que &lt;code&gt;var&lt;/code&gt; tiene un alcance de funci&amp;oacute;n, mientras que &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; tiene un alcance de bloque. Aqu&amp;iacute; hay un ejemplo para ilustrar esto:</target>
        </trans-unit>
        <trans-unit id="dcadd2f97f65d20e36f2d943423cf05c3a58f7a2" translate="yes" xml:space="preserve">
          <source>The building represents our program&amp;rsquo;s nested scope ruleset. The first
  floor of the building represents your currently executing scope,
  wherever you are. The top level of the building is the global scope.
  You resolve LHS and RHS references by looking on your current floor,
  and if you don&amp;rsquo;t find it, taking the elevator to the next floor,
  looking there, then the next, and so on. Once you get to the top floor
  (the global scope), you either find what you&amp;rsquo;re looking for, or you
  don&amp;rsquo;t. But you have to stop regardless.</source>
          <target state="translated">El edificio representa el conjunto de reglas de alcance anidado de nuestro programa. El primer piso del edificio representa su alcance actual en ejecuci&amp;oacute;n, est&amp;eacute; donde est&amp;eacute;. El nivel superior del edificio es el alcance global. Usted resuelve las referencias de LHS y RHS mirando su piso actual, y si no lo encuentra, tome el elevador al siguiente piso, mire all&amp;iacute;, luego al siguiente, y as&amp;iacute; sucesivamente. Una vez que llegue al piso superior (el alcance global), encontrar&amp;aacute; lo que est&amp;aacute; buscando o no. Pero tienes que parar de todos modos.</target>
        </trans-unit>
        <trans-unit id="cdc0afcc10d38d1828b1ade5ac3c30395d6075f9" translate="yes" xml:space="preserve">
          <source>The following prints &lt;code&gt;5&lt;/code&gt;, five times, and then prints &lt;code&gt;5&lt;/code&gt; for an sixth time for the &lt;code&gt;console.log&lt;/code&gt; outside the loop:</source>
          <target state="translated">Lo siguiente imprime &lt;code&gt;5&lt;/code&gt; , cinco veces y luego imprime &lt;code&gt;5&lt;/code&gt; por sexta vez para el &lt;code&gt;console.log&lt;/code&gt; fuera del bucle:</target>
        </trans-unit>
        <trans-unit id="f640071ac23c5f0d26b8e3ca4e3b7d965b5b7397" translate="yes" xml:space="preserve">
          <source>The following prints &lt;code&gt;undefined&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is block-scoped. The callbacks are run one by one asynchronously. New behavior for &lt;code&gt;let&lt;/code&gt; variables means that each anonymous function closed over a different variable named &lt;code&gt;x&lt;/code&gt; (unlike it would have done with &lt;code&gt;var&lt;/code&gt;), and so integers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt; are printed.:</source>
          <target state="translated">Las siguientes impresiones &lt;code&gt;undefined&lt;/code&gt; porque &lt;code&gt;x&lt;/code&gt; tiene un alcance de bloque. Las devoluciones de llamada se ejecutan una por una de forma asincr&amp;oacute;nica. El nuevo comportamiento para las variables &lt;code&gt;let&lt;/code&gt; significa que cada funci&amp;oacute;n an&amp;oacute;nima se cerr&amp;oacute; sobre una variable diferente llamada &lt;code&gt;x&lt;/code&gt; (a diferencia de lo que habr&amp;iacute;a hecho con &lt;code&gt;var&lt;/code&gt; ), por lo que se imprimen los enteros &lt;code&gt;0&lt;/code&gt; a &lt;code&gt;4&lt;/code&gt; . :</target>
        </trans-unit>
        <trans-unit id="07a69d238d156e701c5a367c6a5485165dd070e3" translate="yes" xml:space="preserve">
          <source>The following will NOT throw a &lt;code&gt;ReferenceError&lt;/code&gt; because the visibility of &lt;code&gt;x&lt;/code&gt; is not constrained by the block; it will, however, print &lt;code&gt;undefined&lt;/code&gt; because the variable has not been initialised (because of the &lt;code&gt;if&lt;/code&gt; statement).</source>
          <target state="translated">Lo siguiente NO arrojar&amp;aacute; un Error de &lt;code&gt;ReferenceError&lt;/code&gt; porque la visibilidad de &lt;code&gt;x&lt;/code&gt; no est&amp;aacute; limitada por el bloque; sin embargo, se imprimir&amp;aacute; &lt;code&gt;undefined&lt;/code&gt; porque la variable no se ha inicializado (debido a la instrucci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="05ba3ae9dd9b32ddf42ae7069862c90654d442fa" translate="yes" xml:space="preserve">
          <source>The following will declare a property on the global object, because variables declared using &lt;code&gt;var&lt;/code&gt; within the global context, are added as properties to the global object:</source>
          <target state="translated">Lo siguiente declarar&amp;aacute; una propiedad en el objeto global, porque las variables declaradas usando &lt;code&gt;var&lt;/code&gt; dentro del contexto global, se agregan como propiedades al objeto global:</target>
        </trans-unit>
        <trans-unit id="56e352b3854a340ef82e660d524c84e0929a85f3" translate="yes" xml:space="preserve">
          <source>The following will throw a &lt;code&gt;ReferenceError&lt;/code&gt; because the visibility of &lt;code&gt;x&lt;/code&gt; is constrained by the block:</source>
          <target state="translated">Lo siguiente arrojar&amp;aacute; un &lt;code&gt;ReferenceError&lt;/code&gt; porque la visibilidad de &lt;code&gt;x&lt;/code&gt; est&amp;aacute; limitada por el bloque:</target>
        </trans-unit>
        <trans-unit id="916178c1871c4ad706738ee8325f52860cf80126" translate="yes" xml:space="preserve">
          <source>The following will throw a ReferenceError because the names&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; have no meaning outside of the function &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Lo siguiente arrojar&amp;aacute; un ReferenceError porque los nombres &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; no tienen significado fuera de la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c15f36c25910e782b2fb893c1b27cfa365282f76" translate="yes" xml:space="preserve">
          <source>The following will throw a ReferenceError for &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;, but not for &lt;code&gt;x&lt;/code&gt;, because the visibility of &lt;code&gt;x&lt;/code&gt; is not constrained by the block. Blocks that define the bodies of control structures like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;, behave similarly.</source>
          <target state="translated">Lo siguiente arrojar&amp;aacute; un ReferenceError para &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;z&lt;/code&gt; , pero no para &lt;code&gt;x&lt;/code&gt; , porque la visibilidad de &lt;code&gt;x&lt;/code&gt; no est&amp;aacute; limitada por el bloque. Los bloques que definen los cuerpos de las estructuras de control, como &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; y &lt;code&gt;while&lt;/code&gt; , se comportan de manera similar.</target>
        </trans-unit>
        <trans-unit id="35ea475fa01e3a75809f9d5a47ee4846fc35e629" translate="yes" xml:space="preserve">
          <source>The four scopes are:</source>
          <target state="translated">Los cuatro alcances son:</target>
        </trans-unit>
        <trans-unit id="667c33893d889bc80fd5ed9df2f266c2588c1bb5" translate="yes" xml:space="preserve">
          <source>The idea of scoping in JavaScript when originally designed by &lt;a href=&quot;https://en.wikipedia.org/wiki/Brendan_Eich&quot;&gt;Brendan Eich&lt;/a&gt; came from the &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperCard&quot;&gt;HyperCard&lt;/a&gt; scripting language &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperTalk&quot;&gt;HyperTalk&lt;/a&gt;.</source>
          <target state="translated">La idea de definir el alcance en JavaScript cuando fue dise&amp;ntilde;ada originalmente por &lt;a href=&quot;https://en.wikipedia.org/wiki/Brendan_Eich&quot;&gt;Brendan Eich&lt;/a&gt; surgi&amp;oacute; del lenguaje de script &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperCard&quot;&gt;HyperCard&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperTalk&quot;&gt;HyperTalk&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f6410942035541f508ed90e604fa26f865ffb4a" translate="yes" xml:space="preserve">
          <source>The key, as I understand it, is that Javascript has function level scoping vs the more common C block scoping.</source>
          <target state="translated">La clave,tal y como yo lo entiendo,es que Javascript tiene un alcance a nivel de función frente al alcance más común del bloque C.</target>
        </trans-unit>
        <trans-unit id="baa8f0251c2ad4e18b3c034ad72ce894cbff4fc8" translate="yes" xml:space="preserve">
          <source>The same concepts of lexically scope and scopechain still apply in &lt;code&gt;ES6&lt;/code&gt;. However a new ways to declare variables were introduced. There are the following:</source>
          <target state="translated">Los mismos conceptos de &amp;aacute;mbito l&amp;eacute;xico y &amp;aacute;mbito de aplicaci&amp;oacute;n todav&amp;iacute;a se aplican en &lt;code&gt;ES6&lt;/code&gt; . Sin embargo, se introdujeron nuevas formas de declarar variables. Existen los siguientes:</target>
        </trans-unit>
        <trans-unit id="1facbc7c1c1f813cff549c1dd5c9ee65e8b26f21" translate="yes" xml:space="preserve">
          <source>The scope of the variables that an &lt;code&gt;on*&lt;/code&gt; attribute can reference &lt;em&gt;must&lt;/em&gt; be either:</source>
          <target state="translated">El alcance de las variables a las que puede hacer referencia un atributo &lt;code&gt;on*&lt;/code&gt; &lt;em&gt;debe&lt;/em&gt; ser:</target>
        </trans-unit>
        <trans-unit id="a525d3c4347396db376dab57fb2b417bb3d3c520" translate="yes" xml:space="preserve">
          <source>The this binding will point to the containing object. Sometimes scopes or execution contexts change without the containing object changing, such as in a declared function where the containing object may be &lt;code&gt;window&lt;/code&gt; or a constructor function.</source>
          <target state="translated">El enlace this apuntar&amp;aacute; al objeto contenedor. A veces, los &amp;aacute;mbitos o los contextos de ejecuci&amp;oacute;n cambian sin que cambie el objeto contenedor, como en una funci&amp;oacute;n declarada donde el objeto contenedor puede ser una &lt;code&gt;window&lt;/code&gt; o una funci&amp;oacute;n constructora.</target>
        </trans-unit>
        <trans-unit id="2d36f4ed020b3d4b8edb17fc4c526b8cb4fb6d80" translate="yes" xml:space="preserve">
          <source>The top level of an ES6 module is similar to that of the inside of an IIFE on the top level in a normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;. The module can reference any variables which are global, and nothing can reference anything inside the module unless the module is explicitly designed for it.</source>
          <target state="translated">El nivel superior de un m&amp;oacute;dulo ES6 es similar al del interior de un IIFE en el nivel superior en un &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; normal. El m&amp;oacute;dulo puede hacer referencia a cualquier variable que sea global, y nada puede hacer referencia a nada dentro del m&amp;oacute;dulo a menos que el m&amp;oacute;dulo est&amp;eacute; espec&amp;iacute;ficamente dise&amp;ntilde;ado para &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="7125f4b24be7f56c5a5737818cdbed770efa08f5" translate="yes" xml:space="preserve">
          <source>The top of a control structure (eg. loop, if, while etc)</source>
          <target state="translated">La parte superior de una estructura de control (por ejemplo,bucle,si,mientras,etc.)</target>
        </trans-unit>
        <trans-unit id="ec84a003493d5f7ad27772f7fadcf69a38c15e22" translate="yes" xml:space="preserve">
          <source>The top of the stack takes precedence (the bottom being the global context)</source>
          <target state="translated">La parte superior de la pila tiene prioridad (la parte inferior es el contexto global)</target>
        </trans-unit>
        <trans-unit id="e5147662f95f20c6a0a89a3a7abbdb020dd6c0a5" translate="yes" xml:space="preserve">
          <source>There are ALMOST only two types of JavaScript scopes:</source>
          <target state="translated">Casi sólo hay dos tipos de alcances de JavaScript:</target>
        </trans-unit>
        <trans-unit id="eb06dfbee4e2593fde4a86d0b540f447341e7d7e" translate="yes" xml:space="preserve">
          <source>There are only function scopes in JS. Not block scopes!
You can see what is hoisting too.</source>
          <target state="translated">Sólo hay alcances de función en JS.¡No los visores de bloqueo! Puedes ver lo que se está elevando también.</target>
        </trans-unit>
        <trans-unit id="06ad5b6a8156a5d1e0ba464b34addb7c1635409b" translate="yes" xml:space="preserve">
          <source>There are three pertinent factors in deciding the &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_(computer_science)&quot;&gt;scope&lt;/a&gt; of an &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords&quot;&gt;identifier&lt;/a&gt; in JavaScript:</source>
          <target state="translated">Hay tres factores pertinentes para decidir el &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_(computer_science)&quot;&gt;alcance&lt;/a&gt; de un &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords&quot;&gt;identificador&lt;/a&gt; en JavaScript:</target>
        </trans-unit>
        <trans-unit id="9f972bb206c8387750ed69130eeb77040dd103a2" translate="yes" xml:space="preserve">
          <source>There are two types of scopes in JavaScript.</source>
          <target state="translated">Hay dos tipos de alcances en JavaScript.</target>
        </trans-unit>
        <trans-unit id="e1a1af2ae159fa99a59c517a33be2803648d6f2f" translate="yes" xml:space="preserve">
          <source>These are some browsers that don't support &lt;code&gt;let&lt;/code&gt; at all :</source>
          <target state="translated">Estos son algunos navegadores que no admiten &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4157cf90189663de2f2e49ae60f774e33bc5176b" translate="yes" xml:space="preserve">
          <source>These execution contexts are created any time control is transferred. Control is transferred when code begins to execute, and this is primarily done from function execution.</source>
          <target state="translated">Estos contextos de ejecución se crean cada vez que se transfiere el control de tiempo.El control se transfiere cuando el código comienza a ejecutarse,y esto se hace principalmente desde la ejecución de la función.</target>
        </trans-unit>
        <trans-unit id="fcd7046418deb6ee5f24a080449c0d25ed0ec8aa" translate="yes" xml:space="preserve">
          <source>These linked lexical environments form a scope &quot;chain&quot;. Identifier resolution is the process of searching along this chain for a matching identifier.</source>
          <target state="translated">Estos entornos léxicos vinculados forman una &quot;cadena&quot; de alcance.La resolución del identificador es el proceso de búsqueda a lo largo de esta cadena de un identificador que coincida.</target>
        </trans-unit>
        <trans-unit id="523f7d75f219807a90812d1a03a76d634bd34fc6" translate="yes" xml:space="preserve">
          <source>This idea of &quot;scope levels&quot; explains why &quot;this&quot; can be changed with a newly created scope, if it's being looked up in a nested function.
Here is a link that goes into all these details, &lt;a href=&quot;https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/&quot;&gt;Everything you wanted to know about javascript scope&lt;/a&gt;</source>
          <target state="translated">Esta idea de &quot;niveles de alcance&quot; explica por qu&amp;eacute; &quot;esto&quot; se puede cambiar con un alcance reci&amp;eacute;n creado, si se busca en una funci&amp;oacute;n anidada. Aqu&amp;iacute; hay un enlace que incluye todos estos detalles. &lt;a href=&quot;https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/&quot;&gt;Todo lo que quer&amp;iacute;a saber sobre el alcance de JavaScript.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88c46fe2afcb6c5ec1d4bbaa556544f6c35d6851" translate="yes" xml:space="preserve">
          <source>This is exactly how the JavaScript scoping system is designed. It just has different names. The cards in JavaScript are known as &lt;strong&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;Execution Contexts&lt;sup&gt;ECMA&lt;/sup&gt;&lt;/a&gt;&lt;/strong&gt;. Each one of these contexts contains three main parts. A variable environment, a lexical environment, and a this binding. Going back to the cards reference, the lexical environment contains all of the content from prior cards lower in the stack. The current context is at the top of the stack and any content declared there will be stored in the variable environment. The variable environment will take precedence in the case of naming collisions.</source>
          <target state="translated">As&amp;iacute; es exactamente c&amp;oacute;mo est&amp;aacute; dise&amp;ntilde;ado el sistema de alcance de JavaScript. Solo tiene diferentes nombres. Las tarjetas en JavaScript se conocen como &lt;strong&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;contextos de ejecuci&amp;oacute;n &lt;sup&gt;ECMA&lt;/sup&gt;&lt;/a&gt;&lt;/strong&gt; . Cada uno de estos contextos contiene tres partes principales. Un entorno variable, un entorno l&amp;eacute;xico y un enlace de este. Volviendo a la referencia de las tarjetas, el entorno l&amp;eacute;xico contiene todo el contenido de las tarjetas anteriores m&amp;aacute;s abajo en la pila. El contexto actual est&amp;aacute; en la parte superior de la pila y cualquier contenido declarado all&amp;iacute; se almacenar&amp;aacute; en el entorno variable. El entorno variable tendr&amp;aacute; prioridad en el caso de colisiones de nombres.</target>
        </trans-unit>
        <trans-unit id="f86bca7d7675134768be73474570815258963447" translate="yes" xml:space="preserve">
          <source>This may seem counter intuitive, but it makes sense from the perspective of a imperative language designer.</source>
          <target state="translated">Esto puede parecer contraintuitivo,pero tiene sentido desde la perspectiva de un diseñador de lenguaje imperativo.</target>
        </trans-unit>
        <trans-unit id="9569372657d997762301d2a05e690ebc258d5cc1" translate="yes" xml:space="preserve">
          <source>Thus, in JavaScript, scope is implemented via lexical environments linked together in a &quot;chain&quot; by outer references. This chain of lexical environments is called the scope chain, and identifier resolution occurs by &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference&quot;&gt;searching up the chain&lt;/a&gt; for a matching identifier.</source>
          <target state="translated">Por lo tanto, en JavaScript, el alcance se implementa a trav&amp;eacute;s de entornos l&amp;eacute;xicos unidos en una &quot;cadena&quot; por referencias externas. Esta cadena de entornos l&amp;eacute;xicos se denomina cadena de alcance, y la resoluci&amp;oacute;n del identificador se produce &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference&quot;&gt;buscando en la cadena&lt;/a&gt; un identificador coincidente.</target>
        </trans-unit>
        <trans-unit id="bb6c7e872133e98aeb218ad6ea9c62cee6491672" translate="yes" xml:space="preserve">
          <source>To understand the difference between functional scope and block scope, consider the following code :</source>
          <target state="translated">Para entender la diferencia entre el alcance funcional y el alcance de bloque,considere el siguiente código :</target>
        </trans-unit>
        <trans-unit id="0163360cc80ec2993c1c8f16533f6de416e326dd" translate="yes" xml:space="preserve">
          <source>Traditionally, JavaScript really only has two types of scope :</source>
          <target state="translated">Tradicionalmente,JavaScript sólo tiene dos tipos de alcance:</target>
        </trans-unit>
        <trans-unit id="87b058d74fbe7f22fbb0efb4d9425bc6faa878b9" translate="yes" xml:space="preserve">
          <source>Traditionally, you create your variables like this :</source>
          <target state="translated">Tradicionalmente,creas tus variables así:</target>
        </trans-unit>
        <trans-unit id="ad29238d291882475644003da99e61f8bc49a03b" translate="yes" xml:space="preserve">
          <source>Try the feature at:</source>
          <target state="translated">Pruebe la función en:</target>
        </trans-unit>
        <trans-unit id="2c33461d5cae3061ba752f33725ddcdee0745df3" translate="yes" xml:space="preserve">
          <source>Try this curious example. In the example below if a were a numeric initialized at 0, you'd see 0 and then 1. Except a is an object and javascript will pass f1 a pointer of a rather than a copy of it. The result is that you get the same alert both times.</source>
          <target state="translated">Pruebe este curioso ejemplo.En el siguiente ejemplo si a fuera un numérico inicializado en 0,verías 0 y luego 1.Excepto que a es un objeto y javascript le pasará a f1 un puntero de a en vez de una copia de él.El resultado es que obtienes la misma alerta ambas veces.</target>
        </trans-unit>
        <trans-unit id="9a31c380e5d5713a5b5f2cac2a38ce95810e231c" translate="yes" xml:space="preserve">
          <source>Using functions instead:</source>
          <target state="translated">Usando funciones en su lugar:</target>
        </trans-unit>
        <trans-unit id="09e07e786d7ad2ec030bf960813f71d135a77b77" translate="yes" xml:space="preserve">
          <source>Variables declared globally have a global scope. Variables declared within a function are scoped to that function, and shadow global variables of the same name.</source>
          <target state="translated">Las variables declaradas a nivel mundial tienen un alcance global.Las variables declaradas dentro de una función tienen un alcance a esa función,y sombrean las variables globales del mismo nombre.</target>
        </trans-unit>
        <trans-unit id="83f6135eb31f7889cc2bae9bf00eaae24a2268d7" translate="yes" xml:space="preserve">
          <source>Variables declared using &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; are all scoped to modules:</source>
          <target state="translated">Las variables declaradas usando &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; o &lt;code&gt;const&lt;/code&gt; tienen un alcance para los m&amp;oacute;dulos:</target>
        </trans-unit>
        <trans-unit id="e63da6c1c1854a483ec37bd48437243581e43830" translate="yes" xml:space="preserve">
          <source>Variables in Javascript were initially (pre &lt;code&gt;ES6&lt;/code&gt;) lexically function scoped. The term lexically scoped means that you can see the scope of the variables by 'looking' at the code.</source>
          <target state="translated">Las variables en Javascript ten&amp;iacute;an inicialmente (pre &lt;code&gt;ES6&lt;/code&gt; ) un &amp;aacute;mbito de funci&amp;oacute;n l&amp;eacute;xica. El t&amp;eacute;rmino de &amp;aacute;mbito l&amp;eacute;xico significa que puede ver el alcance de las variables 'mirando' el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="79b5a1ec62a5c78bf7572a8c6548c2e713ed3a8a" translate="yes" xml:space="preserve">
          <source>View the code at:</source>
          <target state="translated">Vea el código en:</target>
        </trans-unit>
        <trans-unit id="d113eb702e389cf7c505ecfecd3bb29698f276f3" translate="yes" xml:space="preserve">
          <source>We try to log bar to the console, bar cannot be found inside the function &lt;code&gt;innerFunc&lt;/code&gt; itself. Therefore, we need to &lt;strong&gt;climb the scope chain&lt;/strong&gt;. We first look in the outer function in which the function &lt;code&gt;innerFunc&lt;/code&gt; was defined. This is the function &lt;code&gt;outerFunc&lt;/code&gt;. In the scope of &lt;code&gt;outerFunc&lt;/code&gt; we can find the variable bar, which holds the string 'outerFunc'.</source>
          <target state="translated">Intentamos registrar la barra en la consola, la barra no se puede encontrar dentro de la funci&amp;oacute;n &lt;code&gt;innerFunc&lt;/code&gt; . Por lo tanto, necesitamos &lt;strong&gt;escalar la cadena de alcance&lt;/strong&gt; . Primero observamos la funci&amp;oacute;n externa en la que se defini&amp;oacute; la funci&amp;oacute;n &lt;code&gt;innerFunc&lt;/code&gt; . Esta es la funci&amp;oacute;n &lt;code&gt;outerFunc&lt;/code&gt; . En el alcance de &lt;code&gt;outerFunc&lt;/code&gt; podemos encontrar la barra variable, que contiene la cadena 'outsideFunc'.</target>
        </trans-unit>
        <trans-unit id="33483a29e47769decbe475c651c75e62bcc26c1d" translate="yes" xml:space="preserve">
          <source>We try to log foo to the console, foo can be found inside the function &lt;code&gt;innerFunc&lt;/code&gt; itself. Therefore, the value of foo is resolved to the string &lt;code&gt;innerFunc&lt;/code&gt;.</source>
          <target state="translated">Intentamos iniciar sesi&amp;oacute;n en la consola, se puede encontrar dentro de la funci&amp;oacute;n &lt;code&gt;innerFunc&lt;/code&gt; . Por lo tanto, el valor de foo se resuelve en la cadena &lt;code&gt;innerFunc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f557bb3c7aec4df772e0ff73b2192b0c2d60c84e" translate="yes" xml:space="preserve">
          <source>What happens when we are trying to log the variables &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;foobar&lt;/code&gt; to the console is the following:</source>
          <target state="translated">Lo que sucede cuando intentamos registrar las variables &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; y &lt;code&gt;foobar&lt;/code&gt; en la consola es lo siguiente:</target>
        </trans-unit>
        <trans-unit id="9b903fe3f970849861b225b53f498c1947e65555" translate="yes" xml:space="preserve">
          <source>What is the scope of variables in JavaScript</source>
          <target state="translated">¿Cuál es el alcance de las variables en JavaScript</target>
        </trans-unit>
        <trans-unit id="c23272951273b7fc083d376b564db88d3610470d" translate="yes" xml:space="preserve">
          <source>What is the scope of variables in javascript? Do they have the same scope inside as opposed to outside a function? Or does it even matter? Also, where are the variables stored if they are defined globally?</source>
          <target state="translated">¿Cuál es el alcance de las variables en javascript? ¿Tienen el mismo alcance dentro que fuera de una función? ¿O incluso importa? Además,¿dónde se almacenan las variables si se definen globalmente?</target>
        </trans-unit>
        <trans-unit id="8bd7003d51c50f3c8761d33449fe913c8f8cac5b" translate="yes" xml:space="preserve">
          <source>When a function look to resolve a variable value it first looks at its own scope. This is the function body, i.e. everything between curly brackets {} (except for variables inside &lt;strong&gt;other&lt;/strong&gt;&lt;strong&gt;functions&lt;/strong&gt; which are in this scope).</source>
          <target state="translated">Cuando una funci&amp;oacute;n busca resolver un valor variable, primero mira su propio alcance. Este es el cuerpo de la funci&amp;oacute;n, es decir, todo entre llaves {} (excepto las variables dentro de &lt;strong&gt;otras&lt;/strong&gt; &lt;strong&gt;funciones&lt;/strong&gt; que est&amp;aacute;n en este &amp;aacute;mbito).</target>
        </trans-unit>
        <trans-unit id="7b320f88c37b5d9ddd50505ed7068dbeb83bd406" translate="yes" xml:space="preserve">
          <source>When resolving a variable, javascript starts at the innermost scope and searches outwards.</source>
          <target state="translated">Cuando se resuelve una variable,javascript comienza en el ámbito más interno y busca hacia afuera.</target>
        </trans-unit>
        <trans-unit id="d7cb4beab01b349af01d024bbaf1102dfb872104" translate="yes" xml:space="preserve">
          <source>When you invoke a function, the hidden &lt;code&gt;[[Call]]&lt;/code&gt; method is called. This method creates a new execution context and establishes a link between the new execution context and the lexical environment of the function-object. It does this by copying the &lt;code&gt;[[Environment]]&lt;/code&gt; value on the function-object, into an &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;outer reference&lt;/a&gt; field on the lexical environment of the new execution context.</source>
          <target state="translated">Cuando invocas una funci&amp;oacute;n, se llama al m&amp;eacute;todo oculto &lt;code&gt;[[Call]]&lt;/code&gt; . Este m&amp;eacute;todo crea un nuevo contexto de ejecuci&amp;oacute;n y establece un v&amp;iacute;nculo entre el nuevo contexto de ejecuci&amp;oacute;n y el entorno l&amp;eacute;xico del objeto de funci&amp;oacute;n. Lo hace copiando el valor &lt;code&gt;[[Environment]]&lt;/code&gt; en el objeto de funci&amp;oacute;n, en un campo de &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;referencia externo&lt;/a&gt; en el entorno l&amp;eacute;xico del nuevo contexto de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c96ef28eb7eabf77773b3a19be2f5414a421175a" translate="yes" xml:space="preserve">
          <source>Where an identifier was declared</source>
          <target state="translated">Cuando se declaró un identificador</target>
        </trans-unit>
        <trans-unit id="db4779584d083e695bd0cf37cd44aa1429a309bc" translate="yes" xml:space="preserve">
          <source>Whether or not it is safe to use today, depends on your environment :</source>
          <target state="translated">Si es o no seguro de usar hoy en día,depende de su entorno:</target>
        </trans-unit>
        <trans-unit id="98f46dd1a1ed53e1e44f3ab136ef987e105853e9" translate="yes" xml:space="preserve">
          <source>Whether you are in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;strict mode&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode&quot;&gt;non-strict mode&lt;/a&gt;</source>
          <target state="translated">Si est&amp;aacute; en &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;modo estricto&lt;/a&gt; o &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode&quot;&gt;no estricto&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="866faa243c8cb14d4f4502051230db635e4581a1" translate="yes" xml:space="preserve">
          <source>Window level - &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;outer&lt;/code&gt; function are at top level in scope chain.</source>
          <target state="translated">Nivel de ventana: &lt;code&gt;a&lt;/code&gt; funci&amp;oacute;n &lt;code&gt;outer&lt;/code&gt; est&amp;aacute; en el nivel superior de la cadena de alcance.</target>
        </trans-unit>
        <trans-unit id="61285999208212a66bb8fb8f69cb29c51fc58afb" translate="yes" xml:space="preserve">
          <source>Yikes!  Be careful using 'with' -- just like var is a noop if the variable is already defined in the function, it is also a noop with respect to names imported from the object!  A little heads up on the name already being defined would make this much safer.  I personally will never use with because of this.</source>
          <target state="translated">¡Caramba! Ten cuidado con el uso de 'con'-al igual que var es un noop si la variable ya está definida en la función,también es un noop con respecto a los nombres importados del objeto! Un pequeño aviso sobre el nombre que ya está definido haría esto mucho más seguro.que yo personalmente nunca usaré por esto.</target>
        </trans-unit>
        <trans-unit id="653677cec5274421cb19c2c9eb0bf04f82dca290" translate="yes" xml:space="preserve">
          <source>You should be using block scoping for every variable you create, just like most other major languages. &lt;code&gt;var&lt;/code&gt; is &lt;em&gt;obsolete&lt;/em&gt;. This makes your code safer and more maintainable.</source>
          <target state="translated">Deber&amp;iacute;a utilizar el alcance de bloque para cada variable que cree, al igual que la mayor&amp;iacute;a de los otros idiomas principales. &lt;code&gt;var&lt;/code&gt; es &lt;em&gt;obsoleto&lt;/em&gt; Esto hace que su c&amp;oacute;digo sea m&amp;aacute;s seguro y m&amp;aacute;s f&amp;aacute;cil de mantener.</target>
        </trans-unit>
        <trans-unit id="98d045c503931bcf6ef7f9b40c8422ec1ba5b590" translate="yes" xml:space="preserve">
          <source>You'll want to investigate closures, and how to use them to make &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;private members&lt;/a&gt;.</source>
          <target state="translated">Querr&amp;aacute;s investigar los cierres y c&amp;oacute;mo usarlos para hacer &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;miembros privados&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b63f2d6c0c543f4dd14dae138ce110ce4819bafe" translate="yes" xml:space="preserve">
          <source>a property of the document (eg, &lt;code&gt;querySelector&lt;/code&gt; as a standalone variable will point to &lt;code&gt;document.querySelector&lt;/code&gt;; rare)</source>
          <target state="translated">una propiedad del documento (por ejemplo, &lt;code&gt;querySelector&lt;/code&gt; como una variable independiente apuntar&amp;aacute; a &lt;code&gt;document.querySelector&lt;/code&gt; ; raro)</target>
        </trans-unit>
        <trans-unit id="fceff746a314cc08e9d118ad4bd96fa755c80556" translate="yes" xml:space="preserve">
          <source>a property of the element the handler is attached to (like above; rare)</source>
          <target state="translated">una propiedad del elemento al que el manipulador está unido (como arriba;raro)</target>
        </trans-unit>
        <trans-unit id="822bc13e2d55b402eb4233cb23c9d414a7a03bc1" translate="yes" xml:space="preserve">
          <source>eval</source>
          <target state="translated">eval</target>
        </trans-unit>
        <trans-unit id="48a783d527b12bb1b6d12822df507e3056d403cb" translate="yes" xml:space="preserve">
          <source>foobar cannot be found in innerFunc. . Therefore, we need to &lt;strong&gt;climb the scope chain&lt;/strong&gt; to the innerFunc scope. It also cannot be found here, we climb another level to the &lt;strong&gt;global scope&lt;/strong&gt; (i.e. the outermost scope). We find the variable foobar here which holds the string 'global'. If it wouldnot have found the variable after climbing the scope chain the JS engine would throw a &lt;strong&gt;referenceError&lt;/strong&gt;.</source>
          <target state="translated">foobar no se puede encontrar en innerFunc. . Por lo tanto, necesitamos &lt;strong&gt;escalar la cadena de alcance&lt;/strong&gt; al alcance innerFunc. Tampoco se puede encontrar aqu&amp;iacute;, subimos otro nivel al &lt;strong&gt;alcance global&lt;/strong&gt; (es decir, el alcance m&amp;aacute;s externo). Aqu&amp;iacute; encontramos la variable foobar que contiene la cadena 'global'. Si no hubiera encontrado la variable despu&amp;eacute;s de subir la cadena de alcance, el motor JS arrojar&amp;iacute;a un error de &lt;strong&gt;referencia&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="887ec4e4d84f875ed30e16b3b555dc44c974324c" translate="yes" xml:space="preserve">
          <source>global (working inline handlers almost always reference global variables)</source>
          <target state="translated">global (los manipuladores en línea que trabajan casi siempre hacen referencia a variables globales)</target>
        </trans-unit>
        <trans-unit id="7344f99b192214421819b3d6d5d5eb925e77386f" translate="yes" xml:space="preserve">
          <source>if there is no enclosing function for a var declaration, it is global scope</source>
          <target state="translated">si no hay una función adjunta para una declaración var,es de alcance global</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">es equivalente a:</target>
        </trans-unit>
        <trans-unit id="fb722bbe2d7de5616bde8841cec1f7151c36e813" translate="yes" xml:space="preserve">
          <source>let and const</source>
          <target state="translated">dejar y constatar</target>
        </trans-unit>
        <trans-unit id="ff9c22082a2b010df2415de1fe69a90317ccdf1c" translate="yes" xml:space="preserve">
          <source>multiple var declarations within the same scope are combined</source>
          <target state="translated">se combinan múltiples declaraciones var dentro del mismo ámbito</target>
        </trans-unit>
        <trans-unit id="222f16742f8432d094b140df773f638f634a3fe5" translate="yes" xml:space="preserve">
          <source>run the code. hope this will give an idea about scoping</source>
          <target state="translated">Ejecute el código.Espero que esto le dé una idea sobre el alcance</target>
        </trans-unit>
        <trans-unit id="e50c3161b714f4fa46bad3943d0cfb3418bf98a5" translate="yes" xml:space="preserve">
          <source>test1 is scoped to the with block, but is aliased to a.test1.  'Var test1' creates a new variable test1 in the upper lexical context (function, or global), unless it is a property of a -- which it is.</source>
          <target state="translated">El test1 se extiende al bloque con,pero se aliena a a.test1.'Var test1' crea una nueva variable test1 en el contexto léxico superior (función,o global),a menos que sea una propiedad de a...que lo sea.</target>
        </trans-unit>
        <trans-unit id="7c5e5564e501683f6afb89ae0a4affd1e86cdeb1" translate="yes" xml:space="preserve">
          <source>the scope of each var declaration is associated with the most immediately enclosing function</source>
          <target state="translated">el alcance de cada declaración var se asocia con la función más inmediata que encierra</target>
        </trans-unit>
        <trans-unit id="a4ebaeeee765207f3a08fde4e0bf36e28958ad9a" translate="yes" xml:space="preserve">
          <source>try/catch introduce new scope ONLY for the exception variable itself, other variables do not have new scope</source>
          <target state="translated">trycatch introduce un nuevo alcance SOLO para la variable de excepción en sí misma,otras variables no tienen nuevo alcance</target>
        </trans-unit>
        <trans-unit id="e5b4e786e382d03c28e9edfab2d8149378ae69df" translate="yes" xml:space="preserve">
          <source>var</source>
          <target state="translated">var</target>
        </trans-unit>
        <trans-unit id="7357ecfa390afc2fce34c3167335bf743c442659" translate="yes" xml:space="preserve">
          <source>var declarations are hoisted to the top of the scope. This means no matter where the var declaration happens, to the compiler it is as if the var itself happens at the top</source>
          <target state="translated">Las declaraciones de los varones se elevan a la parte superior del alcance.Esto significa que no importa dónde ocurra la declaración var,para el compilador es como si la var misma ocurriera en la parte superior</target>
        </trans-unit>
        <trans-unit id="80e40e219ee78a38babf8cce499fd3cb0f6182af" translate="yes" xml:space="preserve">
          <source>when outer function called a new &lt;code&gt;variable scope object&lt;/code&gt;(and included in scope chain) added with variable &lt;code&gt;b&lt;/code&gt; inside it.</source>
          <target state="translated">cuando la funci&amp;oacute;n externa llama un nuevo &lt;code&gt;variable scope object&lt;/code&gt; (e incluido en la cadena de alcance) agregado con la variable &lt;code&gt;b&lt;/code&gt; dentro de &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="5b3cb00aa7dfc23400daf50a18606b8161567f7b" translate="yes" xml:space="preserve">
          <source>with-clause apparently is another exception, but using with-clause it highly discouraged (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&lt;/a&gt;)</source>
          <target state="translated">La cl&amp;aacute;usula with aparentemente es otra excepci&amp;oacute;n, pero el uso de la cl&amp;aacute;usula with es muy desaconsejable ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&lt;/a&gt; )</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
