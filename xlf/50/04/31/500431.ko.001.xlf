<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/500431">
    <body>
      <group id="500431">
        <trans-unit id="b2b80089f01682b9f7777a6969b9faaa80407f05" translate="yes" xml:space="preserve">
          <source>(I'm sure there are many subtleties that real JavaScript programmers will be able to point out in other answers. In particular I came across &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;this page&lt;/a&gt; about what exactly &lt;code&gt;this&lt;/code&gt; means at any time. Hopefully &lt;a href=&quot;http://bowles.byethost3.com/javascript/section6/lesson6.htm#part4&quot;&gt;this more introductory link&lt;/a&gt; is enough to get you started though.)</source>
          <target state="translated">(실제 JavaScript 프로그래머가 다른 답변에서 지적 할 수있는 많은 미묘한 점이 있다고 확신합니다. 특히 언제든지 이것이 정확히 무엇을 의미하는지에 &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;대해이 페이지&lt;/a&gt; 를 보았습니다. 그러나.)</target>
        </trans-unit>
        <trans-unit id="2b079c997f6e9e9f11e2b8533c11a4cdefaf6c17" translate="yes" xml:space="preserve">
          <source>...because of this behavior you need to be careful about closing over variables declared using &lt;code&gt;var&lt;/code&gt; in loops. There is only one instance of variable &lt;code&gt;x&lt;/code&gt; declared here, and it sits logically outside of the loop.</source>
          <target state="translated">...이 동작으로 인해 &lt;code&gt;var&lt;/code&gt; in 루프를 사용하여 선언 된 변수를 닫을 때주의해야합니다. 여기에 선언 된 변수 &lt;code&gt;x&lt;/code&gt; 의 인스턴스는 하나 뿐이며 논리적으로 루프 외부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a9084e5d3eb2e4718aab6268e78f5823849081" translate="yes" xml:space="preserve">
          <source>1) There is a global scope, a function scope, and the with and catch scopes. There is no 'block' level scope in general for variable's -- the with and the catch statements add names to their blocks.</source>
          <target state="translated">1) 전역 범위, 기능 범위 및 with 및 catch 범위가 있습니다. 변수에 대해서는 일반적으로 '블록'레벨 범위가 없습니다. with 및 catch 문은 블록에 이름을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a7c489f0a7142c687da2af2321ca060655d7e2f8" translate="yes" xml:space="preserve">
          <source>2) Scopes are nested by functions all the way to the global scope.</source>
          <target state="translated">2) 범위는 전역 범위까지 모든 기능에 의해 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="d749b9c70cd3d6ec5a37f9e5c4bb7316601c2a74" translate="yes" xml:space="preserve">
          <source>3) Properties are resolved by going through the prototype chain.  The with statement brings object property names into the lexical scope defined by the with block.</source>
          <target state="translated">3) 프로토 타입 체인을 통해 속성이 해결됩니다. with 문은 객체 속성 이름을 with 블록으로 정의 된 어휘 범위로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="08b17079c570142726687fb2c5c9bb253783c20e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES5&lt;/code&gt; and earlier:</source>
          <target state="translated">&lt;code&gt;ES5&lt;/code&gt; 이하 :</target>
        </trans-unit>
        <trans-unit id="2ac152d0029db3c7cd7c3a77df7bfef8ae5d4c57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES6&lt;/code&gt; (ES 2015) and older:</source>
          <target state="translated">&lt;code&gt;ES6&lt;/code&gt; (ES 2015) 이상 :</target>
        </trans-unit>
        <trans-unit id="c4c1a80bcfde13b5ffe96bdafa9c43b74b195f4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; should be used for &lt;strong&gt;95% of cases&lt;/strong&gt;. It makes it so the variable &lt;em&gt;reference&lt;/em&gt; can't change. Array, object, and DOM node properties can change and should likely be &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 는 &lt;strong&gt;95 %의 경우에&lt;/strong&gt; 사용해야합니다. 변수 &lt;em&gt;참조&lt;/em&gt; 를 변경할 수 없도록 만듭니다. 배열, 객체 및 DOM 노드 속성은 변경 될 수 있으며 &lt;code&gt;const&lt;/code&gt; 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="dcf0ad05684411d0af52e47d334a793a1d346e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;: creates a block scoped variable which has to be initialized and cannot be reassigned</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; : 초기화해야하고 재 할당 할 수없는 블록 범위 변수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="84d33e7ec01dc28120ceea7d7d07bb9ccda0bdcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 명세서</target>
        </trans-unit>
        <trans-unit id="f378613076c429aa47b0bc460bdfb9fd805b2aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; in the global context do not add properties to the global object, but still have global scope:</source>
          <target state="translated">전역 컨텍스트에서 &lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 는 전역 객체에 속성을 추가하지 않지만 여전히 전역 범위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="23ddb5e06f75a482ff3a507bfea2c6482c39eb0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; should be be used for any variable expecting to be reassigned. This includes within a for loop. If you ever change value beyond initialization, use &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">재 할당 될 것으로 예상되는 모든 변수에 사용해야합니다. 여기에는 for 루프가 포함됩니다. 초기화 이상으로 값을 변경 한 경우 &lt;code&gt;let&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="39836bea22536ebe1993a1b9a30ed5062e7fc910" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;: creates a block scoped variable</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; : 블록 범위 변수를 만듭니다</target>
        </trans-unit>
        <trans-unit id="f86a4d006feac6327fadfafd72bedb4b3013db57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23a7586104558b94ef7294bd102a26a3fee7bc25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;hoisted&lt;/strong&gt;&lt;/a&gt;.&lt;/em&gt; This means that declarations are always much to the top of the scope.</source>
          <target state="translated">&lt;em&gt;(*) 전역 및 기능 범위 변수는 JavaScript 변수가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;들어&lt;/strong&gt;&lt;/a&gt; 있기 때문에 선언되기 전에 초기화 및 사용할 수 있습니다.&lt;/em&gt; 이것은 선언이 항상 범위의 맨 위에 있다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f1f37e4dcff2ea462372b5383bfff8d1536133fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Whenever a function is called, a variable scope object is created (and included in scope chain) which is followed by variables in JavaScript.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;함수가 호출 될 때마다 변수 범위 개체가 만들어지고 범위 체인에 포함되며 그 뒤에 JavaScript의 변수가옵니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b4f1e280e8a84dd1613867f45aea9b5a09b5e95c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;i&lt;/em&gt;) The outer context. It has a variable environment of a = 1</source>
          <target state="translated">&lt;em&gt;i&lt;/em&gt; ) 외부 상황. 변수 환경은 a = 1입니다.</target>
        </trans-unit>
        <trans-unit id="27dcebcb7c447ec33f3b94ab4786b7e8986fc48a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ii&lt;/em&gt;) The IIFE context, it has a lexical environment of a = 1, but a variable environment of a = 6 which takes precedence in the stack</source>
          <target state="translated">&lt;em&gt;ii&lt;/em&gt; ) IIFE 컨텍스트에서 어휘 환경은 a = 1이지만 변수 환경은 = 6이며 스택에서 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f2d982053f1a3fa4551447f1adedd54422f021ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;iii&lt;/em&gt;) The returned function context, it has a lexical environment of a = 6 and that is the value referenced in the alert when called.</source>
          <target state="translated">&lt;em&gt;iii&lt;/em&gt; ) 반환 된 함수 컨텍스트는 어휘 환경이 = 6이고 호출 될 때 경고에서 참조되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="f56505ee4c5ecc9846d96be13e7dc0c3c70dfa98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Android browser 4&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;안드로이드 브라우저 4&lt;/strong&gt; 이하</target>
        </trans-unit>
        <trans-unit id="55a8f93e956bc391290a79206606d9be4627b589" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Block Scope&lt;/strong&gt; : Identifiers are &quot;known&quot; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;from the top of the scope they are declared within&lt;/a&gt;, but they cannot be assigned to or dereferenced (read) until after the line of their declaration. This interim period is called the &quot;temporal dead zone.&quot;</source>
          <target state="translated">&lt;strong&gt;블록 범위&lt;/strong&gt; : 식별자는 &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;자신이 선언 한 범위의 상단에서&lt;/a&gt; &quot;알려져&quot;있지만 선언이 끝날 때까지 식별자를 할당하거나 역 참조 (읽기) 할 수 없습니다. 이 기간을 &quot;임시 데드 존&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="2f05c56877d8601614fa63855f086a2652e865c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Chome 40&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Chome 40&lt;/strong&gt; 이하</target>
        </trans-unit>
        <trans-unit id="d99cf4a17169c81d37ec13856f6710a2a76cbbad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Firefox 43&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Firefox 43&lt;/strong&gt; 이하</target>
        </trans-unit>
        <trans-unit id="08cd2fc5597977a2613daeb7f079fd9fa0eb16b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional Scope&lt;/strong&gt; : Variable declared within a function with &lt;code&gt;var&lt;/code&gt; keyword has functional scope.</source>
          <target state="translated">&lt;strong&gt;기능 범위&lt;/strong&gt; : &lt;code&gt;var&lt;/code&gt; 키워드를 사용하여 함수 내에 선언 된 변수에는 기능 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a13963dd31b44d28a808a5e2917cae4be7b837de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional Scope&lt;/strong&gt; : Variables are known within &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;the function&lt;/strong&gt;&lt;/a&gt; they are declared in, from the start of the function &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;기능 범위&lt;/strong&gt; : 변수는 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;함수&lt;/strong&gt;&lt;/a&gt; 의 시작부터 선언 된 &lt;strong&gt;함수&lt;/strong&gt; 내 &lt;strong&gt;에서&lt;/strong&gt; 알려져 있습니다 &lt;em&gt;(*)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7298e7a71a2f69245853e050c4bdee749e978e9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional scope or Local scope&lt;/strong&gt;: variable declared in this scope can be used in its own function only. For example:</source>
          <target state="translated">&lt;strong&gt;기능 범위 또는 로컬 범위&lt;/strong&gt; :이 범위에서 선언 된 변수는 자체 기능에서만 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89e21e149d0d0dc547601ca86291fe92f9273963" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Scope&lt;/strong&gt; : Global is nothing but a window level scope.Here, variable present throughout the application.</source>
          <target state="translated">&lt;strong&gt;전역 범위&lt;/strong&gt; : 전역은 창 수준 &lt;strong&gt;범위&lt;/strong&gt; 에 지나지 않습니다. 여기서 응용 프로그램 전체에 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3a549a4e99a97eff2b34e0f09263cffa683cccd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Scope&lt;/strong&gt; : Variables are known throughout the application, from the start of the application &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;글로벌 범위&lt;/strong&gt; : 변수는 응용 프로그램 시작부터 응용 프로그램 전체에 알려져 있습니다 &lt;em&gt;(*)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1f34e4a5bfcdc48aa26833768f67160bd571124" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global scope&lt;/strong&gt;: variable which is announced in global scope can be used anywhere in the program very smoothly. For example:</source>
          <target state="translated">&lt;strong&gt;글로벌 스코프&lt;/strong&gt; : &lt;strong&gt;글로벌 스코프에&lt;/strong&gt; 공지 된 변수는 프로그램의 어느 곳에서나 매우 부드럽게 사용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7ca3efb97c36b6d88809b25331124fb1fffa069" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internet explorer 10&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;인터넷 익스플로러 10&lt;/strong&gt; 이하</target>
        </trans-unit>
        <trans-unit id="f68d935bfb76269d4c30258cf31d26f604040556" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opera 27&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;오페라 27&lt;/strong&gt; 이하</target>
        </trans-unit>
        <trans-unit id="050f7cc7d0dc2635f8b52903f766a2c3db495862" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Safari 9&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;사파리 9&lt;/strong&gt; 이하</target>
        </trans-unit>
        <trans-unit id="44e5d520bd9d0fb39f77e303b90adad358405de1" translate="yes" xml:space="preserve">
          <source>A lexical environment is a mapping between identifier names and the values associated with them.</source>
          <target state="translated">어휘 환경은 식별자 이름과 관련된 값 사이의 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="8fd51b0bd0e4f91009d0f3343c699212c3d96c96" translate="yes" xml:space="preserve">
          <source>A variable declared at the top of a &lt;code&gt;for&lt;/code&gt; loop using &lt;code&gt;let&lt;/code&gt; is scoped to the body of the loop:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 을 사용하여 &lt;code&gt;for&lt;/code&gt; 루프의 상단에 선언 된 변수의 범위는 루프의 본문입니다.</target>
        </trans-unit>
        <trans-unit id="48faefee4b09b7b96e9ee196462af3f716e8b8de" translate="yes" xml:space="preserve">
          <source>A very common issue not described yet that front-end coders often run into is the scope that is visible to an inline event handler in the HTML - for example, with</source>
          <target state="translated">프론트 엔드 코더가 자주 발생하는 매우 일반적인 문제는 HTML에서 인라인 이벤트 핸들러에 표시되는 범위입니다.</target>
        </trans-unit>
        <trans-unit id="60fc03a08e44792e776e9738812c0a4cd623a464" translate="yes" xml:space="preserve">
          <source>ANY version of &lt;strong&gt;Opera Mini&lt;/strong&gt; &amp;amp; &lt;strong&gt;Blackberry Browser&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Opera Mini&lt;/strong&gt; &amp;amp; &lt;strong&gt;Blackberry Browser&lt;/strong&gt; 의 모든 버전</target>
        </trans-unit>
        <trans-unit id="ae46cf4abc73a3b9c1f4dfacc1b829774476ba1e" translate="yes" xml:space="preserve">
          <source>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</source>
          <target state="translated">또한 블록 범위 변수는 게양되지 않았기 때문에 선언되기 전에 알 수 없습니다. 또한 동일한 블록 내에서 동일한 블록 범위 변수를 다시 선언 할 수 없습니다. 이렇게하면 블록 범위 변수가 전역 또는 기능 범위 변수보다 오류가 덜 발생합니다.이 변수는 게양되어 여러 선언의 경우 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb95f617fd60bdb566772a3a947b9cf56a0e0ee3" translate="yes" xml:space="preserve">
          <source>An element in the scope chain is basically a Map with a pointer to its parent scope.</source>
          <target state="translated">스코프 체인의 요소는 기본적으로 상위 범위에 대한 포인터가있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="2f14bc627ff3b593b8ed5e4441d9f45b15ddec5c" translate="yes" xml:space="preserve">
          <source>Applying this to one of the previous examples (5. &quot;Closure&quot;) on this page, it is possible to follow the stack of execution contexts. In this example there are three contexts in the stack. They are defined by the outer context, the context in the immediately invoked function called by var six, and the context in the returned function inside of var six's immediately invoked function.</source>
          <target state="translated">이 페이지의 이전 예제 중 하나 (5. &quot;Closure&quot;)에 이것을 적용하면 실행 컨텍스트 스택을 따를 수 있습니다. 이 예에서는 스택에 세 가지 컨텍스트가 있습니다. 외부 컨텍스트, var six에 의해 호출 된 즉시 호출 된 함수의 컨텍스트 및 var six의 즉시 호출 된 함수 내에서 리턴 된 함수의 컨텍스트에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="425a5e8573ac9d1f6ad5077097cd879a85500359" translate="yes" xml:space="preserve">
          <source>Block - visible within a block (and its sub-blocks)</source>
          <target state="translated">블록-블록 (및 해당 하위 블록)에 표시</target>
        </trans-unit>
        <trans-unit id="b268d619791c64ad9a437793c6df4e96c3bea47e" translate="yes" xml:space="preserve">
          <source>Block scope means that the variable will only be available within the brackets in which it is declared. This extends to internal scopes, including anonymous functions created within your scope.</source>
          <target state="translated">블록 범위는 변수가 선언 된 대괄호 내에서만 변수를 사용할 수 있음을 의미합니다. 이는 범위 내에서 생성 된 익명 함수를 포함하여 내부 범위로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="6ad05cf476194af6ae4eab02f3b9ae25d3fe726e" translate="yes" xml:space="preserve">
          <source>Block scope variables are created like this :</source>
          <target state="translated">블록 범위 변수는 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d4734d382405fe72442dafef31013eff2bc92678" translate="yes" xml:space="preserve">
          <source>But the top level of an ES6 module is &lt;em&gt;not&lt;/em&gt; global. A variable declared at the top of an ES6 module will only be visible inside that module, unless the variable is explicitly &lt;code&gt;export&lt;/code&gt;ed, or unless it's assigned to a property of the global object.</source>
          <target state="translated">그러나 ES6 모듈의 최상위 수준은 전 세계가 &lt;em&gt;아닙니다&lt;/em&gt; . ES6 모듈 상단에 선언 된 변수는 변수를 명시 적으로 &lt;code&gt;export&lt;/code&gt; 거나 전역 객체의 속성에 할당하지 않는 한 해당 모듈 내에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4d272ff3f7fc4237376ed64dc233b59d9966000" translate="yes" xml:space="preserve">
          <source>Catch block parameter</source>
          <target state="translated">캐치 블록 매개 변수</target>
        </trans-unit>
        <trans-unit id="32c3db15ba22df73876c55e60996667cba034b0c" translate="yes" xml:space="preserve">
          <source>Catch block parameters are scoped to the catch-block body:</source>
          <target state="translated">캐치 블록 매개 변수는 캐치 블록 본문에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6fe813611dd6d84d9a1d26977566960643817c11" translate="yes" xml:space="preserve">
          <source>Check this article for in-depth understanding of scope</source>
          <target state="translated">범위에 대한 자세한 내용은이 기사를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="806b84e63f4442df339c4262199841634c53b286" translate="yes" xml:space="preserve">
          <source>Contexts form a stack of environments where variables are stored</source>
          <target state="translated">컨텍스트는 변수가 저장된 환경의 스택을 형성합니다</target>
        </trans-unit>
        <trans-unit id="3b76905c4fef521cd5b87dffcd70e8f6c5497e77" translate="yes" xml:space="preserve">
          <source>Control structure body</source>
          <target state="translated">제어 구조체</target>
        </trans-unit>
        <trans-unit id="9145c9f2f97356d62bd24da8388b2b38acf59902" translate="yes" xml:space="preserve">
          <source>Currently the feature offers support for a depth of 16 nested functions, but currently does not color global variables.</source>
          <target state="translated">현재이 기능은 깊이가 16 인 중첩 함수를 지원하지만 전역 변수에 색상을 지정하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="65fff7fa8d3c3b1a1f3c9528a2264bd097d68887" translate="yes" xml:space="preserve">
          <source>Declaration Styles</source>
          <target state="translated">선언 스타일</target>
        </trans-unit>
        <trans-unit id="a8fbe250f6e0a7b427bb5ef03aadced5ed432e98" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword. Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.</source>
          <target state="translated">ECMAScript 6에는 let 및 const 키워드가 도입되었습니다. 이 키워드는 var 키워드 대신 사용할 수 있습니다. var 키워드와 달리 let 및 const 키워드는 블록 명령문 내에서 로컬 범위 선언을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e4c8806859640baf11f724a1eec52c4f7c4afcf5" translate="yes" xml:space="preserve">
          <source>EDIT: Based on Benjamin's pointing out of the with and catch statements in the comments, I've edited the post, and added more.  Both the with and the catch statements introduce variables into their respective blocks, and that &lt;em&gt;is&lt;/em&gt; a block scope. These variables are aliased to the properties of the objects passed into them.</source>
          <target state="translated">편집 : Benjamin의 의견에 with 및 catch 문을 지적한 결과 게시물을 편집하고 더 추가했습니다. with 및 catch 문은 변수를 해당 블록에 도입하며 이는 블록 범위입니다. 이러한 변수는 전달 된 객체의 속성에 별칭이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e6021de7d4da167c9d1924fe6e9b51d156cf4a9a" translate="yes" xml:space="preserve">
          <source>EDIT: Clarifying example:</source>
          <target state="translated">편집 : 예를 명확하게 :</target>
        </trans-unit>
        <trans-unit id="409777b6233f21776478ec8ae63313ad04d136b2" translate="yes" xml:space="preserve">
          <source>EDIT: ECMAAScript 6 (Harmony) is spec'ed to support let, and I know chrome allows a 'harmony' flag, so perhaps it does support it..</source>
          <target state="translated">편집 : ECMAAScript 6 (Harmony)은 let을 지원하도록 지정되었으며 크롬은 'harmony'플래그를 허용하므로 아마도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="35e06056ed8896626ffd136476a7dd3ee396b131" translate="yes" xml:space="preserve">
          <source>Each function creates an execution context (but not always a new this binding)</source>
          <target state="translated">각 함수는 실행 컨텍스트를 작성합니다 (항상 새로운 바인딩이 아님).</target>
        </trans-unit>
        <trans-unit id="a6992c03e5f9e7f14a3502886f2fe8726fe41373" translate="yes" xml:space="preserve">
          <source>Every variable declared with the &lt;code&gt;var&lt;/code&gt; keyword is scoped to the function. However, if other function are declared within that function those functions will have access to the variables of the outer functions. This is called a &lt;strong&gt;scope chain&lt;/strong&gt;. It works in the following manner:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 키워드로 선언 된 모든 변수의 범위는 함수입니다. 그러나 다른 함수가 해당 함수 내에 선언되면 해당 함수는 외부 함수의 변수에 액세스 할 수 있습니다. 이것을 &lt;strong&gt;스코프 체인&lt;/strong&gt; 이라고합니다. 다음과 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="be91cfda712a2aa2bbaed218f5da3f4f20ced37f" translate="yes" xml:space="preserve">
          <source>Example of block scope is :-</source>
          <target state="translated">블록 범위의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="13c2c628d0e65d9c75a59c080f5bcf4a585ac61e" translate="yes" xml:space="preserve">
          <source>Find out &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures&quot;&gt;more&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures&quot;&gt;자세한 내용을&lt;/a&gt; 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="f3e52c062915c2a123c8f3e107bb729e5edb24b0" translate="yes" xml:space="preserve">
          <source>For an up-to-date overview of which browsers support the &lt;code&gt;let&lt;/code&gt; statement at the time of your reading this answer, see &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;this &lt;code&gt;Can I Use&lt;/code&gt; page&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">이 답변을 읽을 당시의 &lt;code&gt;let&lt;/code&gt; 문을 지원하는 브라우저에 대한 최신 개요는 &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;이 &lt;code&gt;Can I Use&lt;/code&gt; 페이지를 참조하십시오&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f759fff65c16814ccf2912386bb55ea2f49f07e2" translate="yes" xml:space="preserve">
          <source>For those that believe there is only global and local scope, please explain why Mozilla would have an entire page describing the nuances of block scope in JS.</source>
          <target state="translated">글로벌 및 로컬 범위 만 있다고 생각하는 사람들을 위해 Mozilla가 JS에서 블록 범위의 뉘앙스를 설명하는 전체 페이지를 갖는 이유를 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="b3a281d3e09d661ffef9d575955e9402e9acd1b7" translate="yes" xml:space="preserve">
          <source>Function - visible within a function (and its sub-functions and blocks)</source>
          <target state="translated">기능-기능 (및 해당 하위 기능 및 블록) 내에서 표시</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">기능 바디</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">함수 선언</target>
        </trans-unit>
        <trans-unit id="54098e1a6688516674ee45e3b3d0d1327b43c770" translate="yes" xml:space="preserve">
          <source>Function declarations have block scope in strict mode and function scope in non-strict mode. Note: non-strict mode is a complicated set of emergent rules based on the quirky historical implementations of different browsers.</source>
          <target state="translated">함수 선언은 엄격 모드의 블록 범위와 엄격하지 않은 모드의 함수 범위를 갖습니다. 참고 : 엄격하지 않은 모드는 다른 브라우저의 기발한 역사적 구현을 ​​기반으로하는 복잡한 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="7f91e1a8edc0e34ea3bca466ca46d82f7465d0d6" translate="yes" xml:space="preserve">
          <source>Function parameter names</source>
          <target state="translated">함수 매개 변수 이름</target>
        </trans-unit>
        <trans-unit id="9b10b98fb2db663a6af8871104c108ef004b25fd" translate="yes" xml:space="preserve">
          <source>Function parameter names are scoped to the function body.</source>
          <target state="translated">함수 매개 변수 이름은 함수 본문의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="1e0d99529d66efa9e16b2a37d29fa7405450d6fd" translate="yes" xml:space="preserve">
          <source>Function parameters</source>
          <target state="translated">기능 매개 변수</target>
        </trans-unit>
        <trans-unit id="f0919c6e7316ed9e8e640c9b80f7609cc7dbc45b" translate="yes" xml:space="preserve">
          <source>Function parameters can be considered to be declared in the function body:</source>
          <target state="translated">함수 매개 변수는 함수 본문에서 선언 된 것으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc0841f2f77bf09c47bd5cbb83dd0f40e14bf028" translate="yes" xml:space="preserve">
          <source>Global - visible by everything</source>
          <target state="translated">글로벌-모든 것으로 표시</target>
        </trans-unit>
        <trans-unit id="ab9be0bed756d5b31a5365140ba111b3a60a2123" translate="yes" xml:space="preserve">
          <source>Global Scope :</source>
          <target state="translated">글로벌 범위 :</target>
        </trans-unit>
        <trans-unit id="9c1d41d613e2de602e0cfbbc37dd6fb38c9598e2" translate="yes" xml:space="preserve">
          <source>Global context</source>
          <target state="translated">글로벌 컨텍스트</target>
        </trans-unit>
        <trans-unit id="1fd666f0db8baac461a523eb3696c9d6cf767ffc" translate="yes" xml:space="preserve">
          <source>Global scope</source>
          <target state="translated">글로벌 범위</target>
        </trans-unit>
        <trans-unit id="1db5edb9fb9b116986bc02c1af9c99d7780ec95f" translate="yes" xml:space="preserve">
          <source>Global variables are exactly like global stars (Jackie Chan, Nelson Mandela). You can access them (get or set the value), from any part of your application. Global functions are like global events (New Year, Christmas). You can execute (call) them from any part of your application.</source>
          <target state="translated">글로벌 변수는 글로벌 스타와 정확히 같습니다 (Jackie Chan, Nelson Mandela). 응용 프로그램의 어느 부분에서나 액세스 할 수 있습니다 (값을 얻거나 설정). 글로벌 기능은 글로벌 이벤트 (새해, 크리스마스)와 같습니다. 응용 프로그램의 어느 부분에서나 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6c6545a0afcd35503cd3889c2e63ae786e74d3d" translate="yes" xml:space="preserve">
          <source>Here is a good article on the subject.</source>
          <target state="translated">여기 주제에 관한 좋은 기사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36b16afa86f01c1ed6ed7ee0985634679d23724b" translate="yes" xml:space="preserve">
          <source>Here, we can see that our variable &lt;code&gt;j&lt;/code&gt; is only known in the first for loop, but not before and after. Yet, our variable &lt;code&gt;i&lt;/code&gt; is known in the entire function.</source>
          <target state="translated">여기서 변수 &lt;code&gt;j&lt;/code&gt; 는 첫 번째 for 루프에서만 알려져 있지만 이전과 이후는 알 수 없습니다. 그러나 변수 &lt;code&gt;i&lt;/code&gt; 는 전체 기능으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="6197c902dc9a969800bbc1f43aa78895c0f511c1" translate="yes" xml:space="preserve">
          <source>How an identifier was declared</source>
          <target state="translated">식별자 선언 방법</target>
        </trans-unit>
        <trans-unit id="fd84c93e786da583023283e8e6b544cc15f8a544" translate="yes" xml:space="preserve">
          <source>How do I create block scope variables?</source>
          <target state="translated">블록 범위 변수를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="6523732fcc8d20544777c08d98cafcd3a527d5d8" translate="yes" xml:space="preserve">
          <source>How it works under the hood</source>
          <target state="translated">후드 아래에서 작동하는 방식</target>
        </trans-unit>
        <trans-unit id="9bccab4e65ebb124be42a79a1ea8250f796b3a9e" translate="yes" xml:space="preserve">
          <source>How to keep track of browser support</source>
          <target state="translated">브라우저 지원을 추적하는 방법</target>
        </trans-unit>
        <trans-unit id="12e28ac9e5aec52d743e292f0a6d97a79a4481d9" translate="yes" xml:space="preserve">
          <source>I found that many people new to JavaScript have trouble understanding that inheritance is available by default in the language and that function scope is the only scope, so far. I provided an extension to a beautifier I wrote at the end of last year called JSPretty. The feature colors function scope in the code and always associates a color to all variables declared in that scope. Closure is visually demonstrated when a variable with a color from one scope is used in a different scope.</source>
          <target state="translated">JavaScript를 처음 접하는 많은 사람들은 기본적으로 언어에서 상속이 가능하며 함수 범위가 유일한 범위라는 것을 이해하는 데 어려움을 겪었습니다. 작년 말에 JSPretty라고 썼던 미인에 대한 확장을 제공했습니다. 피처 색상은 코드에서 기능 범위이며 항상 해당 범위에서 선언 된 모든 변수에 색상을 연결합니다. 한 범위의 색상을 가진 변수가 다른 범위에서 사용될 때 클로저가 시각적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cdf8b31fb66ebedcd5a01dafdc4d2f5c826f3323" translate="yes" xml:space="preserve">
          <source>I will not elaborate on this, since there are already many other answers explaining the difference.</source>
          <target state="translated">차이점을 설명하는 다른 많은 답변이 이미 있기 때문에 이에 대해 자세히 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eadac369b069051bb3496882603cd8c18a6245be" translate="yes" xml:space="preserve">
          <source>Identifier resolution only occurs in one direction: outwards. In this way, outer lexical environments cannot &quot;see&quot; into inner lexical environments.</source>
          <target state="translated">식별자 해상도는 한 방향으로 만 발생합니다 : 바깥 쪽. 이러한 방식으로 외부 어휘 환경은 내부 어휘 환경을 &quot;볼&quot;수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bac671b2d31df9b17566a019bb6eec35764631e1" translate="yes" xml:space="preserve">
          <source>Identifiers declared using &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;&lt;strong&gt;have block scope&lt;/strong&gt;, apart from when they are declared directly in the global context, in which case they have global scope.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 를 사용하여 선언 된 식별자는 전역 컨텍스트에서 직접 선언 된 경우를 제외하고 전역 범위를 갖는 경우를 제외하고 &lt;strong&gt;블록 범위&lt;/strong&gt; 를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="26eb35e5d6c55c98bf781bbeb4741c6d644d48f6" translate="yes" xml:space="preserve">
          <source>Identifiers declared using &lt;code&gt;var&lt;/code&gt;&lt;strong&gt;have function scope&lt;/strong&gt;, apart from when they are declared directly in the global context, in which case they are added as properties on the global object and have global scope. There are separate rules for their use in &lt;code&gt;eval&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 를 사용하여 선언 된 식별자는 전역 컨텍스트에서 직접 선언 된 경우를 제외하고 &lt;strong&gt;는 함수 scope을 가지며&lt;/strong&gt; ,이 경우 전역 객체의 속성으로 추가되고 전역 범위를 갖습니다. &lt;code&gt;eval&lt;/code&gt; 기능에 사용하기위한 별도의 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f36a64720f58b77b1ccc6c4e4747411d14a62208" translate="yes" xml:space="preserve">
          <source>If it cannot find the variable inside the the function body it &lt;strong&gt;will climb up to the chain&lt;/strong&gt; and look at the variable scope in the function in &lt;strong&gt;where the function was defined&lt;/strong&gt;. This is what is meant with lexical scope, we can see in the code where this function was defined and thus can determine the scope chain by merely looking at the code.</source>
          <target state="translated">함수 본문 내에서 변수를 찾을 수 없으면 &lt;strong&gt;체인으로 올라가&lt;/strong&gt; &lt;strong&gt;함수가 정의 된&lt;/strong&gt; 함수의 변수 범위를 살펴 봅니다. 이것은 어휘 범위의 의미입니다.이 함수가 정의 된 코드에서 볼 수 있으므로 코드를 살펴보면 범위 체인을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="745abb411c5db9b98fe9940dfa7c7e42d66969dd" translate="yes" xml:space="preserve">
          <source>If you are in the USA, you may know Kim Kardashian, infamous celebrity ( she somehow manages to make the tabloids). But people outside of the USA will not recognize her. She is a local star, bound to her territory.</source>
          <target state="translated">당신이 미국에 있다면, 유명한 연예인 인 Kim Kardashian을 알게 될 것입니다 (어쨌든 그녀는 타블로이드를 만들 수 있습니다). 그러나 미국 이외의 사람들은 그녀를 인식하지 못할 것입니다. 그녀는 자신의 영토에 묶인 지역 별입니다.</target>
        </trans-unit>
        <trans-unit id="db4ede529a33a6d48b929256007928a838c5c68c" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</source>
          <target state="translated">클라이언트 측 JavaScript 코드를 작성 중이고 트랜스 파일러를 사용하지 않는 경우 브라우저 지원을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8dcd2b2b003bbf8ee33318bcf617bf8c5934526f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a Node based transpiler (like the &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell script&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.</source>
          <target state="translated">클라이언트 측 JavaScript 코드를 작성하고 &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur 쉘 스크립트&lt;/strong&gt;&lt;/a&gt; 또는 &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt; 과 같은 노드 기반 변환기를 사용하는 경우 &lt;code&gt;let&lt;/code&gt; 문을 안전하게 사용할 수 있습니다. 브라우저는 변환 된 코드에 대해서만 알기 때문에 성능 단점이 제한되어야합니다.</target>
        </trans-unit>
        <trans-unit id="78db1b0537f209bbe9cabb545f633294560d8d7f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a browser based transpiler (like &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement, however your code is likely to be anything but optimal with respect to performance.</source>
          <target state="translated">클라이언트 측 JavaScript 코드를 작성하고 &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt; 과 같은 브라우저 기반 변환기를 사용하는 경우 &lt;code&gt;let&lt;/code&gt; 문을 안전하게 사용할 수 있지만 코드는 성능 측면에서 최적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4730b8ff337fd5e9541397578300f0622cd1031f" translate="yes" xml:space="preserve">
          <source>If you're writing server-side JavaScript code (&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement.</source>
          <target state="translated">서버 측 JavaScript 코드 ( &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt; )를 작성하는 경우 &lt;code&gt;let&lt;/code&gt; 문을 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e76b9230322e627054331e7b9ae49ba5c423394b" translate="yes" xml:space="preserve">
          <source>Implicit variable declarations</source>
          <target state="translated">암시 적 변수 선언</target>
        </trans-unit>
        <trans-unit id="45efcccf469aa7800be7436a4b8905d5812288f9" translate="yes" xml:space="preserve">
          <source>In &quot;Javascript 1.7&quot; (Mozilla's extension to Javascript) one can also declare block-scope variables with &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt;:</source>
          <target state="translated">&quot;Javascript 1.7&quot;(Mozilla의 Javascript 확장)에서 &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11&quot;&gt; &lt;code&gt;let&lt;/code&gt; 문을 사용&lt;/a&gt; 하여 블록 범위 변수를 선언 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="df791ba6a19c022e5fd42c64ae7d2edc9a0401c4" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;eval&lt;/code&gt; strings, variables declared using &lt;code&gt;var&lt;/code&gt; will be placed in the current scope, or, if &lt;code&gt;eval&lt;/code&gt; is used indirectly, as properties on the global object.</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 문자열에서 &lt;code&gt;var&lt;/code&gt; 를 사용하여 선언 된 변수는 현재 범위에 배치되거나 &lt;code&gt;eval&lt;/code&gt; 이 간접적으로 사용되는 경우 전역 객체의 속성으로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="b205565c9d304960cff99be6d6bb359de2add3f5" translate="yes" xml:space="preserve">
          <source>In EcmaScript5, there are mainly two scopes, &lt;strong&gt;local scope&lt;/strong&gt; and &lt;strong&gt;global scope&lt;/strong&gt; but in EcmaScript6 we have mainly three scopes, local scope, global scope and a new scope called &lt;strong&gt;block scope&lt;/strong&gt;.</source>
          <target state="translated">EcmaScript5에는 주로 &lt;strong&gt;로컬 범위&lt;/strong&gt; 와 &lt;strong&gt;전역 범위의&lt;/strong&gt; 두 가지 범위가 있지만 EcmaScript6에는 주로 로컬 범위, 전역 범위 및 &lt;strong&gt;블록 범위&lt;/strong&gt; 라는 새로운 범위의 세 가지 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="524ef03338ba6373ff8442de44d3525db236f6ed" translate="yes" xml:space="preserve">
          <source>In JavaScript there are two types of scope:</source>
          <target state="translated">JavaScript에는 두 가지 유형의 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="49f24e5b3ac83ce8f7d46f9b0b5fbf42b56fef59" translate="yes" xml:space="preserve">
          <source>In JavaScript, every function-object has a hidden &lt;code&gt;[[Environment]]&lt;/code&gt; reference that is a reference to the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;lexical environment&lt;/a&gt; of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;execution context&lt;/a&gt; (stack frame) within which it was created.</source>
          <target state="translated">JavaScript에서 모든 function-object에는 숨겨진 &lt;code&gt;[[Environment]]&lt;/code&gt; 참조가 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;있으며이&lt;/a&gt; 참조는 작성된 [ &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;Context]&lt;/a&gt; 환경 에서 실행 컨텍스트 (스택 프레임)의 어휘 환경 에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="101098685b4ef4c5fe8ddde1f6b84cd946e6cda9" translate="yes" xml:space="preserve">
          <source>In non-strict mode, function declarations have function scope. In strict mode they have block scope.</source>
          <target state="translated">엄격하지 않은 모드에서 함수 선언에는 함수 범위가 있습니다. 엄격 모드에서는 블록 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="517fb1c6e1e082360f7bfc6a062cddd34106ba21" translate="yes" xml:space="preserve">
          <source>In non-strict mode, implicit variable declarations are globally scoped. In strict mode you get an error.</source>
          <target state="translated">엄격하지 않은 모드에서 암시 적 변수 선언은 전체적으로 적용됩니다. 엄격 모드에서는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c530a0f6e7c617894a5240c8ce5b620b9c103965" translate="yes" xml:space="preserve">
          <source>In non-strict mode, implicit variable declarations have global scope. In strict mode these are not permitted.</source>
          <target state="translated">엄격하지 않은 모드에서 암시 적 변수 선언에는 전역 범위가 있습니다. 엄격 모드에서는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f6bfeda81e0e8b51ad8697f031e39feead1aa2e" translate="yes" xml:space="preserve">
          <source>In the above example letVar logs the value global because variables declared with &lt;code&gt;let&lt;/code&gt; are block scoped. They cease to exist outside their respective block, so the variable can't be accessed outside the if block.</source>
          <target state="translated">위의 예에서 &lt;code&gt;let&lt;/code&gt; 으로 선언 된 변수는 블록 범위이므로 letVar는 전역 값을 기록합니다. 그것들은 각각의 블록 외부에 존재하지 않으므로 변수는 if 블록 외부에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f75a76f8d36110fb25053c596b58acad7a1e7f42" translate="yes" xml:space="preserve">
          <source>In the first example, there was no block scope, so the initially declared variables were overwritten. In the second example, there was a new scope due to the function, so the initially declared variables were SHADOWED, and not overwritten.</source>
          <target state="translated">첫 번째 예에서는 블록 범위가 없었으므로 처음 선언 된 변수를 덮어 썼습니다. 두 번째 예에서는 함수로 인해 새로운 범위가 있었으므로 처음 선언 된 변수는 SHADOWED이며 덮어 쓰지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="70b614f546808637e2d6bda4b19e2a55f0206cd8" translate="yes" xml:space="preserve">
          <source>In the following, &lt;code&gt;x&lt;/code&gt; is visible outside of the loop because &lt;code&gt;var&lt;/code&gt; has function scope:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 에서 함수 범위가 있기 때문에 다음에서 &lt;code&gt;x&lt;/code&gt; 는 루프 외부에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d512dd946ae9252d40645adc648a80ba866281e8" translate="yes" xml:space="preserve">
          <source>In this language, the displays were done similar to a stack of index cards. There was a master card referred to as the background. It was transparent and can be seen as the bottom card. Any content on this base card was shared with cards placed on top of it. Each card placed on top had its own content which took precedence over the previous card, but still had access to the prior cards if desired.</source>
          <target state="translated">이 언어에서는 디스플레이가 인덱스 카드 스택과 유사하게 수행되었습니다. 배경이라고하는 마스터 카드가있었습니다. 투명하고 맨 아래 카드로 볼 수 있습니다. 이 기본 카드의 모든 내용은 그 위에 놓인 카드와 공유되었습니다. 상단에 배치 된 각 카드에는 이전 카드보다 우선하는 고유 한 내용이 있지만 원하는 경우 여전히 이전 카드에 액세스 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="597c9aea5b3298abab060a8929051c7f5d129292" translate="yes" xml:space="preserve">
          <source>Is it safe to use block scope variables today?</source>
          <target state="translated">오늘날 블록 범위 변수를 사용하는 것이 안전합니까?</target>
        </trans-unit>
        <trans-unit id="bed514e2588665341497d11ae432c1980024650f" translate="yes" xml:space="preserve">
          <source>JavaScript has lexical (also called static) scoping and closures. This means you can tell the scope of an identifier by looking at the source code.</source>
          <target state="translated">JavaScript에는 어휘 (정적이라고도 함) 범위 지정 및 클로저가 있습니다. 즉, 소스 코드를보고 식별자의 범위를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4452aeeb557996248e57cd5ff1bf92ebc44de21c" translate="yes" xml:space="preserve">
          <source>JavaScript have only two type of scope :</source>
          <target state="translated">JavaScript에는 두 가지 유형의 범위 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="34dae96f32e8c613581daf8160bc2454a1788290" translate="yes" xml:space="preserve">
          <source>Javascript uses scope chains to establish the scope for a given function. There is typically one global scope, and each function defined has its own nested scope. Any function defined within another function has a local scope which is linked to the outer function. It's always the position in the source that defines the scope.</source>
          <target state="translated">Javascript는 범위 체인을 사용하여 지정된 함수의 범위를 설정합니다. 일반적으로 하나의 전역 범위가 있으며 정의 된 각 함수에는 자체 중첩 범위가 있습니다. 다른 함수 내에 정의 된 모든 함수에는 외부 함수에 연결된 로컬 범위가 있습니다. 항상 범위를 정의하는 소스의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="aaccd2b14cae60b4870ad3ae5d1483bf95f1cc7f" translate="yes" xml:space="preserve">
          <source>Just to add to the other answers, scope is a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.  This look-up may be for the purposes of assigning to the variable, which is an LHS (lefthand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. These look-ups are what the JavaScript engine is doing internally when it's compiling and executing the code.</source>
          <target state="translated">다른 답변에 추가하기 위해 scope는 선언 된 모든 식별자 (변수)의 조회 목록이며 현재 실행중인 코드에 액세스 할 수있는 방법에 대한 엄격한 규칙을 시행합니다. 이 조회는 LHS (왼쪽) 참조 인 변수에 할당하기위한 것이거나 RHS (오른쪽) 참조 인 값을 검색하기위한 것일 수 있습니다. 이러한 조회는 JavaScript 엔진이 코드를 컴파일하고 실행할 때 내부적으로 수행하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="6e76cdd0f809219e814e41d1445bb5906bf62b65" translate="yes" xml:space="preserve">
          <source>Let would be a support for block level scoping, but you have to use the keyword to make it happen.</source>
          <target state="translated">블록 레벨 범위 지정을 지원하지만 키워드를 사용하여이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e18f18ab1ca156d4e71dc6cde7b4aa86040a968" translate="yes" xml:space="preserve">
          <source>Local Scope :</source>
          <target state="translated">지역 범위 :</target>
        </trans-unit>
        <trans-unit id="ca1be526eefc4c0c9a3b41b14b0b70782146069f" translate="yes" xml:space="preserve">
          <source>Local scope</source>
          <target state="translated">지역 범위</target>
        </trans-unit>
        <trans-unit id="a5d58a53fe2af24df0c1d2967e48151aa15ad00d" translate="yes" xml:space="preserve">
          <source>Local variables are like local stars. You can only access them (get or set the value) inside the scope. A local function is like local events - you can execute only (celebrate) inside that scope. If you want to access them from outside of the scope, you will get a reference error</source>
          <target state="translated">지역 변수는 지역 별과 같습니다. 범위 내에서만 액세스 할 수 있습니다 (값을 가져 오거나 설정). 로컬 함수는 로컬 이벤트와 유사합니다. 해당 범위 내에서만 (축하) 실행할 수 있습니다. 스코프 외부에서 액세스하려는 경우 참조 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4136eb8081368e099724a9eb455093c190198113" translate="yes" xml:space="preserve">
          <source>Modern JavaScript</source>
          <target state="translated">현대 JavaScript</target>
        </trans-unit>
        <trans-unit id="7616704e501c489cb1ada1999f1307d7d34894df" translate="yes" xml:space="preserve">
          <source>Modern Js, ES6+, '&lt;code&gt;const&lt;/code&gt;' and '&lt;code&gt;let&lt;/code&gt;'</source>
          <target state="translated">현대 JS, ES6 +, ' &lt;code&gt;const&lt;/code&gt; '및 ' &lt;code&gt;let&lt;/code&gt; '</target>
        </trans-unit>
        <trans-unit id="aad38a0f6cdff42e1f74357a58c635fc618d1ed1" translate="yes" xml:space="preserve">
          <source>Module - visible within a module</source>
          <target state="translated">모듈-모듈 내에서 표시</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="003bc7d27503c7802bcadc1da058ded6bae30f8e" translate="yes" xml:space="preserve">
          <source>My understanding is that there are 3 scopes: global scope, available globally; local scope, available to an entire function regardless of blocks; and block scope, only available to the block, statement, or expression on which it was used. Global and local scope are indicated with the keyword 'var', either within a function or outside, and block scope is indicated with the keyword 'let'.</source>
          <target state="translated">내 이해는 3 가지 범위가 있다는 것입니다 : 글로벌 범위, 전 세계적으로 사용 가능; 블록에 관계없이 전체 기능에 사용 가능한 로컬 범위; 그리고 블록 범위는 블록, 명령문 또는 블록이 사용 된 표현식에서만 사용 가능합니다. 전역 및 로컬 범위는 함수 내에서 또는 외부에서 키워드 'var'로 표시되며 블록 범위는 키워드 'let'으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ebc5769ecf05a1a2a40ee3c38b9f80c576a2506b" translate="yes" xml:space="preserve">
          <source>Named function expressions</source>
          <target state="translated">명명 된 함수 표현식</target>
        </trans-unit>
        <trans-unit id="eaab883a49ed3ddf47b830ade67ddd95c8b8889b" translate="yes" xml:space="preserve">
          <source>Named function expressions are scooped only to the expression itself:</source>
          <target state="translated">명명 된 함수 표현식은 표현식 자체에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e130810bfbd11725f532879f063fa5c57ae9625" translate="yes" xml:space="preserve">
          <source>Named function expressions are scoped to themselves (eg. for the purpose of recursion).</source>
          <target state="translated">명명 된 함수 표현식은 그 자체로 범위가 지정됩니다 (예 : 재귀 목적으로).</target>
        </trans-unit>
        <trans-unit id="0f5c3a674d3ca00ddc3c16a5c7583524970181f2" translate="yes" xml:space="preserve">
          <source>Note that this link between the new execution context and the lexical environment of the function object is called a &lt;a href=&quot;https://stackoverflow.com/a/111114/38522&quot;&gt;closure&lt;/a&gt;.</source>
          <target state="translated">새로운 실행 컨텍스트와 함수 객체의 어휘 환경 사이의이 링크를 &lt;a href=&quot;https://stackoverflow.com/a/111114/38522&quot;&gt;클로저&lt;/a&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="6f243cfe125f58adb4304f18257f0d057d6f2352" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;are all hoisted&lt;/a&gt;. This means that their logical position of definition is the top of their enclosing scope (block or function). However, variables declared useing &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; cannot be read or assigned to until control has passed the point of declaration in the source code. The interim period is known as the temporal dead zone.</source>
          <target state="translated">참고 : &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;var&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;는 모두 게양&lt;/a&gt; 됩니다. 이는 논리적 정의 위치가 둘러싸는 범위 (블록 또는 기능)의 최상위임을 의미합니다. 그러나 &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 를 사용 하여 선언 된 변수는 제어가 소스 코드의 선언 지점을 통과 할 때까지 읽거나 할당 할 수 없습니다. 임시 기간은 임시 데드 존이라고합니다.</target>
        </trans-unit>
        <trans-unit id="52c316d760a2406f9de3c2dfe34c168873a682d6" translate="yes" xml:space="preserve">
          <source>Now when a variable &lt;code&gt;a&lt;/code&gt; required it first searches for nearest variable scope and if variable is not there than it move's to next object of variable scope chain.which is in this case is window level.</source>
          <target state="translated">변수 &lt;code&gt;a&lt;/code&gt; 필요한 경우 먼저 가장 가까운 변수 범위를 검색하고 변수가 없으면 변수 범위 체인의 다음 객체로 이동합니다.이 경우 창 수준입니다.</target>
        </trans-unit>
        <trans-unit id="07cc61cfbd5542be1dbdf3df9337149c96b1472d" translate="yes" xml:space="preserve">
          <source>Old school JavaScript</source>
          <target state="translated">구식 JavaScript</target>
        </trans-unit>
        <trans-unit id="d143a89c1211786baeac1937b212ea01195019e5" translate="yes" xml:space="preserve">
          <source>On a different note, unlike normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, which run on the top level, code inside ES6 modules runs in its own private scope. A variable defined at the top of a normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is global, so you can reference it in other &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, like this:</source>
          <target state="translated">다른 참고로 최상위 레벨에서 실행되는 일반 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그와 달리 ES6 모듈 내부의 코드는 자체 개인 범위에서 실행됩니다. 일반 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 상단에 정의 된 변수는 전역이므로 다음과 같이 다른 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그에서 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03a95004161c654858d132f7f32b4344e85bba0" translate="yes" xml:space="preserve">
          <source>One thing of note that is worth mentioning, &quot;Scope look-up stops once it finds the first match&quot;.</source>
          <target state="translated">주목할만한 한 가지 사항은 &quot;첫 번째 일치 항목을 찾으면 스코프 조회가 중지됩니다&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="39d115a82e8ca46b1e1da4cb77b8126173035ef2" translate="yes" xml:space="preserve">
          <source>Ordinary block</source>
          <target state="translated">보통 블록</target>
        </trans-unit>
        <trans-unit id="3e7192956deaab738bd72c8783df974fd557d341" translate="yes" xml:space="preserve">
          <source>Otherwise, you'll get a ReferenceError when the handler is invoked. So, for example, if the inline handler references a function which is defined &lt;em&gt;inside&lt;/em&gt;&lt;code&gt;window.onload&lt;/code&gt; or &lt;code&gt;$(function() {&lt;/code&gt;, the reference will fail, because the inline handler may only reference variables in the global scope, and the function is not global:</source>
          <target state="translated">그렇지 않으면 핸들러가 호출 될 때 ReferenceError가 발생합니다. 예를 들어, 인라인 핸들러가 &lt;code&gt;window.onload&lt;/code&gt; 또는 &lt;code&gt;$(function() {&lt;/code&gt; &lt;em&gt;내에&lt;/em&gt; 정의 된 함수를 참조하는 경우 인라인 핸들러는 전역 범위의 변수 만 참조 할 수 있고 함수는 그렇지 않으므로 참조는 실패합니다. 글로벌 :</target>
        </trans-unit>
        <trans-unit id="b0f7eac222c33234d6b1ce96f288537ff995de59" translate="yes" xml:space="preserve">
          <source>Outside of the special cases of global and module scope, variables are declared using &lt;code&gt;var&lt;/code&gt; (function scope), &lt;code&gt;let&lt;/code&gt; (block scope) and &lt;code&gt;const&lt;/code&gt; (block scope). Most other forms of identifier declaration have block scope in strict mode.</source>
          <target state="translated">전역 및 모듈 범위의 특수한 경우를 제외하고 변수는 &lt;code&gt;var&lt;/code&gt; (함수 범위), &lt;code&gt;let&lt;/code&gt; (블록 범위) 및 &lt;code&gt;const&lt;/code&gt; (블록 범위)를 사용하여 선언됩니다. 대부분의 다른 형태의 식별자 선언은 엄격 모드에서 블록 범위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="4d2fae3746da9a4ac50d19572acc01ad9fa90618" translate="yes" xml:space="preserve">
          <source>Properties of the &lt;code&gt;document&lt;/code&gt; and properties of the element the handler is attached to may also be referenced as standalone variables inside inline handlers because inline handlers are invoked &lt;a href=&quot;https://i.stack.imgur.com/dTDB0.png&quot;&gt;&lt;em&gt;inside&lt;/em&gt; of two &lt;code&gt;with&lt;/code&gt; blocks&lt;/a&gt;, one for the &lt;code&gt;document&lt;/code&gt;, one for the element. The scope chain of variables inside these handlers is &lt;a href=&quot;https://stackoverflow.com/a/57048067&quot;&gt;extremely unintuitive&lt;/a&gt;, and a working event handler will &lt;em&gt;probably&lt;/em&gt; require a function to be global (and unnecessary global pollution &lt;a href=&quot;https://softwareengineering.stackexchange.com/q/148108&quot;&gt;should probably be avoided&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;document&lt;/code&gt; 속성과 핸들러가 연결된 요소의 속성은 인라인 핸들러 내에서 독립형 변수로 참조 될 수도 있습니다. 인라인 핸들러는 &lt;code&gt;document&lt;/code&gt; &lt;a href=&quot;https://i.stack.imgur.com/dTDB0.png&quot;&gt; &lt;code&gt;with&lt;/code&gt; 요소&lt;/a&gt; , 블록 과 함께 두 개의 블록 &lt;em&gt;안에서&lt;/em&gt; 호출되기 때문입니다. 이러한 핸들러 내부의 변수 범위는 &lt;a href=&quot;https://stackoverflow.com/a/57048067&quot;&gt;매우 직관적이지&lt;/a&gt; 않으며 작동하는 이벤트 핸들러는 전역적인 기능을 필요로합니다 (그리고 불필요한 전역 오염 &lt;a href=&quot;https://softwareengineering.stackexchange.com/q/148108&quot;&gt;은 피해야합니다&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="358bcd9d5d263dcf0acf4e412ac146d3ec1cbcef" translate="yes" xml:space="preserve">
          <source>Quoting from his ebook:</source>
          <target state="translated">그의 전자 책에서 인용 :</target>
        </trans-unit>
        <trans-unit id="a23997220606bd14c55eafa62be1140a4157f6e3" translate="yes" xml:space="preserve">
          <source>Scope chain --&amp;gt;</source>
          <target state="translated">범위 체인-&amp;gt;</target>
        </trans-unit>
        <trans-unit id="960f638fe475e770a8e797654ca9cc8ebe41b2a9" translate="yes" xml:space="preserve">
          <source>Scope is defined as the &lt;a href=&quot;https://stackoverflow.com/a/1047479/38522&quot;&gt;lexical&lt;/a&gt; region of code over which an identifier is valid.</source>
          <target state="translated">범위는 식별자가 유효한 &lt;a href=&quot;https://stackoverflow.com/a/1047479/38522&quot;&gt;어휘&lt;/a&gt; 코드 영역으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0001dde1682d4a228cca759a547c5f895b3d0836" translate="yes" xml:space="preserve">
          <source>Scope is formed of a linked nesting of lexical environments, with each level in the nesting corresponding to a lexical environment of an ancestor execution context.</source>
          <target state="translated">범위는 어휘 환경의 연결된 중첩으로 구성되며, 중첩의 각 레벨은 상위 실행 컨텍스트의 어휘 환경에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="03fc8d42427c442b2a752ef4c9a4f0079386dd0a" translate="yes" xml:space="preserve">
          <source>Scope is the region of the codebase over which an identifier is valid.</source>
          <target state="translated">범위는 식별자가 유효한 코드베이스의 영역입니다.</target>
        </trans-unit>
        <trans-unit id="d9e69c5319ff44dd0f7e6cd91e381690e40b15e1" translate="yes" xml:space="preserve">
          <source>Scopes are technically &quot;Execution Contexts&quot;</source>
          <target state="translated">범위는 기술적으로 &quot;실행 컨텍스트&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="8014aa999f8e9f357a908dec6565c42cc7afe011" translate="yes" xml:space="preserve">
          <source>See a demo at:</source>
          <target state="translated">다음에서 데모를보십시오 :</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="4a2982e515416ff8974a0e226abce538efa699bf" translate="yes" xml:space="preserve">
          <source>Since the scope chain inside inline handlers is &lt;em&gt;so weird&lt;/em&gt;, and since inline handlers require global pollution to work, and since inline handlers sometimes require ugly string escaping when passing arguments, it's probably easier to avoid them. Instead, attach event handlers using Javascript (like with &lt;code&gt;addEventListener&lt;/code&gt;), rather than with HTML markup.</source>
          <target state="translated">인라인 핸들러 내부의 스코프 체인은 &lt;em&gt;너무 이상&lt;/em&gt; 하고 인라인 핸들러가 작동하려면 전역 오염이 필요하고 인라인 핸들러는 인수를 전달할 때 추악한 문자열 이스케이프가 필요하기 때문에 피하는 것이 더 쉽습니다. 대신 HTML 마크 업이 아닌 Javascript ( &lt;code&gt;addEventListener&lt;/code&gt; 와 같은)를 사용하여 이벤트 핸들러를 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="d7b8f215615eb4f7e16592cd68df7d8300b6ec09" translate="yes" xml:space="preserve">
          <source>So from this perspective, I think that a picture would help that I found in the Scopes and Closures ebook by Kyle Simpson:</source>
          <target state="translated">이 관점에서, 그림이 Kyle Simpson의 Scopes and Closures ebook에서 찾은 데 도움이 될 것이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="260b57030b2b60bb30906c7875f28bf2c6a9202e" translate="yes" xml:space="preserve">
          <source>So that is the technical explanation. In practice, it is important to remember that in JavaScript</source>
          <target state="translated">이것이 기술적 인 설명입니다. 실제로는 JavaScript에서이를 기억하는 것이 중요합니다</target>
        </trans-unit>
        <trans-unit id="6eeb8f5239adbcf206f276fe0178d507b944531b" translate="yes" xml:space="preserve">
          <source>So this code:</source>
          <target state="translated">따라서이 코드 :</target>
        </trans-unit>
        <trans-unit id="9149eb7ca4536bbe4c6e7d579b916628507a6c43" translate="yes" xml:space="preserve">
          <source>So what is the difference between functional scope and block scope?</source>
          <target state="translated">기능 범위와 블록 범위의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="de0115ead2817c9e584c804563ac34e1a02cf494" translate="yes" xml:space="preserve">
          <source>So you can see JavaScript scoping is actually extremely simple, albeit not always intuitive. A few things to be aware of:</source>
          <target state="translated">따라서 JavaScript 범위 지정은 실제로 매우 간단하지만 항상 매우 간단하다는 것을 알 수 있습니다. 몇 가지 알아 두어야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="3812cb403a9ffcb176a50c641ea80b4719348646" translate="yes" xml:space="preserve">
          <source>So, any blocks other than functions do not create a new scope. That explains why for-loops overwrite outer scoped variables:</source>
          <target state="translated">따라서 함수 이외의 블록은 새로운 범위를 만들지 않습니다. for 루프가 외부 범위 변수를 덮어 쓰는 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="77ce19117cbf62e9aa83a0e9daa5eda964f91d46" translate="yes" xml:space="preserve">
          <source>Some of the locations identifiers can be declared:</source>
          <target state="translated">위치 식별자 중 일부를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c1737e3aa3de31e28974c1c8d07d17beab8ca24" translate="yes" xml:space="preserve">
          <source>Some of the ways identifiers can be declared:</source>
          <target state="translated">식별자를 선언 할 수있는 몇 가지 방법 :</target>
        </trans-unit>
        <trans-unit id="de99e0fa995db074a346a8fd3d2e19d830b3b47e" translate="yes" xml:space="preserve">
          <source>TLDR</source>
          <target state="translated">TLDR</target>
        </trans-unit>
        <trans-unit id="eb94aded85eb85135c48677af15bf3ac1f75c26f" translate="yes" xml:space="preserve">
          <source>That's almost all you need to know in terms of JavaScript scoping, except:</source>
          <target state="translated">JavaScript 범위 지정과 관련하여 알아야 할 거의 모든 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="20ea4c65a85f13a0f7d5880b871c092105665952" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/&quot;&gt;&lt;strong&gt;most recent JavaScript specs&lt;/strong&gt;&lt;/a&gt; now also allow a third scope :</source>
          <target state="translated">&lt;a href=&quot;https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/&quot;&gt;&lt;strong&gt;가장 최근의 JavaScript 사양은&lt;/strong&gt;&lt;/a&gt; 이제 세 번째 범위를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="551aa169f58fce36618019678db10f4c0b8c35c3" translate="yes" xml:space="preserve">
          <source>The Below Class has a Global scope variable &lt;code&gt;carName&lt;/code&gt;. And this variable is accessible from everywhere in the class.</source>
          <target state="translated">아래 클래스에는 전역 범위 변수 &lt;code&gt;carName&lt;/code&gt; 이 있습니다. 이 변수는 클래스의 어느 곳에서나 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f2e6a008008ebd7c8f8b0790fa024387f5103ae" translate="yes" xml:space="preserve">
          <source>The Below function has a local scope variable &lt;code&gt;carName&lt;/code&gt;. And this variable is not accessible from outside of the function.</source>
          <target state="translated">아래 함수에는 로컬 범위 변수 &lt;code&gt;carName&lt;/code&gt; 이 있습니다. 그리고이 변수는 함수 외부에서 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c6297960ee1326cc0b6ece03b632419c8697d63" translate="yes" xml:space="preserve">
          <source>The biggest difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; is that &lt;code&gt;var&lt;/code&gt; is function scoped whereas &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; are block scoped. Here is an example to illustrate this:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 와 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 의 가장 큰 차이점은 var 은 함수 범위이고 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 는 블록 범위입니다. 다음은이를 설명하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="dcadd2f97f65d20e36f2d943423cf05c3a58f7a2" translate="yes" xml:space="preserve">
          <source>The building represents our program&amp;rsquo;s nested scope ruleset. The first
  floor of the building represents your currently executing scope,
  wherever you are. The top level of the building is the global scope.
  You resolve LHS and RHS references by looking on your current floor,
  and if you don&amp;rsquo;t find it, taking the elevator to the next floor,
  looking there, then the next, and so on. Once you get to the top floor
  (the global scope), you either find what you&amp;rsquo;re looking for, or you
  don&amp;rsquo;t. But you have to stop regardless.</source>
          <target state="translated">건물은 프로그램의 중첩 범위 규칙 세트를 나타냅니다. 건물의 1 층은 어디에 있든지 현재 실행중인 범위를 나타냅니다. 건물의 최상위 수준은 글로벌 범위입니다. 현재 층을 살펴보고 LHS 및 RHS 참조를 해결하고, 찾을 수없는 경우 엘리베이터를 다음 층으로 가져 가서 다음 층을 찾은 후 다음 등으로 진행합니다. 최상층에 도달하면 (전 세계 범위) 원하는 것을 찾거나 찾지 않습니다. 그러나 당신은 관계없이 멈춰야합니다.</target>
        </trans-unit>
        <trans-unit id="cdc0afcc10d38d1828b1ade5ac3c30395d6075f9" translate="yes" xml:space="preserve">
          <source>The following prints &lt;code&gt;5&lt;/code&gt;, five times, and then prints &lt;code&gt;5&lt;/code&gt; for an sixth time for the &lt;code&gt;console.log&lt;/code&gt; outside the loop:</source>
          <target state="translated">다음은 루프 외부에서 &lt;code&gt;console.log&lt;/code&gt; 에 대해 &lt;code&gt;5&lt;/code&gt; 를 다섯 번 인쇄 한 다음 여섯 번째로 5 를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f640071ac23c5f0d26b8e3ca4e3b7d965b5b7397" translate="yes" xml:space="preserve">
          <source>The following prints &lt;code&gt;undefined&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is block-scoped. The callbacks are run one by one asynchronously. New behavior for &lt;code&gt;let&lt;/code&gt; variables means that each anonymous function closed over a different variable named &lt;code&gt;x&lt;/code&gt; (unlike it would have done with &lt;code&gt;var&lt;/code&gt;), and so integers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt; are printed.:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 블록 범위이므로 다음은 &lt;code&gt;undefined&lt;/code&gt; 인쇄입니다. 콜백은 하나씩 비동기 적으로 실행됩니다. &lt;code&gt;let&lt;/code&gt; 변수에 대한 새로운 동작은 각 익명 함수가 &lt;code&gt;x&lt;/code&gt; 라는 다른 변수에 대해 닫히고 ( &lt;code&gt;var&lt;/code&gt; 와는 달리) &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;4&lt;/code&gt; 까지의 정수가 인쇄됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="07a69d238d156e701c5a367c6a5485165dd070e3" translate="yes" xml:space="preserve">
          <source>The following will NOT throw a &lt;code&gt;ReferenceError&lt;/code&gt; because the visibility of &lt;code&gt;x&lt;/code&gt; is not constrained by the block; it will, however, print &lt;code&gt;undefined&lt;/code&gt; because the variable has not been initialised (because of the &lt;code&gt;if&lt;/code&gt; statement).</source>
          <target state="translated">다음은 &lt;code&gt;x&lt;/code&gt; 의 가시성이 블록에 의해 제한되지 않기 때문에 &lt;code&gt;ReferenceError&lt;/code&gt; 를 발생 시키지 않습니다. 그러나 변수가 초기화되지 않았으므로 ( &lt;code&gt;if&lt;/code&gt; 문 때문에) &lt;code&gt;undefined&lt;/code&gt; 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="05ba3ae9dd9b32ddf42ae7069862c90654d442fa" translate="yes" xml:space="preserve">
          <source>The following will declare a property on the global object, because variables declared using &lt;code&gt;var&lt;/code&gt; within the global context, are added as properties to the global object:</source>
          <target state="translated">전역 컨텍스트 내에서 &lt;code&gt;var&lt;/code&gt; 를 사용하여 선언 된 변수가 전역 객체에 속성으로 추가되므로 다음은 전역 객체에서 속성을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="56e352b3854a340ef82e660d524c84e0929a85f3" translate="yes" xml:space="preserve">
          <source>The following will throw a &lt;code&gt;ReferenceError&lt;/code&gt; because the visibility of &lt;code&gt;x&lt;/code&gt; is constrained by the block:</source>
          <target state="translated">다음은 &lt;code&gt;x&lt;/code&gt; 의 가시성이 블록에 의해 제한되기 때문에 &lt;code&gt;ReferenceError&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="916178c1871c4ad706738ee8325f52860cf80126" translate="yes" xml:space="preserve">
          <source>The following will throw a ReferenceError because the names&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; have no meaning outside of the function &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 라는 이름은 함수 &lt;code&gt;f&lt;/code&gt; 외부에서 의미가 없으므로 다음은 ReferenceError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c15f36c25910e782b2fb893c1b27cfa365282f76" translate="yes" xml:space="preserve">
          <source>The following will throw a ReferenceError for &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;, but not for &lt;code&gt;x&lt;/code&gt;, because the visibility of &lt;code&gt;x&lt;/code&gt; is not constrained by the block. Blocks that define the bodies of control structures like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;, behave similarly.</source>
          <target state="translated">다음은 &lt;code&gt;x&lt;/code&gt; 의 가시성이 블록에 의해 제한되지 않기 때문에 &lt;code&gt;y&lt;/code&gt; 와 &lt;code&gt;z&lt;/code&gt; 에 대해서는 ReferenceError를 발생 시키지만 x 에 대해서는 ReferenceError를 발생시키지 않습니다. &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 및 &lt;code&gt;while&lt;/code&gt; 과 같은 제어 구조의 본문을 정의하는 블록은 비슷하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="35ea475fa01e3a75809f9d5a47ee4846fc35e629" translate="yes" xml:space="preserve">
          <source>The four scopes are:</source>
          <target state="translated">네 가지 범위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="667c33893d889bc80fd5ed9df2f266c2588c1bb5" translate="yes" xml:space="preserve">
          <source>The idea of scoping in JavaScript when originally designed by &lt;a href=&quot;https://en.wikipedia.org/wiki/Brendan_Eich&quot;&gt;Brendan Eich&lt;/a&gt; came from the &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperCard&quot;&gt;HyperCard&lt;/a&gt; scripting language &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperTalk&quot;&gt;HyperTalk&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Brendan_Eich&quot;&gt;Brendan Eich&lt;/a&gt; 가 처음 디자인했을 때 JavaScript 범위 지정 아이디어는 &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperCard&quot;&gt;HyperCard&lt;/a&gt; 스크립팅 언어 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperTalk&quot;&gt;HyperTalk&lt;/a&gt; 에서 나왔습니다.</target>
        </trans-unit>
        <trans-unit id="7f6410942035541f508ed90e604fa26f865ffb4a" translate="yes" xml:space="preserve">
          <source>The key, as I understand it, is that Javascript has function level scoping vs the more common C block scoping.</source>
          <target state="translated">내가 이해하는 열쇠는 Javascript가 함수 레벨 범위 지정보다 일반적인 C 블록 범위 지정이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="baa8f0251c2ad4e18b3c034ad72ce894cbff4fc8" translate="yes" xml:space="preserve">
          <source>The same concepts of lexically scope and scopechain still apply in &lt;code&gt;ES6&lt;/code&gt;. However a new ways to declare variables were introduced. There are the following:</source>
          <target state="translated">동일한 어휘 범위 및 범위 체인 개념이 &lt;code&gt;ES6&lt;/code&gt; 에도 여전히 적용됩니다. 그러나 변수를 선언하는 새로운 방법이 도입되었습니다. 다음이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1facbc7c1c1f813cff549c1dd5c9ee65e8b26f21" translate="yes" xml:space="preserve">
          <source>The scope of the variables that an &lt;code&gt;on*&lt;/code&gt; attribute can reference &lt;em&gt;must&lt;/em&gt; be either:</source>
          <target state="translated">&lt;code&gt;on*&lt;/code&gt; 속성이 참조 할 수있는 변수의 범위는 다음 중 하나 &lt;em&gt;여야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a525d3c4347396db376dab57fb2b417bb3d3c520" translate="yes" xml:space="preserve">
          <source>The this binding will point to the containing object. Sometimes scopes or execution contexts change without the containing object changing, such as in a declared function where the containing object may be &lt;code&gt;window&lt;/code&gt; or a constructor function.</source>
          <target state="translated">이 바인딩은 포함하는 객체를 가리 킵니다. 포함 객체가 &lt;code&gt;window&lt;/code&gt; 또는 생성자 함수일 수있는 선언 된 함수에서와 같이 포함 객체가 변경되지 않고 범위 또는 실행 컨텍스트가 변경되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d36f4ed020b3d4b8edb17fc4c526b8cb4fb6d80" translate="yes" xml:space="preserve">
          <source>The top level of an ES6 module is similar to that of the inside of an IIFE on the top level in a normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;. The module can reference any variables which are global, and nothing can reference anything inside the module unless the module is explicitly designed for it.</source>
          <target state="translated">ES6 모듈의 최상위 레벨은 일반 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 의 최상위 레벨에있는 IIFE 내부의 최상위 레벨과 유사합니다. 모듈은 전역 변수를 참조 할 수 있으며, 모듈이 명시 적으로 설계된 경우가 아니면 모듈 내부의 어떤 것도 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7125f4b24be7f56c5a5737818cdbed770efa08f5" translate="yes" xml:space="preserve">
          <source>The top of a control structure (eg. loop, if, while etc)</source>
          <target state="translated">제어 구조의 상단 (예 : 루프, if, while 등)</target>
        </trans-unit>
        <trans-unit id="ec84a003493d5f7ad27772f7fadcf69a38c15e22" translate="yes" xml:space="preserve">
          <source>The top of the stack takes precedence (the bottom being the global context)</source>
          <target state="translated">스택의 상단이 우선합니다 (하단은 전역 컨텍스트 임)</target>
        </trans-unit>
        <trans-unit id="e5147662f95f20c6a0a89a3a7abbdb020dd6c0a5" translate="yes" xml:space="preserve">
          <source>There are ALMOST only two types of JavaScript scopes:</source>
          <target state="translated">ALMOST에는 두 가지 유형의 JavaScript 범위 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb06dfbee4e2593fde4a86d0b540f447341e7d7e" translate="yes" xml:space="preserve">
          <source>There are only function scopes in JS. Not block scopes!
You can see what is hoisting too.</source>
          <target state="translated">JS에는 기능 범위 만 있습니다. 범위를 차단하지 마십시오! 당신은 무엇을 게양을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06ad5b6a8156a5d1e0ba464b34addb7c1635409b" translate="yes" xml:space="preserve">
          <source>There are three pertinent factors in deciding the &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_(computer_science)&quot;&gt;scope&lt;/a&gt; of an &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords&quot;&gt;identifier&lt;/a&gt; in JavaScript:</source>
          <target state="translated">JavaScript에서 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords&quot;&gt;식별자&lt;/a&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_(computer_science)&quot;&gt;범위&lt;/a&gt; 를 결정하는 데는 세 가지 관련 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f972bb206c8387750ed69130eeb77040dd103a2" translate="yes" xml:space="preserve">
          <source>There are two types of scopes in JavaScript.</source>
          <target state="translated">JavaScript에는 두 가지 유형의 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1a1af2ae159fa99a59c517a33be2803648d6f2f" translate="yes" xml:space="preserve">
          <source>These are some browsers that don't support &lt;code&gt;let&lt;/code&gt; at all :</source>
          <target state="translated">다음은 전혀 지원하지 않는 일부 브라우저입니다.</target>
        </trans-unit>
        <trans-unit id="4157cf90189663de2f2e49ae60f774e33bc5176b" translate="yes" xml:space="preserve">
          <source>These execution contexts are created any time control is transferred. Control is transferred when code begins to execute, and this is primarily done from function execution.</source>
          <target state="translated">이러한 실행 컨텍스트는 제어가 전송 될 때마다 작성됩니다. 코드 실행이 시작되면 제어가 전송되며 이는 주로 함수 실행에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fcd7046418deb6ee5f24a080449c0d25ed0ec8aa" translate="yes" xml:space="preserve">
          <source>These linked lexical environments form a scope &quot;chain&quot;. Identifier resolution is the process of searching along this chain for a matching identifier.</source>
          <target state="translated">이러한 연결된 어휘 환경은 범위 &quot;체인&quot;을 형성합니다. 식별자 확인은이 체인을 따라 일치하는 식별자를 검색하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="523f7d75f219807a90812d1a03a76d634bd34fc6" translate="yes" xml:space="preserve">
          <source>This idea of &quot;scope levels&quot; explains why &quot;this&quot; can be changed with a newly created scope, if it's being looked up in a nested function.
Here is a link that goes into all these details, &lt;a href=&quot;https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/&quot;&gt;Everything you wanted to know about javascript scope&lt;/a&gt;</source>
          <target state="translated">&quot;범위 수준&quot;에 대한이 개념은 중첩 된 함수에서 조회되는 경우 &quot;이&quot;가 새로 작성된 범위로 변경 될 수있는 이유를 설명합니다. 여기에 모든 세부 사항으로 연결되는 링크가 &lt;a href=&quot;https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/&quot;&gt;있습니다 .Javascript 범위에 대해 알고 싶은 모든 것&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88c46fe2afcb6c5ec1d4bbaa556544f6c35d6851" translate="yes" xml:space="preserve">
          <source>This is exactly how the JavaScript scoping system is designed. It just has different names. The cards in JavaScript are known as &lt;strong&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;Execution Contexts&lt;sup&gt;ECMA&lt;/sup&gt;&lt;/a&gt;&lt;/strong&gt;. Each one of these contexts contains three main parts. A variable environment, a lexical environment, and a this binding. Going back to the cards reference, the lexical environment contains all of the content from prior cards lower in the stack. The current context is at the top of the stack and any content declared there will be stored in the variable environment. The variable environment will take precedence in the case of naming collisions.</source>
          <target state="translated">이것이 바로 JavaScript 범위 지정 시스템이 설계된 방식입니다. 이름이 다릅니다. JavaScript의 카드는 &lt;strong&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;Execution Contexts &lt;sup&gt;ECMA라고&lt;/sup&gt;&lt;/a&gt;&lt;/strong&gt; 합니다. 이러한 맥락 각각에는 세 가지 주요 부분이 있습니다. 가변 환경, 어휘 환경 및이 바인딩 카드 참조로 돌아가서 어휘 환경에는 스택에서 이전 카드의 모든 내용이 포함됩니다. 현재 컨텍스트는 스택 맨 위에 있으며 여기에 선언 된 모든 컨텐츠는 변수 환경에 저장됩니다. 이름 충돌의 경우 변수 환경이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f86bca7d7675134768be73474570815258963447" translate="yes" xml:space="preserve">
          <source>This may seem counter intuitive, but it makes sense from the perspective of a imperative language designer.</source>
          <target state="translated">이것은 직관적이지 않은 것처럼 보이지만 명령형 언어 디자이너의 관점에서 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9569372657d997762301d2a05e690ebc258d5cc1" translate="yes" xml:space="preserve">
          <source>Thus, in JavaScript, scope is implemented via lexical environments linked together in a &quot;chain&quot; by outer references. This chain of lexical environments is called the scope chain, and identifier resolution occurs by &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference&quot;&gt;searching up the chain&lt;/a&gt; for a matching identifier.</source>
          <target state="translated">따라서 JavaScript에서 범위는 외부 참조에 의해 &quot;체인&quot;으로 함께 연결된 어휘 환경을 통해 구현됩니다. 이 어휘 환경 체인을 스코프 체인이라고하며 일치하는 식별자를 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference&quot;&gt;찾기 위해 체인&lt;/a&gt; 을 검색하여 식별자를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bb6c7e872133e98aeb218ad6ea9c62cee6491672" translate="yes" xml:space="preserve">
          <source>To understand the difference between functional scope and block scope, consider the following code :</source>
          <target state="translated">기능 범위와 블록 범위의 차이점을 이해하려면 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0163360cc80ec2993c1c8f16533f6de416e326dd" translate="yes" xml:space="preserve">
          <source>Traditionally, JavaScript really only has two types of scope :</source>
          <target state="translated">일반적으로 JavaScript는 실제로 두 가지 유형의 범위 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="87b058d74fbe7f22fbb0efb4d9425bc6faa878b9" translate="yes" xml:space="preserve">
          <source>Traditionally, you create your variables like this :</source>
          <target state="translated">전통적으로 다음과 같이 변수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ad29238d291882475644003da99e61f8bc49a03b" translate="yes" xml:space="preserve">
          <source>Try the feature at:</source>
          <target state="translated">다음 기능을 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="2c33461d5cae3061ba752f33725ddcdee0745df3" translate="yes" xml:space="preserve">
          <source>Try this curious example. In the example below if a were a numeric initialized at 0, you'd see 0 and then 1. Except a is an object and javascript will pass f1 a pointer of a rather than a copy of it. The result is that you get the same alert both times.</source>
          <target state="translated">이 호기심 많은 예를보십시오. 아래 예제에서 a가 0에서 초기화 된 숫자 인 경우 0과 1이 표시됩니다. a는 객체이고 javascript는 f1을 복사하지 않고 포인터로 전달합니다. 결과적으로 동일한 경고가 두 번 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9a31c380e5d5713a5b5f2cac2a38ce95810e231c" translate="yes" xml:space="preserve">
          <source>Using functions instead:</source>
          <target state="translated">대신 함수 사용하기 :</target>
        </trans-unit>
        <trans-unit id="09e07e786d7ad2ec030bf960813f71d135a77b77" translate="yes" xml:space="preserve">
          <source>Variables declared globally have a global scope. Variables declared within a function are scoped to that function, and shadow global variables of the same name.</source>
          <target state="translated">전역 적으로 선언 된 변수에는 전역 범위가 있습니다. 함수 내에서 선언 된 변수는 해당 함수로 범위가 지정되고 동일한 이름의 전역 변수를 음영 처리합니다.</target>
        </trans-unit>
        <trans-unit id="83f6135eb31f7889cc2bae9bf00eaae24a2268d7" translate="yes" xml:space="preserve">
          <source>Variables declared using &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; are all scoped to modules:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 를 사용하여 선언 된 변수는 모두 모듈 범위입니다.</target>
        </trans-unit>
        <trans-unit id="e63da6c1c1854a483ec37bd48437243581e43830" translate="yes" xml:space="preserve">
          <source>Variables in Javascript were initially (pre &lt;code&gt;ES6&lt;/code&gt;) lexically function scoped. The term lexically scoped means that you can see the scope of the variables by 'looking' at the code.</source>
          <target state="translated">Javascript의 변수는 초기에 사전 &lt;code&gt;ES6&lt;/code&gt; 이전의 어휘 기능 범위였습니다. 어휘 범위라는 용어는 코드를 '보고'변수의 범위를 볼 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="79b5a1ec62a5c78bf7572a8c6548c2e713ed3a8a" translate="yes" xml:space="preserve">
          <source>View the code at:</source>
          <target state="translated">다음에서 코드를보십시오.</target>
        </trans-unit>
        <trans-unit id="d113eb702e389cf7c505ecfecd3bb29698f276f3" translate="yes" xml:space="preserve">
          <source>We try to log bar to the console, bar cannot be found inside the function &lt;code&gt;innerFunc&lt;/code&gt; itself. Therefore, we need to &lt;strong&gt;climb the scope chain&lt;/strong&gt;. We first look in the outer function in which the function &lt;code&gt;innerFunc&lt;/code&gt; was defined. This is the function &lt;code&gt;outerFunc&lt;/code&gt;. In the scope of &lt;code&gt;outerFunc&lt;/code&gt; we can find the variable bar, which holds the string 'outerFunc'.</source>
          <target state="translated">bar를 콘솔에 기록하려고 시도하는데 &lt;code&gt;innerFunc&lt;/code&gt; 자체에서 bar를 찾을 수 없습니다. 따라서 &lt;strong&gt;스코프 체인&lt;/strong&gt; 을 &lt;strong&gt;올라 가야합니다&lt;/strong&gt; . 먼저 &lt;code&gt;innerFunc&lt;/code&gt; 함수가 정의 된 외부 함수를 살펴 봅니다. 이것은 &lt;code&gt;outerFunc&lt;/code&gt; 함수 입니다 . &lt;code&gt;outerFunc&lt;/code&gt; 의 범위에서 문자열 'outerFunc'를 보유하는 변수 막대를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33483a29e47769decbe475c651c75e62bcc26c1d" translate="yes" xml:space="preserve">
          <source>We try to log foo to the console, foo can be found inside the function &lt;code&gt;innerFunc&lt;/code&gt; itself. Therefore, the value of foo is resolved to the string &lt;code&gt;innerFunc&lt;/code&gt;.</source>
          <target state="translated">우리는 foo를 콘솔에 기록하려고 시도합니다. foo는 &lt;code&gt;innerFunc&lt;/code&gt; 함수 자체에서 찾을 수 있습니다. 따라서 foo 값은 문자열 &lt;code&gt;innerFunc&lt;/code&gt; 로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="f557bb3c7aec4df772e0ff73b2192b0c2d60c84e" translate="yes" xml:space="preserve">
          <source>What happens when we are trying to log the variables &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;foobar&lt;/code&gt; to the console is the following:</source>
          <target state="translated">변수 &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;foobar&lt;/code&gt; 를 콘솔에 기록하려고 할 때 발생하는 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b903fe3f970849861b225b53f498c1947e65555" translate="yes" xml:space="preserve">
          <source>What is the scope of variables in JavaScript</source>
          <target state="translated">JavaScript에서 변수의 범위는 무엇입니까</target>
        </trans-unit>
        <trans-unit id="c23272951273b7fc083d376b564db88d3610470d" translate="yes" xml:space="preserve">
          <source>What is the scope of variables in javascript? Do they have the same scope inside as opposed to outside a function? Or does it even matter? Also, where are the variables stored if they are defined globally?</source>
          <target state="translated">자바 스크립트에서 변수의 범위는 무엇입니까? 그것들은 함수 외부와 반대로 내부와 동일한 범위를 가지고 있습니까? 아니면 중요합니까? 또한 전역 적으로 정의 된 변수는 어디에 저장됩니까?</target>
        </trans-unit>
        <trans-unit id="8bd7003d51c50f3c8761d33449fe913c8f8cac5b" translate="yes" xml:space="preserve">
          <source>When a function look to resolve a variable value it first looks at its own scope. This is the function body, i.e. everything between curly brackets {} (except for variables inside &lt;strong&gt;other&lt;/strong&gt;&lt;strong&gt;functions&lt;/strong&gt; which are in this scope).</source>
          <target state="translated">함수가 변수 값을 확인할 때 먼저 자체 범위를 봅니다. 이것은 함수 본문입니다. 즉 중괄호 {} 사이의 모든 것입니다 (이 범위에있는 &lt;strong&gt;다른&lt;/strong&gt; &lt;strong&gt;함수&lt;/strong&gt; 내의 변수는 제외).</target>
        </trans-unit>
        <trans-unit id="7b320f88c37b5d9ddd50505ed7068dbeb83bd406" translate="yes" xml:space="preserve">
          <source>When resolving a variable, javascript starts at the innermost scope and searches outwards.</source>
          <target state="translated">변수를 해결할 때 javascript는 가장 안쪽 범위에서 시작하여 바깥쪽으로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d7cb4beab01b349af01d024bbaf1102dfb872104" translate="yes" xml:space="preserve">
          <source>When you invoke a function, the hidden &lt;code&gt;[[Call]]&lt;/code&gt; method is called. This method creates a new execution context and establishes a link between the new execution context and the lexical environment of the function-object. It does this by copying the &lt;code&gt;[[Environment]]&lt;/code&gt; value on the function-object, into an &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;outer reference&lt;/a&gt; field on the lexical environment of the new execution context.</source>
          <target state="translated">함수를 호출하면 숨겨진 &lt;code&gt;[[Call]]&lt;/code&gt; 메소드가 호출됩니다. 이 메소드는 새로운 실행 컨텍스트를 작성하고 새 실행 컨텍스트와 함수 오브젝트의 어휘 환경 사이에 링크를 설정합니다. 함수 객체의 &lt;code&gt;[[Environment]]&lt;/code&gt; 값을 새로운 실행 컨텍스트의 어휘 환경에있는 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;외부 참조&lt;/a&gt; 필드에 복사하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c96ef28eb7eabf77773b3a19be2f5414a421175a" translate="yes" xml:space="preserve">
          <source>Where an identifier was declared</source>
          <target state="translated">식별자가 선언 된 곳</target>
        </trans-unit>
        <trans-unit id="db4779584d083e695bd0cf37cd44aa1429a309bc" translate="yes" xml:space="preserve">
          <source>Whether or not it is safe to use today, depends on your environment :</source>
          <target state="translated">오늘날 사용하기에 안전한지 여부는 환경에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="98f46dd1a1ed53e1e44f3ab136ef987e105853e9" translate="yes" xml:space="preserve">
          <source>Whether you are in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;strict mode&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode&quot;&gt;non-strict mode&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;엄격 모드&lt;/a&gt; 인지 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode&quot;&gt;비&lt;/a&gt; 엄격 모드 인지 여부</target>
        </trans-unit>
        <trans-unit id="866faa243c8cb14d4f4502051230db635e4581a1" translate="yes" xml:space="preserve">
          <source>Window level - &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;outer&lt;/code&gt; function are at top level in scope chain.</source>
          <target state="translated">창 수준-a 및 &lt;code&gt;outer&lt;/code&gt; 기능이 스코프 체인에서 최상위 수준에 있습니다.</target>
        </trans-unit>
        <trans-unit id="61285999208212a66bb8fb8f69cb29c51fc58afb" translate="yes" xml:space="preserve">
          <source>Yikes!  Be careful using 'with' -- just like var is a noop if the variable is already defined in the function, it is also a noop with respect to names imported from the object!  A little heads up on the name already being defined would make this much safer.  I personally will never use with because of this.</source>
          <target state="translated">이케 스! 변수가 이미 함수에 정의되어 있다면 var는 noop 인 것처럼 'with'를 사용하는 것에주의하십시오. 객체에서 가져온 이름과 관련하여 noop이기도합니다! 이미 정의 된 이름에 약간의 머리글이 있으면 훨씬 더 안전합니다. 이 때문에 개인적으로는 절대 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="653677cec5274421cb19c2c9eb0bf04f82dca290" translate="yes" xml:space="preserve">
          <source>You should be using block scoping for every variable you create, just like most other major languages. &lt;code&gt;var&lt;/code&gt; is &lt;em&gt;obsolete&lt;/em&gt;. This makes your code safer and more maintainable.</source>
          <target state="translated">대부분의 다른 주요 언어와 마찬가지로 작성하는 모든 변수에 대해 블록 범위 지정을 사용해야합니다. &lt;code&gt;var&lt;/code&gt; 는 &lt;em&gt;더 이상 사용되지 않습니다&lt;/em&gt; . 이를 통해 코드를보다 안전하고 유지 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="98d045c503931bcf6ef7f9b40c8422ec1ba5b590" translate="yes" xml:space="preserve">
          <source>You'll want to investigate closures, and how to use them to make &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;private members&lt;/a&gt;.</source>
          <target state="translated">클로저를 조사하고 클로저를 사용하여 &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;비공개 회원&lt;/a&gt; 을 만드는 방법을 조사하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b63f2d6c0c543f4dd14dae138ce110ce4819bafe" translate="yes" xml:space="preserve">
          <source>a property of the document (eg, &lt;code&gt;querySelector&lt;/code&gt; as a standalone variable will point to &lt;code&gt;document.querySelector&lt;/code&gt;; rare)</source>
          <target state="translated">문서의 속성 (예 : 독립형 변수 인 &lt;code&gt;querySelector&lt;/code&gt; 는 &lt;code&gt;document.querySelector&lt;/code&gt; 를 가리 킵니다. 드문 경우)</target>
        </trans-unit>
        <trans-unit id="fceff746a314cc08e9d118ad4bd96fa755c80556" translate="yes" xml:space="preserve">
          <source>a property of the element the handler is attached to (like above; rare)</source>
          <target state="translated">핸들러가 부착 된 요소의 속성 (위와 같으며 드문 경우)</target>
        </trans-unit>
        <trans-unit id="822bc13e2d55b402eb4233cb23c9d414a7a03bc1" translate="yes" xml:space="preserve">
          <source>eval</source>
          <target state="translated">eval</target>
        </trans-unit>
        <trans-unit id="48a783d527b12bb1b6d12822df507e3056d403cb" translate="yes" xml:space="preserve">
          <source>foobar cannot be found in innerFunc. . Therefore, we need to &lt;strong&gt;climb the scope chain&lt;/strong&gt; to the innerFunc scope. It also cannot be found here, we climb another level to the &lt;strong&gt;global scope&lt;/strong&gt; (i.e. the outermost scope). We find the variable foobar here which holds the string 'global'. If it wouldnot have found the variable after climbing the scope chain the JS engine would throw a &lt;strong&gt;referenceError&lt;/strong&gt;.</source>
          <target state="translated">innerFunc에서 foobar를 찾을 수 없습니다. . 따라서 &lt;strong&gt;스코프 체인&lt;/strong&gt; 을 innerFunc 스코프까지 &lt;strong&gt;올라 가야합니다&lt;/strong&gt; . 또한 여기서 찾을 수 없습니다. 우리는 또 다른 차원을 &lt;strong&gt;글로벌 범위&lt;/strong&gt; (즉, 가장 바깥 쪽 범위)로 올립니다. 문자열 'global'을 보유한 변수 foobar가 있습니다. 스코프 체인을 올라간 후 변수를 찾지 못하면 JS 엔진은 &lt;strong&gt;referenceError를 발생&lt;/strong&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="887ec4e4d84f875ed30e16b3b555dc44c974324c" translate="yes" xml:space="preserve">
          <source>global (working inline handlers almost always reference global variables)</source>
          <target state="translated">전역 (작업 인라인 핸들러는 거의 항상 전역 변수를 참조합니다)</target>
        </trans-unit>
        <trans-unit id="7344f99b192214421819b3d6d5d5eb925e77386f" translate="yes" xml:space="preserve">
          <source>if there is no enclosing function for a var declaration, it is global scope</source>
          <target state="translated">var 선언에 대한 엔 클로징 함수가 없으면 전역 범위입니다.</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb722bbe2d7de5616bde8841cec1f7151c36e813" translate="yes" xml:space="preserve">
          <source>let and const</source>
          <target state="translated">let과 const</target>
        </trans-unit>
        <trans-unit id="ff9c22082a2b010df2415de1fe69a90317ccdf1c" translate="yes" xml:space="preserve">
          <source>multiple var declarations within the same scope are combined</source>
          <target state="translated">동일한 범위 내의 여러 var 선언이 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="222f16742f8432d094b140df773f638f634a3fe5" translate="yes" xml:space="preserve">
          <source>run the code. hope this will give an idea about scoping</source>
          <target state="translated">코드를 실행하십시오. 이것이 범위 지정에 대한 아이디어를 줄 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="e50c3161b714f4fa46bad3943d0cfb3418bf98a5" translate="yes" xml:space="preserve">
          <source>test1 is scoped to the with block, but is aliased to a.test1.  'Var test1' creates a new variable test1 in the upper lexical context (function, or global), unless it is a property of a -- which it is.</source>
          <target state="translated">test1의 범위는 with 블록이지만 a.test1의 별칭입니다. 'Var test1'은 어휘 컨텍스트 (함수 또는 전역)에 새로운 변수 test1을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7c5e5564e501683f6afb89ae0a4affd1e86cdeb1" translate="yes" xml:space="preserve">
          <source>the scope of each var declaration is associated with the most immediately enclosing function</source>
          <target state="translated">각 var 선언의 범위는 가장 즉시 둘러싸는 함수와 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="a4ebaeeee765207f3a08fde4e0bf36e28958ad9a" translate="yes" xml:space="preserve">
          <source>try/catch introduce new scope ONLY for the exception variable itself, other variables do not have new scope</source>
          <target state="translated">try / catch는 예외 변수 자체에만 새로운 범위를 도입하고 다른 변수에는 새로운 범위가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5b4e786e382d03c28e9edfab2d8149378ae69df" translate="yes" xml:space="preserve">
          <source>var</source>
          <target state="translated">var</target>
        </trans-unit>
        <trans-unit id="7357ecfa390afc2fce34c3167335bf743c442659" translate="yes" xml:space="preserve">
          <source>var declarations are hoisted to the top of the scope. This means no matter where the var declaration happens, to the compiler it is as if the var itself happens at the top</source>
          <target state="translated">var 선언은 범위의 맨 위로 들어갑니다. 이것은 var 선언이 어디에서 발생하더라도 컴파일러 자체가 var 자체가 최상위에서 일어나는 것처럼</target>
        </trans-unit>
        <trans-unit id="80e40e219ee78a38babf8cce499fd3cb0f6182af" translate="yes" xml:space="preserve">
          <source>when outer function called a new &lt;code&gt;variable scope object&lt;/code&gt;(and included in scope chain) added with variable &lt;code&gt;b&lt;/code&gt; inside it.</source>
          <target state="translated">외부 함수가 새로운 &lt;code&gt;variable scope object&lt;/code&gt; 호출하고 (범위 체인에 포함) 변수 &lt;code&gt;b&lt;/code&gt; 가 내부에 추가되었을 때.</target>
        </trans-unit>
        <trans-unit id="5b3cb00aa7dfc23400daf50a18606b8161567f7b" translate="yes" xml:space="preserve">
          <source>with-clause apparently is another exception, but using with-clause it highly discouraged (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&lt;/a&gt;)</source>
          <target state="translated">with-clause는 분명히 또 다른 예외이지만 with-clause를 사용하면 권장하지 않습니다 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&lt;/a&gt; )</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
