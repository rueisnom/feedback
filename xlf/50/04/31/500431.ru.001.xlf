<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/500431">
    <body>
      <group id="500431">
        <trans-unit id="b2b80089f01682b9f7777a6969b9faaa80407f05" translate="yes" xml:space="preserve">
          <source>(I'm sure there are many subtleties that real JavaScript programmers will be able to point out in other answers. In particular I came across &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;this page&lt;/a&gt; about what exactly &lt;code&gt;this&lt;/code&gt; means at any time. Hopefully &lt;a href=&quot;http://bowles.byethost3.com/javascript/section6/lesson6.htm#part4&quot;&gt;this more introductory link&lt;/a&gt; is enough to get you started though.)</source>
          <target state="translated">(Я уверен, что есть много тонкостей, на которые настоящие программисты JavaScript смогут указать в других ответах. В частности, я наткнулся на &lt;a href=&quot;http://www.digital-web.com/articles/scope_in_javascript/&quot;&gt;эту страницу&lt;/a&gt; о том, что именно &lt;code&gt;this&lt;/code&gt; означает в любое время. Надеюсь, &lt;a href=&quot;http://bowles.byethost3.com/javascript/section6/lesson6.htm#part4&quot;&gt;этой более вводной ссылки&lt;/a&gt; достаточно, чтобы вы начали хоть.)</target>
        </trans-unit>
        <trans-unit id="2b079c997f6e9e9f11e2b8533c11a4cdefaf6c17" translate="yes" xml:space="preserve">
          <source>...because of this behavior you need to be careful about closing over variables declared using &lt;code&gt;var&lt;/code&gt; in loops. There is only one instance of variable &lt;code&gt;x&lt;/code&gt; declared here, and it sits logically outside of the loop.</source>
          <target state="translated">... из-за этого поведения вы должны быть осторожны при закрытии переменных, объявленных с использованием переменных в циклах. Здесь объявлен только один экземпляр переменной &lt;code&gt;x&lt;/code&gt; , и он логически находится вне цикла.</target>
        </trans-unit>
        <trans-unit id="c2a9084e5d3eb2e4718aab6268e78f5823849081" translate="yes" xml:space="preserve">
          <source>1) There is a global scope, a function scope, and the with and catch scopes. There is no 'block' level scope in general for variable's -- the with and the catch statements add names to their blocks.</source>
          <target state="translated">1)Существует глобальный масштаб,функциональный охват,а также с и с охватом.Для переменных вообще нет области видимости уровня 'block' --операторы catch и with добавляют имена к своим блокам.</target>
        </trans-unit>
        <trans-unit id="a7c489f0a7142c687da2af2321ca060655d7e2f8" translate="yes" xml:space="preserve">
          <source>2) Scopes are nested by functions all the way to the global scope.</source>
          <target state="translated">2)Охваты вложены функциями вплоть до глобального масштаба.</target>
        </trans-unit>
        <trans-unit id="d749b9c70cd3d6ec5a37f9e5c4bb7316601c2a74" translate="yes" xml:space="preserve">
          <source>3) Properties are resolved by going through the prototype chain.  The with statement brings object property names into the lexical scope defined by the with block.</source>
          <target state="translated">3)Свойства решаются путем прохождения цепочки прототипов.Оператор с оператором выводит имена свойств объектов в лексическую область,определяемую блоком с блоком.</target>
        </trans-unit>
        <trans-unit id="08b17079c570142726687fb2c5c9bb253783c20e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES5&lt;/code&gt; and earlier:</source>
          <target state="translated">&lt;code&gt;ES5&lt;/code&gt; и более ранние:</target>
        </trans-unit>
        <trans-unit id="2ac152d0029db3c7cd7c3a77df7bfef8ae5d4c57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES6&lt;/code&gt; (ES 2015) and older:</source>
          <target state="translated">&lt;code&gt;ES6&lt;/code&gt; (ES 2015) и старше:</target>
        </trans-unit>
        <trans-unit id="c4c1a80bcfde13b5ffe96bdafa9c43b74b195f4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; should be used for &lt;strong&gt;95% of cases&lt;/strong&gt;. It makes it so the variable &lt;em&gt;reference&lt;/em&gt; can't change. Array, object, and DOM node properties can change and should likely be &lt;code&gt;const&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; следует использовать в &lt;strong&gt;95% случаев&lt;/strong&gt; . Это делает так, чтобы &lt;em&gt;ссылка&lt;/em&gt; на переменную не могла измениться. Свойства массива, объекта и узла DOM могут изменяться и, вероятно, должны быть постоянными.</target>
        </trans-unit>
        <trans-unit id="dcf0ad05684411d0af52e47d334a793a1d346e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;: creates a block scoped variable which has to be initialized and cannot be reassigned</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; : создает переменную области блока, которая должна быть инициализирована и не может быть переназначена</target>
        </trans-unit>
        <trans-unit id="84d33e7ec01dc28120ceea7d7d07bb9ccda0bdcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; заявления</target>
        </trans-unit>
        <trans-unit id="f378613076c429aa47b0bc460bdfb9fd805b2aa3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; in the global context do not add properties to the global object, but still have global scope:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; в глобальном контексте не добавляют свойства к глобальному объекту, но все еще имеют глобальную область видимости:</target>
        </trans-unit>
        <trans-unit id="23ddb5e06f75a482ff3a507bfea2c6482c39eb0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; should be be used for any variable expecting to be reassigned. This includes within a for loop. If you ever change value beyond initialization, use &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; следует использовать для любой переменной, ожидающей переназначения. Это включает в себя цикл for. Если вы когда-нибудь измените значение после инициализации, используйте &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39836bea22536ebe1993a1b9a30ed5062e7fc910" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;: creates a block scoped variable</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; : создает переменную области видимости блока</target>
        </trans-unit>
        <trans-unit id="f86a4d006feac6327fadfafd72bedb4b3013db57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23a7586104558b94ef7294bd102a26a3fee7bc25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(*) Globally and functionally scoped variables can be initialized and used before they are declared because JavaScript variables are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;hoisted&lt;/strong&gt;&lt;/a&gt;.&lt;/em&gt; This means that declarations are always much to the top of the scope.</source>
          <target state="translated">&lt;em&gt;(*) Глобальные и функциональные переменные могут быть инициализированы и использованы до того, как объявлены, потому что переменные JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;&lt;strong&gt;подняты&lt;/strong&gt;&lt;/a&gt; .&lt;/em&gt; Это означает, что объявления всегда находятся на вершине области видимости.</target>
        </trans-unit>
        <trans-unit id="f1f37e4dcff2ea462372b5383bfff8d1536133fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Whenever a function is called, a variable scope object is created (and included in scope chain) which is followed by variables in JavaScript.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Каждый раз, когда вызывается функция, создается объект переменной области (и включается в цепочку областей действия), за которой следуют переменные в JavaScript.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b4f1e280e8a84dd1613867f45aea9b5a09b5e95c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;i&lt;/em&gt;) The outer context. It has a variable environment of a = 1</source>
          <target state="translated">&lt;em&gt;я&lt;/em&gt; ) Внешний контекст. Имеет переменную среду с = 1</target>
        </trans-unit>
        <trans-unit id="27dcebcb7c447ec33f3b94ab4786b7e8986fc48a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ii&lt;/em&gt;) The IIFE context, it has a lexical environment of a = 1, but a variable environment of a = 6 which takes precedence in the stack</source>
          <target state="translated">&lt;em&gt;ii&lt;/em&gt; ) контекст IIFE, он имеет лексическую среду a = 1, но переменную среду a = 6, которая имеет приоритет в стеке</target>
        </trans-unit>
        <trans-unit id="f2d982053f1a3fa4551447f1adedd54422f021ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;iii&lt;/em&gt;) The returned function context, it has a lexical environment of a = 6 and that is the value referenced in the alert when called.</source>
          <target state="translated">&lt;em&gt;iii&lt;/em&gt; ) Возвращенный контекст функции, он имеет лексическую среду a = 6, и это значение, на которое ссылается предупреждение при вызове.</target>
        </trans-unit>
        <trans-unit id="f56505ee4c5ecc9846d96be13e7dc0c3c70dfa98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Android browser 4&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Android-браузер 4&lt;/strong&gt; и ниже</target>
        </trans-unit>
        <trans-unit id="55a8f93e956bc391290a79206606d9be4627b589" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Block Scope&lt;/strong&gt; : Identifiers are &quot;known&quot; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;from the top of the scope they are declared within&lt;/a&gt;, but they cannot be assigned to or dereferenced (read) until after the line of their declaration. This interim period is called the &quot;temporal dead zone.&quot;</source>
          <target state="translated">&lt;strong&gt;Блок-область&lt;/strong&gt; . Идентификаторы &amp;laquo;известны&amp;raquo; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;из верхней части области, в которой они объявлены&lt;/a&gt; , но они не могут быть назначены или разыменованы (прочитаны) до окончания строки их объявления. Этот промежуточный период называется &amp;laquo;временной мертвой зоной&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2f05c56877d8601614fa63855f086a2652e865c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Chome 40&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Chome 40&lt;/strong&gt; и ниже</target>
        </trans-unit>
        <trans-unit id="d99cf4a17169c81d37ec13856f6710a2a76cbbad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Firefox 43&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Firefox 43&lt;/strong&gt; и ниже</target>
        </trans-unit>
        <trans-unit id="08cd2fc5597977a2613daeb7f079fd9fa0eb16b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional Scope&lt;/strong&gt; : Variable declared within a function with &lt;code&gt;var&lt;/code&gt; keyword has functional scope.</source>
          <target state="translated">&lt;strong&gt;Функциональная область&lt;/strong&gt; : переменная, объявленная в функции с ключевым словом &lt;code&gt;var&lt;/code&gt; , имеет функциональную область.</target>
        </trans-unit>
        <trans-unit id="a13963dd31b44d28a808a5e2917cae4be7b837de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional Scope&lt;/strong&gt; : Variables are known within &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;the function&lt;/strong&gt;&lt;/a&gt; they are declared in, from the start of the function &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Функциональная сфера&lt;/strong&gt; : переменные известны в &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;&lt;strong&gt;той функции, в которой&lt;/strong&gt;&lt;/a&gt; они объявлены, с начала функции &lt;em&gt;(*)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7298e7a71a2f69245853e050c4bdee749e978e9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional scope or Local scope&lt;/strong&gt;: variable declared in this scope can be used in its own function only. For example:</source>
          <target state="translated">&lt;strong&gt;Функциональная область или локальная область&lt;/strong&gt; : переменная, объявленная в этой области, может использоваться только в своей собственной функции. Например:</target>
        </trans-unit>
        <trans-unit id="89e21e149d0d0dc547601ca86291fe92f9273963" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Scope&lt;/strong&gt; : Global is nothing but a window level scope.Here, variable present throughout the application.</source>
          <target state="translated">&lt;strong&gt;Global Scope&lt;/strong&gt; : Global - это не что иное, как область действия на уровне окна. Здесь переменная присутствует во всем приложении.</target>
        </trans-unit>
        <trans-unit id="f3a549a4e99a97eff2b34e0f09263cffa683cccd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global Scope&lt;/strong&gt; : Variables are known throughout the application, from the start of the application &lt;em&gt;(*)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Глобальная область&lt;/strong&gt; : переменные известны во всем приложении с самого начала приложения &lt;em&gt;(*)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1f34e4a5bfcdc48aa26833768f67160bd571124" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Global scope&lt;/strong&gt;: variable which is announced in global scope can be used anywhere in the program very smoothly. For example:</source>
          <target state="translated">&lt;strong&gt;Глобальная область&lt;/strong&gt; : переменная, объявленная в глобальной области, может использоваться в любом месте программы очень плавно. Например:</target>
        </trans-unit>
        <trans-unit id="a7ca3efb97c36b6d88809b25331124fb1fffa069" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internet explorer 10&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Internet Explorer 10&lt;/strong&gt; и ниже</target>
        </trans-unit>
        <trans-unit id="f68d935bfb76269d4c30258cf31d26f604040556" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opera 27&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Опера 27&lt;/strong&gt; и ниже</target>
        </trans-unit>
        <trans-unit id="050f7cc7d0dc2635f8b52903f766a2c3db495862" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Safari 9&lt;/strong&gt; and below</source>
          <target state="translated">&lt;strong&gt;Safari 9&lt;/strong&gt; и ниже</target>
        </trans-unit>
        <trans-unit id="44e5d520bd9d0fb39f77e303b90adad358405de1" translate="yes" xml:space="preserve">
          <source>A lexical environment is a mapping between identifier names and the values associated with them.</source>
          <target state="translated">Лексическое окружение-это сопоставление имен идентификаторов и связанных с ними значений.</target>
        </trans-unit>
        <trans-unit id="8fd51b0bd0e4f91009d0f3343c699212c3d96c96" translate="yes" xml:space="preserve">
          <source>A variable declared at the top of a &lt;code&gt;for&lt;/code&gt; loop using &lt;code&gt;let&lt;/code&gt; is scoped to the body of the loop:</source>
          <target state="translated">Переменная, объявленная в верхней части цикла &lt;code&gt;for&lt;/code&gt; с помощью &lt;code&gt;let&lt;/code&gt; , находится в теле цикла:</target>
        </trans-unit>
        <trans-unit id="48faefee4b09b7b96e9ee196462af3f716e8b8de" translate="yes" xml:space="preserve">
          <source>A very common issue not described yet that front-end coders often run into is the scope that is visible to an inline event handler in the HTML - for example, with</source>
          <target state="translated">Очень распространенная проблема,еще не описанная,с которой часто сталкиваются фронт-кодеры,это область видимости обработчика событий в HTML-например,с помощью</target>
        </trans-unit>
        <trans-unit id="60fc03a08e44792e776e9738812c0a4cd623a464" translate="yes" xml:space="preserve">
          <source>ANY version of &lt;strong&gt;Opera Mini&lt;/strong&gt; &amp;amp; &lt;strong&gt;Blackberry Browser&lt;/strong&gt;</source>
          <target state="translated">ЛЮБАЯ версия &lt;strong&gt;Opera Mini&lt;/strong&gt; и &lt;strong&gt;Blackberry Browser&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae46cf4abc73a3b9c1f4dfacc1b829774476ba1e" translate="yes" xml:space="preserve">
          <source>Also, consider that block scoped variables are not known before they are declared because they are not hoisted. You're also not allowed to redeclare the same block scoped variable within the same block. This makes block scoped variables less error prone than globally or functionally scoped variables, which are hoisted and which do not produce any errors in case of multiple declarations.</source>
          <target state="translated">Кроме того,следует учитывать,что переменные в блочном пространстве не известны до их объявления,так как они не поднимаются.Вы также не имеете права передекларировать одну и ту же переменную в пределах одного и того же блока.Это делает блок-скопированные переменные менее склонными к ошибкам,чем глобальные или функционально скопированные переменные,которые поднимаются и не производят ошибок в случае множественных деклараций.</target>
        </trans-unit>
        <trans-unit id="cb95f617fd60bdb566772a3a947b9cf56a0e0ee3" translate="yes" xml:space="preserve">
          <source>An element in the scope chain is basically a Map with a pointer to its parent scope.</source>
          <target state="translated">Элементом в цепочке областей видимости в основном является карта с указателем на ее родительскую область видимости.</target>
        </trans-unit>
        <trans-unit id="2f14bc627ff3b593b8ed5e4441d9f45b15ddec5c" translate="yes" xml:space="preserve">
          <source>Applying this to one of the previous examples (5. &quot;Closure&quot;) on this page, it is possible to follow the stack of execution contexts. In this example there are three contexts in the stack. They are defined by the outer context, the context in the immediately invoked function called by var six, and the context in the returned function inside of var six's immediately invoked function.</source>
          <target state="translated">Применяя это к одному из предыдущих примеров (5.&quot;Закрыть&quot;)на этой странице,можно следовать стеку контекстов исполнения.В данном примере в стеке есть три контекста.Они определяются внешним контекстом,контекстом в немедленно вызываемой функции,вызываемой var six,и контекстом в возвращаемой функции внутри немедленно вызываемой функции var six.</target>
        </trans-unit>
        <trans-unit id="425a5e8573ac9d1f6ad5077097cd879a85500359" translate="yes" xml:space="preserve">
          <source>Block - visible within a block (and its sub-blocks)</source>
          <target state="translated">Блок-виден внутри блока (и его подблоков).</target>
        </trans-unit>
        <trans-unit id="b268d619791c64ad9a437793c6df4e96c3bea47e" translate="yes" xml:space="preserve">
          <source>Block scope means that the variable will only be available within the brackets in which it is declared. This extends to internal scopes, including anonymous functions created within your scope.</source>
          <target state="translated">Блокировать область видимости означает,что переменная будет доступна только в скобках,в которых она объявлена.Это распространяется на внутренние области видимости,включая анонимные функции,созданные в вашей области видимости.</target>
        </trans-unit>
        <trans-unit id="6ad05cf476194af6ae4eab02f3b9ae25d3fe726e" translate="yes" xml:space="preserve">
          <source>Block scope variables are created like this :</source>
          <target state="translated">Переменные диапазона блоков создаются таким образом :</target>
        </trans-unit>
        <trans-unit id="d4734d382405fe72442dafef31013eff2bc92678" translate="yes" xml:space="preserve">
          <source>But the top level of an ES6 module is &lt;em&gt;not&lt;/em&gt; global. A variable declared at the top of an ES6 module will only be visible inside that module, unless the variable is explicitly &lt;code&gt;export&lt;/code&gt;ed, or unless it's assigned to a property of the global object.</source>
          <target state="translated">Но верхний уровень модуля ES6 &lt;em&gt;не&lt;/em&gt; является глобальным. Переменная, объявленная в верхней части модуля ES6, будет видна только внутри этого модуля, если только эта переменная явно не &lt;code&gt;export&lt;/code&gt; или не назначена свойству глобального объекта.</target>
        </trans-unit>
        <trans-unit id="c4d272ff3f7fc4237376ed64dc233b59d9966000" translate="yes" xml:space="preserve">
          <source>Catch block parameter</source>
          <target state="translated">Параметр блока улавливания</target>
        </trans-unit>
        <trans-unit id="32c3db15ba22df73876c55e60996667cba034b0c" translate="yes" xml:space="preserve">
          <source>Catch block parameters are scoped to the catch-block body:</source>
          <target state="translated">Параметры блока улавливания заносятся в тело блока улавливания:</target>
        </trans-unit>
        <trans-unit id="6fe813611dd6d84d9a1d26977566960643817c11" translate="yes" xml:space="preserve">
          <source>Check this article for in-depth understanding of scope</source>
          <target state="translated">Ознакомьтесь с этой статьей для более глубокого понимания сферы применения</target>
        </trans-unit>
        <trans-unit id="806b84e63f4442df339c4262199841634c53b286" translate="yes" xml:space="preserve">
          <source>Contexts form a stack of environments where variables are stored</source>
          <target state="translated">Контексты образуют стек сред,в котором хранятся переменные.</target>
        </trans-unit>
        <trans-unit id="3b76905c4fef521cd5b87dffcd70e8f6c5497e77" translate="yes" xml:space="preserve">
          <source>Control structure body</source>
          <target state="translated">Орган управления структурой</target>
        </trans-unit>
        <trans-unit id="9145c9f2f97356d62bd24da8388b2b38acf59902" translate="yes" xml:space="preserve">
          <source>Currently the feature offers support for a depth of 16 nested functions, but currently does not color global variables.</source>
          <target state="translated">В настоящее время функция поддерживает глубину 16 вложенных функций,но на данный момент не окрашивает глобальные переменные.</target>
        </trans-unit>
        <trans-unit id="65fff7fa8d3c3b1a1f3c9528a2264bd097d68887" translate="yes" xml:space="preserve">
          <source>Declaration Styles</source>
          <target state="translated">Декларационные стили</target>
        </trans-unit>
        <trans-unit id="a8fbe250f6e0a7b427bb5ef03aadced5ed432e98" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 introduced the let and const keywords. These keywords can be used in place of the var keyword. Contrary to the var keyword, the let and const keywords support the declaration of local scope inside block statements.</source>
          <target state="translated">ECMAScript 6 ввел ключевые слова let и const.Эти ключевые слова могут быть использованы вместо ключевого слова var.В отличие от ключевого слова var,ключевые слова let и const поддерживают объявление локальной области видимости внутри блочных операторов.</target>
        </trans-unit>
        <trans-unit id="e4c8806859640baf11f724a1eec52c4f7c4afcf5" translate="yes" xml:space="preserve">
          <source>EDIT: Based on Benjamin's pointing out of the with and catch statements in the comments, I've edited the post, and added more.  Both the with and the catch statements introduce variables into their respective blocks, and that &lt;em&gt;is&lt;/em&gt; a block scope. These variables are aliased to the properties of the objects passed into them.</source>
          <target state="translated">РЕДАКТИРОВАТЬ: Исходя из того, что Бенджамин указал на утверждения with и catch в комментариях, я отредактировал пост и добавил больше. Оба оператора with и catch вводят переменные в соответствующие блоки, и это &lt;em&gt;является&lt;/em&gt; областью видимости блоков. Эти переменные связываются со свойствами переданных в них объектов.</target>
        </trans-unit>
        <trans-unit id="e6021de7d4da167c9d1924fe6e9b51d156cf4a9a" translate="yes" xml:space="preserve">
          <source>EDIT: Clarifying example:</source>
          <target state="translated">EDIT:Пояснительный пример:</target>
        </trans-unit>
        <trans-unit id="409777b6233f21776478ec8ae63313ad04d136b2" translate="yes" xml:space="preserve">
          <source>EDIT: ECMAAScript 6 (Harmony) is spec'ed to support let, and I know chrome allows a 'harmony' flag, so perhaps it does support it..</source>
          <target state="translated">EDIT:ECMAAScript 6 (Harmony)является spec'ed для поддержки let,и я знаю,что chrome позволяет флаг &quot;гармония&quot;,так что,возможно,он действительно поддерживает его...</target>
        </trans-unit>
        <trans-unit id="35e06056ed8896626ffd136476a7dd3ee396b131" translate="yes" xml:space="preserve">
          <source>Each function creates an execution context (but not always a new this binding)</source>
          <target state="translated">Каждая функция создает контекст выполнения (но не всегда новую эту привязку).</target>
        </trans-unit>
        <trans-unit id="a6992c03e5f9e7f14a3502886f2fe8726fe41373" translate="yes" xml:space="preserve">
          <source>Every variable declared with the &lt;code&gt;var&lt;/code&gt; keyword is scoped to the function. However, if other function are declared within that function those functions will have access to the variables of the outer functions. This is called a &lt;strong&gt;scope chain&lt;/strong&gt;. It works in the following manner:</source>
          <target state="translated">Каждая переменная, объявленная с ключевым словом &lt;code&gt;var&lt;/code&gt; , попадает в функцию. Однако, если в этой функции объявлена ​​другая функция, эти функции будут иметь доступ к переменным внешних функций. Это называется &lt;strong&gt;цепочкой контекста&lt;/strong&gt; . Это работает следующим образом:</target>
        </trans-unit>
        <trans-unit id="be91cfda712a2aa2bbaed218f5da3f4f20ced37f" translate="yes" xml:space="preserve">
          <source>Example of block scope is :-</source>
          <target state="translated">Пример области применения блока :-</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="13c2c628d0e65d9c75a59c080f5bcf4a585ac61e" translate="yes" xml:space="preserve">
          <source>Find out &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures&quot;&gt;more&lt;/a&gt;.</source>
          <target state="translated">Узнайте &lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures&quot;&gt;больше&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3e52c062915c2a123c8f3e107bb729e5edb24b0" translate="yes" xml:space="preserve">
          <source>For an up-to-date overview of which browsers support the &lt;code&gt;let&lt;/code&gt; statement at the time of your reading this answer, see &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt;this &lt;code&gt;Can I Use&lt;/code&gt; page&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">Актуальный обзор того, какие браузеры поддерживают оператор &lt;code&gt;let&lt;/code&gt; на момент прочтения этого ответа, см. &lt;a href=&quot;http://caniuse.com/#search=let&quot;&gt;&lt;strong&gt; &lt;code&gt;Can I Use&lt;/code&gt; странице &amp;laquo; Могу ли я использовать&amp;raquo;&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f759fff65c16814ccf2912386bb55ea2f49f07e2" translate="yes" xml:space="preserve">
          <source>For those that believe there is only global and local scope, please explain why Mozilla would have an entire page describing the nuances of block scope in JS.</source>
          <target state="translated">Для тех,кто считает,что существует только глобальный и локальный охват,пожалуйста,объясните,почему Mozilla будет иметь целую страницу,описывающую нюансы блочного охвата в JS.</target>
        </trans-unit>
        <trans-unit id="b3a281d3e09d661ffef9d575955e9402e9acd1b7" translate="yes" xml:space="preserve">
          <source>Function - visible within a function (and its sub-functions and blocks)</source>
          <target state="translated">Функция-видна внутри функции (а также ее подфункций и блоков).</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">Функциональный орган</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">Функциональные декларации</target>
        </trans-unit>
        <trans-unit id="54098e1a6688516674ee45e3b3d0d1327b43c770" translate="yes" xml:space="preserve">
          <source>Function declarations have block scope in strict mode and function scope in non-strict mode. Note: non-strict mode is a complicated set of emergent rules based on the quirky historical implementations of different browsers.</source>
          <target state="translated">Объявления функций имеют область действия блока в строгом режиме и область действия функции в нестрогом режиме.Примечание:нестрогий режим-это сложный набор возникающих правил,основанных на причудливых исторических реализациях различных браузеров.</target>
        </trans-unit>
        <trans-unit id="7f91e1a8edc0e34ea3bca466ca46d82f7465d0d6" translate="yes" xml:space="preserve">
          <source>Function parameter names</source>
          <target state="translated">Имена параметров функции</target>
        </trans-unit>
        <trans-unit id="9b10b98fb2db663a6af8871104c108ef004b25fd" translate="yes" xml:space="preserve">
          <source>Function parameter names are scoped to the function body.</source>
          <target state="translated">Имена параметров функции привязываются к телу функции.</target>
        </trans-unit>
        <trans-unit id="1e0d99529d66efa9e16b2a37d29fa7405450d6fd" translate="yes" xml:space="preserve">
          <source>Function parameters</source>
          <target state="translated">Функциональные параметры</target>
        </trans-unit>
        <trans-unit id="f0919c6e7316ed9e8e640c9b80f7609cc7dbc45b" translate="yes" xml:space="preserve">
          <source>Function parameters can be considered to be declared in the function body:</source>
          <target state="translated">Параметры функции можно считать декларированными в теле функции:</target>
        </trans-unit>
        <trans-unit id="cc0841f2f77bf09c47bd5cbb83dd0f40e14bf028" translate="yes" xml:space="preserve">
          <source>Global - visible by everything</source>
          <target state="translated">Глобальный-видимый всем</target>
        </trans-unit>
        <trans-unit id="ab9be0bed756d5b31a5365140ba111b3a60a2123" translate="yes" xml:space="preserve">
          <source>Global Scope :</source>
          <target state="translated">Глобальный охват :</target>
        </trans-unit>
        <trans-unit id="9c1d41d613e2de602e0cfbbc37dd6fb38c9598e2" translate="yes" xml:space="preserve">
          <source>Global context</source>
          <target state="translated">Глобальный контекст</target>
        </trans-unit>
        <trans-unit id="1fd666f0db8baac461a523eb3696c9d6cf767ffc" translate="yes" xml:space="preserve">
          <source>Global scope</source>
          <target state="translated">Глобальный контекст</target>
        </trans-unit>
        <trans-unit id="1db5edb9fb9b116986bc02c1af9c99d7780ec95f" translate="yes" xml:space="preserve">
          <source>Global variables are exactly like global stars (Jackie Chan, Nelson Mandela). You can access them (get or set the value), from any part of your application. Global functions are like global events (New Year, Christmas). You can execute (call) them from any part of your application.</source>
          <target state="translated">Глобальные переменные точно такие же,как и глобальные звезды (Джеки Чан,Нельсон Мандела).Вы можете получить к ним доступ (получить или установить значение)из любой части вашего приложения.Глобальные функции похожи на глобальные события (Новый год,Рождество).Вы можете выполнять их (звонить)из любой части вашего приложения.</target>
        </trans-unit>
        <trans-unit id="b6c6545a0afcd35503cd3889c2e63ae786e74d3d" translate="yes" xml:space="preserve">
          <source>Here is a good article on the subject.</source>
          <target state="translated">Вот хорошая статья на эту тему.</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="36b16afa86f01c1ed6ed7ee0985634679d23724b" translate="yes" xml:space="preserve">
          <source>Here, we can see that our variable &lt;code&gt;j&lt;/code&gt; is only known in the first for loop, but not before and after. Yet, our variable &lt;code&gt;i&lt;/code&gt; is known in the entire function.</source>
          <target state="translated">Здесь мы видим, что наша переменная &lt;code&gt;j&lt;/code&gt; известна только в первом цикле for, но не до и после. Тем не менее, наша переменная &lt;code&gt;i&lt;/code&gt; известна во всей функции.</target>
        </trans-unit>
        <trans-unit id="6197c902dc9a969800bbc1f43aa78895c0f511c1" translate="yes" xml:space="preserve">
          <source>How an identifier was declared</source>
          <target state="translated">Как был объявлен идентификатор</target>
        </trans-unit>
        <trans-unit id="fd84c93e786da583023283e8e6b544cc15f8a544" translate="yes" xml:space="preserve">
          <source>How do I create block scope variables?</source>
          <target state="translated">Как создать переменные блочной области видимости?</target>
        </trans-unit>
        <trans-unit id="6523732fcc8d20544777c08d98cafcd3a527d5d8" translate="yes" xml:space="preserve">
          <source>How it works under the hood</source>
          <target state="translated">Как это работает под капотом</target>
        </trans-unit>
        <trans-unit id="9bccab4e65ebb124be42a79a1ea8250f796b3a9e" translate="yes" xml:space="preserve">
          <source>How to keep track of browser support</source>
          <target state="translated">Как отслеживать поддержку браузера</target>
        </trans-unit>
        <trans-unit id="12e28ac9e5aec52d743e292f0a6d97a79a4481d9" translate="yes" xml:space="preserve">
          <source>I found that many people new to JavaScript have trouble understanding that inheritance is available by default in the language and that function scope is the only scope, so far. I provided an extension to a beautifier I wrote at the end of last year called JSPretty. The feature colors function scope in the code and always associates a color to all variables declared in that scope. Closure is visually demonstrated when a variable with a color from one scope is used in a different scope.</source>
          <target state="translated">Я обнаружил,что многие новички в JavaScript с трудом понимают,что наследование доступно по умолчанию в языке,и что область видимости функций пока единственная область видимости.Я предоставил расширение к красивому скрипту,который я написал в конце прошлого года под названием JSPretty.Функция определяет цвет границы видимости в коде и всегда связывает цвет со всеми переменными,объявленными в этой области видимости.Закрытие визуально демонстрируется,когда переменная с цветом из одной области видимости используется в другой области видимости.</target>
        </trans-unit>
        <trans-unit id="cdf8b31fb66ebedcd5a01dafdc4d2f5c826f3323" translate="yes" xml:space="preserve">
          <source>I will not elaborate on this, since there are already many other answers explaining the difference.</source>
          <target state="translated">Я не буду подробно останавливаться на этом,так как уже есть много других ответов,объясняющих разницу.</target>
        </trans-unit>
        <trans-unit id="eadac369b069051bb3496882603cd8c18a6245be" translate="yes" xml:space="preserve">
          <source>Identifier resolution only occurs in one direction: outwards. In this way, outer lexical environments cannot &quot;see&quot; into inner lexical environments.</source>
          <target state="translated">Разрешение идентификатора происходит только в одном направлении:наружу.Таким образом,внешние лексические среды не могут &quot;видеть&quot; во внутренних лексических средах.</target>
        </trans-unit>
        <trans-unit id="bac671b2d31df9b17566a019bb6eec35764631e1" translate="yes" xml:space="preserve">
          <source>Identifiers declared using &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;&lt;strong&gt;have block scope&lt;/strong&gt;, apart from when they are declared directly in the global context, in which case they have global scope.</source>
          <target state="translated">Идентификаторы, объявленные с использованием &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; , &lt;strong&gt;имеют область видимости блока&lt;/strong&gt; , кроме случаев, когда они объявляются непосредственно в глобальном контексте, и в этом случае они имеют глобальную область видимости.</target>
        </trans-unit>
        <trans-unit id="26eb35e5d6c55c98bf781bbeb4741c6d644d48f6" translate="yes" xml:space="preserve">
          <source>Identifiers declared using &lt;code&gt;var&lt;/code&gt;&lt;strong&gt;have function scope&lt;/strong&gt;, apart from when they are declared directly in the global context, in which case they are added as properties on the global object and have global scope. There are separate rules for their use in &lt;code&gt;eval&lt;/code&gt; functions.</source>
          <target state="translated">Идентификаторы, объявленные с использованием &lt;code&gt;var&lt;/code&gt; , &lt;strong&gt;имеют область действия функции&lt;/strong&gt; , кроме тех случаев, когда они объявляются непосредственно в глобальном контексте, и в этом случае они добавляются в качестве свойств глобального объекта и имеют глобальную область действия. Существуют отдельные правила их использования в функциях &lt;code&gt;eval&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f36a64720f58b77b1ccc6c4e4747411d14a62208" translate="yes" xml:space="preserve">
          <source>If it cannot find the variable inside the the function body it &lt;strong&gt;will climb up to the chain&lt;/strong&gt; and look at the variable scope in the function in &lt;strong&gt;where the function was defined&lt;/strong&gt;. This is what is meant with lexical scope, we can see in the code where this function was defined and thus can determine the scope chain by merely looking at the code.</source>
          <target state="translated">Если он не может найти переменную внутри тела функции, он &lt;strong&gt;поднимется до цепочки&lt;/strong&gt; и рассмотрит область действия переменной в функции, в &lt;strong&gt;которой была определена функция&lt;/strong&gt; . Это то, что подразумевается под лексической областью действия, мы можем видеть в коде, где была определена эта функция, и, таким образом, можем определить цепочку области действия, просто взглянув на код.</target>
        </trans-unit>
        <trans-unit id="745abb411c5db9b98fe9940dfa7c7e42d66969dd" translate="yes" xml:space="preserve">
          <source>If you are in the USA, you may know Kim Kardashian, infamous celebrity ( she somehow manages to make the tabloids). But people outside of the USA will not recognize her. She is a local star, bound to her territory.</source>
          <target state="translated">Если вы находитесь в США,вы можете знать Ким Кардашьян,печально известную знаменитость (ей каким-то образом удается сделать таблоиды).Но люди за пределами США не узнают ее.Она местная звезда,привязанная к своей территории.</target>
        </trans-unit>
        <trans-unit id="db4ede529a33a6d48b929256007928a838c5c68c" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and don't use a transpiler, you need to consider browser support.</source>
          <target state="translated">Если вы пишете JavaScript-код на клиентской стороне и не используете транспайлер,то вам необходимо учесть поддержку браузера.</target>
        </trans-unit>
        <trans-unit id="8dcd2b2b003bbf8ee33318bcf617bf8c5934526f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a Node based transpiler (like the &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;traceur shell script&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement. And because your browser will only know about the transpiled code, performance drawbacks should be limited.</source>
          <target state="translated">Если вы пишете код JavaScript на стороне клиента и используете транспортер на основе Node (например, &lt;a href=&quot;https://github.com/google/traceur-compiler/wiki/Compiling-Offline&quot;&gt;&lt;strong&gt;скрипт оболочки traceur&lt;/strong&gt;&lt;/a&gt; или &lt;a href=&quot;https://babeljs.io/&quot;&gt;&lt;strong&gt;Babel&lt;/strong&gt;&lt;/a&gt; ), вы можете смело использовать оператор &lt;code&gt;let&lt;/code&gt; . А поскольку ваш браузер будет знать только о переданном коде, недостатки производительности должны быть ограничены.</target>
        </trans-unit>
        <trans-unit id="78db1b0537f209bbe9cabb545f633294560d8d7f" translate="yes" xml:space="preserve">
          <source>If you're writing client-side JavaScript code and use a browser based transpiler (like &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement, however your code is likely to be anything but optimal with respect to performance.</source>
          <target state="translated">Если вы пишете код JavaScript на стороне клиента и используете браузер-транспортер (например, &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;&lt;strong&gt;Traceur&lt;/strong&gt;&lt;/a&gt; или &lt;a href=&quot;https://github.com/babel/babel-standalone&quot;&gt;&lt;strong&gt;babel-standalone&lt;/strong&gt;&lt;/a&gt; ), вы можете смело использовать оператор &lt;code&gt;let&lt;/code&gt; , однако ваш код, вероятно, будет не оптимальным с точки зрения производительности.</target>
        </trans-unit>
        <trans-unit id="4730b8ff337fd5e9541397578300f0622cd1031f" translate="yes" xml:space="preserve">
          <source>If you're writing server-side JavaScript code (&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt;), you can safely use the &lt;code&gt;let&lt;/code&gt; statement.</source>
          <target state="translated">Если вы пишете код JavaScript на стороне сервера ( &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;&lt;strong&gt;Node.js&lt;/strong&gt;&lt;/a&gt; ), вы можете смело использовать оператор &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e76b9230322e627054331e7b9ae49ba5c423394b" translate="yes" xml:space="preserve">
          <source>Implicit variable declarations</source>
          <target state="translated">Объявления неявных переменных</target>
        </trans-unit>
        <trans-unit id="45efcccf469aa7800be7436a4b8905d5812288f9" translate="yes" xml:space="preserve">
          <source>In &quot;Javascript 1.7&quot; (Mozilla's extension to Javascript) one can also declare block-scope variables with &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11&quot;&gt;&lt;code&gt;let&lt;/code&gt; statement&lt;/a&gt;:</source>
          <target state="translated">В &amp;laquo;Javascript 1.7&amp;raquo; (расширение Mozilla до Javascript) также можно объявить переменные области блока с помощью &lt;a href=&quot;https://developer.mozilla.org/en/New_in_JavaScript_1.7#section_11&quot;&gt;оператора &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="df791ba6a19c022e5fd42c64ae7d2edc9a0401c4" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;eval&lt;/code&gt; strings, variables declared using &lt;code&gt;var&lt;/code&gt; will be placed in the current scope, or, if &lt;code&gt;eval&lt;/code&gt; is used indirectly, as properties on the global object.</source>
          <target state="translated">В строках &lt;code&gt;eval&lt;/code&gt; переменные, объявленные с использованием &lt;code&gt;var&lt;/code&gt; , будут помещены в текущую область или, если &lt;code&gt;eval&lt;/code&gt; используется косвенно, в качестве свойств глобального объекта.</target>
        </trans-unit>
        <trans-unit id="b205565c9d304960cff99be6d6bb359de2add3f5" translate="yes" xml:space="preserve">
          <source>In EcmaScript5, there are mainly two scopes, &lt;strong&gt;local scope&lt;/strong&gt; and &lt;strong&gt;global scope&lt;/strong&gt; but in EcmaScript6 we have mainly three scopes, local scope, global scope and a new scope called &lt;strong&gt;block scope&lt;/strong&gt;.</source>
          <target state="translated">В EcmaScript5 есть в основном две области: &lt;strong&gt;локальная область&lt;/strong&gt; и &lt;strong&gt;глобальная область,&lt;/strong&gt; но в EcmaScript6 у нас есть в основном три области: локальная область, глобальная область и новая область, называемая &lt;strong&gt;областью блока&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="524ef03338ba6373ff8442de44d3525db236f6ed" translate="yes" xml:space="preserve">
          <source>In JavaScript there are two types of scope:</source>
          <target state="translated">В JavaScript есть два типа области видимости:</target>
        </trans-unit>
        <trans-unit id="49f24e5b3ac83ce8f7d46f9b0b5fbf42b56fef59" translate="yes" xml:space="preserve">
          <source>In JavaScript, every function-object has a hidden &lt;code&gt;[[Environment]]&lt;/code&gt; reference that is a reference to the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;lexical environment&lt;/a&gt; of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;execution context&lt;/a&gt; (stack frame) within which it was created.</source>
          <target state="translated">В JavaScript каждый объект-функция имеет скрытую ссылку &lt;code&gt;[[Environment]]&lt;/code&gt; , которая является ссылкой на &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;лексическую среду&lt;/a&gt; &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;контекста выполнения&lt;/a&gt; (стекового фрейма), в которой он был создан.</target>
        </trans-unit>
        <trans-unit id="101098685b4ef4c5fe8ddde1f6b84cd946e6cda9" translate="yes" xml:space="preserve">
          <source>In non-strict mode, function declarations have function scope. In strict mode they have block scope.</source>
          <target state="translated">В неограниченном режиме декларации функций имеют объем функций.В строгом режиме они имеют блочную область действия.</target>
        </trans-unit>
        <trans-unit id="517fb1c6e1e082360f7bfc6a062cddd34106ba21" translate="yes" xml:space="preserve">
          <source>In non-strict mode, implicit variable declarations are globally scoped. In strict mode you get an error.</source>
          <target state="translated">В неограниченном режиме неявные объявления переменных глобально просматриваются.В строгом режиме вы получаете ошибку.</target>
        </trans-unit>
        <trans-unit id="c530a0f6e7c617894a5240c8ce5b620b9c103965" translate="yes" xml:space="preserve">
          <source>In non-strict mode, implicit variable declarations have global scope. In strict mode these are not permitted.</source>
          <target state="translated">В неограниченном режиме неявные декларации переменных имеют глобальный охват.В строгом режиме они не допускаются.</target>
        </trans-unit>
        <trans-unit id="5f6bfeda81e0e8b51ad8697f031e39feead1aa2e" translate="yes" xml:space="preserve">
          <source>In the above example letVar logs the value global because variables declared with &lt;code&gt;let&lt;/code&gt; are block scoped. They cease to exist outside their respective block, so the variable can't be accessed outside the if block.</source>
          <target state="translated">В приведенном выше примере letVar регистрирует глобальное значение, потому что переменные, объявленные с помощью &lt;code&gt;let&lt;/code&gt; , имеют область видимости. Они перестают существовать вне соответствующего блока, поэтому к переменной нельзя обратиться за пределы блока if.</target>
        </trans-unit>
        <trans-unit id="f75a76f8d36110fb25053c596b58acad7a1e7f42" translate="yes" xml:space="preserve">
          <source>In the first example, there was no block scope, so the initially declared variables were overwritten. In the second example, there was a new scope due to the function, so the initially declared variables were SHADOWED, and not overwritten.</source>
          <target state="translated">В первом примере не было блок-области,поэтому изначально объявленные переменные были перезаписаны.Во втором примере из-за функции появилась новая область видимости,поэтому изначально объявленные переменные были SHADOWED,а не перезаписаны.</target>
        </trans-unit>
        <trans-unit id="70b614f546808637e2d6bda4b19e2a55f0206cd8" translate="yes" xml:space="preserve">
          <source>In the following, &lt;code&gt;x&lt;/code&gt; is visible outside of the loop because &lt;code&gt;var&lt;/code&gt; has function scope:</source>
          <target state="translated">Далее &lt;code&gt;x&lt;/code&gt; виден вне цикла, потому что у &lt;code&gt;var&lt;/code&gt; есть область действия функции:</target>
        </trans-unit>
        <trans-unit id="d512dd946ae9252d40645adc648a80ba866281e8" translate="yes" xml:space="preserve">
          <source>In this language, the displays were done similar to a stack of index cards. There was a master card referred to as the background. It was transparent and can be seen as the bottom card. Any content on this base card was shared with cards placed on top of it. Each card placed on top had its own content which took precedence over the previous card, but still had access to the prior cards if desired.</source>
          <target state="translated">На этом языке отображения были сделаны подобно стопке картотечных карточек.В качестве фона называлась мастер-карта.Она была прозрачной и могла рассматриваться как нижняя карта.Любое содержимое этой базовой карты делилось с картами,размещенными на ней.Каждая карта,помещенная сверху,имела свое собственное содержание,которое имело преимущественную силу перед предыдущей картой,но,при желании,имела доступ к предыдущим картам.</target>
        </trans-unit>
        <trans-unit id="597c9aea5b3298abab060a8929051c7f5d129292" translate="yes" xml:space="preserve">
          <source>Is it safe to use block scope variables today?</source>
          <target state="translated">Безопасно ли сегодня использовать блочные переменные диапазона?</target>
        </trans-unit>
        <trans-unit id="bed514e2588665341497d11ae432c1980024650f" translate="yes" xml:space="preserve">
          <source>JavaScript has lexical (also called static) scoping and closures. This means you can tell the scope of an identifier by looking at the source code.</source>
          <target state="translated">JavaScript имеет лексическое (также называемое статическим)сканирование и закрытие.Это означает,что можно определить область действия идентификатора,посмотрев на исходный код.</target>
        </trans-unit>
        <trans-unit id="4452aeeb557996248e57cd5ff1bf92ebc44de21c" translate="yes" xml:space="preserve">
          <source>JavaScript have only two type of scope :</source>
          <target state="translated">JavaScript имеет только два типа области видимости :</target>
        </trans-unit>
        <trans-unit id="34dae96f32e8c613581daf8160bc2454a1788290" translate="yes" xml:space="preserve">
          <source>Javascript uses scope chains to establish the scope for a given function. There is typically one global scope, and each function defined has its own nested scope. Any function defined within another function has a local scope which is linked to the outer function. It's always the position in the source that defines the scope.</source>
          <target state="translated">Javascript использует цепочки диапазонов для установления диапазона для данной функции.Обычно существует одна глобальная область видимости,и каждая определенная функция имеет свою собственную вложенную область видимости.Любая функция,определенная внутри другой функции,имеет локальную область видимости,которая связана с внешней функцией.Область действия всегда определяется положением в источнике.</target>
        </trans-unit>
        <trans-unit id="aaccd2b14cae60b4870ad3ae5d1483bf95f1cc7f" translate="yes" xml:space="preserve">
          <source>Just to add to the other answers, scope is a look-up list of all the declared identifiers (variables), and enforces a strict set of rules as to how these are accessible to currently executing code.  This look-up may be for the purposes of assigning to the variable, which is an LHS (lefthand-side) reference, or it may be for the purposes of retrieving its value, which is an RHS (righthand-side) reference. These look-ups are what the JavaScript engine is doing internally when it's compiling and executing the code.</source>
          <target state="translated">Просто чтобы добавить к остальным ответам,scope представляет собой список всех объявленных идентификаторов (переменных),и приводит в исполнение строгий набор правил о том,как они доступны для выполняющегося в данный момент кода.Этот поиск может быть направлен на присвоение переменной,которая является ссылкой LHS (левая сторона),или на извлечение ее значения,которое является ссылкой RHS (правая сторона).Эти поисковые запросы-это то,что JavaScript-движок делает внутри,когда компилирует и выполняет код.</target>
        </trans-unit>
        <trans-unit id="6e76cdd0f809219e814e41d1445bb5906bf62b65" translate="yes" xml:space="preserve">
          <source>Let would be a support for block level scoping, but you have to use the keyword to make it happen.</source>
          <target state="translated">Пусть это будет поддержка блокового уровня,но вы должны использовать ключевое слово,чтобы это произошло.</target>
        </trans-unit>
        <trans-unit id="8e18f18ab1ca156d4e71dc6cde7b4aa86040a968" translate="yes" xml:space="preserve">
          <source>Local Scope :</source>
          <target state="translated">Локальный охват :</target>
        </trans-unit>
        <trans-unit id="ca1be526eefc4c0c9a3b41b14b0b70782146069f" translate="yes" xml:space="preserve">
          <source>Local scope</source>
          <target state="translated">Местный масштаб</target>
        </trans-unit>
        <trans-unit id="a5d58a53fe2af24df0c1d2967e48151aa15ad00d" translate="yes" xml:space="preserve">
          <source>Local variables are like local stars. You can only access them (get or set the value) inside the scope. A local function is like local events - you can execute only (celebrate) inside that scope. If you want to access them from outside of the scope, you will get a reference error</source>
          <target state="translated">Локальные переменные похожи на локальные звезды.Вы можете получить к ним доступ (получить или установить значение)только внутри области видимости.Локальная функция похожа на локальные события-вы можете выполнять только (отмечать)внутри этой области видимости.Если вы захотите получить к ним доступ из-за пределов области видимости,вы получите ошибку по ссылке</target>
        </trans-unit>
        <trans-unit id="4136eb8081368e099724a9eb455093c190198113" translate="yes" xml:space="preserve">
          <source>Modern JavaScript</source>
          <target state="translated">Современный JavaScript</target>
        </trans-unit>
        <trans-unit id="7616704e501c489cb1ada1999f1307d7d34894df" translate="yes" xml:space="preserve">
          <source>Modern Js, ES6+, '&lt;code&gt;const&lt;/code&gt;' and '&lt;code&gt;let&lt;/code&gt;'</source>
          <target state="translated">Современные Js, ES6 +, &amp;laquo; &lt;code&gt;const&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;let&lt;/code&gt; &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="aad38a0f6cdff42e1f74357a58c635fc618d1ed1" translate="yes" xml:space="preserve">
          <source>Module - visible within a module</source>
          <target state="translated">Модуль-виден внутри модуля</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="003bc7d27503c7802bcadc1da058ded6bae30f8e" translate="yes" xml:space="preserve">
          <source>My understanding is that there are 3 scopes: global scope, available globally; local scope, available to an entire function regardless of blocks; and block scope, only available to the block, statement, or expression on which it was used. Global and local scope are indicated with the keyword 'var', either within a function or outside, and block scope is indicated with the keyword 'let'.</source>
          <target state="translated">Насколько я понимаю,существует 3 области применения:глобальная область применения,доступная в глобальном масштабе;локальная область применения,доступная для целой функции,независимо от блоков;и блочная область применения,доступная только для блока,оператора или выражения,на котором она была использована.Глобальный и локальный охват обозначаются ключевым словом 'var',как внутри функции,так и за ее пределами,а блочный охват обозначается ключевым словом 'let'.</target>
        </trans-unit>
        <trans-unit id="ebc5769ecf05a1a2a40ee3c38b9f80c576a2506b" translate="yes" xml:space="preserve">
          <source>Named function expressions</source>
          <target state="translated">Выражения именованных функций</target>
        </trans-unit>
        <trans-unit id="eaab883a49ed3ddf47b830ade67ddd95c8b8889b" translate="yes" xml:space="preserve">
          <source>Named function expressions are scooped only to the expression itself:</source>
          <target state="translated">Выражения именованных функций вычисляются только для самого выражения:</target>
        </trans-unit>
        <trans-unit id="7e130810bfbd11725f532879f063fa5c57ae9625" translate="yes" xml:space="preserve">
          <source>Named function expressions are scoped to themselves (eg. for the purpose of recursion).</source>
          <target state="translated">Выражения именованных функций просматриваются сами по себе (например,с целью рекурсии).</target>
        </trans-unit>
        <trans-unit id="0f5c3a674d3ca00ddc3c16a5c7583524970181f2" translate="yes" xml:space="preserve">
          <source>Note that this link between the new execution context and the lexical environment of the function object is called a &lt;a href=&quot;https://stackoverflow.com/a/111114/38522&quot;&gt;closure&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что эта связь между новым контекстом выполнения и лексической средой объекта функции называется &lt;a href=&quot;https://stackoverflow.com/a/111114/38522&quot;&gt;замыканием&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f243cfe125f58adb4304f18257f0d057d6f2352" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;var&lt;/code&gt;&lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;are all hoisted&lt;/a&gt;. This means that their logical position of definition is the top of their enclosing scope (block or function). However, variables declared useing &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; cannot be read or assigned to until control has passed the point of declaration in the source code. The interim period is known as the temporal dead zone.</source>
          <target state="translated">Примечание: &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; и &lt;code&gt;var&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/a/31222689/38522&quot;&gt;все подняты&lt;/a&gt; . Это означает, что их логическая позиция определения является вершиной их охватывающей области (блока или функции). Однако переменные, объявленные с использованием &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; , не могут быть считаны или назначены, пока управление не пройдет точку объявления в исходном коде. Промежуточный период известен как временная мертвая зона.</target>
        </trans-unit>
        <trans-unit id="52c316d760a2406f9de3c2dfe34c168873a682d6" translate="yes" xml:space="preserve">
          <source>Now when a variable &lt;code&gt;a&lt;/code&gt; required it first searches for nearest variable scope and if variable is not there than it move's to next object of variable scope chain.which is in this case is window level.</source>
          <target state="translated">Теперь, когда переменная обязательна, она сначала ищет ближайшую область видимости переменной, а если переменная отсутствует, то она перемещается к следующему объекту цепочки области видимости переменной. То, что в этом случае является уровнем окна.</target>
        </trans-unit>
        <trans-unit id="07cc61cfbd5542be1dbdf3df9337149c96b1472d" translate="yes" xml:space="preserve">
          <source>Old school JavaScript</source>
          <target state="translated">JavaScript старой школы</target>
        </trans-unit>
        <trans-unit id="d143a89c1211786baeac1937b212ea01195019e5" translate="yes" xml:space="preserve">
          <source>On a different note, unlike normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, which run on the top level, code inside ES6 modules runs in its own private scope. A variable defined at the top of a normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag is global, so you can reference it in other &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, like this:</source>
          <target state="translated">С другой стороны, в отличие от обычных тегов &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; , которые выполняются на верхнем уровне, код внутри модулей ES6 выполняется в своей собственной области видимости. Переменная, определенная в верхней части обычного &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; является глобальной, поэтому вы можете ссылаться на нее в других тегах &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="d03a95004161c654858d132f7f32b4344e85bba0" translate="yes" xml:space="preserve">
          <source>One thing of note that is worth mentioning, &quot;Scope look-up stops once it finds the first match&quot;.</source>
          <target state="translated">Стоит отметить одну вещь:&quot;Поиск Scope останавливается,как только находит первый матч&quot;.</target>
        </trans-unit>
        <trans-unit id="39d115a82e8ca46b1e1da4cb77b8126173035ef2" translate="yes" xml:space="preserve">
          <source>Ordinary block</source>
          <target state="translated">Обычный блок</target>
        </trans-unit>
        <trans-unit id="3e7192956deaab738bd72c8783df974fd557d341" translate="yes" xml:space="preserve">
          <source>Otherwise, you'll get a ReferenceError when the handler is invoked. So, for example, if the inline handler references a function which is defined &lt;em&gt;inside&lt;/em&gt;&lt;code&gt;window.onload&lt;/code&gt; or &lt;code&gt;$(function() {&lt;/code&gt;, the reference will fail, because the inline handler may only reference variables in the global scope, and the function is not global:</source>
          <target state="translated">В противном случае вы получите ReferenceError при вызове обработчика. Так, например, если встроенный обработчик ссылается на функцию, которая определена &lt;em&gt;внутри&lt;/em&gt; &lt;code&gt;window.onload&lt;/code&gt; или &lt;code&gt;$(function() {&lt;/code&gt; , ссылка потерпит неудачу, потому что встроенный обработчик может ссылаться только на переменные в глобальной области видимости, а функция не является Глобальный:</target>
        </trans-unit>
        <trans-unit id="b0f7eac222c33234d6b1ce96f288537ff995de59" translate="yes" xml:space="preserve">
          <source>Outside of the special cases of global and module scope, variables are declared using &lt;code&gt;var&lt;/code&gt; (function scope), &lt;code&gt;let&lt;/code&gt; (block scope) and &lt;code&gt;const&lt;/code&gt; (block scope). Most other forms of identifier declaration have block scope in strict mode.</source>
          <target state="translated">Вне особых случаев глобальной и модульной области видимости переменных объявляются с использованием &lt;code&gt;var&lt;/code&gt; (область действия функции), &lt;code&gt;let&lt;/code&gt; (область видимости блока) и &lt;code&gt;const&lt;/code&gt; (область видимости блока). Большинство других форм объявления идентификаторов имеют строгую область видимости блока.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="4d2fae3746da9a4ac50d19572acc01ad9fa90618" translate="yes" xml:space="preserve">
          <source>Properties of the &lt;code&gt;document&lt;/code&gt; and properties of the element the handler is attached to may also be referenced as standalone variables inside inline handlers because inline handlers are invoked &lt;a href=&quot;https://i.stack.imgur.com/dTDB0.png&quot;&gt;&lt;em&gt;inside&lt;/em&gt; of two &lt;code&gt;with&lt;/code&gt; blocks&lt;/a&gt;, one for the &lt;code&gt;document&lt;/code&gt;, one for the element. The scope chain of variables inside these handlers is &lt;a href=&quot;https://stackoverflow.com/a/57048067&quot;&gt;extremely unintuitive&lt;/a&gt;, and a working event handler will &lt;em&gt;probably&lt;/em&gt; require a function to be global (and unnecessary global pollution &lt;a href=&quot;https://softwareengineering.stackexchange.com/q/148108&quot;&gt;should probably be avoided&lt;/a&gt;).</source>
          <target state="translated">Свойства &lt;code&gt;document&lt;/code&gt; и свойства элемента, к которому прикреплен обработчик, также могут указываться как автономные переменные внутри встроенных обработчиков, потому что встроенные обработчики вызываются &lt;a href=&quot;https://i.stack.imgur.com/dTDB0.png&quot;&gt;&lt;em&gt;внутри&lt;/em&gt; двух &lt;code&gt;with&lt;/code&gt; блоками&lt;/a&gt; , один для &lt;code&gt;document&lt;/code&gt; , один для элемента. Цепочка области видимости переменных внутри этих обработчиков &lt;a href=&quot;https://stackoverflow.com/a/57048067&quot;&gt;чрезвычайно неинтуитивна&lt;/a&gt; , и обработчику рабочего события, &lt;em&gt;вероятно,&lt;/em&gt; потребуется глобальная функция (и, &lt;a href=&quot;https://softwareengineering.stackexchange.com/q/148108&quot;&gt;вероятно, следует избегать&lt;/a&gt; ненужного глобального загрязнения).</target>
        </trans-unit>
        <trans-unit id="358bcd9d5d263dcf0acf4e412ac146d3ec1cbcef" translate="yes" xml:space="preserve">
          <source>Quoting from his ebook:</source>
          <target state="translated">Цитата из его электронной книги:</target>
        </trans-unit>
        <trans-unit id="a23997220606bd14c55eafa62be1140a4157f6e3" translate="yes" xml:space="preserve">
          <source>Scope chain --&amp;gt;</source>
          <target state="translated">Цепочка прицела -&amp;gt;</target>
        </trans-unit>
        <trans-unit id="960f638fe475e770a8e797654ca9cc8ebe41b2a9" translate="yes" xml:space="preserve">
          <source>Scope is defined as the &lt;a href=&quot;https://stackoverflow.com/a/1047479/38522&quot;&gt;lexical&lt;/a&gt; region of code over which an identifier is valid.</source>
          <target state="translated">Область действия определяется как &lt;a href=&quot;https://stackoverflow.com/a/1047479/38522&quot;&gt;лексическая&lt;/a&gt; область кода, по которой действителен идентификатор.</target>
        </trans-unit>
        <trans-unit id="0001dde1682d4a228cca759a547c5f895b3d0836" translate="yes" xml:space="preserve">
          <source>Scope is formed of a linked nesting of lexical environments, with each level in the nesting corresponding to a lexical environment of an ancestor execution context.</source>
          <target state="translated">Область действия формируется из связанного вложением лексического окружения,при этом каждый уровень вложенности соответствует лексическому окружению контекста исполнения предка.</target>
        </trans-unit>
        <trans-unit id="03fc8d42427c442b2a752ef4c9a4f0079386dd0a" translate="yes" xml:space="preserve">
          <source>Scope is the region of the codebase over which an identifier is valid.</source>
          <target state="translated">Сфера действия-это область кодовой базы,над которой действителен идентификатор.</target>
        </trans-unit>
        <trans-unit id="d9e69c5319ff44dd0f7e6cd91e381690e40b15e1" translate="yes" xml:space="preserve">
          <source>Scopes are technically &quot;Execution Contexts&quot;</source>
          <target state="translated">Области применения технически являются &quot;Контекстами исполнения&quot;.</target>
        </trans-unit>
        <trans-unit id="8014aa999f8e9f357a908dec6565c42cc7afe011" translate="yes" xml:space="preserve">
          <source>See a demo at:</source>
          <target state="translated">Смотрите демо:</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Показать фрагмент кода</target>
        </trans-unit>
        <trans-unit id="4a2982e515416ff8974a0e226abce538efa699bf" translate="yes" xml:space="preserve">
          <source>Since the scope chain inside inline handlers is &lt;em&gt;so weird&lt;/em&gt;, and since inline handlers require global pollution to work, and since inline handlers sometimes require ugly string escaping when passing arguments, it's probably easier to avoid them. Instead, attach event handlers using Javascript (like with &lt;code&gt;addEventListener&lt;/code&gt;), rather than with HTML markup.</source>
          <target state="translated">Поскольку цепочка областей видимости внутри встроенных обработчиков &lt;em&gt;очень странная&lt;/em&gt; , а встроенные обработчики требуют глобального загрязнения, а встроенные обработчики иногда требуют экранирования строки при передаче аргументов, вероятно, их легче избежать. Вместо этого присоединяйте обработчики событий, используя Javascript (как с &lt;code&gt;addEventListener&lt;/code&gt; ), а не с HTML-разметкой.</target>
        </trans-unit>
        <trans-unit id="d7b8f215615eb4f7e16592cd68df7d8300b6ec09" translate="yes" xml:space="preserve">
          <source>So from this perspective, I think that a picture would help that I found in the Scopes and Closures ebook by Kyle Simpson:</source>
          <target state="translated">Так что с этой точки зрения,я думаю,что картина поможет,что я нашел в электронной книге Кайла Симпсона Scopes and Closures:</target>
        </trans-unit>
        <trans-unit id="260b57030b2b60bb30906c7875f28bf2c6a9202e" translate="yes" xml:space="preserve">
          <source>So that is the technical explanation. In practice, it is important to remember that in JavaScript</source>
          <target state="translated">Так что это техническое объяснение.На практике важно помнить,что в JavaScript</target>
        </trans-unit>
        <trans-unit id="6eeb8f5239adbcf206f276fe0178d507b944531b" translate="yes" xml:space="preserve">
          <source>So this code:</source>
          <target state="translated">Итак,этот код:</target>
        </trans-unit>
        <trans-unit id="9149eb7ca4536bbe4c6e7d579b916628507a6c43" translate="yes" xml:space="preserve">
          <source>So what is the difference between functional scope and block scope?</source>
          <target state="translated">Так в чем же разница между функциональным охватом и блочным охватом?</target>
        </trans-unit>
        <trans-unit id="de0115ead2817c9e584c804563ac34e1a02cf494" translate="yes" xml:space="preserve">
          <source>So you can see JavaScript scoping is actually extremely simple, albeit not always intuitive. A few things to be aware of:</source>
          <target state="translated">Таким образом,вы можете видеть JavaScript обзор на самом деле чрезвычайно прост,хотя и не всегда интуитивно понятным.Несколько вещей,о которых следует знать:</target>
        </trans-unit>
        <trans-unit id="3812cb403a9ffcb176a50c641ea80b4719348646" translate="yes" xml:space="preserve">
          <source>So, any blocks other than functions do not create a new scope. That explains why for-loops overwrite outer scoped variables:</source>
          <target state="translated">Таким образом,любые блоки,кроме функций,не создают новой области применения.Это объясняет,почему for-loops перезаписывает внешние scoped-переменные:</target>
        </trans-unit>
        <trans-unit id="77ce19117cbf62e9aa83a0e9daa5eda964f91d46" translate="yes" xml:space="preserve">
          <source>Some of the locations identifiers can be declared:</source>
          <target state="translated">Некоторые из идентификаторов мест могут быть объявлены:</target>
        </trans-unit>
        <trans-unit id="6c1737e3aa3de31e28974c1c8d07d17beab8ca24" translate="yes" xml:space="preserve">
          <source>Some of the ways identifiers can be declared:</source>
          <target state="translated">Некоторые из способов объявления идентификаторов:</target>
        </trans-unit>
        <trans-unit id="de99e0fa995db074a346a8fd3d2e19d830b3b47e" translate="yes" xml:space="preserve">
          <source>TLDR</source>
          <target state="translated">TLDR</target>
        </trans-unit>
        <trans-unit id="eb94aded85eb85135c48677af15bf3ac1f75c26f" translate="yes" xml:space="preserve">
          <source>That's almost all you need to know in terms of JavaScript scoping, except:</source>
          <target state="translated">Это почти все,что вам нужно знать с точки зрения JavaScript,кроме..:</target>
        </trans-unit>
        <trans-unit id="20ea4c65a85f13a0f7d5880b871c092105665952" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/&quot;&gt;&lt;strong&gt;most recent JavaScript specs&lt;/strong&gt;&lt;/a&gt; now also allow a third scope :</source>
          <target state="translated">&lt;a href=&quot;https://www.smashingmagazine.com/2015/10/es6-whats-new-next-version-javascript/&quot;&gt;&lt;strong&gt;Самые последние спецификации JavaScript&lt;/strong&gt;&lt;/a&gt; теперь также допускают третью область:</target>
        </trans-unit>
        <trans-unit id="551aa169f58fce36618019678db10f4c0b8c35c3" translate="yes" xml:space="preserve">
          <source>The Below Class has a Global scope variable &lt;code&gt;carName&lt;/code&gt;. And this variable is accessible from everywhere in the class.</source>
          <target state="translated">Класс Below имеет глобальную переменную области видимости &lt;code&gt;carName&lt;/code&gt; . И эта переменная доступна из любого места в классе.</target>
        </trans-unit>
        <trans-unit id="6f2e6a008008ebd7c8f8b0790fa024387f5103ae" translate="yes" xml:space="preserve">
          <source>The Below function has a local scope variable &lt;code&gt;carName&lt;/code&gt;. And this variable is not accessible from outside of the function.</source>
          <target state="translated">Функция Below имеет локальную переменную области видимости &lt;code&gt;carName&lt;/code&gt; . И эта переменная не доступна извне функции.</target>
        </trans-unit>
        <trans-unit id="1c6297960ee1326cc0b6ece03b632419c8697d63" translate="yes" xml:space="preserve">
          <source>The biggest difference between &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; is that &lt;code&gt;var&lt;/code&gt; is function scoped whereas &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; are block scoped. Here is an example to illustrate this:</source>
          <target state="translated">Самое большое различие между &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; состоит в том, что &lt;code&gt;var&lt;/code&gt; является областью действия функции, тогда как &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; является областью действия блока. Вот пример, чтобы проиллюстрировать это:</target>
        </trans-unit>
        <trans-unit id="dcadd2f97f65d20e36f2d943423cf05c3a58f7a2" translate="yes" xml:space="preserve">
          <source>The building represents our program&amp;rsquo;s nested scope ruleset. The first
  floor of the building represents your currently executing scope,
  wherever you are. The top level of the building is the global scope.
  You resolve LHS and RHS references by looking on your current floor,
  and if you don&amp;rsquo;t find it, taking the elevator to the next floor,
  looking there, then the next, and so on. Once you get to the top floor
  (the global scope), you either find what you&amp;rsquo;re looking for, or you
  don&amp;rsquo;t. But you have to stop regardless.</source>
          <target state="translated">Здание представляет собой набор правил для вложенной области действия нашей программы. Первый этаж здания представляет вашу текущую область действия, где бы вы ни находились. Верхний уровень здания - глобальная область. Вы решаете рекомендации LHS и RHS, просматривая свой текущий этаж, а если вы его не находите, поднимаетесь на лифте на следующий этаж, смотрите там, затем на следующий и так далее. Как только вы попадаете на верхний этаж (глобальный охват), вы либо находите то, что ищете, либо нет. Но ты должен остановиться независимо.</target>
        </trans-unit>
        <trans-unit id="cdc0afcc10d38d1828b1ade5ac3c30395d6075f9" translate="yes" xml:space="preserve">
          <source>The following prints &lt;code&gt;5&lt;/code&gt;, five times, and then prints &lt;code&gt;5&lt;/code&gt; for an sixth time for the &lt;code&gt;console.log&lt;/code&gt; outside the loop:</source>
          <target state="translated">Следующая команда печатает &lt;code&gt;5&lt;/code&gt; , пять раз, а затем печатает &lt;code&gt;5&lt;/code&gt; в шестой раз для &lt;code&gt;console.log&lt;/code&gt; вне цикла:</target>
        </trans-unit>
        <trans-unit id="f640071ac23c5f0d26b8e3ca4e3b7d965b5b7397" translate="yes" xml:space="preserve">
          <source>The following prints &lt;code&gt;undefined&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is block-scoped. The callbacks are run one by one asynchronously. New behavior for &lt;code&gt;let&lt;/code&gt; variables means that each anonymous function closed over a different variable named &lt;code&gt;x&lt;/code&gt; (unlike it would have done with &lt;code&gt;var&lt;/code&gt;), and so integers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;4&lt;/code&gt; are printed.:</source>
          <target state="translated">Следующие распечатки &lt;code&gt;undefined&lt;/code&gt; потому что &lt;code&gt;x&lt;/code&gt; является областью видимости. Обратные вызовы запускаются один за другим асинхронно. Новое поведение для переменных &lt;code&gt;let&lt;/code&gt; означает, что каждая анонимная функция закрывается на другую переменную с именем &lt;code&gt;x&lt;/code&gt; (в отличие от того, что было бы с &lt;code&gt;var&lt;/code&gt; ), и поэтому целые числа от &lt;code&gt;0&lt;/code&gt; до &lt;code&gt;4&lt;/code&gt; выводятся на печать .:</target>
        </trans-unit>
        <trans-unit id="07a69d238d156e701c5a367c6a5485165dd070e3" translate="yes" xml:space="preserve">
          <source>The following will NOT throw a &lt;code&gt;ReferenceError&lt;/code&gt; because the visibility of &lt;code&gt;x&lt;/code&gt; is not constrained by the block; it will, however, print &lt;code&gt;undefined&lt;/code&gt; because the variable has not been initialised (because of the &lt;code&gt;if&lt;/code&gt; statement).</source>
          <target state="translated">Следующее НЕ сгенерирует &lt;code&gt;ReferenceError&lt;/code&gt; , потому что видимость &lt;code&gt;x&lt;/code&gt; не ограничена блоком; однако он будет печатать &lt;code&gt;undefined&lt;/code&gt; , поскольку переменная не была инициализирована (из-за оператора &lt;code&gt;if&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="05ba3ae9dd9b32ddf42ae7069862c90654d442fa" translate="yes" xml:space="preserve">
          <source>The following will declare a property on the global object, because variables declared using &lt;code&gt;var&lt;/code&gt; within the global context, are added as properties to the global object:</source>
          <target state="translated">Далее будет объявлено свойство глобального объекта, поскольку переменные, объявленные с использованием &lt;code&gt;var&lt;/code&gt; в глобальном контексте, добавляются в качестве свойств к глобальному объекту:</target>
        </trans-unit>
        <trans-unit id="56e352b3854a340ef82e660d524c84e0929a85f3" translate="yes" xml:space="preserve">
          <source>The following will throw a &lt;code&gt;ReferenceError&lt;/code&gt; because the visibility of &lt;code&gt;x&lt;/code&gt; is constrained by the block:</source>
          <target state="translated">Следующее вызовет &lt;code&gt;ReferenceError&lt;/code&gt; , потому что видимость &lt;code&gt;x&lt;/code&gt; ограничена блоком:</target>
        </trans-unit>
        <trans-unit id="916178c1871c4ad706738ee8325f52860cf80126" translate="yes" xml:space="preserve">
          <source>The following will throw a ReferenceError because the names&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; have no meaning outside of the function &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Следующее вызовет ReferenceError, потому что имена &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; не имеют значения вне функции &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c15f36c25910e782b2fb893c1b27cfa365282f76" translate="yes" xml:space="preserve">
          <source>The following will throw a ReferenceError for &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;, but not for &lt;code&gt;x&lt;/code&gt;, because the visibility of &lt;code&gt;x&lt;/code&gt; is not constrained by the block. Blocks that define the bodies of control structures like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;, behave similarly.</source>
          <target state="translated">Следующее вызовет ReferenceError для &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; , но не для &lt;code&gt;x&lt;/code&gt; , потому что видимость &lt;code&gt;x&lt;/code&gt; не ограничена блоком. Блоки, которые определяют тела управляющих структур, например, &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;while&lt;/code&gt; , ведут себя одинаково.</target>
        </trans-unit>
        <trans-unit id="35ea475fa01e3a75809f9d5a47ee4846fc35e629" translate="yes" xml:space="preserve">
          <source>The four scopes are:</source>
          <target state="translated">Четыре диапазона:</target>
        </trans-unit>
        <trans-unit id="667c33893d889bc80fd5ed9df2f266c2588c1bb5" translate="yes" xml:space="preserve">
          <source>The idea of scoping in JavaScript when originally designed by &lt;a href=&quot;https://en.wikipedia.org/wiki/Brendan_Eich&quot;&gt;Brendan Eich&lt;/a&gt; came from the &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperCard&quot;&gt;HyperCard&lt;/a&gt; scripting language &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperTalk&quot;&gt;HyperTalk&lt;/a&gt;.</source>
          <target state="translated">Идея области видимости в JavaScript, изначально разработанная &lt;a href=&quot;https://en.wikipedia.org/wiki/Brendan_Eich&quot;&gt;Бренданом Айхом,&lt;/a&gt; возникла из языка сценариев &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperCard&quot;&gt;HyperCard&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/HyperTalk&quot;&gt;HyperTalk&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f6410942035541f508ed90e604fa26f865ffb4a" translate="yes" xml:space="preserve">
          <source>The key, as I understand it, is that Javascript has function level scoping vs the more common C block scoping.</source>
          <target state="translated">Ключевым моментом,как я понимаю,является то,что Javascript имеет функциональный уровень,в отличие от более распространенных блоков на C.</target>
        </trans-unit>
        <trans-unit id="baa8f0251c2ad4e18b3c034ad72ce894cbff4fc8" translate="yes" xml:space="preserve">
          <source>The same concepts of lexically scope and scopechain still apply in &lt;code&gt;ES6&lt;/code&gt;. However a new ways to declare variables were introduced. There are the following:</source>
          <target state="translated">Те же самые понятия лексического объема и области видимости все еще применяются в &lt;code&gt;ES6&lt;/code&gt; . Однако были введены новые способы объявления переменных. Есть следующее:</target>
        </trans-unit>
        <trans-unit id="1facbc7c1c1f813cff549c1dd5c9ee65e8b26f21" translate="yes" xml:space="preserve">
          <source>The scope of the variables that an &lt;code&gt;on*&lt;/code&gt; attribute can reference &lt;em&gt;must&lt;/em&gt; be either:</source>
          <target state="translated">Область действия переменных, &lt;code&gt;on*&lt;/code&gt; которые может ссылаться атрибут on *, &lt;em&gt;должна&lt;/em&gt; быть:</target>
        </trans-unit>
        <trans-unit id="a525d3c4347396db376dab57fb2b417bb3d3c520" translate="yes" xml:space="preserve">
          <source>The this binding will point to the containing object. Sometimes scopes or execution contexts change without the containing object changing, such as in a declared function where the containing object may be &lt;code&gt;window&lt;/code&gt; or a constructor function.</source>
          <target state="translated">Привязка this будет указывать на содержащий объект. Иногда контексты или контексты выполнения изменяются без изменения содержащего объекта, например, в объявленной функции, где содержащийся объект может быть &lt;code&gt;window&lt;/code&gt; или функцией конструктора.</target>
        </trans-unit>
        <trans-unit id="2d36f4ed020b3d4b8edb17fc4c526b8cb4fb6d80" translate="yes" xml:space="preserve">
          <source>The top level of an ES6 module is similar to that of the inside of an IIFE on the top level in a normal &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;. The module can reference any variables which are global, and nothing can reference anything inside the module unless the module is explicitly designed for it.</source>
          <target state="translated">Верхний уровень модуля ES6 аналогичен внутреннему уровню IIFE на верхнем уровне в обычном &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; . Модуль может ссылаться на любые переменные, которые являются глобальными, и ничто не может ссылаться на что-либо внутри модуля, если модуль явно не предназначен для него.</target>
        </trans-unit>
        <trans-unit id="7125f4b24be7f56c5a5737818cdbed770efa08f5" translate="yes" xml:space="preserve">
          <source>The top of a control structure (eg. loop, if, while etc)</source>
          <target state="translated">Верхняя часть структуры управления (например,контур,если,в то время и т.д.)</target>
        </trans-unit>
        <trans-unit id="ec84a003493d5f7ad27772f7fadcf69a38c15e22" translate="yes" xml:space="preserve">
          <source>The top of the stack takes precedence (the bottom being the global context)</source>
          <target state="translated">Верхняя часть стека имеет приоритет (нижняя часть-глобальный контекст).</target>
        </trans-unit>
        <trans-unit id="e5147662f95f20c6a0a89a3a7abbdb020dd6c0a5" translate="yes" xml:space="preserve">
          <source>There are ALMOST only two types of JavaScript scopes:</source>
          <target state="translated">Существует только два типа JavaScript-скриптов ALMOST:</target>
        </trans-unit>
        <trans-unit id="eb06dfbee4e2593fde4a86d0b540f447341e7d7e" translate="yes" xml:space="preserve">
          <source>There are only function scopes in JS. Not block scopes!
You can see what is hoisting too.</source>
          <target state="translated">В JS.есть только функциональные диапазоны.Не блокировать диапазоны! Вы тоже можете видеть,что поднимается.</target>
        </trans-unit>
        <trans-unit id="06ad5b6a8156a5d1e0ba464b34addb7c1635409b" translate="yes" xml:space="preserve">
          <source>There are three pertinent factors in deciding the &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_(computer_science)&quot;&gt;scope&lt;/a&gt; of an &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords&quot;&gt;identifier&lt;/a&gt; in JavaScript:</source>
          <target state="translated">При определении области &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_(computer_science)&quot;&gt;действия&lt;/a&gt; &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-names-and-keywords&quot;&gt;идентификатора&lt;/a&gt; в JavaScript существует три важных фактора:</target>
        </trans-unit>
        <trans-unit id="9f972bb206c8387750ed69130eeb77040dd103a2" translate="yes" xml:space="preserve">
          <source>There are two types of scopes in JavaScript.</source>
          <target state="translated">В JavaScript есть два типа областей применения.</target>
        </trans-unit>
        <trans-unit id="e1a1af2ae159fa99a59c517a33be2803648d6f2f" translate="yes" xml:space="preserve">
          <source>These are some browsers that don't support &lt;code&gt;let&lt;/code&gt; at all :</source>
          <target state="translated">Вот некоторые браузеры, которые вообще не поддерживают &lt;code&gt;let&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4157cf90189663de2f2e49ae60f774e33bc5176b" translate="yes" xml:space="preserve">
          <source>These execution contexts are created any time control is transferred. Control is transferred when code begins to execute, and this is primarily done from function execution.</source>
          <target state="translated">Эти контексты исполнения создаются в любой момент времени,когда передается управление.Контроль передается,когда код начинает выполняться,и в первую очередь это происходит от выполнения функции.</target>
        </trans-unit>
        <trans-unit id="fcd7046418deb6ee5f24a080449c0d25ed0ec8aa" translate="yes" xml:space="preserve">
          <source>These linked lexical environments form a scope &quot;chain&quot;. Identifier resolution is the process of searching along this chain for a matching identifier.</source>
          <target state="translated">Эти связанные лексические среды образуют &quot;цепочку&quot;.Разрешение идентификатора-это процесс поиска по этой цепочке подходящего идентификатора.</target>
        </trans-unit>
        <trans-unit id="523f7d75f219807a90812d1a03a76d634bd34fc6" translate="yes" xml:space="preserve">
          <source>This idea of &quot;scope levels&quot; explains why &quot;this&quot; can be changed with a newly created scope, if it's being looked up in a nested function.
Here is a link that goes into all these details, &lt;a href=&quot;https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/&quot;&gt;Everything you wanted to know about javascript scope&lt;/a&gt;</source>
          <target state="translated">Эта идея &amp;laquo;уровней области действия&amp;raquo; объясняет, почему &amp;laquo;это&amp;raquo; можно изменить с помощью вновь созданной области действия, если она ищется во вложенной функции. Вот ссылка, которая входит во все эти детали, &lt;a href=&quot;https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/&quot;&gt;Все&lt;/a&gt; , что вы хотели знать о сфере действия JavaScript</target>
        </trans-unit>
        <trans-unit id="88c46fe2afcb6c5ec1d4bbaa556544f6c35d6851" translate="yes" xml:space="preserve">
          <source>This is exactly how the JavaScript scoping system is designed. It just has different names. The cards in JavaScript are known as &lt;strong&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;Execution Contexts&lt;sup&gt;ECMA&lt;/sup&gt;&lt;/a&gt;&lt;/strong&gt;. Each one of these contexts contains three main parts. A variable environment, a lexical environment, and a this binding. Going back to the cards reference, the lexical environment contains all of the content from prior cards lower in the stack. The current context is at the top of the stack and any content declared there will be stored in the variable environment. The variable environment will take precedence in the case of naming collisions.</source>
          <target state="translated">Именно так спроектирована система определения объема JavaScript. У него просто разные имена. Карты в JavaScript известны как &lt;strong&gt;&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-10.3&quot;&gt;контексты исполнения &lt;sup&gt;ECMA&lt;/sup&gt;&lt;/a&gt;&lt;/strong&gt; . Каждый из этих контекстов состоит из трех основных частей. Переменная среда, лексическая среда и привязка this. Возвращаясь к справочнику карточек, лексическая среда содержит весь контент из предыдущих карточек ниже в стопке. Текущий контекст находится на вершине стека, и любой объявленный там контент будет храниться в переменной среде. Переменная среда будет иметь приоритет в случае именования коллизий.</target>
        </trans-unit>
        <trans-unit id="f86bca7d7675134768be73474570815258963447" translate="yes" xml:space="preserve">
          <source>This may seem counter intuitive, but it makes sense from the perspective of a imperative language designer.</source>
          <target state="translated">Это может показаться контр-интуитивным,но это имеет смысл с точки зрения императивного дизайнера языка.</target>
        </trans-unit>
        <trans-unit id="9569372657d997762301d2a05e690ebc258d5cc1" translate="yes" xml:space="preserve">
          <source>Thus, in JavaScript, scope is implemented via lexical environments linked together in a &quot;chain&quot; by outer references. This chain of lexical environments is called the scope chain, and identifier resolution occurs by &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference&quot;&gt;searching up the chain&lt;/a&gt; for a matching identifier.</source>
          <target state="translated">Таким образом, в JavaScript область видимости реализуется через лексические среды, связанные друг с другом в &amp;laquo;цепочку&amp;raquo; внешними ссылками. Эта цепочка лексических сред называется цепочкой областей действия, и разрешение идентификатора происходит путем &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-getidentifierreference&quot;&gt;поиска в цепочке&lt;/a&gt; соответствующего идентификатора.</target>
        </trans-unit>
        <trans-unit id="bb6c7e872133e98aeb218ad6ea9c62cee6491672" translate="yes" xml:space="preserve">
          <source>To understand the difference between functional scope and block scope, consider the following code :</source>
          <target state="translated">Чтобы понять разницу между функциональной областью действия и областью действия блока,рассмотрим следующий код :</target>
        </trans-unit>
        <trans-unit id="0163360cc80ec2993c1c8f16533f6de416e326dd" translate="yes" xml:space="preserve">
          <source>Traditionally, JavaScript really only has two types of scope :</source>
          <target state="translated">Традиционно,JavaScript действительно имеет только два типа области применения :</target>
        </trans-unit>
        <trans-unit id="87b058d74fbe7f22fbb0efb4d9425bc6faa878b9" translate="yes" xml:space="preserve">
          <source>Traditionally, you create your variables like this :</source>
          <target state="translated">Традиционно,вы создаете свои переменные таким образом :</target>
        </trans-unit>
        <trans-unit id="ad29238d291882475644003da99e61f8bc49a03b" translate="yes" xml:space="preserve">
          <source>Try the feature at:</source>
          <target state="translated">Попробуйте:</target>
        </trans-unit>
        <trans-unit id="2c33461d5cae3061ba752f33725ddcdee0745df3" translate="yes" xml:space="preserve">
          <source>Try this curious example. In the example below if a were a numeric initialized at 0, you'd see 0 and then 1. Except a is an object and javascript will pass f1 a pointer of a rather than a copy of it. The result is that you get the same alert both times.</source>
          <target state="translated">Попробуй этот любопытный пример.В примере ниже,если бы a была числовой инициализированной в 0,вы бы увидели 0,а затем 1.Кроме того,что a является объектом,javascript передаст f1 указатель a,а не его копию.В результате вы получите одно и то же предупреждение оба раза.</target>
        </trans-unit>
        <trans-unit id="9a31c380e5d5713a5b5f2cac2a38ce95810e231c" translate="yes" xml:space="preserve">
          <source>Using functions instead:</source>
          <target state="translated">Используя вместо этого функции:</target>
        </trans-unit>
        <trans-unit id="09e07e786d7ad2ec030bf960813f71d135a77b77" translate="yes" xml:space="preserve">
          <source>Variables declared globally have a global scope. Variables declared within a function are scoped to that function, and shadow global variables of the same name.</source>
          <target state="translated">Переменные,объявленные в глобальном масштабе,имеют глобальный охват.Переменные,объявленные в рамках функции,находятся под контролем этой функции,а теневые глобальные переменные с тем же именем.</target>
        </trans-unit>
        <trans-unit id="83f6135eb31f7889cc2bae9bf00eaae24a2268d7" translate="yes" xml:space="preserve">
          <source>Variables declared using &lt;code&gt;var&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; are all scoped to modules:</source>
          <target state="translated">Переменные, объявленные с использованием &lt;code&gt;var&lt;/code&gt; , &lt;code&gt;let&lt;/code&gt; или &lt;code&gt;const&lt;/code&gt; , относятся к модулям:</target>
        </trans-unit>
        <trans-unit id="e63da6c1c1854a483ec37bd48437243581e43830" translate="yes" xml:space="preserve">
          <source>Variables in Javascript were initially (pre &lt;code&gt;ES6&lt;/code&gt;) lexically function scoped. The term lexically scoped means that you can see the scope of the variables by 'looking' at the code.</source>
          <target state="translated">Переменные в Javascript изначально (до &lt;code&gt;ES6&lt;/code&gt; ) были ограничены лексической функцией. Термин лексически ограниченный означает, что вы можете увидеть область действия переменных, &amp;laquo;посмотрев&amp;raquo; на код.</target>
        </trans-unit>
        <trans-unit id="79b5a1ec62a5c78bf7572a8c6548c2e713ed3a8a" translate="yes" xml:space="preserve">
          <source>View the code at:</source>
          <target state="translated">Просмотрите код:</target>
        </trans-unit>
        <trans-unit id="d113eb702e389cf7c505ecfecd3bb29698f276f3" translate="yes" xml:space="preserve">
          <source>We try to log bar to the console, bar cannot be found inside the function &lt;code&gt;innerFunc&lt;/code&gt; itself. Therefore, we need to &lt;strong&gt;climb the scope chain&lt;/strong&gt;. We first look in the outer function in which the function &lt;code&gt;innerFunc&lt;/code&gt; was defined. This is the function &lt;code&gt;outerFunc&lt;/code&gt;. In the scope of &lt;code&gt;outerFunc&lt;/code&gt; we can find the variable bar, which holds the string 'outerFunc'.</source>
          <target state="translated">Мы пытаемся войти в панель bar, консоль не может быть найдена внутри самой функции &lt;code&gt;innerFunc&lt;/code&gt; . Поэтому нам нужно &lt;strong&gt;подняться по цепочке прицелов&lt;/strong&gt; . Сначала мы посмотрим на внешнюю функцию, в которой была определена функция &lt;code&gt;innerFunc&lt;/code&gt; . Это функция &lt;code&gt;outerFunc&lt;/code&gt; . В области &lt;code&gt;outerFunc&lt;/code&gt; мы можем найти переменную bar, которая содержит строку &amp;laquo;externalFunc&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="33483a29e47769decbe475c651c75e62bcc26c1d" translate="yes" xml:space="preserve">
          <source>We try to log foo to the console, foo can be found inside the function &lt;code&gt;innerFunc&lt;/code&gt; itself. Therefore, the value of foo is resolved to the string &lt;code&gt;innerFunc&lt;/code&gt;.</source>
          <target state="translated">Мы пытаемся войти в консоль foo, foo можно найти внутри самой функции &lt;code&gt;innerFunc&lt;/code&gt; . Поэтому значение foo разрешается в строку &lt;code&gt;innerFunc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f557bb3c7aec4df772e0ff73b2192b0c2d60c84e" translate="yes" xml:space="preserve">
          <source>What happens when we are trying to log the variables &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;foobar&lt;/code&gt; to the console is the following:</source>
          <target state="translated">Когда мы пытаемся записать переменные &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; и &lt;code&gt;foobar&lt;/code&gt; в консоль, происходит следующее:</target>
        </trans-unit>
        <trans-unit id="9b903fe3f970849861b225b53f498c1947e65555" translate="yes" xml:space="preserve">
          <source>What is the scope of variables in JavaScript</source>
          <target state="translated">Какова область применения переменных в JavaScript</target>
        </trans-unit>
        <trans-unit id="c23272951273b7fc083d376b564db88d3610470d" translate="yes" xml:space="preserve">
          <source>What is the scope of variables in javascript? Do they have the same scope inside as opposed to outside a function? Or does it even matter? Also, where are the variables stored if they are defined globally?</source>
          <target state="translated">Какова область применения переменных в javascript? Имеют ли они такую же область видимости внутри,в отличие от внешней функции? Или это вообще имеет значение? Также,где хранятся переменные,если они определены глобально?</target>
        </trans-unit>
        <trans-unit id="8bd7003d51c50f3c8761d33449fe913c8f8cac5b" translate="yes" xml:space="preserve">
          <source>When a function look to resolve a variable value it first looks at its own scope. This is the function body, i.e. everything between curly brackets {} (except for variables inside &lt;strong&gt;other&lt;/strong&gt;&lt;strong&gt;functions&lt;/strong&gt; which are in this scope).</source>
          <target state="translated">Когда функция ищет разрешение переменной, она сначала смотрит на свою область видимости. Это тело функции, т. Е. Все, что находится в фигурных скобках {} (за исключением переменных внутри &lt;strong&gt;других&lt;/strong&gt; &lt;strong&gt;функций,&lt;/strong&gt; находящихся в этой области видимости).</target>
        </trans-unit>
        <trans-unit id="7b320f88c37b5d9ddd50505ed7068dbeb83bd406" translate="yes" xml:space="preserve">
          <source>When resolving a variable, javascript starts at the innermost scope and searches outwards.</source>
          <target state="translated">При разрешении переменной javascript начинает с внутренней области видимости и ищет наружу.</target>
        </trans-unit>
        <trans-unit id="d7cb4beab01b349af01d024bbaf1102dfb872104" translate="yes" xml:space="preserve">
          <source>When you invoke a function, the hidden &lt;code&gt;[[Call]]&lt;/code&gt; method is called. This method creates a new execution context and establishes a link between the new execution context and the lexical environment of the function-object. It does this by copying the &lt;code&gt;[[Environment]]&lt;/code&gt; value on the function-object, into an &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;outer reference&lt;/a&gt; field on the lexical environment of the new execution context.</source>
          <target state="translated">Когда вы вызываете функцию, вызывается скрытый метод &lt;code&gt;[[Call]]&lt;/code&gt; . Этот метод создает новый контекст выполнения и устанавливает связь между новым контекстом выполнения и лексической средой объекта-функции. Это делается путем копирования значения &lt;code&gt;[[Environment]]&lt;/code&gt; объекта-функции во &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;внешнее&lt;/a&gt; поле ссылки в лексической среде нового контекста выполнения.</target>
        </trans-unit>
        <trans-unit id="c96ef28eb7eabf77773b3a19be2f5414a421175a" translate="yes" xml:space="preserve">
          <source>Where an identifier was declared</source>
          <target state="translated">Где был объявлен идентификатор</target>
        </trans-unit>
        <trans-unit id="db4779584d083e695bd0cf37cd44aa1429a309bc" translate="yes" xml:space="preserve">
          <source>Whether or not it is safe to use today, depends on your environment :</source>
          <target state="translated">Безопасно ли использовать его сегодня,зависит от вашей окружающей среды:</target>
        </trans-unit>
        <trans-unit id="98f46dd1a1ed53e1e44f3ab136ef987e105853e9" translate="yes" xml:space="preserve">
          <source>Whether you are in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;strict mode&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode&quot;&gt;non-strict mode&lt;/a&gt;</source>
          <target state="translated">Находитесь ли вы в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;строгом режиме&lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Sloppy_mode&quot;&gt;не строгом режиме&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="866faa243c8cb14d4f4502051230db635e4581a1" translate="yes" xml:space="preserve">
          <source>Window level - &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;outer&lt;/code&gt; function are at top level in scope chain.</source>
          <target state="translated">Уровень окна - &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;outer&lt;/code&gt; функция находятся на верхнем уровне в цепочке областей видимости.</target>
        </trans-unit>
        <trans-unit id="61285999208212a66bb8fb8f69cb29c51fc58afb" translate="yes" xml:space="preserve">
          <source>Yikes!  Be careful using 'with' -- just like var is a noop if the variable is already defined in the function, it is also a noop with respect to names imported from the object!  A little heads up on the name already being defined would make this much safer.  I personally will never use with because of this.</source>
          <target state="translated">Ой! Будьте осторожны,используя 'with' --так же как var-это noop,если переменная уже определена в функции,это также noop по отношению к именам,импортированным из объекта! Немного предостережения по поводу уже определенного имени сделает это намного безопаснее.Лично я никогда не буду использовать с этим.</target>
        </trans-unit>
        <trans-unit id="653677cec5274421cb19c2c9eb0bf04f82dca290" translate="yes" xml:space="preserve">
          <source>You should be using block scoping for every variable you create, just like most other major languages. &lt;code&gt;var&lt;/code&gt; is &lt;em&gt;obsolete&lt;/em&gt;. This makes your code safer and more maintainable.</source>
          <target state="translated">Для каждой создаваемой переменной вы должны использовать блочную область видимости, как и большинство других основных языков. &lt;code&gt;var&lt;/code&gt; &lt;em&gt;устарел&lt;/em&gt; . Это делает ваш код безопаснее и удобнее в обслуживании.</target>
        </trans-unit>
        <trans-unit id="98d045c503931bcf6ef7f9b40c8422ec1ba5b590" translate="yes" xml:space="preserve">
          <source>You'll want to investigate closures, and how to use them to make &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;private members&lt;/a&gt;.</source>
          <target state="translated">Вы захотите исследовать замыкания и узнать, как использовать их для создания &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;частных пользователей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b63f2d6c0c543f4dd14dae138ce110ce4819bafe" translate="yes" xml:space="preserve">
          <source>a property of the document (eg, &lt;code&gt;querySelector&lt;/code&gt; as a standalone variable will point to &lt;code&gt;document.querySelector&lt;/code&gt;; rare)</source>
          <target state="translated">свойство документа (например, &lt;code&gt;querySelector&lt;/code&gt; как отдельная переменная будет указывать на &lt;code&gt;document.querySelector&lt;/code&gt; ; редко)</target>
        </trans-unit>
        <trans-unit id="fceff746a314cc08e9d118ad4bd96fa755c80556" translate="yes" xml:space="preserve">
          <source>a property of the element the handler is attached to (like above; rare)</source>
          <target state="translated">свойство элемента,к которому прикреплен обработчик (как указано выше;редко встречается)</target>
        </trans-unit>
        <trans-unit id="822bc13e2d55b402eb4233cb23c9d414a7a03bc1" translate="yes" xml:space="preserve">
          <source>eval</source>
          <target state="translated">eval</target>
        </trans-unit>
        <trans-unit id="48a783d527b12bb1b6d12822df507e3056d403cb" translate="yes" xml:space="preserve">
          <source>foobar cannot be found in innerFunc. . Therefore, we need to &lt;strong&gt;climb the scope chain&lt;/strong&gt; to the innerFunc scope. It also cannot be found here, we climb another level to the &lt;strong&gt;global scope&lt;/strong&gt; (i.e. the outermost scope). We find the variable foobar here which holds the string 'global'. If it wouldnot have found the variable after climbing the scope chain the JS engine would throw a &lt;strong&gt;referenceError&lt;/strong&gt;.</source>
          <target state="translated">foobar не может быть найден во innerFunc. , Поэтому нам нужно &lt;strong&gt;подняться по цепочке&lt;/strong&gt; областей видимости в область видимости innerFunc. Это также не может быть найдено здесь, мы поднимаемся на другой уровень к &lt;strong&gt;глобальной области видимости&lt;/strong&gt; (то есть к самой внешней области видимости). Здесь мы находим переменную foobar, которая содержит строку &amp;laquo;global&amp;raquo;. Если он не найдет переменную после перехода по цепочке областей действия, механизм JS выдаст &lt;strong&gt;referenceError&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="887ec4e4d84f875ed30e16b3b555dc44c974324c" translate="yes" xml:space="preserve">
          <source>global (working inline handlers almost always reference global variables)</source>
          <target state="translated">глобальный (работающие встроенные обработчики почти всегда ссылаются на глобальные переменные)</target>
        </trans-unit>
        <trans-unit id="7344f99b192214421819b3d6d5d5eb925e77386f" translate="yes" xml:space="preserve">
          <source>if there is no enclosing function for a var declaration, it is global scope</source>
          <target state="translated">если нет функции ограждения для объявления var,то это глобальная сфера применения.</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">эквивалентно:</target>
        </trans-unit>
        <trans-unit id="fb722bbe2d7de5616bde8841cec1f7151c36e813" translate="yes" xml:space="preserve">
          <source>let and const</source>
          <target state="translated">позволять и констебль</target>
        </trans-unit>
        <trans-unit id="ff9c22082a2b010df2415de1fe69a90317ccdf1c" translate="yes" xml:space="preserve">
          <source>multiple var declarations within the same scope are combined</source>
          <target state="translated">несколько деклараций о разнородности в пределах одной и той же области применения объединены</target>
        </trans-unit>
        <trans-unit id="222f16742f8432d094b140df773f638f634a3fe5" translate="yes" xml:space="preserve">
          <source>run the code. hope this will give an idea about scoping</source>
          <target state="translated">запустите код.Надеюсь,это даст представление о том.</target>
        </trans-unit>
        <trans-unit id="e50c3161b714f4fa46bad3943d0cfb3418bf98a5" translate="yes" xml:space="preserve">
          <source>test1 is scoped to the with block, but is aliased to a.test1.  'Var test1' creates a new variable test1 in the upper lexical context (function, or global), unless it is a property of a -- which it is.</source>
          <target state="translated">test1 приравнивается к блоку,но имеет псевдоним a.test1.'Var test1' создает новую переменную test1 в верхнем лексическом контексте (функции,или глобальном),если только она не является свойством a --которым она и является.</target>
        </trans-unit>
        <trans-unit id="7c5e5564e501683f6afb89ae0a4affd1e86cdeb1" translate="yes" xml:space="preserve">
          <source>the scope of each var declaration is associated with the most immediately enclosing function</source>
          <target state="translated">область применения каждого объявления var связана с самой непосредственной функцией ограждения</target>
        </trans-unit>
        <trans-unit id="a4ebaeeee765207f3a08fde4e0bf36e28958ad9a" translate="yes" xml:space="preserve">
          <source>try/catch introduce new scope ONLY for the exception variable itself, other variables do not have new scope</source>
          <target state="translated">trycatch вводит новую область видимости ТОЛЬКО для самой переменной исключения,другие переменные не имеют новой области видимости</target>
        </trans-unit>
        <trans-unit id="e5b4e786e382d03c28e9edfab2d8149378ae69df" translate="yes" xml:space="preserve">
          <source>var</source>
          <target state="translated">var</target>
        </trans-unit>
        <trans-unit id="7357ecfa390afc2fce34c3167335bf743c442659" translate="yes" xml:space="preserve">
          <source>var declarations are hoisted to the top of the scope. This means no matter where the var declaration happens, to the compiler it is as if the var itself happens at the top</source>
          <target state="translated">Объявления о вариации поднимаются в верхнюю часть области применения.Это означает,что независимо от того,где происходит объявление var,компилятору кажется,что сам var происходит в верхней части области видимости.</target>
        </trans-unit>
        <trans-unit id="80e40e219ee78a38babf8cce499fd3cb0f6182af" translate="yes" xml:space="preserve">
          <source>when outer function called a new &lt;code&gt;variable scope object&lt;/code&gt;(and included in scope chain) added with variable &lt;code&gt;b&lt;/code&gt; inside it.</source>
          <target state="translated">когда внешняя функция вызывает новый &lt;code&gt;variable scope object&lt;/code&gt; (и включается в цепочку областей видимости), добавляется переменная &lt;code&gt;b&lt;/code&gt; внутри него.</target>
        </trans-unit>
        <trans-unit id="5b3cb00aa7dfc23400daf50a18606b8161567f7b" translate="yes" xml:space="preserve">
          <source>with-clause apparently is another exception, but using with-clause it highly discouraged (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&lt;/a&gt;)</source>
          <target state="translated">with-clause, очевидно, является еще одним исключением, но использование with-clause крайне нежелательно ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with&lt;/a&gt; )</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
