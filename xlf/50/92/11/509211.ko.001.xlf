<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/509211">
    <body>
      <group id="509211">
        <trans-unit id="0aaf66473b71c5d42becc13d72b6f4ed70fedde3" translate="yes" xml:space="preserve">
          <source>(Python 3 gets a &lt;code&gt;list.copy&lt;/code&gt; and &lt;code&gt;list.clear&lt;/code&gt; method.)</source>
          <target state="translated">(Python 3은 &lt;code&gt;list.copy&lt;/code&gt; 및 &lt;code&gt;list.clear&lt;/code&gt; 메소드를 얻습니다.)</target>
        </trans-unit>
        <trans-unit id="95d6f5f0e5758c7fa9092f862da9a2259661dfd4" translate="yes" xml:space="preserve">
          <source>1. Slice Notation</source>
          <target state="translated">1. 슬라이스 표기법</target>
        </trans-unit>
        <trans-unit id="0f38c5a54db99d84e876f9b5eaa8720b9f3a9a26" translate="yes" xml:space="preserve">
          <source>2. Pitfalls</source>
          <target state="translated">2. 함정</target>
        </trans-unit>
        <trans-unit id="8862228b2902925878e3e9b09c1707ac7de719af" translate="yes" xml:space="preserve">
          <source>3. Examples</source>
          <target state="translated">3. 예</target>
        </trans-unit>
        <trans-unit id="a3d3ca439ad803f892271df58e7d3c810355f6fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;end&lt;/code&gt;: last index, &lt;strong&gt;NOTE that &lt;code&gt;end&lt;/code&gt; index will not be included in the resulted slice&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; : 마지막 인덱스, &lt;strong&gt; &lt;code&gt;end&lt;/code&gt; 인덱스는 결과 슬라이스에 포함되지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6643606539da7a52988dc6cf4ceeadabfd2aeb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: an object that can be sliced</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; : 슬라이스 가능한 객체</target>
        </trans-unit>
        <trans-unit id="1b4c4192b9f7af406c63bd0fcecb821e5c7cd6f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt;: first index to start iteration</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; : 반복을 시작하는 첫 번째 색인</target>
        </trans-unit>
        <trans-unit id="f694d4d7856a4daa5fcd72c6329bb35f7a4a3b91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt;: pick element every &lt;code&gt;step&lt;/code&gt; index</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; : &lt;code&gt;step&lt;/code&gt; 인덱스마다 요소 선택</target>
        </trans-unit>
        <trans-unit id="31b0888c10f4ec32c43b2a524281bf1bc1307538" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A negative step means iterate the array backwards: from the end to start, with the end index included, and the start index excluded from the result.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;음수 단계는 끝 인덱스가 포함되고 시작 인덱스가 결과에서 제외 된 상태에서 배열을 거꾸로 반복 함을 의미합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dd769027176645af5d46752c43bf60e2cbab996" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basic Slicing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본 슬라이싱&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03764b700c4114b7c7e0b1fc151ca8ee76b98522" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Python Figures Out Missing Parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;파이썬이 누락 된 매개 변수를 파악하는 방법 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a8df44af93130aa47cf7708478946a1e899c9b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: when step is negative, the default value for &lt;code&gt;start&lt;/code&gt; is &lt;code&gt;len(s)&lt;/code&gt; (while &lt;code&gt;end&lt;/code&gt; does not equal to &lt;code&gt;0&lt;/code&gt;, because &lt;code&gt;s[::-1]&lt;/code&gt; contains &lt;code&gt;s[0]&lt;/code&gt;). For example:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 단계가 음수 인 경우 &lt;code&gt;start&lt;/code&gt; 의 기본값은 &lt;code&gt;len(s)&lt;/code&gt; &lt;code&gt;s[::-1]&lt;/code&gt; 에 &lt;code&gt;s[0]&lt;/code&gt; 포함되어 있기 때문에 &lt;code&gt;end&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 이 아님). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a040621624a5c253662c247800c0317b88fdc6d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This post was originally written in my blog, &lt;em&gt;&lt;a href=&quot;https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html&quot;&gt;The Intelligence Behind Python Slices&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 게시물은 원래 내 블로그 인 &lt;em&gt;&lt;a href=&quot;https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html&quot;&gt;The Python Behind Python Slices&lt;/a&gt;&lt;/em&gt; 에서 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="dd2468b43f8b0b0ef298ce86ccd65ed0c9f49ef9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Slicing With Step:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;단계를 가진 저 미기 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fe67ddb4f6798a243fbf3c1c781e47c402b956c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Slicing can also be applied to multi-dimensional arrays.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;슬라이스는 다차원 배열에도 적용 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54689a39c2f4af595b96d8fcee877e522e69fc2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TODO&lt;/strong&gt;: The code below had a bug with &quot;never go outside the sequence&quot; when abs(step)&amp;gt;1; I &lt;em&gt;think&lt;/em&gt; I patched it to be correct, but it's hard to understand.</source>
          <target state="translated">&lt;strong&gt;TODO&lt;/strong&gt; : 아래 코드는 abs (step)&amp;gt; 1 일 때 &quot;시퀀스를 벗어나지 않습니다&quot;라는 버그가있었습니다. 나는 &lt;em&gt;그것이&lt;/em&gt; 올바른 것으로 패치 &lt;em&gt;했다고 생각&lt;/em&gt; 하지만 이해하기는 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="120f2d378e6907d447c90878b70cfec95cfa80ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Understanding the difference between indexing and slicing:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;인덱싱과 슬라이싱의 차이점 이해 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c3618c39203bd4928667eb7837893a51d2c72ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;start:&lt;/strong&gt; the beginning index of the slice, it will include the element at this index unless it is the same as &lt;em&gt;stop&lt;/em&gt;, defaults to 0, i.e. the first index. If it's negative, it means to start &lt;code&gt;n&lt;/code&gt; items from the end.</source>
          <target state="translated">&lt;strong&gt;start :&lt;/strong&gt; 슬라이스의 시작 인덱스. &lt;em&gt;stop&lt;/em&gt; 과 동일하지 않으면이 인덱스의 요소를 포함합니다. 기본값은 0, 즉 첫 번째 인덱스입니다. 음수이면 끝에서 &lt;code&gt;n&lt;/code&gt; 개의 항목을 시작한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="3b0828277ef33d65b168b24d8f7acb52b6e97797" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;step:&lt;/strong&gt; the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse.</source>
          <target state="translated">&lt;strong&gt;단계 :&lt;/strong&gt; 인덱스가 증가하는 양의 기본값은 1입니다. 음수이면 iterable에 대해 반대로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="f4d542aea390972989442b2f47543ac47e2b208f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stop:&lt;/strong&gt; the ending index of the slice, it does &lt;em&gt;not&lt;/em&gt; include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.</source>
          <target state="translated">&lt;strong&gt;stop :&lt;/strong&gt; 슬라이스의 끝 인덱스.이 인덱스에 요소를 포함하지 &lt;em&gt;않습니다&lt;/em&gt; . 기본적으로 슬라이스되는 시퀀스의 길이, 즉 끝까지 포함합니다.</target>
        </trans-unit>
        <trans-unit id="227dd9dbc0108dfd4661edff64d2fe881992bffb" translate="yes" xml:space="preserve">
          <source>After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a &lt;code&gt;for&lt;/code&gt; loop...</source>
          <target state="translated">그것을 조금 사용한 후에는 가장 간단한 설명이 &lt;code&gt;for&lt;/code&gt; 루프의 인수와 정확히 동일하다는 것을 알고 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="ee7829458bdd9d9fb9e4d5d3a2fb33291ce2cf6c" translate="yes" xml:space="preserve">
          <source>Also, note that negative values for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are relative to the end of the list and computed in the example above by &lt;code&gt;given_index + a.shape[0]&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 의 음수 값은 목록의 끝을 기준으로하며 위 예제에서 &lt;code&gt;given_index + a.shape[0]&lt;/code&gt; 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="70a021868ab3df3f88ae6899b164851777cd1b14" translate="yes" xml:space="preserve">
          <source>And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:</source>
          <target state="translated">그리고 슬라이싱 구문을 처음봤을 때 나에게 분명하지 않은 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d105f3bd854548cc6f0bd3800349d324c615cb05" translate="yes" xml:space="preserve">
          <source>And clearing them is with:</source>
          <target state="translated">그리고 그것들을 지우는 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d25005772475e3ef4f540f81cb570f204b58a0d9" translate="yes" xml:space="preserve">
          <source>And if you wanted, for some reason, every second item in the reversed sequence:</source>
          <target state="translated">그리고 당신이 어떤 이유로 든 역순으로 매 두 번째 항목을 원한다면 :</target>
        </trans-unit>
        <trans-unit id="77bb433c739e5798f1c99c633d2b911edd356fc6" translate="yes" xml:space="preserve">
          <source>And recall that there are defaults for &lt;em&gt;start&lt;/em&gt;, &lt;em&gt;stop&lt;/em&gt;, and &lt;em&gt;step&lt;/em&gt;, so to access the defaults, simply leave out the argument.</source>
          <target state="translated">&lt;em&gt;start&lt;/em&gt; , &lt;em&gt;stop&lt;/em&gt; 및 &lt;em&gt;step&lt;/em&gt; 의 기본값이 있으므로 기본값에 액세스하려면 인수를 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="8d114526a29d613405e6408309b436a186ca0d52" translate="yes" xml:space="preserve">
          <source>And then once you've seen that, slice assignment to the empty slice makes sense too:</source>
          <target state="translated">그리고 당신이 그것을 본 후에, 빈 슬라이스에 슬라이스 할당도 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5de2b62e17f6a84350d6fbe4ce6b42edec436e54" translate="yes" xml:space="preserve">
          <source>Another heuristic is, &quot;for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning&quot;</source>
          <target state="translated">또 다른 휴리스틱은 &quot;모든 슬라이스에 대해 시작을 0으로 바꾸고 이전 휴리스틱을 적용하여 목록의 끝을 얻은 다음 첫 번째 숫자를 다시 계산하여 처음부터 항목을 잘라냅니다&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="faa6734c0c057ce07a0df52181d494e9f022c4d5" translate="yes" xml:space="preserve">
          <source>Another import thing: &lt;strong&gt;all &lt;code&gt;start&lt;/code&gt;,&lt;code&gt;end&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt; can be omitted!&lt;/strong&gt; And if they are omitted, their default value will be used: &lt;code&gt;0&lt;/code&gt;,&lt;code&gt;len(s)&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt; accordingly.</source>
          <target state="translated">또 다른 중요한 것은 &lt;strong&gt;모든 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; 를 생략 할 수 있다는 것입니다!&lt;/strong&gt; 그리고 생략하면 기본값은 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;len(s)&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 이 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="7af9ada0982e5ec6222baca6341c1c5cff1f46c9" translate="yes" xml:space="preserve">
          <source>Any of them are optional:</source>
          <target state="translated">그들 중 하나는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="9e68e1c90bdbb11b1d0236fe65983d5f0f2685f0" translate="yes" xml:space="preserve">
          <source>As a general rule, writing code with a lot of hardcoded index values leads to a readability
and maintenance mess. For example, if you come back to the code a year later, you&amp;rsquo;ll
look at it and wonder what you were thinking when you wrote it. The solution shown
is simply a way of more clearly stating what your code is actually doing.
In general, the built-in slice() creates a slice object that can be used anywhere a slice
is allowed. For example:</source>
          <target state="translated">일반적으로 하드 코딩 된 인덱스 값이 많은 코드를 작성하면 가독성 및 유지 관리가 복잡해집니다. 예를 들어, 1 년 후 코드로 돌아 오면 코드를보고 코드를 작성할 때 무슨 생각을했는지 궁금해 할 것입니다. 표시된 솔루션은 코드에서 실제로 수행중인 작업을보다 명확하게 나타내는 방법입니다. 일반적으로 내장 slice ()는 슬라이스가 허용되는 모든 곳에서 사용할 수있는 슬라이스 객체를 만듭니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5d1179754e1ec07fb3a1e15a9fe95c4e93756e2" translate="yes" xml:space="preserve">
          <source>As you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element.</source>
          <target state="translated">보시다시피 stop 만 정의하면 하나의 요소 만 반환됩니다. 시작은 기본적으로 none으로 설정되므로 하나의 요소 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="10ddbc6f0ff07831197cae7c89a5e4feb5e47439" translate="yes" xml:space="preserve">
          <source>Backing up a little bit, what happens when you keep going with our procession of counting up the slice beginning?</source>
          <target state="translated">약간 백업하면 슬라이스 시작 카운트 업을 계속 진행하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="a0a44e8c2753c157919dea94666ab53b99900c6e" translate="yes" xml:space="preserve">
          <source>Be surprised: &lt;strong&gt;slice does not raise an IndexError when the index is out of range!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;인덱스가 범위를 벗어날 때 slice가 IndexError를 발생시키지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51688e4ac0a45d12d7f9bb788db79cb941448aea" translate="yes" xml:space="preserve">
          <source>Begin from &lt;code&gt;start&lt;/code&gt;, increment by &lt;code&gt;step&lt;/code&gt;, do not reach &lt;code&gt;stop&lt;/code&gt;.  Very simple.</source>
          <target state="translated">시작부터 &lt;code&gt;start&lt;/code&gt; 하여 단계적으로 증가하며 &lt;code&gt;stop&lt;/code&gt; 도달하지 마십시오. 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="4b2092c15e09d1d0a69d863b94fdb3e35c63e659" translate="yes" xml:space="preserve">
          <source>Below is the example usage:</source>
          <target state="translated">아래는 사용법 예입니다.</target>
        </trans-unit>
        <trans-unit id="2b5c42838b863b4b8a4537944505370085a2f395" translate="yes" xml:space="preserve">
          <source>Below is the text of my original answer. It has been useful to many people, so I didn't want to delete it.</source>
          <target state="translated">아래는 원래 답변의 텍스트입니다. 많은 사람들에게 유용했기 때문에 삭제하고 싶지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c47e4145f6e8d534763f4eeb46a2b86362f0690b" translate="yes" xml:space="preserve">
          <source>Besides basic slicing, it is also possible to apply the following notation:</source>
          <target state="translated">기본 슬라이싱 외에도 다음 표기법을 적용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b189ce87053a4a6f9151c04b8051585e6e4e7ff" translate="yes" xml:space="preserve">
          <source>Blank values are defaulted as follows: &lt;code&gt;[+0:-0:1]&lt;/code&gt;.</source>
          <target state="translated">공백 값의 기본값은 &lt;code&gt;[+0:-0:1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9ab9f5780bbd8ad36625e87ca02af9b8bf9361df" translate="yes" xml:space="preserve">
          <source>But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the &lt;code&gt;end&lt;/code&gt;-th element.</source>
          <target state="translated">그러나 때때로 의문의 여지가 생겨 뇌가 &lt;code&gt;end&lt;/code&gt; 요소를 포함하지 않는다는 확신을 요구합니다.</target>
        </trans-unit>
        <trans-unit id="25e3d76337cea9e9d631c334c54bbcb275c06f0f" translate="yes" xml:space="preserve">
          <source>But this range continues in both directions infinitely:</source>
          <target state="translated">그러나이 범위는 양방향으로 무한대로 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="313813cd850a6b775a1fb26d3d9c84054d7263b9" translate="yes" xml:space="preserve">
          <source>But you can pass in a negative integer, and the list (or most other standard slicables) will be sliced from the end to the beginning.</source>
          <target state="translated">그러나 음수를 전달할 수 있으며 목록 (또는 대부분의 다른 표준 슬라 이블)은 끝에서 시작으로 슬라이스됩니다.</target>
        </trans-unit>
        <trans-unit id="78c9a2985c6c2db62af25652b536f68dff04e931" translate="yes" xml:space="preserve">
          <source>By default, when the &lt;code&gt;step&lt;/code&gt; argument is empty (or &lt;code&gt;None&lt;/code&gt;), it is assigned to &lt;code&gt;+1&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;step&lt;/code&gt; 인수가 비어 있거나 &lt;code&gt;None&lt;/code&gt; 이면 &lt;code&gt;+1&lt;/code&gt; 에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="74e101616da42c9f860f041e06e88cf3afc9af8d" translate="yes" xml:space="preserve">
          <source>Coming from other programming languages, that's when the common sense gets compromised. What are x and y?</source>
          <target state="translated">다른 프로그래밍 언어에서 나온 것은 상식이 타협되는 시점입니다. x와 y는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="114f22f6d7079d292a7e78398094c20f332e1368" translate="yes" xml:space="preserve">
          <source>Confirming this in the source</source>
          <target state="translated">소스에서 이것을 확인</target>
        </trans-unit>
        <trans-unit id="3eb94acf98e91b224000fb69a7e7764bf5d24a8e" translate="yes" xml:space="preserve">
          <source>Create two lists to slice. The first is a numeric list from 1 to 9 (List A). The second is also a numeric list, from 0 to 9 (List B):</source>
          <target state="translated">슬라이스 할 두 개의 목록을 작성하십시오. 첫 번째는 1에서 9까지의 숫자 목록입니다 (목록 A). 두 번째는 0에서 9까지의 숫자 목록입니다 (목록 B).</target>
        </trans-unit>
        <trans-unit id="57856d05bb32d5be32788eb0692ff1468ddf3c07" translate="yes" xml:space="preserve">
          <source>Depending on your application, that might... or might not... be what you were hoping for there!</source>
          <target state="translated">응용 프로그램에 따라, 당신이 원하는 것이거나 아닐 수도 있습니다!</target>
        </trans-unit>
        <trans-unit id="20f3af310b2b47de75d12e36f7756694568aec42" translate="yes" xml:space="preserve">
          <source>Don't worry about the &lt;code&gt;is None&lt;/code&gt; details - just remember that omitting &lt;code&gt;start&lt;/code&gt; and/or &lt;code&gt;stop&lt;/code&gt; always does the right thing to give you the whole sequence.</source>
          <target state="translated">아무것도 &lt;code&gt;is None&lt;/code&gt; 에 대해 걱정하지 마십시오. &lt;code&gt;start&lt;/code&gt; 및 / 또는 &lt;code&gt;stop&lt;/code&gt; 을 생략하면 항상 전체 시퀀스를 제공하는 것이 옳다는 것을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="6d6d1b284c6af28298538c5cdc0a7256d5d5f150" translate="yes" xml:space="preserve">
          <source>Easy way to reverse sequences!</source>
          <target state="translated">시퀀스를 바꾸는 쉬운 방법!</target>
        </trans-unit>
        <trans-unit id="dec3b85ab5c8afe4bdcf9aa78a36bb7b04f5b4e2" translate="yes" xml:space="preserve">
          <source>Enumerating the possibilities allowed by the grammar:</source>
          <target state="translated">문법에 의해 허용되는 가능성을 열거 :</target>
        </trans-unit>
        <trans-unit id="e2005c2f600247253cdd9b3a166cb5e388bbfb14" translate="yes" xml:space="preserve">
          <source>Explain Python's slice notation</source>
          <target state="translated">파이썬의 슬라이스 표기법 설명</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="ad2d3fd5da36e4d1450b52434f65543e2c249274" translate="yes" xml:space="preserve">
          <source>Extended indexing syntax used for slicing is aList[start:stop:step]. The start argument and the step argument both default to none - the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by range(start, stop, step). Python 3.4 documentation.</source>
          <target state="translated">슬라이싱에 사용되는 확장 인덱싱 구문은 aList [start : stop : step]입니다. start 인수와 step 인수는 모두 none으로 기본 설정됩니다. 필요한 유일한 인수는 stop입니다. 이것이 범위가 목록 A와 B를 정의하는 데 사용 된 방법과 유사하다는 것을 알고 있습니까? 슬라이스 개체는 range (start, stop, step)에 의해 지정된 인덱스 집합을 나타 내기 때문입니다. 파이썬 3.4 문서.</target>
        </trans-unit>
        <trans-unit id="25a46e8db798e121dc4a998aaa52b7c9c2f4ec77" translate="yes" xml:space="preserve">
          <source>Extended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.</source>
          <target state="translated">확장 슬라이싱 (쉼표와 타원 포함)은 대부분 특수 데이터 구조 (예 : NumPy)에서만 사용됩니다. 기본 시퀀스는이를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ce6a2c45d1f432b7017f6d8ad6c6f1f419ab941" translate="yes" xml:space="preserve">
          <source>Few other tricks for reversing the list:</source>
          <target state="translated">목록을 뒤집는 몇 가지 다른 트릭 :</target>
        </trans-unit>
        <trans-unit id="53c11609ebb7eeb39c6ae1148df32803811abaf7" translate="yes" xml:space="preserve">
          <source>First, we will create a list of values to use in our slicing.</source>
          <target state="translated">먼저 슬라이싱에 사용할 값 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="189f73dcf0d0e026377e4c161485f0bca4a39a7e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, negative values are interpreted as being relative to the end of the sequence.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 의 경우 음수 값은 시퀀스의 끝을 기준으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad09b9342bcb6da8bd5c7a868860d3b6440eb901" translate="yes" xml:space="preserve">
          <source>For those who don't know, you can create any substring from &lt;code&gt;azString&lt;/code&gt; using the notation &lt;code&gt;azString[x:y]&lt;/code&gt;</source>
          <target state="translated">모르는 사람들을 위해 &lt;code&gt;azString[x:y]&lt;/code&gt; 표기법을 사용하여 &lt;code&gt;azString&lt;/code&gt; 에서 하위 문자열을 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c2d2d5928c54cd3be6435296e94075da9fefa553" translate="yes" xml:space="preserve">
          <source>Found this great table at &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt; 에서이 훌륭한 테이블을 찾았습니다 .</target>
        </trans-unit>
        <trans-unit id="666ad671cbeba0a89e7c706687f77df7b879dbc2" translate="yes" xml:space="preserve">
          <source>From the diagram, I expect &lt;code&gt;a[-4,-6,-1]&lt;/code&gt; to be &lt;code&gt;yP&lt;/code&gt; but it is &lt;code&gt;ty&lt;/code&gt;.</source>
          <target state="translated">다이어그램에서 &lt;code&gt;a[-4,-6,-1]&lt;/code&gt; 은 &lt;code&gt;yP&lt;/code&gt; 일 것으로 예상되지만 &lt;code&gt;ty&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="181af959e4f8d0fb4083b24c9a79dcab0d808777" translate="yes" xml:space="preserve">
          <source>Give your slices a descriptive name!</source>
          <target state="translated">슬라이스에 설명적인 이름을 지정하십시오!</target>
        </trans-unit>
        <trans-unit id="d8bca9c064390cb40eb6923b46c08e356cc9a63d" translate="yes" xml:space="preserve">
          <source>Given the pattern aList[start:stop], retrieve the first two elements from List A.</source>
          <target state="translated">aList [start : stop] 패턴이 주어지면 List A에서 처음 두 요소를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="f94faa9a2d2714420791cc753d22514493d014e9" translate="yes" xml:space="preserve">
          <source>Here is an example visualization of that ...</source>
          <target state="translated">다음은 그 시각화 예입니다 ...</target>
        </trans-unit>
        <trans-unit id="77b2dd3c3ff1e4885a243132aecac207f224e3f5" translate="yes" xml:space="preserve">
          <source>How Indexing Works</source>
          <target state="translated">인덱싱 작동 방식</target>
        </trans-unit>
        <trans-unit id="6f1f32310474f8326626103969ab54a0b5070606" translate="yes" xml:space="preserve">
          <source>How Slicing Works</source>
          <target state="translated">슬라이싱 작동 방식</target>
        </trans-unit>
        <trans-unit id="3da40c095b10f44487cd4ccca0f47467d44aa681" translate="yes" xml:space="preserve">
          <source>However, using a negative value for &lt;code&gt;step&lt;/code&gt; could become very confusing. Moreover, in order to be &lt;a href=&quot;https://en.wiktionary.org/wiki/Pythonic#Adjective&quot;&gt;Pythonic&lt;/a&gt;, you should avoid using &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).</source>
          <target state="translated">그러나 &lt;code&gt;step&lt;/code&gt; 음수 값을 사용하면 매우 혼란 스러울 수 있습니다. 또한 &lt;a href=&quot;https://en.wiktionary.org/wiki/Pythonic#Adjective&quot;&gt;Pythonic&lt;/a&gt; 되기 위해서는 단일 슬라이스에서 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;step&lt;/code&gt; 사용을 피해야합니다. 이것이 필요한 경우, 두 가지 과제 (하나는 슬라이스하고 다른 하나는 걸음)에서 이것을 수행하는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4ad93a5dd4fcd6d7c940755502a6bc63d374feb4" translate="yes" xml:space="preserve">
          <source>However, you can't just assign some integers separated by colons to a variable. You need to use the slice object:</source>
          <target state="translated">그러나 콜론으로 구분 된 정수를 변수에 지정할 수는 없습니다. 슬라이스 객체를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aaa8f93b237e6d327bf33efc09bdaf86ccf36c81" translate="yes" xml:space="preserve">
          <source>I don't think that the &lt;a href=&quot;https://docs.python.org/3/tutorial/introduction.html#strings&quot;&gt;Python tutorial&lt;/a&gt; diagram (cited in various other answers) is good as this suggestion works for positive stride, but does not for a negative stride.</source>
          <target state="translated">나는이 제안이 긍정적 보폭에는 효과가 있지만 부정적인 보폭에는 그렇지 않기 때문에 &lt;a href=&quot;https://docs.python.org/3/tutorial/introduction.html#strings&quot;&gt;파이썬 튜토리얼&lt;/a&gt; 다이어그램 (다양한 다른 답변에 인용)이 좋다고 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c138ed3c54e5f033afa16fdbd5fccf8d39b80779" translate="yes" xml:space="preserve">
          <source>I find it easier to remember how it works, and then I can figure out any specific start/stop/step combination.</source>
          <target state="translated">작동 방식을 기억하기가 더 쉽다는 것을 알게 된 후 특정 시작 / 중지 / 단계 조합을 알아낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef399e0ded15774144fa63ae11d01aba3089469e" translate="yes" xml:space="preserve">
          <source>I had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt.</source>
          <target state="translated">나는 x와 y가 무엇인지 기억하고 첫 번째 시도에서 문자열을 올바르게 슬라이스하는 데 도움이되는 암기 기술을 찾기 위해 앉아서 여러 시나리오를 실행해야했습니다.</target>
        </trans-unit>
        <trans-unit id="c7d0e42afda61407f67326f1c6eb38abab198765" translate="yes" xml:space="preserve">
          <source>I hope this will help you to model the list in Python.</source>
          <target state="translated">이것이 파이썬으로 목록을 모델링하는 데 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="77b54aef5e492c40146cd9a6d0b499de291945d3" translate="yes" xml:space="preserve">
          <source>I like to encourage users to read the source as well as the documentation. The &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/sliceobject.c&quot;&gt;source code for slice objects and this logic is found here&lt;/a&gt;. First we determine if &lt;code&gt;step&lt;/code&gt; is negative:</source>
          <target state="translated">사용자가 문서뿐만 아니라 소스를 읽도록 권장합니다. &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/sliceobject.c&quot;&gt;슬라이스 개체 및이 논리에 대한 소스 코드는 여기에 있습니다&lt;/a&gt; . 먼저 &lt;code&gt;step&lt;/code&gt; 가 음수인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5d3b3b36c387b5d0fc042b55acf61c2d549b5f7d" translate="yes" xml:space="preserve">
          <source>I need a good explanation (references are a plus) on Python's slice notation.</source>
          <target state="translated">파이썬의 슬라이스 표기법에 대한 좋은 설명 (참조는 플러스)이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ad507a3da03671c61941620ae7a2906912f4a37b" translate="yes" xml:space="preserve">
          <source>I personally think about it like a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">개인적으로 &lt;code&gt;for&lt;/code&gt; 루프처럼 생각합니다.</target>
        </trans-unit>
        <trans-unit id="98382aeb1507eab72853d9ce777b3db6e8f02198" translate="yes" xml:space="preserve">
          <source>I use the &quot;an index points between elements&quot; method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:</source>
          <target state="translated">나는 스스로 생각하는 &quot;요소들 사이의 인덱스 포인트&quot;방법을 사용하지만 때로는 다른 사람들이 이해하는 데 도움이되는 한 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c6fedebad3f718314d64d61745e8419abe48090" translate="yes" xml:space="preserve">
          <source>I want to add one &lt;em&gt;Hello, World!&lt;/em&gt; example that explains the basics of slices for the very beginners. It helped me a lot.</source>
          <target state="translated">&lt;em&gt;안녕하세요, 월드를&lt;/em&gt; 하나 추가하고 싶습니다 &lt;em&gt;!&lt;/em&gt; 초보자를위한 슬라이스 기본 사항을 설명하는 예제입니다. 그것은 많은 도움이되었습니다.</target>
        </trans-unit>
        <trans-unit id="152b4bcea4dcb6a08bc28ea6e60677690158dfe0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stride&lt;/code&gt; is negative, the ordering is changed a bit since we're counting down:</source>
          <target state="translated">&lt;code&gt;stride&lt;/code&gt; 이 음수이면 카운트 다운 이후 순서가 약간 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="cd1befa8b487c0ecabed83a3de28c3d4c4a8dbce" translate="yes" xml:space="preserve">
          <source>If so, the lower bound is &lt;code&gt;-1&lt;/code&gt;  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this &lt;code&gt;-1&lt;/code&gt; is &lt;em&gt;different&lt;/em&gt; from a &lt;code&gt;-1&lt;/code&gt; that users may pass indexes in Python indicating the last item.)</source>
          <target state="translated">그렇다면 하한은 &lt;code&gt;-1&lt;/code&gt; 을 의미하며 시작을 포함하여 끝까지 슬라이스하고 상한은 길이에서 1을 뺀 값으로 끝에서 시작합니다. (이 &lt;code&gt;-1&lt;/code&gt; 의 의미는 사용자가 마지막 항목을 나타내는 Python의 인덱스를 전달할 수 있다는 -1 과 &lt;em&gt;다릅니다&lt;/em&gt; .)</target>
        </trans-unit>
        <trans-unit id="2f065d470b215e663b57b87dd50c698f07db3377" translate="yes" xml:space="preserve">
          <source>If the index is out of range, Python will try its best to set the index to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;len(s)&lt;/code&gt; according to the situation. For example:</source>
          <target state="translated">인덱스가 범위를 벗어나면 Python은 상황에 따라 인덱스를 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;len(s)&lt;/code&gt; 으로 설정하기 위해 최선을 다할 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8def849642c7353545fcda04de289db5103721fe" translate="yes" xml:space="preserve">
          <source>If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced:</source>
          <target state="translated">할당 작업을 수행 할 때 시작 및 끝 인덱스가 생략되면 컬렉션의 전체 내용이 참조 된 내용의 복사본으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="661ece95ee93a03aaa302b463dca836f55c6dd14" translate="yes" xml:space="preserve">
          <source>If you check the source code of &lt;a href=&quot;http://en.wikipedia.org/wiki/CPython&quot;&gt;CPython&lt;/a&gt;, you will find a function called PySlice_GetIndicesEx() which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/CPython&quot;&gt;CPython&lt;/a&gt; 의 소스 코드를 확인하면 PySlice_GetIndicesEx ()라는 함수를 사용하여 주어진 매개 변수에 대한 슬라이스의 인덱스를 파악할 수 있습니다. 다음은 파이썬에서 논리적으로 동등한 코드입니다.</target>
        </trans-unit>
        <trans-unit id="47b5bc36bf784848f762edafdff62074643233f8" translate="yes" xml:space="preserve">
          <source>If you feel negative indices in slicing is confusing, here's a very easy way to think about it: just replace the negative index with &lt;code&gt;len - index&lt;/code&gt;. So for example, replace -3 with &lt;code&gt;len(list) - 3&lt;/code&gt;.</source>
          <target state="translated">슬라이싱에서 음수 인덱스가 혼동된다고 생각되면 여기에 대해 매우 쉽게 생각할 수 있습니다. 음수 인덱스를 &lt;code&gt;len - index&lt;/code&gt; 바꾸십시오. 예를 들어, -3을 &lt;code&gt;len(list) - 3&lt;/code&gt; -3으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="fa833ad31212b2a3b3d439a0e7c53b383e2b3ca5" translate="yes" xml:space="preserve">
          <source>If you have a slice instance s, you can get more information about it by looking at its
s.start, s.stop, and s.step attributes, respectively. For example:</source>
          <target state="translated">슬라이스 인스턴스가있는 경우 각각 s.start, s.stop 및 s.step 속성을보고 이에 대한 자세한 정보를 얻을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3d97417ba0181b71f5aaffd104fe653cf71364a" translate="yes" xml:space="preserve">
          <source>If you omit the start and end index, you will make a copy of the collection:</source>
          <target state="translated">시작 및 종료 색인을 생략하면 콜렉션의 사본을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f60db26cf6492e7fc7bbed6f90da520c3f57371b" translate="yes" xml:space="preserve">
          <source>If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list.</source>
          <target state="translated">a, b 및 c를 선택하면 위의 a, b, c에 대한 규칙을 사용하여 트래버스 할 때 위의 범위와 겹칠 수 있으면 요소가 포함 된 목록 (탐색 중 터치)을 얻거나 빈 목록을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="f466c12bda6762ec7169a18df85f167e0081116f" translate="yes" xml:space="preserve">
          <source>Important Definitions</source>
          <target state="translated">중요한 정의</target>
        </trans-unit>
        <trans-unit id="f2bb9ecf761b6e88e8102a7536ee8d44abe40249" translate="yes" xml:space="preserve">
          <source>In Python 2.7</source>
          <target state="translated">파이썬 2.7에서</target>
        </trans-unit>
        <trans-unit id="90a6eb777e8cda542826e3c6334816f4f0ee8eb6" translate="yes" xml:space="preserve">
          <source>In Python, the most basic form for slicing is the following:</source>
          <target state="translated">파이썬에서 슬라이싱을위한 가장 기본적인 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ee248346d0af5cd683e4a36d0a440e60af3c740" translate="yes" xml:space="preserve">
          <source>In fact, compared to indexing, Python slicing is bizarrely error-proof:</source>
          <target state="translated">사실, 인덱싱과 비교하여 파이썬 슬라이싱은 기이하게 오류를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="e26167c936dd528fda49f3a0a8e244ad7c09578d" translate="yes" xml:space="preserve">
          <source>In my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on).</source>
          <target state="translated">내 의견으로는, 파이썬 문자열 슬라이싱 표기법을 다음과 같이 보면 더 잘 이해하고 기억할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7dabe40d708c905a0cefb23cf2333f28977c80b" translate="yes" xml:space="preserve">
          <source>In short, the colons (&lt;code&gt;:&lt;/code&gt;) in subscript notation (&lt;code&gt;subscriptable[subscriptarg]&lt;/code&gt;) make slice notation - which has the optional arguments, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;:</source>
          <target state="translated">간단히 말해서, 첨자 표기법 ( &lt;code&gt;subscriptable[subscriptarg]&lt;/code&gt; )에서 콜론 (:)은 슬라이스 표기법을 만듭니다. 이것은 선택적 인수 인 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; 이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb5e2ff5da706301f634ce9ca90e75ed00059cba" translate="yes" xml:space="preserve">
          <source>In these moments I rely on this simple theorem:</source>
          <target state="translated">이 순간에 나는이 간단한 정리에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="5870a8ca498a1c74154e2cfd9acc8e21c121fdb0" translate="yes" xml:space="preserve">
          <source>Index the number 3 from A and the number 6 from B.</source>
          <target state="translated">A의 숫자 3과 B의 숫자 6을 인덱싱하십시오.</target>
        </trans-unit>
        <trans-unit id="3631e9d015a9f2d779f98610e8e9d63664c32ef5" translate="yes" xml:space="preserve">
          <source>Indexing is like dealing with the contents of box. You can check contents of any box. But you can't check the contents of multiple boxes at once. You can even replace the contents of the box. But you can't place two balls in one box or replace two balls at a time.</source>
          <target state="translated">인덱싱은 박스의 내용을 다루는 것과 같습니다. 모든 상자의 내용을 확인할 수 있습니다. 그러나 한 번에 여러 상자의 내용을 확인할 수 없습니다. 상자 내용물을 교체 할 수도 있습니다. 그러나 한 상자에 두 개의 공을 넣거나 한 번에 두 개의 공을 교체 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e852a9a85a011a4821ea957a6c18af49fdb2384" translate="yes" xml:space="preserve">
          <source>It is a list with six elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it.</source>
          <target state="translated">6 개의 요소가 포함 된 목록입니다. 슬라이싱을 더 잘 이해하려면 해당 목록을 6 개의 상자 세트로 구성하십시오. 각 상자에는 알파벳이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72edc078c44d61355487724654334d433672237e" translate="yes" xml:space="preserve">
          <source>It is also possible to use negative integers for &lt;code&gt;step&lt;/code&gt; as the following example:</source>
          <target state="translated">다음 예제와 같이 &lt;code&gt;step&lt;/code&gt; 음수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2e55fc42f854f48df8f7704c2076ef2f0b82f26" translate="yes" xml:space="preserve">
          <source>It is important to note, the first element is index 0, &lt;em&gt;not&lt;/em&gt; index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc.) while List B's elements are the numbers that would be used to index them ([0] for the first element 0, etc.).</source>
          <target state="translated">첫 번째 요소는 인덱스 1이 &lt;em&gt;아니라&lt;/em&gt; 인덱스 0입니다. 이것이 우리가이 연습에 2 개의 목록을 사용하는 이유입니다. List A의 요소는 서수 위치에 따라 번호가 매겨지며 (첫 번째 요소는 1, 두 번째 요소는 2 등) List B의 요소는 색인을 만드는 데 사용되는 숫자입니다 (첫 번째 요소 0의 경우 [0], 기타.).</target>
        </trans-unit>
        <trans-unit id="8437802c00fcb02882fb640fb2f6aa10b7ed41e7" translate="yes" xml:space="preserve">
          <source>It is possible to provide indices that are out of bounds when slicing such as:</source>
          <target state="translated">다음과 같이 슬라이싱 할 때 범위를 벗어난 인덱스를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc08d6b3965c9cd2a7d0a9d353abfe631305e0ce" translate="yes" xml:space="preserve">
          <source>It looks extremely powerful, but I haven't quite got my head around it.</source>
          <target state="translated">그것은 매우 강력 해 보이지만, 나는 그 주위에 내 머리를 갖지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="c3478bf3faba9c41f22e71efd498abcab65d1e72" translate="yes" xml:space="preserve">
          <source>It's instructive to understand &lt;code&gt;range()&lt;/code&gt; first:</source>
          <target state="translated">&lt;code&gt;range()&lt;/code&gt; 먼저 이해하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="db93970c161e9b60dc37836b4ad4bcc5e738b56f" translate="yes" xml:space="preserve">
          <source>It's interesting that ranges also take slices:</source>
          <target state="translated">범위에도 조각이 필요하다는 점이 흥미 롭습니다.</target>
        </trans-unit>
        <trans-unit id="393247b02d3798ab868c03bcc3f85e6ad9331f9b" translate="yes" xml:space="preserve">
          <source>It's pretty simple really:</source>
          <target state="translated">정말 간단합니다.</target>
        </trans-unit>
        <trans-unit id="07e297809eb4051826121e82a0caefbf899d3c86" translate="yes" xml:space="preserve">
          <source>Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignments do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values:</source>
          <target state="translated">컬렉션을 슬라이스 한 결과는 완전히 새로운 컬렉션입니다. 또한 할당에 슬라이스 표기법을 사용할 때 슬라이스 할당의 길이가 같을 필요는 없습니다. 할당 된 슬라이스 전후의 값이 유지되고 컬렉션은 새 값을 포함하도록 축소되거나 커집니다.</target>
        </trans-unit>
        <trans-unit id="cf594f555786da65b5bbbcfa5d1f5e37ff7665e6" translate="yes" xml:space="preserve">
          <source>Let's finish this answer with examples, explaining everything we have discussed:</source>
          <target state="translated">우리가 논의한 모든 것을 설명하면서 예제로이 답변을 마무리합시다 :</target>
        </trans-unit>
        <trans-unit id="26f47aa550adca492b5233c25393b47b841fe5ad" translate="yes" xml:space="preserve">
          <source>Let's have a list with six values &lt;code&gt;['P', 'Y', 'T', 'H', 'O', 'N']&lt;/code&gt;:</source>
          <target state="translated">6 개의 값 &lt;code&gt;['P', 'Y', 'T', 'H', 'O', 'N']&lt;/code&gt; 이있는 목록을 보자.</target>
        </trans-unit>
        <trans-unit id="7137555528de00a0bcf2c040f1daafce2f58347c" translate="yes" xml:space="preserve">
          <source>Let's work with the following string ...</source>
          <target state="translated">다음 문자열로 작업 해 봅시다 ...</target>
        </trans-unit>
        <trans-unit id="3f6a7a17387285ecbb29103e91399ef401031fff" translate="yes" xml:space="preserve">
          <source>Making things more confusing is that &lt;strong&gt;&lt;code&gt;step&lt;/code&gt; can be negative too!&lt;/strong&gt;</source>
          <target state="translated">상황을 더 혼란스럽게 만드는 것은 &lt;strong&gt; &lt;code&gt;step&lt;/code&gt; 도 부정적 일 수 있다는 것입니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4d6fecb17d10399cfa47983f1042cccd5affc47" translate="yes" xml:space="preserve">
          <source>Memory Considerations:</source>
          <target state="translated">메모리 고려 사항 :</target>
        </trans-unit>
        <trans-unit id="1ff1eb25d65b7e8b0b1c5bcc0650dd539ed6fbbd" translate="yes" xml:space="preserve">
          <source>More slicing examples: &lt;a href=&quot;https://docs.python.org/2.3/whatsnew/section-slices.html&quot;&gt;15 Extended Slices&lt;/a&gt;</source>
          <target state="translated">더 많은 슬라이스 예 : &lt;a href=&quot;https://docs.python.org/2.3/whatsnew/section-slices.html&quot;&gt;15 개의 확장 슬라이스&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="236384af55aea443e68110eede08ce564e280d4c" translate="yes" xml:space="preserve">
          <source>Most of the previous answers clears up questions about slice notation.</source>
          <target state="translated">이전 답변의 대부분은 슬라이스 표기법에 대한 질문을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="258dc3b32b7b8c786022e52d99f1e20b993d915e" translate="yes" xml:space="preserve">
          <source>My brain seems happy to accept that &lt;code&gt;lst[start:end]&lt;/code&gt; contains the &lt;code&gt;start&lt;/code&gt;-th item. I might even say that it is a 'natural assumption'.</source>
          <target state="translated">내 두뇌는 &lt;code&gt;lst[start:end]&lt;/code&gt; 에 &lt;code&gt;start&lt;/code&gt; 번째 항목이 포함되어 있음을 기뻐합니다. 나는 그것이 '자연적인 가정'이라고 말할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e9abc9291766099a35bbc0daca4bfdba74ab393" translate="yes" xml:space="preserve">
          <source>My conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as &lt;code&gt;azString[index1, index2]&lt;/code&gt; or even more clearer as &lt;code&gt;azString[index_of_first_character, index_after_the_last_character]&lt;/code&gt;.</source>
          <target state="translated">필자의 결론은 x와 y는 우리가 추가하고자하는 문자열을 둘러싼 경계 인덱스로보아야한다는 것입니다. 따라서 표현식은 &lt;code&gt;azString[index1, index2]&lt;/code&gt; 또는 &lt;code&gt;azString[index_of_first_character, index_after_the_last_character]&lt;/code&gt; 보다 명확해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bc0687f0ccd20cd39dcb014b119503d374c4139" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;start &amp;gt;= end&lt;/code&gt; (considering only when &lt;code&gt;step&amp;gt;0&lt;/code&gt;), Python will return a empty slice &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;start &amp;gt;= end&lt;/code&gt; ( &lt;code&gt;step&amp;gt;0&lt;/code&gt; 에만 고려) 경우 Python은 빈 슬라이스 &lt;code&gt;[]&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3924ca69a9c6ef3c94b8adce539357eedbfe98b1" translate="yes" xml:space="preserve">
          <source>Negative indexes</source>
          <target state="translated">음의 인덱스</target>
        </trans-unit>
        <trans-unit id="19a3fcc38635b3630af723c1238943e8e1843247" translate="yes" xml:space="preserve">
          <source>Negative integers are useful when doing offsets relative to the end of a collection:</source>
          <target state="translated">음수는 컬렉션의 끝을 기준으로 오프셋을 수행 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="afa9d728aad9ce367861bb103920cb5b75e339e7" translate="yes" xml:space="preserve">
          <source>Negative step</source>
          <target state="translated">부정적인 단계</target>
        </trans-unit>
        <trans-unit id="96650fe967ba54c6b724f6429dd3614089107d32" translate="yes" xml:space="preserve">
          <source>Normalizing negative indexes first allows start and/or stop to be counted from the end independently: &lt;code&gt;'abcde'[1:-2] == 'abcde'[1:3] == 'bc'&lt;/code&gt; despite &lt;code&gt;range(1,-2) == []&lt;/code&gt;.
The normalization is sometimes thought of as &quot;modulo the length&quot;, but note it adds the length just once: e.g. &lt;code&gt;'abcde'[-53:42]&lt;/code&gt; is just the whole string.</source>
          <target state="translated">음수 인덱스을 정규화하면 먼저 시작 및 / 또는 중지를 끝에서 독립적으로 계산할 수 있습니다. &lt;code&gt;'abcde'[1:-2] == 'abcde'[1:3] == 'bc'&lt;/code&gt; &lt;code&gt;range(1,-2) == []&lt;/code&gt; 에도 불구하고 == [] . 정규화는 때때로 &quot;길이 모듈로&quot;로 생각되지만 길이를 한 번만 추가한다는 점에 유의하십시오. 예를 들어 &lt;code&gt;'abcde'[-53:42]&lt;/code&gt; 는 전체 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4d43af0ad3abe59f6e4fb376c128181bd7bde7b5" translate="yes" xml:space="preserve">
          <source>Note that this theorem is true for any &lt;code&gt;n&lt;/code&gt; at all. For example, you can check that</source>
          <target state="translated">이 정리는 모든 &lt;code&gt;n&lt;/code&gt; 에 대해 사실입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2ceb96fc5e9a3dc2bc105bff4a65c7e6742be2cc" translate="yes" xml:space="preserve">
          <source>Note that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments.</source>
          <target state="translated">슬라이스의 두 번째 숫자 (4)를 변경하지 않기 때문에 빈 슬라이스에 할당하더라도 삽입 된 항목은 항상 'o'에 대해 쌓입니다. 따라서 빈 슬라이스 할당 위치는 비어 있지 않은 슬라이스 할당 위치의 논리적 확장입니다.</target>
        </trans-unit>
        <trans-unit id="967bf0aa1a3677571a7849b566735433ec166495" translate="yes" xml:space="preserve">
          <source>Now if you make a slice &lt;code&gt;[2:5]&lt;/code&gt; of the list above, this will happen:</source>
          <target state="translated">이제 위 목록의 슬라이스 &lt;code&gt;[2:5]&lt;/code&gt; 를 만들면 이런 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e6df6b2bcf9a3314ee026c4f79df59cdd07fa7f8" translate="yes" xml:space="preserve">
          <source>Now the simplest slices of that list are its sublists. The notation is &lt;code&gt;[&amp;lt;index&amp;gt;:&amp;lt;index&amp;gt;]&lt;/code&gt; and the key is to read it like this:</source>
          <target state="translated">이제 해당 목록의 가장 간단한 조각은 하위 목록입니다. 표기법은 &lt;code&gt;[&amp;lt;index&amp;gt;:&amp;lt;index&amp;gt;]&lt;/code&gt; 이며 키는 다음과 같이 읽습니다.</target>
        </trans-unit>
        <trans-unit id="4b69184bd6d629ae67ecbb030f96e1b6febacc6a" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;(high-low)%stride != 0&lt;/code&gt;, then the end point will be a little lower than &lt;code&gt;high-1&lt;/code&gt;.</source>
          <target state="translated">물론 &lt;code&gt;(high-low)%stride != 0&lt;/code&gt; 이면 끝 점이 &lt;code&gt;high-1&lt;/code&gt; 보다 약간 낮아집니다.</target>
        </trans-unit>
        <trans-unit id="9797498b5445b5a3c49a8d9a5a8bcc115a3f1de4" translate="yes" xml:space="preserve">
          <source>One heuristic is, for a slice from zero to n, think: &quot;zero is the beginning, start at the beginning and take n items in a list&quot;.</source>
          <target state="translated">휴리스틱 중 하나는 0에서 n까지의 슬라이스에 대해 &quot;0은 시작이며 처음부터 시작하여 목록에서 n 개의 항목을 가져옵니다&quot;라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="1deb5c09927c43e07c799a375e42510fd8ab8301" translate="yes" xml:space="preserve">
          <source>One last thing: if a and b are equal, then also you get an empty list:</source>
          <target state="translated">마지막으로 a와 b가 같으면 빈 목록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="22de4720e28cbf22dbc85b732b56fab0a497d9da" translate="yes" xml:space="preserve">
          <source>One way to remember how slices work is to think of the indices as pointing &lt;em&gt;between&lt;/em&gt; characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of &lt;em&gt;n&lt;/em&gt; characters has index &lt;em&gt;n&lt;/em&gt;.</source>
          <target state="translated">슬라이스의 작동 방식을 기억하는 한 가지 방법은 첫 번째 문자의 왼쪽 가장자리가 0 인 인덱스를 문자 &lt;em&gt;사이&lt;/em&gt; 를 가리키는 것으로 생각하는 것입니다. 그런 다음 &lt;em&gt;n 개의&lt;/em&gt; 문자열 문자열의 마지막 문자의 오른쪽 가장자리에는 인덱스 &lt;em&gt;n이&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="01230747b9914341b6ea0abf3a127d2554050e61" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;step&lt;/code&gt; is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;step&lt;/code&gt; 는 양수이고 하한은 0이고 상한은 (우리는 올라가지 만 포함하지는 않음) 슬라이스 목록의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="6ee09859ae901d353f04d7756fc619a422996265" translate="yes" xml:space="preserve">
          <source>Out of range error?</source>
          <target state="translated">범위를 벗어난 오류?</target>
        </trans-unit>
        <trans-unit id="1e32d6d4f298657e76954434ba9df3c467b606d2" translate="yes" xml:space="preserve">
          <source>Positive indices for &lt;code&gt;end&lt;/code&gt; indicate the position &lt;em&gt;after&lt;/em&gt; the last element to be included.</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; 에 대한 양의 인덱스는 마지막 요소가 포함 된 &lt;em&gt;후의&lt;/em&gt; 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="94740c4c4bc99ca509491718d4ba079f2a8f218e" translate="yes" xml:space="preserve">
          <source>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for &lt;code&gt;a[:-2]&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.</source>
          <target state="translated">파이썬은 당신이 요구하는 것보다 적은 수의 아이템이 있다면 프로그래머에게 친절합니다. 예를 들어, &lt;code&gt;a[:-2]&lt;/code&gt; 를 요청하고 하나의 요소 만 포함하면 오류 대신 빈 목록이 표시됩니다. 때로는 오류를 선호하기 때문에 이러한 상황이 발생할 수 있음을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b248a1be31c8962b0faa6461a8e1ebdb8bf936b1" translate="yes" xml:space="preserve">
          <source>Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with.</source>
          <target state="translated">Python 슬라이싱은 데이터의 일부에 체계적으로 액세스하는 계산 방식의 빠른 방법입니다. 제 생각에는 중급 파이썬 프로그래머가 되려면 익숙해야 할 언어의 한 측면입니다.</target>
        </trans-unit>
        <trans-unit id="4be307b534051fdddbb09f680b1f90334e27c87c" translate="yes" xml:space="preserve">
          <source>Python slicing notation:</source>
          <target state="translated">파이썬 슬라이싱 표기법 :</target>
        </trans-unit>
        <trans-unit id="0f99ce71c7cc473f59ebcdd42fafcac7ebb5607c" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85e3167baf4fe31a5ac66fca1064289b89090879" translate="yes" xml:space="preserve">
          <source>Relation to &lt;code&gt;slice()&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;slice()&lt;/code&gt; 객체와의 관계</target>
        </trans-unit>
        <trans-unit id="ded5af84f53bac1b910e783dc1876f40d1930247" translate="yes" xml:space="preserve">
          <source>Remember that we are setting the boundaries. And those boundaries are the positions where you could place some brackets that will be wrapped around the substring like this ...</source>
          <target state="translated">우리는 경계를 설정하고 있음을 기억하십시오. 그리고 그 경계는 다음과 같이 부분 문자열을 감싸는 괄호를 넣을 수있는 위치입니다 ...</target>
        </trans-unit>
        <trans-unit id="87aef1727fb2103950e2e345944a306d9d583015" translate="yes" xml:space="preserve">
          <source>Sequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence:</source>
          <target state="translated">시퀀스 슬라이싱은 음의 인덱스를 먼저 정규화한다는 점을 제외하고는 동일하며 시퀀스 외부로 나올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96eaebe560215c517ad3e5af8e2a9735ecb8738d" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;step&lt;/code&gt; may be a negative number:</source>
          <target state="translated">마찬가지로 &lt;code&gt;step&lt;/code&gt; 는 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae00240360bccc296201ca8138f454fe741d7f58" translate="yes" xml:space="preserve">
          <source>Since slices of Python lists create new objects in memory, another important function to be aware of is &lt;code&gt;itertools.islice&lt;/code&gt;. Typically you'll want to iterate over a slice, not just have it created statically in memory. &lt;code&gt;islice&lt;/code&gt; is perfect for this. A caveat, it doesn't support negative arguments to &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, or &lt;code&gt;step&lt;/code&gt;, so if that's an issue you may need to calculate indices or reverse the iterable in advance.</source>
          <target state="translated">파이썬 목록 조각은 메모리에 새로운 객체를 생성하기 때문에 알아야 할 또 다른 중요한 기능은 &lt;code&gt;itertools.islice&lt;/code&gt; 입니다. 일반적으로 메모리에서 정적으로 생성 된 것이 아니라 슬라이스를 반복하는 것이 좋습니다. &lt;code&gt;islice&lt;/code&gt; 는 이것에 완벽합니다. 주의 사항 : &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; 또는 &lt;code&gt;step&lt;/code&gt; 에는 부정적인 인수를 지원하지 않으므로 문제가되는 경우 인덱스를 계산하거나 iterable을 미리 되돌려 야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c3c2e5e113c75c44c107bde062191fa1ee7c4b5" translate="yes" xml:space="preserve">
          <source>Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:</source>
          <target state="translated">목록에서 마지막 9 개 요소 (또는 문자열과 같이이를 지원하는 다른 시퀀스)를 가져 오는 슬라이스 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afd155507ef02b023315f7f2437ce7518f12da0e" translate="yes" xml:space="preserve">
          <source>Slice notation works like this:</source>
          <target state="translated">슬라이스 표기법은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2bf8562fbd4372800fdbdad7eef6770e5b0c3ac3" translate="yes" xml:space="preserve">
          <source>Slice objects also behave slightly differently depending on the number of arguments, similarly to &lt;code&gt;range()&lt;/code&gt;, i.e. both &lt;code&gt;slice(stop)&lt;/code&gt; and &lt;code&gt;slice(start, stop[, step])&lt;/code&gt; are supported.
To skip specifying a given argument, one might use &lt;code&gt;None&lt;/code&gt;, so that e.g. &lt;code&gt;a[start:]&lt;/code&gt; is equivalent to &lt;code&gt;a[slice(start, None)]&lt;/code&gt; or &lt;code&gt;a[::-1]&lt;/code&gt; is equivalent to &lt;code&gt;a[slice(None, None, -1)]&lt;/code&gt;.</source>
          <target state="translated">슬라이스 객체도 인수의 수에 따라 약간 다르게 동작합니다. 예를 들어 &lt;code&gt;range()&lt;/code&gt; 와 비슷하게 &lt;code&gt;slice(stop)&lt;/code&gt; 및 &lt;code&gt;slice(start, stop[, step])&lt;/code&gt; 가 모두 지원됩니다. 주어진 인수 지정을 건너 뛰려면 &lt;code&gt;None&lt;/code&gt; 을 사용할 수 있습니다. 예를 들어 &lt;code&gt;a[start:]&lt;/code&gt; 는 &lt;code&gt;a[slice(start, None)]&lt;/code&gt; 같거나 &lt;code&gt;a[::-1]&lt;/code&gt; 은 &lt;code&gt;a[slice(None, None, -1)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0de34fe528d24a6ab78b22ea621d459ea58bcde" translate="yes" xml:space="preserve">
          <source>Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use &lt;a href=&quot;https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python&quot;&gt;&lt;code&gt;deepcopy()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">슬라이스는 배열 요소의 사본이 아닌 참조를 보유합니다. 별도의 복사본을 배열로 만들려면 &lt;a href=&quot;https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python&quot;&gt; &lt;code&gt;deepcopy()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7a0ec14b698ea62c178c70915809b11eee0b1d4" translate="yes" xml:space="preserve">
          <source>Slicing example: [start:end:step]</source>
          <target state="translated">슬라이스 예 : [start : end : step]</target>
        </trans-unit>
        <trans-unit id="0fab7676f1313a7031d732db17a3266ea48b260e" translate="yes" xml:space="preserve">
          <source>Slicing in Python</source>
          <target state="translated">파이썬에서 슬라이싱</target>
        </trans-unit>
        <trans-unit id="2f82b358ce4a2bd3562b18aca5eb96f4abc16964" translate="yes" xml:space="preserve">
          <source>Slicing is like dealing with boxes themselves. You can pick up the first box and place it on another table. To pick up the box, all you need to know is the position of beginning and ending of the box.</source>
          <target state="translated">슬라이스는 박스 자체를 다루는 것과 같습니다. 첫 번째 상자를 들고 다른 테이블에 놓을 수 있습니다. 상자를 집어 올리려면 상자의 시작과 끝 위치 만 알면됩니다.</target>
        </trans-unit>
        <trans-unit id="b6071a94da6c32b2f41ecdb9b7c54c4fc53d3bbe" translate="yes" xml:space="preserve">
          <source>So all you have to do is setting index1 and index2 to the values that will surround the desired substring. For instance, to get the substring &quot;cdefgh&quot;, you can use &lt;code&gt;azString[2:8]&lt;/code&gt;, because the index on the left side of &quot;c&quot; is 2 and the one on the right size of &quot;h&quot; is 8.</source>
          <target state="translated">따라서 index1과 index2를 원하는 부분 문자열을 둘러싸는 값으로 설정하기 만하면됩니다. 예를 들어, 하위 문자열 &quot;cdefgh&quot;를 ​​가져 오려면 &quot;c&quot;의 왼쪽에있는 인덱스는 2이고 &quot;h&quot;의 오른쪽 크기에있는 인덱스는 &lt;code&gt;azString[2:8]&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d36a8ded558a57acb9a21c94c859b6d67771f8e" translate="yes" xml:space="preserve">
          <source>So possible variations are:</source>
          <target state="translated">가능한 변형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e112be622e92277daa08e6daca504e718916de7" translate="yes" xml:space="preserve">
          <source>That trick works all the time and is easy to memorize.</source>
          <target state="translated">그 트릭은 항상 작동하며 기억하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="fdf01cb06945a582fa2999e094744ca983173e6c" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;:2&lt;/code&gt;&quot; before the comma operates on the first dimension and the &quot;&lt;code&gt;0:3:2&lt;/code&gt;&quot; after the comma operates on the second dimension.</source>
          <target state="translated">쉼표 앞의 &quot; &lt;code&gt;:2&lt;/code&gt; &quot;는 첫 번째 차원에서 작동하고 쉼표 뒤의 &quot; &lt;code&gt;0:3:2&lt;/code&gt; &quot;는 두 번째 차원에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="671738aa3584c456b592e354d91684dcd323f399" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#strings&quot;&gt;Python tutorial&lt;/a&gt; talks about it (scroll down a bit until you get to the part about slicing).</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#strings&quot;&gt;파이썬 튜토리얼&lt;/a&gt; 은 그것에 대해 이야기합니다 (슬라이스에 대해 배울 때까지 조금 아래로 스크롤하십시오).</target>
        </trans-unit>
        <trans-unit id="fb121e6f32b2ed82d98fe529053634abd387ad84" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;colon&lt;/strong&gt;, &lt;code&gt;:&lt;/code&gt;,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is</source>
          <target state="translated">&lt;strong&gt;콜론 (:)&lt;/strong&gt; 은 파이썬에게 일반 인덱스가 아니라 슬라이스를 제공한다는 것을 알려주는 것입니다. 그렇기 때문에 파이썬 2에서 목록의 얕은 사본을 만드는 관용적 인 방법은</target>
        </trans-unit>
        <trans-unit id="064ca1037f07ebe70ccb6e0e4303cf9c8fd960d8" translate="yes" xml:space="preserve">
          <source>The ASCII art diagram is helpful too for remembering how slices work:</source>
          <target state="translated">ASCII 아트 다이어그램은 슬라이스의 작동 방식을 기억하는 데에도 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c2a53ea7c27bc274090377248543665760dc2d23" translate="yes" xml:space="preserve">
          <source>The above part explains the core features on how slice works, and it will work on most occasions. However, there can be pitfalls you should watch out, and this part explains them.</source>
          <target state="translated">위의 부분은 슬라이스 작동 방식의 핵심 기능을 설명하며 대부분의 경우 작동합니다. 그러나 조심해야 할 함정이있을 수 있으며이 부분에서이를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9a0d878051d5575a2cc4db1865d8619aa0945996" translate="yes" xml:space="preserve">
          <source>The answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art:</source>
          <target state="translated">위의 답변은 슬라이스 할당에 대해 설명하지 않습니다. 슬라이스 할당을 이해하려면 ASCII 아트에 다른 개념을 추가하면 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="4827bfb62b55032ff3bc19f8d7461338d02ba84c" translate="yes" xml:space="preserve">
          <source>The basic slicing technique is to define the starting point, the stopping point, and the step size - also known as stride.</source>
          <target state="translated">기본 슬라이싱 기술은 시작점, 중지 점 및 단계 크기 (보폭이라고도 함)를 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7afa04f193c1a31833d08e539febf8032a61d69d" translate="yes" xml:space="preserve">
          <source>The below is the example of an index of a string:</source>
          <target state="translated">아래는 문자열 색인의 예입니다.</target>
        </trans-unit>
        <trans-unit id="a6fdc6b5102e017e74aa1ebfa120ec1728976bd7" translate="yes" xml:space="preserve">
          <source>The best way to illustrate what slicing does internally is just show it in code that implements this operation:</source>
          <target state="translated">슬라이싱이 내부에서 수행하는 작업을 설명하는 가장 좋은 방법은이 작업을 구현하는 코드에 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b289ec304478ab3aa8206822ac93132cd9189a0" translate="yes" xml:space="preserve">
          <source>The extended indexing syntax used for slicing is &lt;code&gt;aList[start:stop:step]&lt;/code&gt;, and basic examples are:</source>
          <target state="translated">슬라이싱에 사용되는 확장 인덱싱 구문은 &lt;code&gt;aList[start:stop:step]&lt;/code&gt; 이며 기본 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="835f8ab3b0337722c0f132a2e78a9079b59cded7" translate="yes" xml:space="preserve">
          <source>The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy.</source>
          <target state="translated">목록 조각이 복사본을 만든다는 사실은 목록 자체의 기능입니다. Pandas DataFrame과 같은 고급 개체를 슬라이스하는 경우 복사본이 아니라 원본에서보기를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41c12238b9c9bbcd33df30b54dc049e7a8a037bb" translate="yes" xml:space="preserve">
          <source>The first rule of slice assignment is that since slicing &lt;em&gt;returns&lt;/em&gt; a list, slice assignment &lt;em&gt;requires&lt;/em&gt; a list (or other iterable):</source>
          <target state="translated">슬라이스 할당의 첫 번째 규칙은 슬라이싱이 목록을 &lt;em&gt;반환&lt;/em&gt; 하므로 슬라이스 할당 &lt;em&gt;에는&lt;/em&gt; 목록 (또는 다른 반복 가능)이 &lt;em&gt;필요하다는&lt;/em&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="053d4b345613c9e63af290ea87904c13976fb020" translate="yes" xml:space="preserve">
          <source>The full notation is</source>
          <target state="translated">전체 표기법은</target>
        </trans-unit>
        <trans-unit id="a279c32eedbdb41ca0663a3f3c7caa14aacb8d48" translate="yes" xml:space="preserve">
          <source>The interesting thing is that you can replace multiple boxes at once. Also you can place multiple boxes wherever you like.</source>
          <target state="translated">흥미로운 점은 여러 상자를 한 번에 교체 할 수 있다는 것입니다. 또한 원하는 곳에 여러 상자를 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbafdf992eb9b0ec11721982bbb3effe97d12b16" translate="yes" xml:space="preserve">
          <source>The key point to remember is that the &lt;code&gt;:stop&lt;/code&gt; value represents the first value that is &lt;em&gt;not&lt;/em&gt; in the selected slice. So, the difference between &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; is the number of elements selected (if &lt;code&gt;step&lt;/code&gt; is 1, the default).</source>
          <target state="translated">기억해야 할 핵심 사항은 &lt;code&gt;:stop&lt;/code&gt; 값이 선택한 슬라이스에 &lt;em&gt;없는&lt;/em&gt; 첫 번째 값을 나타냅니다. 따라서 &lt;code&gt;stop&lt;/code&gt; 와 &lt;code&gt;start&lt;/code&gt; 의 차이는 선택한 요소 수입니다 ( &lt;code&gt;step&lt;/code&gt; 가 1 인 경우 기본값).</target>
        </trans-unit>
        <trans-unit id="75586a32a01b71ebd61830c9004e1d99bb7e7f3c" translate="yes" xml:space="preserve">
          <source>The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use:</source>
          <target state="translated">표기법은 (numpy) 행렬 및 다차원 배열로 확장됩니다. 예를 들어 전체 열을 슬라이스하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="517bdfc38c62e4ed8dbc0ebe6233fdd418806066" translate="yes" xml:space="preserve">
          <source>The other feature is that &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; may be a &lt;em&gt;negative&lt;/em&gt; number, which means it counts from the end of the array instead of the beginning. So:</source>
          <target state="translated">다른 기능은 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;stop&lt;/code&gt; 가 &lt;em&gt;음수&lt;/em&gt; 일 수 있다는 것입니다. 이는 시작이 아니라 배열의 끝에서 계산됩니다. 그래서:</target>
        </trans-unit>
        <trans-unit id="88cb13542cd6c22a7ed79eaff2dca42af648aa1a" translate="yes" xml:space="preserve">
          <source>The previous answers don't discuss multi-dimensional array slicing which is possible using the famous &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; package:</source>
          <target state="translated">이전 답변에서는 유명한 &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; 패키지를 사용하여 다차원 배열 슬라이싱에 대해 설명하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bcb48bc85f26256a3ee0c0f6a3e5b4429c47ae72" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;None&lt;/code&gt;, is required, so that the first argument is interpreted as the &lt;code&gt;start&lt;/code&gt; argument &lt;a href=&quot;https://docs.python.org/2/library/functions.html#slice&quot;&gt;otherwise it would be the &lt;code&gt;stop&lt;/code&gt; argument&lt;/a&gt;.</source>
          <target state="translated">두 번째 인수 인 &lt;code&gt;None&lt;/code&gt; 은 필수이므로 첫 번째 인수는 &lt;code&gt;start&lt;/code&gt; 인수로 해석됩니다. &lt;a href=&quot;https://docs.python.org/2/library/functions.html#slice&quot;&gt;그렇지 않으면 &lt;code&gt;stop&lt;/code&gt; 인수가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="596e5324916e7331fb73503433bce1ac5233475a" translate="yes" xml:space="preserve">
          <source>The second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment:</source>
          <target state="translated">위에서 볼 수있는 슬라이스 할당의 두 번째 규칙은 슬라이스 인덱싱으로 목록의 모든 부분이 반환된다는 것입니다. 슬라이스 할당에 의해 변경된 부분과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e952b134f12b0ea29603efb0b559bc9cc9ad704f" translate="yes" xml:space="preserve">
          <source>The slicing operator &lt;code&gt;[]&lt;/code&gt; is actually being used in the above code with a &lt;code&gt;slice()&lt;/code&gt; object using the &lt;code&gt;:&lt;/code&gt; notation (which is only valid within &lt;code&gt;[]&lt;/code&gt;), i.e.:</source>
          <target state="translated">슬라이싱 연산자 &lt;code&gt;[]&lt;/code&gt; 는 실제로 위의 코드에서 다음과 같이 &lt;code&gt;slice()&lt;/code&gt; 객체와 함께 사용됩니다 &lt;code&gt;:&lt;/code&gt; [ notation ( &lt;code&gt;[]&lt;/code&gt; 내에서만 유효)) :</target>
        </trans-unit>
        <trans-unit id="e691224537259b930d7e6fe4624c31eea62f2d85" translate="yes" xml:space="preserve">
          <source>The thing to remember about negative step is that &lt;code&gt;stop&lt;/code&gt; is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. &lt;code&gt;'abcde'[1:-2][::-1]&lt;/code&gt; slices off one char from left, two from right, then reverses. (See also &lt;a href=&quot;http://www.python.org/dev/peps/pep-0322/&quot;&gt;&lt;code&gt;reversed()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">부정적인 단계에 대해 기억해야 할 것은 그 &lt;code&gt;stop&lt;/code&gt; 가 더 높거나 낮든 항상 배제 끝이라는 것입니다. 동일한 슬라이스를 반대 순서로 원한다면 반전을 별도로 수행하는 것이 훨씬 더 깔끔합니다. ( &lt;a href=&quot;http://www.python.org/dev/peps/pep-0322/&quot;&gt; &lt;code&gt;reversed()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="77887242adef23e77fb02d89d877a784f02e2b36" translate="yes" xml:space="preserve">
          <source>The third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned:</source>
          <target state="translated">슬라이스 할당의 세 번째 규칙은 할당 된 목록 (반복 가능)의 길이가 동일하지 않아도된다는 것입니다. 인덱싱 된 슬라이스는 단순히 슬라이스되고 할당 된 모든 항목으로 일괄 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="29855a6656d9eb287192ae5bff65ab56fdd630e5" translate="yes" xml:space="preserve">
          <source>The trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around &lt;em&gt;indexing&lt;/em&gt; an empty slice:</source>
          <target state="translated">가장 까다로운 부분은 빈 조각에 할당하는 것입니다. 휴리스틱 1과 2를 사용하면 빈 조각을 &lt;em&gt;색인화&lt;/em&gt; 하는 것이 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="4443911b7fa6e0ec19af60b9f6f8c54543309dbe" translate="yes" xml:space="preserve">
          <source>The very first thing that confuses Python learners is that &lt;strong&gt;an index can be negative!&lt;/strong&gt;
Don't panic: &lt;strong&gt;a negative index means count backwards.&lt;/strong&gt;</source>
          <target state="translated">파이썬 학습자들을 혼란스럽게하는 첫 번째 것은 &lt;strong&gt;인덱스가 음수&lt;/strong&gt; 일 수 있다는 것입니다 &lt;strong&gt;!&lt;/strong&gt; 당황하지 마십시오. &lt;strong&gt;음수 인덱스는 거꾸로 세는 것을 의미합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc233fdd4b1aa1d0eec08f781b67af8b6d1de6f5" translate="yes" xml:space="preserve">
          <source>Then the negative indexing just needs you to add the length of the string to the negative indices to understand it.</source>
          <target state="translated">그런 다음 음수 인덱싱에서는 문자열 길이를 음수 인덱스에 추가하여 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="849becd57d4d9dfce3e88751e6e091a0dece7725" translate="yes" xml:space="preserve">
          <source>Then, we may need to apply the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; - the default then for &lt;code&gt;start&lt;/code&gt; is calculated as the upper bound when &lt;code&gt;step&lt;/code&gt; is negative:</source>
          <target state="translated">그런 다음 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 기본값을 적용해야 할 수도 있습니다. 시작에 대한 기본값은 &lt;code&gt;step&lt;/code&gt; 가 음수 일 때 상한으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="b7d7ff65eee8f921208cc372c6ebb7dfee9bb661" translate="yes" xml:space="preserve">
          <source>There are some weird consequences to the &quot;once you're done, you're done&quot; rule:</source>
          <target state="translated">&quot;한 번 완료하면 완료&quot;규칙에 이상한 결과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9a00425fdfcba9c3b6367238a922973214a9b04" translate="yes" xml:space="preserve">
          <source>There is also the &lt;code&gt;step&lt;/code&gt; value, which can be used with any of the above:</source>
          <target state="translated">위의 값 중 하나와 함께 사용할 수있는 &lt;code&gt;step&lt;/code&gt; 값도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8748ae39a14aa6c556cf400a604d76f7a5986f03" translate="yes" xml:space="preserve">
          <source>This can come in handy sometimes, but it can also lead to somewhat strange behavior:</source>
          <target state="translated">때로는 유용 할 수 있지만 다소 이상한 동작이 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="096585dfd11ee121086fdfe39adc2486eb298a85" translate="yes" xml:space="preserve">
          <source>This function takes a Python object and optional parameters for slicing and returns the start, stop, step, and slice length for the requested slice.</source>
          <target state="translated">이 함수는 슬라이싱을 위해 Python 객체와 선택적 매개 변수를 사용하여 요청 된 슬라이스의 시작, 중지, 단계 및 슬라이스 길이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c019865eaefe89398d12a470966b9e731ebcceb" translate="yes" xml:space="preserve">
          <source>This is how I teach slices to newbies:</source>
          <target state="translated">이것이 초보자에게 조각을 가르치는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="93ec6623e85643a7f24c84166f00188e862c3121" translate="yes" xml:space="preserve">
          <source>This is just for some extra info...
Consider the list below</source>
          <target state="translated">이것은 약간의 추가 정보입니다 ... 아래 목록을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2f3bd8ad9ced207179166369787553277fa774f3" translate="yes" xml:space="preserve">
          <source>This is the diagram:</source>
          <target state="translated">이것은 다이어그램입니다 :</target>
        </trans-unit>
        <trans-unit id="30363f59507d9db8769972ab941783b864dbd2ab" translate="yes" xml:space="preserve">
          <source>This is the intelligence that is present behind slices. Since Python has an built-in function called slice, you can pass some parameters and check how smartly it calculates missing parameters.</source>
          <target state="translated">이것이 조각 뒤에 존재하는 지능입니다. Python에는 slice라는 내장 함수가 있으므로 일부 매개 변수를 전달하고 누락 된 매개 변수를 얼마나 똑똑하게 계산하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d57f5dd395014f54497c19cddb5a2ce5c7ea7a57" translate="yes" xml:space="preserve">
          <source>This may also clarify the difference between slicing and indexing.</source>
          <target state="translated">또한 슬라이싱과 인덱싱의 차이점을 명확히 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95f0acc0a5d079ab45b81544212226023725e34" translate="yes" xml:space="preserve">
          <source>This pretty property tells me that &lt;code&gt;lst[start:end]&lt;/code&gt; does not contain the &lt;code&gt;end&lt;/code&gt;-th item because it is in &lt;code&gt;lst[end:]&lt;/code&gt;.</source>
          <target state="translated">이 예쁜 속성은 &lt;code&gt;lst[start:end]&lt;/code&gt; 에 &lt;code&gt;lst[end:]&lt;/code&gt; 이므로 lst [start : end] 에 &lt;code&gt;end&lt;/code&gt; - th 항목이 포함되어 있지 않다는 것을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="8007629ae4bd6492e6ac3709a0f6817d52e38741" translate="yes" xml:space="preserve">
          <source>This way, I can think of &lt;code&gt;a[-4:-6:-1]&lt;/code&gt; as &lt;code&gt;a(-6,-4]&lt;/code&gt; in interval terminology.</source>
          <target state="translated">이런 식으로, 나는 간격 용어에서 &lt;code&gt;a[-4:-6:-1]&lt;/code&gt; 을 &lt;code&gt;a(-6,-4]&lt;/code&gt; 로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88160c485e5bf5fb043177dc6d2bf96217e61ab0" translate="yes" xml:space="preserve">
          <source>This works for me anyway...</source>
          <target state="translated">이것은 어쨌든 나를 위해 작동합니다 ...</target>
        </trans-unit>
        <trans-unit id="36a968ddf7619f1775f5b9341d45ab5c6d7d9f33" translate="yes" xml:space="preserve">
          <source>Thus a negative slice will change the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;!</source>
          <target state="translated">따라서 네거티브 슬라이스는 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 의 기본값을 변경합니다!</target>
        </trans-unit>
        <trans-unit id="6c35d5a48cbaacaa30e85a96cdc7b46a6bf157e1" translate="yes" xml:space="preserve">
          <source>Till now you have picked boxes continuously. But sometimes you need to pick up discretely. For example, you can pick up every second box. You can even pick up every third box from the end. This value is called step size. This represents the gap between your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa.</source>
          <target state="translated">지금까지 상자를 계속 골랐습니다. 그러나 때로는 신중하게 픽업해야합니다. 예를 들어, 매 초 상자를 선택할 수 있습니다. 끝에서 세 번째 상자를 모두 선택할 수도 있습니다. 이 값을 단계 크기라고합니다. 이는 연속 픽업 간의 간격을 나타냅니다. 상자를 처음부터 끝까지 선택하거나 그 반대의 경우 단계 크기는 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="31ee61905e41466bdf813b3f8668d410b0e1fa58" translate="yes" xml:space="preserve">
          <source>To begin with, let's define a few terms:</source>
          <target state="translated">우선 몇 가지 용어를 정의 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="2e1c54513da531934e461b5f4aa70c3c39a3e784" translate="yes" xml:space="preserve">
          <source>To make it simple, remember &lt;strong&gt;slice has only one form：&lt;/strong&gt;</source>
          <target state="translated">간단하게하기 위해 &lt;strong&gt;슬라이스는 한 가지 형식 만&lt;/strong&gt; 기억 &lt;strong&gt;합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6133370c4351e43ebcb470ed39b01c2df88aa87a" translate="yes" xml:space="preserve">
          <source>To me, this notation needs a bit of picking up.</source>
          <target state="translated">나 에게이 표기법은 약간의 픽업이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="427ca464e82784a054828caeff41890bcf767d80" translate="yes" xml:space="preserve">
          <source>To retrieve a subset of elements, the start and stop positions need to be defined.</source>
          <target state="translated">요소의 서브 세트를 검색하려면 시작 및 중지 위치를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e7a6a811c35a7adca15b7530f42f47e0dda5845" translate="yes" xml:space="preserve">
          <source>To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;implement the &lt;code&gt;__getitem__&lt;/code&gt; method of the sequence, according to the Python data model&lt;/a&gt;.)</source>
          <target state="translated">슬라이스 표기법을 지원하는 시퀀스와 함께 슬라이스 표기법을 사용하려면 시퀀스 뒤에 오는 대괄호에 콜론을 하나 이상 포함해야합니다 ( &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;파이썬 데이터 모델에 따라 시퀀스의 &lt;code&gt;__getitem__&lt;/code&gt; 메소드&lt;/a&gt; 를 실제로 구현합니다 ).</target>
        </trans-unit>
        <trans-unit id="0e7a206b9021aa8d0ea3e3c6e22e9c2a9fd3b850" translate="yes" xml:space="preserve">
          <source>Understanding index assignment is very important.</source>
          <target state="translated">인덱스 할당을 이해하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="eb8117520c3958acd43c0f8e454eeec3f534d349" translate="yes" xml:space="preserve">
          <source>Understanding slice notation</source>
          <target state="translated">슬라이스 표기법 이해</target>
        </trans-unit>
        <trans-unit id="10c5a38a7a014349bab2658d201f411e1780237b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;step&lt;/code&gt; provides a useful trick to reverse a collection in Python:</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; 사용하면 파이썬에서 컬렉션을 뒤집는 유용한 트릭을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="625b0998df7fa1a8b226d789e201ac2c633e1b85" translate="yes" xml:space="preserve">
          <source>Using a negative step reverses the interpretation of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">음수 단계를 사용하면 &lt;code&gt;start&lt;/code&gt; 과 &lt;code&gt;end&lt;/code&gt; 의 해석이 반대로됩니다.</target>
        </trans-unit>
        <trans-unit id="62654d2560fca6df984a34445f5e3dec93d4d93b" translate="yes" xml:space="preserve">
          <source>What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride.</source>
          <target state="translated">항상 작동하는 것은 문자 또는 슬롯에서 생각하고 인덱싱을 반 열린 간격으로 사용하는 것입니다. 양의 보폭이면 오른쪽 열림, 음의 보폭이면 왼쪽 열림입니다.</target>
        </trans-unit>
        <trans-unit id="526db1adfef28b92b75500e179ee7473e39b4025" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;step&lt;/code&gt; is negative, the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; change</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; 가 음수이면 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 의 기본값이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="2c8d0413ebb06c76b410bc829582598046a90e73" translate="yes" xml:space="preserve">
          <source>When I see this, I read the part in the brackets as &quot;9th from the end, to the end.&quot; (Actually, I abbreviate it mentally as &quot;-9, on&quot;)</source>
          <target state="translated">이것을 보면 괄호 안의 부분을 &quot;끝에서 끝까지 9 번째&quot;라고 읽습니다. (실제로, 나는 그것을 정신적으로 &quot;-9, on&quot;으로 축약합니다)</target>
        </trans-unit>
        <trans-unit id="6847d5ecc89aafb251c20bc69d5137967a12634d" translate="yes" xml:space="preserve">
          <source>When slicing from the start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose:</source>
          <target state="translated">처음부터 슬라이스 할 때는 0 인덱스를 생략하고 끝까지 슬라이스 할 때 중복되므로 최종 인덱스를 생략 할 수 있으므로 자세하게 설명하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0331d52f669a9d089e322197c2a42b467d18a25b" translate="yes" xml:space="preserve">
          <source>When slicing, if you leave out any parameter, Python tries to figure it out automatically.</source>
          <target state="translated">슬라이싱 할 때 매개 변수를 생략하면 Python은 자동으로 파악하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ec05e68a3474403744db580556c5b4b5147a48ab" translate="yes" xml:space="preserve">
          <source>When using a negative step, notice that the answer is shifted to the right by 1.</source>
          <target state="translated">음수 단계를 사용하면 답이 1 씩 오른쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d52f5e951410da3205e348d328fbec3fed74bc94" translate="yes" xml:space="preserve">
          <source>When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range:</source>
          <target state="translated">[a : b : c]라고 말하면 c의 부호 (앞뒤로)에 따라 a에서 시작하여 b에서 끝납니다 (b 번째 인덱스의 요소 제외). 위의 색인 규칙을 사용하면이 범위의 요소 만 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60ffa2bfa59ad91cfa5b5fac46b9f1af335ca27a" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;:&lt;/code&gt;-based notation is very helpful for simple slicing, the explicit use of &lt;code&gt;slice()&lt;/code&gt; objects simplifies the programmatic generation of slicing.</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; 기반 표기법은 간단한 슬라이싱에 매우 유용하지만 &lt;code&gt;slice()&lt;/code&gt; 객체를 명시 적으로 사용하면 프로그래밍 방식으로 슬라이싱을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fac29e5b50e4050ea0c9107b01d2b1be0ad4b52" translate="yes" xml:space="preserve">
          <source>Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.</source>
          <target state="translated">Wiki Python에는 인덱싱과 슬라이싱을 명확히 구분하는 놀라운 그림이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc7857679c446d31b3fa48d4d430634f0052baba" translate="yes" xml:space="preserve">
          <source>With extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon.</source>
          <target state="translated">확장 된 인덱싱 구문을 사용하여 다양한 값을 검색합니다. 예를 들어, 모든 값은 콜론으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="48850a7b49c3ba2cdae5d4c04076f27217921200" translate="yes" xml:space="preserve">
          <source>With slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number.</source>
          <target state="translated">슬라이싱을 사용하면 완료되면 완료됩니다. 뒤로 자르기 시작하지 않습니다. 파이썬에서는 음수를 사용하여 명시 적으로 요청하지 않는 한 음수 보폭을 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="8e6854e86dbd642a89919deb5004ced1375069af" translate="yes" xml:space="preserve">
          <source>X is the index of the first element you want.</source>
          <target state="translated">X는 원하는 첫 번째 요소의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="1caf266993cb78b65a51c14f80f90f52a48c1ad0" translate="yes" xml:space="preserve">
          <source>Y is the index of the first element you &lt;em&gt;don't&lt;/em&gt; want.</source>
          <target state="translated">Y는 원하지 &lt;em&gt;않는&lt;/em&gt; 첫 번째 요소의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="37c763665adfe6c32f74ceb3ab85198ed95e14f3" translate="yes" xml:space="preserve">
          <source>You can also use slice assignment to remove one or more elements from a list:</source>
          <target state="translated">슬라이스 할당을 사용하여 목록에서 하나 이상의 요소를 제거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6537afebf0730bd8d23b3fe9847bf52f1415c3b" translate="yes" xml:space="preserve">
          <source>You can even pick up the first three boxes or the last two boxes or all boxes between 1 and 4. So, you can pick any set of boxes if you know the beginning and ending. These positions are called start and stop positions.</source>
          <target state="translated">처음 세 개의 상자 나 마지막 두 개의 상자 또는 1과 4 사이의 모든 상자를 선택할 수도 있습니다. 따라서 시작과 끝을 알고 있으면 모든 상자 세트를 선택할 수 있습니다. 이러한 위치를 시작 및 중지 위치라고합니다.</target>
        </trans-unit>
        <trans-unit id="c778f916c05737b62b181e6441afcd1a4fe8b894" translate="yes" xml:space="preserve">
          <source>You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;stop&lt;/em&gt;, and for the &lt;em&gt;step&lt;/em&gt;, you simply decrement your index. This example is &lt;a href=&quot;https://docs.python.org/2/tutorial/introduction.html&quot;&gt;from the documentation's tutorial&lt;/a&gt;, but I've modified it slightly to indicate which item in a sequence each index references:</source>
          <target state="translated">이 양수 또는 음수를 만들 수 있습니다. 양수의 의미는 간단하지만 파이썬의 인덱스와 마찬가지로 음수의 경우 &lt;em&gt;start&lt;/em&gt; 및 &lt;em&gt;stop&lt;/em&gt; 끝에서 거꾸로 세고 &lt;em&gt;step의&lt;/em&gt; 경우 단순히 인덱스를 줄입니다. 이 예제는 &lt;a href=&quot;https://docs.python.org/2/tutorial/introduction.html&quot;&gt;문서의 튜토리얼에서 가져온&lt;/a&gt; 것이지만 각 인덱스가 참조하는 시퀀스의 항목을 나타내도록 약간 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="9b7644b509b2bf8e1ff27f855c7f83b37789181c" translate="yes" xml:space="preserve">
          <source>You can run this script and experiment with it, below is some samples that I got from the script.</source>
          <target state="translated">이 스크립트를 실행하고 실험 해 볼 수 있습니다. 아래는 스크립트에서 얻은 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="64faa3902ada5ca110aa668c8de78a324815760c" translate="yes" xml:space="preserve">
          <source>You can then pass the slice object to your sequence:</source>
          <target state="translated">그런 다음 슬라이스 객체를 시퀀스에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="195e61f26a2fef8e34f3db23bd78fcb41bfedb3e" translate="yes" xml:space="preserve">
          <source>You made a cut &lt;strong&gt;before&lt;/strong&gt; the element with index &lt;code&gt;2&lt;/code&gt; and another cut &lt;strong&gt;before&lt;/strong&gt; the element with index &lt;code&gt;5&lt;/code&gt;. So the result will be a slice between those two cuts, a list &lt;code&gt;['T', 'H', 'O']&lt;/code&gt;.</source>
          <target state="translated">색인이 &lt;code&gt;2&lt;/code&gt; 인 요소 &lt;strong&gt;앞에&lt;/strong&gt; 절단 &lt;strong&gt;을&lt;/strong&gt; 하고 색인이 &lt;code&gt;5&lt;/code&gt; 인 요소 &lt;strong&gt;앞에&lt;/strong&gt; 또 다른 절단을 작성했습니다. 결과는 목록 &lt;code&gt;['T', 'H', 'O']&lt;/code&gt; 두 컷 사이의 슬라이스가됩니다.</target>
        </trans-unit>
        <trans-unit id="89d9115fa306118ea0f00933e8378ed5c6878642" translate="yes" xml:space="preserve">
          <source>You may find it useful to separate forming the slice from passing it to the &lt;code&gt;list.__getitem__&lt;/code&gt; method (&lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;that's what the square brackets do&lt;/a&gt;). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing.</source>
          <target state="translated">슬라이스를 형성하는 것을 &lt;code&gt;list.__getitem__&lt;/code&gt; 메소드로 전달하는 것을 분리하는 것이 유용 할 수 있습니다 ( &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;대괄호가하는 일&lt;/a&gt; ). 새로운 것이 아니더라도 코드를 더 읽기 쉽게 유지하여 코드를 읽어야하는 다른 사람들이 자신이하는 일을 더 쉽게 이해할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="8e3e016f8f3879b55e19d0fb4c4a1a15482a3faa" translate="yes" xml:space="preserve">
          <source>a b &lt;strong&gt;[&lt;/strong&gt; c d e f g h &lt;strong&gt;]&lt;/strong&gt; i j</source>
          <target state="translated">ab &lt;strong&gt;[&lt;/strong&gt; cdefgh &lt;strong&gt;]&lt;/strong&gt; ij</target>
        </trans-unit>
        <trans-unit id="a604aec6cdc49c95cd2d0c53292ad902a479d32d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;stop&lt;/code&gt;, the lower bound:</source>
          <target state="translated">하한 :</target>
        </trans-unit>
        <trans-unit id="631cab8239639a1208a15258a7f7aeda4d018888" translate="yes" xml:space="preserve">
          <source>and here is how it works:</source>
          <target state="translated">작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">그리고 지금:</target>
        </trans-unit>
        <trans-unit id="ce39fead1872adb72fba2b688bc7e4b8311fc7f4" translate="yes" xml:space="preserve">
          <source>and to substitute the defaults (actually when &lt;code&gt;step&lt;/code&gt; is negative, &lt;code&gt;stop&lt;/code&gt;'s default is &lt;code&gt;-len(my_list) - 1&lt;/code&gt;, so &lt;code&gt;None&lt;/code&gt; for stop really just means it goes to whichever end step takes it to):</source>
          <target state="translated">기본값을 대체하려면 (실제로 &lt;code&gt;step&lt;/code&gt; 이 음수 일 때 &lt;code&gt;stop&lt;/code&gt; 의 기본값은 &lt;code&gt;-len(my_list) - 1&lt;/code&gt; 이므로 stop에 대한 &lt;code&gt;None&lt;/code&gt; 은 실제로 어떤 마지막 단계로 진행되는지를 의미합니다) :</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1110fd3a6c30458a698644d555d607d113a08279" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9adbb8529fa7bf42a21e2483f8aa574d755b96e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;l&lt;/code&gt; is a collection, &lt;code&gt;start&lt;/code&gt; is an inclusive index, &lt;code&gt;end&lt;/code&gt; is an exclusive index, and &lt;code&gt;step&lt;/code&gt; is a stride that can be used to take every &lt;em&gt;nth&lt;/em&gt; item in &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;l&lt;/code&gt; 은 콜렉션이고 &lt;code&gt;start&lt;/code&gt; 는 포괄적 인 인덱스이고 &lt;code&gt;end&lt;/code&gt; 는 독점적 인 인덱스이며 &lt;code&gt;step&lt;/code&gt; 은 &lt;code&gt;l&lt;/code&gt; 의 모든 &lt;em&gt;n 번째&lt;/em&gt; 항목을 가져 오는 데 사용할 수있는 보폭입니다.</target>
        </trans-unit>
        <trans-unit id="1b8a81384b7443c9cbeaad37bd4704f2d8b3165a" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;l&lt;/code&gt; is some collection, &lt;code&gt;start&lt;/code&gt; is an inclusive index, and &lt;code&gt;end&lt;/code&gt; is an exclusive index.</source>
          <target state="translated">여기서 &lt;code&gt;l&lt;/code&gt; 은 일부 콜렉션이고 &lt;code&gt;start&lt;/code&gt; 는 포괄적 색인이고 &lt;code&gt;end&lt;/code&gt; 는 독점 색인입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
