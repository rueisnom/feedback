<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/509211">
    <body>
      <group id="509211">
        <trans-unit id="0aaf66473b71c5d42becc13d72b6f4ed70fedde3" translate="yes" xml:space="preserve">
          <source>(Python 3 gets a &lt;code&gt;list.copy&lt;/code&gt; and &lt;code&gt;list.clear&lt;/code&gt; method.)</source>
          <target state="translated">（Python 3は &lt;code&gt;list.copy&lt;/code&gt; および &lt;code&gt;list.clear&lt;/code&gt; メソッドを取得します。）</target>
        </trans-unit>
        <trans-unit id="95d6f5f0e5758c7fa9092f862da9a2259661dfd4" translate="yes" xml:space="preserve">
          <source>1. Slice Notation</source>
          <target state="translated">1.スライス表記</target>
        </trans-unit>
        <trans-unit id="0f38c5a54db99d84e876f9b5eaa8720b9f3a9a26" translate="yes" xml:space="preserve">
          <source>2. Pitfalls</source>
          <target state="translated">2.落とし穴</target>
        </trans-unit>
        <trans-unit id="8862228b2902925878e3e9b09c1707ac7de719af" translate="yes" xml:space="preserve">
          <source>3. Examples</source>
          <target state="translated">3.例としては</target>
        </trans-unit>
        <trans-unit id="a3d3ca439ad803f892271df58e7d3c810355f6fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;end&lt;/code&gt;: last index, &lt;strong&gt;NOTE that &lt;code&gt;end&lt;/code&gt; index will not be included in the resulted slice&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; ：最後のインデックス、 &lt;strong&gt; &lt;code&gt;end&lt;/code&gt; インデックスは結果のスライスに含まれないこと&lt;/strong&gt;に&lt;strong&gt;注意してください&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6643606539da7a52988dc6cf4ceeadabfd2aeb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: an object that can be sliced</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; ：スライスできるオブジェクト</target>
        </trans-unit>
        <trans-unit id="1b4c4192b9f7af406c63bd0fcecb821e5c7cd6f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt;: first index to start iteration</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; ：反復を開始する最初のインデックス</target>
        </trans-unit>
        <trans-unit id="f694d4d7856a4daa5fcd72c6329bb35f7a4a3b91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt;: pick element every &lt;code&gt;step&lt;/code&gt; index</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; ： &lt;code&gt;step&lt;/code&gt; インデックスごとに要素を選択</target>
        </trans-unit>
        <trans-unit id="31b0888c10f4ec32c43b2a524281bf1bc1307538" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A negative step means iterate the array backwards: from the end to start, with the end index included, and the start index excluded from the result.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;負のステップは、配列を逆方向に反復することを意味します：終了インデックスを含めて、終了インデックスを含め、開始インデックスを結果から除外します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dd769027176645af5d46752c43bf60e2cbab996" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basic Slicing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;基本的なスライス&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03764b700c4114b7c7e0b1fc151ca8ee76b98522" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Python Figures Out Missing Parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pythonが欠落しているパラメーターを計算する方法：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a8df44af93130aa47cf7708478946a1e899c9b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: when step is negative, the default value for &lt;code&gt;start&lt;/code&gt; is &lt;code&gt;len(s)&lt;/code&gt; (while &lt;code&gt;end&lt;/code&gt; does not equal to &lt;code&gt;0&lt;/code&gt;, because &lt;code&gt;s[::-1]&lt;/code&gt; contains &lt;code&gt;s[0]&lt;/code&gt;). For example:</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt; ：stepが負の場合、 &lt;code&gt;start&lt;/code&gt; のデフォルト値は &lt;code&gt;len(s)&lt;/code&gt; です （ &lt;code&gt;s[::-1]&lt;/code&gt; は &lt;code&gt;s[0]&lt;/code&gt; が含まれているため、 &lt;code&gt;end&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt; ではありません）。 例えば：</target>
        </trans-unit>
        <trans-unit id="a040621624a5c253662c247800c0317b88fdc6d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This post was originally written in my blog, &lt;em&gt;&lt;a href=&quot;https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html&quot;&gt;The Intelligence Behind Python Slices&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;この投稿は、もともと私のブログ、 &lt;em&gt;&lt;a href=&quot;https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html&quot;&gt;Python Behind Python Slicesで&lt;/a&gt;&lt;/em&gt;書かれていました。</target>
        </trans-unit>
        <trans-unit id="dd2468b43f8b0b0ef298ce86ccd65ed0c9f49ef9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Slicing With Step:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ステップによるスライス：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fe67ddb4f6798a243fbf3c1c781e47c402b956c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Slicing can also be applied to multi-dimensional arrays.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;スライスは、多次元配列にも適用できます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54689a39c2f4af595b96d8fcee877e522e69fc2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TODO&lt;/strong&gt;: The code below had a bug with &quot;never go outside the sequence&quot; when abs(step)&amp;gt;1; I &lt;em&gt;think&lt;/em&gt; I patched it to be correct, but it's hard to understand.</source>
          <target state="translated">&lt;strong&gt;TODO&lt;/strong&gt; ：以下のコードには、abs（step）&amp;gt; 1のときに「シーケンスの外に出ない」というバグがありました。 パッチを当てて正しい&lt;em&gt;と思い&lt;/em&gt;ますが、わかりにくいです。</target>
        </trans-unit>
        <trans-unit id="120f2d378e6907d447c90878b70cfec95cfa80ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Understanding the difference between indexing and slicing:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;インデックス作成とスライスの違いを理解する：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c3618c39203bd4928667eb7837893a51d2c72ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;start:&lt;/strong&gt; the beginning index of the slice, it will include the element at this index unless it is the same as &lt;em&gt;stop&lt;/em&gt;, defaults to 0, i.e. the first index. If it's negative, it means to start &lt;code&gt;n&lt;/code&gt; items from the end.</source>
          <target state="translated">&lt;strong&gt;start：&lt;/strong&gt;スライスの開始インデックス。stopと同じでない限り、このインデックスの要素が含まれ&lt;em&gt;ます&lt;/em&gt; 。デフォルトは0、つまり最初のインデックスです。 負の数の場合、最後から &lt;code&gt;n&lt;/code&gt; 個の項目を開始することを意味します。</target>
        </trans-unit>
        <trans-unit id="3b0828277ef33d65b168b24d8f7acb52b6e97797" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;step:&lt;/strong&gt; the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse.</source>
          <target state="translated">&lt;strong&gt;ステップ：&lt;/strong&gt;インデックスが増加する量。デフォルトは1です。負の場合は、イテラブルを逆方向​​にスライスします。</target>
        </trans-unit>
        <trans-unit id="f4d542aea390972989442b2f47543ac47e2b208f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stop:&lt;/strong&gt; the ending index of the slice, it does &lt;em&gt;not&lt;/em&gt; include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.</source>
          <target state="translated">&lt;strong&gt;stop：&lt;/strong&gt;スライスの終了インデックス。このインデックスにある要素&lt;em&gt;は&lt;/em&gt;含まれませ&lt;em&gt;ん&lt;/em&gt; 。デフォルトでは、スライスされるシーケンスの長さ、つまり最後まで含まれます。</target>
        </trans-unit>
        <trans-unit id="227dd9dbc0108dfd4661edff64d2fe881992bffb" translate="yes" xml:space="preserve">
          <source>After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a &lt;code&gt;for&lt;/code&gt; loop...</source>
          <target state="translated">少し使ってみると、最も簡単な説明は、 &lt;code&gt;for&lt;/code&gt; ループの引数とまったく同じであることがわかります...</target>
        </trans-unit>
        <trans-unit id="ee7829458bdd9d9fb9e4d5d3a2fb33291ce2cf6c" translate="yes" xml:space="preserve">
          <source>Also, note that negative values for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are relative to the end of the list and computed in the example above by &lt;code&gt;given_index + a.shape[0]&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;end&lt;/code&gt; の負の値はリストの最後を基準とし、上記の例では &lt;code&gt;given_index + a.shape[0]&lt;/code&gt; によって計算されることに注意してください 。</target>
        </trans-unit>
        <trans-unit id="70a021868ab3df3f88ae6899b164851777cd1b14" translate="yes" xml:space="preserve">
          <source>And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:</source>
          <target state="translated">最初にスライシングの構文を見たときにはすぐにはわからなかったことがいくつかありました。</target>
        </trans-unit>
        <trans-unit id="d105f3bd854548cc6f0bd3800349d324c615cb05" translate="yes" xml:space="preserve">
          <source>And clearing them is with:</source>
          <target state="translated">そして、それらをクリアすることは、一緒です。</target>
        </trans-unit>
        <trans-unit id="d25005772475e3ef4f540f81cb570f204b58a0d9" translate="yes" xml:space="preserve">
          <source>And if you wanted, for some reason, every second item in the reversed sequence:</source>
          <target state="translated">欲を言えば、なぜか2番目の項目が全て逆順になっている</target>
        </trans-unit>
        <trans-unit id="77bb433c739e5798f1c99c633d2b911edd356fc6" translate="yes" xml:space="preserve">
          <source>And recall that there are defaults for &lt;em&gt;start&lt;/em&gt;, &lt;em&gt;stop&lt;/em&gt;, and &lt;em&gt;step&lt;/em&gt;, so to access the defaults, simply leave out the argument.</source>
          <target state="translated">また、 &lt;em&gt;start&lt;/em&gt; 、 &lt;em&gt;stop&lt;/em&gt; 、 &lt;em&gt;step&lt;/em&gt;にはデフォルトがあることを思い出してください。デフォルトにアクセスするには、引数を省略します。</target>
        </trans-unit>
        <trans-unit id="8d114526a29d613405e6408309b436a186ca0d52" translate="yes" xml:space="preserve">
          <source>And then once you've seen that, slice assignment to the empty slice makes sense too:</source>
          <target state="translated">それがわかった上で空のスライスへのスライス割り当ても意味があるんだよ</target>
        </trans-unit>
        <trans-unit id="5de2b62e17f6a84350d6fbe4ce6b42edec436e54" translate="yes" xml:space="preserve">
          <source>Another heuristic is, &quot;for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning&quot;</source>
          <target state="translated">もう一つのヒューリスティックな方法は、&quot;任意のスライスのために、ゼロで開始を置き換え、リストの最後を取得するには、前のヒューリスティックな方法を適用して、最初の数をカウントして戻って最初からアイテムを切り刻む &quot;です。</target>
        </trans-unit>
        <trans-unit id="faa6734c0c057ce07a0df52181d494e9f022c4d5" translate="yes" xml:space="preserve">
          <source>Another import thing: &lt;strong&gt;all &lt;code&gt;start&lt;/code&gt;,&lt;code&gt;end&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt; can be omitted!&lt;/strong&gt; And if they are omitted, their default value will be used: &lt;code&gt;0&lt;/code&gt;,&lt;code&gt;len(s)&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt; accordingly.</source>
          <target state="translated">別のインポート： &lt;strong&gt;すべての &lt;code&gt;start&lt;/code&gt; 、 &lt;code&gt;end&lt;/code&gt; 、 &lt;code&gt;step&lt;/code&gt; は省略できます！&lt;/strong&gt; そして、それらが省略された場合、それらのデフォルト値が使用されます： &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;len(s)&lt;/code&gt; 、それに応じて &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7af9ada0982e5ec6222baca6341c1c5cff1f46c9" translate="yes" xml:space="preserve">
          <source>Any of them are optional:</source>
          <target state="translated">いずれも任意です。</target>
        </trans-unit>
        <trans-unit id="9e68e1c90bdbb11b1d0236fe65983d5f0f2685f0" translate="yes" xml:space="preserve">
          <source>As a general rule, writing code with a lot of hardcoded index values leads to a readability
and maintenance mess. For example, if you come back to the code a year later, you&amp;rsquo;ll
look at it and wonder what you were thinking when you wrote it. The solution shown
is simply a way of more clearly stating what your code is actually doing.
In general, the built-in slice() creates a slice object that can be used anywhere a slice
is allowed. For example:</source>
          <target state="translated">原則として、ハードコードされたインデックス値を多く含むコードを記述すると、読みやすさとメンテナンスの面倒が発生します。 たとえば、1年後にコードに戻ると、コードを見て、それを書いたときに何を考えていたのか不思議に思うでしょう。 示されている解決策は、コードが実際に何をしているのかをより明確に示す方法にすぎません。 一般に、組み込みのslice（）は、スライスが許可されている任意の場所で使用できるスライスオブジェクトを作成します。 例えば：</target>
        </trans-unit>
        <trans-unit id="a5d1179754e1ec07fb3a1e15a9fe95c4e93756e2" translate="yes" xml:space="preserve">
          <source>As you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element.</source>
          <target state="translated">ご覧のように、stopだけを定義すると1つの要素を返します。startのデフォルトはnoneなので、これは1つの要素のみを取得することになります。</target>
        </trans-unit>
        <trans-unit id="10ddbc6f0ff07831197cae7c89a5e4feb5e47439" translate="yes" xml:space="preserve">
          <source>Backing up a little bit, what happens when you keep going with our procession of counting up the slice beginning?</source>
          <target state="translated">少し話を戻して、スライスの始まりをカウントアップする我々の行列を続けるとどうなりますか?</target>
        </trans-unit>
        <trans-unit id="a0a44e8c2753c157919dea94666ab53b99900c6e" translate="yes" xml:space="preserve">
          <source>Be surprised: &lt;strong&gt;slice does not raise an IndexError when the index is out of range!&lt;/strong&gt;</source>
          <target state="translated">驚いてください： &lt;strong&gt;インデックスが範囲外の場合、スライスはIndexErrorを発生させません！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51688e4ac0a45d12d7f9bb788db79cb941448aea" translate="yes" xml:space="preserve">
          <source>Begin from &lt;code&gt;start&lt;/code&gt;, increment by &lt;code&gt;step&lt;/code&gt;, do not reach &lt;code&gt;stop&lt;/code&gt;.  Very simple.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; から開始し 、 &lt;code&gt;step&lt;/code&gt; に増加し、 &lt;code&gt;stop&lt;/code&gt; 到達しません。 とても簡単です。</target>
        </trans-unit>
        <trans-unit id="4b2092c15e09d1d0a69d863b94fdb3e35c63e659" translate="yes" xml:space="preserve">
          <source>Below is the example usage:</source>
          <target state="translated">以下に使用例を示します。</target>
        </trans-unit>
        <trans-unit id="2b5c42838b863b4b8a4537944505370085a2f395" translate="yes" xml:space="preserve">
          <source>Below is the text of my original answer. It has been useful to many people, so I didn't want to delete it.</source>
          <target state="translated">以下、私が元々回答していた文章です。多くの方の参考になったので、削除しないようにしました。</target>
        </trans-unit>
        <trans-unit id="c47e4145f6e8d534763f4eeb46a2b86362f0690b" translate="yes" xml:space="preserve">
          <source>Besides basic slicing, it is also possible to apply the following notation:</source>
          <target state="translated">基本的なスライシングの他に、以下のような表記を適用することも可能です。</target>
        </trans-unit>
        <trans-unit id="0b189ce87053a4a6f9151c04b8051585e6e4e7ff" translate="yes" xml:space="preserve">
          <source>Blank values are defaulted as follows: &lt;code&gt;[+0:-0:1]&lt;/code&gt;.</source>
          <target state="translated">空白の値のデフォルトは次のとおりです： &lt;code&gt;[+0:-0:1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ab9f5780bbd8ad36625e87ca02af9b8bf9361df" translate="yes" xml:space="preserve">
          <source>But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the &lt;code&gt;end&lt;/code&gt;-th element.</source>
          <target state="translated">しかし、時折疑念が忍び寄り、私の脳はそれが &lt;code&gt;end&lt;/code&gt; 要素を含んでいないという安心を求めます。</target>
        </trans-unit>
        <trans-unit id="25e3d76337cea9e9d631c334c54bbcb275c06f0f" translate="yes" xml:space="preserve">
          <source>But this range continues in both directions infinitely:</source>
          <target state="translated">しかし、この範囲は両方向に無限に続きます。</target>
        </trans-unit>
        <trans-unit id="313813cd850a6b775a1fb26d3d9c84054d7263b9" translate="yes" xml:space="preserve">
          <source>But you can pass in a negative integer, and the list (or most other standard slicables) will be sliced from the end to the beginning.</source>
          <target state="translated">しかし、負の整数を渡すことができ、リスト(または他のほとんどの標準的なスライカブル)は最後から最初にスライスされます。</target>
        </trans-unit>
        <trans-unit id="78c9a2985c6c2db62af25652b536f68dff04e931" translate="yes" xml:space="preserve">
          <source>By default, when the &lt;code&gt;step&lt;/code&gt; argument is empty (or &lt;code&gt;None&lt;/code&gt;), it is assigned to &lt;code&gt;+1&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;step&lt;/code&gt; 引数が空（または &lt;code&gt;None&lt;/code&gt; ）の場合、 &lt;code&gt;+1&lt;/code&gt; が割り当てられます。</target>
        </trans-unit>
        <trans-unit id="74e101616da42c9f860f041e06e88cf3afc9af8d" translate="yes" xml:space="preserve">
          <source>Coming from other programming languages, that's when the common sense gets compromised. What are x and y?</source>
          <target state="translated">他のプログラミング言語から来た場合、それは常識が損なわれる時です。x と y とは何か?</target>
        </trans-unit>
        <trans-unit id="114f22f6d7079d292a7e78398094c20f332e1368" translate="yes" xml:space="preserve">
          <source>Confirming this in the source</source>
          <target state="translated">ソースで確認</target>
        </trans-unit>
        <trans-unit id="3eb94acf98e91b224000fb69a7e7764bf5d24a8e" translate="yes" xml:space="preserve">
          <source>Create two lists to slice. The first is a numeric list from 1 to 9 (List A). The second is also a numeric list, from 0 to 9 (List B):</source>
          <target state="translated">スライスするリストを2つ作成します。1つ目は1から9までの数値リストです (リストA)。2 番目は、0 から 9 までの数値リストです (リスト B)。</target>
        </trans-unit>
        <trans-unit id="57856d05bb32d5be32788eb0692ff1468ddf3c07" translate="yes" xml:space="preserve">
          <source>Depending on your application, that might... or might not... be what you were hoping for there!</source>
          <target state="translated">あなたのアプリケーションによっては、それは...あなたが望んでいたものではないかもしれません!</target>
        </trans-unit>
        <trans-unit id="20f3af310b2b47de75d12e36f7756694568aec42" translate="yes" xml:space="preserve">
          <source>Don't worry about the &lt;code&gt;is None&lt;/code&gt; details - just remember that omitting &lt;code&gt;start&lt;/code&gt; and/or &lt;code&gt;stop&lt;/code&gt; always does the right thing to give you the whole sequence.</source>
          <target state="translated">&lt;code&gt;is None&lt;/code&gt; の詳細については心配しないでください。 &lt;code&gt;start&lt;/code&gt; や &lt;code&gt;stop&lt;/code&gt; を省略しても、常にシーケンス全体が正しいことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="6d6d1b284c6af28298538c5cdc0a7256d5d5f150" translate="yes" xml:space="preserve">
          <source>Easy way to reverse sequences!</source>
          <target state="translated">シーケンスを反転させる簡単な方法!</target>
        </trans-unit>
        <trans-unit id="dec3b85ab5c8afe4bdcf9aa78a36bb7b04f5b4e2" translate="yes" xml:space="preserve">
          <source>Enumerating the possibilities allowed by the grammar:</source>
          <target state="translated">文法によって許される可能性を列挙する。</target>
        </trans-unit>
        <trans-unit id="e2005c2f600247253cdd9b3a166cb5e388bbfb14" translate="yes" xml:space="preserve">
          <source>Explain Python's slice notation</source>
          <target state="translated">Pythonのスライス記法を説明する</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="ad2d3fd5da36e4d1450b52434f65543e2c249274" translate="yes" xml:space="preserve">
          <source>Extended indexing syntax used for slicing is aList[start:stop:step]. The start argument and the step argument both default to none - the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by range(start, stop, step). Python 3.4 documentation.</source>
          <target state="translated">スライスに使用される拡張インデックス構文は、aList[start:stop:step]です。start 引数と step 引数はどちらもデフォルトでは何も指定されていません。これは、リスト A と B を定義するために range を使用していたのと似ていることにお気づきでしょうか?これは、sliceオブジェクトがrange(start,stop,step)で指定されたインデックスのセットを表しているからです。Python 3.4 のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="25a46e8db798e121dc4a998aaa52b7c9c2f4ec77" translate="yes" xml:space="preserve">
          <source>Extended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.</source>
          <target state="translated">拡張スライシング(カンマや楕円を含む)は、ほとんどの場合、特殊なデータ構造(NumPyのような)でのみ使用され、基本シーケンスではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="2ce6a2c45d1f432b7017f6d8ad6c6f1f419ab941" translate="yes" xml:space="preserve">
          <source>Few other tricks for reversing the list:</source>
          <target state="translated">リストを反転させるための他のいくつかのトリック。</target>
        </trans-unit>
        <trans-unit id="53c11609ebb7eeb39c6ae1148df32803811abaf7" translate="yes" xml:space="preserve">
          <source>First, we will create a list of values to use in our slicing.</source>
          <target state="translated">まず、スライスで使用する値のリストを作成します。</target>
        </trans-unit>
        <trans-unit id="189f73dcf0d0e026377e4c161485f0bca4a39a7e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, negative values are interpreted as being relative to the end of the sequence.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; と &lt;code&gt;end&lt;/code&gt; の場合、負の値はシーケンスの終わりを基準にして解釈されます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="ad09b9342bcb6da8bd5c7a868860d3b6440eb901" translate="yes" xml:space="preserve">
          <source>For those who don't know, you can create any substring from &lt;code&gt;azString&lt;/code&gt; using the notation &lt;code&gt;azString[x:y]&lt;/code&gt;</source>
          <target state="translated">知らない人のために、表記 &lt;code&gt;azString[x:y]&lt;/code&gt; を使用して &lt;code&gt;azString&lt;/code&gt; から任意の部分文字列を作成できます。</target>
        </trans-unit>
        <trans-unit id="c2d2d5928c54cd3be6435296e94075da9fefa553" translate="yes" xml:space="preserve">
          <source>Found this great table at &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguagesで&lt;/a&gt;この素晴らしいテーブルを見つけました</target>
        </trans-unit>
        <trans-unit id="666ad671cbeba0a89e7c706687f77df7b879dbc2" translate="yes" xml:space="preserve">
          <source>From the diagram, I expect &lt;code&gt;a[-4,-6,-1]&lt;/code&gt; to be &lt;code&gt;yP&lt;/code&gt; but it is &lt;code&gt;ty&lt;/code&gt;.</source>
          <target state="translated">図から、 &lt;code&gt;a[-4,-6,-1]&lt;/code&gt; は &lt;code&gt;yP&lt;/code&gt; であると予想しますが、それは &lt;code&gt;ty&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="181af959e4f8d0fb4083b24c9a79dcab0d808777" translate="yes" xml:space="preserve">
          <source>Give your slices a descriptive name!</source>
          <target state="translated">スライスに説明的な名前をつけよう!</target>
        </trans-unit>
        <trans-unit id="d8bca9c064390cb40eb6923b46c08e356cc9a63d" translate="yes" xml:space="preserve">
          <source>Given the pattern aList[start:stop], retrieve the first two elements from List A.</source>
          <target state="translated">パターン aList[start:stop]が与えられると、リスト A から最初の 2 つの要素を取得します。</target>
        </trans-unit>
        <trans-unit id="f94faa9a2d2714420791cc753d22514493d014e9" translate="yes" xml:space="preserve">
          <source>Here is an example visualization of that ...</source>
          <target state="translated">ここでは、その可視化の例を紹介します。</target>
        </trans-unit>
        <trans-unit id="77b2dd3c3ff1e4885a243132aecac207f224e3f5" translate="yes" xml:space="preserve">
          <source>How Indexing Works</source>
          <target state="translated">インデックスの仕組み</target>
        </trans-unit>
        <trans-unit id="6f1f32310474f8326626103969ab54a0b5070606" translate="yes" xml:space="preserve">
          <source>How Slicing Works</source>
          <target state="translated">スライシングの仕組み</target>
        </trans-unit>
        <trans-unit id="3da40c095b10f44487cd4ccca0f47467d44aa681" translate="yes" xml:space="preserve">
          <source>However, using a negative value for &lt;code&gt;step&lt;/code&gt; could become very confusing. Moreover, in order to be &lt;a href=&quot;https://en.wiktionary.org/wiki/Pythonic#Adjective&quot;&gt;Pythonic&lt;/a&gt;, you should avoid using &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).</source>
          <target state="translated">ただし、 &lt;code&gt;step&lt;/code&gt; に負の値を使用すると、非常に混乱する可能性があります。 さらに、 &lt;a href=&quot;https://en.wiktionary.org/wiki/Pythonic#Adjective&quot;&gt;Pythonic&lt;/a&gt;であるためには、単一のスライスで &lt;code&gt;start&lt;/code&gt; 、 &lt;code&gt;end&lt;/code&gt; 、および &lt;code&gt;step&lt;/code&gt; を使用しないでください。 これが必要な場合は、2つの割り当て（1つはスライス、もう1つはストライド）で行うことを検討してください。</target>
        </trans-unit>
        <trans-unit id="4ad93a5dd4fcd6d7c940755502a6bc63d374feb4" translate="yes" xml:space="preserve">
          <source>However, you can't just assign some integers separated by colons to a variable. You need to use the slice object:</source>
          <target state="translated">しかし、コロンで区切られた整数を変数に代入することはできません。スライスオブジェクトを使う必要があります。</target>
        </trans-unit>
        <trans-unit id="aaa8f93b237e6d327bf33efc09bdaf86ccf36c81" translate="yes" xml:space="preserve">
          <source>I don't think that the &lt;a href=&quot;https://docs.python.org/3/tutorial/introduction.html#strings&quot;&gt;Python tutorial&lt;/a&gt; diagram (cited in various other answers) is good as this suggestion works for positive stride, but does not for a negative stride.</source>
          <target state="translated">この提案はポジティブストライドには有効ですが、ネガティブストライドには適さないため、（他のさまざまな回答で引用されている） &lt;a href=&quot;https://docs.python.org/3/tutorial/introduction.html#strings&quot;&gt;Pythonチュートリアル&lt;/a&gt;図は適切ではないと思います。</target>
        </trans-unit>
        <trans-unit id="c138ed3c54e5f033afa16fdbd5fccf8d39b80779" translate="yes" xml:space="preserve">
          <source>I find it easier to remember how it works, and then I can figure out any specific start/stop/step combination.</source>
          <target state="translated">それがどのように動作するかを覚えておくと、特定のスタート・ストップ・ステップの組み合わせを把握するのが簡単になります。</target>
        </trans-unit>
        <trans-unit id="ef399e0ded15774144fa63ae11d01aba3089469e" translate="yes" xml:space="preserve">
          <source>I had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt.</source>
          <target state="translated">私は、XとYが何であるかを覚え、最初の試みで適切に文字列をスライスするのに役立つ暗記テクニックの探求の中で、いくつかのシナリオを座って実行しなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="c7d0e42afda61407f67326f1c6eb38abab198765" translate="yes" xml:space="preserve">
          <source>I hope this will help you to model the list in Python.</source>
          <target state="translated">Pythonでリストをモデル化する際の参考になれば幸いです。</target>
        </trans-unit>
        <trans-unit id="77b54aef5e492c40146cd9a6d0b499de291945d3" translate="yes" xml:space="preserve">
          <source>I like to encourage users to read the source as well as the documentation. The &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/sliceobject.c&quot;&gt;source code for slice objects and this logic is found here&lt;/a&gt;. First we determine if &lt;code&gt;step&lt;/code&gt; is negative:</source>
          <target state="translated">私はユーザーにソースとドキュメントを読むことを勧めたいと思います。 &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/sliceobject.c&quot;&gt;スライスオブジェクトとこのロジック&lt;/a&gt;のソースコードはここにあります 。 まず、 &lt;code&gt;step&lt;/code&gt; が負かどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="5d3b3b36c387b5d0fc042b55acf61c2d549b5f7d" translate="yes" xml:space="preserve">
          <source>I need a good explanation (references are a plus) on Python's slice notation.</source>
          <target state="translated">Pythonのスライス記法についてしっかりとした説明が欲しい(参照はプラス)。</target>
        </trans-unit>
        <trans-unit id="ad507a3da03671c61941620ae7a2906912f4a37b" translate="yes" xml:space="preserve">
          <source>I personally think about it like a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">私は個人的には &lt;code&gt;for&lt;/code&gt; ループのように考えています：</target>
        </trans-unit>
        <trans-unit id="98382aeb1507eab72853d9ce777b3db6e8f02198" translate="yes" xml:space="preserve">
          <source>I use the &quot;an index points between elements&quot; method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:</source>
          <target state="translated">私自身は「要素間のインデックスポイント」という方法を使って考えていますが、他の人がそれを理解するのに役立つこともある記述方法の一つがこれです。</target>
        </trans-unit>
        <trans-unit id="7c6fedebad3f718314d64d61745e8419abe48090" translate="yes" xml:space="preserve">
          <source>I want to add one &lt;em&gt;Hello, World!&lt;/em&gt; example that explains the basics of slices for the very beginners. It helped me a lot.</source>
          <target state="translated">&lt;em&gt;Hello、World！を&lt;/em&gt; 1つ追加し&lt;em&gt;ます。&lt;/em&gt; 初心者向けのスライスの基本を説明する例。 それは私を大いに助けました。</target>
        </trans-unit>
        <trans-unit id="152b4bcea4dcb6a08bc28ea6e60677690158dfe0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stride&lt;/code&gt; is negative, the ordering is changed a bit since we're counting down:</source>
          <target state="translated">&lt;code&gt;stride&lt;/code&gt; が負の場合、カウントダウンしているため、順序が少し変更されます。</target>
        </trans-unit>
        <trans-unit id="cd1befa8b487c0ecabed83a3de28c3d4c4a8dbce" translate="yes" xml:space="preserve">
          <source>If so, the lower bound is &lt;code&gt;-1&lt;/code&gt;  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this &lt;code&gt;-1&lt;/code&gt; is &lt;em&gt;different&lt;/em&gt; from a &lt;code&gt;-1&lt;/code&gt; that users may pass indexes in Python indicating the last item.)</source>
          <target state="translated">その場合、下限は &lt;code&gt;-1&lt;/code&gt; で、最初までをスライスすることを意味し、上限は、長さから1を引いたもので、最後から開始することを意味します。 （この &lt;code&gt;-1&lt;/code&gt; のセマンティクスは、ユーザーが最後のアイテムを示すPythonでインデックスを渡すことができる &lt;code&gt;-1&lt;/code&gt; とは&lt;em&gt;異なる&lt;/em&gt;ことに注意してください。）</target>
        </trans-unit>
        <trans-unit id="2f065d470b215e663b57b87dd50c698f07db3377" translate="yes" xml:space="preserve">
          <source>If the index is out of range, Python will try its best to set the index to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;len(s)&lt;/code&gt; according to the situation. For example:</source>
          <target state="translated">インデックスが範囲外の場合、Pythonは状況に応じてインデックスを &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;len(s)&lt;/code&gt; に設定するために最善を尽くします。 例えば：</target>
        </trans-unit>
        <trans-unit id="8def849642c7353545fcda04de289db5103721fe" translate="yes" xml:space="preserve">
          <source>If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced:</source>
          <target state="translated">代入操作を行う際に開始インデックスと終了インデックスが省略された場合、コレクションの内容全体が参照されているもののコピーで置き換えられます。</target>
        </trans-unit>
        <trans-unit id="661ece95ee93a03aaa302b463dca836f55c6dd14" translate="yes" xml:space="preserve">
          <source>If you check the source code of &lt;a href=&quot;http://en.wikipedia.org/wiki/CPython&quot;&gt;CPython&lt;/a&gt;, you will find a function called PySlice_GetIndicesEx() which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/CPython&quot;&gt;CPython&lt;/a&gt;のソースコードを確認すると、PySlice_GetIndicesEx（）と呼ばれる関数が見つかります。この関数は、特定のパラメーターのスライスへのインデックスを計算します。 Pythonでの論理的に同等のコードを次に示します。</target>
        </trans-unit>
        <trans-unit id="47b5bc36bf784848f762edafdff62074643233f8" translate="yes" xml:space="preserve">
          <source>If you feel negative indices in slicing is confusing, here's a very easy way to think about it: just replace the negative index with &lt;code&gt;len - index&lt;/code&gt;. So for example, replace -3 with &lt;code&gt;len(list) - 3&lt;/code&gt;.</source>
          <target state="translated">スライスの負のインデックスが混乱していると感じた場合は、非常に簡単に考えることができ &lt;code&gt;len - index&lt;/code&gt; 。負のインデックスをlen-indexに置き換えてください。 したがって、たとえば-3を &lt;code&gt;len(list) - 3&lt;/code&gt; -3に置き換えます。</target>
        </trans-unit>
        <trans-unit id="fa833ad31212b2a3b3d439a0e7c53b383e2b3ca5" translate="yes" xml:space="preserve">
          <source>If you have a slice instance s, you can get more information about it by looking at its
s.start, s.stop, and s.step attributes, respectively. For example:</source>
          <target state="translated">スライスインスタンスsがある場合、そのs.start、s.stop、s.step属性をそれぞれ見ることで、それに関するより多くの情報を得ることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f3d97417ba0181b71f5aaffd104fe653cf71364a" translate="yes" xml:space="preserve">
          <source>If you omit the start and end index, you will make a copy of the collection:</source>
          <target state="translated">開始インデックスと終了インデックスを省略した場合は、コレクションのコピーを作成します。</target>
        </trans-unit>
        <trans-unit id="f60db26cf6492e7fc7bbed6f90da520c3f57371b" translate="yes" xml:space="preserve">
          <source>If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list.</source>
          <target state="translated">a,b,c のルールを使ってトラバースする際に、a,b,c の選択が上記の範囲との重複を許容する場合、要素を含むリスト(トラバース中にタッチされたもの)を得るか、空のリストを得るかのどちらかになります。</target>
        </trans-unit>
        <trans-unit id="f466c12bda6762ec7169a18df85f167e0081116f" translate="yes" xml:space="preserve">
          <source>Important Definitions</source>
          <target state="translated">重要な定義</target>
        </trans-unit>
        <trans-unit id="f2bb9ecf761b6e88e8102a7536ee8d44abe40249" translate="yes" xml:space="preserve">
          <source>In Python 2.7</source>
          <target state="translated">Python 2.7では</target>
        </trans-unit>
        <trans-unit id="90a6eb777e8cda542826e3c6334816f4f0ee8eb6" translate="yes" xml:space="preserve">
          <source>In Python, the most basic form for slicing is the following:</source>
          <target state="translated">Pythonでは、スライシングの最も基本的な形は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0ee248346d0af5cd683e4a36d0a440e60af3c740" translate="yes" xml:space="preserve">
          <source>In fact, compared to indexing, Python slicing is bizarrely error-proof:</source>
          <target state="translated">実際、インデックス化に比べて、Pythonのスライスは異様にエラーが出にくいです。</target>
        </trans-unit>
        <trans-unit id="e26167c936dd528fda49f3a0a8e244ad7c09578d" translate="yes" xml:space="preserve">
          <source>In my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on).</source>
          <target state="translated">私見ですが、Pythonの文字列スライス記法は、以下のように見ていくと理解が深まり、覚えやすくなると思います(読み進めてください)。</target>
        </trans-unit>
        <trans-unit id="f7dabe40d708c905a0cefb23cf2333f28977c80b" translate="yes" xml:space="preserve">
          <source>In short, the colons (&lt;code&gt;:&lt;/code&gt;) in subscript notation (&lt;code&gt;subscriptable[subscriptarg]&lt;/code&gt;) make slice notation - which has the optional arguments, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;:</source>
          <target state="translated">要するに、下付き表記のコロン（ &lt;code&gt;:&lt;/code&gt; ）（ &lt;code&gt;subscriptable[subscriptarg]&lt;/code&gt; ）はスライス表記を作成します-これはオプションの引数 &lt;code&gt;start&lt;/code&gt; 、 &lt;code&gt;stop&lt;/code&gt; 、 &lt;code&gt;step&lt;/code&gt; を持っています：</target>
        </trans-unit>
        <trans-unit id="bb5e2ff5da706301f634ce9ca90e75ed00059cba" translate="yes" xml:space="preserve">
          <source>In these moments I rely on this simple theorem:</source>
          <target state="translated">このような時には、私はこの単純な定理に頼っています。</target>
        </trans-unit>
        <trans-unit id="5870a8ca498a1c74154e2cfd9acc8e21c121fdb0" translate="yes" xml:space="preserve">
          <source>Index the number 3 from A and the number 6 from B.</source>
          <target state="translated">Aの数字の3とBの数字の6をインデックス化します。</target>
        </trans-unit>
        <trans-unit id="3631e9d015a9f2d779f98610e8e9d63664c32ef5" translate="yes" xml:space="preserve">
          <source>Indexing is like dealing with the contents of box. You can check contents of any box. But you can't check the contents of multiple boxes at once. You can even replace the contents of the box. But you can't place two balls in one box or replace two balls at a time.</source>
          <target state="translated">インデックス作成は、箱の中身を扱うようなものです。どんな箱でも中身を確認することはできます。しかし、複数の箱の内容を一度に確認することはできません。箱の中身を入れ替えることもできます。しかし、1つの箱に2つの玉を入れたり、一度に2つの玉を入れ替えたりすることはできません。</target>
        </trans-unit>
        <trans-unit id="2e852a9a85a011a4821ea957a6c18af49fdb2384" translate="yes" xml:space="preserve">
          <source>It is a list with six elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it.</source>
          <target state="translated">これは、6つの要素が入ったリストです。スライスをよりよく理解するためには、そのリストを6つの箱が一緒に配置されたセットと考えてみてください。それぞれの箱にはアルファベットが入っています。</target>
        </trans-unit>
        <trans-unit id="72edc078c44d61355487724654334d433672237e" translate="yes" xml:space="preserve">
          <source>It is also possible to use negative integers for &lt;code&gt;step&lt;/code&gt; as the following example:</source>
          <target state="translated">次の例のように、 &lt;code&gt;step&lt;/code&gt; 負の整数を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="d2e55fc42f854f48df8f7704c2076ef2f0b82f26" translate="yes" xml:space="preserve">
          <source>It is important to note, the first element is index 0, &lt;em&gt;not&lt;/em&gt; index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc.) while List B's elements are the numbers that would be used to index them ([0] for the first element 0, etc.).</source>
          <target state="translated">最初の要素はインデックス1では&lt;em&gt;なく&lt;/em&gt; 、インデックス0であることに注意してください。これが、この演習で2つのリストを使用している理由です。 リストAの要素は序数（最初の要素は1、2番目の要素は2など）に従って番号が付けられていますが、リストBの要素はそれらをインデックスするために使用される番号です（最初の要素0は[0]、等。）。</target>
        </trans-unit>
        <trans-unit id="8437802c00fcb02882fb640fb2f6aa10b7ed41e7" translate="yes" xml:space="preserve">
          <source>It is possible to provide indices that are out of bounds when slicing such as:</source>
          <target state="translated">のようなスライス時に圏外となるインデックスを提供することが可能です。</target>
        </trans-unit>
        <trans-unit id="cc08d6b3965c9cd2a7d0a9d353abfe631305e0ce" translate="yes" xml:space="preserve">
          <source>It looks extremely powerful, but I haven't quite got my head around it.</source>
          <target state="translated">非常に強力そうに見えるが、まだよく分からない。</target>
        </trans-unit>
        <trans-unit id="c3478bf3faba9c41f22e71efd498abcab65d1e72" translate="yes" xml:space="preserve">
          <source>It's instructive to understand &lt;code&gt;range()&lt;/code&gt; first:</source>
          <target state="translated">最初に &lt;code&gt;range()&lt;/code&gt; を理解することは有益です ：</target>
        </trans-unit>
        <trans-unit id="db93970c161e9b60dc37836b4ad4bcc5e738b56f" translate="yes" xml:space="preserve">
          <source>It's interesting that ranges also take slices:</source>
          <target state="translated">レンジでもスライスが取れるのは面白いですね。</target>
        </trans-unit>
        <trans-unit id="393247b02d3798ab868c03bcc3f85e6ad9331f9b" translate="yes" xml:space="preserve">
          <source>It's pretty simple really:</source>
          <target state="translated">本当に簡単なことなんです。</target>
        </trans-unit>
        <trans-unit id="07e297809eb4051826121e82a0caefbf899d3c86" translate="yes" xml:space="preserve">
          <source>Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignments do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values:</source>
          <target state="translated">コレクションをスライスした結果は、全く新しいコレクションになることを覚えておいてください。さらに、代入でスライス表記を使用する場合、スライス代入の長さは同じである必要はありません。割り当てられたスライスの前後の値は保持され、コレクションは新しい値を含むように縮小または成長します。</target>
        </trans-unit>
        <trans-unit id="cf594f555786da65b5bbbcfa5d1f5e37ff7665e6" translate="yes" xml:space="preserve">
          <source>Let's finish this answer with examples, explaining everything we have discussed:</source>
          <target state="translated">これまでに話したことをすべて説明して、この回答を例題で締めくくりましょう。</target>
        </trans-unit>
        <trans-unit id="26f47aa550adca492b5233c25393b47b841fe5ad" translate="yes" xml:space="preserve">
          <source>Let's have a list with six values &lt;code&gt;['P', 'Y', 'T', 'H', 'O', 'N']&lt;/code&gt;:</source>
          <target state="translated">6つの値を持つリストがあるとします &lt;code&gt;['P', 'Y', 'T', 'H', 'O', 'N']&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7137555528de00a0bcf2c040f1daafce2f58347c" translate="yes" xml:space="preserve">
          <source>Let's work with the following string ...</source>
          <target state="translated">次の文字列を使って作業してみましょう ...</target>
        </trans-unit>
        <trans-unit id="3f6a7a17387285ecbb29103e91399ef401031fff" translate="yes" xml:space="preserve">
          <source>Making things more confusing is that &lt;strong&gt;&lt;code&gt;step&lt;/code&gt; can be negative too!&lt;/strong&gt;</source>
          <target state="translated">物事をより混乱させるのは、その&lt;strong&gt; &lt;code&gt;step&lt;/code&gt; もネガティブになる可能性&lt;/strong&gt;があるという&lt;strong&gt;ことです！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4d6fecb17d10399cfa47983f1042cccd5affc47" translate="yes" xml:space="preserve">
          <source>Memory Considerations:</source>
          <target state="translated">記憶の考察。</target>
        </trans-unit>
        <trans-unit id="1ff1eb25d65b7e8b0b1c5bcc0650dd539ed6fbbd" translate="yes" xml:space="preserve">
          <source>More slicing examples: &lt;a href=&quot;https://docs.python.org/2.3/whatsnew/section-slices.html&quot;&gt;15 Extended Slices&lt;/a&gt;</source>
          <target state="translated">その他のスライスの例： &lt;a href=&quot;https://docs.python.org/2.3/whatsnew/section-slices.html&quot;&gt;15個の拡張スライス&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="236384af55aea443e68110eede08ce564e280d4c" translate="yes" xml:space="preserve">
          <source>Most of the previous answers clears up questions about slice notation.</source>
          <target state="translated">これまでの回答のほとんどが、スライス表記に関する疑問を解決してくれています。</target>
        </trans-unit>
        <trans-unit id="258dc3b32b7b8c786022e52d99f1e20b993d915e" translate="yes" xml:space="preserve">
          <source>My brain seems happy to accept that &lt;code&gt;lst[start:end]&lt;/code&gt; contains the &lt;code&gt;start&lt;/code&gt;-th item. I might even say that it is a 'natural assumption'.</source>
          <target state="translated">私の脳は、 &lt;code&gt;lst[start:end]&lt;/code&gt; に &lt;code&gt;start&lt;/code&gt; 番目の項目が含まれていることを喜んで受け入れています。 それは「自然な仮定」だとさえ言うかもしれません。</target>
        </trans-unit>
        <trans-unit id="0e9abc9291766099a35bbc0daca4bfdba74ab393" translate="yes" xml:space="preserve">
          <source>My conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as &lt;code&gt;azString[index1, index2]&lt;/code&gt; or even more clearer as &lt;code&gt;azString[index_of_first_character, index_after_the_last_character]&lt;/code&gt;.</source>
          <target state="translated">私の結論は、xとyは追加したい文字列を囲む境界インデックスとして見られるべきだということです。 したがって、式は &lt;code&gt;azString[index_of_first_character, index_after_the_last_character]&lt;/code&gt; として、またはさらに明確にazString [index_of_first_character、index_after_the_last_character]として表示されます。</target>
        </trans-unit>
        <trans-unit id="5bc0687f0ccd20cd39dcb014b119503d374c4139" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;start &amp;gt;= end&lt;/code&gt; (considering only when &lt;code&gt;step&amp;gt;0&lt;/code&gt;), Python will return a empty slice &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;start &amp;gt;= end&lt;/code&gt; （ &lt;code&gt;step&amp;gt;0&lt;/code&gt; の場合のみを考慮する）の場合、Pythonは空のスライス &lt;code&gt;[]&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="3924ca69a9c6ef3c94b8adce539357eedbfe98b1" translate="yes" xml:space="preserve">
          <source>Negative indexes</source>
          <target state="translated">負の指標</target>
        </trans-unit>
        <trans-unit id="19a3fcc38635b3630af723c1238943e8e1843247" translate="yes" xml:space="preserve">
          <source>Negative integers are useful when doing offsets relative to the end of a collection:</source>
          <target state="translated">負の整数は、コレクションの終わりを相対的にオフセットするときに便利です。</target>
        </trans-unit>
        <trans-unit id="afa9d728aad9ce367861bb103920cb5b75e339e7" translate="yes" xml:space="preserve">
          <source>Negative step</source>
          <target state="translated">ネガティブステップ</target>
        </trans-unit>
        <trans-unit id="96650fe967ba54c6b724f6429dd3614089107d32" translate="yes" xml:space="preserve">
          <source>Normalizing negative indexes first allows start and/or stop to be counted from the end independently: &lt;code&gt;'abcde'[1:-2] == 'abcde'[1:3] == 'bc'&lt;/code&gt; despite &lt;code&gt;range(1,-2) == []&lt;/code&gt;.
The normalization is sometimes thought of as &quot;modulo the length&quot;, but note it adds the length just once: e.g. &lt;code&gt;'abcde'[-53:42]&lt;/code&gt; is just the whole string.</source>
          <target state="translated">最初に負のインデックスを正規化すると、開始および/または停止を最後から個別にカウントできます： &lt;code&gt;'abcde'[1:-2] == 'abcde'[1:3] == 'bc'&lt;/code&gt; &lt;code&gt;range(1,-2) == []&lt;/code&gt; にもかかわらず== [] 。 正規化は「長さを法とする」と考えられることがありますが、長さは1回だけ追加されることに注意してください。たとえば、 &lt;code&gt;'abcde'[-53:42]&lt;/code&gt; : 42]は文字列全体です。</target>
        </trans-unit>
        <trans-unit id="4d43af0ad3abe59f6e4fb376c128181bd7bde7b5" translate="yes" xml:space="preserve">
          <source>Note that this theorem is true for any &lt;code&gt;n&lt;/code&gt; at all. For example, you can check that</source>
          <target state="translated">この定理はどの &lt;code&gt;n&lt;/code&gt; にも当てはまることに注意してください。 たとえば、あなたはそれを確認することができます</target>
        </trans-unit>
        <trans-unit id="2ceb96fc5e9a3dc2bc105bff4a65c7e6742be2cc" translate="yes" xml:space="preserve">
          <source>Note that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments.</source>
          <target state="translated">スライスの2番目の番号(4)を変更していないので、空のスライスに代入している場合でも、挿入されたアイテムは常に'o'に対して真上に積み重なっていることに注意してください。したがって、空のスライス代入の位置は、空でないスライス代入の位置の論理的な拡張子となります。</target>
        </trans-unit>
        <trans-unit id="967bf0aa1a3677571a7849b566735433ec166495" translate="yes" xml:space="preserve">
          <source>Now if you make a slice &lt;code&gt;[2:5]&lt;/code&gt; of the list above, this will happen:</source>
          <target state="translated">上記のリストのスライス &lt;code&gt;[2:5]&lt;/code&gt; を作成すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="e6df6b2bcf9a3314ee026c4f79df59cdd07fa7f8" translate="yes" xml:space="preserve">
          <source>Now the simplest slices of that list are its sublists. The notation is &lt;code&gt;[&amp;lt;index&amp;gt;:&amp;lt;index&amp;gt;]&lt;/code&gt; and the key is to read it like this:</source>
          <target state="translated">これで、そのリストの最も単純なスライスがそのサブリストになります。 表記は &lt;code&gt;[&amp;lt;index&amp;gt;:&amp;lt;index&amp;gt;]&lt;/code&gt; で、キーは次のようにそれを読み取ることです。</target>
        </trans-unit>
        <trans-unit id="4b69184bd6d629ae67ecbb030f96e1b6febacc6a" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;(high-low)%stride != 0&lt;/code&gt;, then the end point will be a little lower than &lt;code&gt;high-1&lt;/code&gt;.</source>
          <target state="translated">もちろん、 &lt;code&gt;(high-low)%stride != 0&lt;/code&gt; 場合、終点は &lt;code&gt;high-1&lt;/code&gt; よりも少し低くなります。</target>
        </trans-unit>
        <trans-unit id="9797498b5445b5a3c49a8d9a5a8bcc115a3f1de4" translate="yes" xml:space="preserve">
          <source>One heuristic is, for a slice from zero to n, think: &quot;zero is the beginning, start at the beginning and take n items in a list&quot;.</source>
          <target state="translated">1つのヒューリスティックな方法は、0からnまでのスライスについて、「0が最初で、最初から始めて、リストの中のn個の項目を取る」と考えることです。</target>
        </trans-unit>
        <trans-unit id="1deb5c09927c43e07c799a375e42510fd8ab8301" translate="yes" xml:space="preserve">
          <source>One last thing: if a and b are equal, then also you get an empty list:</source>
          <target state="translated">最後にもう一つ、aとbが等しい場合、空のリストも得られます。</target>
        </trans-unit>
        <trans-unit id="22de4720e28cbf22dbc85b732b56fab0a497d9da" translate="yes" xml:space="preserve">
          <source>One way to remember how slices work is to think of the indices as pointing &lt;em&gt;between&lt;/em&gt; characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of &lt;em&gt;n&lt;/em&gt; characters has index &lt;em&gt;n&lt;/em&gt;.</source>
          <target state="translated">スライスがどのように機能するかを覚える1つの方法は、インデックスを文字&lt;em&gt;間&lt;/em&gt;を指すと考え、最初の文字の左端を0と番号付けすることです。次に、 &lt;em&gt;n&lt;/em&gt;文字の文字列の最後の文字の右端のインデックスは&lt;em&gt;n&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="01230747b9914341b6ea0abf3a127d2554050e61" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;step&lt;/code&gt; is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list.</source>
          <target state="translated">それ以外の場合、 &lt;code&gt;step&lt;/code&gt; は正であり、下限はゼロであり、上限（スライスのリストの長さを含みます）はスライスリストの長さになります。</target>
        </trans-unit>
        <trans-unit id="6ee09859ae901d353f04d7756fc619a422996265" translate="yes" xml:space="preserve">
          <source>Out of range error?</source>
          <target state="translated">範囲外エラー?</target>
        </trans-unit>
        <trans-unit id="1e32d6d4f298657e76954434ba9df3c467b606d2" translate="yes" xml:space="preserve">
          <source>Positive indices for &lt;code&gt;end&lt;/code&gt; indicate the position &lt;em&gt;after&lt;/em&gt; the last element to be included.</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; の正のインデックスは、含まれる最後の要素の&lt;em&gt;後&lt;/em&gt;の位置を示します。</target>
        </trans-unit>
        <trans-unit id="94740c4c4bc99ca509491718d4ba079f2a8f218e" translate="yes" xml:space="preserve">
          <source>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for &lt;code&gt;a[:-2]&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.</source>
          <target state="translated">あなたが要求するよりも項目が少ない場合、Pythonはプログラマーに親切です。 たとえば、 &lt;code&gt;a[:-2]&lt;/code&gt; を要求し、aに1つの要素しか含まれ &lt;code&gt;a&lt;/code&gt; ない場合、エラーではなく空のリストが表示されます。 時々あなたはエラーを好むので、あなたはこれが起こるかもしれないことに注意しなければなりません。</target>
        </trans-unit>
        <trans-unit id="b248a1be31c8962b0faa6461a8e1ebdb8bf936b1" translate="yes" xml:space="preserve">
          <source>Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with.</source>
          <target state="translated">Pythonのスライシングは、データの一部にメソッド的にアクセスするための高速な計算方法です。私の考えでは、Pythonプログラマーの中級者であっても、この言語に精通していることが必要な一面です。</target>
        </trans-unit>
        <trans-unit id="4be307b534051fdddbb09f680b1f90334e27c87c" translate="yes" xml:space="preserve">
          <source>Python slicing notation:</source>
          <target state="translated">Pythonのスライス記法。</target>
        </trans-unit>
        <trans-unit id="0f99ce71c7cc473f59ebcdd42fafcac7ebb5607c" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</source>
          <target state="translated">リファレンス： &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http&lt;/a&gt; : //wiki.python.org/moin/MovingToPythonFromOtherLanguages</target>
        </trans-unit>
        <trans-unit id="85e3167baf4fe31a5ac66fca1064289b89090879" translate="yes" xml:space="preserve">
          <source>Relation to &lt;code&gt;slice()&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;slice()&lt;/code&gt; オブジェクトとの関係</target>
        </trans-unit>
        <trans-unit id="ded5af84f53bac1b910e783dc1876f40d1930247" translate="yes" xml:space="preserve">
          <source>Remember that we are setting the boundaries. And those boundaries are the positions where you could place some brackets that will be wrapped around the substring like this ...</source>
          <target state="translated">境界線を設定していることを覚えておいてください。この境界線は、以下のように部分文字列の周りに括弧を置くことができる位置です...</target>
        </trans-unit>
        <trans-unit id="87aef1727fb2103950e2e345944a306d9d583015" translate="yes" xml:space="preserve">
          <source>Sequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence:</source>
          <target state="translated">シーケンススライシングは、最初に負のインデックスを正規化し、シーケンスの外に出ることができないことを除いては同じです。</target>
        </trans-unit>
        <trans-unit id="96eaebe560215c517ad3e5af8e2a9735ecb8738d" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;step&lt;/code&gt; may be a negative number:</source>
          <target state="translated">同様に、 &lt;code&gt;step&lt;/code&gt; は負の数になる場合があります。</target>
        </trans-unit>
        <trans-unit id="ae00240360bccc296201ca8138f454fe741d7f58" translate="yes" xml:space="preserve">
          <source>Since slices of Python lists create new objects in memory, another important function to be aware of is &lt;code&gt;itertools.islice&lt;/code&gt;. Typically you'll want to iterate over a slice, not just have it created statically in memory. &lt;code&gt;islice&lt;/code&gt; is perfect for this. A caveat, it doesn't support negative arguments to &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, or &lt;code&gt;step&lt;/code&gt;, so if that's an issue you may need to calculate indices or reverse the iterable in advance.</source>
          <target state="translated">Pythonリストのスライスはメモリ内に新しいオブジェクトを作成するため、知っておくべきもう1つの重要な関数は &lt;code&gt;itertools.islice&lt;/code&gt; です。 通常、メモリ内で静的に作成するだけでなく、スライスを反復処理する必要があります。 &lt;code&gt;islice&lt;/code&gt; はこれに最適です。 注意点として、 &lt;code&gt;start&lt;/code&gt; 、 &lt;code&gt;stop&lt;/code&gt; 、 &lt;code&gt;step&lt;/code&gt; の負の引数はサポートされていないため、それが問題である場合は、事前にインデックスを計算するか、反復可能オブジェクトを逆にする必要があります。</target>
        </trans-unit>
        <trans-unit id="8c3c2e5e113c75c44c107bde062191fa1ee7c4b5" translate="yes" xml:space="preserve">
          <source>Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:</source>
          <target state="translated">リスト(またはそれをサポートする他のシーケンス、文字列など)から最後の9つの要素を取得するためのスライス記法は次のようになります。</target>
        </trans-unit>
        <trans-unit id="afd155507ef02b023315f7f2437ce7518f12da0e" translate="yes" xml:space="preserve">
          <source>Slice notation works like this:</source>
          <target state="translated">スライス記法はこのように動作します。</target>
        </trans-unit>
        <trans-unit id="2bf8562fbd4372800fdbdad7eef6770e5b0c3ac3" translate="yes" xml:space="preserve">
          <source>Slice objects also behave slightly differently depending on the number of arguments, similarly to &lt;code&gt;range()&lt;/code&gt;, i.e. both &lt;code&gt;slice(stop)&lt;/code&gt; and &lt;code&gt;slice(start, stop[, step])&lt;/code&gt; are supported.
To skip specifying a given argument, one might use &lt;code&gt;None&lt;/code&gt;, so that e.g. &lt;code&gt;a[start:]&lt;/code&gt; is equivalent to &lt;code&gt;a[slice(start, None)]&lt;/code&gt; or &lt;code&gt;a[::-1]&lt;/code&gt; is equivalent to &lt;code&gt;a[slice(None, None, -1)]&lt;/code&gt;.</source>
          <target state="translated">Sliceオブジェクトも &lt;code&gt;range()&lt;/code&gt; と同様に、引数の数に応じて少し異なる動作をします 。つまり、 &lt;code&gt;slice(stop)&lt;/code&gt; と &lt;code&gt;slice(start, stop[, step])&lt;/code&gt; 両方がサポートされます。 特定の引数の指定をスキップするには、 &lt;code&gt;None&lt;/code&gt; を使用します。たとえば &lt;code&gt;a[start:]&lt;/code&gt; は &lt;code&gt;a[slice(start, None)]&lt;/code&gt; &lt;code&gt;a[::-1]&lt;/code&gt; と同等、またはa [::-1]は &lt;code&gt;a[slice(None, None, -1)]&lt;/code&gt; ）と同等です。 、-1）] 。</target>
        </trans-unit>
        <trans-unit id="e0de34fe528d24a6ab78b22ea621d459ea58bcde" translate="yes" xml:space="preserve">
          <source>Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use &lt;a href=&quot;https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python&quot;&gt;&lt;code&gt;deepcopy()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">スライスは、配列要素のコピーではなく参照を保持します。 別のコピーを配列にしたい場合は、 &lt;a href=&quot;https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python&quot;&gt; &lt;code&gt;deepcopy()&lt;/code&gt; を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="e7a0ec14b698ea62c178c70915809b11eee0b1d4" translate="yes" xml:space="preserve">
          <source>Slicing example: [start:end:step]</source>
          <target state="translated">スライスの例です。開始:終了:ステップ</target>
        </trans-unit>
        <trans-unit id="0fab7676f1313a7031d732db17a3266ea48b260e" translate="yes" xml:space="preserve">
          <source>Slicing in Python</source>
          <target state="translated">Pythonでのスライシング</target>
        </trans-unit>
        <trans-unit id="2f82b358ce4a2bd3562b18aca5eb96f4abc16964" translate="yes" xml:space="preserve">
          <source>Slicing is like dealing with boxes themselves. You can pick up the first box and place it on another table. To pick up the box, all you need to know is the position of beginning and ending of the box.</source>
          <target state="translated">スライスは箱そのものを扱うようなものです。最初の箱を拾って、別のテーブルに置くことができます。箱を拾うために必要なのは、箱の始点と終点の位置だけです。</target>
        </trans-unit>
        <trans-unit id="b6071a94da6c32b2f41ecdb9b7c54c4fc53d3bbe" translate="yes" xml:space="preserve">
          <source>So all you have to do is setting index1 and index2 to the values that will surround the desired substring. For instance, to get the substring &quot;cdefgh&quot;, you can use &lt;code&gt;azString[2:8]&lt;/code&gt;, because the index on the left side of &quot;c&quot; is 2 and the one on the right size of &quot;h&quot; is 8.</source>
          <target state="translated">したがって、必要なのは、index1とindex2を目的のサブストリングを囲む値に設定することだけです。 たとえば、部分文字列「cdefgh」を取得するには、 &lt;code&gt;azString[2:8]&lt;/code&gt; 使用できます。これは、「c」の左側のインデックスが2で、「h」の右側のサイズのインデックスが8であるためです。</target>
        </trans-unit>
        <trans-unit id="9d36a8ded558a57acb9a21c94c859b6d67771f8e" translate="yes" xml:space="preserve">
          <source>So possible variations are:</source>
          <target state="translated">だから可能性のあるバリエーションは</target>
        </trans-unit>
        <trans-unit id="5e112be622e92277daa08e6daca504e718916de7" translate="yes" xml:space="preserve">
          <source>That trick works all the time and is easy to memorize.</source>
          <target state="translated">そのトリックはいつでも通用するし、覚えやすい。</target>
        </trans-unit>
        <trans-unit id="fdf01cb06945a582fa2999e094744ca983173e6c" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;:2&lt;/code&gt;&quot; before the comma operates on the first dimension and the &quot;&lt;code&gt;0:3:2&lt;/code&gt;&quot; after the comma operates on the second dimension.</source>
          <target state="translated">コンマの前の「 &lt;code&gt;:2&lt;/code&gt; 」は最初の次元で機能し、コンマの後の「 &lt;code&gt;0:3:2&lt;/code&gt; 」は2番目の次元で機能します。</target>
        </trans-unit>
        <trans-unit id="671738aa3584c456b592e354d91684dcd323f399" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#strings&quot;&gt;Python tutorial&lt;/a&gt; talks about it (scroll down a bit until you get to the part about slicing).</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#strings&quot;&gt;Pythonチュートリアル&lt;/a&gt;がそれについて語っています（スライスに関する部分にたどり着くまで少し下にスクロールしてください）。</target>
        </trans-unit>
        <trans-unit id="fb121e6f32b2ed82d98fe529053634abd387ad84" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;colon&lt;/strong&gt;, &lt;code&gt;:&lt;/code&gt;,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is</source>
          <target state="translated">&lt;strong&gt;コロン&lt;/strong&gt; &lt;code&gt;:&lt;/code&gt; は 、Pythonに通常のインデックスではなくスライスを与えることを伝えます。 そのため、Python 2でリストの浅いコピーを作成する慣用的な方法は、</target>
        </trans-unit>
        <trans-unit id="064ca1037f07ebe70ccb6e0e4303cf9c8fd960d8" translate="yes" xml:space="preserve">
          <source>The ASCII art diagram is helpful too for remembering how slices work:</source>
          <target state="translated">アスキーアート図もスライスの仕組みを覚えるのに便利です。</target>
        </trans-unit>
        <trans-unit id="c2a53ea7c27bc274090377248543665760dc2d23" translate="yes" xml:space="preserve">
          <source>The above part explains the core features on how slice works, and it will work on most occasions. However, there can be pitfalls you should watch out, and this part explains them.</source>
          <target state="translated">上記のパートでは、スライスがどのように動作するかについての核心的な機能を説明しており、ほとんどの場面で動作するでしょう。しかし、注意すべき落とし穴がある場合があり、この部分ではそれらを説明します。</target>
        </trans-unit>
        <trans-unit id="9a0d878051d5575a2cc4db1865d8619aa0945996" translate="yes" xml:space="preserve">
          <source>The answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art:</source>
          <target state="translated">上記の回答では、スライスの割り当てについては触れていません。スライスアサインを理解するためには、アスキーアートに別の概念を加えると便利です。</target>
        </trans-unit>
        <trans-unit id="4827bfb62b55032ff3bc19f8d7461338d02ba84c" translate="yes" xml:space="preserve">
          <source>The basic slicing technique is to define the starting point, the stopping point, and the step size - also known as stride.</source>
          <target state="translated">基本的なスライシングテクニックは、開始点、停止点、ステップサイズ(ストライドとも呼ばれる)を定義することです。</target>
        </trans-unit>
        <trans-unit id="7afa04f193c1a31833d08e539febf8032a61d69d" translate="yes" xml:space="preserve">
          <source>The below is the example of an index of a string:</source>
          <target state="translated">以下は文字列のインデックスの例です。</target>
        </trans-unit>
        <trans-unit id="a6fdc6b5102e017e74aa1ebfa120ec1728976bd7" translate="yes" xml:space="preserve">
          <source>The best way to illustrate what slicing does internally is just show it in code that implements this operation:</source>
          <target state="translated">スライシングが内部的に何をするのかを説明する最良の方法は、この操作を実装したコードでそれを表示することです。</target>
        </trans-unit>
        <trans-unit id="9b289ec304478ab3aa8206822ac93132cd9189a0" translate="yes" xml:space="preserve">
          <source>The extended indexing syntax used for slicing is &lt;code&gt;aList[start:stop:step]&lt;/code&gt;, and basic examples are:</source>
          <target state="translated">スライスに使用される拡張インデックス構文は &lt;code&gt;aList[start:stop:step]&lt;/code&gt; で、基本的な例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="835f8ab3b0337722c0f132a2e78a9079b59cded7" translate="yes" xml:space="preserve">
          <source>The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy.</source>
          <target state="translated">リストのスライスがコピーを作るというのは、リスト自体の特徴です。Pandas DataFrame のような高度なオブジェクトをスライスしている場合、コピーではなくオリジナルのビューを返すことがあります。</target>
        </trans-unit>
        <trans-unit id="41c12238b9c9bbcd33df30b54dc049e7a8a037bb" translate="yes" xml:space="preserve">
          <source>The first rule of slice assignment is that since slicing &lt;em&gt;returns&lt;/em&gt; a list, slice assignment &lt;em&gt;requires&lt;/em&gt; a list (or other iterable):</source>
          <target state="translated">スライス割り当ての最初のルールは、スライスするとリスト&lt;em&gt;が返さ&lt;/em&gt;れるため、スライス割り当てに&lt;em&gt;は&lt;/em&gt;リスト（または他の反復可能） &lt;em&gt;が必要で&lt;/em&gt;あることです。</target>
        </trans-unit>
        <trans-unit id="053d4b345613c9e63af290ea87904c13976fb020" translate="yes" xml:space="preserve">
          <source>The full notation is</source>
          <target state="translated">完全表記は</target>
        </trans-unit>
        <trans-unit id="a279c32eedbdb41ca0663a3f3c7caa14aacb8d48" translate="yes" xml:space="preserve">
          <source>The interesting thing is that you can replace multiple boxes at once. Also you can place multiple boxes wherever you like.</source>
          <target state="translated">面白いのは、一度に複数の箱を入れ替えることができることです。また、複数の箱を好きな場所に配置することができます。</target>
        </trans-unit>
        <trans-unit id="cbafdf992eb9b0ec11721982bbb3effe97d12b16" translate="yes" xml:space="preserve">
          <source>The key point to remember is that the &lt;code&gt;:stop&lt;/code&gt; value represents the first value that is &lt;em&gt;not&lt;/em&gt; in the selected slice. So, the difference between &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; is the number of elements selected (if &lt;code&gt;step&lt;/code&gt; is 1, the default).</source>
          <target state="translated">覚えておくべき重要な点は、 &lt;code&gt;:stop&lt;/code&gt; 値は、選択されたスライスに&lt;em&gt;ない&lt;/em&gt;最初の値を表すということです。 したがって、 &lt;code&gt;stop&lt;/code&gt; と &lt;code&gt;start&lt;/code&gt; 違いは、選択された要素の数です（ &lt;code&gt;step&lt;/code&gt; が1の場合、デフォルト）。</target>
        </trans-unit>
        <trans-unit id="75586a32a01b71ebd61830c9004e1d99bb7e7f3c" translate="yes" xml:space="preserve">
          <source>The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use:</source>
          <target state="translated">この記法は,(numpy)行列や多次元配列にも拡張されています.例えば,列全体をスライスするには,次のようにします.</target>
        </trans-unit>
        <trans-unit id="517bdfc38c62e4ed8dbc0ebe6233fdd418806066" translate="yes" xml:space="preserve">
          <source>The other feature is that &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; may be a &lt;em&gt;negative&lt;/em&gt; number, which means it counts from the end of the array instead of the beginning. So:</source>
          <target state="translated">もう1つの機能は、 &lt;code&gt;start&lt;/code&gt; または &lt;code&gt;stop&lt;/code&gt; が&lt;em&gt;負の&lt;/em&gt;数になる可能性があることです。つまり、配列の最初ではなく最後から数えます。 そう：</target>
        </trans-unit>
        <trans-unit id="88cb13542cd6c22a7ed79eaff2dca42af648aa1a" translate="yes" xml:space="preserve">
          <source>The previous answers don't discuss multi-dimensional array slicing which is possible using the famous &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; package:</source>
          <target state="translated">以前の回答では、有名な&lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt;パッケージを使用して可能な多次元配列スライシングについては触れていません。</target>
        </trans-unit>
        <trans-unit id="bcb48bc85f26256a3ee0c0f6a3e5b4429c47ae72" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;None&lt;/code&gt;, is required, so that the first argument is interpreted as the &lt;code&gt;start&lt;/code&gt; argument &lt;a href=&quot;https://docs.python.org/2/library/functions.html#slice&quot;&gt;otherwise it would be the &lt;code&gt;stop&lt;/code&gt; argument&lt;/a&gt;.</source>
          <target state="translated">2番目の引数 &lt;code&gt;None&lt;/code&gt; は必須であるため、最初の引数は &lt;code&gt;start&lt;/code&gt; 引数として解釈され、 &lt;a href=&quot;https://docs.python.org/2/library/functions.html#slice&quot;&gt;それ以外の場合は &lt;code&gt;stop&lt;/code&gt; 引数になります&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="596e5324916e7331fb73503433bce1ac5233475a" translate="yes" xml:space="preserve">
          <source>The second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment:</source>
          <target state="translated">スライス代入の第二のルールは、上にもありますが、スライスインデキシングによって返されるリストのどの部分であっても、スライス代入によって変更される部分と同じであるということです。</target>
        </trans-unit>
        <trans-unit id="e952b134f12b0ea29603efb0b559bc9cc9ad704f" translate="yes" xml:space="preserve">
          <source>The slicing operator &lt;code&gt;[]&lt;/code&gt; is actually being used in the above code with a &lt;code&gt;slice()&lt;/code&gt; object using the &lt;code&gt;:&lt;/code&gt; notation (which is only valid within &lt;code&gt;[]&lt;/code&gt;), i.e.:</source>
          <target state="translated">上記のコードでは、 &lt;code&gt;slice()&lt;/code&gt; 演算子 &lt;code&gt;[]&lt;/code&gt; は実際には &lt;code&gt;:&lt;/code&gt; ()表記（ &lt;code&gt;[]&lt;/code&gt; 内でのみ有効）を使用して、 slice（）オブジェクトで使用されています。</target>
        </trans-unit>
        <trans-unit id="e691224537259b930d7e6fe4624c31eea62f2d85" translate="yes" xml:space="preserve">
          <source>The thing to remember about negative step is that &lt;code&gt;stop&lt;/code&gt; is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. &lt;code&gt;'abcde'[1:-2][::-1]&lt;/code&gt; slices off one char from left, two from right, then reverses. (See also &lt;a href=&quot;http://www.python.org/dev/peps/pep-0322/&quot;&gt;&lt;code&gt;reversed()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">否定的なステップについて覚えておくべきことは、それが高いか低いかにかかわらず、 &lt;code&gt;stop&lt;/code&gt; は常に除外された端であることです。 同じスライスを反対の順序で使用したい場合は、逆に個別に行う方がはるかにクリーンです。たとえば、 &lt;code&gt;'abcde'[1:-2][::-1]&lt;/code&gt; は、左から1文字、右から2文字をスライスしてから逆にします。 （ &lt;a href=&quot;http://www.python.org/dev/peps/pep-0322/&quot;&gt; &lt;code&gt;reversed()&lt;/code&gt; &lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="77887242adef23e77fb02d89d877a784f02e2b36" translate="yes" xml:space="preserve">
          <source>The third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned:</source>
          <target state="translated">スライス代入の第三のルールは、代入されたリスト(iterable)は同じ長さである必要はありません。</target>
        </trans-unit>
        <trans-unit id="29855a6656d9eb287192ae5bff65ab56fdd630e5" translate="yes" xml:space="preserve">
          <source>The trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around &lt;em&gt;indexing&lt;/em&gt; an empty slice:</source>
          <target state="translated">慣れるのが最も難しい部分は、空のスライスへの割り当てです。 ヒューリスティック1と2を使用すると、空のスライスに&lt;em&gt;インデックスを付ける&lt;/em&gt;ことが簡単になります。</target>
        </trans-unit>
        <trans-unit id="4443911b7fa6e0ec19af60b9f6f8c54543309dbe" translate="yes" xml:space="preserve">
          <source>The very first thing that confuses Python learners is that &lt;strong&gt;an index can be negative!&lt;/strong&gt;
Don't panic: &lt;strong&gt;a negative index means count backwards.&lt;/strong&gt;</source>
          <target state="translated">Python学習者を混乱させる最初のことは&lt;strong&gt;、インデックスが負になる可能性&lt;/strong&gt;がある&lt;strong&gt;ということです！&lt;/strong&gt; パニックにならないでください： &lt;strong&gt;負のインデックスは逆数を意味します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc233fdd4b1aa1d0eec08f781b67af8b6d1de6f5" translate="yes" xml:space="preserve">
          <source>Then the negative indexing just needs you to add the length of the string to the negative indices to understand it.</source>
          <target state="translated">そうすると、負のインデックスは文字列の長さを負のインデックスに足すだけで理解できるようになります。</target>
        </trans-unit>
        <trans-unit id="849becd57d4d9dfce3e88751e6e091a0dece7725" translate="yes" xml:space="preserve">
          <source>Then, we may need to apply the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; - the default then for &lt;code&gt;start&lt;/code&gt; is calculated as the upper bound when &lt;code&gt;step&lt;/code&gt; is negative:</source>
          <target state="translated">次に、 &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; デフォルトを適用する必要がある場合があります。 &lt;code&gt;step&lt;/code&gt; が負の場合、 &lt;code&gt;start&lt;/code&gt; のデフォルトは上限として計算されます。</target>
        </trans-unit>
        <trans-unit id="b7d7ff65eee8f921208cc372c6ebb7dfee9bb661" translate="yes" xml:space="preserve">
          <source>There are some weird consequences to the &quot;once you're done, you're done&quot; rule:</source>
          <target state="translated">終わったら終わり」というルールには、おかしな結果になることがあります。</target>
        </trans-unit>
        <trans-unit id="d9a00425fdfcba9c3b6367238a922973214a9b04" translate="yes" xml:space="preserve">
          <source>There is also the &lt;code&gt;step&lt;/code&gt; value, which can be used with any of the above:</source>
          <target state="translated">上記のいずれかで使用できる &lt;code&gt;step&lt;/code&gt; 値もあります。</target>
        </trans-unit>
        <trans-unit id="8748ae39a14aa6c556cf400a604d76f7a5986f03" translate="yes" xml:space="preserve">
          <source>This can come in handy sometimes, but it can also lead to somewhat strange behavior:</source>
          <target state="translated">これはたまに重宝することもありますが、なんとなくおかしな行動に出てしまうこともあります。</target>
        </trans-unit>
        <trans-unit id="096585dfd11ee121086fdfe39adc2486eb298a85" translate="yes" xml:space="preserve">
          <source>This function takes a Python object and optional parameters for slicing and returns the start, stop, step, and slice length for the requested slice.</source>
          <target state="translated">この関数は、Pythonオブジェクトとスライス用のオプションのパラメータを受け取り、要求されたスライスの開始、停止、ステップ、スライス長を返します。</target>
        </trans-unit>
        <trans-unit id="5c019865eaefe89398d12a470966b9e731ebcceb" translate="yes" xml:space="preserve">
          <source>This is how I teach slices to newbies:</source>
          <target state="translated">初心者にはこうやってスライスを教えています。</target>
        </trans-unit>
        <trans-unit id="93ec6623e85643a7f24c84166f00188e862c3121" translate="yes" xml:space="preserve">
          <source>This is just for some extra info...
Consider the list below</source>
          <target state="translated">これは、いくつかの余分な情報のためだけに...以下のリストを考慮してください。</target>
        </trans-unit>
        <trans-unit id="2f3bd8ad9ced207179166369787553277fa774f3" translate="yes" xml:space="preserve">
          <source>This is the diagram:</source>
          <target state="translated">このような図になっています。</target>
        </trans-unit>
        <trans-unit id="30363f59507d9db8769972ab941783b864dbd2ab" translate="yes" xml:space="preserve">
          <source>This is the intelligence that is present behind slices. Since Python has an built-in function called slice, you can pass some parameters and check how smartly it calculates missing parameters.</source>
          <target state="translated">これがスライスの背後にあるインテリジェンスです。Pythonにはsliceという関数が組み込まれているので、いくつかのパラメータを渡して、欠落しているパラメータをどれだけスマートに計算してくれるかを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="d57f5dd395014f54497c19cddb5a2ce5c7ea7a57" translate="yes" xml:space="preserve">
          <source>This may also clarify the difference between slicing and indexing.</source>
          <target state="translated">これでスライスとインデックスの違いも明確になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b95f0acc0a5d079ab45b81544212226023725e34" translate="yes" xml:space="preserve">
          <source>This pretty property tells me that &lt;code&gt;lst[start:end]&lt;/code&gt; does not contain the &lt;code&gt;end&lt;/code&gt;-th item because it is in &lt;code&gt;lst[end:]&lt;/code&gt;.</source>
          <target state="translated">このかなりのプロパティは、 &lt;code&gt;lst[end:]&lt;/code&gt; ため、 &lt;code&gt;lst[start:end]&lt;/code&gt; はend-番目のアイテムが含まれていないことを示しています。</target>
        </trans-unit>
        <trans-unit id="8007629ae4bd6492e6ac3709a0f6817d52e38741" translate="yes" xml:space="preserve">
          <source>This way, I can think of &lt;code&gt;a[-4:-6:-1]&lt;/code&gt; as &lt;code&gt;a(-6,-4]&lt;/code&gt; in interval terminology.</source>
          <target state="translated">このように、私は &lt;code&gt;a[-4:-6:-1]&lt;/code&gt; をインターバル用語で &lt;code&gt;a(-6,-4]&lt;/code&gt; と考えることができます。</target>
        </trans-unit>
        <trans-unit id="88160c485e5bf5fb043177dc6d2bf96217e61ab0" translate="yes" xml:space="preserve">
          <source>This works for me anyway...</source>
          <target state="translated">これはとにかく私には効きます...。</target>
        </trans-unit>
        <trans-unit id="36a968ddf7619f1775f5b9341d45ab5c6d7d9f33" translate="yes" xml:space="preserve">
          <source>Thus a negative slice will change the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;!</source>
          <target state="translated">したがって、負のスライスは、 &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; デフォルトを変更します！</target>
        </trans-unit>
        <trans-unit id="6c35d5a48cbaacaa30e85a96cdc7b46a6bf157e1" translate="yes" xml:space="preserve">
          <source>Till now you have picked boxes continuously. But sometimes you need to pick up discretely. For example, you can pick up every second box. You can even pick up every third box from the end. This value is called step size. This represents the gap between your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa.</source>
          <target state="translated">今までは連続して箱を拾っていましたが、時にはバラバラに拾う必要があります。しかし、時にはバラバラに拾わなければならないこともあります。例えば、2つ目の箱ごとに拾うこともできます。端から3つ目の箱を拾うこともできます。この値をステップサイズといいます。これは、連続して拾ってくる箱の間隔を表します。箱を最初から最後まで拾う場合はステップサイズを正の値にし、その逆の場合はステップサイズを正の値にします。</target>
        </trans-unit>
        <trans-unit id="31ee61905e41466bdf813b3f8668d410b0e1fa58" translate="yes" xml:space="preserve">
          <source>To begin with, let's define a few terms:</source>
          <target state="translated">まずは、いくつかの用語を定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="2e1c54513da531934e461b5f4aa70c3c39a3e784" translate="yes" xml:space="preserve">
          <source>To make it simple, remember &lt;strong&gt;slice has only one form：&lt;/strong&gt;</source>
          <target state="translated">簡単にするために、 &lt;strong&gt;スライスには1つの形式しかない&lt;/strong&gt;ことに&lt;strong&gt;注意してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6133370c4351e43ebcb470ed39b01c2df88aa87a" translate="yes" xml:space="preserve">
          <source>To me, this notation needs a bit of picking up.</source>
          <target state="translated">私にとっては、この表記には少し手を加える必要があります。</target>
        </trans-unit>
        <trans-unit id="427ca464e82784a054828caeff41890bcf767d80" translate="yes" xml:space="preserve">
          <source>To retrieve a subset of elements, the start and stop positions need to be defined.</source>
          <target state="translated">要素のサブセットを取得するには、開始位置と停止位置を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="8e7a6a811c35a7adca15b7530f42f47e0dda5845" translate="yes" xml:space="preserve">
          <source>To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;implement the &lt;code&gt;__getitem__&lt;/code&gt; method of the sequence, according to the Python data model&lt;/a&gt;.)</source>
          <target state="translated">それをサポートするシーケンスでスライス表記を使用するには、シーケンスに続く角括弧に少なくとも1つのコロンを含める必要があります（ &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;Pythonデータモデルによれば、&lt;/a&gt;実際にはシーケンスの &lt;code&gt;__getitem__&lt;/code&gt; メソッドを実装しています）。</target>
        </trans-unit>
        <trans-unit id="0e7a206b9021aa8d0ea3e3c6e22e9c2a9fd3b850" translate="yes" xml:space="preserve">
          <source>Understanding index assignment is very important.</source>
          <target state="translated">インデックスの割り当てを理解することは非常に重要です。</target>
        </trans-unit>
        <trans-unit id="eb8117520c3958acd43c0f8e454eeec3f534d349" translate="yes" xml:space="preserve">
          <source>Understanding slice notation</source>
          <target state="translated">スライス表記を理解する</target>
        </trans-unit>
        <trans-unit id="10c5a38a7a014349bab2658d201f411e1780237b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;step&lt;/code&gt; provides a useful trick to reverse a collection in Python:</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; を使用すると、Pythonでコレクションを元に戻すための便利なトリックが提供されます。</target>
        </trans-unit>
        <trans-unit id="625b0998df7fa1a8b226d789e201ac2c633e1b85" translate="yes" xml:space="preserve">
          <source>Using a negative step reverses the interpretation of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">負のステップを使用すると、 &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;end&lt;/code&gt; 解釈が逆になります</target>
        </trans-unit>
        <trans-unit id="62654d2560fca6df984a34445f5e3dec93d4d93b" translate="yes" xml:space="preserve">
          <source>What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride.</source>
          <target state="translated">いつもうまくいくのは、文字やスロットで考えて、半開きの間隔でインデックスを使うことです-正のストライドの場合は右開き、負のストライドの場合は左開きです。</target>
        </trans-unit>
        <trans-unit id="526db1adfef28b92b75500e179ee7473e39b4025" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;step&lt;/code&gt; is negative, the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; change</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; が負の場合、 &lt;code&gt;start&lt;/code&gt; と &lt;code&gt;stop&lt;/code&gt; デフォルトが変更されます</target>
        </trans-unit>
        <trans-unit id="2c8d0413ebb06c76b410bc829582598046a90e73" translate="yes" xml:space="preserve">
          <source>When I see this, I read the part in the brackets as &quot;9th from the end, to the end.&quot; (Actually, I abbreviate it mentally as &quot;-9, on&quot;)</source>
          <target state="translated">これを見ていると、カッコの中の部分を &quot;最後から9番目、最後まで &quot;と読んでしまいます。(実際には、精神的には&quot;-9,on &quot;と略しています)</target>
        </trans-unit>
        <trans-unit id="6847d5ecc89aafb251c20bc69d5137967a12634d" translate="yes" xml:space="preserve">
          <source>When slicing from the start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose:</source>
          <target state="translated">最初からスライスする場合はゼロインデックスを省略し、最後までスライスする場合は冗長なので最後のインデックスを省略しても構わないので、冗長にならないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="0331d52f669a9d089e322197c2a42b467d18a25b" translate="yes" xml:space="preserve">
          <source>When slicing, if you leave out any parameter, Python tries to figure it out automatically.</source>
          <target state="translated">スライスするときにパラメータを省略すると、Pythonは自動的にそれを把握しようとします。</target>
        </trans-unit>
        <trans-unit id="ec05e68a3474403744db580556c5b4b5147a48ab" translate="yes" xml:space="preserve">
          <source>When using a negative step, notice that the answer is shifted to the right by 1.</source>
          <target state="translated">負のステップを使用する場合は、答えが1だけ右にずれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d52f5e951410da3205e348d328fbec3fed74bc94" translate="yes" xml:space="preserve">
          <source>When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range:</source>
          <target state="translated">a:b:c]と言うと、cの符号(前方か後方か)によって、aで始まりbで終わる(b番目のインデックスの要素を除く)と言っていることになります。上記のインデックスルールを使用して、この範囲内の要素のみを見つけることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="60ffa2bfa59ad91cfa5b5fac46b9f1af335ca27a" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;:&lt;/code&gt;-based notation is very helpful for simple slicing, the explicit use of &lt;code&gt;slice()&lt;/code&gt; objects simplifies the programmatic generation of slicing.</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; ベースの表記は単純なスライスに非常に役立ちますが、 &lt;code&gt;slice()&lt;/code&gt; オブジェクトを明示的に使用すると、プログラムによるスライスの生成が簡単になります。</target>
        </trans-unit>
        <trans-unit id="1fac29e5b50e4050ea0c9107b01d2b1be0ad4b52" translate="yes" xml:space="preserve">
          <source>Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.</source>
          <target state="translated">Wiki Pythonには、インデックス化とスライスを明確に区別するこの素晴らしい画像があります。</target>
        </trans-unit>
        <trans-unit id="dc7857679c446d31b3fa48d4d430634f0052baba" translate="yes" xml:space="preserve">
          <source>With extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon.</source>
          <target state="translated">拡張インデックス構文では、値の範囲を取得します。例えば、すべての値をコロンで取得します。</target>
        </trans-unit>
        <trans-unit id="48850a7b49c3ba2cdae5d4c04076f27217921200" translate="yes" xml:space="preserve">
          <source>With slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number.</source>
          <target state="translated">スライシングでは、一度終わったら終わりです。Pythonでは、負の数を使って明示的に要求しない限り、負のストライドは得られません。</target>
        </trans-unit>
        <trans-unit id="8e6854e86dbd642a89919deb5004ced1375069af" translate="yes" xml:space="preserve">
          <source>X is the index of the first element you want.</source>
          <target state="translated">Xは欲しい最初の要素のインデックスです。</target>
        </trans-unit>
        <trans-unit id="1caf266993cb78b65a51c14f80f90f52a48c1ad0" translate="yes" xml:space="preserve">
          <source>Y is the index of the first element you &lt;em&gt;don't&lt;/em&gt; want.</source>
          <target state="translated">Yは、不要な最初の要素のインデックスです。</target>
        </trans-unit>
        <trans-unit id="37c763665adfe6c32f74ceb3ab85198ed95e14f3" translate="yes" xml:space="preserve">
          <source>You can also use slice assignment to remove one or more elements from a list:</source>
          <target state="translated">また、スライス代入を使用して、リストから1つ以上の要素を削除することもできます。</target>
        </trans-unit>
        <trans-unit id="f6537afebf0730bd8d23b3fe9847bf52f1415c3b" translate="yes" xml:space="preserve">
          <source>You can even pick up the first three boxes or the last two boxes or all boxes between 1 and 4. So, you can pick any set of boxes if you know the beginning and ending. These positions are called start and stop positions.</source>
          <target state="translated">最初の3つの箱、最後の2つの箱、または1から4までのすべての箱を選ぶこともできます。つまり、始点と終点が分かっていれば、どのような箱でも拾うことができます。これらの位置を開始位置と停止位置と呼びます。</target>
        </trans-unit>
        <trans-unit id="c778f916c05737b62b181e6441afcd1a4fe8b894" translate="yes" xml:space="preserve">
          <source>You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;stop&lt;/em&gt;, and for the &lt;em&gt;step&lt;/em&gt;, you simply decrement your index. This example is &lt;a href=&quot;https://docs.python.org/2/tutorial/introduction.html&quot;&gt;from the documentation's tutorial&lt;/a&gt;, but I've modified it slightly to indicate which item in a sequence each index references:</source>
          <target state="translated">これらの正または負の数のいずれかを作成できます。 正の数の意味は簡単ですが、Pythonのインデックスと同様に、負の数の場合は、 &lt;em&gt;start&lt;/em&gt;と&lt;em&gt;stopの&lt;/em&gt;末尾から逆方向にカウントし、 &lt;em&gt;stepの&lt;/em&gt;場合は、インデックスをデクリメントします。 この例は&lt;a href=&quot;https://docs.python.org/2/tutorial/introduction.html&quot;&gt;ドキュメントのチュートリアルからの&lt;/a&gt;ものですが、各インデックスが参照するシーケンス内のアイテムを示すように少し変更しました。</target>
        </trans-unit>
        <trans-unit id="9b7644b509b2bf8e1ff27f855c7f83b37789181c" translate="yes" xml:space="preserve">
          <source>You can run this script and experiment with it, below is some samples that I got from the script.</source>
          <target state="translated">このスクリプトを実行して実験することができます。</target>
        </trans-unit>
        <trans-unit id="64faa3902ada5ca110aa668c8de78a324815760c" translate="yes" xml:space="preserve">
          <source>You can then pass the slice object to your sequence:</source>
          <target state="translated">その後、スライスオブジェクトをシーケンスに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="195e61f26a2fef8e34f3db23bd78fcb41bfedb3e" translate="yes" xml:space="preserve">
          <source>You made a cut &lt;strong&gt;before&lt;/strong&gt; the element with index &lt;code&gt;2&lt;/code&gt; and another cut &lt;strong&gt;before&lt;/strong&gt; the element with index &lt;code&gt;5&lt;/code&gt;. So the result will be a slice between those two cuts, a list &lt;code&gt;['T', 'H', 'O']&lt;/code&gt;.</source>
          <target state="translated">インデックス &lt;code&gt;2&lt;/code&gt; の要素の&lt;strong&gt;前&lt;/strong&gt;にカットを作成し、インデックス &lt;code&gt;5&lt;/code&gt; の要素の&lt;strong&gt;前に&lt;/strong&gt;別のカットを作成しました。 したがって、結果はこれら2つのカットの間のスライス、リスト &lt;code&gt;['T', 'H', 'O']&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="89d9115fa306118ea0f00933e8378ed5c6878642" translate="yes" xml:space="preserve">
          <source>You may find it useful to separate forming the slice from passing it to the &lt;code&gt;list.__getitem__&lt;/code&gt; method (&lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;that's what the square brackets do&lt;/a&gt;). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing.</source>
          <target state="translated">&lt;code&gt;list.__getitem__&lt;/code&gt; メソッドに渡すことからスライスを形成することを分離することが役立つかもしれません（ &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;角括弧が行うことです&lt;/a&gt; ）。 あなたがそれに慣れていない場合でも、コードを読みやすくするので、コードを読む必要のある他の人があなたが何をしているかをより簡単に理解できます。</target>
        </trans-unit>
        <trans-unit id="8e3e016f8f3879b55e19d0fb4c4a1a15482a3faa" translate="yes" xml:space="preserve">
          <source>a b &lt;strong&gt;[&lt;/strong&gt; c d e f g h &lt;strong&gt;]&lt;/strong&gt; i j</source>
          <target state="translated">ab &lt;strong&gt;[&lt;/strong&gt; cdefgh &lt;strong&gt;]&lt;/strong&gt; ij</target>
        </trans-unit>
        <trans-unit id="a604aec6cdc49c95cd2d0c53292ad902a479d32d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;stop&lt;/code&gt;, the lower bound:</source>
          <target state="translated">そして、下限、下限：</target>
        </trans-unit>
        <trans-unit id="631cab8239639a1208a15258a7f7aeda4d018888" translate="yes" xml:space="preserve">
          <source>and here is how it works:</source>
          <target state="translated">と、こんな感じです。</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">そして今。</target>
        </trans-unit>
        <trans-unit id="ce39fead1872adb72fba2b688bc7e4b8311fc7f4" translate="yes" xml:space="preserve">
          <source>and to substitute the defaults (actually when &lt;code&gt;step&lt;/code&gt; is negative, &lt;code&gt;stop&lt;/code&gt;'s default is &lt;code&gt;-len(my_list) - 1&lt;/code&gt;, so &lt;code&gt;None&lt;/code&gt; for stop really just means it goes to whichever end step takes it to):</source>
          <target state="translated">デフォルトを置き換えるには（実際に &lt;code&gt;step&lt;/code&gt; が負の場合、 &lt;code&gt;stop&lt;/code&gt; のデフォルトは &lt;code&gt;-len(my_list) - 1&lt;/code&gt; 。したがって、stopの &lt;code&gt;None&lt;/code&gt; は 、実際には、終了ステップが実行するいずれかのステップに進むことを意味します）：</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">に相当します。</target>
        </trans-unit>
        <trans-unit id="1110fd3a6c30458a698644d555d607d113a08279" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="d9adbb8529fa7bf42a21e2483f8aa574d755b96e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;l&lt;/code&gt; is a collection, &lt;code&gt;start&lt;/code&gt; is an inclusive index, &lt;code&gt;end&lt;/code&gt; is an exclusive index, and &lt;code&gt;step&lt;/code&gt; is a stride that can be used to take every &lt;em&gt;nth&lt;/em&gt; item in &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;l&lt;/code&gt; はコレクション、 &lt;code&gt;start&lt;/code&gt; は包括的インデックス、 &lt;code&gt;end&lt;/code&gt; は排他的インデックス、 &lt;code&gt;step&lt;/code&gt; はストライドで、 &lt;code&gt;l&lt;/code&gt; の &lt;em&gt;n番目&lt;/em&gt;ごとのアイテムを取得するために使用できます。</target>
        </trans-unit>
        <trans-unit id="1b8a81384b7443c9cbeaad37bd4704f2d8b3165a" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;l&lt;/code&gt; is some collection, &lt;code&gt;start&lt;/code&gt; is an inclusive index, and &lt;code&gt;end&lt;/code&gt; is an exclusive index.</source>
          <target state="translated">ここで、 &lt;code&gt;l&lt;/code&gt; はあるコレクション、 &lt;code&gt;start&lt;/code&gt; は包括的インデックス、 &lt;code&gt;end&lt;/code&gt; は排他的インデックスです。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
