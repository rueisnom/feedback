<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/509211">
    <body>
      <group id="509211">
        <trans-unit id="0aaf66473b71c5d42becc13d72b6f4ed70fedde3" translate="yes" xml:space="preserve">
          <source>(Python 3 gets a &lt;code&gt;list.copy&lt;/code&gt; and &lt;code&gt;list.clear&lt;/code&gt; method.)</source>
          <target state="translated">(Python 3 получает &lt;code&gt;list.copy&lt;/code&gt; и &lt;code&gt;list.clear&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="95d6f5f0e5758c7fa9092f862da9a2259661dfd4" translate="yes" xml:space="preserve">
          <source>1. Slice Notation</source>
          <target state="translated">1.Нотация срезов</target>
        </trans-unit>
        <trans-unit id="0f38c5a54db99d84e876f9b5eaa8720b9f3a9a26" translate="yes" xml:space="preserve">
          <source>2. Pitfalls</source>
          <target state="translated">2.подводные камни</target>
        </trans-unit>
        <trans-unit id="8862228b2902925878e3e9b09c1707ac7de719af" translate="yes" xml:space="preserve">
          <source>3. Examples</source>
          <target state="translated">3.Примеры .</target>
        </trans-unit>
        <trans-unit id="a3d3ca439ad803f892271df58e7d3c810355f6fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;end&lt;/code&gt;: last index, &lt;strong&gt;NOTE that &lt;code&gt;end&lt;/code&gt; index will not be included in the resulted slice&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; : последний индекс, &lt;strong&gt;ОБРАТИТЕ ВНИМАНИЕ, что &lt;code&gt;end&lt;/code&gt; индекс не будет включен в результирующий фрагмент&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6643606539da7a52988dc6cf4ceeadabfd2aeb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: an object that can be sliced</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; : объект, который можно разрезать</target>
        </trans-unit>
        <trans-unit id="1b4c4192b9f7af406c63bd0fcecb821e5c7cd6f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt;: first index to start iteration</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; : первый индекс для начала итерации</target>
        </trans-unit>
        <trans-unit id="f694d4d7856a4daa5fcd72c6329bb35f7a4a3b91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt;: pick element every &lt;code&gt;step&lt;/code&gt; index</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; : выбрать элемент индекс каждого &lt;code&gt;step&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31b0888c10f4ec32c43b2a524281bf1bc1307538" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A negative step means iterate the array backwards: from the end to start, with the end index included, and the start index excluded from the result.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Отрицательный шаг означает итерацию массива в обратном направлении: от конца к началу, с включенным индексом конца и индексом начала, исключенным из результата.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dd769027176645af5d46752c43bf60e2cbab996" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basic Slicing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Базовая нарезка&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03764b700c4114b7c7e0b1fc151ca8ee76b98522" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Python Figures Out Missing Parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как Python вычисляет недостающие параметры:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a8df44af93130aa47cf7708478946a1e899c9b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: when step is negative, the default value for &lt;code&gt;start&lt;/code&gt; is &lt;code&gt;len(s)&lt;/code&gt; (while &lt;code&gt;end&lt;/code&gt; does not equal to &lt;code&gt;0&lt;/code&gt;, because &lt;code&gt;s[::-1]&lt;/code&gt; contains &lt;code&gt;s[0]&lt;/code&gt;). For example:</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ&lt;/strong&gt; : когда шаг отрицателен, значением по умолчанию для &lt;code&gt;start&lt;/code&gt; является &lt;code&gt;len(s)&lt;/code&gt; (в то время как &lt;code&gt;end&lt;/code&gt; не равен &lt;code&gt;0&lt;/code&gt; , потому что &lt;code&gt;s[::-1]&lt;/code&gt; содержит &lt;code&gt;s[0]&lt;/code&gt; ). Например:</target>
        </trans-unit>
        <trans-unit id="a040621624a5c253662c247800c0317b88fdc6d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This post was originally written in my blog, &lt;em&gt;&lt;a href=&quot;https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html&quot;&gt;The Intelligence Behind Python Slices&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Этот пост изначально был написан в моем блоге &lt;em&gt;&lt;a href=&quot;https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html&quot;&gt;&amp;laquo;Интеллект за кусочками Python&amp;raquo;&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dd2468b43f8b0b0ef298ce86ccd65ed0c9f49ef9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Slicing With Step:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Нарезка с шагом:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fe67ddb4f6798a243fbf3c1c781e47c402b956c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Slicing can also be applied to multi-dimensional arrays.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Нарезка также может применяться к многомерным массивам.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54689a39c2f4af595b96d8fcee877e522e69fc2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TODO&lt;/strong&gt;: The code below had a bug with &quot;never go outside the sequence&quot; when abs(step)&amp;gt;1; I &lt;em&gt;think&lt;/em&gt; I patched it to be correct, but it's hard to understand.</source>
          <target state="translated">&lt;strong&gt;TODO&lt;/strong&gt; : В приведенном ниже коде была ошибка &amp;laquo;никогда не выходить за пределы последовательности&amp;raquo;, когда abs (step)&amp;gt; 1; Я &lt;em&gt;думаю, что&lt;/em&gt; я исправил это, чтобы быть правильным, но это трудно понять.</target>
        </trans-unit>
        <trans-unit id="120f2d378e6907d447c90878b70cfec95cfa80ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Understanding the difference between indexing and slicing:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Понимание разницы между индексированием и нарезкой:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c3618c39203bd4928667eb7837893a51d2c72ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;start:&lt;/strong&gt; the beginning index of the slice, it will include the element at this index unless it is the same as &lt;em&gt;stop&lt;/em&gt;, defaults to 0, i.e. the first index. If it's negative, it means to start &lt;code&gt;n&lt;/code&gt; items from the end.</source>
          <target state="translated">&lt;strong&gt;start:&lt;/strong&gt; начальный индекс среза, он будет включать в себя элемент с этим индексом, если он не совпадает со &lt;em&gt;стопом&lt;/em&gt; , по умолчанию равен 0, т.е. первый индекс. Если оно отрицательное, это означает, что нужно начинать &lt;code&gt;n&lt;/code&gt; пунктов с конца.</target>
        </trans-unit>
        <trans-unit id="3b0828277ef33d65b168b24d8f7acb52b6e97797" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;step:&lt;/strong&gt; the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse.</source>
          <target state="translated">&lt;strong&gt;шаг:&lt;/strong&gt; величина, на которую увеличивается индекс, по умолчанию равен 1. Если он отрицательный, вы разрезаете итеративное в обратном порядке.</target>
        </trans-unit>
        <trans-unit id="f4d542aea390972989442b2f47543ac47e2b208f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stop:&lt;/strong&gt; the ending index of the slice, it does &lt;em&gt;not&lt;/em&gt; include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.</source>
          <target state="translated">&lt;strong&gt;stop:&lt;/strong&gt; конечный индекс среза, он &lt;em&gt;не&lt;/em&gt; включает в себя элемент с этим индексом, по умолчанию длина отрезка последовательности, то есть до конца включительно.</target>
        </trans-unit>
        <trans-unit id="227dd9dbc0108dfd4661edff64d2fe881992bffb" translate="yes" xml:space="preserve">
          <source>After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a &lt;code&gt;for&lt;/code&gt; loop...</source>
          <target state="translated">После небольшого использования я понимаю, что самое простое описание - это то же самое, что и аргументы в цикле &lt;code&gt;for&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="ee7829458bdd9d9fb9e4d5d3a2fb33291ce2cf6c" translate="yes" xml:space="preserve">
          <source>Also, note that negative values for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are relative to the end of the list and computed in the example above by &lt;code&gt;given_index + a.shape[0]&lt;/code&gt;.</source>
          <target state="translated">Также обратите внимание, что отрицательные значения для &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;end&lt;/code&gt; относятся к концу списка и вычисляются в приведенном выше примере с помощью &lt;code&gt;given_index + a.shape[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70a021868ab3df3f88ae6899b164851777cd1b14" translate="yes" xml:space="preserve">
          <source>And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:</source>
          <target state="translated">И пара вещей,которые не были сразу очевидны для меня,когда я впервые увидел синтаксис нарезки:</target>
        </trans-unit>
        <trans-unit id="d105f3bd854548cc6f0bd3800349d324c615cb05" translate="yes" xml:space="preserve">
          <source>And clearing them is with:</source>
          <target state="translated">И их очистка-вместе с ними:</target>
        </trans-unit>
        <trans-unit id="d25005772475e3ef4f540f81cb570f204b58a0d9" translate="yes" xml:space="preserve">
          <source>And if you wanted, for some reason, every second item in the reversed sequence:</source>
          <target state="translated">И если бы вы захотели,по какой-то причине,каждый второй элемент в перевернутой последовательности:</target>
        </trans-unit>
        <trans-unit id="77bb433c739e5798f1c99c633d2b911edd356fc6" translate="yes" xml:space="preserve">
          <source>And recall that there are defaults for &lt;em&gt;start&lt;/em&gt;, &lt;em&gt;stop&lt;/em&gt;, and &lt;em&gt;step&lt;/em&gt;, so to access the defaults, simply leave out the argument.</source>
          <target state="translated">И помните, что существуют значения по умолчанию для &lt;em&gt;start&lt;/em&gt; , &lt;em&gt;stop&lt;/em&gt; и &lt;em&gt;step&lt;/em&gt; , поэтому для доступа к значениям по умолчанию просто пропустите аргумент.</target>
        </trans-unit>
        <trans-unit id="8d114526a29d613405e6408309b436a186ca0d52" translate="yes" xml:space="preserve">
          <source>And then once you've seen that, slice assignment to the empty slice makes sense too:</source>
          <target state="translated">И как только вы это увидите,назначение кусочков на пустой кусочек тоже имеет смысл:</target>
        </trans-unit>
        <trans-unit id="5de2b62e17f6a84350d6fbe4ce6b42edec436e54" translate="yes" xml:space="preserve">
          <source>Another heuristic is, &quot;for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning&quot;</source>
          <target state="translated">Другой эвристический метод:&quot;для любого кусочка заменить начало на ноль,применить предыдущий эвристический метод,чтобы получить конец списка,затем отсчитать первое число обратно,чтобы отрубить элементы от начала&quot;.</target>
        </trans-unit>
        <trans-unit id="faa6734c0c057ce07a0df52181d494e9f022c4d5" translate="yes" xml:space="preserve">
          <source>Another import thing: &lt;strong&gt;all &lt;code&gt;start&lt;/code&gt;,&lt;code&gt;end&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt; can be omitted!&lt;/strong&gt; And if they are omitted, their default value will be used: &lt;code&gt;0&lt;/code&gt;,&lt;code&gt;len(s)&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt; accordingly.</source>
          <target state="translated">Еще одна важная вещь: &lt;strong&gt;все &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; можно пропустить!&lt;/strong&gt; И если они опущены, будет использоваться их значение по умолчанию: &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;len(s)&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="7af9ada0982e5ec6222baca6341c1c5cff1f46c9" translate="yes" xml:space="preserve">
          <source>Any of them are optional:</source>
          <target state="translated">Любой из них необязателен:</target>
        </trans-unit>
        <trans-unit id="9e68e1c90bdbb11b1d0236fe65983d5f0f2685f0" translate="yes" xml:space="preserve">
          <source>As a general rule, writing code with a lot of hardcoded index values leads to a readability
and maintenance mess. For example, if you come back to the code a year later, you&amp;rsquo;ll
look at it and wonder what you were thinking when you wrote it. The solution shown
is simply a way of more clearly stating what your code is actually doing.
In general, the built-in slice() creates a slice object that can be used anywhere a slice
is allowed. For example:</source>
          <target state="translated">Как правило, написание кода с большим количеством жестко закодированных значений индекса приводит к беспорядку читаемости и обслуживания. Например, если вы вернетесь к коду год спустя, вы посмотрите на него и удивитесь, о чем вы думали, когда писали его. Показанное решение - просто способ более четко определить, что на самом деле делает ваш код. Как правило, встроенный slice () создает объект слайса, который можно использовать везде, где разрешен слайс. Например:</target>
        </trans-unit>
        <trans-unit id="a5d1179754e1ec07fb3a1e15a9fe95c4e93756e2" translate="yes" xml:space="preserve">
          <source>As you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element.</source>
          <target state="translated">Как видите,определение стопа возвращает только один элемент.Так как по умолчанию start равен none,это означает,что возвращается только один элемент.</target>
        </trans-unit>
        <trans-unit id="10ddbc6f0ff07831197cae7c89a5e4feb5e47439" translate="yes" xml:space="preserve">
          <source>Backing up a little bit, what happens when you keep going with our procession of counting up the slice beginning?</source>
          <target state="translated">Немного назад,что случится,когда вы продолжите нашу процессию подсчета начала ломтиков?</target>
        </trans-unit>
        <trans-unit id="a0a44e8c2753c157919dea94666ab53b99900c6e" translate="yes" xml:space="preserve">
          <source>Be surprised: &lt;strong&gt;slice does not raise an IndexError when the index is out of range!&lt;/strong&gt;</source>
          <target state="translated">Будьте удивлены: &lt;strong&gt;слайс не вызывает ошибку IndexError, когда индекс выходит за пределы диапазона!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51688e4ac0a45d12d7f9bb788db79cb941448aea" translate="yes" xml:space="preserve">
          <source>Begin from &lt;code&gt;start&lt;/code&gt;, increment by &lt;code&gt;step&lt;/code&gt;, do not reach &lt;code&gt;stop&lt;/code&gt;.  Very simple.</source>
          <target state="translated">Начните с &lt;code&gt;start&lt;/code&gt; , шаг за &lt;code&gt;step&lt;/code&gt; , не достигайте &lt;code&gt;stop&lt;/code&gt; . Очень просто.</target>
        </trans-unit>
        <trans-unit id="4b2092c15e09d1d0a69d863b94fdb3e35c63e659" translate="yes" xml:space="preserve">
          <source>Below is the example usage:</source>
          <target state="translated">Ниже приведен пример использования:</target>
        </trans-unit>
        <trans-unit id="2b5c42838b863b4b8a4537944505370085a2f395" translate="yes" xml:space="preserve">
          <source>Below is the text of my original answer. It has been useful to many people, so I didn't want to delete it.</source>
          <target state="translated">Ниже текст моего первоначального ответа.Он был полезен многим людям,поэтому я не хотел его удалять.</target>
        </trans-unit>
        <trans-unit id="c47e4145f6e8d534763f4eeb46a2b86362f0690b" translate="yes" xml:space="preserve">
          <source>Besides basic slicing, it is also possible to apply the following notation:</source>
          <target state="translated">Кроме основной нарезки,можно также применить следующую нотацию:</target>
        </trans-unit>
        <trans-unit id="0b189ce87053a4a6f9151c04b8051585e6e4e7ff" translate="yes" xml:space="preserve">
          <source>Blank values are defaulted as follows: &lt;code&gt;[+0:-0:1]&lt;/code&gt;.</source>
          <target state="translated">Пустые значения по умолчанию следующие: &lt;code&gt;[+0:-0:1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ab9f5780bbd8ad36625e87ca02af9b8bf9361df" translate="yes" xml:space="preserve">
          <source>But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the &lt;code&gt;end&lt;/code&gt;-th element.</source>
          <target state="translated">Но иногда возникает сомнение, и мой мозг просит заверить, что он не содержит &lt;code&gt;end&lt;/code&gt; элемента.</target>
        </trans-unit>
        <trans-unit id="25e3d76337cea9e9d631c334c54bbcb275c06f0f" translate="yes" xml:space="preserve">
          <source>But this range continues in both directions infinitely:</source>
          <target state="translated">Но этот диапазон продолжается в обоих направлениях бесконечно:</target>
        </trans-unit>
        <trans-unit id="313813cd850a6b775a1fb26d3d9c84054d7263b9" translate="yes" xml:space="preserve">
          <source>But you can pass in a negative integer, and the list (or most other standard slicables) will be sliced from the end to the beginning.</source>
          <target state="translated">Но вы можете пропустить отрицательное целое число,и список (или большинство других стандартных срезов)будет нарезан от конца до начала.</target>
        </trans-unit>
        <trans-unit id="78c9a2985c6c2db62af25652b536f68dff04e931" translate="yes" xml:space="preserve">
          <source>By default, when the &lt;code&gt;step&lt;/code&gt; argument is empty (or &lt;code&gt;None&lt;/code&gt;), it is assigned to &lt;code&gt;+1&lt;/code&gt;.</source>
          <target state="translated">По умолчанию, когда аргумент &lt;code&gt;step&lt;/code&gt; пуст (или &lt;code&gt;None&lt;/code&gt; ), ему присваивается &lt;code&gt;+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74e101616da42c9f860f041e06e88cf3afc9af8d" translate="yes" xml:space="preserve">
          <source>Coming from other programming languages, that's when the common sense gets compromised. What are x and y?</source>
          <target state="translated">Если исходить из других языков программирования,то в этом случае здравый смысл нарушается.Что такое &quot;x&quot; и &quot;y&quot;?</target>
        </trans-unit>
        <trans-unit id="114f22f6d7079d292a7e78398094c20f332e1368" translate="yes" xml:space="preserve">
          <source>Confirming this in the source</source>
          <target state="translated">Подтвердить это в источнике</target>
        </trans-unit>
        <trans-unit id="3eb94acf98e91b224000fb69a7e7764bf5d24a8e" translate="yes" xml:space="preserve">
          <source>Create two lists to slice. The first is a numeric list from 1 to 9 (List A). The second is also a numeric list, from 0 to 9 (List B):</source>
          <target state="translated">Создайте два списка,чтобы нарезать их.Первый-это цифровой список от 1 до 9 (список A).Второй также является цифровым списком,от 0 до 9 (Список B):</target>
        </trans-unit>
        <trans-unit id="57856d05bb32d5be32788eb0692ff1468ddf3c07" translate="yes" xml:space="preserve">
          <source>Depending on your application, that might... or might not... be what you were hoping for there!</source>
          <target state="translated">В зависимости от вашего заявления,это может быть...или не быть...тем,на что вы надеялись!</target>
        </trans-unit>
        <trans-unit id="20f3af310b2b47de75d12e36f7756694568aec42" translate="yes" xml:space="preserve">
          <source>Don't worry about the &lt;code&gt;is None&lt;/code&gt; details - just remember that omitting &lt;code&gt;start&lt;/code&gt; and/or &lt;code&gt;stop&lt;/code&gt; always does the right thing to give you the whole sequence.</source>
          <target state="translated">Не беспокойтесь о деталях &lt;code&gt;is None&lt;/code&gt; - просто помните, что пропуски &lt;code&gt;start&lt;/code&gt; и / или &lt;code&gt;stop&lt;/code&gt; всегда дают правильную последовательность действий.</target>
        </trans-unit>
        <trans-unit id="6d6d1b284c6af28298538c5cdc0a7256d5d5f150" translate="yes" xml:space="preserve">
          <source>Easy way to reverse sequences!</source>
          <target state="translated">Легкий способ перевернуть последовательность!</target>
        </trans-unit>
        <trans-unit id="dec3b85ab5c8afe4bdcf9aa78a36bb7b04f5b4e2" translate="yes" xml:space="preserve">
          <source>Enumerating the possibilities allowed by the grammar:</source>
          <target state="translated">Перечисление возможностей,допустимых грамматикой:</target>
        </trans-unit>
        <trans-unit id="e2005c2f600247253cdd9b3a166cb5e388bbfb14" translate="yes" xml:space="preserve">
          <source>Explain Python's slice notation</source>
          <target state="translated">Объяснить нотацию ломтиков Пайтона</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="ad2d3fd5da36e4d1450b52434f65543e2c249274" translate="yes" xml:space="preserve">
          <source>Extended indexing syntax used for slicing is aList[start:stop:step]. The start argument and the step argument both default to none - the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by range(start, stop, step). Python 3.4 documentation.</source>
          <target state="translated">Расширенный синтаксис индексирования,используемый для нарезки,это aList[start:stop:step].По умолчанию аргумент start и аргумент step равны нулю-единственным требуемым аргументом является stop.Вы заметили,что это похоже на то,как диапазон использовался для определения списков A и B? Это связано с тем,что объект среза представляет собой набор индексов,заданных диапазоном (start,stop,step).Документация на Python 3.4.</target>
        </trans-unit>
        <trans-unit id="25a46e8db798e121dc4a998aaa52b7c9c2f4ec77" translate="yes" xml:space="preserve">
          <source>Extended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.</source>
          <target state="translated">Расширенное нарезание (запятыми и эллипсами)чаще всего используется только специальными структурами данных (например,NumPy);базовые последовательности их не поддерживают.</target>
        </trans-unit>
        <trans-unit id="2ce6a2c45d1f432b7017f6d8ad6c6f1f419ab941" translate="yes" xml:space="preserve">
          <source>Few other tricks for reversing the list:</source>
          <target state="translated">Несколько других трюков для изменения списка:</target>
        </trans-unit>
        <trans-unit id="53c11609ebb7eeb39c6ae1148df32803811abaf7" translate="yes" xml:space="preserve">
          <source>First, we will create a list of values to use in our slicing.</source>
          <target state="translated">Сначала мы создадим список значений для использования при нарезке.</target>
        </trans-unit>
        <trans-unit id="189f73dcf0d0e026377e4c161485f0bca4a39a7e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, negative values are interpreted as being relative to the end of the sequence.</source>
          <target state="translated">Для &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;end&lt;/code&gt; отрицательные значения интерпретируются как относящиеся к концу последовательности.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="ad09b9342bcb6da8bd5c7a868860d3b6440eb901" translate="yes" xml:space="preserve">
          <source>For those who don't know, you can create any substring from &lt;code&gt;azString&lt;/code&gt; using the notation &lt;code&gt;azString[x:y]&lt;/code&gt;</source>
          <target state="translated">Для тех, кто не знает, вы можете создать любую подстроку из &lt;code&gt;azString&lt;/code&gt; , используя обозначение &lt;code&gt;azString[x:y]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2d2d5928c54cd3be6435296e94075da9fefa553" translate="yes" xml:space="preserve">
          <source>Found this great table at &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</source>
          <target state="translated">Нашел эту отличную таблицу на &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="666ad671cbeba0a89e7c706687f77df7b879dbc2" translate="yes" xml:space="preserve">
          <source>From the diagram, I expect &lt;code&gt;a[-4,-6,-1]&lt;/code&gt; to be &lt;code&gt;yP&lt;/code&gt; but it is &lt;code&gt;ty&lt;/code&gt;.</source>
          <target state="translated">На диаграмме я ожидаю, &lt;code&gt;a[-4,-6,-1]&lt;/code&gt; будет &lt;code&gt;yP&lt;/code&gt; , но это &lt;code&gt;ty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="181af959e4f8d0fb4083b24c9a79dcab0d808777" translate="yes" xml:space="preserve">
          <source>Give your slices a descriptive name!</source>
          <target state="translated">Дайте Вашим кусочкам описательное имя!</target>
        </trans-unit>
        <trans-unit id="d8bca9c064390cb40eb6923b46c08e356cc9a63d" translate="yes" xml:space="preserve">
          <source>Given the pattern aList[start:stop], retrieve the first two elements from List A.</source>
          <target state="translated">Учитывая шаблон aList[start:stop],извлеките первые два элемента из списка A.</target>
        </trans-unit>
        <trans-unit id="f94faa9a2d2714420791cc753d22514493d014e9" translate="yes" xml:space="preserve">
          <source>Here is an example visualization of that ...</source>
          <target state="translated">Вот пример визуализации этого ...</target>
        </trans-unit>
        <trans-unit id="77b2dd3c3ff1e4885a243132aecac207f224e3f5" translate="yes" xml:space="preserve">
          <source>How Indexing Works</source>
          <target state="translated">Как работает индексирование</target>
        </trans-unit>
        <trans-unit id="6f1f32310474f8326626103969ab54a0b5070606" translate="yes" xml:space="preserve">
          <source>How Slicing Works</source>
          <target state="translated">Как работает нарезка</target>
        </trans-unit>
        <trans-unit id="3da40c095b10f44487cd4ccca0f47467d44aa681" translate="yes" xml:space="preserve">
          <source>However, using a negative value for &lt;code&gt;step&lt;/code&gt; could become very confusing. Moreover, in order to be &lt;a href=&quot;https://en.wiktionary.org/wiki/Pythonic#Adjective&quot;&gt;Pythonic&lt;/a&gt;, you should avoid using &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).</source>
          <target state="translated">Однако использование отрицательного значения для &lt;code&gt;step&lt;/code&gt; может стать очень запутанным. Кроме того, чтобы быть &lt;a href=&quot;https://en.wiktionary.org/wiki/Pythonic#Adjective&quot;&gt;Pythonic&lt;/a&gt; , вы должны избегать использования &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; и &lt;code&gt;step&lt;/code&gt; в одном срезе. В случае, если это требуется, рассмотрите возможность сделать это в двух заданиях (одно для нарезки, а другое для продвижения).</target>
        </trans-unit>
        <trans-unit id="4ad93a5dd4fcd6d7c940755502a6bc63d374feb4" translate="yes" xml:space="preserve">
          <source>However, you can't just assign some integers separated by colons to a variable. You need to use the slice object:</source>
          <target state="translated">Однако нельзя просто присвоить переменной несколько целых чисел,разделенных двоеточиями.Вам нужно использовать объект среза:</target>
        </trans-unit>
        <trans-unit id="aaa8f93b237e6d327bf33efc09bdaf86ccf36c81" translate="yes" xml:space="preserve">
          <source>I don't think that the &lt;a href=&quot;https://docs.python.org/3/tutorial/introduction.html#strings&quot;&gt;Python tutorial&lt;/a&gt; diagram (cited in various other answers) is good as this suggestion works for positive stride, but does not for a negative stride.</source>
          <target state="translated">Я не думаю, что &lt;a href=&quot;https://docs.python.org/3/tutorial/introduction.html#strings&quot;&gt;учебная&lt;/a&gt; схема Python (цитируемая в различных других ответах) хороша, поскольку это предложение работает для положительного шага, но не для отрицательного шага.</target>
        </trans-unit>
        <trans-unit id="c138ed3c54e5f033afa16fdbd5fccf8d39b80779" translate="yes" xml:space="preserve">
          <source>I find it easier to remember how it works, and then I can figure out any specific start/stop/step combination.</source>
          <target state="translated">Мне легче запомнить,как это работает,и тогда я смогу вычислить любую конкретную комбинацию стартового шага.</target>
        </trans-unit>
        <trans-unit id="ef399e0ded15774144fa63ae11d01aba3089469e" translate="yes" xml:space="preserve">
          <source>I had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt.</source>
          <target state="translated">Мне пришлось сесть и запустить несколько сценариев в поисках техники запоминания,которая поможет мне вспомнить,что такое x и y,и поможет мне правильно нарезать строки с первой попытки.</target>
        </trans-unit>
        <trans-unit id="c7d0e42afda61407f67326f1c6eb38abab198765" translate="yes" xml:space="preserve">
          <source>I hope this will help you to model the list in Python.</source>
          <target state="translated">Надеюсь,это поможет вам смоделировать список на Пайтоне.</target>
        </trans-unit>
        <trans-unit id="77b54aef5e492c40146cd9a6d0b499de291945d3" translate="yes" xml:space="preserve">
          <source>I like to encourage users to read the source as well as the documentation. The &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/sliceobject.c&quot;&gt;source code for slice objects and this logic is found here&lt;/a&gt;. First we determine if &lt;code&gt;step&lt;/code&gt; is negative:</source>
          <target state="translated">Мне нравится поощрять пользователей читать источник и документацию. &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/sliceobject.c&quot;&gt;Исходный код объектов слайса и эта логика находятся здесь&lt;/a&gt; . Сначала мы определяем, является ли &lt;code&gt;step&lt;/code&gt; отрицательным:</target>
        </trans-unit>
        <trans-unit id="5d3b3b36c387b5d0fc042b55acf61c2d549b5f7d" translate="yes" xml:space="preserve">
          <source>I need a good explanation (references are a plus) on Python's slice notation.</source>
          <target state="translated">Мне нужно хорошее объяснение (ссылки-плюс)нотации кусочка Python.</target>
        </trans-unit>
        <trans-unit id="ad507a3da03671c61941620ae7a2906912f4a37b" translate="yes" xml:space="preserve">
          <source>I personally think about it like a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">Я лично думаю об этом как о цикле:</target>
        </trans-unit>
        <trans-unit id="98382aeb1507eab72853d9ce777b3db6e8f02198" translate="yes" xml:space="preserve">
          <source>I use the &quot;an index points between elements&quot; method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:</source>
          <target state="translated">Я сам использую метод &quot;точки индекса между элементами&quot;,но один из способов его описания,который иногда помогает другим получить его,-это так:</target>
        </trans-unit>
        <trans-unit id="7c6fedebad3f718314d64d61745e8419abe48090" translate="yes" xml:space="preserve">
          <source>I want to add one &lt;em&gt;Hello, World!&lt;/em&gt; example that explains the basics of slices for the very beginners. It helped me a lot.</source>
          <target state="translated">Я хочу добавить один &lt;em&gt;Hello, World!&lt;/em&gt; Пример, объясняющий основы ломтиков для самых начинающих. Это мне очень помогло.</target>
        </trans-unit>
        <trans-unit id="152b4bcea4dcb6a08bc28ea6e60677690158dfe0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stride&lt;/code&gt; is negative, the ordering is changed a bit since we're counting down:</source>
          <target state="translated">Если &lt;code&gt;stride&lt;/code&gt; отрицательный, порядок немного меняется, так как мы ведем обратный отсчет:</target>
        </trans-unit>
        <trans-unit id="cd1befa8b487c0ecabed83a3de28c3d4c4a8dbce" translate="yes" xml:space="preserve">
          <source>If so, the lower bound is &lt;code&gt;-1&lt;/code&gt;  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this &lt;code&gt;-1&lt;/code&gt; is &lt;em&gt;different&lt;/em&gt; from a &lt;code&gt;-1&lt;/code&gt; that users may pass indexes in Python indicating the last item.)</source>
          <target state="translated">Если это так, то нижняя граница равна &lt;code&gt;-1&lt;/code&gt; ,что означает, что мы нарезаем весь путь вплоть до начала, а верхняя граница равна длине минус 1, что означает, что мы начинаем с конца. (Обратите внимание, что семантика этого &lt;code&gt;-1&lt;/code&gt; &lt;em&gt;отличается&lt;/em&gt; от &lt;code&gt;-1&lt;/code&gt; тем, что пользователи могут передавать индексы в Python, указывающие последний элемент.)</target>
        </trans-unit>
        <trans-unit id="2f065d470b215e663b57b87dd50c698f07db3377" translate="yes" xml:space="preserve">
          <source>If the index is out of range, Python will try its best to set the index to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;len(s)&lt;/code&gt; according to the situation. For example:</source>
          <target state="translated">Если индекс выходит за пределы диапазона, Python постарается установить для него значение &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;len(s)&lt;/code&gt; зависимости от ситуации. Например:</target>
        </trans-unit>
        <trans-unit id="8def849642c7353545fcda04de289db5103721fe" translate="yes" xml:space="preserve">
          <source>If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced:</source>
          <target state="translated">Если начальный и конечный индексы опускаются при выполнении операции присвоения,все содержимое коллекции будет заменено копией того,на что имеются ссылки:</target>
        </trans-unit>
        <trans-unit id="661ece95ee93a03aaa302b463dca836f55c6dd14" translate="yes" xml:space="preserve">
          <source>If you check the source code of &lt;a href=&quot;http://en.wikipedia.org/wiki/CPython&quot;&gt;CPython&lt;/a&gt;, you will find a function called PySlice_GetIndicesEx() which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python.</source>
          <target state="translated">Если вы проверите исходный код &lt;a href=&quot;http://en.wikipedia.org/wiki/CPython&quot;&gt;CPython&lt;/a&gt; , вы найдете функцию PySlice_GetIndicesEx (), которая вычисляет индексы для среза для любых заданных параметров. Вот логический эквивалент кода в Python.</target>
        </trans-unit>
        <trans-unit id="47b5bc36bf784848f762edafdff62074643233f8" translate="yes" xml:space="preserve">
          <source>If you feel negative indices in slicing is confusing, here's a very easy way to think about it: just replace the negative index with &lt;code&gt;len - index&lt;/code&gt;. So for example, replace -3 with &lt;code&gt;len(list) - 3&lt;/code&gt;.</source>
          <target state="translated">Если вы чувствуете, что отрицательные индексы в разрезании сбивают с толку, вот очень простой способ подумать об этом: просто замените отрицательный индекс на &lt;code&gt;len - index&lt;/code&gt; . Так, например, замените -3 на &lt;code&gt;len(list) - 3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa833ad31212b2a3b3d439a0e7c53b383e2b3ca5" translate="yes" xml:space="preserve">
          <source>If you have a slice instance s, you can get more information about it by looking at its
s.start, s.stop, and s.step attributes, respectively. For example:</source>
          <target state="translated">Если у Вас есть экземпляр среза s,Вы можете получить дополнительную информацию о нем,посмотрев на его атрибуты s.start,s.stop и s.step соответственно.Например:</target>
        </trans-unit>
        <trans-unit id="f3d97417ba0181b71f5aaffd104fe653cf71364a" translate="yes" xml:space="preserve">
          <source>If you omit the start and end index, you will make a copy of the collection:</source>
          <target state="translated">Если вы опустите начальный и конечный указатели,вы сделаете копию коллекции:</target>
        </trans-unit>
        <trans-unit id="f60db26cf6492e7fc7bbed6f90da520c3f57371b" translate="yes" xml:space="preserve">
          <source>If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list.</source>
          <target state="translated">Если ваш выбор a,b,и c позволяет накладываться на диапазон,указанный выше,при прохождении по правилам для a,b,c выше вы либо получите список с элементами (затронутыми во время прохождении),либо получите пустой список.</target>
        </trans-unit>
        <trans-unit id="f466c12bda6762ec7169a18df85f167e0081116f" translate="yes" xml:space="preserve">
          <source>Important Definitions</source>
          <target state="translated">Важные определения</target>
        </trans-unit>
        <trans-unit id="f2bb9ecf761b6e88e8102a7536ee8d44abe40249" translate="yes" xml:space="preserve">
          <source>In Python 2.7</source>
          <target state="translated">На Питоне 2.7</target>
        </trans-unit>
        <trans-unit id="90a6eb777e8cda542826e3c6334816f4f0ee8eb6" translate="yes" xml:space="preserve">
          <source>In Python, the most basic form for slicing is the following:</source>
          <target state="translated">На Питоне самая основная форма нарезки-это следующая:</target>
        </trans-unit>
        <trans-unit id="0ee248346d0af5cd683e4a36d0a440e60af3c740" translate="yes" xml:space="preserve">
          <source>In fact, compared to indexing, Python slicing is bizarrely error-proof:</source>
          <target state="translated">На самом деле,по сравнению с индексацией,нарезка на питон причудливо защищена от ошибок:</target>
        </trans-unit>
        <trans-unit id="e26167c936dd528fda49f3a0a8e244ad7c09578d" translate="yes" xml:space="preserve">
          <source>In my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on).</source>
          <target state="translated">На мой взгляд,вы лучше поймёте и запомните нотацию нарезания питоновской строки,если посмотрите на неё следующим образом (читайте дальше).</target>
        </trans-unit>
        <trans-unit id="f7dabe40d708c905a0cefb23cf2333f28977c80b" translate="yes" xml:space="preserve">
          <source>In short, the colons (&lt;code&gt;:&lt;/code&gt;) in subscript notation (&lt;code&gt;subscriptable[subscriptarg]&lt;/code&gt;) make slice notation - which has the optional arguments, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;:</source>
          <target state="translated">Короче говоря, двоеточия (:) в нотации &lt;code&gt;subscriptable[subscriptarg]&lt;/code&gt; индекса ( subscriptable [subscriptarg] ) создают нотацию среза, которая имеет необязательные аргументы, &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bb5e2ff5da706301f634ce9ca90e75ed00059cba" translate="yes" xml:space="preserve">
          <source>In these moments I rely on this simple theorem:</source>
          <target state="translated">В эти моменты я полагаюсь на эту простую теорему:</target>
        </trans-unit>
        <trans-unit id="5870a8ca498a1c74154e2cfd9acc8e21c121fdb0" translate="yes" xml:space="preserve">
          <source>Index the number 3 from A and the number 6 from B.</source>
          <target state="translated">Индексируйте число 3 из A и число 6 из B.</target>
        </trans-unit>
        <trans-unit id="3631e9d015a9f2d779f98610e8e9d63664c32ef5" translate="yes" xml:space="preserve">
          <source>Indexing is like dealing with the contents of box. You can check contents of any box. But you can't check the contents of multiple boxes at once. You can even replace the contents of the box. But you can't place two balls in one box or replace two balls at a time.</source>
          <target state="translated">Индексирование похоже на работу с содержимым ящика.Вы можете проверить содержимое любого поля.Но вы не можете проверить содержимое сразу нескольких ящиков.Вы даже можете заменить содержимое ящика.Но вы не можете поместить два шара в один ящик или заменить два шара за раз.</target>
        </trans-unit>
        <trans-unit id="2e852a9a85a011a4821ea957a6c18af49fdb2384" translate="yes" xml:space="preserve">
          <source>It is a list with six elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it.</source>
          <target state="translated">Это список с шестью элементами.Чтобы лучше понять нарезку,рассмотрим этот список как набор из шести ячеек,расположенных вместе.В каждой коробке есть алфавит.</target>
        </trans-unit>
        <trans-unit id="72edc078c44d61355487724654334d433672237e" translate="yes" xml:space="preserve">
          <source>It is also possible to use negative integers for &lt;code&gt;step&lt;/code&gt; as the following example:</source>
          <target state="translated">Также можно использовать отрицательные целые числа для &lt;code&gt;step&lt;/code&gt; в следующем примере:</target>
        </trans-unit>
        <trans-unit id="d2e55fc42f854f48df8f7704c2076ef2f0b82f26" translate="yes" xml:space="preserve">
          <source>It is important to note, the first element is index 0, &lt;em&gt;not&lt;/em&gt; index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc.) while List B's elements are the numbers that would be used to index them ([0] for the first element 0, etc.).</source>
          <target state="translated">Важно отметить, что первым элементом является индекс 0, а &lt;em&gt;не&lt;/em&gt; индекс 1. Именно поэтому мы используем 2 списка для этого упражнения. Элементы списка A нумеруются в соответствии с порядковым положением (первый элемент равен 1, второй элемент равен 2 и т. Д.), А элементы списка B представляют собой числа, которые будут использоваться для их индексации ([0] для первого элемента 0, так далее.).</target>
        </trans-unit>
        <trans-unit id="8437802c00fcb02882fb640fb2f6aa10b7ed41e7" translate="yes" xml:space="preserve">
          <source>It is possible to provide indices that are out of bounds when slicing such as:</source>
          <target state="translated">Можно предоставить индексы,которые выходят за рамки при такой нарезке:</target>
        </trans-unit>
        <trans-unit id="cc08d6b3965c9cd2a7d0a9d353abfe631305e0ce" translate="yes" xml:space="preserve">
          <source>It looks extremely powerful, but I haven't quite got my head around it.</source>
          <target state="translated">Выглядит очень мощным,но у меня не хватает головы.</target>
        </trans-unit>
        <trans-unit id="c3478bf3faba9c41f22e71efd498abcab65d1e72" translate="yes" xml:space="preserve">
          <source>It's instructive to understand &lt;code&gt;range()&lt;/code&gt; first:</source>
          <target state="translated">Поучительно сначала понять &lt;code&gt;range()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="db93970c161e9b60dc37836b4ad4bcc5e738b56f" translate="yes" xml:space="preserve">
          <source>It's interesting that ranges also take slices:</source>
          <target state="translated">Интересно,что на хребет тоже берут ломтики:</target>
        </trans-unit>
        <trans-unit id="393247b02d3798ab868c03bcc3f85e6ad9331f9b" translate="yes" xml:space="preserve">
          <source>It's pretty simple really:</source>
          <target state="translated">Всё очень просто:</target>
        </trans-unit>
        <trans-unit id="07e297809eb4051826121e82a0caefbf899d3c86" translate="yes" xml:space="preserve">
          <source>Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignments do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values:</source>
          <target state="translated">Имейте в виду,что результатом нарезки коллекции является совершенно новая коллекция.Кроме того,при использовании нотации срезов в присваиваниях,длина присваиваний срезов не обязательно должна быть одинаковой.Значения до и после назначенного среза будут сохранены,а коллекция сократится или вырастет,чтобы содержать новые значения:</target>
        </trans-unit>
        <trans-unit id="cf594f555786da65b5bbbcfa5d1f5e37ff7665e6" translate="yes" xml:space="preserve">
          <source>Let's finish this answer with examples, explaining everything we have discussed:</source>
          <target state="translated">Давайте закончим этот ответ примерами,объясняя все,что мы обсуждали:</target>
        </trans-unit>
        <trans-unit id="26f47aa550adca492b5233c25393b47b841fe5ad" translate="yes" xml:space="preserve">
          <source>Let's have a list with six values &lt;code&gt;['P', 'Y', 'T', 'H', 'O', 'N']&lt;/code&gt;:</source>
          <target state="translated">Давайте получим список из шести значений &lt;code&gt;['P', 'Y', 'T', 'H', 'O', 'N']&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7137555528de00a0bcf2c040f1daafce2f58347c" translate="yes" xml:space="preserve">
          <source>Let's work with the following string ...</source>
          <target state="translated">Давайте поработаем со следующей строкой ...</target>
        </trans-unit>
        <trans-unit id="3f6a7a17387285ecbb29103e91399ef401031fff" translate="yes" xml:space="preserve">
          <source>Making things more confusing is that &lt;strong&gt;&lt;code&gt;step&lt;/code&gt; can be negative too!&lt;/strong&gt;</source>
          <target state="translated">Еще более запутанным является то, что этот &lt;strong&gt; &lt;code&gt;step&lt;/code&gt; может быть отрицательным!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4d6fecb17d10399cfa47983f1042cccd5affc47" translate="yes" xml:space="preserve">
          <source>Memory Considerations:</source>
          <target state="translated">Памятные соображения:</target>
        </trans-unit>
        <trans-unit id="1ff1eb25d65b7e8b0b1c5bcc0650dd539ed6fbbd" translate="yes" xml:space="preserve">
          <source>More slicing examples: &lt;a href=&quot;https://docs.python.org/2.3/whatsnew/section-slices.html&quot;&gt;15 Extended Slices&lt;/a&gt;</source>
          <target state="translated">Больше примеров нарезки: &lt;a href=&quot;https://docs.python.org/2.3/whatsnew/section-slices.html&quot;&gt;15 расширенных ломтиков&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="236384af55aea443e68110eede08ce564e280d4c" translate="yes" xml:space="preserve">
          <source>Most of the previous answers clears up questions about slice notation.</source>
          <target state="translated">Большинство предыдущих ответов проясняют вопросы о нотации кусочков.</target>
        </trans-unit>
        <trans-unit id="258dc3b32b7b8c786022e52d99f1e20b993d915e" translate="yes" xml:space="preserve">
          <source>My brain seems happy to accept that &lt;code&gt;lst[start:end]&lt;/code&gt; contains the &lt;code&gt;start&lt;/code&gt;-th item. I might even say that it is a 'natural assumption'.</source>
          <target state="translated">Мой мозг, кажется, рад принять, что &lt;code&gt;lst[start:end]&lt;/code&gt; содержит элемент &lt;code&gt;start&lt;/code&gt; -th. Я мог бы даже сказать, что это &amp;laquo;естественное предположение&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0e9abc9291766099a35bbc0daca4bfdba74ab393" translate="yes" xml:space="preserve">
          <source>My conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as &lt;code&gt;azString[index1, index2]&lt;/code&gt; or even more clearer as &lt;code&gt;azString[index_of_first_character, index_after_the_last_character]&lt;/code&gt;.</source>
          <target state="translated">Мой вывод заключается в том, что x и y следует рассматривать как граничные индексы, которые окружают строки, которые мы хотим добавить. Таким образом, мы должны увидеть выражение как &lt;code&gt;azString[index1, index2]&lt;/code&gt; или еще более ясно, как &lt;code&gt;azString[index_of_first_character, index_after_the_last_character]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bc0687f0ccd20cd39dcb014b119503d374c4139" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;start &amp;gt;= end&lt;/code&gt; (considering only when &lt;code&gt;step&amp;gt;0&lt;/code&gt;), Python will return a empty slice &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">ПРИМЕЧАНИЕ. Если &lt;code&gt;start &amp;gt;= end&lt;/code&gt; (учитывая только при &lt;code&gt;step&amp;gt;0&lt;/code&gt; ), Python вернет пустой фрагмент &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3924ca69a9c6ef3c94b8adce539357eedbfe98b1" translate="yes" xml:space="preserve">
          <source>Negative indexes</source>
          <target state="translated">Отрицательные индексы</target>
        </trans-unit>
        <trans-unit id="19a3fcc38635b3630af723c1238943e8e1843247" translate="yes" xml:space="preserve">
          <source>Negative integers are useful when doing offsets relative to the end of a collection:</source>
          <target state="translated">Отрицательные целые числа полезны при выполнении смещения относительно конца коллекции:</target>
        </trans-unit>
        <trans-unit id="afa9d728aad9ce367861bb103920cb5b75e339e7" translate="yes" xml:space="preserve">
          <source>Negative step</source>
          <target state="translated">Отрицательный шаг</target>
        </trans-unit>
        <trans-unit id="96650fe967ba54c6b724f6429dd3614089107d32" translate="yes" xml:space="preserve">
          <source>Normalizing negative indexes first allows start and/or stop to be counted from the end independently: &lt;code&gt;'abcde'[1:-2] == 'abcde'[1:3] == 'bc'&lt;/code&gt; despite &lt;code&gt;range(1,-2) == []&lt;/code&gt;.
The normalization is sometimes thought of as &quot;modulo the length&quot;, but note it adds the length just once: e.g. &lt;code&gt;'abcde'[-53:42]&lt;/code&gt; is just the whole string.</source>
          <target state="translated">Нормализация отрицательных индексов сначала позволяет независимо начинать и / или останавливать отсчет с конца: &lt;code&gt;'abcde'[1:-2] == 'abcde'[1:3] == 'bc'&lt;/code&gt; несмотря на &lt;code&gt;range(1,-2) == []&lt;/code&gt; . Нормализацию иногда считают &amp;laquo;по модулю длины&amp;raquo;, но обратите внимание, что она добавляет длину только один раз: например, &lt;code&gt;'abcde'[-53:42]&lt;/code&gt; - это просто вся строка.</target>
        </trans-unit>
        <trans-unit id="4d43af0ad3abe59f6e4fb376c128181bd7bde7b5" translate="yes" xml:space="preserve">
          <source>Note that this theorem is true for any &lt;code&gt;n&lt;/code&gt; at all. For example, you can check that</source>
          <target state="translated">Обратите внимание, что эта теорема верна для любого &lt;code&gt;n&lt;/code&gt; вообще. Например, вы можете проверить, что</target>
        </trans-unit>
        <trans-unit id="2ceb96fc5e9a3dc2bc105bff4a65c7e6742be2cc" translate="yes" xml:space="preserve">
          <source>Note that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments.</source>
          <target state="translated">Обратите внимание,что поскольку мы не меняем второе число среза (4),вставленные элементы всегда стекаются прямо на 'o',даже когда мы присваиваем пустой срез.Таким образом,позиция для назначения пустого среза является логическим продолжением позиции для назначения непустого среза.</target>
        </trans-unit>
        <trans-unit id="967bf0aa1a3677571a7849b566735433ec166495" translate="yes" xml:space="preserve">
          <source>Now if you make a slice &lt;code&gt;[2:5]&lt;/code&gt; of the list above, this will happen:</source>
          <target state="translated">Теперь, если вы сделаете фрагмент &lt;code&gt;[2:5]&lt;/code&gt; из списка выше, это произойдет:</target>
        </trans-unit>
        <trans-unit id="e6df6b2bcf9a3314ee026c4f79df59cdd07fa7f8" translate="yes" xml:space="preserve">
          <source>Now the simplest slices of that list are its sublists. The notation is &lt;code&gt;[&amp;lt;index&amp;gt;:&amp;lt;index&amp;gt;]&lt;/code&gt; and the key is to read it like this:</source>
          <target state="translated">Теперь простейшими срезами этого списка являются его подсписки. Обозначение - &lt;code&gt;[&amp;lt;index&amp;gt;:&amp;lt;index&amp;gt;]&lt;/code&gt; , и ключ должен прочитать это как это:</target>
        </trans-unit>
        <trans-unit id="4b69184bd6d629ae67ecbb030f96e1b6febacc6a" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;(high-low)%stride != 0&lt;/code&gt;, then the end point will be a little lower than &lt;code&gt;high-1&lt;/code&gt;.</source>
          <target state="translated">Конечно, если &lt;code&gt;(high-low)%stride != 0&lt;/code&gt; , то конечная точка будет немного ниже, чем &lt;code&gt;high-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9797498b5445b5a3c49a8d9a5a8bcc115a3f1de4" translate="yes" xml:space="preserve">
          <source>One heuristic is, for a slice from zero to n, think: &quot;zero is the beginning, start at the beginning and take n items in a list&quot;.</source>
          <target state="translated">Один эвристический метод:для кусочка от нуля до n подумайте:&quot;ноль-это начало,начните с начала и возьмите n пунктов из списка&quot;.</target>
        </trans-unit>
        <trans-unit id="1deb5c09927c43e07c799a375e42510fd8ab8301" translate="yes" xml:space="preserve">
          <source>One last thing: if a and b are equal, then also you get an empty list:</source>
          <target state="translated">И последнее:если a и b равны,то также вы получаете пустой список:</target>
        </trans-unit>
        <trans-unit id="22de4720e28cbf22dbc85b732b56fab0a497d9da" translate="yes" xml:space="preserve">
          <source>One way to remember how slices work is to think of the indices as pointing &lt;em&gt;between&lt;/em&gt; characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of &lt;em&gt;n&lt;/em&gt; characters has index &lt;em&gt;n&lt;/em&gt;.</source>
          <target state="translated">Один из способов помнить, как работают срезы, - рассматривать индексы как указывающие &lt;em&gt;между&lt;/em&gt; символами, причем левый край первого символа пронумерован 0. Тогда правый край последнего символа строки из &lt;em&gt;n&lt;/em&gt; символов имеет индекс &lt;em&gt;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="01230747b9914341b6ea0abf3a127d2554050e61" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;step&lt;/code&gt; is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list.</source>
          <target state="translated">В противном случае &lt;code&gt;step&lt;/code&gt; является положительным, и нижняя граница будет равна нулю, а верхняя граница (до которой мы идем, но не включая) длины нарезанного списка.</target>
        </trans-unit>
        <trans-unit id="6ee09859ae901d353f04d7756fc619a422996265" translate="yes" xml:space="preserve">
          <source>Out of range error?</source>
          <target state="translated">Ошибка вне радиуса действия?</target>
        </trans-unit>
        <trans-unit id="1e32d6d4f298657e76954434ba9df3c467b606d2" translate="yes" xml:space="preserve">
          <source>Positive indices for &lt;code&gt;end&lt;/code&gt; indicate the position &lt;em&gt;after&lt;/em&gt; the last element to be included.</source>
          <target state="translated">Положительные индексы для &lt;code&gt;end&lt;/code&gt; указывают позицию &lt;em&gt;после&lt;/em&gt; последнего включаемого элемента.</target>
        </trans-unit>
        <trans-unit id="94740c4c4bc99ca509491718d4ba079f2a8f218e" translate="yes" xml:space="preserve">
          <source>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for &lt;code&gt;a[:-2]&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.</source>
          <target state="translated">Python добр к программисту, если в нем меньше элементов, чем вы просите. Например, если вы запрашиваете &lt;code&gt;a[:-2]&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; содержит только один элемент, вы получите пустой список вместо ошибки. Иногда вы бы предпочли ошибку, поэтому вы должны знать, что это может произойти.</target>
        </trans-unit>
        <trans-unit id="b248a1be31c8962b0faa6461a8e1ebdb8bf936b1" translate="yes" xml:space="preserve">
          <source>Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with.</source>
          <target state="translated">Нарезка на питон-это вычислительно быстрый способ методического доступа к частям ваших данных.На мой взгляд,чтобы быть даже промежуточным программистом с Python,это один из аспектов языка,с которым необходимо быть знакомым.</target>
        </trans-unit>
        <trans-unit id="4be307b534051fdddbb09f680b1f90334e27c87c" translate="yes" xml:space="preserve">
          <source>Python slicing notation:</source>
          <target state="translated">Нотация на нарезки питона:</target>
        </trans-unit>
        <trans-unit id="0f99ce71c7cc473f59ebcdd42fafcac7ebb5607c" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</source>
          <target state="translated">Ссылка: &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85e3167baf4fe31a5ac66fca1064289b89090879" translate="yes" xml:space="preserve">
          <source>Relation to &lt;code&gt;slice()&lt;/code&gt; object</source>
          <target state="translated">Отношение к объекту &lt;code&gt;slice()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ded5af84f53bac1b910e783dc1876f40d1930247" translate="yes" xml:space="preserve">
          <source>Remember that we are setting the boundaries. And those boundaries are the positions where you could place some brackets that will be wrapped around the substring like this ...</source>
          <target state="translated">Помните,что мы устанавливаем границы.И эти границы являются позициями,где вы можете разместить некоторые скобки,которые будут обернуты вокруг подстроки,как это ...</target>
        </trans-unit>
        <trans-unit id="87aef1727fb2103950e2e345944a306d9d583015" translate="yes" xml:space="preserve">
          <source>Sequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence:</source>
          <target state="translated">Последовательность нарезки одинакова,за исключением того,что она сначала нормализует отрицательные показатели,и она никогда не может выйти за пределы последовательности:</target>
        </trans-unit>
        <trans-unit id="96eaebe560215c517ad3e5af8e2a9735ecb8738d" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;step&lt;/code&gt; may be a negative number:</source>
          <target state="translated">Аналогично, &lt;code&gt;step&lt;/code&gt; может быть отрицательным числом:</target>
        </trans-unit>
        <trans-unit id="ae00240360bccc296201ca8138f454fe741d7f58" translate="yes" xml:space="preserve">
          <source>Since slices of Python lists create new objects in memory, another important function to be aware of is &lt;code&gt;itertools.islice&lt;/code&gt;. Typically you'll want to iterate over a slice, not just have it created statically in memory. &lt;code&gt;islice&lt;/code&gt; is perfect for this. A caveat, it doesn't support negative arguments to &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, or &lt;code&gt;step&lt;/code&gt;, so if that's an issue you may need to calculate indices or reverse the iterable in advance.</source>
          <target state="translated">Так как фрагменты списков Python создают новые объекты в памяти, следует помнить еще одну важную функцию - &lt;code&gt;itertools.islice&lt;/code&gt; . Обычно вам нужно перебирать фрагмент, а не просто создавать его статически в памяти. &lt;code&gt;islice&lt;/code&gt; идеально подходит для этого. Предостережение: он не поддерживает отрицательные аргументы для &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; или &lt;code&gt;step&lt;/code&gt; , поэтому, если это проблема, вам может понадобиться рассчитать индексы или заранее изменить итерацию заранее.</target>
        </trans-unit>
        <trans-unit id="8c3c2e5e113c75c44c107bde062191fa1ee7c4b5" translate="yes" xml:space="preserve">
          <source>Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:</source>
          <target state="translated">Нотация среза для получения последних девяти элементов из списка (или любой другой последовательности,поддерживающей ее,например,строки)будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="afd155507ef02b023315f7f2437ce7518f12da0e" translate="yes" xml:space="preserve">
          <source>Slice notation works like this:</source>
          <target state="translated">Нотация на срезах работает вот так:</target>
        </trans-unit>
        <trans-unit id="2bf8562fbd4372800fdbdad7eef6770e5b0c3ac3" translate="yes" xml:space="preserve">
          <source>Slice objects also behave slightly differently depending on the number of arguments, similarly to &lt;code&gt;range()&lt;/code&gt;, i.e. both &lt;code&gt;slice(stop)&lt;/code&gt; and &lt;code&gt;slice(start, stop[, step])&lt;/code&gt; are supported.
To skip specifying a given argument, one might use &lt;code&gt;None&lt;/code&gt;, so that e.g. &lt;code&gt;a[start:]&lt;/code&gt; is equivalent to &lt;code&gt;a[slice(start, None)]&lt;/code&gt; or &lt;code&gt;a[::-1]&lt;/code&gt; is equivalent to &lt;code&gt;a[slice(None, None, -1)]&lt;/code&gt;.</source>
          <target state="translated">Объекты &lt;code&gt;slice(stop)&lt;/code&gt; также ведут себя немного по-разному в зависимости от количества аргументов, аналогично &lt;code&gt;range()&lt;/code&gt; , то есть поддерживаются как slice (stop), так и &lt;code&gt;slice(start, stop[, step])&lt;/code&gt; . Чтобы пропустить указание заданного аргумента, можно использовать &lt;code&gt;None&lt;/code&gt; , так что, например, &lt;code&gt;a[start:]&lt;/code&gt; эквивалентно &lt;code&gt;a[slice(start, None)]&lt;/code&gt; или &lt;code&gt;a[::-1]&lt;/code&gt; эквивалентно &lt;code&gt;a[slice(None, None, -1)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0de34fe528d24a6ab78b22ea621d459ea58bcde" translate="yes" xml:space="preserve">
          <source>Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use &lt;a href=&quot;https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python&quot;&gt;&lt;code&gt;deepcopy()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Срезы содержат ссылки, а не копии элементов массива. Если вы хотите сделать отдельную копию массива, вы можете использовать &lt;a href=&quot;https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python&quot;&gt; &lt;code&gt;deepcopy()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7a0ec14b698ea62c178c70915809b11eee0b1d4" translate="yes" xml:space="preserve">
          <source>Slicing example: [start:end:step]</source>
          <target state="translated">Пример нарезки:[start:end:step]</target>
        </trans-unit>
        <trans-unit id="0fab7676f1313a7031d732db17a3266ea48b260e" translate="yes" xml:space="preserve">
          <source>Slicing in Python</source>
          <target state="translated">Нарезка на Питоне</target>
        </trans-unit>
        <trans-unit id="2f82b358ce4a2bd3562b18aca5eb96f4abc16964" translate="yes" xml:space="preserve">
          <source>Slicing is like dealing with boxes themselves. You can pick up the first box and place it on another table. To pick up the box, all you need to know is the position of beginning and ending of the box.</source>
          <target state="translated">Нарезка-это все равно,что иметь дело с самими коробками.Вы можете взять первую коробку и положить ее на другой стол.Чтобы забрать коробку,все,что вам нужно знать-это положение начала и конца коробки.</target>
        </trans-unit>
        <trans-unit id="b6071a94da6c32b2f41ecdb9b7c54c4fc53d3bbe" translate="yes" xml:space="preserve">
          <source>So all you have to do is setting index1 and index2 to the values that will surround the desired substring. For instance, to get the substring &quot;cdefgh&quot;, you can use &lt;code&gt;azString[2:8]&lt;/code&gt;, because the index on the left side of &quot;c&quot; is 2 and the one on the right size of &quot;h&quot; is 8.</source>
          <target state="translated">Поэтому все, что вам нужно сделать, это установить index1 и index2 в значения, которые будут окружать желаемую подстроку. Например, чтобы получить подстроку &amp;laquo;cdefgh&amp;raquo;, вы можете использовать &lt;code&gt;azString[2:8]&lt;/code&gt; , потому что индекс слева от &amp;laquo;c&amp;raquo; равен 2, а индекс справа от &amp;laquo;h&amp;raquo; равен 8.</target>
        </trans-unit>
        <trans-unit id="9d36a8ded558a57acb9a21c94c859b6d67771f8e" translate="yes" xml:space="preserve">
          <source>So possible variations are:</source>
          <target state="translated">Так что возможны варианты:</target>
        </trans-unit>
        <trans-unit id="5e112be622e92277daa08e6daca504e718916de7" translate="yes" xml:space="preserve">
          <source>That trick works all the time and is easy to memorize.</source>
          <target state="translated">Этот трюк работает постоянно и его легко запомнить.</target>
        </trans-unit>
        <trans-unit id="fdf01cb06945a582fa2999e094744ca983173e6c" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;:2&lt;/code&gt;&quot; before the comma operates on the first dimension and the &quot;&lt;code&gt;0:3:2&lt;/code&gt;&quot; after the comma operates on the second dimension.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;:2&lt;/code&gt; &amp;raquo; перед запятой действует в первом измерении, а &amp;laquo; &lt;code&gt;0:3:2&lt;/code&gt; &amp;raquo; после запятой действует во втором измерении.</target>
        </trans-unit>
        <trans-unit id="671738aa3584c456b592e354d91684dcd323f399" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#strings&quot;&gt;Python tutorial&lt;/a&gt; talks about it (scroll down a bit until you get to the part about slicing).</source>
          <target state="translated">Об этом рассказывается в &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#strings&quot;&gt;руководстве по Python&lt;/a&gt; (прокрутите немного, пока не дойдете до части о нарезке).</target>
        </trans-unit>
        <trans-unit id="fb121e6f32b2ed82d98fe529053634abd387ad84" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;colon&lt;/strong&gt;, &lt;code&gt;:&lt;/code&gt;,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is</source>
          <target state="translated">&lt;strong&gt;Двоеточие&lt;/strong&gt; , &lt;code&gt;:&lt;/code&gt; , это то, что говорит Python, что вы даете ему фрагмент, а не обычный индекс. Вот почему идиоматический способ создания мелкой копии списков в Python 2</target>
        </trans-unit>
        <trans-unit id="064ca1037f07ebe70ccb6e0e4303cf9c8fd960d8" translate="yes" xml:space="preserve">
          <source>The ASCII art diagram is helpful too for remembering how slices work:</source>
          <target state="translated">Художественная диаграмма ASCII также полезна для запоминания того,как работают фрагменты:</target>
        </trans-unit>
        <trans-unit id="c2a53ea7c27bc274090377248543665760dc2d23" translate="yes" xml:space="preserve">
          <source>The above part explains the core features on how slice works, and it will work on most occasions. However, there can be pitfalls you should watch out, and this part explains them.</source>
          <target state="translated">В вышеприведенной части объясняются основные особенности того,как работает срез,и он будет работать в большинстве случаев.Однако,могут быть и подводные камни,на которые следует обратить внимание,и эта часть объясняет их.</target>
        </trans-unit>
        <trans-unit id="9a0d878051d5575a2cc4db1865d8619aa0945996" translate="yes" xml:space="preserve">
          <source>The answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art:</source>
          <target state="translated">Ответы выше не обсуждают задания на срез.Чтобы понять назначение срезов,полезно добавить еще одно понятие в ASCII искусство:</target>
        </trans-unit>
        <trans-unit id="4827bfb62b55032ff3bc19f8d7461338d02ba84c" translate="yes" xml:space="preserve">
          <source>The basic slicing technique is to define the starting point, the stopping point, and the step size - also known as stride.</source>
          <target state="translated">Основная техника продольной резки заключается в определении начальной точки,точки остановки и размера шага-также называемого шага.</target>
        </trans-unit>
        <trans-unit id="7afa04f193c1a31833d08e539febf8032a61d69d" translate="yes" xml:space="preserve">
          <source>The below is the example of an index of a string:</source>
          <target state="translated">Ниже приведен пример индекса строки:</target>
        </trans-unit>
        <trans-unit id="a6fdc6b5102e017e74aa1ebfa120ec1728976bd7" translate="yes" xml:space="preserve">
          <source>The best way to illustrate what slicing does internally is just show it in code that implements this operation:</source>
          <target state="translated">Лучший способ проиллюстрировать,что делает нарезка внутри,это просто показать это в коде,который реализует эту операцию:</target>
        </trans-unit>
        <trans-unit id="9b289ec304478ab3aa8206822ac93132cd9189a0" translate="yes" xml:space="preserve">
          <source>The extended indexing syntax used for slicing is &lt;code&gt;aList[start:stop:step]&lt;/code&gt;, and basic examples are:</source>
          <target state="translated">Расширенный синтаксис индексации, используемый для нарезки, представляет собой &lt;code&gt;aList[start:stop:step]&lt;/code&gt; , а основными примерами являются:</target>
        </trans-unit>
        <trans-unit id="835f8ab3b0337722c0f132a2e78a9079b59cded7" translate="yes" xml:space="preserve">
          <source>The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy.</source>
          <target state="translated">Тот факт,что фрагменты списка делают копию,является особенностью самих списков.Если вы нарезаете расширенные объекты,такие как Pandas DataFrame,он может вернуть вид на оригинал,а не копию.</target>
        </trans-unit>
        <trans-unit id="41c12238b9c9bbcd33df30b54dc049e7a8a037bb" translate="yes" xml:space="preserve">
          <source>The first rule of slice assignment is that since slicing &lt;em&gt;returns&lt;/em&gt; a list, slice assignment &lt;em&gt;requires&lt;/em&gt; a list (or other iterable):</source>
          <target state="translated">Первое правило назначения срезов состоит в том, что, поскольку срезы &lt;em&gt;возвращают&lt;/em&gt; список, для назначения срезов &lt;em&gt;требуется&lt;/em&gt; список (или другие итерируемые):</target>
        </trans-unit>
        <trans-unit id="053d4b345613c9e63af290ea87904c13976fb020" translate="yes" xml:space="preserve">
          <source>The full notation is</source>
          <target state="translated">Полная нотация</target>
        </trans-unit>
        <trans-unit id="a279c32eedbdb41ca0663a3f3c7caa14aacb8d48" translate="yes" xml:space="preserve">
          <source>The interesting thing is that you can replace multiple boxes at once. Also you can place multiple boxes wherever you like.</source>
          <target state="translated">Интересно то,что вы можете заменить несколько коробок сразу.Также вы можете разместить несколько коробок где угодно.</target>
        </trans-unit>
        <trans-unit id="cbafdf992eb9b0ec11721982bbb3effe97d12b16" translate="yes" xml:space="preserve">
          <source>The key point to remember is that the &lt;code&gt;:stop&lt;/code&gt; value represents the first value that is &lt;em&gt;not&lt;/em&gt; in the selected slice. So, the difference between &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; is the number of elements selected (if &lt;code&gt;step&lt;/code&gt; is 1, the default).</source>
          <target state="translated">Ключевой момент, который следует помнить, заключается в том, что значение &lt;code&gt;:stop&lt;/code&gt; представляет первое значение, которого &lt;em&gt;нет&lt;/em&gt; в выбранном срезе. Таким образом, разница между &lt;code&gt;stop&lt;/code&gt; и &lt;code&gt;start&lt;/code&gt; заключается в количестве выбранных элементов (если &lt;code&gt;step&lt;/code&gt; равен 1, по умолчанию).</target>
        </trans-unit>
        <trans-unit id="75586a32a01b71ebd61830c9004e1d99bb7e7f3c" translate="yes" xml:space="preserve">
          <source>The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use:</source>
          <target state="translated">Нотация распространяется на (нумированные)матрицы и многомерные массивы.Например,для нарезки целых столбцов можно использовать:</target>
        </trans-unit>
        <trans-unit id="517bdfc38c62e4ed8dbc0ebe6233fdd418806066" translate="yes" xml:space="preserve">
          <source>The other feature is that &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; may be a &lt;em&gt;negative&lt;/em&gt; number, which means it counts from the end of the array instead of the beginning. So:</source>
          <target state="translated">Другая особенность заключается в том, что &lt;code&gt;start&lt;/code&gt; или &lt;code&gt;stop&lt;/code&gt; могут быть &lt;em&gt;отрицательным&lt;/em&gt; числом, что означает, что они считаются с конца массива, а не с начала. Так:</target>
        </trans-unit>
        <trans-unit id="88cb13542cd6c22a7ed79eaff2dca42af648aa1a" translate="yes" xml:space="preserve">
          <source>The previous answers don't discuss multi-dimensional array slicing which is possible using the famous &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; package:</source>
          <target state="translated">В предыдущих ответах не обсуждается разделение многомерных массивов, что возможно при использовании известного пакета &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bcb48bc85f26256a3ee0c0f6a3e5b4429c47ae72" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;None&lt;/code&gt;, is required, so that the first argument is interpreted as the &lt;code&gt;start&lt;/code&gt; argument &lt;a href=&quot;https://docs.python.org/2/library/functions.html#slice&quot;&gt;otherwise it would be the &lt;code&gt;stop&lt;/code&gt; argument&lt;/a&gt;.</source>
          <target state="translated">Второй аргумент, &lt;code&gt;None&lt;/code&gt; , является обязательным, поэтому первый аргумент интерпретируется как &lt;code&gt;start&lt;/code&gt; аргумент, в &lt;a href=&quot;https://docs.python.org/2/library/functions.html#slice&quot;&gt;противном случае это будет аргумент &lt;code&gt;stop&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="596e5324916e7331fb73503433bce1ac5233475a" translate="yes" xml:space="preserve">
          <source>The second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment:</source>
          <target state="translated">Второе правило назначения срезов,которое вы также можете увидеть выше,заключается в том,что какая бы часть списка не возвращалась при индексировании срезов,это та же самая часть,которая изменяется при назначении срезов:</target>
        </trans-unit>
        <trans-unit id="e952b134f12b0ea29603efb0b559bc9cc9ad704f" translate="yes" xml:space="preserve">
          <source>The slicing operator &lt;code&gt;[]&lt;/code&gt; is actually being used in the above code with a &lt;code&gt;slice()&lt;/code&gt; object using the &lt;code&gt;:&lt;/code&gt; notation (which is only valid within &lt;code&gt;[]&lt;/code&gt;), i.e.:</source>
          <target state="translated">Оператор среза &lt;code&gt;[]&lt;/code&gt; фактически используется в приведенном выше коде с объектом &lt;code&gt;slice()&lt;/code&gt; с использованием нотации &lt;code&gt;:&lt;/code&gt; (которая действительна только в &lt;code&gt;[]&lt;/code&gt; ), то есть:</target>
        </trans-unit>
        <trans-unit id="e691224537259b930d7e6fe4624c31eea62f2d85" translate="yes" xml:space="preserve">
          <source>The thing to remember about negative step is that &lt;code&gt;stop&lt;/code&gt; is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. &lt;code&gt;'abcde'[1:-2][::-1]&lt;/code&gt; slices off one char from left, two from right, then reverses. (See also &lt;a href=&quot;http://www.python.org/dev/peps/pep-0322/&quot;&gt;&lt;code&gt;reversed()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">О негативном шаге следует помнить, что &lt;code&gt;stop&lt;/code&gt; всегда является исключенным концом, будь то выше или ниже. Если вы хотите, чтобы один и тот же срез находился в противоположном порядке, гораздо проще сделать инверсию по отдельности: например, &lt;code&gt;'abcde'[1:-2][::-1]&lt;/code&gt; отсекает один символ слева, два справа, а затем переворачивает. (См. Также &lt;a href=&quot;http://www.python.org/dev/peps/pep-0322/&quot;&gt; &lt;code&gt;reversed()&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="77887242adef23e77fb02d89d877a784f02e2b36" translate="yes" xml:space="preserve">
          <source>The third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned:</source>
          <target state="translated">Третье правило назначения срезов-назначенный список (итерабельный)не обязательно должен иметь одинаковую длину;проиндексированный срез просто вырезается и массово заменяется тем,что ему назначено:</target>
        </trans-unit>
        <trans-unit id="29855a6656d9eb287192ae5bff65ab56fdd630e5" translate="yes" xml:space="preserve">
          <source>The trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around &lt;em&gt;indexing&lt;/em&gt; an empty slice:</source>
          <target state="translated">Самая хитрая часть, к которой нужно привыкнуть, - это назначение пустым слайсам. Используя эвристику 1 и 2, легко разобраться с &lt;em&gt;индексированием&lt;/em&gt; пустого фрагмента:</target>
        </trans-unit>
        <trans-unit id="4443911b7fa6e0ec19af60b9f6f8c54543309dbe" translate="yes" xml:space="preserve">
          <source>The very first thing that confuses Python learners is that &lt;strong&gt;an index can be negative!&lt;/strong&gt;
Don't panic: &lt;strong&gt;a negative index means count backwards.&lt;/strong&gt;</source>
          <target state="translated">Самое первое, что смущает изучающих Python, это то, что &lt;strong&gt;индекс может быть отрицательным!&lt;/strong&gt; Не паникуйте: &lt;strong&gt;отрицательный индекс означает обратный отсчет.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc233fdd4b1aa1d0eec08f781b67af8b6d1de6f5" translate="yes" xml:space="preserve">
          <source>Then the negative indexing just needs you to add the length of the string to the negative indices to understand it.</source>
          <target state="translated">Тогда для понимания отрицательной индексации достаточно добавить длину строки к отрицательным индексам.</target>
        </trans-unit>
        <trans-unit id="849becd57d4d9dfce3e88751e6e091a0dece7725" translate="yes" xml:space="preserve">
          <source>Then, we may need to apply the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; - the default then for &lt;code&gt;start&lt;/code&gt; is calculated as the upper bound when &lt;code&gt;step&lt;/code&gt; is negative:</source>
          <target state="translated">Затем нам может потребоваться применить значения по умолчанию для &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; - тогда значение по умолчанию для &lt;code&gt;start&lt;/code&gt; рассчитывается как верхняя граница, когда &lt;code&gt;step&lt;/code&gt; отрицательный:</target>
        </trans-unit>
        <trans-unit id="b7d7ff65eee8f921208cc372c6ebb7dfee9bb661" translate="yes" xml:space="preserve">
          <source>There are some weird consequences to the &quot;once you're done, you're done&quot; rule:</source>
          <target state="translated">Есть некоторые странные последствия для правила &quot;как только ты закончил,ты закончил&quot;:</target>
        </trans-unit>
        <trans-unit id="d9a00425fdfcba9c3b6367238a922973214a9b04" translate="yes" xml:space="preserve">
          <source>There is also the &lt;code&gt;step&lt;/code&gt; value, which can be used with any of the above:</source>
          <target state="translated">Существует также значение &lt;code&gt;step&lt;/code&gt; , которое можно использовать с любым из вышеперечисленных:</target>
        </trans-unit>
        <trans-unit id="8748ae39a14aa6c556cf400a604d76f7a5986f03" translate="yes" xml:space="preserve">
          <source>This can come in handy sometimes, but it can also lead to somewhat strange behavior:</source>
          <target state="translated">Иногда это может пригодиться,но также может привести к несколько странному поведению:</target>
        </trans-unit>
        <trans-unit id="096585dfd11ee121086fdfe39adc2486eb298a85" translate="yes" xml:space="preserve">
          <source>This function takes a Python object and optional parameters for slicing and returns the start, stop, step, and slice length for the requested slice.</source>
          <target state="translated">Эта функция принимает объект Python и дополнительные параметры для нарезки и возвращает начало,остановку,шаг и длину среза для запрашиваемого среза.</target>
        </trans-unit>
        <trans-unit id="5c019865eaefe89398d12a470966b9e731ebcceb" translate="yes" xml:space="preserve">
          <source>This is how I teach slices to newbies:</source>
          <target state="translated">Вот как я учу новичков кусочкам:</target>
        </trans-unit>
        <trans-unit id="93ec6623e85643a7f24c84166f00188e862c3121" translate="yes" xml:space="preserve">
          <source>This is just for some extra info...
Consider the list below</source>
          <target state="translated">Это просто для дополнительной информации...Рассмотрим список ниже</target>
        </trans-unit>
        <trans-unit id="2f3bd8ad9ced207179166369787553277fa774f3" translate="yes" xml:space="preserve">
          <source>This is the diagram:</source>
          <target state="translated">Это диаграмма:</target>
        </trans-unit>
        <trans-unit id="30363f59507d9db8769972ab941783b864dbd2ab" translate="yes" xml:space="preserve">
          <source>This is the intelligence that is present behind slices. Since Python has an built-in function called slice, you can pass some parameters and check how smartly it calculates missing parameters.</source>
          <target state="translated">Это интеллект,который присутствует за кусочками.Так как Python имеет встроенную функцию под названием slice,вы можете передать некоторые параметры и проверить,насколько умно она вычисляет недостающие параметры.</target>
        </trans-unit>
        <trans-unit id="d57f5dd395014f54497c19cddb5a2ce5c7ea7a57" translate="yes" xml:space="preserve">
          <source>This may also clarify the difference between slicing and indexing.</source>
          <target state="translated">Это может также прояснить разницу между нарезкой и индексацией.</target>
        </trans-unit>
        <trans-unit id="b95f0acc0a5d079ab45b81544212226023725e34" translate="yes" xml:space="preserve">
          <source>This pretty property tells me that &lt;code&gt;lst[start:end]&lt;/code&gt; does not contain the &lt;code&gt;end&lt;/code&gt;-th item because it is in &lt;code&gt;lst[end:]&lt;/code&gt;.</source>
          <target state="translated">Это симпатичное свойство говорит мне, что &lt;code&gt;lst[start:end]&lt;/code&gt; не содержит элемент &lt;code&gt;end&lt;/code&gt; -th, потому что он находится в &lt;code&gt;lst[end:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8007629ae4bd6492e6ac3709a0f6817d52e38741" translate="yes" xml:space="preserve">
          <source>This way, I can think of &lt;code&gt;a[-4:-6:-1]&lt;/code&gt; as &lt;code&gt;a(-6,-4]&lt;/code&gt; in interval terminology.</source>
          <target state="translated">Таким образом, я могу думать о &lt;code&gt;a[-4:-6:-1]&lt;/code&gt; как &lt;code&gt;a(-6,-4]&lt;/code&gt; в интервальной терминологии.</target>
        </trans-unit>
        <trans-unit id="88160c485e5bf5fb043177dc6d2bf96217e61ab0" translate="yes" xml:space="preserve">
          <source>This works for me anyway...</source>
          <target state="translated">Это все равно работает на меня...</target>
        </trans-unit>
        <trans-unit id="36a968ddf7619f1775f5b9341d45ab5c6d7d9f33" translate="yes" xml:space="preserve">
          <source>Thus a negative slice will change the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;!</source>
          <target state="translated">Таким образом, отрицательный срез изменит значения по умолчанию для &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="6c35d5a48cbaacaa30e85a96cdc7b46a6bf157e1" translate="yes" xml:space="preserve">
          <source>Till now you have picked boxes continuously. But sometimes you need to pick up discretely. For example, you can pick up every second box. You can even pick up every third box from the end. This value is called step size. This represents the gap between your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa.</source>
          <target state="translated">До сих пор ты постоянно выбирал коробки.Но иногда нужно подбирать дискретно.Например,вы можете подобрать каждую вторую коробку.Вы даже можете забрать каждую третью коробку с конца.Это значение называется размер шага.Оно представляет собой промежуток между вашими последовательными пикировками.Размер шага должен быть положительным,если вы пикируете ящики от начала до конца и наоборот.</target>
        </trans-unit>
        <trans-unit id="31ee61905e41466bdf813b3f8668d410b0e1fa58" translate="yes" xml:space="preserve">
          <source>To begin with, let's define a few terms:</source>
          <target state="translated">Для начала давайте определим несколько терминов:</target>
        </trans-unit>
        <trans-unit id="2e1c54513da531934e461b5f4aa70c3c39a3e784" translate="yes" xml:space="preserve">
          <source>To make it simple, remember &lt;strong&gt;slice has only one form：&lt;/strong&gt;</source>
          <target state="translated">Чтобы было проще, помните, что &lt;strong&gt;ломтик имеет только одну форму:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6133370c4351e43ebcb470ed39b01c2df88aa87a" translate="yes" xml:space="preserve">
          <source>To me, this notation needs a bit of picking up.</source>
          <target state="translated">Для меня эта нотация должна быть немного подтянута.</target>
        </trans-unit>
        <trans-unit id="427ca464e82784a054828caeff41890bcf767d80" translate="yes" xml:space="preserve">
          <source>To retrieve a subset of elements, the start and stop positions need to be defined.</source>
          <target state="translated">Для получения подмножества элементов необходимо определить начальное и конечное положения.</target>
        </trans-unit>
        <trans-unit id="8e7a6a811c35a7adca15b7530f42f47e0dda5845" translate="yes" xml:space="preserve">
          <source>To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;implement the &lt;code&gt;__getitem__&lt;/code&gt; method of the sequence, according to the Python data model&lt;/a&gt;.)</source>
          <target state="translated">Чтобы использовать нотацию среза с последовательностью, которая ее поддерживает, необходимо включить хотя бы одно двоеточие в квадратные скобки, следующие за последовательностью (которые фактически &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;реализуют метод &lt;code&gt;__getitem__&lt;/code&gt; последовательности, согласно модели данных Python&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0e7a206b9021aa8d0ea3e3c6e22e9c2a9fd3b850" translate="yes" xml:space="preserve">
          <source>Understanding index assignment is very important.</source>
          <target state="translated">Понимание назначения индекса очень важно.</target>
        </trans-unit>
        <trans-unit id="eb8117520c3958acd43c0f8e454eeec3f534d349" translate="yes" xml:space="preserve">
          <source>Understanding slice notation</source>
          <target state="translated">Понимание нотации среза</target>
        </trans-unit>
        <trans-unit id="10c5a38a7a014349bab2658d201f411e1780237b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;step&lt;/code&gt; provides a useful trick to reverse a collection in Python:</source>
          <target state="translated">Использование &lt;code&gt;step&lt;/code&gt; предоставляет полезную хитрость для обращения коллекции в Python:</target>
        </trans-unit>
        <trans-unit id="625b0998df7fa1a8b226d789e201ac2c633e1b85" translate="yes" xml:space="preserve">
          <source>Using a negative step reverses the interpretation of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">Использование отрицательного шага меняет интерпретацию &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62654d2560fca6df984a34445f5e3dec93d4d93b" translate="yes" xml:space="preserve">
          <source>What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride.</source>
          <target state="translated">Что всегда работает,так это мыслить в символах или слотах и использовать индексирование как полуоткрытый интервал-вправо-открытый при положительном шаге,влево-открытый при отрицательном шаге.</target>
        </trans-unit>
        <trans-unit id="526db1adfef28b92b75500e179ee7473e39b4025" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;step&lt;/code&gt; is negative, the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; change</source>
          <target state="translated">Когда &lt;code&gt;step&lt;/code&gt; отрицательный, по умолчанию для &lt;code&gt;start&lt;/code&gt; и &lt;code&gt;stop&lt;/code&gt; изменения</target>
        </trans-unit>
        <trans-unit id="2c8d0413ebb06c76b410bc829582598046a90e73" translate="yes" xml:space="preserve">
          <source>When I see this, I read the part in the brackets as &quot;9th from the end, to the end.&quot; (Actually, I abbreviate it mentally as &quot;-9, on&quot;)</source>
          <target state="translated">Когда я вижу это,я читаю часть в скобках как &quot;9-я от конца,до конца&quot;.(Вообще-то,я мысленно сокращаю ее как &quot;-9,дальше&quot;).</target>
        </trans-unit>
        <trans-unit id="6847d5ecc89aafb251c20bc69d5137967a12634d" translate="yes" xml:space="preserve">
          <source>When slicing from the start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose:</source>
          <target state="translated">При нарезке с начала вы можете опустить нулевой индекс,а при нарезке до конца вы можете опустить итоговый индекс,так как он является избыточным,поэтому не будьте многословным:</target>
        </trans-unit>
        <trans-unit id="0331d52f669a9d089e322197c2a42b467d18a25b" translate="yes" xml:space="preserve">
          <source>When slicing, if you leave out any parameter, Python tries to figure it out automatically.</source>
          <target state="translated">При нарезке,если вы упускаете любой параметр,Python пытается разобраться с ним автоматически.</target>
        </trans-unit>
        <trans-unit id="ec05e68a3474403744db580556c5b4b5147a48ab" translate="yes" xml:space="preserve">
          <source>When using a negative step, notice that the answer is shifted to the right by 1.</source>
          <target state="translated">При использовании отрицательного шага,обратите внимание,что ответ сдвинут вправо на 1.</target>
        </trans-unit>
        <trans-unit id="d52f5e951410da3205e348d328fbec3fed74bc94" translate="yes" xml:space="preserve">
          <source>When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range:</source>
          <target state="translated">Когда вы говорите [a:b:c],вы говорите в зависимости от знака c (вперед или назад),начинайте с a и заканчивайте с b (исключая элемент в индексе bth).Используйте правило индексирования выше и помните,что вы найдете только элементы в этом диапазоне:</target>
        </trans-unit>
        <trans-unit id="60ffa2bfa59ad91cfa5b5fac46b9f1af335ca27a" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;:&lt;/code&gt;-based notation is very helpful for simple slicing, the explicit use of &lt;code&gt;slice()&lt;/code&gt; objects simplifies the programmatic generation of slicing.</source>
          <target state="translated">Хотя нотация на основе: очень полезна для простого среза, явное использование объектов &lt;code&gt;slice()&lt;/code&gt; упрощает программную генерацию срезов.</target>
        </trans-unit>
        <trans-unit id="1fac29e5b50e4050ea0c9107b01d2b1be0ad4b52" translate="yes" xml:space="preserve">
          <source>Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.</source>
          <target state="translated">У Wiki Python есть эта удивительная картина,которая чётко различает индексирование и нарезку.</target>
        </trans-unit>
        <trans-unit id="dc7857679c446d31b3fa48d4d430634f0052baba" translate="yes" xml:space="preserve">
          <source>With extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon.</source>
          <target state="translated">С помощью расширенного синтаксиса индексирования мы получаем диапазон значений.Например,все значения извлекаются двоеточием.</target>
        </trans-unit>
        <trans-unit id="48850a7b49c3ba2cdae5d4c04076f27217921200" translate="yes" xml:space="preserve">
          <source>With slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number.</source>
          <target state="translated">С нарезкой,как только вы закончили,вы закончили;она не начинает нарезать задом наперёд.На Python вы не получите отрицательных результатов,если не попросите их явно,используя отрицательное число.</target>
        </trans-unit>
        <trans-unit id="8e6854e86dbd642a89919deb5004ced1375069af" translate="yes" xml:space="preserve">
          <source>X is the index of the first element you want.</source>
          <target state="translated">X-это индекс первого элемента,который вам нужен.</target>
        </trans-unit>
        <trans-unit id="1caf266993cb78b65a51c14f80f90f52a48c1ad0" translate="yes" xml:space="preserve">
          <source>Y is the index of the first element you &lt;em&gt;don't&lt;/em&gt; want.</source>
          <target state="translated">Y - индекс первого элемента, который вам &lt;em&gt;не&lt;/em&gt; нужен.</target>
        </trans-unit>
        <trans-unit id="37c763665adfe6c32f74ceb3ab85198ed95e14f3" translate="yes" xml:space="preserve">
          <source>You can also use slice assignment to remove one or more elements from a list:</source>
          <target state="translated">Вы также можете использовать назначение фрагментов для удаления одного или нескольких элементов из списка:</target>
        </trans-unit>
        <trans-unit id="f6537afebf0730bd8d23b3fe9847bf52f1415c3b" translate="yes" xml:space="preserve">
          <source>You can even pick up the first three boxes or the last two boxes or all boxes between 1 and 4. So, you can pick any set of boxes if you know the beginning and ending. These positions are called start and stop positions.</source>
          <target state="translated">Вы даже можете забрать первые три коробки или последние две коробки или все коробки от 1 до 4.Таким образом,вы можете выбрать любой набор коробок,если знаете начало и конец.Эти позиции называются начальная и конечная позиции.</target>
        </trans-unit>
        <trans-unit id="c778f916c05737b62b181e6441afcd1a4fe8b894" translate="yes" xml:space="preserve">
          <source>You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;stop&lt;/em&gt;, and for the &lt;em&gt;step&lt;/em&gt;, you simply decrement your index. This example is &lt;a href=&quot;https://docs.python.org/2/tutorial/introduction.html&quot;&gt;from the documentation's tutorial&lt;/a&gt;, but I've modified it slightly to indicate which item in a sequence each index references:</source>
          <target state="translated">Вы можете сделать любое из этих положительных или отрицательных чисел. Смысл положительных чисел прост, но для отрицательных чисел, как и индексы в Python, вы начинаете отсчет с конца для &lt;em&gt;начала&lt;/em&gt; и конца, а для &lt;em&gt;шага&lt;/em&gt; вы просто уменьшаете свой индекс. Этот пример взят &lt;a href=&quot;https://docs.python.org/2/tutorial/introduction.html&quot;&gt;из учебного пособия по документации&lt;/a&gt; , но я немного изменил его, чтобы указать, на какой элемент в последовательности ссылается каждый индекс:</target>
        </trans-unit>
        <trans-unit id="9b7644b509b2bf8e1ff27f855c7f83b37789181c" translate="yes" xml:space="preserve">
          <source>You can run this script and experiment with it, below is some samples that I got from the script.</source>
          <target state="translated">Вы можете запустить этот скрипт и поэкспериментировать с ним,ниже приведены некоторые примеры,которые я получил из скрипта.</target>
        </trans-unit>
        <trans-unit id="64faa3902ada5ca110aa668c8de78a324815760c" translate="yes" xml:space="preserve">
          <source>You can then pass the slice object to your sequence:</source>
          <target state="translated">Затем вы можете передать ломтик объекта в вашу последовательность:</target>
        </trans-unit>
        <trans-unit id="195e61f26a2fef8e34f3db23bd78fcb41bfedb3e" translate="yes" xml:space="preserve">
          <source>You made a cut &lt;strong&gt;before&lt;/strong&gt; the element with index &lt;code&gt;2&lt;/code&gt; and another cut &lt;strong&gt;before&lt;/strong&gt; the element with index &lt;code&gt;5&lt;/code&gt;. So the result will be a slice between those two cuts, a list &lt;code&gt;['T', 'H', 'O']&lt;/code&gt;.</source>
          <target state="translated">Вы сделали разрез &lt;strong&gt;перед&lt;/strong&gt; элементом с индексом &lt;code&gt;2&lt;/code&gt; и еще один разрез &lt;strong&gt;перед&lt;/strong&gt; элементом с индексом &lt;code&gt;5&lt;/code&gt; . Таким образом, результатом будет срез между этими двумя разрезами, список &lt;code&gt;['T', 'H', 'O']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89d9115fa306118ea0f00933e8378ed5c6878642" translate="yes" xml:space="preserve">
          <source>You may find it useful to separate forming the slice from passing it to the &lt;code&gt;list.__getitem__&lt;/code&gt; method (&lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;that's what the square brackets do&lt;/a&gt;). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing.</source>
          <target state="translated">Может оказаться полезным отделить формирование среза от передачи его в метод &lt;code&gt;list.__getitem__&lt;/code&gt; (это &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;то, что делают квадратные скобки&lt;/a&gt; ). Даже если вы не новичок в этом, он делает ваш код более читабельным, чтобы другие, которым, возможно, придется читать ваш код, могли более легко понять, что вы делаете.</target>
        </trans-unit>
        <trans-unit id="8e3e016f8f3879b55e19d0fb4c4a1a15482a3faa" translate="yes" xml:space="preserve">
          <source>a b &lt;strong&gt;[&lt;/strong&gt; c d e f g h &lt;strong&gt;]&lt;/strong&gt; i j</source>
          <target state="translated">ab &lt;strong&gt;[&lt;/strong&gt; cdefgh &lt;strong&gt;]&lt;/strong&gt; ij</target>
        </trans-unit>
        <trans-unit id="a604aec6cdc49c95cd2d0c53292ad902a479d32d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;stop&lt;/code&gt;, the lower bound:</source>
          <target state="translated">и &lt;code&gt;stop&lt;/code&gt; , нижняя граница:</target>
        </trans-unit>
        <trans-unit id="631cab8239639a1208a15258a7f7aeda4d018888" translate="yes" xml:space="preserve">
          <source>and here is how it works:</source>
          <target state="translated">и вот как это работает:</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">и сейчас:</target>
        </trans-unit>
        <trans-unit id="ce39fead1872adb72fba2b688bc7e4b8311fc7f4" translate="yes" xml:space="preserve">
          <source>and to substitute the defaults (actually when &lt;code&gt;step&lt;/code&gt; is negative, &lt;code&gt;stop&lt;/code&gt;'s default is &lt;code&gt;-len(my_list) - 1&lt;/code&gt;, so &lt;code&gt;None&lt;/code&gt; for stop really just means it goes to whichever end step takes it to):</source>
          <target state="translated">и заменить значения по умолчанию (на самом деле, когда &lt;code&gt;step&lt;/code&gt; отрицателен, &lt;code&gt;stop&lt;/code&gt; умолчанию равен &lt;code&gt;-len(my_list) - 1&lt;/code&gt; , так что &lt;code&gt;None&lt;/code&gt; для стопа просто означает, что он переходит к тому, к какому конечному шагу он подходит):</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">эквивалентно:</target>
        </trans-unit>
        <trans-unit id="1110fd3a6c30458a698644d555d607d113a08279" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">возвращает &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9adbb8529fa7bf42a21e2483f8aa574d755b96e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;l&lt;/code&gt; is a collection, &lt;code&gt;start&lt;/code&gt; is an inclusive index, &lt;code&gt;end&lt;/code&gt; is an exclusive index, and &lt;code&gt;step&lt;/code&gt; is a stride that can be used to take every &lt;em&gt;nth&lt;/em&gt; item in &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">где &lt;code&gt;l&lt;/code&gt; - коллекция, &lt;code&gt;start&lt;/code&gt; - включающий индекс, &lt;code&gt;end&lt;/code&gt; - исключительный индекс, а &lt;code&gt;step&lt;/code&gt; - шаг, который можно использовать для получения каждого &lt;em&gt;n-го&lt;/em&gt; элемента в &lt;code&gt;l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b8a81384b7443c9cbeaad37bd4704f2d8b3165a" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;l&lt;/code&gt; is some collection, &lt;code&gt;start&lt;/code&gt; is an inclusive index, and &lt;code&gt;end&lt;/code&gt; is an exclusive index.</source>
          <target state="translated">где &lt;code&gt;l&lt;/code&gt; - некоторая коллекция, &lt;code&gt;start&lt;/code&gt; - включающий индекс, а &lt;code&gt;end&lt;/code&gt; - исключительный.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
