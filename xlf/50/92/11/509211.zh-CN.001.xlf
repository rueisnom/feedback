<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/509211">
    <body>
      <group id="509211">
        <trans-unit id="0aaf66473b71c5d42becc13d72b6f4ed70fedde3" translate="yes" xml:space="preserve">
          <source>(Python 3 gets a &lt;code&gt;list.copy&lt;/code&gt; and &lt;code&gt;list.clear&lt;/code&gt; method.)</source>
          <target state="translated">（Python 3获得 &lt;code&gt;list.copy&lt;/code&gt; 和 &lt;code&gt;list.clear&lt;/code&gt; 方法。）</target>
        </trans-unit>
        <trans-unit id="95d6f5f0e5758c7fa9092f862da9a2259661dfd4" translate="yes" xml:space="preserve">
          <source>1. Slice Notation</source>
          <target state="translated">1.切片记事法</target>
        </trans-unit>
        <trans-unit id="0f38c5a54db99d84e876f9b5eaa8720b9f3a9a26" translate="yes" xml:space="preserve">
          <source>2. Pitfalls</source>
          <target state="translated">2.隐患</target>
        </trans-unit>
        <trans-unit id="8862228b2902925878e3e9b09c1707ac7de719af" translate="yes" xml:space="preserve">
          <source>3. Examples</source>
          <target state="translated">3.3.例子</target>
        </trans-unit>
        <trans-unit id="a3d3ca439ad803f892271df58e7d3c810355f6fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;end&lt;/code&gt;: last index, &lt;strong&gt;NOTE that &lt;code&gt;end&lt;/code&gt; index will not be included in the resulted slice&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; ：最后一个索引， &lt;strong&gt;注意 &lt;code&gt;end&lt;/code&gt; 索引将不包含在结果切片中&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6643606539da7a52988dc6cf4ceeadabfd2aeb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: an object that can be sliced</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; ：可以切片的对象</target>
        </trans-unit>
        <trans-unit id="1b4c4192b9f7af406c63bd0fcecb821e5c7cd6f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt;: first index to start iteration</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; ：开始迭代的第一个索引</target>
        </trans-unit>
        <trans-unit id="f694d4d7856a4daa5fcd72c6329bb35f7a4a3b91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt;: pick element every &lt;code&gt;step&lt;/code&gt; index</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; ：选择每个 &lt;code&gt;step&lt;/code&gt; 元素索引</target>
        </trans-unit>
        <trans-unit id="31b0888c10f4ec32c43b2a524281bf1bc1307538" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A negative step means iterate the array backwards: from the end to start, with the end index included, and the start index excluded from the result.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;否定步骤意味着向后迭代数组：从头到尾，包括结束索引，并且从结果中排除开始索引。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dd769027176645af5d46752c43bf60e2cbab996" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basic Slicing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;基本切片&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03764b700c4114b7c7e0b1fc151ca8ee76b98522" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Python Figures Out Missing Parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Python如何找出缺失的参数：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a8df44af93130aa47cf7708478946a1e899c9b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: when step is negative, the default value for &lt;code&gt;start&lt;/code&gt; is &lt;code&gt;len(s)&lt;/code&gt; (while &lt;code&gt;end&lt;/code&gt; does not equal to &lt;code&gt;0&lt;/code&gt;, because &lt;code&gt;s[::-1]&lt;/code&gt; contains &lt;code&gt;s[0]&lt;/code&gt;). For example:</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：当step为负数时， &lt;code&gt;start&lt;/code&gt; 的默认值为 &lt;code&gt;len(s)&lt;/code&gt; 而 &lt;code&gt;end&lt;/code&gt; 不等于 &lt;code&gt;0&lt;/code&gt; ，因为 &lt;code&gt;s[::-1]&lt;/code&gt; 包含 &lt;code&gt;s[0]&lt;/code&gt; ）。 例如：</target>
        </trans-unit>
        <trans-unit id="a040621624a5c253662c247800c0317b88fdc6d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This post was originally written in my blog, &lt;em&gt;&lt;a href=&quot;https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html&quot;&gt;The Intelligence Behind Python Slices&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这篇文章最初是在我的博客&lt;em&gt;&lt;a href=&quot;https://avilpage.com/2015/03/a-slice-of-python-intelligence-behind.html&quot;&gt;Python切片背后的情报中&lt;/a&gt;&lt;/em&gt;撰写的。</target>
        </trans-unit>
        <trans-unit id="dd2468b43f8b0b0ef298ce86ccd65ed0c9f49ef9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Slicing With Step:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;切片步骤：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7fe67ddb4f6798a243fbf3c1c781e47c402b956c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Slicing can also be applied to multi-dimensional arrays.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;切片也可以应用于多维数组。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54689a39c2f4af595b96d8fcee877e522e69fc2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TODO&lt;/strong&gt;: The code below had a bug with &quot;never go outside the sequence&quot; when abs(step)&amp;gt;1; I &lt;em&gt;think&lt;/em&gt; I patched it to be correct, but it's hard to understand.</source>
          <target state="translated">&lt;strong&gt;待办事项&lt;/strong&gt; ：当abs（step）&amp;gt; 1;时，下面的代码有一个&amp;ldquo;永不超出序列&amp;rdquo;的错误； 我&lt;em&gt;认为&lt;/em&gt;我打补丁是正确的，但很难理解。</target>
        </trans-unit>
        <trans-unit id="120f2d378e6907d447c90878b70cfec95cfa80ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Understanding the difference between indexing and slicing:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;了解索引和切片之间的区别：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c3618c39203bd4928667eb7837893a51d2c72ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;start:&lt;/strong&gt; the beginning index of the slice, it will include the element at this index unless it is the same as &lt;em&gt;stop&lt;/em&gt;, defaults to 0, i.e. the first index. If it's negative, it means to start &lt;code&gt;n&lt;/code&gt; items from the end.</source>
          <target state="translated">&lt;strong&gt;start：&lt;/strong&gt;切片的开始索引，它将包含该索引处的元素，除非它与&lt;em&gt;stop&lt;/em&gt;相同，默认为0，即第一个索引。 如果为负，则意味着从末尾开始 &lt;code&gt;n&lt;/code&gt; 个项目。</target>
        </trans-unit>
        <trans-unit id="3b0828277ef33d65b168b24d8f7acb52b6e97797" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;step:&lt;/strong&gt; the amount by which the index increases, defaults to 1. If it's negative, you're slicing over the iterable in reverse.</source>
          <target state="translated">&lt;strong&gt;步骤：&lt;/strong&gt;索引增加的数量，默认为1。如果为负数，则按相反方向切片。</target>
        </trans-unit>
        <trans-unit id="f4d542aea390972989442b2f47543ac47e2b208f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stop:&lt;/strong&gt; the ending index of the slice, it does &lt;em&gt;not&lt;/em&gt; include the element at this index, defaults to length of the sequence being sliced, that is, up to and including the end.</source>
          <target state="translated">&lt;strong&gt;stop：&lt;/strong&gt;切片的结束索引， &lt;em&gt;不&lt;/em&gt;包含该索引处的元素，默认为要切片的序列的长度，即直到并包括结束。</target>
        </trans-unit>
        <trans-unit id="227dd9dbc0108dfd4661edff64d2fe881992bffb" translate="yes" xml:space="preserve">
          <source>After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a &lt;code&gt;for&lt;/code&gt; loop...</source>
          <target state="translated">使用了一点之后，我意识到最简单的描述是它与 &lt;code&gt;for&lt;/code&gt; 循环中的参数完全相同...</target>
        </trans-unit>
        <trans-unit id="ee7829458bdd9d9fb9e4d5d3a2fb33291ce2cf6c" translate="yes" xml:space="preserve">
          <source>Also, note that negative values for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are relative to the end of the list and computed in the example above by &lt;code&gt;given_index + a.shape[0]&lt;/code&gt;.</source>
          <target state="translated">另外，请注意， &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 负值相对于列表的末尾，并在上述示例中由 &lt;code&gt;given_index + a.shape[0]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70a021868ab3df3f88ae6899b164851777cd1b14" translate="yes" xml:space="preserve">
          <source>And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:</source>
          <target state="translated">还有几件事情,我第一次看到分片语法的时候,并不是马上就能看出来的。</target>
        </trans-unit>
        <trans-unit id="d105f3bd854548cc6f0bd3800349d324c615cb05" translate="yes" xml:space="preserve">
          <source>And clearing them is with:</source>
          <target state="translated">而清算他们是与。</target>
        </trans-unit>
        <trans-unit id="d25005772475e3ef4f540f81cb570f204b58a0d9" translate="yes" xml:space="preserve">
          <source>And if you wanted, for some reason, every second item in the reversed sequence:</source>
          <target state="translated">而如果你想,由于某些原因,每第二个项目都是反转的。</target>
        </trans-unit>
        <trans-unit id="77bb433c739e5798f1c99c633d2b911edd356fc6" translate="yes" xml:space="preserve">
          <source>And recall that there are defaults for &lt;em&gt;start&lt;/em&gt;, &lt;em&gt;stop&lt;/em&gt;, and &lt;em&gt;step&lt;/em&gt;, so to access the defaults, simply leave out the argument.</source>
          <target state="translated">并回想起&lt;em&gt;start&lt;/em&gt; ， &lt;em&gt;stop&lt;/em&gt;和&lt;em&gt;step&lt;/em&gt;有默认值，因此要访问默认值，只需省去参数。</target>
        </trans-unit>
        <trans-unit id="8d114526a29d613405e6408309b436a186ca0d52" translate="yes" xml:space="preserve">
          <source>And then once you've seen that, slice assignment to the empty slice makes sense too:</source>
          <target state="translated">而一旦看到这一点,切片分配到空的切片也就有了意义。</target>
        </trans-unit>
        <trans-unit id="5de2b62e17f6a84350d6fbe4ce6b42edec436e54" translate="yes" xml:space="preserve">
          <source>Another heuristic is, &quot;for any slice, replace the start by zero, apply the previous heuristic to get the end of the list, then count the first number back up to chop items off the beginning&quot;</source>
          <target state="translated">另一个启发式是,&quot;对于任何一个片断,将起始数替换为0,应用前一个启发式得到列表的末尾,然后将第一个数字往上数,将起始数砍掉。&quot;</target>
        </trans-unit>
        <trans-unit id="faa6734c0c057ce07a0df52181d494e9f022c4d5" translate="yes" xml:space="preserve">
          <source>Another import thing: &lt;strong&gt;all &lt;code&gt;start&lt;/code&gt;,&lt;code&gt;end&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt; can be omitted!&lt;/strong&gt; And if they are omitted, their default value will be used: &lt;code&gt;0&lt;/code&gt;,&lt;code&gt;len(s)&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt; accordingly.</source>
          <target state="translated">另一个导入的东西： &lt;strong&gt;所有 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; ， &lt;code&gt;step&lt;/code&gt; 都可以省略！&lt;/strong&gt; 如果省略它们，将使用其默认值： &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;len(s)&lt;/code&gt; ， &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7af9ada0982e5ec6222baca6341c1c5cff1f46c9" translate="yes" xml:space="preserve">
          <source>Any of them are optional:</source>
          <target state="translated">任何一个都可以选择。</target>
        </trans-unit>
        <trans-unit id="9e68e1c90bdbb11b1d0236fe65983d5f0f2685f0" translate="yes" xml:space="preserve">
          <source>As a general rule, writing code with a lot of hardcoded index values leads to a readability
and maintenance mess. For example, if you come back to the code a year later, you&amp;rsquo;ll
look at it and wonder what you were thinking when you wrote it. The solution shown
is simply a way of more clearly stating what your code is actually doing.
In general, the built-in slice() creates a slice object that can be used anywhere a slice
is allowed. For example:</source>
          <target state="translated">通常，编写带有很多硬编码索引值的代码会导致可读性和维护混乱。 例如，如果一年后返回代码，您将对其进行查看，并想知道编写代码时的想法。 显示的解决方案只是一种更清晰地说明代码实际运行方式的方式。 通常，内置slice（）创建一个slice对象，该对象可在允许slice的任何地方使用。 例如：</target>
        </trans-unit>
        <trans-unit id="a5d1179754e1ec07fb3a1e15a9fe95c4e93756e2" translate="yes" xml:space="preserve">
          <source>As you can see, defining only stop returns one element. Since the start defaults to none, this translates into retrieving only one element.</source>
          <target state="translated">正如你所看到的,定义只返回一个元素。由于start默认为none,这意味着只返回一个元素。</target>
        </trans-unit>
        <trans-unit id="10ddbc6f0ff07831197cae7c89a5e4feb5e47439" translate="yes" xml:space="preserve">
          <source>Backing up a little bit, what happens when you keep going with our procession of counting up the slice beginning?</source>
          <target state="translated">退一步说,当你继续和我们的游行,数起切片开始时,会发生什么?</target>
        </trans-unit>
        <trans-unit id="a0a44e8c2753c157919dea94666ab53b99900c6e" translate="yes" xml:space="preserve">
          <source>Be surprised: &lt;strong&gt;slice does not raise an IndexError when the index is out of range!&lt;/strong&gt;</source>
          <target state="translated">惊讶的是： &lt;strong&gt;当索引超出范围时，slice不会引发IndexError！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="51688e4ac0a45d12d7f9bb788db79cb941448aea" translate="yes" xml:space="preserve">
          <source>Begin from &lt;code&gt;start&lt;/code&gt;, increment by &lt;code&gt;step&lt;/code&gt;, do not reach &lt;code&gt;stop&lt;/code&gt;.  Very simple.</source>
          <target state="translated">从 &lt;code&gt;start&lt;/code&gt; ，逐步增加，不要到达 &lt;code&gt;stop&lt;/code&gt; 。 非常简单。</target>
        </trans-unit>
        <trans-unit id="4b2092c15e09d1d0a69d863b94fdb3e35c63e659" translate="yes" xml:space="preserve">
          <source>Below is the example usage:</source>
          <target state="translated">以下是示例用法。</target>
        </trans-unit>
        <trans-unit id="2b5c42838b863b4b8a4537944505370085a2f395" translate="yes" xml:space="preserve">
          <source>Below is the text of my original answer. It has been useful to many people, so I didn't want to delete it.</source>
          <target state="translated">以下是我最初的回答文字。这篇文章对很多人都有帮助,所以我不想删除。</target>
        </trans-unit>
        <trans-unit id="c47e4145f6e8d534763f4eeb46a2b86362f0690b" translate="yes" xml:space="preserve">
          <source>Besides basic slicing, it is also possible to apply the following notation:</source>
          <target state="translated">除了基本的切片外,还可以采用以下记号法。</target>
        </trans-unit>
        <trans-unit id="0b189ce87053a4a6f9151c04b8051585e6e4e7ff" translate="yes" xml:space="preserve">
          <source>Blank values are defaulted as follows: &lt;code&gt;[+0:-0:1]&lt;/code&gt;.</source>
          <target state="translated">空白值的默认值如下： &lt;code&gt;[+0:-0:1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ab9f5780bbd8ad36625e87ca02af9b8bf9361df" translate="yes" xml:space="preserve">
          <source>But occasionally a doubt creeps in and my brain asks for reassurance that it does not contain the &lt;code&gt;end&lt;/code&gt;-th element.</source>
          <target state="translated">但是偶尔会有一个疑问浮出水面，我的大脑要求保证它不包含 &lt;code&gt;end&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="25e3d76337cea9e9d631c334c54bbcb275c06f0f" translate="yes" xml:space="preserve">
          <source>But this range continues in both directions infinitely:</source>
          <target state="translated">但这个范围却在两个方向上无限延伸。</target>
        </trans-unit>
        <trans-unit id="313813cd850a6b775a1fb26d3d9c84054d7263b9" translate="yes" xml:space="preserve">
          <source>But you can pass in a negative integer, and the list (or most other standard slicables) will be sliced from the end to the beginning.</source>
          <target state="translated">但你可以传入一个负整数,列表(或大多数其他标准的分片器)将从尾部到开头进行分片。</target>
        </trans-unit>
        <trans-unit id="78c9a2985c6c2db62af25652b536f68dff04e931" translate="yes" xml:space="preserve">
          <source>By default, when the &lt;code&gt;step&lt;/code&gt; argument is empty (or &lt;code&gt;None&lt;/code&gt;), it is assigned to &lt;code&gt;+1&lt;/code&gt;.</source>
          <target state="translated">默认情况下，当 &lt;code&gt;step&lt;/code&gt; 参数为空（或 &lt;code&gt;None&lt;/code&gt; ）时，会将其分配给 &lt;code&gt;+1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74e101616da42c9f860f041e06e88cf3afc9af8d" translate="yes" xml:space="preserve">
          <source>Coming from other programming languages, that's when the common sense gets compromised. What are x and y?</source>
          <target state="translated">来自于其他编程语言,这时常识就会受到影响。什么是x和y?</target>
        </trans-unit>
        <trans-unit id="114f22f6d7079d292a7e78398094c20f332e1368" translate="yes" xml:space="preserve">
          <source>Confirming this in the source</source>
          <target state="translated">在源头上确认了这一点</target>
        </trans-unit>
        <trans-unit id="3eb94acf98e91b224000fb69a7e7764bf5d24a8e" translate="yes" xml:space="preserve">
          <source>Create two lists to slice. The first is a numeric list from 1 to 9 (List A). The second is also a numeric list, from 0 to 9 (List B):</source>
          <target state="translated">创建两个列表进行切片。第一个是一个数字列表,从1到9的数字列表(列表A)。第二个也是一个数字列表,从0到9(列表B)。</target>
        </trans-unit>
        <trans-unit id="57856d05bb32d5be32788eb0692ff1468ddf3c07" translate="yes" xml:space="preserve">
          <source>Depending on your application, that might... or might not... be what you were hoping for there!</source>
          <target state="translated">取决于你的申请,这可能......也可能不是........你所希望的!</target>
        </trans-unit>
        <trans-unit id="20f3af310b2b47de75d12e36f7756694568aec42" translate="yes" xml:space="preserve">
          <source>Don't worry about the &lt;code&gt;is None&lt;/code&gt; details - just remember that omitting &lt;code&gt;start&lt;/code&gt; and/or &lt;code&gt;stop&lt;/code&gt; always does the right thing to give you the whole sequence.</source>
          <target state="translated">不必担心&amp;ldquo; &lt;code&gt;is None&lt;/code&gt; 详细信息-请记住，省略 &lt;code&gt;start&lt;/code&gt; 和/或 &lt;code&gt;stop&lt;/code&gt; 总是可以正确地完成整个过程。</target>
        </trans-unit>
        <trans-unit id="6d6d1b284c6af28298538c5cdc0a7256d5d5f150" translate="yes" xml:space="preserve">
          <source>Easy way to reverse sequences!</source>
          <target state="translated">逆转序列的简单方法!</target>
        </trans-unit>
        <trans-unit id="dec3b85ab5c8afe4bdcf9aa78a36bb7b04f5b4e2" translate="yes" xml:space="preserve">
          <source>Enumerating the possibilities allowed by the grammar:</source>
          <target state="translated">列举语法允许的可能性。</target>
        </trans-unit>
        <trans-unit id="e2005c2f600247253cdd9b3a166cb5e388bbfb14" translate="yes" xml:space="preserve">
          <source>Explain Python's slice notation</source>
          <target state="translated">解释一下Python的切片记事法</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="ad2d3fd5da36e4d1450b52434f65543e2c249274" translate="yes" xml:space="preserve">
          <source>Extended indexing syntax used for slicing is aList[start:stop:step]. The start argument and the step argument both default to none - the only required argument is stop. Did you notice this is similar to how range was used to define lists A and B? This is because the slice object represents the set of indices specified by range(start, stop, step). Python 3.4 documentation.</source>
          <target state="translated">用于分片的扩展索引语法是aList[start:stop:step]。start参数和step参数都默认为无-唯一需要的参数是stop。你有没有注意到,这和以前定义列表A和B的范围类似?这是因为slice对象表示由range(start、stop、step)指定的索引集。Python 3.4 文档。</target>
        </trans-unit>
        <trans-unit id="25a46e8db798e121dc4a998aaa52b7c9c2f4ec77" translate="yes" xml:space="preserve">
          <source>Extended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.</source>
          <target state="translated">扩展分片(带逗号和省略号)大多只在特殊数据结构(如NumPy)中使用,基本序列不支持。</target>
        </trans-unit>
        <trans-unit id="2ce6a2c45d1f432b7017f6d8ad6c6f1f419ab941" translate="yes" xml:space="preserve">
          <source>Few other tricks for reversing the list:</source>
          <target state="translated">还有一些其他的翻盘技巧。</target>
        </trans-unit>
        <trans-unit id="53c11609ebb7eeb39c6ae1148df32803811abaf7" translate="yes" xml:space="preserve">
          <source>First, we will create a list of values to use in our slicing.</source>
          <target state="translated">首先,我们将创建一个值的列表,以便在我们的切片中使用。</target>
        </trans-unit>
        <trans-unit id="189f73dcf0d0e026377e4c161485f0bca4a39a7e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;, negative values are interpreted as being relative to the end of the sequence.</source>
          <target state="translated">对于 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; ，负值被解释为相对于序列的结尾。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="ad09b9342bcb6da8bd5c7a868860d3b6440eb901" translate="yes" xml:space="preserve">
          <source>For those who don't know, you can create any substring from &lt;code&gt;azString&lt;/code&gt; using the notation &lt;code&gt;azString[x:y]&lt;/code&gt;</source>
          <target state="translated">对于那些不知道的人，您可以使用 &lt;code&gt;azString[x:y]&lt;/code&gt; 表示法从 &lt;code&gt;azString&lt;/code&gt; 创建任何子字符串</target>
        </trans-unit>
        <trans-unit id="c2d2d5928c54cd3be6435296e94075da9fefa553" translate="yes" xml:space="preserve">
          <source>Found this great table at &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages中&lt;/a&gt;找到了这张很棒的桌子</target>
        </trans-unit>
        <trans-unit id="666ad671cbeba0a89e7c706687f77df7b879dbc2" translate="yes" xml:space="preserve">
          <source>From the diagram, I expect &lt;code&gt;a[-4,-6,-1]&lt;/code&gt; to be &lt;code&gt;yP&lt;/code&gt; but it is &lt;code&gt;ty&lt;/code&gt;.</source>
          <target state="translated">从图中，我希望 &lt;code&gt;a[-4,-6,-1]&lt;/code&gt; 是 &lt;code&gt;yP&lt;/code&gt; ,但它是 &lt;code&gt;ty&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="181af959e4f8d0fb4083b24c9a79dcab0d808777" translate="yes" xml:space="preserve">
          <source>Give your slices a descriptive name!</source>
          <target state="translated">给你的切片起个描述性的名字!</target>
        </trans-unit>
        <trans-unit id="d8bca9c064390cb40eb6923b46c08e356cc9a63d" translate="yes" xml:space="preserve">
          <source>Given the pattern aList[start:stop], retrieve the first two elements from List A.</source>
          <target state="translated">给出模式aList[start:stop],从列表A中检索前两个元素。</target>
        </trans-unit>
        <trans-unit id="f94faa9a2d2714420791cc753d22514493d014e9" translate="yes" xml:space="preserve">
          <source>Here is an example visualization of that ...</source>
          <target state="translated">这里是一个可视化的例子.....</target>
        </trans-unit>
        <trans-unit id="77b2dd3c3ff1e4885a243132aecac207f224e3f5" translate="yes" xml:space="preserve">
          <source>How Indexing Works</source>
          <target state="translated">如何进行索引编制</target>
        </trans-unit>
        <trans-unit id="6f1f32310474f8326626103969ab54a0b5070606" translate="yes" xml:space="preserve">
          <source>How Slicing Works</source>
          <target state="translated">切片是如何工作的</target>
        </trans-unit>
        <trans-unit id="3da40c095b10f44487cd4ccca0f47467d44aa681" translate="yes" xml:space="preserve">
          <source>However, using a negative value for &lt;code&gt;step&lt;/code&gt; could become very confusing. Moreover, in order to be &lt;a href=&quot;https://en.wiktionary.org/wiki/Pythonic#Adjective&quot;&gt;Pythonic&lt;/a&gt;, you should avoid using &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; in a single slice. In case this is required, consider doing this in two assignments (one to slice, and the other to stride).</source>
          <target state="translated">但是，为 &lt;code&gt;step&lt;/code&gt; 使用负值可能会造成很大的混乱。 此外，为了成为&lt;a href=&quot;https://en.wiktionary.org/wiki/Pythonic#Adjective&quot;&gt;Pythonic&lt;/a&gt; ，您应该避免在单个切片中使用 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt; 和 &lt;code&gt;step&lt;/code&gt; 。 如果需要这样做，请考虑分两次进行（一次进行切片，另一次进行跨步）。</target>
        </trans-unit>
        <trans-unit id="4ad93a5dd4fcd6d7c940755502a6bc63d374feb4" translate="yes" xml:space="preserve">
          <source>However, you can't just assign some integers separated by colons to a variable. You need to use the slice object:</source>
          <target state="translated">但是,你不能只给一个变量分配一些用冒号隔开的整数。你需要使用slice对象。</target>
        </trans-unit>
        <trans-unit id="aaa8f93b237e6d327bf33efc09bdaf86ccf36c81" translate="yes" xml:space="preserve">
          <source>I don't think that the &lt;a href=&quot;https://docs.python.org/3/tutorial/introduction.html#strings&quot;&gt;Python tutorial&lt;/a&gt; diagram (cited in various other answers) is good as this suggestion works for positive stride, but does not for a negative stride.</source>
          <target state="translated">我认为&lt;a href=&quot;https://docs.python.org/3/tutorial/introduction.html#strings&quot;&gt;Python教程&lt;/a&gt;图（在其他各种答案中被引用）不是很好，因为该建议对积极的步伐有效，但对消极的步伐却无效。</target>
        </trans-unit>
        <trans-unit id="c138ed3c54e5f033afa16fdbd5fccf8d39b80779" translate="yes" xml:space="preserve">
          <source>I find it easier to remember how it works, and then I can figure out any specific start/stop/step combination.</source>
          <target state="translated">我觉得这样更容易记住它的工作原理,然后我就能想出任何具体的启动步骤组合。</target>
        </trans-unit>
        <trans-unit id="ef399e0ded15774144fa63ae11d01aba3089469e" translate="yes" xml:space="preserve">
          <source>I had to sit down and run several scenarios in my quest for a memorization technique that will help me remember what x and y are and help me slice strings properly at the first attempt.</source>
          <target state="translated">在寻找背诵技巧的过程中,我不得不坐下来,跑了好几个场景,希望能帮助我记住x和y是什么,并帮助我在第一次尝试的时候正确地切线。</target>
        </trans-unit>
        <trans-unit id="c7d0e42afda61407f67326f1c6eb38abab198765" translate="yes" xml:space="preserve">
          <source>I hope this will help you to model the list in Python.</source>
          <target state="translated">希望对大家在Python中的列表建模有帮助。</target>
        </trans-unit>
        <trans-unit id="77b54aef5e492c40146cd9a6d0b499de291945d3" translate="yes" xml:space="preserve">
          <source>I like to encourage users to read the source as well as the documentation. The &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/sliceobject.c&quot;&gt;source code for slice objects and this logic is found here&lt;/a&gt;. First we determine if &lt;code&gt;step&lt;/code&gt; is negative:</source>
          <target state="translated">我希望鼓励用户阅读源代码和文档。 &lt;a href=&quot;https://github.com/python/cpython/blob/master/Objects/sliceobject.c&quot;&gt;切片对象&lt;/a&gt;的源代码和此逻辑可在此处找到 。 首先，我们确定 &lt;code&gt;step&lt;/code&gt; 是否为负：</target>
        </trans-unit>
        <trans-unit id="5d3b3b36c387b5d0fc042b55acf61c2d549b5f7d" translate="yes" xml:space="preserve">
          <source>I need a good explanation (references are a plus) on Python's slice notation.</source>
          <target state="translated">我需要一个关于Python的切片标记法的好的解释(参考文献是个加分项)。</target>
        </trans-unit>
        <trans-unit id="ad507a3da03671c61941620ae7a2906912f4a37b" translate="yes" xml:space="preserve">
          <source>I personally think about it like a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">我个人认为它像一个 &lt;code&gt;for&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="98382aeb1507eab72853d9ce777b3db6e8f02198" translate="yes" xml:space="preserve">
          <source>I use the &quot;an index points between elements&quot; method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:</source>
          <target state="translated">我自己用 &quot;元素之间的索引点 &quot;的方法来思考它,但有一种描述方法有时会帮助别人得到它,那就是这样的。</target>
        </trans-unit>
        <trans-unit id="7c6fedebad3f718314d64d61745e8419abe48090" translate="yes" xml:space="preserve">
          <source>I want to add one &lt;em&gt;Hello, World!&lt;/em&gt; example that explains the basics of slices for the very beginners. It helped me a lot.</source>
          <target state="translated">我要添加一个&lt;em&gt;世界您好！&lt;/em&gt; 该示例为初学者解释了切片的基础知识。 这对我帮助很大。</target>
        </trans-unit>
        <trans-unit id="152b4bcea4dcb6a08bc28ea6e60677690158dfe0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stride&lt;/code&gt; is negative, the ordering is changed a bit since we're counting down:</source>
          <target state="translated">如果 &lt;code&gt;stride&lt;/code&gt; 为负，则由于我们递减计数，因此顺序有所更改：</target>
        </trans-unit>
        <trans-unit id="cd1befa8b487c0ecabed83a3de28c3d4c4a8dbce" translate="yes" xml:space="preserve">
          <source>If so, the lower bound is &lt;code&gt;-1&lt;/code&gt;  meaning we slice all the way up to and including the beginning, and the upper bound is the length minus 1, meaning we start at the end. (Note that the semantics of this &lt;code&gt;-1&lt;/code&gt; is &lt;em&gt;different&lt;/em&gt; from a &lt;code&gt;-1&lt;/code&gt; that users may pass indexes in Python indicating the last item.)</source>
          <target state="translated">如果是这样，则下限是 &lt;code&gt;-1&lt;/code&gt; ,这意味着我们将一直切到开始并包括起点，而上限是长度减去1，这意味着我们从结尾开始。 （请注意，此 &lt;code&gt;-1&lt;/code&gt; 的语义与-1的含义 &lt;em&gt;不同&lt;/em&gt; ，用户可以通过 &lt;code&gt;-1&lt;/code&gt; 在Python中传递指示最后一项的索引。）</target>
        </trans-unit>
        <trans-unit id="2f065d470b215e663b57b87dd50c698f07db3377" translate="yes" xml:space="preserve">
          <source>If the index is out of range, Python will try its best to set the index to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;len(s)&lt;/code&gt; according to the situation. For example:</source>
          <target state="translated">如果索引超出范围，Python将根据情况尽最大努力将索引设置为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;len(s)&lt;/code&gt; 。 例如：</target>
        </trans-unit>
        <trans-unit id="8def849642c7353545fcda04de289db5103721fe" translate="yes" xml:space="preserve">
          <source>If the start and end indexes are omitted when performing an assignment operation, the entire content of the collection will be replaced with a copy of what is referenced:</source>
          <target state="translated">如果在执行赋值操作时省略了开始和结束索引,那么整个集合的内容将被替换为被引用的内容的副本。</target>
        </trans-unit>
        <trans-unit id="661ece95ee93a03aaa302b463dca836f55c6dd14" translate="yes" xml:space="preserve">
          <source>If you check the source code of &lt;a href=&quot;http://en.wikipedia.org/wiki/CPython&quot;&gt;CPython&lt;/a&gt;, you will find a function called PySlice_GetIndicesEx() which figures out indices to a slice for any given parameters. Here is the logical equivalent code in Python.</source>
          <target state="translated">如果检查&lt;a href=&quot;http://en.wikipedia.org/wiki/CPython&quot;&gt;CPython&lt;/a&gt;的源代码，则会发现一个名为PySlice_GetIndicesEx（）的函数，该函数可以为任何给定参数找出切片的索引。 这是Python中的逻辑等效代码。</target>
        </trans-unit>
        <trans-unit id="47b5bc36bf784848f762edafdff62074643233f8" translate="yes" xml:space="preserve">
          <source>If you feel negative indices in slicing is confusing, here's a very easy way to think about it: just replace the negative index with &lt;code&gt;len - index&lt;/code&gt;. So for example, replace -3 with &lt;code&gt;len(list) - 3&lt;/code&gt;.</source>
          <target state="translated">如果您认为切片时使用负索引会造成混淆，这是一种很简单的思考方法：只需将 &lt;code&gt;len - index&lt;/code&gt; 替换为负索引即可 。 因此，例如，将-3替换为 &lt;code&gt;len(list) - 3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa833ad31212b2a3b3d439a0e7c53b383e2b3ca5" translate="yes" xml:space="preserve">
          <source>If you have a slice instance s, you can get more information about it by looking at its
s.start, s.stop, and s.step attributes, respectively. For example:</source>
          <target state="translated">如果你有一个slice实例s,你可以通过查看它的s.start、s.stop和s.step属性,分别获得更多关于它的信息。比如说。</target>
        </trans-unit>
        <trans-unit id="f3d97417ba0181b71f5aaffd104fe653cf71364a" translate="yes" xml:space="preserve">
          <source>If you omit the start and end index, you will make a copy of the collection:</source>
          <target state="translated">如果省略了开头和结尾索引,就会把收藏品复制出来。</target>
        </trans-unit>
        <trans-unit id="f60db26cf6492e7fc7bbed6f90da520c3f57371b" translate="yes" xml:space="preserve">
          <source>If your choice of a, b, and c allows overlap with the range above as you traverse using rules for a,b,c above you will either get a list with elements (touched during traversal) or you will get an empty list.</source>
          <target state="translated">如果你选择的a、b和c允许与上面的范围重叠,当你使用上面的a、b、c的规则进行遍历时,你将得到一个包含元素的列表(在遍历过程中被触及),或者你将得到一个空的列表。</target>
        </trans-unit>
        <trans-unit id="f466c12bda6762ec7169a18df85f167e0081116f" translate="yes" xml:space="preserve">
          <source>Important Definitions</source>
          <target state="translated">重要的定义</target>
        </trans-unit>
        <trans-unit id="f2bb9ecf761b6e88e8102a7536ee8d44abe40249" translate="yes" xml:space="preserve">
          <source>In Python 2.7</source>
          <target state="translated">在Python 2.7中</target>
        </trans-unit>
        <trans-unit id="90a6eb777e8cda542826e3c6334816f4f0ee8eb6" translate="yes" xml:space="preserve">
          <source>In Python, the most basic form for slicing is the following:</source>
          <target state="translated">在Python中,分片的最基本形式如下。</target>
        </trans-unit>
        <trans-unit id="0ee248346d0af5cd683e4a36d0a440e60af3c740" translate="yes" xml:space="preserve">
          <source>In fact, compared to indexing, Python slicing is bizarrely error-proof:</source>
          <target state="translated">事实上,与索引化相比,Python切片的防错能力非常奇特。</target>
        </trans-unit>
        <trans-unit id="e26167c936dd528fda49f3a0a8e244ad7c09578d" translate="yes" xml:space="preserve">
          <source>In my opinion, you will understand and memorize better the Python string slicing notation if you look at it the following way (read on).</source>
          <target state="translated">在我看来,如果你用下面的方法来看,你会更好地理解和记忆Python字符串切片符号(继续阅读)。</target>
        </trans-unit>
        <trans-unit id="f7dabe40d708c905a0cefb23cf2333f28977c80b" translate="yes" xml:space="preserve">
          <source>In short, the colons (&lt;code&gt;:&lt;/code&gt;) in subscript notation (&lt;code&gt;subscriptable[subscriptarg]&lt;/code&gt;) make slice notation - which has the optional arguments, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;:</source>
          <target state="translated">简而言之，下标符号（ &lt;code&gt;subscriptable[subscriptarg]&lt;/code&gt; ）中的冒号（：）成为切片符号-该符号具有可选参数 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;stop&lt;/code&gt; 和 &lt;code&gt;step&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bb5e2ff5da706301f634ce9ca90e75ed00059cba" translate="yes" xml:space="preserve">
          <source>In these moments I rely on this simple theorem:</source>
          <target state="translated">在这些时刻,我依靠这个简单的定理。</target>
        </trans-unit>
        <trans-unit id="5870a8ca498a1c74154e2cfd9acc8e21c121fdb0" translate="yes" xml:space="preserve">
          <source>Index the number 3 from A and the number 6 from B.</source>
          <target state="translated">将A的数字3和B的数字6索引出来。</target>
        </trans-unit>
        <trans-unit id="3631e9d015a9f2d779f98610e8e9d63664c32ef5" translate="yes" xml:space="preserve">
          <source>Indexing is like dealing with the contents of box. You can check contents of any box. But you can't check the contents of multiple boxes at once. You can even replace the contents of the box. But you can't place two balls in one box or replace two balls at a time.</source>
          <target state="translated">索引就像处理框中的内容一样。你可以检查任何盒子的内容。但是,你不能同时检查多个盒子的内容。你甚至可以更换盒子里的内容物。但你不能把两个球放在一个盒子里,也不能一次更换两个球。</target>
        </trans-unit>
        <trans-unit id="2e852a9a85a011a4821ea957a6c18af49fdb2384" translate="yes" xml:space="preserve">
          <source>It is a list with six elements in it. To understand slicing better, consider that list as a set of six boxes placed together. Each box has an alphabet in it.</source>
          <target state="translated">它是一个包含六个元素的列表。为了更好地理解分片,可以把这个列表看成是一组六个盒子放在一起。每个盒子里都有一个字母表。</target>
        </trans-unit>
        <trans-unit id="72edc078c44d61355487724654334d433672237e" translate="yes" xml:space="preserve">
          <source>It is also possible to use negative integers for &lt;code&gt;step&lt;/code&gt; as the following example:</source>
          <target state="translated">也可以对 &lt;code&gt;step&lt;/code&gt; 使用负整数，如以下示例所示：</target>
        </trans-unit>
        <trans-unit id="d2e55fc42f854f48df8f7704c2076ef2f0b82f26" translate="yes" xml:space="preserve">
          <source>It is important to note, the first element is index 0, &lt;em&gt;not&lt;/em&gt; index 1. This is why we are using 2 lists for this exercise. List A's elements are numbered according to the ordinal position (the first element is 1, the second element is 2, etc.) while List B's elements are the numbers that would be used to index them ([0] for the first element 0, etc.).</source>
          <target state="translated">重要的是要注意，第一个元素是索引0， &lt;em&gt;而不是&lt;/em&gt;索引1。这就是为什么我们在此练习中使用2个列表的原因。 列表A的元素根据顺序位置编号（第一个元素为1，第二个元素为2，依此类推），而列表B的元素是将用于为其编号的数字（第一个元素为[0]，第一个元素为0，等等。）。</target>
        </trans-unit>
        <trans-unit id="8437802c00fcb02882fb640fb2f6aa10b7ed41e7" translate="yes" xml:space="preserve">
          <source>It is possible to provide indices that are out of bounds when slicing such as:</source>
          <target state="translated">可以在切片时提供出界的指数,如。</target>
        </trans-unit>
        <trans-unit id="cc08d6b3965c9cd2a7d0a9d353abfe631305e0ce" translate="yes" xml:space="preserve">
          <source>It looks extremely powerful, but I haven't quite got my head around it.</source>
          <target state="translated">它看起来非常强大,但我还没有想明白。</target>
        </trans-unit>
        <trans-unit id="c3478bf3faba9c41f22e71efd498abcab65d1e72" translate="yes" xml:space="preserve">
          <source>It's instructive to understand &lt;code&gt;range()&lt;/code&gt; first:</source>
          <target state="translated">首先了解 &lt;code&gt;range()&lt;/code&gt; 具有指导意义：</target>
        </trans-unit>
        <trans-unit id="db93970c161e9b60dc37836b4ad4bcc5e738b56f" translate="yes" xml:space="preserve">
          <source>It's interesting that ranges also take slices:</source>
          <target state="translated">有意思的是,范围也采取切片。</target>
        </trans-unit>
        <trans-unit id="393247b02d3798ab868c03bcc3f85e6ad9331f9b" translate="yes" xml:space="preserve">
          <source>It's pretty simple really:</source>
          <target state="translated">真的很简单</target>
        </trans-unit>
        <trans-unit id="07e297809eb4051826121e82a0caefbf899d3c86" translate="yes" xml:space="preserve">
          <source>Keep in mind that the result of slicing a collection is a whole new collection. In addition, when using slice notation in assignments, the length of the slice assignments do not need to be the same. The values before and after the assigned slice will be kept, and the collection will shrink or grow to contain the new values:</source>
          <target state="translated">请记住,切分集合的结果是一个全新的集合。另外,在分配时使用分片符号时,分片分配的长度不需要相同。分片赋值前后的值会被保留,而集合会缩小或增长,以包含新的值。</target>
        </trans-unit>
        <trans-unit id="cf594f555786da65b5bbbcfa5d1f5e37ff7665e6" translate="yes" xml:space="preserve">
          <source>Let's finish this answer with examples, explaining everything we have discussed:</source>
          <target state="translated">让我们用例子来完成这个答案,把我们讨论过的东西都解释清楚。</target>
        </trans-unit>
        <trans-unit id="26f47aa550adca492b5233c25393b47b841fe5ad" translate="yes" xml:space="preserve">
          <source>Let's have a list with six values &lt;code&gt;['P', 'Y', 'T', 'H', 'O', 'N']&lt;/code&gt;:</source>
          <target state="translated">让我们有一个包含六个值的列表 &lt;code&gt;['P', 'Y', 'T', 'H', 'O', 'N']&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7137555528de00a0bcf2c040f1daafce2f58347c" translate="yes" xml:space="preserve">
          <source>Let's work with the following string ...</source>
          <target state="translated">让我们用下面的字符串来工作......</target>
        </trans-unit>
        <trans-unit id="3f6a7a17387285ecbb29103e91399ef401031fff" translate="yes" xml:space="preserve">
          <source>Making things more confusing is that &lt;strong&gt;&lt;code&gt;step&lt;/code&gt; can be negative too!&lt;/strong&gt;</source>
          <target state="translated">使事情更加混乱的是，这一&lt;strong&gt; &lt;code&gt;step&lt;/code&gt; 也可能是负面的！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4d6fecb17d10399cfa47983f1042cccd5affc47" translate="yes" xml:space="preserve">
          <source>Memory Considerations:</source>
          <target state="translated">记忆方面的考虑。</target>
        </trans-unit>
        <trans-unit id="1ff1eb25d65b7e8b0b1c5bcc0650dd539ed6fbbd" translate="yes" xml:space="preserve">
          <source>More slicing examples: &lt;a href=&quot;https://docs.python.org/2.3/whatsnew/section-slices.html&quot;&gt;15 Extended Slices&lt;/a&gt;</source>
          <target state="translated">更多切片示例： &lt;a href=&quot;https://docs.python.org/2.3/whatsnew/section-slices.html&quot;&gt;15个扩展切片&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="236384af55aea443e68110eede08ce564e280d4c" translate="yes" xml:space="preserve">
          <source>Most of the previous answers clears up questions about slice notation.</source>
          <target state="translated">前面的回答,大部分都是澄清了关于切片记号的问题。</target>
        </trans-unit>
        <trans-unit id="258dc3b32b7b8c786022e52d99f1e20b993d915e" translate="yes" xml:space="preserve">
          <source>My brain seems happy to accept that &lt;code&gt;lst[start:end]&lt;/code&gt; contains the &lt;code&gt;start&lt;/code&gt;-th item. I might even say that it is a 'natural assumption'.</source>
          <target state="translated">我的大脑似乎很高兴接受 &lt;code&gt;lst[start:end]&lt;/code&gt; 包含第-st个项目。 我什至可以说这是一个&amp;ldquo;自然假设&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0e9abc9291766099a35bbc0daca4bfdba74ab393" translate="yes" xml:space="preserve">
          <source>My conclusion is that x and y should be seen as the boundary indexes that are surrounding the strings that we want to extra. So we should see the expression as &lt;code&gt;azString[index1, index2]&lt;/code&gt; or even more clearer as &lt;code&gt;azString[index_of_first_character, index_after_the_last_character]&lt;/code&gt;.</source>
          <target state="translated">我的结论是，x和y应该被视为包围我们要附加的字符串的边界索引。 因此，我们应该将表达式视为 &lt;code&gt;azString[index1, index2]&lt;/code&gt; 或更清晰的名称为 &lt;code&gt;azString[index_of_first_character, index_after_the_last_character]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bc0687f0ccd20cd39dcb014b119503d374c4139" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;start &amp;gt;= end&lt;/code&gt; (considering only when &lt;code&gt;step&amp;gt;0&lt;/code&gt;), Python will return a empty slice &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">注意：如果 &lt;code&gt;start &amp;gt;= end&lt;/code&gt; （仅在 &lt;code&gt;step&amp;gt;0&lt;/code&gt; 时考虑），Python将返回一个空切片 &lt;code&gt;[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3924ca69a9c6ef3c94b8adce539357eedbfe98b1" translate="yes" xml:space="preserve">
          <source>Negative indexes</source>
          <target state="translated">负指数</target>
        </trans-unit>
        <trans-unit id="19a3fcc38635b3630af723c1238943e8e1843247" translate="yes" xml:space="preserve">
          <source>Negative integers are useful when doing offsets relative to the end of a collection:</source>
          <target state="translated">负整数在做相对于集合末端的偏移时非常有用。</target>
        </trans-unit>
        <trans-unit id="afa9d728aad9ce367861bb103920cb5b75e339e7" translate="yes" xml:space="preserve">
          <source>Negative step</source>
          <target state="translated">负级</target>
        </trans-unit>
        <trans-unit id="96650fe967ba54c6b724f6429dd3614089107d32" translate="yes" xml:space="preserve">
          <source>Normalizing negative indexes first allows start and/or stop to be counted from the end independently: &lt;code&gt;'abcde'[1:-2] == 'abcde'[1:3] == 'bc'&lt;/code&gt; despite &lt;code&gt;range(1,-2) == []&lt;/code&gt;.
The normalization is sometimes thought of as &quot;modulo the length&quot;, but note it adds the length just once: e.g. &lt;code&gt;'abcde'[-53:42]&lt;/code&gt; is just the whole string.</source>
          <target state="translated">规范化负索引首先允许独立地从头开始和/或从头开始计数：尽管 &lt;code&gt;range(1,-2) == []&lt;/code&gt; 但 &lt;code&gt;'abcde'[1:-2] == 'abcde'[1:3] == 'bc'&lt;/code&gt; == [] 。 标准化有时被认为是&amp;ldquo;模数长度&amp;rdquo;，但请注意，它仅将长度加一次：例如， &lt;code&gt;'abcde'[-53:42]&lt;/code&gt; 只是整个字符串。</target>
        </trans-unit>
        <trans-unit id="4d43af0ad3abe59f6e4fb376c128181bd7bde7b5" translate="yes" xml:space="preserve">
          <source>Note that this theorem is true for any &lt;code&gt;n&lt;/code&gt; at all. For example, you can check that</source>
          <target state="translated">注意，该定理对于任何 &lt;code&gt;n&lt;/code&gt; 都是成立的。 例如，您可以检查</target>
        </trans-unit>
        <trans-unit id="2ceb96fc5e9a3dc2bc105bff4a65c7e6742be2cc" translate="yes" xml:space="preserve">
          <source>Note that, since we are not changing the second number of the slice (4), the inserted items always stack right up against the 'o', even when we're assigning to the empty slice. So the position for the empty slice assignment is the logical extension of the positions for the non-empty slice assignments.</source>
          <target state="translated">请注意,由于我们没有改变切片的第二个数字(4),所以插入的项总是紧贴着 &quot;O &quot;堆叠,即使我们分配到空切片时也是如此。所以空切片赋值的位置就是非空切片赋值的位置的逻辑延伸。</target>
        </trans-unit>
        <trans-unit id="967bf0aa1a3677571a7849b566735433ec166495" translate="yes" xml:space="preserve">
          <source>Now if you make a slice &lt;code&gt;[2:5]&lt;/code&gt; of the list above, this will happen:</source>
          <target state="translated">现在，如果您在上面的列表中切片 &lt;code&gt;[2:5]&lt;/code&gt; ，则会发生这种情况：</target>
        </trans-unit>
        <trans-unit id="e6df6b2bcf9a3314ee026c4f79df59cdd07fa7f8" translate="yes" xml:space="preserve">
          <source>Now the simplest slices of that list are its sublists. The notation is &lt;code&gt;[&amp;lt;index&amp;gt;:&amp;lt;index&amp;gt;]&lt;/code&gt; and the key is to read it like this:</source>
          <target state="translated">现在，该列表中最简单的部分就是其子列表。 表示法是 &lt;code&gt;[&amp;lt;index&amp;gt;:&amp;lt;index&amp;gt;]&lt;/code&gt; ，关键是像这样读取它：</target>
        </trans-unit>
        <trans-unit id="4b69184bd6d629ae67ecbb030f96e1b6febacc6a" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;(high-low)%stride != 0&lt;/code&gt;, then the end point will be a little lower than &lt;code&gt;high-1&lt;/code&gt;.</source>
          <target state="translated">当然，如果 &lt;code&gt;(high-low)%stride != 0&lt;/code&gt; ，则终点将略低于 &lt;code&gt;high-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9797498b5445b5a3c49a8d9a5a8bcc115a3f1de4" translate="yes" xml:space="preserve">
          <source>One heuristic is, for a slice from zero to n, think: &quot;zero is the beginning, start at the beginning and take n items in a list&quot;.</source>
          <target state="translated">一个启发式是,对于从0到n的切口,想一想:&quot;0是起始点,从起始点开始,在列表中取n项&quot;。</target>
        </trans-unit>
        <trans-unit id="1deb5c09927c43e07c799a375e42510fd8ab8301" translate="yes" xml:space="preserve">
          <source>One last thing: if a and b are equal, then also you get an empty list:</source>
          <target state="translated">最后一件事:如果a和b相等,那么你也会得到一个空列表。</target>
        </trans-unit>
        <trans-unit id="22de4720e28cbf22dbc85b732b56fab0a497d9da" translate="yes" xml:space="preserve">
          <source>One way to remember how slices work is to think of the indices as pointing &lt;em&gt;between&lt;/em&gt; characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of &lt;em&gt;n&lt;/em&gt; characters has index &lt;em&gt;n&lt;/em&gt;.</source>
          <target state="translated">记住切片如何工作的一种方法是将索引视为指向字符&lt;em&gt;之间的&lt;/em&gt;指针，第一个字符的左边缘编号为0。然后， &lt;em&gt;n个&lt;/em&gt;字符的字符串的最后一个字符的右侧边缘具有索引&lt;em&gt;n&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="01230747b9914341b6ea0abf3a127d2554050e61" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;step&lt;/code&gt; is positive, and the lower bound will be zero and the upper bound (which we go up to but not including) the length of the sliced list.</source>
          <target state="translated">否则， &lt;code&gt;step&lt;/code&gt; 为正，下界将为零，上限（我们将向上但不包括）为切片列表的长度。</target>
        </trans-unit>
        <trans-unit id="6ee09859ae901d353f04d7756fc619a422996265" translate="yes" xml:space="preserve">
          <source>Out of range error?</source>
          <target state="translated">超出范围误差?</target>
        </trans-unit>
        <trans-unit id="1e32d6d4f298657e76954434ba9df3c467b606d2" translate="yes" xml:space="preserve">
          <source>Positive indices for &lt;code&gt;end&lt;/code&gt; indicate the position &lt;em&gt;after&lt;/em&gt; the last element to be included.</source>
          <target state="translated">&lt;code&gt;end&lt;/code&gt; 的正索引指示要包含的最后一个元素&lt;em&gt;之后&lt;/em&gt;的位置。</target>
        </trans-unit>
        <trans-unit id="94740c4c4bc99ca509491718d4ba079f2a8f218e" translate="yes" xml:space="preserve">
          <source>Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for &lt;code&gt;a[:-2]&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.</source>
          <target state="translated">如果项目数量少于您的要求，Python对程序员很友好。 例如，如果您要求 &lt;code&gt;a[:-2]&lt;/code&gt; 并且 &lt;code&gt;a&lt;/code&gt; 仅包含一个元素，则会得到一个空列表而不是错误。 有时您会更喜欢该错误，因此您必须意识到这种情况可能会发生。</target>
        </trans-unit>
        <trans-unit id="b248a1be31c8962b0faa6461a8e1ebdb8bf936b1" translate="yes" xml:space="preserve">
          <source>Python slicing is a computationally fast way to methodically access parts of your data. In my opinion, to be even an intermediate Python programmer, it's one aspect of the language that it is necessary to be familiar with.</source>
          <target state="translated">Python分片是一种计算速度快的方法,可以有条不紊地访问部分数据。在我看来,要想成为一名中级的Python程序员,哪怕是中级的Python程序员,这也是这门语言必须要熟悉的一个方面。</target>
        </trans-unit>
        <trans-unit id="4be307b534051fdddbb09f680b1f90334e27c87c" translate="yes" xml:space="preserve">
          <source>Python slicing notation:</source>
          <target state="translated">Python 切片记事法。</target>
        </trans-unit>
        <trans-unit id="0f99ce71c7cc473f59ebcdd42fafcac7ebb5607c" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&lt;/a&gt;</source>
          <target state="translated">参考： &lt;a href=&quot;http://wiki.python.org/moin/MovingToPythonFromOtherLanguages&quot;&gt;http&lt;/a&gt; : //wiki.python.org/moin/MovingToPythonFromOtherLanguages</target>
        </trans-unit>
        <trans-unit id="85e3167baf4fe31a5ac66fca1064289b89090879" translate="yes" xml:space="preserve">
          <source>Relation to &lt;code&gt;slice()&lt;/code&gt; object</source>
          <target state="translated">与 &lt;code&gt;slice()&lt;/code&gt; 对象的关系</target>
        </trans-unit>
        <trans-unit id="ded5af84f53bac1b910e783dc1876f40d1930247" translate="yes" xml:space="preserve">
          <source>Remember that we are setting the boundaries. And those boundaries are the positions where you could place some brackets that will be wrapped around the substring like this ...</source>
          <target state="translated">记住,我们正在设置边界。而这些边界就是你可以在其中放置一些括号的位置,这些括号会像这样包裹着子字符串......</target>
        </trans-unit>
        <trans-unit id="87aef1727fb2103950e2e345944a306d9d583015" translate="yes" xml:space="preserve">
          <source>Sequence slicing is same, except it first normalizes negative indexes, and it can never go outside the sequence:</source>
          <target state="translated">序列切片也是一样的,只是它首先将负指数归一化,而且它永远不能走到序列之外。</target>
        </trans-unit>
        <trans-unit id="96eaebe560215c517ad3e5af8e2a9735ecb8738d" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;step&lt;/code&gt; may be a negative number:</source>
          <target state="translated">同样， &lt;code&gt;step&lt;/code&gt; 可以为负数：</target>
        </trans-unit>
        <trans-unit id="ae00240360bccc296201ca8138f454fe741d7f58" translate="yes" xml:space="preserve">
          <source>Since slices of Python lists create new objects in memory, another important function to be aware of is &lt;code&gt;itertools.islice&lt;/code&gt;. Typically you'll want to iterate over a slice, not just have it created statically in memory. &lt;code&gt;islice&lt;/code&gt; is perfect for this. A caveat, it doesn't support negative arguments to &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, or &lt;code&gt;step&lt;/code&gt;, so if that's an issue you may need to calculate indices or reverse the iterable in advance.</source>
          <target state="translated">由于Python列表切片在内存中创建了新对象，因此需要注意的另一个重要功能是 &lt;code&gt;itertools.islice&lt;/code&gt; 。 通常，您将需要遍历切片，而不仅仅是在内存中静态创建切片。 &lt;code&gt;islice&lt;/code&gt; 非常适合此。 请注意，它不支持 &lt;code&gt;start&lt;/code&gt; ， &lt;code&gt;stop&lt;/code&gt; 或 &lt;code&gt;step&lt;/code&gt; 的否定参数，因此，如果这是一个问题，则可能需要预先计算索引或反转可迭代对象。</target>
        </trans-unit>
        <trans-unit id="8c3c2e5e113c75c44c107bde062191fa1ee7c4b5" translate="yes" xml:space="preserve">
          <source>Slice notation to get the last nine elements from a list (or any other sequence that supports it, like a string) would look like this:</source>
          <target state="translated">从一个列表(或任何其他支持它的序列,如字符串)中获取最后9个元素的分片记号是这样的。</target>
        </trans-unit>
        <trans-unit id="afd155507ef02b023315f7f2437ce7518f12da0e" translate="yes" xml:space="preserve">
          <source>Slice notation works like this:</source>
          <target state="translated">切片记事法是这样的。</target>
        </trans-unit>
        <trans-unit id="2bf8562fbd4372800fdbdad7eef6770e5b0c3ac3" translate="yes" xml:space="preserve">
          <source>Slice objects also behave slightly differently depending on the number of arguments, similarly to &lt;code&gt;range()&lt;/code&gt;, i.e. both &lt;code&gt;slice(stop)&lt;/code&gt; and &lt;code&gt;slice(start, stop[, step])&lt;/code&gt; are supported.
To skip specifying a given argument, one might use &lt;code&gt;None&lt;/code&gt;, so that e.g. &lt;code&gt;a[start:]&lt;/code&gt; is equivalent to &lt;code&gt;a[slice(start, None)]&lt;/code&gt; or &lt;code&gt;a[::-1]&lt;/code&gt; is equivalent to &lt;code&gt;a[slice(None, None, -1)]&lt;/code&gt;.</source>
          <target state="translated">切片对象的行为也取决于参数的数量，与 &lt;code&gt;range()&lt;/code&gt; 略有不同，即，都支持 &lt;code&gt;slice(stop)&lt;/code&gt; 和 &lt;code&gt;slice(start, stop[, step])&lt;/code&gt; 。 要跳过指定给定参数的操作，可以使用 &lt;code&gt;None&lt;/code&gt; ，例如 &lt;code&gt;a[start:]&lt;/code&gt; 等同于 &lt;code&gt;a[slice(start, None)]&lt;/code&gt; 或 &lt;code&gt;a[::-1]&lt;/code&gt; 等同于 &lt;code&gt;a[slice(None, None, -1)]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0de34fe528d24a6ab78b22ea621d459ea58bcde" translate="yes" xml:space="preserve">
          <source>Slices hold references, not copies, of the array elements.  If you want to make a separate copy an array, you can use &lt;a href=&quot;https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python&quot;&gt;&lt;code&gt;deepcopy()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">切片包含数组元素的引用，而不是副本。 如果要为数组创建单独的副本，则可以使用&lt;a href=&quot;https://stackoverflow.com/questions/6532881/how-to-make-a-copy-of-a-2d-array-in-python&quot;&gt; &lt;code&gt;deepcopy()&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7a0ec14b698ea62c178c70915809b11eee0b1d4" translate="yes" xml:space="preserve">
          <source>Slicing example: [start:end:step]</source>
          <target state="translated">切片示例。[start:end:step]</target>
        </trans-unit>
        <trans-unit id="0fab7676f1313a7031d732db17a3266ea48b260e" translate="yes" xml:space="preserve">
          <source>Slicing in Python</source>
          <target state="translated">用Python进行切片</target>
        </trans-unit>
        <trans-unit id="2f82b358ce4a2bd3562b18aca5eb96f4abc16964" translate="yes" xml:space="preserve">
          <source>Slicing is like dealing with boxes themselves. You can pick up the first box and place it on another table. To pick up the box, all you need to know is the position of beginning and ending of the box.</source>
          <target state="translated">切片就像处理盒子本身一样。你可以拿起第一个盒子,把它放在另一张桌子上。要拿起盒子,你只需要知道盒子开始和结束的位置就可以了。</target>
        </trans-unit>
        <trans-unit id="b6071a94da6c32b2f41ecdb9b7c54c4fc53d3bbe" translate="yes" xml:space="preserve">
          <source>So all you have to do is setting index1 and index2 to the values that will surround the desired substring. For instance, to get the substring &quot;cdefgh&quot;, you can use &lt;code&gt;azString[2:8]&lt;/code&gt;, because the index on the left side of &quot;c&quot; is 2 and the one on the right size of &quot;h&quot; is 8.</source>
          <target state="translated">因此，您要做的就是将index1和index2设置为所需子字符串周围的值。 例如，要获取子字符串&amp;ldquo; cdefgh&amp;rdquo;，可以使用 &lt;code&gt;azString[2:8]&lt;/code&gt; ，因为&amp;ldquo; c&amp;rdquo;左侧的索引是2，而在&amp;ldquo; h&amp;rdquo;右侧的索引是8。</target>
        </trans-unit>
        <trans-unit id="9d36a8ded558a57acb9a21c94c859b6d67771f8e" translate="yes" xml:space="preserve">
          <source>So possible variations are:</source>
          <target state="translated">所以可能的变化是:</target>
        </trans-unit>
        <trans-unit id="5e112be622e92277daa08e6daca504e718916de7" translate="yes" xml:space="preserve">
          <source>That trick works all the time and is easy to memorize.</source>
          <target state="translated">这一招一直很管用,而且很容易背。</target>
        </trans-unit>
        <trans-unit id="fdf01cb06945a582fa2999e094744ca983173e6c" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;code&gt;:2&lt;/code&gt;&quot; before the comma operates on the first dimension and the &quot;&lt;code&gt;0:3:2&lt;/code&gt;&quot; after the comma operates on the second dimension.</source>
          <target state="translated">逗号在第一维上运行前的&amp;ldquo; &lt;code&gt;:2&lt;/code&gt; &amp;rdquo;和逗号在第二维上运行后的&amp;ldquo; &lt;code&gt;0:3:2&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="671738aa3584c456b592e354d91684dcd323f399" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#strings&quot;&gt;Python tutorial&lt;/a&gt; talks about it (scroll down a bit until you get to the part about slicing).</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/tutorial/introduction.html#strings&quot;&gt;Python教程&lt;/a&gt;对此进行了讨论（向下滚动直到您了解有关切片的内容）。</target>
        </trans-unit>
        <trans-unit id="fb121e6f32b2ed82d98fe529053634abd387ad84" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;colon&lt;/strong&gt;, &lt;code&gt;:&lt;/code&gt;,  is what tells Python you're giving it a slice and not a regular index. That's why the idiomatic way of making a shallow copy of lists in Python 2 is</source>
          <target state="translated">&lt;strong&gt;冒号&lt;/strong&gt; &lt;code&gt;:&lt;/code&gt; 告诉Python您在给它一个分片而不是一个常规索引。 这就是为什么在Python 2中制作列表的浅表副本的惯用方式是</target>
        </trans-unit>
        <trans-unit id="064ca1037f07ebe70ccb6e0e4303cf9c8fd960d8" translate="yes" xml:space="preserve">
          <source>The ASCII art diagram is helpful too for remembering how slices work:</source>
          <target state="translated">ASCII艺术图对记忆切片的工作原理也很有帮助。</target>
        </trans-unit>
        <trans-unit id="c2a53ea7c27bc274090377248543665760dc2d23" translate="yes" xml:space="preserve">
          <source>The above part explains the core features on how slice works, and it will work on most occasions. However, there can be pitfalls you should watch out, and this part explains them.</source>
          <target state="translated">以上部分介绍了slice的核心功能,在大多数情况下都能正常工作。但是,可能会有一些陷阱需要注意,本部分就为大家讲解一下。</target>
        </trans-unit>
        <trans-unit id="9a0d878051d5575a2cc4db1865d8619aa0945996" translate="yes" xml:space="preserve">
          <source>The answers above don't discuss slice assignment. To understand slice assignment, it's helpful to add another concept to the ASCII art:</source>
          <target state="translated">上面的答案不讨论切片赋值。要理解分片赋值,可以在ASCII艺术中加入另一个概念。</target>
        </trans-unit>
        <trans-unit id="4827bfb62b55032ff3bc19f8d7461338d02ba84c" translate="yes" xml:space="preserve">
          <source>The basic slicing technique is to define the starting point, the stopping point, and the step size - also known as stride.</source>
          <target state="translated">基本的分片技术是确定起点、停止点和步幅大小--也叫跨度。</target>
        </trans-unit>
        <trans-unit id="7afa04f193c1a31833d08e539febf8032a61d69d" translate="yes" xml:space="preserve">
          <source>The below is the example of an index of a string:</source>
          <target state="translated">下面是一个字符串的索引的例子。</target>
        </trans-unit>
        <trans-unit id="a6fdc6b5102e017e74aa1ebfa120ec1728976bd7" translate="yes" xml:space="preserve">
          <source>The best way to illustrate what slicing does internally is just show it in code that implements this operation:</source>
          <target state="translated">最好的方法是在内部说明切片的作用,只需在实现这个操作的代码中显示出来即可。</target>
        </trans-unit>
        <trans-unit id="9b289ec304478ab3aa8206822ac93132cd9189a0" translate="yes" xml:space="preserve">
          <source>The extended indexing syntax used for slicing is &lt;code&gt;aList[start:stop:step]&lt;/code&gt;, and basic examples are:</source>
          <target state="translated">用于切片的扩展索引语法为 &lt;code&gt;aList[start:stop:step]&lt;/code&gt; ，基本示例为：</target>
        </trans-unit>
        <trans-unit id="835f8ab3b0337722c0f132a2e78a9079b59cded7" translate="yes" xml:space="preserve">
          <source>The fact that list slices make a copy is a feature of lists themselves. If you're slicing advanced objects like a Pandas DataFrame, it may return a view on the original, and not a copy.</source>
          <target state="translated">事实上,列表切片做副本是列表本身的一个特点。如果你在分片的时候像Pandas DataFrame这样的高级对象,它可能会返回原件上的视图,而不是副本。</target>
        </trans-unit>
        <trans-unit id="41c12238b9c9bbcd33df30b54dc049e7a8a037bb" translate="yes" xml:space="preserve">
          <source>The first rule of slice assignment is that since slicing &lt;em&gt;returns&lt;/em&gt; a list, slice assignment &lt;em&gt;requires&lt;/em&gt; a list (or other iterable):</source>
          <target state="translated">切片分配的第一个规则是，由于切片&lt;em&gt;返回&lt;/em&gt;一个列表，因此切片分配&lt;em&gt;需要&lt;/em&gt;一个列表（或其他可迭代的）：</target>
        </trans-unit>
        <trans-unit id="053d4b345613c9e63af290ea87904c13976fb020" translate="yes" xml:space="preserve">
          <source>The full notation is</source>
          <target state="translated">完整的记号是</target>
        </trans-unit>
        <trans-unit id="a279c32eedbdb41ca0663a3f3c7caa14aacb8d48" translate="yes" xml:space="preserve">
          <source>The interesting thing is that you can replace multiple boxes at once. Also you can place multiple boxes wherever you like.</source>
          <target state="translated">有趣的是,你可以一次更换多个盒子。而且你可以把多个盒子放在你喜欢的地方。</target>
        </trans-unit>
        <trans-unit id="cbafdf992eb9b0ec11721982bbb3effe97d12b16" translate="yes" xml:space="preserve">
          <source>The key point to remember is that the &lt;code&gt;:stop&lt;/code&gt; value represents the first value that is &lt;em&gt;not&lt;/em&gt; in the selected slice. So, the difference between &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; is the number of elements selected (if &lt;code&gt;step&lt;/code&gt; is 1, the default).</source>
          <target state="translated">要记住的关键点是 &lt;code&gt;:stop&lt;/code&gt; 值表示&lt;em&gt;不在&lt;/em&gt;所选切片中的第一个值。 因此， &lt;code&gt;stop&lt;/code&gt; 和 &lt;code&gt;start&lt;/code&gt; 之间的差异是所选元素的数量（如果 &lt;code&gt;step&lt;/code&gt; 为1，则为默认值）。</target>
        </trans-unit>
        <trans-unit id="75586a32a01b71ebd61830c9004e1d99bb7e7f3c" translate="yes" xml:space="preserve">
          <source>The notation extends to (numpy) matrices and multidimensional arrays.  For example, to slice entire columns you can use:</source>
          <target state="translated">这个符号可以扩展到(numpy)矩阵和多维数组。例如,要对整个列进行切片,你可以使用:</target>
        </trans-unit>
        <trans-unit id="517bdfc38c62e4ed8dbc0ebe6233fdd418806066" translate="yes" xml:space="preserve">
          <source>The other feature is that &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; may be a &lt;em&gt;negative&lt;/em&gt; number, which means it counts from the end of the array instead of the beginning. So:</source>
          <target state="translated">另一个功能是 &lt;code&gt;start&lt;/code&gt; 或 &lt;code&gt;stop&lt;/code&gt; 可以是&lt;em&gt;负数&lt;/em&gt; ，这意味着它是从数组的末尾而不是开头开始计数。 所以：</target>
        </trans-unit>
        <trans-unit id="88cb13542cd6c22a7ed79eaff2dca42af648aa1a" translate="yes" xml:space="preserve">
          <source>The previous answers don't discuss multi-dimensional array slicing which is possible using the famous &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; package:</source>
          <target state="translated">先前的答案没有讨论使用著名的&lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt;包可以实现的多维数组切片：</target>
        </trans-unit>
        <trans-unit id="bcb48bc85f26256a3ee0c0f6a3e5b4429c47ae72" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;code&gt;None&lt;/code&gt;, is required, so that the first argument is interpreted as the &lt;code&gt;start&lt;/code&gt; argument &lt;a href=&quot;https://docs.python.org/2/library/functions.html#slice&quot;&gt;otherwise it would be the &lt;code&gt;stop&lt;/code&gt; argument&lt;/a&gt;.</source>
          <target state="translated">第二个参数 &lt;code&gt;None&lt;/code&gt; 是必需的，因此第一个参数将被解释为 &lt;code&gt;start&lt;/code&gt; 参数， &lt;a href=&quot;https://docs.python.org/2/library/functions.html#slice&quot;&gt;否则将成为 &lt;code&gt;stop&lt;/code&gt; 参数&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="596e5324916e7331fb73503433bce1ac5233475a" translate="yes" xml:space="preserve">
          <source>The second rule of slice assignment, which you can also see above, is that whatever portion of the list is returned by slice indexing, that's the same portion that is changed by slice assignment:</source>
          <target state="translated">分片赋值的第二条规则,你也可以在上面看到,无论列表中的任何部分被分片索引返回,那就是被分片赋值改变的部分。</target>
        </trans-unit>
        <trans-unit id="e952b134f12b0ea29603efb0b559bc9cc9ad704f" translate="yes" xml:space="preserve">
          <source>The slicing operator &lt;code&gt;[]&lt;/code&gt; is actually being used in the above code with a &lt;code&gt;slice()&lt;/code&gt; object using the &lt;code&gt;:&lt;/code&gt; notation (which is only valid within &lt;code&gt;[]&lt;/code&gt;), i.e.:</source>
          <target state="translated">在上面的代码中，实际上使用 &lt;code&gt;:&lt;/code&gt; 表示法将切片运算符 &lt;code&gt;[]&lt;/code&gt; 与 &lt;code&gt;slice()&lt;/code&gt; 对象一起使用（仅在 &lt;code&gt;[]&lt;/code&gt; 中有效），即：</target>
        </trans-unit>
        <trans-unit id="e691224537259b930d7e6fe4624c31eea62f2d85" translate="yes" xml:space="preserve">
          <source>The thing to remember about negative step is that &lt;code&gt;stop&lt;/code&gt; is always the excluded end, whether it's higher or lower. If you want same slice in opposite order, it's much cleaner to do the reversal separately: e.g. &lt;code&gt;'abcde'[1:-2][::-1]&lt;/code&gt; slices off one char from left, two from right, then reverses. (See also &lt;a href=&quot;http://www.python.org/dev/peps/pep-0322/&quot;&gt;&lt;code&gt;reversed()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">关于负步长要记住的一点是， &lt;code&gt;stop&lt;/code&gt; 始终是排除的端点，无论该端点是更高还是更低。 如果您想以相反的顺序进行相同的切片，则分别进行反转会更清洁：例如 &lt;code&gt;'abcde'[1:-2][::-1]&lt;/code&gt; 从左侧切一个字符，从右侧切两个字符，然后反转。 （另请参见&lt;a href=&quot;http://www.python.org/dev/peps/pep-0322/&quot;&gt; &lt;code&gt;reversed()&lt;/code&gt; &lt;/a&gt; 。）</target>
        </trans-unit>
        <trans-unit id="77887242adef23e77fb02d89d877a784f02e2b36" translate="yes" xml:space="preserve">
          <source>The third rule of slice assignment is, the assigned list (iterable) doesn't have to have the same length; the indexed slice is simply sliced out and replaced en masse by whatever is being assigned:</source>
          <target state="translated">切片分配的第三条规则是,被分配的列表(iterable)不一定要有相同的长度;被索引的切片只是简单地切掉,然后用被分配的东西来代替。</target>
        </trans-unit>
        <trans-unit id="29855a6656d9eb287192ae5bff65ab56fdd630e5" translate="yes" xml:space="preserve">
          <source>The trickiest part to get used to is assignment to empty slices. Using heuristic 1 and 2 it's easy to get your head around &lt;em&gt;indexing&lt;/em&gt; an empty slice:</source>
          <target state="translated">习惯最棘手的部分是分配给空片。 使用启发式1和2可以很容易地&lt;em&gt;索引&lt;/em&gt;一个空片：</target>
        </trans-unit>
        <trans-unit id="4443911b7fa6e0ec19af60b9f6f8c54543309dbe" translate="yes" xml:space="preserve">
          <source>The very first thing that confuses Python learners is that &lt;strong&gt;an index can be negative!&lt;/strong&gt;
Don't panic: &lt;strong&gt;a negative index means count backwards.&lt;/strong&gt;</source>
          <target state="translated">令Python学习者困惑的第一件事是&lt;strong&gt;索引可能是负数！&lt;/strong&gt; 不要惊慌： &lt;strong&gt;负索引意味着倒数。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc233fdd4b1aa1d0eec08f781b67af8b6d1de6f5" translate="yes" xml:space="preserve">
          <source>Then the negative indexing just needs you to add the length of the string to the negative indices to understand it.</source>
          <target state="translated">那么负索引只需要你把字符串的长度加上负索引就可以理解了。</target>
        </trans-unit>
        <trans-unit id="849becd57d4d9dfce3e88751e6e091a0dece7725" translate="yes" xml:space="preserve">
          <source>Then, we may need to apply the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; - the default then for &lt;code&gt;start&lt;/code&gt; is calculated as the upper bound when &lt;code&gt;step&lt;/code&gt; is negative:</source>
          <target state="translated">然后，我们可能需要将默认值用于 &lt;code&gt;start&lt;/code&gt; 和stop- &lt;code&gt;step&lt;/code&gt; 为负时， &lt;code&gt;start&lt;/code&gt; 的默认值将作为上限：</target>
        </trans-unit>
        <trans-unit id="b7d7ff65eee8f921208cc372c6ebb7dfee9bb661" translate="yes" xml:space="preserve">
          <source>There are some weird consequences to the &quot;once you're done, you're done&quot; rule:</source>
          <target state="translated">&quot;一劳永逸,一劳永逸 &quot;的规定会带来一些奇怪的后果。</target>
        </trans-unit>
        <trans-unit id="d9a00425fdfcba9c3b6367238a922973214a9b04" translate="yes" xml:space="preserve">
          <source>There is also the &lt;code&gt;step&lt;/code&gt; value, which can be used with any of the above:</source>
          <target state="translated">还有 &lt;code&gt;step&lt;/code&gt; 值，可以与以上任何一个一起使用：</target>
        </trans-unit>
        <trans-unit id="8748ae39a14aa6c556cf400a604d76f7a5986f03" translate="yes" xml:space="preserve">
          <source>This can come in handy sometimes, but it can also lead to somewhat strange behavior:</source>
          <target state="translated">这有时会派上用场,但也会导致一些奇怪的行为。</target>
        </trans-unit>
        <trans-unit id="096585dfd11ee121086fdfe39adc2486eb298a85" translate="yes" xml:space="preserve">
          <source>This function takes a Python object and optional parameters for slicing and returns the start, stop, step, and slice length for the requested slice.</source>
          <target state="translated">该函数获取一个Python对象和可选的切片参数,并返回所请求的切片的起始、停止、步长和切片长度。</target>
        </trans-unit>
        <trans-unit id="5c019865eaefe89398d12a470966b9e731ebcceb" translate="yes" xml:space="preserve">
          <source>This is how I teach slices to newbies:</source>
          <target state="translated">我是这样教新手做切片的。</target>
        </trans-unit>
        <trans-unit id="93ec6623e85643a7f24c84166f00188e862c3121" translate="yes" xml:space="preserve">
          <source>This is just for some extra info...
Consider the list below</source>
          <target state="translated">这仅仅是为了提供一些额外的信息......。考虑一下下面的列表</target>
        </trans-unit>
        <trans-unit id="2f3bd8ad9ced207179166369787553277fa774f3" translate="yes" xml:space="preserve">
          <source>This is the diagram:</source>
          <target state="translated">这个图就是这个图。</target>
        </trans-unit>
        <trans-unit id="30363f59507d9db8769972ab941783b864dbd2ab" translate="yes" xml:space="preserve">
          <source>This is the intelligence that is present behind slices. Since Python has an built-in function called slice, you can pass some parameters and check how smartly it calculates missing parameters.</source>
          <target state="translated">这就是slices背后的智能。因为Python有一个内置的函数叫slice,你可以传递一些参数,并检查它计算缺失参数的智能程度。</target>
        </trans-unit>
        <trans-unit id="d57f5dd395014f54497c19cddb5a2ce5c7ea7a57" translate="yes" xml:space="preserve">
          <source>This may also clarify the difference between slicing and indexing.</source>
          <target state="translated">这也可以明确分片和索引的区别。</target>
        </trans-unit>
        <trans-unit id="b95f0acc0a5d079ab45b81544212226023725e34" translate="yes" xml:space="preserve">
          <source>This pretty property tells me that &lt;code&gt;lst[start:end]&lt;/code&gt; does not contain the &lt;code&gt;end&lt;/code&gt;-th item because it is in &lt;code&gt;lst[end:]&lt;/code&gt;.</source>
          <target state="translated">这个漂亮的属性告诉我 &lt;code&gt;lst[start:end]&lt;/code&gt; 不包含第 &lt;code&gt;end&lt;/code&gt; 个项目，因为它位于 &lt;code&gt;lst[end:]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8007629ae4bd6492e6ac3709a0f6817d52e38741" translate="yes" xml:space="preserve">
          <source>This way, I can think of &lt;code&gt;a[-4:-6:-1]&lt;/code&gt; as &lt;code&gt;a(-6,-4]&lt;/code&gt; in interval terminology.</source>
          <target state="translated">这样，我可以将 &lt;code&gt;a[-4:-6:-1]&lt;/code&gt; 视为区间术语中的 &lt;code&gt;a(-6,-4]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88160c485e5bf5fb043177dc6d2bf96217e61ab0" translate="yes" xml:space="preserve">
          <source>This works for me anyway...</source>
          <target state="translated">反正这个对我来说很管用.....</target>
        </trans-unit>
        <trans-unit id="36a968ddf7619f1775f5b9341d45ab5c6d7d9f33" translate="yes" xml:space="preserve">
          <source>Thus a negative slice will change the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;!</source>
          <target state="translated">因此，负片将更改 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 的默认值！</target>
        </trans-unit>
        <trans-unit id="6c35d5a48cbaacaa30e85a96cdc7b46a6bf157e1" translate="yes" xml:space="preserve">
          <source>Till now you have picked boxes continuously. But sometimes you need to pick up discretely. For example, you can pick up every second box. You can even pick up every third box from the end. This value is called step size. This represents the gap between your successive pickups. The step size should be positive if You are picking boxes from the beginning to end and vice versa.</source>
          <target state="translated">到现在为止,你已经连续地捡到了箱子。但有时你需要谨慎地捡拾。比如说,你可以每隔一个箱子就拿起一个箱子。你甚至可以每隔第三个箱子就拿起一个箱子。这个值叫做步数大小。这代表了你连续拾取之间的差距。如果你从头到尾拾取盒子,步长应该是正数,反之亦然。</target>
        </trans-unit>
        <trans-unit id="31ee61905e41466bdf813b3f8668d410b0e1fa58" translate="yes" xml:space="preserve">
          <source>To begin with, let's define a few terms:</source>
          <target state="translated">首先,我们来定义几个名词。</target>
        </trans-unit>
        <trans-unit id="2e1c54513da531934e461b5f4aa70c3c39a3e784" translate="yes" xml:space="preserve">
          <source>To make it simple, remember &lt;strong&gt;slice has only one form：&lt;/strong&gt;</source>
          <target state="translated">为简单起见，请记住&lt;strong&gt;slice只有一种形式：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6133370c4351e43ebcb470ed39b01c2df88aa87a" translate="yes" xml:space="preserve">
          <source>To me, this notation needs a bit of picking up.</source>
          <target state="translated">在我看来,这个记事本需要好好拾掇一下。</target>
        </trans-unit>
        <trans-unit id="427ca464e82784a054828caeff41890bcf767d80" translate="yes" xml:space="preserve">
          <source>To retrieve a subset of elements, the start and stop positions need to be defined.</source>
          <target state="translated">要检索元素的子集,需要定义起始和停止位置。</target>
        </trans-unit>
        <trans-unit id="8e7a6a811c35a7adca15b7530f42f47e0dda5845" translate="yes" xml:space="preserve">
          <source>To use slice notation with a sequence that supports it, you must include at least one colon in the square brackets that follow the sequence (which actually &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;implement the &lt;code&gt;__getitem__&lt;/code&gt; method of the sequence, according to the Python data model&lt;/a&gt;.)</source>
          <target state="translated">要将切片符号与支持它的序列一起使用，您必须在序列后的方括号中至少包含一个冒号（ &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;根据Python数据模型&lt;/a&gt; ，该括号实际上实现了序列的 &lt;code&gt;__getitem__&lt;/code&gt; 方法 ）。</target>
        </trans-unit>
        <trans-unit id="0e7a206b9021aa8d0ea3e3c6e22e9c2a9fd3b850" translate="yes" xml:space="preserve">
          <source>Understanding index assignment is very important.</source>
          <target state="translated">了解指数分配是非常重要的。</target>
        </trans-unit>
        <trans-unit id="eb8117520c3958acd43c0f8e454eeec3f534d349" translate="yes" xml:space="preserve">
          <source>Understanding slice notation</source>
          <target state="translated">理解切片记事法</target>
        </trans-unit>
        <trans-unit id="10c5a38a7a014349bab2658d201f411e1780237b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;step&lt;/code&gt; provides a useful trick to reverse a collection in Python:</source>
          <target state="translated">使用 &lt;code&gt;step&lt;/code&gt; 提供了一个有用的技巧来反转Python中的集合：</target>
        </trans-unit>
        <trans-unit id="625b0998df7fa1a8b226d789e201ac2c633e1b85" translate="yes" xml:space="preserve">
          <source>Using a negative step reverses the interpretation of &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">使用否定步骤会颠倒对 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 的解释</target>
        </trans-unit>
        <trans-unit id="62654d2560fca6df984a34445f5e3dec93d4d93b" translate="yes" xml:space="preserve">
          <source>What always work is to think in characters or slots and use indexing as a half-open interval -- right-open if positive stride, left-open if negative stride.</source>
          <target state="translated">始终有效的方法是以字符或插槽为单位思考,并将索引作为一个半开区间----如果是正跨度,则右开;如果是负跨度,则左开。</target>
        </trans-unit>
        <trans-unit id="526db1adfef28b92b75500e179ee7473e39b4025" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;step&lt;/code&gt; is negative, the defaults for &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; change</source>
          <target state="translated">如果 &lt;code&gt;step&lt;/code&gt; 为负，则默认为 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 更改</target>
        </trans-unit>
        <trans-unit id="2c8d0413ebb06c76b410bc829582598046a90e73" translate="yes" xml:space="preserve">
          <source>When I see this, I read the part in the brackets as &quot;9th from the end, to the end.&quot; (Actually, I abbreviate it mentally as &quot;-9, on&quot;)</source>
          <target state="translated">看到这里,我把括号里的部分读成了&quot;-9,从头到尾,到尾。&quot; (其实,我在心理上缩写为&quot;-9,上&quot;)</target>
        </trans-unit>
        <trans-unit id="6847d5ecc89aafb251c20bc69d5137967a12634d" translate="yes" xml:space="preserve">
          <source>When slicing from the start, you can omit the zero index, and when slicing to the end, you can omit the final index since it is redundant, so do not be verbose:</source>
          <target state="translated">当从头切入时,可以省略零索引,当切到尾部时,可以省略最后的索引,因为最后的索引是多余的,所以不要啰嗦。</target>
        </trans-unit>
        <trans-unit id="0331d52f669a9d089e322197c2a42b467d18a25b" translate="yes" xml:space="preserve">
          <source>When slicing, if you leave out any parameter, Python tries to figure it out automatically.</source>
          <target state="translated">切片时,如果你遗漏了任何参数,Python会自动计算出它。</target>
        </trans-unit>
        <trans-unit id="ec05e68a3474403744db580556c5b4b5147a48ab" translate="yes" xml:space="preserve">
          <source>When using a negative step, notice that the answer is shifted to the right by 1.</source>
          <target state="translated">使用负步法时,注意答案要向右移1。</target>
        </trans-unit>
        <trans-unit id="d52f5e951410da3205e348d328fbec3fed74bc94" translate="yes" xml:space="preserve">
          <source>When you say [a:b:c], you are saying depending on the sign of c (forward or backward), start at a and end at b (excluding element at bth index). Use the indexing rule above and remember you will only find elements in this range:</source>
          <target state="translated">当你说[a:b:c]时,你说的是根据c的符号(向前或向后),以a为起点,以b为终点(不包括位于bth索引的元素)。使用上面的索引规则,记住,你只会在这个范围内找到元素。</target>
        </trans-unit>
        <trans-unit id="60ffa2bfa59ad91cfa5b5fac46b9f1af335ca27a" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;:&lt;/code&gt;-based notation is very helpful for simple slicing, the explicit use of &lt;code&gt;slice()&lt;/code&gt; objects simplifies the programmatic generation of slicing.</source>
          <target state="translated">尽管基于 &lt;code&gt;:&lt;/code&gt; 的符号对于简单切片非常有用，但是对 &lt;code&gt;slice()&lt;/code&gt; 对象的显式使用简化了切片的程序化生成。</target>
        </trans-unit>
        <trans-unit id="1fac29e5b50e4050ea0c9107b01d2b1be0ad4b52" translate="yes" xml:space="preserve">
          <source>Wiki Python has this amazing picture which clearly distinguishes indexing and slicing.</source>
          <target state="translated">Wiki Python有这样一张惊人的图片,可以清楚地区分出索引和切片。</target>
        </trans-unit>
        <trans-unit id="dc7857679c446d31b3fa48d4d430634f0052baba" translate="yes" xml:space="preserve">
          <source>With extended indexing syntax, we retrieve a range of values. For example, all values are retrieved with a colon.</source>
          <target state="translated">通过扩展的索引语法,我们可以检索到一系列的值。例如,所有的值都用冒号来检索。</target>
        </trans-unit>
        <trans-unit id="48850a7b49c3ba2cdae5d4c04076f27217921200" translate="yes" xml:space="preserve">
          <source>With slicing, once you're done, you're done; it doesn't start slicing backwards. In Python you don't get negative strides unless you explicitly ask for them by using a negative number.</source>
          <target state="translated">有了分片,一旦你做完了,你就完了;它不会开始倒着做分片。在Python中,除非你明确要求使用负数,否则不会得到负跨度。</target>
        </trans-unit>
        <trans-unit id="8e6854e86dbd642a89919deb5004ced1375069af" translate="yes" xml:space="preserve">
          <source>X is the index of the first element you want.</source>
          <target state="translated">X是你要的第一个元素的索引。</target>
        </trans-unit>
        <trans-unit id="1caf266993cb78b65a51c14f80f90f52a48c1ad0" translate="yes" xml:space="preserve">
          <source>Y is the index of the first element you &lt;em&gt;don't&lt;/em&gt; want.</source>
          <target state="translated">Y是您&lt;em&gt;不需要&lt;/em&gt;的第一个元素的索引。</target>
        </trans-unit>
        <trans-unit id="37c763665adfe6c32f74ceb3ab85198ed95e14f3" translate="yes" xml:space="preserve">
          <source>You can also use slice assignment to remove one or more elements from a list:</source>
          <target state="translated">您还可以使用分片分配来删除列表中的一个或多个元素。</target>
        </trans-unit>
        <trans-unit id="f6537afebf0730bd8d23b3fe9847bf52f1415c3b" translate="yes" xml:space="preserve">
          <source>You can even pick up the first three boxes or the last two boxes or all boxes between 1 and 4. So, you can pick any set of boxes if you know the beginning and ending. These positions are called start and stop positions.</source>
          <target state="translated">你甚至可以拿起前三个盒子,或者最后两个盒子,或者1到4之间的所有盒子。所以,如果你知道开始和结束的位置,你可以选择任意一组盒子。这些位置被称为起始位置和停止位置。</target>
        </trans-unit>
        <trans-unit id="c778f916c05737b62b181e6441afcd1a4fe8b894" translate="yes" xml:space="preserve">
          <source>You can make any of these positive or negative numbers. The meaning of the positive numbers is straightforward, but for negative numbers, just like indexes in Python, you count backwards from the end for the &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;stop&lt;/em&gt;, and for the &lt;em&gt;step&lt;/em&gt;, you simply decrement your index. This example is &lt;a href=&quot;https://docs.python.org/2/tutorial/introduction.html&quot;&gt;from the documentation's tutorial&lt;/a&gt;, but I've modified it slightly to indicate which item in a sequence each index references:</source>
          <target state="translated">您可以使这些正数或负数中的任何一个。 正数的含义很简单，但是对于负数，就像Python中的索引一样，您从头到尾都从末尾&lt;em&gt;开始&lt;/em&gt;倒数，对于&lt;em&gt;step&lt;/em&gt; ，您只需减少索引数即可。 此示例&lt;a href=&quot;https://docs.python.org/2/tutorial/introduction.html&quot;&gt;来自文档的教程&lt;/a&gt; ，但我对其进行了稍微修改，以指示每个索引引用序列中的哪个项目：</target>
        </trans-unit>
        <trans-unit id="9b7644b509b2bf8e1ff27f855c7f83b37789181c" translate="yes" xml:space="preserve">
          <source>You can run this script and experiment with it, below is some samples that I got from the script.</source>
          <target state="translated">你可以运行这个脚本并进行实验,下面是我从脚本中得到的一些样本。</target>
        </trans-unit>
        <trans-unit id="64faa3902ada5ca110aa668c8de78a324815760c" translate="yes" xml:space="preserve">
          <source>You can then pass the slice object to your sequence:</source>
          <target state="translated">然后,你可以将切片对象传递给你的序列。</target>
        </trans-unit>
        <trans-unit id="195e61f26a2fef8e34f3db23bd78fcb41bfedb3e" translate="yes" xml:space="preserve">
          <source>You made a cut &lt;strong&gt;before&lt;/strong&gt; the element with index &lt;code&gt;2&lt;/code&gt; and another cut &lt;strong&gt;before&lt;/strong&gt; the element with index &lt;code&gt;5&lt;/code&gt;. So the result will be a slice between those two cuts, a list &lt;code&gt;['T', 'H', 'O']&lt;/code&gt;.</source>
          <target state="translated">您在具有索引 &lt;code&gt;2&lt;/code&gt; 的元素&lt;strong&gt;之前&lt;/strong&gt;进行了切割&lt;strong&gt;，&lt;/strong&gt;并&lt;strong&gt;在&lt;/strong&gt;具有索引 &lt;code&gt;5&lt;/code&gt; 的元素&lt;strong&gt;之前进行&lt;/strong&gt;了另一个切割。 因此，结果将是这两个剪切之间的一个片段，一个列表 &lt;code&gt;['T', 'H', 'O']&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89d9115fa306118ea0f00933e8378ed5c6878642" translate="yes" xml:space="preserve">
          <source>You may find it useful to separate forming the slice from passing it to the &lt;code&gt;list.__getitem__&lt;/code&gt; method (&lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;that's what the square brackets do&lt;/a&gt;). Even if you're not new to it, it keeps your code more readable so that others that may have to read your code can more readily understand what you're doing.</source>
          <target state="translated">您可能会发现，将形成切片与将其传递到 &lt;code&gt;list.__getitem__&lt;/code&gt; 方法分开是很有用的（ &lt;a href=&quot;https://docs.python.org/2/reference/datamodel.html#object.__getitem__&quot;&gt;方括号就是这样做的&lt;/a&gt; ）。 即使您不陌生，它也可以使您的代码更具可读性，以便其他可能需要阅读代码的人可以更轻松地了解您的操作。</target>
        </trans-unit>
        <trans-unit id="8e3e016f8f3879b55e19d0fb4c4a1a15482a3faa" translate="yes" xml:space="preserve">
          <source>a b &lt;strong&gt;[&lt;/strong&gt; c d e f g h &lt;strong&gt;]&lt;/strong&gt; i j</source>
          <target state="translated">ab &lt;strong&gt;[&lt;/strong&gt; cdefgh &lt;strong&gt;]&lt;/strong&gt; ij</target>
        </trans-unit>
        <trans-unit id="a604aec6cdc49c95cd2d0c53292ad902a479d32d" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;stop&lt;/code&gt;, the lower bound:</source>
          <target state="translated">并 &lt;code&gt;stop&lt;/code&gt; ，下限：</target>
        </trans-unit>
        <trans-unit id="631cab8239639a1208a15258a7f7aeda4d018888" translate="yes" xml:space="preserve">
          <source>and here is how it works:</source>
          <target state="translated">这里是如何工作的。</target>
        </trans-unit>
        <trans-unit id="9ed5a643d410a394491f567e56e051b01be293d5" translate="yes" xml:space="preserve">
          <source>and now:</source>
          <target state="translated">而现在,</target>
        </trans-unit>
        <trans-unit id="ce39fead1872adb72fba2b688bc7e4b8311fc7f4" translate="yes" xml:space="preserve">
          <source>and to substitute the defaults (actually when &lt;code&gt;step&lt;/code&gt; is negative, &lt;code&gt;stop&lt;/code&gt;'s default is &lt;code&gt;-len(my_list) - 1&lt;/code&gt;, so &lt;code&gt;None&lt;/code&gt; for stop really just means it goes to whichever end step takes it to):</source>
          <target state="translated">并替换为默认值（实际上，当 &lt;code&gt;step&lt;/code&gt; 为负数时， &lt;code&gt;stop&lt;/code&gt; 的默认值为 &lt;code&gt;-len(my_list) - 1&lt;/code&gt; ，因此，stop的 &lt;code&gt;None&lt;/code&gt; 实际上仅意味着它将转到执行该步骤的最后一个步骤）：</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="1110fd3a6c30458a698644d555d607d113a08279" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;True&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9adbb8529fa7bf42a21e2483f8aa574d755b96e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;l&lt;/code&gt; is a collection, &lt;code&gt;start&lt;/code&gt; is an inclusive index, &lt;code&gt;end&lt;/code&gt; is an exclusive index, and &lt;code&gt;step&lt;/code&gt; is a stride that can be used to take every &lt;em&gt;nth&lt;/em&gt; item in &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;l&lt;/code&gt; 是一个集合， &lt;code&gt;start&lt;/code&gt; 是一个包含索引， &lt;code&gt;end&lt;/code&gt; 是一个排斥索引，而 &lt;code&gt;step&lt;/code&gt; 是一个跨步 ，可用于获取 &lt;code&gt;l&lt;/code&gt; 中的 &lt;em&gt;第n个&lt;/em&gt;项目。</target>
        </trans-unit>
        <trans-unit id="1b8a81384b7443c9cbeaad37bd4704f2d8b3165a" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;l&lt;/code&gt; is some collection, &lt;code&gt;start&lt;/code&gt; is an inclusive index, and &lt;code&gt;end&lt;/code&gt; is an exclusive index.</source>
          <target state="translated">其中 &lt;code&gt;l&lt;/code&gt; 是某个集合， &lt;code&gt;start&lt;/code&gt; 是一个包含索引，而 &lt;code&gt;end&lt;/code&gt; 是一个排斥索引。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
