<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/504103">
    <body>
      <group id="504103">
        <trans-unit id="7c98885362dfac889a9855e3cada87c420301ccb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;jmh&lt;/a&gt; is a recent addition to OpenJDK and has been written by some performance engineers from Oracle. Certainly worth a look.</source>
          <target state="translated">&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;jmh&lt;/a&gt; является недавним дополнением к OpenJDK и написано некоторыми инженерами по производительности из Oracle. Конечно, стоит посмотреть.</target>
        </trans-unit>
        <trans-unit id="e83d76042e828ed3c8e11fb07151725fca9240b5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://opt.sourceforge.net/&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark - control tasks required to determine the comparative performance characteristics of the computer system on different platforms. Can be used to guide optimization decisions and to compare different Java implementations.</source>
          <target state="translated">&lt;a href=&quot;http://opt.sourceforge.net/&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark - управляющие задачи, необходимые для определения сравнительных характеристик производительности компьютерной системы на разных платформах. Может использоваться для руководства решениями по оптимизации и для сравнения различных реализаций Java.</target>
        </trans-unit>
        <trans-unit id="002ff0009ac698d62577e1dacfbbd66bec9fce5f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot;&gt;Discussion on the main strengths of jmh&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot;&gt;Обсуждение основных сильных сторон JMH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3262a13a878ada9ad80da38be74e4e326a4dbc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Getting started tutorials&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Начало обучения&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58b8f129eaa1ef1df1f79c088dc155d676bab11c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH from OpenJDK&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH из OpenJDK&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1cab88a8d7c77af82261e5a17335a55be0286ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper from Google&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Штангенциркуль от Google&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e08658c12ec073195992e373f7f39e2930d359c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 0:&lt;/strong&gt; Read a reputable paper on JVMs and micro-benchmarking. A good one is &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot;&gt;Brian Goetz, 2005&lt;/a&gt;. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics.</source>
          <target state="translated">&lt;strong&gt;Правило 0:&lt;/strong&gt; Прочтите авторитетную статью о JVM и микробенчмаркинге. Хороший - &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot;&gt;Брайан Гетц, 2005&lt;/a&gt; . Не ожидайте слишком многого от микро-тестов; они измеряют только ограниченный диапазон рабочих характеристик JVM.</target>
        </trans-unit>
        <trans-unit id="d45fa44e30fc3e7cad85ca1896b5fffd407b89b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 1:&lt;/strong&gt; Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timing phase(s). (Fewer iterations is OK on the warmup phase. The rule of thumb is several tens of thousands of inner loop iterations.)</source>
          <target state="translated">&lt;strong&gt;Правило 1:&lt;/strong&gt; всегда включайте фазу разминки, которая запускает ваше тестовое ядро ​​на всем протяжении, достаточное для запуска всех инициализаций и компиляций до фазы (фаз) синхронизации. (Меньше итераций в порядке на этапе разогрева. Основное правило - несколько десятков тысяч итераций внутреннего цикла.)</target>
        </trans-unit>
        <trans-unit id="8c3aa86e67b88f2049f3994203039a7ec263cde1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 2.1:&lt;/strong&gt; Print messages at the beginning and end of timing and warmup phases, so you can verify that there is no output from Rule 2 during the timing phase.</source>
          <target state="translated">&lt;strong&gt;Правило 2.1.&lt;/strong&gt; Печатайте сообщения в начале и в конце фаз синхронизации и прогрева, чтобы можно было убедиться, что в фазе синхронизации нет выходных данных из правила 2.</target>
        </trans-unit>
        <trans-unit id="f2003e400027cc14055ad96eecc77dd4cc897cde" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 2:&lt;/strong&gt; Always run with &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt;, &lt;code&gt;-verbose:gc&lt;/code&gt;, etc., so you can verify that the compiler and other parts of the JVM are not doing unexpected work during your timing phase.</source>
          <target state="translated">&lt;strong&gt;Правило 2:&lt;/strong&gt; всегда запускайте с &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; , -verbose &lt;code&gt;-verbose:gc&lt;/code&gt; и т. Д., Чтобы вы могли убедиться, что компилятор и другие части JVM не выполняют неожиданную работу на этапе синхронизации.</target>
        </trans-unit>
        <trans-unit id="82a300d3f7024d24e03d349acfe0ce39d6315045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 3:&lt;/strong&gt; Be aware of the difference between &lt;code&gt;-client&lt;/code&gt; and &lt;code&gt;-server&lt;/code&gt;, and OSR and regular compilations. The &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; flag reports OSR compilations with an at-sign to denote the non-initial entry point, for example: &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt;. Prefer server to client, and regular to OSR, if you are after best performance.</source>
          <target state="translated">&lt;strong&gt;Правило 3:&lt;/strong&gt; помните о разнице между &lt;code&gt;-client&lt;/code&gt; и &lt;code&gt;-server&lt;/code&gt; и OSR и регулярными компиляциями. Флаг &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; сообщает о компиляции OSR со знаком at, обозначающим не начальную точку входа, например: &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt; . Предпочитайте сервер клиенту, а обычное - OSR, если вы стремитесь к лучшей производительности.</target>
        </trans-unit>
        <trans-unit id="9fe68b85cd38859a59a3c019f4abe56850c6f896" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 4:&lt;/strong&gt; Be aware of initialization effects. Do not print for the first time during your timing phase, since printing loads and initializes classes. Do not load new classes outside of the warmup phase (or final reporting phase), unless you are testing class loading specifically (and in that case load only the test classes). Rule 2 is your first line of defense against such effects.</source>
          <target state="translated">&lt;strong&gt;Правило 4:&lt;/strong&gt; знать об эффектах инициализации. Не печатайте в первый раз во время фазы синхронизации, так как печать загружает и инициализирует классы. Не загружайте новые классы вне фазы прогрева (или финальной фазы отчетности), если только вы не тестируете загрузку классов специально (а в этом случае загружаете только тестовые классы). Правило 2 - ваша первая линия защиты от таких эффектов.</target>
        </trans-unit>
        <trans-unit id="96adbb1b64b53f6a4f822f7be16037426b9faf61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 5:&lt;/strong&gt; Be aware of deoptimization and recompilation effects. Do not take any code path for the first time in the timing phase, because the compiler may junk and recompile the code, based on an earlier optimistic assumption that the path was not going to be used at all. Rule 2 is your first line of defense against such effects.</source>
          <target state="translated">&lt;strong&gt;Правило 5:&lt;/strong&gt; знать о последствиях деоптимизации и перекомпиляции. Не используйте какой-либо путь к коду в первый раз на этапе синхронизации, потому что компилятор может создать нежелательную и перекомпилировать код, основываясь на более раннем оптимистическом предположении, что путь вообще не будет использоваться. Правило 2 - ваша первая линия защиты от таких эффектов.</target>
        </trans-unit>
        <trans-unit id="7fb62c7b72ed7085cdadc9ffda9ceefbbb9ad946" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 6:&lt;/strong&gt; Use appropriate tools to read the compiler's mind, and expect to be surprised by the code it produces. Inspect the code yourself before forming theories about what makes something faster or slower.</source>
          <target state="translated">&lt;strong&gt;Правило 6:&lt;/strong&gt; Используйте соответствующие инструменты, чтобы прочитать мысли компилятора и ожидать, что вы будете удивлены кодом, который он создает. Проверьте код самостоятельно, прежде чем создавать теории о том, что делает что-то быстрее или медленнее.</target>
        </trans-unit>
        <trans-unit id="5c5dde812c075176c9041fa138d2a9a90fce4363" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 7:&lt;/strong&gt; Reduce noise in your measurements. Run your benchmark on a quiet machine, and run it several times, discarding outliers. Use &lt;code&gt;-Xbatch&lt;/code&gt; to serialize the compiler with the application, and consider setting &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; to prevent the compiler from running in parallel with itself. Try your best to reduce GC overhead, set &lt;code&gt;Xmx&lt;/code&gt;(large enough) equals &lt;code&gt;Xms&lt;/code&gt; and use &lt;a href=&quot;http://openjdk.java.net/jeps/318&quot;&gt;&lt;code&gt;UseEpsilonGC&lt;/code&gt;&lt;/a&gt; if it is available.</source>
          <target state="translated">&lt;strong&gt;Правило 7:&lt;/strong&gt; Уменьшите шум в ваших измерениях. Запустите тест на тихой машине и запустите его несколько раз, отбрасывая выбросы. Используйте &lt;code&gt;-Xbatch&lt;/code&gt; для сериализации компилятора с приложением и рассмотрите возможность установки &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; , чтобы компилятор не работал параллельно с самим собой. Старайтесь &lt;code&gt;Xmx&lt;/code&gt; уменьшить накладные расходы GC, установите Xmx (достаточно большой) равным &lt;code&gt;Xms&lt;/code&gt; и используйте &lt;a href=&quot;http://openjdk.java.net/jeps/318&quot;&gt; &lt;code&gt;UseEpsilonGC&lt;/code&gt; ,&lt;/a&gt; если он доступен.</target>
        </trans-unit>
        <trans-unit id="4794c7852029678f813d3a6a3ad951731b0589f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 8:&lt;/strong&gt; Use a library for your benchmark as it is probably more efficient and was already debugged for this sole purpose. Such as &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt;, &lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper&lt;/a&gt; or &lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot;&gt;Bill and Paul's Excellent UCSD Benchmarks for Java&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Правило 8:&lt;/strong&gt; используйте библиотеку для своего теста, поскольку она, вероятно, более эффективна и уже отлажена для этой единственной цели. Такие как &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt; , &lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper&lt;/a&gt; или &lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot;&gt;Билл и превосходные тесты UCSD Пола для Java&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b900f6d5071c2310201e024ff990519c9b60003" translate="yes" xml:space="preserve">
          <source>Also, make sure that &lt;em&gt;n&lt;/em&gt; is very large, so that the runtime of each loop is at the very least 10 seconds or so.  The more iterations, the more significant figures in your benchmark time and the more reliable that data is.</source>
          <target state="translated">Кроме того, убедитесь, что &lt;em&gt;n&lt;/em&gt; очень велико, чтобы время выполнения каждого цикла составляло как минимум 10 секунд или около того. Чем больше итераций, тем значительнее показатели времени тестирования и тем надежнее данные.</target>
        </trans-unit>
        <trans-unit id="291a53f8afab7a8ada4aa04f96b773eb9331ee82" translate="yes" xml:space="preserve">
          <source>Avoiding Benchmarking Pitfalls on the JVM</source>
          <target state="translated">Избежание эталонных ям на JVM</target>
        </trans-unit>
        <trans-unit id="9fdb89d13608249537686498201d2b8013f81d5b" translate="yes" xml:space="preserve">
          <source>Example: Should the benchmark measure time/iteration or iterations/time, and why?</source>
          <target state="translated">Пример:Должен ли эталон измерять время или итерационную оценку,и почему?</target>
        </trans-unit>
        <trans-unit id="7c30a2a120296936d804852069941c3f3b4b3697" translate="yes" xml:space="preserve">
          <source>First: You have to calculate with all sorts of events that take time more or less random: Garbage collection, caching effects (of OS for files and of CPU for memory), IO etc.</source>
          <target state="translated">Первое:Вы должны вычислить со всеми видами событий,которые занимают время более или менее случайным:Сбор мусора,эффекты кэширования (операционной системы для файлов и процессора для памяти),IO и т.д.</target>
        </trans-unit>
        <trans-unit id="5fd020f2e8c9e9c9f5c7fabb9d269a776ca80082" translate="yes" xml:space="preserve">
          <source>For some CPUs (e.g. Intel Core i5 range with TurboBoost), the temperature (and number of cores currently being used, as well as thier utilisation percent) affects the clock speed. Since CPUs are dynamically clocked, this can affect your results. For example, if you have a single-threaded application, the maximum clock speed (with TurboBoost) is higher than for an application using all cores. This can therefore interfere with comparisons of single and multi-threaded performance on some systems. Bear in mind that the temperature and volatages also affect how long Turbo frequency is maintained.</source>
          <target state="translated">Для некоторых процессоров (например,Intel Core i5 с технологией TurboBoost)температура (и количество используемых в настоящее время ядер,а также процент использования)влияет на тактовую частоту.Поскольку процессоры динамически синхронизируются,это может повлиять на результаты.Например,если у вас однопоточное приложение,максимальная тактовая частота (с TurboBoost)выше,чем у приложения,использующего все ядра.Поэтому это может повлиять на сравнение однопоточной и многопоточной производительности на некоторых системах.Помните,что температура и напряжение также влияют на продолжительность поддержания частоты Turbo.</target>
        </trans-unit>
        <trans-unit id="7b60187da88886bca2657e4a6777410827026413" translate="yes" xml:space="preserve">
          <source>How do I write a correct micro-benchmark in Java</source>
          <target state="translated">Как написать правильную микро-бенчмарку на Java.</target>
        </trans-unit>
        <trans-unit id="1cbff6d9740743fbbd7f9c95fa887c6effb7d086" translate="yes" xml:space="preserve">
          <source>How do you write (and run) a correct micro-benchmark in Java?</source>
          <target state="translated">Как написать (и запустить)правильную микро-бенчмарку на Java?</target>
        </trans-unit>
        <trans-unit id="345f77da8a43bfb9f331059c7ac811f4abfb5447" translate="yes" xml:space="preserve">
          <source>I have found some noticeable differences (5-10% sometimes) in the runtime of the same algorithm in different passes..</source>
          <target state="translated">Я обнаружил некоторые заметные различия (иногда 5-10%)во времени исполнения одного и того же алгоритма в разных проходах...</target>
        </trans-unit>
        <trans-unit id="9288dce15b94ef8dabd0c6bdca3af22ce5ad08c1" translate="yes" xml:space="preserve">
          <source>I know this question has been marked as answered but I wanted to mention two libraries that help us to write micro benchmarks</source>
          <target state="translated">Я знаю,что этот вопрос был отмечен как ответ,но я хотел бы упомянуть две библиотеки,которые помогают нам писать микро-тесты.</target>
        </trans-unit>
        <trans-unit id="b49185e438b5ff2e0365effaefd146926922e274" translate="yes" xml:space="preserve">
          <source>I like to display iterations and time, and a score of time/iteration which can be scaled such that the &quot;best&quot; algorithm gets a score of 1.0 and others are scored in a relative fashion. This means you can run &lt;em&gt;all&lt;/em&gt; algorithms for a longish time, varying both number of iterations and time, but still getting comparable results.</source>
          <target state="translated">Мне нравится отображать итерации и время, а также счет времени / итерации, который можно масштабировать так, чтобы &amp;laquo;лучший&amp;raquo; алгоритм получил оценку 1,0, а другие оценивали относительно. Это означает, что вы можете запускать &lt;em&gt;все&lt;/em&gt; алгоритмы в течение длительного времени, варьируя как количество итераций, так и время, но при этом получая сопоставимые результаты.</target>
        </trans-unit>
        <trans-unit id="073918582af97d175c9583f4544e6c59d66b8800" translate="yes" xml:space="preserve">
          <source>I'm just in the process of blogging about the design of a benchmarking framework in .NET. I've got a &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/26/benchmarking-made-easy.aspx&quot;&gt;couple&lt;/a&gt; of &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot;&gt;earlier posts&lt;/a&gt; which may be able to give you some ideas - not everything will be appropriate, of course, but some of it may be.</source>
          <target state="translated">Я только в процессе ведения блога о разработке платформы для тестирования в .NET. У меня есть &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/26/benchmarking-made-easy.aspx&quot;&gt;несколько&lt;/a&gt; &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot;&gt;предыдущих постов,&lt;/a&gt; которые могут дать вам некоторые идеи - конечно, не все будет уместно, но некоторые из них могут быть.</target>
        </trans-unit>
        <trans-unit id="51e309adae3a577233db4148a52db0b5e82ad882" translate="yes" xml:space="preserve">
          <source>I'm looking for some code samples and comments illustrating various things to think about.</source>
          <target state="translated">Я ищу примеры кода и комментарии,иллюстрирующие различные вещи,о которых стоит задуматься.</target>
        </trans-unit>
        <trans-unit id="36261b5d7d09dc19c64cb2ee96d2ae81bfed859d" translate="yes" xml:space="preserve">
          <source>If you are interested in &lt;strong&gt;latency&lt;/strong&gt;, use time/iteration and if you are interested in &lt;strong&gt;throughput&lt;/strong&gt;, use iterations/time.</source>
          <target state="translated">Если вас интересует &lt;strong&gt;задержка&lt;/strong&gt; , используйте время / итерацию, а если вас интересует &lt;strong&gt;пропускная способность&lt;/strong&gt; , используйте итерации / время.</target>
        </trans-unit>
        <trans-unit id="57fe3c1aa7a71ecc2622b2368266380f1ba646de" translate="yes" xml:space="preserve">
          <source>If you are trying to compare two algorithms, do at least two benchmarks for each, alternating the order.  i.e.:</source>
          <target state="translated">Если вы пытаетесь сравнить два алгоритма,сделайте как минимум по два бенчмарка для каждого,чередуя порядок,т.е..:</target>
        </trans-unit>
        <trans-unit id="446509b69736161c6a7f8538df894b0283704899" translate="yes" xml:space="preserve">
          <source>Important things for Java benchmarks are:</source>
          <target state="translated">Важные вещи для Java-тестов:</target>
        </trans-unit>
        <trans-unit id="8a984f01db14194be668e260faf7f1dd1670ba36" translate="yes" xml:space="preserve">
          <source>It depends on &lt;strong&gt;what&lt;/strong&gt; you are trying to test.</source>
          <target state="translated">Это зависит от &lt;strong&gt;того, что&lt;/strong&gt; вы пытаетесь проверить.</target>
        </trans-unit>
        <trans-unit id="feeb65010e24c48f6e8b09b1aefe0fddee8b6bc9" translate="yes" xml:space="preserve">
          <source>It should also be noted that it might also be important to analyze the results of the micro benchmark when comparing different implementations. Therefore a &lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot;&gt;significance test&lt;/a&gt; should be made.</source>
          <target state="translated">Следует также отметить, что также может быть важно проанализировать результаты микропроцессора при сравнении различных реализаций. Поэтому следует провести &lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot;&gt;тест значимости&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a4a5f032bf62a386234c6f707d69863e3492a61" translate="yes" xml:space="preserve">
          <source>Make sure you run it for long enough to be able to measure the results in seconds or (better) tens of seconds</source>
          <target state="translated">Убедитесь,что вы запускаете его достаточно долго,чтобы быть в состоянии измерить результаты в секундах или (лучше)десятки секунд.</target>
        </trans-unit>
        <trans-unit id="4f40942c1d46b6591496e7b2b047342ec5e9778d" translate="yes" xml:space="preserve">
          <source>Make sure you somehow use results which are computed in benchmarked code. Otherwise your code can be optimized away.</source>
          <target state="translated">Убедитесь,что вы как-то используете результаты,которые вычисляются в эталонном коде.В противном случае Ваш код может быть оптимизирован.</target>
        </trans-unit>
        <trans-unit id="66b7124924abc42f465159758abb309a487e6f45" translate="yes" xml:space="preserve">
          <source>My recommendations: Make your benchmark run some seconds, that is more reliable than a runtime over milliseconds. Warm up the JVM (means running the benchmark at least once without measuring, that the JVM can run optimizations). And run your benchmark multiple times (maybe 5 times) and take the median-value. Run every micro-benchmark in a new JVM-instance (call for every benchmark new Java) otherwise optimization effects of the JVM can influence later running tests. Don't execute things, that aren't executed in the warmup-phase (as this could trigger class-load and recompilation).</source>
          <target state="translated">Мои рекомендации:Заставьте свой эталон работать несколько секунд,что надежнее,чем время работы в миллисекундах.Разогрейте JVM (это означает,что JVM может выполнять оптимизацию без измерения хотя бы один раз).И запустите бенчмарк несколько раз (может быть,5 раз)и возьмите медианное значение.Запускайте каждый микро бенчмарк в новом экземпляре JVM (вызов для каждого бенчмарка новой Java),иначе оптимизационные эффекты JVM могут повлиять на последующие запущенные тесты.Не выполняйте вещи,которые не выполняются в разогреве (так как это может спровоцировать загрузку и перекомпиляцию класса).</target>
        </trans-unit>
        <trans-unit id="84b3a6d3b735a279b8a95eec81ccdd77ef213d67" translate="yes" xml:space="preserve">
          <source>Perhaps a more fundamentally important aspect that you have direct control over: make sure you're measuring the right thing! For example, if you're using &lt;code&gt;System.nanoTime()&lt;/code&gt; to benchmark a particular bit of code, put the calls to the assignment in places that make sense to avoid measuring things which you aren't interested in. For example, don't do:</source>
          <target state="translated">Возможно, это более важный аспект, который вы непосредственно контролируете: убедитесь, что вы измеряете правильную вещь! Например, если вы используете &lt;code&gt;System.nanoTime()&lt;/code&gt; для сравнения определенного фрагмента кода, размещайте вызовы в назначениях в местах, которые имеют смысл, чтобы избежать измерения вещей, которые вам не интересны. Например, не делать:</target>
        </trans-unit>
        <trans-unit id="24e94fd01de88afc005218fb420a74bbf3940440" translate="yes" xml:space="preserve">
          <source>Problem is you're not immediately getting the end time when the code has finished. Instead, try the following:</source>
          <target state="translated">Проблема в том,что вы не сразу получаете время окончания кода.Вместо этого попробуйте следующее:</target>
        </trans-unit>
        <trans-unit id="083b98d32d7fe2f0ca96bec067bd4906c6064c09" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://stackoverflow.com/questions/410437/is-stopwatch-benchmarking-acceptable&quot;&gt;Is stopwatch benchmarking acceptable?&lt;/a&gt;</source>
          <target state="translated">Связанный: &lt;a href=&quot;https://stackoverflow.com/questions/410437/is-stopwatch-benchmarking-acceptable&quot;&gt;приемлем ли сравнительный анализ секундомера?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec4ff7b50a4635d42059faa78909f7f5f9d7a2eb" translate="yes" xml:space="preserve">
          <source>Second: You cannot trust the accuracy of the measured times for very short intervals.</source>
          <target state="translated">Второе:Вы не можете доверять точности измеренных времен в течение очень коротких промежутков времени.</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">См.также:</target>
        </trans-unit>
        <trans-unit id="fec816031df94b29566d620805f308d6cf737166" translate="yes" xml:space="preserve">
          <source>Should the benchmark measure time/iteration or iterations/time, and why?</source>
          <target state="translated">Должен ли эталон измерять время или итерационную оценку,и почему?</target>
        </trans-unit>
        <trans-unit id="c090559196e8e996c17e7d433bc64f8b76c7baad" translate="yes" xml:space="preserve">
          <source>So it is also important to write and run a micro benchmark correctly, but also to analyze it correctly.</source>
          <target state="translated">Поэтому также важно правильно написать и запустить микро бенчмаркинг,а также правильно его проанализировать.</target>
        </trans-unit>
        <trans-unit id="ca5ea60128b328a761b56bf9b62dbcaf8e859acb" translate="yes" xml:space="preserve">
          <source>The jmh is a Java harness for building, running, and analysing nano/micro/macro benchmarks written in Java and other languages targetting the JVM.</source>
          <target state="translated">jmh является Java жгутом для создания,запуска и анализа бенчмарков nanomicromacro,написанных на Java и других языках,нацеленных на JVM.</target>
        </trans-unit>
        <trans-unit id="8b8343ec5e38906eb0a29c2be2182da0957c52aa" translate="yes" xml:space="preserve">
          <source>There are many possible pitfalls for writing micro-benchmarks in Java.</source>
          <target state="translated">Существует много возможных подводных камней для написания микро-бенчмаркеров на Java.</target>
        </trans-unit>
        <trans-unit id="1beb582fcae9e9c673cb7f6f4df5cf4c23a15792" translate="yes" xml:space="preserve">
          <source>Third: The JVM optimizes your code while executing. So different runs in the same JVM-instance will become faster and faster.</source>
          <target state="translated">Третье:JVM оптимизирует ваш код во время выполнения.Так что разные прогоны в одном и том же экземпляре JVM будут становиться все быстрее и быстрее.</target>
        </trans-unit>
        <trans-unit id="0f9f7a1cf8a428a9d13c0c15079ccb8e8a7c3323" translate="yes" xml:space="preserve">
          <source>This is because implementation &lt;code&gt;A&lt;/code&gt; might be faster during most of the runs of the benchmark than implementation &lt;code&gt;B&lt;/code&gt;. But &lt;code&gt;A&lt;/code&gt; might also have a higher spread, so the measured performance benefit of &lt;code&gt;A&lt;/code&gt; won't be of any significance when compared with &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Это связано с тем, что реализация &lt;code&gt;A&lt;/code&gt; может быть быстрее во время большинства прогонов теста, чем реализация &lt;code&gt;B&lt;/code&gt; . Но у &lt;code&gt;A&lt;/code&gt; также может быть более высокий разброс, поэтому измеренный выигрыш в производительности &lt;code&gt;A&lt;/code&gt; не будет иметь никакого значения по сравнению с &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15e6b0c5d76c16417c6007b1618f6b7c6ff8d43d" translate="yes" xml:space="preserve">
          <source>Tips about writing micro benchmarks &lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot;&gt;from the creators of Java HotSpot&lt;/a&gt;:</source>
          <target state="translated">Советы по написанию микро-тестов &lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot;&gt;от создателей Java HotSpot&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2175398196c5bd9dc22098e16383b9977459087d" translate="yes" xml:space="preserve">
          <source>To add to the other excellent advice, I'd also be mindful of the following:</source>
          <target state="translated">В дополнение к другим отличным советам,я бы также принял во внимание следующее:</target>
        </trans-unit>
        <trans-unit id="23055b4d37f59f17de37b2f34febaa4ebff5215d" translate="yes" xml:space="preserve">
          <source>Very interesting pieces of information buried in &lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot;&gt;the sample tests comments&lt;/a&gt;.</source>
          <target state="translated">Очень интересные фрагменты информации скрыты в &lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot;&gt;примерах тестовых комментариев&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ada6fca5c78392f28aae4ac87bca62c28900053" translate="yes" xml:space="preserve">
          <source>Warm up the JIT first by running the code several times &lt;strong&gt;before timing&lt;/strong&gt; it</source>
          <target state="translated">Сначала прогрейте JIT, запустив код несколько раз, &lt;strong&gt;прежде чем синхронизировать&lt;/strong&gt; его</target>
        </trans-unit>
        <trans-unit id="266c504aa997c2e2ca6e724568658a941f940414" translate="yes" xml:space="preserve">
          <source>While you can't call &lt;code&gt;System.gc()&lt;/code&gt; between iterations, it's a good idea to run it between tests, so that each test will hopefully get a &quot;clean&quot; memory space to work with. (Yes, &lt;code&gt;gc()&lt;/code&gt; is more of a hint than a guarantee, but it's very &lt;em&gt;likely&lt;/em&gt; that it really will garbage collect in my experience.)</source>
          <target state="translated">Несмотря на то, что вы не можете вызывать &lt;code&gt;System.gc()&lt;/code&gt; между итерациями, рекомендуется запускать его между тестами, чтобы каждый тест получал &amp;laquo;чистое&amp;raquo; пространство памяти для работы. (Да, &lt;code&gt;gc()&lt;/code&gt; - это скорее подсказка, чем гарантия, но вполне &lt;em&gt;вероятно,&lt;/em&gt; что в моем опыте он действительно будет собирать мусор.)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
