<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/504103">
    <body>
      <group id="504103">
        <trans-unit id="7c98885362dfac889a9855e3cada87c420301ccb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;jmh&lt;/a&gt; is a recent addition to OpenJDK and has been written by some performance engineers from Oracle. Certainly worth a look.</source>
          <target state="translated">&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;jmh&lt;/a&gt; 는 최근 OpenJDK에 추가되었으며 Oracle의 일부 성능 엔지니어가 작성했습니다. 확실히 볼만한 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e83d76042e828ed3c8e11fb07151725fca9240b5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://opt.sourceforge.net/&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark - control tasks required to determine the comparative performance characteristics of the computer system on different platforms. Can be used to guide optimization decisions and to compare different Java implementations.</source>
          <target state="translated">&lt;a href=&quot;http://opt.sourceforge.net/&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark-다른 플랫폼에서 컴퓨터 시스템의 비교 성능 특성을 결정하는 데 필요한 제어 작업. 최적화 결정을 안내하고 다른 Java 구현을 비교하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="002ff0009ac698d62577e1dacfbbd66bec9fce5f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot;&gt;Discussion on the main strengths of jmh&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot;&gt;jmh의 주요 강점에 대한 토론&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3262a13a878ada9ad80da38be74e4e326a4dbc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Getting started tutorials&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;튜토리얼 시작하기&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58b8f129eaa1ef1df1f79c088dc155d676bab11c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH from OpenJDK&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;OpenJDK의 JMH&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1cab88a8d7c77af82261e5a17335a55be0286ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper from Google&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Google의 캘리퍼스&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e08658c12ec073195992e373f7f39e2930d359c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 0:&lt;/strong&gt; Read a reputable paper on JVMs and micro-benchmarking. A good one is &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot;&gt;Brian Goetz, 2005&lt;/a&gt;. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics.</source>
          <target state="translated">&lt;strong&gt;규칙 0 :&lt;/strong&gt; JVM 및 마이크로 벤치마킹에 대한 평판이 좋은 논문을 읽으십시오. 좋은 것은 &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot;&gt;Brian Goetz, 2005&lt;/a&gt; 입니다. 마이크로 벤치 마크에서 너무 많이 기대하지 마십시오. 제한된 범위의 JVM 성능 특성 만 측정합니다.</target>
        </trans-unit>
        <trans-unit id="d45fa44e30fc3e7cad85ca1896b5fffd407b89b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 1:&lt;/strong&gt; Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timing phase(s). (Fewer iterations is OK on the warmup phase. The rule of thumb is several tens of thousands of inner loop iterations.)</source>
          <target state="translated">&lt;strong&gt;규칙 1 :&lt;/strong&gt; 타이밍 단계 전에 모든 초기화 및 컴파일을 트리거 할 수있을만큼 테스트 커널을 끝까지 실행하는 워밍업 단계를 항상 포함하십시오. 예열 단계에서는 반복 횟수가 적습니다. 일반적으로 수만 개의 내부 루프 반복이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c3aa86e67b88f2049f3994203039a7ec263cde1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 2.1:&lt;/strong&gt; Print messages at the beginning and end of timing and warmup phases, so you can verify that there is no output from Rule 2 during the timing phase.</source>
          <target state="translated">&lt;strong&gt;규칙 2.1 :&lt;/strong&gt; 타이밍 및 워밍업 단계의 시작과 끝에 메시지를 인쇄하여 타이밍 단계 중에 규칙 2의 출력이 없는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2003e400027cc14055ad96eecc77dd4cc897cde" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 2:&lt;/strong&gt; Always run with &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt;, &lt;code&gt;-verbose:gc&lt;/code&gt;, etc., so you can verify that the compiler and other parts of the JVM are not doing unexpected work during your timing phase.</source>
          <target state="translated">&lt;strong&gt;규칙 2 :&lt;/strong&gt; 항상 &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; , &lt;code&gt;-verbose:gc&lt;/code&gt; 등으로 실행되므로 타이밍 단계에서 컴파일러 및 기타 JVM 부분이 예상치 못한 작업을 수행하고 있지 않은지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82a300d3f7024d24e03d349acfe0ce39d6315045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 3:&lt;/strong&gt; Be aware of the difference between &lt;code&gt;-client&lt;/code&gt; and &lt;code&gt;-server&lt;/code&gt;, and OSR and regular compilations. The &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; flag reports OSR compilations with an at-sign to denote the non-initial entry point, for example: &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt;. Prefer server to client, and regular to OSR, if you are after best performance.</source>
          <target state="translated">&lt;strong&gt;규칙 3 :&lt;/strong&gt; &lt;code&gt;-client&lt;/code&gt; 와 &lt;code&gt;-server&lt;/code&gt; , OSR과 정기적 컴파일의 차이점을 알고 있어야합니다. &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; 플래그는 초기 부호가 아닌 진입 점을 표시하기 위해 at 기호로 OSR 컴파일을보고합니다 (예 : &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt; . 최상의 성능을 갖춘 경우 서버를 클라이언트로, OSR을 정기적으로 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="9fe68b85cd38859a59a3c019f4abe56850c6f896" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 4:&lt;/strong&gt; Be aware of initialization effects. Do not print for the first time during your timing phase, since printing loads and initializes classes. Do not load new classes outside of the warmup phase (or final reporting phase), unless you are testing class loading specifically (and in that case load only the test classes). Rule 2 is your first line of defense against such effects.</source>
          <target state="translated">&lt;strong&gt;규칙 4 :&lt;/strong&gt; 초기화 효과에 유의하십시오. 인쇄는 클래스를로드하고 초기화하기 때문에 타이밍 단계에서 처음으로 인쇄하지 마십시오. 클래스 로딩을 구체적으로 테스트하지 않는 한 (그리고이 경우 테스트 클래스 만로드) 워밍업 단계 (또는 최종보고 단계) 외부에 새 클래스를로드하지 마십시오. 규칙 2는 이러한 영향에 대한 첫 번째 방어선입니다.</target>
        </trans-unit>
        <trans-unit id="96adbb1b64b53f6a4f822f7be16037426b9faf61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 5:&lt;/strong&gt; Be aware of deoptimization and recompilation effects. Do not take any code path for the first time in the timing phase, because the compiler may junk and recompile the code, based on an earlier optimistic assumption that the path was not going to be used at all. Rule 2 is your first line of defense against such effects.</source>
          <target state="translated">&lt;strong&gt;규칙 5 :&lt;/strong&gt; 최적화 해제 및 재 컴파일 효과에 유의하십시오. 경로가 전혀 사용되지 않을 것이라는 이전의 낙관적 인 가정에 따라 컴파일러가 코드를 정크 및 재 컴파일 할 수 있으므로 타이밍 단계에서 처음으로 코드 경로를 사용하지 마십시오. 규칙 2는 이러한 영향에 대한 첫 번째 방어선입니다.</target>
        </trans-unit>
        <trans-unit id="7fb62c7b72ed7085cdadc9ffda9ceefbbb9ad946" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 6:&lt;/strong&gt; Use appropriate tools to read the compiler's mind, and expect to be surprised by the code it produces. Inspect the code yourself before forming theories about what makes something faster or slower.</source>
          <target state="translated">&lt;strong&gt;규칙 6 :&lt;/strong&gt; 적절한 도구를 사용하여 컴파일러의 생각을 읽고, 생성하는 코드에 놀라게 될 것입니다. 무언가를 더 빠르거나 느리게 만드는 것에 대한 이론을 만들기 전에 코드를 직접 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="5c5dde812c075176c9041fa138d2a9a90fce4363" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 7:&lt;/strong&gt; Reduce noise in your measurements. Run your benchmark on a quiet machine, and run it several times, discarding outliers. Use &lt;code&gt;-Xbatch&lt;/code&gt; to serialize the compiler with the application, and consider setting &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; to prevent the compiler from running in parallel with itself. Try your best to reduce GC overhead, set &lt;code&gt;Xmx&lt;/code&gt;(large enough) equals &lt;code&gt;Xms&lt;/code&gt; and use &lt;a href=&quot;http://openjdk.java.net/jeps/318&quot;&gt;&lt;code&gt;UseEpsilonGC&lt;/code&gt;&lt;/a&gt; if it is available.</source>
          <target state="translated">&lt;strong&gt;규칙 7 :&lt;/strong&gt; 측정시 노이즈를 줄입니다. 조용한 컴퓨터에서 벤치 마크를 실행하고 여러 번 실행하여 특이 치를 버립니다. &lt;code&gt;-Xbatch&lt;/code&gt; 를 사용하여 응용 프로그램으로 컴파일러를 직렬화하고 컴파일러가 자체적으로 병렬로 실행되지 않도록 &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; 설정을 고려하십시오. GC 오버 헤드를 줄이려면 최선을 다하고 &lt;code&gt;Xmx&lt;/code&gt; (충분히 큰)를 &lt;code&gt;Xms&lt;/code&gt; 로 설정 하고 사용 &lt;a href=&quot;http://openjdk.java.net/jeps/318&quot;&gt; &lt;code&gt;UseEpsilonGC&lt;/code&gt; &lt;/a&gt; 경우 UseEpsilonGC 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4794c7852029678f813d3a6a3ad951731b0589f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 8:&lt;/strong&gt; Use a library for your benchmark as it is probably more efficient and was already debugged for this sole purpose. Such as &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt;, &lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper&lt;/a&gt; or &lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot;&gt;Bill and Paul's Excellent UCSD Benchmarks for Java&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;규칙 8 :&lt;/strong&gt; 벤치 마크에 라이브러리를 사용하는 것이 더 효율적일 수 있으며이 목적을 위해 이미 디버깅되었습니다. &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt; , &lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper&lt;/a&gt; 또는 &lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot;&gt;Bill 및 Paul의 Java에 대한 탁월한 UCSD 벤치 마크와 같은&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b900f6d5071c2310201e024ff990519c9b60003" translate="yes" xml:space="preserve">
          <source>Also, make sure that &lt;em&gt;n&lt;/em&gt; is very large, so that the runtime of each loop is at the very least 10 seconds or so.  The more iterations, the more significant figures in your benchmark time and the more reliable that data is.</source>
          <target state="translated">또한 각 루프의 런타임이 최소 10 초 정도가되도록 &lt;em&gt;n&lt;/em&gt; 이 매우 큰지 확인하십시오. 반복 횟수가 많을수록 벤치 마크 시간이 더 중요하고 데이터의 안정성이 높아집니다.</target>
        </trans-unit>
        <trans-unit id="291a53f8afab7a8ada4aa04f96b773eb9331ee82" translate="yes" xml:space="preserve">
          <source>Avoiding Benchmarking Pitfalls on the JVM</source>
          <target state="translated">JVM에서 벤치마킹 함정 방지</target>
        </trans-unit>
        <trans-unit id="9fdb89d13608249537686498201d2b8013f81d5b" translate="yes" xml:space="preserve">
          <source>Example: Should the benchmark measure time/iteration or iterations/time, and why?</source>
          <target state="translated">예 : 벤치 마크가 시간 / 반복 또는 반복 / 시간을 측정해야하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7c30a2a120296936d804852069941c3f3b4b3697" translate="yes" xml:space="preserve">
          <source>First: You have to calculate with all sorts of events that take time more or less random: Garbage collection, caching effects (of OS for files and of CPU for memory), IO etc.</source>
          <target state="translated">첫째 : 가비지 수집, 캐싱 효과 (파일의 OS 및 메모리의 CPU), IO 등 시간이 다소 무작위로 걸리는 모든 종류의 이벤트를 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fd020f2e8c9e9c9f5c7fabb9d269a776ca80082" translate="yes" xml:space="preserve">
          <source>For some CPUs (e.g. Intel Core i5 range with TurboBoost), the temperature (and number of cores currently being used, as well as thier utilisation percent) affects the clock speed. Since CPUs are dynamically clocked, this can affect your results. For example, if you have a single-threaded application, the maximum clock speed (with TurboBoost) is higher than for an application using all cores. This can therefore interfere with comparisons of single and multi-threaded performance on some systems. Bear in mind that the temperature and volatages also affect how long Turbo frequency is maintained.</source>
          <target state="translated">일부 CPU (예 : TurboBoost가 포함 된 Intel Core i5 범위)의 경우 온도 (및 현재 사용중인 코어 수 및 전체 활용률)가 ​​클럭 속도에 영향을줍니다. CPU는 동적으로 클럭되므로 결과에 영향을 줄 수 있습니다. 예를 들어 단일 스레드 응용 프로그램을 사용하는 경우 최대 코어 속도 (TurboBoost 사용)는 모든 코어를 사용하는 응용 프로그램보다 높습니다. 따라서 일부 시스템에서 단일 및 다중 스레드 성능의 비교를 방해 할 수 있습니다. 온도와 전압은 터보 주파수가 유지되는 시간에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="7b60187da88886bca2657e4a6777410827026413" translate="yes" xml:space="preserve">
          <source>How do I write a correct micro-benchmark in Java</source>
          <target state="translated">Java에서 올바른 마이크로 벤치 마크를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="1cbff6d9740743fbbd7f9c95fa887c6effb7d086" translate="yes" xml:space="preserve">
          <source>How do you write (and run) a correct micro-benchmark in Java?</source>
          <target state="translated">Java에서 올바른 마이크로 벤치 마크를 작성하고 실행하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="345f77da8a43bfb9f331059c7ac811f4abfb5447" translate="yes" xml:space="preserve">
          <source>I have found some noticeable differences (5-10% sometimes) in the runtime of the same algorithm in different passes..</source>
          <target state="translated">다른 패스에서 동일한 알고리즘의 런타임에서 눈에 띄는 차이 (때로는 5-10 %)를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="9288dce15b94ef8dabd0c6bdca3af22ce5ad08c1" translate="yes" xml:space="preserve">
          <source>I know this question has been marked as answered but I wanted to mention two libraries that help us to write micro benchmarks</source>
          <target state="translated">이 질문에 대한 답변이 표시되었지만 마이크로 벤치 마크 작성에 도움이되는 두 개의 라이브러리를 언급하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="b49185e438b5ff2e0365effaefd146926922e274" translate="yes" xml:space="preserve">
          <source>I like to display iterations and time, and a score of time/iteration which can be scaled such that the &quot;best&quot; algorithm gets a score of 1.0 and others are scored in a relative fashion. This means you can run &lt;em&gt;all&lt;/em&gt; algorithms for a longish time, varying both number of iterations and time, but still getting comparable results.</source>
          <target state="translated">반복 및 시간을 표시하고 &quot;최상의&quot;알고리즘이 1.0의 점수를 얻고 다른 알고리즘이 상대적으로 점수가 매겨 질 수 있도록 시간 / 반복 점수를 표시하고 싶습니다. 즉, 반복 횟수와 시간을 모두 바꾸면서도 &lt;em&gt;모든&lt;/em&gt; 알고리즘을 오랫동안 실행할 수 있지만 여전히 비슷한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="073918582af97d175c9583f4544e6c59d66b8800" translate="yes" xml:space="preserve">
          <source>I'm just in the process of blogging about the design of a benchmarking framework in .NET. I've got a &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/26/benchmarking-made-easy.aspx&quot;&gt;couple&lt;/a&gt; of &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot;&gt;earlier posts&lt;/a&gt; which may be able to give you some ideas - not everything will be appropriate, of course, but some of it may be.</source>
          <target state="translated">.NET에서 벤치마킹 프레임 워크 디자인에 대해 블로그하는 중입니다. 나는 당신에게 몇 가지 아이디어를 줄 수있는 &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/26/benchmarking-made-easy.aspx&quot;&gt;몇&lt;/a&gt; 가지 &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot;&gt;초기 게시물을&lt;/a&gt; 가지고 있습니다. 물론 모든 것이 적절하지는 않지만 일부는 적합 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="51e309adae3a577233db4148a52db0b5e82ad882" translate="yes" xml:space="preserve">
          <source>I'm looking for some code samples and comments illustrating various things to think about.</source>
          <target state="translated">생각할 다양한 것들을 보여주는 몇 가지 코드 샘플과 주석을 찾고 있습니다.</target>
        </trans-unit>
        <trans-unit id="36261b5d7d09dc19c64cb2ee96d2ae81bfed859d" translate="yes" xml:space="preserve">
          <source>If you are interested in &lt;strong&gt;latency&lt;/strong&gt;, use time/iteration and if you are interested in &lt;strong&gt;throughput&lt;/strong&gt;, use iterations/time.</source>
          <target state="translated">&lt;strong&gt;대기 시간&lt;/strong&gt; 에 관심이있는 경우 시간 / 반복을 사용하고 &lt;strong&gt;처리량에&lt;/strong&gt; 관심이있는 경우 반복 / 시간을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57fe3c1aa7a71ecc2622b2368266380f1ba646de" translate="yes" xml:space="preserve">
          <source>If you are trying to compare two algorithms, do at least two benchmarks for each, alternating the order.  i.e.:</source>
          <target state="translated">두 알고리즘을 비교하려는 경우 순서에 따라 두 개 이상의 벤치 마크를 수행하십시오. 즉 :</target>
        </trans-unit>
        <trans-unit id="446509b69736161c6a7f8538df894b0283704899" translate="yes" xml:space="preserve">
          <source>Important things for Java benchmarks are:</source>
          <target state="translated">Java 벤치 마크의 중요한 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a984f01db14194be668e260faf7f1dd1670ba36" translate="yes" xml:space="preserve">
          <source>It depends on &lt;strong&gt;what&lt;/strong&gt; you are trying to test.</source>
          <target state="translated">테스트하려는 대상에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="feeb65010e24c48f6e8b09b1aefe0fddee8b6bc9" translate="yes" xml:space="preserve">
          <source>It should also be noted that it might also be important to analyze the results of the micro benchmark when comparing different implementations. Therefore a &lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot;&gt;significance test&lt;/a&gt; should be made.</source>
          <target state="translated">또한 다른 구현을 비교할 때 마이크로 벤치 마크 결과를 분석하는 것이 중요 할 수도 있습니다. 따라서 &lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot;&gt;유의성 테스트를 수행&lt;/a&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a4a5f032bf62a386234c6f707d69863e3492a61" translate="yes" xml:space="preserve">
          <source>Make sure you run it for long enough to be able to measure the results in seconds or (better) tens of seconds</source>
          <target state="translated">결과를 초 또는 (더 나은) 수십 초로 측정 할 수있을 정도로 오랫동안 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="4f40942c1d46b6591496e7b2b047342ec5e9778d" translate="yes" xml:space="preserve">
          <source>Make sure you somehow use results which are computed in benchmarked code. Otherwise your code can be optimized away.</source>
          <target state="translated">어떻게 든 벤치마킹 된 코드로 계산 된 결과를 사용해야합니다. 그렇지 않으면 코드를 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66b7124924abc42f465159758abb309a487e6f45" translate="yes" xml:space="preserve">
          <source>My recommendations: Make your benchmark run some seconds, that is more reliable than a runtime over milliseconds. Warm up the JVM (means running the benchmark at least once without measuring, that the JVM can run optimizations). And run your benchmark multiple times (maybe 5 times) and take the median-value. Run every micro-benchmark in a new JVM-instance (call for every benchmark new Java) otherwise optimization effects of the JVM can influence later running tests. Don't execute things, that aren't executed in the warmup-phase (as this could trigger class-load and recompilation).</source>
          <target state="translated">내 권장 사항 : 벤치 마크를 몇 초 동안 실행하십시오. 즉, 밀리 초 이상의 런타임보다 안정적입니다. JVM을 준비합니다 (측정하지 않고 벤치 마크를 한 번 이상 실행하면 JVM이 최적화를 실행할 수 있음). 그리고 벤치 마크를 여러 번 (5 회 정도) 실행하고 중앙값을 가져옵니다. 새로운 JVM 인스턴스에서 모든 마이크로 벤치 마크를 실행하십시오 (모든 벤치 마크 새 Java를 호출). 그렇지 않으면 JVM의 최적화 효과가 나중에 실행중인 테스트에 영향을 줄 수 있습니다. 예열 단계에서 실행되지 않는 작업은 실행하지 마십시오 (클래스로드 및 재 컴파일을 트리거 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="84b3a6d3b735a279b8a95eec81ccdd77ef213d67" translate="yes" xml:space="preserve">
          <source>Perhaps a more fundamentally important aspect that you have direct control over: make sure you're measuring the right thing! For example, if you're using &lt;code&gt;System.nanoTime()&lt;/code&gt; to benchmark a particular bit of code, put the calls to the assignment in places that make sense to avoid measuring things which you aren't interested in. For example, don't do:</source>
          <target state="translated">아마도 직접적으로 제어 할 수있는보다 근본적으로 중요한 측면 일 것입니다. 올바른 것을 측정하고 있는지 확인하십시오! 예를 들어, 특정 코드 비트를 벤치마킹하기 위해 &lt;code&gt;System.nanoTime()&lt;/code&gt; 을 사용하는 경우 관심없는 항목을 측정하지 않도록 적절한 위치에 할당을 호출하십시오. 예를 들어, 하다:</target>
        </trans-unit>
        <trans-unit id="24e94fd01de88afc005218fb420a74bbf3940440" translate="yes" xml:space="preserve">
          <source>Problem is you're not immediately getting the end time when the code has finished. Instead, try the following:</source>
          <target state="translated">문제는 코드가 끝나면 즉시 종료 시간을 얻지 못한다는 것입니다. 대신 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="083b98d32d7fe2f0ca96bec067bd4906c6064c09" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://stackoverflow.com/questions/410437/is-stopwatch-benchmarking-acceptable&quot;&gt;Is stopwatch benchmarking acceptable?&lt;/a&gt;</source>
          <target state="translated">관련 : &lt;a href=&quot;https://stackoverflow.com/questions/410437/is-stopwatch-benchmarking-acceptable&quot;&gt;스톱워치 벤치마킹이 허용됩니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec4ff7b50a4635d42059faa78909f7f5f9d7a2eb" translate="yes" xml:space="preserve">
          <source>Second: You cannot trust the accuracy of the measured times for very short intervals.</source>
          <target state="translated">둘째 : 매우 짧은 간격 동안 측정 된 시간의 정확도를 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="fec816031df94b29566d620805f308d6cf737166" translate="yes" xml:space="preserve">
          <source>Should the benchmark measure time/iteration or iterations/time, and why?</source>
          <target state="translated">벤치 마크가 시간 / 반복 또는 반복 / 시간을 측정해야하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c090559196e8e996c17e7d433bc64f8b76c7baad" translate="yes" xml:space="preserve">
          <source>So it is also important to write and run a micro benchmark correctly, but also to analyze it correctly.</source>
          <target state="translated">따라서 마이크로 벤치 마크를 올바르게 작성하고 실행하는 것뿐만 아니라 올바르게 분석하는 것도 중요합니다.</target>
        </trans-unit>
        <trans-unit id="ca5ea60128b328a761b56bf9b62dbcaf8e859acb" translate="yes" xml:space="preserve">
          <source>The jmh is a Java harness for building, running, and analysing nano/micro/macro benchmarks written in Java and other languages targetting the JVM.</source>
          <target state="translated">jmh는 Java 및 JVM을 대상으로하는 다른 언어로 작성된 나노 / 마이크로 / 매크로 벤치 마크를 작성, 실행 및 분석하기위한 Java 하네스입니다.</target>
        </trans-unit>
        <trans-unit id="8b8343ec5e38906eb0a29c2be2182da0957c52aa" translate="yes" xml:space="preserve">
          <source>There are many possible pitfalls for writing micro-benchmarks in Java.</source>
          <target state="translated">Java로 마이크로 벤치 마크를 작성하는 데는 많은 함정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1beb582fcae9e9c673cb7f6f4df5cf4c23a15792" translate="yes" xml:space="preserve">
          <source>Third: The JVM optimizes your code while executing. So different runs in the same JVM-instance will become faster and faster.</source>
          <target state="translated">셋째 : JVM은 실행하는 동안 코드를 최적화합니다. 따라서 동일한 JVM 인스턴스에서 다른 실행이 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="0f9f7a1cf8a428a9d13c0c15079ccb8e8a7c3323" translate="yes" xml:space="preserve">
          <source>This is because implementation &lt;code&gt;A&lt;/code&gt; might be faster during most of the runs of the benchmark than implementation &lt;code&gt;B&lt;/code&gt;. But &lt;code&gt;A&lt;/code&gt; might also have a higher spread, so the measured performance benefit of &lt;code&gt;A&lt;/code&gt; won't be of any significance when compared with &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">이는 구현 &lt;code&gt;A&lt;/code&gt; 가 구현 &lt;code&gt;B&lt;/code&gt; 보다 대부분의 벤치 마크 실행 중에 더 빠를 수 있기 때문입니다. 그러나 &lt;code&gt;A&lt;/code&gt; 의 스프레드가 더 높을 수 있으므로 A 의 측정 성능 이점은 &lt;code&gt;B&lt;/code&gt; 와 비교할 때 아무런 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="15e6b0c5d76c16417c6007b1618f6b7c6ff8d43d" translate="yes" xml:space="preserve">
          <source>Tips about writing micro benchmarks &lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot;&gt;from the creators of Java HotSpot&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot;&gt;Java HotSpot 제작자의&lt;/a&gt; 마이크로 벤치 마크 작성에 대한 팁 :</target>
        </trans-unit>
        <trans-unit id="2175398196c5bd9dc22098e16383b9977459087d" translate="yes" xml:space="preserve">
          <source>To add to the other excellent advice, I'd also be mindful of the following:</source>
          <target state="translated">다른 훌륭한 조언을 추가하기 위해 다음 사항도 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="23055b4d37f59f17de37b2f34febaa4ebff5215d" translate="yes" xml:space="preserve">
          <source>Very interesting pieces of information buried in &lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot;&gt;the sample tests comments&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot;&gt;샘플 테스트 주석에&lt;/a&gt; 묻힌 매우 흥미로운 정보 조각.</target>
        </trans-unit>
        <trans-unit id="0ada6fca5c78392f28aae4ac87bca62c28900053" translate="yes" xml:space="preserve">
          <source>Warm up the JIT first by running the code several times &lt;strong&gt;before timing&lt;/strong&gt; it</source>
          <target state="translated">코드 &lt;strong&gt;를 타이밍하기 전에&lt;/strong&gt; 코드를 여러 번 실행하여 JIT를 먼저 예열하십시오.</target>
        </trans-unit>
        <trans-unit id="266c504aa997c2e2ca6e724568658a941f940414" translate="yes" xml:space="preserve">
          <source>While you can't call &lt;code&gt;System.gc()&lt;/code&gt; between iterations, it's a good idea to run it between tests, so that each test will hopefully get a &quot;clean&quot; memory space to work with. (Yes, &lt;code&gt;gc()&lt;/code&gt; is more of a hint than a guarantee, but it's very &lt;em&gt;likely&lt;/em&gt; that it really will garbage collect in my experience.)</source>
          <target state="translated">반복 사이에 &lt;code&gt;System.gc()&lt;/code&gt; 호출 할 수는 없지만 테스트간에이를 실행하는 것이 좋습니다. 따라서 각 테스트에서 &quot;깨끗한&quot;메모리 공간을 확보 할 수 있습니다. (예, &lt;code&gt;gc()&lt;/code&gt; 는 보증보다 암시적인 것이지만 실제로 내 경험에서 가비지 수집 &lt;em&gt;가능성&lt;/em&gt; 이 &lt;em&gt;높습니다&lt;/em&gt; .)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
