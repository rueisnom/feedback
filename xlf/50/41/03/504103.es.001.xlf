<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/504103">
    <body>
      <group id="504103">
        <trans-unit id="7c98885362dfac889a9855e3cada87c420301ccb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;jmh&lt;/a&gt; is a recent addition to OpenJDK and has been written by some performance engineers from Oracle. Certainly worth a look.</source>
          <target state="translated">&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;jmh&lt;/a&gt; es una adici&amp;oacute;n reciente a OpenJDK y ha sido escrito por algunos ingenieros de rendimiento de Oracle. Sin duda vale la pena echarle un vistazo.</target>
        </trans-unit>
        <trans-unit id="e83d76042e828ed3c8e11fb07151725fca9240b5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://opt.sourceforge.net/&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark - control tasks required to determine the comparative performance characteristics of the computer system on different platforms. Can be used to guide optimization decisions and to compare different Java implementations.</source>
          <target state="translated">&lt;a href=&quot;http://opt.sourceforge.net/&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark: tareas de control necesarias para determinar las caracter&amp;iacute;sticas comparativas de rendimiento del sistema inform&amp;aacute;tico en diferentes plataformas. Se puede utilizar para guiar las decisiones de optimizaci&amp;oacute;n y comparar diferentes implementaciones de Java.</target>
        </trans-unit>
        <trans-unit id="002ff0009ac698d62577e1dacfbbd66bec9fce5f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot;&gt;Discussion on the main strengths of jmh&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot;&gt;Discusi&amp;oacute;n sobre las principales fortalezas de jmh&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3262a13a878ada9ad80da38be74e4e326a4dbc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Getting started tutorials&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Tutoriales de iniciaci&amp;oacute;n&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58b8f129eaa1ef1df1f79c088dc155d676bab11c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH from OpenJDK&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH de OpenJDK&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1cab88a8d7c77af82261e5a17335a55be0286ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper from Google&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Pinza de Google&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e08658c12ec073195992e373f7f39e2930d359c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 0:&lt;/strong&gt; Read a reputable paper on JVMs and micro-benchmarking. A good one is &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot;&gt;Brian Goetz, 2005&lt;/a&gt;. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics.</source>
          <target state="translated">&lt;strong&gt;Regla 0:&lt;/strong&gt; Lea un documento de buena reputaci&amp;oacute;n sobre JVM y micro-benchmarking. Uno bueno es &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot;&gt;Brian Goetz, 2005&lt;/a&gt; . No esperes demasiado de los micro-puntos de referencia; miden solo un rango limitado de caracter&amp;iacute;sticas de rendimiento de JVM.</target>
        </trans-unit>
        <trans-unit id="d45fa44e30fc3e7cad85ca1896b5fffd407b89b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 1:&lt;/strong&gt; Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timing phase(s). (Fewer iterations is OK on the warmup phase. The rule of thumb is several tens of thousands of inner loop iterations.)</source>
          <target state="translated">&lt;strong&gt;Regla 1:&lt;/strong&gt; Incluya siempre una fase de calentamiento que ejecute su n&amp;uacute;cleo de prueba hasta el final, lo suficiente como para activar todas las inicializaciones y compilaciones antes de la (s) fase (s) de temporizaci&amp;oacute;n. (Menos iteraciones est&amp;aacute;n bien en la fase de calentamiento. La regla general es varias decenas de miles de iteraciones de bucle interno).</target>
        </trans-unit>
        <trans-unit id="8c3aa86e67b88f2049f3994203039a7ec263cde1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 2.1:&lt;/strong&gt; Print messages at the beginning and end of timing and warmup phases, so you can verify that there is no output from Rule 2 during the timing phase.</source>
          <target state="translated">&lt;strong&gt;Regla 2.1:&lt;/strong&gt; Imprima mensajes al comienzo y al final de las fases de temporizaci&amp;oacute;n y calentamiento, para que pueda verificar que no haya salida de la Regla 2 durante la fase de temporizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f2003e400027cc14055ad96eecc77dd4cc897cde" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 2:&lt;/strong&gt; Always run with &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt;, &lt;code&gt;-verbose:gc&lt;/code&gt;, etc., so you can verify that the compiler and other parts of the JVM are not doing unexpected work during your timing phase.</source>
          <target state="translated">&lt;strong&gt;Regla 2:&lt;/strong&gt; siempre ejecute con &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; , -verbose &lt;code&gt;-verbose:gc&lt;/code&gt; , etc., para que pueda verificar que el compilador y otras partes de la JVM no est&amp;aacute;n haciendo un trabajo inesperado durante su fase de temporizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="82a300d3f7024d24e03d349acfe0ce39d6315045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 3:&lt;/strong&gt; Be aware of the difference between &lt;code&gt;-client&lt;/code&gt; and &lt;code&gt;-server&lt;/code&gt;, and OSR and regular compilations. The &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; flag reports OSR compilations with an at-sign to denote the non-initial entry point, for example: &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt;. Prefer server to client, and regular to OSR, if you are after best performance.</source>
          <target state="translated">&lt;strong&gt;Regla 3:&lt;/strong&gt; Tenga en cuenta la diferencia entre &lt;code&gt;-client&lt;/code&gt; y &lt;code&gt;-server&lt;/code&gt; , y OSR y compilaciones regulares. El &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; informa compilaciones de OSR con un signo de signo para denotar el punto de entrada no inicial, por ejemplo: &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt; . Prefiere servidor a cliente y regular a OSR, si buscas el mejor rendimiento.</target>
        </trans-unit>
        <trans-unit id="9fe68b85cd38859a59a3c019f4abe56850c6f896" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 4:&lt;/strong&gt; Be aware of initialization effects. Do not print for the first time during your timing phase, since printing loads and initializes classes. Do not load new classes outside of the warmup phase (or final reporting phase), unless you are testing class loading specifically (and in that case load only the test classes). Rule 2 is your first line of defense against such effects.</source>
          <target state="translated">&lt;strong&gt;Regla 4:&lt;/strong&gt; Tenga en cuenta los efectos de inicializaci&amp;oacute;n. No imprima por primera vez durante su fase de temporizaci&amp;oacute;n, ya que la impresi&amp;oacute;n carga e inicializa las clases. No cargue nuevas clases fuera de la fase de calentamiento (o fase de informe final), a menos que est&amp;eacute; probando la carga de clase espec&amp;iacute;ficamente (y en ese caso cargue solo las clases de prueba). La regla 2 es su primera l&amp;iacute;nea de defensa contra tales efectos.</target>
        </trans-unit>
        <trans-unit id="96adbb1b64b53f6a4f822f7be16037426b9faf61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 5:&lt;/strong&gt; Be aware of deoptimization and recompilation effects. Do not take any code path for the first time in the timing phase, because the compiler may junk and recompile the code, based on an earlier optimistic assumption that the path was not going to be used at all. Rule 2 is your first line of defense against such effects.</source>
          <target state="translated">&lt;strong&gt;Regla 5:&lt;/strong&gt; Tenga en cuenta los efectos de desoptimizaci&amp;oacute;n y recompilaci&amp;oacute;n. No tome ninguna ruta de c&amp;oacute;digo por primera vez en la fase de temporizaci&amp;oacute;n, porque el compilador puede desechar y volver a compilar el c&amp;oacute;digo, en base a una suposici&amp;oacute;n optimista anterior de que la ruta no se iba a utilizar en absoluto. La regla 2 es su primera l&amp;iacute;nea de defensa contra tales efectos.</target>
        </trans-unit>
        <trans-unit id="7fb62c7b72ed7085cdadc9ffda9ceefbbb9ad946" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 6:&lt;/strong&gt; Use appropriate tools to read the compiler's mind, and expect to be surprised by the code it produces. Inspect the code yourself before forming theories about what makes something faster or slower.</source>
          <target state="translated">&lt;strong&gt;Regla 6:&lt;/strong&gt; Use las herramientas apropiadas para leer la mente del compilador y espere ser sorprendido por el c&amp;oacute;digo que produce. Inspeccione el c&amp;oacute;digo usted mismo antes de formar teor&amp;iacute;as sobre lo que hace que algo sea m&amp;aacute;s r&amp;aacute;pido o m&amp;aacute;s lento.</target>
        </trans-unit>
        <trans-unit id="5c5dde812c075176c9041fa138d2a9a90fce4363" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 7:&lt;/strong&gt; Reduce noise in your measurements. Run your benchmark on a quiet machine, and run it several times, discarding outliers. Use &lt;code&gt;-Xbatch&lt;/code&gt; to serialize the compiler with the application, and consider setting &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; to prevent the compiler from running in parallel with itself. Try your best to reduce GC overhead, set &lt;code&gt;Xmx&lt;/code&gt;(large enough) equals &lt;code&gt;Xms&lt;/code&gt; and use &lt;a href=&quot;http://openjdk.java.net/jeps/318&quot;&gt;&lt;code&gt;UseEpsilonGC&lt;/code&gt;&lt;/a&gt; if it is available.</source>
          <target state="translated">&lt;strong&gt;Regla 7:&lt;/strong&gt; reduzca el ruido en sus mediciones. Ejecute su punto de referencia en una m&amp;aacute;quina silenciosa, y ejec&amp;uacute;telo varias veces, descartando valores at&amp;iacute;picos. Use &lt;code&gt;-Xbatch&lt;/code&gt; para serializar el compilador con la aplicaci&amp;oacute;n, y considere configurar &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; para evitar que el compilador se ejecute en paralelo consigo mismo. Haga todo lo posible para reducir la sobrecarga del GC, establezca &lt;code&gt;Xmx&lt;/code&gt; (lo suficientemente grande) igual a &lt;code&gt;Xms&lt;/code&gt; y use &lt;a href=&quot;http://openjdk.java.net/jeps/318&quot;&gt; &lt;code&gt;UseEpsilonGC&lt;/code&gt; &lt;/a&gt; si est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="4794c7852029678f813d3a6a3ad951731b0589f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 8:&lt;/strong&gt; Use a library for your benchmark as it is probably more efficient and was already debugged for this sole purpose. Such as &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt;, &lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper&lt;/a&gt; or &lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot;&gt;Bill and Paul's Excellent UCSD Benchmarks for Java&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Regla 8:&lt;/strong&gt; Use una biblioteca para su punto de referencia, ya que probablemente sea m&amp;aacute;s eficiente y ya se haya depurado para este &amp;uacute;nico prop&amp;oacute;sito. Como &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt; , &lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper&lt;/a&gt; o &lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot;&gt;Bill y Paul's Excellent UCSD Benchmarks para Java&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b900f6d5071c2310201e024ff990519c9b60003" translate="yes" xml:space="preserve">
          <source>Also, make sure that &lt;em&gt;n&lt;/em&gt; is very large, so that the runtime of each loop is at the very least 10 seconds or so.  The more iterations, the more significant figures in your benchmark time and the more reliable that data is.</source>
          <target state="translated">Adem&amp;aacute;s, aseg&amp;uacute;rese de que &lt;em&gt;n&lt;/em&gt; sea ​​muy grande, de modo que el tiempo de ejecuci&amp;oacute;n de cada ciclo sea de al menos 10 segundos m&amp;aacute;s o menos. Cuantas m&amp;aacute;s iteraciones, m&amp;aacute;s cifras significativas en su tiempo de referencia y m&amp;aacute;s confiables son los datos.</target>
        </trans-unit>
        <trans-unit id="291a53f8afab7a8ada4aa04f96b773eb9331ee82" translate="yes" xml:space="preserve">
          <source>Avoiding Benchmarking Pitfalls on the JVM</source>
          <target state="translated">Evitar las trampas de la evaluación comparativa en la MVC</target>
        </trans-unit>
        <trans-unit id="9fdb89d13608249537686498201d2b8013f81d5b" translate="yes" xml:space="preserve">
          <source>Example: Should the benchmark measure time/iteration or iterations/time, and why?</source>
          <target state="translated">Ejemplo:¿Debería el punto de referencia medir la timeiteración o el tiempo de iteración,y por qué?</target>
        </trans-unit>
        <trans-unit id="7c30a2a120296936d804852069941c3f3b4b3697" translate="yes" xml:space="preserve">
          <source>First: You have to calculate with all sorts of events that take time more or less random: Garbage collection, caching effects (of OS for files and of CPU for memory), IO etc.</source>
          <target state="translated">Primero:Tienes que calcular con todo tipo de eventos que toman tiempo más o menos al azar:Recolección de basura,efectos de cacheo (de OS para los archivos y de CPU para la memoria),IO etc.</target>
        </trans-unit>
        <trans-unit id="5fd020f2e8c9e9c9f5c7fabb9d269a776ca80082" translate="yes" xml:space="preserve">
          <source>For some CPUs (e.g. Intel Core i5 range with TurboBoost), the temperature (and number of cores currently being used, as well as thier utilisation percent) affects the clock speed. Since CPUs are dynamically clocked, this can affect your results. For example, if you have a single-threaded application, the maximum clock speed (with TurboBoost) is higher than for an application using all cores. This can therefore interfere with comparisons of single and multi-threaded performance on some systems. Bear in mind that the temperature and volatages also affect how long Turbo frequency is maintained.</source>
          <target state="translated">Para algunas CPU (por ejemplo,la gama Intel Core i5 con TurboBoost),la temperatura (y el número de núcleos que se utilizan actualmente,así como su porcentaje de utilización)afecta a la velocidad del reloj.Dado que las CPU tienen un reloj dinámico,esto puede afectar a los resultados.Por ejemplo,si tiene una aplicación de un solo hilo,la velocidad máxima del reloj (con TurboBoost)es mayor que para una aplicación que utiliza todos los núcleos.Por lo tanto,esto puede interferir con las comparaciones de rendimiento de un solo hilo y de varios hilos en algunos sistemas.Tenga en cuenta que la temperatura y los voltajes también afectan al tiempo que se mantiene la frecuencia del Turbo.</target>
        </trans-unit>
        <trans-unit id="7b60187da88886bca2657e4a6777410827026413" translate="yes" xml:space="preserve">
          <source>How do I write a correct micro-benchmark in Java</source>
          <target state="translated">¿Cómo puedo escribir una micro marca correcta en Java</target>
        </trans-unit>
        <trans-unit id="1cbff6d9740743fbbd7f9c95fa887c6effb7d086" translate="yes" xml:space="preserve">
          <source>How do you write (and run) a correct micro-benchmark in Java?</source>
          <target state="translated">¿Cómo se escribe (y se ejecuta)una micro marca correcta en Java?</target>
        </trans-unit>
        <trans-unit id="345f77da8a43bfb9f331059c7ac811f4abfb5447" translate="yes" xml:space="preserve">
          <source>I have found some noticeable differences (5-10% sometimes) in the runtime of the same algorithm in different passes..</source>
          <target state="translated">He encontrado algunas diferencias notables (5-10% a veces)en el tiempo de ejecución del mismo algoritmo en diferentes pasadas..</target>
        </trans-unit>
        <trans-unit id="9288dce15b94ef8dabd0c6bdca3af22ce5ad08c1" translate="yes" xml:space="preserve">
          <source>I know this question has been marked as answered but I wanted to mention two libraries that help us to write micro benchmarks</source>
          <target state="translated">Sé que esta pregunta ha sido marcada como respondida pero quería mencionar dos bibliotecas que nos ayudan a escribir micro puntos de referencia</target>
        </trans-unit>
        <trans-unit id="b49185e438b5ff2e0365effaefd146926922e274" translate="yes" xml:space="preserve">
          <source>I like to display iterations and time, and a score of time/iteration which can be scaled such that the &quot;best&quot; algorithm gets a score of 1.0 and others are scored in a relative fashion. This means you can run &lt;em&gt;all&lt;/em&gt; algorithms for a longish time, varying both number of iterations and time, but still getting comparable results.</source>
          <target state="translated">Me gusta mostrar las iteraciones y el tiempo, y una puntuaci&amp;oacute;n de tiempo / iteraci&amp;oacute;n que se puede escalar de modo que el &quot;mejor&quot; algoritmo obtenga una puntuaci&amp;oacute;n de 1.0 y otros se califiquen de manera relativa. Esto significa que puede ejecutar &lt;em&gt;todos los&lt;/em&gt; algoritmos durante un tiempo prolongado, variando tanto el n&amp;uacute;mero de iteraciones como el tiempo, pero a&amp;uacute;n obteniendo resultados comparables.</target>
        </trans-unit>
        <trans-unit id="073918582af97d175c9583f4544e6c59d66b8800" translate="yes" xml:space="preserve">
          <source>I'm just in the process of blogging about the design of a benchmarking framework in .NET. I've got a &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/26/benchmarking-made-easy.aspx&quot;&gt;couple&lt;/a&gt; of &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot;&gt;earlier posts&lt;/a&gt; which may be able to give you some ideas - not everything will be appropriate, of course, but some of it may be.</source>
          <target state="translated">Estoy en el proceso de bloguear sobre el dise&amp;ntilde;o de un marco de referencia en .NET. Tengo un &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/26/benchmarking-made-easy.aspx&quot;&gt;par&lt;/a&gt; de &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot;&gt;publicaciones anteriores&lt;/a&gt; que pueden darte algunas ideas; no todo ser&amp;aacute; apropiado, por supuesto, pero algunas pueden serlo.</target>
        </trans-unit>
        <trans-unit id="51e309adae3a577233db4148a52db0b5e82ad882" translate="yes" xml:space="preserve">
          <source>I'm looking for some code samples and comments illustrating various things to think about.</source>
          <target state="translated">Estoy buscando algunas muestras de código y comentarios que ilustren varias cosas en las que pensar.</target>
        </trans-unit>
        <trans-unit id="36261b5d7d09dc19c64cb2ee96d2ae81bfed859d" translate="yes" xml:space="preserve">
          <source>If you are interested in &lt;strong&gt;latency&lt;/strong&gt;, use time/iteration and if you are interested in &lt;strong&gt;throughput&lt;/strong&gt;, use iterations/time.</source>
          <target state="translated">Si est&amp;aacute; interesado en la &lt;strong&gt;latencia&lt;/strong&gt; , use tiempo / iteraci&amp;oacute;n y si est&amp;aacute; interesado en el &lt;strong&gt;rendimiento&lt;/strong&gt; , use iteraciones / tiempo.</target>
        </trans-unit>
        <trans-unit id="57fe3c1aa7a71ecc2622b2368266380f1ba646de" translate="yes" xml:space="preserve">
          <source>If you are trying to compare two algorithms, do at least two benchmarks for each, alternating the order.  i.e.:</source>
          <target state="translated">Si está tratando de comparar dos algoritmos,haga al menos dos puntos de referencia para cada uno,alternando el orden,es decir:</target>
        </trans-unit>
        <trans-unit id="446509b69736161c6a7f8538df894b0283704899" translate="yes" xml:space="preserve">
          <source>Important things for Java benchmarks are:</source>
          <target state="translated">Las cosas importantes para los puntos de referencia de Java son:</target>
        </trans-unit>
        <trans-unit id="8a984f01db14194be668e260faf7f1dd1670ba36" translate="yes" xml:space="preserve">
          <source>It depends on &lt;strong&gt;what&lt;/strong&gt; you are trying to test.</source>
          <target state="translated">Depende de &lt;strong&gt;lo&lt;/strong&gt; que intente probar.</target>
        </trans-unit>
        <trans-unit id="feeb65010e24c48f6e8b09b1aefe0fddee8b6bc9" translate="yes" xml:space="preserve">
          <source>It should also be noted that it might also be important to analyze the results of the micro benchmark when comparing different implementations. Therefore a &lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot;&gt;significance test&lt;/a&gt; should be made.</source>
          <target state="translated">Tambi&amp;eacute;n se debe tener en cuenta que tambi&amp;eacute;n podr&amp;iacute;a ser importante analizar los resultados del micro punto de referencia al comparar diferentes implementaciones. Por lo tanto &lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot;&gt;, se&lt;/a&gt; debe hacer una prueba de significaci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="9a4a5f032bf62a386234c6f707d69863e3492a61" translate="yes" xml:space="preserve">
          <source>Make sure you run it for long enough to be able to measure the results in seconds or (better) tens of seconds</source>
          <target state="translated">Asegúrate de que lo haces durante el tiempo suficiente para poder medir los resultados en segundos o (mejor)en decenas de segundos.</target>
        </trans-unit>
        <trans-unit id="4f40942c1d46b6591496e7b2b047342ec5e9778d" translate="yes" xml:space="preserve">
          <source>Make sure you somehow use results which are computed in benchmarked code. Otherwise your code can be optimized away.</source>
          <target state="translated">Asegúrate de usar de alguna manera los resultados que se calculan en el código de referencia.De lo contrario,tu código puede ser optimizado.</target>
        </trans-unit>
        <trans-unit id="66b7124924abc42f465159758abb309a487e6f45" translate="yes" xml:space="preserve">
          <source>My recommendations: Make your benchmark run some seconds, that is more reliable than a runtime over milliseconds. Warm up the JVM (means running the benchmark at least once without measuring, that the JVM can run optimizations). And run your benchmark multiple times (maybe 5 times) and take the median-value. Run every micro-benchmark in a new JVM-instance (call for every benchmark new Java) otherwise optimization effects of the JVM can influence later running tests. Don't execute things, that aren't executed in the warmup-phase (as this could trigger class-load and recompilation).</source>
          <target state="translated">Mis recomendaciones:Haga que su referencia funcione algunos segundos,que es más fiable que un tiempo de ejecución de más de milisegundos.Calentar la JVM (significa ejecutar el benchmark al menos una vez sin medir,que la JVM puede ejecutar optimizaciones).Y ejecuta tu punto de referencia varias veces (tal vez 5 veces)y toma el valor medio.Ejecutar cada micro-marca en una nueva JVM-instancia (llamar a cada marca nueva Java)de lo contrario los efectos de la optimización de la JVM pueden influir en la posterior ejecución de las pruebas.No ejecute cosas que no se ejecuten en la fase de calentamiento (ya que esto podría desencadenar la carga de clase y la recompilación).</target>
        </trans-unit>
        <trans-unit id="84b3a6d3b735a279b8a95eec81ccdd77ef213d67" translate="yes" xml:space="preserve">
          <source>Perhaps a more fundamentally important aspect that you have direct control over: make sure you're measuring the right thing! For example, if you're using &lt;code&gt;System.nanoTime()&lt;/code&gt; to benchmark a particular bit of code, put the calls to the assignment in places that make sense to avoid measuring things which you aren't interested in. For example, don't do:</source>
          <target state="translated">Quiz&amp;aacute;s un aspecto m&amp;aacute;s fundamentalmente importante sobre el que tiene control directo: &amp;iexcl;aseg&amp;uacute;rese de medir lo correcto! Por ejemplo, si est&amp;aacute; usando &lt;code&gt;System.nanoTime()&lt;/code&gt; para comparar un bit de c&amp;oacute;digo en particular, coloque las llamadas a la asignaci&amp;oacute;n en lugares que tengan sentido para evitar medir cosas que no le interesan. Por ejemplo, no hacer:</target>
        </trans-unit>
        <trans-unit id="24e94fd01de88afc005218fb420a74bbf3940440" translate="yes" xml:space="preserve">
          <source>Problem is you're not immediately getting the end time when the code has finished. Instead, try the following:</source>
          <target state="translated">El problema es que no se obtiene inmediatamente el tiempo de finalización cuando el código ha terminado.En su lugar,intenta lo siguiente:</target>
        </trans-unit>
        <trans-unit id="083b98d32d7fe2f0ca96bec067bd4906c6064c09" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://stackoverflow.com/questions/410437/is-stopwatch-benchmarking-acceptable&quot;&gt;Is stopwatch benchmarking acceptable?&lt;/a&gt;</source>
          <target state="translated">Relacionado: &lt;a href=&quot;https://stackoverflow.com/questions/410437/is-stopwatch-benchmarking-acceptable&quot;&gt;&amp;iquest;Es aceptable el benchmarking de cron&amp;oacute;metro?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec4ff7b50a4635d42059faa78909f7f5f9d7a2eb" translate="yes" xml:space="preserve">
          <source>Second: You cannot trust the accuracy of the measured times for very short intervals.</source>
          <target state="translated">Segundo:No se puede confiar en la exactitud de los tiempos medidos en intervalos muy cortos.</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">Ver también:</target>
        </trans-unit>
        <trans-unit id="fec816031df94b29566d620805f308d6cf737166" translate="yes" xml:space="preserve">
          <source>Should the benchmark measure time/iteration or iterations/time, and why?</source>
          <target state="translated">¿Debería el punto de referencia medir la timeiteración o el tiempo de iteración,y por qué?</target>
        </trans-unit>
        <trans-unit id="c090559196e8e996c17e7d433bc64f8b76c7baad" translate="yes" xml:space="preserve">
          <source>So it is also important to write and run a micro benchmark correctly, but also to analyze it correctly.</source>
          <target state="translated">Por lo tanto,también es importante escribir y ejecutar correctamente un micro punto de referencia,pero también analizarlo correctamente.</target>
        </trans-unit>
        <trans-unit id="ca5ea60128b328a761b56bf9b62dbcaf8e859acb" translate="yes" xml:space="preserve">
          <source>The jmh is a Java harness for building, running, and analysing nano/micro/macro benchmarks written in Java and other languages targetting the JVM.</source>
          <target state="translated">El jmh es un arnés de Java para construir,ejecutar y analizar benchmarks de nanomicromacro escritos en Java y otros lenguajes dirigidos a la JVM.</target>
        </trans-unit>
        <trans-unit id="8b8343ec5e38906eb0a29c2be2182da0957c52aa" translate="yes" xml:space="preserve">
          <source>There are many possible pitfalls for writing micro-benchmarks in Java.</source>
          <target state="translated">Hay muchas posibles trampas para escribir micro-bancos en Java.</target>
        </trans-unit>
        <trans-unit id="1beb582fcae9e9c673cb7f6f4df5cf4c23a15792" translate="yes" xml:space="preserve">
          <source>Third: The JVM optimizes your code while executing. So different runs in the same JVM-instance will become faster and faster.</source>
          <target state="translated">Tercero:La JVM optimiza su código mientras se ejecuta.Así que diferentes ejecuciones en la misma JVM,se volverán cada vez más rápidas.</target>
        </trans-unit>
        <trans-unit id="0f9f7a1cf8a428a9d13c0c15079ccb8e8a7c3323" translate="yes" xml:space="preserve">
          <source>This is because implementation &lt;code&gt;A&lt;/code&gt; might be faster during most of the runs of the benchmark than implementation &lt;code&gt;B&lt;/code&gt;. But &lt;code&gt;A&lt;/code&gt; might also have a higher spread, so the measured performance benefit of &lt;code&gt;A&lt;/code&gt; won't be of any significance when compared with &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">Esto se debe a que la implementaci&amp;oacute;n &lt;code&gt;A&lt;/code&gt; podr&amp;iacute;a ser m&amp;aacute;s r&amp;aacute;pida durante la mayor&amp;iacute;a de las ejecuciones del benchmark que la implementaci&amp;oacute;n &lt;code&gt;B&lt;/code&gt; . Pero &lt;code&gt;A&lt;/code&gt; tambi&amp;eacute;n podr&amp;iacute;a tener una mayor difusi&amp;oacute;n, por lo que el beneficio de rendimiento medido de &lt;code&gt;A&lt;/code&gt; no ser&amp;aacute; de ninguna importancia en comparaci&amp;oacute;n con &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15e6b0c5d76c16417c6007b1618f6b7c6ff8d43d" translate="yes" xml:space="preserve">
          <source>Tips about writing micro benchmarks &lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot;&gt;from the creators of Java HotSpot&lt;/a&gt;:</source>
          <target state="translated">Consejos sobre c&amp;oacute;mo escribir micro benchmarks &lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot;&gt;de los creadores de Java HotSpot&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2175398196c5bd9dc22098e16383b9977459087d" translate="yes" xml:space="preserve">
          <source>To add to the other excellent advice, I'd also be mindful of the following:</source>
          <target state="translated">Para añadir al otro excelente consejo,también tendría en cuenta lo siguiente:</target>
        </trans-unit>
        <trans-unit id="23055b4d37f59f17de37b2f34febaa4ebff5215d" translate="yes" xml:space="preserve">
          <source>Very interesting pieces of information buried in &lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot;&gt;the sample tests comments&lt;/a&gt;.</source>
          <target state="translated">Datos muy interesantes enterrados en &lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot;&gt;los comentarios de las pruebas de muestra&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ada6fca5c78392f28aae4ac87bca62c28900053" translate="yes" xml:space="preserve">
          <source>Warm up the JIT first by running the code several times &lt;strong&gt;before timing&lt;/strong&gt; it</source>
          <target state="translated">Primero calienta el JIT ejecutando el c&amp;oacute;digo varias veces &lt;strong&gt;antes de cronometrarlo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="266c504aa997c2e2ca6e724568658a941f940414" translate="yes" xml:space="preserve">
          <source>While you can't call &lt;code&gt;System.gc()&lt;/code&gt; between iterations, it's a good idea to run it between tests, so that each test will hopefully get a &quot;clean&quot; memory space to work with. (Yes, &lt;code&gt;gc()&lt;/code&gt; is more of a hint than a guarantee, but it's very &lt;em&gt;likely&lt;/em&gt; that it really will garbage collect in my experience.)</source>
          <target state="translated">Si bien no puede llamar a &lt;code&gt;System.gc()&lt;/code&gt; entre iteraciones, es una buena idea ejecutarlo entre pruebas, para que cada prueba obtenga un espacio de memoria &quot;limpio&quot; para trabajar. (S&amp;iacute;, &lt;code&gt;gc()&lt;/code&gt; es m&amp;aacute;s una pista que una garant&amp;iacute;a, pero es muy &lt;em&gt;probable&lt;/em&gt; que realmente acumule basura en mi experiencia).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
