<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/504103">
    <body>
      <group id="504103">
        <trans-unit id="7c98885362dfac889a9855e3cada87c420301ccb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;jmh&lt;/a&gt; is a recent addition to OpenJDK and has been written by some performance engineers from Oracle. Certainly worth a look.</source>
          <target state="translated">&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;jmh&lt;/a&gt;是OpenJDK的最新成员，由Oracle的一些性能工程师编写。 当然值得一看。</target>
        </trans-unit>
        <trans-unit id="e83d76042e828ed3c8e11fb07151725fca9240b5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://opt.sourceforge.net/&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark - control tasks required to determine the comparative performance characteristics of the computer system on different platforms. Can be used to guide optimization decisions and to compare different Java implementations.</source>
          <target state="translated">&lt;a href=&quot;http://opt.sourceforge.net/&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark-控制任务，以确定不同平台上计算机系统的比较性能特征。 可用于指导优化决策并比较不同的Java实现。</target>
        </trans-unit>
        <trans-unit id="002ff0009ac698d62577e1dacfbbd66bec9fce5f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot;&gt;Discussion on the main strengths of jmh&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot;&gt;讨论jmh的主要优点&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3262a13a878ada9ad80da38be74e4e326a4dbc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Getting started tutorials&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;入门教程&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58b8f129eaa1ef1df1f79c088dc155d676bab11c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH from OpenJDK&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;来自OpenJDK的JMH&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1cab88a8d7c77af82261e5a17335a55be0286ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper from Google&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Google的游标卡尺&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e08658c12ec073195992e373f7f39e2930d359c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 0:&lt;/strong&gt; Read a reputable paper on JVMs and micro-benchmarking. A good one is &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot;&gt;Brian Goetz, 2005&lt;/a&gt;. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics.</source>
          <target state="translated">&lt;strong&gt;规则0：&lt;/strong&gt;阅读有关JVM和微基准测试的著名论文。 好的人是&lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot;&gt;布莱恩&amp;middot;格茨&lt;/a&gt; （ Brian Goetz），2005年 。 不要对微观基准期望太高； 它们仅测量有限范围的JVM性能特征。</target>
        </trans-unit>
        <trans-unit id="d45fa44e30fc3e7cad85ca1896b5fffd407b89b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 1:&lt;/strong&gt; Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timing phase(s). (Fewer iterations is OK on the warmup phase. The rule of thumb is several tens of thousands of inner loop iterations.)</source>
          <target state="translated">&lt;strong&gt;规则1：&lt;/strong&gt;始终包括一个预热阶段，该阶段一直运行您的测试内核，足以在计时阶段之前触发所有初始化和编译。 （在预热阶段可以进行较少的迭代。经验法则是数以万计的内循环迭代。）</target>
        </trans-unit>
        <trans-unit id="8c3aa86e67b88f2049f3994203039a7ec263cde1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 2.1:&lt;/strong&gt; Print messages at the beginning and end of timing and warmup phases, so you can verify that there is no output from Rule 2 during the timing phase.</source>
          <target state="translated">&lt;strong&gt;规则2.1：&lt;/strong&gt;在计时和预热阶段的开始和结束时打印消息，因此您可以验证在计时阶段没有规则2的输出。</target>
        </trans-unit>
        <trans-unit id="f2003e400027cc14055ad96eecc77dd4cc897cde" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 2:&lt;/strong&gt; Always run with &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt;, &lt;code&gt;-verbose:gc&lt;/code&gt;, etc., so you can verify that the compiler and other parts of the JVM are not doing unexpected work during your timing phase.</source>
          <target state="translated">&lt;strong&gt;规则2：&lt;/strong&gt;始终与 &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; ， &lt;code&gt;-verbose:gc&lt;/code&gt; 等一起运行，因此您可以验证在计时阶段，编译器和JVM的其他部分没有进行意外的工作。</target>
        </trans-unit>
        <trans-unit id="82a300d3f7024d24e03d349acfe0ce39d6315045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 3:&lt;/strong&gt; Be aware of the difference between &lt;code&gt;-client&lt;/code&gt; and &lt;code&gt;-server&lt;/code&gt;, and OSR and regular compilations. The &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; flag reports OSR compilations with an at-sign to denote the non-initial entry point, for example: &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt;. Prefer server to client, and regular to OSR, if you are after best performance.</source>
          <target state="translated">&lt;strong&gt;规则3：&lt;/strong&gt;请注意 &lt;code&gt;-client&lt;/code&gt; 和 &lt;code&gt;-server&lt;/code&gt; 以及OSR和常规编译之间的区别。 &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; 标志报告OSR编译，并带有一个at符号表示非初始入口点，例如： &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt; 。 如果您追求最佳性能，则优先选择服务器而不是客户端，并经常选择OSR。</target>
        </trans-unit>
        <trans-unit id="9fe68b85cd38859a59a3c019f4abe56850c6f896" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 4:&lt;/strong&gt; Be aware of initialization effects. Do not print for the first time during your timing phase, since printing loads and initializes classes. Do not load new classes outside of the warmup phase (or final reporting phase), unless you are testing class loading specifically (and in that case load only the test classes). Rule 2 is your first line of defense against such effects.</source>
          <target state="translated">&lt;strong&gt;规则4：&lt;/strong&gt;注意初始化效果。 在计时阶段不要第一次打印，因为打印会加载并初始化类。 不要在预热阶段（或最终报告阶段）之外加载新的类，除非您正在专门测试类的加载（在这种情况下，仅加载测试类）。 规则2是抵御此类影响的第一道防线。</target>
        </trans-unit>
        <trans-unit id="96adbb1b64b53f6a4f822f7be16037426b9faf61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 5:&lt;/strong&gt; Be aware of deoptimization and recompilation effects. Do not take any code path for the first time in the timing phase, because the compiler may junk and recompile the code, based on an earlier optimistic assumption that the path was not going to be used at all. Rule 2 is your first line of defense against such effects.</source>
          <target state="translated">&lt;strong&gt;规则5：&lt;/strong&gt;注意优化和重新编译的影响。 在时序阶段不要第一次使用任何代码路径，因为基于较早的乐观假设（即根本不会使用该路径），编译器可能会垃圾并重新编译代码。 规则2是抵御此类影响的第一道防线。</target>
        </trans-unit>
        <trans-unit id="7fb62c7b72ed7085cdadc9ffda9ceefbbb9ad946" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 6:&lt;/strong&gt; Use appropriate tools to read the compiler's mind, and expect to be surprised by the code it produces. Inspect the code yourself before forming theories about what makes something faster or slower.</source>
          <target state="translated">&lt;strong&gt;规则6：&lt;/strong&gt;使用适当的工具来阅读编译器的思想，并期望对其生成的代码感到惊讶。 在形成有关使某事物变快或变慢的理论之前，请自己检查代码。</target>
        </trans-unit>
        <trans-unit id="5c5dde812c075176c9041fa138d2a9a90fce4363" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 7:&lt;/strong&gt; Reduce noise in your measurements. Run your benchmark on a quiet machine, and run it several times, discarding outliers. Use &lt;code&gt;-Xbatch&lt;/code&gt; to serialize the compiler with the application, and consider setting &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; to prevent the compiler from running in parallel with itself. Try your best to reduce GC overhead, set &lt;code&gt;Xmx&lt;/code&gt;(large enough) equals &lt;code&gt;Xms&lt;/code&gt; and use &lt;a href=&quot;http://openjdk.java.net/jeps/318&quot;&gt;&lt;code&gt;UseEpsilonGC&lt;/code&gt;&lt;/a&gt; if it is available.</source>
          <target state="translated">&lt;strong&gt;规则7：&lt;/strong&gt;减少测量中的噪音。 在安静的计算机上运行基准测试，然后运行几次，丢弃异常值。 使用 &lt;code&gt;-Xbatch&lt;/code&gt; 可以将编译器与应用程序序列化，并考虑设置 &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; 可以防止编译器与其自身并行运行。 尽最大努力减少GC开销，将 &lt;code&gt;Xmx&lt;/code&gt; （足够大）设置为 &lt;code&gt;Xms&lt;/code&gt; ,并使用&lt;a href=&quot;http://openjdk.java.net/jeps/318&quot;&gt; &lt;code&gt;UseEpsilonGC&lt;/code&gt; (&lt;/a&gt;如果可用）。</target>
        </trans-unit>
        <trans-unit id="4794c7852029678f813d3a6a3ad951731b0589f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 8:&lt;/strong&gt; Use a library for your benchmark as it is probably more efficient and was already debugged for this sole purpose. Such as &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt;, &lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper&lt;/a&gt; or &lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot;&gt;Bill and Paul's Excellent UCSD Benchmarks for Java&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;规则8：&lt;/strong&gt;将库用于您的基准测试，因为它可能更有效，并且已经针对该目的进行了调试。 例如&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt; ， &lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper&lt;/a&gt;或&lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot;&gt;Bill和Paul的Java优秀UCSD基准&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b900f6d5071c2310201e024ff990519c9b60003" translate="yes" xml:space="preserve">
          <source>Also, make sure that &lt;em&gt;n&lt;/em&gt; is very large, so that the runtime of each loop is at the very least 10 seconds or so.  The more iterations, the more significant figures in your benchmark time and the more reliable that data is.</source>
          <target state="translated">另外，请确保&lt;em&gt;n&lt;/em&gt;非常大，以便每个循环的运行时间至少在10秒左右。 迭代次数越多，基准时间中的数字就越大，数据就越可靠。</target>
        </trans-unit>
        <trans-unit id="291a53f8afab7a8ada4aa04f96b773eb9331ee82" translate="yes" xml:space="preserve">
          <source>Avoiding Benchmarking Pitfalls on the JVM</source>
          <target state="translated">避免JVM上的基准测试陷阱</target>
        </trans-unit>
        <trans-unit id="9fdb89d13608249537686498201d2b8013f81d5b" translate="yes" xml:space="preserve">
          <source>Example: Should the benchmark measure time/iteration or iterations/time, and why?</source>
          <target state="translated">例子。基准应该衡量时间迭代还是迭代时间,为什么?</target>
        </trans-unit>
        <trans-unit id="7c30a2a120296936d804852069941c3f3b4b3697" translate="yes" xml:space="preserve">
          <source>First: You have to calculate with all sorts of events that take time more or less random: Garbage collection, caching effects (of OS for files and of CPU for memory), IO etc.</source>
          <target state="translated">首先:你必须用各种各样的事件来计算,这些事件或多或少都是随机的。垃圾收集、缓存效应(操作系统对文件和CPU对内存的缓存效应)、IO等。</target>
        </trans-unit>
        <trans-unit id="5fd020f2e8c9e9c9f5c7fabb9d269a776ca80082" translate="yes" xml:space="preserve">
          <source>For some CPUs (e.g. Intel Core i5 range with TurboBoost), the temperature (and number of cores currently being used, as well as thier utilisation percent) affects the clock speed. Since CPUs are dynamically clocked, this can affect your results. For example, if you have a single-threaded application, the maximum clock speed (with TurboBoost) is higher than for an application using all cores. This can therefore interfere with comparisons of single and multi-threaded performance on some systems. Bear in mind that the temperature and volatages also affect how long Turbo frequency is maintained.</source>
          <target state="translated">对于某些CPU(例如Intel Core i5系列的TurboBoost处理器),温度(和当前使用的核心数量,以及其利用率)会影响时钟速度。由于CPU是动态时钟,这可能会影响到你的结果。例如,如果你有一个单线程的应用程序,最大的时钟速度(使用TurboBoost)会比使用所有内核的应用程序高。因此,这可能会干扰某些系统上的单线程和多线程性能的比较。请记住,温度和电压也会影响到Turbo频率的维持时间。</target>
        </trans-unit>
        <trans-unit id="7b60187da88886bca2657e4a6777410827026413" translate="yes" xml:space="preserve">
          <source>How do I write a correct micro-benchmark in Java</source>
          <target state="translated">如何在Java中写出一个正确的微标?</target>
        </trans-unit>
        <trans-unit id="1cbff6d9740743fbbd7f9c95fa887c6effb7d086" translate="yes" xml:space="preserve">
          <source>How do you write (and run) a correct micro-benchmark in Java?</source>
          <target state="translated">如何在Java中编写(和运行)一个正确的微信标示?</target>
        </trans-unit>
        <trans-unit id="345f77da8a43bfb9f331059c7ac811f4abfb5447" translate="yes" xml:space="preserve">
          <source>I have found some noticeable differences (5-10% sometimes) in the runtime of the same algorithm in different passes..</source>
          <target state="translated">我发现同一算法在不同的通行证中的运行时间有一些明显的差异(有时会有5%-10%)。</target>
        </trans-unit>
        <trans-unit id="9288dce15b94ef8dabd0c6bdca3af22ce5ad08c1" translate="yes" xml:space="preserve">
          <source>I know this question has been marked as answered but I wanted to mention two libraries that help us to write micro benchmarks</source>
          <target state="translated">我知道这个问题已经被标记为回答了,但我想提两个库,帮助我们编写微观基准的库</target>
        </trans-unit>
        <trans-unit id="b49185e438b5ff2e0365effaefd146926922e274" translate="yes" xml:space="preserve">
          <source>I like to display iterations and time, and a score of time/iteration which can be scaled such that the &quot;best&quot; algorithm gets a score of 1.0 and others are scored in a relative fashion. This means you can run &lt;em&gt;all&lt;/em&gt; algorithms for a longish time, varying both number of iterations and time, but still getting comparable results.</source>
          <target state="translated">我喜欢显示迭代次数和时间，以及可以缩放的时间/迭代分数，以使&amp;ldquo;最佳&amp;rdquo;算法的得分为1.0，而其他算法则以相对方式得分。 这意味着您可以长时间运行&lt;em&gt;所有&lt;/em&gt;算法，同时改变迭代次数和时间，但仍可获得可比的结果。</target>
        </trans-unit>
        <trans-unit id="073918582af97d175c9583f4544e6c59d66b8800" translate="yes" xml:space="preserve">
          <source>I'm just in the process of blogging about the design of a benchmarking framework in .NET. I've got a &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/26/benchmarking-made-easy.aspx&quot;&gt;couple&lt;/a&gt; of &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot;&gt;earlier posts&lt;/a&gt; which may be able to give you some ideas - not everything will be appropriate, of course, but some of it may be.</source>
          <target state="translated">我只是在撰写有关.NET中基准测试框架设计的博客。 我之前有&lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot;&gt;几篇文章&lt;/a&gt;可能会给您一些想法-当然，并非所有内容都合适，但其中某些内容可能是合适的。</target>
        </trans-unit>
        <trans-unit id="51e309adae3a577233db4148a52db0b5e82ad882" translate="yes" xml:space="preserve">
          <source>I'm looking for some code samples and comments illustrating various things to think about.</source>
          <target state="translated">我想找一些代码样本和说明各种事情的评论,请大家思考一下。</target>
        </trans-unit>
        <trans-unit id="36261b5d7d09dc19c64cb2ee96d2ae81bfed859d" translate="yes" xml:space="preserve">
          <source>If you are interested in &lt;strong&gt;latency&lt;/strong&gt;, use time/iteration and if you are interested in &lt;strong&gt;throughput&lt;/strong&gt;, use iterations/time.</source>
          <target state="translated">如果您对&lt;strong&gt;延迟&lt;/strong&gt;感兴趣，请使用时间/迭代，如果您对&lt;strong&gt;吞吐量&lt;/strong&gt;感兴趣，请使用迭代/时间。</target>
        </trans-unit>
        <trans-unit id="57fe3c1aa7a71ecc2622b2368266380f1ba646de" translate="yes" xml:space="preserve">
          <source>If you are trying to compare two algorithms, do at least two benchmarks for each, alternating the order.  i.e.:</source>
          <target state="translated">如果你想比较两种算法,请至少为每种算法做两个基准,交替进行排序。</target>
        </trans-unit>
        <trans-unit id="446509b69736161c6a7f8538df894b0283704899" translate="yes" xml:space="preserve">
          <source>Important things for Java benchmarks are:</source>
          <target state="translated">Java基准的重要事情是。</target>
        </trans-unit>
        <trans-unit id="8a984f01db14194be668e260faf7f1dd1670ba36" translate="yes" xml:space="preserve">
          <source>It depends on &lt;strong&gt;what&lt;/strong&gt; you are trying to test.</source>
          <target state="translated">这取决于您要测试的内容。</target>
        </trans-unit>
        <trans-unit id="feeb65010e24c48f6e8b09b1aefe0fddee8b6bc9" translate="yes" xml:space="preserve">
          <source>It should also be noted that it might also be important to analyze the results of the micro benchmark when comparing different implementations. Therefore a &lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot;&gt;significance test&lt;/a&gt; should be made.</source>
          <target state="translated">还应注意，比较不同的实现时，分析微型基准测试的结果也可能很重要。 因此，应该进行&lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot;&gt;显着性检验&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a4a5f032bf62a386234c6f707d69863e3492a61" translate="yes" xml:space="preserve">
          <source>Make sure you run it for long enough to be able to measure the results in seconds or (better) tens of seconds</source>
          <target state="translated">确保你运行的时间足够长,能够以秒或(更好的)几十秒为单位测量结果。</target>
        </trans-unit>
        <trans-unit id="4f40942c1d46b6591496e7b2b047342ec5e9778d" translate="yes" xml:space="preserve">
          <source>Make sure you somehow use results which are computed in benchmarked code. Otherwise your code can be optimized away.</source>
          <target state="translated">确保你以某种方式使用在基准代码中计算的结果。否则你的代码会被优化掉。</target>
        </trans-unit>
        <trans-unit id="66b7124924abc42f465159758abb309a487e6f45" translate="yes" xml:space="preserve">
          <source>My recommendations: Make your benchmark run some seconds, that is more reliable than a runtime over milliseconds. Warm up the JVM (means running the benchmark at least once without measuring, that the JVM can run optimizations). And run your benchmark multiple times (maybe 5 times) and take the median-value. Run every micro-benchmark in a new JVM-instance (call for every benchmark new Java) otherwise optimization effects of the JVM can influence later running tests. Don't execute things, that aren't executed in the warmup-phase (as this could trigger class-load and recompilation).</source>
          <target state="translated">我的建议。让你的基准运行一些秒,这比运行时间超过毫秒更可靠。预热JVM(意味着在不测量的情况下至少运行一次基准,使JVM能够运行优化)。并运行你的基准多次(也许5次),取中位数值。在一个新的JVM实例中运行每一个微基准(为每一个基准调用新的Java),否则JVM的优化效果会影响后面的测试运行。不要执行那些在预热阶段没有执行的东西(因为这可能会触发类加载和重新编译)。</target>
        </trans-unit>
        <trans-unit id="84b3a6d3b735a279b8a95eec81ccdd77ef213d67" translate="yes" xml:space="preserve">
          <source>Perhaps a more fundamentally important aspect that you have direct control over: make sure you're measuring the right thing! For example, if you're using &lt;code&gt;System.nanoTime()&lt;/code&gt; to benchmark a particular bit of code, put the calls to the assignment in places that make sense to avoid measuring things which you aren't interested in. For example, don't do:</source>
          <target state="translated">您可能直接控制着一个更根本的重要方面：确保您正在衡量正确的事情！ 例如，如果您使用 &lt;code&gt;System.nanoTime()&lt;/code&gt; 对特定代码进行基准测试，请将对调用的调用放置在有意义的位置，以避免测量您不感兴趣的内容。例如，不要做：</target>
        </trans-unit>
        <trans-unit id="24e94fd01de88afc005218fb420a74bbf3940440" translate="yes" xml:space="preserve">
          <source>Problem is you're not immediately getting the end time when the code has finished. Instead, try the following:</source>
          <target state="translated">问题是,当代码完成后,你没有立即得到结束时间。相反,可以试试下面的方法。</target>
        </trans-unit>
        <trans-unit id="083b98d32d7fe2f0ca96bec067bd4906c6064c09" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://stackoverflow.com/questions/410437/is-stopwatch-benchmarking-acceptable&quot;&gt;Is stopwatch benchmarking acceptable?&lt;/a&gt;</source>
          <target state="translated">相关： &lt;a href=&quot;https://stackoverflow.com/questions/410437/is-stopwatch-benchmarking-acceptable&quot;&gt;秒表基准测试是否可以接受？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec4ff7b50a4635d42059faa78909f7f5f9d7a2eb" translate="yes" xml:space="preserve">
          <source>Second: You cannot trust the accuracy of the measured times for very short intervals.</source>
          <target state="translated">第二:在很短的时间间隔内,不能相信测量时间的准确性。</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">也见。</target>
        </trans-unit>
        <trans-unit id="fec816031df94b29566d620805f308d6cf737166" translate="yes" xml:space="preserve">
          <source>Should the benchmark measure time/iteration or iterations/time, and why?</source>
          <target state="translated">基准应该衡量时间迭代还是迭代时间,为什么?</target>
        </trans-unit>
        <trans-unit id="c090559196e8e996c17e7d433bc64f8b76c7baad" translate="yes" xml:space="preserve">
          <source>So it is also important to write and run a micro benchmark correctly, but also to analyze it correctly.</source>
          <target state="translated">所以正确编写和运行一个微观基准也很重要,同时也要正确分析。</target>
        </trans-unit>
        <trans-unit id="ca5ea60128b328a761b56bf9b62dbcaf8e859acb" translate="yes" xml:space="preserve">
          <source>The jmh is a Java harness for building, running, and analysing nano/micro/macro benchmarks written in Java and other languages targetting the JVM.</source>
          <target state="translated">jmh是一个Java线束,用于构建、运行和分析用Java和其他语言编写的纳米微机基准,以JVM为目标。</target>
        </trans-unit>
        <trans-unit id="8b8343ec5e38906eb0a29c2be2182da0957c52aa" translate="yes" xml:space="preserve">
          <source>There are many possible pitfalls for writing micro-benchmarks in Java.</source>
          <target state="translated">在Java中编写微基准可能存在很多隐患。</target>
        </trans-unit>
        <trans-unit id="1beb582fcae9e9c673cb7f6f4df5cf4c23a15792" translate="yes" xml:space="preserve">
          <source>Third: The JVM optimizes your code while executing. So different runs in the same JVM-instance will become faster and faster.</source>
          <target state="translated">第三:JVM在执行时,会对你的代码进行优化。所以同一JVM-instance中不同的运行速度会越来越快。</target>
        </trans-unit>
        <trans-unit id="0f9f7a1cf8a428a9d13c0c15079ccb8e8a7c3323" translate="yes" xml:space="preserve">
          <source>This is because implementation &lt;code&gt;A&lt;/code&gt; might be faster during most of the runs of the benchmark than implementation &lt;code&gt;B&lt;/code&gt;. But &lt;code&gt;A&lt;/code&gt; might also have a higher spread, so the measured performance benefit of &lt;code&gt;A&lt;/code&gt; won't be of any significance when compared with &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">这是因为在基准测试的大多数运行中，实现 &lt;code&gt;A&lt;/code&gt; 可能比实现 &lt;code&gt;B&lt;/code&gt; 更快。 但是 &lt;code&gt;A&lt;/code&gt; 可能还具有更高的价差，因此与 &lt;code&gt;B&lt;/code&gt; 相比， &lt;code&gt;A&lt;/code&gt; 的测得性能收益没有任何意义。</target>
        </trans-unit>
        <trans-unit id="15e6b0c5d76c16417c6007b1618f6b7c6ff8d43d" translate="yes" xml:space="preserve">
          <source>Tips about writing micro benchmarks &lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot;&gt;from the creators of Java HotSpot&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot;&gt;Java HotSpot的创建者&lt;/a&gt;编写微基准测试的提示：</target>
        </trans-unit>
        <trans-unit id="2175398196c5bd9dc22098e16383b9977459087d" translate="yes" xml:space="preserve">
          <source>To add to the other excellent advice, I'd also be mindful of the following:</source>
          <target state="translated">除了其他的优秀建议,我还会注意以下几点。</target>
        </trans-unit>
        <trans-unit id="23055b4d37f59f17de37b2f34febaa4ebff5215d" translate="yes" xml:space="preserve">
          <source>Very interesting pieces of information buried in &lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot;&gt;the sample tests comments&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot;&gt;样本测试注释中&lt;/a&gt;隐藏了非常有趣的信息。</target>
        </trans-unit>
        <trans-unit id="0ada6fca5c78392f28aae4ac87bca62c28900053" translate="yes" xml:space="preserve">
          <source>Warm up the JIT first by running the code several times &lt;strong&gt;before timing&lt;/strong&gt; it</source>
          <target state="translated">首先对JIT进行热身，方法是&lt;strong&gt;在计时之前&lt;/strong&gt;多次运行代码</target>
        </trans-unit>
        <trans-unit id="266c504aa997c2e2ca6e724568658a941f940414" translate="yes" xml:space="preserve">
          <source>While you can't call &lt;code&gt;System.gc()&lt;/code&gt; between iterations, it's a good idea to run it between tests, so that each test will hopefully get a &quot;clean&quot; memory space to work with. (Yes, &lt;code&gt;gc()&lt;/code&gt; is more of a hint than a guarantee, but it's very &lt;em&gt;likely&lt;/em&gt; that it really will garbage collect in my experience.)</source>
          <target state="translated">虽然您无法在迭代之间调用 &lt;code&gt;System.gc()&lt;/code&gt; ，但最好在测试之间运行它，这样每个测试都有望获得一个&amp;ldquo;干净的&amp;rdquo;内存空间来使用。 （是的， &lt;code&gt;gc()&lt;/code&gt; 不仅仅是一个提示，而不是一个保证，但是根据我的经验，它很有&lt;em&gt;可能&lt;/em&gt;真的会进行垃圾回收。）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
