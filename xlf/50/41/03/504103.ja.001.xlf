<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/504103">
    <body>
      <group id="504103">
        <trans-unit id="7c98885362dfac889a9855e3cada87c420301ccb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;jmh&lt;/a&gt; is a recent addition to OpenJDK and has been written by some performance engineers from Oracle. Certainly worth a look.</source>
          <target state="translated">&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;jmh&lt;/a&gt;は最近OpenJDKに追加されたものであり、Oracleの一部のパフォーマンスエンジニアによって記述されています。 確かに一見の価値があります。</target>
        </trans-unit>
        <trans-unit id="e83d76042e828ed3c8e11fb07151725fca9240b5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://opt.sourceforge.net/&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark - control tasks required to determine the comparative performance characteristics of the computer system on different platforms. Can be used to guide optimization decisions and to compare different Java implementations.</source>
          <target state="translated">&lt;a href=&quot;http://opt.sourceforge.net/&quot;&gt;http://opt.sourceforge.net/&lt;/a&gt; Java Micro Benchmark-異なるプラットフォーム上のコンピューターシステムの比較パフォーマンス特性を決定するために必要な制御タスク。 最適化の決定を導き、さまざまなJava実装を比較するために使用できます。</target>
        </trans-unit>
        <trans-unit id="002ff0009ac698d62577e1dacfbbd66bec9fce5f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot;&gt;Discussion on the main strengths of jmh&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://groups.google.com/forum/#!msg/mechanical-sympathy/m4opvy4xq3U/7lY8x8SvHgwJ&quot;&gt;jmhの主な長所に関する議論&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3262a13a878ada9ad80da38be74e4e326a4dbc8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Getting started tutorials&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;入門チュートリアル&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58b8f129eaa1ef1df1f79c088dc155d676bab11c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH from OpenJDK&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;OpenJDKのJMH&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1cab88a8d7c77af82261e5a17335a55be0286ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper from Google&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Googleのキャリパー&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e08658c12ec073195992e373f7f39e2930d359c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 0:&lt;/strong&gt; Read a reputable paper on JVMs and micro-benchmarking. A good one is &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot;&gt;Brian Goetz, 2005&lt;/a&gt;. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics.</source>
          <target state="translated">&lt;strong&gt;ルール0：&lt;/strong&gt; JVMとマイクロベンチマークに関する評判の良い論文を読んでください。 良いものは、 &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225&quot;&gt;ブライアン・ゲッツ、2005年&lt;/a&gt;です。 マイクロベンチマークにあまり期待しないでください。 限られた範囲のJVMパフォーマンス特性のみを測定します。</target>
        </trans-unit>
        <trans-unit id="d45fa44e30fc3e7cad85ca1896b5fffd407b89b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 1:&lt;/strong&gt; Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timing phase(s). (Fewer iterations is OK on the warmup phase. The rule of thumb is several tens of thousands of inner loop iterations.)</source>
          <target state="translated">&lt;strong&gt;ルール1：&lt;/strong&gt;テストカーネルを実行するウォームアップフェーズを常に含めます。これは、タイミングフェーズの前にすべての初期化とコンパイルをトリガーするのに十分です。 （ウォームアップフェーズでは反復回数を減らしても問題ありません。経験則では、数万回の内部ループの反復回数です。）</target>
        </trans-unit>
        <trans-unit id="8c3aa86e67b88f2049f3994203039a7ec263cde1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 2.1:&lt;/strong&gt; Print messages at the beginning and end of timing and warmup phases, so you can verify that there is no output from Rule 2 during the timing phase.</source>
          <target state="translated">&lt;strong&gt;ルール2.1：&lt;/strong&gt;タイミングフェーズとウォームアップフェーズの最初と最後にメッセージを出力するので、タイミングフェーズ中にルール2からの出力がないことを確認できます。</target>
        </trans-unit>
        <trans-unit id="f2003e400027cc14055ad96eecc77dd4cc897cde" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 2:&lt;/strong&gt; Always run with &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt;, &lt;code&gt;-verbose:gc&lt;/code&gt;, etc., so you can verify that the compiler and other parts of the JVM are not doing unexpected work during your timing phase.</source>
          <target state="translated">&lt;strong&gt;ルール2：&lt;/strong&gt;常に &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; 、 &lt;code&gt;-verbose:gc&lt;/code&gt; などを使用して実行します。これにより、コンパイラーおよびJVMの他の部分がタイミングフェーズ中に予期しない作業を行っていないことを確認できます。</target>
        </trans-unit>
        <trans-unit id="82a300d3f7024d24e03d349acfe0ce39d6315045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 3:&lt;/strong&gt; Be aware of the difference between &lt;code&gt;-client&lt;/code&gt; and &lt;code&gt;-server&lt;/code&gt;, and OSR and regular compilations. The &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; flag reports OSR compilations with an at-sign to denote the non-initial entry point, for example: &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt;. Prefer server to client, and regular to OSR, if you are after best performance.</source>
          <target state="translated">&lt;strong&gt;ルール3：&lt;/strong&gt; &lt;code&gt;-client&lt;/code&gt; と &lt;code&gt;-server&lt;/code&gt; 、OSRと通常のコンパイルの違いに注意してください。 &lt;code&gt;-XX:+PrintCompilation&lt;/code&gt; フラグは、先頭以外のエントリポイントを示すアットマーク付きのOSRコンパイルを報告します。例： &lt;code&gt;Trouble$1::run @ 2 (41 bytes)&lt;/code&gt; 。 最高のパフォーマンスを求めている場合は、クライアントよりサーバーを優先し、OSRよりも定期的に実行します。</target>
        </trans-unit>
        <trans-unit id="9fe68b85cd38859a59a3c019f4abe56850c6f896" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 4:&lt;/strong&gt; Be aware of initialization effects. Do not print for the first time during your timing phase, since printing loads and initializes classes. Do not load new classes outside of the warmup phase (or final reporting phase), unless you are testing class loading specifically (and in that case load only the test classes). Rule 2 is your first line of defense against such effects.</source>
          <target state="translated">&lt;strong&gt;ルール4：&lt;/strong&gt;初期化の影響に注意してください。 印刷するとクラスがロードおよび初期化されるため、タイミングフェーズで初めて印刷しないでください。 クラスのロードを具体的にテストする場合（およびその場合はテストクラスのみをロードする場合）を除き、ウォームアップフェーズ（または最終レポートフェーズ）の外で新しいクラスをロードしないでください。 ルール2は、そのような影響に対する防御の最前線です。</target>
        </trans-unit>
        <trans-unit id="96adbb1b64b53f6a4f822f7be16037426b9faf61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 5:&lt;/strong&gt; Be aware of deoptimization and recompilation effects. Do not take any code path for the first time in the timing phase, because the compiler may junk and recompile the code, based on an earlier optimistic assumption that the path was not going to be used at all. Rule 2 is your first line of defense against such effects.</source>
          <target state="translated">&lt;strong&gt;ルール5：&lt;/strong&gt;最適化解除と再コンパイルの影響に注意してください。 タイミングフェーズでコードパスを初めて使用しないでください。これは、パスがまったく使用されないという以前の楽観的な仮定に基づいて、コンパイラがコードをジャンクして再コンパイルする可能性があるためです。 ルール2は、そのような影響に対する防御の最前線です。</target>
        </trans-unit>
        <trans-unit id="7fb62c7b72ed7085cdadc9ffda9ceefbbb9ad946" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 6:&lt;/strong&gt; Use appropriate tools to read the compiler's mind, and expect to be surprised by the code it produces. Inspect the code yourself before forming theories about what makes something faster or slower.</source>
          <target state="translated">&lt;strong&gt;ルール6：&lt;/strong&gt;適切なツールを使用してコンパイラーの心を読み、コンパイラーが生成するコードに驚かされることを期待します。 何かを速くしたり遅くしたりするものについての理論を形成する前に、コードを自分で検査してください。</target>
        </trans-unit>
        <trans-unit id="5c5dde812c075176c9041fa138d2a9a90fce4363" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 7:&lt;/strong&gt; Reduce noise in your measurements. Run your benchmark on a quiet machine, and run it several times, discarding outliers. Use &lt;code&gt;-Xbatch&lt;/code&gt; to serialize the compiler with the application, and consider setting &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; to prevent the compiler from running in parallel with itself. Try your best to reduce GC overhead, set &lt;code&gt;Xmx&lt;/code&gt;(large enough) equals &lt;code&gt;Xms&lt;/code&gt; and use &lt;a href=&quot;http://openjdk.java.net/jeps/318&quot;&gt;&lt;code&gt;UseEpsilonGC&lt;/code&gt;&lt;/a&gt; if it is available.</source>
          <target state="translated">&lt;strong&gt;ルール7：&lt;/strong&gt;測定のノイズを減らします。 ベンチマークを静かなマシンで実行し、数回実行して、外れ値を破棄します。 &lt;code&gt;-Xbatch&lt;/code&gt; を使用してアプリケーションとコンパイラーをシリアル化し、 &lt;code&gt;-XX:CICompilerCount=1&lt;/code&gt; を設定して、コンパイラーがそれ自体と並行して実行されないようにすることを検討してください。 GCのオーバーヘッドを減らすために最善を尽くし、 &lt;code&gt;Xmx&lt;/code&gt; （十分に大きい）を &lt;code&gt;Xms&lt;/code&gt; に設定し 、 &lt;a href=&quot;http://openjdk.java.net/jeps/318&quot;&gt; &lt;code&gt;UseEpsilonGC&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="4794c7852029678f813d3a6a3ad951731b0589f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rule 8:&lt;/strong&gt; Use a library for your benchmark as it is probably more efficient and was already debugged for this sole purpose. Such as &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt;, &lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper&lt;/a&gt; or &lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot;&gt;Bill and Paul's Excellent UCSD Benchmarks for Java&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;ルール8：&lt;/strong&gt;おそらくより効率的で、この唯一の目的のためにデバッグ済みであるため、ベンチマークにはライブラリを使用します。 &lt;a href=&quot;http://openjdk.java.net/projects/code-tools/jmh/&quot;&gt;JMH&lt;/a&gt; 、 &lt;a href=&quot;https://github.com/google/caliper&quot;&gt;Caliper、&lt;/a&gt;または&lt;a href=&quot;http://cseweb.ucsd.edu/users/wgg/JavaProf/javaprof.html&quot;&gt;Bill and PaulのJava用の優れたUCSDベンチマークなど&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b900f6d5071c2310201e024ff990519c9b60003" translate="yes" xml:space="preserve">
          <source>Also, make sure that &lt;em&gt;n&lt;/em&gt; is very large, so that the runtime of each loop is at the very least 10 seconds or so.  The more iterations, the more significant figures in your benchmark time and the more reliable that data is.</source>
          <target state="translated">また、 &lt;em&gt;n&lt;/em&gt;が非常に大きいことを確認して、各ループの実行時間が少なくとも10秒程度になるようにします。 反復回数が多いほど、ベンチマーク時間の数値が大きくなり、データの信頼性が高くなります。</target>
        </trans-unit>
        <trans-unit id="291a53f8afab7a8ada4aa04f96b773eb9331ee82" translate="yes" xml:space="preserve">
          <source>Avoiding Benchmarking Pitfalls on the JVM</source>
          <target state="translated">JVMでのベンチマークの落とし穴の回避</target>
        </trans-unit>
        <trans-unit id="9fdb89d13608249537686498201d2b8013f81d5b" translate="yes" xml:space="preserve">
          <source>Example: Should the benchmark measure time/iteration or iterations/time, and why?</source>
          <target state="translated">例。ベンチマークはtimeiterationとiterationstimeのどちらを測定すべきか、その理由は?</target>
        </trans-unit>
        <trans-unit id="7c30a2a120296936d804852069941c3f3b4b3697" translate="yes" xml:space="preserve">
          <source>First: You have to calculate with all sorts of events that take time more or less random: Garbage collection, caching effects (of OS for files and of CPU for memory), IO etc.</source>
          <target state="translated">最初に:多かれ少なかれランダムに時間がかかるイベントのすべての種類で計算しなければなりません。ガベージコレクション、キャッシュ効果(ファイル用OSとメモリ用CPUの)、IOなど。</target>
        </trans-unit>
        <trans-unit id="5fd020f2e8c9e9c9f5c7fabb9d269a776ca80082" translate="yes" xml:space="preserve">
          <source>For some CPUs (e.g. Intel Core i5 range with TurboBoost), the temperature (and number of cores currently being used, as well as thier utilisation percent) affects the clock speed. Since CPUs are dynamically clocked, this can affect your results. For example, if you have a single-threaded application, the maximum clock speed (with TurboBoost) is higher than for an application using all cores. This can therefore interfere with comparisons of single and multi-threaded performance on some systems. Bear in mind that the temperature and volatages also affect how long Turbo frequency is maintained.</source>
          <target state="translated">いくつかのCPU(Intel Core i5シリーズのTurboBoost搭載など)では、温度(現在使用しているコアの数や使用率)がクロック速度に影響を与えます。CPUは動的にクロックされるので、これは結果に影響を与える可能性があります。例えば、シングルスレッドのアプリケーションを使用している場合、(TurboBoostを使用している場合)最大クロック速度は、すべてのコアを使用しているアプリケーションよりも高くなります。このため、システムによっては、シングルスレッドとマルチスレッドのパフォーマンスの比較に支障をきたすことがあります。温度と電圧は、ターボ周波数の維持時間にも影響することを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="7b60187da88886bca2657e4a6777410827026413" translate="yes" xml:space="preserve">
          <source>How do I write a correct micro-benchmark in Java</source>
          <target state="translated">Javaで正しいマイクロベンチマークを書くには?</target>
        </trans-unit>
        <trans-unit id="1cbff6d9740743fbbd7f9c95fa887c6effb7d086" translate="yes" xml:space="preserve">
          <source>How do you write (and run) a correct micro-benchmark in Java?</source>
          <target state="translated">Javaで正しいマイクロベンチマークを書く(実行する)には?</target>
        </trans-unit>
        <trans-unit id="345f77da8a43bfb9f331059c7ac811f4abfb5447" translate="yes" xml:space="preserve">
          <source>I have found some noticeable differences (5-10% sometimes) in the runtime of the same algorithm in different passes..</source>
          <target state="translated">私は、同じアルゴリズムの実行時間に、異なるパスでいくつかの顕著な違い(5-10%の場合もあります)を見つけました。</target>
        </trans-unit>
        <trans-unit id="9288dce15b94ef8dabd0c6bdca3af22ce5ad08c1" translate="yes" xml:space="preserve">
          <source>I know this question has been marked as answered but I wanted to mention two libraries that help us to write micro benchmarks</source>
          <target state="translated">この質問が回答済みとしてマークされていることは知っていますが、マイクロベンチマークを書くのに役立つ2つのライブラリについて言及したいと思いました。</target>
        </trans-unit>
        <trans-unit id="b49185e438b5ff2e0365effaefd146926922e274" translate="yes" xml:space="preserve">
          <source>I like to display iterations and time, and a score of time/iteration which can be scaled such that the &quot;best&quot; algorithm gets a score of 1.0 and others are scored in a relative fashion. This means you can run &lt;em&gt;all&lt;/em&gt; algorithms for a longish time, varying both number of iterations and time, but still getting comparable results.</source>
          <target state="translated">反復と時間、および「最良の」アルゴリズムが1.0のスコアを取得し、その他のスコアが相対的にスコア付けされるようにスケーリングできる時間/反復のスコアを表示したい。 つまり、 &lt;em&gt;すべての&lt;/em&gt;アルゴリズムを長めの時間実行でき、反復回数と時間の両方を変化させながら、同等の結果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="073918582af97d175c9583f4544e6c59d66b8800" translate="yes" xml:space="preserve">
          <source>I'm just in the process of blogging about the design of a benchmarking framework in .NET. I've got a &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/26/benchmarking-made-easy.aspx&quot;&gt;couple&lt;/a&gt; of &lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot;&gt;earlier posts&lt;/a&gt; which may be able to give you some ideas - not everything will be appropriate, of course, but some of it may be.</source>
          <target state="translated">私は.NETのベンチマークフレームワークの設計についてブログを書いている最中です。 私はいくつかのアイデアをあなたに与えることができるかもしれないいくつかの&lt;a href=&quot;http://msmvps.com/blogs/jon_skeet/archive/2009/01/29/for-vs-foreach-on-arrays-and-lists.aspx&quot;&gt;以前の投稿&lt;/a&gt;を持っています-もちろんすべてが適切であるとは限りませんが、それのいくつかはそうかもしれません。</target>
        </trans-unit>
        <trans-unit id="51e309adae3a577233db4148a52db0b5e82ad882" translate="yes" xml:space="preserve">
          <source>I'm looking for some code samples and comments illustrating various things to think about.</source>
          <target state="translated">いろんなことを考えるためのコードサンプルやコメントを探しています。</target>
        </trans-unit>
        <trans-unit id="36261b5d7d09dc19c64cb2ee96d2ae81bfed859d" translate="yes" xml:space="preserve">
          <source>If you are interested in &lt;strong&gt;latency&lt;/strong&gt;, use time/iteration and if you are interested in &lt;strong&gt;throughput&lt;/strong&gt;, use iterations/time.</source>
          <target state="translated">&lt;strong&gt;レイテンシ&lt;/strong&gt;に関心がある場合は時間/反復を使用し、 &lt;strong&gt;スループット&lt;/strong&gt;に関心がある場合は反復/時間を使用します。</target>
        </trans-unit>
        <trans-unit id="57fe3c1aa7a71ecc2622b2368266380f1ba646de" translate="yes" xml:space="preserve">
          <source>If you are trying to compare two algorithms, do at least two benchmarks for each, alternating the order.  i.e.:</source>
          <target state="translated">2つのアルゴリズムを比較しようとしている場合は、少なくとも2つのベンチマークを交互に行います。</target>
        </trans-unit>
        <trans-unit id="446509b69736161c6a7f8538df894b0283704899" translate="yes" xml:space="preserve">
          <source>Important things for Java benchmarks are:</source>
          <target state="translated">Javaベンチマークで重要なことは</target>
        </trans-unit>
        <trans-unit id="8a984f01db14194be668e260faf7f1dd1670ba36" translate="yes" xml:space="preserve">
          <source>It depends on &lt;strong&gt;what&lt;/strong&gt; you are trying to test.</source>
          <target state="translated">テストしようとして&lt;strong&gt;いるもの&lt;/strong&gt;に依存します。</target>
        </trans-unit>
        <trans-unit id="feeb65010e24c48f6e8b09b1aefe0fddee8b6bc9" translate="yes" xml:space="preserve">
          <source>It should also be noted that it might also be important to analyze the results of the micro benchmark when comparing different implementations. Therefore a &lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot;&gt;significance test&lt;/a&gt; should be made.</source>
          <target state="translated">また、異なる実装を比較する場合は、マイクロベンチマークの結果を分析することが重要になる場合があることにも注意してください。 したがって、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Significance_testing&quot;&gt;有意性検定を&lt;/a&gt;行う必要があります。</target>
        </trans-unit>
        <trans-unit id="9a4a5f032bf62a386234c6f707d69863e3492a61" translate="yes" xml:space="preserve">
          <source>Make sure you run it for long enough to be able to measure the results in seconds or (better) tens of seconds</source>
          <target state="translated">秒または(より良い)数十秒で結果を測定できるように、十分に長い時間実行してください。</target>
        </trans-unit>
        <trans-unit id="4f40942c1d46b6591496e7b2b047342ec5e9778d" translate="yes" xml:space="preserve">
          <source>Make sure you somehow use results which are computed in benchmarked code. Otherwise your code can be optimized away.</source>
          <target state="translated">ベンチマークされたコードで計算された結果を何らかの形で使用していることを確認してください。そうしないと、あなたのコードが最適化されてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="66b7124924abc42f465159758abb309a487e6f45" translate="yes" xml:space="preserve">
          <source>My recommendations: Make your benchmark run some seconds, that is more reliable than a runtime over milliseconds. Warm up the JVM (means running the benchmark at least once without measuring, that the JVM can run optimizations). And run your benchmark multiple times (maybe 5 times) and take the median-value. Run every micro-benchmark in a new JVM-instance (call for every benchmark new Java) otherwise optimization effects of the JVM can influence later running tests. Don't execute things, that aren't executed in the warmup-phase (as this could trigger class-load and recompilation).</source>
          <target state="translated">私の推奨事項 ベンチマークの実行時間を数秒にすると、ミリ秒以上の実行時間よりも信頼性が高くなります。JVMをウォームアップする(JVMが最適化を実行できるように、ベンチマークを測定せずに少なくとも1回実行することを意味する)。そして、ベンチマークを複数回(多分5回)実行し、中央値を取る。すべてのマイクロベンチマークを新しいJVMインスタンスで実行する(すべてのベンチマークに対して新しいJavaを呼び出す)そうしないと、JVMの最適化効果が後のテスト実行に影響を与える可能性があります。ウォームアップフェーズで実行されていないものを実行しないようにしてください(クラスロードや再コンパイルを引き起こす可能性があるため)。</target>
        </trans-unit>
        <trans-unit id="84b3a6d3b735a279b8a95eec81ccdd77ef213d67" translate="yes" xml:space="preserve">
          <source>Perhaps a more fundamentally important aspect that you have direct control over: make sure you're measuring the right thing! For example, if you're using &lt;code&gt;System.nanoTime()&lt;/code&gt; to benchmark a particular bit of code, put the calls to the assignment in places that make sense to avoid measuring things which you aren't interested in. For example, don't do:</source>
          <target state="translated">おそらく、あなたが直接制御できる、より根本的に重要な側面です。正しいものを測定していることを確認してください！ たとえば、 &lt;code&gt;System.nanoTime()&lt;/code&gt; を使用してコードの特定のビットをベンチマークする場合、 不要なものを測定しないように、意味のある場所に割り当てへの呼び出しを配置し​​ます。たとえば、行う：</target>
        </trans-unit>
        <trans-unit id="24e94fd01de88afc005218fb420a74bbf3940440" translate="yes" xml:space="preserve">
          <source>Problem is you're not immediately getting the end time when the code has finished. Instead, try the following:</source>
          <target state="translated">問題は、コードが終了してもすぐに終了時刻が表示されないことです。代わりに、次のようにしてみてください。</target>
        </trans-unit>
        <trans-unit id="083b98d32d7fe2f0ca96bec067bd4906c6064c09" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://stackoverflow.com/questions/410437/is-stopwatch-benchmarking-acceptable&quot;&gt;Is stopwatch benchmarking acceptable?&lt;/a&gt;</source>
          <target state="translated">関連： &lt;a href=&quot;https://stackoverflow.com/questions/410437/is-stopwatch-benchmarking-acceptable&quot;&gt;ストップウォッチのベンチマークは受け入れられますか？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec4ff7b50a4635d42059faa78909f7f5f9d7a2eb" translate="yes" xml:space="preserve">
          <source>Second: You cannot trust the accuracy of the measured times for very short intervals.</source>
          <target state="translated">2つ目:非常に短い間隔で測定された時間の精度を信用することはできません。</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="fec816031df94b29566d620805f308d6cf737166" translate="yes" xml:space="preserve">
          <source>Should the benchmark measure time/iteration or iterations/time, and why?</source>
          <target state="translated">ベンチマークはtimeiterationとiterationtimeのどちらを測定すべきか、その理由は?</target>
        </trans-unit>
        <trans-unit id="c090559196e8e996c17e7d433bc64f8b76c7baad" translate="yes" xml:space="preserve">
          <source>So it is also important to write and run a micro benchmark correctly, but also to analyze it correctly.</source>
          <target state="translated">そのため、マイクロベンチマークを正しく書いて実行するだけでなく、正しく分析することも重要です。</target>
        </trans-unit>
        <trans-unit id="ca5ea60128b328a761b56bf9b62dbcaf8e859acb" translate="yes" xml:space="preserve">
          <source>The jmh is a Java harness for building, running, and analysing nano/micro/macro benchmarks written in Java and other languages targetting the JVM.</source>
          <target state="translated">jmhは、Javaや他の言語で書かれたナノマクロベンチマークを構築、実行、分析するためのJavaハーネスで、JVMをターゲットにしています。</target>
        </trans-unit>
        <trans-unit id="8b8343ec5e38906eb0a29c2be2182da0957c52aa" translate="yes" xml:space="preserve">
          <source>There are many possible pitfalls for writing micro-benchmarks in Java.</source>
          <target state="translated">Javaでマイクロベンチマークを書く際には、多くの落とし穴が考えられます。</target>
        </trans-unit>
        <trans-unit id="1beb582fcae9e9c673cb7f6f4df5cf4c23a15792" translate="yes" xml:space="preserve">
          <source>Third: The JVM optimizes your code while executing. So different runs in the same JVM-instance will become faster and faster.</source>
          <target state="translated">3番目:JVMは実行中にコードを最適化します。そのため、同じJVMインスタンス内での異なる実行は、より速く、より速くなります。</target>
        </trans-unit>
        <trans-unit id="0f9f7a1cf8a428a9d13c0c15079ccb8e8a7c3323" translate="yes" xml:space="preserve">
          <source>This is because implementation &lt;code&gt;A&lt;/code&gt; might be faster during most of the runs of the benchmark than implementation &lt;code&gt;B&lt;/code&gt;. But &lt;code&gt;A&lt;/code&gt; might also have a higher spread, so the measured performance benefit of &lt;code&gt;A&lt;/code&gt; won't be of any significance when compared with &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">これは、ベンチマークのほとんどの実行中に、実装 &lt;code&gt;A&lt;/code&gt; が実装 &lt;code&gt;B&lt;/code&gt; よりも高速になる可能性があるためです。 ただし、 &lt;code&gt;A&lt;/code&gt; の方が拡散が大きい可能性があるため、 &lt;code&gt;B&lt;/code&gt; と比較した場合、 &lt;code&gt;A&lt;/code&gt; の測定されたパフォーマンス上の利点は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="15e6b0c5d76c16417c6007b1618f6b7c6ff8d43d" translate="yes" xml:space="preserve">
          <source>Tips about writing micro benchmarks &lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot;&gt;from the creators of Java HotSpot&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://wiki.openjdk.java.net/display/HotSpot/Main&quot;&gt;Java HotSpotの作成者からの&lt;/a&gt;マイクロベンチマークの作成に関するヒント：</target>
        </trans-unit>
        <trans-unit id="2175398196c5bd9dc22098e16383b9977459087d" translate="yes" xml:space="preserve">
          <source>To add to the other excellent advice, I'd also be mindful of the following:</source>
          <target state="translated">他の優れたアドバイスに加えて、以下のようなことにも気をつけたいと思います。</target>
        </trans-unit>
        <trans-unit id="23055b4d37f59f17de37b2f34febaa4ebff5215d" translate="yes" xml:space="preserve">
          <source>Very interesting pieces of information buried in &lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot;&gt;the sample tests comments&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/&quot;&gt;サンプルテストのコメントに&lt;/a&gt;埋め込まれた非常に興味深い情報。</target>
        </trans-unit>
        <trans-unit id="0ada6fca5c78392f28aae4ac87bca62c28900053" translate="yes" xml:space="preserve">
          <source>Warm up the JIT first by running the code several times &lt;strong&gt;before timing&lt;/strong&gt; it</source>
          <target state="translated">&lt;strong&gt;タイミングを&lt;/strong&gt;とる&lt;strong&gt;前に&lt;/strong&gt;コードを数回実行して、最初にJITをウォームアップします。</target>
        </trans-unit>
        <trans-unit id="266c504aa997c2e2ca6e724568658a941f940414" translate="yes" xml:space="preserve">
          <source>While you can't call &lt;code&gt;System.gc()&lt;/code&gt; between iterations, it's a good idea to run it between tests, so that each test will hopefully get a &quot;clean&quot; memory space to work with. (Yes, &lt;code&gt;gc()&lt;/code&gt; is more of a hint than a guarantee, but it's very &lt;em&gt;likely&lt;/em&gt; that it really will garbage collect in my experience.)</source>
          <target state="translated">反復間で &lt;code&gt;System.gc()&lt;/code&gt; を呼び出すことはできませんが、テスト間で実行することをお勧めします。これにより、各テストで「クリーンな」メモリ空間を処理できるようになります。 （はい、 &lt;code&gt;gc()&lt;/code&gt; は保証というよりヒントですが、私の経験ではガベージコレクションが実際に行われる&lt;em&gt;可能性&lt;/em&gt;が非常に&lt;em&gt;高い&lt;/em&gt;です。）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
