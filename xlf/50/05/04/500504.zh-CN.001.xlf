<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/500504">
    <body>
      <group id="500504">
        <trans-unit id="4bd6398b6ec50d16e0ba8b718869fa0726943b47" translate="yes" xml:space="preserve">
          <source>(Emphasis mine.)</source>
          <target state="translated">(强调是我的)。</target>
        </trans-unit>
        <trans-unit id="d8063be2dd09276b0e12dbda5c629337424e931e" translate="yes" xml:space="preserve">
          <source>1.) There is already a higher order function, or method, that has that purpose for an array, but has more functionality and leaner syntax, called 'forEach': &lt;code&gt;Array.prototype.forEach(function(element, index, array) {} );&lt;/code&gt;</source>
          <target state="translated">1.）已经有一个用于数组的目的的高级函数或方法，但是具有更多功能和更精简的语法，称为&amp;ldquo; forEach&amp;rdquo;： &lt;code&gt;Array.prototype.forEach(function(element, index, array) {} );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f5212d015eaea70f541c879dc9a1ee3ee6ea4e6" translate="yes" xml:space="preserve">
          <source>2.) Arrays always have a length, but &lt;code&gt;for...in&lt;/code&gt; and &lt;code&gt;forEach&lt;/code&gt; do not execute a function for any value that is &lt;code&gt;'undefined'&lt;/code&gt;, only for the indexes that have a value defined. So if you only assign one value, these loops will only execute a function once, but since an array is enumerated, it will always have a length up to the highest index that has a defined value, but that length could go unnoticed when using these loops.</source>
          <target state="translated">2.）数组总是有长度，但是 &lt;code&gt;for...in&lt;/code&gt; 和 &lt;code&gt;forEach&lt;/code&gt; 不会对任何 &lt;code&gt;'undefined'&lt;/code&gt; 值执行函数，仅对定义了值的索引执行。 因此，如果仅分配一个值，则这些循环将仅执行一次函数，但是由于枚举了一个数组，因此它的长度将一直到具有定义值的最高索引，但是使用这些值时，该长度可能会被忽略循环。</target>
        </trans-unit>
        <trans-unit id="1a000b47a2784ab5959eeb6bb68516347e56d65f" translate="yes" xml:space="preserve">
          <source>3.) The standard for loop will execute a function as many times as you define in the parameters, and since an array is numbered, it makes more sense to define how many times you want to execute a function. Unlike the other loops, the for loop can then execute a function for every index in the array, whether the value is defined or not.</source>
          <target state="translated">3.)标准的for循环会根据你在参数中定义的次数执行一个函数,由于数组是有编号的,所以定义一个函数的执行次数更有意义。与其他循环不同的是,for循环可以对数组中的每一个索引执行一个函数,无论是否定义了值,都可以执行一个函数。</target>
        </trans-unit>
        <trans-unit id="85146881dc047a08449a004a02b095cacd0cb609" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for (... in ...)&lt;/code&gt; is not guaranteed to return the object properties in sequential order, as one might expect.</source>
          <target state="translated">不保证 &lt;code&gt;for (... in ...)&lt;/code&gt; 可以按预期顺序返回对象属性。</target>
        </trans-unit>
        <trans-unit id="f7fb489c373f09f65363d8fdde0d33f885cc248d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; lists only the &lt;code&gt;5&lt;/code&gt;, ignoring undefined array indexes, but adding &lt;code&gt;foo&lt;/code&gt;. It shows array &lt;strong&gt;property names&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 仅列出 &lt;code&gt;5&lt;/code&gt; 个 ，忽略未定义的数组索引，但添加 &lt;code&gt;foo&lt;/code&gt; 。 它显示了数组&lt;strong&gt;属性名称&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c070578b97dc889d040320474709963bba8ff11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops &lt;strong&gt;do not guarantee a specific iteration order&lt;/strong&gt;. Although is order is usually seen in most modern browsers these days, there is still no 100% guarantee.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 循环&lt;strong&gt;不保证特定的迭代顺序&lt;/strong&gt; 。 尽管这些天通常在大多数现代浏览器中都可以看到订单，但是仍然没有100％的保证。</target>
        </trans-unit>
        <trans-unit id="75add2a4d0fc3dfc08d7b2e03792fa72128dc96e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops ignore &lt;code&gt;undefined&lt;/code&gt; array elements, i.e. array elements which not have been assigned yet.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 循环会忽略 &lt;code&gt;undefined&lt;/code&gt; 数组元素，即尚未分配的数组元素。</target>
        </trans-unit>
        <trans-unit id="e02c78b83b9baae453efbdb0e530f06924f7cb8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops iterate over all their own enumerable properties &lt;strong&gt;and&lt;/strong&gt; the enumerable properties of their prototype(s). Usually in an array iteration we only want to iterate over the array itself. And even though you yourself may not add anything to the array, your libraries or framework might add something.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 循环迭代其自己的所有可枚举属性&lt;strong&gt;和&lt;/strong&gt;其原型的可枚举属性。 通常在数组迭代中，我们只想迭代数组本身。 即使您自己可能未在阵列中添加任何内容，您的库或框架也可能添加了某些内容。</target>
        </trans-unit>
        <trans-unit id="5b510d520668177a37ca1233fffcce16d554bed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...of&lt;/code&gt; counts from 0 to 5, and also ignores &lt;code&gt;Array.prototype.foo&lt;/code&gt;. It shows array &lt;strong&gt;values&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;for...of&lt;/code&gt; 从0到5 的计数，并且也忽略 &lt;code&gt;Array.prototype.foo&lt;/code&gt; 。 它显示数组&lt;strong&gt;值&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="de8d59ac496d49a3cc2830db61e5080ba7b3ed4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; isn't guaranteed to preserve element ordering</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; 不能保证保留元素顺序</target>
        </trans-unit>
        <trans-unit id="57c504b07cbe053e6d9258c6e6ce9dab71001517" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; will loop over all own and inherited properties of the array object which aren't &lt;code&gt;DontEnum&lt;/code&gt;; that means if someone adds properties to the specific array object (there are valid reasons for this - I've done so myself) or changed &lt;code&gt;Array.prototype&lt;/code&gt; (which is considered bad practice in code which is supposed to work well with other scripts), these properties will be iterated over as well; inherited properties can be excluded by checking &lt;code&gt;hasOwnProperty()&lt;/code&gt;, but that won't help you with properties set in the array object itself</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; 将遍历数组对象的所有自己和继承的属性，这些属性不是 &lt;code&gt;DontEnum&lt;/code&gt; ； 这意味着如果有人将属性添加到特定的数组对象（这样做有充分的理由，我自己做了）或更改了 &lt;code&gt;Array.prototype&lt;/code&gt; （在代码中被认为是不好的做法，应该与其他脚本一起使用），这些属性也将被迭代； 可以通过检查 &lt;code&gt;hasOwnProperty()&lt;/code&gt; 来排除继承的属性，但这不会帮助您在数组对象本身中设置属性</target>
        </trans-unit>
        <trans-unit id="5c924ba7b90dce15af127843f7697ca7dc50c687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b0a4e9b74e35d5bb4223b2cc511f2cfc42e49e60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="ed70972dc116b90558966dcf0dc7a880652a1079" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It loops through inherited properties as well:&lt;/strong&gt; First of all any extensions to the &lt;code&gt;Array.prototype&lt;/code&gt; should have been done by using &lt;a href=&quot;https://developer.mozilla.org/tr/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt; and their &lt;code&gt;enumerable&lt;/code&gt; descriptor should be set to &lt;code&gt;false&lt;/code&gt;. Any library not doing so should not be used at all.</source>
          <target state="translated">&lt;strong&gt;它也循环遍历继承的属性：&lt;/strong&gt;首先，应该使用&lt;a href=&quot;https://developer.mozilla.org/tr/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt;对 &lt;code&gt;Array.prototype&lt;/code&gt; 进行任何扩展，并将它们的 &lt;code&gt;enumerable&lt;/code&gt; 描述符设置为 &lt;code&gt;false&lt;/code&gt; 。 任何不这样做的库都不应使用。</target>
        </trans-unit>
        <trans-unit id="864471cf89b4825cee0c68d43263743a49b07aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;One&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;One&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2930f375e598c4c0cda99ef5ee5ced807b11895f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Properties those you add to the inheritance chain later get counted:&lt;/strong&gt; When doing array sub-classing by &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or by Class &lt;code&gt;extend&lt;/code&gt;. You should again use &lt;code&gt;Object.defineProperty()&lt;/code&gt; which by default sets the &lt;code&gt;writable&lt;/code&gt;, &lt;code&gt;enumerable&lt;/code&gt; and &lt;code&gt;configurable&lt;/code&gt; property descriptors to &lt;code&gt;false&lt;/code&gt;. Lets see an array sub-classing example here...</source>
          <target state="translated">&lt;strong&gt;稍后添加到继承链中的属性将被计算在内：&lt;/strong&gt;当执行 &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; 或Classextend的数组子分类时。 您应该再次使用 &lt;code&gt;Object.defineProperty()&lt;/code&gt; ，该默认情况下会将 &lt;code&gt;writable&lt;/code&gt; ， &lt;code&gt;enumerable&lt;/code&gt; 和可 &lt;code&gt;configurable&lt;/code&gt; 属性描述符设置为 &lt;code&gt;false&lt;/code&gt; 。 让我们在这里看到数组子分类的例子...</target>
        </trans-unit>
        <trans-unit id="1d17c64273e3caf29ac784b4ed9036aa7703f21e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL&amp;amp;DR:&lt;/strong&gt; Using the &lt;code&gt;for in&lt;/code&gt; loop in arrays is not evil, in fact quite the opposite.</source>
          <target state="translated">&lt;strong&gt;TL＆DR：&lt;/strong&gt;在数组中使用 &lt;code&gt;for in&lt;/code&gt; 循环并不有害，实际上恰恰相反。</target>
        </trans-unit>
        <trans-unit id="f4a90667800dfac206439640fe039e0a8ec77ce8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;for in&lt;/code&gt; loop is slow:&lt;/strong&gt; Hell no. It's by far the fastest method of iteration if you are looping over sparse arrays which are needed time to time. This is one of the most important performance tricks that one should know. Let's see an example. We will loop over a sparse array.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;for in&lt;/code&gt; 循环缓慢：&lt;/strong&gt;该死。 如果要遍历稀疏数组，这是迄今为止最快的迭代方法。 这是应该知道的最重要的性能技巧之一。 让我们来看一个例子。 我们将遍历一个稀疏数组。</target>
        </trans-unit>
        <trans-unit id="7e70c28d46516e16a285932547326e3516ac248f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Two&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aa55c4c1ec6fa0600a16d8a1df0ed62aebb5a00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for...in&lt;/strong&gt; is useful when working on an object in JavaScript, but not for an Array, but still we can not say it's a wrong way, but it's not recommended, look at this example below using &lt;strong&gt;for...in&lt;/strong&gt; loop:</source>
          <target state="translated">&lt;strong&gt;for ... in&lt;/strong&gt;在使用JavaScript处理对象时很有用，但不适用于Array，但我们仍然不能说这是错误的方法，但是不建议这样做，请在下面的示例中使用&lt;strong&gt;for ... in&lt;/strong&gt;循环：</target>
        </trans-unit>
        <trans-unit id="723137f7795e3401755b70d4616c338ef4c6b6e9" translate="yes" xml:space="preserve">
          <source>A for...in loop always enumerates the keys.
Objects properties keys are always String, even the indexed properties of an array :</source>
          <target state="translated">一个for...in循环总是枚举键。对象的属性键总是String,即使是数组的索引属性。</target>
        </trans-unit>
        <trans-unit id="e380bf6c22148b057e16f813b7f95eb85c229ee9" translate="yes" xml:space="preserve">
          <source>A real answer for this will depend on how the browser parsers/interpret the JavaScript code. It can change between browsers.</source>
          <target state="translated">这个问题的真正答案取决于浏览器的解析器如何解释JavaScript代码。这在不同的浏览器之间可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="3f8ee733770af90d6a036b73e38df85ea12e55c2" translate="yes" xml:space="preserve">
          <source>Also consider that &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; libraries might do things like this, which will affect any array you create:</source>
          <target state="translated">还请注意， &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;库可能会执行以下操作，这会影响您创建的任何数组：</target>
        </trans-unit>
        <trans-unit id="81a354e95f9aef67cb843763fd3927258da5fdda" translate="yes" xml:space="preserve">
          <source>Also, due to semantics, the way &lt;code&gt;for, in&lt;/code&gt; treats arrays (i.e. the same as any other JavaScript object) is not aligned with other popular languages.</source>
          <target state="translated">同样，由于语义，处理数组（即，与任何其他JavaScript对象相同）的方式与其他流行语言不一致。</target>
        </trans-unit>
        <trans-unit id="56813a034610fd55b9667a342f05765d16c2560a" translate="yes" xml:space="preserve">
          <source>Also, it may be considered a better practice to use the &lt;code&gt;forEach&lt;/code&gt; method than the &lt;code&gt;for...in&lt;/code&gt; loop in general, because it is easier to write and has more functionality, so you may want to get in the habit of only using this method and standard for, but your call.</source>
          <target state="translated">另外，一般来说，使用 &lt;code&gt;forEach&lt;/code&gt; 方法比使用 &lt;code&gt;for...in&lt;/code&gt; 循环可能是更好的做法，因为它更容易编写且功能更多，因此您可能想养成仅使用此方法的习惯和标准，但您可以致电。</target>
        </trans-unit>
        <trans-unit id="8e9ef6ce457a097e6cbaa9a5cee537865b67b8ae" translate="yes" xml:space="preserve">
          <source>Also, speaking about inherited properties, if you, for example, extend the &lt;code&gt;Array.prototype&lt;/code&gt; object (like some libraries as MooTools do), that properties will be also enumerated:</source>
          <target state="translated">同样，谈到继承的属性，例如，如果您扩展 &lt;code&gt;Array.prototype&lt;/code&gt; 对象（就像MooTools的某些库一样），那么这些属性也会被枚举：</target>
        </trans-unit>
        <trans-unit id="77e8cec41cc494061a090fc5862a2f2e51506df4" translate="yes" xml:space="preserve">
          <source>Also, the order of iteration is not guaranteed by the spec., meaning that if you want to &quot;iterate&quot; an array object, with this statement you cannot be sure that the properties (array indexes) will be visited in the numeric order.</source>
          <target state="translated">另外,迭代的顺序并不是规范所保证的,也就是说,如果你想对一个数组对象进行 &quot;迭代&quot;,用这个语句,你不能确定属性(数组索引)会按照数字顺序访问。</target>
        </trans-unit>
        <trans-unit id="4caa9f9af0086837955f928c936648d78e3cf12c" translate="yes" xml:space="preserve">
          <source>An alternative way of iterating through an array is using a for-loop:</source>
          <target state="translated">迭代数组的另一种方法是使用for-loop。</target>
        </trans-unit>
        <trans-unit id="4330d9777faffc1aebc6faa887599a7ad547c366" translate="yes" xml:space="preserve">
          <source>An important aspect is that &lt;code&gt;for...in&lt;/code&gt; only iterates over properties contained in an object which have their &lt;strong&gt;enumerable&lt;/strong&gt;&lt;em&gt;property attribute&lt;/em&gt; set to true. So if one attempts to iterate over an object using &lt;code&gt;for...in&lt;/code&gt; then arbitrary properties may be missed if their enumerable property attribute is false. It is quite possible to alter the enumerable property attribute for normal Array objects so that certain elements are not enumerated. Though in general the property attributes tend to apply to function properties within an object.</source>
          <target state="translated">一个重要方面是 &lt;code&gt;for...in&lt;/code&gt; 仅迭代对象中包含的&lt;strong&gt;可枚举&lt;/strong&gt; &lt;em&gt;属性属性&lt;/em&gt;设置为true的&lt;em&gt;属性&lt;/em&gt; 。 因此，如果尝试使用 &lt;code&gt;for...in&lt;/code&gt; 遍历对象，则如果其可枚举的property属性为false ，则可能会丢失任意属性。 很有可能会更改普通Array对象的enumerable属性属性，以便不枚举某些元素。 尽管通常属性属性倾向于应用于对象内的函数属性。</target>
        </trans-unit>
        <trans-unit id="bdc123fed57544f574b847785e448b373aff2349" translate="yes" xml:space="preserve">
          <source>And since you can never be sure that nothing will be added to the prototype chain just use a for loop to enumerate the array:</source>
          <target state="translated">因为你永远不能确定没有任何东西会被添加到原型链中,所以只需使用for循环来枚举数组。</target>
        </trans-unit>
        <trans-unit id="ad0c718b13ffaf815489fe18ec085881a6be06e3" translate="yes" xml:space="preserve">
          <source>And some people even recommend calling the method directly from &lt;code&gt;Object.prototype&lt;/code&gt; to avoid having problems if somebody adds a property named &lt;code&gt;hasOwnProperty&lt;/code&gt; to our object:</source>
          <target state="translated">甚至有人建议直接从 &lt;code&gt;Object.prototype&lt;/code&gt; 调用该方法，以避免在有人向我们的对象添加名为 &lt;code&gt;hasOwnProperty&lt;/code&gt; 的属性时出现问题的情况：</target>
        </trans-unit>
        <trans-unit id="35888521210af7f9dd1e0af389345f2c1f605553" translate="yes" xml:space="preserve">
          <source>Any object can have arbitrary properties associated with it. There would be nothing terrible about loading additional properties onto an array instance, in particular. Code that wants to see &lt;em&gt;only&lt;/em&gt; indexed array-like properties therefore &lt;em&gt;must&lt;/em&gt; stick to an integer index. Code that is fully aware of what &lt;code&gt;for ... in&lt;/code&gt; does and really &lt;em&gt;need&lt;/em&gt; to see all properties, well then that's ok too.</source>
          <target state="translated">任何对象都可以具有与之关联的任意属性。 特别是将额外的属性加载到数组实例上并没有什么可怕的。 因此，只想查看类似索引的数组属性的代码&lt;em&gt;必须&lt;/em&gt;坚持整数索引。 完全知道 &lt;code&gt;for ... in&lt;/code&gt; 做什么的代码，实际上&lt;em&gt;需要&lt;/em&gt;查看所有属性，那么那也没关系。</target>
        </trans-unit>
        <trans-unit id="8ae256cf5a988279dae9f08c26581718bda89b9c" translate="yes" xml:space="preserve">
          <source>As I said before to &lt;em&gt;iterate&lt;/em&gt; over arrays or array-like objects, the best thing is to use a &lt;em&gt;sequential loop&lt;/em&gt;, such as a plain-old &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loop.</source>
          <target state="translated">就像我之前说过的，要&lt;em&gt;遍历&lt;/em&gt;数组或类似数组的对象，最好的方法是使用&lt;em&gt;顺序循环&lt;/em&gt; ，例如普通的 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 循环。</target>
        </trans-unit>
        <trans-unit id="6223893ff2388e165f873960bac2ba5392b49cb2" translate="yes" xml:space="preserve">
          <source>As of 2016 (ES6) we may use &lt;code&gt;for&amp;hellip;of&lt;/code&gt; for array iteration, as John Slegers already noticed.</source>
          <target state="translated">正如John Slegers已经注意到的那样，从2016年（ES6）起，我们可以将 &lt;code&gt;for&amp;hellip;of&lt;/code&gt; 用于数组迭代。</target>
        </trans-unit>
        <trans-unit id="b9ffc247af1b8ed568d6b5c1b3a27e66e602fc7e" translate="yes" xml:space="preserve">
          <source>As you see the result the same...</source>
          <target state="translated">就像你看到的结果一样......</target>
        </trans-unit>
        <trans-unit id="894f0d6f0a5dc7e6d9477fd432341a08cc075bbf" translate="yes" xml:space="preserve">
          <source>Aside from the fact that &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; loops over all enumerable properties (which is &lt;em&gt;not&lt;/em&gt; the same as &quot;all array elements&quot;!), see &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&quot;&gt;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&lt;/a&gt;, section 12.6.4 (5th edition) or 13.7.5.15 (7th edition):</source>
          <target state="translated">除了 &lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;in&lt;/code&gt; 循环遍历所有可枚举属性（与&amp;ldquo;所有数组元素&amp;rdquo;不同！）外，请参见&lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&quot;&gt;http://www.ecma-international.org/publications/files/ECMA-ST /Ecma-262.pdf&lt;/a&gt; ，第12.6.4节（第5版）或13.7.5.15节（第7版）：</target>
        </trans-unit>
        <trans-unit id="eb7d92e5a3d183746be4cc4443582416eca4294e" translate="yes" xml:space="preserve">
          <source>Because for...in enumerates through the object that holds the array, not the array itself. If I add a function to the arrays prototype chain, that will also be included. I.e.</source>
          <target state="translated">因为for...in是通过枚举对象来容纳数组,而不是数组本身。如果我在数组原型链中添加一个函数,那也会被包含在内。比如说......</target>
        </trans-unit>
        <trans-unit id="b96448a2e10a4868599ab0a74179eb46b603e8f6" translate="yes" xml:space="preserve">
          <source>Because it enumerates through object fields, not indexes. You can get value with index &quot;length&quot; and I doubt you want this.</source>
          <target state="translated">因为它通过对象字段枚举,而不是索引。你可以通过索引 &quot;length &quot;来获取值,我怀疑你是否想要这个。</target>
        </trans-unit>
        <trans-unit id="8992d96aafc9f0ab11805a540be31b57da2de068" translate="yes" xml:space="preserve">
          <source>Because it will iterate over properties belonging to objects up the prototype chain if you're not careful.</source>
          <target state="translated">因为如果你不小心,它就会在原型链上迭代属于对象的属性。</target>
        </trans-unit>
        <trans-unit id="ee90f63ccf1f6222ef3e10f7c081882454ec920d" translate="yes" xml:space="preserve">
          <source>But in my opinion, it's better to use &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;, the process required for that auto-detection is very small.</source>
          <target state="translated">但是我认为，最好在/ &lt;code&gt;in&lt;/code&gt; 中使用该自动检测所需的过程很小。</target>
        </trans-unit>
        <trans-unit id="12279b51e8d023c0ad5031c9a0b1e701ef3132e1" translate="yes" xml:space="preserve">
          <source>But let's try something, let's prototype something to &lt;strong&gt;Array&lt;/strong&gt;...</source>
          <target state="translated">但是让我们尝试一些事情，让我们为&lt;strong&gt;Array制作&lt;/strong&gt;一些原型...</target>
        </trans-unit>
        <trans-unit id="43740775866432b484bee9f9cd495c479fdafbb1" translate="yes" xml:space="preserve">
          <source>Either way, &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; carries with it no connotation of order.  If you care about order, be explicit about it and use a regular &lt;code&gt;for&lt;/code&gt; loop with an index.</source>
          <target state="translated">无论哪种方式， &lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;in&lt;/code&gt; 都没有顺序的含义。 如果您关心顺序，请明确说明顺序，并使用带有索引的常规 &lt;code&gt;for&lt;/code&gt; 循环。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="0f0d139be39da72d26c2fc44d8e9127747d60e99" translate="yes" xml:space="preserve">
          <source>For example, in JScript (IE &amp;lt;= 8), the order of enumeration even on Array objects is defined as the properties were created:</source>
          <target state="translated">例如，在JScript（IE &amp;lt;= 8）中，即使创建了属性，也定义了对Array对象的枚举顺序：</target>
        </trans-unit>
        <trans-unit id="2428f10d15c193c4c3f102bd0050a7d4e2a6f520" translate="yes" xml:space="preserve">
          <source>For these reasons an acceptable trade-off between performance and convenience doesn't even exist.  There's really no benefit unless the intent is to handle the array as an &lt;em&gt;object&lt;/em&gt; and perform operations on the object properties of the array.</source>
          <target state="translated">由于这些原因，甚至不存在性能和便利性之间可接受的折衷。 除非意图是将数组作为&lt;em&gt;对象&lt;/em&gt;处理并对数组的对象属性执行操作，否则实际上没有任何好处。</target>
        </trans-unit>
        <trans-unit id="32b5cb0e39239e899eede9d898b826f9b8871c75" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&lt;/a&gt;</source>
          <target state="translated">来自&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68c380cf4529191d6c4d7cbc7090efd3852b6892" translate="yes" xml:space="preserve">
          <source>Here are the reasons why this is (usually) a bad practice:</source>
          <target state="translated">以下是(通常)这种做法不好的原因。</target>
        </trans-unit>
        <trans-unit id="8800cd23cee45b4bed05921ce5f6db9ef6fde066" translate="yes" xml:space="preserve">
          <source>However, if your code (or the framework you are using) add custom properties to arrays or to the array prototype, then these properties will be included in the iteration, which is probably not what you want.</source>
          <target state="translated">但是,如果你的代码(或你使用的框架)向数组或数组原型添加自定义属性,那么这些属性将被包含在迭代中,这可能不是你想要的。</target>
        </trans-unit>
        <trans-unit id="3f41c8e3bf1d0164c41613e45d4575733160cd11" translate="yes" xml:space="preserve">
          <source>However, this have a different issue. The issue is that a JavaScript array can have &quot;holes&quot;. If you define &lt;code&gt;arr&lt;/code&gt; as:</source>
          <target state="translated">但是，这有一个不同的问题。 问题是JavaScript数组可能有&amp;ldquo;漏洞&amp;rdquo;。 如果将 &lt;code&gt;arr&lt;/code&gt; 定义为：</target>
        </trans-unit>
        <trans-unit id="4609f4613ee2485b87e9ea3693f15a345fdc5bff" translate="yes" xml:space="preserve">
          <source>I can't think of other purposes to not using &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;;</source>
          <target state="translated">我无法想到不使用 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; 的其他目的；</target>
        </trans-unit>
        <trans-unit id="c84398cbe7864ec7d29debf086fe632c20a743ee" translate="yes" xml:space="preserve">
          <source>I do, however, would like to add that &lt;strong&gt;in modern browsers&lt;/strong&gt; there is an alternative to &lt;code&gt;for...in&lt;/code&gt; that can be used in those cases where &lt;code&gt;for...in&lt;/code&gt; can't be used. That alternative is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/a&gt; :</source>
          <target state="translated">但是，我确实想补充一点， &lt;strong&gt;在现代浏览器中，&lt;/strong&gt;有一种替代方法 &lt;code&gt;for...in&lt;/code&gt; 可以在无法使用 &lt;code&gt;for...in&lt;/code&gt; 情况下使用。 该替代方法&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="e3b3a26ba9647b9bce83a99b6dd6343035cd56ae" translate="yes" xml:space="preserve">
          <source>I don't think I have much to add to eg. &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/500531#500531&quot;&gt;Triptych's answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/4261096#4261096&quot;&gt;CMS's answer&lt;/a&gt; on why using &lt;code&gt;for...in&lt;/code&gt; should be avoided in some cases.</source>
          <target state="translated">我认为我没有什么要补充的。 在某些情况下 &lt;code&gt;for...in&lt;/code&gt; 应避免使用&lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/500531#500531&quot;&gt;Triptych的答案&lt;/a&gt;或&lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/4261096#4261096&quot;&gt;CMS的答案&lt;/a&gt;来解释为什么要使用...。</target>
        </trans-unit>
        <trans-unit id="cd3028b86fe1e48337d81eff923a6ece9b04e2b8" translate="yes" xml:space="preserve">
          <source>I think the &lt;code&gt;for in&lt;/code&gt; loop is a gem of JS if used &lt;em&gt;correctly&lt;/em&gt; in arrays. You are expected to have full control over your software and know what you are doing. Let's see the mentioned drawbacks and disprove them one by one.</source>
          <target state="translated">如果在数组中&lt;em&gt;正确&lt;/em&gt;使用，我认为 &lt;code&gt;for in&lt;/code&gt; 循环是JS的瑰宝。 您应该完全控制您的软件，并且知道自己在做什么。 让我们看看所提到的缺点，并逐一加以证明。</target>
        </trans-unit>
        <trans-unit id="3c5457f2a9b947636475a19d3f1132040b65b1d3" translate="yes" xml:space="preserve">
          <source>I would just like to add this simple demonstration code, to make things clearer:</source>
          <target state="translated">我只是想把这个简单的演示代码加上去,让事情更清晰。</target>
        </trans-unit>
        <trans-unit id="64e3da07990d73da0857766c8c4119fdfa3d8581" translate="yes" xml:space="preserve">
          <source>I've been told not to use &lt;code&gt;for...in&lt;/code&gt; with arrays in JavaScript. Why not?</source>
          <target state="translated">有人告诉我不要将 &lt;code&gt;for...in&lt;/code&gt; 用于JavaScript 中的数组。 为什么不？</target>
        </trans-unit>
        <trans-unit id="97e955c989e786a9c59188ad385759593bc273f9" translate="yes" xml:space="preserve">
          <source>If a function called &lt;code&gt;helpfulUtilityMethod&lt;/code&gt; has been added to &lt;code&gt;Array&lt;/code&gt;'s &lt;code&gt;prototype&lt;/code&gt;, then your loop would end up running four times: &lt;code&gt;key&lt;/code&gt; would be &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;helpfulUtilityMethod&lt;/code&gt;.  If you were only expecting integers, oops.</source>
          <target state="translated">如果已将一个名为 &lt;code&gt;helpfulUtilityMethod&lt;/code&gt; 的函数添加到 &lt;code&gt;Array&lt;/code&gt; 的 &lt;code&gt;prototype&lt;/code&gt; ，则您的循环最终将运行四次： &lt;code&gt;key&lt;/code&gt; 将为 &lt;code&gt;0&lt;/code&gt; ,1,2和 &lt;code&gt;helpfulUtilityMethod&lt;/code&gt; 。 如果您只期望整数，哎呀。</target>
        </trans-unit>
        <trans-unit id="36c04e2865843e125432c9e852edd02d54e879a0" translate="yes" xml:space="preserve">
          <source>If you are in doubt, you probably shouldn't use for-in.</source>
          <target state="translated">如果你有疑问,你可能不应该使用for-in。</target>
        </trans-unit>
        <trans-unit id="3f9cf51b07160b61873b4313b13e4209e40cf8d3" translate="yes" xml:space="preserve">
          <source>In addition to the other problems, the &quot;for..in&quot; syntax is probably slower, because the index is a string, not an integer.</source>
          <target state="translated">除了其他问题外,&quot;for...in &quot;语法可能比较慢,因为索引是一个字符串,而不是整数。</target>
        </trans-unit>
        <trans-unit id="5d7f89f56c3c8e5432b67de63d59ca4ec8daee20" translate="yes" xml:space="preserve">
          <source>In addition to the reasons given in other answers, you may not want to use the &quot;for...in&quot; structure if you need to do math with the counter variable because the loop iterates through the names of the object's properties and so the variable is a string.</source>
          <target state="translated">除了其他答案中给出的原因外,如果你需要用计数器变量进行数学运算,你可能不想使用 &quot;for...in &quot;结构,因为循环会通过对象的属性名进行迭代,所以变量是一个字符串。</target>
        </trans-unit>
        <trans-unit id="987fa132a1fc4549a83c1787f42d94ea85f4d2a2" translate="yes" xml:space="preserve">
          <source>In essence, you can use any loop, but you should remember exactly how they work. Understand the conditions upon which the different loops reiterate, their separate functionalities, and realize they will be more or less appropriate for differing scenarios.</source>
          <target state="translated">本质上,你可以使用任何循环,但你应该记住它们是如何工作的。理解不同的循环所依据的条件,了解不同的循环所重申的条件,了解它们的独立功能,并意识到它们或多或少会适合不同的场景。</target>
        </trans-unit>
        <trans-unit id="aec6fa3400776b4a7fb59542b27ba833e3407a93" translate="yes" xml:space="preserve">
          <source>In isolation, there is nothing wrong with using for-in on arrays. For-in iterates over the property names of an object, and in the case of an &quot;out-of-the-box&quot; array, the properties corresponds to the array indexes. (The built-in propertes like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;toString&lt;/code&gt; and so on are not included in the iteration.)</source>
          <target state="translated">孤立地，在数组上使用for-in并没有错。 for-in遍历对象的属性名称，对于&amp;ldquo;开箱即用&amp;rdquo;的数组，属性对应于数组索引。 （迭代中不包括诸如 &lt;code&gt;length&lt;/code&gt; ， &lt;code&gt;toString&lt;/code&gt; 等内置属性。）</target>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">换句话说。</target>
        </trans-unit>
        <trans-unit id="734568a26e2da175e7b2711963a36f6889e16233" translate="yes" xml:space="preserve">
          <source>In practice, most browsers currently like to iterate in roughly the same order.  But there's nothing saying they have to.  That's implementation specific, and could change at any time if another way was found to be far more efficient.</source>
          <target state="translated">在实际操作中,目前大多数浏览器都喜欢按照大致相同的顺序进行迭代。但并没有说他们必须这样做。这是特定的实现方式,如果发现另一种方式更有效率,那就会随时改变。</target>
        </trans-unit>
        <trans-unit id="63b585b5d4653967345fb2a5acb868a3bc4a2b69" translate="yes" xml:space="preserve">
          <source>It's not &lt;em&gt;necessarily&lt;/em&gt; bad (based on what you're doing), but in the case of arrays, if something has been added to &lt;code&gt;Array.prototype&lt;/code&gt;, then you're going to get strange results.  Where you'd expect this loop to run three times:</source>
          <target state="translated">&lt;em&gt;不一定很&lt;/em&gt;糟糕（基于您的工作），但是对于数组，如果将某些内容添加到 &lt;code&gt;Array.prototype&lt;/code&gt; 中 ，那么您将得到奇怪的结果。 您希望此循环运行三次的位置：</target>
        </trans-unit>
        <trans-unit id="48512dd4b3a3c1f7350ccbc046b3e86d288aef9a" translate="yes" xml:space="preserve">
          <source>JavaScript will automatically determine the way its passes through the items. So if you know that your array is really non-associative you can use &lt;code&gt;for (var i=0; i&amp;lt;=arrayLen; i++)&lt;/code&gt;, and skip the auto-detection iteration.</source>
          <target state="translated">JavaScript将自动确定其通过项目的方式。 因此，如果您知道数组实际上是非关联的，则可以将其 &lt;code&gt;for (var i=0; i&amp;lt;=arrayLen; i++)&lt;/code&gt; ，并跳过自动检测迭代。</target>
        </trans-unit>
        <trans-unit id="2f7f0686684ed446fc32930174e01f5395bb10e0" translate="yes" xml:space="preserve">
          <source>Like others have said, You might get keys which aren't in your array or that are inherited from the prototype. So if, let's say, a library adds a property to the Array or Object prototypes:</source>
          <target state="translated">就像其他人说的那样,你可能会得到不在数组中的键,或者是从原型中继承的键。所以,假设一个库在数组或对象原型中添加了一个属性。</target>
        </trans-unit>
        <trans-unit id="f45b5193da0aaa7c52cb48f0bc144438c2dff04a" translate="yes" xml:space="preserve">
          <source>Long answer: It's just not worth it...</source>
          <target state="translated">漫长的答案。就是不值得......</target>
        </trans-unit>
        <trans-unit id="5585fccb2ae308d5040fc4d2fff80a5c0290f3a8" translate="yes" xml:space="preserve">
          <source>Longer answer: It's just not worth it, even if sequential element order and optimal performance aren't required.</source>
          <target state="translated">较长的答案。就是不值得,即使不要求元素顺序和最佳性能,也是不值得的。</target>
        </trans-unit>
        <trans-unit id="2b171ef9d258336524bc78a30c41d1586e22ad24" translate="yes" xml:space="preserve">
          <source>Mainly two reasons:</source>
          <target state="translated">主要是两个原因。</target>
        </trans-unit>
        <trans-unit id="82155128d69281609acce32458fe028999ca1517" translate="yes" xml:space="preserve">
          <source>Note :</source>
          <target state="translated">注:</target>
        </trans-unit>
        <trans-unit id="af88e59767f8ff55e7690c17ad58d65f053bf1a9" translate="yes" xml:space="preserve">
          <source>Now we create a new Array();</source>
          <target state="translated">现在我们创建一个新的Array()。</target>
        </trans-unit>
        <trans-unit id="6e27c94a861aeaf1d0ac22ebe6d7a6026d13e8c7" translate="yes" xml:space="preserve">
          <source>OK, let's do it with &lt;strong&gt;Array&lt;/strong&gt; now:</source>
          <target state="translated">好的，让我们现在使用&lt;strong&gt;Array进行操作&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="56bdfee68984425cbf940d97eb5ac6566ed73d68" translate="yes" xml:space="preserve">
          <source>Of course, this can easily be overcome by including</source>
          <target state="translated">当然,这一点可以很容易克服,可以通过加入</target>
        </trans-unit>
        <trans-unit id="861d60bb59642c4abc4400719fd6c6e81961b6fa" translate="yes" xml:space="preserve">
          <source>One can check the value of a properties' enumerable property attribute by:</source>
          <target state="translated">可以通过以下方法检查属性的可数属性属性的值。</target>
        </trans-unit>
        <trans-unit id="ee3c6cf9a9fbe4ea8fa522f3b09dbeb432226060" translate="yes" xml:space="preserve">
          <source>Or to obtain all four property attributes:</source>
          <target state="translated">或者获得全部四种属性的属性。</target>
        </trans-unit>
        <trans-unit id="6b7fb34e41e8a58c247a862c50d777d11e97a216" translate="yes" xml:space="preserve">
          <source>See below that the first two loops only execute the console.log statements once, while the standard for loop executes the function as many times as specified, in this case, array.length = 6.</source>
          <target state="translated">请看下面,前两个循环只执行一次console.log语句,而标准的for循环按指定的次数执行函数,在本例中,array.length=6。</target>
        </trans-unit>
        <trans-unit id="d916bf343fb39f0ba6d742b44d8afd005717534b" translate="yes" xml:space="preserve">
          <source>Short answer: It's just not worth it.</source>
          <target state="translated">简单的回答是:就是不值得。</target>
        </trans-unit>
        <trans-unit id="28d26e832aa07432925257b320c040f95173eadb" translate="yes" xml:space="preserve">
          <source>Since JavaScript elements are saved as standard object properties, it
  is not advisable to iterate through JavaScript arrays using for...in
  loops because normal elements and all enumerable properties will be
  listed.</source>
          <target state="translated">由于JavaScript元素被保存为标准的对象属性,所以不建议使用for...in循环迭代JavaScript数组,因为正常的元素和所有的可枚举属性都会被列出。</target>
        </trans-unit>
        <trans-unit id="4a9c0e2640786d86947354f29810a2bec59ff248" translate="yes" xml:space="preserve">
          <source>So that's one of the reasons why we need to use &lt;strong&gt;for..in&lt;/strong&gt; carefully, but it's not always the case...</source>
          <target state="translated">因此，这就是我们需要谨慎使用&lt;strong&gt;..in&lt;/strong&gt;的原因之一，但并非总是如此...</target>
        </trans-unit>
        <trans-unit id="43ccb63fe244a71ca951301d73d2ae606c309d0c" translate="yes" xml:space="preserve">
          <source>So you see.. &lt;code&gt;for in&lt;/code&gt; loop is now safe since you cared about your code.</source>
          <target state="translated">因此，您看到。for &lt;code&gt;for in&lt;/code&gt; 循环现在很安全，因为您关心代码。</target>
        </trans-unit>
        <trans-unit id="a856eaad5930fc3c1ad42c0a1072da1e9a71aa22" translate="yes" xml:space="preserve">
          <source>Some  JS frameworks, like Prototype modifies the Array prototype. Other frameworks like JQuery doesn't, so with JQuery you can safely use for-in.</source>
          <target state="translated">一些JS框架,如Prototype,修改了Array原型。其他框架如JQuery没有,所以用JQuery可以安全地使用for-in。</target>
        </trans-unit>
        <trans-unit id="241cc38f95d86d00578498c6cd6e9d8e3e40f7b1" translate="yes" xml:space="preserve">
          <source>That means if a browser wanted to, it could go through the properties in the order in which they were inserted.  Or in numerical order.  Or in lexical order (where &quot;30&quot; comes before &quot;4&quot;!  Keep in mind all object keys -- and thus, all array indexes -- are actually strings, so that makes total sense).  It could go through them by bucket, if it implemented objects as hash tables.  Or take any of that and add &quot;backwards&quot;.  A browser could even iterate &lt;em&gt;randomly&lt;/em&gt; and be ECMA-262 compliant, as long as it visited each property exactly once.</source>
          <target state="translated">这意味着，如果浏览器愿意，可以按插入属性的顺序浏览属性。 或按数字顺序。 或按词法顺序（&amp;ldquo; 30&amp;rdquo;在&amp;ldquo; 4&amp;rdquo;之前！！请记住，所有对象键-因此，所有数组索引-实际上都是字符串，因此完全有意义）。 如果将对象实现为哈希表，则可以按桶进行遍历。 或采取任何一种并添加&amp;ldquo;向后&amp;rdquo;。 只要浏览器恰好访问每个属性一次，它甚至可以&lt;em&gt;随机&lt;/em&gt;迭代并符合ECMA-262。</target>
        </trans-unit>
        <trans-unit id="4925097cf7b88e57feb64e9ce18adcce8750efa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-in&lt;/code&gt; statement by itself is not a &quot;bad practice&quot;, however it can be &lt;em&gt;mis-used&lt;/em&gt;, for example, to &lt;em&gt;iterate&lt;/em&gt; over arrays or array-like objects.</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; 语句本身并不是一个&amp;ldquo;坏习惯&amp;rdquo;，但是它可能被&lt;em&gt;滥用&lt;/em&gt; ，例如，在数组或类似数组的对象上进行&lt;em&gt;迭代&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="62abc57f4ad07e973cfe4762c0071680716cdbbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; works with two types of variables: hashtables (associative arrays) and array (non-associative).</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; 使用两种类型的变量：哈希表（关联数组）和数组（非关联）。</target>
        </trans-unit>
        <trans-unit id="a4e5b7446e20249c9f271cc6a796ffd24079b6d5" translate="yes" xml:space="preserve">
          <source>The console shows:</source>
          <target state="translated">控制台显示。</target>
        </trans-unit>
        <trans-unit id="c373dd9dcd853eabd38b0b011d5e2e23c21a3f2d" translate="yes" xml:space="preserve">
          <source>The mechanics and &lt;strong&gt;order&lt;/strong&gt; of enumerating the properties ... &lt;strong&gt;is not specified&lt;/strong&gt;...</source>
          <target state="translated">&lt;strong&gt;未指定&lt;/strong&gt;枚举属性的机制和&lt;strong&gt;顺序&lt;/strong&gt; ...</target>
        </trans-unit>
        <trans-unit id="288b516678cca5f53f82af2e6b9622249813364e" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;for ... in ...&lt;/code&gt; &amp;mdash; and this only becomes a problem when a programmer doesn't really understand the language; it's not really a bug or anything &amp;mdash; is that it iterates over &lt;em&gt;all&lt;/em&gt; members of an object (well, all &lt;em&gt;enumerable&lt;/em&gt; members, but that's a detail for now).  When you want to iterate over &lt;em&gt;just&lt;/em&gt; the indexed properties of an array, the only guaranteed way to keep things semantically consistent is to use an integer index (that is, a &lt;code&gt;for (var i = 0; i &amp;lt; array.length; ++i)&lt;/code&gt; style loop).</source>
          <target state="translated">&lt;code&gt;for ... in ...&lt;/code&gt; 的问题&amp;ndash;仅在程序员不真正理解该语言时才成为问题。 它并不是真正的bug或其他任何东西，而是它遍历对象的&lt;em&gt;所有&lt;/em&gt;成员（嗯，所有&lt;em&gt;可枚举的&lt;/em&gt;成员，但这是现在的细节）。 当您只想遍历数组的索引属性时，唯一可以保证语义一致的方法是使用整数索引（即， &lt;code&gt;for (var i = 0; i &amp;lt; array.length; ++i)&lt;/code&gt; 样式循环）。</target>
        </trans-unit>
        <trans-unit id="f366257c93fa147fea297156a165fc8f6425c44c" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;for-in&lt;/code&gt; statement is to &lt;em&gt;enumerate&lt;/em&gt; over object properties. This statement will go up in the prototype chain, also enumerating over &lt;em&gt;inherited&lt;/em&gt; properties, a thing that &lt;em&gt;sometimes&lt;/em&gt; is not desired.</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; 语句的目的是&lt;em&gt;枚举&lt;/em&gt;对象属性。 该语句将出现在原型链中，还会枚举&lt;em&gt;继承的&lt;/em&gt;属性，这&lt;em&gt;有时&lt;/em&gt;是不希望的。</target>
        </trans-unit>
        <trans-unit id="89a42ff68b32c1edc7f8b93e5041095c61ebc5a0" translate="yes" xml:space="preserve">
          <source>The reason is that one construct:</source>
          <target state="translated">原因是,一个构造。</target>
        </trans-unit>
        <trans-unit id="5da49b7ae2a0921436ddcfd460a1e53611ffa346" translate="yes" xml:space="preserve">
          <source>Then the array have two items, but a length of 101. Using for-in will yield two indexes, while the for-loop will yield 101 indexes, where the 99 has a value of &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">然后该数组有两个项目，但长度为101。使用for-in将产生两个索引，而for-loop将产生101个索引，其中99的值为 &lt;code&gt;undefined&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19e517ee8dfd19dc33ba7657aca3b885dc791954" translate="yes" xml:space="preserve">
          <source>There are three reasons why you shouldn't use &lt;code&gt;for..in&lt;/code&gt; to iterate over array elements:</source>
          <target state="translated">为什么不应该使用 &lt;code&gt;for..in&lt;/code&gt; 遍历数组元素的原因有三个：</target>
        </trans-unit>
        <trans-unit id="0e72dc9f7dbd7a51c36c0e6a445eeb0e565c1d45" translate="yes" xml:space="preserve">
          <source>This is a feature available in ECMAScript 5 - in earlier versions it was not possible to alter the value of the enumerable property attribute (it was always set to true).</source>
          <target state="translated">这是ECMAScript 5中的一个功能--在早期版本中,无法改变可数属性属性的值(它总是被设置为true)。</target>
        </trans-unit>
        <trans-unit id="c340939eba6baf47234d9046c52b928e6cf080c5" translate="yes" xml:space="preserve">
          <source>This will write:</source>
          <target state="translated">这个会写。</target>
        </trans-unit>
        <trans-unit id="5926b3627ee73db27b2bc9423c0585f3650b0163" translate="yes" xml:space="preserve">
          <source>Unfortunately, no version of Internet Explorer supports &lt;code&gt;for...of&lt;/code&gt; (&lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;Edge 12+&lt;/a&gt; does), so you'll have to wait a bit longer until you can use it in your client side production code. However, it should be safe to use in your server side JS code (if you use &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt;).</source>
          <target state="translated">不幸的是，Internet Explorer没有任何版本支持 &lt;code&gt;for...of&lt;/code&gt; （ &lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;Edge 12+&lt;/a&gt;支持），因此您必须等待更长的时间才能在客户端生产代码中使用它。 但是，在服务器端JS代码中使用它应该是安全的（如果使用&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="00554097d82380cea803eeb8bfd41d05a2d514a3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;for (var property in array)&lt;/code&gt; will cause &lt;code&gt;array&lt;/code&gt; to be iterated over as an &lt;em&gt;object&lt;/em&gt;, traversing the object prototype chain and ultimately performing slower than an index-based &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">使用 &lt;code&gt;for (var property in array)&lt;/code&gt; 将使 &lt;code&gt;array&lt;/code&gt; 作为&lt;em&gt;对象&lt;/em&gt;进行迭代，遍历对象原型链，最终执行的速度比基于索引的 &lt;code&gt;for&lt;/code&gt; 循环慢。</target>
        </trans-unit>
        <trans-unit id="9c96a1056df973395a0c429bef208a88ee62a434" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;hasOwnProperty()&lt;/code&gt; and &lt;code&gt;!isNaN()&lt;/code&gt; checks to filter the object properties is an additional overhead causing it to perform even slower and negates the key reason for using it in the first place, i.e. because of the more concise format.</source>
          <target state="translated">使用 &lt;code&gt;hasOwnProperty()&lt;/code&gt; 和 &lt;code&gt;!isNaN()&lt;/code&gt; 检查来过滤对象属性是一个额外的开销，这导致它执行得更慢，并且首先否定了使用它的关键原因，即由于格式更加简洁。</target>
        </trans-unit>
        <trans-unit id="918fbcebd19b214ca6c6ed8e07393e70c7d695f3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;for...in&lt;/code&gt; loop for an array is not wrong, although I can guess why someone told you that:</source>
          <target state="translated">对数组使用 &lt;code&gt;for...in&lt;/code&gt; 循环是没有错的，尽管我可以猜测为什么有人告诉您：</target>
        </trans-unit>
        <trans-unit id="bc913488828c3bcac109d7fea4f36a8fb9fb9d46" translate="yes" xml:space="preserve">
          <source>Usually the order of the items in an array is important, but the for-in loop won't necessarily iterate in the right order, that's because it treats the array as an object, which is the way it is implemented in JS, and not as an array.
This seems like a small thing, but it can really screw up applications and is hard to debug.</source>
          <target state="translated">通常情况下,数组中项的顺序很重要,但是for-in循环不一定会按照正确的顺序进行迭代,这是因为它把数组作为一个对象来对待,这在JS中是这样实现的,而不是作为一个数组。这看似是一件小事,但确实会把应用搞得一团糟,而且很难调试。</target>
        </trans-unit>
        <trans-unit id="149c70146186d5720fac2f29bfd0ada94cf61c04" translate="yes" xml:space="preserve">
          <source>When you want to enumerate only the &lt;em&gt;own properties&lt;/em&gt; of an object (the ones that aren't inherited), you can use the &lt;code&gt;hasOwnProperty&lt;/code&gt; method:</source>
          <target state="translated">当您只想枚举对象&lt;em&gt;本身的属性&lt;/em&gt; （不继承&lt;em&gt;的属性&lt;/em&gt; ）时，可以使用 &lt;code&gt;hasOwnProperty&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="b64e58a83fb02454b1c9859d3d2932e652511b06" translate="yes" xml:space="preserve">
          <source>Why is using “for…in” with array iteration a bad idea</source>
          <target state="translated">为什么使用 &quot;for...in &quot;与数组迭代是个坏主意?</target>
        </trans-unit>
        <trans-unit id="0577fbc195c6a54c24c161142179133a755af8f0" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;for.. in&lt;/code&gt;, just be sure to check each property with &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;hasOwnProperty&lt;/a&gt;.</source>
          <target state="translated">您可以在中使用 &lt;code&gt;for.. in&lt;/code&gt; ，只需确保使用&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;hasOwnProperty&lt;/a&gt;检查每个属性。</target>
        </trans-unit>
        <trans-unit id="5dd7c262d3b63fe2406be4d0a3f7de7d6d43d204" translate="yes" xml:space="preserve">
          <source>You see the &lt;strong&gt;someoneelse&lt;/strong&gt;!!!... We actually looping through new Array object in this case!</source>
          <target state="translated">您会看到一个&lt;strong&gt;人&lt;/strong&gt; ！!!! ...在这种情况下，我们实际上在遍历新的Array对象！</target>
        </trans-unit>
        <trans-unit id="9c8ef39926fd73e765f1eb8ee4fa6bd53c3ec533" translate="yes" xml:space="preserve">
          <source>You should use the &lt;code&gt;for(var x in y)&lt;/code&gt; only on property lists, not on objects (as explained above).</source>
          <target state="translated">您仅应在属性列表上使用 &lt;code&gt;for(var x in y)&lt;/code&gt; ，而不能在对象上使用（如上所述）。</target>
        </trans-unit>
        <trans-unit id="a96bcd7cc3ea125e82ec1633c0c044086ec4d453" translate="yes" xml:space="preserve">
          <source>You'll get it as part of every array:</source>
          <target state="translated">你会得到它作为每个阵列的一部分。</target>
        </trans-unit>
        <trans-unit id="451738ae11c58dea638bd4da33b99df9b1367655" translate="yes" xml:space="preserve">
          <source>although not specifically addressed by this question, I would add that there's a very good reason not to ever use for...in with a &lt;code&gt;NodeList&lt;/code&gt; (as one would obtain from a &lt;code&gt;querySelectorAll&lt;/code&gt; call, as it doesn't see the returned elements at all, instead iterating only over the NodeList properties.</source>
          <target state="translated">尽管此问题未专门解决，但我想补充一下，有一个很好的理由，不要在 &lt;code&gt;NodeList&lt;/code&gt; 中使用...（因为它可以从 &lt;code&gt;querySelectorAll&lt;/code&gt; 调用中获取，因为它根本看不到返回的元素） ，而是仅在NodeList属性上进行迭代。</target>
        </trans-unit>
        <trans-unit id="b01218ba4e2077e27d32f94c86b9d176de94e14e" translate="yes" xml:space="preserve">
          <source>but this is true for iterating over any object with a for-in loop.</source>
          <target state="translated">但这对于任何有for-in循环的对象的迭代都是如此。</target>
        </trans-unit>
        <trans-unit id="409e3dd82374e4e55f29d3a98652e2ae85e1e66f" translate="yes" xml:space="preserve">
          <source>can sometimes be totally different from the other:</source>
          <target state="translated">有时可以完全不同的。</target>
        </trans-unit>
        <trans-unit id="d26272a8e99b364a53d8375d2aaf9e58565fdc59" translate="yes" xml:space="preserve">
          <source>in the case of a single result, I got:</source>
          <target state="translated">如果是单一的结果,我得到的是:</target>
        </trans-unit>
        <trans-unit id="da1ab8a35220f16c304ed232b0ce34d0d22e60c1" translate="yes" xml:space="preserve">
          <source>in the loop, but the first structure is more direct.</source>
          <target state="translated">循环中,但第一种结构更直接。</target>
        </trans-unit>
        <trans-unit id="38d998cc7ed3a4c5ac9f65bf863b7c90ce1fc902" translate="yes" xml:space="preserve">
          <source>it's slow because you have to walk all properties of the array object and its whole prototype chain and will still only get the property's name, ie to get the value, an additional lookup will be required</source>
          <target state="translated">这很慢,因为你必须走过数组对象的所有属性和它的整个原型链,并且仍然只能得到属性的名称,即要得到值,就需要额外的查询</target>
        </trans-unit>
        <trans-unit id="f34c97c6342dac87f71ff8d0ba7b7f737b6be403" translate="yes" xml:space="preserve">
          <source>whereas,</source>
          <target state="translated">whereas,</target>
        </trans-unit>
        <trans-unit id="7c5e58bccc2148f04b16afa5d9963af3bc3acc1b" translate="yes" xml:space="preserve">
          <source>which explained why my &lt;code&gt;for (node in nodes) node.href = newLink;&lt;/code&gt; was failing.</source>
          <target state="translated">这就解释了为什么我的 &lt;code&gt;for (node in nodes) node.href = newLink;&lt;/code&gt; 失败了。</target>
        </trans-unit>
        <trans-unit id="7c400da46a809de9bf574c312d350ee791784418" translate="yes" xml:space="preserve">
          <source>will write</source>
          <target state="translated">会写</target>
        </trans-unit>
        <trans-unit id="5c923b1cf4e840a71705024b687048a1b3731fba" translate="yes" xml:space="preserve">
          <source>you could solve this with the hasOwnProperty method:</source>
          <target state="translated">你可以用hasOwnProperty方法解决这个问题。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
