<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/500504">
    <body>
      <group id="500504">
        <trans-unit id="4bd6398b6ec50d16e0ba8b718869fa0726943b47" translate="yes" xml:space="preserve">
          <source>(Emphasis mine.)</source>
          <target state="translated">(Emphasis mine.)</target>
        </trans-unit>
        <trans-unit id="d8063be2dd09276b0e12dbda5c629337424e931e" translate="yes" xml:space="preserve">
          <source>1.) There is already a higher order function, or method, that has that purpose for an array, but has more functionality and leaner syntax, called 'forEach': &lt;code&gt;Array.prototype.forEach(function(element, index, array) {} );&lt;/code&gt;</source>
          <target state="translated">1.) 배열에 대한 목적을 가지고 있지만 'forEach'라는 더 많은 기능과 더 적은 구문을 갖는 고차 함수 또는 메소드가 이미 있습니다. &lt;code&gt;Array.prototype.forEach(function(element, index, array) {} );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f5212d015eaea70f541c879dc9a1ee3ee6ea4e6" translate="yes" xml:space="preserve">
          <source>2.) Arrays always have a length, but &lt;code&gt;for...in&lt;/code&gt; and &lt;code&gt;forEach&lt;/code&gt; do not execute a function for any value that is &lt;code&gt;'undefined'&lt;/code&gt;, only for the indexes that have a value defined. So if you only assign one value, these loops will only execute a function once, but since an array is enumerated, it will always have a length up to the highest index that has a defined value, but that length could go unnoticed when using these loops.</source>
          <target state="translated">2.) 배열은 항상 길이가 있지만 &lt;code&gt;for...in&lt;/code&gt; 및 &lt;code&gt;forEach&lt;/code&gt; 는 값이 &lt;code&gt;'undefined'&lt;/code&gt; 인덱스에 대해서만 'undefined' 값에 대해 함수를 실행하지 않습니다. 따라서 하나의 값만 할당하면 이러한 루프는 함수를 한 번만 실행하지만 배열이 열거되므로 항상 정의 된 값을 갖는 가장 높은 색인까지의 길이를 갖지만이 값을 사용할 때 해당 길이는 눈에 띄지 않을 수 있습니다 루프.</target>
        </trans-unit>
        <trans-unit id="1a000b47a2784ab5959eeb6bb68516347e56d65f" translate="yes" xml:space="preserve">
          <source>3.) The standard for loop will execute a function as many times as you define in the parameters, and since an array is numbered, it makes more sense to define how many times you want to execute a function. Unlike the other loops, the for loop can then execute a function for every index in the array, whether the value is defined or not.</source>
          <target state="translated">3.) 표준 for 루프는 매개 변수에서 정의한 횟수만큼 함수를 실행하며 배열에 번호가 매겨 지므로 함수를 실행할 횟수를 정의하는 것이 더 합리적입니다. 다른 루프와 달리 for 루프는 값의 정의 여부에 관계없이 배열의 모든 인덱스에 대해 함수를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85146881dc047a08449a004a02b095cacd0cb609" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for (... in ...)&lt;/code&gt; is not guaranteed to return the object properties in sequential order, as one might expect.</source>
          <target state="translated">&lt;code&gt;for (... in ...)&lt;/code&gt; 는 예상대로 객체 속성을 순차적으로 반환한다고 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7fb489c373f09f65363d8fdde0d33f885cc248d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; lists only the &lt;code&gt;5&lt;/code&gt;, ignoring undefined array indexes, but adding &lt;code&gt;foo&lt;/code&gt;. It shows array &lt;strong&gt;property names&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 은 정의되지 않은 배열 인덱스를 무시하고 &lt;code&gt;foo&lt;/code&gt; 를 추가하여 &lt;code&gt;5&lt;/code&gt; 만 나열합니다. 배열 &lt;strong&gt;속성 이름을&lt;/strong&gt; 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7c070578b97dc889d040320474709963bba8ff11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops &lt;strong&gt;do not guarantee a specific iteration order&lt;/strong&gt;. Although is order is usually seen in most modern browsers these days, there is still no 100% guarantee.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 루프 &lt;strong&gt;는 특정 반복 순서를 보장하지 않습니다&lt;/strong&gt; . 요즘은 대부분의 최신 브라우저에서 일반적으로 주문이 표시되지만 100 % 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="75add2a4d0fc3dfc08d7b2e03792fa72128dc96e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops ignore &lt;code&gt;undefined&lt;/code&gt; array elements, i.e. array elements which not have been assigned yet.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 루프는 &lt;code&gt;undefined&lt;/code&gt; 배열 요소, 즉 아직 할당 되지 않은 배열 요소를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="e02c78b83b9baae453efbdb0e530f06924f7cb8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops iterate over all their own enumerable properties &lt;strong&gt;and&lt;/strong&gt; the enumerable properties of their prototype(s). Usually in an array iteration we only want to iterate over the array itself. And even though you yourself may not add anything to the array, your libraries or framework might add something.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 루프는 자체 열거 가능한 모든 속성 &lt;strong&gt;과&lt;/strong&gt; 프로토 타입의 열거 가능한 속성을 반복합니다. 일반적으로 배열 반복에서는 배열 자체 만 반복하려고합니다. 배열에 아무것도 추가하지 않아도 라이브러리 나 프레임 워크에 무언가가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b510d520668177a37ca1233fffcce16d554bed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...of&lt;/code&gt; counts from 0 to 5, and also ignores &lt;code&gt;Array.prototype.foo&lt;/code&gt;. It shows array &lt;strong&gt;values&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;for...of&lt;/code&gt; 는 0에서 5까지 카운트되며 &lt;code&gt;Array.prototype.foo&lt;/code&gt; 도 무시합니다. 배열 &lt;strong&gt;값을&lt;/strong&gt; 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="de8d59ac496d49a3cc2830db61e5080ba7b3ed4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; isn't guaranteed to preserve element ordering</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; 은 요소 순서를 유지한다고 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57c504b07cbe053e6d9258c6e6ce9dab71001517" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; will loop over all own and inherited properties of the array object which aren't &lt;code&gt;DontEnum&lt;/code&gt;; that means if someone adds properties to the specific array object (there are valid reasons for this - I've done so myself) or changed &lt;code&gt;Array.prototype&lt;/code&gt; (which is considered bad practice in code which is supposed to work well with other scripts), these properties will be iterated over as well; inherited properties can be excluded by checking &lt;code&gt;hasOwnProperty()&lt;/code&gt;, but that won't help you with properties set in the array object itself</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; 은 &lt;code&gt;DontEnum&lt;/code&gt; 이 아닌 배열 객체의 모든 상속 속성을 반복합니다 . 그것은 누군가가 특정 배열 객체에 속성을 추가하거나 (이에 대한 정당한 이유가 있습니다) 직접 변경했거나 &lt;code&gt;Array.prototype&lt;/code&gt; (다른 스크립트와 잘 작동하는 코드에서 나쁜 습관으로 간주 됨)을 변경했음을 의미합니다. 이 속성들도 반복 될 것입니다; 상속 된 속성은 &lt;code&gt;hasOwnProperty()&lt;/code&gt; 를 확인하여 제외 할 수 있지만 배열 객체 자체에 설정된 속성에는 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c924ba7b90dce15af127843f7697ca7dc50c687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b0a4e9b74e35d5bb4223b2cc511f2cfc42e49e60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="ed70972dc116b90558966dcf0dc7a880652a1079" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It loops through inherited properties as well:&lt;/strong&gt; First of all any extensions to the &lt;code&gt;Array.prototype&lt;/code&gt; should have been done by using &lt;a href=&quot;https://developer.mozilla.org/tr/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt; and their &lt;code&gt;enumerable&lt;/code&gt; descriptor should be set to &lt;code&gt;false&lt;/code&gt;. Any library not doing so should not be used at all.</source>
          <target state="translated">&lt;strong&gt;상속 된 속성도 반복합니다.&lt;/strong&gt; 먼저 &lt;code&gt;Array.prototype&lt;/code&gt; 에 대한 모든 확장은 &lt;a href=&quot;https://developer.mozilla.org/tr/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt; 를 사용하여 수행되어야하며 &lt;code&gt;enumerable&lt;/code&gt; 설명자는 &lt;code&gt;false&lt;/code&gt; 로 설정되어야합니다. 그렇게하지 않은 라이브러리는 전혀 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="864471cf89b4825cee0c68d43263743a49b07aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;One&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;One&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2930f375e598c4c0cda99ef5ee5ced807b11895f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Properties those you add to the inheritance chain later get counted:&lt;/strong&gt; When doing array sub-classing by &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or by Class &lt;code&gt;extend&lt;/code&gt;. You should again use &lt;code&gt;Object.defineProperty()&lt;/code&gt; which by default sets the &lt;code&gt;writable&lt;/code&gt;, &lt;code&gt;enumerable&lt;/code&gt; and &lt;code&gt;configurable&lt;/code&gt; property descriptors to &lt;code&gt;false&lt;/code&gt;. Lets see an array sub-classing example here...</source>
          <target state="translated">&lt;strong&gt;상속 체인에 추가 한 속성은 나중에 계산됩니다.&lt;/strong&gt; &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; 또는 Class &lt;code&gt;extend&lt;/code&gt; 로 배열 서브 클래 싱을 수행 할 때. 기본적으로 &lt;code&gt;writable&lt;/code&gt; 하고 &lt;code&gt;enumerable&lt;/code&gt; 하며 &lt;code&gt;configurable&lt;/code&gt; 가능한 속성 설명자를 &lt;code&gt;false&lt;/code&gt; 로 설정하는 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 를 사용해야합니다. 여기에서 배열 서브 클래 싱 예제를 보자 ...</target>
        </trans-unit>
        <trans-unit id="1d17c64273e3caf29ac784b4ed9036aa7703f21e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL&amp;amp;DR:&lt;/strong&gt; Using the &lt;code&gt;for in&lt;/code&gt; loop in arrays is not evil, in fact quite the opposite.</source>
          <target state="translated">&lt;strong&gt;TL &amp;amp; DR :&lt;/strong&gt; 배열에서 &lt;code&gt;for in&lt;/code&gt; 루프를 사용하는 것은 실제로 그 반대가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f4a90667800dfac206439640fe039e0a8ec77ce8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;for in&lt;/code&gt; loop is slow:&lt;/strong&gt; Hell no. It's by far the fastest method of iteration if you are looping over sparse arrays which are needed time to time. This is one of the most important performance tricks that one should know. Let's see an example. We will loop over a sparse array.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;for in&lt;/code&gt; 루프는 느리다 :&lt;/strong&gt; 지옥 아니. 때때로 필요한 스파 스 어레이를 반복하는 경우 가장 빠른 반복 방법입니다. 이것은 알아야 할 가장 중요한 성능 트릭 중 하나입니다. 예를 보자. 희소 배열을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="7e70c28d46516e16a285932547326e3516ac248f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Two&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aa55c4c1ec6fa0600a16d8a1df0ed62aebb5a00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for...in&lt;/strong&gt; is useful when working on an object in JavaScript, but not for an Array, but still we can not say it's a wrong way, but it's not recommended, look at this example below using &lt;strong&gt;for...in&lt;/strong&gt; loop:</source>
          <target state="translated">&lt;strong&gt;for ... in&lt;/strong&gt; 은 JavaScript에서 객체를 작업 할 때 유용하지만 Array에서는 유용하지 않지만 여전히 잘못된 방법이라고 말할 수는 없지만 권장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="723137f7795e3401755b70d4616c338ef4c6b6e9" translate="yes" xml:space="preserve">
          <source>A for...in loop always enumerates the keys.
Objects properties keys are always String, even the indexed properties of an array :</source>
          <target state="translated">for ... in 루프는 항상 키를 열거합니다. 객체 속성 키는 배열의 색인 속성을 포함하여 항상 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e380bf6c22148b057e16f813b7f95eb85c229ee9" translate="yes" xml:space="preserve">
          <source>A real answer for this will depend on how the browser parsers/interpret the JavaScript code. It can change between browsers.</source>
          <target state="translated">이에 대한 진정한 대답은 브라우저가 JavaScript 코드를 파서 / 해석하는 방법에 달려 있습니다. 브라우저간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8ee733770af90d6a036b73e38df85ea12e55c2" translate="yes" xml:space="preserve">
          <source>Also consider that &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; libraries might do things like this, which will affect any array you create:</source>
          <target state="translated">또한 &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; 라이브러리는 다음과 같은 작업을 수행하여 생성하는 모든 배열에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81a354e95f9aef67cb843763fd3927258da5fdda" translate="yes" xml:space="preserve">
          <source>Also, due to semantics, the way &lt;code&gt;for, in&lt;/code&gt; treats arrays (i.e. the same as any other JavaScript object) is not aligned with other popular languages.</source>
          <target state="translated">또한 의미론으로 인해 &lt;code&gt;for, in&lt;/code&gt; 취급 에서 (즉, 다른 JavaScript 객체와 동일) 취급 방식 은 다른 인기있는 언어와 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56813a034610fd55b9667a342f05765d16c2560a" translate="yes" xml:space="preserve">
          <source>Also, it may be considered a better practice to use the &lt;code&gt;forEach&lt;/code&gt; method than the &lt;code&gt;for...in&lt;/code&gt; loop in general, because it is easier to write and has more functionality, so you may want to get in the habit of only using this method and standard for, but your call.</source>
          <target state="translated">또한 작성하기 쉽고 기능이 더 많기 때문에 일반적으로 &lt;code&gt;for...in&lt;/code&gt; 루프보다 &lt;code&gt;forEach&lt;/code&gt; 메소드를 사용하는 것이 더 나은 방법으로 간주 될 수 있습니다 . 그리고 당신의 전화에 대한 표준.</target>
        </trans-unit>
        <trans-unit id="8e9ef6ce457a097e6cbaa9a5cee537865b67b8ae" translate="yes" xml:space="preserve">
          <source>Also, speaking about inherited properties, if you, for example, extend the &lt;code&gt;Array.prototype&lt;/code&gt; object (like some libraries as MooTools do), that properties will be also enumerated:</source>
          <target state="translated">또한 상속 된 속성에 대해 말하면 (예를 들어 MooTools와 같은 일부 라이브러리와 같이) &lt;code&gt;Array.prototype&lt;/code&gt; 객체를 확장하면 해당 속성도 열거됩니다.</target>
        </trans-unit>
        <trans-unit id="77e8cec41cc494061a090fc5862a2f2e51506df4" translate="yes" xml:space="preserve">
          <source>Also, the order of iteration is not guaranteed by the spec., meaning that if you want to &quot;iterate&quot; an array object, with this statement you cannot be sure that the properties (array indexes) will be visited in the numeric order.</source>
          <target state="translated">또한 스펙에 의해 반복 순서가 보장되지는 않습니다. 즉,이 명령문을 사용하여 배열 오브젝트를 &quot;반복&quot;하려는 경우 특성 (배열 색인)이 숫자 순서대로 방문되는지 확신 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4caa9f9af0086837955f928c936648d78e3cf12c" translate="yes" xml:space="preserve">
          <source>An alternative way of iterating through an array is using a for-loop:</source>
          <target state="translated">배열을 반복하는 다른 방법은 for-loop를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4330d9777faffc1aebc6faa887599a7ad547c366" translate="yes" xml:space="preserve">
          <source>An important aspect is that &lt;code&gt;for...in&lt;/code&gt; only iterates over properties contained in an object which have their &lt;strong&gt;enumerable&lt;/strong&gt;&lt;em&gt;property attribute&lt;/em&gt; set to true. So if one attempts to iterate over an object using &lt;code&gt;for...in&lt;/code&gt; then arbitrary properties may be missed if their enumerable property attribute is false. It is quite possible to alter the enumerable property attribute for normal Array objects so that certain elements are not enumerated. Though in general the property attributes tend to apply to function properties within an object.</source>
          <target state="translated">중요한 측면은 &lt;code&gt;for...in&lt;/code&gt; &lt;strong&gt;열거 가능한&lt;/strong&gt; &lt;em&gt;속성 속성&lt;/em&gt; 이 true로 설정된 객체에 포함 된 속성 만 반복한다는 것입니다. 따라서 &lt;code&gt;for...in&lt;/code&gt; 을 사용하여 객체를 반복하려고하면 열거 가능한 속성 속성이 false 인 경우 임의의 속성이 누락 될 수 있습니다. 특정 요소가 열거되지 않도록 일반 Array 객체의 열거 가능 속성 속성을 변경하는 것이 가능합니다. 일반적으로 속성 속성은 객체 내의 함수 속성에 적용되는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc123fed57544f574b847785e448b373aff2349" translate="yes" xml:space="preserve">
          <source>And since you can never be sure that nothing will be added to the prototype chain just use a for loop to enumerate the array:</source>
          <target state="translated">프로토 타입 체인에 아무것도 추가되지 않을 것이라고 확신 할 수 없으므로 for 루프를 사용하여 배열을 열거하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ad0c718b13ffaf815489fe18ec085881a6be06e3" translate="yes" xml:space="preserve">
          <source>And some people even recommend calling the method directly from &lt;code&gt;Object.prototype&lt;/code&gt; to avoid having problems if somebody adds a property named &lt;code&gt;hasOwnProperty&lt;/code&gt; to our object:</source>
          <target state="translated">그리고 어떤 사람들은 &lt;code&gt;hasOwnProperty&lt;/code&gt; 라는 속성을 객체에 추가 할 때 문제가 발생하지 않도록 &lt;code&gt;Object.prototype&lt;/code&gt; 에서 직접 메서드를 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="35888521210af7f9dd1e0af389345f2c1f605553" translate="yes" xml:space="preserve">
          <source>Any object can have arbitrary properties associated with it. There would be nothing terrible about loading additional properties onto an array instance, in particular. Code that wants to see &lt;em&gt;only&lt;/em&gt; indexed array-like properties therefore &lt;em&gt;must&lt;/em&gt; stick to an integer index. Code that is fully aware of what &lt;code&gt;for ... in&lt;/code&gt; does and really &lt;em&gt;need&lt;/em&gt; to see all properties, well then that's ok too.</source>
          <target state="translated">모든 객체는 이와 관련된 임의의 속성을 가질 수 있습니다. 특히 배열 인스턴스에 추가 속성을로드하는 데 끔찍한 일은 없습니다. 따라서 인덱스 배열과 유사한 속성 &lt;em&gt;만&lt;/em&gt; 보려는 코드는 정수 인덱스를 &lt;em&gt;사용해야합니다&lt;/em&gt; . 무엇을 &lt;code&gt;for ... in&lt;/code&gt; 무엇 을 알고 있고 실제로 모든 속성을 볼 &lt;em&gt;필요&lt;/em&gt; 가있는 코드는 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8ae256cf5a988279dae9f08c26581718bda89b9c" translate="yes" xml:space="preserve">
          <source>As I said before to &lt;em&gt;iterate&lt;/em&gt; over arrays or array-like objects, the best thing is to use a &lt;em&gt;sequential loop&lt;/em&gt;, such as a plain-old &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loop.</source>
          <target state="translated">앞서 배열이나 배열과 같은 객체를 &lt;em&gt;반복&lt;/em&gt; 하기 위해 말했듯이 가장 좋은 방법은 평범한 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 루프와 같은 &lt;em&gt;순차 루프&lt;/em&gt; 를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6223893ff2388e165f873960bac2ba5392b49cb2" translate="yes" xml:space="preserve">
          <source>As of 2016 (ES6) we may use &lt;code&gt;for&amp;hellip;of&lt;/code&gt; for array iteration, as John Slegers already noticed.</source>
          <target state="translated">John Slegers가 이미 알고 있듯이 2016 (ES6) 기준으로 배열 반복에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ffc247af1b8ed568d6b5c1b3a27e66e602fc7e" translate="yes" xml:space="preserve">
          <source>As you see the result the same...</source>
          <target state="translated">결과가 동일하게 보이면 ...</target>
        </trans-unit>
        <trans-unit id="894f0d6f0a5dc7e6d9477fd432341a08cc075bbf" translate="yes" xml:space="preserve">
          <source>Aside from the fact that &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; loops over all enumerable properties (which is &lt;em&gt;not&lt;/em&gt; the same as &quot;all array elements&quot;!), see &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&quot;&gt;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&lt;/a&gt;, section 12.6.4 (5th edition) or 13.7.5.15 (7th edition):</source>
          <target state="translated">열거 가능한 모든 속성 ( &quot;모든 배열 요소&quot;와 동일 &lt;em&gt;하지 않음&lt;/em&gt; !) &lt;code&gt;in&lt;/code&gt; 반복하는 경우는 &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&quot;&gt;http://www.ecma-international.org/publications/files/ECMA-ST를&lt;/a&gt; 참조하십시오 . /Ecma-262.pdf , 섹션 12.6.4 (5 판) 또는 13.7.5.15 (7 판) :</target>
        </trans-unit>
        <trans-unit id="eb7d92e5a3d183746be4cc4443582416eca4294e" translate="yes" xml:space="preserve">
          <source>Because for...in enumerates through the object that holds the array, not the array itself. If I add a function to the arrays prototype chain, that will also be included. I.e.</source>
          <target state="translated">for ... in은 배열 자체가 아니라 배열을 보유하는 객체를 통해 열거하기 때문입니다. 배열 프로토 타입 체인에 함수를 추가하면 포함됩니다. 즉</target>
        </trans-unit>
        <trans-unit id="b96448a2e10a4868599ab0a74179eb46b603e8f6" translate="yes" xml:space="preserve">
          <source>Because it enumerates through object fields, not indexes. You can get value with index &quot;length&quot; and I doubt you want this.</source>
          <target state="translated">인덱스가 아닌 객체 필드를 통해 열거되기 때문에. 당신은 인덱스 &quot;길이&quot;로 가치를 얻을 수 있고 당신이 이것을 의심합니다.</target>
        </trans-unit>
        <trans-unit id="8992d96aafc9f0ab11805a540be31b57da2de068" translate="yes" xml:space="preserve">
          <source>Because it will iterate over properties belonging to objects up the prototype chain if you're not careful.</source>
          <target state="translated">주의하지 않으면 프로토 타입 체인의 객체에 속하는 속성을 반복하므로</target>
        </trans-unit>
        <trans-unit id="ee90f63ccf1f6222ef3e10f7c081882454ec920d" translate="yes" xml:space="preserve">
          <source>But in my opinion, it's better to use &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;, the process required for that auto-detection is very small.</source>
          <target state="translated">그러나 내 의견으로 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; 에 사용 하는 것이 좋습니다. 자동 감지에 필요한 프로세스는 매우 작습니다.</target>
        </trans-unit>
        <trans-unit id="12279b51e8d023c0ad5031c9a0b1e701ef3132e1" translate="yes" xml:space="preserve">
          <source>But let's try something, let's prototype something to &lt;strong&gt;Array&lt;/strong&gt;...</source>
          <target state="translated">그러나 무언가를 시도해 보자.</target>
        </trans-unit>
        <trans-unit id="43740775866432b484bee9f9cd495c479fdafbb1" translate="yes" xml:space="preserve">
          <source>Either way, &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; carries with it no connotation of order.  If you care about order, be explicit about it and use a regular &lt;code&gt;for&lt;/code&gt; loop with an index.</source>
          <target state="translated">어느 쪽이든, ... &lt;code&gt;in&lt;/code&gt; 대해서는 순서의 의미가 없습니다. 순서에 관심이 있다면 명시 적으로 확인하고 색인과 함께 정기적 인 &lt;code&gt;for&lt;/code&gt; 루프를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="0f0d139be39da72d26c2fc44d8e9127747d60e99" translate="yes" xml:space="preserve">
          <source>For example, in JScript (IE &amp;lt;= 8), the order of enumeration even on Array objects is defined as the properties were created:</source>
          <target state="translated">예를 들어, JScript (IE &amp;lt;= 8)에서 Array 객체에서도 열거 순서는 속성이 만들어 짐에 따라 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2428f10d15c193c4c3f102bd0050a7d4e2a6f520" translate="yes" xml:space="preserve">
          <source>For these reasons an acceptable trade-off between performance and convenience doesn't even exist.  There's really no benefit unless the intent is to handle the array as an &lt;em&gt;object&lt;/em&gt; and perform operations on the object properties of the array.</source>
          <target state="translated">이러한 이유로 성능과 편의성 사이에 적절한 균형이 존재하지 않습니다. 배열을 &lt;em&gt;객체&lt;/em&gt; 로 처리하고 배열의 객체 속성에 대한 작업을 수행하지 않는 한 실제로 이점은 없습니다.</target>
        </trans-unit>
        <trans-unit id="32b5cb0e39239e899eede9d898b826f9b8871c75" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections에서&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68c380cf4529191d6c4d7cbc7090efd3852b6892" translate="yes" xml:space="preserve">
          <source>Here are the reasons why this is (usually) a bad practice:</source>
          <target state="translated">이것이 (보통) 나쁜 습관 인 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8800cd23cee45b4bed05921ce5f6db9ef6fde066" translate="yes" xml:space="preserve">
          <source>However, if your code (or the framework you are using) add custom properties to arrays or to the array prototype, then these properties will be included in the iteration, which is probably not what you want.</source>
          <target state="translated">그러나 코드 (또는 사용중인 프레임 워크)가 사용자 지정 속성을 배열 또는 배열 프로토 타입에 추가하면 이러한 속성이 반복에 포함되며 이는 아마도 원하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3f41c8e3bf1d0164c41613e45d4575733160cd11" translate="yes" xml:space="preserve">
          <source>However, this have a different issue. The issue is that a JavaScript array can have &quot;holes&quot;. If you define &lt;code&gt;arr&lt;/code&gt; as:</source>
          <target state="translated">그러나 이것은 다른 문제가 있습니다. 문제는 JavaScript 배열에 &quot;구멍&quot;이있을 수 있다는 것입니다. &lt;code&gt;arr&lt;/code&gt; 을 다음과 같이 정의하면 :</target>
        </trans-unit>
        <trans-unit id="4609f4613ee2485b87e9ea3693f15a345fdc5bff" translate="yes" xml:space="preserve">
          <source>I can't think of other purposes to not using &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;;</source>
          <target state="translated">나는 / &lt;code&gt;in&lt;/code&gt; 을 사용하지 않는 다른 목적을 생각할 수 없다.</target>
        </trans-unit>
        <trans-unit id="c84398cbe7864ec7d29debf086fe632c20a743ee" translate="yes" xml:space="preserve">
          <source>I do, however, would like to add that &lt;strong&gt;in modern browsers&lt;/strong&gt; there is an alternative to &lt;code&gt;for...in&lt;/code&gt; that can be used in those cases where &lt;code&gt;for...in&lt;/code&gt; can't be used. That alternative is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/a&gt; :</source>
          <target state="translated">그러나 &lt;strong&gt;현대 브라우저&lt;/strong&gt; 에는 &lt;code&gt;for...in&lt;/code&gt; 사용할 수없는 경우에 사용할 수있는 &lt;code&gt;for...in&lt;/code&gt; 대안이 있다고 덧붙이고 싶습니다. 그 대안은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3b3a26ba9647b9bce83a99b6dd6343035cd56ae" translate="yes" xml:space="preserve">
          <source>I don't think I have much to add to eg. &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/500531#500531&quot;&gt;Triptych's answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/4261096#4261096&quot;&gt;CMS's answer&lt;/a&gt; on why using &lt;code&gt;for...in&lt;/code&gt; should be avoided in some cases.</source>
          <target state="translated">나는 예를 들어 추가해야 할 것이 많지 않다고 생각합니다. &lt;code&gt;for...in&lt;/code&gt; 사용하는 이유에 &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/500531#500531&quot;&gt;대한 Triptych의 답변&lt;/a&gt; 또는 &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/4261096#4261096&quot;&gt;CMS의 답변&lt;/a&gt; 은 경우에 따라 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd3028b86fe1e48337d81eff923a6ece9b04e2b8" translate="yes" xml:space="preserve">
          <source>I think the &lt;code&gt;for in&lt;/code&gt; loop is a gem of JS if used &lt;em&gt;correctly&lt;/em&gt; in arrays. You are expected to have full control over your software and know what you are doing. Let's see the mentioned drawbacks and disprove them one by one.</source>
          <target state="translated">배열에서 &lt;em&gt;올바르게&lt;/em&gt; 사용하면 &lt;code&gt;for in&lt;/code&gt; 루프가 JS의 보석이라고 생각합니다. 소프트웨어를 완전히 제어하고 수행중인 작업을 알고 있어야합니다. 언급 된 단점을보고 하나씩 반증 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="3c5457f2a9b947636475a19d3f1132040b65b1d3" translate="yes" xml:space="preserve">
          <source>I would just like to add this simple demonstration code, to make things clearer:</source>
          <target state="translated">이 간단한 데모 코드를 추가하여 더 명확하게 만들고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="64e3da07990d73da0857766c8c4119fdfa3d8581" translate="yes" xml:space="preserve">
          <source>I've been told not to use &lt;code&gt;for...in&lt;/code&gt; with arrays in JavaScript. Why not?</source>
          <target state="translated">JavaScript에서 배열과 함께 사용하지 말라고 들었습니다. 왜 안돼?</target>
        </trans-unit>
        <trans-unit id="97e955c989e786a9c59188ad385759593bc273f9" translate="yes" xml:space="preserve">
          <source>If a function called &lt;code&gt;helpfulUtilityMethod&lt;/code&gt; has been added to &lt;code&gt;Array&lt;/code&gt;'s &lt;code&gt;prototype&lt;/code&gt;, then your loop would end up running four times: &lt;code&gt;key&lt;/code&gt; would be &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;helpfulUtilityMethod&lt;/code&gt;.  If you were only expecting integers, oops.</source>
          <target state="translated">&lt;code&gt;helpfulUtilityMethod&lt;/code&gt; 라는 함수가 &lt;code&gt;Array&lt;/code&gt; 의 &lt;code&gt;prototype&lt;/code&gt; 에 추가 된 경우 루프는 4 번 실행됩니다. &lt;code&gt;key&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 및 &lt;code&gt;helpfulUtilityMethod&lt;/code&gt; 입니다. 정수 만 기대한다면 죄송합니다.</target>
        </trans-unit>
        <trans-unit id="36c04e2865843e125432c9e852edd02d54e879a0" translate="yes" xml:space="preserve">
          <source>If you are in doubt, you probably shouldn't use for-in.</source>
          <target state="translated">확실치 않다면 아마도 for-in을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3f9cf51b07160b61873b4313b13e4209e40cf8d3" translate="yes" xml:space="preserve">
          <source>In addition to the other problems, the &quot;for..in&quot; syntax is probably slower, because the index is a string, not an integer.</source>
          <target state="translated">다른 문제 외에도 인덱스가 정수가 아닌 문자열이기 때문에 &quot;for..in&quot;구문이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d7f89f56c3c8e5432b67de63d59ca4ec8daee20" translate="yes" xml:space="preserve">
          <source>In addition to the reasons given in other answers, you may not want to use the &quot;for...in&quot; structure if you need to do math with the counter variable because the loop iterates through the names of the object's properties and so the variable is a string.</source>
          <target state="translated">루프가 객체의 속성 이름과 변수를 반복하기 때문에 카운터 변수로 수학을 수행 해야하는 경우 다른 답변에 주어진 이유 외에도 &quot;for ... in&quot;구조를 사용하지 않을 수 있습니다 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="987fa132a1fc4549a83c1787f42d94ea85f4d2a2" translate="yes" xml:space="preserve">
          <source>In essence, you can use any loop, but you should remember exactly how they work. Understand the conditions upon which the different loops reiterate, their separate functionalities, and realize they will be more or less appropriate for differing scenarios.</source>
          <target state="translated">본질적으로 모든 루프를 사용할 수 있지만 작동 방식을 정확하게 기억해야합니다. 서로 다른 루프가 반복되는 조건과 개별 기능을 이해하고 서로 다른 시나리오에 다소 적합하다는 것을 인식하십시오.</target>
        </trans-unit>
        <trans-unit id="aec6fa3400776b4a7fb59542b27ba833e3407a93" translate="yes" xml:space="preserve">
          <source>In isolation, there is nothing wrong with using for-in on arrays. For-in iterates over the property names of an object, and in the case of an &quot;out-of-the-box&quot; array, the properties corresponds to the array indexes. (The built-in propertes like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;toString&lt;/code&gt; and so on are not included in the iteration.)</source>
          <target state="translated">격리에서 for-in을 사용하는 데 아무런 문제가 없습니다. For-in은 개체의 속성 이름을 반복하며 &quot;기본 제공&quot;배열의 경우 속성은 배열 인덱스에 해당합니다. &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;toString&lt;/code&gt; 등과 같은 기본 제공 속성은 반복에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">다시 말해:</target>
        </trans-unit>
        <trans-unit id="734568a26e2da175e7b2711963a36f6889e16233" translate="yes" xml:space="preserve">
          <source>In practice, most browsers currently like to iterate in roughly the same order.  But there's nothing saying they have to.  That's implementation specific, and could change at any time if another way was found to be far more efficient.</source>
          <target state="translated">실제로, 대부분의 브라우저는 현재 대략 동일한 순서로 반복하는 것을 좋아합니다. 그러나 그들이 할 말은 없습니다. 그것은 구현에 따라 다르며 다른 방법이 훨씬 더 효율적이라면 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63b585b5d4653967345fb2a5acb868a3bc4a2b69" translate="yes" xml:space="preserve">
          <source>It's not &lt;em&gt;necessarily&lt;/em&gt; bad (based on what you're doing), but in the case of arrays, if something has been added to &lt;code&gt;Array.prototype&lt;/code&gt;, then you're going to get strange results.  Where you'd expect this loop to run three times:</source>
          <target state="translated">&lt;em&gt;반드시 (&lt;/em&gt; 나쁜 일을 기반으로) 나쁘지는 않지만 배열의 경우 &lt;code&gt;Array.prototype&lt;/code&gt; 에 무언가가 추가되면 이상한 결과를 얻을 수 있습니다. 이 루프가 세 번 실행될 것으로 예상되는 위치 :</target>
        </trans-unit>
        <trans-unit id="48512dd4b3a3c1f7350ccbc046b3e86d288aef9a" translate="yes" xml:space="preserve">
          <source>JavaScript will automatically determine the way its passes through the items. So if you know that your array is really non-associative you can use &lt;code&gt;for (var i=0; i&amp;lt;=arrayLen; i++)&lt;/code&gt;, and skip the auto-detection iteration.</source>
          <target state="translated">JavaScript는 항목을 통과하는 방법을 자동으로 결정합니다. 따라서 배열이 실제로 비 연관 &lt;code&gt;for (var i=0; i&amp;lt;=arrayLen; i++)&lt;/code&gt; 을 알고 있다면 (var i = 0; i &amp;lt;= arrayLen; i ++) 에 사용할 수 있고 자동 감지 반복을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f7f0686684ed446fc32930174e01f5395bb10e0" translate="yes" xml:space="preserve">
          <source>Like others have said, You might get keys which aren't in your array or that are inherited from the prototype. So if, let's say, a library adds a property to the Array or Object prototypes:</source>
          <target state="translated">다른 사람들이 말했듯이 배열에 없거나 프로토 타입에서 상속받은 키를 얻을 수 있습니다. 예를 들어 라이브러리가 배열 또는 객체 프로토 타입에 속성을 추가한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f45b5193da0aaa7c52cb48f0bc144438c2dff04a" translate="yes" xml:space="preserve">
          <source>Long answer: It's just not worth it...</source>
          <target state="translated">긴 대답 : 가치가 없습니다 ...</target>
        </trans-unit>
        <trans-unit id="5585fccb2ae308d5040fc4d2fff80a5c0290f3a8" translate="yes" xml:space="preserve">
          <source>Longer answer: It's just not worth it, even if sequential element order and optimal performance aren't required.</source>
          <target state="translated">더 긴 대답 : 순차적 요소 순서와 최적의 성능이 필요하지 않더라도 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b171ef9d258336524bc78a30c41d1586e22ad24" translate="yes" xml:space="preserve">
          <source>Mainly two reasons:</source>
          <target state="translated">주로 두 가지 이유 :</target>
        </trans-unit>
        <trans-unit id="82155128d69281609acce32458fe028999ca1517" translate="yes" xml:space="preserve">
          <source>Note :</source>
          <target state="translated">노트 :</target>
        </trans-unit>
        <trans-unit id="af88e59767f8ff55e7690c17ad58d65f053bf1a9" translate="yes" xml:space="preserve">
          <source>Now we create a new Array();</source>
          <target state="translated">이제 새로운 Array ()를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6e27c94a861aeaf1d0ac22ebe6d7a6026d13e8c7" translate="yes" xml:space="preserve">
          <source>OK, let's do it with &lt;strong&gt;Array&lt;/strong&gt; now:</source>
          <target state="translated">자 이제 &lt;strong&gt;Array로&lt;/strong&gt; 해봅시다 :</target>
        </trans-unit>
        <trans-unit id="56bdfee68984425cbf940d97eb5ac6566ed73d68" translate="yes" xml:space="preserve">
          <source>Of course, this can easily be overcome by including</source>
          <target state="translated">물론 이것은 포함하여 쉽게 극복 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="861d60bb59642c4abc4400719fd6c6e81961b6fa" translate="yes" xml:space="preserve">
          <source>One can check the value of a properties' enumerable property attribute by:</source>
          <target state="translated">다음과 같이 속성의 열거 가능한 속성 속성의 값을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee3c6cf9a9fbe4ea8fa522f3b09dbeb432226060" translate="yes" xml:space="preserve">
          <source>Or to obtain all four property attributes:</source>
          <target state="translated">또는 네 가지 속성 속성을 모두 얻으려면</target>
        </trans-unit>
        <trans-unit id="6b7fb34e41e8a58c247a862c50d777d11e97a216" translate="yes" xml:space="preserve">
          <source>See below that the first two loops only execute the console.log statements once, while the standard for loop executes the function as many times as specified, in this case, array.length = 6.</source>
          <target state="translated">아래의 첫 두 루프는 console.log 문을 한 번만 실행하는 반면, for 루프 표준은 지정된 횟수만큼 함수를 실행합니다 (이 경우 array.length = 6).</target>
        </trans-unit>
        <trans-unit id="d916bf343fb39f0ba6d742b44d8afd005717534b" translate="yes" xml:space="preserve">
          <source>Short answer: It's just not worth it.</source>
          <target state="translated">짧은 대답 : 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="28d26e832aa07432925257b320c040f95173eadb" translate="yes" xml:space="preserve">
          <source>Since JavaScript elements are saved as standard object properties, it
  is not advisable to iterate through JavaScript arrays using for...in
  loops because normal elements and all enumerable properties will be
  listed.</source>
          <target state="translated">JavaScript 요소는 표준 객체 속성으로 저장되므로 일반적인 요소와 열거 가능한 모든 속성이 나열되므로 for ... in 루프를 사용하여 JavaScript 배열을 반복하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a9c0e2640786d86947354f29810a2bec59ff248" translate="yes" xml:space="preserve">
          <source>So that's one of the reasons why we need to use &lt;strong&gt;for..in&lt;/strong&gt; carefully, but it's not always the case...</source>
          <target state="translated">이것이 우리가 신중하게 사용해야하는 이유 중 하나이지만 항상 그런 것은 아닙니다 ...</target>
        </trans-unit>
        <trans-unit id="43ccb63fe244a71ca951301d73d2ae606c309d0c" translate="yes" xml:space="preserve">
          <source>So you see.. &lt;code&gt;for in&lt;/code&gt; loop is now safe since you cared about your code.</source>
          <target state="translated">그래서 당신은 .. &lt;code&gt;for in&lt;/code&gt; 루프가 코드에 신경 쓰므로 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a856eaad5930fc3c1ad42c0a1072da1e9a71aa22" translate="yes" xml:space="preserve">
          <source>Some  JS frameworks, like Prototype modifies the Array prototype. Other frameworks like JQuery doesn't, so with JQuery you can safely use for-in.</source>
          <target state="translated">프로토 타입과 같은 일부 JS 프레임 워크는 배열 프로토 타입을 수정합니다. JQuery와 같은 다른 프레임 워크는 그렇지 않으므로 JQuery를 사용하면 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="241cc38f95d86d00578498c6cd6e9d8e3e40f7b1" translate="yes" xml:space="preserve">
          <source>That means if a browser wanted to, it could go through the properties in the order in which they were inserted.  Or in numerical order.  Or in lexical order (where &quot;30&quot; comes before &quot;4&quot;!  Keep in mind all object keys -- and thus, all array indexes -- are actually strings, so that makes total sense).  It could go through them by bucket, if it implemented objects as hash tables.  Or take any of that and add &quot;backwards&quot;.  A browser could even iterate &lt;em&gt;randomly&lt;/em&gt; and be ECMA-262 compliant, as long as it visited each property exactly once.</source>
          <target state="translated">즉, 브라우저가 원하는 경우 삽입 된 순서대로 속성을 통과 할 수 있습니다. 또는 숫자 순서로. 또는 어휘 순서로 ( &quot;30&quot;이 &quot;4&quot;보다 먼저 나오는 경우!) 모든 객체 키와 모든 배열 인덱스는 실제로 문자열이므로 완전히 이해됩니다. 객체를 해시 테이블로 구현 한 경우 버킷별로 처리 할 수 ​​있습니다. 또는 그 중 하나를 가지고 &quot;뒤로&quot;를 추가하십시오. 브라우저는 각 속성을 정확히 한 번 방문한 경우 &lt;em&gt;무작위로&lt;/em&gt; 반복하고 ECMA-262를 준수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4925097cf7b88e57feb64e9ce18adcce8750efa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-in&lt;/code&gt; statement by itself is not a &quot;bad practice&quot;, however it can be &lt;em&gt;mis-used&lt;/em&gt;, for example, to &lt;em&gt;iterate&lt;/em&gt; over arrays or array-like objects.</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; 문 자체는 &quot;나쁜 습관&quot;이 아니지만 배열이나 배열과 같은 객체를 &lt;em&gt;반복&lt;/em&gt; &lt;em&gt;하는&lt;/em&gt; 등 &lt;em&gt;잘못 사용할&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62abc57f4ad07e973cfe4762c0071680716cdbbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; works with two types of variables: hashtables (associative arrays) and array (non-associative).</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; 은 해시 테이블 (연관 배열)과 배열 (비 연관)의 두 가지 유형의 변수와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a4e5b7446e20249c9f271cc6a796ffd24079b6d5" translate="yes" xml:space="preserve">
          <source>The console shows:</source>
          <target state="translated">콘솔에 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c373dd9dcd853eabd38b0b011d5e2e23c21a3f2d" translate="yes" xml:space="preserve">
          <source>The mechanics and &lt;strong&gt;order&lt;/strong&gt; of enumerating the properties ... &lt;strong&gt;is not specified&lt;/strong&gt;...</source>
          <target state="translated">속성을 열거하는 메커니즘과 &lt;strong&gt;순서&lt;/strong&gt; 는 &lt;strong&gt;지정되지 않았습니다&lt;/strong&gt; ...</target>
        </trans-unit>
        <trans-unit id="288b516678cca5f53f82af2e6b9622249813364e" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;for ... in ...&lt;/code&gt; &amp;mdash; and this only becomes a problem when a programmer doesn't really understand the language; it's not really a bug or anything &amp;mdash; is that it iterates over &lt;em&gt;all&lt;/em&gt; members of an object (well, all &lt;em&gt;enumerable&lt;/em&gt; members, but that's a detail for now).  When you want to iterate over &lt;em&gt;just&lt;/em&gt; the indexed properties of an array, the only guaranteed way to keep things semantically consistent is to use an integer index (that is, a &lt;code&gt;for (var i = 0; i &amp;lt; array.length; ++i)&lt;/code&gt; style loop).</source>
          <target state="translated">&lt;code&gt;for ... in ...&lt;/code&gt; 의 문제 &amp;ndash; 이것은 프로그래머가 실제로 언어를 이해하지 못하는 경우에만 문제가됩니다. 그것은 실제로 버그 나 그 어떤 것도 아닙니다. 객체의 &lt;em&gt;모든&lt;/em&gt; 멤버를 반복한다는 것입니다 (물론, &lt;em&gt;열거 가능한&lt;/em&gt; 모든 멤버이지만 세부 사항입니다). 배열의 인덱싱 된 속성 &lt;em&gt;만&lt;/em&gt; 반복하려는 경우 의미 적으로 일관된 상태를 유지하는 유일한 방법은 정수 인덱스 (즉, &lt;code&gt;for (var i = 0; i &amp;lt; array.length; ++i)&lt;/code&gt; 스타일 루프).</target>
        </trans-unit>
        <trans-unit id="f366257c93fa147fea297156a165fc8f6425c44c" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;for-in&lt;/code&gt; statement is to &lt;em&gt;enumerate&lt;/em&gt; over object properties. This statement will go up in the prototype chain, also enumerating over &lt;em&gt;inherited&lt;/em&gt; properties, a thing that &lt;em&gt;sometimes&lt;/em&gt; is not desired.</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; 문의 목적은 객체 속성을 &lt;em&gt;열거&lt;/em&gt; 하는 것입니다. 이 문장은 프로토 타입 체인에서 올라가고 &lt;em&gt;때로는&lt;/em&gt; 원하지 않는 속성을 &lt;em&gt;상속 받았다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="89a42ff68b32c1edc7f8b93e5041095c61ebc5a0" translate="yes" xml:space="preserve">
          <source>The reason is that one construct:</source>
          <target state="translated">그 이유는 하나의 구성입니다.</target>
        </trans-unit>
        <trans-unit id="5da49b7ae2a0921436ddcfd460a1e53611ffa346" translate="yes" xml:space="preserve">
          <source>Then the array have two items, but a length of 101. Using for-in will yield two indexes, while the for-loop will yield 101 indexes, where the 99 has a value of &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">그런 다음 배열에는 두 개의 항목이 있지만 길이는 101입니다. for-in을 사용하면 두 개의 인덱스가 생성되고 for-loop는 101 개의 인덱스를 생성하며 99는 &lt;code&gt;undefined&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="19e517ee8dfd19dc33ba7657aca3b885dc791954" translate="yes" xml:space="preserve">
          <source>There are three reasons why you shouldn't use &lt;code&gt;for..in&lt;/code&gt; to iterate over array elements:</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; 을 사용하여 배열 요소를 반복해서는 안되는 세 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e72dc9f7dbd7a51c36c0e6a445eeb0e565c1d45" translate="yes" xml:space="preserve">
          <source>This is a feature available in ECMAScript 5 - in earlier versions it was not possible to alter the value of the enumerable property attribute (it was always set to true).</source>
          <target state="translated">이는 ECMAScript 5에서 사용할 수있는 기능입니다. 이전 버전에서는 열거 가능한 속성 속성의 값을 변경할 수 없었습니다 (항상 true로 설정 됨).</target>
        </trans-unit>
        <trans-unit id="c340939eba6baf47234d9046c52b928e6cf080c5" translate="yes" xml:space="preserve">
          <source>This will write:</source>
          <target state="translated">이것은 쓸 것이다 :</target>
        </trans-unit>
        <trans-unit id="5926b3627ee73db27b2bc9423c0585f3650b0163" translate="yes" xml:space="preserve">
          <source>Unfortunately, no version of Internet Explorer supports &lt;code&gt;for...of&lt;/code&gt; (&lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;Edge 12+&lt;/a&gt; does), so you'll have to wait a bit longer until you can use it in your client side production code. However, it should be safe to use in your server side JS code (if you use &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt;).</source>
          <target state="translated">불행히도 Internet Explorer 버전은 ( &lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;Edge 12+에서&lt;/a&gt; 지원) 버전을 지원하지 않으므로 클라이언트 쪽 프로덕션 코드에서 사용할 수있을 때까지 조금 더 기다려야합니다. 그러나 &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; 를 사용하는 경우 서버 측 JS 코드에서 사용하는 것이 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="00554097d82380cea803eeb8bfd41d05a2d514a3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;for (var property in array)&lt;/code&gt; will cause &lt;code&gt;array&lt;/code&gt; to be iterated over as an &lt;em&gt;object&lt;/em&gt;, traversing the object prototype chain and ultimately performing slower than an index-based &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">&lt;code&gt;for (var property in array)&lt;/code&gt; 를 사용하면 &lt;code&gt;array&lt;/code&gt; 이 &lt;em&gt;객체&lt;/em&gt; 로 반복되어 객체 프로토 타입 체인을 통과하여 궁극적으로 인덱스 기반 &lt;code&gt;for&lt;/code&gt; 루프보다 느리게 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="9c96a1056df973395a0c429bef208a88ee62a434" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;hasOwnProperty()&lt;/code&gt; and &lt;code&gt;!isNaN()&lt;/code&gt; checks to filter the object properties is an additional overhead causing it to perform even slower and negates the key reason for using it in the first place, i.e. because of the more concise format.</source>
          <target state="translated">&lt;code&gt;hasOwnProperty()&lt;/code&gt; 및 &lt;code&gt;!isNaN()&lt;/code&gt; 검사를 사용하여 객체 속성을 필터링하면 추가 오버 헤드가 발생하여 성능이 훨씬 느려지고 처음에 사용하는 주요 이유, 즉보다 간결한 형식으로 인해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="918fbcebd19b214ca6c6ed8e07393e70c7d695f3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;for...in&lt;/code&gt; loop for an array is not wrong, although I can guess why someone told you that:</source>
          <target state="translated">배열 &lt;code&gt;for...in&lt;/code&gt; 루프를 사용하는 것은 잘못된 것이 아니지만 누군가 누군가 당신에게 왜 그런 말을했는지 추측 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc913488828c3bcac109d7fea4f36a8fb9fb9d46" translate="yes" xml:space="preserve">
          <source>Usually the order of the items in an array is important, but the for-in loop won't necessarily iterate in the right order, that's because it treats the array as an object, which is the way it is implemented in JS, and not as an array.
This seems like a small thing, but it can really screw up applications and is hard to debug.</source>
          <target state="translated">일반적으로 배열의 항목 순서는 중요하지만 for-in 루프는 반드시 올바른 순서로 반복 될 필요는 없습니다. 왜냐하면 배열을 객체로 취급하기 때문입니다. 배열로. 이것은 작은 것 같지만 실제로 응용 프로그램을 망칠 수 있으며 디버깅하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="149c70146186d5720fac2f29bfd0ada94cf61c04" translate="yes" xml:space="preserve">
          <source>When you want to enumerate only the &lt;em&gt;own properties&lt;/em&gt; of an object (the ones that aren't inherited), you can use the &lt;code&gt;hasOwnProperty&lt;/code&gt; method:</source>
          <target state="translated">상속되지 않은 객체의 &lt;em&gt;고유 한 속성&lt;/em&gt; 만 열거하려면 &lt;code&gt;hasOwnProperty&lt;/code&gt; 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b64e58a83fb02454b1c9859d3d2932e652511b06" translate="yes" xml:space="preserve">
          <source>Why is using “for…in” with array iteration a bad idea</source>
          <target state="translated">배열 반복과 함께 &quot;for&amp;hellip; in&quot;을 사용하는 것이 나쁜 생각 인 이유</target>
        </trans-unit>
        <trans-unit id="0577fbc195c6a54c24c161142179133a755af8f0" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;for.. in&lt;/code&gt;, just be sure to check each property with &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;hasOwnProperty&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;for.. in&lt;/code&gt; 사용할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;hasOwnProperty로&lt;/a&gt; 각 속성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5dd7c262d3b63fe2406be4d0a3f7de7d6d43d204" translate="yes" xml:space="preserve">
          <source>You see the &lt;strong&gt;someoneelse&lt;/strong&gt;!!!... We actually looping through new Array object in this case!</source>
          <target state="translated">당신은 &lt;strong&gt;someoneelse를&lt;/strong&gt; 참조하십시오 !!! ... 우리는 실제로이 경우 새로운 Array 객체를 반복합니다!</target>
        </trans-unit>
        <trans-unit id="9c8ef39926fd73e765f1eb8ee4fa6bd53c3ec533" translate="yes" xml:space="preserve">
          <source>You should use the &lt;code&gt;for(var x in y)&lt;/code&gt; only on property lists, not on objects (as explained above).</source>
          <target state="translated">&lt;code&gt;for(var x in y)&lt;/code&gt; 는 객체가 아닌 속성 목록에서만 사용해야합니다 ( 위 설명 참조).</target>
        </trans-unit>
        <trans-unit id="a96bcd7cc3ea125e82ec1633c0c044086ec4d453" translate="yes" xml:space="preserve">
          <source>You'll get it as part of every array:</source>
          <target state="translated">모든 배열의 일부로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="451738ae11c58dea638bd4da33b99df9b1367655" translate="yes" xml:space="preserve">
          <source>although not specifically addressed by this question, I would add that there's a very good reason not to ever use for...in with a &lt;code&gt;NodeList&lt;/code&gt; (as one would obtain from a &lt;code&gt;querySelectorAll&lt;/code&gt; call, as it doesn't see the returned elements at all, instead iterating only over the NodeList properties.</source>
          <target state="translated">이 질문에 구체적으로 언급되어 있지는 않지만 &lt;code&gt;NodeList&lt;/code&gt; 와 함께 사용하지 말아야 할 아주 좋은 이유가 있다고 덧붙일 것입니다. 대신 NodeList 속성에 대해서만 반복합니다.</target>
        </trans-unit>
        <trans-unit id="b01218ba4e2077e27d32f94c86b9d176de94e14e" translate="yes" xml:space="preserve">
          <source>but this is true for iterating over any object with a for-in loop.</source>
          <target state="translated">그러나 for-in 루프가있는 모든 객체를 반복하는 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="409e3dd82374e4e55f29d3a98652e2ae85e1e66f" translate="yes" xml:space="preserve">
          <source>can sometimes be totally different from the other:</source>
          <target state="translated">때로는 다른 것과 완전히 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d26272a8e99b364a53d8375d2aaf9e58565fdc59" translate="yes" xml:space="preserve">
          <source>in the case of a single result, I got:</source>
          <target state="translated">단일 결과의 경우 다음을 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="da1ab8a35220f16c304ed232b0ce34d0d22e60c1" translate="yes" xml:space="preserve">
          <source>in the loop, but the first structure is more direct.</source>
          <target state="translated">루프에서 첫 번째 구조가 더 직접적입니다.</target>
        </trans-unit>
        <trans-unit id="38d998cc7ed3a4c5ac9f65bf863b7c90ce1fc902" translate="yes" xml:space="preserve">
          <source>it's slow because you have to walk all properties of the array object and its whole prototype chain and will still only get the property's name, ie to get the value, an additional lookup will be required</source>
          <target state="translated">배열 객체의 모든 속성과 전체 프로토 타입 체인을 걸어야하므로 속성 이름 만 가져옵니다. 즉, 값을 얻으려면 추가 조회가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f34c97c6342dac87f71ff8d0ba7b7f737b6be403" translate="yes" xml:space="preserve">
          <source>whereas,</source>
          <target state="translated">whereas,</target>
        </trans-unit>
        <trans-unit id="7c5e58bccc2148f04b16afa5d9963af3bc3acc1b" translate="yes" xml:space="preserve">
          <source>which explained why my &lt;code&gt;for (node in nodes) node.href = newLink;&lt;/code&gt; was failing.</source>
          <target state="translated">왜 내 &lt;code&gt;for (node in nodes) node.href = newLink;&lt;/code&gt; 실패했다.</target>
        </trans-unit>
        <trans-unit id="7c400da46a809de9bf574c312d350ee791784418" translate="yes" xml:space="preserve">
          <source>will write</source>
          <target state="translated">쓸 것이다</target>
        </trans-unit>
        <trans-unit id="5c923b1cf4e840a71705024b687048a1b3731fba" translate="yes" xml:space="preserve">
          <source>you could solve this with the hasOwnProperty method:</source>
          <target state="translated">hasOwnProperty 메소드를 사용하여이를 해결할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
