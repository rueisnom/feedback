<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/500504">
    <body>
      <group id="500504">
        <trans-unit id="4bd6398b6ec50d16e0ba8b718869fa0726943b47" translate="yes" xml:space="preserve">
          <source>(Emphasis mine.)</source>
          <target state="translated">(Акцент мой.)</target>
        </trans-unit>
        <trans-unit id="d8063be2dd09276b0e12dbda5c629337424e931e" translate="yes" xml:space="preserve">
          <source>1.) There is already a higher order function, or method, that has that purpose for an array, but has more functionality and leaner syntax, called 'forEach': &lt;code&gt;Array.prototype.forEach(function(element, index, array) {} );&lt;/code&gt;</source>
          <target state="translated">1.) Уже существует функция или метод более высокого порядка, которые имеют эту цель для массива, но имеют больше функциональности и более &lt;code&gt;Array.prototype.forEach(function(element, index, array) {} );&lt;/code&gt; синтаксис и называются &amp;laquo;forEach&amp;raquo;: Array.prototype.forEach (function (element, index, array) { });</target>
        </trans-unit>
        <trans-unit id="7f5212d015eaea70f541c879dc9a1ee3ee6ea4e6" translate="yes" xml:space="preserve">
          <source>2.) Arrays always have a length, but &lt;code&gt;for...in&lt;/code&gt; and &lt;code&gt;forEach&lt;/code&gt; do not execute a function for any value that is &lt;code&gt;'undefined'&lt;/code&gt;, only for the indexes that have a value defined. So if you only assign one value, these loops will only execute a function once, but since an array is enumerated, it will always have a length up to the highest index that has a defined value, but that length could go unnoticed when using these loops.</source>
          <target state="translated">2.) Массивы всегда имеют длину, но &lt;code&gt;for...in&lt;/code&gt; и &lt;code&gt;forEach&lt;/code&gt; не выполняют функцию для любого значения, которое &lt;code&gt;'undefined'&lt;/code&gt; , только для индексов, для которых определено значение. Таким образом, если вы присваиваете только одно значение, эти циклы будут выполнять функцию только один раз, но поскольку массив перечисляется, он всегда будет иметь длину до самого высокого индекса, который имеет определенное значение, но эта длина может остаться незамеченной при использовании этих значений. петли.</target>
        </trans-unit>
        <trans-unit id="1a000b47a2784ab5959eeb6bb68516347e56d65f" translate="yes" xml:space="preserve">
          <source>3.) The standard for loop will execute a function as many times as you define in the parameters, and since an array is numbered, it makes more sense to define how many times you want to execute a function. Unlike the other loops, the for loop can then execute a function for every index in the array, whether the value is defined or not.</source>
          <target state="translated">3.)Стандартный цикл выполняет функцию столько раз,сколько вы определяете в параметрах,а поскольку массив нумеруется,то имеет смысл определить,сколько раз вы хотите выполнить функцию.В отличие от других циклов,цикл for может затем выполнить функцию для каждого индекса в массиве,независимо от того,определено значение или нет.</target>
        </trans-unit>
        <trans-unit id="85146881dc047a08449a004a02b095cacd0cb609" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for (... in ...)&lt;/code&gt; is not guaranteed to return the object properties in sequential order, as one might expect.</source>
          <target state="translated">&lt;code&gt;for (... in ...)&lt;/code&gt; не гарантирует возвращение свойств объекта в последовательном порядке, как можно было бы ожидать.</target>
        </trans-unit>
        <trans-unit id="f7fb489c373f09f65363d8fdde0d33f885cc248d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; lists only the &lt;code&gt;5&lt;/code&gt;, ignoring undefined array indexes, but adding &lt;code&gt;foo&lt;/code&gt;. It shows array &lt;strong&gt;property names&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; списках только &lt;code&gt;5&lt;/code&gt; , игнорируя неопределенные индексы массива, но добавляя &lt;code&gt;foo&lt;/code&gt; . Он показывает &lt;strong&gt;имена свойств&lt;/strong&gt; массива.</target>
        </trans-unit>
        <trans-unit id="7c070578b97dc889d040320474709963bba8ff11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops &lt;strong&gt;do not guarantee a specific iteration order&lt;/strong&gt;. Although is order is usually seen in most modern browsers these days, there is still no 100% guarantee.</source>
          <target state="translated">Циклы &lt;code&gt;for...in&lt;/code&gt; &lt;strong&gt;не гарантируют определенный порядок итераций&lt;/strong&gt; . Хотя этот порядок обычно наблюдается в большинстве современных браузеров, гарантия 100% все еще отсутствует.</target>
        </trans-unit>
        <trans-unit id="75add2a4d0fc3dfc08d7b2e03792fa72128dc96e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops ignore &lt;code&gt;undefined&lt;/code&gt; array elements, i.e. array elements which not have been assigned yet.</source>
          <target state="translated">Циклы &lt;code&gt;for...in&lt;/code&gt; игнорируют &lt;code&gt;undefined&lt;/code&gt; элементы массива, то есть элементы массива, которые еще не были назначены.</target>
        </trans-unit>
        <trans-unit id="e02c78b83b9baae453efbdb0e530f06924f7cb8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops iterate over all their own enumerable properties &lt;strong&gt;and&lt;/strong&gt; the enumerable properties of their prototype(s). Usually in an array iteration we only want to iterate over the array itself. And even though you yourself may not add anything to the array, your libraries or framework might add something.</source>
          <target state="translated">Циклы &lt;code&gt;for...in&lt;/code&gt; перебирают все свои перечисляемые свойства &lt;strong&gt;и&lt;/strong&gt; перечислимые свойства своих прототипов. Обычно в итерации массива мы хотим перебирать только сам массив. И даже если вы сами ничего не можете добавить в массив, ваши библиотеки или фреймворк могут что-то добавить.</target>
        </trans-unit>
        <trans-unit id="5b510d520668177a37ca1233fffcce16d554bed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...of&lt;/code&gt; counts from 0 to 5, and also ignores &lt;code&gt;Array.prototype.foo&lt;/code&gt;. It shows array &lt;strong&gt;values&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;for...of&lt;/code&gt; рассчитывает от 0 до 5, а также игнорирует &lt;code&gt;Array.prototype.foo&lt;/code&gt; . Показывает &lt;strong&gt;значения&lt;/strong&gt; массива.</target>
        </trans-unit>
        <trans-unit id="de8d59ac496d49a3cc2830db61e5080ba7b3ed4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; isn't guaranteed to preserve element ordering</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; не гарантируется сохранение порядка элементов</target>
        </trans-unit>
        <trans-unit id="57c504b07cbe053e6d9258c6e6ce9dab71001517" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; will loop over all own and inherited properties of the array object which aren't &lt;code&gt;DontEnum&lt;/code&gt;; that means if someone adds properties to the specific array object (there are valid reasons for this - I've done so myself) or changed &lt;code&gt;Array.prototype&lt;/code&gt; (which is considered bad practice in code which is supposed to work well with other scripts), these properties will be iterated over as well; inherited properties can be excluded by checking &lt;code&gt;hasOwnProperty()&lt;/code&gt;, but that won't help you with properties set in the array object itself</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; будет перебирать все собственные и унаследованные свойства объекта массива, которые не являются &lt;code&gt;DontEnum&lt;/code&gt; ; это означает, что если кто-то добавляет свойства к конкретному объекту массива (для этого есть веские причины - я сам это сделал) или &lt;code&gt;Array.prototype&lt;/code&gt; (что считается плохой практикой в ​​коде, который должен хорошо работать с другими сценариями), эти свойства также будут повторяться; Унаследованные свойства могут быть исключены путем проверки &lt;code&gt;hasOwnProperty()&lt;/code&gt; , но это не поможет вам со свойствами, установленными в самом объекте массива</target>
        </trans-unit>
        <trans-unit id="5c924ba7b90dce15af127843f7697ca7dc50c687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b0a4e9b74e35d5bb4223b2cc511f2cfc42e49e60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="ed70972dc116b90558966dcf0dc7a880652a1079" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It loops through inherited properties as well:&lt;/strong&gt; First of all any extensions to the &lt;code&gt;Array.prototype&lt;/code&gt; should have been done by using &lt;a href=&quot;https://developer.mozilla.org/tr/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt; and their &lt;code&gt;enumerable&lt;/code&gt; descriptor should be set to &lt;code&gt;false&lt;/code&gt;. Any library not doing so should not be used at all.</source>
          <target state="translated">&lt;strong&gt;Он также перебирает наследуемые свойства:&lt;/strong&gt; прежде всего любые расширения для &lt;code&gt;Array.prototype&lt;/code&gt; должны были быть сделаны с помощью &lt;a href=&quot;https://developer.mozilla.org/tr/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt; а их &lt;code&gt;enumerable&lt;/code&gt; дескриптор должен быть установлен в &lt;code&gt;false&lt;/code&gt; . Любая библиотека, не делающая этого, не должна использоваться вообще.</target>
        </trans-unit>
        <trans-unit id="864471cf89b4825cee0c68d43263743a49b07aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;One&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;One&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2930f375e598c4c0cda99ef5ee5ced807b11895f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Properties those you add to the inheritance chain later get counted:&lt;/strong&gt; When doing array sub-classing by &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or by Class &lt;code&gt;extend&lt;/code&gt;. You should again use &lt;code&gt;Object.defineProperty()&lt;/code&gt; which by default sets the &lt;code&gt;writable&lt;/code&gt;, &lt;code&gt;enumerable&lt;/code&gt; and &lt;code&gt;configurable&lt;/code&gt; property descriptors to &lt;code&gt;false&lt;/code&gt;. Lets see an array sub-classing example here...</source>
          <target state="translated">&lt;strong&gt;Свойства, которые вы добавляете в цепочку наследования, позже учитываются:&lt;/strong&gt; при выполнении подклассов массива с помощью &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; или &lt;code&gt;extend&lt;/code&gt; класса. Вам следует снова использовать &lt;code&gt;Object.defineProperty()&lt;/code&gt; который по умолчанию устанавливает дескрипторы свойств для &lt;code&gt;writable&lt;/code&gt; , &lt;code&gt;enumerable&lt;/code&gt; и &lt;code&gt;configurable&lt;/code&gt; в значение &lt;code&gt;false&lt;/code&gt; . Давайте посмотрим пример подклассификации массива здесь ...</target>
        </trans-unit>
        <trans-unit id="1d17c64273e3caf29ac784b4ed9036aa7703f21e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL&amp;amp;DR:&lt;/strong&gt; Using the &lt;code&gt;for in&lt;/code&gt; loop in arrays is not evil, in fact quite the opposite.</source>
          <target state="translated">&lt;strong&gt;TL &amp;amp; DR:&lt;/strong&gt; использование цикла &lt;code&gt;for in&lt;/code&gt; в массивах не является злом, на самом деле это совсем наоборот.</target>
        </trans-unit>
        <trans-unit id="f4a90667800dfac206439640fe039e0a8ec77ce8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;for in&lt;/code&gt; loop is slow:&lt;/strong&gt; Hell no. It's by far the fastest method of iteration if you are looping over sparse arrays which are needed time to time. This is one of the most important performance tricks that one should know. Let's see an example. We will loop over a sparse array.</source>
          <target state="translated">&lt;strong&gt;Цикл &lt;code&gt;for in&lt;/code&gt; медленен:&lt;/strong&gt; Ад нет. Это самый быстрый метод итерации, если вы зацикливаетесь на разреженных массивах, которые время от времени необходимы. Это один из самых важных приемов производительности, которые следует знать. Давайте посмотрим на пример. Мы будем зацикливаться на разреженном массиве.</target>
        </trans-unit>
        <trans-unit id="7e70c28d46516e16a285932547326e3516ac248f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Two&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aa55c4c1ec6fa0600a16d8a1df0ed62aebb5a00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for...in&lt;/strong&gt; is useful when working on an object in JavaScript, but not for an Array, but still we can not say it's a wrong way, but it's not recommended, look at this example below using &lt;strong&gt;for...in&lt;/strong&gt; loop:</source>
          <target state="translated">&lt;strong&gt;for ... in&lt;/strong&gt; полезен при работе с объектом в JavaScript, но не для Array, но все же мы не можем сказать, что это неправильный путь, но это не рекомендуется, посмотрите на этот пример ниже, используя цикл &lt;strong&gt;for ... in&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="723137f7795e3401755b70d4616c338ef4c6b6e9" translate="yes" xml:space="preserve">
          <source>A for...in loop always enumerates the keys.
Objects properties keys are always String, even the indexed properties of an array :</source>
          <target state="translated">А для...в петле всегда перечисляет ключи.Ключами свойств объектов всегда являются String,даже индексированные свойства массива :</target>
        </trans-unit>
        <trans-unit id="e380bf6c22148b057e16f813b7f95eb85c229ee9" translate="yes" xml:space="preserve">
          <source>A real answer for this will depend on how the browser parsers/interpret the JavaScript code. It can change between browsers.</source>
          <target state="translated">Реальный ответ на этот вопрос будет зависеть от того,как браузер синтерпретирует JavaScript-код.Он может меняться между браузерами.</target>
        </trans-unit>
        <trans-unit id="3f8ee733770af90d6a036b73e38df85ea12e55c2" translate="yes" xml:space="preserve">
          <source>Also consider that &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; libraries might do things like this, which will affect any array you create:</source>
          <target state="translated">Также учтите, что библиотеки &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; могут делать такие вещи, которые влияют на любой создаваемый вами массив:</target>
        </trans-unit>
        <trans-unit id="81a354e95f9aef67cb843763fd3927258da5fdda" translate="yes" xml:space="preserve">
          <source>Also, due to semantics, the way &lt;code&gt;for, in&lt;/code&gt; treats arrays (i.e. the same as any other JavaScript object) is not aligned with other popular languages.</source>
          <target state="translated">Кроме того, из-за семантики, способ &lt;code&gt;for, in&lt;/code&gt; массивов (т. Е. Такой же, как любой другой объект JavaScript) не согласован с другими популярными языками.</target>
        </trans-unit>
        <trans-unit id="56813a034610fd55b9667a342f05765d16c2560a" translate="yes" xml:space="preserve">
          <source>Also, it may be considered a better practice to use the &lt;code&gt;forEach&lt;/code&gt; method than the &lt;code&gt;for...in&lt;/code&gt; loop in general, because it is easier to write and has more functionality, so you may want to get in the habit of only using this method and standard for, but your call.</source>
          <target state="translated">Кроме того, может считаться лучшей практикой использовать метод &lt;code&gt;forEach&lt;/code&gt; , чем цикл &lt;code&gt;for...in&lt;/code&gt; в целом, потому что он легче писать и имеет больше функций, поэтому вы можете захотеть использовать только этот метод и стандартный для, но ваш звонок.</target>
        </trans-unit>
        <trans-unit id="8e9ef6ce457a097e6cbaa9a5cee537865b67b8ae" translate="yes" xml:space="preserve">
          <source>Also, speaking about inherited properties, if you, for example, extend the &lt;code&gt;Array.prototype&lt;/code&gt; object (like some libraries as MooTools do), that properties will be also enumerated:</source>
          <target state="translated">Кроме того, если говорить о унаследованных свойствах, если, например, вы расширяете объект &lt;code&gt;Array.prototype&lt;/code&gt; (как это делают некоторые библиотеки, как это делает MooTools), эти свойства также будут перечислены:</target>
        </trans-unit>
        <trans-unit id="77e8cec41cc494061a090fc5862a2f2e51506df4" translate="yes" xml:space="preserve">
          <source>Also, the order of iteration is not guaranteed by the spec., meaning that if you want to &quot;iterate&quot; an array object, with this statement you cannot be sure that the properties (array indexes) will be visited in the numeric order.</source>
          <target state="translated">Также порядок итераций не гарантируется спецификацией,то есть,если вы хотите &quot;выполнить итерацию&quot; объекта массива,то с помощью этого утверждения вы не можете быть уверены,что свойства (индексы массива)будут посещены в числовом порядке.</target>
        </trans-unit>
        <trans-unit id="4caa9f9af0086837955f928c936648d78e3cf12c" translate="yes" xml:space="preserve">
          <source>An alternative way of iterating through an array is using a for-loop:</source>
          <target state="translated">Альтернативным способом итерации через массив является использование for-loop:</target>
        </trans-unit>
        <trans-unit id="4330d9777faffc1aebc6faa887599a7ad547c366" translate="yes" xml:space="preserve">
          <source>An important aspect is that &lt;code&gt;for...in&lt;/code&gt; only iterates over properties contained in an object which have their &lt;strong&gt;enumerable&lt;/strong&gt;&lt;em&gt;property attribute&lt;/em&gt; set to true. So if one attempts to iterate over an object using &lt;code&gt;for...in&lt;/code&gt; then arbitrary properties may be missed if their enumerable property attribute is false. It is quite possible to alter the enumerable property attribute for normal Array objects so that certain elements are not enumerated. Though in general the property attributes tend to apply to function properties within an object.</source>
          <target state="translated">Важным аспектом является то, что &lt;code&gt;for...in&lt;/code&gt; перебирает только свойства, содержащиеся в объекте, для &lt;em&gt;атрибута&lt;/em&gt; &lt;strong&gt;перечисляемого&lt;/strong&gt; &lt;em&gt;свойства которого&lt;/em&gt; установлено значение true. Таким образом, если кто-то пытается перебрать объект, используя &lt;code&gt;for...in&lt;/code&gt; тогда можно пропустить произвольные свойства, если их атрибут перечислимого свойства равен false. Вполне возможно изменить атрибут перечислимого свойства для обычных объектов Array, чтобы некоторые элементы не перечислялись. Хотя в целом атрибуты свойств обычно применяются к свойствам функций внутри объекта.</target>
        </trans-unit>
        <trans-unit id="bdc123fed57544f574b847785e448b373aff2349" translate="yes" xml:space="preserve">
          <source>And since you can never be sure that nothing will be added to the prototype chain just use a for loop to enumerate the array:</source>
          <target state="translated">А так как вы никогда не можете быть уверены,что ничего не будет добавлено в цепочку прототипов,просто используйте цикл for для перебора массива:</target>
        </trans-unit>
        <trans-unit id="ad0c718b13ffaf815489fe18ec085881a6be06e3" translate="yes" xml:space="preserve">
          <source>And some people even recommend calling the method directly from &lt;code&gt;Object.prototype&lt;/code&gt; to avoid having problems if somebody adds a property named &lt;code&gt;hasOwnProperty&lt;/code&gt; to our object:</source>
          <target state="translated">А некоторые люди даже рекомендуют вызывать метод напрямую из &lt;code&gt;Object.prototype&lt;/code&gt; , чтобы избежать проблем, если кто-то добавит свойство с именем &lt;code&gt;hasOwnProperty&lt;/code&gt; к нашему объекту:</target>
        </trans-unit>
        <trans-unit id="35888521210af7f9dd1e0af389345f2c1f605553" translate="yes" xml:space="preserve">
          <source>Any object can have arbitrary properties associated with it. There would be nothing terrible about loading additional properties onto an array instance, in particular. Code that wants to see &lt;em&gt;only&lt;/em&gt; indexed array-like properties therefore &lt;em&gt;must&lt;/em&gt; stick to an integer index. Code that is fully aware of what &lt;code&gt;for ... in&lt;/code&gt; does and really &lt;em&gt;need&lt;/em&gt; to see all properties, well then that's ok too.</source>
          <target state="translated">Любой объект может иметь произвольные свойства, связанные с ним. В частности, не было бы ничего страшного в загрузке дополнительных свойств в экземпляр массива. Код, который хочет видеть &lt;em&gt;только&lt;/em&gt; индексированные свойства массива, &lt;em&gt;должен&lt;/em&gt; придерживаться целочисленного индекса. Код, который полностью осведомлен о том, что &lt;code&gt;for ... in&lt;/code&gt; , и действительно &lt;em&gt;должен&lt;/em&gt; видеть все свойства, ну тогда это тоже хорошо.</target>
        </trans-unit>
        <trans-unit id="8ae256cf5a988279dae9f08c26581718bda89b9c" translate="yes" xml:space="preserve">
          <source>As I said before to &lt;em&gt;iterate&lt;/em&gt; over arrays or array-like objects, the best thing is to use a &lt;em&gt;sequential loop&lt;/em&gt;, such as a plain-old &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loop.</source>
          <target state="translated">Как я уже говорил, для &lt;em&gt;перебора&lt;/em&gt; массивов или объектов, подобных массивам, лучше всего использовать &lt;em&gt;последовательный цикл&lt;/em&gt; , такой как обычный старый цикл &lt;code&gt;for&lt;/code&gt; / while.</target>
        </trans-unit>
        <trans-unit id="6223893ff2388e165f873960bac2ba5392b49cb2" translate="yes" xml:space="preserve">
          <source>As of 2016 (ES6) we may use &lt;code&gt;for&amp;hellip;of&lt;/code&gt; for array iteration, as John Slegers already noticed.</source>
          <target state="translated">С 2016 года (ES6) мы можем использовать &lt;code&gt;for&amp;hellip;of&lt;/code&gt; для итерации массива, как уже заметил Джон Слегерс.</target>
        </trans-unit>
        <trans-unit id="b9ffc247af1b8ed568d6b5c1b3a27e66e602fc7e" translate="yes" xml:space="preserve">
          <source>As you see the result the same...</source>
          <target state="translated">Как вы видите,результат тот же...</target>
        </trans-unit>
        <trans-unit id="894f0d6f0a5dc7e6d9477fd432341a08cc075bbf" translate="yes" xml:space="preserve">
          <source>Aside from the fact that &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; loops over all enumerable properties (which is &lt;em&gt;not&lt;/em&gt; the same as &quot;all array elements&quot;!), see &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&quot;&gt;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&lt;/a&gt;, section 12.6.4 (5th edition) or 13.7.5.15 (7th edition):</source>
          <target state="translated">Помимо того, что &lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;in&lt;/code&gt; зацикливается на всех перечисляемых свойствах (что &lt;em&gt;не&lt;/em&gt; совпадает с &amp;laquo;всеми элементами массива&amp;raquo;!), См. &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&quot;&gt;Http://www.ecma-international.org/publications/files/ECMA-ST /Ecma-262.pdf&lt;/a&gt; , раздел 12.6.4 (5-е издание) или 13.7.5.15 (7-е издание):</target>
        </trans-unit>
        <trans-unit id="eb7d92e5a3d183746be4cc4443582416eca4294e" translate="yes" xml:space="preserve">
          <source>Because for...in enumerates through the object that holds the array, not the array itself. If I add a function to the arrays prototype chain, that will also be included. I.e.</source>
          <target state="translated">Потому что для...в пересчёте через объект,который содержит массив,а не сам массив.Если я добавлю функцию в цепочку прототипов массивов,то она тоже будет включена.Т.е.</target>
        </trans-unit>
        <trans-unit id="b96448a2e10a4868599ab0a74179eb46b603e8f6" translate="yes" xml:space="preserve">
          <source>Because it enumerates through object fields, not indexes. You can get value with index &quot;length&quot; and I doubt you want this.</source>
          <target state="translated">Потому что он перечисляет через поля объектов,а не через индексы.Вы можете получить значение с помощью индекса &quot;длина&quot;,и я сомневаюсь,что вы этого хотите.</target>
        </trans-unit>
        <trans-unit id="8992d96aafc9f0ab11805a540be31b57da2de068" translate="yes" xml:space="preserve">
          <source>Because it will iterate over properties belonging to objects up the prototype chain if you're not careful.</source>
          <target state="translated">Потому что,если вы не будете осторожны,он будет повторять свойства,принадлежащие объектам в цепочке прототипов.</target>
        </trans-unit>
        <trans-unit id="ee90f63ccf1f6222ef3e10f7c081882454ec920d" translate="yes" xml:space="preserve">
          <source>But in my opinion, it's better to use &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;, the process required for that auto-detection is very small.</source>
          <target state="translated">Но, на мой взгляд, лучше использовать &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; , процесс, необходимый для этого автоопределения очень маленький.</target>
        </trans-unit>
        <trans-unit id="12279b51e8d023c0ad5031c9a0b1e701ef3132e1" translate="yes" xml:space="preserve">
          <source>But let's try something, let's prototype something to &lt;strong&gt;Array&lt;/strong&gt;...</source>
          <target state="translated">Но давайте попробуем что-то, давайте создадим что-то для &lt;strong&gt;Array&lt;/strong&gt; ...</target>
        </trans-unit>
        <trans-unit id="43740775866432b484bee9f9cd495c479fdafbb1" translate="yes" xml:space="preserve">
          <source>Either way, &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; carries with it no connotation of order.  If you care about order, be explicit about it and use a regular &lt;code&gt;for&lt;/code&gt; loop with an index.</source>
          <target state="translated">В любом случае, ... не несет &lt;code&gt;in&lt;/code&gt; себе никакого смысла порядка. Если вы заботитесь о порядке, проясните его и используйте регулярный цикл &lt;code&gt;for&lt;/code&gt; с индексом.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="0f0d139be39da72d26c2fc44d8e9127747d60e99" translate="yes" xml:space="preserve">
          <source>For example, in JScript (IE &amp;lt;= 8), the order of enumeration even on Array objects is defined as the properties were created:</source>
          <target state="translated">Например, в JScript (IE &amp;lt;= 8) порядок перечисления даже для объектов Array определяется по мере создания свойств:</target>
        </trans-unit>
        <trans-unit id="2428f10d15c193c4c3f102bd0050a7d4e2a6f520" translate="yes" xml:space="preserve">
          <source>For these reasons an acceptable trade-off between performance and convenience doesn't even exist.  There's really no benefit unless the intent is to handle the array as an &lt;em&gt;object&lt;/em&gt; and perform operations on the object properties of the array.</source>
          <target state="translated">По этим причинам приемлемый компромисс между производительностью и удобством даже не существует. На самом деле нет никакой выгоды, если только мы не хотим обрабатывать массив как &lt;em&gt;объект&lt;/em&gt; и выполнять операции над свойствами объекта массива.</target>
        </trans-unit>
        <trans-unit id="32b5cb0e39239e899eede9d898b826f9b8871c75" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68c380cf4529191d6c4d7cbc7090efd3852b6892" translate="yes" xml:space="preserve">
          <source>Here are the reasons why this is (usually) a bad practice:</source>
          <target state="translated">Вот причины,по которым это (обычно)плохая практика:</target>
        </trans-unit>
        <trans-unit id="8800cd23cee45b4bed05921ce5f6db9ef6fde066" translate="yes" xml:space="preserve">
          <source>However, if your code (or the framework you are using) add custom properties to arrays or to the array prototype, then these properties will be included in the iteration, which is probably not what you want.</source>
          <target state="translated">Однако,если ваш код (или каркас,который вы используете)добавляет пользовательские свойства к массивам или прототипу массива,то эти свойства будут включены в итерацию,что,вероятно,не то,что вы хотите.</target>
        </trans-unit>
        <trans-unit id="3f41c8e3bf1d0164c41613e45d4575733160cd11" translate="yes" xml:space="preserve">
          <source>However, this have a different issue. The issue is that a JavaScript array can have &quot;holes&quot;. If you define &lt;code&gt;arr&lt;/code&gt; as:</source>
          <target state="translated">Однако у этого есть другая проблема. Проблема в том, что массив JavaScript может иметь &amp;laquo;дыры&amp;raquo;. Если вы определили &lt;code&gt;arr&lt;/code&gt; как:</target>
        </trans-unit>
        <trans-unit id="4609f4613ee2485b87e9ea3693f15a345fdc5bff" translate="yes" xml:space="preserve">
          <source>I can't think of other purposes to not using &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;;</source>
          <target state="translated">Я не могу думать о других целях, чтобы не использовать &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="c84398cbe7864ec7d29debf086fe632c20a743ee" translate="yes" xml:space="preserve">
          <source>I do, however, would like to add that &lt;strong&gt;in modern browsers&lt;/strong&gt; there is an alternative to &lt;code&gt;for...in&lt;/code&gt; that can be used in those cases where &lt;code&gt;for...in&lt;/code&gt; can't be used. That alternative is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/a&gt; :</source>
          <target state="translated">Однако я хотел бы добавить, что &lt;strong&gt;в современных браузерах&lt;/strong&gt; есть альтернатива &lt;code&gt;for...in&lt;/code&gt; которая может использоваться в тех случаях, когда &lt;code&gt;for...in&lt;/code&gt; не может использоваться. Эта альтернатива &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e3b3a26ba9647b9bce83a99b6dd6343035cd56ae" translate="yes" xml:space="preserve">
          <source>I don't think I have much to add to eg. &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/500531#500531&quot;&gt;Triptych's answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/4261096#4261096&quot;&gt;CMS's answer&lt;/a&gt; on why using &lt;code&gt;for...in&lt;/code&gt; should be avoided in some cases.</source>
          <target state="translated">Я не думаю, что мне есть что добавить, например. &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/500531#500531&quot;&gt;В&lt;/a&gt; некоторых случаях следует избегать ответа Триптиха или ответа &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/4261096#4261096&quot;&gt;CMS&lt;/a&gt; о том, почему использование &lt;code&gt;for...in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd3028b86fe1e48337d81eff923a6ece9b04e2b8" translate="yes" xml:space="preserve">
          <source>I think the &lt;code&gt;for in&lt;/code&gt; loop is a gem of JS if used &lt;em&gt;correctly&lt;/em&gt; in arrays. You are expected to have full control over your software and know what you are doing. Let's see the mentioned drawbacks and disprove them one by one.</source>
          <target state="translated">Я думаю, что цикл for является самоцветом JS, если он используется &lt;em&gt;правильно&lt;/em&gt; в массивах. От вас ожидают, что вы полностью контролируете свое программное обеспечение и знаете, что делаете. Давайте посмотрим на упомянутые недостатки и опровергаем их один за другим.</target>
        </trans-unit>
        <trans-unit id="3c5457f2a9b947636475a19d3f1132040b65b1d3" translate="yes" xml:space="preserve">
          <source>I would just like to add this simple demonstration code, to make things clearer:</source>
          <target state="translated">Я просто хотел бы добавить этот простой демонстрационный код,чтобы прояснить ситуацию:</target>
        </trans-unit>
        <trans-unit id="64e3da07990d73da0857766c8c4119fdfa3d8581" translate="yes" xml:space="preserve">
          <source>I've been told not to use &lt;code&gt;for...in&lt;/code&gt; with arrays in JavaScript. Why not?</source>
          <target state="translated">Мне сказали не использовать &lt;code&gt;for...in&lt;/code&gt; с массивами в JavaScript. Почему бы нет?</target>
        </trans-unit>
        <trans-unit id="97e955c989e786a9c59188ad385759593bc273f9" translate="yes" xml:space="preserve">
          <source>If a function called &lt;code&gt;helpfulUtilityMethod&lt;/code&gt; has been added to &lt;code&gt;Array&lt;/code&gt;'s &lt;code&gt;prototype&lt;/code&gt;, then your loop would end up running four times: &lt;code&gt;key&lt;/code&gt; would be &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;helpfulUtilityMethod&lt;/code&gt;.  If you were only expecting integers, oops.</source>
          <target state="translated">Если к &lt;code&gt;prototype&lt;/code&gt; &lt;code&gt;Array&lt;/code&gt; была добавлена ​​функция &lt;code&gt;helpfulUtilityMethod&lt;/code&gt; , цикл завершился бы четыре раза: &lt;code&gt;key&lt;/code&gt; будет &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; &lt;code&gt;helpfulUtilityMethod&lt;/code&gt; . Если вы ожидали только целых чисел, упс.</target>
        </trans-unit>
        <trans-unit id="36c04e2865843e125432c9e852edd02d54e879a0" translate="yes" xml:space="preserve">
          <source>If you are in doubt, you probably shouldn't use for-in.</source>
          <target state="translated">Если ты сомневаешься,тебе,наверное,не стоит использовать для входа.</target>
        </trans-unit>
        <trans-unit id="3f9cf51b07160b61873b4313b13e4209e40cf8d3" translate="yes" xml:space="preserve">
          <source>In addition to the other problems, the &quot;for..in&quot; syntax is probably slower, because the index is a string, not an integer.</source>
          <target state="translated">В дополнение к другим проблемам,синтаксис &quot;for...in&quot;,вероятно,работает медленнее,так как индекс-это строка,а не целое число.</target>
        </trans-unit>
        <trans-unit id="5d7f89f56c3c8e5432b67de63d59ca4ec8daee20" translate="yes" xml:space="preserve">
          <source>In addition to the reasons given in other answers, you may not want to use the &quot;for...in&quot; structure if you need to do math with the counter variable because the loop iterates through the names of the object's properties and so the variable is a string.</source>
          <target state="translated">В дополнение к причинам,приведенным в других ответах,вы можете не захотеть использовать структуру &quot;for...in&quot;,если вам нужно провести математику с переменной счетчика,потому что цикл итераций проходит через имена свойств объекта,а значит,переменная-это строка.</target>
        </trans-unit>
        <trans-unit id="987fa132a1fc4549a83c1787f42d94ea85f4d2a2" translate="yes" xml:space="preserve">
          <source>In essence, you can use any loop, but you should remember exactly how they work. Understand the conditions upon which the different loops reiterate, their separate functionalities, and realize they will be more or less appropriate for differing scenarios.</source>
          <target state="translated">В сущности,вы можете использовать любой цикл,но вы должны точно помнить,как они работают.Поймите условия,при которых различные петли повторяют друг друга,их отдельные функции,и поймите,что они будут более или менее подходящими для различных сценариев.</target>
        </trans-unit>
        <trans-unit id="aec6fa3400776b4a7fb59542b27ba833e3407a93" translate="yes" xml:space="preserve">
          <source>In isolation, there is nothing wrong with using for-in on arrays. For-in iterates over the property names of an object, and in the case of an &quot;out-of-the-box&quot; array, the properties corresponds to the array indexes. (The built-in propertes like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;toString&lt;/code&gt; and so on are not included in the iteration.)</source>
          <target state="translated">В изоляции нет ничего плохого в использовании for-in для массивов. For-in перебирает имена свойств объекта, а в случае массива &amp;laquo;из коробки&amp;raquo; свойства соответствуют индексам массива. (Встроенные свойства, такие как &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;toString&lt;/code&gt; и т. Д., Не включены в итерацию.)</target>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">Другими словами:</target>
        </trans-unit>
        <trans-unit id="734568a26e2da175e7b2711963a36f6889e16233" translate="yes" xml:space="preserve">
          <source>In practice, most browsers currently like to iterate in roughly the same order.  But there's nothing saying they have to.  That's implementation specific, and could change at any time if another way was found to be far more efficient.</source>
          <target state="translated">На практике большинство браузеров в настоящее время любят выполнять итерации примерно в том же порядке.Но ничто не говорит о том,что они должны.Это специфично для реализации,и может измениться в любой момент,если будет найден другой способ,который будет намного эффективнее.</target>
        </trans-unit>
        <trans-unit id="63b585b5d4653967345fb2a5acb868a3bc4a2b69" translate="yes" xml:space="preserve">
          <source>It's not &lt;em&gt;necessarily&lt;/em&gt; bad (based on what you're doing), but in the case of arrays, if something has been added to &lt;code&gt;Array.prototype&lt;/code&gt;, then you're going to get strange results.  Where you'd expect this loop to run three times:</source>
          <target state="translated">Это не &lt;em&gt;обязательно&lt;/em&gt; плохо (в зависимости от того, что вы делаете), но в случае массивов, если что-то было добавлено в &lt;code&gt;Array.prototype&lt;/code&gt; , вы получите странные результаты. Где вы ожидаете, что этот цикл будет выполняться три раза:</target>
        </trans-unit>
        <trans-unit id="48512dd4b3a3c1f7350ccbc046b3e86d288aef9a" translate="yes" xml:space="preserve">
          <source>JavaScript will automatically determine the way its passes through the items. So if you know that your array is really non-associative you can use &lt;code&gt;for (var i=0; i&amp;lt;=arrayLen; i++)&lt;/code&gt;, and skip the auto-detection iteration.</source>
          <target state="translated">JavaScript автоматически определит способ прохождения элементов. Поэтому, если вы знаете, что ваш массив действительно неассоциативен, вы можете использовать &lt;code&gt;for (var i=0; i&amp;lt;=arrayLen; i++)&lt;/code&gt; и пропустить итерацию автоопределения.</target>
        </trans-unit>
        <trans-unit id="2f7f0686684ed446fc32930174e01f5395bb10e0" translate="yes" xml:space="preserve">
          <source>Like others have said, You might get keys which aren't in your array or that are inherited from the prototype. So if, let's say, a library adds a property to the Array or Object prototypes:</source>
          <target state="translated">Как говорили другие,вы можете получить ключи,которых нет в вашем массиве или которые унаследованы от прототипа.Так что если,допустим,библиотека добавляет свойство к прототипу массива или объекта:</target>
        </trans-unit>
        <trans-unit id="f45b5193da0aaa7c52cb48f0bc144438c2dff04a" translate="yes" xml:space="preserve">
          <source>Long answer: It's just not worth it...</source>
          <target state="translated">Длинный ответ:Оно того не стоит...</target>
        </trans-unit>
        <trans-unit id="5585fccb2ae308d5040fc4d2fff80a5c0290f3a8" translate="yes" xml:space="preserve">
          <source>Longer answer: It's just not worth it, even if sequential element order and optimal performance aren't required.</source>
          <target state="translated">Более длинный ответ:Просто оно того не стоит,даже если не требуется последовательный порядок элементов и оптимальная производительность.</target>
        </trans-unit>
        <trans-unit id="2b171ef9d258336524bc78a30c41d1586e22ad24" translate="yes" xml:space="preserve">
          <source>Mainly two reasons:</source>
          <target state="translated">В основном по двум причинам:</target>
        </trans-unit>
        <trans-unit id="82155128d69281609acce32458fe028999ca1517" translate="yes" xml:space="preserve">
          <source>Note :</source>
          <target state="translated">Примечание :</target>
        </trans-unit>
        <trans-unit id="af88e59767f8ff55e7690c17ad58d65f053bf1a9" translate="yes" xml:space="preserve">
          <source>Now we create a new Array();</source>
          <target state="translated">Теперь мы создаем новый массив (Array());</target>
        </trans-unit>
        <trans-unit id="6e27c94a861aeaf1d0ac22ebe6d7a6026d13e8c7" translate="yes" xml:space="preserve">
          <source>OK, let's do it with &lt;strong&gt;Array&lt;/strong&gt; now:</source>
          <target state="translated">Хорошо, теперь сделаем это с &lt;strong&gt;Array&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="56bdfee68984425cbf940d97eb5ac6566ed73d68" translate="yes" xml:space="preserve">
          <source>Of course, this can easily be overcome by including</source>
          <target state="translated">Конечно,это можно легко преодолеть,включив в список</target>
        </trans-unit>
        <trans-unit id="861d60bb59642c4abc4400719fd6c6e81961b6fa" translate="yes" xml:space="preserve">
          <source>One can check the value of a properties' enumerable property attribute by:</source>
          <target state="translated">Можно проверить значение атрибута свойства свойства по:</target>
        </trans-unit>
        <trans-unit id="ee3c6cf9a9fbe4ea8fa522f3b09dbeb432226060" translate="yes" xml:space="preserve">
          <source>Or to obtain all four property attributes:</source>
          <target state="translated">Или получить все четыре атрибута собственности:</target>
        </trans-unit>
        <trans-unit id="6b7fb34e41e8a58c247a862c50d777d11e97a216" translate="yes" xml:space="preserve">
          <source>See below that the first two loops only execute the console.log statements once, while the standard for loop executes the function as many times as specified, in this case, array.length = 6.</source>
          <target state="translated">Смотрите ниже,что первые два цикла выполняют операторы console.log только один раз,в то время как стандартный цикл выполняет функцию столько раз,сколько указано,в данном случае array.length=6.</target>
        </trans-unit>
        <trans-unit id="d916bf343fb39f0ba6d742b44d8afd005717534b" translate="yes" xml:space="preserve">
          <source>Short answer: It's just not worth it.</source>
          <target state="translated">Короткий ответ:Оно того не стоит.</target>
        </trans-unit>
        <trans-unit id="28d26e832aa07432925257b320c040f95173eadb" translate="yes" xml:space="preserve">
          <source>Since JavaScript elements are saved as standard object properties, it
  is not advisable to iterate through JavaScript arrays using for...in
  loops because normal elements and all enumerable properties will be
  listed.</source>
          <target state="translated">Так как элементы JavaScript сохраняются в виде стандартных свойств объекта,не рекомендуется проводить итерации через массивы JavaScript,используя...в циклах,так как обычные элементы и все бесчисленные свойства будут перечислены.</target>
        </trans-unit>
        <trans-unit id="4a9c0e2640786d86947354f29810a2bec59ff248" translate="yes" xml:space="preserve">
          <source>So that's one of the reasons why we need to use &lt;strong&gt;for..in&lt;/strong&gt; carefully, but it's not always the case...</source>
          <target state="translated">Так что это одна из причин, почему мы должны использовать для &lt;strong&gt;...&lt;/strong&gt; осторожно, но это не всегда так ...</target>
        </trans-unit>
        <trans-unit id="43ccb63fe244a71ca951301d73d2ae606c309d0c" translate="yes" xml:space="preserve">
          <source>So you see.. &lt;code&gt;for in&lt;/code&gt; loop is now safe since you cared about your code.</source>
          <target state="translated">Итак, вы видите ... цикл &lt;code&gt;for in&lt;/code&gt; теперь безопасен, поскольку вы заботились о своем коде.</target>
        </trans-unit>
        <trans-unit id="a856eaad5930fc3c1ad42c0a1072da1e9a71aa22" translate="yes" xml:space="preserve">
          <source>Some  JS frameworks, like Prototype modifies the Array prototype. Other frameworks like JQuery doesn't, so with JQuery you can safely use for-in.</source>
          <target state="translated">Некоторые JS-фреймворки,такие как Prototype модифицирует прототип Array.Другие фреймворки,такие как JQuery,не модифицируют,поэтому с JQuery вы можете безопасно использовать for-in.</target>
        </trans-unit>
        <trans-unit id="241cc38f95d86d00578498c6cd6e9d8e3e40f7b1" translate="yes" xml:space="preserve">
          <source>That means if a browser wanted to, it could go through the properties in the order in which they were inserted.  Or in numerical order.  Or in lexical order (where &quot;30&quot; comes before &quot;4&quot;!  Keep in mind all object keys -- and thus, all array indexes -- are actually strings, so that makes total sense).  It could go through them by bucket, if it implemented objects as hash tables.  Or take any of that and add &quot;backwards&quot;.  A browser could even iterate &lt;em&gt;randomly&lt;/em&gt; and be ECMA-262 compliant, as long as it visited each property exactly once.</source>
          <target state="translated">Это означает, что если браузер хочет, он может просматривать свойства в том порядке, в котором они были вставлены. Или в порядке номеров. Или в лексическом порядке (где &amp;laquo;30&amp;raquo; предшествует &amp;laquo;4&amp;raquo;! Имейте в виду, что все ключи объектов - и, следовательно, все индексы массивов - на самом деле являются строками, так что это имеет смысл). Он мог бы проходить через них, если реализовывал объекты в виде хеш-таблиц. Или возьмите что-нибудь из этого и добавьте &amp;laquo;назад&amp;raquo;. Браузер может даже выполнять итерации &lt;em&gt;случайным образом&lt;/em&gt; и быть совместимым с ECMA-262, если он посещает каждое свойство ровно один раз.</target>
        </trans-unit>
        <trans-unit id="4925097cf7b88e57feb64e9ce18adcce8750efa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-in&lt;/code&gt; statement by itself is not a &quot;bad practice&quot;, however it can be &lt;em&gt;mis-used&lt;/em&gt;, for example, to &lt;em&gt;iterate&lt;/em&gt; over arrays or array-like objects.</source>
          <target state="translated">Сам по себе оператор &lt;code&gt;for-in&lt;/code&gt; не является &amp;laquo;плохой практикой&amp;raquo;, однако его можно &lt;em&gt;неправильно использовать&lt;/em&gt; , например, для &lt;em&gt;перебора&lt;/em&gt; массивов или объектов, подобных массивам.</target>
        </trans-unit>
        <trans-unit id="62abc57f4ad07e973cfe4762c0071680716cdbbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; works with two types of variables: hashtables (associative arrays) and array (non-associative).</source>
          <target state="translated">For / &lt;code&gt;in&lt;/code&gt; работает с двумя типами переменных: хеш-таблицы (ассоциативные массивы) и массив (неассоциативные).</target>
        </trans-unit>
        <trans-unit id="a4e5b7446e20249c9f271cc6a796ffd24079b6d5" translate="yes" xml:space="preserve">
          <source>The console shows:</source>
          <target state="translated">На консоли видно:</target>
        </trans-unit>
        <trans-unit id="c373dd9dcd853eabd38b0b011d5e2e23c21a3f2d" translate="yes" xml:space="preserve">
          <source>The mechanics and &lt;strong&gt;order&lt;/strong&gt; of enumerating the properties ... &lt;strong&gt;is not specified&lt;/strong&gt;...</source>
          <target state="translated">Механика и &lt;strong&gt;порядок&lt;/strong&gt; перечисления свойств ... &lt;strong&gt;не уточняется&lt;/strong&gt; ...</target>
        </trans-unit>
        <trans-unit id="288b516678cca5f53f82af2e6b9622249813364e" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;for ... in ...&lt;/code&gt; &amp;mdash; and this only becomes a problem when a programmer doesn't really understand the language; it's not really a bug or anything &amp;mdash; is that it iterates over &lt;em&gt;all&lt;/em&gt; members of an object (well, all &lt;em&gt;enumerable&lt;/em&gt; members, but that's a detail for now).  When you want to iterate over &lt;em&gt;just&lt;/em&gt; the indexed properties of an array, the only guaranteed way to keep things semantically consistent is to use an integer index (that is, a &lt;code&gt;for (var i = 0; i &amp;lt; array.length; ++i)&lt;/code&gt; style loop).</source>
          <target state="translated">Проблема с &lt;code&gt;for ... in ...&lt;/code&gt; - и это становится проблемой только тогда, когда программист действительно не понимает язык; на самом деле это не ошибка или что-то в этом роде - это то, что она перебирает &lt;em&gt;все&lt;/em&gt; элементы объекта (ну, все &lt;em&gt;перечисляемые&lt;/em&gt; элементы, но пока это подробно). Когда вы хотите выполнить итерации &lt;em&gt;только&lt;/em&gt; по индексированным свойствам массива, единственный гарантированный способ сохранить семантически непротиворечивые вещи - это использовать целочисленный индекс (то есть a &lt;code&gt;for (var i = 0; i &amp;lt; array.length; ++i)&lt;/code&gt; петля стиля).</target>
        </trans-unit>
        <trans-unit id="f366257c93fa147fea297156a165fc8f6425c44c" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;for-in&lt;/code&gt; statement is to &lt;em&gt;enumerate&lt;/em&gt; over object properties. This statement will go up in the prototype chain, also enumerating over &lt;em&gt;inherited&lt;/em&gt; properties, a thing that &lt;em&gt;sometimes&lt;/em&gt; is not desired.</source>
          <target state="translated">Цель оператора &lt;code&gt;for-in&lt;/code&gt; состоит в &lt;em&gt;перечислении&lt;/em&gt; свойств объекта. Это утверждение будет идти вверх по цепочке прототипов, также перечисляя &lt;em&gt;наследуемые&lt;/em&gt; свойства, что &lt;em&gt;иногда&lt;/em&gt; нежелательно.</target>
        </trans-unit>
        <trans-unit id="89a42ff68b32c1edc7f8b93e5041095c61ebc5a0" translate="yes" xml:space="preserve">
          <source>The reason is that one construct:</source>
          <target state="translated">Причина в том,что это одна из конструкций:</target>
        </trans-unit>
        <trans-unit id="5da49b7ae2a0921436ddcfd460a1e53611ffa346" translate="yes" xml:space="preserve">
          <source>Then the array have two items, but a length of 101. Using for-in will yield two indexes, while the for-loop will yield 101 indexes, where the 99 has a value of &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Тогда у массива есть два элемента, но длина 101. Использование for-in даст два индекса, в то время как цикл for даст 101 индекс, где значение 99 имеет значение &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19e517ee8dfd19dc33ba7657aca3b885dc791954" translate="yes" xml:space="preserve">
          <source>There are three reasons why you shouldn't use &lt;code&gt;for..in&lt;/code&gt; to iterate over array elements:</source>
          <target state="translated">Есть три причины, по которым вы не должны использовать &lt;code&gt;for..in&lt;/code&gt; для перебора элементов массива:</target>
        </trans-unit>
        <trans-unit id="0e72dc9f7dbd7a51c36c0e6a445eeb0e565c1d45" translate="yes" xml:space="preserve">
          <source>This is a feature available in ECMAScript 5 - in earlier versions it was not possible to alter the value of the enumerable property attribute (it was always set to true).</source>
          <target state="translated">Эта функция доступна в ECMAScript 5-в более ранних версиях не было возможности изменить значение атрибута бесчисленного свойства (оно всегда было установлено в true).</target>
        </trans-unit>
        <trans-unit id="c340939eba6baf47234d9046c52b928e6cf080c5" translate="yes" xml:space="preserve">
          <source>This will write:</source>
          <target state="translated">Это будет написано:</target>
        </trans-unit>
        <trans-unit id="5926b3627ee73db27b2bc9423c0585f3650b0163" translate="yes" xml:space="preserve">
          <source>Unfortunately, no version of Internet Explorer supports &lt;code&gt;for...of&lt;/code&gt; (&lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;Edge 12+&lt;/a&gt; does), so you'll have to wait a bit longer until you can use it in your client side production code. However, it should be safe to use in your server side JS code (if you use &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt;).</source>
          <target state="translated">К сожалению, ни одна версия Internet Explorer не поддерживает &lt;code&gt;for...of&lt;/code&gt; ( &lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;Edge 12+&lt;/a&gt; ), поэтому вам придется немного подождать, пока вы не сможете использовать ее в своем рабочем коде на стороне клиента. Тем не менее, он должен быть безопасным для использования в вашем JS-коде на стороне сервера (если вы используете &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="00554097d82380cea803eeb8bfd41d05a2d514a3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;for (var property in array)&lt;/code&gt; will cause &lt;code&gt;array&lt;/code&gt; to be iterated over as an &lt;em&gt;object&lt;/em&gt;, traversing the object prototype chain and ultimately performing slower than an index-based &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">Использование &lt;code&gt;for (var property in array)&lt;/code&gt; приведет к тому, что &lt;code&gt;array&lt;/code&gt; будет перебираться как &lt;em&gt;объект&lt;/em&gt; , проходя цепочку прототипов объекта и, в конечном итоге, работая медленнее, чем основанный &lt;code&gt;for&lt;/code&gt; индексе цикл for .</target>
        </trans-unit>
        <trans-unit id="9c96a1056df973395a0c429bef208a88ee62a434" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;hasOwnProperty()&lt;/code&gt; and &lt;code&gt;!isNaN()&lt;/code&gt; checks to filter the object properties is an additional overhead causing it to perform even slower and negates the key reason for using it in the first place, i.e. because of the more concise format.</source>
          <target state="translated">Использование &lt;code&gt;hasOwnProperty()&lt;/code&gt; и &lt;code&gt;!isNaN()&lt;/code&gt; для фильтрации свойств объекта - это дополнительные издержки, которые заставляют его работать еще медленнее, и сводит на нет основную причину его использования, т. Е. Из-за более лаконичного формата.</target>
        </trans-unit>
        <trans-unit id="918fbcebd19b214ca6c6ed8e07393e70c7d695f3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;for...in&lt;/code&gt; loop for an array is not wrong, although I can guess why someone told you that:</source>
          <target state="translated">Использование цикла &lt;code&gt;for...in&lt;/code&gt; для массива не является неправильным, хотя я могу догадаться, почему кто-то сказал вам, что:</target>
        </trans-unit>
        <trans-unit id="bc913488828c3bcac109d7fea4f36a8fb9fb9d46" translate="yes" xml:space="preserve">
          <source>Usually the order of the items in an array is important, but the for-in loop won't necessarily iterate in the right order, that's because it treats the array as an object, which is the way it is implemented in JS, and not as an array.
This seems like a small thing, but it can really screw up applications and is hard to debug.</source>
          <target state="translated">Обычно порядок элементов в массиве важен,но цикл for-in не обязательно будет выполнять итерации в правильном порядке,это связано с тем,что он рассматривает массив как объект,как это реализовано в JS,а не как массив.Это кажется мелочью,но это действительно может испортить работу приложений и трудно отлаживается.</target>
        </trans-unit>
        <trans-unit id="149c70146186d5720fac2f29bfd0ada94cf61c04" translate="yes" xml:space="preserve">
          <source>When you want to enumerate only the &lt;em&gt;own properties&lt;/em&gt; of an object (the ones that aren't inherited), you can use the &lt;code&gt;hasOwnProperty&lt;/code&gt; method:</source>
          <target state="translated">Если вы хотите перечислить только &lt;em&gt;собственные свойства&lt;/em&gt; объекта (те, которые не наследуются), вы можете использовать метод &lt;code&gt;hasOwnProperty&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b64e58a83fb02454b1c9859d3d2932e652511b06" translate="yes" xml:space="preserve">
          <source>Why is using “for…in” with array iteration a bad idea</source>
          <target state="translated">Почему использование &quot;for...in&quot; с итерацией массива-плохая идея.</target>
        </trans-unit>
        <trans-unit id="0577fbc195c6a54c24c161142179133a755af8f0" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;for.. in&lt;/code&gt;, just be sure to check each property with &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;hasOwnProperty&lt;/a&gt;.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;for.. in&lt;/code&gt; , просто обязательно проверьте каждое свойство с &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;hasOwnProperty&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5dd7c262d3b63fe2406be4d0a3f7de7d6d43d204" translate="yes" xml:space="preserve">
          <source>You see the &lt;strong&gt;someoneelse&lt;/strong&gt;!!!... We actually looping through new Array object in this case!</source>
          <target state="translated">Вы видите &lt;strong&gt;кого-&lt;/strong&gt; то &lt;strong&gt;другого&lt;/strong&gt; ... ... В этом случае мы фактически перебираем новый объект Array!</target>
        </trans-unit>
        <trans-unit id="9c8ef39926fd73e765f1eb8ee4fa6bd53c3ec533" translate="yes" xml:space="preserve">
          <source>You should use the &lt;code&gt;for(var x in y)&lt;/code&gt; only on property lists, not on objects (as explained above).</source>
          <target state="translated">Вы должны использовать &lt;code&gt;for(var x in y)&lt;/code&gt; только в списках свойств, а не в объектах (как описано выше).</target>
        </trans-unit>
        <trans-unit id="a96bcd7cc3ea125e82ec1633c0c044086ec4d453" translate="yes" xml:space="preserve">
          <source>You'll get it as part of every array:</source>
          <target state="translated">Вы получите его как часть каждого массива:</target>
        </trans-unit>
        <trans-unit id="451738ae11c58dea638bd4da33b99df9b1367655" translate="yes" xml:space="preserve">
          <source>although not specifically addressed by this question, I would add that there's a very good reason not to ever use for...in with a &lt;code&gt;NodeList&lt;/code&gt; (as one would obtain from a &lt;code&gt;querySelectorAll&lt;/code&gt; call, as it doesn't see the returned elements at all, instead iterating only over the NodeList properties.</source>
          <target state="translated">хотя этот вопрос конкретно не рассматривается, я хотел бы добавить, что есть очень веская причина не использовать for ... in с &lt;code&gt;NodeList&lt;/code&gt; (как можно было бы получить из вызова querySelectorAll , поскольку он вообще не видит возвращаемые элементы вместо этого перебирая только свойства NodeList.</target>
        </trans-unit>
        <trans-unit id="b01218ba4e2077e27d32f94c86b9d176de94e14e" translate="yes" xml:space="preserve">
          <source>but this is true for iterating over any object with a for-in loop.</source>
          <target state="translated">но это верно для итерации по любому объекту с циклом for-in.</target>
        </trans-unit>
        <trans-unit id="409e3dd82374e4e55f29d3a98652e2ae85e1e66f" translate="yes" xml:space="preserve">
          <source>can sometimes be totally different from the other:</source>
          <target state="translated">иногда может полностью отличаться от других:</target>
        </trans-unit>
        <trans-unit id="d26272a8e99b364a53d8375d2aaf9e58565fdc59" translate="yes" xml:space="preserve">
          <source>in the case of a single result, I got:</source>
          <target state="translated">в случае единичного результата,я получил:</target>
        </trans-unit>
        <trans-unit id="da1ab8a35220f16c304ed232b0ce34d0d22e60c1" translate="yes" xml:space="preserve">
          <source>in the loop, but the first structure is more direct.</source>
          <target state="translated">в цикле,но первая структура более прямая.</target>
        </trans-unit>
        <trans-unit id="38d998cc7ed3a4c5ac9f65bf863b7c90ce1fc902" translate="yes" xml:space="preserve">
          <source>it's slow because you have to walk all properties of the array object and its whole prototype chain and will still only get the property's name, ie to get the value, an additional lookup will be required</source>
          <target state="translated">это медленно,потому что вам придется пройтись по всем свойствам объекта массива и всей его цепочки прототипов и при этом получить только имя свойства,т.е.чтобы получить значение,потребуется дополнительный поиск</target>
        </trans-unit>
        <trans-unit id="f34c97c6342dac87f71ff8d0ba7b7f737b6be403" translate="yes" xml:space="preserve">
          <source>whereas,</source>
          <target state="translated">whereas,</target>
        </trans-unit>
        <trans-unit id="7c5e58bccc2148f04b16afa5d9963af3bc3acc1b" translate="yes" xml:space="preserve">
          <source>which explained why my &lt;code&gt;for (node in nodes) node.href = newLink;&lt;/code&gt; was failing.</source>
          <target state="translated">который объяснил, почему мой &lt;code&gt;for (node in nodes) node.href = newLink;&lt;/code&gt; терпел неудачу.</target>
        </trans-unit>
        <trans-unit id="7c400da46a809de9bf574c312d350ee791784418" translate="yes" xml:space="preserve">
          <source>will write</source>
          <target state="translated">будет писать</target>
        </trans-unit>
        <trans-unit id="5c923b1cf4e840a71705024b687048a1b3731fba" translate="yes" xml:space="preserve">
          <source>you could solve this with the hasOwnProperty method:</source>
          <target state="translated">ты можешь решить это методом hasOwnProperty:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
