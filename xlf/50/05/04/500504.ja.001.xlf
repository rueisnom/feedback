<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/500504">
    <body>
      <group id="500504">
        <trans-unit id="4bd6398b6ec50d16e0ba8b718869fa0726943b47" translate="yes" xml:space="preserve">
          <source>(Emphasis mine.)</source>
          <target state="translated">(私が強調します)</target>
        </trans-unit>
        <trans-unit id="d8063be2dd09276b0e12dbda5c629337424e931e" translate="yes" xml:space="preserve">
          <source>1.) There is already a higher order function, or method, that has that purpose for an array, but has more functionality and leaner syntax, called 'forEach': &lt;code&gt;Array.prototype.forEach(function(element, index, array) {} );&lt;/code&gt;</source>
          <target state="translated">1.）配列に対してその目的を持つ、より高次の関数またはメソッドが既に存在しますが、「forEach」と呼ばれるより多くの機能性と &lt;code&gt;Array.prototype.forEach(function(element, index, array) {} );&lt;/code&gt; 構文があります： Array.prototype.forEach（function（element、index、array）{ }）;</target>
        </trans-unit>
        <trans-unit id="7f5212d015eaea70f541c879dc9a1ee3ee6ea4e6" translate="yes" xml:space="preserve">
          <source>2.) Arrays always have a length, but &lt;code&gt;for...in&lt;/code&gt; and &lt;code&gt;forEach&lt;/code&gt; do not execute a function for any value that is &lt;code&gt;'undefined'&lt;/code&gt;, only for the indexes that have a value defined. So if you only assign one value, these loops will only execute a function once, but since an array is enumerated, it will always have a length up to the highest index that has a defined value, but that length could go unnoticed when using these loops.</source>
          <target state="translated">2.）配列には常に長さがあり &lt;code&gt;for...in&lt;/code&gt; が、 for ... inおよび &lt;code&gt;forEach&lt;/code&gt; は、値が定義されていないインデックスに対してのみ、 &lt;code&gt;'undefined'&lt;/code&gt; である値に対して関数を実行しません。 したがって、値を1つだけ割り当てた場合、これらのループは関数を1回だけ実行しますが、配列が列挙されるため、定義された値を持つ最大のインデックスまでの長さが常にありますが、これらの長さはこれらを使用すると気付かれない場合がありますループ。</target>
        </trans-unit>
        <trans-unit id="1a000b47a2784ab5959eeb6bb68516347e56d65f" translate="yes" xml:space="preserve">
          <source>3.) The standard for loop will execute a function as many times as you define in the parameters, and since an array is numbered, it makes more sense to define how many times you want to execute a function. Unlike the other loops, the for loop can then execute a function for every index in the array, whether the value is defined or not.</source>
          <target state="translated">3.)標準のforループは、パラメータで定義した回数だけ関数を実行します。配列は番号が付けられているので、関数を何回実行するかを定義する方が理にかなっています。他のループとは異なり、forループは、値が定義されているかどうかに関わらず、配列の各インデックスに対して関数を実行することができます。</target>
        </trans-unit>
        <trans-unit id="85146881dc047a08449a004a02b095cacd0cb609" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for (... in ...)&lt;/code&gt; is not guaranteed to return the object properties in sequential order, as one might expect.</source>
          <target state="translated">&lt;code&gt;for (... in ...)&lt;/code&gt; は、予想どおり、オブジェクトのプロパティを順番に返すことは保証されていません。</target>
        </trans-unit>
        <trans-unit id="f7fb489c373f09f65363d8fdde0d33f885cc248d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; lists only the &lt;code&gt;5&lt;/code&gt;, ignoring undefined array indexes, but adding &lt;code&gt;foo&lt;/code&gt;. It shows array &lt;strong&gt;property names&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; は &lt;code&gt;5&lt;/code&gt; のみをリストし、未定義の配列インデックスは無視しますが、 &lt;code&gt;foo&lt;/code&gt; を追加します。 配列の&lt;strong&gt;プロパティ名が&lt;/strong&gt;表示されます。</target>
        </trans-unit>
        <trans-unit id="7c070578b97dc889d040320474709963bba8ff11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops &lt;strong&gt;do not guarantee a specific iteration order&lt;/strong&gt;. Although is order is usually seen in most modern browsers these days, there is still no 100% guarantee.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; ループ&lt;strong&gt;は、特定の反復順序を保証するものではありません&lt;/strong&gt; 。 最近ではほとんどの最新ブラウザーで順序が見られますが、100％の保証はまだありません。</target>
        </trans-unit>
        <trans-unit id="75add2a4d0fc3dfc08d7b2e03792fa72128dc96e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops ignore &lt;code&gt;undefined&lt;/code&gt; array elements, i.e. array elements which not have been assigned yet.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; ループは、 &lt;code&gt;undefined&lt;/code&gt; 配列要素、つまりまだ割り当てられていない配列要素を無視します。</target>
        </trans-unit>
        <trans-unit id="e02c78b83b9baae453efbdb0e530f06924f7cb8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...in&lt;/code&gt; loops iterate over all their own enumerable properties &lt;strong&gt;and&lt;/strong&gt; the enumerable properties of their prototype(s). Usually in an array iteration we only want to iterate over the array itself. And even though you yourself may not add anything to the array, your libraries or framework might add something.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; ループは、独自の列挙可能なプロパティ&lt;strong&gt;と&lt;/strong&gt;プロトタイプの列挙可能なプロパティすべてを反復します。 通常、配列の反復では、配列自体を反復するだけです。 そして、あなた自身が配列に何も追加しなくても、ライブラリまたはフレームワークが何かを追加する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5b510d520668177a37ca1233fffcce16d554bed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for...of&lt;/code&gt; counts from 0 to 5, and also ignores &lt;code&gt;Array.prototype.foo&lt;/code&gt;. It shows array &lt;strong&gt;values&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;for...of&lt;/code&gt; は0から5までカウントし、 &lt;code&gt;Array.prototype.foo&lt;/code&gt; も無視します 。 配列の&lt;strong&gt;値が&lt;/strong&gt;表示され&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="de8d59ac496d49a3cc2830db61e5080ba7b3ed4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; isn't guaranteed to preserve element ordering</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; は要素の順序を保持することが保証されていません</target>
        </trans-unit>
        <trans-unit id="57c504b07cbe053e6d9258c6e6ce9dab71001517" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..in&lt;/code&gt; will loop over all own and inherited properties of the array object which aren't &lt;code&gt;DontEnum&lt;/code&gt;; that means if someone adds properties to the specific array object (there are valid reasons for this - I've done so myself) or changed &lt;code&gt;Array.prototype&lt;/code&gt; (which is considered bad practice in code which is supposed to work well with other scripts), these properties will be iterated over as well; inherited properties can be excluded by checking &lt;code&gt;hasOwnProperty()&lt;/code&gt;, but that won't help you with properties set in the array object itself</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; は、 &lt;code&gt;DontEnum&lt;/code&gt; でない、配列オブジェクトのすべての独自のプロパティと継承されたプロパティをループします。 つまり、誰かが特定の配列オブジェクトにプロパティを追加した場合（これには正当な理由があります-私自身が行いました）、または &lt;code&gt;Array.prototype&lt;/code&gt; を変更した場合 （これは、他のスクリプトで適切に機能するはずのコードでは悪い習慣と見なされています）、これらのプロパティも繰り返されます。 継承されたプロパティは、 &lt;code&gt;hasOwnProperty()&lt;/code&gt; をチェックすることで除外できますが、配列オブジェクト自体に設定されたプロパティは役立ちません</target>
        </trans-unit>
        <trans-unit id="5c924ba7b90dce15af127843f7697ca7dc50c687" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="b0a4e9b74e35d5bb4223b2cc511f2cfc42e49e60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="ed70972dc116b90558966dcf0dc7a880652a1079" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It loops through inherited properties as well:&lt;/strong&gt; First of all any extensions to the &lt;code&gt;Array.prototype&lt;/code&gt; should have been done by using &lt;a href=&quot;https://developer.mozilla.org/tr/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt;&lt;/a&gt; and their &lt;code&gt;enumerable&lt;/code&gt; descriptor should be set to &lt;code&gt;false&lt;/code&gt;. Any library not doing so should not be used at all.</source>
          <target state="translated">&lt;strong&gt;継承されたプロパティもループします。&lt;/strong&gt;まず、 &lt;code&gt;Array.prototype&lt;/code&gt; の拡張はすべて&lt;a href=&quot;https://developer.mozilla.org/tr/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt; &lt;code&gt;Object.defineProperty()&lt;/code&gt; &lt;/a&gt;を使用して行われ、 &lt;code&gt;enumerable&lt;/code&gt; 記述子は &lt;code&gt;false&lt;/code&gt; に設定されている必要があります 。 そうしていないライブラリは使用しないでください。</target>
        </trans-unit>
        <trans-unit id="864471cf89b4825cee0c68d43263743a49b07aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;One&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;One&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2930f375e598c4c0cda99ef5ee5ced807b11895f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Properties those you add to the inheritance chain later get counted:&lt;/strong&gt; When doing array sub-classing by &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or by Class &lt;code&gt;extend&lt;/code&gt;. You should again use &lt;code&gt;Object.defineProperty()&lt;/code&gt; which by default sets the &lt;code&gt;writable&lt;/code&gt;, &lt;code&gt;enumerable&lt;/code&gt; and &lt;code&gt;configurable&lt;/code&gt; property descriptors to &lt;code&gt;false&lt;/code&gt;. Lets see an array sub-classing example here...</source>
          <target state="translated">&lt;strong&gt;継承チェーンに追加したプロパティは、後でカウント&lt;/strong&gt;されます &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; またはClass &lt;code&gt;extend&lt;/code&gt; による配列のサブクラス化を行う場合。 再度 &lt;code&gt;Object.defineProperty()&lt;/code&gt; を使用する必要があります。これは、デフォルトで &lt;code&gt;writable&lt;/code&gt; 、 &lt;code&gt;enumerable&lt;/code&gt; 可能 、および &lt;code&gt;configurable&lt;/code&gt; 可能なプロパティ記述子を &lt;code&gt;false&lt;/code&gt; に 設定します 。 ここで配列のサブクラス化の例を見てみましょう...</target>
        </trans-unit>
        <trans-unit id="1d17c64273e3caf29ac784b4ed9036aa7703f21e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL&amp;amp;DR:&lt;/strong&gt; Using the &lt;code&gt;for in&lt;/code&gt; loop in arrays is not evil, in fact quite the opposite.</source>
          <target state="translated">&lt;strong&gt;TL＆DR：&lt;/strong&gt;配列で &lt;code&gt;for in&lt;/code&gt; ループを使用することは悪ではなく、実際には逆です。</target>
        </trans-unit>
        <trans-unit id="f4a90667800dfac206439640fe039e0a8ec77ce8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;code&gt;for in&lt;/code&gt; loop is slow:&lt;/strong&gt; Hell no. It's by far the fastest method of iteration if you are looping over sparse arrays which are needed time to time. This is one of the most important performance tricks that one should know. Let's see an example. We will loop over a sparse array.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;for in&lt;/code&gt; ループが遅い：&lt;/strong&gt;地獄いいえ。 時々必要なスパース配列をループする場合は、これが最も高速な反復方法です。 これは、知っておくべき最も重要なパフォーマンストリックの1つです。 例を見てみましょう。 スパース配列をループします。</target>
        </trans-unit>
        <trans-unit id="7e70c28d46516e16a285932547326e3516ac248f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Two&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Two&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aa55c4c1ec6fa0600a16d8a1df0ed62aebb5a00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for...in&lt;/strong&gt; is useful when working on an object in JavaScript, but not for an Array, but still we can not say it's a wrong way, but it's not recommended, look at this example below using &lt;strong&gt;for...in&lt;/strong&gt; loop:</source>
          <target state="translated">&lt;strong&gt;for ... in&lt;/strong&gt;は、JavaScriptでオブジェクトを操作するときに便利ですが、配列に対しては使用できませんが、間違った方法であるとは言えませんが、お勧めできません&lt;strong&gt;。&lt;/strong&gt;以下の&lt;strong&gt;for ... in&lt;/strong&gt;ループを使用&lt;strong&gt;した&lt;/strong&gt;例をご覧ください。</target>
        </trans-unit>
        <trans-unit id="723137f7795e3401755b70d4616c338ef4c6b6e9" translate="yes" xml:space="preserve">
          <source>A for...in loop always enumerates the keys.
Objects properties keys are always String, even the indexed properties of an array :</source>
          <target state="translated">for...inループは常にキーを列挙します。オブジェクトのプロパティのキーは、配列のインデックス付きプロパティであっても、常に String です。</target>
        </trans-unit>
        <trans-unit id="e380bf6c22148b057e16f813b7f95eb85c229ee9" translate="yes" xml:space="preserve">
          <source>A real answer for this will depend on how the browser parsers/interpret the JavaScript code. It can change between browsers.</source>
          <target state="translated">これに対する本当の答えは、ブラウザのパーサーがJavaScriptのコードをどのように解釈するかに依存します。それはブラウザ間で変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f8ee733770af90d6a036b73e38df85ea12e55c2" translate="yes" xml:space="preserve">
          <source>Also consider that &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; libraries might do things like this, which will affect any array you create:</source>
          <target state="translated">また、 &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;ライブラリーが次のようなことを行う可能性があることを考慮してください。これは、作成するすべての配列に影響します。</target>
        </trans-unit>
        <trans-unit id="81a354e95f9aef67cb843763fd3927258da5fdda" translate="yes" xml:space="preserve">
          <source>Also, due to semantics, the way &lt;code&gt;for, in&lt;/code&gt; treats arrays (i.e. the same as any other JavaScript object) is not aligned with other popular languages.</source>
          <target state="translated">また、セマンティクスの &lt;code&gt;for, in&lt;/code&gt; 配列の扱い方（つまり、他のJavaScriptオブジェクトと同じ）は、他の一般的な言語と整合していません。</target>
        </trans-unit>
        <trans-unit id="56813a034610fd55b9667a342f05765d16c2560a" translate="yes" xml:space="preserve">
          <source>Also, it may be considered a better practice to use the &lt;code&gt;forEach&lt;/code&gt; method than the &lt;code&gt;for...in&lt;/code&gt; loop in general, because it is easier to write and has more functionality, so you may want to get in the habit of only using this method and standard for, but your call.</source>
          <target state="translated">また、一般的に &lt;code&gt;for...in&lt;/code&gt; ループよりも &lt;code&gt;forEach&lt;/code&gt; メソッドを使用する方が良い方法と見なされる場合があります。これは、記述が簡単で機能が多いため、このメソッドのみを使用する習慣を身に付けたい場合があるためです。と標準ですが、あなたの呼び出し。</target>
        </trans-unit>
        <trans-unit id="8e9ef6ce457a097e6cbaa9a5cee537865b67b8ae" translate="yes" xml:space="preserve">
          <source>Also, speaking about inherited properties, if you, for example, extend the &lt;code&gt;Array.prototype&lt;/code&gt; object (like some libraries as MooTools do), that properties will be also enumerated:</source>
          <target state="translated">また、継承されたプロパティについて言えば、たとえば、（MooToolsのように一部のライブラリのように） &lt;code&gt;Array.prototype&lt;/code&gt; オブジェクトを拡張すると、そのプロパティも列挙されます。</target>
        </trans-unit>
        <trans-unit id="77e8cec41cc494061a090fc5862a2f2e51506df4" translate="yes" xml:space="preserve">
          <source>Also, the order of iteration is not guaranteed by the spec., meaning that if you want to &quot;iterate&quot; an array object, with this statement you cannot be sure that the properties (array indexes) will be visited in the numeric order.</source>
          <target state="translated">また、反復処理の順序は仕様では保証されていません。つまり、配列オブジェクトを「反復処理」したい場合、この文ではプロパティ(配列のインデックス)が数値順に訪問されるかどうかは保証できません。</target>
        </trans-unit>
        <trans-unit id="4caa9f9af0086837955f928c936648d78e3cf12c" translate="yes" xml:space="preserve">
          <source>An alternative way of iterating through an array is using a for-loop:</source>
          <target state="translated">配列を反復処理する別の方法として、for-loopを使用する方法があります。</target>
        </trans-unit>
        <trans-unit id="4330d9777faffc1aebc6faa887599a7ad547c366" translate="yes" xml:space="preserve">
          <source>An important aspect is that &lt;code&gt;for...in&lt;/code&gt; only iterates over properties contained in an object which have their &lt;strong&gt;enumerable&lt;/strong&gt;&lt;em&gt;property attribute&lt;/em&gt; set to true. So if one attempts to iterate over an object using &lt;code&gt;for...in&lt;/code&gt; then arbitrary properties may be missed if their enumerable property attribute is false. It is quite possible to alter the enumerable property attribute for normal Array objects so that certain elements are not enumerated. Though in general the property attributes tend to apply to function properties within an object.</source>
          <target state="translated">重要な点は、 &lt;strong&gt;列挙可能な&lt;/strong&gt; &lt;em&gt;プロパティ属性&lt;/em&gt;がtrueに設定されているオブジェクトに含まれるプロパティのみを反復することです。 したがって、 &lt;code&gt;for...in&lt;/code&gt; を使用してオブジェクトを反復しようとすると、列挙可能なプロパティ属性がfalseの場合、任意のプロパティが失われる可能性があります。 特定の要素が列挙されないように、通常のArrayオブジェクトの列挙可能なプロパティ属性を変更することは十分に可能です。 一般に、プロパティ属性はオブジェクト内の関数プロパティに適用される傾向があります。</target>
        </trans-unit>
        <trans-unit id="bdc123fed57544f574b847785e448b373aff2349" translate="yes" xml:space="preserve">
          <source>And since you can never be sure that nothing will be added to the prototype chain just use a for loop to enumerate the array:</source>
          <target state="translated">プロトタイプチェーンに何も追加されないということはありえないので、forループを使って配列を列挙します。</target>
        </trans-unit>
        <trans-unit id="ad0c718b13ffaf815489fe18ec085881a6be06e3" translate="yes" xml:space="preserve">
          <source>And some people even recommend calling the method directly from &lt;code&gt;Object.prototype&lt;/code&gt; to avoid having problems if somebody adds a property named &lt;code&gt;hasOwnProperty&lt;/code&gt; to our object:</source>
          <target state="translated">また、オブジェクトに &lt;code&gt;hasOwnProperty&lt;/code&gt; という名前のプロパティを追加した場合に問題が発生しないように、 &lt;code&gt;Object.prototype&lt;/code&gt; から直接メソッドを呼び出すことを勧める人もいます。</target>
        </trans-unit>
        <trans-unit id="35888521210af7f9dd1e0af389345f2c1f605553" translate="yes" xml:space="preserve">
          <source>Any object can have arbitrary properties associated with it. There would be nothing terrible about loading additional properties onto an array instance, in particular. Code that wants to see &lt;em&gt;only&lt;/em&gt; indexed array-like properties therefore &lt;em&gt;must&lt;/em&gt; stick to an integer index. Code that is fully aware of what &lt;code&gt;for ... in&lt;/code&gt; does and really &lt;em&gt;need&lt;/em&gt; to see all properties, well then that's ok too.</source>
          <target state="translated">どのオブジェクトにも任意のプロパティを関連付けることができます。 特に配列インスタンスに追加のプロパティをロードすることについて、ひどいことは何もありません。 したがって、インデックス付きの配列のようなプロパティ&lt;em&gt;のみ&lt;/em&gt;を表示するコードは、整数インデックスに固執する&lt;em&gt;必要があり&lt;/em&gt;ます。 &lt;code&gt;for ... in&lt;/code&gt; 完全に認識しているコードは実際にすべてのプロパティを表示&lt;em&gt;する必要&lt;/em&gt;がありますが、それでも問題&lt;em&gt;あり&lt;/em&gt;ません。</target>
        </trans-unit>
        <trans-unit id="8ae256cf5a988279dae9f08c26581718bda89b9c" translate="yes" xml:space="preserve">
          <source>As I said before to &lt;em&gt;iterate&lt;/em&gt; over arrays or array-like objects, the best thing is to use a &lt;em&gt;sequential loop&lt;/em&gt;, such as a plain-old &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loop.</source>
          <target state="translated">配列または配列のようなオブジェクトを&lt;em&gt;反復処理&lt;/em&gt;するために前に述べたように、最良のことは、単純な古い &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; ループなどの&lt;em&gt;順次ループ&lt;/em&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="6223893ff2388e165f873960bac2ba5392b49cb2" translate="yes" xml:space="preserve">
          <source>As of 2016 (ES6) we may use &lt;code&gt;for&amp;hellip;of&lt;/code&gt; for array iteration, as John Slegers already noticed.</source>
          <target state="translated">John Slegersがすでに気づいたように、2016年（ES6）以降は、配列の反復に &lt;code&gt;for&amp;hellip;of&lt;/code&gt; を使用する可能性があります。</target>
        </trans-unit>
        <trans-unit id="b9ffc247af1b8ed568d6b5c1b3a27e66e602fc7e" translate="yes" xml:space="preserve">
          <source>As you see the result the same...</source>
          <target state="translated">結果は同じように...</target>
        </trans-unit>
        <trans-unit id="894f0d6f0a5dc7e6d9477fd432341a08cc075bbf" translate="yes" xml:space="preserve">
          <source>Aside from the fact that &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; loops over all enumerable properties (which is &lt;em&gt;not&lt;/em&gt; the same as &quot;all array elements&quot;!), see &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&quot;&gt;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&lt;/a&gt;, section 12.6.4 (5th edition) or 13.7.5.15 (7th edition):</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;in&lt;/code&gt; が列挙可能なすべてのプロパティ（「すべての配列要素」と同じでは&lt;em&gt;ない&lt;/em&gt; ）をループするという事実は別として、 &lt;a href=&quot;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&quot;&gt;http：//www.ecma-international.org/publications/files/ECMA-STを&lt;/a&gt;参照してください。 /Ecma-262.pdf 、セクション12.6.4（第5版）または13.7.5.15（第7版）：</target>
        </trans-unit>
        <trans-unit id="eb7d92e5a3d183746be4cc4443582416eca4294e" translate="yes" xml:space="preserve">
          <source>Because for...in enumerates through the object that holds the array, not the array itself. If I add a function to the arrays prototype chain, that will also be included. I.e.</source>
          <target state="translated">なぜなら、for...inは配列そのものではなく、配列を保持しているオブジェクトを介して列挙するからです。配列のプロトタイプチェーンに関数を追加した場合、それも含まれます。つまり</target>
        </trans-unit>
        <trans-unit id="b96448a2e10a4868599ab0a74179eb46b603e8f6" translate="yes" xml:space="preserve">
          <source>Because it enumerates through object fields, not indexes. You can get value with index &quot;length&quot; and I doubt you want this.</source>
          <target state="translated">なぜなら、インデックスではなくオブジェクトフィールドを通して列挙するからです。インデックス &quot;length &quot;で値を取得することができますが、これは必要ないでしょう。</target>
        </trans-unit>
        <trans-unit id="8992d96aafc9f0ab11805a540be31b57da2de068" translate="yes" xml:space="preserve">
          <source>Because it will iterate over properties belonging to objects up the prototype chain if you're not careful.</source>
          <target state="translated">注意しないと、プロトタイプチェーンの上位にあるオブジェクトに属するプロパティを反復処理してしまうからです。</target>
        </trans-unit>
        <trans-unit id="ee90f63ccf1f6222ef3e10f7c081882454ec920d" translate="yes" xml:space="preserve">
          <source>But in my opinion, it's better to use &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;, the process required for that auto-detection is very small.</source>
          <target state="translated">しかし、私の意見では &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; 使用する方が良いです。その自動検出に必要なプロセスは非常に小さいです。</target>
        </trans-unit>
        <trans-unit id="12279b51e8d023c0ad5031c9a0b1e701ef3132e1" translate="yes" xml:space="preserve">
          <source>But let's try something, let's prototype something to &lt;strong&gt;Array&lt;/strong&gt;...</source>
          <target state="translated">しかし、何かを試してみましょう。Arrayに何かのプロトタイプを作成しましょう...</target>
        </trans-unit>
        <trans-unit id="43740775866432b484bee9f9cd495c479fdafbb1" translate="yes" xml:space="preserve">
          <source>Either way, &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; carries with it no connotation of order.  If you care about order, be explicit about it and use a regular &lt;code&gt;for&lt;/code&gt; loop with an index.</source>
          <target state="translated">いずれにせよ、〜の &lt;code&gt;in&lt;/code&gt; は順序の意味合いはありません。 順序を気にする場合は、順序を明示し、インデックス付きの通常の &lt;code&gt;for&lt;/code&gt; ループを使用してください。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="0f0d139be39da72d26c2fc44d8e9127747d60e99" translate="yes" xml:space="preserve">
          <source>For example, in JScript (IE &amp;lt;= 8), the order of enumeration even on Array objects is defined as the properties were created:</source>
          <target state="translated">たとえば、JScript（IE &amp;lt;= 8）では、プロパティが作成されたときに、Arrayオブジェクトでも列挙の順序が定義されます。</target>
        </trans-unit>
        <trans-unit id="2428f10d15c193c4c3f102bd0050a7d4e2a6f520" translate="yes" xml:space="preserve">
          <source>For these reasons an acceptable trade-off between performance and convenience doesn't even exist.  There's really no benefit unless the intent is to handle the array as an &lt;em&gt;object&lt;/em&gt; and perform operations on the object properties of the array.</source>
          <target state="translated">これらの理由により、パフォーマンスと利便性の間の許容できるトレードオフは存在しません。 目的が配列を&lt;em&gt;オブジェクト&lt;/em&gt;として処理し、配列のオブジェクトプロパティに対して操作を実行することでない限り、実際には何のメリットもありません。</target>
        </trans-unit>
        <trans-unit id="32b5cb0e39239e899eede9d898b826f9b8871c75" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections&lt;/a&gt;から</target>
        </trans-unit>
        <trans-unit id="68c380cf4529191d6c4d7cbc7090efd3852b6892" translate="yes" xml:space="preserve">
          <source>Here are the reasons why this is (usually) a bad practice:</source>
          <target state="translated">これが(通常は)悪い習慣である理由をご紹介します。</target>
        </trans-unit>
        <trans-unit id="8800cd23cee45b4bed05921ce5f6db9ef6fde066" translate="yes" xml:space="preserve">
          <source>However, if your code (or the framework you are using) add custom properties to arrays or to the array prototype, then these properties will be included in the iteration, which is probably not what you want.</source>
          <target state="translated">しかし、あなたのコード (または使用しているフレームワーク)が配列や配列プロトタイプにカスタムプロパティを追加した場合、これらのプロパティは反復処理に含まれます。</target>
        </trans-unit>
        <trans-unit id="3f41c8e3bf1d0164c41613e45d4575733160cd11" translate="yes" xml:space="preserve">
          <source>However, this have a different issue. The issue is that a JavaScript array can have &quot;holes&quot;. If you define &lt;code&gt;arr&lt;/code&gt; as:</source>
          <target state="translated">ただし、これには別の問題があります。 問題は、JavaScript配列に「穴」がある可能性があることです。 &lt;code&gt;arr&lt;/code&gt; を次のように定義すると、</target>
        </trans-unit>
        <trans-unit id="4609f4613ee2485b87e9ea3693f15a345fdc5bff" translate="yes" xml:space="preserve">
          <source>I can't think of other purposes to not using &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; を使用しない他の目的は考えられません。</target>
        </trans-unit>
        <trans-unit id="c84398cbe7864ec7d29debf086fe632c20a743ee" translate="yes" xml:space="preserve">
          <source>I do, however, would like to add that &lt;strong&gt;in modern browsers&lt;/strong&gt; there is an alternative to &lt;code&gt;for...in&lt;/code&gt; that can be used in those cases where &lt;code&gt;for...in&lt;/code&gt; can't be used. That alternative is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/a&gt; :</source>
          <target state="translated">ただし、 &lt;strong&gt;最近のブラウザー&lt;/strong&gt;では、 &lt;code&gt;for...in&lt;/code&gt; を使用できない場合に使用できるfor ... inの代替手段があることを付け加えて&lt;strong&gt;おきます&lt;/strong&gt; 。 その代替は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="e3b3a26ba9647b9bce83a99b6dd6343035cd56ae" translate="yes" xml:space="preserve">
          <source>I don't think I have much to add to eg. &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/500531#500531&quot;&gt;Triptych's answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/4261096#4261096&quot;&gt;CMS's answer&lt;/a&gt; on why using &lt;code&gt;for...in&lt;/code&gt; should be avoided in some cases.</source>
          <target state="translated">たとえば、追加することはあまりないと思います。 なぜ &lt;code&gt;for...in&lt;/code&gt; を使用するのかについて&lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/4261096#4261096&quot;&gt;の&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea/500531#500531&quot;&gt;トリプティクの回答&lt;/a&gt;またはCMSの回答は、場合によっては避ける必要があります。</target>
        </trans-unit>
        <trans-unit id="cd3028b86fe1e48337d81eff923a6ece9b04e2b8" translate="yes" xml:space="preserve">
          <source>I think the &lt;code&gt;for in&lt;/code&gt; loop is a gem of JS if used &lt;em&gt;correctly&lt;/em&gt; in arrays. You are expected to have full control over your software and know what you are doing. Let's see the mentioned drawbacks and disprove them one by one.</source>
          <target state="translated">配列で&lt;em&gt;正しく&lt;/em&gt;使用すれば、 &lt;code&gt;for in&lt;/code&gt; ループはJSの逸品だと思います。 ソフトウェアを完全に制御し、自分が何をしているかを理解していることが求められます。 前述の欠点を見て、それらを1つずつ反証しましょう。</target>
        </trans-unit>
        <trans-unit id="3c5457f2a9b947636475a19d3f1132040b65b1d3" translate="yes" xml:space="preserve">
          <source>I would just like to add this simple demonstration code, to make things clearer:</source>
          <target state="translated">物事をより明確にするために、この簡単なデモコードを追加したいと思います。</target>
        </trans-unit>
        <trans-unit id="64e3da07990d73da0857766c8c4119fdfa3d8581" translate="yes" xml:space="preserve">
          <source>I've been told not to use &lt;code&gt;for...in&lt;/code&gt; with arrays in JavaScript. Why not?</source>
          <target state="translated">JavaScriptの配列で &lt;code&gt;for...in&lt;/code&gt; 使用しないように言われました。 何故なの？</target>
        </trans-unit>
        <trans-unit id="97e955c989e786a9c59188ad385759593bc273f9" translate="yes" xml:space="preserve">
          <source>If a function called &lt;code&gt;helpfulUtilityMethod&lt;/code&gt; has been added to &lt;code&gt;Array&lt;/code&gt;'s &lt;code&gt;prototype&lt;/code&gt;, then your loop would end up running four times: &lt;code&gt;key&lt;/code&gt; would be &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;helpfulUtilityMethod&lt;/code&gt;.  If you were only expecting integers, oops.</source>
          <target state="translated">&lt;code&gt;helpfulUtilityMethod&lt;/code&gt; と呼ばれる関数が &lt;code&gt;Array&lt;/code&gt; の &lt;code&gt;prototype&lt;/code&gt; 追加されている場合、ループは最終的に4回実行されます。 &lt;code&gt;key&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt; 、1、2 、および &lt;code&gt;helpfulUtilityMethod&lt;/code&gt; です。 整数しか期待していない場合は、おっと。</target>
        </trans-unit>
        <trans-unit id="36c04e2865843e125432c9e852edd02d54e879a0" translate="yes" xml:space="preserve">
          <source>If you are in doubt, you probably shouldn't use for-in.</source>
          <target state="translated">迷っているなら、フォーインは使わない方がいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="3f9cf51b07160b61873b4313b13e4209e40cf8d3" translate="yes" xml:space="preserve">
          <source>In addition to the other problems, the &quot;for..in&quot; syntax is probably slower, because the index is a string, not an integer.</source>
          <target state="translated">他の問題に加えて、インデックスが整数ではなく文字列なので、&quot;for...in &quot;構文の方が遅いのかもしれません。</target>
        </trans-unit>
        <trans-unit id="5d7f89f56c3c8e5432b67de63d59ca4ec8daee20" translate="yes" xml:space="preserve">
          <source>In addition to the reasons given in other answers, you may not want to use the &quot;for...in&quot; structure if you need to do math with the counter variable because the loop iterates through the names of the object's properties and so the variable is a string.</source>
          <target state="translated">他の回答で与えられた理由に加えて、カウンタ変数で数学を行う必要がある場合は、&quot;for...in &quot;構造を使用しない方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="987fa132a1fc4549a83c1787f42d94ea85f4d2a2" translate="yes" xml:space="preserve">
          <source>In essence, you can use any loop, but you should remember exactly how they work. Understand the conditions upon which the different loops reiterate, their separate functionalities, and realize they will be more or less appropriate for differing scenarios.</source>
          <target state="translated">本質的には、どのようなループを使用しても構いませんが、それらがどのように動作するかを正確に覚えておく必要があります。異なるループが繰り返し使用される条件、それぞれの機能を理解し、異なるシナリオに合わせて多かれ少なかれ適切なものになることを理解してください。</target>
        </trans-unit>
        <trans-unit id="aec6fa3400776b4a7fb59542b27ba833e3407a93" translate="yes" xml:space="preserve">
          <source>In isolation, there is nothing wrong with using for-in on arrays. For-in iterates over the property names of an object, and in the case of an &quot;out-of-the-box&quot; array, the properties corresponds to the array indexes. (The built-in propertes like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;toString&lt;/code&gt; and so on are not included in the iteration.)</source>
          <target state="translated">単独では、配列でfor-inを使用しても何も問題はありません。 for-inはオブジェクトのプロパティ名を反復処理します。「すぐに使える」配列の場合、プロパティは配列のインデックスに対応します。 （ &lt;code&gt;length&lt;/code&gt; 、 &lt;code&gt;toString&lt;/code&gt; などの組み込みプロパティは反復には含まれません。）</target>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">言い換えれば</target>
        </trans-unit>
        <trans-unit id="734568a26e2da175e7b2711963a36f6889e16233" translate="yes" xml:space="preserve">
          <source>In practice, most browsers currently like to iterate in roughly the same order.  But there's nothing saying they have to.  That's implementation specific, and could change at any time if another way was found to be far more efficient.</source>
          <target state="translated">実際には、現在ほとんどのブラウザは大体同じ順番で反復することを好みます。しかし、そうしなければならないということは何もありません。これは実装上の問題であり、他の方法の方がはるかに効率的であることが判明した場合には、いつでも変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="63b585b5d4653967345fb2a5acb868a3bc4a2b69" translate="yes" xml:space="preserve">
          <source>It's not &lt;em&gt;necessarily&lt;/em&gt; bad (based on what you're doing), but in the case of arrays, if something has been added to &lt;code&gt;Array.prototype&lt;/code&gt;, then you're going to get strange results.  Where you'd expect this loop to run three times:</source>
          <target state="translated">これは&lt;em&gt;必ずしも&lt;/em&gt;悪いことではありません（何をしているかに基づく）が、配列の場合、何かが &lt;code&gt;Array.prototype&lt;/code&gt; に追加されていると、奇妙な結果が得られます。 このループが3回実行されると予想される場所：</target>
        </trans-unit>
        <trans-unit id="48512dd4b3a3c1f7350ccbc046b3e86d288aef9a" translate="yes" xml:space="preserve">
          <source>JavaScript will automatically determine the way its passes through the items. So if you know that your array is really non-associative you can use &lt;code&gt;for (var i=0; i&amp;lt;=arrayLen; i++)&lt;/code&gt;, and skip the auto-detection iteration.</source>
          <target state="translated">JavaScriptは、アイテムを通過する方法を自動的に決定します。 したがって、配列が実際には非結合であることがわかっている場合は &lt;code&gt;for (var i=0; i&amp;lt;=arrayLen; i++)&lt;/code&gt; 、自動検出の繰り返しをスキップできます。</target>
        </trans-unit>
        <trans-unit id="2f7f0686684ed446fc32930174e01f5395bb10e0" translate="yes" xml:space="preserve">
          <source>Like others have said, You might get keys which aren't in your array or that are inherited from the prototype. So if, let's say, a library adds a property to the Array or Object prototypes:</source>
          <target state="translated">他の人が言っているように、配列にないキーやプロトタイプから継承されたキーを取得することがあるかもしれません。例えば、ライブラリが配列やオブジェクトのプロトタイプにプロパティを追加したとしましょう。</target>
        </trans-unit>
        <trans-unit id="f45b5193da0aaa7c52cb48f0bc144438c2dff04a" translate="yes" xml:space="preserve">
          <source>Long answer: It's just not worth it...</source>
          <target state="translated">長い答えだ それは価値がないだけです...</target>
        </trans-unit>
        <trans-unit id="5585fccb2ae308d5040fc4d2fff80a5c0290f3a8" translate="yes" xml:space="preserve">
          <source>Longer answer: It's just not worth it, even if sequential element order and optimal performance aren't required.</source>
          <target state="translated">長めの回答です。逐次要素の順番や最適な性能が求められていなくても、それだけでは意味がありません。</target>
        </trans-unit>
        <trans-unit id="2b171ef9d258336524bc78a30c41d1586e22ad24" translate="yes" xml:space="preserve">
          <source>Mainly two reasons:</source>
          <target state="translated">主に2つの理由があります。</target>
        </trans-unit>
        <trans-unit id="82155128d69281609acce32458fe028999ca1517" translate="yes" xml:space="preserve">
          <source>Note :</source>
          <target state="translated">注.</target>
        </trans-unit>
        <trans-unit id="af88e59767f8ff55e7690c17ad58d65f053bf1a9" translate="yes" xml:space="preserve">
          <source>Now we create a new Array();</source>
          <target state="translated">ここで、新しいArray()を作成します。</target>
        </trans-unit>
        <trans-unit id="6e27c94a861aeaf1d0ac22ebe6d7a6026d13e8c7" translate="yes" xml:space="preserve">
          <source>OK, let's do it with &lt;strong&gt;Array&lt;/strong&gt; now:</source>
          <target state="translated">さて、今それを&lt;strong&gt;配列で&lt;/strong&gt;やってみましょう：</target>
        </trans-unit>
        <trans-unit id="56bdfee68984425cbf940d97eb5ac6566ed73d68" translate="yes" xml:space="preserve">
          <source>Of course, this can easily be overcome by including</source>
          <target state="translated">もちろん、これは、以下を含めることで簡単に克服することができます。</target>
        </trans-unit>
        <trans-unit id="861d60bb59642c4abc4400719fd6c6e81961b6fa" translate="yes" xml:space="preserve">
          <source>One can check the value of a properties' enumerable property attribute by:</source>
          <target state="translated">プロパティの列挙可能なプロパティ属性の値は、以下の方法で確認することができます。</target>
        </trans-unit>
        <trans-unit id="ee3c6cf9a9fbe4ea8fa522f3b09dbeb432226060" translate="yes" xml:space="preserve">
          <source>Or to obtain all four property attributes:</source>
          <target state="translated">または、4つのプロパティ属性をすべて取得する。</target>
        </trans-unit>
        <trans-unit id="6b7fb34e41e8a58c247a862c50d777d11e97a216" translate="yes" xml:space="preserve">
          <source>See below that the first two loops only execute the console.log statements once, while the standard for loop executes the function as many times as specified, in this case, array.length = 6.</source>
          <target state="translated">最初の 2 つのループは console.log 文を 1 回だけ実行しますが、標準の for ループは指定した回数だけ関数を実行します(この場合は array.length=6)。</target>
        </trans-unit>
        <trans-unit id="d916bf343fb39f0ba6d742b44d8afd005717534b" translate="yes" xml:space="preserve">
          <source>Short answer: It's just not worth it.</source>
          <target state="translated">簡潔な答えだ。それだけでは価値がありません。</target>
        </trans-unit>
        <trans-unit id="28d26e832aa07432925257b320c040f95173eadb" translate="yes" xml:space="preserve">
          <source>Since JavaScript elements are saved as standard object properties, it
  is not advisable to iterate through JavaScript arrays using for...in
  loops because normal elements and all enumerable properties will be
  listed.</source>
          <target state="translated">JavaScriptの要素は標準オブジェクトのプロパティとして保存されるため、通常の要素とすべての列挙可能なプロパティがリストアップされるため、for...inループを使用してJavaScriptの配列を反復処理することはお勧めできません。</target>
        </trans-unit>
        <trans-unit id="4a9c0e2640786d86947354f29810a2bec59ff248" translate="yes" xml:space="preserve">
          <source>So that's one of the reasons why we need to use &lt;strong&gt;for..in&lt;/strong&gt; carefully, but it's not always the case...</source>
          <target state="translated">これが、 &lt;strong&gt;.. inを&lt;/strong&gt;慎重に使用する必要がある理由の1つですが、常にそうであるとは限りません...</target>
        </trans-unit>
        <trans-unit id="43ccb63fe244a71ca951301d73d2ae606c309d0c" translate="yes" xml:space="preserve">
          <source>So you see.. &lt;code&gt;for in&lt;/code&gt; loop is now safe since you cared about your code.</source>
          <target state="translated">コードを気にしているので、 &lt;code&gt;for in&lt;/code&gt; ループは安全です。</target>
        </trans-unit>
        <trans-unit id="a856eaad5930fc3c1ad42c0a1072da1e9a71aa22" translate="yes" xml:space="preserve">
          <source>Some  JS frameworks, like Prototype modifies the Array prototype. Other frameworks like JQuery doesn't, so with JQuery you can safely use for-in.</source>
          <target state="translated">PrototypeのようなJSフレームワークの中には、Arrayのプロトタイプを変更するものがあります。JQueryのような他のフレームワークはそうではないので、JQueryでは安心してfor-inを使うことができます。</target>
        </trans-unit>
        <trans-unit id="241cc38f95d86d00578498c6cd6e9d8e3e40f7b1" translate="yes" xml:space="preserve">
          <source>That means if a browser wanted to, it could go through the properties in the order in which they were inserted.  Or in numerical order.  Or in lexical order (where &quot;30&quot; comes before &quot;4&quot;!  Keep in mind all object keys -- and thus, all array indexes -- are actually strings, so that makes total sense).  It could go through them by bucket, if it implemented objects as hash tables.  Or take any of that and add &quot;backwards&quot;.  A browser could even iterate &lt;em&gt;randomly&lt;/em&gt; and be ECMA-262 compliant, as long as it visited each property exactly once.</source>
          <target state="translated">つまり、ブラウザが希望する場合は、挿入された順序でプロパティを通過できます。 または番号順に。 または、字句順になります（「30」が「4」の前に来ます！すべてのオブジェクトキー（つまり、すべての配列インデックス）は実際には文字列なので、完全に理にかなっていることに注意してください）。 ハッシュテーブルとしてオブジェクトを実装している場合は、バケットでそれらを通過できます。 または、そのいずれかを取り、「後方」を追加します。 ブラウザは、各プロパティに1回だけアクセスする限り、 &lt;em&gt;ランダムに&lt;/em&gt;反復してECMA-262に準拠することもできます。</target>
        </trans-unit>
        <trans-unit id="4925097cf7b88e57feb64e9ce18adcce8750efa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-in&lt;/code&gt; statement by itself is not a &quot;bad practice&quot;, however it can be &lt;em&gt;mis-used&lt;/em&gt;, for example, to &lt;em&gt;iterate&lt;/em&gt; over arrays or array-like objects.</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; ステートメント自体は「悪い習慣」ではありませんが、たとえば、配列や配列のようなオブジェクトを&lt;em&gt;反復処理&lt;/em&gt;するために&lt;em&gt;誤用される&lt;/em&gt;可能性があります。</target>
        </trans-unit>
        <trans-unit id="62abc57f4ad07e973cfe4762c0071680716cdbbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; works with two types of variables: hashtables (associative arrays) and array (non-associative).</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; は、ハッシュテーブル（連想配列）と配列（非連想配列）の2種類の変数で機能します。</target>
        </trans-unit>
        <trans-unit id="a4e5b7446e20249c9f271cc6a796ffd24079b6d5" translate="yes" xml:space="preserve">
          <source>The console shows:</source>
          <target state="translated">コンソールに表示されます。</target>
        </trans-unit>
        <trans-unit id="c373dd9dcd853eabd38b0b011d5e2e23c21a3f2d" translate="yes" xml:space="preserve">
          <source>The mechanics and &lt;strong&gt;order&lt;/strong&gt; of enumerating the properties ... &lt;strong&gt;is not specified&lt;/strong&gt;...</source>
          <target state="translated">プロパティを列挙するメカニズムと&lt;strong&gt;順序&lt;/strong&gt; ... &lt;strong&gt;は指定されていません&lt;/strong&gt; ...</target>
        </trans-unit>
        <trans-unit id="288b516678cca5f53f82af2e6b9622249813364e" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;for ... in ...&lt;/code&gt; &amp;mdash; and this only becomes a problem when a programmer doesn't really understand the language; it's not really a bug or anything &amp;mdash; is that it iterates over &lt;em&gt;all&lt;/em&gt; members of an object (well, all &lt;em&gt;enumerable&lt;/em&gt; members, but that's a detail for now).  When you want to iterate over &lt;em&gt;just&lt;/em&gt; the indexed properties of an array, the only guaranteed way to keep things semantically consistent is to use an integer index (that is, a &lt;code&gt;for (var i = 0; i &amp;lt; array.length; ++i)&lt;/code&gt; style loop).</source>
          <target state="translated">&lt;code&gt;for ... in ...&lt;/code&gt; の問題&amp;mdash;これは、プログラマーが言語を本当に理解していない場合にのみ問題になります。 それは実際にはバグや何かではありません&amp;mdash;オブジェクトの&lt;em&gt;すべての&lt;/em&gt;メンバーを反復処理するということです（まあ、すべての&lt;em&gt;列挙可能な&lt;/em&gt;メンバーですが、今のところ詳細です）。 配列のインデックス付きプロパティ&lt;em&gt;のみ&lt;/em&gt;を反復処理する場合、意味的に一貫性を保つ唯一の保証された方法は、整数インデックスを使用することです（つまり、 &lt;code&gt;for (var i = 0; i &amp;lt; array.length; ++i)&lt;/code&gt; スタイルループ）。</target>
        </trans-unit>
        <trans-unit id="f366257c93fa147fea297156a165fc8f6425c44c" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;for-in&lt;/code&gt; statement is to &lt;em&gt;enumerate&lt;/em&gt; over object properties. This statement will go up in the prototype chain, also enumerating over &lt;em&gt;inherited&lt;/em&gt; properties, a thing that &lt;em&gt;sometimes&lt;/em&gt; is not desired.</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; ステートメントの目的は、オブジェクトのプロパティを&lt;em&gt;列挙&lt;/em&gt;することです。 このステートメントはプロトタイプチェーンで上昇し、 &lt;em&gt;継承された&lt;/em&gt;プロパティも列挙します。これは、望ましくない場合&lt;em&gt;も&lt;/em&gt;あります。</target>
        </trans-unit>
        <trans-unit id="89a42ff68b32c1edc7f8b93e5041095c61ebc5a0" translate="yes" xml:space="preserve">
          <source>The reason is that one construct:</source>
          <target state="translated">理由は、一つの構築物があるからです。</target>
        </trans-unit>
        <trans-unit id="5da49b7ae2a0921436ddcfd460a1e53611ffa346" translate="yes" xml:space="preserve">
          <source>Then the array have two items, but a length of 101. Using for-in will yield two indexes, while the for-loop will yield 101 indexes, where the 99 has a value of &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">次に、配列には2つの項目がありますが、長さは101です。for-inを使用すると2つのインデックスが生成され、forループを使用すると101のインデックスが生成されます。99の値は &lt;code&gt;undefined&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="19e517ee8dfd19dc33ba7657aca3b885dc791954" translate="yes" xml:space="preserve">
          <source>There are three reasons why you shouldn't use &lt;code&gt;for..in&lt;/code&gt; to iterate over array elements:</source>
          <target state="translated">配列要素を反復するために &lt;code&gt;for..in&lt;/code&gt; を使用してはならない理由は3つあります。</target>
        </trans-unit>
        <trans-unit id="0e72dc9f7dbd7a51c36c0e6a445eeb0e565c1d45" translate="yes" xml:space="preserve">
          <source>This is a feature available in ECMAScript 5 - in earlier versions it was not possible to alter the value of the enumerable property attribute (it was always set to true).</source>
          <target state="translated">これは ECMAScript 5 で利用可能な機能です-以前のバージョンでは、enumerable プロパティ属性の値を変更することはできませんでした(それは常に true に設定されていました)。</target>
        </trans-unit>
        <trans-unit id="c340939eba6baf47234d9046c52b928e6cf080c5" translate="yes" xml:space="preserve">
          <source>This will write:</source>
          <target state="translated">これは書きます。</target>
        </trans-unit>
        <trans-unit id="5926b3627ee73db27b2bc9423c0585f3650b0163" translate="yes" xml:space="preserve">
          <source>Unfortunately, no version of Internet Explorer supports &lt;code&gt;for...of&lt;/code&gt; (&lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;Edge 12+&lt;/a&gt; does), so you'll have to wait a bit longer until you can use it in your client side production code. However, it should be safe to use in your server side JS code (if you use &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt;).</source>
          <target state="translated">残念ながら、Internet Explorer &lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;のど&lt;/a&gt;のバージョンも &lt;code&gt;for...of&lt;/code&gt; サポートしていないため（ Edge 12+はサポートしています ）、クライアント側の本番コードで使用できるようになるまでもう少し待つ必要があります。 ただし、サーバー側のJSコードで使用しても安全です（ &lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt;を使用する場合）。</target>
        </trans-unit>
        <trans-unit id="00554097d82380cea803eeb8bfd41d05a2d514a3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;for (var property in array)&lt;/code&gt; will cause &lt;code&gt;array&lt;/code&gt; to be iterated over as an &lt;em&gt;object&lt;/em&gt;, traversing the object prototype chain and ultimately performing slower than an index-based &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">&lt;code&gt;for (var property in array)&lt;/code&gt; すると、 &lt;code&gt;array&lt;/code&gt; が&lt;em&gt;オブジェクト&lt;/em&gt;として反復され、オブジェクトプロトタイプチェーンをトラバースし、最終的にインデックスベースの &lt;code&gt;for&lt;/code&gt; ループよりもパフォーマンスが低下します。</target>
        </trans-unit>
        <trans-unit id="9c96a1056df973395a0c429bef208a88ee62a434" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;hasOwnProperty()&lt;/code&gt; and &lt;code&gt;!isNaN()&lt;/code&gt; checks to filter the object properties is an additional overhead causing it to perform even slower and negates the key reason for using it in the first place, i.e. because of the more concise format.</source>
          <target state="translated">&lt;code&gt;hasOwnProperty()&lt;/code&gt; および &lt;code&gt;!isNaN()&lt;/code&gt; チェックを使用してオブジェクトのプロパティをフィルターすると、オーバーヘッドが増加し、パフォーマンスがさらに低下し、そもそもそれを使用する主な理由、つまり形式が簡潔になるため、それが無効になります。</target>
        </trans-unit>
        <trans-unit id="918fbcebd19b214ca6c6ed8e07393e70c7d695f3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;for...in&lt;/code&gt; loop for an array is not wrong, although I can guess why someone told you that:</source>
          <target state="translated">配列に &lt;code&gt;for...in&lt;/code&gt; ループを使用することは間違っていませんが、なぜ誰かがあなたにそのように言ったのか推測できます：</target>
        </trans-unit>
        <trans-unit id="bc913488828c3bcac109d7fea4f36a8fb9fb9d46" translate="yes" xml:space="preserve">
          <source>Usually the order of the items in an array is important, but the for-in loop won't necessarily iterate in the right order, that's because it treats the array as an object, which is the way it is implemented in JS, and not as an array.
This seems like a small thing, but it can really screw up applications and is hard to debug.</source>
          <target state="translated">通常、配列内の項目の順序は重要ですが、for-in ループは必ずしも正しい順序で反復処理を行うとは限りません。これは小さなことのように見えますが、アプリケーションを台無しにしてしまいますし、デバッグも大変です。</target>
        </trans-unit>
        <trans-unit id="149c70146186d5720fac2f29bfd0ada94cf61c04" translate="yes" xml:space="preserve">
          <source>When you want to enumerate only the &lt;em&gt;own properties&lt;/em&gt; of an object (the ones that aren't inherited), you can use the &lt;code&gt;hasOwnProperty&lt;/code&gt; method:</source>
          <target state="translated">オブジェクト（継承されていない&lt;em&gt;プロパティ）のプロパティ&lt;/em&gt;のみを列挙する場合は、 &lt;code&gt;hasOwnProperty&lt;/code&gt; メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="b64e58a83fb02454b1c9859d3d2932e652511b06" translate="yes" xml:space="preserve">
          <source>Why is using “for…in” with array iteration a bad idea</source>
          <target state="translated">なぜ配列の反復で &quot;for...in &quot;を使うのが悪い考えなのか</target>
        </trans-unit>
        <trans-unit id="0577fbc195c6a54c24c161142179133a755af8f0" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;for.. in&lt;/code&gt;, just be sure to check each property with &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;hasOwnProperty&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;for.. in&lt;/code&gt; を使用できますが 、必ず各プロパティを&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;hasOwnProperty&lt;/a&gt;で確認してください。</target>
        </trans-unit>
        <trans-unit id="5dd7c262d3b63fe2406be4d0a3f7de7d6d43d204" translate="yes" xml:space="preserve">
          <source>You see the &lt;strong&gt;someoneelse&lt;/strong&gt;!!!... We actually looping through new Array object in this case!</source>
          <target state="translated">&lt;strong&gt;誰か&lt;/strong&gt;が表示され&lt;strong&gt;ます&lt;/strong&gt; !!! ...この場合、実際には新しいArrayオブジェクトをループします！</target>
        </trans-unit>
        <trans-unit id="9c8ef39926fd73e765f1eb8ee4fa6bd53c3ec533" translate="yes" xml:space="preserve">
          <source>You should use the &lt;code&gt;for(var x in y)&lt;/code&gt; only on property lists, not on objects (as explained above).</source>
          <target state="translated">&lt;code&gt;for(var x in y)&lt;/code&gt; は、プロパティリストでのみ使用し、オブジェクトでは使用しないでください（上記で説明）。</target>
        </trans-unit>
        <trans-unit id="a96bcd7cc3ea125e82ec1633c0c044086ec4d453" translate="yes" xml:space="preserve">
          <source>You'll get it as part of every array:</source>
          <target state="translated">すべての配列の一部として取得します。</target>
        </trans-unit>
        <trans-unit id="451738ae11c58dea638bd4da33b99df9b1367655" translate="yes" xml:space="preserve">
          <source>although not specifically addressed by this question, I would add that there's a very good reason not to ever use for...in with a &lt;code&gt;NodeList&lt;/code&gt; (as one would obtain from a &lt;code&gt;querySelectorAll&lt;/code&gt; call, as it doesn't see the returned elements at all, instead iterating only over the NodeList properties.</source>
          <target state="translated">この質問では具体的には取り上げていませんが、 &lt;code&gt;NodeList&lt;/code&gt; で使用しない非常に十分な理由があることを &lt;code&gt;querySelectorAll&lt;/code&gt; ます（返された要素がまったく表示されないため、 querySelectorAll呼び出しから取得するため）。代わりに、NodeListプロパティのみを反復処理します。</target>
        </trans-unit>
        <trans-unit id="b01218ba4e2077e27d32f94c86b9d176de94e14e" translate="yes" xml:space="preserve">
          <source>but this is true for iterating over any object with a for-in loop.</source>
          <target state="translated">しかし、これはfor-inループを持つ任意のオブジェクトの反復処理にも当てはまります。</target>
        </trans-unit>
        <trans-unit id="409e3dd82374e4e55f29d3a98652e2ae85e1e66f" translate="yes" xml:space="preserve">
          <source>can sometimes be totally different from the other:</source>
          <target state="translated">が全く違うものになってしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="d26272a8e99b364a53d8375d2aaf9e58565fdc59" translate="yes" xml:space="preserve">
          <source>in the case of a single result, I got:</source>
          <target state="translated">結果が1つの場合、私は得ました。</target>
        </trans-unit>
        <trans-unit id="da1ab8a35220f16c304ed232b0ce34d0d22e60c1" translate="yes" xml:space="preserve">
          <source>in the loop, but the first structure is more direct.</source>
          <target state="translated">はループの中にありますが、最初の構造の方がより直接的です。</target>
        </trans-unit>
        <trans-unit id="38d998cc7ed3a4c5ac9f65bf863b7c90ce1fc902" translate="yes" xml:space="preserve">
          <source>it's slow because you have to walk all properties of the array object and its whole prototype chain and will still only get the property's name, ie to get the value, an additional lookup will be required</source>
          <target state="translated">これは、配列オブジェクトのすべてのプロパティとそのプロトタイプチェーン全体を歩かなければならず、プロパティの名前だけを取得しなければならないので時間がかかります。</target>
        </trans-unit>
        <trans-unit id="f34c97c6342dac87f71ff8d0ba7b7f737b6be403" translate="yes" xml:space="preserve">
          <source>whereas,</source>
          <target state="translated">whereas,</target>
        </trans-unit>
        <trans-unit id="7c5e58bccc2148f04b16afa5d9963af3bc3acc1b" translate="yes" xml:space="preserve">
          <source>which explained why my &lt;code&gt;for (node in nodes) node.href = newLink;&lt;/code&gt; was failing.</source>
          <target state="translated">私の理由 &lt;code&gt;for (node in nodes) node.href = newLink;&lt;/code&gt; 失敗していた。</target>
        </trans-unit>
        <trans-unit id="7c400da46a809de9bf574c312d350ee791784418" translate="yes" xml:space="preserve">
          <source>will write</source>
          <target state="translated">書く</target>
        </trans-unit>
        <trans-unit id="5c923b1cf4e840a71705024b687048a1b3731fba" translate="yes" xml:space="preserve">
          <source>you could solve this with the hasOwnProperty method:</source>
          <target state="translated">これはhasOwnPropertyメソッドで解決できます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
