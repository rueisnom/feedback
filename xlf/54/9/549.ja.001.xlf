<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/549">
    <body>
      <group id="549">
        <trans-unit id="69df7b128404cdc2a24c0bfd9cd27a00e203a315" translate="yes" xml:space="preserve">
          <source>&quot;In a &lt;em&gt;corporate,&lt;/em&gt;&lt;strong&gt;intra-&lt;/strong&gt; net setting,&quot; most if not all of the foregoing might not apply!</source>
          <target state="translated">「 &lt;em&gt;企業の&lt;/em&gt; &lt;strong&gt;イントラネット&lt;/strong&gt;環境では」、前述のすべてではないにしてもほとんどが当てはまらない可能性があります。</target>
        </trans-unit>
        <trans-unit id="058f419589e9dd656281d473affa1f7e3ba832f9" translate="yes" xml:space="preserve">
          <source>&quot;Remember me&quot; checkbox</source>
          <target state="translated">&quot;私を覚えている」チェックボックス</target>
        </trans-unit>
        <trans-unit id="7bfcf80c49fcc34753a9509db01b7f4fad1e8be7" translate="yes" xml:space="preserve">
          <source>1 failed attempt = 5 sec delay</source>
          <target state="translated">1回の試行失敗=5秒の遅延</target>
        </trans-unit>
        <trans-unit id="4933c9e0a9a55746fe717a260189a4c3b7776226" translate="yes" xml:space="preserve">
          <source>1 failed attempt = no delay</source>
          <target state="translated">1回の試行に失敗した=遅延なし</target>
        </trans-unit>
        <trans-unit id="bda7f01ca3465367872dae9f245215d37c7e8f44" translate="yes" xml:space="preserve">
          <source>1-4 failed attempts = no delay</source>
          <target state="translated">1-4回の試行に失敗した=遅延なし</target>
        </trans-unit>
        <trans-unit id="935e9ab41e1866d02953c899137cc5bd98598cd6" translate="yes" xml:space="preserve">
          <source>2 failed attempts = 15 sec delay</source>
          <target state="translated">2回の試行失敗=15秒の遅延</target>
        </trans-unit>
        <trans-unit id="47aec48c770a6e89a9cdc96d4cfc0356ccf62251" translate="yes" xml:space="preserve">
          <source>2 failed attempts = 2 sec delay</source>
          <target state="translated">2回の試行に失敗した場合、2秒の遅延</target>
        </trans-unit>
        <trans-unit id="daa302056ffb870a1635435f22e21ea1dafe9e09" translate="yes" xml:space="preserve">
          <source>21 page academic article with many great tips.</source>
          <target state="translated">21ページのアカデミックな記事には、素晴らしいヒントがたくさん詰まっています。</target>
        </trans-unit>
        <trans-unit id="dd4616a9b5e7761604c57acbe22a9f66ccc224ba" translate="yes" xml:space="preserve">
          <source>3 failed attempts = 4 sec delay</source>
          <target state="translated">3回の試行失敗=4秒の遅延</target>
        </trans-unit>
        <trans-unit id="a2ab0f46bed565e502c16626cce6aa94ed0265ea" translate="yes" xml:space="preserve">
          <source>3+ failed attempts = 45 sec delay</source>
          <target state="translated">3回以上の試行失敗=45秒の遅延</target>
        </trans-unit>
        <trans-unit id="5f26327f3b922c025c50d407447c515c8398f853" translate="yes" xml:space="preserve">
          <source>4 failed attempts = 8 sec delay</source>
          <target state="translated">4回の試行失敗=8秒の遅延</target>
        </trans-unit>
        <trans-unit id="b410d68b441165f7e208e0c3606b2d34caa8f485" translate="yes" xml:space="preserve">
          <source>5 failed attempts = 15-30 min delay</source>
          <target state="translated">5回の試行に失敗した場合=15~30分の遅延</target>
        </trans-unit>
        <trans-unit id="89eb27e67e97b23b39627fd0ebb7f6c8ddf3bf1d" translate="yes" xml:space="preserve">
          <source>5 failed attempts = 16 sec delay</source>
          <target state="translated">5回の試行に失敗した場合、16秒の遅延が発生します。</target>
        </trans-unit>
        <trans-unit id="3fe528174a0b4a8437fd8b6038b509f4f9de6167" translate="yes" xml:space="preserve">
          <source>5+ failed attempts = 20 sec delay</source>
          <target state="translated">5回以上の試行失敗=20秒の遅延</target>
        </trans-unit>
        <trans-unit id="6921455f96323553f199528f7622f4a3b9a9786f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt; client side - give the clients a public key certificate (support in all major browsers - but raises questions over client machine security).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt;クライアント側-クライアントに公開鍵証明書を提供します（すべての主要なブラウザでサポートされていますが、クライアントマシンのセキュリティについて質問があります）。</target>
        </trans-unit>
        <trans-unit id="45b4f07c39663a3e6c27f9302d6e20007ce9782d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol&quot;&gt;SRP&lt;/a&gt; - sort of clever password authentication without a trusted third party. But here we are getting into the realms of &quot;it's safer to use two-factor authentication, even if that's costlier&quot;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol&quot;&gt;SRP-&lt;/a&gt;信頼できるサードパーティなしの一種の巧妙なパスワード認証。 しかし、ここでは「2要素認証を使用した方がコストが高くても安全です」という領域に入ります。</target>
        </trans-unit>
        <trans-unit id="90f385f4e0a0b7f11399b82fc614984d76a16f3e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Session_hijacking&quot;&gt;Cookies can be hijacked&lt;/a&gt;: they are only as secure as the rest of the client's machine and other communications. They can be read from disk, sniffed in network traffic, lifted by a cross-site scripting attack, phished from a poisoned DNS so the client sends their cookies to the wrong servers. Don't send persistent cookies. Cookies should expire at the end of the client session (browser close or leaving your domain).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Session_hijacking&quot;&gt;Cookieはハイジャックされる可能性があります。Cookie&lt;/a&gt;は、クライアントの他のマシンやその他の通信と同じくらい安全です。 ディスクから読み取ったり、ネットワークトラフィックを傍受したり、クロスサイトスクリプティング攻撃によって持ち上げたり、ポイズニングされたDNSからフィッシングしたりして、クライアントがCookieを間違ったサーバーに送信する可能性があります。 永続的なCookieを送信しないでください。 Cookieは、クライアントセッションの終了時（ブラウザが閉じるか、ドメインを離れるとき）に期限切れになります。</target>
        </trans-unit>
        <trans-unit id="49f9e15c72f3955bacc5f154f5cca6c87bd5ba73" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt; is meant to thwart one specific category of attack: automated dictionary/brute force trial-and-error with no human operator. There is no doubt that this is a real threat, however, there are ways of dealing with it seamlessly that don't require a CAPTCHA, specifically properly designed server-side login throttling schemes - we'll discuss those later.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt;は、特定のカテゴリの攻撃を阻止することを目的としています。人間のオペレーターがいない自動化された辞書/総当たりの試行錯誤です。 これが本当の脅威であることは間違いありませんが、CAPTCHAを必要としないシームレスに対処する方法があり、特に適切に設計されたサーバー側ログインスロットリングスキームがあります。これらについては後で説明します。</target>
        </trans-unit>
        <trans-unit id="4a414bc028ed50a0f3218630992fe44aa5dda99f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP Guide To Authentication&lt;/a&gt; / &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP Authentication Cheat Sheet&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP認証ガイド&lt;/a&gt; / &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP認証チートシート&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="350279b88821264707fd02b036767898b4c1bda2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://tech.dropbox.com/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;Dropbox Tech Blog &amp;raquo; Blog Archive &amp;raquo; zxcvbn: realistic password strength estimation&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://tech.dropbox.com/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;Dropbox Techブログ&amp;raquo;ブログアーカイブ&amp;raquo;zxcvbn：現実的なパスワード強度推定&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a5383b5bd8ae9fa5958ef40b0e46c085b1e5259" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;As a rule of thumb, however, I would say: the stronger your password policy is, the less you have to bug users with delays. If you require strong (case-sensitive alphanumerics + required numbers and symbols) 9+ character passwords, you could give the users 2-4 non-delayed password attempts before activating the throttling.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;しかし、経験則として、私は言うでしょう：パスワードポリシーが強力であるほど、遅延によるユーザーのバグを減らす必要があります。&lt;/em&gt; &lt;em&gt;強力な（大文字と小文字を区別する英数字+必須の数字と記号）9文字以上のパスワードが必要な場合は、スロットルをアクティブにする前に、遅延のないパスワードを2〜4回試行するようユーザーに与えることができます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4957adf699c8759c1e40cd9b96d75b27b268fc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;and much more about&lt;/em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Form-based_authentication&quot;&gt;form based authentication&lt;/a&gt;...</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Form-based_authentication&quot;&gt;フォームベース認証の詳細&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="fcc4b958071127c62617da40ec128a417501f1df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(Do not) Roll-your-own JavaScript encryption/hashing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;（しないでください）Roll-your-own JavaScript暗号化/ハッシュ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6dcdf8f937fc5401388255a12713637e49f4722f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice #1:&lt;/strong&gt; A short time delay that increases with the number of failed attempts, like:</source>
          <target state="translated">&lt;strong&gt;ベストプラクティス＃1：次&lt;/strong&gt;のように、失敗した試行の数とともに増加する短い遅延時間。</target>
        </trans-unit>
        <trans-unit id="4359ce5b629b2c1989c0365aa8961ffd79ee0d06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice #2:&lt;/strong&gt; A medium length time delay that goes into effect after N failed attempts, like:</source>
          <target state="translated">&lt;strong&gt;ベストプラクティス＃2：&lt;/strong&gt; N回の試行が失敗した後に有効になる中程度の時間遅延。</target>
        </trans-unit>
        <trans-unit id="01abe219c5d4dda6367efc589d92ab2506211aad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice #3:&lt;/strong&gt; Combining the two approaches - either a fixed, short time delay that goes into effect after N failed attempts, like:</source>
          <target state="translated">&lt;strong&gt;ベストプラクティス＃3：&lt;/strong&gt; 2つのアプローチを組み合わせる-次のように、N回の試行が失敗した後に有効になる固定の短い時間遅延。</target>
        </trans-unit>
        <trans-unit id="37c2926d835584f9eabb2cd451babd8b70ad6a67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAPTCHAS against humanity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;人道に対するキャプチャ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="516d16a7e5a12ca5bcd98935577ee8e1d46c30d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't implement 'secret questions'&lt;/strong&gt;. The 'secret questions' feature is a security anti-pattern. Read the paper from link number 4 from the MUST-READ list. You can ask Sarah Palin about that one, after her Yahoo! email account got hacked during a previous presidential campaign because the answer to her security question was... &quot;Wasilla High School&quot;!</source>
          <target state="translated">&lt;strong&gt;「秘密の質問」を実装しないでください&lt;/strong&gt; 。 「秘密の質問」機能は、セキュリティ対策パターンです。 必読リストのリンク番号4の論文を読んでください。 あなたは彼女のYahoo!の後にサラPalinにそれについて尋ねることができます。 以前の大統領選挙でメールアカウントがハッキングされたのは、彼女のセキュリティの質問に対する答えが「ワシラ高校」だったからです！</target>
        </trans-unit>
        <trans-unit id="ec175f6942cc7b1865ec041ac5613bc9f80c0eef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you DO decide to implement persistent login cookies, this is how you do it:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;永続的なログインCookieを実装する場合は、次のようにします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="637473bd2adb089039b0c89d6433ba778b84b474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of a bot:&lt;/strong&gt; The bot will see a field whose type is &lt;code&gt;text&lt;/code&gt; and a name &lt;code&gt;email&lt;/code&gt; (or whatever it is you called it) and will logically attempt to fill it with appropriate data. It doesn't care if you styled the input form with some fancy CSS, web-developers do it all the time. Whatever the value in the dummy field is, we don't care as long as it's larger than &lt;code&gt;0&lt;/code&gt; characters.</source>
          <target state="translated">&lt;strong&gt;ボットの場合：&lt;/strong&gt;ボットは、 &lt;code&gt;text&lt;/code&gt; と名前の &lt;code&gt;email&lt;/code&gt; （またはそれと呼ばれるもの）のフィールドを表示し、適切なデータを論理的に入力しようとします。 派手なCSSで入力フォームのスタイルを設定してもかまいません。Web開発者は常にそれを行います。 ダミーフィールドの値が何であれ、 &lt;code&gt;0&lt;/code&gt; 文字よりも長ければ問題ありません。</target>
        </trans-unit>
        <trans-unit id="aae812a71f3bb70676afff65f15c280be558f9db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of a human:&lt;/strong&gt;
The user will not see the dummy field (in my case named &quot;email&quot;) and will not attempt to fill it. So the value of the dummy field should still be empty when the form has been sent.</source>
          <target state="translated">&lt;strong&gt;人間の場合：&lt;/strong&gt;ユーザーはダミーのフィールド（私の場合は「email」という名前）を表示せず、入力も試みません。 そのため、フォームが送信されたとき、ダミーフィールドの値は空のままである必要があります。</target>
        </trans-unit>
        <trans-unit id="0e6713aeddfc7a12a7fde3f069db7a29490d39d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In conclusion, security questions are inherently insecure in virtually all their forms and variations, and should not be employed in an authentication scheme for any reason.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;結論として、セキュリティの質問は、事実上すべての形式とバリエーションで本質的に安全ではなく、何らかの理由で認証スキームで使用されるべきではありません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5921de4d57a4fbc23f79b12ad7e9cdeb5fb7c8e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It would, however, take an inordinate amount of time to crack even a 6-character password, &lt;em&gt;if you were limited to one attempt per second!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ただし、 &lt;em&gt;1秒あたりの試行回数が1回に制限されている場合&lt;/em&gt; 、6文字のパスワードでも解読するのに非常に時間がかかります&lt;em&gt;。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9fe7f6c15e0366087eea39f6e6266f59f5ea4149" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Locking accounts&lt;/strong&gt; and requiring email verification after N failed attempts (this is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Denial-of-service_attack&quot;&gt;DoS&lt;/a&gt; attack waiting to happen)</source>
          <target state="translated">N回の試行の失敗後に&lt;strong&gt;アカウント&lt;/strong&gt;を&lt;strong&gt;ロックし&lt;/strong&gt; 、電子メールの検証を要求する（これは、発生するのを待っている&lt;a href=&quot;https://en.wikipedia.org/wiki/Denial-of-service_attack&quot;&gt;DoS&lt;/a&gt;攻撃です）</target>
        </trans-unit>
        <trans-unit id="e90850633bfc5febc51640b8ccb1003e1a125b35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Session data - &quot;You are logged in as Spiderman69&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;セッションデータ-「Spiderman69としてログインしています」&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd9c2a725de6be5c8d8a56d77ade192b833ed89e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Storing Passwords / Verifying logins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;パスワードの保存/ログインの確認&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bbd3f75083cc61c829eb8133833162ea78ad59c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To HTTPS or not to HTTPS?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTTPSを使用するか、またはHTTPSを使用しないか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aff7d87f4b6a1c8cb8a94e4e8a8d78776ee65e55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Of course this method is not 100% foolproof. Bots can be programmed to ignore input fields with the style &lt;code&gt;display:none&lt;/code&gt; applied to it. You also have to think about people who use some form of auto-completion (like most browsers have built-in!) to auto-fill all form fields for them. They might just as well pick up a dummy field.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ：もちろん、この方法は100％確実というわけではありません。 ボットは、 &lt;code&gt;display:none&lt;/code&gt; スタイルが適用されている入力フィールドを無視するようにプログラムできます。 また、（ほとんどのブラウザに組み込まれているように）オートコンプリートのフォームを使用して、すべてのフォームフィールドを自動入力する人々についても考える必要があります。 彼らは同様にダミーフィールドを拾うかもしれません。</target>
        </trans-unit>
        <trans-unit id="5d5d1f9e278d3727050a077840f6bd8ade191eb6" translate="yes" xml:space="preserve">
          <source>A 'standard' secret question like mother's maiden name or favorite pet</source>
          <target state="translated">母の旧姓や好きなペットのような「定番」の秘密の質問</target>
        </trans-unit>
        <trans-unit id="f64690874d20c3aeaa77943a06ac83d30946406d" translate="yes" xml:space="preserve">
          <source>A big user interface benefit being sought here is the &amp;ldquo;identity selector&amp;rdquo;. When a user visits a site and chooses to authenticate, their browser shows them a selection of email addresses (&amp;ldquo;personal&amp;rdquo;, &amp;ldquo;work&amp;rdquo;, &amp;ldquo;political activism&amp;rdquo;, etc.) they may use to identify themselves to the site.</source>
          <target state="translated">ここで求められているユーザーインターフェイスの大きなメリットは、「IDセレクター」です。 ユーザーがサイトにアクセスして認証を選択すると、ユーザーのブラウザーには、ユーザーがサイトで自分を識別するために使用できる電子メールアドレス（「個人」、「仕事」、「政治活動」など）が表示されます。</target>
        </trans-unit>
        <trans-unit id="20a4741b328cb885ac3f4e272309bb731bd02051" translate="yes" xml:space="preserve">
          <source>A cryptographic hash should not be used for password storage because user-selected passwords are not strong enough (i.e. do not usually contain enough entropy) and a password guessing attack could be completed in a relatively short time by an attacker with access to the hashes. This is why KDFs are used - these effectively &lt;a href=&quot;https://en.wikipedia.org/wiki/Key_stretching&quot;&gt;&quot;stretch the key&quot;&lt;/a&gt;, which means that every password guess an attacker makes causes multiple repetitions of the hash algorithm, for example 10,000 times, which causes the attacker to guess the password 10,000 times slower.</source>
          <target state="translated">ユーザーが選択したパスワードは十分に強力ではないため（通常、十分なエントロピーが含まれていないため）、暗号化ハッシュをパスワードの保存に使用しないでください。パスワードを推測する攻撃は、ハッシュにアクセスできる攻撃者によって比較的短時間で完了する可能性があります。 これがKDFが使用される理由です。これらは効果的に&lt;a href=&quot;https://en.wikipedia.org/wiki/Key_stretching&quot;&gt;「キーをストレッチ」します。&lt;/a&gt;つまり、攻撃者が作成するすべてのパスワードがハッシュアルゴリズムを複数回繰り返し、たとえば10,000回繰り返すため、攻撃者はパスワードを10,000倍遅く推測します。</target>
        </trans-unit>
        <trans-unit id="7590029be61bfd68fc48f94dac75c5aef9aad07f" translate="yes" xml:space="preserve">
          <source>A final note: always make sure your interface for entering the 'lost password code' is at least as secure as your login form itself, or an attacker will simply use this to gain access instead. Making sure you generate very long 'lost password codes' (for example, 16 case-sensitive alphanumeric characters) is a good start, but consider adding the same throttling scheme that you do for the login form itself.</source>
          <target state="translated">最後の注意:「失われたパスワードコード」を入力するためのインターフェイスが少なくともログインフォーム自体と同じくらい安全であることを常に確認してください。非常に長い「失われたパスワードコード」(例えば16文字の大文字小文字を区別する英数字)を生成することは良いスタートですが、ログインフォーム自体に行うのと同じスロットリングスキームを追加することを検討してください。</target>
        </trans-unit>
        <trans-unit id="11d28e408d6e08e9bc8b44384de8740b08f464cd" translate="yes" xml:space="preserve">
          <source>A good article about realistic password strength estimation is:</source>
          <target state="translated">リアルなパスワード強度推定に関する良い記事です。</target>
        </trans-unit>
        <trans-unit id="c73360d37de0cecf6fb825c8a88ccb92b682493b" translate="yes" xml:space="preserve">
          <source>A simple piece of trivia that anyone could lift from their blog, LinkedIn profile, or similar</source>
          <target state="translated">誰でも自分のブログ、LinkedInのプロフィール、または類似のものから持ち出すことができる簡単なトリビア。</target>
        </trans-unit>
        <trans-unit id="5d9880021de84dd0fea8123c504dd9636c53c978" translate="yes" xml:space="preserve">
          <source>Additionally, it makes sense to do more aggressive throttling on admin accounts, since those are the most attractive entry points</source>
          <target state="translated">さらに、管理者アカウントにもっと積極的なスロットルをかけるのは理にかなっています。</target>
        </trans-unit>
        <trans-unit id="d7e5b123cdf543d44b363c873a05a3315621a304" translate="yes" xml:space="preserve">
          <source>After the user logs in, the server sends the user a session cookie. The server can retrieve the username or id from the cookie, but nobody else can generate such a cookie (TODO explain mechanisms).</source>
          <target state="translated">ユーザがログインした後、サーバはユーザにセッションクッキーを送ります。サーバはクッキーからユーザ名や ID を取得できますが、他の誰もそのようなクッキーを生成することはできません (TODO は仕組みを説明します)。</target>
        </trans-unit>
        <trans-unit id="cf64446be670d9f89a6800352ab8de9cc2e9bb10" translate="yes" xml:space="preserve">
          <source>Always hash the lost password code/token in the database. &lt;strong&gt;&lt;em&gt;AGAIN&lt;/em&gt;&lt;/strong&gt;, this code is another example of a Password Equivalent, so it MUST be hashed in case an attacker got their hands on your database. When a lost password code is requested, send the plaintext code to the user's email address, then hash it, save the hash in your database -- and &lt;em&gt;throw away the original&lt;/em&gt;. Just like a password or a persistent login token.</source>
          <target state="translated">失われたパスワードコード/トークンは、常にデータベースでハッシュしてください。 再度、このコードは同等のパスワードの別の例であるため、攻撃者がデータベースを手にした場合に備えて、ハッシュする必要があります。 紛失したパスワードコードが要求された場合は、プレーンテキストコードをユーザーのメールアドレスに送信し、ハッシュしてデータベースに保存します。 &lt;em&gt;元の&lt;/em&gt;コードは破棄してください。 パスワードや永続的なログイントークンと同じです。</target>
        </trans-unit>
        <trans-unit id="f8fa1c13ce1fcf0e5a7c7b34d06206e4a19a7e2d" translate="yes" xml:space="preserve">
          <source>And finally, &lt;strong&gt;login throttling&lt;/strong&gt;: that is, setting a time delay between attempts after N failed attempts (yes, DoS attacks are still possible, but at least they are far less likely and a lot more complicated to pull off).</source>
          <target state="translated">そして最後に、 &lt;strong&gt;ログインスロットリング&lt;/strong&gt; ：つまり、N回の試行が失敗した後の試行間の時間遅延を設定します（はい、DoS攻撃は依然として可能ですが、少なくとも攻撃の可能性ははるかに低く、引き出すのははるかに複雑です）。</target>
        </trans-unit>
        <trans-unit id="50261011750b3da345a0d096efbd266f05c0265c" translate="yes" xml:space="preserve">
          <source>And for a refreshing take on user-friendliness of high-entropy passwords, Randall Munroe's &lt;a href=&quot;https://xkcd.com/936/&quot;&gt;Password Strength xkcd&lt;/a&gt; is highly recommended.</source>
          <target state="translated">また、エントロピーの高いパスワードを使いやすくするために、Randall Munroeの&lt;a href=&quot;https://xkcd.com/936/&quot;&gt;Password Strength xkcd&lt;/a&gt;を強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="17c338063d0906b9a8c9db49206427ff3518197a" translate="yes" xml:space="preserve">
          <source>And just to reiterate one of the most common pitfalls, &lt;strong&gt;DO NOT STORE THE PERSISTENT LOGIN COOKIE (TOKEN) IN YOUR DATABASE, ONLY A HASH OF IT!&lt;/strong&gt; The login token is Password Equivalent, so if an attacker got their hands on your database, they could use the tokens to log in to any account, just as if they were cleartext login-password combinations. Therefore, use hashing (according to &lt;a href=&quot;https://security.stackexchange.com/a/63438/5002&quot;&gt;https://security.stackexchange.com/a/63438/5002&lt;/a&gt; a weak hash will do just fine for this purpose) when storing persistent login tokens.</source>
          <target state="translated">そして、最も一般的な落とし穴の1つを繰り返すために、 &lt;strong&gt;永続的なログインクッキー（トークン）をデータベースに保存しないでください。&lt;/strong&gt; ログイントークンは同等のパスワードであるため、攻撃者がデータベースを手に入れたら、平文のログインパスワードの組み合わせのように、トークンを使用して任意のアカウントにログインできます。 したがって、永続的なログイントークンを保存する場合は、ハッシュを使用し&lt;a href=&quot;https://security.stackexchange.com/a/63438/5002&quot;&gt;ます&lt;/a&gt; （ https://security.stackexchange.com/a/63438/5002によると、この目的には弱いハッシュで十分です）。</target>
        </trans-unit>
        <trans-unit id="72316e90ea3528bdbe9b7197ccebf727fd3c4940" translate="yes" xml:space="preserve">
          <source>Another big user interface benefit being sought as part of this effort is &lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest-Session&quot;&gt;helping the browser know more about the user&amp;rsquo;s session&lt;/a&gt; &amp;ndash; who they&amp;rsquo;re signed in as currently, primarily &amp;ndash; so it may display that in the browser chrome.</source>
          <target state="translated">この取り組みの一環として求められているもう1つの大きなユーザーインターフェイスの利点は&lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest-Session&quot;&gt;、ブラウザーがユーザーのセッション（ユーザーが&lt;/a&gt;現在サインインしている主なユーザー）についてさらに理解できるようにすることです。これにより、ブラウザーのクロムにそれが表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="705253cd657208d09c588cee3c6ce2acfa7a6043" translate="yes" xml:space="preserve">
          <source>Another warning about storing passwords in the database.</source>
          <target state="translated">データベースにパスワードを保存することについてのもう一つの警告。</target>
        </trans-unit>
        <trans-unit id="54b5a6243a4307025588c6723f58ebb3abfde047" translate="yes" xml:space="preserve">
          <source>Any question that is easier to answer than guessing their password. Which, for any decent password, is every question you can imagine</source>
          <target state="translated">パスワードを推測するよりも簡単に答えられるどんな質問でも どのようなまともなパスワードのために、あなたが想像することができるすべての質問です。</target>
        </trans-unit>
        <trans-unit id="ac85befbefb90c64bf699051a1715be6633e17ed" translate="yes" xml:space="preserve">
          <source>As a second level of expressing identity, each domain manages its own set of accounts.</source>
          <target state="translated">アイデンティティを表現する第二のレベルとして、各ドメインは独自のアカウントセットを管理します。</target>
        </trans-unit>
        <trans-unit id="7fae24196de93a89f7bc9168355345ea97141c87" translate="yes" xml:space="preserve">
          <source>As nothing is more efficient than not doing it at all.</source>
          <target state="translated">何もしないよりは全くしない方が効率的なので。</target>
        </trans-unit>
        <trans-unit id="b9a023176b2c76e659482f620b9f75601624a29e" translate="yes" xml:space="preserve">
          <source>Ask YC: Best Practices for User Authentication</source>
          <target state="translated">YCに聞く。ユーザー認証のベストプラクティス</target>
        </trans-unit>
        <trans-unit id="df15f74ac80c8dd3799c1c499d1cc92b7ae3c505" translate="yes" xml:space="preserve">
          <source>Authentication can be completely delegated to a single-sign-on service, where another provider handles collecting credentials. This pushes the problem to a trusted third party. Google and Twitter both provide standards-based SSO services, while Facebook provides a similar proprietary solution.</source>
          <target state="translated">認証は、別のプロバイダがクレデンシャルの収集を処理するシングルサインオンサービスに完全に委譲することができます。これにより、問題は信頼できるサードパーティに押し付けられます。GoogleとTwitterはともに標準ベースのSSOサービスを提供しており、Facebookは同様の独自のソリューションを提供しています。</target>
        </trans-unit>
        <trans-unit id="f70be28530087a7439a32ae20f152509cc4f41a4" translate="yes" xml:space="preserve">
          <source>Be creative!</source>
          <target state="translated">創造的になれ!</target>
        </trans-unit>
        <trans-unit id="1de8c9a58ce4eebe00ed4c7a8a4c68f84a6b9ba8" translate="yes" xml:space="preserve">
          <source>Because of the distributed nature of this system, it avoids lock-in to major sites like Facebook, Twitter, Google, etc. Any individual can own their own domain and therefore act as their own identity provider.</source>
          <target state="translated">このシステムは分散型であるため、Facebook、Twitter、Googleなどの大手サイトへのロックインを避けることができます。個人であれば誰でも独自のドメインを持つことができるため、独自のアイデンティティ・プロバイダーとして活動することができます。</target>
        </trans-unit>
        <trans-unit id="9f0cb361ff24b04aa6092ff32d4cb6f1c75f9ee1" translate="yes" xml:space="preserve">
          <source>Browser autocompletion of usernames and passwords</source>
          <target state="translated">ユーザ名とパスワードのブラウザ自動補完</target>
        </trans-unit>
        <trans-unit id="5172cfd6482bd52a4f6c2f400ad548c6594c7e4b" translate="yes" xml:space="preserve">
          <source>But this is a &lt;em&gt;lot&lt;/em&gt; of a hassle, and not very web 2.0. However, it is the only secure way to create new accounts that have access to valuable information that is not self-created.</source>
          <target state="translated">しかし、これは面倒な作業であり、Web 2.0ではありません。 ただし、これは、自己作成ではない貴重な情報にアクセスできる新しいアカウントを作成する唯一の安全な方法です。</target>
        </trans-unit>
        <trans-unit id="28c851e3c23baa12d952c7c21330cc5b4915d3fd" translate="yes" xml:space="preserve">
          <source>Checking password strength</source>
          <target state="translated">パスワードの強度を確認する</target>
        </trans-unit>
        <trans-unit id="2099227ae53d0bb69ac620e426264f3954bf9b76" translate="yes" xml:space="preserve">
          <source>Credentials can be compromised, whether by exploits, passwords being written down and lost, laptops with keys being stolen, or users entering logins into phishing sites.  Logins can be further protected with two-factor authentication, which uses out-of-band factors such as single-use codes received from a phone call, SMS message, app, or dongle. Several providers offer two-factor authentication services.</source>
          <target state="translated">認証情報は、悪用されたり、パスワードが書き留められて紛失したり、ノートパソコンの鍵が盗まれたり、フィッシングサイトにユーザーがログインしたりすることで、危険にさらされる可能性があります。ログインは、電話、SMSメッセージ、アプリ、ドングルから受信した単一の使用コードなどの帯域外の要素を使用する二要素認証でさらに保護することができます。いくつかのプロバイダが二要素認証サービスを提供しています。</target>
        </trans-unit>
        <trans-unit id="5137f3cf30b10d748e2139da3d3ff6a7f14769cd" translate="yes" xml:space="preserve">
          <source>Definitive Article</source>
          <target state="translated">決定的な記事</target>
        </trans-unit>
        <trans-unit id="0852a700c5db81b3b623eebfdac10924f4cb53cc" translate="yes" xml:space="preserve">
          <source>Digest Authentication is a standards-based approach supported in all major browsers and servers, that will not send a password even over a secure channel.</source>
          <target state="translated">ダイジェスト認証は、すべての主要なブラウザとサーバーでサポートされている標準ベースのアプローチで、安全なチャネルでもパスワードを送信することはありません。</target>
        </trans-unit>
        <trans-unit id="5724bf395ae05f9a76fbdee9b6b10fda30c0d956" translate="yes" xml:space="preserve">
          <source>Discussion about rainbow tables and how to defend against them, and against other threads. Includes extensive discussion.</source>
          <target state="translated">虹の表についての議論とそれに対する防御方法、他のスレッドとの議論。広範な議論を含む。</target>
        </trans-unit>
        <trans-unit id="75200dc7711cafface63f254986b6f2ef192e789" translate="yes" xml:space="preserve">
          <source>Discussion: Coding Horror: You're Probably Storing Passwords Incorrectly</source>
          <target state="translated">ディスカッション。コーディングホラー。パスワードの保存方法が間違っている可能性が高い</target>
        </trans-unit>
        <trans-unit id="9700753881a2fcb4aa5513ef58545733b290ed25" translate="yes" xml:space="preserve">
          <source>Distributing the attempts on a botnet to prevent IP address flagging</source>
          <target state="translated">ボットネット上での試みを分散してIPアドレスのフラグを防ぐ</target>
        </trans-unit>
        <trans-unit id="ac89eed1b4b4a5aef7852b1e48fc27ff64d4c4f4" translate="yes" xml:space="preserve">
          <source>Do NOT try to implement your own login form or database storage of passwords, unless 
the data being stored is valueless at account creation and self-generated (that is, web 2.0 style like Facebook, &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt;, etc.)</source>
          <target state="translated">独自のログインフォームやパスワードのデータベースストレージを実装しようとしないでください。ただし、保存されるデータがアカウントの作成時に無価値であり、自動生成されている場合（つまり、Facebook、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt;などのWeb 2.0スタイル）</target>
        </trans-unit>
        <trans-unit id="b407c4a28fed3e87fb4c9cd858d136f953302fac" translate="yes" xml:space="preserve">
          <source>DoS attacking this final login throttling scheme would be &lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt; impractical. And as a final touch, always allow persistent (cookie) logins (and/or a CAPTCHA-verified login form) to pass through, so legitimate users won't even be delayed &lt;em&gt;while the attack is in progress&lt;/em&gt;. That way, the very impractical DoS attack becomes an &lt;em&gt;extremely&lt;/em&gt; impractical attack.</source>
          <target state="translated">この最終ログインスロットルスキームを攻撃するDoSは、 &lt;strong&gt;&lt;em&gt;非常に&lt;/em&gt;&lt;/strong&gt;非現実的です。 そして最後の仕上げとして、永続的な（Cookie）ログイン（および/またはCAPTCHAで検証されたログインフォーム）の通過を常に許可するため&lt;em&gt;、攻撃の進行中に&lt;/em&gt;正当なユーザーが遅れることもありません。 このように、非常に非現実的なDoS攻撃は、 &lt;em&gt;非常に&lt;/em&gt;非現実的な攻撃になります。</target>
        </trans-unit>
        <trans-unit id="9e7a3a3d5fd3f56cab117f9ef1747e6b549435b4" translate="yes" xml:space="preserve">
          <source>DoS attacking this scheme would be quite impractical, but certainly doable. Also, it might be relevant to note that such a long delay can be very annoying for a legitimate user. Forgetful users will dislike you.</source>
          <target state="translated">このスキームを攻撃する DoS は非常に非現実的ですが、確かに可能です。また、このような長い遅延は正当なユーザにとって非常に迷惑になるということも関連しているかもしれません。忘却的なユーザはあなたを嫌うでしょう。</target>
        </trans-unit>
        <trans-unit id="da0e8494de518dd7e8a6918d639ad934c79f4341" translate="yes" xml:space="preserve">
          <source>DoS attacking this scheme would be very impractical, since the resulting lockout time is slightly larger than the sum of the previous lockout times.</source>
          <target state="translated">このスキームを攻撃するDoSは、結果として生じるロックアウト時間が以前のロックアウト時間の合計よりもわずかに大きくなるため、非常に非現実的なものになります。</target>
        </trans-unit>
        <trans-unit id="0104c9c8e1e30ebe0dea4b4e83fd6608c1f8882a" translate="yes" xml:space="preserve">
          <source>Don't &lt;em&gt;reset&lt;/em&gt; a forgotten password to an autogenerated strong password - such passwords are notoriously hard to remember, which means the user must either change it or write it down - say, on a bright yellow Post-It on the edge of their monitor. Instead of setting a new password, just let users pick a new one right away - which is what they want to do anyway. (An exception to this might be if the users are universally using a password manager to store/manage passwords that would normally be impossible to remember without writing it down).</source>
          <target state="translated">忘れたパスワードを自動生成された強力なパスワードに&lt;em&gt;リセット&lt;/em&gt;しないでください。そのようなパスワードは覚えがたいことで悪名高いため、ユーザーはパスワードを変更するか書き留める必要があります。たとえば、モニターの端にある明るい黄色のポストイットに記入する必要があります。 新しいパスワードを設定する代わりに、ユーザーがすぐに新しいパスワードを選択できるようにします。これがユーザーがとにかくやりたいことです。 （これに対する例外は、ユーザーがパスワードマネージャーを使用してパスワードを保存/管理するために普遍的に使用している場合で、パスワードを書き留めておかないと覚えることは通常不可能です）。</target>
        </trans-unit>
        <trans-unit id="2de2a3f83a86845063f5b948c1410f326797445a" translate="yes" xml:space="preserve">
          <source>Don't ever store passwords as plaintext in the database. Not even if you don't care about the security of your own site. Assume that some of your users will reuse the password of their online bank account. So, store the hashed password, and throw away the original. And make sure the password doesn't show up in access logs or application logs. OWASP &lt;a href=&quot;https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet#Impose_infeasible_verification_on_attacker&quot;&gt;recommends the use of Argon2&lt;/a&gt; as your first choice for new applications. If this is not available, PBKDF2 or scrypt should be used instead. And finally if none of the above are available, use bcrypt.</source>
          <target state="translated">パスワードをプレーンテキストとしてデータベースに保存しないでください。 自分のサイトのセキュリティを気にしなくても。 一部のユーザーがオンライン銀行口座のパスワードを再利用するとします。 したがって、ハッシュ化されたパスワードを保存し、元のパスワードは捨ててください。 また、パスワードがアクセスログやアプリケーションログに表示されないようにしてください。 OWASP &lt;a href=&quot;https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet#Impose_infeasible_verification_on_attacker&quot;&gt;では、&lt;/a&gt;新しいアプリケーションの最初の選択肢としてArgon2の使用を推奨しています。 これが利用できない場合は、代わりにPBKDF2またはscryptを使用する必要があります。 最後に、上記のいずれも使用できない場合は、bcryptを使用します。</target>
        </trans-unit>
        <trans-unit id="0ee655cfc09904ea89a7dd7a61686e2332a87c87" translate="yes" xml:space="preserve">
          <source>Dos and Don&amp;rsquo;ts of Client Authentication on the Web (very readable MIT research paper)</source>
          <target state="translated">Webでのクライアント認証の推奨事項と禁止事項（非常に読みやすいMITリサーチペーパー）</target>
        </trans-unit>
        <trans-unit id="a9d3cd24a6e8137771c2eb5231b4292534173c59" translate="yes" xml:space="preserve">
          <source>Dos and Don'ts of Client Authentication on the Web (PDF)</source>
          <target state="translated">Web上でのクライアント認証の注意点 (PDF)</target>
        </trans-unit>
        <trans-unit id="a6df6aab068ddfca1dd445a099c04ab77b30380c" translate="yes" xml:space="preserve">
          <source>E-mail validation</source>
          <target state="translated">電子メールの検証</target>
        </trans-unit>
        <trans-unit id="26a0e3922cf6459a169fb69c5cedf0594a660c30" translate="yes" xml:space="preserve">
          <source>Editing the official answer</source>
          <target state="translated">公式回答の編集</target>
        </trans-unit>
        <trans-unit id="2a5bf7ecd3c3bb79697e4b75902e93bf1d1f63ef" translate="yes" xml:space="preserve">
          <source>Email providers are already the de-facto primary identity providers online. Current password reset flows usually let you take control of an account if you can prove that you control that account&amp;rsquo;s associated email address.</source>
          <target state="translated">電子メールプロバイダーは、すでにオンラインの事実上の主要なIDプロバイダーです。 現在のパスワードリセットフローでは、通常、アカウントに関連付けられているメールアドレスを制御できることが証明できれば、そのアカウントを制御できます。</target>
        </trans-unit>
        <trans-unit id="ca82a8d4544f8e713eb61230c51166734ade8bc0" translate="yes" xml:space="preserve">
          <source>Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes</source>
          <target state="translated">レインボーテーブルはもういい。安全なパスワードスキームについて知っておく必要があること</target>
        </trans-unit>
        <trans-unit id="2c81c599e2b514bdc593f3664a3e0b805bb4f759" translate="yes" xml:space="preserve">
          <source>Even with user-specified questions, it is highly likely that most users will choose either:</source>
          <target state="translated">ユーザー指定の質問でも、ほとんどのユーザーがどちらかを選択する可能性が高いです。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="94eb0c2edb61f0c161e93c8ae7a3d970650bcabd" translate="yes" xml:space="preserve">
          <source>Financial websites such as banks and credit cards, on the other hand, only have sensitive data and should not allow auto-login or a low-security mode.</source>
          <target state="translated">一方、銀行やクレジットカードなどの金融系のサイトは、機密データがあるだけで、自動ログインやセキュリティの低いモードを許可してはいけません。</target>
        </trans-unit>
        <trans-unit id="055ea5e2a84b88f78196f3343fc0481996477833" translate="yes" xml:space="preserve">
          <source>First, a strong caveat that this answer is not the best fit for this exact question. It should definitely not be the top answer!</source>
          <target state="translated">まず、この答えがこの正確な質問に最適ではないという強い注意点があります。これは絶対にトップの答えにすべきではありません</target>
        </trans-unit>
        <trans-unit id="6f4757517fb79956122368fef702663232eb1875" translate="yes" xml:space="preserve">
          <source>First, have a look at the numbers: &lt;a href=&quot;https://www.lockdown.co.uk/?pg=combi&amp;amp;s=articles&quot;&gt;Password Recovery Speeds - How long will your password stand up&lt;/a&gt;</source>
          <target state="translated">まず、数字を見てください： &lt;a href=&quot;https://www.lockdown.co.uk/?pg=combi&amp;amp;s=articles&quot;&gt;パスワード回復速度-パスワードはどれくらいの期間有効ですか&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0009187974f9e3ce61f9861d9dbd0e82cd7d920" translate="yes" xml:space="preserve">
          <source>First, take some time to read &lt;a href=&quot;https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence&quot;&gt;Paragon Initiative's article&lt;/a&gt; on the subject. You'll need to get a bunch of elements right, and the article does a great job of explaining each.</source>
          <target state="translated">まず、このテーマ&lt;a href=&quot;https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence&quot;&gt;に関するParagon Initiativeの記事&lt;/a&gt;を読んでください。 たくさんの要素を正しく理解する必要があります。この記事では、それぞれの要素をうまく説明しています。</target>
        </trans-unit>
        <trans-unit id="9983f7fe8e0548ed05592e10b4d8737faf0870ba" translate="yes" xml:space="preserve">
          <source>First, we are confusing the initial creation of an account (with a password) with the re-checking of the password subsequently. If I am Flickr and creating your site for the first time, the new user has access to zero value (blank web space). I truly do not care if the person creating the account is lying about their name. If I am creating an account of the hospital intranet/extranet, the value lies in all the medical records, and so I &lt;em&gt;do&lt;/em&gt; care about the identity (*) of the account creator.</source>
          <target state="translated">まず、最初にアカウント（パスワードを使用）を作成することと、その後にパスワードを再確認することを混同しています。 私がFlickrで初めてサイトを作成する場合、新しいユーザーはゼロの値（空白のWebスペース）にアクセスできます。 アカウントを作成する人が自分の名前について嘘をついているかどうか、私は本当に気にしません。 病院のイントラネット/エクストラネットのアカウントを作成している場合、その値はすべての医療記録にあるため、アカウント作成者のID（*）に注意します。</target>
        </trans-unit>
        <trans-unit id="43fce5a38d3ccc4394c31ed312d1e3f3bbcdb4f5" translate="yes" xml:space="preserve">
          <source>First, you'll want to read this small article for a reality check: &lt;a href=&quot;http://www.whatsmypass.com/?p=415&quot;&gt;The 500 most common passwords&lt;/a&gt;</source>
          <target state="translated">最初に、現実をチェックするためにこの小さな記事を読みたくなるでしょう： &lt;a href=&quot;http://www.whatsmypass.com/?p=415&quot;&gt;最も一般的な500のパスワード&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc25ac14ee563260aa5557fc0a6773974bd214de" translate="yes" xml:space="preserve">
          <source>For browsers that don&amp;rsquo;t support the Verified Email Protocol (currently all of them), Mozilla provides a shim which implements the protocol in client-side JavaScript code.</source>
          <target state="translated">確認済みメールプロトコルをサポートしていないブラウザ（現在はすべて）に対して、Mozillaはクライアント側のJavaScriptコードでプロトコルを実装するシムを提供しています。</target>
        </trans-unit>
        <trans-unit id="a432583ba49ebf5724dd0a7840811c9356950ca3" translate="yes" xml:space="preserve">
          <source>For email services that don&amp;rsquo;t support the Verified Email Protocol, the protocol allows third parties to act as a trusted intermediary, asserting that they&amp;rsquo;ve verified a user&amp;rsquo;s ownership of an account. It is not desirable to have a large number of such third parties; this capability is intended only to allow an upgrade path, and it is much preferred that email services provide these assertions themselves.</source>
          <target state="translated">確認済みメールプロトコルをサポートしていないメールサービスの場合、このプロトコルを使用すると、第三者が信頼できる仲介者として機能し、ユーザーがアカウントの所有権を確認したことを証明できます。 このような第三者を多数持つことは望ましくありません。 この機能は、アップグレードパスを許可することのみを目的としており、電子メールサービスがこれらのアサーションを提供することが非常に推奨されます。</target>
        </trans-unit>
        <trans-unit id="1a29c9f448b4e82925d7464abc91594ed7ceb096" translate="yes" xml:space="preserve">
          <source>Forgotten username/password functionality</source>
          <target state="translated">ユーザー名とパスワードを忘れた場合の機能</target>
        </trans-unit>
        <trans-unit id="4c44940eff64d8851ea63a4d7d267c3700ac7b6f" translate="yes" xml:space="preserve">
          <source>Form-based authentication for websites</source>
          <target state="translated">ウェブサイトのフォームベース認証</target>
        </trans-unit>
        <trans-unit id="8c3c600b9979573648ec2a7bc6061a82458b6242" translate="yes" xml:space="preserve">
          <source>Form-based authentication has a big drawback, which is an increased risk of &lt;a href=&quot;http://en.wikipedia.org/wiki/Phishing&quot;&gt;phishing&lt;/a&gt;. Users are asked to enter sensitive information into an area controlled by a remote entity, rather than an area controlled by their User Agent (browser).</source>
          <target state="translated">フォームベースの認証には大きな欠点があり、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Phishing&quot;&gt;フィッシングの&lt;/a&gt;リスクが高まります。 ユーザーは、ユーザーエージェント（ブラウザ）によって制御される領域ではなく、リモートエンティティによって制御される領域に機密情報を入力するように求められます。</target>
        </trans-unit>
        <trans-unit id="0ef26769a71921c31789a2a8774d89fdae723d09" translate="yes" xml:space="preserve">
          <source>Forum discussion about a Coding Horror article.</source>
          <target state="translated">コーディングホラーの記事についてのフォーラムディスカッション。</target>
        </trans-unit>
        <trans-unit id="c026b4ef95ca288f3bb81cc79228ab85b91d71b2" translate="yes" xml:space="preserve">
          <source>Forum discussion on the subject</source>
          <target state="translated">話題のフォーラムディスカッション</target>
        </trans-unit>
        <trans-unit id="da292fcb68a4e760db8e5e44afc487fef3ebd153" translate="yes" xml:space="preserve">
          <source>From your point-of-view, you simply know this: that &lt;em&gt;anyone&lt;/em&gt; who legitimately winds-up at your website &lt;em&gt;must&lt;/em&gt; be accompanied by [an environment-variable magically containing ...] a &quot;token.&quot; (&lt;em&gt;i.e.&lt;/em&gt; The absence of such a token must be immediate grounds for &lt;code&gt;404 Not Found&lt;/code&gt;.)</source>
          <target state="translated">あなたの視点から、あなたはこれを単に知っています：あなたのウェブサイトを正当に巻き上げる&lt;em&gt;人は誰でも&lt;/em&gt; [魔法のように含んでいる環境変数...] &quot;トークン&quot;を伴わ&lt;em&gt;なければならないという&lt;/em&gt;ことです。 （ &lt;em&gt;つまり&lt;/em&gt; 、そのようなトークンがないことは、 &lt;code&gt;404 Not Found&lt;/code&gt; の直接の根拠でなければなりません 。）</target>
        </trans-unit>
        <trans-unit id="6711dc17a4ea41f713c35b2df6b7663446e7a514" translate="yes" xml:space="preserve">
          <source>Generally speaking, you have three choices that are all effective against brute-force attacks &lt;em&gt;(and dictionary attacks, but since you are already employing a strong passwords policy, they shouldn't be an issue)&lt;/em&gt;:</source>
          <target state="translated">一般的に、ブルートフォース攻撃&lt;em&gt;（および辞書攻撃）&lt;/em&gt;に対して効果的な3つの選択肢があり&lt;em&gt;ますが、既に強力なパスワードポリシーを採用しているため、問題にはなりません&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a740b3ba607923f583d5988ec528cdaf1406a543" translate="yes" xml:space="preserve">
          <source>Given the perceived (though now &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;avoidable&lt;/a&gt;) cost and technical difficulty of setting up an SSL certificate on your website, some developers are tempted to roll their own in-browser hashing or encryption schemes in order to avoid passing cleartext logins over an unsecured wire.</source>
          <target state="translated">WebサイトにSSL証明書を設定することの知覚された（現在は&lt;a href=&quot;https://letsencrypt.org/&quot;&gt;回避可能ですが&lt;/a&gt; ）コストと技術的な難しさを考えると、一部の開発者は、セキュリティで保護されていないワイヤを介してクリアテキストのログインを渡さないようにするために、ブラウザ内のハッシュまたは暗号化スキームを独自に導入したいと考えています。</target>
        </trans-unit>
        <trans-unit id="40da55bdbda9f92b4cb162d0fa0d30ae87ad8e57" translate="yes" xml:space="preserve">
          <source>HTTP basic authentication</source>
          <target state="translated">HTTTP基本認証</target>
        </trans-unit>
        <trans-unit id="a7a3e467744831641be2fe6f9f61a5eb1eab7a0c" translate="yes" xml:space="preserve">
          <source>Hashes by themselves are also insecure. For instance, identical passwords mean identical hashes--this makes hash lookup tables an effective way of cracking lots of passwords at once. Instead, store the &lt;strong&gt;salted&lt;/strong&gt; hash. A salt is a string appended to the password prior to hashing - use a different (random) salt per user. The salt is a public value, so you can store them with the hash in the database. See &lt;a href=&quot;http://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right&quot;&gt;here&lt;/a&gt; for more on this.</source>
          <target state="translated">ハッシュ自体も安全ではありません。 たとえば、同一のパスワードは同一のハッシュを意味します。これにより、ハッシュルックアップテーブルは多数のパスワードを一度にクラックする効果的な方法になります。 代わりに、 &lt;strong&gt;ソルト&lt;/strong&gt;ハッシュを保存します。 ソルトとは、ハッシュの前にパスワードに追加される文字列です。ユーザーごとに異なる（ランダムな）ソルトを使用してください。 ソルトは公開値なので、ハッシュとともにデータベースに保存できます。 詳しくは&lt;a href=&quot;http://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="fd6ee87981c059ffe762f87d9835ba6d3ad5cb0a" translate="yes" xml:space="preserve">
          <source>Here, the best practice would be &lt;strong&gt;logging the number of failed logins, system-wide&lt;/strong&gt;, and using a running average of your site's bad-login frequency as the basis for an upper limit that you then impose on all users.</source>
          <target state="translated">ここでのベストプラクティスは&lt;strong&gt;、失敗したログインの数をシステム全体&lt;/strong&gt;で&lt;strong&gt;ログに記録し、&lt;/strong&gt;サイトの不正ログイン頻度の移動平均を、すべてのユーザーに課す上限の基準として使用することです。</target>
        </trans-unit>
        <trans-unit id="fd97645c83ca1f0b0cb1e045d47f5c3cb7a28597" translate="yes" xml:space="preserve">
          <source>How to log in</source>
          <target state="translated">ログイン方法</target>
        </trans-unit>
        <trans-unit id="2e2ac11edd26bbdc67b5b782fb1bfa9b679a85ca" translate="yes" xml:space="preserve">
          <source>How to log out</source>
          <target state="translated">ログアウト方法</target>
        </trans-unit>
        <trans-unit id="b242ffd64cf4e91fee323fe99df436b843031995" translate="yes" xml:space="preserve">
          <source>How to remain logged in</source>
          <target state="translated">ログイン状態を維持する方法</target>
        </trans-unit>
        <trans-unit id="2a1b49d2e2c078dfbf427749a4c26aa10b7064f2" translate="yes" xml:space="preserve">
          <source>How to store passwords</source>
          <target state="translated">パスワードの保存方法</target>
        </trans-unit>
        <trans-unit id="396f12c235f8be0ad58a8e4b445d0acff62942ae" translate="yes" xml:space="preserve">
          <source>However, I do not recommend this, except for public, low-value services. This is an issue with some of the other answers above - do not try an re-implement server-side authentication mechanisms - this problem has been solved and is supported by most major browsers. Do not use cookies. Do not store anything in your own hand-rolled database. Just ask, per request, if the request is authenticated. Everything else should be supported by configuration and third-party trusted software.</source>
          <target state="translated">しかし、パブリックで価値の低いサービスを除いては、私はこれをお勧めしません。これは上記の他の回答のいくつかの問題です-サーバーサイドの認証メカニズムを再実装しようとしないでください-この問題は解決されており、ほとんどの主要なブラウザでサポートされています。クッキーを使用しないでください。あなた自身の手で操作したデータベースには何も保存しないでください。リクエストごとに、リクエストが認証されているかどうかを尋ねるだけです。それ以外のことは、設定とサードパーティの信頼できるソフトウェアでサポートされているはずです。</target>
        </trans-unit>
        <trans-unit id="35336df7d00b75c54f5da32119b429c80525c3f8" translate="yes" xml:space="preserve">
          <source>I already mentioned why you should &lt;strong&gt;never use security questions&lt;/strong&gt; for handling forgotten/lost user passwords; it also goes without saying that you should never e-mail users their actual passwords. There are at least two more all-too-common pitfalls to avoid in this field:</source>
          <target state="translated">忘れた/紛失したユーザーパスワードの処理に&lt;strong&gt;セキュリティの質問&lt;/strong&gt;を&lt;strong&gt;使用し&lt;/strong&gt;てはいけ&lt;strong&gt;ない&lt;/strong&gt;理由についてはすでに述べました。 言うまでもなく、ユーザーに実際のパスワードを電子メールで送信してはなりません。 この分野で避けるべき、少なくとも2つのあまりにも一般的な落とし穴があります。</target>
        </trans-unit>
        <trans-unit id="359c53abe1e06714c19e031a3d67bc68ab3e0368" translate="yes" xml:space="preserve">
          <source>I also posted a question with &lt;a href=&quot;https://stackoverflow.com/questions/479233/what-is-the-best-distributed-brute-force-countermeasure&quot;&gt;more details and a really good discussion of how to avoid tricky pitfals&lt;/a&gt; in fending off distributed brute force attacks</source>
          <target state="translated">私はまた、 &lt;a href=&quot;https://stackoverflow.com/questions/479233/what-is-the-best-distributed-brute-force-countermeasure&quot;&gt;詳細と&lt;/a&gt;質問を投稿し、分散型ブルートフォース攻撃を回避する際にトリッキーなピットファルを回避する方法についての非常に良い議論をしました</target>
        </trans-unit>
        <trans-unit id="552c8b130191ea16fccf86d6a9186258c92a2d85" translate="yes" xml:space="preserve">
          <source>I believe this can also be used just fine with a login/authentication form.</source>
          <target state="translated">これもloginauthentication形式で丁度いい感じに使えると思います。</target>
        </trans-unit>
        <trans-unit id="58d1e47f90e80b52a252896eadaa4328f0a6b31f" translate="yes" xml:space="preserve">
          <source>I call it the &lt;strong&gt;Dummy Field&lt;/strong&gt; (though I haven't invented this so don't credit me).</source>
          <target state="translated">私はそれを&lt;strong&gt;ダミーフィールド&lt;/strong&gt;と呼んでいます（私はこれを発明していませんので、私を信用しないでください）。</target>
        </trans-unit>
        <trans-unit id="51d616a1c6a5e687603e42051a1947e650345bcd" translate="yes" xml:space="preserve">
          <source>I do not think the above answer is &quot;wrong&quot; but there are large areas of authentication that are not touched upon (or rather the emphasis is on &quot;how to implement cookie sessions&quot;, not on &quot;what options are available and what are the trade-offs&quot;.</source>
          <target state="translated">上記の回答が「間違っている」とは思いませんが、認証には触れられていない大きな領域があります(というか、強調されているのは「クッキーセッションをどのように実装するか」であって、「どのようなオプションが利用可能で、どのようなトレードオフがあるか」ではありません)。</target>
        </trans-unit>
        <trans-unit id="234454f3c20ac324649e33650f7a78ebefe0cf90" translate="yes" xml:space="preserve">
          <source>I dont't know whether it was best to answer this as an answer or as a comment. I opted for the first option.</source>
          <target state="translated">これに回答として答えるのがベストだったのか、コメントとして答えるのがベストだったのかはわかりません。私は最初の選択肢を選びました。</target>
        </trans-unit>
        <trans-unit id="090605f11afa494248191955e5ee70233bd277e2" translate="yes" xml:space="preserve">
          <source>I just thought I'd share this solution that I found to be working just fine.</source>
          <target state="translated">私はちょうど私がちょうどうまく機能していることを発見したこのソリューションを共有しようと思いました。</target>
        </trans-unit>
        <trans-unit id="846fe96011a7002d9135a22ab8068ef55c9146e6" translate="yes" xml:space="preserve">
          <source>I used this method on a guestbook in combination with &lt;a href=&quot;http://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt;, and I haven't seen a single spam post since. I had used a CAPTCHA-only solution before, but eventually, it resulted in about five spam posts every hour. Adding the dummy field in the form has stopped (at least until now) all the spam from appearing.</source>
          <target state="translated">ゲストブックでこの方法を&lt;a href=&quot;http://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt;と組み合わせて使用​​しましたが、それ以来、スパムの投稿は1つもありません。 以前はCAPTCHAのみのソリューションを使用していましたが、最終的には毎時約5つのスパム投稿が発生しました。 フォームにダミーフィールドを追加すると、（少なくとも今までは）すべてのスパムが表示されなくなりました。</target>
        </trans-unit>
        <trans-unit id="b6d4b92eeb3592863419cde2a6152c7de7c64e87" translate="yes" xml:space="preserve">
          <source>I will go ahead and mention Mozilla&amp;rsquo;s proposed &lt;a href=&quot;https://browserid.org/&quot;&gt;BrowserID&lt;/a&gt; (or perhaps more precisely, the &lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest&quot;&gt;Verified Email Protocol&lt;/a&gt;) in the spirit of finding an upgrade path to better approaches to authentication in the future.</source>
          <target state="translated">私は先に進み、将来の認証へのより良いアプローチへのアップグレードパスを見つけるという精神で、Mozillaが提案した&lt;a href=&quot;https://browserid.org/&quot;&gt;BrowserID&lt;/a&gt; （またはより正確には&lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest&quot;&gt;Verified Email Protocol&lt;/a&gt; ）について言及します。</target>
        </trans-unit>
        <trans-unit id="bc9c11bf6ed7710b34884d2f00080ae405fc5189" translate="yes" xml:space="preserve">
          <source>I would like to add one very important comment: -</source>
          <target state="translated">とても重要なコメントを一つ付け加えたいと思います。</target>
        </trans-unit>
        <trans-unit id="0ca82fef2a32b5097bc2b8a6714ceaa59492e5aa" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;ll summarize it this way:</source>
          <target state="translated">このように要約します。</target>
        </trans-unit>
        <trans-unit id="083a429183d693f1046288e656d2da6a9a2af83c" translate="yes" xml:space="preserve">
          <source>I'd like to add one suggestion I've used, based on defense in depth. You don't need to have the same auth&amp;amp;auth system for admins as regular users. You can have a separate login form on a separate url executing separate code for requests that will grant high privileges. This one can make choices that would be a total pain to regular users. One such that I've used is to actually scramble the login URL for admin access and email the admin the new URL. Stops any brute force attack right away as your new URL can be arbitrarily difficult (very long random string) but your admin user's only inconvenience is following a link in their email. The attacker no longer knows where to even POST to.</source>
          <target state="translated">多層防御に基づいて、使用した提案を1つ追加したいと思います。 管理者は通常のユーザーと同じ認証と認証システムを使用する必要はありません。 高い特権を付与するリクエストに対して個別のコードを実行する個別のURLに個別のログインフォームを設定できます。 これは、通常のユーザーにとって大変な苦痛になる選択をすることができます。 私が使用したものの1つは、管理者アクセスのログインURLを実際にスクランブルし、管理者に新しいURLをメールで送信することです。 新しいURLは恣意的に困難（非常に長いランダム文字列）になる可能性があるため、ブルートフォース攻撃をすぐに停止しますが、管理ユーザーの唯一の不便は、メールのリンクをたどることです。 攻撃者は、どこにPOSTするかさえわからなくなります。</target>
        </trans-unit>
        <trans-unit id="f7d467c663e66cb7f264b6751a1994846cbe912f" translate="yes" xml:space="preserve">
          <source>If at all possible, make sure the session cookie has the secure and HTTP Only flags set when sent to the browser. The HttpOnly flag provides some protection against the cookie being read through XSS attack. The secure flag ensures that the cookie is only sent back via HTTPS, and therefore protects against network sniffing attacks. The value of the cookie should not be predictable. Where a cookie referencing a non-existent session is presented, its value should be replaced immediately to prevent &lt;a href=&quot;https://www.owasp.org/index.php/Session_fixation&quot;&gt;session fixation&lt;/a&gt;.</source>
          <target state="translated">可能であれば、ブラウザに送信するときにセッションCookieにセキュアフラグとHTTPのみのフラグが設定されていることを確認してください。 HttpOnlyフラグは、XSS攻撃によって読み取られるCookieに対するある程度の保護を提供します。 セキュアフラグは、CookieがHTTPS経由でのみ返されることを保証し、ネットワークスニッフィング攻撃から保護します。 Cookieの値は予測できません。 存在しないセッションを参照するCookieが提示された場合、その値をすぐに置き換えて、 &lt;a href=&quot;https://www.owasp.org/index.php/Session_fixation&quot;&gt;セッションが固定さ&lt;/a&gt;れないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="05a40820406ffb4581e8e6750a3ac4b5784853e0" translate="yes" xml:space="preserve">
          <source>If the connection between the client and server is unencrypted, everything you do is &lt;a href=&quot;https://stackoverflow.com/questions/14907581/ssl-and-man-in-the-middle-misunderstanding&quot;&gt;vulnerable to man-in-the-middle attacks&lt;/a&gt;. An attacker could replace the incoming javascript to break the hashing or send all credentials to their server, they could listen to client responses and impersonate the users perfectly, etc. etc. SSL with trusted Certificate Authorities is designed to prevent MitM attacks.</source>
          <target state="translated">クライアントとサーバー間の接続が暗号化されていない場合、実行することはすべて&lt;a href=&quot;https://stackoverflow.com/questions/14907581/ssl-and-man-in-the-middle-misunderstanding&quot;&gt;中間者攻撃に対して脆弱&lt;/a&gt;です。 攻撃者は、受信したJavaScriptを置き換えてハッシュを壊したり、すべての資格情報をサーバーに送信したり、クライアントの応答を聞いたり、ユーザーを完全に偽装したりすることができます。など。信頼できる認証局とのSSLは、MitM攻撃を防ぐように設計されています。</target>
        </trans-unit>
        <trans-unit id="a005965818e2683004bec583de84ca2d5c7d5f8f" translate="yes" xml:space="preserve">
          <source>If you are unfamiliar with session data, here's how it works: A single randomly-generated string is stored in an expiring cookie and used to reference a collection of data - the session data - which is stored on the server. If you are using an MVC framework, this is undoubtedly handled already.</source>
          <target state="translated">セッションデータについてよく知らない方のために、セッションデータがどのように機能するかを説明します。ランダムに生成された単一の文字列が期限切れのクッキーに保存され、サーバに保存されているデータの集合であるセッションデータを参照するために使用されます。MVC フレームワークを使っている場合、これは間違いなくすでに処理されています。</target>
        </trans-unit>
        <trans-unit id="9bf51661f29e2e2b97a777af17d93aa3c2ad75df" translate="yes" xml:space="preserve">
          <source>If you don't have the time to look through the tables in that link, here's the list of them:</source>
          <target state="translated">そのリンク先の表に目を通す時間がないという方は、こちらの表をご覧ください。</target>
        </trans-unit>
        <trans-unit id="a9f82947c6f8dcc354957eb7fe3f008ee9248d9d" translate="yes" xml:space="preserve">
          <source>If you want to autologin your users, you can set a persistent cookie, but it should be distinct from a full-session cookie. You can set an additional flag that the user has auto-logged in, and needs to log in for real for sensitive operations. This is popular with shopping sites that want to provide you with a seamless, personalized shopping experience but still protect your financial details. For example, when you return to visit Amazon, they show you a page that looks like you're logged in, but when you go to place an order (or change your shipping address, credit card etc.), they ask you to confirm your password.</source>
          <target state="translated">ユーザーを自動ログインさせたい場合、永続的なクッキーを設定できますが、フルセッション・クッキーとは区別されなければなりません。ユーザーが自動ログインしており、機密性の高い操作のために実際にログインする必要があるという追加のフラグを設定することができます。これは、シームレスでパーソナライズされたショッピング体験を提供しながらも、お客様の財務情報を保護したいショッピングサイトで人気があります。例えば、Amazonを訪問するために戻ってくると、ログインしているように見えるページが表示されますが、注文(または配送先住所やクレジットカードなどの変更)をしに行くと、パスワードの確認を求められます。</target>
        </trans-unit>
        <trans-unit id="2a3aa3e666ad28239fd17e0d9ca973882c20bb50" translate="yes" xml:space="preserve">
          <source>In essence, the only &lt;strong&gt;practical&lt;/strong&gt; way to protect against wiretapping/packet sniffing during login is by using HTTPS or another certificate-based encryption scheme (for example, &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLS&lt;/a&gt;) or a proven &amp;amp; tested challenge-response scheme (for example, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;Diffie-Hellman&lt;/a&gt;-based SRP). &lt;em&gt;Any other method can be easily circumvented&lt;/em&gt; by an eavesdropping attacker.</source>
          <target state="translated">本質的に、ログイン中の盗聴/パケットスニッフィングから保護する唯一の&lt;strong&gt;実用的な&lt;/strong&gt;方法は、HTTPSまたは別の証明書ベースの暗号化スキーム（ &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLSなど&lt;/a&gt; ）または実証済みでテスト済みのチャレンジ/レスポンススキーム（ &lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;Diffie-Hellmanなど）を使用することです&lt;/a&gt;ベースのSRP）。 &lt;em&gt;その他の方法は&lt;/em&gt; 、盗聴者によって&lt;em&gt;簡単に回避できます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="2544113bc111cfaa02b8dad7705eb320ec051b0e" translate="yes" xml:space="preserve">
          <source>In short: you just have to insert this into your &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; and check for it to be empty at when validating:</source>
          <target state="translated">つまり、これを &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; に挿入して、検証時に空になることを確認するだけです。</target>
        </trans-unit>
        <trans-unit id="5889d9ac21ea7878fc3980b6f8fb4739068f29ad" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;Remember your password&lt;/strong&gt; forms, an attacker could potentially check a full list of emails and detect which are registered to the system (see link below).</source>
          <target state="translated">&lt;strong&gt;パスワード&lt;/strong&gt;を&lt;strong&gt;記憶する&lt;/strong&gt;フォームでは、攻撃者は電子メールの完全なリストをチェックして、システムに登録されている電子メールを検出する可能性があります（以下のリンクを参照）。</target>
        </trans-unit>
        <trans-unit id="b63daf6854097ee286d453fcdaa4ea9d7d846b17" translate="yes" xml:space="preserve">
          <source>In the end, it's a tradeoff - what is the cost of a security breach vs the cost of implementing more secure approaches. One day, we may see a proper &lt;a href=&quot;http://en.wikipedia.org/wiki/Public-key_infrastructure&quot;&gt;PKI&lt;/a&gt; widely accepted and so no more own rolled authentication forms and databases. One day...</source>
          <target state="translated">結局のところ、それはトレードオフです-セキュリティ違反のコストと、より安全なアプローチを実装するコストはどれくらいですか。 ある日、広く受け入れられている適切な&lt;a href=&quot;http://en.wikipedia.org/wiki/Public-key_infrastructure&quot;&gt;PKIが見つかる&lt;/a&gt;ようになり、独自のロール認証フォームとデータベースがなくなります。 ある日...</target>
        </trans-unit>
        <trans-unit id="0635ff3ae1d3558d900b0d72cf905e6930f16a3d" translate="yes" xml:space="preserve">
          <source>Introductory article about storing passwords</source>
          <target state="translated">パスワードの保存についての紹介記事</target>
        </trans-unit>
        <trans-unit id="5e735dc6ff9a579700296dcebbafce05242f5c1e" translate="yes" xml:space="preserve">
          <source>It should include topics such as:</source>
          <target state="translated">などのトピックが含まれているはずです。</target>
        </trans-unit>
        <trans-unit id="a6420257e778a00afc297ad00fbecf2ebe7c8b6a" translate="yes" xml:space="preserve">
          <source>It should not include things like:</source>
          <target state="translated">のようなものを含むべきではありません。</target>
        </trans-unit>
        <trans-unit id="b1ce4421333cb720d377733655d21a7298f4e002" translate="yes" xml:space="preserve">
          <source>It takes &lt;em&gt;virtually no time&lt;/em&gt; to crack a weak password, even if you're cracking it with an abacus</source>
          <target state="translated">そろばんでクラックしても、弱いパスワードをクラックするのに&lt;em&gt;ほとんど時間&lt;/em&gt;はかかり&lt;em&gt;ません&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f95b8ec5420157ff1e1b91b761a8ebd2d92a665b" translate="yes" xml:space="preserve">
          <source>It takes &lt;em&gt;virtually no time&lt;/em&gt; to crack an alphanumeric 9-character password if it is &lt;strong&gt;case insensitive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;大文字と小文字を区別しない&lt;/strong&gt;場合、英数字の9文字のパスワードをクラックするのに&lt;em&gt;実質的&lt;/em&gt;に時間はかかり&lt;em&gt;ませ&lt;/em&gt; &lt;strong&gt;ん&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2183ae63555a89f9b9da5626b8c677c779b62650" translate="yes" xml:space="preserve">
          <source>It takes &lt;em&gt;virtually no time&lt;/em&gt; to crack an intricate, symbols-and-letters-and-numbers, upper-and-lowercase password if it is &lt;strong&gt;less than 8 characters long&lt;/strong&gt; (a desktop PC can search the entire keyspace up to 7 characters in a matter of days or even hours)</source>
          <target state="translated">&lt;strong&gt;長さが8文字未満で&lt;/strong&gt;あれば、複雑な記号と文字と数字の大文字と小文字のパスワードを解読するのに&lt;em&gt;実質的&lt;/em&gt;に時間はかかり&lt;em&gt;ません&lt;/em&gt; （デスクトップPCは最大7文字のキースペース全体を検索できます）日または時間の）</target>
        </trans-unit>
        <trans-unit id="ca83a47062492ece2469dd660cd19ba05f1e6542" translate="yes" xml:space="preserve">
          <source>Just as an aside, more advanced attackers will try to circumvent login throttling by 'spreading their activities':</source>
          <target state="translated">余談ですが、より高度な攻撃者は「活動を広める」ことでログイン・スロットリングを回避しようとします。</target>
        </trans-unit>
        <trans-unit id="454c33180f12a0ab4b94d928089179f2810d2e55" translate="yes" xml:space="preserve">
          <source>Kerberos and SPNEGO - single sign-on mechanisms with a trusted third party - basically the user verifies against a trusted third party. (NB this is not in any way the not to be trusted &lt;a href=&quot;http://en.wikipedia.org/wiki/OAuth&quot;&gt;OAuth&lt;/a&gt;)</source>
          <target state="translated">KerberosとSPNEGO-信頼できるサードパーティによるシングルサインオンメカニズム-基本的に、ユーザーは信頼できるサードパーティに対して検証を行います。 （これは決して信頼できる&lt;a href=&quot;http://en.wikipedia.org/wiki/OAuth&quot;&gt;OAuthで&lt;/a&gt;はありません）</target>
        </trans-unit>
        <trans-unit id="ef605fb60b2983e8337bddb62501975987044821" translate="yes" xml:space="preserve">
          <source>Know that CAPTCHA implementations are not created alike; they often aren't human-solvable, most of them are actually ineffective against bots, all of them are ineffective against cheap third-world labor (according to &lt;a href=&quot;https://en.wikipedia.org/wiki/OWASP&quot;&gt;OWASP&lt;/a&gt;, the current sweatshop rate is $12 per 500 tests), and some implementations may be technically illegal in some countries (see &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP Authentication Cheat Sheet&lt;/a&gt;). If you must use a CAPTCHA, use Google's &lt;a href=&quot;https://en.wikipedia.org/wiki/ReCAPTCHA&quot;&gt;reCAPTCHA&lt;/a&gt;, since it is OCR-hard by definition (since it uses already OCR-misclassified book scans) and tries very hard to be user-friendly.</source>
          <target state="translated">CAPTCHA実装は同じように作成されていないことを知ってください。 それらはしばしば人間が解決できないものであり、それらのほとんどは実際にはボットに対して無効であり、それらのすべては安価な第三世界の労働に対して無効です（ &lt;a href=&quot;https://en.wikipedia.org/wiki/OWASP&quot;&gt;OWASP&lt;/a&gt;によると、現在のスウェットショップのレートは500テストあたり12ドルです）。一部の国では技術的に違法です（ &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP認証チートシートを&lt;/a&gt;参照）。 CAPTCHAを使用する必要がある場合、Googleの&lt;a href=&quot;https://en.wikipedia.org/wiki/ReCAPTCHA&quot;&gt;reCAPTCHAを&lt;/a&gt;使用してください。これは、定義によりOCRが難しいため（すでにOCRが誤って分類されたブックスキャンを使用しているため）、ユーザーフレンドリーになるように非常に努力しています。</target>
        </trans-unit>
        <trans-unit id="a204cab302bc515068a3e7ff919f172312b7a0da" translate="yes" xml:space="preserve">
          <source>List of external resources</source>
          <target state="translated">外部リソース一覧</target>
        </trans-unit>
        <trans-unit id="800d50f9971121d60ff4213c83ab585dc8eeb2d2" translate="yes" xml:space="preserve">
          <source>MUST-READ LINKS About Web Authentication</source>
          <target state="translated">ウェブ認証についての必読リンク</target>
        </trans-unit>
        <trans-unit id="e39ad0433ee22ae9d29fea44a1452bb36e98f70f" translate="yes" xml:space="preserve">
          <source>Managing cookies (including recommended settings)</source>
          <target state="translated">クッキーの管理(推奨設定を含む</target>
        </trans-unit>
        <trans-unit id="13f082e2a62294764b183257e5521811d1761c76" translate="yes" xml:space="preserve">
          <source>Many corporations deploy &quot;internal use only&quot; websites which are, effectively, &quot;corporate applications&quot; that happen to have been implemented through URLs. These URLs can &lt;em&gt;(supposedly ...)&lt;/em&gt; only be resolved within &quot;the company's internal network.&quot; &lt;em&gt;(Which network magically includes all VPN-connected 'road warriors.')&lt;/em&gt;</source>
          <target state="translated">多くの企業は、「社内使用のみ」のWebサイトを展開しています。これは、事実上、「企業アプリケーション」であり、URLを介して実装されています。 これらのURLは&lt;em&gt;（おそらく...）&lt;/em&gt; 「会社の内部ネットワーク」内でのみ解決できます。 &lt;em&gt;（どのネットワークには、VPN接続されたすべての「ロードウォリアー」が魔法のように含まれています。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d428631e07ab70149afe871ed89abba6b41c7b09" translate="yes" xml:space="preserve">
          <source>Mozilla is a nonprofit with &lt;a href=&quot;http://www.mozilla.org/about/manifesto.en.html&quot;&gt;values&lt;/a&gt; that align well with finding good solutions to this problem.</source>
          <target state="translated">Mozillaは非営利団体であり、この問題に対する適切な解決策を見つけることとうまく一致する&lt;a href=&quot;http://www.mozilla.org/about/manifesto.en.html&quot;&gt;価値観&lt;/a&gt;を持っています 。</target>
        </trans-unit>
        <trans-unit id="f78a34f17d1960af584815ea7b1a57f63ea0b523" translate="yes" xml:space="preserve">
          <source>Mozilla offers their own service to act like such a trusted third party. Service Providers (that is, Relying Parties) implementing the Verified Email Protocol may choose to trust Mozilla's assertions or not. Mozilla&amp;rsquo;s service verifies users&amp;rsquo; account ownership using the conventional means of sending an email with a confirmation link.</source>
          <target state="translated">Mozillaは、このような信頼できるサードパーティのように機能する独自のサービスを提供しています。 検証済み電子メールプロトコルを実装するサービスプロバイダー（つまり、依拠当事者）は、Mozillaの主張を信頼するかどうかを選択できます。 Mozillaのサービスは、確認リンクを含む電子メールを送信する従来の方法を使用して、ユーザーのアカウントの所有権を確認します。</target>
        </trans-unit>
        <trans-unit id="498fc0cb3210a89a93612a59292b4e349dedcfe9" translate="yes" xml:space="preserve">
          <source>My favourite rule in regards to authentication systems: use passphrases, not passwords. Easy to remember, hard to crack.
More info: &lt;a href=&quot;http://www.codinghorror.com/blog/2005/07/passwords-vs-pass-phrases.html&quot;&gt;Coding Horror: Passwords vs. Pass Phrases&lt;/a&gt;</source>
          <target state="translated">認証システムに関して私のお気に入りのルール：パスワードではなくパスフレーズを使用します。 覚えやすく、割れにくい。 詳細： &lt;a href=&quot;http://www.codinghorror.com/blog/2005/07/passwords-vs-pass-phrases.html&quot;&gt;コーディングホラー：パスワードとパスフレーズ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46d5ca1861ce7684ad68bb0fececc25f88365029" translate="yes" xml:space="preserve">
          <source>My suggested edits/answers are</source>
          <target state="translated">私が提案する編集回答は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a02f8183c755dd3e7c9319a28b14d5b05917066b" translate="yes" xml:space="preserve">
          <source>Never store passwords in a database!</source>
          <target state="translated">パスワードをデータベースに保存してはいけません。</target>
        </trans-unit>
        <trans-unit id="c3cad7a29e678534156a1c67fb73684d81f0154f" translate="yes" xml:space="preserve">
          <source>Of course, if you are willing to get a little bit impractical, you could also employ some form of two-factor authentication scheme (e.g. the Google Authenticator app, a physical 'cold war style' codebook, or an RSA key generator dongle). If applied correctly, this could work even with an unsecured connection, but it's hard to imagine that a dev would be willing to implement two-factor auth but not SSL.</source>
          <target state="translated">もちろん、もしあなたが少しでも非現実的になりたいのであれば、何らかの形で二要素認証スキームを採用することもできます (例:Google Authenticator アプリ、物理的な「冷戦スタイル」のコードブック、または RSA キージェネレータのドングル)。正しく適用されれば、これは安全でない接続でも動作しますが、開発者が二要素認証を実装してもSSLではないことは想像に難くありません。</target>
        </trans-unit>
        <trans-unit id="40746c6aaf7e82f6f6299e3405c2afa45a1ae213" translate="yes" xml:space="preserve">
          <source>Of course, some systems can't afford to have &lt;em&gt;any&lt;/em&gt; accounts hacked; for such systems, there is no way you can justify having persistent logins.</source>
          <target state="translated">もちろん、一部のシステムではアカウントをハッキングすることはできません。 このようなシステムでは、永続的なログインを正当化する方法はありません。</target>
        </trans-unit>
        <trans-unit id="d9bfdd2c36a6c3abb8c87cb643353651b30d90ae" translate="yes" xml:space="preserve">
          <source>Okay, so maybe the list isn't the &lt;em&gt;canonical&lt;/em&gt; list of most common passwords on &lt;em&gt;any&lt;/em&gt; system &lt;em&gt;anywhere ever&lt;/em&gt;, but it's a good indication of how poorly people will choose their passwords when there is no enforced policy in place. Plus, the list looks frighteningly close to home when you compare it to publicly available analyses of recently stolen passwords.</source>
          <target state="translated">わかりました。そのため、このリストは&lt;em&gt;どこの&lt;/em&gt;システムで&lt;em&gt;も&lt;/em&gt;最も一般的なパスワードの&lt;em&gt;正規の&lt;/em&gt;リストではないかもしれませんが、ポリシーが適用されていない場合に、ユーザーがパスワードをどの程度適切に選択しないかを示す良い目安になります。 さらに、最近盗まれたパスワードの公に利用可能な分析と比較すると、リストは恐ろしく自宅に近いように見えます。</target>
        </trans-unit>
        <trans-unit id="dab5116e744a1fc1ff720960059dcea9695942af" translate="yes" xml:space="preserve">
          <source>Once the server has verified the login and password against your user database and found a match, the system needs a way to remember that the browser has been authenticated. This fact should only ever be stored server side in the session data.</source>
          <target state="translated">サーバがログインとパスワードをユーザデータベースと照合し、一致するものを見つけたら、システムはブラウザが認証されたことを記憶する方法を必要とします。この事実は、サーバー側のセッションデータにのみ保存されるべきです。</target>
        </trans-unit>
        <trans-unit id="472334b926db37e8b1ba9a091cdc0aa12469e6de" translate="yes" xml:space="preserve">
          <source>OpenID</source>
          <target state="translated">OpenID</target>
        </trans-unit>
        <trans-unit id="43d608c39c9af2e6d0b1f96b90ac641933e3c53f" translate="yes" xml:space="preserve">
          <source>Or, an increasing delay with a fixed upper bound, like:</source>
          <target state="translated">または、固定の上界を持つ増加する遅延、のような。</target>
        </trans-unit>
        <trans-unit id="ee98feac3f48bf9954396afdbaec912b4b30373b" translate="yes" xml:space="preserve">
          <source>PART I: How To Log In</source>
          <target state="translated">パート I:ログイン方法</target>
        </trans-unit>
        <trans-unit id="373bd2e0e8256779823fc6ab870ebbbd9fc5217a" translate="yes" xml:space="preserve">
          <source>PART II: How To Remain Logged In - The Infamous &quot;Remember Me&quot; Checkbox</source>
          <target state="translated">PART II:ログイン状態を維持する方法-悪名高い &quot;Remember Me &quot;チェックボックス</target>
        </trans-unit>
        <trans-unit id="8dffe7fbee47b5816874a7c779754cfc07bb7637" translate="yes" xml:space="preserve">
          <source>PART III: Using Secret Questions</source>
          <target state="translated">PART III:秘密の質問を使う</target>
        </trans-unit>
        <trans-unit id="8dc18f138173394995a3a25ea9f93f0d9276d9d7" translate="yes" xml:space="preserve">
          <source>PART IV: Forgotten Password Functionality</source>
          <target state="translated">PART IV:パスワードを忘れた場合の機能</target>
        </trans-unit>
        <trans-unit id="1bc7c0f4d41ebaa82c69b8f3e030406e7a778c30" translate="yes" xml:space="preserve">
          <source>PART V: Checking Password Strength</source>
          <target state="translated">PART V:パスワードの強度の確認</target>
        </trans-unit>
        <trans-unit id="f78f54dcfe36e53595355daeea59a314d68113c3" translate="yes" xml:space="preserve">
          <source>PART VI: Much More - Or: Preventing Rapid-Fire Login Attempts</source>
          <target state="translated">PART VI:もっと多くのことを-あるいは:突然のログイン試行を防ぐために</target>
        </trans-unit>
        <trans-unit id="d09120b5dd85861867d30d321dcb24147dc5181d" translate="yes" xml:space="preserve">
          <source>PART VII: Distributed Brute Force Attacks</source>
          <target state="translated">PART VII:分散型ブルートフォース攻撃</target>
        </trans-unit>
        <trans-unit id="3dfbaba91066aa51a3ed68e104660765f9263364" translate="yes" xml:space="preserve">
          <source>PART VIII: Two-Factor Authentication and Authentication Providers</source>
          <target state="translated">第VIII部:二要素認証と認証プロバイダ</target>
        </trans-unit>
        <trans-unit id="fca31875c99e7a759095453f43a17f8d41cc70b3" translate="yes" xml:space="preserve">
          <source>Password cracking</source>
          <target state="translated">パスワードクラッキング</target>
        </trans-unit>
        <trans-unit id="146c22ca524a64487e2cc7bae8bcd42354c41547" translate="yes" xml:space="preserve">
          <source>Persistent Login Cookies (&quot;remember me&quot; functionality) are a danger zone; on the one hand, they are entirely as safe as conventional logins when users understand how to handle them; and on the other hand, they are an enormous security risk in the hands of careless users, who may use them on public computers and forget to log out, and who may not know what browser cookies are or how to delete them.</source>
          <target state="translated">一方では、ユーザーがその扱い方を理解していれば、従来のログインと全く同じように安全ですが、一方では、公共のコンピュータで使用してログアウトするのを忘れたり、ブラウザのクッキーが何であるかや削除方法を知らなかったりするような不注意なユーザーの手には、巨大なセキュリティリスクとなります。</target>
        </trans-unit>
        <trans-unit id="4deb1845003254bce090e7dce697fed2deca1d3f" translate="yes" xml:space="preserve">
          <source>Personal knowledge questions for fallback authentication: Security questions in the era of Facebook (very readable Berkeley research paper)</source>
          <target state="translated">フォールバック認証のための個人知識の疑問 Facebook時代のセキュリティの疑問 (非常に読みやすいバークレーの研究論文)</target>
        </trans-unit>
        <trans-unit id="8715dbe3e22e6a227a3a03c6e99bbe78ee4654ac" translate="yes" xml:space="preserve">
          <source>Personally, I like persistent logins for the websites I visit on a regular basis, but I know how to handle them safely. If you are positive that your users know the same, you can use persistent logins with a clean conscience. If not - well, then you may subscribe to the philosophy that users who are careless with their login credentials brought it upon themselves if they get hacked. It's not like we go to our user's houses and tear off all those facepalm-inducing Post-It notes with passwords they have lined up on the edge of their monitors, either.</source>
          <target state="translated">個人的には、定期的に訪問するWebサイトでは永続的ログインが好きなのですが、安全に扱う方法を知っています。もしあなたのユーザーが同じことを知っていると確信しているのであれば、クリーンな良心で持続的ログインを使用することができます。そうでない場合は-まあ、ログイン認証情報に不注意なユーザーがハッキングされた場合、自分の責任であるという哲学を支持するかもしれません。ユーザーの家に行って、モニターの端に並んだパスワードを書いたポストイットノートを引きちぎるようなことはしません。</target>
        </trans-unit>
        <trans-unit id="b5bc9ae9abb000e507efbc7f604f75840ed71637" translate="yes" xml:space="preserve">
          <source>Personally, I tend to find CAPTCHAS annoying, and use them only as a last resort when a user has failed to log in a number of times and throttling delays are maxed out. This will happen rarely enough to be acceptable, and it strengthens the system as a whole.</source>
          <target state="translated">個人的には、CAPTCHASが煩わしいと感じる傾向があり、ユーザーが何度もログインに失敗してスロットリングの遅延がMAXになったときの最後の手段としてのみ使用しています。これは受け入れられるほど稀に起こることで、システム全体を強化します。</target>
        </trans-unit>
        <trans-unit id="e87d5138425a2b5a37293950847a50aac1982132" translate="yes" xml:space="preserve">
          <source>Please help us by:</source>
          <target state="translated">ご協力をお願いします。</target>
        </trans-unit>
        <trans-unit id="67d1467cdb0013316748d8f4abc7d3d3ed3d223d" translate="yes" xml:space="preserve">
          <source>Present a &lt;strong&gt;CAPTCHA&lt;/strong&gt; after N failed attempts (annoying as hell and often ineffective -- but I'm repeating myself here)</source>
          <target state="translated">N回の試行が失敗した後、 &lt;strong&gt;CAPTCHAを&lt;/strong&gt;提示します（地獄のように迷惑で、多くの場合効果がありませんが、ここでは繰り返します）。</target>
        </trans-unit>
        <trans-unit id="64a7e99339d587e4be9caac89b32728bfc07f27a" translate="yes" xml:space="preserve">
          <source>Rather than picking one user and trying the 50.000 most common passwords (which they can't, because of our throttling), they will pick THE most common password and try it against 50.000 users instead. That way, not only do they get around maximum-attempts measures like CAPTCHAs and login throttling, their chance of success increases as well, since the number 1 most common password is far more likely than number 49.995</source>
          <target state="translated">1人のユーザーを選んで、最も一般的な50,000のパスワードを試すのではなく(スロットリングのため、試すことができません)、最も一般的なパスワードを選んで、代わりに50,000のユーザーに対して試してみます。この方法では、CAPTCHAやログインスロットリングのような最大試行回数の制限を回避できるだけでなく、成功する可能性も高くなります。</target>
        </trans-unit>
        <trans-unit id="d13b08c8870d8a1a7e6f0400242c035b1aa248ea" translate="yes" xml:space="preserve">
          <source>Regarding the Forgotten Password Form, I would add that it is a good idea to equal times between successful and unsucessful queries with some delay function.</source>
          <target state="translated">パスワードを忘れた時のフォームについては、成功した時と失敗した時の時間を遅延機能を使って均等にするのが良いと思います。</target>
        </trans-unit>
        <trans-unit id="4de0e7b256b6ff9364d661492733a75f01e5a749" translate="yes" xml:space="preserve">
          <source>Regarding the poing &lt;strong&gt;PART IV: Forgotten Password Functionality&lt;/strong&gt; in the first answer, I would make a point about Timing Attacks.</source>
          <target state="translated">poing &lt;strong&gt;パートIV：&lt;/strong&gt;最初の答えの&lt;strong&gt;忘れられたパスワード機能&lt;/strong&gt;について、私はタイミング攻撃について指摘します。</target>
        </trans-unit>
        <trans-unit id="9586ca70862e87cb3f3f00c482403bfa49063bb2" translate="yes" xml:space="preserve">
          <source>Roles and authorization</source>
          <target state="translated">役割と認可</target>
        </trans-unit>
        <trans-unit id="c2f60d05179df3c940cc3e88087d3b1e28775f9d" translate="yes" xml:space="preserve">
          <source>SSL/HTTPS encryption</source>
          <target state="translated">SSLHTTPS暗号化</target>
        </trans-unit>
        <trans-unit id="cda028908c5cf102590df2f37ad3e49bc40adb5c" translate="yes" xml:space="preserve">
          <source>Say your site has had an average of 120 bad logins per day over the past 3 months. Using that (running average), your system might set the global limit to 3 times that -- ie. 360 failed attempts over a 24 hour period. Then, if the total number of failed attempts across all accounts exceeds that number within one day (or even better, monitor the rate of acceleration and trigger on a calculated threshold), it activates system-wide login throttling - meaning short delays for ALL users (still, with the exception of cookie logins and/or backup CAPTCHA logins).</source>
          <target state="translated">あなたのサイトでは、過去3ヶ月間に1日平均120件の不正ログインがあったとします。この(実行中の平均値)を使用して、システムはグローバル制限をその3倍、つまり24時間の間に360回の失敗したとします。そして、すべてのアカウントで失敗した試行の合計数が1日以内にその数を超えた場合(あるいは、加速率を監視し、計算されたしきい値でトリガーするのがより良い)、システム全体のログインスロットリングを有効にします-つまり、すべてのユーザーに対して短い遅延を意味します(それでも、クッキーログインとバックアップCAPTCHAログインを除いて)。</target>
        </trans-unit>
        <trans-unit id="976262d7d8f225a98d283e5a7e1b9cb193c18cf0" translate="yes" xml:space="preserve">
          <source>Secret URLs (public &lt;a href=&quot;https://en.wikipedia.org/wiki/Uniform_Resource_Locator&quot;&gt;URL&lt;/a&gt; protected by digest)</source>
          <target state="translated">シークレットURL（ダイジェストで保護されたパブリック&lt;a href=&quot;https://en.wikipedia.org/wiki/Uniform_Resource_Locator&quot;&gt;URL&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="77f6e374d07021931c1f95ca6fd95d57bd175cf9" translate="yes" xml:space="preserve">
          <source>Security questions</source>
          <target state="translated">セキュリティに関する質問</target>
        </trans-unit>
        <trans-unit id="f96888df9de73f78978c270b888a8ed379132818" translate="yes" xml:space="preserve">
          <source>Security questions are insecure - avoid using them. Why? Anything a security question does, a password does better. Read &lt;strong&gt;&lt;em&gt;PART III: Using Secret Questions&lt;/em&gt;&lt;/strong&gt; in &lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;@Jens Roland answer&lt;/a&gt; here in this wiki.</source>
          <target state="translated">セキュリティの質問は安全ではありません-使用しないでください。 どうして？ セキュリティの質問が行うことは何でも、パスワードの方が優れています。 このWikiの&lt;strong&gt;&lt;em&gt;パートIII：&lt;/em&gt;&lt;/strong&gt; &lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;@Jens Rolandで&lt;/a&gt; &lt;strong&gt;&lt;em&gt;秘密の質問を使用する&lt;/em&gt;&lt;/strong&gt;を読んでください。</target>
        </trans-unit>
        <trans-unit id="2b50787548079d4d7d7960927c4abf6a9dbcfb40" translate="yes" xml:space="preserve">
          <source>Sending credentials</source>
          <target state="translated">証明書の送信</target>
        </trans-unit>
        <trans-unit id="2e2996d4874beab228575a84252d47ac06b477f1" translate="yes" xml:space="preserve">
          <source>Service Providers may, of course, offer this protocol as an option in addition to any other method(s) of authentication they might wish to offer.</source>
          <target state="translated">サービスプロバイダは、もちろん、このプロトコルを、提供を希望する他の認証方法に加えてオプションとして提供することができます。</target>
        </trans-unit>
        <trans-unit id="a5de7556cf7bd4f9692d5121762b926c377ffd0d" translate="yes" xml:space="preserve">
          <source>Session cookies</source>
          <target state="translated">セッションクッキー</target>
        </trans-unit>
        <trans-unit id="93696b6328cb310229b7e31a446255308241cbe4" translate="yes" xml:space="preserve">
          <source>Since browsers are implicitly trusted (the whole idea of a User Agent is to act on behalf of the User), they can help improve this situation.</source>
          <target state="translated">ブラウザは暗黙のうちに信頼されているので(ユーザーエージェントはユーザーに代わって行動することを目的としています)、この状況を改善するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="17da9e369068d05b58adc834c73b72fa8baaef08" translate="yes" xml:space="preserve">
          <source>So ...</source>
          <target state="translated">だから...</target>
        </trans-unit>
        <trans-unit id="8dfb410f25bb9c65cce4be237c8e98eed0a7cb91" translate="yes" xml:space="preserve">
          <source>So if you can't store the password, how do you check that the login+password combination POSTed from the login form is correct? The answer is hashing using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Key_derivation_function&quot;&gt;key derivation function&lt;/a&gt;. Whenever a new user is created or a password is changed, you take the password and run it through a KDF, such as Argon2, bcrypt, scrypt or PBKDF2, turning the cleartext password (&quot;correcthorsebatterystaple&quot;) into a long, random-looking string, which is a lot safer to store in your database. To verify a login, you run the same hash function on the entered password, this time passing in the salt and compare the resulting hash string to the value stored in your database. Argon2, bcrypt and scrypt store the salt with the hash already. Check out this &lt;a href=&quot;https://security.stackexchange.com/a/31846/8340&quot;&gt;article&lt;/a&gt; on sec.stackexchange for more detailed information.</source>
          <target state="translated">パスワードを保存できない場合、ログインフォームからPOSTされたログインとパスワードの組み合わせが正しいことをどのように確認しますか？ 答えは、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Key_derivation_function&quot;&gt;鍵導出関数&lt;/a&gt;を使用したハッシュです。 新しいユーザーが作成されるか、パスワードが変更されるたびに、パスワードを取得して、それをArgon2、bcrypt、scrypt、PBKDF2などのKDFで実行し、クリアテキストのパスワード（ &quot;correcthorsebatterystaple&quot;）を長いランダムな文字列に変換します、データベースに保存する方がはるかに安全です。 ログインを確認するには、入力したパスワードに対して同じハッシュ関数を実行します。今回はソルトを渡して、結果のハッシュ文字列をデータベースに保存されている値と比較します。 Argon2、bcrypt、およびscryptはすでにハッシュとともにソルトを格納しています。 詳細&lt;a href=&quot;https://security.stackexchange.com/a/31846/8340&quot;&gt;については&lt;/a&gt; 、sec.stackexchangeに関するこの記事をご覧ください。</target>
        </trans-unit>
        <trans-unit id="9c543295c769b88282780bf3ce124008f98174f5" translate="yes" xml:space="preserve">
          <source>So what can we learn from these numbers? Well, lots, but we can focus on the most important part: the fact that preventing large numbers of rapid-fire successive login attempts (ie. the &lt;em&gt;brute force&lt;/em&gt; attack) really isn't that difficult. But preventing it &lt;em&gt;right&lt;/em&gt; isn't as easy as it seems.</source>
          <target state="translated">では、これらの数値から何を学ぶことができるでしょうか？ ええ、たくさんありますが、最も重要な部分に焦点を当てることができます。大量の迅速な連続ログイン試行（つまり、 &lt;em&gt;ブルートフォース&lt;/em&gt;攻撃）を防ぐことは実際にはそれほど難しいことではありません。 しかし、それを&lt;em&gt;正しく&lt;/em&gt;防止することは、思ったほど簡単ではありません。</target>
        </trans-unit>
        <trans-unit id="68e69724334b1e16fdb092289aa1cf8d11c40991" translate="yes" xml:space="preserve">
          <source>So: With no minimum password strength requirements, 2% of users use one of the top 20 most common passwords. Meaning: if an attacker gets just 20 attempts, 1 in 50 accounts on your website will be crackable.</source>
          <target state="translated">だから。最低限のパスワード強度の要件がない場合、ユーザーの2%が最も一般的な上位20のパスワードのいずれかを使用しています。つまり、攻撃者がたった20回の攻撃を受けただけで、ウェブサイト上の50のアカウントのうち1つがクラック可能になるということです。</target>
        </trans-unit>
        <trans-unit id="d72444c8feb585090c34a3591bc5ac42a272168f" translate="yes" xml:space="preserve">
          <source>Spacing the login requests for each user account, say, 30 seconds apart, to sneak under the radar</source>
          <target state="translated">各ユーザーアカウントへのログイン要求の間隔を、例えば30秒間隔にして、レーダーを潜り抜けるようにします。</target>
        </trans-unit>
        <trans-unit id="8b54ab058e9d7a5ee0966df2639aa71cbd984855" translate="yes" xml:space="preserve">
          <source>Storing passwords</source>
          <target state="translated">パスワードの保存</target>
        </trans-unit>
        <trans-unit id="75d6fac1e47bc2b7e87cdd0dcf77828ce747bdff" translate="yes" xml:space="preserve">
          <source>Submitting good articles about this subject</source>
          <target state="translated">このテーマについての良い記事を投稿する</target>
        </trans-unit>
        <trans-unit id="075dae39a09962a66fc3b6dcab72dc07fce4b9c3" translate="yes" xml:space="preserve">
          <source>Suggesting subtopics</source>
          <target state="translated">サブトピックの提案</target>
        </trans-unit>
        <trans-unit id="c82008d6dc532dd74a5b27dec8eb806cb6db97e4" translate="yes" xml:space="preserve">
          <source>The Verified Email Protocol was proposed to provide a secure method, based on public key cryptography, for streamlining the process of proving to domain B that you have an account on domain A.</source>
          <target state="translated">Verified Email Protocolは、ドメインAにアカウントを持っていることをドメインBに証明するプロセスを合理化するために、公開鍵暗号に基づいた安全な方法を提供するために提案されました。</target>
        </trans-unit>
        <trans-unit id="873001bc6949e1b1e8ae1950e66e687b66728c5c" translate="yes" xml:space="preserve">
          <source>The definitive guide to form-based website authentication</source>
          <target state="translated">フォームベースのウェブサイト認証の決定版ガイド</target>
        </trans-unit>
        <trans-unit id="2f8b3b0b656f122876b0d5005972fd58779fb004" translate="yes" xml:space="preserve">
          <source>The faster you can create hashes, the faster any brute force checker can work. Slower hashes will therefore slow down brute forcing. A slow hash algorithm will make brute forcing impractical for longer passwords (8 digits +)</source>
          <target state="translated">ハッシュの作成が速ければ速いほど、ブルートフォースチェッカーの動作が速くなります。そのため、ハッシュの速度が遅いとブルートフォースの動作が遅くなります。ハッシュアルゴリズムが遅いと、長いパスワード (8桁以上)の場合には、ブルートフォースは実用的ではありません。</target>
        </trans-unit>
        <trans-unit id="0c1bf73b4546848eba3244b4674b70975415dd39" translate="yes" xml:space="preserve">
          <source>The form &amp;ldquo;account&lt;code&gt;@&lt;/code&gt;domain&amp;rdquo; is concise and supported by a wide range of protocols and URI schemes. Such an identifier is, of course, most universally recognized as an email address.</source>
          <target state="translated">「アカウント &lt;code&gt;@&lt;/code&gt; ドメイン」の形式は簡潔で、幅広いプロトコルとURIスキームでサポートされています。 もちろん、そのような識別子は電子メールアドレスとして最も一般的に認識されています。</target>
        </trans-unit>
        <trans-unit id="39aa11169b685321ba98f52046fe4fdc8e18aa45" translate="yes" xml:space="preserve">
          <source>The hashed password received by the server is &lt;a href=&quot;https://security.stackexchange.com/questions/45254/owasp-recommendation-on-client-side-password-hashing&quot;&gt;less secure&lt;/a&gt; if you don't do additional, redundant work on the server.</source>
          <target state="translated">サーバーで追加の冗長な作業を行わないと、サーバーが受信したハッシュ化されたパスワードの&lt;a href=&quot;https://security.stackexchange.com/questions/45254/owasp-recommendation-on-client-side-password-hashing&quot;&gt;安全性&lt;/a&gt;が低下します。</target>
        </trans-unit>
        <trans-unit id="3b494303db06e8467fef215f068e1ef5ff334216" translate="yes" xml:space="preserve">
          <source>The only practical way to send credentials 100% securely is by using &lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt;. Using JavaScript to hash the password is not safe. Common pitfalls for client-side password hashing:</source>
          <target state="translated">資格情報を100％安全に送信する唯一の実用的な方法は、 &lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt;を使用することです。 JavaScriptを使用してパスワードをハッシュすることは安全ではありません。 クライアント側のパスワードハッシュの一般的な落とし穴：</target>
        </trans-unit>
        <trans-unit id="d5ddceaf2ff3d13b24a879ec3ea4ed76cdfcfd28" translate="yes" xml:space="preserve">
          <source>The primary force holding back progress here is &lt;a href=&quot;http://www.w3.org/2011/identity-ws/papers/idbrowser2011_submission_10.pdf&quot;&gt;deployment deadlock&lt;/a&gt;. Solutions must be decomposed into steps which provide some incremental benefit on their own.</source>
          <target state="translated">ここで進行を遅らせる主な力は、 &lt;a href=&quot;http://www.w3.org/2011/identity-ws/papers/idbrowser2011_submission_10.pdf&quot;&gt;展開のデッドロック&lt;/a&gt;です。 ソリューションは、それ自体でいくつかの段階的な利点を提供するステップに分解する必要があります。</target>
        </trans-unit>
        <trans-unit id="c4641bb1386ab4039d988d9fed3b98531f88c493" translate="yes" xml:space="preserve">
          <source>The problem lies more in account setup than in password checking.</source>
          <target state="translated">問題はパスワードチェックよりもアカウント設定にあります。</target>
        </trans-unit>
        <trans-unit id="30e901319f87b3eb9defafddfce85dc76b0c72c1" translate="yes" xml:space="preserve">
          <source>The reality today is that most websites use form-based authentication</source>
          <target state="translated">現在の現実は、ほとんどのウェブサイトでフォームベースの認証を使用しています。</target>
        </trans-unit>
        <trans-unit id="2d2c5891d4a87869d2517de039d313ea2d260b5b" translate="yes" xml:space="preserve">
          <source>The reason a salt is used is that hashing in itself is not sufficient -- you'll want to add a so-called 'salt' to protect the hash against &lt;a href=&quot;https://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;rainbow tables&lt;/a&gt;. A salt effectively prevents two passwords that exactly match from being stored as the same hash value, preventing the whole database being scanned in one run if an attacker is executing a password guessing attack.</source>
          <target state="translated">ソルトが使用される理由は、ハッシュ自体では不十分なためです。 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;レインボーテーブル&lt;/a&gt;からハッシュを保護するために、いわゆる「ソルト」を追加する必要があります。 ソルトは、完全に一致する2つのパスワードが同じハッシュ値として保存されることを効果的に防ぎ、攻撃者がパスワード推測攻撃を実行している場合に、データベース全体が1回の実行でスキャンされるのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="db6f1f3c4b6cc7ccfb89ce39aa7239fd8fe129e2" translate="yes" xml:space="preserve">
          <source>The simplest decentralized method for expressing an identity that is built into the internet infrastructure is the domain name.</source>
          <target state="translated">インターネットのインフラに組み込まれたアイデンティティを表現するための最もシンプルな分散型の方法がドメイン名です。</target>
        </trans-unit>
        <trans-unit id="5645d99ab2bd1ebc1c21888e2b9d0ac583d105e4" translate="yes" xml:space="preserve">
          <source>The token's value makes no sense to you, &lt;em&gt;but,&lt;/em&gt; should the need arise, &quot;appropriate means exist&quot; by which your website can &quot;[authoritatively] ask someone who knows (LDAP... etc.)&quot; about any &lt;em&gt;and every(!)&lt;/em&gt; question that you may have. In other words, you do &lt;strong&gt;not&lt;/strong&gt; avail yourself of &lt;em&gt;any&lt;/em&gt; &quot;home-grown logic.&quot; Instead, you inquire of The Authority and implicitly trust its verdict.</source>
          <target state="translated">トークンの値はあなたには意味がありません&lt;em&gt;が、&lt;/em&gt;必要に応じて、「適切な手段が存在する」ことで、あなたのウェブサイトは「（権威的に）知っている人に（LDAP ...など）あらゆるものについて尋ねることができます」 &lt;em&gt;（！）&lt;/em&gt;あなたが持っているかもしれない質問。 言い換えれば、「自家製のロジック」を利用すること&lt;strong&gt;は&lt;/strong&gt;できませ&lt;strong&gt;ん&lt;/strong&gt; 。 代わりに、当局に問い合わせ、暗黙のうちにその評決を信頼します。</target>
        </trans-unit>
        <trans-unit id="998a2bb8b6d5ada4705d13a767e1564f7753b72e" translate="yes" xml:space="preserve">
          <source>The trick is to fool a bot into thinking it has to insert data into a required field, that's why I named the input &quot;email&quot;. If you already have a field called email that you're using you should try naming the dummy field something else like &quot;company&quot;, &quot;phone&quot; or &quot;emailaddress&quot;. Just pick something you know you don't need and what sounds like something people would normally find logical to fill in into a web form. Now hide the &lt;code&gt;input&lt;/code&gt; field using CSS or JavaScript/jQuery - whatever fits you best - just &lt;strong&gt;don't&lt;/strong&gt; set the input &lt;code&gt;type&lt;/code&gt; to &lt;code&gt;hidden&lt;/code&gt; or else the bot won't fall for it.</source>
          <target state="translated">トリックは、ボットをだまして、必須フィールドにデータを挿入する必要があると考えさせることです。そのため、私は入力に「メール」という名前を付けました。 使用しているemailというフィールドがすでにある場合は、ダミーフィールドに「company」、「phone」、「emailaddress」などの名前を付けてみてください。 不要だとわかっているものを選んで、Webフォームに入力するのが一般的だと思われるものを選んでください。 次に、CSSまたはJavaScript / jQueryを使用して &lt;code&gt;input&lt;/code&gt; フィールドを非表示にします -最適な方法を選択してください-入力 &lt;code&gt;type&lt;/code&gt; を &lt;code&gt;hidden&lt;/code&gt; 設定&lt;strong&gt;しないでください。そうしない&lt;/strong&gt;と、ボットが入力に失敗しません。</target>
        </trans-unit>
        <trans-unit id="34e257a9ce4c5bd6caca77d9bc6d2b2754dd5b72" translate="yes" xml:space="preserve">
          <source>The true reason why security questions even exist in the wild is that they conveniently save the cost of a few support calls from users who can't access their email to get to a reactivation code. This at the expense of security and Sarah Palin's reputation. Worth it? Probably not.</source>
          <target state="translated">セキュリティの質問が野生でさえ存在する本当の理由は、彼らが再起動コードに到達するために電子メールにアクセスできないユーザーからのいくつかのサポートコールのコストを便利に節約することです。これはセキュリティとサラ・ペイリンの評判を犠牲にしたものです。その価値は?おそらくそうではありません。</target>
        </trans-unit>
        <trans-unit id="1e505b002c5044c3265daeba9329406fa68c57e8" translate="yes" xml:space="preserve">
          <source>The use of two-factor authentication is much more secure than more clever means of password encryption</source>
          <target state="translated">二要素認証の使用は、パスワード暗号化などの巧妙な手段よりもはるかに安全です。</target>
        </trans-unit>
        <trans-unit id="5cdb1655b55ede36b4d163c4d821e27240908a02" translate="yes" xml:space="preserve">
          <source>There's another secure method called &lt;strong&gt;SRP&lt;/strong&gt;, but it's patented (although it is &lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;freely licensed&lt;/a&gt;) and there are few good implementations available.</source>
          <target state="translated">&lt;strong&gt;SRP&lt;/strong&gt;と呼ばれる別の安全な方法がありますが、それは特許を取得しており（ &lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;無料でライセンスさ&lt;/a&gt;れていますが）、優れた実装はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="e77a8bc439bb506043e4f2e70e1106ab5d80d188" translate="yes" xml:space="preserve">
          <source>This &quot;authentication + authorization&quot; service can be provided by several different technologies, such as LDAP &lt;em&gt;(Microsoft OpenDirectory)&lt;/em&gt;, or Kerberos.</source>
          <target state="translated">この「認証+承認」サービスは、LDAP &lt;em&gt;（Microsoft OpenDirectory）&lt;/em&gt;やKerberosなどのいくつかの異なるテクノロジーによって提供できます。</target>
        </trans-unit>
        <trans-unit id="1613367f7592fc39a4fb19d5789345ac911f3f19" translate="yes" xml:space="preserve">
          <source>This avoids any need to have &quot;sessions&quot; or cookies as the browser itself will re-encrypt the communication each time. It is the most &quot;lightweight&quot; development approach.</source>
          <target state="translated">これにより、ブラウザ自体が毎回通信を再暗号化するため、「セッション」やクッキーを持つ必要がなくなります。これは最も「軽量」な開発アプローチです。</target>
        </trans-unit>
        <trans-unit id="2f8c91afeec66bcb11bbf481732a4120d32f6711" translate="yes" xml:space="preserve">
          <source>This final scheme was taken from the OWASP best-practices suggestions (link 1 from the MUST-READ list) and should be considered best practice, even if it is admittedly on the restrictive side.</source>
          <target state="translated">この最終的なスキームは、OWASP のベスト・プラクティスの提案(MUST-READ リストのリンク 1)から取られたもので、たとえそれが制限的な側にあることは認められていても、ベスト・プラクティスと考えられるべきです。</target>
        </trans-unit>
        <trans-unit id="767b6b49b2a806781a3997fcd35e32349fa00635" translate="yes" xml:space="preserve">
          <source>This is not strictly &amp;ldquo;form-based authentication for websites&amp;rdquo;. But it is an effort to transition from the current norm of form-based authentication to something more secure: browser-supported authentication.</source>
          <target state="translated">これは厳密には「ウェブサイトのフォームベースの認証」ではありません。 しかし、これは、フォームベース認証の現在の標準から、より安全なもの、つまりブラウザーでサポートされる認証に移行するための取り組みです。</target>
        </trans-unit>
        <trans-unit id="708c1b02320666c817634aa6a6e7cde2ea43c78c" translate="yes" xml:space="preserve">
          <source>This is the very very hard part. The &lt;em&gt;only&lt;/em&gt; decent solution is a web of trust. For example, you join the hospital as a doctor. You create a web page hosted somewhere with your photo, your passport number, and a public key, and hash them all with the private key. You then visit the hospital and the system administrator looks at your passport, sees if the photo matches you, and then hashes the web page/photo hash with the hospital private key. From now on we can securely exchange keys and tokens. As can anyone who trusts the hospital (there is the secret sauce BTW). The system administrator can also give you an &lt;a href=&quot;http://en.wikipedia.org/wiki/RSA_%28security_firm%29&quot;&gt;RSA&lt;/a&gt; dongle or other two-factor authentication.</source>
          <target state="translated">これは非常に難しい部分です。 &lt;em&gt;唯一の&lt;/em&gt;適切な解決策は、信頼の網です。 たとえば、医師として病院に参加したとします。 写真、パスポート番号、公開鍵をどこかにホストするWebページを作成し、それらすべてを秘密鍵でハッシュします。 次に病院を訪問し、システム管理者がパスポートを見て、写真があなたに一致するかどうかを確認してから、病院の秘密鍵でWebページ/写真のハッシュをハッシュします。 今後は、キーとトークンを安全に交換できます。 病院を信頼する人なら誰でも同じように（秘密のソースBTWがあります）。 システム管理者は、 &lt;a href=&quot;http://en.wikipedia.org/wiki/RSA_%28security_firm%29&quot;&gt;RSA&lt;/a&gt;ドングルまたはその他の2要素認証も提供できます。</target>
        </trans-unit>
        <trans-unit id="9deba28d9534afcb8e520cdc7cf83311773566e5" translate="yes" xml:space="preserve">
          <source>This may finally be common knowledge after all the highly-publicized hacks and user data leaks we've seen in recent years, but it has to be said: Do not store passwords in cleartext in your database. User databases are routinely hacked, leaked or gleaned through SQL injection, and if you are storing raw, plaintext passwords, that is instant game over for your login security.</source>
          <target state="translated">これは、ここ数年のハッキングやユーザーデータの漏洩事件の後、ようやく常識となってきたことかもしれませんが、言わずもがなです。パスワードを平文でデータベースに保存してはいけません。ユーザーデータベースは日常的にハッキングされたり、漏洩したり、SQLインジェクションによって収集されたりしていますが、もしあなたが生の平文のパスワードを保存しているのであれば、あなたのログインセキュリティにとっては即ゲームオーバーです。</target>
        </trans-unit>
        <trans-unit id="e1ced78f2b800be0fb1dd40392fe018c4ecb6faf" translate="yes" xml:space="preserve">
          <source>This means that you can't send the user their forgotten passwords (because you only have the hash). Don't reset the user's password unless you have authenticated the user (users must prove that they are able to read emails sent to the stored (and validated) email address.)</source>
          <target state="translated">つまり、忘れたパスワードをユーザーに送ることはできないということです(ハッシュしか持っていないので)。ユーザーを認証しない限り、ユーザーのパスワードをリセットしないでください(ユーザーは、保存されている(そして認証された)メールアドレスに送信されたメールを読むことができることを証明しなければなりません)。</target>
        </trans-unit>
        <trans-unit id="40c1ddc3ab72f671316ac6d8edab98496078d667" translate="yes" xml:space="preserve">
          <source>Thwarting this requires calculating the entropy of a password and then applying a threshold.  The National Institute of Standards and Technology (NIST) &lt;a href=&quot;https://en.wikipedia.org/wiki/Password_strength#NIST_Special_Publication_800-63&quot;&gt;Special Publication 800-63&lt;/a&gt; has a set of very good suggestions.  That, when combined with a dictionary and keyboard layout analysis (for example, 'qwertyuiop' is a bad password), can &lt;a href=&quot;https://cubicspot.blogspot.com/2012/01/how-to-calculate-password-strength-part.html&quot;&gt;reject 99% of all poorly selected passwords&lt;/a&gt; at a level of 18 bits of entropy.  Simply calculating password strength and &lt;a href=&quot;https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;showing a visual strength meter&lt;/a&gt; to a user is good, but insufficient.  Unless it is enforced, a lot of users will most likely ignore it.</source>
          <target state="translated">これを阻止するには、パスワードのエントロピーを計算してから、しきい値を適用する必要があります。 国立標準技術研究所（NIST）の&lt;a href=&quot;https://en.wikipedia.org/wiki/Password_strength#NIST_Special_Publication_800-63&quot;&gt;特別刊行物800-63に&lt;/a&gt;は、一連の非常に優れた提案があります。 つまり、辞書とキーボードレイアウト分析（たとえば、「qwertyuiop」は&lt;a href=&quot;https://cubicspot.blogspot.com/2012/01/how-to-calculate-password-strength-part.html&quot;&gt;不適切&lt;/a&gt;なパスワードです）と組み合わせると、18ビットのエントロピーレベルで、 不適切に選択されたすべてのパスワードの99％を拒否できます 。 パスワードの強度を計算し&lt;a href=&quot;https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;、視覚的な強度メーター&lt;/a&gt;をユーザーに表示するだけでよいのですが、不十分です。 強制されない限り、多くのユーザーはそれを無視するでしょう。</target>
        </trans-unit>
        <trans-unit id="36f59e7438359f6b6dec486a56fd74055564200a" translate="yes" xml:space="preserve">
          <source>To clarify: The delay is &lt;em&gt;not&lt;/em&gt; a delay before returning the response to the browser. It is more like a timeout or refractory period during which login attempts to a specific account or from a specific IP address will not be accepted or evaluated at all. That is, correct credentials will not return in a successful login, and incorrect credentials will not trigger a delay increase.</source>
          <target state="translated">明確にするために：遅延は、ブラウザーに応答を返す前の遅延ではあり&lt;em&gt;ません&lt;/em&gt; 。 これは、特定のアカウントまたは特定のIPアドレスからのログイン試行がまったく受け入れられないか評価されないタイムアウトまたは不応期に似ています。 つまり、ログインが成功しても正しい認証情報が返されず、誤った認証情報によって遅延の増加が引き起こされることはありません。</target>
        </trans-unit>
        <trans-unit id="d37cb16ef3fef2e7115eaa0053b26dfbe21af32e" translate="yes" xml:space="preserve">
          <source>Too abstract? Let me rephrase:</source>
          <target state="translated">抽象的すぎる?言い直そう</target>
        </trans-unit>
        <trans-unit id="94ed89c349e440a548a29267a028903c24ca14a6" translate="yes" xml:space="preserve">
          <source>Uh huh ... it's &lt;em&gt;quite&lt;/em&gt; a mental-switch from the &quot;wild-and-wooly Internet.&quot;</source>
          <target state="translated">ええと...それは「荒々しいインターネット」からの精神的なスイッチです。</target>
        </trans-unit>
        <trans-unit id="4265473602814216b394ca2290e014784cf52b26" translate="yes" xml:space="preserve">
          <source>Unless the connection is already secure (that is, tunneled through HTTPS using SSL/TLS), your login form values will be sent in cleartext, which allows anyone eavesdropping on the line between browser and web server will be able to read logins as they pass through. This type of wiretapping is done routinely by governments, but in general, we won't address 'owned' wires other than to say this: Just use HTTPS.</source>
          <target state="translated">接続がすでに安全でない限り(つまり、SSLTLS を使用して HTTPS を通過している)、あなたのログインフォームの値はクリアテキストで送信されます。この種の盗聴は政府によって日常的に行われていますが、一般的には、これを言う以外に「所有する」ワイヤーには触れません。HTTPS を使用してください。</target>
        </trans-unit>
        <trans-unit id="fc20528d51ba47e05223bf0a781ff269bf656c20" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://openid.net/connect/&quot;&gt;OpenID Connect&lt;/a&gt; or &lt;a href=&quot;https://kantarainitiative.org/confluence/display/uma/Home&quot;&gt;User-Managed Access&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://openid.net/connect/&quot;&gt;OpenID Connect&lt;/a&gt;または&lt;a href=&quot;https://kantarainitiative.org/confluence/display/uma/Home&quot;&gt;ユーザー管理アクセスを使用し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="569514ecdf06ab5d5875ae06513d8acc92496198" translate="yes" xml:space="preserve">
          <source>Use of &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;nonces&lt;/a&gt; to prevent &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;cross-site request forgeries (CSRF)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;nonce&lt;/a&gt;を使用した&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;クロスサイトリクエストフォージェリ（CSRF）の&lt;/a&gt;防止</target>
        </trans-unit>
        <trans-unit id="5692cfefa5a54d8be531f2dc6d33d0432dc849fe" translate="yes" xml:space="preserve">
          <source>Using secret questions</source>
          <target state="translated">秘密の質問を使って</target>
        </trans-unit>
        <trans-unit id="0082a6cc3e0b2bbeae74eaf89dd9ed0c542121f9" translate="yes" xml:space="preserve">
          <source>Utilize Troy Hunt's &lt;a href=&quot;https://haveibeenpwned.com/API/&quot;&gt;Have I Been Pwned API&lt;/a&gt; to check users passwords against passwords compromised in public data breaches.</source>
          <target state="translated">Troy Huntの&lt;a href=&quot;https://haveibeenpwned.com/API/&quot;&gt;Have I been Pwned API&lt;/a&gt;を利用して、ユーザーのパスワードを、公開データ侵害で侵害されたパスワードと照合します。</target>
        </trans-unit>
        <trans-unit id="5a208e8a90fc7c482e752087202866b98cf9ae23" translate="yes" xml:space="preserve">
          <source>We believe that Stack&amp;nbsp;Overflow should not just be a resource for very specific technical questions, but also for general guidelines on how to solve variations on common problems. &quot;Form based authentication for websites&quot; should be a fine topic for such an experiment.</source>
          <target state="translated">スタックオーバーフローは、非常に具体的な技術的な質問だけでなく、一般的な問題のバリエーションを解決する方法に関する一般的なガイドラインにも役立つはずです。 「Webサイトのフォームベースの認証」は、このような実験に適したトピックです。</target>
        </trans-unit>
        <trans-unit id="27c0e1a0723aceee1fa3a38394e3557605e31eaa" translate="yes" xml:space="preserve">
          <source>We'll assume you already know how to build a login+password HTML form which POSTs the values to a script on the server side for authentication. The sections below will deal with patterns for sound practical auth, and how to avoid the most common security pitfalls.</source>
          <target state="translated">認証のためにサーバ側のスクリプトに値をPOSTするlogin+passwordのHTMLフォームを構築する方法をすでに知っていると仮定します。以下のセクションでは、健全で実用的な認証のためのパターンと、最も一般的なセキュリティの落とし穴を回避する方法を扱います。</target>
        </trans-unit>
        <trans-unit id="dbd15fa92d23c602686ecb421e837fa5c0100a95" translate="yes" xml:space="preserve">
          <source>When a user is dutifully-connected to the aforesaid network, their identity &lt;em&gt;(&quot;authentication&quot;)&lt;/em&gt; is [already ...] &quot;conclusively known,&quot; as is their permission &lt;em&gt;(&quot;authorization&quot;)&lt;/em&gt; to do certain things ... such as ... &quot;to access this website.&quot;</source>
          <target state="translated">ユーザーが前述のネットワークに忠実に接続されている場合、ユーザーのID &lt;em&gt;（「認証」）&lt;/em&gt;は[すでに...]「決定的に知られている」ので、特定のことを実行するためのユーザーの許可&lt;em&gt;（「承認」）&lt;/em&gt;は...などです。 ..「このウェブサイトにアクセスするには」</target>
        </trans-unit>
        <trans-unit id="6b7e7b430708b466db8f5dc96f8c359bf35d1a98" translate="yes" xml:space="preserve">
          <source>When hashing, don't use fast hash algorithms such as MD5 (many hardware implementations exist).  Use something like SHA-512.  For passwords, slower hashes are better.</source>
          <target state="translated">ハッシュ化する際には、MD5 のような高速なハッシュアルゴリズムは使わないようにしましょう (多くのハードウェア実装が存在します)。SHA-512 のようなものを使いましょう。パスワードの場合は、より遅いハッシュの方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="1b1261f95eb01d2a4a663842cd7729c9a950766b" translate="yes" xml:space="preserve">
          <source>When you are validating the form (either client or server side) check if your dummy field has been filled to determine if it was sent by a human or a bot.</source>
          <target state="translated">フォームを検証しているとき(クライアント側またはサーバー側)、ダミーフィールドが埋められているかどうかをチェックして、それが人間によって送信されたものかボットによって送信されたものかを判断してください。</target>
        </trans-unit>
        <trans-unit id="9990351cb6dc5a037c4956e9bc10cae3faf4b145" translate="yes" xml:space="preserve">
          <source>While it is true that hashing the password &lt;em&gt;can be&lt;/em&gt; effective against &lt;strong&gt;password disclosure&lt;/strong&gt;, it is vulnerable to replay attacks, Man-In-The-Middle attacks / hijackings (if an attacker can inject a few bytes into your unsecured HTML page before it reaches your browser, they can simply comment out the hashing in the JavaScript), or brute-force attacks (since you are handing the attacker both username, salt and hashed password).</source>
          <target state="translated">パスワードのハッシュはパスワードの&lt;strong&gt;開示&lt;/strong&gt;に対して効果的である&lt;em&gt;可能&lt;/em&gt;性&lt;em&gt;があることは&lt;/em&gt;事実です&lt;em&gt;が&lt;/em&gt; 、リプレイ攻撃、中間者攻撃/ハイジャックに対して脆弱です（攻撃者がセキュリティで&lt;strong&gt;保護&lt;/strong&gt;されていないHTMLページに数バイトを挿入してから、ブラウザでは、JavaScriptのハッシュをコメント化することができます）、またはブルートフォース攻撃（攻撃者にユーザー名、ソルト、ハッシュされたパスワードの両方を渡しているため）。</target>
        </trans-unit>
        <trans-unit id="3584882b01cd0f3c5269eeae6ec1a2fd214b72e5" translate="yes" xml:space="preserve">
          <source>While this is a noble thought, it is essentially useless (and can be a &lt;a href=&quot;https://stackoverflow.com/questions/1380168/does-it-make-security-sense-to-hash-password-on-client-end&quot;&gt;security flaw&lt;/a&gt;) unless it is combined with one of the above - that is, either securing the line with strong encryption or using a tried-and-tested challenge-response mechanism (if you don't know what that is, just know that it is one of the most difficult to prove, most difficult to design, and most difficult to implement concepts in digital security).</source>
          <target state="translated">これは高貴な考えですが、上記のいずれかと組み合わせない限り、つまり、強力な暗号化で回線をセキュリティで保護するか、実証済みのチャレンジ/レスポンスを使用しない限り、本質的に役に立たない（そして&lt;a href=&quot;https://stackoverflow.com/questions/1380168/does-it-make-security-sense-to-hash-password-on-client-end&quot;&gt;セキュリティ上の欠陥に&lt;/a&gt;なる可能性があります ）メカニズム（それが何であるかわからない場合は、それが証明するのが最も難しく、設計が最も難しく、デジタルセキュリティの概念を実装するのが最も難しいものの1つであることを知っているだけです）。</target>
        </trans-unit>
        <trans-unit id="33e6a957bfa924b65ff628b30fcdd2dbd1ba74b7" translate="yes" xml:space="preserve">
          <source>Wikipedia article on weaknesses of several password hashing schemes.</source>
          <target state="translated">いくつかのパスワードハッシュ化方式の弱点に関するウィキペディアの記事。</target>
        </trans-unit>
        <trans-unit id="8643406d224fa433c9299efb0492bf78e73bb0e0" translate="yes" xml:space="preserve">
          <source>Wikipedia: HTTP cookie</source>
          <target state="translated">ウィキペディア HTTPクッキー</target>
        </trans-unit>
        <trans-unit id="c67b948f981569ab7d4f3ea77c17d7b5eb452012" translate="yes" xml:space="preserve">
          <source>You can also vary this up a little by leaving the dummy field visible but outside the boundaries of the screen, but this is totally up to you.</source>
          <target state="translated">また、ダミーのフィールドを画面の境界線の外側に表示したままにすることで、これを少し変化させることもできますが、これは完全にあなた次第です。</target>
        </trans-unit>
        <trans-unit id="d0abd0a897c5f9b121995cd958577feb15f7b6ac" translate="yes" xml:space="preserve">
          <source>You're Probably Storing Passwords Incorrectly</source>
          <target state="translated">パスワードを誤って保存している可能性が高い</target>
        </trans-unit>
        <trans-unit id="fb7f7c94028fe09a6d2d9b3bf0b8501eb7095619" translate="yes" xml:space="preserve">
          <source>etc.</source>
          <target state="translated">etc.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
