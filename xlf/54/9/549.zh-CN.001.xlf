<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/549">
    <body>
      <group id="549">
        <trans-unit id="69df7b128404cdc2a24c0bfd9cd27a00e203a315" translate="yes" xml:space="preserve">
          <source>&quot;In a &lt;em&gt;corporate,&lt;/em&gt;&lt;strong&gt;intra-&lt;/strong&gt; net setting,&quot; most if not all of the foregoing might not apply!</source>
          <target state="translated">&amp;ldquo;在&lt;em&gt;公司&lt;/em&gt; &lt;strong&gt;内部&lt;/strong&gt;网络环境中&amp;rdquo;，上述所有内容（如果不是全部）可能都不适用！</target>
        </trans-unit>
        <trans-unit id="058f419589e9dd656281d473affa1f7e3ba832f9" translate="yes" xml:space="preserve">
          <source>&quot;Remember me&quot; checkbox</source>
          <target state="translated">&quot;记住我 &quot;复选框</target>
        </trans-unit>
        <trans-unit id="7bfcf80c49fcc34753a9509db01b7f4fad1e8be7" translate="yes" xml:space="preserve">
          <source>1 failed attempt = 5 sec delay</source>
          <target state="translated">1次尝试失败=5秒延迟</target>
        </trans-unit>
        <trans-unit id="4933c9e0a9a55746fe717a260189a4c3b7776226" translate="yes" xml:space="preserve">
          <source>1 failed attempt = no delay</source>
          <target state="translated">1次尝试失败=无延迟</target>
        </trans-unit>
        <trans-unit id="bda7f01ca3465367872dae9f245215d37c7e8f44" translate="yes" xml:space="preserve">
          <source>1-4 failed attempts = no delay</source>
          <target state="translated">1-4次尝试失败=无延迟</target>
        </trans-unit>
        <trans-unit id="935e9ab41e1866d02953c899137cc5bd98598cd6" translate="yes" xml:space="preserve">
          <source>2 failed attempts = 15 sec delay</source>
          <target state="translated">2次尝试失败=15秒延迟</target>
        </trans-unit>
        <trans-unit id="47aec48c770a6e89a9cdc96d4cfc0356ccf62251" translate="yes" xml:space="preserve">
          <source>2 failed attempts = 2 sec delay</source>
          <target state="translated">2次尝试失败=2秒延迟</target>
        </trans-unit>
        <trans-unit id="daa302056ffb870a1635435f22e21ea1dafe9e09" translate="yes" xml:space="preserve">
          <source>21 page academic article with many great tips.</source>
          <target state="translated">21页的学术文章,有很多精彩的技巧。</target>
        </trans-unit>
        <trans-unit id="dd4616a9b5e7761604c57acbe22a9f66ccc224ba" translate="yes" xml:space="preserve">
          <source>3 failed attempts = 4 sec delay</source>
          <target state="translated">3次尝试失败=4秒延迟</target>
        </trans-unit>
        <trans-unit id="a2ab0f46bed565e502c16626cce6aa94ed0265ea" translate="yes" xml:space="preserve">
          <source>3+ failed attempts = 45 sec delay</source>
          <target state="translated">3次以上失败=45秒延迟</target>
        </trans-unit>
        <trans-unit id="5f26327f3b922c025c50d407447c515c8398f853" translate="yes" xml:space="preserve">
          <source>4 failed attempts = 8 sec delay</source>
          <target state="translated">4次尝试失败=8秒延迟</target>
        </trans-unit>
        <trans-unit id="b410d68b441165f7e208e0c3606b2d34caa8f485" translate="yes" xml:space="preserve">
          <source>5 failed attempts = 15-30 min delay</source>
          <target state="translated">5次尝试失败=15-30分钟延迟</target>
        </trans-unit>
        <trans-unit id="89eb27e67e97b23b39627fd0ebb7f6c8ddf3bf1d" translate="yes" xml:space="preserve">
          <source>5 failed attempts = 16 sec delay</source>
          <target state="translated">5次尝试失败=16秒延迟</target>
        </trans-unit>
        <trans-unit id="3fe528174a0b4a8437fd8b6038b509f4f9de6167" translate="yes" xml:space="preserve">
          <source>5+ failed attempts = 20 sec delay</source>
          <target state="translated">5次以上失败=20秒延迟</target>
        </trans-unit>
        <trans-unit id="6921455f96323553f199528f7622f4a3b9a9786f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt; client side - give the clients a public key certificate (support in all major browsers - but raises questions over client machine security).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt;客户端-向客户端提供公共密钥证书（所有主要浏览器均支持-但对客户端计算机的安全性提出了疑问）。</target>
        </trans-unit>
        <trans-unit id="45b4f07c39663a3e6c27f9302d6e20007ce9782d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol&quot;&gt;SRP&lt;/a&gt; - sort of clever password authentication without a trusted third party. But here we are getting into the realms of &quot;it's safer to use two-factor authentication, even if that's costlier&quot;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol&quot;&gt;SRP-&lt;/a&gt;一种巧妙的密码身份验证，无需可信任的第三方。 但是在这里，我们进入了&amp;ldquo;使用双重身份验证的安全性，即使这样更昂贵&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="90f385f4e0a0b7f11399b82fc614984d76a16f3e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Session_hijacking&quot;&gt;Cookies can be hijacked&lt;/a&gt;: they are only as secure as the rest of the client's machine and other communications. They can be read from disk, sniffed in network traffic, lifted by a cross-site scripting attack, phished from a poisoned DNS so the client sends their cookies to the wrong servers. Don't send persistent cookies. Cookies should expire at the end of the client session (browser close or leaving your domain).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Session_hijacking&quot;&gt;Cookie可以被劫持&lt;/a&gt; ：它们仅与客户端计算机其余部分和其他通信一样安全。 可以从磁盘读取它们，嗅探网络流量，并通过跨站点脚本攻击将其清除，从有毒的DNS中捕获信息，以便客户端将其Cookie发送到错误的服务器。 不要发送永久性cookie。 Cookies应该在客户端会话结束时（浏览器关闭或离开您的域）到期。</target>
        </trans-unit>
        <trans-unit id="49f9e15c72f3955bacc5f154f5cca6c87bd5ba73" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt; is meant to thwart one specific category of attack: automated dictionary/brute force trial-and-error with no human operator. There is no doubt that this is a real threat, however, there are ways of dealing with it seamlessly that don't require a CAPTCHA, specifically properly designed server-side login throttling schemes - we'll discuss those later.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt;旨在阻止一种特定的攻击类型：无需人工操作的自动词典/蛮力反复试验。 毫无疑问，这是一个真正的威胁，但是，有许多方法可以无缝处理它，不需要CAPTCHA（经过专门设计的服务器端登录限制方案），我们将在后面讨论。</target>
        </trans-unit>
        <trans-unit id="4a414bc028ed50a0f3218630992fe44aa5dda99f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP Guide To Authentication&lt;/a&gt; / &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP Authentication Cheat Sheet&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP身份验证指南&lt;/a&gt; / &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP身份验证备忘单&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="350279b88821264707fd02b036767898b4c1bda2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://tech.dropbox.com/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;Dropbox Tech Blog &amp;raquo; Blog Archive &amp;raquo; zxcvbn: realistic password strength estimation&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://tech.dropbox.com/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;Dropbox技术博客&amp;raquo;博客存档&amp;raquo;zxcvbn：现实的密码强度估算&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a5383b5bd8ae9fa5958ef40b0e46c085b1e5259" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;As a rule of thumb, however, I would say: the stronger your password policy is, the less you have to bug users with delays. If you require strong (case-sensitive alphanumerics + required numbers and symbols) 9+ character passwords, you could give the users 2-4 non-delayed password attempts before activating the throttling.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;根据经验，我会说：密码策略越强，对用户进行延迟的麻烦就越少。&lt;/em&gt; &lt;em&gt;如果您需要强壮的（区分大小写的字母数字+所需的数字和符号）9个以上的字符密码，则可以在激活限制之前为用户提供2-4次无延迟的密码尝试。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4957adf699c8759c1e40cd9b96d75b27b268fc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;and much more about&lt;/em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Form-based_authentication&quot;&gt;form based authentication&lt;/a&gt;...</source>
          <target state="translated">&lt;em&gt;还有更多关于&lt;/em&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/Form-based_authentication&quot;&gt;基于表单的身份验证&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="fcc4b958071127c62617da40ec128a417501f1df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(Do not) Roll-your-own JavaScript encryption/hashing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;（请勿）自行编写JavaScript加密/哈希&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6dcdf8f937fc5401388255a12713637e49f4722f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice #1:&lt;/strong&gt; A short time delay that increases with the number of failed attempts, like:</source>
          <target state="translated">&lt;strong&gt;最佳实践1：&lt;/strong&gt;尝试失败的次数越短，延迟时间越长，例如：</target>
        </trans-unit>
        <trans-unit id="4359ce5b629b2c1989c0365aa8961ffd79ee0d06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice #2:&lt;/strong&gt; A medium length time delay that goes into effect after N failed attempts, like:</source>
          <target state="translated">&lt;strong&gt;最佳做法2：&lt;/strong&gt;中等长度的时间延迟会在N次失败尝试后生效，例如：</target>
        </trans-unit>
        <trans-unit id="01abe219c5d4dda6367efc589d92ab2506211aad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice #3:&lt;/strong&gt; Combining the two approaches - either a fixed, short time delay that goes into effect after N failed attempts, like:</source>
          <target state="translated">&lt;strong&gt;最佳实践3：&lt;/strong&gt;将两种方法结合使用-固定的短时延，在N次失败尝试后生效，例如：</target>
        </trans-unit>
        <trans-unit id="37c2926d835584f9eabb2cd451babd8b70ad6a67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAPTCHAS against humanity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CAPTCHAS反人类&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="516d16a7e5a12ca5bcd98935577ee8e1d46c30d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't implement 'secret questions'&lt;/strong&gt;. The 'secret questions' feature is a security anti-pattern. Read the paper from link number 4 from the MUST-READ list. You can ask Sarah Palin about that one, after her Yahoo! email account got hacked during a previous presidential campaign because the answer to her security question was... &quot;Wasilla High School&quot;!</source>
          <target state="translated">&lt;strong&gt;不要实施&amp;ldquo;秘密问题&amp;rdquo;&lt;/strong&gt; 。 &amp;ldquo;秘密问题&amp;rdquo;功能是一种安全反模式。 从必读列表中的链接编号4中阅读论文。 您可以在Yahoo!之后询问Sarah Palin的问题。 该电子邮件帐户在上次总统竞选期间遭到黑客入侵，原因是对她的安全问题的答案是&amp;ldquo; Wasilla高中&amp;rdquo;！</target>
        </trans-unit>
        <trans-unit id="ec175f6942cc7b1865ec041ac5613bc9f80c0eef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you DO decide to implement persistent login cookies, this is how you do it:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果您决定实施永久登录cookie，请按以下步骤进行：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="637473bd2adb089039b0c89d6433ba778b84b474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of a bot:&lt;/strong&gt; The bot will see a field whose type is &lt;code&gt;text&lt;/code&gt; and a name &lt;code&gt;email&lt;/code&gt; (or whatever it is you called it) and will logically attempt to fill it with appropriate data. It doesn't care if you styled the input form with some fancy CSS, web-developers do it all the time. Whatever the value in the dummy field is, we don't care as long as it's larger than &lt;code&gt;0&lt;/code&gt; characters.</source>
          <target state="translated">&lt;strong&gt;如果是漫游器：&lt;/strong&gt;漫游器将看到一个类型为 &lt;code&gt;text&lt;/code&gt; 和名称 &lt;code&gt;email&lt;/code&gt; （或您称呼它的名字）的字段，并在逻辑上尝试用适当的数据填充它。 不管您是否使用一些精美的CSS设置输入表单的样式，Web开发人员始终都会这样做。 无论虚拟字段中的值是多少，只要它大于 &lt;code&gt;0&lt;/code&gt; 个字符，我们都不会在乎。</target>
        </trans-unit>
        <trans-unit id="aae812a71f3bb70676afff65f15c280be558f9db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of a human:&lt;/strong&gt;
The user will not see the dummy field (in my case named &quot;email&quot;) and will not attempt to fill it. So the value of the dummy field should still be empty when the form has been sent.</source>
          <target state="translated">&lt;strong&gt;如果是人类：&lt;/strong&gt;用户将不会看到虚拟字段（在我的情况下为&amp;ldquo;电子邮件&amp;rdquo;），也不会尝试填写该字段。 因此，发送表单后，虚拟字段的值仍应为空。</target>
        </trans-unit>
        <trans-unit id="0e6713aeddfc7a12a7fde3f069db7a29490d39d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In conclusion, security questions are inherently insecure in virtually all their forms and variations, and should not be employed in an authentication scheme for any reason.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;总而言之，安全性问题本质上在所有形式和变体上本质上都是不安全的，并且出于任何原因都不应在身份验证方案中使用。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5921de4d57a4fbc23f79b12ad7e9cdeb5fb7c8e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It would, however, take an inordinate amount of time to crack even a 6-character password, &lt;em&gt;if you were limited to one attempt per second!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;但是， &lt;em&gt;如果您每秒只能尝试&lt;/em&gt;一次，则破解6个字符的密码将花费大量时间&lt;em&gt;！&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9fe7f6c15e0366087eea39f6e6266f59f5ea4149" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Locking accounts&lt;/strong&gt; and requiring email verification after N failed attempts (this is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Denial-of-service_attack&quot;&gt;DoS&lt;/a&gt; attack waiting to happen)</source>
          <target state="translated">N次尝试失败后&lt;strong&gt;锁定帐户&lt;/strong&gt;并要求电子邮件验证（这是等待发生的&lt;a href=&quot;https://en.wikipedia.org/wiki/Denial-of-service_attack&quot;&gt;DoS&lt;/a&gt;攻击）</target>
        </trans-unit>
        <trans-unit id="e90850633bfc5febc51640b8ccb1003e1a125b35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Session data - &quot;You are logged in as Spiderman69&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;会话数据-&amp;ldquo;您以Spiderman69登录&amp;rdquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd9c2a725de6be5c8d8a56d77ade192b833ed89e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Storing Passwords / Verifying logins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;存储密码/验证登录名&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bbd3f75083cc61c829eb8133833162ea78ad59c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To HTTPS or not to HTTPS?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;要HTTPS还是不要HTTPS？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aff7d87f4b6a1c8cb8a94e4e8a8d78776ee65e55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Of course this method is not 100% foolproof. Bots can be programmed to ignore input fields with the style &lt;code&gt;display:none&lt;/code&gt; applied to it. You also have to think about people who use some form of auto-completion (like most browsers have built-in!) to auto-fill all form fields for them. They might just as well pick up a dummy field.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ：当然，这种方法不是100％可靠的。 可以对Bot进行编程，使其忽略样式为 &lt;code&gt;display:none&lt;/code&gt; 输入字段：未应用。 您还必须考虑使用某种形式的自动完成功能（例如大多数浏览器都内置了这些功能）来为他们自动填写所有表单字段的人。 他们也可能会选择一个虚拟字段。</target>
        </trans-unit>
        <trans-unit id="5d5d1f9e278d3727050a077840f6bd8ade191eb6" translate="yes" xml:space="preserve">
          <source>A 'standard' secret question like mother's maiden name or favorite pet</source>
          <target state="translated">标准的秘密问题,如母亲的姓氏或最喜欢的宠物等 &quot;标准 &quot;的秘密问题</target>
        </trans-unit>
        <trans-unit id="f64690874d20c3aeaa77943a06ac83d30946406d" translate="yes" xml:space="preserve">
          <source>A big user interface benefit being sought here is the &amp;ldquo;identity selector&amp;rdquo;. When a user visits a site and chooses to authenticate, their browser shows them a selection of email addresses (&amp;ldquo;personal&amp;rdquo;, &amp;ldquo;work&amp;rdquo;, &amp;ldquo;political activism&amp;rdquo;, etc.) they may use to identify themselves to the site.</source>
          <target state="translated">此处寻求的最大的用户界面好处是&amp;ldquo;身份选择器&amp;rdquo;。 当用户访问网站并选择进行身份验证时，他们的浏览器会向他们显示选择的电子邮件地址（&amp;ldquo;个人&amp;rdquo;，&amp;ldquo;工作&amp;rdquo;，&amp;ldquo;政治活动&amp;rdquo;等），以供他们在该网站中使用自己的身份。</target>
        </trans-unit>
        <trans-unit id="20a4741b328cb885ac3f4e272309bb731bd02051" translate="yes" xml:space="preserve">
          <source>A cryptographic hash should not be used for password storage because user-selected passwords are not strong enough (i.e. do not usually contain enough entropy) and a password guessing attack could be completed in a relatively short time by an attacker with access to the hashes. This is why KDFs are used - these effectively &lt;a href=&quot;https://en.wikipedia.org/wiki/Key_stretching&quot;&gt;&quot;stretch the key&quot;&lt;/a&gt;, which means that every password guess an attacker makes causes multiple repetitions of the hash algorithm, for example 10,000 times, which causes the attacker to guess the password 10,000 times slower.</source>
          <target state="translated">密码哈希不能用于密码存储，因为用户选择的密码不够强（即通常不包含足够的熵），并且攻击者可以在较短时间内完成对密码的猜测攻击。 这就是为什么使用KDF的原因-它们有效地&lt;a href=&quot;https://en.wikipedia.org/wiki/Key_stretching&quot;&gt;&amp;ldquo;拉伸了密钥&amp;rdquo;&lt;/a&gt; ，这意味着攻击者猜测的每个密码都会导致哈希算法的多次重复，例如10,000次，这会使攻击者猜测密码的速度慢10,000倍。</target>
        </trans-unit>
        <trans-unit id="7590029be61bfd68fc48f94dac75c5aef9aad07f" translate="yes" xml:space="preserve">
          <source>A final note: always make sure your interface for entering the 'lost password code' is at least as secure as your login form itself, or an attacker will simply use this to gain access instead. Making sure you generate very long 'lost password codes' (for example, 16 case-sensitive alphanumeric characters) is a good start, but consider adding the same throttling scheme that you do for the login form itself.</source>
          <target state="translated">最后注意:确保输入 &quot;丢失密码代码 &quot;的界面至少和登录表单本身一样安全,否则攻击者会用它来获取访问权限。确保您生成非常长的 &quot;丢失密码代码&quot;(例如,16个大小写敏感的字母数字字符)是一个很好的开始,但考虑添加与您的登录表单本身相同的节流方案。</target>
        </trans-unit>
        <trans-unit id="11d28e408d6e08e9bc8b44384de8740b08f464cd" translate="yes" xml:space="preserve">
          <source>A good article about realistic password strength estimation is:</source>
          <target state="translated">关于现实中的密码强度估计的好文章是。</target>
        </trans-unit>
        <trans-unit id="c73360d37de0cecf6fb825c8a88ccb92b682493b" translate="yes" xml:space="preserve">
          <source>A simple piece of trivia that anyone could lift from their blog, LinkedIn profile, or similar</source>
          <target state="translated">一个简单的琐事,任何人都可以从他们的博客、LinkedIn简介或类似的资料中提取出来。</target>
        </trans-unit>
        <trans-unit id="5d9880021de84dd0fea8123c504dd9636c53c978" translate="yes" xml:space="preserve">
          <source>Additionally, it makes sense to do more aggressive throttling on admin accounts, since those are the most attractive entry points</source>
          <target state="translated">此外,对管理员账户进行更积极的节流也是有意义的,因为这些账户是最有吸引力的切入点</target>
        </trans-unit>
        <trans-unit id="d7e5b123cdf543d44b363c873a05a3315621a304" translate="yes" xml:space="preserve">
          <source>After the user logs in, the server sends the user a session cookie. The server can retrieve the username or id from the cookie, but nobody else can generate such a cookie (TODO explain mechanisms).</source>
          <target state="translated">用户登录后,服务器会向用户发送一个会话cookie。服务器可以从cookie中获取用户名或id,但其他人不能生成这样的cookie(TODO解释机制)。</target>
        </trans-unit>
        <trans-unit id="cf64446be670d9f89a6800352ab8de9cc2e9bb10" translate="yes" xml:space="preserve">
          <source>Always hash the lost password code/token in the database. &lt;strong&gt;&lt;em&gt;AGAIN&lt;/em&gt;&lt;/strong&gt;, this code is another example of a Password Equivalent, so it MUST be hashed in case an attacker got their hands on your database. When a lost password code is requested, send the plaintext code to the user's email address, then hash it, save the hash in your database -- and &lt;em&gt;throw away the original&lt;/em&gt;. Just like a password or a persistent login token.</source>
          <target state="translated">始终对数据库中丢失的密码代码/令牌进行哈希处理。 &lt;strong&gt;&lt;em&gt;再次&lt;/em&gt;&lt;/strong&gt; ，此代码是等效密码的另一个示例，因此必须进行哈希处理，以防攻击者使用您的数据库。 当要求输入丢失的密码代码时，请将纯文本代码发送到用户的电子邮件地址，然后对其进行哈希处理，然后将哈希表保存在数据库中，然后&lt;em&gt;丢弃原始&lt;/em&gt;密码。 就像密码或永久登录令牌一样。</target>
        </trans-unit>
        <trans-unit id="f8fa1c13ce1fcf0e5a7c7b34d06206e4a19a7e2d" translate="yes" xml:space="preserve">
          <source>And finally, &lt;strong&gt;login throttling&lt;/strong&gt;: that is, setting a time delay between attempts after N failed attempts (yes, DoS attacks are still possible, but at least they are far less likely and a lot more complicated to pull off).</source>
          <target state="translated">最后， &lt;strong&gt;登录限制&lt;/strong&gt; ：也就是说，在N次失败尝试之后设置两次尝试之间的时间延迟（是的，仍然可能发生DoS攻击，但起跳的可能性要小得多，复杂得多）。</target>
        </trans-unit>
        <trans-unit id="50261011750b3da345a0d096efbd266f05c0265c" translate="yes" xml:space="preserve">
          <source>And for a refreshing take on user-friendliness of high-entropy passwords, Randall Munroe's &lt;a href=&quot;https://xkcd.com/936/&quot;&gt;Password Strength xkcd&lt;/a&gt; is highly recommended.</source>
          <target state="translated">为了使用户更轻松地使用高熵密码，强烈建议使用Randall Munroe的&lt;a href=&quot;https://xkcd.com/936/&quot;&gt;Password Strength xkcd&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="17c338063d0906b9a8c9db49206427ff3518197a" translate="yes" xml:space="preserve">
          <source>And just to reiterate one of the most common pitfalls, &lt;strong&gt;DO NOT STORE THE PERSISTENT LOGIN COOKIE (TOKEN) IN YOUR DATABASE, ONLY A HASH OF IT!&lt;/strong&gt; The login token is Password Equivalent, so if an attacker got their hands on your database, they could use the tokens to log in to any account, just as if they were cleartext login-password combinations. Therefore, use hashing (according to &lt;a href=&quot;https://security.stackexchange.com/a/63438/5002&quot;&gt;https://security.stackexchange.com/a/63438/5002&lt;/a&gt; a weak hash will do just fine for this purpose) when storing persistent login tokens.</source>
          <target state="translated">只是要重申最常见的陷阱之一， &lt;strong&gt;请勿将持久登录的Cookie（令牌）存储在您的数据库中，&lt;/strong&gt;而只是将其&lt;strong&gt;作为哈希！&lt;/strong&gt; 登录令牌等效于密码，因此，如果攻击者将您的手放在数据库上，他们可以使用令牌登录任何帐户，就像它们是明文登录密码组合一样。 因此，在存储持久性登录令牌时，请使用哈希（根据&lt;a href=&quot;https://security.stackexchange.com/a/63438/5002&quot;&gt;https://security.stackexchange.com/a/63438/5002&lt;/a&gt;进行此操作，散列就可以达到此目的）。</target>
        </trans-unit>
        <trans-unit id="72316e90ea3528bdbe9b7197ccebf727fd3c4940" translate="yes" xml:space="preserve">
          <source>Another big user interface benefit being sought as part of this effort is &lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest-Session&quot;&gt;helping the browser know more about the user&amp;rsquo;s session&lt;/a&gt; &amp;ndash; who they&amp;rsquo;re signed in as currently, primarily &amp;ndash; so it may display that in the browser chrome.</source>
          <target state="translated">这项工作的另一个重要目标是&lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest-Session&quot;&gt;帮助浏览器更好地了解用户会话&lt;/a&gt; -主要是他们当前登录的用户 -因此可以在浏览器镶边中显示该用户会话 。</target>
        </trans-unit>
        <trans-unit id="705253cd657208d09c588cee3c6ce2acfa7a6043" translate="yes" xml:space="preserve">
          <source>Another warning about storing passwords in the database.</source>
          <target state="translated">另一个关于在数据库中存储密码的警告。</target>
        </trans-unit>
        <trans-unit id="54b5a6243a4307025588c6723f58ebb3abfde047" translate="yes" xml:space="preserve">
          <source>Any question that is easier to answer than guessing their password. Which, for any decent password, is every question you can imagine</source>
          <target state="translated">任何一个比猜密码更容易回答的问题。对于任何一个像样的密码,就是你能想到的所有问题。</target>
        </trans-unit>
        <trans-unit id="ac85befbefb90c64bf699051a1715be6633e17ed" translate="yes" xml:space="preserve">
          <source>As a second level of expressing identity, each domain manages its own set of accounts.</source>
          <target state="translated">作为身份的第二层表达方式,每个域管理着自己的一套账户。</target>
        </trans-unit>
        <trans-unit id="7fae24196de93a89f7bc9168355345ea97141c87" translate="yes" xml:space="preserve">
          <source>As nothing is more efficient than not doing it at all.</source>
          <target state="translated">因为没有什么比根本不做更有效率的了。</target>
        </trans-unit>
        <trans-unit id="b9a023176b2c76e659482f620b9f75601624a29e" translate="yes" xml:space="preserve">
          <source>Ask YC: Best Practices for User Authentication</source>
          <target state="translated">Ask YC:用户认证的最佳实践</target>
        </trans-unit>
        <trans-unit id="df15f74ac80c8dd3799c1c499d1cc92b7ae3c505" translate="yes" xml:space="preserve">
          <source>Authentication can be completely delegated to a single-sign-on service, where another provider handles collecting credentials. This pushes the problem to a trusted third party. Google and Twitter both provide standards-based SSO services, while Facebook provides a similar proprietary solution.</source>
          <target state="translated">认证可以完全委托给单点登录服务,由另一个提供商处理收集凭证。这就把问题推给了值得信赖的第三方。谷歌和Twitter都提供了基于标准的SSO服务,而Facebook提供了类似的专有解决方案。</target>
        </trans-unit>
        <trans-unit id="f70be28530087a7439a32ae20f152509cc4f41a4" translate="yes" xml:space="preserve">
          <source>Be creative!</source>
          <target state="translated">要有创意!</target>
        </trans-unit>
        <trans-unit id="1de8c9a58ce4eebe00ed4c7a8a4c68f84a6b9ba8" translate="yes" xml:space="preserve">
          <source>Because of the distributed nature of this system, it avoids lock-in to major sites like Facebook, Twitter, Google, etc. Any individual can own their own domain and therefore act as their own identity provider.</source>
          <target state="translated">由于该系统的分布式特性,避免了对Facebook、Twitter、Google等大型网站的锁定。任何个人都可以拥有自己的域名,因此可以作为自己的身份提供者。</target>
        </trans-unit>
        <trans-unit id="9f0cb361ff24b04aa6092ff32d4cb6f1c75f9ee1" translate="yes" xml:space="preserve">
          <source>Browser autocompletion of usernames and passwords</source>
          <target state="translated">浏览器自动填写用户名和密码</target>
        </trans-unit>
        <trans-unit id="5172cfd6482bd52a4f6c2f400ad548c6594c7e4b" translate="yes" xml:space="preserve">
          <source>But this is a &lt;em&gt;lot&lt;/em&gt; of a hassle, and not very web 2.0. However, it is the only secure way to create new accounts that have access to valuable information that is not self-created.</source>
          <target state="translated">但这很麻烦，而且不是Web 2.0。 但是，这是创建可以访问非自行创建的有价值信息的新帐户的唯一安全方法。</target>
        </trans-unit>
        <trans-unit id="28c851e3c23baa12d952c7c21330cc5b4915d3fd" translate="yes" xml:space="preserve">
          <source>Checking password strength</source>
          <target state="translated">检查密码强度</target>
        </trans-unit>
        <trans-unit id="2099227ae53d0bb69ac620e426264f3954bf9b76" translate="yes" xml:space="preserve">
          <source>Credentials can be compromised, whether by exploits, passwords being written down and lost, laptops with keys being stolen, or users entering logins into phishing sites.  Logins can be further protected with two-factor authentication, which uses out-of-band factors such as single-use codes received from a phone call, SMS message, app, or dongle. Several providers offer two-factor authentication services.</source>
          <target state="translated">凭证可能会被泄露,无论是通过漏洞、密码被写下并丢失、带钥匙的笔记本电脑被盗,还是用户在钓鱼网站上输入登录信息,都有可能被泄露。登录可以通过双因素认证进一步保护,它使用带外因素,如从电话、短信、应用程序或加密狗收到的一次性使用代码等。一些供应商提供双因素认证服务。</target>
        </trans-unit>
        <trans-unit id="5137f3cf30b10d748e2139da3d3ff6a7f14769cd" translate="yes" xml:space="preserve">
          <source>Definitive Article</source>
          <target state="translated">明确的条款</target>
        </trans-unit>
        <trans-unit id="0852a700c5db81b3b623eebfdac10924f4cb53cc" translate="yes" xml:space="preserve">
          <source>Digest Authentication is a standards-based approach supported in all major browsers and servers, that will not send a password even over a secure channel.</source>
          <target state="translated">Digest认证是一种基于标准的方法,所有主流浏览器和服务器都支持,即使通过安全通道也不会发送密码。</target>
        </trans-unit>
        <trans-unit id="5724bf395ae05f9a76fbdee9b6b10fda30c0d956" translate="yes" xml:space="preserve">
          <source>Discussion about rainbow tables and how to defend against them, and against other threads. Includes extensive discussion.</source>
          <target state="translated">关于彩虹表的讨论,以及如何防守,和其他线程的讨论。包括广泛的讨论。</target>
        </trans-unit>
        <trans-unit id="75200dc7711cafface63f254986b6f2ef192e789" translate="yes" xml:space="preserve">
          <source>Discussion: Coding Horror: You're Probably Storing Passwords Incorrectly</source>
          <target state="translated">讨论。编码恐怖。你可能是在错误地存储密码</target>
        </trans-unit>
        <trans-unit id="9700753881a2fcb4aa5513ef58545733b290ed25" translate="yes" xml:space="preserve">
          <source>Distributing the attempts on a botnet to prevent IP address flagging</source>
          <target state="translated">在僵尸网络上分发防止IP地址标记的企图</target>
        </trans-unit>
        <trans-unit id="ac89eed1b4b4a5aef7852b1e48fc27ff64d4c4f4" translate="yes" xml:space="preserve">
          <source>Do NOT try to implement your own login form or database storage of passwords, unless 
the data being stored is valueless at account creation and self-generated (that is, web 2.0 style like Facebook, &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt;, etc.)</source>
          <target state="translated">不要尝试实施自己的登录表单或密码的数据库存储，除非所存储的数据在创建帐户和自行生成时是无价值的（即，Web 2.0样式，如Facebook， &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt;等）。</target>
        </trans-unit>
        <trans-unit id="b407c4a28fed3e87fb4c9cd858d136f953302fac" translate="yes" xml:space="preserve">
          <source>DoS attacking this final login throttling scheme would be &lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt; impractical. And as a final touch, always allow persistent (cookie) logins (and/or a CAPTCHA-verified login form) to pass through, so legitimate users won't even be delayed &lt;em&gt;while the attack is in progress&lt;/em&gt;. That way, the very impractical DoS attack becomes an &lt;em&gt;extremely&lt;/em&gt; impractical attack.</source>
          <target state="translated">DoS攻击这种最终的登录限制方案将是&lt;strong&gt;&lt;em&gt;非常&lt;/em&gt;&lt;/strong&gt;不切实际的。 最后，始终允许持久（cookie）登录（和/或经过CAPTCHA验证的登录表单）通过，因此&lt;em&gt;在攻击&lt;/em&gt;进行&lt;em&gt;期间&lt;/em&gt; ，合法用户甚至都不会受到延迟。 这样，非常不切实际的DoS攻击就变成了&lt;em&gt;极其&lt;/em&gt;不切实际的攻击。</target>
        </trans-unit>
        <trans-unit id="9e7a3a3d5fd3f56cab117f9ef1747e6b549435b4" translate="yes" xml:space="preserve">
          <source>DoS attacking this scheme would be quite impractical, but certainly doable. Also, it might be relevant to note that such a long delay can be very annoying for a legitimate user. Forgetful users will dislike you.</source>
          <target state="translated">DoS攻击这个计划是相当不切实际的,但肯定是可以做到的。另外,可能需要注意的是,这么长的延迟对于一个合法用户来说是非常烦人的。健忘的用户会不喜欢你。</target>
        </trans-unit>
        <trans-unit id="da0e8494de518dd7e8a6918d639ad934c79f4341" translate="yes" xml:space="preserve">
          <source>DoS attacking this scheme would be very impractical, since the resulting lockout time is slightly larger than the sum of the previous lockout times.</source>
          <target state="translated">DoS攻击这种方案将是非常不切实际的,因为所产生的锁定时间比之前的锁定时间之和略大。</target>
        </trans-unit>
        <trans-unit id="0104c9c8e1e30ebe0dea4b4e83fd6608c1f8882a" translate="yes" xml:space="preserve">
          <source>Don't &lt;em&gt;reset&lt;/em&gt; a forgotten password to an autogenerated strong password - such passwords are notoriously hard to remember, which means the user must either change it or write it down - say, on a bright yellow Post-It on the edge of their monitor. Instead of setting a new password, just let users pick a new one right away - which is what they want to do anyway. (An exception to this might be if the users are universally using a password manager to store/manage passwords that would normally be impossible to remember without writing it down).</source>
          <target state="translated">不要&lt;em&gt;将&lt;/em&gt;忘记的密码重设为自动生成的强密码-众所周知，此类密码很难记住，这意味着用户必须更改密码或将其写下来-例如，在显示器边缘的亮黄色Post-It上。 无需设置新密码，只需让用户立即选择一个新密码即可。 （这可能是一个例外，如果用户普遍使用密码管理器来存储/管理通常不记下来就无法记住的密码）。</target>
        </trans-unit>
        <trans-unit id="2de2a3f83a86845063f5b948c1410f326797445a" translate="yes" xml:space="preserve">
          <source>Don't ever store passwords as plaintext in the database. Not even if you don't care about the security of your own site. Assume that some of your users will reuse the password of their online bank account. So, store the hashed password, and throw away the original. And make sure the password doesn't show up in access logs or application logs. OWASP &lt;a href=&quot;https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet#Impose_infeasible_verification_on_attacker&quot;&gt;recommends the use of Argon2&lt;/a&gt; as your first choice for new applications. If this is not available, PBKDF2 or scrypt should be used instead. And finally if none of the above are available, use bcrypt.</source>
          <target state="translated">永远不要将密码以明文形式存储在数据库中。 即使您不在乎自己网站的安全性，也不会这样做。 假设您的某些用户将重复使用其在线银行帐户的密码。 因此，存储散列密码，然后丢弃原始密码。 并确保密码未显示在访问日志或应用程序日志中。 OWASP &lt;a href=&quot;https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet#Impose_infeasible_verification_on_attacker&quot;&gt;建议将Argon2&lt;/a&gt;用作新应用程序的首选。 如果不可用，则应改用PBKDF2或scrypt。 最后，如果以上都不可用，请使用bcrypt。</target>
        </trans-unit>
        <trans-unit id="0ee655cfc09904ea89a7dd7a61686e2332a87c87" translate="yes" xml:space="preserve">
          <source>Dos and Don&amp;rsquo;ts of Client Authentication on the Web (very readable MIT research paper)</source>
          <target state="translated">Web上客户端身份验证的注意事项（麻省理工学院的研究论文）</target>
        </trans-unit>
        <trans-unit id="a9d3cd24a6e8137771c2eb5231b4292534173c59" translate="yes" xml:space="preserve">
          <source>Dos and Don'ts of Client Authentication on the Web (PDF)</source>
          <target state="translated">客户端网络认证的 &quot;该做的和不该做的&quot;(PDF)</target>
        </trans-unit>
        <trans-unit id="a6df6aab068ddfca1dd445a099c04ab77b30380c" translate="yes" xml:space="preserve">
          <source>E-mail validation</source>
          <target state="translated">电子邮件验证</target>
        </trans-unit>
        <trans-unit id="26a0e3922cf6459a169fb69c5cedf0594a660c30" translate="yes" xml:space="preserve">
          <source>Editing the official answer</source>
          <target state="translated">编辑官方答案</target>
        </trans-unit>
        <trans-unit id="2a5bf7ecd3c3bb79697e4b75902e93bf1d1f63ef" translate="yes" xml:space="preserve">
          <source>Email providers are already the de-facto primary identity providers online. Current password reset flows usually let you take control of an account if you can prove that you control that account&amp;rsquo;s associated email address.</source>
          <target state="translated">电子邮件提供商已经是事实上的在线主要身份提供商。 如果可以证明您控制了该帐户的关联电子邮件地址，那么当前的密码重置流程通常可以让您控制一个帐户。</target>
        </trans-unit>
        <trans-unit id="ca82a8d4544f8e713eb61230c51166734ade8bc0" translate="yes" xml:space="preserve">
          <source>Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes</source>
          <target state="translated">够了,彩虹表。关于安全密码计划,你需要知道的是什么</target>
        </trans-unit>
        <trans-unit id="2c81c599e2b514bdc593f3664a3e0b805bb4f759" translate="yes" xml:space="preserve">
          <source>Even with user-specified questions, it is highly likely that most users will choose either:</source>
          <target state="translated">即使是用户指定的问题,大多数用户也极有可能会选择二者之一。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="94eb0c2edb61f0c161e93c8ae7a3d970650bcabd" translate="yes" xml:space="preserve">
          <source>Financial websites such as banks and credit cards, on the other hand, only have sensitive data and should not allow auto-login or a low-security mode.</source>
          <target state="translated">另一方面,银行、信用卡等金融网站只有敏感数据,不应该允许自动登录,也不应该是低安全模式。</target>
        </trans-unit>
        <trans-unit id="055ea5e2a84b88f78196f3343fc0481996477833" translate="yes" xml:space="preserve">
          <source>First, a strong caveat that this answer is not the best fit for this exact question. It should definitely not be the top answer!</source>
          <target state="translated">首先,强烈警告,这个答案并不是最适合这个问题的准确答案。它绝对不应该是最高的答案!</target>
        </trans-unit>
        <trans-unit id="6f4757517fb79956122368fef702663232eb1875" translate="yes" xml:space="preserve">
          <source>First, have a look at the numbers: &lt;a href=&quot;https://www.lockdown.co.uk/?pg=combi&amp;amp;s=articles&quot;&gt;Password Recovery Speeds - How long will your password stand up&lt;/a&gt;</source>
          <target state="translated">首先，请看一下数字： &lt;a href=&quot;https://www.lockdown.co.uk/?pg=combi&amp;amp;s=articles&quot;&gt;密码恢复速度-您的密码可以使用多长时间&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0009187974f9e3ce61f9861d9dbd0e82cd7d920" translate="yes" xml:space="preserve">
          <source>First, take some time to read &lt;a href=&quot;https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence&quot;&gt;Paragon Initiative's article&lt;/a&gt; on the subject. You'll need to get a bunch of elements right, and the article does a great job of explaining each.</source>
          <target state="translated">首先，花一些时间阅读&lt;a href=&quot;https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence&quot;&gt;Paragon Initiative&lt;/a&gt;关于该主题的文章 。 您需要正确处理一堆元素，并且本文在解释每个元素方面做得很好。</target>
        </trans-unit>
        <trans-unit id="9983f7fe8e0548ed05592e10b4d8737faf0870ba" translate="yes" xml:space="preserve">
          <source>First, we are confusing the initial creation of an account (with a password) with the re-checking of the password subsequently. If I am Flickr and creating your site for the first time, the new user has access to zero value (blank web space). I truly do not care if the person creating the account is lying about their name. If I am creating an account of the hospital intranet/extranet, the value lies in all the medical records, and so I &lt;em&gt;do&lt;/em&gt; care about the identity (*) of the account creator.</source>
          <target state="translated">首先，我们混淆了最初创建帐户（使用密码）与随后重新检查密码的混淆。 如果我是Flickr，并且是第一次创建您的网站，则新用户可以访问零值（空白网站空间）。 我真的不在乎创建帐户的人是否在撒谎。 如果我要创建医院内部网/外部网的帐户，则该值存在于所有医疗记录中，因此，我&lt;em&gt;确实&lt;/em&gt;关心帐户创建者的身份（*）。</target>
        </trans-unit>
        <trans-unit id="43fce5a38d3ccc4394c31ed312d1e3f3bbcdb4f5" translate="yes" xml:space="preserve">
          <source>First, you'll want to read this small article for a reality check: &lt;a href=&quot;http://www.whatsmypass.com/?p=415&quot;&gt;The 500 most common passwords&lt;/a&gt;</source>
          <target state="translated">首先，您需要阅读这篇小文章进行现实检查： &lt;a href=&quot;http://www.whatsmypass.com/?p=415&quot;&gt;500个最常用的密码&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc25ac14ee563260aa5557fc0a6773974bd214de" translate="yes" xml:space="preserve">
          <source>For browsers that don&amp;rsquo;t support the Verified Email Protocol (currently all of them), Mozilla provides a shim which implements the protocol in client-side JavaScript code.</source>
          <target state="translated">对于不支持经过验证的电子邮件协议的浏览器（当前所有浏览器），Mozilla提供了一个垫片，该垫片在客户端JavaScript代码中实现该协议。</target>
        </trans-unit>
        <trans-unit id="a432583ba49ebf5724dd0a7840811c9356950ca3" translate="yes" xml:space="preserve">
          <source>For email services that don&amp;rsquo;t support the Verified Email Protocol, the protocol allows third parties to act as a trusted intermediary, asserting that they&amp;rsquo;ve verified a user&amp;rsquo;s ownership of an account. It is not desirable to have a large number of such third parties; this capability is intended only to allow an upgrade path, and it is much preferred that email services provide these assertions themselves.</source>
          <target state="translated">对于不支持&amp;ldquo;已验证电子邮件协议&amp;rdquo;的电子邮件服务，该协议允许第三方充当受信任的中介，声称他们已经验证了用户对帐户的所有权。 拥有大量这样的第三方是不理想的； 此功能仅旨在允许升级路径，并且电子邮件服务本身最好提供这些声明。</target>
        </trans-unit>
        <trans-unit id="1a29c9f448b4e82925d7464abc91594ed7ceb096" translate="yes" xml:space="preserve">
          <source>Forgotten username/password functionality</source>
          <target state="translated">忘记用户名和密码功能</target>
        </trans-unit>
        <trans-unit id="4c44940eff64d8851ea63a4d7d267c3700ac7b6f" translate="yes" xml:space="preserve">
          <source>Form-based authentication for websites</source>
          <target state="translated">基于表单的网站认证</target>
        </trans-unit>
        <trans-unit id="8c3c600b9979573648ec2a7bc6061a82458b6242" translate="yes" xml:space="preserve">
          <source>Form-based authentication has a big drawback, which is an increased risk of &lt;a href=&quot;http://en.wikipedia.org/wiki/Phishing&quot;&gt;phishing&lt;/a&gt;. Users are asked to enter sensitive information into an area controlled by a remote entity, rather than an area controlled by their User Agent (browser).</source>
          <target state="translated">基于表单的身份验证有一个很大的缺点，那就是&lt;a href=&quot;http://en.wikipedia.org/wiki/Phishing&quot;&gt;网络钓鱼的&lt;/a&gt;风险增加。 要求用户将敏感信息输入由远程实体控制的区域，而不是由其用户代理（浏览器）控制的区域。</target>
        </trans-unit>
        <trans-unit id="0ef26769a71921c31789a2a8774d89fdae723d09" translate="yes" xml:space="preserve">
          <source>Forum discussion about a Coding Horror article.</source>
          <target state="translated">论坛上讨论了一篇《编码恐怖》的文章。</target>
        </trans-unit>
        <trans-unit id="c026b4ef95ca288f3bb81cc79228ab85b91d71b2" translate="yes" xml:space="preserve">
          <source>Forum discussion on the subject</source>
          <target state="translated">关于这个问题的论坛讨论</target>
        </trans-unit>
        <trans-unit id="da292fcb68a4e760db8e5e44afc487fef3ebd153" translate="yes" xml:space="preserve">
          <source>From your point-of-view, you simply know this: that &lt;em&gt;anyone&lt;/em&gt; who legitimately winds-up at your website &lt;em&gt;must&lt;/em&gt; be accompanied by [an environment-variable magically containing ...] a &quot;token.&quot; (&lt;em&gt;i.e.&lt;/em&gt; The absence of such a token must be immediate grounds for &lt;code&gt;404 Not Found&lt;/code&gt;.)</source>
          <target state="translated">从您的角度来看，您仅知道这一点： &lt;em&gt;任何&lt;/em&gt;合法访问您网站的人都&lt;em&gt;必须&lt;/em&gt;附有&amp;ldquo;环境变量，其中包含&amp;hellip;&amp;hellip;&amp;rdquo;。 （ &lt;em&gt;即&lt;/em&gt; ，缺少此类令牌必须是 &lt;code&gt;404 Not Found&lt;/code&gt; 直接依据。）</target>
        </trans-unit>
        <trans-unit id="6711dc17a4ea41f713c35b2df6b7663446e7a514" translate="yes" xml:space="preserve">
          <source>Generally speaking, you have three choices that are all effective against brute-force attacks &lt;em&gt;(and dictionary attacks, but since you are already employing a strong passwords policy, they shouldn't be an issue)&lt;/em&gt;:</source>
          <target state="translated">一般而言，您有三种选择都可以有效抵抗暴力攻击&lt;em&gt;（和字典攻击），但是由于您已经在使用强密码策略，因此这不应该成为问题&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a740b3ba607923f583d5988ec528cdaf1406a543" translate="yes" xml:space="preserve">
          <source>Given the perceived (though now &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;avoidable&lt;/a&gt;) cost and technical difficulty of setting up an SSL certificate on your website, some developers are tempted to roll their own in-browser hashing or encryption schemes in order to avoid passing cleartext logins over an unsecured wire.</source>
          <target state="translated">考虑到在您的网站上设置SSL证书的成本（尽管现在&lt;a href=&quot;https://letsencrypt.org/&quot;&gt;可以避免&lt;/a&gt; ）和技术难度，因此一些开发人员倾向于使用自己的浏览器内哈希或加密方案，以避免在不安全的网络上传递明文登录信息。</target>
        </trans-unit>
        <trans-unit id="40da55bdbda9f92b4cb162d0fa0d30ae87ad8e57" translate="yes" xml:space="preserve">
          <source>HTTP basic authentication</source>
          <target state="translated">HTTP基本认证</target>
        </trans-unit>
        <trans-unit id="a7a3e467744831641be2fe6f9f61a5eb1eab7a0c" translate="yes" xml:space="preserve">
          <source>Hashes by themselves are also insecure. For instance, identical passwords mean identical hashes--this makes hash lookup tables an effective way of cracking lots of passwords at once. Instead, store the &lt;strong&gt;salted&lt;/strong&gt; hash. A salt is a string appended to the password prior to hashing - use a different (random) salt per user. The salt is a public value, so you can store them with the hash in the database. See &lt;a href=&quot;http://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right&quot;&gt;here&lt;/a&gt; for more on this.</source>
          <target state="translated">散列本身也不安全。 例如，相同的密码意味着相同的哈希值-这使哈希查找表成为一次破解大量密码的有效方法。 而是存储&lt;strong&gt;加盐的&lt;/strong&gt;哈希。 盐是哈希之前附加在密码上的字符串-每个用户使用不同的（随机）盐。 salt是一个公共值，因此您可以将它们与哈希一起存储在数据库中。 有关更多信息，请参见&lt;a href=&quot;http://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right&quot;&gt;此处&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd6ee87981c059ffe762f87d9835ba6d3ad5cb0a" translate="yes" xml:space="preserve">
          <source>Here, the best practice would be &lt;strong&gt;logging the number of failed logins, system-wide&lt;/strong&gt;, and using a running average of your site's bad-login frequency as the basis for an upper limit that you then impose on all users.</source>
          <target state="translated">在这里，最佳做法是&lt;strong&gt;记录系统范围内失败登录的次数&lt;/strong&gt; ，并使用站点错误登录频率的运行平均值作为基础，然后对所有用户强加上限。</target>
        </trans-unit>
        <trans-unit id="fd97645c83ca1f0b0cb1e045d47f5c3cb7a28597" translate="yes" xml:space="preserve">
          <source>How to log in</source>
          <target state="translated">如何登录</target>
        </trans-unit>
        <trans-unit id="2e2ac11edd26bbdc67b5b782fb1bfa9b679a85ca" translate="yes" xml:space="preserve">
          <source>How to log out</source>
          <target state="translated">如何登出</target>
        </trans-unit>
        <trans-unit id="b242ffd64cf4e91fee323fe99df436b843031995" translate="yes" xml:space="preserve">
          <source>How to remain logged in</source>
          <target state="translated">如何保持登录</target>
        </trans-unit>
        <trans-unit id="2a1b49d2e2c078dfbf427749a4c26aa10b7064f2" translate="yes" xml:space="preserve">
          <source>How to store passwords</source>
          <target state="translated">如何存储密码</target>
        </trans-unit>
        <trans-unit id="396f12c235f8be0ad58a8e4b445d0acff62942ae" translate="yes" xml:space="preserve">
          <source>However, I do not recommend this, except for public, low-value services. This is an issue with some of the other answers above - do not try an re-implement server-side authentication mechanisms - this problem has been solved and is supported by most major browsers. Do not use cookies. Do not store anything in your own hand-rolled database. Just ask, per request, if the request is authenticated. Everything else should be supported by configuration and third-party trusted software.</source>
          <target state="translated">不过,除了公共的、低价值的服务,我不建议这样做。这是上面的一些其他答案的问题--不要尝试重新实现服务器端认证机制--这个问题已经解决了,而且大多数主流浏览器都支持。不要使用cookies。不要在自己的手游数据库中存储任何东西。只需按请求询问,请求是否通过了验证就可以了。其他的都应该由配置和第三方可信软件支持。</target>
        </trans-unit>
        <trans-unit id="35336df7d00b75c54f5da32119b429c80525c3f8" translate="yes" xml:space="preserve">
          <source>I already mentioned why you should &lt;strong&gt;never use security questions&lt;/strong&gt; for handling forgotten/lost user passwords; it also goes without saying that you should never e-mail users their actual passwords. There are at least two more all-too-common pitfalls to avoid in this field:</source>
          <target state="translated">我已经提到了为什么您不应该&lt;strong&gt;使用安全性问题&lt;/strong&gt;来处理忘记/丢失的用户密码。 不用说，您永远不要通过电子邮件向用户发送其实际密码。 在此字段中，至少还要避免两个非常常见的陷阱：</target>
        </trans-unit>
        <trans-unit id="359c53abe1e06714c19e031a3d67bc68ab3e0368" translate="yes" xml:space="preserve">
          <source>I also posted a question with &lt;a href=&quot;https://stackoverflow.com/questions/479233/what-is-the-best-distributed-brute-force-countermeasure&quot;&gt;more details and a really good discussion of how to avoid tricky pitfals&lt;/a&gt; in fending off distributed brute force attacks</source>
          <target state="translated">我还发布了一个具有&lt;a href=&quot;https://stackoverflow.com/questions/479233/what-is-the-best-distributed-brute-force-countermeasure&quot;&gt;更多细节&lt;/a&gt;的问题， 并就如何避免防御分布式蛮力攻击进行了很好的讨论。</target>
        </trans-unit>
        <trans-unit id="552c8b130191ea16fccf86d6a9186258c92a2d85" translate="yes" xml:space="preserve">
          <source>I believe this can also be used just fine with a login/authentication form.</source>
          <target state="translated">我相信,这也可以用loginauthentication表格来完成。</target>
        </trans-unit>
        <trans-unit id="58d1e47f90e80b52a252896eadaa4328f0a6b31f" translate="yes" xml:space="preserve">
          <source>I call it the &lt;strong&gt;Dummy Field&lt;/strong&gt; (though I haven't invented this so don't credit me).</source>
          <target state="translated">我称它为&lt;strong&gt;虚拟字段&lt;/strong&gt; （尽管我还没有发明这个，所以请不要相信我）。</target>
        </trans-unit>
        <trans-unit id="51d616a1c6a5e687603e42051a1947e650345bcd" translate="yes" xml:space="preserve">
          <source>I do not think the above answer is &quot;wrong&quot; but there are large areas of authentication that are not touched upon (or rather the emphasis is on &quot;how to implement cookie sessions&quot;, not on &quot;what options are available and what are the trade-offs&quot;.</source>
          <target state="translated">我不认为上面的答案是 &quot;错误的&quot;,但有很大一部分认证领域没有触及(或者说重点在于 &quot;如何实现cookie会话&quot;,而不是 &quot;有哪些选择,有哪些取舍&quot;。</target>
        </trans-unit>
        <trans-unit id="234454f3c20ac324649e33650f7a78ebefe0cf90" translate="yes" xml:space="preserve">
          <source>I dont't know whether it was best to answer this as an answer or as a comment. I opted for the first option.</source>
          <target state="translated">我不知道是作为回答还是作为评论来回答最好。我选择了第一个选项。</target>
        </trans-unit>
        <trans-unit id="090605f11afa494248191955e5ee70233bd277e2" translate="yes" xml:space="preserve">
          <source>I just thought I'd share this solution that I found to be working just fine.</source>
          <target state="translated">我只是想和大家分享一下这个我发现很好用的解决方案。</target>
        </trans-unit>
        <trans-unit id="846fe96011a7002d9135a22ab8068ef55c9146e6" translate="yes" xml:space="preserve">
          <source>I used this method on a guestbook in combination with &lt;a href=&quot;http://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt;, and I haven't seen a single spam post since. I had used a CAPTCHA-only solution before, but eventually, it resulted in about five spam posts every hour. Adding the dummy field in the form has stopped (at least until now) all the spam from appearing.</source>
          <target state="translated">我在访客留言簿上将此方法与&lt;a href=&quot;http://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt;结合使用，此后我再也没有看到过任何垃圾邮件。 我之前使用的是仅包含验证码的解决方案，但最终，它每小时产生大约5封垃圾邮件。 在表单中添加虚拟字段已停止（至少到现在为止）所有垃圾邮件的出现。</target>
        </trans-unit>
        <trans-unit id="b6d4b92eeb3592863419cde2a6152c7de7c64e87" translate="yes" xml:space="preserve">
          <source>I will go ahead and mention Mozilla&amp;rsquo;s proposed &lt;a href=&quot;https://browserid.org/&quot;&gt;BrowserID&lt;/a&gt; (or perhaps more precisely, the &lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest&quot;&gt;Verified Email Protocol&lt;/a&gt;) in the spirit of finding an upgrade path to better approaches to authentication in the future.</source>
          <target state="translated">我将继续本着寻找将来升级到更好的身份验证方法的精神，提及Mozilla提出的&lt;a href=&quot;https://browserid.org/&quot;&gt;BrowserID&lt;/a&gt; （或更确切地说，是经过&lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest&quot;&gt;验证的电子邮件协议&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bc9c11bf6ed7710b34884d2f00080ae405fc5189" translate="yes" xml:space="preserve">
          <source>I would like to add one very important comment: -</source>
          <target state="translated">我想补充一条非常重要的意见:----</target>
        </trans-unit>
        <trans-unit id="0ca82fef2a32b5097bc2b8a6714ceaa59492e5aa" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;ll summarize it this way:</source>
          <target state="translated">我将以这种方式总结一下：</target>
        </trans-unit>
        <trans-unit id="083a429183d693f1046288e656d2da6a9a2af83c" translate="yes" xml:space="preserve">
          <source>I'd like to add one suggestion I've used, based on defense in depth. You don't need to have the same auth&amp;amp;auth system for admins as regular users. You can have a separate login form on a separate url executing separate code for requests that will grant high privileges. This one can make choices that would be a total pain to regular users. One such that I've used is to actually scramble the login URL for admin access and email the admin the new URL. Stops any brute force attack right away as your new URL can be arbitrarily difficult (very long random string) but your admin user's only inconvenience is following a link in their email. The attacker no longer knows where to even POST to.</source>
          <target state="translated">基于深度防御，我想添加一个建议。 对于管理员，您不需要具有与普通用户相同的auth＆auth系统。 您可以在单独的url上拥有单独的登录表单，以对授予高特权的请求执行单独的代码。 这可能会给普通用户带来很多痛苦的选择。 我曾经使用过的一种方法是实际上对管理员访问的登录URL进行加密，然后将新URL通过电子邮件发送给管理员。 立即停止任何暴力攻击，因为您的新URL可能非常困难（非常长的随机字符串），但是管理员用户唯一的不便便是关注其电子邮件中的链接。 攻击者甚至不知道发布到哪里。</target>
        </trans-unit>
        <trans-unit id="f7d467c663e66cb7f264b6751a1994846cbe912f" translate="yes" xml:space="preserve">
          <source>If at all possible, make sure the session cookie has the secure and HTTP Only flags set when sent to the browser. The HttpOnly flag provides some protection against the cookie being read through XSS attack. The secure flag ensures that the cookie is only sent back via HTTPS, and therefore protects against network sniffing attacks. The value of the cookie should not be predictable. Where a cookie referencing a non-existent session is presented, its value should be replaced immediately to prevent &lt;a href=&quot;https://www.owasp.org/index.php/Session_fixation&quot;&gt;session fixation&lt;/a&gt;.</source>
          <target state="translated">如果有可能，请确保会话cookie发送到浏览器时已设置了安全和HTTP Only标志。 HttpOnly标志为通过XSS攻击读取cookie提供了一些保护。 安全标志可确保Cookie仅通过HTTPS发送回，因此可以防止网络嗅探攻击。 cookie的值不应是可预测的。 如果提供了引用不存在的会话的cookie，则应立即替换其值以防止&lt;a href=&quot;https://www.owasp.org/index.php/Session_fixation&quot;&gt;会话固定&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="05a40820406ffb4581e8e6750a3ac4b5784853e0" translate="yes" xml:space="preserve">
          <source>If the connection between the client and server is unencrypted, everything you do is &lt;a href=&quot;https://stackoverflow.com/questions/14907581/ssl-and-man-in-the-middle-misunderstanding&quot;&gt;vulnerable to man-in-the-middle attacks&lt;/a&gt;. An attacker could replace the incoming javascript to break the hashing or send all credentials to their server, they could listen to client responses and impersonate the users perfectly, etc. etc. SSL with trusted Certificate Authorities is designed to prevent MitM attacks.</source>
          <target state="translated">如果客户端和服务器之间的连接未加密，则您所做的一切都&lt;a href=&quot;https://stackoverflow.com/questions/14907581/ssl-and-man-in-the-middle-misunderstanding&quot;&gt;容易受到中间人攻击&lt;/a&gt; 。 攻击者可以替换传入的Javascript来破坏哈希或将所有凭据发送到其服务器，他们可以侦听客户端的响应并完美地模拟用户，等等。等等。具有受信任证书颁发机构的SSL旨在防止MitM攻击。</target>
        </trans-unit>
        <trans-unit id="a005965818e2683004bec583de84ca2d5c7d5f8f" translate="yes" xml:space="preserve">
          <source>If you are unfamiliar with session data, here's how it works: A single randomly-generated string is stored in an expiring cookie and used to reference a collection of data - the session data - which is stored on the server. If you are using an MVC framework, this is undoubtedly handled already.</source>
          <target state="translated">如果你不熟悉会话数据,下面是它的工作原理。一个单独的随机生成的字符串被存储在一个过期的cookie中,并用于引用一个数据集合--会话数据--存储在服务器上。如果你使用的是MVC框架,无疑已经处理好了。</target>
        </trans-unit>
        <trans-unit id="9bf51661f29e2e2b97a777af17d93aa3c2ad75df" translate="yes" xml:space="preserve">
          <source>If you don't have the time to look through the tables in that link, here's the list of them:</source>
          <target state="translated">如果你没有时间去翻看那个链接里的表格,下面是他们的列表。</target>
        </trans-unit>
        <trans-unit id="a9f82947c6f8dcc354957eb7fe3f008ee9248d9d" translate="yes" xml:space="preserve">
          <source>If you want to autologin your users, you can set a persistent cookie, but it should be distinct from a full-session cookie. You can set an additional flag that the user has auto-logged in, and needs to log in for real for sensitive operations. This is popular with shopping sites that want to provide you with a seamless, personalized shopping experience but still protect your financial details. For example, when you return to visit Amazon, they show you a page that looks like you're logged in, but when you go to place an order (or change your shipping address, credit card etc.), they ask you to confirm your password.</source>
          <target state="translated">如果你想让用户自动登录,可以设置一个持久性cookie,但它应该和全会话cookie不同。你可以设置一个额外的标志,表示用户已经自动登录,需要真实登录才能进行敏感操作。这在那些希望为你提供无缝、个性化购物体验的购物网站中很受欢迎,但仍能保护你的财务细节。例如,当你返回访问亚马逊时,他们会给你显示一个页面,看起来你已经登录了,但当你去下单时(或更改你的发货地址、信用卡等),他们会要求你确认密码。</target>
        </trans-unit>
        <trans-unit id="2a3aa3e666ad28239fd17e0d9ca973882c20bb50" translate="yes" xml:space="preserve">
          <source>In essence, the only &lt;strong&gt;practical&lt;/strong&gt; way to protect against wiretapping/packet sniffing during login is by using HTTPS or another certificate-based encryption scheme (for example, &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLS&lt;/a&gt;) or a proven &amp;amp; tested challenge-response scheme (for example, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;Diffie-Hellman&lt;/a&gt;-based SRP). &lt;em&gt;Any other method can be easily circumvented&lt;/em&gt; by an eavesdropping attacker.</source>
          <target state="translated">本质上，防止登录期间窃听/数据包嗅探的唯一&lt;strong&gt;实用&lt;/strong&gt;方法是使用HTTPS或其他基于证书的加密方案（例如&lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLS&lt;/a&gt; ）或经过验证的测试挑战响应方案（例如&lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;Diffie-Hellman）&lt;/a&gt;的SRP）。 窃听攻击者&lt;em&gt;可以轻松地绕过任何其他方法&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="2544113bc111cfaa02b8dad7705eb320ec051b0e" translate="yes" xml:space="preserve">
          <source>In short: you just have to insert this into your &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; and check for it to be empty at when validating:</source>
          <target state="translated">简而言之：您只需将其插入到 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 中,并在验证时检查它是否为空：</target>
        </trans-unit>
        <trans-unit id="5889d9ac21ea7878fc3980b6f8fb4739068f29ad" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;Remember your password&lt;/strong&gt; forms, an attacker could potentially check a full list of emails and detect which are registered to the system (see link below).</source>
          <target state="translated">在&amp;ldquo; &lt;strong&gt;记住您的密码&amp;rdquo;&lt;/strong&gt;表格中，攻击者可能检查电子邮件的完整列表，并检测哪些电子邮件已注册到系统（请参阅下面的链接）。</target>
        </trans-unit>
        <trans-unit id="b63daf6854097ee286d453fcdaa4ea9d7d846b17" translate="yes" xml:space="preserve">
          <source>In the end, it's a tradeoff - what is the cost of a security breach vs the cost of implementing more secure approaches. One day, we may see a proper &lt;a href=&quot;http://en.wikipedia.org/wiki/Public-key_infrastructure&quot;&gt;PKI&lt;/a&gt; widely accepted and so no more own rolled authentication forms and databases. One day...</source>
          <target state="translated">最后，这是一个权衡&amp;ndash;安全漏洞的成本与实施更安全方法的成本是什么？ 有一天，我们可能会看到适当的&lt;a href=&quot;http://en.wikipedia.org/wiki/Public-key_infrastructure&quot;&gt;PKI&lt;/a&gt;被广泛接受，因此不再拥有自己的滚动式身份验证表单和数据库。 一天...</target>
        </trans-unit>
        <trans-unit id="0635ff3ae1d3558d900b0d72cf905e6930f16a3d" translate="yes" xml:space="preserve">
          <source>Introductory article about storing passwords</source>
          <target state="translated">关于存储密码的介绍性文章</target>
        </trans-unit>
        <trans-unit id="5e735dc6ff9a579700296dcebbafce05242f5c1e" translate="yes" xml:space="preserve">
          <source>It should include topics such as:</source>
          <target state="translated">它应包括以下主题:</target>
        </trans-unit>
        <trans-unit id="a6420257e778a00afc297ad00fbecf2ebe7c8b6a" translate="yes" xml:space="preserve">
          <source>It should not include things like:</source>
          <target state="translated">它不应该包括这样的事情:</target>
        </trans-unit>
        <trans-unit id="b1ce4421333cb720d377733655d21a7298f4e002" translate="yes" xml:space="preserve">
          <source>It takes &lt;em&gt;virtually no time&lt;/em&gt; to crack a weak password, even if you're cracking it with an abacus</source>
          <target state="translated">&lt;em&gt;几乎不需要时间就&lt;/em&gt;可以破解一个弱密码，即使您使用算盘破解它也是如此。</target>
        </trans-unit>
        <trans-unit id="f95b8ec5420157ff1e1b91b761a8ebd2d92a665b" translate="yes" xml:space="preserve">
          <source>It takes &lt;em&gt;virtually no time&lt;/em&gt; to crack an alphanumeric 9-character password if it is &lt;strong&gt;case insensitive&lt;/strong&gt;</source>
          <target state="translated">如果&lt;strong&gt;不区分大小写&lt;/strong&gt; ，则&lt;em&gt;几乎不需要时间&lt;/em&gt;来破解字母数字的9个字符的密码</target>
        </trans-unit>
        <trans-unit id="2183ae63555a89f9b9da5626b8c677c779b62650" translate="yes" xml:space="preserve">
          <source>It takes &lt;em&gt;virtually no time&lt;/em&gt; to crack an intricate, symbols-and-letters-and-numbers, upper-and-lowercase password if it is &lt;strong&gt;less than 8 characters long&lt;/strong&gt; (a desktop PC can search the entire keyspace up to 7 characters in a matter of days or even hours)</source>
          <target state="translated">如果密码的长度&lt;strong&gt;少于8个字符&lt;/strong&gt; ， &lt;em&gt;几乎不需要&lt;/em&gt;花费&lt;em&gt;任何时间就&lt;/em&gt;可以破解复杂的符号，字母和数字，大写和小写（台式PC可以在一个问题中最多搜索7个字符的整个密钥空间）天甚至几小时）</target>
        </trans-unit>
        <trans-unit id="ca83a47062492ece2469dd660cd19ba05f1e6542" translate="yes" xml:space="preserve">
          <source>Just as an aside, more advanced attackers will try to circumvent login throttling by 'spreading their activities':</source>
          <target state="translated">只是作为一个旁观,更高级的攻击者会通过 &quot;传播他们的活动 &quot;来规避登录节流。</target>
        </trans-unit>
        <trans-unit id="454c33180f12a0ab4b94d928089179f2810d2e55" translate="yes" xml:space="preserve">
          <source>Kerberos and SPNEGO - single sign-on mechanisms with a trusted third party - basically the user verifies against a trusted third party. (NB this is not in any way the not to be trusted &lt;a href=&quot;http://en.wikipedia.org/wiki/OAuth&quot;&gt;OAuth&lt;/a&gt;)</source>
          <target state="translated">Kerberos和SPNEGO-与受信任的第三方的单点登录机制-基本上，用户可以针对受信任的第三方进行验证。 （注意，这绝不是不可信任的&lt;a href=&quot;http://en.wikipedia.org/wiki/OAuth&quot;&gt;OAuth&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="ef605fb60b2983e8337bddb62501975987044821" translate="yes" xml:space="preserve">
          <source>Know that CAPTCHA implementations are not created alike; they often aren't human-solvable, most of them are actually ineffective against bots, all of them are ineffective against cheap third-world labor (according to &lt;a href=&quot;https://en.wikipedia.org/wiki/OWASP&quot;&gt;OWASP&lt;/a&gt;, the current sweatshop rate is $12 per 500 tests), and some implementations may be technically illegal in some countries (see &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP Authentication Cheat Sheet&lt;/a&gt;). If you must use a CAPTCHA, use Google's &lt;a href=&quot;https://en.wikipedia.org/wiki/ReCAPTCHA&quot;&gt;reCAPTCHA&lt;/a&gt;, since it is OCR-hard by definition (since it uses already OCR-misclassified book scans) and tries very hard to be user-friendly.</source>
          <target state="translated">知道CAPTCHA的实现不是完全一样的。 它们通常不是人类可解决的，大多数实际上对机器人无效，对廉价的第三世界劳动力而言它们都无效（根据&lt;a href=&quot;https://en.wikipedia.org/wiki/OWASP&quot;&gt;OWASP&lt;/a&gt; ，当前的血汗工厂价格是每500个测试12美元），某些实现可能是在某些国家/地区在技术上是非法的（请参阅&lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP身份验证备忘单&lt;/a&gt; ）。 如果您必须使用CAPTCHA，请使用Google的&lt;a href=&quot;https://en.wikipedia.org/wiki/ReCAPTCHA&quot;&gt;reCAPTCHA&lt;/a&gt; ，因为从定义上讲它是OCR硬的（因为它使用了已经被OCR错误分类的书本扫描），并且会尽力使用户友好。</target>
        </trans-unit>
        <trans-unit id="a204cab302bc515068a3e7ff919f172312b7a0da" translate="yes" xml:space="preserve">
          <source>List of external resources</source>
          <target state="translated">外部资源清单</target>
        </trans-unit>
        <trans-unit id="800d50f9971121d60ff4213c83ab585dc8eeb2d2" translate="yes" xml:space="preserve">
          <source>MUST-READ LINKS About Web Authentication</source>
          <target state="translated">关于网络认证的必读链接</target>
        </trans-unit>
        <trans-unit id="e39ad0433ee22ae9d29fea44a1452bb36e98f70f" translate="yes" xml:space="preserve">
          <source>Managing cookies (including recommended settings)</source>
          <target state="translated">管理cookies(包括建议的设置</target>
        </trans-unit>
        <trans-unit id="13f082e2a62294764b183257e5521811d1761c76" translate="yes" xml:space="preserve">
          <source>Many corporations deploy &quot;internal use only&quot; websites which are, effectively, &quot;corporate applications&quot; that happen to have been implemented through URLs. These URLs can &lt;em&gt;(supposedly ...)&lt;/em&gt; only be resolved within &quot;the company's internal network.&quot; &lt;em&gt;(Which network magically includes all VPN-connected 'road warriors.')&lt;/em&gt;</source>
          <target state="translated">许多公司部署&amp;ldquo;仅供内部使用&amp;rdquo;的网站，这些网站实际上是恰好通过URL实现的&amp;ldquo;企业应用程序&amp;rdquo;。 这些URL &lt;em&gt;（可能...）&lt;/em&gt;只能在&amp;ldquo;公司的内部网络&amp;rdquo;中解析。 &lt;em&gt;（哪个网络神奇地包含了所有连接VPN的&amp;ldquo;公路战士&amp;rdquo;。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d428631e07ab70149afe871ed89abba6b41c7b09" translate="yes" xml:space="preserve">
          <source>Mozilla is a nonprofit with &lt;a href=&quot;http://www.mozilla.org/about/manifesto.en.html&quot;&gt;values&lt;/a&gt; that align well with finding good solutions to this problem.</source>
          <target state="translated">Mozilla是一家非营利组织，其&lt;a href=&quot;http://www.mozilla.org/about/manifesto.en.html&quot;&gt;价值观&lt;/a&gt;与为该问题找到良好的解决方案非常吻合。</target>
        </trans-unit>
        <trans-unit id="f78a34f17d1960af584815ea7b1a57f63ea0b523" translate="yes" xml:space="preserve">
          <source>Mozilla offers their own service to act like such a trusted third party. Service Providers (that is, Relying Parties) implementing the Verified Email Protocol may choose to trust Mozilla's assertions or not. Mozilla&amp;rsquo;s service verifies users&amp;rsquo; account ownership using the conventional means of sending an email with a confirmation link.</source>
          <target state="translated">Mozilla提供了自己的服务，像这样的受信任的第三方一样工作。 实施&amp;ldquo;已验证电子邮件协议&amp;rdquo;的服务提供商（即依赖方）可以选择是否信任Mozilla的主张。 Mozilla的服务使用传统的发送带有确认链接的电子邮件的方式来验证用户的帐户所有权。</target>
        </trans-unit>
        <trans-unit id="498fc0cb3210a89a93612a59292b4e349dedcfe9" translate="yes" xml:space="preserve">
          <source>My favourite rule in regards to authentication systems: use passphrases, not passwords. Easy to remember, hard to crack.
More info: &lt;a href=&quot;http://www.codinghorror.com/blog/2005/07/passwords-vs-pass-phrases.html&quot;&gt;Coding Horror: Passwords vs. Pass Phrases&lt;/a&gt;</source>
          <target state="translated">关于身份验证系统，我最喜欢的规则是：使用密码短语，而不是密码。 容易记住，难以破解。 更多信息： &lt;a href=&quot;http://www.codinghorror.com/blog/2005/07/passwords-vs-pass-phrases.html&quot;&gt;编码恐怖：密码与密码短语&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46d5ca1861ce7684ad68bb0fececc25f88365029" translate="yes" xml:space="preserve">
          <source>My suggested edits/answers are</source>
          <target state="translated">我的建议修改答案是</target>
        </trans-unit>
        <trans-unit id="a02f8183c755dd3e7c9319a28b14d5b05917066b" translate="yes" xml:space="preserve">
          <source>Never store passwords in a database!</source>
          <target state="translated">切勿将密码存储在数据库中!</target>
        </trans-unit>
        <trans-unit id="c3cad7a29e678534156a1c67fb73684d81f0154f" translate="yes" xml:space="preserve">
          <source>Of course, if you are willing to get a little bit impractical, you could also employ some form of two-factor authentication scheme (e.g. the Google Authenticator app, a physical 'cold war style' codebook, or an RSA key generator dongle). If applied correctly, this could work even with an unsecured connection, but it's hard to imagine that a dev would be willing to implement two-factor auth but not SSL.</source>
          <target state="translated">当然,如果你愿意变得有点不切实际,你也可以采用某种形式的双因素认证方案(例如,Google Authenticator应用,一个物理的 &quot;冷战式 &quot;代码本,或者一个RSA密钥生成器加密狗)。如果应用得当,即使是在无安全连接的情况下,这也是可行的,但很难想象一个开发者会愿意实现双因素认证,而不是SSL。</target>
        </trans-unit>
        <trans-unit id="40746c6aaf7e82f6f6299e3405c2afa45a1ae213" translate="yes" xml:space="preserve">
          <source>Of course, some systems can't afford to have &lt;em&gt;any&lt;/em&gt; accounts hacked; for such systems, there is no way you can justify having persistent logins.</source>
          <target state="translated">当然，某些系统承受不了&lt;em&gt;任何&lt;/em&gt;帐户被黑客入侵的风险。 对于此类系统，您无法证明拥有永久登录名是合理的。</target>
        </trans-unit>
        <trans-unit id="d9bfdd2c36a6c3abb8c87cb643353651b30d90ae" translate="yes" xml:space="preserve">
          <source>Okay, so maybe the list isn't the &lt;em&gt;canonical&lt;/em&gt; list of most common passwords on &lt;em&gt;any&lt;/em&gt; system &lt;em&gt;anywhere ever&lt;/em&gt;, but it's a good indication of how poorly people will choose their passwords when there is no enforced policy in place. Plus, the list looks frighteningly close to home when you compare it to publicly available analyses of recently stolen passwords.</source>
          <target state="translated">好的，所以该列表可能不是&lt;em&gt;任何&lt;/em&gt;系统上&lt;em&gt;任何&lt;/em&gt;系统上最常见密码的&lt;em&gt;规范&lt;/em&gt;列表，但这很好地表明了在没有实施强制策略的情况下人们选择密码的可怜性。 此外，将列表与最近对被盗密码进行公开分析相比，该列表看上去离家很近。</target>
        </trans-unit>
        <trans-unit id="dab5116e744a1fc1ff720960059dcea9695942af" translate="yes" xml:space="preserve">
          <source>Once the server has verified the login and password against your user database and found a match, the system needs a way to remember that the browser has been authenticated. This fact should only ever be stored server side in the session data.</source>
          <target state="translated">一旦服务器根据你的用户数据库验证了登录和密码并找到了匹配的用户,系统需要一个方法来记住浏览器已经通过了验证。这个事实应该只在会话数据中存储在服务器端。</target>
        </trans-unit>
        <trans-unit id="472334b926db37e8b1ba9a091cdc0aa12469e6de" translate="yes" xml:space="preserve">
          <source>OpenID</source>
          <target state="translated">OpenID</target>
        </trans-unit>
        <trans-unit id="43d608c39c9af2e6d0b1f96b90ac641933e3c53f" translate="yes" xml:space="preserve">
          <source>Or, an increasing delay with a fixed upper bound, like:</source>
          <target state="translated">或者说,有一个固定的上界的递增延迟,如。</target>
        </trans-unit>
        <trans-unit id="ee98feac3f48bf9954396afdbaec912b4b30373b" translate="yes" xml:space="preserve">
          <source>PART I: How To Log In</source>
          <target state="translated">第一部分:如何登录</target>
        </trans-unit>
        <trans-unit id="373bd2e0e8256779823fc6ab870ebbbd9fc5217a" translate="yes" xml:space="preserve">
          <source>PART II: How To Remain Logged In - The Infamous &quot;Remember Me&quot; Checkbox</source>
          <target state="translated">第二部分:如何保持登录-臭名昭著的 &quot;记住我 &quot;复选框</target>
        </trans-unit>
        <trans-unit id="8dffe7fbee47b5816874a7c779754cfc07bb7637" translate="yes" xml:space="preserve">
          <source>PART III: Using Secret Questions</source>
          <target state="translated">第三部分:使用秘密问题</target>
        </trans-unit>
        <trans-unit id="8dc18f138173394995a3a25ea9f93f0d9276d9d7" translate="yes" xml:space="preserve">
          <source>PART IV: Forgotten Password Functionality</source>
          <target state="translated">第四部分:忘记密码功能</target>
        </trans-unit>
        <trans-unit id="1bc7c0f4d41ebaa82c69b8f3e030406e7a778c30" translate="yes" xml:space="preserve">
          <source>PART V: Checking Password Strength</source>
          <target state="translated">第五部分:检查密码强度</target>
        </trans-unit>
        <trans-unit id="f78f54dcfe36e53595355daeea59a314d68113c3" translate="yes" xml:space="preserve">
          <source>PART VI: Much More - Or: Preventing Rapid-Fire Login Attempts</source>
          <target state="translated">第六部分:更多----或者说:防止急速登录企图</target>
        </trans-unit>
        <trans-unit id="d09120b5dd85861867d30d321dcb24147dc5181d" translate="yes" xml:space="preserve">
          <source>PART VII: Distributed Brute Force Attacks</source>
          <target state="translated">第七部分:分布式蛮力攻击</target>
        </trans-unit>
        <trans-unit id="3dfbaba91066aa51a3ed68e104660765f9263364" translate="yes" xml:space="preserve">
          <source>PART VIII: Two-Factor Authentication and Authentication Providers</source>
          <target state="translated">第八部分:双因素认证和认证供应商</target>
        </trans-unit>
        <trans-unit id="fca31875c99e7a759095453f43a17f8d41cc70b3" translate="yes" xml:space="preserve">
          <source>Password cracking</source>
          <target state="translated">破解密码</target>
        </trans-unit>
        <trans-unit id="146c22ca524a64487e2cc7bae8bcd42354c41547" translate="yes" xml:space="preserve">
          <source>Persistent Login Cookies (&quot;remember me&quot; functionality) are a danger zone; on the one hand, they are entirely as safe as conventional logins when users understand how to handle them; and on the other hand, they are an enormous security risk in the hands of careless users, who may use them on public computers and forget to log out, and who may not know what browser cookies are or how to delete them.</source>
          <target state="translated">持久性登录Cookies(&quot;记住我 &quot;功能)是一个危险地带,一方面,当用户了解如何处理这些功能时,它们完全可以像传统的登录一样安全;另一方面,在粗心大意的用户手中,它们是一个巨大的安全隐患,他们可能会在公共电脑上使用这些功能而忘记注销,也可能不知道什么是浏览器的Cookies,也不知道如何删除这些功能。</target>
        </trans-unit>
        <trans-unit id="4deb1845003254bce090e7dce697fed2deca1d3f" translate="yes" xml:space="preserve">
          <source>Personal knowledge questions for fallback authentication: Security questions in the era of Facebook (very readable Berkeley research paper)</source>
          <target state="translated">个人知识问题的回退认证的个人知识问题。脸书时代的安全问题(可读性很强的伯克利研究论文</target>
        </trans-unit>
        <trans-unit id="8715dbe3e22e6a227a3a03c6e99bbe78ee4654ac" translate="yes" xml:space="preserve">
          <source>Personally, I like persistent logins for the websites I visit on a regular basis, but I know how to handle them safely. If you are positive that your users know the same, you can use persistent logins with a clean conscience. If not - well, then you may subscribe to the philosophy that users who are careless with their login credentials brought it upon themselves if they get hacked. It's not like we go to our user's houses and tear off all those facepalm-inducing Post-It notes with passwords they have lined up on the edge of their monitors, either.</source>
          <target state="translated">就我个人而言,对于我经常访问的网站,我喜欢持久登录,但我知道如何安全地处理它们。如果你肯定你的用户也知道这个道理,那么你就可以问心无愧地使用持久性登录。如果不是的话--那么你可能会认同这样的理念,那就是那些不小心使用登录凭证的用户如果被黑客入侵,那就是自找的。我们也不会去用户家里撕掉那些写着密码的贴纸条,把他们在显示器边上排成一排的密码都撕掉。</target>
        </trans-unit>
        <trans-unit id="b5bc9ae9abb000e507efbc7f604f75840ed71637" translate="yes" xml:space="preserve">
          <source>Personally, I tend to find CAPTCHAS annoying, and use them only as a last resort when a user has failed to log in a number of times and throttling delays are maxed out. This will happen rarely enough to be acceptable, and it strengthens the system as a whole.</source>
          <target state="translated">就我个人而言,我倾向于觉得CAPTCHAS很烦人,只有在用户多次登录失败,并且节流延迟达到最大限度时才会使用。这种情况很少会发生,足以让人接受,而且它可以加强整个系统的功能。</target>
        </trans-unit>
        <trans-unit id="e87d5138425a2b5a37293950847a50aac1982132" translate="yes" xml:space="preserve">
          <source>Please help us by:</source>
          <target state="translated">请帮助我们:</target>
        </trans-unit>
        <trans-unit id="67d1467cdb0013316748d8f4abc7d3d3ed3d223d" translate="yes" xml:space="preserve">
          <source>Present a &lt;strong&gt;CAPTCHA&lt;/strong&gt; after N failed attempts (annoying as hell and often ineffective -- but I'm repeating myself here)</source>
          <target state="translated">在N次失败尝试后提出&lt;strong&gt;验证码&lt;/strong&gt; （令人讨厌并且经常无效-但我在这里重复我自己）</target>
        </trans-unit>
        <trans-unit id="64a7e99339d587e4be9caac89b32728bfc07f27a" translate="yes" xml:space="preserve">
          <source>Rather than picking one user and trying the 50.000 most common passwords (which they can't, because of our throttling), they will pick THE most common password and try it against 50.000 users instead. That way, not only do they get around maximum-attempts measures like CAPTCHAs and login throttling, their chance of success increases as well, since the number 1 most common password is far more likely than number 49.995</source>
          <target state="translated">与其选择一个用户并尝试50.000个最常用的密码(因为我们的节流措施,他们不能这样做),不如选择一个最常用的密码,然后对着50.000个用户尝试。这样一来,他们不仅可以避开了CAPTCHA和登录节流等最大尝试措施,而且他们的成功几率也会增加,因为最常见的1号密码比49.995号密码更有可能</target>
        </trans-unit>
        <trans-unit id="d13b08c8870d8a1a7e6f0400242c035b1aa248ea" translate="yes" xml:space="preserve">
          <source>Regarding the Forgotten Password Form, I would add that it is a good idea to equal times between successful and unsucessful queries with some delay function.</source>
          <target state="translated">关于遗忘密码表单,我想补充的是,在成功和失败的查询之间,用一些延迟功能来平衡时间是个好主意。</target>
        </trans-unit>
        <trans-unit id="4de0e7b256b6ff9364d661492733a75f01e5a749" translate="yes" xml:space="preserve">
          <source>Regarding the poing &lt;strong&gt;PART IV: Forgotten Password Functionality&lt;/strong&gt; in the first answer, I would make a point about Timing Attacks.</source>
          <target state="translated">关于&lt;strong&gt;第&lt;/strong&gt;一个答案中的&lt;strong&gt;第四部分：忘记密码功能&lt;/strong&gt; ，我将重点介绍定时攻击。</target>
        </trans-unit>
        <trans-unit id="9586ca70862e87cb3f3f00c482403bfa49063bb2" translate="yes" xml:space="preserve">
          <source>Roles and authorization</source>
          <target state="translated">作用和授权</target>
        </trans-unit>
        <trans-unit id="c2f60d05179df3c940cc3e88087d3b1e28775f9d" translate="yes" xml:space="preserve">
          <source>SSL/HTTPS encryption</source>
          <target state="translated">SSLHTTPS加密</target>
        </trans-unit>
        <trans-unit id="cda028908c5cf102590df2f37ad3e49bc40adb5c" translate="yes" xml:space="preserve">
          <source>Say your site has had an average of 120 bad logins per day over the past 3 months. Using that (running average), your system might set the global limit to 3 times that -- ie. 360 failed attempts over a 24 hour period. Then, if the total number of failed attempts across all accounts exceeds that number within one day (or even better, monitor the rate of acceleration and trigger on a calculated threshold), it activates system-wide login throttling - meaning short delays for ALL users (still, with the exception of cookie logins and/or backup CAPTCHA logins).</source>
          <target state="translated">假设你的网站在过去3个月里平均每天有120次错误登录。使用这个数字(运行中的平均数),你的系统可能会将全局限制设置为3倍,即24小时内360次失败尝试。然后,如果一天内所有账户的失败尝试总数超过了这个数字(或者更好的是,监控加速率,并在计算出的阈值上触发),系统就会激活全系统的登录节流--这意味着所有用户都会有短暂的延迟(仍然是cookie登录和备份验证码登录除外)。</target>
        </trans-unit>
        <trans-unit id="976262d7d8f225a98d283e5a7e1b9cb193c18cf0" translate="yes" xml:space="preserve">
          <source>Secret URLs (public &lt;a href=&quot;https://en.wikipedia.org/wiki/Uniform_Resource_Locator&quot;&gt;URL&lt;/a&gt; protected by digest)</source>
          <target state="translated">秘密URL（受摘要保护的公共&lt;a href=&quot;https://en.wikipedia.org/wiki/Uniform_Resource_Locator&quot;&gt;URL&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="77f6e374d07021931c1f95ca6fd95d57bd175cf9" translate="yes" xml:space="preserve">
          <source>Security questions</source>
          <target state="translated">安全问题</target>
        </trans-unit>
        <trans-unit id="f96888df9de73f78978c270b888a8ed379132818" translate="yes" xml:space="preserve">
          <source>Security questions are insecure - avoid using them. Why? Anything a security question does, a password does better. Read &lt;strong&gt;&lt;em&gt;PART III: Using Secret Questions&lt;/em&gt;&lt;/strong&gt; in &lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;@Jens Roland answer&lt;/a&gt; here in this wiki.</source>
          <target state="translated">安全问题是不安全的-避免使用它们。 为什么？ 任何安全问题都可以解决，密码更好。 阅读&lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;@Jens Roland中的&lt;/a&gt; &lt;strong&gt;&lt;em&gt;第III部分：使用秘密问题&lt;/em&gt;&lt;/strong&gt; ，在此Wiki中回答 。</target>
        </trans-unit>
        <trans-unit id="2b50787548079d4d7d7960927c4abf6a9dbcfb40" translate="yes" xml:space="preserve">
          <source>Sending credentials</source>
          <target state="translated">发送全权证书</target>
        </trans-unit>
        <trans-unit id="2e2996d4874beab228575a84252d47ac06b477f1" translate="yes" xml:space="preserve">
          <source>Service Providers may, of course, offer this protocol as an option in addition to any other method(s) of authentication they might wish to offer.</source>
          <target state="translated">当然,除了他们可能希望提供的任何其他认证方法之外,服务提供商还可以提供该协议作为一种选择。</target>
        </trans-unit>
        <trans-unit id="a5de7556cf7bd4f9692d5121762b926c377ffd0d" translate="yes" xml:space="preserve">
          <source>Session cookies</source>
          <target state="translated">会话cookie</target>
        </trans-unit>
        <trans-unit id="93696b6328cb310229b7e31a446255308241cbe4" translate="yes" xml:space="preserve">
          <source>Since browsers are implicitly trusted (the whole idea of a User Agent is to act on behalf of the User), they can help improve this situation.</source>
          <target state="translated">由于浏览器是隐含着信任的(用户代理的整个想法是代表用户行事),所以它们可以帮助改善这种情况。</target>
        </trans-unit>
        <trans-unit id="17da9e369068d05b58adc834c73b72fa8baaef08" translate="yes" xml:space="preserve">
          <source>So ...</source>
          <target state="translated">所以.....</target>
        </trans-unit>
        <trans-unit id="8dfb410f25bb9c65cce4be237c8e98eed0a7cb91" translate="yes" xml:space="preserve">
          <source>So if you can't store the password, how do you check that the login+password combination POSTed from the login form is correct? The answer is hashing using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Key_derivation_function&quot;&gt;key derivation function&lt;/a&gt;. Whenever a new user is created or a password is changed, you take the password and run it through a KDF, such as Argon2, bcrypt, scrypt or PBKDF2, turning the cleartext password (&quot;correcthorsebatterystaple&quot;) into a long, random-looking string, which is a lot safer to store in your database. To verify a login, you run the same hash function on the entered password, this time passing in the salt and compare the resulting hash string to the value stored in your database. Argon2, bcrypt and scrypt store the salt with the hash already. Check out this &lt;a href=&quot;https://security.stackexchange.com/a/31846/8340&quot;&gt;article&lt;/a&gt; on sec.stackexchange for more detailed information.</source>
          <target state="translated">因此，如果您不能存储密码，如何检查从登录表单发布的登录名和密码组合是否正确？ 答案是使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Key_derivation_function&quot;&gt;密钥派生函数进行&lt;/a&gt;哈希处理。 每当创建新用户或更改密码时，您都将获取密码并通过KDF（例如Argon2，bcrypt，scrypt或PBKDF2）运行它，将明文密码（&amp;ldquo; correcthorsebatterystaple&amp;rdquo;）变成长的，随机的字符串，这样可以更安全地存储在数据库中。 要验证登录名，请对输入的密码运行相同的哈希函数，这一次传入了salt并将结果哈希字符串与数据库中存储的值进行比较。 Argon2，bcrypt和scrypt已经将盐与哈希一起存储了。 请查看sec.stackexchange上的&lt;a href=&quot;https://security.stackexchange.com/a/31846/8340&quot;&gt;本文&lt;/a&gt;以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="9c543295c769b88282780bf3ce124008f98174f5" translate="yes" xml:space="preserve">
          <source>So what can we learn from these numbers? Well, lots, but we can focus on the most important part: the fact that preventing large numbers of rapid-fire successive login attempts (ie. the &lt;em&gt;brute force&lt;/em&gt; attack) really isn't that difficult. But preventing it &lt;em&gt;right&lt;/em&gt; isn't as easy as it seems.</source>
          <target state="translated">那么我们可以从这些数字中学到什么呢？ 好了，但有很多，但是我们可以集中在最重要的部分上：防止大量快速连续射击尝试（即&lt;em&gt;强力&lt;/em&gt;攻击）确实并不那么困难。 但是， &lt;em&gt;正确地&lt;/em&gt;阻止它似乎并不容易。</target>
        </trans-unit>
        <trans-unit id="68e69724334b1e16fdb092289aa1cf8d11c40991" translate="yes" xml:space="preserve">
          <source>So: With no minimum password strength requirements, 2% of users use one of the top 20 most common passwords. Meaning: if an attacker gets just 20 attempts, 1 in 50 accounts on your website will be crackable.</source>
          <target state="translated">所以。在没有最低密码强度要求的情况下,2%的用户会使用前20个最常用的密码之一。意味着:如果攻击者只需要20次尝试,你的网站上50个账户中就有1个是可以被破解的。</target>
        </trans-unit>
        <trans-unit id="d72444c8feb585090c34a3591bc5ac42a272168f" translate="yes" xml:space="preserve">
          <source>Spacing the login requests for each user account, say, 30 seconds apart, to sneak under the radar</source>
          <target state="translated">将每个用户账户的登录请求间隔30秒,比如说,间隔30秒,以潜移默化的方式进行登录。</target>
        </trans-unit>
        <trans-unit id="8b54ab058e9d7a5ee0966df2639aa71cbd984855" translate="yes" xml:space="preserve">
          <source>Storing passwords</source>
          <target state="translated">存储密码</target>
        </trans-unit>
        <trans-unit id="75d6fac1e47bc2b7e87cdd0dcf77828ce747bdff" translate="yes" xml:space="preserve">
          <source>Submitting good articles about this subject</source>
          <target state="translated">提交这方面的好文章</target>
        </trans-unit>
        <trans-unit id="075dae39a09962a66fc3b6dcab72dc07fce4b9c3" translate="yes" xml:space="preserve">
          <source>Suggesting subtopics</source>
          <target state="translated">建议分专题</target>
        </trans-unit>
        <trans-unit id="c82008d6dc532dd74a5b27dec8eb806cb6db97e4" translate="yes" xml:space="preserve">
          <source>The Verified Email Protocol was proposed to provide a secure method, based on public key cryptography, for streamlining the process of proving to domain B that you have an account on domain A.</source>
          <target state="translated">验证电子邮件协议的提出,是为了提供一种基于公钥密码学的安全方法,以简化向B域证明你在A域有一个账户的过程。</target>
        </trans-unit>
        <trans-unit id="873001bc6949e1b1e8ae1950e66e687b66728c5c" translate="yes" xml:space="preserve">
          <source>The definitive guide to form-based website authentication</source>
          <target state="translated">基于表单的网站认证的权威指南</target>
        </trans-unit>
        <trans-unit id="2f8b3b0b656f122876b0d5005972fd58779fb004" translate="yes" xml:space="preserve">
          <source>The faster you can create hashes, the faster any brute force checker can work. Slower hashes will therefore slow down brute forcing. A slow hash algorithm will make brute forcing impractical for longer passwords (8 digits +)</source>
          <target state="translated">你创建哈希值的速度越快,任何蛮力检查器的工作速度就越快。因此,较慢的散列算法会减慢粗暴强制的速度。一个较慢的散列算法将使粗暴强制对较长的密码(8位数+)不切实际。</target>
        </trans-unit>
        <trans-unit id="0c1bf73b4546848eba3244b4674b70975415dd39" translate="yes" xml:space="preserve">
          <source>The form &amp;ldquo;account&lt;code&gt;@&lt;/code&gt;domain&amp;rdquo; is concise and supported by a wide range of protocols and URI schemes. Such an identifier is, of course, most universally recognized as an email address.</source>
          <target state="translated">&amp;ldquo;帐户 &lt;code&gt;@&lt;/code&gt; 域&amp;rdquo;的形式简明扼要，并得到各种协议和URI方案的支持。 当然，这种标识符最普遍地被认为是电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="39aa11169b685321ba98f52046fe4fdc8e18aa45" translate="yes" xml:space="preserve">
          <source>The hashed password received by the server is &lt;a href=&quot;https://security.stackexchange.com/questions/45254/owasp-recommendation-on-client-side-password-hashing&quot;&gt;less secure&lt;/a&gt; if you don't do additional, redundant work on the server.</source>
          <target state="translated">如果您不对服务器执行其他多余的工作，则服务器收到的哈希密码&lt;a href=&quot;https://security.stackexchange.com/questions/45254/owasp-recommendation-on-client-side-password-hashing&quot;&gt;不太安全&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b494303db06e8467fef215f068e1ef5ff334216" translate="yes" xml:space="preserve">
          <source>The only practical way to send credentials 100% securely is by using &lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt;. Using JavaScript to hash the password is not safe. Common pitfalls for client-side password hashing:</source>
          <target state="translated">唯一安全地100％发送凭据的实用方法是使用&lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt; 。 使用JavaScript哈希密码是不安全的。 客户端密码哈希的常见陷阱：</target>
        </trans-unit>
        <trans-unit id="d5ddceaf2ff3d13b24a879ec3ea4ed76cdfcfd28" translate="yes" xml:space="preserve">
          <source>The primary force holding back progress here is &lt;a href=&quot;http://www.w3.org/2011/identity-ws/papers/idbrowser2011_submission_10.pdf&quot;&gt;deployment deadlock&lt;/a&gt;. Solutions must be decomposed into steps which provide some incremental benefit on their own.</source>
          <target state="translated">阻碍进展的主要动力是&lt;a href=&quot;http://www.w3.org/2011/identity-ws/papers/idbrowser2011_submission_10.pdf&quot;&gt;部署僵局&lt;/a&gt; 。 解决方案必须分解为可自行提供一些增量收益的步骤。</target>
        </trans-unit>
        <trans-unit id="c4641bb1386ab4039d988d9fed3b98531f88c493" translate="yes" xml:space="preserve">
          <source>The problem lies more in account setup than in password checking.</source>
          <target state="translated">问题更多的是在账户设置上,而不是密码检查上。</target>
        </trans-unit>
        <trans-unit id="30e901319f87b3eb9defafddfce85dc76b0c72c1" translate="yes" xml:space="preserve">
          <source>The reality today is that most websites use form-based authentication</source>
          <target state="translated">现在的现实情况是,大多数网站都使用基于表单的身份认证</target>
        </trans-unit>
        <trans-unit id="2d2c5891d4a87869d2517de039d313ea2d260b5b" translate="yes" xml:space="preserve">
          <source>The reason a salt is used is that hashing in itself is not sufficient -- you'll want to add a so-called 'salt' to protect the hash against &lt;a href=&quot;https://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;rainbow tables&lt;/a&gt;. A salt effectively prevents two passwords that exactly match from being stored as the same hash value, preventing the whole database being scanned in one run if an attacker is executing a password guessing attack.</source>
          <target state="translated">使用盐的原因是散列本身是不够的-您将要添加一个所谓的&amp;ldquo;盐&amp;rdquo;来保护散列免受&lt;a href=&quot;https://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;彩虹表的&lt;/a&gt;侵害。 Salt可以有效地防止将两个完全匹配的密码存储为相同的哈希值，从而防止在攻击者执行密码猜测攻击时一次扫描整个数据库。</target>
        </trans-unit>
        <trans-unit id="db6f1f3c4b6cc7ccfb89ce39aa7239fd8fe129e2" translate="yes" xml:space="preserve">
          <source>The simplest decentralized method for expressing an identity that is built into the internet infrastructure is the domain name.</source>
          <target state="translated">最简单的去中心化表达身份的方法是域名,它内置在互联网基础设施中。</target>
        </trans-unit>
        <trans-unit id="5645d99ab2bd1ebc1c21888e2b9d0ac583d105e4" translate="yes" xml:space="preserve">
          <source>The token's value makes no sense to you, &lt;em&gt;but,&lt;/em&gt; should the need arise, &quot;appropriate means exist&quot; by which your website can &quot;[authoritatively] ask someone who knows (LDAP... etc.)&quot; about any &lt;em&gt;and every(!)&lt;/em&gt; question that you may have. In other words, you do &lt;strong&gt;not&lt;/strong&gt; avail yourself of &lt;em&gt;any&lt;/em&gt; &quot;home-grown logic.&quot; Instead, you inquire of The Authority and implicitly trust its verdict.</source>
          <target state="translated">令牌的值对您没有意义， &lt;em&gt;但是，&lt;/em&gt;如果需要的话，&amp;ldquo;适当的手段存在&amp;rdquo;，您的网站可以通过它&amp;ldquo; [权威性地]向认识（LDAP ...等）的人&amp;rdquo;询问任何&lt;em&gt;和每个（！）。&lt;/em&gt;您可能有的问题。 换句话说，您&lt;strong&gt;不会&lt;/strong&gt;利用&lt;em&gt;任何&lt;/em&gt; &amp;ldquo;本土逻辑&amp;rdquo;。 取而代之的是，您查询&amp;ldquo;权威&amp;rdquo;并暗中信任其裁决。</target>
        </trans-unit>
        <trans-unit id="998a2bb8b6d5ada4705d13a767e1564f7753b72e" translate="yes" xml:space="preserve">
          <source>The trick is to fool a bot into thinking it has to insert data into a required field, that's why I named the input &quot;email&quot;. If you already have a field called email that you're using you should try naming the dummy field something else like &quot;company&quot;, &quot;phone&quot; or &quot;emailaddress&quot;. Just pick something you know you don't need and what sounds like something people would normally find logical to fill in into a web form. Now hide the &lt;code&gt;input&lt;/code&gt; field using CSS or JavaScript/jQuery - whatever fits you best - just &lt;strong&gt;don't&lt;/strong&gt; set the input &lt;code&gt;type&lt;/code&gt; to &lt;code&gt;hidden&lt;/code&gt; or else the bot won't fall for it.</source>
          <target state="translated">诀窍是让机器人认为必须将数据插入必填字段，这就是为什么我将输入命名为&amp;ldquo;电子邮件&amp;rdquo;的原因。 如果您已经使用了一个名为email的字段，则应尝试为该虚拟字段命名，例如&amp;ldquo; company&amp;rdquo;，&amp;ldquo; phone&amp;rdquo;或&amp;ldquo; emailaddress&amp;rdquo;。 只需选择您不需要的东西，听起来人们通常会发现逻辑上可以将其填写到Web表单中。 现在，使用CSS或JavaScript / jQuery（最适合您）隐藏 &lt;code&gt;input&lt;/code&gt; 字段-只是&lt;strong&gt;不要&lt;/strong&gt;将输入 &lt;code&gt;type&lt;/code&gt; 设置为 &lt;code&gt;hidden&lt;/code&gt; ，否则机器人就不会喜欢它。</target>
        </trans-unit>
        <trans-unit id="34e257a9ce4c5bd6caca77d9bc6d2b2754dd5b72" translate="yes" xml:space="preserve">
          <source>The true reason why security questions even exist in the wild is that they conveniently save the cost of a few support calls from users who can't access their email to get to a reactivation code. This at the expense of security and Sarah Palin's reputation. Worth it? Probably not.</source>
          <target state="translated">安全问题甚至在野外存在的真正原因是,他们方便地省去了用户打几个支持电话的成本,因为他们无法访问他们的电子邮件来获取重新激活的代码。这是以牺牲安全问题和萨拉-佩林的声誉为代价。值得吗?可能不值得。</target>
        </trans-unit>
        <trans-unit id="1e505b002c5044c3265daeba9329406fa68c57e8" translate="yes" xml:space="preserve">
          <source>The use of two-factor authentication is much more secure than more clever means of password encryption</source>
          <target state="translated">使用双因素认证比更高明的密码加密手段更安全。</target>
        </trans-unit>
        <trans-unit id="5cdb1655b55ede36b4d163c4d821e27240908a02" translate="yes" xml:space="preserve">
          <source>There's another secure method called &lt;strong&gt;SRP&lt;/strong&gt;, but it's patented (although it is &lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;freely licensed&lt;/a&gt;) and there are few good implementations available.</source>
          <target state="translated">还有另一种称为&lt;strong&gt;SRP&lt;/strong&gt;的安全方法，但该方法已获得专利（尽管它是&lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;免费许可的&lt;/a&gt; ），并且几乎没有好的实现方法。</target>
        </trans-unit>
        <trans-unit id="e77a8bc439bb506043e4f2e70e1106ab5d80d188" translate="yes" xml:space="preserve">
          <source>This &quot;authentication + authorization&quot; service can be provided by several different technologies, such as LDAP &lt;em&gt;(Microsoft OpenDirectory)&lt;/em&gt;, or Kerberos.</source>
          <target state="translated">可以通过几种不同的技术来提供此&amp;ldquo;身份验证+授权&amp;rdquo;服务，例如LDAP &lt;em&gt;（Microsoft OpenDirectory）&lt;/em&gt;或Kerberos。</target>
        </trans-unit>
        <trans-unit id="1613367f7592fc39a4fb19d5789345ac911f3f19" translate="yes" xml:space="preserve">
          <source>This avoids any need to have &quot;sessions&quot; or cookies as the browser itself will re-encrypt the communication each time. It is the most &quot;lightweight&quot; development approach.</source>
          <target state="translated">这就避免了任何需要的 &quot;会话 &quot;或cookie,因为浏览器本身每次都会对通信进行重新加密。这是最 &quot;轻量级 &quot;的开发方式。</target>
        </trans-unit>
        <trans-unit id="2f8c91afeec66bcb11bbf481732a4120d32f6711" translate="yes" xml:space="preserve">
          <source>This final scheme was taken from the OWASP best-practices suggestions (link 1 from the MUST-READ list) and should be considered best practice, even if it is admittedly on the restrictive side.</source>
          <target state="translated">这个最后的方案来自于OWASP的最佳做法建议(MUST-READ清单中的链接1),应该被认为是最佳做法,即使它的限制性很强。</target>
        </trans-unit>
        <trans-unit id="767b6b49b2a806781a3997fcd35e32349fa00635" translate="yes" xml:space="preserve">
          <source>This is not strictly &amp;ldquo;form-based authentication for websites&amp;rdquo;. But it is an effort to transition from the current norm of form-based authentication to something more secure: browser-supported authentication.</source>
          <target state="translated">这并不是严格的&amp;ldquo;网站基于表单的身份验证&amp;rdquo;。 但是，这是从当前基于表单的身份验证规范过渡到更加安全的工作：浏览器支持的身份验证。</target>
        </trans-unit>
        <trans-unit id="708c1b02320666c817634aa6a6e7cde2ea43c78c" translate="yes" xml:space="preserve">
          <source>This is the very very hard part. The &lt;em&gt;only&lt;/em&gt; decent solution is a web of trust. For example, you join the hospital as a doctor. You create a web page hosted somewhere with your photo, your passport number, and a public key, and hash them all with the private key. You then visit the hospital and the system administrator looks at your passport, sees if the photo matches you, and then hashes the web page/photo hash with the hospital private key. From now on we can securely exchange keys and tokens. As can anyone who trusts the hospital (there is the secret sauce BTW). The system administrator can also give you an &lt;a href=&quot;http://en.wikipedia.org/wiki/RSA_%28security_firm%29&quot;&gt;RSA&lt;/a&gt; dongle or other two-factor authentication.</source>
          <target state="translated">这是非常非常困难的部分。 &lt;em&gt;唯一的&lt;/em&gt;体面解决方案是信任网络。 例如，您以医生身份加入医院。 您创建一个网页，其中托管了您的照片，护照号码和公钥，并使用私钥对它们进行了哈希处理。 然后，您访问医院，系统管理员查看您的护照，查看照片是否与您匹配，然后使用医院私钥对网页/照片哈希进行哈希处理。 从现在开始，我们可以安全地交换密钥和令牌。 信任医院的人也可以（有秘密调味品BTW）。 系统管理员还可以为您提供&lt;a href=&quot;http://en.wikipedia.org/wiki/RSA_%28security_firm%29&quot;&gt;RSA&lt;/a&gt;加密狗或其他两因素验证。</target>
        </trans-unit>
        <trans-unit id="9deba28d9534afcb8e520cdc7cf83311773566e5" translate="yes" xml:space="preserve">
          <source>This may finally be common knowledge after all the highly-publicized hacks and user data leaks we've seen in recent years, but it has to be said: Do not store passwords in cleartext in your database. User databases are routinely hacked, leaked or gleaned through SQL injection, and if you are storing raw, plaintext passwords, that is instant game over for your login security.</source>
          <target state="translated">在近几年来我们看到了大量的黑客和用户数据泄露事件之后,这可能终于成为了常识,但不得不说。不要在数据库中以明文存储密码。用户数据库经常会被黑客入侵、泄露或通过SQL注入来获取,如果你存储的是原始的明文密码,那对于你的登录安全来说,那就是瞬间的游戏结束。</target>
        </trans-unit>
        <trans-unit id="e1ced78f2b800be0fb1dd40392fe018c4ecb6faf" translate="yes" xml:space="preserve">
          <source>This means that you can't send the user their forgotten passwords (because you only have the hash). Don't reset the user's password unless you have authenticated the user (users must prove that they are able to read emails sent to the stored (and validated) email address.)</source>
          <target state="translated">这意味着,你不能给用户发送他们忘记的密码(因为你只有散列)。除非你对用户进行了身份验证,否则不要重置用户的密码(用户必须证明他们能够阅读发送到存储的(和验证过的)电子邮件地址的电子邮件)。</target>
        </trans-unit>
        <trans-unit id="40c1ddc3ab72f671316ac6d8edab98496078d667" translate="yes" xml:space="preserve">
          <source>Thwarting this requires calculating the entropy of a password and then applying a threshold.  The National Institute of Standards and Technology (NIST) &lt;a href=&quot;https://en.wikipedia.org/wiki/Password_strength#NIST_Special_Publication_800-63&quot;&gt;Special Publication 800-63&lt;/a&gt; has a set of very good suggestions.  That, when combined with a dictionary and keyboard layout analysis (for example, 'qwertyuiop' is a bad password), can &lt;a href=&quot;https://cubicspot.blogspot.com/2012/01/how-to-calculate-password-strength-part.html&quot;&gt;reject 99% of all poorly selected passwords&lt;/a&gt; at a level of 18 bits of entropy.  Simply calculating password strength and &lt;a href=&quot;https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;showing a visual strength meter&lt;/a&gt; to a user is good, but insufficient.  Unless it is enforced, a lot of users will most likely ignore it.</source>
          <target state="translated">要阻止这种情况，需要计算密码的熵，然后应用阈值。 美国国家标准技术研究院（NIST） &lt;a href=&quot;https://en.wikipedia.org/wiki/Password_strength#NIST_Special_Publication_800-63&quot;&gt;特殊出版物800-63&lt;/a&gt;有一组非常好的建议。 当与字典和键盘布局分析结合使用时（例如，&amp;ldquo; qwertyuiop&amp;rdquo;是错误的密码），可以以18位的熵级别&lt;a href=&quot;https://cubicspot.blogspot.com/2012/01/how-to-calculate-password-strength-part.html&quot;&gt;拒绝所有错误选择的密码的99％&lt;/a&gt; 。 简单地计算密码强度并向用户&lt;a href=&quot;https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;显示视觉强度计&lt;/a&gt;是好的，但还不够。 除非强制执行，否则很多用户很可能会忽略它。</target>
        </trans-unit>
        <trans-unit id="36f59e7438359f6b6dec486a56fd74055564200a" translate="yes" xml:space="preserve">
          <source>To clarify: The delay is &lt;em&gt;not&lt;/em&gt; a delay before returning the response to the browser. It is more like a timeout or refractory period during which login attempts to a specific account or from a specific IP address will not be accepted or evaluated at all. That is, correct credentials will not return in a successful login, and incorrect credentials will not trigger a delay increase.</source>
          <target state="translated">需要说明的是：延迟&lt;em&gt;不是&lt;/em&gt;将响应返回到浏览器之前的延迟。 这更像是超时或不应期，在此期间完全不会接受或评估到特定帐户或特定IP地址的登录尝试。 也就是说，正确的凭据不会在成功登录后返回，并且错误的凭据也不会触发延迟增加。</target>
        </trans-unit>
        <trans-unit id="d37cb16ef3fef2e7115eaa0053b26dfbe21af32e" translate="yes" xml:space="preserve">
          <source>Too abstract? Let me rephrase:</source>
          <target state="translated">太抽象了?让我换个说法。</target>
        </trans-unit>
        <trans-unit id="94ed89c349e440a548a29267a028903c24ca14a6" translate="yes" xml:space="preserve">
          <source>Uh huh ... it's &lt;em&gt;quite&lt;/em&gt; a mental-switch from the &quot;wild-and-wooly Internet.&quot;</source>
          <target state="translated">呃&amp;hellip;&amp;hellip;这是从&amp;ldquo;狂野而喧嚣的互联网&amp;rdquo;转变过来的一种精神上的转变。</target>
        </trans-unit>
        <trans-unit id="4265473602814216b394ca2290e014784cf52b26" translate="yes" xml:space="preserve">
          <source>Unless the connection is already secure (that is, tunneled through HTTPS using SSL/TLS), your login form values will be sent in cleartext, which allows anyone eavesdropping on the line between browser and web server will be able to read logins as they pass through. This type of wiretapping is done routinely by governments, but in general, we won't address 'owned' wires other than to say this: Just use HTTPS.</source>
          <target state="translated">除非连接已经是安全的(也就是通过HTTPS使用SSLTLS进行隧道化),否则你的登录表单值将以透明文本的形式发送,这允许任何人在浏览器和网络服务器之间的线路上窃听,当他们通过时,就能读取登录信息。这种窃听是政府经常做的事情,但一般来说,我们除了这样说之外,不会涉及到 &quot;拥有 &quot;的线,一般来说。只要使用HTTPS就可以了。</target>
        </trans-unit>
        <trans-unit id="fc20528d51ba47e05223bf0a781ff269bf656c20" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://openid.net/connect/&quot;&gt;OpenID Connect&lt;/a&gt; or &lt;a href=&quot;https://kantarainitiative.org/confluence/display/uma/Home&quot;&gt;User-Managed Access&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;http://openid.net/connect/&quot;&gt;OpenID Connect&lt;/a&gt;或&lt;a href=&quot;https://kantarainitiative.org/confluence/display/uma/Home&quot;&gt;用户管理的访问权限&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="569514ecdf06ab5d5875ae06513d8acc92496198" translate="yes" xml:space="preserve">
          <source>Use of &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;nonces&lt;/a&gt; to prevent &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;cross-site request forgeries (CSRF)&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;随机数&lt;/a&gt;来防止&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;跨站点请求伪造（CSRF）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5692cfefa5a54d8be531f2dc6d33d0432dc849fe" translate="yes" xml:space="preserve">
          <source>Using secret questions</source>
          <target state="translated">使用秘密问题</target>
        </trans-unit>
        <trans-unit id="0082a6cc3e0b2bbeae74eaf89dd9ed0c542121f9" translate="yes" xml:space="preserve">
          <source>Utilize Troy Hunt's &lt;a href=&quot;https://haveibeenpwned.com/API/&quot;&gt;Have I Been Pwned API&lt;/a&gt; to check users passwords against passwords compromised in public data breaches.</source>
          <target state="translated">利用Troy Hunt的&lt;a href=&quot;https://haveibeenpwned.com/API/&quot;&gt;&amp;ldquo;我曾经拥有&amp;rdquo; API&lt;/a&gt;来检查用户密码，以防在公共数据泄露中泄露密码。</target>
        </trans-unit>
        <trans-unit id="5a208e8a90fc7c482e752087202866b98cf9ae23" translate="yes" xml:space="preserve">
          <source>We believe that Stack&amp;nbsp;Overflow should not just be a resource for very specific technical questions, but also for general guidelines on how to solve variations on common problems. &quot;Form based authentication for websites&quot; should be a fine topic for such an experiment.</source>
          <target state="translated">我们认为，堆栈溢出不仅应作为解决非常具体的技术问题的资源，而且还应作为解决常见问题的通用准则。 &amp;ldquo;基于表单的网站身份验证&amp;rdquo;应该是此类实验的一个不错的主题。</target>
        </trans-unit>
        <trans-unit id="27c0e1a0723aceee1fa3a38394e3557605e31eaa" translate="yes" xml:space="preserve">
          <source>We'll assume you already know how to build a login+password HTML form which POSTs the values to a script on the server side for authentication. The sections below will deal with patterns for sound practical auth, and how to avoid the most common security pitfalls.</source>
          <target state="translated">我们假设你已经知道如何建立一个登录+密码的HTML表单,将值传递给服务器端的脚本进行认证。下面的章节将讨论如何建立健全实用的认证模式,以及如何避免最常见的安全隐患。</target>
        </trans-unit>
        <trans-unit id="dbd15fa92d23c602686ecb421e837fa5c0100a95" translate="yes" xml:space="preserve">
          <source>When a user is dutifully-connected to the aforesaid network, their identity &lt;em&gt;(&quot;authentication&quot;)&lt;/em&gt; is [already ...] &quot;conclusively known,&quot; as is their permission &lt;em&gt;(&quot;authorization&quot;)&lt;/em&gt; to do certain things ... such as ... &quot;to access this website.&quot;</source>
          <target state="translated">当用户忠实地连接到上述网络时，其身份&lt;em&gt;（&amp;ldquo;身份验证&amp;rdquo;）&lt;/em&gt; [已经&amp;hellip;&amp;hellip;]&amp;ldquo;已经确定&amp;rdquo;，以及他们进行某些事情（例如&lt;em&gt;）&lt;/em&gt;的许可&lt;em&gt;（&amp;ldquo;授权&amp;rdquo;）&lt;/em&gt; 。 ..&amp;ldquo;访问此网站。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="6b7e7b430708b466db8f5dc96f8c359bf35d1a98" translate="yes" xml:space="preserve">
          <source>When hashing, don't use fast hash algorithms such as MD5 (many hardware implementations exist).  Use something like SHA-512.  For passwords, slower hashes are better.</source>
          <target state="translated">散列时,不要使用快速的散列算法,比如MD5(有很多硬件实现)。使用像SHA-512这样的散列算法。对于密码,较慢的散列算法更好。</target>
        </trans-unit>
        <trans-unit id="1b1261f95eb01d2a4a663842cd7729c9a950766b" translate="yes" xml:space="preserve">
          <source>When you are validating the form (either client or server side) check if your dummy field has been filled to determine if it was sent by a human or a bot.</source>
          <target state="translated">当你在验证表单时(无论是客户端还是服务器端),检查你的假字段是否已被填写,以确定它是由人类还是机器人发送的。</target>
        </trans-unit>
        <trans-unit id="9990351cb6dc5a037c4956e9bc10cae3faf4b145" translate="yes" xml:space="preserve">
          <source>While it is true that hashing the password &lt;em&gt;can be&lt;/em&gt; effective against &lt;strong&gt;password disclosure&lt;/strong&gt;, it is vulnerable to replay attacks, Man-In-The-Middle attacks / hijackings (if an attacker can inject a few bytes into your unsecured HTML page before it reaches your browser, they can simply comment out the hashing in the JavaScript), or brute-force attacks (since you are handing the attacker both username, salt and hashed password).</source>
          <target state="translated">散列密码确实&lt;em&gt;可以&lt;/em&gt;有效地防止&lt;strong&gt;密码泄露&lt;/strong&gt; ，但是它很容易受到重放攻击，中间人攻击/劫持（如果攻击者可以在未受保护的HTML页面中注入一些字节，然后再到达您的网站）浏览器，他们可以简单地注释掉JavaScript中的哈希）或蛮力攻击（因为您同时向攻击者提供了用户名，盐和哈希密码）。</target>
        </trans-unit>
        <trans-unit id="3584882b01cd0f3c5269eeae6ec1a2fd214b72e5" translate="yes" xml:space="preserve">
          <source>While this is a noble thought, it is essentially useless (and can be a &lt;a href=&quot;https://stackoverflow.com/questions/1380168/does-it-make-security-sense-to-hash-password-on-client-end&quot;&gt;security flaw&lt;/a&gt;) unless it is combined with one of the above - that is, either securing the line with strong encryption or using a tried-and-tested challenge-response mechanism (if you don't know what that is, just know that it is one of the most difficult to prove, most difficult to design, and most difficult to implement concepts in digital security).</source>
          <target state="translated">尽管这是一种高尚的思想，但除非将其与上述方法之一结合使用，否则它实际上是无用的（并且可能是&lt;a href=&quot;https://stackoverflow.com/questions/1380168/does-it-make-security-sense-to-hash-password-on-client-end&quot;&gt;安全缺陷&lt;/a&gt; ）-也就是说，要么通过强加密保护线路，要么使用经过验证的挑战响应机制（如果您不知道这是什么，只需知道它是数字安全中最难证明，最难设计和最难实现的概念之一）。</target>
        </trans-unit>
        <trans-unit id="33e6a957bfa924b65ff628b30fcdd2dbd1ba74b7" translate="yes" xml:space="preserve">
          <source>Wikipedia article on weaknesses of several password hashing schemes.</source>
          <target state="translated">维基百科关于几种密码散列方案的弱点的文章。</target>
        </trans-unit>
        <trans-unit id="8643406d224fa433c9299efb0492bf78e73bb0e0" translate="yes" xml:space="preserve">
          <source>Wikipedia: HTTP cookie</source>
          <target state="translated">维基百科:HTTP cookie</target>
        </trans-unit>
        <trans-unit id="c67b948f981569ab7d4f3ea77c17d7b5eb452012" translate="yes" xml:space="preserve">
          <source>You can also vary this up a little by leaving the dummy field visible but outside the boundaries of the screen, but this is totally up to you.</source>
          <target state="translated">你也可以稍微改变一下,让假人字段显示在屏幕的边界之外,但这完全由你自己决定。</target>
        </trans-unit>
        <trans-unit id="d0abd0a897c5f9b121995cd958577feb15f7b6ac" translate="yes" xml:space="preserve">
          <source>You're Probably Storing Passwords Incorrectly</source>
          <target state="translated">你可能存储的密码可能不正确</target>
        </trans-unit>
        <trans-unit id="fb7f7c94028fe09a6d2d9b3bf0b8501eb7095619" translate="yes" xml:space="preserve">
          <source>etc.</source>
          <target state="translated">etc.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
