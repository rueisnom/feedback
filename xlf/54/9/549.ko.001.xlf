<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/549">
    <body>
      <group id="549">
        <trans-unit id="69df7b128404cdc2a24c0bfd9cd27a00e203a315" translate="yes" xml:space="preserve">
          <source>&quot;In a &lt;em&gt;corporate,&lt;/em&gt;&lt;strong&gt;intra-&lt;/strong&gt; net setting,&quot; most if not all of the foregoing might not apply!</source>
          <target state="translated">&quot; &lt;em&gt;기업의&lt;/em&gt; &lt;strong&gt;인트라넷&lt;/strong&gt; 환경에서&quot;대부분의 경우 전술 한 내용이 모두 적용되지 않을 수도 있습니다!</target>
        </trans-unit>
        <trans-unit id="058f419589e9dd656281d473affa1f7e3ba832f9" translate="yes" xml:space="preserve">
          <source>&quot;Remember me&quot; checkbox</source>
          <target state="translated">&quot;기억하십시오&quot;확인란</target>
        </trans-unit>
        <trans-unit id="7bfcf80c49fcc34753a9509db01b7f4fad1e8be7" translate="yes" xml:space="preserve">
          <source>1 failed attempt = 5 sec delay</source>
          <target state="translated">1 회 시도 실패 = 5 초 지연</target>
        </trans-unit>
        <trans-unit id="4933c9e0a9a55746fe717a260189a4c3b7776226" translate="yes" xml:space="preserve">
          <source>1 failed attempt = no delay</source>
          <target state="translated">1 회 시도 실패 = 지연 없음</target>
        </trans-unit>
        <trans-unit id="bda7f01ca3465367872dae9f245215d37c7e8f44" translate="yes" xml:space="preserve">
          <source>1-4 failed attempts = no delay</source>
          <target state="translated">1-4 회 시도 실패 = 지연 없음</target>
        </trans-unit>
        <trans-unit id="935e9ab41e1866d02953c899137cc5bd98598cd6" translate="yes" xml:space="preserve">
          <source>2 failed attempts = 15 sec delay</source>
          <target state="translated">2 회 실패 = 15 초 지연</target>
        </trans-unit>
        <trans-unit id="47aec48c770a6e89a9cdc96d4cfc0356ccf62251" translate="yes" xml:space="preserve">
          <source>2 failed attempts = 2 sec delay</source>
          <target state="translated">2 회 실패 = 2 초 지연</target>
        </trans-unit>
        <trans-unit id="daa302056ffb870a1635435f22e21ea1dafe9e09" translate="yes" xml:space="preserve">
          <source>21 page academic article with many great tips.</source>
          <target state="translated">많은 유용한 팁을 제공하는 21 페이지 학술 기사.</target>
        </trans-unit>
        <trans-unit id="dd4616a9b5e7761604c57acbe22a9f66ccc224ba" translate="yes" xml:space="preserve">
          <source>3 failed attempts = 4 sec delay</source>
          <target state="translated">3 회 실패 시도 = 4 초 지연</target>
        </trans-unit>
        <trans-unit id="a2ab0f46bed565e502c16626cce6aa94ed0265ea" translate="yes" xml:space="preserve">
          <source>3+ failed attempts = 45 sec delay</source>
          <target state="translated">3 회 이상 실패 = 45 초 지연</target>
        </trans-unit>
        <trans-unit id="5f26327f3b922c025c50d407447c515c8398f853" translate="yes" xml:space="preserve">
          <source>4 failed attempts = 8 sec delay</source>
          <target state="translated">4 회 실패 = 8 초 지연</target>
        </trans-unit>
        <trans-unit id="b410d68b441165f7e208e0c3606b2d34caa8f485" translate="yes" xml:space="preserve">
          <source>5 failed attempts = 15-30 min delay</source>
          <target state="translated">5 회 시도 실패 = 15-30 분 지연</target>
        </trans-unit>
        <trans-unit id="89eb27e67e97b23b39627fd0ebb7f6c8ddf3bf1d" translate="yes" xml:space="preserve">
          <source>5 failed attempts = 16 sec delay</source>
          <target state="translated">5 회 시도 실패 = 16 초 지연</target>
        </trans-unit>
        <trans-unit id="3fe528174a0b4a8437fd8b6038b509f4f9de6167" translate="yes" xml:space="preserve">
          <source>5+ failed attempts = 20 sec delay</source>
          <target state="translated">5 회 이상 실패 = 20 초 지연</target>
        </trans-unit>
        <trans-unit id="6921455f96323553f199528f7622f4a3b9a9786f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt; client side - give the clients a public key certificate (support in all major browsers - but raises questions over client machine security).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt; 클라이언트 쪽-클라이언트에 공개 키 인증서를 제공합니다 (모든 주요 브라우저에서 지원되지만 클라이언트 컴퓨터 보안에 대한 의문을 제기 함).</target>
        </trans-unit>
        <trans-unit id="45b4f07c39663a3e6c27f9302d6e20007ce9782d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol&quot;&gt;SRP&lt;/a&gt; - sort of clever password authentication without a trusted third party. But here we are getting into the realms of &quot;it's safer to use two-factor authentication, even if that's costlier&quot;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol&quot;&gt;SRP-&lt;/a&gt; 신뢰할 수있는 제 3자가없는 일종의 영리한 비밀번호 인증. 그러나 여기서는 &quot;비싸더라도 이중 인증을 사용하는 것이 더 안전합니다&quot;라는 영역으로 들어가고 있습니다.</target>
        </trans-unit>
        <trans-unit id="90f385f4e0a0b7f11399b82fc614984d76a16f3e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Session_hijacking&quot;&gt;Cookies can be hijacked&lt;/a&gt;: they are only as secure as the rest of the client's machine and other communications. They can be read from disk, sniffed in network traffic, lifted by a cross-site scripting attack, phished from a poisoned DNS so the client sends their cookies to the wrong servers. Don't send persistent cookies. Cookies should expire at the end of the client session (browser close or leaving your domain).</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Session_hijacking&quot;&gt;쿠키는 도용 될 수 있습니다. 쿠키는&lt;/a&gt; 클라이언트의 다른 시스템 및 기타 통신만큼 안전합니다. 디스크에서 읽을 수 있고, 네트워크 트래픽이 스니핑되고, 사이트 간 스크립팅 공격에 의해 제거되고, 독이있는 DNS에서 피싱되어 클라이언트가 쿠키를 잘못된 서버로 보냅니다. 영구 쿠키를 보내지 마십시오. 쿠키는 클라이언트 세션이 끝날 때 만료됩니다 (브라우저가 닫히거나 도메인을 떠남).</target>
        </trans-unit>
        <trans-unit id="49f9e15c72f3955bacc5f154f5cca6c87bd5ba73" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt; is meant to thwart one specific category of attack: automated dictionary/brute force trial-and-error with no human operator. There is no doubt that this is a real threat, however, there are ways of dealing with it seamlessly that don't require a CAPTCHA, specifically properly designed server-side login throttling schemes - we'll discuss those later.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;보안 문자&lt;/a&gt; 는 한 가지 특정 범주의 공격, 즉 작업자가없는 자동화 된 사전 / 무차별 시행 착오를 막기위한 것입니다. 이것이 실제 위협이라는 것은 의심의 여지가 없지만 CAPTCHA, 특히 올바르게 설계된 서버 측 로그인 조절 체계가 필요없는 문제를 완벽하게 처리하는 방법이 있습니다. 나중에 논의 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="4a414bc028ed50a0f3218630992fe44aa5dda99f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP Guide To Authentication&lt;/a&gt; / &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP Authentication Cheat Sheet&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP 인증 가이드&lt;/a&gt; / &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP 인증 치트 시트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="350279b88821264707fd02b036767898b4c1bda2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://tech.dropbox.com/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;Dropbox Tech Blog &amp;raquo; Blog Archive &amp;raquo; zxcvbn: realistic password strength estimation&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://tech.dropbox.com/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;Dropbox Tech 블로그&amp;raquo;블로그 아카이브&amp;raquo;zxcvbn : 현실적인 암호 강도 추정&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a5383b5bd8ae9fa5958ef40b0e46c085b1e5259" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;As a rule of thumb, however, I would say: the stronger your password policy is, the less you have to bug users with delays. If you require strong (case-sensitive alphanumerics + required numbers and symbols) 9+ character passwords, you could give the users 2-4 non-delayed password attempts before activating the throttling.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;그러나 일반적으로 암호 정책이 강력할수록 지연으로 사용자를 버그를 줄이지 않아도됩니다.&lt;/em&gt; &lt;em&gt;강력한 (대소 문자 구분 영숫자 + 필수 숫자 및 기호) 9+ 문자 암호가 필요한 경우 제한을 활성화하기 전에 사용자에게 2-4 개의 지연되지 않은 암호 시도를 제공 할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4957adf699c8759c1e40cd9b96d75b27b268fc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;and much more about&lt;/em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Form-based_authentication&quot;&gt;form based authentication&lt;/a&gt;...</source>
          <target state="translated">&lt;em&gt;그리고&lt;/em&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/Form-based_authentication&quot;&gt;폼 기반 인증&lt;/a&gt; &lt;em&gt;에 대한 훨씬 더&lt;/em&gt; ...</target>
        </trans-unit>
        <trans-unit id="fcc4b958071127c62617da40ec128a417501f1df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(Do not) Roll-your-own JavaScript encryption/hashing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;(자신의 롤업) JavaScript 암호화 / 해싱&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6dcdf8f937fc5401388255a12713637e49f4722f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice #1:&lt;/strong&gt; A short time delay that increases with the number of failed attempts, like:</source>
          <target state="translated">&lt;strong&gt;모범 사례 # 1 :&lt;/strong&gt; 다음과 같이 실패한 시도 횟수에 따라 증가하는 짧은 시간 지연 :</target>
        </trans-unit>
        <trans-unit id="4359ce5b629b2c1989c0365aa8961ffd79ee0d06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice #2:&lt;/strong&gt; A medium length time delay that goes into effect after N failed attempts, like:</source>
          <target state="translated">&lt;strong&gt;모범 사례 # 2 :&lt;/strong&gt; N 번의 시도 실패 후 적용되는 중간 길이의 시간 지연 :</target>
        </trans-unit>
        <trans-unit id="01abe219c5d4dda6367efc589d92ab2506211aad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best practice #3:&lt;/strong&gt; Combining the two approaches - either a fixed, short time delay that goes into effect after N failed attempts, like:</source>
          <target state="translated">&lt;strong&gt;모범 사례 # 3 :&lt;/strong&gt; 두 가지 접근 방식 결합-N 번의 시도 실패 후 적용되는 고정 된 짧은 시간 지연 :</target>
        </trans-unit>
        <trans-unit id="37c2926d835584f9eabb2cd451babd8b70ad6a67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAPTCHAS against humanity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;인류에 대한 보안 문자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="516d16a7e5a12ca5bcd98935577ee8e1d46c30d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Don't implement 'secret questions'&lt;/strong&gt;. The 'secret questions' feature is a security anti-pattern. Read the paper from link number 4 from the MUST-READ list. You can ask Sarah Palin about that one, after her Yahoo! email account got hacked during a previous presidential campaign because the answer to her security question was... &quot;Wasilla High School&quot;!</source>
          <target state="translated">&lt;strong&gt;'비밀 질문'을 구현하지 마십시오&lt;/strong&gt; . '비밀 질문'기능은 보안 안티 패턴입니다. 링크 번호 4의 필독서를 반드시 읽어야합니다. Sarah Palin에게 Yahoo! 그녀의 보안 질문에 대한 대답은 &quot;Wasilla High School&quot;이었기 때문에 이전 대통령 선거 운동 중에 전자 메일 계정이 해킹당했습니다!</target>
        </trans-unit>
        <trans-unit id="ec175f6942cc7b1865ec041ac5613bc9f80c0eef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you DO decide to implement persistent login cookies, this is how you do it:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;영구 로그인 쿠키를 구현하기로 결정한 경우 다음과 같이하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="637473bd2adb089039b0c89d6433ba778b84b474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of a bot:&lt;/strong&gt; The bot will see a field whose type is &lt;code&gt;text&lt;/code&gt; and a name &lt;code&gt;email&lt;/code&gt; (or whatever it is you called it) and will logically attempt to fill it with appropriate data. It doesn't care if you styled the input form with some fancy CSS, web-developers do it all the time. Whatever the value in the dummy field is, we don't care as long as it's larger than &lt;code&gt;0&lt;/code&gt; characters.</source>
          <target state="translated">&lt;strong&gt;봇의 경우 :&lt;/strong&gt; 봇은 유형이 &lt;code&gt;text&lt;/code&gt; 인 필드와 이름 &lt;code&gt;email&lt;/code&gt; (또는 사용자가 호출 한 것)을 논리적으로보고 적절한 데이터로 채 웁니다. 멋진 CSS로 입력 양식의 스타일을 지정해도 상관 없으며 웹 개발자는 항상 그렇게합니다. 더미 필드의 값이 무엇이든, &lt;code&gt;0&lt;/code&gt; 자를 초과하는 한 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aae812a71f3bb70676afff65f15c280be558f9db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case of a human:&lt;/strong&gt;
The user will not see the dummy field (in my case named &quot;email&quot;) and will not attempt to fill it. So the value of the dummy field should still be empty when the form has been sent.</source>
          <target state="translated">&lt;strong&gt;사람의 경우 :&lt;/strong&gt; 사용자는 더미 필드 (내 경우에는 &quot;이메일&quot;이라고 함)를 보지 않고 채우려 고 시도하지 않습니다. 따라서 양식을 보낼 때 더미 필드의 값은 여전히 ​​비어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0e6713aeddfc7a12a7fde3f069db7a29490d39d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In conclusion, security questions are inherently insecure in virtually all their forms and variations, and should not be employed in an authentication scheme for any reason.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;결론적으로 보안 질문은 사실상 모든 형태와 변형에서 안전하지 않으므로 어떠한 이유로 든 인증 체계에 사용해서는 안됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5921de4d57a4fbc23f79b12ad7e9cdeb5fb7c8e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It would, however, take an inordinate amount of time to crack even a 6-character password, &lt;em&gt;if you were limited to one attempt per second!&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그러나 &lt;em&gt;초당 1 회 시도로 제한되는 경우&lt;/em&gt; 6 자 암호조차 해독하는 데 시간이 많이 걸립니다 &lt;em&gt;!&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9fe7f6c15e0366087eea39f6e6266f59f5ea4149" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Locking accounts&lt;/strong&gt; and requiring email verification after N failed attempts (this is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Denial-of-service_attack&quot;&gt;DoS&lt;/a&gt; attack waiting to happen)</source>
          <target state="translated">N 번의 시도 실패 후 &lt;strong&gt;계정 잠금&lt;/strong&gt; 및 이메일 확인 필요 (이는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Denial-of-service_attack&quot;&gt;DoS&lt;/a&gt; 공격 발생 대기 중)</target>
        </trans-unit>
        <trans-unit id="e90850633bfc5febc51640b8ccb1003e1a125b35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Session data - &quot;You are logged in as Spiderman69&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;세션 데이터- &quot;Spiderman69로 로그인했습니다&quot;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd9c2a725de6be5c8d8a56d77ade192b833ed89e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Storing Passwords / Verifying logins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;비밀번호 저장 / 로그인 확인&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9bbd3f75083cc61c829eb8133833162ea78ad59c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To HTTPS or not to HTTPS?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HTTPS로 또는 HTTPS로?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aff7d87f4b6a1c8cb8a94e4e8a8d78776ee65e55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Of course this method is not 100% foolproof. Bots can be programmed to ignore input fields with the style &lt;code&gt;display:none&lt;/code&gt; applied to it. You also have to think about people who use some form of auto-completion (like most browsers have built-in!) to auto-fill all form fields for them. They might just as well pick up a dummy field.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 물론이 방법은 100 % 완전하지 않습니다. 스타일 &lt;code&gt;display:none&lt;/code&gt; 가없는 입력 필드를 무시하도록 봇을 프로그래밍 할 수 있습니다. 또한 모든 양식 필드를 자동으로 채우려면 특정 양식의 자동 완성 기능을 사용하는 사람들 (대부분의 브라우저에 내장되어 있음)을 고려해야합니다. 그들은 더미 필드를 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d5d1f9e278d3727050a077840f6bd8ade191eb6" translate="yes" xml:space="preserve">
          <source>A 'standard' secret question like mother's maiden name or favorite pet</source>
          <target state="translated">어머니의 성함 또는 좋아하는 애완 동물과 같은 '표준'비밀 질문</target>
        </trans-unit>
        <trans-unit id="f64690874d20c3aeaa77943a06ac83d30946406d" translate="yes" xml:space="preserve">
          <source>A big user interface benefit being sought here is the &amp;ldquo;identity selector&amp;rdquo;. When a user visits a site and chooses to authenticate, their browser shows them a selection of email addresses (&amp;ldquo;personal&amp;rdquo;, &amp;ldquo;work&amp;rdquo;, &amp;ldquo;political activism&amp;rdquo;, etc.) they may use to identify themselves to the site.</source>
          <target state="translated">여기서 가장 큰 사용자 인터페이스 이점은 &quot;ID 선택기&quot;입니다. 사용자가 사이트를 방문하고 인증을 선택하면 브라우저는 사이트에 자신을 식별하는 데 사용할 수있는 전자 메일 주소 ( &quot;개인&quot;, &quot;작업&quot;, &quot;정치 행동&quot;등)를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="20a4741b328cb885ac3f4e272309bb731bd02051" translate="yes" xml:space="preserve">
          <source>A cryptographic hash should not be used for password storage because user-selected passwords are not strong enough (i.e. do not usually contain enough entropy) and a password guessing attack could be completed in a relatively short time by an attacker with access to the hashes. This is why KDFs are used - these effectively &lt;a href=&quot;https://en.wikipedia.org/wiki/Key_stretching&quot;&gt;&quot;stretch the key&quot;&lt;/a&gt;, which means that every password guess an attacker makes causes multiple repetitions of the hash algorithm, for example 10,000 times, which causes the attacker to guess the password 10,000 times slower.</source>
          <target state="translated">사용자가 선택한 암호는 충분히 강력하지 않고 (즉, 일반적으로 충분한 엔트로피를 포함하지 않음) 암호 추측 공격은 해시에 대한 액세스 권한이있는 공격자가 비교적 짧은 시간 내에 완료 할 수 있기 때문에 암호 해시를 암호 저장소에 사용해서는 안됩니다. 이것이 바로 KDF가 사용되는 이유입니다. 이는 효과적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Key_stretching&quot;&gt;&quot;키를&lt;/a&gt; 잡아 당김 &quot;입니다 . 이는 공격자가 만드는 모든 암호 추측으로 인해 해시 알고리즘이 여러 번 반복되어 (예 : 10,000 번) 공격자가 암호를 10,000 번 느리게 추측하게됩니다.</target>
        </trans-unit>
        <trans-unit id="7590029be61bfd68fc48f94dac75c5aef9aad07f" translate="yes" xml:space="preserve">
          <source>A final note: always make sure your interface for entering the 'lost password code' is at least as secure as your login form itself, or an attacker will simply use this to gain access instead. Making sure you generate very long 'lost password codes' (for example, 16 case-sensitive alphanumeric characters) is a good start, but consider adding the same throttling scheme that you do for the login form itself.</source>
          <target state="translated">마지막 참고 사항 : 항상 '비밀번호 암호'를 입력하기위한 인터페이스가 최소한 로그인 양식 자체보다 안전해야합니다. 그렇지 않으면 공격자 가이 정보를 사용하여 대신 액세스 할 수 있습니다. 매우 긴 '비밀번호 암호'(예 : 대소 문자를 구분하는 16 자의 영숫자)를 생성하는 것이 좋은 시작이지만 로그인 양식 자체와 동일한 제한 체계를 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="11d28e408d6e08e9bc8b44384de8740b08f464cd" translate="yes" xml:space="preserve">
          <source>A good article about realistic password strength estimation is:</source>
          <target state="translated">현실적인 암호 강도 추정에 대한 좋은 기사는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c73360d37de0cecf6fb825c8a88ccb92b682493b" translate="yes" xml:space="preserve">
          <source>A simple piece of trivia that anyone could lift from their blog, LinkedIn profile, or similar</source>
          <target state="translated">누구나 자신의 블로그, 링크드 인 프로필 등에서 들어 올릴 수있는 간단한 퀴즈</target>
        </trans-unit>
        <trans-unit id="5d9880021de84dd0fea8123c504dd9636c53c978" translate="yes" xml:space="preserve">
          <source>Additionally, it makes sense to do more aggressive throttling on admin accounts, since those are the most attractive entry points</source>
          <target state="translated">또한 가장 매력적인 진입 점이므로 관리자 계정에 대해보다 적극적인 조절을 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d7e5b123cdf543d44b363c873a05a3315621a304" translate="yes" xml:space="preserve">
          <source>After the user logs in, the server sends the user a session cookie. The server can retrieve the username or id from the cookie, but nobody else can generate such a cookie (TODO explain mechanisms).</source>
          <target state="translated">사용자가 로그인 한 후 서버는 사용자에게 세션 쿠키를 보냅니다. 서버는 쿠키에서 사용자 이름 또는 ID를 검색 할 수 있지만, 아무도 쿠키를 생성 할 수 없습니다 (TODO Explain 메커니즘).</target>
        </trans-unit>
        <trans-unit id="cf64446be670d9f89a6800352ab8de9cc2e9bb10" translate="yes" xml:space="preserve">
          <source>Always hash the lost password code/token in the database. &lt;strong&gt;&lt;em&gt;AGAIN&lt;/em&gt;&lt;/strong&gt;, this code is another example of a Password Equivalent, so it MUST be hashed in case an attacker got their hands on your database. When a lost password code is requested, send the plaintext code to the user's email address, then hash it, save the hash in your database -- and &lt;em&gt;throw away the original&lt;/em&gt;. Just like a password or a persistent login token.</source>
          <target state="translated">항상 데이터베이스에서 유실 된 비밀번호 코드 / 토큰을 해시하십시오. &lt;strong&gt;&lt;em&gt;다시 말하지만&lt;/em&gt;&lt;/strong&gt; ,이 코드는 Password Equivalent의 또 다른 예이므로 공격자가 데이터베이스에 손을 넣은 경우 반드시 해시해야합니다. 분실 한 비밀번호 코드가 요청되면 일반 텍스트 코드를 사용자의 이메일 주소로 보낸 다음 해시하고 데이터베이스에 해시를 저장 &lt;em&gt;하고 원본을 버립니다&lt;/em&gt; . 비밀번호 나 영구 로그인 토큰과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8fa1c13ce1fcf0e5a7c7b34d06206e4a19a7e2d" translate="yes" xml:space="preserve">
          <source>And finally, &lt;strong&gt;login throttling&lt;/strong&gt;: that is, setting a time delay between attempts after N failed attempts (yes, DoS attacks are still possible, but at least they are far less likely and a lot more complicated to pull off).</source>
          <target state="translated">마지막으로 &lt;strong&gt;로그인 조절&lt;/strong&gt; : 즉, N 번의 시도 실패 후 시도 사이에 시간 지연을 설정합니다 (예, DoS 공격은 여전히 ​​가능하지만 적어도이 방법은 훨씬 덜 복잡하고 해체하기가 더 복잡합니다).</target>
        </trans-unit>
        <trans-unit id="50261011750b3da345a0d096efbd266f05c0265c" translate="yes" xml:space="preserve">
          <source>And for a refreshing take on user-friendliness of high-entropy passwords, Randall Munroe's &lt;a href=&quot;https://xkcd.com/936/&quot;&gt;Password Strength xkcd&lt;/a&gt; is highly recommended.</source>
          <target state="translated">엔트로피가 높은 암호를 사용자에게 친숙하게 바꾸려면 Randall Munroe의 &lt;a href=&quot;https://xkcd.com/936/&quot;&gt;암호 강도 xkcd&lt;/a&gt; 를 적극 권장합니다.</target>
        </trans-unit>
        <trans-unit id="17c338063d0906b9a8c9db49206427ff3518197a" translate="yes" xml:space="preserve">
          <source>And just to reiterate one of the most common pitfalls, &lt;strong&gt;DO NOT STORE THE PERSISTENT LOGIN COOKIE (TOKEN) IN YOUR DATABASE, ONLY A HASH OF IT!&lt;/strong&gt; The login token is Password Equivalent, so if an attacker got their hands on your database, they could use the tokens to log in to any account, just as if they were cleartext login-password combinations. Therefore, use hashing (according to &lt;a href=&quot;https://security.stackexchange.com/a/63438/5002&quot;&gt;https://security.stackexchange.com/a/63438/5002&lt;/a&gt; a weak hash will do just fine for this purpose) when storing persistent login tokens.</source>
          <target state="translated">가장 일반적인 함정 중 하나를 되풀이하려면 &lt;strong&gt;영구 로그인 쿠키 (TOKEN)를 데이터베이스에 저장하지 마십시오.&lt;/strong&gt; 로그인 토큰은 Password Equivalent이므로 공격자가 데이터베이스에 손을 대면 마치 일반 텍스트 로그인-암호 조합 인 것처럼 토큰을 사용하여 모든 계정에 로그인 할 수 있습니다. 따라서 영구 로그인 토큰을 저장할 때 해싱을 사용하십시오 ( &lt;a href=&quot;https://security.stackexchange.com/a/63438/5002&quot;&gt;https://security.stackexchange.com/a/63438/5002&lt;/a&gt; 에 따르면 약한 해시는이 목적에 적합합니다).</target>
        </trans-unit>
        <trans-unit id="72316e90ea3528bdbe9b7197ccebf727fd3c4940" translate="yes" xml:space="preserve">
          <source>Another big user interface benefit being sought as part of this effort is &lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest-Session&quot;&gt;helping the browser know more about the user&amp;rsquo;s session&lt;/a&gt; &amp;ndash; who they&amp;rsquo;re signed in as currently, primarily &amp;ndash; so it may display that in the browser chrome.</source>
          <target state="translated">이 노력의 일환으로 또 다른 큰 사용자 인터페이스의 이점 &lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest-Session&quot;&gt;은 현재 사용자가&lt;/a&gt; 주로 로그인 한 사용자의 세션에 대해 브라우저가 더 많은 것을 알 수 있도록 브라우저 크롬에 표시 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="705253cd657208d09c588cee3c6ce2acfa7a6043" translate="yes" xml:space="preserve">
          <source>Another warning about storing passwords in the database.</source>
          <target state="translated">데이터베이스에 비밀번호를 저장하는 것에 대한 또 다른 경고.</target>
        </trans-unit>
        <trans-unit id="54b5a6243a4307025588c6723f58ebb3abfde047" translate="yes" xml:space="preserve">
          <source>Any question that is easier to answer than guessing their password. Which, for any decent password, is every question you can imagine</source>
          <target state="translated">비밀번호를 추측하는 것보다 대답하기 쉬운 질문. 어느 암호에 대해서도 상상할 수있는 모든 질문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac85befbefb90c64bf699051a1715be6633e17ed" translate="yes" xml:space="preserve">
          <source>As a second level of expressing identity, each domain manages its own set of accounts.</source>
          <target state="translated">두 번째 수준의 표현 아이덴티티로서 각 도메인은 고유 한 계정 세트를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="7fae24196de93a89f7bc9168355345ea97141c87" translate="yes" xml:space="preserve">
          <source>As nothing is more efficient than not doing it at all.</source>
          <target state="translated">전혀하지 않는 것보다 더 효율적인 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="b9a023176b2c76e659482f620b9f75601624a29e" translate="yes" xml:space="preserve">
          <source>Ask YC: Best Practices for User Authentication</source>
          <target state="translated">YC에 문의 : 사용자 인증 모범 사례</target>
        </trans-unit>
        <trans-unit id="df15f74ac80c8dd3799c1c499d1cc92b7ae3c505" translate="yes" xml:space="preserve">
          <source>Authentication can be completely delegated to a single-sign-on service, where another provider handles collecting credentials. This pushes the problem to a trusted third party. Google and Twitter both provide standards-based SSO services, while Facebook provides a similar proprietary solution.</source>
          <target state="translated">다른 공급자가 자격 증명 수집을 처리하는 싱글 사인온 서비스에 인증을 완전히 위임 할 수 있습니다. 이렇게하면 문제를 신뢰할 수있는 제 3 자에게 푸시합니다. Google과 Twitter는 모두 표준 기반 SSO 서비스를 제공하는 반면 Facebook은 유사한 독점 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f70be28530087a7439a32ae20f152509cc4f41a4" translate="yes" xml:space="preserve">
          <source>Be creative!</source>
          <target state="translated">창의력을 발휘하십시오!</target>
        </trans-unit>
        <trans-unit id="1de8c9a58ce4eebe00ed4c7a8a4c68f84a6b9ba8" translate="yes" xml:space="preserve">
          <source>Because of the distributed nature of this system, it avoids lock-in to major sites like Facebook, Twitter, Google, etc. Any individual can own their own domain and therefore act as their own identity provider.</source>
          <target state="translated">이 시스템의 분산 특성으로 인해 Facebook, Twitter, Google 등과 같은 주요 사이트에 대한 접속을 피할 수 있습니다. 모든 개인은 자신의 도메인을 소유 할 수 있으므로 고유 한 ID 제공 업체로 활동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f0cb361ff24b04aa6092ff32d4cb6f1c75f9ee1" translate="yes" xml:space="preserve">
          <source>Browser autocompletion of usernames and passwords</source>
          <target state="translated">사용자 이름 및 비밀번호의 브라우저 자동 완성</target>
        </trans-unit>
        <trans-unit id="5172cfd6482bd52a4f6c2f400ad548c6594c7e4b" translate="yes" xml:space="preserve">
          <source>But this is a &lt;em&gt;lot&lt;/em&gt; of a hassle, and not very web 2.0. However, it is the only secure way to create new accounts that have access to valuable information that is not self-created.</source>
          <target state="translated">그러나 이것은 &lt;em&gt;많은&lt;/em&gt; 번거 로움이며 웹 2.0은 아닙니다. 그러나 자체 생성되지 않은 중요한 정보에 액세스 할 수있는 새 계정을 만드는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="28c851e3c23baa12d952c7c21330cc5b4915d3fd" translate="yes" xml:space="preserve">
          <source>Checking password strength</source>
          <target state="translated">비밀번호 강도 확인</target>
        </trans-unit>
        <trans-unit id="2099227ae53d0bb69ac620e426264f3954bf9b76" translate="yes" xml:space="preserve">
          <source>Credentials can be compromised, whether by exploits, passwords being written down and lost, laptops with keys being stolen, or users entering logins into phishing sites.  Logins can be further protected with two-factor authentication, which uses out-of-band factors such as single-use codes received from a phone call, SMS message, app, or dongle. Several providers offer two-factor authentication services.</source>
          <target state="translated">악용, 암호 기록 및 유실, 키가 도난당한 랩톱 또는 사용자가 피싱 사이트에 로그인을 입력하여 자격 증명이 손상 될 수 있습니다. 전화, SMS 메시지, 앱 또는 동글에서 수신 한 일회용 코드와 같은 대역 외 요소를 사용하는 2 단계 인증으로 로그인을 추가로 보호 할 수 있습니다. 몇몇 공급자는 이중 인증 서비스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5137f3cf30b10d748e2139da3d3ff6a7f14769cd" translate="yes" xml:space="preserve">
          <source>Definitive Article</source>
          <target state="translated">결정적인 기사</target>
        </trans-unit>
        <trans-unit id="0852a700c5db81b3b623eebfdac10924f4cb53cc" translate="yes" xml:space="preserve">
          <source>Digest Authentication is a standards-based approach supported in all major browsers and servers, that will not send a password even over a secure channel.</source>
          <target state="translated">다이제스트 인증은 모든 주요 브라우저와 서버에서 지원되는 표준 기반 접근 방식으로, 보안 채널을 통해서도 암호를 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5724bf395ae05f9a76fbdee9b6b10fda30c0d956" translate="yes" xml:space="preserve">
          <source>Discussion about rainbow tables and how to defend against them, and against other threads. Includes extensive discussion.</source>
          <target state="translated">무지개 테이블과 그것들을 방어하는 법, 그리고 다른 실에 대한 토론. 광범위한 토론을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="75200dc7711cafface63f254986b6f2ef192e789" translate="yes" xml:space="preserve">
          <source>Discussion: Coding Horror: You're Probably Storing Passwords Incorrectly</source>
          <target state="translated">토론 : 코딩 공포 : 암호를 잘못 저장했을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9700753881a2fcb4aa5513ef58545733b290ed25" translate="yes" xml:space="preserve">
          <source>Distributing the attempts on a botnet to prevent IP address flagging</source>
          <target state="translated">IP 주소 플래그를 방지하기 위해 봇넷에 시도 배포</target>
        </trans-unit>
        <trans-unit id="ac89eed1b4b4a5aef7852b1e48fc27ff64d4c4f4" translate="yes" xml:space="preserve">
          <source>Do NOT try to implement your own login form or database storage of passwords, unless 
the data being stored is valueless at account creation and self-generated (that is, web 2.0 style like Facebook, &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt;, etc.)</source>
          <target state="translated">계정을 만들 때 자체적으로 생성 된 데이터가 가치가없고 자체적으로 생성 된 경우 (즉, Facebook, &lt;a href=&quot;http://en.wikipedia.org/wiki/Flickr&quot;&gt;Flickr&lt;/a&gt; 와 같은 웹 2.0 스타일)가 아닌 한, 고유 한 로그인 양식 또는 비밀번호 데이터베이스 저장소를 구현하려고 시도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b407c4a28fed3e87fb4c9cd858d136f953302fac" translate="yes" xml:space="preserve">
          <source>DoS attacking this final login throttling scheme would be &lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt; impractical. And as a final touch, always allow persistent (cookie) logins (and/or a CAPTCHA-verified login form) to pass through, so legitimate users won't even be delayed &lt;em&gt;while the attack is in progress&lt;/em&gt;. That way, the very impractical DoS attack becomes an &lt;em&gt;extremely&lt;/em&gt; impractical attack.</source>
          <target state="translated">이 최종 로그인 제한 체계를 공격하는 DoS는 &lt;strong&gt;&lt;em&gt;매우&lt;/em&gt;&lt;/strong&gt; 비현실적입니다. 마지막으로 영구 (쿠키) 로그인 (및 / 또는 CAPTCHA 인증 로그인 양식)을 항상 통과 할 수 &lt;em&gt;있으므로 공격이 진행되는 동안&lt;/em&gt; 합법적 인 사용자가 지연되지 않을 수도 있습니다. 이렇게하면 매우 실용적이지 않은 DoS 공격은 &lt;em&gt;매우&lt;/em&gt; 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e7a3a3d5fd3f56cab117f9ef1747e6b549435b4" translate="yes" xml:space="preserve">
          <source>DoS attacking this scheme would be quite impractical, but certainly doable. Also, it might be relevant to note that such a long delay can be very annoying for a legitimate user. Forgetful users will dislike you.</source>
          <target state="translated">이 체계를 공격하는 DoS는 상당히 비현실적이지만 확실히 가능합니다. 또한, 그러한 긴 지연은 합법적 인 사용자에게는 매우 성 가실 수 있습니다. 잊어 버린 사용자는 당신을 싫어할 것입니다.</target>
        </trans-unit>
        <trans-unit id="da0e8494de518dd7e8a6918d639ad934c79f4341" translate="yes" xml:space="preserve">
          <source>DoS attacking this scheme would be very impractical, since the resulting lockout time is slightly larger than the sum of the previous lockout times.</source>
          <target state="translated">결과 잠금 시간이 이전 잠금 시간의 합보다 약간 크므로이 체계를 공격하는 DoS는 매우 비실용적입니다.</target>
        </trans-unit>
        <trans-unit id="0104c9c8e1e30ebe0dea4b4e83fd6608c1f8882a" translate="yes" xml:space="preserve">
          <source>Don't &lt;em&gt;reset&lt;/em&gt; a forgotten password to an autogenerated strong password - such passwords are notoriously hard to remember, which means the user must either change it or write it down - say, on a bright yellow Post-It on the edge of their monitor. Instead of setting a new password, just let users pick a new one right away - which is what they want to do anyway. (An exception to this might be if the users are universally using a password manager to store/manage passwords that would normally be impossible to remember without writing it down).</source>
          <target state="translated">잊어 버린 암호를 자동 생성 된 강력한 암호로 &lt;em&gt;재설정&lt;/em&gt; 하지 마십시오. 이러한 암호는 기억하기 어렵 기 때문에 사용자가 암호를 변경하거나 기록해야합니다 (예 : 모니터 가장자리의 밝은 노란색 포스트잇). 새 비밀번호를 설정하는 대신 사용자가 새 비밀번호를 바로 선택할 수있게합니다. (일반적으로 사용자가 암호 관리자를 사용하여 암호를 기록하지 않고 기억하기 어려운 암호를 저장 / 관리하는 경우)는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="2de2a3f83a86845063f5b948c1410f326797445a" translate="yes" xml:space="preserve">
          <source>Don't ever store passwords as plaintext in the database. Not even if you don't care about the security of your own site. Assume that some of your users will reuse the password of their online bank account. So, store the hashed password, and throw away the original. And make sure the password doesn't show up in access logs or application logs. OWASP &lt;a href=&quot;https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet#Impose_infeasible_verification_on_attacker&quot;&gt;recommends the use of Argon2&lt;/a&gt; as your first choice for new applications. If this is not available, PBKDF2 or scrypt should be used instead. And finally if none of the above are available, use bcrypt.</source>
          <target state="translated">데이터베이스에 암호를 일반 텍스트로 저장하지 마십시오. 자신의 사이트 보안에 관심이없는 경우에도 마찬가지입니다. 일부 사용자가 온라인 은행 계좌의 비밀번호를 재사용한다고 가정하십시오. 따라서 해시 된 비밀번호를 저장하고 원본을 버립니다. 또한 액세스 로그 또는 응용 프로그램 로그에 비밀번호가 표시되지 않아야합니다. OWASP는 새로운 애플리케이션을위한 첫 번째 선택 &lt;a href=&quot;https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet#Impose_infeasible_verification_on_attacker&quot;&gt;으로 Argon2&lt;/a&gt; 를 사용할 것을 권장합니다 . 이것이 가능하지 않은 경우, 대신 PBKDF2 또는 scrypt를 사용해야합니다. 마지막으로 위의 사항 중 어느 것도 사용할 수 없으면 bcrypt를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0ee655cfc09904ea89a7dd7a61686e2332a87c87" translate="yes" xml:space="preserve">
          <source>Dos and Don&amp;rsquo;ts of Client Authentication on the Web (very readable MIT research paper)</source>
          <target state="translated">웹에서 클라이언트 인증의 수행 및 금지 (읽기 쉬운 MIT 연구 논문)</target>
        </trans-unit>
        <trans-unit id="a9d3cd24a6e8137771c2eb5231b4292534173c59" translate="yes" xml:space="preserve">
          <source>Dos and Don'ts of Client Authentication on the Web (PDF)</source>
          <target state="translated">웹에서 클라이언트 인증의 수행 및 금지 (PDF)</target>
        </trans-unit>
        <trans-unit id="a6df6aab068ddfca1dd445a099c04ab77b30380c" translate="yes" xml:space="preserve">
          <source>E-mail validation</source>
          <target state="translated">이메일 검증</target>
        </trans-unit>
        <trans-unit id="26a0e3922cf6459a169fb69c5cedf0594a660c30" translate="yes" xml:space="preserve">
          <source>Editing the official answer</source>
          <target state="translated">공식 답변 수정</target>
        </trans-unit>
        <trans-unit id="2a5bf7ecd3c3bb79697e4b75902e93bf1d1f63ef" translate="yes" xml:space="preserve">
          <source>Email providers are already the de-facto primary identity providers online. Current password reset flows usually let you take control of an account if you can prove that you control that account&amp;rsquo;s associated email address.</source>
          <target state="translated">이메일 제공 업체는 이미 사실상의 기본 ID 제공 업체입니다. 현재 비밀번호 재설정 흐름을 사용하면 해당 계정의 관련 이메일 주소를 제어 할 수 있음을 증명할 수있는 경우 일반적으로 계정을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca82a8d4544f8e713eb61230c51166734ade8bc0" translate="yes" xml:space="preserve">
          <source>Enough With The Rainbow Tables: What You Need To Know About Secure Password Schemes</source>
          <target state="translated">레인보우 테이블로 충분 : 보안 암호 체계에 대해 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="2c81c599e2b514bdc593f3664a3e0b805bb4f759" translate="yes" xml:space="preserve">
          <source>Even with user-specified questions, it is highly likely that most users will choose either:</source>
          <target state="translated">사용자 지정 질문이 있더라도 대부분의 사용자는 다음 중 하나를 선택할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="94eb0c2edb61f0c161e93c8ae7a3d970650bcabd" translate="yes" xml:space="preserve">
          <source>Financial websites such as banks and credit cards, on the other hand, only have sensitive data and should not allow auto-login or a low-security mode.</source>
          <target state="translated">반면 은행 및 신용 카드와 같은 금융 웹 사이트는 중요한 데이터 만 가지고 있으며 자동 로그인 또는 보안 수준이 낮은 모드를 허용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="055ea5e2a84b88f78196f3343fc0481996477833" translate="yes" xml:space="preserve">
          <source>First, a strong caveat that this answer is not the best fit for this exact question. It should definitely not be the top answer!</source>
          <target state="translated">첫째,이 답변이이 정확한 질문에 가장 적합하지 않다는 강력한 경고입니다. 확실히 최고의 답변이되어서는 안됩니다!</target>
        </trans-unit>
        <trans-unit id="6f4757517fb79956122368fef702663232eb1875" translate="yes" xml:space="preserve">
          <source>First, have a look at the numbers: &lt;a href=&quot;https://www.lockdown.co.uk/?pg=combi&amp;amp;s=articles&quot;&gt;Password Recovery Speeds - How long will your password stand up&lt;/a&gt;</source>
          <target state="translated">먼저, 숫자를 살펴보십시오 : &lt;a href=&quot;https://www.lockdown.co.uk/?pg=combi&amp;amp;s=articles&quot;&gt;비밀번호 복구 속도-비밀번호가 얼마나 오래 지속됩니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0009187974f9e3ce61f9861d9dbd0e82cd7d920" translate="yes" xml:space="preserve">
          <source>First, take some time to read &lt;a href=&quot;https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence&quot;&gt;Paragon Initiative's article&lt;/a&gt; on the subject. You'll need to get a bunch of elements right, and the article does a great job of explaining each.</source>
          <target state="translated">먼저, 주제에 관한 &lt;a href=&quot;https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence&quot;&gt;Paragon Initiative의 기사&lt;/a&gt; 를 읽으십시오. 많은 요소를 올바르게 가져와야하며 기사는 각 요소를 설명하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="9983f7fe8e0548ed05592e10b4d8737faf0870ba" translate="yes" xml:space="preserve">
          <source>First, we are confusing the initial creation of an account (with a password) with the re-checking of the password subsequently. If I am Flickr and creating your site for the first time, the new user has access to zero value (blank web space). I truly do not care if the person creating the account is lying about their name. If I am creating an account of the hospital intranet/extranet, the value lies in all the medical records, and so I &lt;em&gt;do&lt;/em&gt; care about the identity (*) of the account creator.</source>
          <target state="translated">먼저, 초기 비밀번호 생성과 비밀번호 재확인을 혼동하고 있습니다. Flickr이고 처음으로 사이트를 만드는 경우 새 사용자는 0 값 (빈 웹 공간)에 액세스 할 수 있습니다. 계정을 만드는 사람이 자신의 이름에 대해 거짓말하고 있는지는 상관하지 않습니다. 병원 인트라넷 / 엑스트라 넷의 계정을 만드는 경우 그 가치는 모든 의료 기록에 있으므로 계정 작성자의 신원 (*)을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="43fce5a38d3ccc4394c31ed312d1e3f3bbcdb4f5" translate="yes" xml:space="preserve">
          <source>First, you'll want to read this small article for a reality check: &lt;a href=&quot;http://www.whatsmypass.com/?p=415&quot;&gt;The 500 most common passwords&lt;/a&gt;</source>
          <target state="translated">먼저, 현실 점검을 위해이 작은 기사를 읽으십시오 : &lt;a href=&quot;http://www.whatsmypass.com/?p=415&quot;&gt;500 개의 가장 일반적인 암호&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc25ac14ee563260aa5557fc0a6773974bd214de" translate="yes" xml:space="preserve">
          <source>For browsers that don&amp;rsquo;t support the Verified Email Protocol (currently all of them), Mozilla provides a shim which implements the protocol in client-side JavaScript code.</source>
          <target state="translated">확인 된 이메일 프로토콜 (현재 모든 브라우저)을 지원하지 않는 브라우저의 경우, Mozilla는 클라이언트 측 JavaScript 코드로 프로토콜을 구현하는 shim을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a432583ba49ebf5724dd0a7840811c9356950ca3" translate="yes" xml:space="preserve">
          <source>For email services that don&amp;rsquo;t support the Verified Email Protocol, the protocol allows third parties to act as a trusted intermediary, asserting that they&amp;rsquo;ve verified a user&amp;rsquo;s ownership of an account. It is not desirable to have a large number of such third parties; this capability is intended only to allow an upgrade path, and it is much preferred that email services provide these assertions themselves.</source>
          <target state="translated">확인 된 이메일 프로토콜을 지원하지 않는 이메일 서비스의 경우,이 프로토콜을 사용하면 제 3자가 신뢰할 수있는 중개자 역할을하여 계정의 사용자 소유권을 확인했다고 주장 할 수 있습니다. 그러한 제 3자를 많이 갖는 것은 바람직하지 않습니다. 이 기능은 업그레이드 경로 만 허용하기위한 것이며 전자 메일 서비스가 이러한 어설 션 자체를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1a29c9f448b4e82925d7464abc91594ed7ceb096" translate="yes" xml:space="preserve">
          <source>Forgotten username/password functionality</source>
          <target state="translated">잊어 버린 사용자 이름 / 암호 기능</target>
        </trans-unit>
        <trans-unit id="4c44940eff64d8851ea63a4d7d267c3700ac7b6f" translate="yes" xml:space="preserve">
          <source>Form-based authentication for websites</source>
          <target state="translated">웹 사이트를위한 폼 기반 인증</target>
        </trans-unit>
        <trans-unit id="8c3c600b9979573648ec2a7bc6061a82458b6242" translate="yes" xml:space="preserve">
          <source>Form-based authentication has a big drawback, which is an increased risk of &lt;a href=&quot;http://en.wikipedia.org/wiki/Phishing&quot;&gt;phishing&lt;/a&gt;. Users are asked to enter sensitive information into an area controlled by a remote entity, rather than an area controlled by their User Agent (browser).</source>
          <target state="translated">양식 기반 인증에는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Phishing&quot;&gt;피싱&lt;/a&gt; 위험이 증가하는 큰 단점이 있습니다. 사용자는 사용자 에이전트 (브라우저)가 제어하는 ​​영역이 아니라 원격 엔터티가 제어하는 ​​영역에 중요한 정보를 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ef26769a71921c31789a2a8774d89fdae723d09" translate="yes" xml:space="preserve">
          <source>Forum discussion about a Coding Horror article.</source>
          <target state="translated">코딩 공포 기사에 대한 포럼 토론.</target>
        </trans-unit>
        <trans-unit id="c026b4ef95ca288f3bb81cc79228ab85b91d71b2" translate="yes" xml:space="preserve">
          <source>Forum discussion on the subject</source>
          <target state="translated">주제에 관한 포럼 토론</target>
        </trans-unit>
        <trans-unit id="da292fcb68a4e760db8e5e44afc487fef3ebd153" translate="yes" xml:space="preserve">
          <source>From your point-of-view, you simply know this: that &lt;em&gt;anyone&lt;/em&gt; who legitimately winds-up at your website &lt;em&gt;must&lt;/em&gt; be accompanied by [an environment-variable magically containing ...] a &quot;token.&quot; (&lt;em&gt;i.e.&lt;/em&gt; The absence of such a token must be immediate grounds for &lt;code&gt;404 Not Found&lt;/code&gt;.)</source>
          <target state="translated">당신의 관점에서, 당신은 단순히 이것을 알고 있습니다 : 당신의 웹 사이트에 합법적으로 바람을 피우는 &lt;em&gt;사람&lt;/em&gt; 은 [토론 적으로 ...를 포함하는 환경 변수]를 동반 &lt;em&gt;해야합니다&lt;/em&gt; . ( &lt;em&gt;즉&lt;/em&gt; , 그러한 토큰이 없으면 &lt;code&gt;404 Not Found&lt;/code&gt; 의 즉각적인 근거가되어야합니다.)</target>
        </trans-unit>
        <trans-unit id="6711dc17a4ea41f713c35b2df6b7663446e7a514" translate="yes" xml:space="preserve">
          <source>Generally speaking, you have three choices that are all effective against brute-force attacks &lt;em&gt;(and dictionary attacks, but since you are already employing a strong passwords policy, they shouldn't be an issue)&lt;/em&gt;:</source>
          <target state="translated">일반적으로, 무차별 대입 공격 &lt;em&gt;(및 사전 공격&lt;/em&gt; 에 대해 모두 효과적인 세 가지 선택 사항이 &lt;em&gt;있지만 이미 강력한 암호 정책을 사용하고 있으므로 문제가되지 않아야합니다)&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a740b3ba607923f583d5988ec528cdaf1406a543" translate="yes" xml:space="preserve">
          <source>Given the perceived (though now &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;avoidable&lt;/a&gt;) cost and technical difficulty of setting up an SSL certificate on your website, some developers are tempted to roll their own in-browser hashing or encryption schemes in order to avoid passing cleartext logins over an unsecured wire.</source>
          <target state="translated">웹 사이트에서 SSL 인증서를 설정하는 데 인식 된 (현재는 &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;피할 수는&lt;/a&gt; 있지만) 비용과 기술적 인 어려움을 고려할 때 일부 개발자는 보안되지 않은 와이어를 통해 일반 텍스트 로그인을 전달하지 않기 위해 자체 브라우저 내 해싱 또는 암호화 체계를 롤업하려는 유혹을받습니다.</target>
        </trans-unit>
        <trans-unit id="40da55bdbda9f92b4cb162d0fa0d30ae87ad8e57" translate="yes" xml:space="preserve">
          <source>HTTP basic authentication</source>
          <target state="translated">HTTP 기본 인증</target>
        </trans-unit>
        <trans-unit id="a7a3e467744831641be2fe6f9f61a5eb1eab7a0c" translate="yes" xml:space="preserve">
          <source>Hashes by themselves are also insecure. For instance, identical passwords mean identical hashes--this makes hash lookup tables an effective way of cracking lots of passwords at once. Instead, store the &lt;strong&gt;salted&lt;/strong&gt; hash. A salt is a string appended to the password prior to hashing - use a different (random) salt per user. The salt is a public value, so you can store them with the hash in the database. See &lt;a href=&quot;http://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right&quot;&gt;here&lt;/a&gt; for more on this.</source>
          <target state="translated">해시 자체도 안전하지 않습니다. 예를 들어, 동일한 암호는 동일한 해시를 의미하므로 해시 조회 테이블은 많은 암호를 한 번에 크래킹하는 효과적인 방법입니다. 대신 &lt;strong&gt;소금에 절인&lt;/strong&gt; 해시를 저장하십시오. 솔트는 해싱하기 전에 비밀번호에 추가되는 문자열입니다. 사용자마다 다른 (임의의) 솔트를 사용하십시오. 솔트는 공개 값이므로 해시와 함께 데이터베이스에 저장할 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;http://www.codeproject.com/Articles/704865/Salted-Password-Hashing-Doing-it-Right&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd6ee87981c059ffe762f87d9835ba6d3ad5cb0a" translate="yes" xml:space="preserve">
          <source>Here, the best practice would be &lt;strong&gt;logging the number of failed logins, system-wide&lt;/strong&gt;, and using a running average of your site's bad-login frequency as the basis for an upper limit that you then impose on all users.</source>
          <target state="translated">여기서 가장 좋은 방법은 &lt;strong&gt;시스템 전체&lt;/strong&gt; 에서 &lt;strong&gt;실패한 로그인 수를 기록하고&lt;/strong&gt; 모든 사용자에게 부과하는 상한의 기준으로 사이트의 잘못된 로그인 빈도의 평균 실행을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fd97645c83ca1f0b0cb1e045d47f5c3cb7a28597" translate="yes" xml:space="preserve">
          <source>How to log in</source>
          <target state="translated">로그인하는 방법</target>
        </trans-unit>
        <trans-unit id="2e2ac11edd26bbdc67b5b782fb1bfa9b679a85ca" translate="yes" xml:space="preserve">
          <source>How to log out</source>
          <target state="translated">로그 아웃하는 방법</target>
        </trans-unit>
        <trans-unit id="b242ffd64cf4e91fee323fe99df436b843031995" translate="yes" xml:space="preserve">
          <source>How to remain logged in</source>
          <target state="translated">로그인 상태를 유지하는 방법</target>
        </trans-unit>
        <trans-unit id="2a1b49d2e2c078dfbf427749a4c26aa10b7064f2" translate="yes" xml:space="preserve">
          <source>How to store passwords</source>
          <target state="translated">비밀번호를 저장하는 방법</target>
        </trans-unit>
        <trans-unit id="396f12c235f8be0ad58a8e4b445d0acff62942ae" translate="yes" xml:space="preserve">
          <source>However, I do not recommend this, except for public, low-value services. This is an issue with some of the other answers above - do not try an re-implement server-side authentication mechanisms - this problem has been solved and is supported by most major browsers. Do not use cookies. Do not store anything in your own hand-rolled database. Just ask, per request, if the request is authenticated. Everything else should be supported by configuration and third-party trusted software.</source>
          <target state="translated">그러나 저렴한 공개 서비스를 제외하고는 이것을 권장하지 않습니다. 이것은 위의 다른 답변 중 일부와 관련된 문제입니다. 서버 측 인증 메커니즘을 다시 구현하지 마십시오.이 문제는 대부분의 주요 브라우저에서 해결되었으며 지원됩니다. 쿠키를 사용하지 마십시오. 자신의 수동 롤 데이터베이스에는 아무 것도 저장하지 마십시오. 요청이 인증되면 요청마다 요청하십시오. 다른 모든 구성 및 타사 신뢰할 수있는 소프트웨어에서 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="35336df7d00b75c54f5da32119b429c80525c3f8" translate="yes" xml:space="preserve">
          <source>I already mentioned why you should &lt;strong&gt;never use security questions&lt;/strong&gt; for handling forgotten/lost user passwords; it also goes without saying that you should never e-mail users their actual passwords. There are at least two more all-too-common pitfalls to avoid in this field:</source>
          <target state="translated">잊어 버린 / 분실 된 사용자 암호를 처리 &lt;strong&gt;하기&lt;/strong&gt; 위해 &lt;strong&gt;보안 질문&lt;/strong&gt; 을 &lt;strong&gt;사용&lt;/strong&gt; 해서는 안되는 이유를 이미 언급했습니다. 또한 사용자에게 실제 비밀번호를 이메일로 보내면 안된다는 것은 말할 것도 없습니다. 이 분야에서는 피해야 할 함정이 두 개 이상 있습니다.</target>
        </trans-unit>
        <trans-unit id="359c53abe1e06714c19e031a3d67bc68ab3e0368" translate="yes" xml:space="preserve">
          <source>I also posted a question with &lt;a href=&quot;https://stackoverflow.com/questions/479233/what-is-the-best-distributed-brute-force-countermeasure&quot;&gt;more details and a really good discussion of how to avoid tricky pitfals&lt;/a&gt; in fending off distributed brute force attacks</source>
          <target state="translated">또한 분산 된 무차별 대입 공격을 &lt;a href=&quot;https://stackoverflow.com/questions/479233/what-is-the-best-distributed-brute-force-countermeasure&quot;&gt;막기 위해 까다로운 함정을 피하는 방법에 대한 자세한 내용과 정말 좋은 토론이&lt;/a&gt; 있는 질문을 게시했습니다.</target>
        </trans-unit>
        <trans-unit id="552c8b130191ea16fccf86d6a9186258c92a2d85" translate="yes" xml:space="preserve">
          <source>I believe this can also be used just fine with a login/authentication form.</source>
          <target state="translated">나는 이것이 로그인 / 인증 양식으로도 잘 사용될 수 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="58d1e47f90e80b52a252896eadaa4328f0a6b31f" translate="yes" xml:space="preserve">
          <source>I call it the &lt;strong&gt;Dummy Field&lt;/strong&gt; (though I haven't invented this so don't credit me).</source>
          <target state="translated">나는 그것을 &lt;strong&gt;더미 필드&lt;/strong&gt; 라고 부릅니다 (그러나 나는 이것을 발명하지 않았기 때문에 저를 신용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="51d616a1c6a5e687603e42051a1947e650345bcd" translate="yes" xml:space="preserve">
          <source>I do not think the above answer is &quot;wrong&quot; but there are large areas of authentication that are not touched upon (or rather the emphasis is on &quot;how to implement cookie sessions&quot;, not on &quot;what options are available and what are the trade-offs&quot;.</source>
          <target state="translated">위의 답변이 &quot;틀린 것&quot;이라고 생각하지는 않지만 다루지 않는 넓은 인증 영역이 있습니다 (또는 &quot;쿠키 세션을 구현하는 방법&quot;에 중점을두고 있습니다. &quot;사용 가능한 옵션 및 거래는 무엇입니까?&quot; -오프 &quot;.</target>
        </trans-unit>
        <trans-unit id="234454f3c20ac324649e33650f7a78ebefe0cf90" translate="yes" xml:space="preserve">
          <source>I dont't know whether it was best to answer this as an answer or as a comment. I opted for the first option.</source>
          <target state="translated">나는 이것이 대답이나 의견으로 대답하는 것이 가장 좋은지 모르겠습니다. 첫 번째 옵션을 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="090605f11afa494248191955e5ee70233bd277e2" translate="yes" xml:space="preserve">
          <source>I just thought I'd share this solution that I found to be working just fine.</source>
          <target state="translated">방금 잘 작동하는 것으로 밝혀진이 솔루션을 공유한다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="846fe96011a7002d9135a22ab8068ef55c9146e6" translate="yes" xml:space="preserve">
          <source>I used this method on a guestbook in combination with &lt;a href=&quot;http://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt;, and I haven't seen a single spam post since. I had used a CAPTCHA-only solution before, but eventually, it resulted in about five spam posts every hour. Adding the dummy field in the form has stopped (at least until now) all the spam from appearing.</source>
          <target state="translated">이 방법을 방명록과 함께 &lt;a href=&quot;http://en.wikipedia.org/wiki/CAPTCHA&quot;&gt;CAPTCHA&lt;/a&gt; 와 함께 사용했는데 그 이후로 단일 스팸 게시물을 보지 못했습니다. 전에는 보안 문자 전용 솔루션을 사용했지만 결국에는 매시간 약 5 개의 스팸 게시물이 발생했습니다. 양식에 더미 필드를 추가하면 모든 스팸이 (최소한 지금까지) 중지되었습니다.</target>
        </trans-unit>
        <trans-unit id="b6d4b92eeb3592863419cde2a6152c7de7c64e87" translate="yes" xml:space="preserve">
          <source>I will go ahead and mention Mozilla&amp;rsquo;s proposed &lt;a href=&quot;https://browserid.org/&quot;&gt;BrowserID&lt;/a&gt; (or perhaps more precisely, the &lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest&quot;&gt;Verified Email Protocol&lt;/a&gt;) in the spirit of finding an upgrade path to better approaches to authentication in the future.</source>
          <target state="translated">앞으로 더 나은 인증 방법에 대한 업그레이드 경로를 찾기 위해 Mozilla의 제안 된 &lt;a href=&quot;https://browserid.org/&quot;&gt;BrowserID&lt;/a&gt; (또는보다 정확하게는 &lt;a href=&quot;https://wiki.mozilla.org/Identity/Verified_Email_Protocol/Latest&quot;&gt;Verified Email Protocol&lt;/a&gt; )를 언급 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="bc9c11bf6ed7710b34884d2f00080ae405fc5189" translate="yes" xml:space="preserve">
          <source>I would like to add one very important comment: -</source>
          <target state="translated">매우 중요한 의견을 하나 추가하고 싶습니다 :-</target>
        </trans-unit>
        <trans-unit id="0ca82fef2a32b5097bc2b8a6714ceaa59492e5aa" translate="yes" xml:space="preserve">
          <source>I&amp;rsquo;ll summarize it this way:</source>
          <target state="translated">다음과 같이 요약하겠습니다.</target>
        </trans-unit>
        <trans-unit id="083a429183d693f1046288e656d2da6a9a2af83c" translate="yes" xml:space="preserve">
          <source>I'd like to add one suggestion I've used, based on defense in depth. You don't need to have the same auth&amp;amp;auth system for admins as regular users. You can have a separate login form on a separate url executing separate code for requests that will grant high privileges. This one can make choices that would be a total pain to regular users. One such that I've used is to actually scramble the login URL for admin access and email the admin the new URL. Stops any brute force attack right away as your new URL can be arbitrarily difficult (very long random string) but your admin user's only inconvenience is following a link in their email. The attacker no longer knows where to even POST to.</source>
          <target state="translated">심층 방어를 기반으로 사용한 제안 하나를 추가하고 싶습니다. 관리자에게는 일반 사용자와 동일한 인증 및 인증 시스템이 필요하지 않습니다. 높은 권한을 부여하는 요청에 대해 별도의 코드를 실행하는 별도의 URL에 별도의 로그인 양식을 가질 수 있습니다. 이것은 일반 사용자에게 총 고통이 될 선택을 할 수 있습니다. 내가 사용한 한 가지 방법은 실제로 관리자 액세스를 위해 로그인 URL을 스크램블하고 관리자에게 새 URL을 이메일로 보내는 것입니다. 새 URL이 임의로 어려울 수 있으므로 (매우 긴 임의의 문자열) 무차별 대입 공격을 즉시 중지하지만 관리자의 유일한 불편은 이메일의 링크를 따르는 것입니다. 공격자는 더 이상 POST 할 위치를 알지 못합니다.</target>
        </trans-unit>
        <trans-unit id="f7d467c663e66cb7f264b6751a1994846cbe912f" translate="yes" xml:space="preserve">
          <source>If at all possible, make sure the session cookie has the secure and HTTP Only flags set when sent to the browser. The HttpOnly flag provides some protection against the cookie being read through XSS attack. The secure flag ensures that the cookie is only sent back via HTTPS, and therefore protects against network sniffing attacks. The value of the cookie should not be predictable. Where a cookie referencing a non-existent session is presented, its value should be replaced immediately to prevent &lt;a href=&quot;https://www.owasp.org/index.php/Session_fixation&quot;&gt;session fixation&lt;/a&gt;.</source>
          <target state="translated">가능하면 세션 쿠키가 브라우저로 전송 될 때 보안 및 HTTP 전용 플래그가 설정되어 있는지 확인하십시오. HttpOnly 플래그는 XSS 공격을 통해 쿠키가 읽히는 것을 방지합니다. 보안 플래그는 쿠키가 HTTPS를 통해서만 다시 전송되도록하여 네트워크 스니핑 공격으로부터 보호합니다. 쿠키의 가치는 예측할 수 없어야합니다. 존재하지 않는 세션을 참조하는 쿠키가 제공되는 경우 &lt;a href=&quot;https://www.owasp.org/index.php/Session_fixation&quot;&gt;세션 고정&lt;/a&gt; 을 방지하기 위해 해당 값을 즉시 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="05a40820406ffb4581e8e6750a3ac4b5784853e0" translate="yes" xml:space="preserve">
          <source>If the connection between the client and server is unencrypted, everything you do is &lt;a href=&quot;https://stackoverflow.com/questions/14907581/ssl-and-man-in-the-middle-misunderstanding&quot;&gt;vulnerable to man-in-the-middle attacks&lt;/a&gt;. An attacker could replace the incoming javascript to break the hashing or send all credentials to their server, they could listen to client responses and impersonate the users perfectly, etc. etc. SSL with trusted Certificate Authorities is designed to prevent MitM attacks.</source>
          <target state="translated">클라이언트와 서버 간의 연결이 암호화되지 않은 경우 수행하는 모든 작업이 &lt;a href=&quot;https://stackoverflow.com/questions/14907581/ssl-and-man-in-the-middle-misunderstanding&quot;&gt;MITM (Man-in-the-Middle) 공격에 취약&lt;/a&gt; 합니다. 공격자는 들어오는 자바 스크립트를 교체하여 해시를 중단하거나 모든 자격 증명을 서버로 보낼 수 있으며, 클라이언트 응답을 듣고 사용자를 완벽하게 가장 할 수 있습니다. 등 신뢰할 수있는 인증 기관이있는 SSL은 MitM 공격을 방지하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="a005965818e2683004bec583de84ca2d5c7d5f8f" translate="yes" xml:space="preserve">
          <source>If you are unfamiliar with session data, here's how it works: A single randomly-generated string is stored in an expiring cookie and used to reference a collection of data - the session data - which is stored on the server. If you are using an MVC framework, this is undoubtedly handled already.</source>
          <target state="translated">세션 데이터에 익숙하지 않은 경우 작동 방식은 다음과 같습니다. 무작위로 생성 된 단일 문자열이 만료 쿠키에 저장되고 서버에 저장된 세션 데이터 인 세션 데이터를 참조하는 데 사용됩니다. MVC 프레임 워크를 사용하는 경우 의심 할 여지없이 이미 처리되었습니다.</target>
        </trans-unit>
        <trans-unit id="9bf51661f29e2e2b97a777af17d93aa3c2ad75df" translate="yes" xml:space="preserve">
          <source>If you don't have the time to look through the tables in that link, here's the list of them:</source>
          <target state="translated">해당 링크의 테이블을 살펴볼 시간이 없다면 다음 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9f82947c6f8dcc354957eb7fe3f008ee9248d9d" translate="yes" xml:space="preserve">
          <source>If you want to autologin your users, you can set a persistent cookie, but it should be distinct from a full-session cookie. You can set an additional flag that the user has auto-logged in, and needs to log in for real for sensitive operations. This is popular with shopping sites that want to provide you with a seamless, personalized shopping experience but still protect your financial details. For example, when you return to visit Amazon, they show you a page that looks like you're logged in, but when you go to place an order (or change your shipping address, credit card etc.), they ask you to confirm your password.</source>
          <target state="translated">사용자를 자동 로그인하려면 영구 쿠키를 설정할 수 있지만 전체 세션 쿠키와는 구별되어야합니다. 사용자가 자동 ​​로그인했으며 민감한 작업을 위해 실제 로그인해야하는 추가 플래그를 설정할 수 있습니다. 이는 완벽하고 개인화 된 쇼핑 경험을 제공하지만 여전히 재무 정보를 보호하려는 쇼핑 사이트에서 인기가 있습니다. 예를 들어, 아마존 방문으로 돌아 가면 로그인 한 것처럼 보이는 페이지가 표시되지만 주문을하려고 할 때 (또는 배송 주소, 신용 카드 등 변경) 확인 요청을합니다. 너의 비밀번호.</target>
        </trans-unit>
        <trans-unit id="2a3aa3e666ad28239fd17e0d9ca973882c20bb50" translate="yes" xml:space="preserve">
          <source>In essence, the only &lt;strong&gt;practical&lt;/strong&gt; way to protect against wiretapping/packet sniffing during login is by using HTTPS or another certificate-based encryption scheme (for example, &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLS&lt;/a&gt;) or a proven &amp;amp; tested challenge-response scheme (for example, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;Diffie-Hellman&lt;/a&gt;-based SRP). &lt;em&gt;Any other method can be easily circumvented&lt;/em&gt; by an eavesdropping attacker.</source>
          <target state="translated">본질적으로 로그인 중에 도청 / 패킷 스니핑을 방지하는 유일한 &lt;strong&gt;실질적인&lt;/strong&gt; 방법은 HTTPS 또는 다른 인증서 기반 암호화 체계 (예 : &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLS&lt;/a&gt; ) 또는 검증되고 테스트 된 시도-응답 체계 (예 : &lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;Diffie-Hellman)를 사용하는 것입니다.&lt;/a&gt; 기반 SRP). 도청 공격자가 &lt;em&gt;다른 방법을 쉽게 우회 할 수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2544113bc111cfaa02b8dad7705eb320ec051b0e" translate="yes" xml:space="preserve">
          <source>In short: you just have to insert this into your &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; and check for it to be empty at when validating:</source>
          <target state="translated">간단히 말해서 이것을 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 에 삽입하고 유효성을 검사 할 때 비어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5889d9ac21ea7878fc3980b6f8fb4739068f29ad" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;Remember your password&lt;/strong&gt; forms, an attacker could potentially check a full list of emails and detect which are registered to the system (see link below).</source>
          <target state="translated">&lt;strong&gt;암호 기억&lt;/strong&gt; 양식에서 공격자는 잠재적으로 전체 전자 메일 목록을 확인하고 시스템에 등록 된 전자 메일을 탐지 할 수 있습니다 (아래 링크 참조).</target>
        </trans-unit>
        <trans-unit id="b63daf6854097ee286d453fcdaa4ea9d7d846b17" translate="yes" xml:space="preserve">
          <source>In the end, it's a tradeoff - what is the cost of a security breach vs the cost of implementing more secure approaches. One day, we may see a proper &lt;a href=&quot;http://en.wikipedia.org/wiki/Public-key_infrastructure&quot;&gt;PKI&lt;/a&gt; widely accepted and so no more own rolled authentication forms and databases. One day...</source>
          <target state="translated">결국, 보안 위반 비용과보다 안전한 접근 방식을 구현하는 비용은 트레이드 오프입니다. 언젠가, 우리는 적절한 &lt;a href=&quot;http://en.wikipedia.org/wiki/Public-key_infrastructure&quot;&gt;PKI가&lt;/a&gt; 널리 수용되어 더 이상 자체적으로 롤링 된 인증 양식 및 데이터베이스를 볼 수 없을 것입니다. 어느 날 ...</target>
        </trans-unit>
        <trans-unit id="0635ff3ae1d3558d900b0d72cf905e6930f16a3d" translate="yes" xml:space="preserve">
          <source>Introductory article about storing passwords</source>
          <target state="translated">비밀번호 저장에 대한 소개 기사</target>
        </trans-unit>
        <trans-unit id="5e735dc6ff9a579700296dcebbafce05242f5c1e" translate="yes" xml:space="preserve">
          <source>It should include topics such as:</source>
          <target state="translated">다음과 같은 주제를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6420257e778a00afc297ad00fbecf2ebe7c8b6a" translate="yes" xml:space="preserve">
          <source>It should not include things like:</source>
          <target state="translated">다음과 같은 것들을 포함해서는 안됩니다 :</target>
        </trans-unit>
        <trans-unit id="b1ce4421333cb720d377733655d21a7298f4e002" translate="yes" xml:space="preserve">
          <source>It takes &lt;em&gt;virtually no time&lt;/em&gt; to crack a weak password, even if you're cracking it with an abacus</source>
          <target state="translated">주판으로 해독하더라도 약한 암호를 해독하는 데 &lt;em&gt;거의 시간&lt;/em&gt; 이 걸리지 &lt;em&gt;않습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f95b8ec5420157ff1e1b91b761a8ebd2d92a665b" translate="yes" xml:space="preserve">
          <source>It takes &lt;em&gt;virtually no time&lt;/em&gt; to crack an alphanumeric 9-character password if it is &lt;strong&gt;case insensitive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;대소 문자를 구분하지&lt;/strong&gt; 않으면 영숫자 9 자리 비밀번호를 해독하는 데 &lt;em&gt;거의 시간&lt;/em&gt; 이 걸리지 &lt;strong&gt;않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2183ae63555a89f9b9da5626b8c677c779b62650" translate="yes" xml:space="preserve">
          <source>It takes &lt;em&gt;virtually no time&lt;/em&gt; to crack an intricate, symbols-and-letters-and-numbers, upper-and-lowercase password if it is &lt;strong&gt;less than 8 characters long&lt;/strong&gt; (a desktop PC can search the entire keyspace up to 7 characters in a matter of days or even hours)</source>
          <target state="translated">암호 &lt;strong&gt;가 8 자 미만인&lt;/strong&gt; 경우 복잡한 기호 및 문자, 숫자, 대소 문자 암호를 해독하는 데 &lt;em&gt;거의 시간&lt;/em&gt; 이 걸리지 &lt;em&gt;않습니다&lt;/em&gt; (데스크탑 PC는 문제에서 최대 7 자까지 전체 키 공간을 검색 할 수 있음) 며칠 또는 몇 시간)</target>
        </trans-unit>
        <trans-unit id="ca83a47062492ece2469dd660cd19ba05f1e6542" translate="yes" xml:space="preserve">
          <source>Just as an aside, more advanced attackers will try to circumvent login throttling by 'spreading their activities':</source>
          <target state="translated">더 나아가, 고급 공격자들은 '활동 확산'을 통해 로그인 제한을 피하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="454c33180f12a0ab4b94d928089179f2810d2e55" translate="yes" xml:space="preserve">
          <source>Kerberos and SPNEGO - single sign-on mechanisms with a trusted third party - basically the user verifies against a trusted third party. (NB this is not in any way the not to be trusted &lt;a href=&quot;http://en.wikipedia.org/wiki/OAuth&quot;&gt;OAuth&lt;/a&gt;)</source>
          <target state="translated">신뢰할 수있는 타사와의 싱글 사인온 메커니즘 인 Kerberos 및 SPNEGO는 기본적으로 사용자가 신뢰할 수있는 타사에 대해 확인합니다. (NB는 &lt;a href=&quot;http://en.wikipedia.org/wiki/OAuth&quot;&gt;OAuth를&lt;/a&gt; 신뢰하지 않아야합니다.)</target>
        </trans-unit>
        <trans-unit id="ef605fb60b2983e8337bddb62501975987044821" translate="yes" xml:space="preserve">
          <source>Know that CAPTCHA implementations are not created alike; they often aren't human-solvable, most of them are actually ineffective against bots, all of them are ineffective against cheap third-world labor (according to &lt;a href=&quot;https://en.wikipedia.org/wiki/OWASP&quot;&gt;OWASP&lt;/a&gt;, the current sweatshop rate is $12 per 500 tests), and some implementations may be technically illegal in some countries (see &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP Authentication Cheat Sheet&lt;/a&gt;). If you must use a CAPTCHA, use Google's &lt;a href=&quot;https://en.wikipedia.org/wiki/ReCAPTCHA&quot;&gt;reCAPTCHA&lt;/a&gt;, since it is OCR-hard by definition (since it uses already OCR-misclassified book scans) and tries very hard to be user-friendly.</source>
          <target state="translated">보안 문자 구현은 동일하게 작성되지 않습니다. 그들은 종종 인간이 해결할 수 없으며, 대부분은 실제로 봇에 대해 비효율적이며, 모두 저렴한 3 차 노동 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/OWASP&quot;&gt;OWASP&lt;/a&gt; 에 따르면 현재 땀받이 비율은 500 테스트 당 12 달러)에 비효율적이며 일부 구현은 일부 국가에서는 기술적으로 불법입니다 ( &lt;a href=&quot;https://www.owasp.org/index.php/Authentication_Cheat_Sheet&quot;&gt;OWASP 인증 치트 시트&lt;/a&gt; 참조). 보안 문자를 사용해야하는 경우 Google &lt;a href=&quot;https://en.wikipedia.org/wiki/ReCAPTCHA&quot;&gt;reCAPTCHA를&lt;/a&gt; 사용하십시오. Google reCAPTCHA 는 정의상 OCR이 어렵 기 때문에 (이미 OCR에서 잘못 분류 된 도서 스캔을 사용하기 때문에) 사용자 친화적 인 시도를하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="a204cab302bc515068a3e7ff919f172312b7a0da" translate="yes" xml:space="preserve">
          <source>List of external resources</source>
          <target state="translated">외부 자원 목록</target>
        </trans-unit>
        <trans-unit id="800d50f9971121d60ff4213c83ab585dc8eeb2d2" translate="yes" xml:space="preserve">
          <source>MUST-READ LINKS About Web Authentication</source>
          <target state="translated">웹 인증에 대한 필수 링크</target>
        </trans-unit>
        <trans-unit id="e39ad0433ee22ae9d29fea44a1452bb36e98f70f" translate="yes" xml:space="preserve">
          <source>Managing cookies (including recommended settings)</source>
          <target state="translated">쿠키 관리 (권장 설정 포함)</target>
        </trans-unit>
        <trans-unit id="13f082e2a62294764b183257e5521811d1761c76" translate="yes" xml:space="preserve">
          <source>Many corporations deploy &quot;internal use only&quot; websites which are, effectively, &quot;corporate applications&quot; that happen to have been implemented through URLs. These URLs can &lt;em&gt;(supposedly ...)&lt;/em&gt; only be resolved within &quot;the company's internal network.&quot; &lt;em&gt;(Which network magically includes all VPN-connected 'road warriors.')&lt;/em&gt;</source>
          <target state="translated">많은 회사에서 URL을 통해 구현 된 &quot;기업 응용 프로그램&quot;인 &quot;내부 전용&quot;웹 사이트를 배포합니다. 이 URL은 &quot;회사 내부 네트워크&quot;내에서만 해결할 수 있습니다 &lt;em&gt;(아마도 ...)&lt;/em&gt; . &lt;em&gt;(VPN에 연결된 모든 '도로 전사'를 마법으로 포함하는 네트워크는 무엇입니까?)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d428631e07ab70149afe871ed89abba6b41c7b09" translate="yes" xml:space="preserve">
          <source>Mozilla is a nonprofit with &lt;a href=&quot;http://www.mozilla.org/about/manifesto.en.html&quot;&gt;values&lt;/a&gt; that align well with finding good solutions to this problem.</source>
          <target state="translated">모질라는이 문제에 대한 좋은 해결책을 찾는 것과 잘 어울리는 비영리 단체입니다.</target>
        </trans-unit>
        <trans-unit id="f78a34f17d1960af584815ea7b1a57f63ea0b523" translate="yes" xml:space="preserve">
          <source>Mozilla offers their own service to act like such a trusted third party. Service Providers (that is, Relying Parties) implementing the Verified Email Protocol may choose to trust Mozilla's assertions or not. Mozilla&amp;rsquo;s service verifies users&amp;rsquo; account ownership using the conventional means of sending an email with a confirmation link.</source>
          <target state="translated">Mozilla는 신뢰할 수있는 타사처럼 행동하기 위해 자체 서비스를 제공합니다. 검증 된 이메일 프로토콜을 구현하는 서비스 제공 업체 (즉, 신뢰 당사자)는 Mozilla의 주장을 신뢰할지 여부를 선택할 수 있습니다. Mozilla의 서비스는 확인 링크가 포함 된 전자 메일을 보내는 일반적인 방법을 사용하여 사용자 계정 소유권을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="498fc0cb3210a89a93612a59292b4e349dedcfe9" translate="yes" xml:space="preserve">
          <source>My favourite rule in regards to authentication systems: use passphrases, not passwords. Easy to remember, hard to crack.
More info: &lt;a href=&quot;http://www.codinghorror.com/blog/2005/07/passwords-vs-pass-phrases.html&quot;&gt;Coding Horror: Passwords vs. Pass Phrases&lt;/a&gt;</source>
          <target state="translated">인증 시스템과 관련하여 내가 가장 좋아하는 규칙은 암호가 아닌 암호를 사용하는 것입니다. 기억하기 쉽고 깨지기 어렵다. 추가 정보 : &lt;a href=&quot;http://www.codinghorror.com/blog/2005/07/passwords-vs-pass-phrases.html&quot;&gt;코딩 공포 : 암호와 암호 문구&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46d5ca1861ce7684ad68bb0fececc25f88365029" translate="yes" xml:space="preserve">
          <source>My suggested edits/answers are</source>
          <target state="translated">내가 제안한 수정 / 답변은</target>
        </trans-unit>
        <trans-unit id="a02f8183c755dd3e7c9319a28b14d5b05917066b" translate="yes" xml:space="preserve">
          <source>Never store passwords in a database!</source>
          <target state="translated">데이터베이스에 비밀번호를 저장하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="c3cad7a29e678534156a1c67fb73684d81f0154f" translate="yes" xml:space="preserve">
          <source>Of course, if you are willing to get a little bit impractical, you could also employ some form of two-factor authentication scheme (e.g. the Google Authenticator app, a physical 'cold war style' codebook, or an RSA key generator dongle). If applied correctly, this could work even with an unsecured connection, but it's hard to imagine that a dev would be willing to implement two-factor auth but not SSL.</source>
          <target state="translated">물론 약간 비실용적이라면 기꺼이 어떤 형태의 2 단계 인증 체계 (예 : Google OTP 앱, 실제 '콜드 워 스타일'코드북 또는 RSA 키 생성기 동글)를 사용할 수도 있습니다. 올바르게 적용하면 보안되지 않은 연결에서도 작동 할 수 있지만 개발자가 SSL을 사용하지 않고 2 단계 인증을 기꺼이 구현한다고 상상하기는 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="40746c6aaf7e82f6f6299e3405c2afa45a1ae213" translate="yes" xml:space="preserve">
          <source>Of course, some systems can't afford to have &lt;em&gt;any&lt;/em&gt; accounts hacked; for such systems, there is no way you can justify having persistent logins.</source>
          <target state="translated">물론 일부 시스템 &lt;em&gt;에서는&lt;/em&gt; 계정을 해킹 할 여유가 &lt;em&gt;없습니다&lt;/em&gt; . 이러한 시스템의 경우 지속적인 로그인이 필요하다는 것을 정당화 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d9bfdd2c36a6c3abb8c87cb643353651b30d90ae" translate="yes" xml:space="preserve">
          <source>Okay, so maybe the list isn't the &lt;em&gt;canonical&lt;/em&gt; list of most common passwords on &lt;em&gt;any&lt;/em&gt; system &lt;em&gt;anywhere ever&lt;/em&gt;, but it's a good indication of how poorly people will choose their passwords when there is no enforced policy in place. Plus, the list looks frighteningly close to home when you compare it to publicly available analyses of recently stolen passwords.</source>
          <target state="translated">아마도이 목록은 &lt;em&gt;어느&lt;/em&gt; 시스템 &lt;em&gt;에서나&lt;/em&gt; 가장 일반적인 암호의 &lt;em&gt;정식&lt;/em&gt; 목록이 아닐 수도 있지만, 시행되는 정책이 없을 때 사람들이 암호를 얼마나 잘 선택하지 않는지를 나타내는 좋은 증거 일 것입니다. 또한 최근에 도난당한 암호를 공개적으로 사용 가능한 분석과 비교하면 목록이 집과 매우 흡사하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="dab5116e744a1fc1ff720960059dcea9695942af" translate="yes" xml:space="preserve">
          <source>Once the server has verified the login and password against your user database and found a match, the system needs a way to remember that the browser has been authenticated. This fact should only ever be stored server side in the session data.</source>
          <target state="translated">서버가 사용자 데이터베이스에 대한 로그인 및 비밀번호를 확인하고 일치하는 것을 발견하면 시스템은 브라우저가 인증되었음을 기억하는 방법이 필요합니다. 이 사실은 세션 데이터에 서버 측에만 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="472334b926db37e8b1ba9a091cdc0aa12469e6de" translate="yes" xml:space="preserve">
          <source>OpenID</source>
          <target state="translated">OpenID</target>
        </trans-unit>
        <trans-unit id="43d608c39c9af2e6d0b1f96b90ac641933e3c53f" translate="yes" xml:space="preserve">
          <source>Or, an increasing delay with a fixed upper bound, like:</source>
          <target state="translated">또는 다음과 같이 고정 된 상한으로 지연이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="ee98feac3f48bf9954396afdbaec912b4b30373b" translate="yes" xml:space="preserve">
          <source>PART I: How To Log In</source>
          <target state="translated">1 부 : 로그인 방법</target>
        </trans-unit>
        <trans-unit id="373bd2e0e8256779823fc6ab870ebbbd9fc5217a" translate="yes" xml:space="preserve">
          <source>PART II: How To Remain Logged In - The Infamous &quot;Remember Me&quot; Checkbox</source>
          <target state="translated">파트 II : 로그인 상태를 유지하는 방법-악명 높은 &quot;기억하기&quot;확인란</target>
        </trans-unit>
        <trans-unit id="8dffe7fbee47b5816874a7c779754cfc07bb7637" translate="yes" xml:space="preserve">
          <source>PART III: Using Secret Questions</source>
          <target state="translated">3 부 : 비밀 질문 사용</target>
        </trans-unit>
        <trans-unit id="8dc18f138173394995a3a25ea9f93f0d9276d9d7" translate="yes" xml:space="preserve">
          <source>PART IV: Forgotten Password Functionality</source>
          <target state="translated">IV 부 : 잊어 버린 암호 기능</target>
        </trans-unit>
        <trans-unit id="1bc7c0f4d41ebaa82c69b8f3e030406e7a778c30" translate="yes" xml:space="preserve">
          <source>PART V: Checking Password Strength</source>
          <target state="translated">파트 V : 비밀번호 강도 확인</target>
        </trans-unit>
        <trans-unit id="f78f54dcfe36e53595355daeea59a314d68113c3" translate="yes" xml:space="preserve">
          <source>PART VI: Much More - Or: Preventing Rapid-Fire Login Attempts</source>
          <target state="translated">6 부 : 훨씬 더-또는 : 빠른 실행 로그인 시도 방지</target>
        </trans-unit>
        <trans-unit id="d09120b5dd85861867d30d321dcb24147dc5181d" translate="yes" xml:space="preserve">
          <source>PART VII: Distributed Brute Force Attacks</source>
          <target state="translated">제 7 부 : 분산 된 무차별 대입 공격</target>
        </trans-unit>
        <trans-unit id="3dfbaba91066aa51a3ed68e104660765f9263364" translate="yes" xml:space="preserve">
          <source>PART VIII: Two-Factor Authentication and Authentication Providers</source>
          <target state="translated">제 8 부 : 2 단계 인증 및 인증 제공자</target>
        </trans-unit>
        <trans-unit id="fca31875c99e7a759095453f43a17f8d41cc70b3" translate="yes" xml:space="preserve">
          <source>Password cracking</source>
          <target state="translated">비밀번호 크래킹</target>
        </trans-unit>
        <trans-unit id="146c22ca524a64487e2cc7bae8bcd42354c41547" translate="yes" xml:space="preserve">
          <source>Persistent Login Cookies (&quot;remember me&quot; functionality) are a danger zone; on the one hand, they are entirely as safe as conventional logins when users understand how to handle them; and on the other hand, they are an enormous security risk in the hands of careless users, who may use them on public computers and forget to log out, and who may not know what browser cookies are or how to delete them.</source>
          <target state="translated">영구 로그인 쿠키 ( &quot;기억하기&quot;기능)는 위험 영역입니다. 한편으로, 사용자가 로그인 방법을 이해할 때 기존 로그인보다 안전합니다. 반면에, 부주의 한 사용자에게는 공개 보안 컴퓨터에서 사용하고 로그 아웃하는 것을 잊어 버릴 수 있으며 브라우저 쿠키가 무엇인지 또는 쿠키를 삭제하는 방법을 모를 수있는 사용자에게는 엄청난 보안 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4deb1845003254bce090e7dce697fed2deca1d3f" translate="yes" xml:space="preserve">
          <source>Personal knowledge questions for fallback authentication: Security questions in the era of Facebook (very readable Berkeley research paper)</source>
          <target state="translated">대체 인증에 대한 개인 지식 질문 : Facebook 시대의 보안 질문 (매우 읽기 쉬운 Berkeley 연구 논문)</target>
        </trans-unit>
        <trans-unit id="8715dbe3e22e6a227a3a03c6e99bbe78ee4654ac" translate="yes" xml:space="preserve">
          <source>Personally, I like persistent logins for the websites I visit on a regular basis, but I know how to handle them safely. If you are positive that your users know the same, you can use persistent logins with a clean conscience. If not - well, then you may subscribe to the philosophy that users who are careless with their login credentials brought it upon themselves if they get hacked. It's not like we go to our user's houses and tear off all those facepalm-inducing Post-It notes with passwords they have lined up on the edge of their monitors, either.</source>
          <target state="translated">개인적으로 나는 정기적으로 방문하는 웹 사이트에 대한 지속적인 로그인을 좋아하지만 안전하게 처리하는 방법을 알고 있습니다. 사용자가 동일한 정보를 알고 있다고 확신하는 경우, 양심을 유지하면서 지속적인 로그인을 사용할 수 있습니다. 그렇지 않은 경우, 로그인 자격 증명을 부주의하게 사용하는 사용자가 해킹을 당했을 때 스스로 가져 왔다는 철학에 가입 할 수 있습니다. 그것은 우리가 사용자의 집에 가서 모니터 가장자리에 줄을 지어 암호가있는 얼굴을 유발하는 Post-It 노트를 모두 찢어 버리는 것과는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b5bc9ae9abb000e507efbc7f604f75840ed71637" translate="yes" xml:space="preserve">
          <source>Personally, I tend to find CAPTCHAS annoying, and use them only as a last resort when a user has failed to log in a number of times and throttling delays are maxed out. This will happen rarely enough to be acceptable, and it strengthens the system as a whole.</source>
          <target state="translated">개인적으로, 나는 보안 문자를 성가 시게하는 경향이 있으며, 사용자가 여러 번 로그인하지 못하고 조절 지연이 최대가 될 때 마지막 수단으로 만 사용합니다. 이는 수용 할 수 없을 정도로 거의 발생하지 않으며 시스템 전체를 강화합니다.</target>
        </trans-unit>
        <trans-unit id="e87d5138425a2b5a37293950847a50aac1982132" translate="yes" xml:space="preserve">
          <source>Please help us by:</source>
          <target state="translated">우리를 도와주세요 :</target>
        </trans-unit>
        <trans-unit id="67d1467cdb0013316748d8f4abc7d3d3ed3d223d" translate="yes" xml:space="preserve">
          <source>Present a &lt;strong&gt;CAPTCHA&lt;/strong&gt; after N failed attempts (annoying as hell and often ineffective -- but I'm repeating myself here)</source>
          <target state="translated">N 번의 시도가 실패한 후 &lt;strong&gt;보안 문자를&lt;/strong&gt; 제시하십시오 (지루하고 짜증나지만 종종 반복됩니다)</target>
        </trans-unit>
        <trans-unit id="64a7e99339d587e4be9caac89b32728bfc07f27a" translate="yes" xml:space="preserve">
          <source>Rather than picking one user and trying the 50.000 most common passwords (which they can't, because of our throttling), they will pick THE most common password and try it against 50.000 users instead. That way, not only do they get around maximum-attempts measures like CAPTCHAs and login throttling, their chance of success increases as well, since the number 1 most common password is far more likely than number 49.995</source>
          <target state="translated">한 명의 사용자를 선택하고 55,000 개의 가장 일반적인 비밀번호 (스로틀 링으로 인해 사용할 수없는)를 시도하는 대신 가장 일반적인 비밀번호를 선택하고 대신 50.000 명의 사용자에 대해 시도합니다. 이렇게하면 보안 문자 및 로그인 제한과 같은 최대 시도 횟수를 극복 할 수있을뿐만 아니라 가장 일반적인 비밀번호가 49.995보다 훨씬 많기 때문에 성공 가능성도 높아집니다.</target>
        </trans-unit>
        <trans-unit id="d13b08c8870d8a1a7e6f0400242c035b1aa248ea" translate="yes" xml:space="preserve">
          <source>Regarding the Forgotten Password Form, I would add that it is a good idea to equal times between successful and unsucessful queries with some delay function.</source>
          <target state="translated">잊어 버린 암호 양식과 관련하여 지연 기능이있는 성공한 쿼리와 실패한 쿼리 사이의 시간을 동일하게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4de0e7b256b6ff9364d661492733a75f01e5a749" translate="yes" xml:space="preserve">
          <source>Regarding the poing &lt;strong&gt;PART IV: Forgotten Password Functionality&lt;/strong&gt; in the first answer, I would make a point about Timing Attacks.</source>
          <target state="translated">첫 번째 답변의 포인팅 &lt;strong&gt;IV IV : 잊어 버린 암호 기능&lt;/strong&gt; 과 관련하여 타이밍 공격에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="9586ca70862e87cb3f3f00c482403bfa49063bb2" translate="yes" xml:space="preserve">
          <source>Roles and authorization</source>
          <target state="translated">역할 및 권한</target>
        </trans-unit>
        <trans-unit id="c2f60d05179df3c940cc3e88087d3b1e28775f9d" translate="yes" xml:space="preserve">
          <source>SSL/HTTPS encryption</source>
          <target state="translated">SSL / HTTPS 암호화</target>
        </trans-unit>
        <trans-unit id="cda028908c5cf102590df2f37ad3e49bc40adb5c" translate="yes" xml:space="preserve">
          <source>Say your site has had an average of 120 bad logins per day over the past 3 months. Using that (running average), your system might set the global limit to 3 times that -- ie. 360 failed attempts over a 24 hour period. Then, if the total number of failed attempts across all accounts exceeds that number within one day (or even better, monitor the rate of acceleration and trigger on a calculated threshold), it activates system-wide login throttling - meaning short delays for ALL users (still, with the exception of cookie logins and/or backup CAPTCHA logins).</source>
          <target state="translated">지난 3 개월 동안 사이트에서 하루 평균 120 번의 잘못된 로그인이 발생했다고 가정 해 보겠습니다. 이를 사용하여 (평균 실행) 시스템은 전체 한계를 3 배로 설정할 수 있습니다. 24 시간 동안 360 번의 시도가 실패했습니다. 그런 다음 모든 계정에서 실패한 총 시도 횟수가 하루 내에 해당 숫자를 초과하면 (또는 더 나은 경우, 가속 속도를 모니터링하고 계산 된 임계 값에서 트리거) 시스템 전체 로그인 조절을 활성화하여 모든 사용자에게 짧은 지연을 의미합니다 (여전히 쿠키 로그인 및 / 또는 백업 보안 문자 로그인 제외).</target>
        </trans-unit>
        <trans-unit id="976262d7d8f225a98d283e5a7e1b9cb193c18cf0" translate="yes" xml:space="preserve">
          <source>Secret URLs (public &lt;a href=&quot;https://en.wikipedia.org/wiki/Uniform_Resource_Locator&quot;&gt;URL&lt;/a&gt; protected by digest)</source>
          <target state="translated">비밀 URL (다이제스트로 보호되는 공개 &lt;a href=&quot;https://en.wikipedia.org/wiki/Uniform_Resource_Locator&quot;&gt;URL&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="77f6e374d07021931c1f95ca6fd95d57bd175cf9" translate="yes" xml:space="preserve">
          <source>Security questions</source>
          <target state="translated">보안 질문</target>
        </trans-unit>
        <trans-unit id="f96888df9de73f78978c270b888a8ed379132818" translate="yes" xml:space="preserve">
          <source>Security questions are insecure - avoid using them. Why? Anything a security question does, a password does better. Read &lt;strong&gt;&lt;em&gt;PART III: Using Secret Questions&lt;/em&gt;&lt;/strong&gt; in &lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;@Jens Roland answer&lt;/a&gt; here in this wiki.</source>
          <target state="translated">보안 질문은 안전하지 않으므로 사용하지 마십시오. 왜? 보안 질문이 무엇이든 암호가 더 좋습니다. 이 위키에서 &lt;strong&gt;&lt;em&gt;Part III :&lt;/em&gt;&lt;/strong&gt; &lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;@Jens Roland의&lt;/a&gt; &lt;strong&gt;&lt;em&gt;비밀 질문 사용하기를&lt;/em&gt;&lt;/strong&gt; 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="2b50787548079d4d7d7960927c4abf6a9dbcfb40" translate="yes" xml:space="preserve">
          <source>Sending credentials</source>
          <target state="translated">자격 증명 보내기</target>
        </trans-unit>
        <trans-unit id="2e2996d4874beab228575a84252d47ac06b477f1" translate="yes" xml:space="preserve">
          <source>Service Providers may, of course, offer this protocol as an option in addition to any other method(s) of authentication they might wish to offer.</source>
          <target state="translated">물론 서비스 제공 업체는 제공하고자하는 다른 인증 방법 외에이 프로토콜을 옵션으로 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5de7556cf7bd4f9692d5121762b926c377ffd0d" translate="yes" xml:space="preserve">
          <source>Session cookies</source>
          <target state="translated">세션 쿠키</target>
        </trans-unit>
        <trans-unit id="93696b6328cb310229b7e31a446255308241cbe4" translate="yes" xml:space="preserve">
          <source>Since browsers are implicitly trusted (the whole idea of a User Agent is to act on behalf of the User), they can help improve this situation.</source>
          <target state="translated">브라우저는 암시 적으로 신뢰할 수 있기 때문에 (사용자 에이전트의 전체 아이디어는 사용자를 대신하여 행동해야 함)이 상황을 개선하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17da9e369068d05b58adc834c73b72fa8baaef08" translate="yes" xml:space="preserve">
          <source>So ...</source>
          <target state="translated">그래서 ...</target>
        </trans-unit>
        <trans-unit id="8dfb410f25bb9c65cce4be237c8e98eed0a7cb91" translate="yes" xml:space="preserve">
          <source>So if you can't store the password, how do you check that the login+password combination POSTed from the login form is correct? The answer is hashing using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Key_derivation_function&quot;&gt;key derivation function&lt;/a&gt;. Whenever a new user is created or a password is changed, you take the password and run it through a KDF, such as Argon2, bcrypt, scrypt or PBKDF2, turning the cleartext password (&quot;correcthorsebatterystaple&quot;) into a long, random-looking string, which is a lot safer to store in your database. To verify a login, you run the same hash function on the entered password, this time passing in the salt and compare the resulting hash string to the value stored in your database. Argon2, bcrypt and scrypt store the salt with the hash already. Check out this &lt;a href=&quot;https://security.stackexchange.com/a/31846/8340&quot;&gt;article&lt;/a&gt; on sec.stackexchange for more detailed information.</source>
          <target state="translated">비밀번호를 저장할 수없는 경우 로그인 양식에서 게시 된 로그인 + 비밀번호 조합이 올바른지 어떻게 확인합니까? 대답은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Key_derivation_function&quot;&gt;키 파생 함수를&lt;/a&gt; 사용하는 해싱입니다. 새로운 사용자가 생성되거나 비밀번호가 변경 될 때마다 비밀번호를 가져와 Argon2, bcrypt, scrypt 또는 PBKDF2와 같은 KDF를 통해 실행하여 일반 텍스트 비밀번호 ( &quot;correcthorsebatterystaple&quot;)를 길고 무작위로 보이는 문자열로 바꿉니다. 데이터베이스에 저장하는 것이 훨씬 안전합니다. 로그인을 확인하려면 입력 한 비밀번호에 대해 동일한 해시 함수를 실행하십시오. 이번에는 salt를 전달하고 결과 해시 문자열을 데이터베이스에 저장된 값과 비교하십시오. Argon2, bcrypt 및 scrypt는 이미 해시와 함께 소금을 저장합니다. 자세한 내용은 sec.stackexchange에서이 &lt;a href=&quot;https://security.stackexchange.com/a/31846/8340&quot;&gt;기사&lt;/a&gt; 를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9c543295c769b88282780bf3ce124008f98174f5" translate="yes" xml:space="preserve">
          <source>So what can we learn from these numbers? Well, lots, but we can focus on the most important part: the fact that preventing large numbers of rapid-fire successive login attempts (ie. the &lt;em&gt;brute force&lt;/em&gt; attack) really isn't that difficult. But preventing it &lt;em&gt;right&lt;/em&gt; isn't as easy as it seems.</source>
          <target state="translated">그렇다면이 숫자들로부터 무엇을 배울 수 있습니까? 글쎄요, 그러나 우리는 가장 중요한 부분에 집중할 수 있습니다. 많은 수의 신속한 연속 로그인 시도 (예 : &lt;em&gt;무차별 대입&lt;/em&gt; 공격)를 방지하는 것이 그렇게 어렵지 않다는 사실. 그러나 올바르게 방지하는 것은 쉬운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="68e69724334b1e16fdb092289aa1cf8d11c40991" translate="yes" xml:space="preserve">
          <source>So: With no minimum password strength requirements, 2% of users use one of the top 20 most common passwords. Meaning: if an attacker gets just 20 attempts, 1 in 50 accounts on your website will be crackable.</source>
          <target state="translated">따라서 최소 암호 강도 요구 사항이 없으면 사용자의 2 %가 가장 많이 사용되는 상위 20 개 암호 중 하나를 사용합니다. 의미 : 공격자가 20 번만 시도하면 웹 사이트의 50 개 계정 중 1 개가 깨질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d72444c8feb585090c34a3591bc5ac42a272168f" translate="yes" xml:space="preserve">
          <source>Spacing the login requests for each user account, say, 30 seconds apart, to sneak under the radar</source>
          <target state="translated">각 사용자 계정에 대한 로그인 요청 간격 (예 : 30 초 간격)</target>
        </trans-unit>
        <trans-unit id="8b54ab058e9d7a5ee0966df2639aa71cbd984855" translate="yes" xml:space="preserve">
          <source>Storing passwords</source>
          <target state="translated">비밀번호 저장</target>
        </trans-unit>
        <trans-unit id="75d6fac1e47bc2b7e87cdd0dcf77828ce747bdff" translate="yes" xml:space="preserve">
          <source>Submitting good articles about this subject</source>
          <target state="translated">이 주제에 관한 좋은 기사 제출</target>
        </trans-unit>
        <trans-unit id="075dae39a09962a66fc3b6dcab72dc07fce4b9c3" translate="yes" xml:space="preserve">
          <source>Suggesting subtopics</source>
          <target state="translated">하위 주제 제안</target>
        </trans-unit>
        <trans-unit id="c82008d6dc532dd74a5b27dec8eb806cb6db97e4" translate="yes" xml:space="preserve">
          <source>The Verified Email Protocol was proposed to provide a secure method, based on public key cryptography, for streamlining the process of proving to domain B that you have an account on domain A.</source>
          <target state="translated">확인 된 전자 메일 프로토콜은 공개 키 암호화를 기반으로 도메인 A에 계정이 있음을 도메인 B에 증명하는 프로세스를 간소화하기위한 안전한 방법을 제공하기 위해 제안되었습니다.</target>
        </trans-unit>
        <trans-unit id="873001bc6949e1b1e8ae1950e66e687b66728c5c" translate="yes" xml:space="preserve">
          <source>The definitive guide to form-based website authentication</source>
          <target state="translated">양식 기반 웹 사이트 인증에 대한 결정적인 가이드</target>
        </trans-unit>
        <trans-unit id="2f8b3b0b656f122876b0d5005972fd58779fb004" translate="yes" xml:space="preserve">
          <source>The faster you can create hashes, the faster any brute force checker can work. Slower hashes will therefore slow down brute forcing. A slow hash algorithm will make brute forcing impractical for longer passwords (8 digits +)</source>
          <target state="translated">해시를 더 빨리 만들수록 모든 무차별 검사기가 더 빨리 작동 할 수 있습니다. 따라서 해시가 느리면 무차별 강제 실행 속도가 느려집니다. 느린 해시 알고리즘은 더 긴 암호 (8 자리 +)에 대해 무차별 강제 실행을 불가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="0c1bf73b4546848eba3244b4674b70975415dd39" translate="yes" xml:space="preserve">
          <source>The form &amp;ldquo;account&lt;code&gt;@&lt;/code&gt;domain&amp;rdquo; is concise and supported by a wide range of protocols and URI schemes. Such an identifier is, of course, most universally recognized as an email address.</source>
          <target state="translated">&amp;ldquo;account &lt;code&gt;@&lt;/code&gt; domain&amp;rdquo;형식은 다양한 프로토콜과 URI 체계로 간결하고 지원됩니다. 물론 이러한 식별자는 전자 메일 주소로 가장 널리 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="39aa11169b685321ba98f52046fe4fdc8e18aa45" translate="yes" xml:space="preserve">
          <source>The hashed password received by the server is &lt;a href=&quot;https://security.stackexchange.com/questions/45254/owasp-recommendation-on-client-side-password-hashing&quot;&gt;less secure&lt;/a&gt; if you don't do additional, redundant work on the server.</source>
          <target state="translated">서버에서 추가로 중복 작업을 수행하지 않으면 서버에서 수신 한 해시 된 비밀번호의 &lt;a href=&quot;https://security.stackexchange.com/questions/45254/owasp-recommendation-on-client-side-password-hashing&quot;&gt;보안&lt;/a&gt; 이 떨어 집니다.</target>
        </trans-unit>
        <trans-unit id="3b494303db06e8467fef215f068e1ef5ff334216" translate="yes" xml:space="preserve">
          <source>The only practical way to send credentials 100% securely is by using &lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt;. Using JavaScript to hash the password is not safe. Common pitfalls for client-side password hashing:</source>
          <target state="translated">자격 증명을 100 % 안전하게 보내는 실질적인 방법은 &lt;a href=&quot;http://en.wikipedia.org/wiki/SSL&quot;&gt;SSL&lt;/a&gt; 을 사용하는 것입니다. JavaScript를 사용하여 비밀번호를 해시하는 것은 안전하지 않습니다. 클라이언트 측 비밀번호 해싱의 일반적인 함정 :</target>
        </trans-unit>
        <trans-unit id="d5ddceaf2ff3d13b24a879ec3ea4ed76cdfcfd28" translate="yes" xml:space="preserve">
          <source>The primary force holding back progress here is &lt;a href=&quot;http://www.w3.org/2011/identity-ws/papers/idbrowser2011_submission_10.pdf&quot;&gt;deployment deadlock&lt;/a&gt;. Solutions must be decomposed into steps which provide some incremental benefit on their own.</source>
          <target state="translated">여기서 진행을 보류하는 주요 힘은 &lt;a href=&quot;http://www.w3.org/2011/identity-ws/papers/idbrowser2011_submission_10.pdf&quot;&gt;배치 교착 상태&lt;/a&gt; 입니다. 솔루션은 자체적으로 약간의 이점을 제공하는 단계로 분해되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c4641bb1386ab4039d988d9fed3b98531f88c493" translate="yes" xml:space="preserve">
          <source>The problem lies more in account setup than in password checking.</source>
          <target state="translated">문제는 비밀번호 확인보다 계정 설정에 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="30e901319f87b3eb9defafddfce85dc76b0c72c1" translate="yes" xml:space="preserve">
          <source>The reality today is that most websites use form-based authentication</source>
          <target state="translated">오늘날 대부분의 웹 사이트는 폼 기반 인증을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2d2c5891d4a87869d2517de039d313ea2d260b5b" translate="yes" xml:space="preserve">
          <source>The reason a salt is used is that hashing in itself is not sufficient -- you'll want to add a so-called 'salt' to protect the hash against &lt;a href=&quot;https://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;rainbow tables&lt;/a&gt;. A salt effectively prevents two passwords that exactly match from being stored as the same hash value, preventing the whole database being scanned in one run if an attacker is executing a password guessing attack.</source>
          <target state="translated">소금이 사용되는 이유는 해싱 자체가 충분하지 않기 때문입니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Rainbow_table&quot;&gt;레인보우 테이블&lt;/a&gt; 로부터 해시를 보호하기 위해 소위 '소금'을 추가하고 싶을 것입니다. 솔트는 정확히 일치하는 두 개의 암호가 동일한 해시 값으로 저장되는 것을 효과적으로 방지하여 공격자가 암호 추측 공격을 실행하는 경우 한 번의 실행으로 전체 데이터베이스를 검사하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="db6f1f3c4b6cc7ccfb89ce39aa7239fd8fe129e2" translate="yes" xml:space="preserve">
          <source>The simplest decentralized method for expressing an identity that is built into the internet infrastructure is the domain name.</source>
          <target state="translated">인터넷 인프라에 내장 된 아이덴티티를 표현하는 가장 간단한 탈 중앙화 방법은 도메인 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5645d99ab2bd1ebc1c21888e2b9d0ac583d105e4" translate="yes" xml:space="preserve">
          <source>The token's value makes no sense to you, &lt;em&gt;but,&lt;/em&gt; should the need arise, &quot;appropriate means exist&quot; by which your website can &quot;[authoritatively] ask someone who knows (LDAP... etc.)&quot; about any &lt;em&gt;and every(!)&lt;/em&gt; question that you may have. In other words, you do &lt;strong&gt;not&lt;/strong&gt; avail yourself of &lt;em&gt;any&lt;/em&gt; &quot;home-grown logic.&quot; Instead, you inquire of The Authority and implicitly trust its verdict.</source>
          <target state="translated">토큰의 가치는 당신에게 이해가되지 &lt;em&gt;않지만,&lt;/em&gt; 필요하다면, &quot;적절한 수단이 존재&quot;하여 귀하의 웹 사이트가 &quot;[정식 적으로&quot;아는 사람 (LDAP ... 등)에게 모든 것에 대해 요청할 수 있습니다 &lt;em&gt;(!)&lt;/em&gt; 당신이 가질 수있는 질문. 다시 말해, 당신은 &lt;em&gt;어떤&lt;/em&gt; &quot;가정용 논리&quot;를 쓸모가 &lt;strong&gt;없습니다&lt;/strong&gt; . 대신에, 당신은 당국에 문의하여 암묵적으로 그 평결을 믿습니다.</target>
        </trans-unit>
        <trans-unit id="998a2bb8b6d5ada4705d13a767e1564f7753b72e" translate="yes" xml:space="preserve">
          <source>The trick is to fool a bot into thinking it has to insert data into a required field, that's why I named the input &quot;email&quot;. If you already have a field called email that you're using you should try naming the dummy field something else like &quot;company&quot;, &quot;phone&quot; or &quot;emailaddress&quot;. Just pick something you know you don't need and what sounds like something people would normally find logical to fill in into a web form. Now hide the &lt;code&gt;input&lt;/code&gt; field using CSS or JavaScript/jQuery - whatever fits you best - just &lt;strong&gt;don't&lt;/strong&gt; set the input &lt;code&gt;type&lt;/code&gt; to &lt;code&gt;hidden&lt;/code&gt; or else the bot won't fall for it.</source>
          <target state="translated">트릭은 필수 필드에 데이터를 삽입해야한다고 봇을 속이는 것입니다. 이것이 바로 입력 이름을 &quot;이메일&quot;이라고하는 이유입니다. 사용중인 이메일이라는 필드가 이미있는 경우 더미 필드의 이름을 &quot;company&quot;, &quot;phone&quot;또는 &quot;emailaddress&quot;와 같은 다른 이름으로 지정해야합니다. 필요하지 않은 것을 선택하고 사람들이 일반적으로 웹 양식을 작성하기 위해 논리적으로 생각하는 것과 같은 소리를 선택하십시오. 이제 CSS 또는 JavaScript / jQuery를 사용하여 &lt;code&gt;input&lt;/code&gt; 필드를 숨기십시오-가장 적합한 것이 무엇이든 입력 &lt;code&gt;type&lt;/code&gt; 을 &lt;code&gt;hidden&lt;/code&gt; 설정 &lt;strong&gt;하지 마십시오.&lt;/strong&gt; 그렇지 않으면 봇이 그에 빠지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34e257a9ce4c5bd6caca77d9bc6d2b2754dd5b72" translate="yes" xml:space="preserve">
          <source>The true reason why security questions even exist in the wild is that they conveniently save the cost of a few support calls from users who can't access their email to get to a reactivation code. This at the expense of security and Sarah Palin's reputation. Worth it? Probably not.</source>
          <target state="translated">보안 문제가 생겨난 진정한 이유는 재 활성화 코드를 얻기 위해 이메일에 액세스 할 수없는 사용자의 몇 가지 지원 호출 비용을 편리하게 절약하기 때문입니다. 이것은 보안과 Sarah Palin의 명성을 희생시킵니다. 그럴 가치가 있습니까? 아마 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1e505b002c5044c3265daeba9329406fa68c57e8" translate="yes" xml:space="preserve">
          <source>The use of two-factor authentication is much more secure than more clever means of password encryption</source>
          <target state="translated">2 단계 인증을 사용하는 것이보다 현명한 암호 암호화 수단보다 훨씬 안전합니다.</target>
        </trans-unit>
        <trans-unit id="5cdb1655b55ede36b4d163c4d821e27240908a02" translate="yes" xml:space="preserve">
          <source>There's another secure method called &lt;strong&gt;SRP&lt;/strong&gt;, but it's patented (although it is &lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;freely licensed&lt;/a&gt;) and there are few good implementations available.</source>
          <target state="translated">&lt;strong&gt;SRP&lt;/strong&gt; 라는 또 다른 안전한 방법이 있지만 특허를 받았지만 ( &lt;a href=&quot;http://srp.stanford.edu/license.txt&quot;&gt;무료로 라이센스&lt;/a&gt; 가 부여 되었지만) 유용한 구현은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="e77a8bc439bb506043e4f2e70e1106ab5d80d188" translate="yes" xml:space="preserve">
          <source>This &quot;authentication + authorization&quot; service can be provided by several different technologies, such as LDAP &lt;em&gt;(Microsoft OpenDirectory)&lt;/em&gt;, or Kerberos.</source>
          <target state="translated">이 &quot;인증 + 권한 부여&quot;서비스는 LDAP &lt;em&gt;(Microsoft OpenDirectory)&lt;/em&gt; 또는 Kerberos와 같은 여러 가지 다른 기술로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1613367f7592fc39a4fb19d5789345ac911f3f19" translate="yes" xml:space="preserve">
          <source>This avoids any need to have &quot;sessions&quot; or cookies as the browser itself will re-encrypt the communication each time. It is the most &quot;lightweight&quot; development approach.</source>
          <target state="translated">이렇게하면 브라우저 자체가 매번 통신을 다시 암호화하므로 &quot;세션&quot;또는 쿠키가 필요하지 않습니다. 가장 &quot;가벼운&quot;개발 방식입니다.</target>
        </trans-unit>
        <trans-unit id="2f8c91afeec66bcb11bbf481732a4120d32f6711" translate="yes" xml:space="preserve">
          <source>This final scheme was taken from the OWASP best-practices suggestions (link 1 from the MUST-READ list) and should be considered best practice, even if it is admittedly on the restrictive side.</source>
          <target state="translated">이 최종 계획은 OWASP 모범 사례 제안 (MUST-READ 목록의 링크 1)에서 가져 왔으며 제한적인 측면에서 허용되는 경우에도 모범 사례로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="767b6b49b2a806781a3997fcd35e32349fa00635" translate="yes" xml:space="preserve">
          <source>This is not strictly &amp;ldquo;form-based authentication for websites&amp;rdquo;. But it is an effort to transition from the current norm of form-based authentication to something more secure: browser-supported authentication.</source>
          <target state="translated">이것은 &quot;웹 사이트에 대한 폼 기반 인증&quot;이 아닙니다. 그러나 현재의 폼 기반 인증 표준에서보다 안전한 것으로 지원되는 브라우저 지원 인증으로 전환하려는 노력입니다.</target>
        </trans-unit>
        <trans-unit id="708c1b02320666c817634aa6a6e7cde2ea43c78c" translate="yes" xml:space="preserve">
          <source>This is the very very hard part. The &lt;em&gt;only&lt;/em&gt; decent solution is a web of trust. For example, you join the hospital as a doctor. You create a web page hosted somewhere with your photo, your passport number, and a public key, and hash them all with the private key. You then visit the hospital and the system administrator looks at your passport, sees if the photo matches you, and then hashes the web page/photo hash with the hospital private key. From now on we can securely exchange keys and tokens. As can anyone who trusts the hospital (there is the secret sauce BTW). The system administrator can also give you an &lt;a href=&quot;http://en.wikipedia.org/wiki/RSA_%28security_firm%29&quot;&gt;RSA&lt;/a&gt; dongle or other two-factor authentication.</source>
          <target state="translated">이것은 매우 어려운 부분입니다. &lt;em&gt;유일한&lt;/em&gt; 해결책은 신뢰의 웹입니다. 예를 들어, 의사로서 병원에 가입합니다. 사진, 여권 번호 및 공개 키로 어딘가에 호스팅 된 웹 페이지를 만들고 개인 키로 모두 해시합니다. 그런 다음 병원을 방문하면 시스템 관리자가 여권을보고 사진이 자신과 일치하는지 확인한 다음 병원 개인 키로 웹 페이지 / 사진 해시를 해시합니다. 이제부터 키와 토큰을 안전하게 교환 할 수 있습니다. 병원을 신뢰하는 사람은 누구나 할 수 있습니다 (비밀 소스 BTW가 있습니다). 시스템 관리자는 &lt;a href=&quot;http://en.wikipedia.org/wiki/RSA_%28security_firm%29&quot;&gt;RSA&lt;/a&gt; 동글 또는 기타 2 단계 인증을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9deba28d9534afcb8e520cdc7cf83311773566e5" translate="yes" xml:space="preserve">
          <source>This may finally be common knowledge after all the highly-publicized hacks and user data leaks we've seen in recent years, but it has to be said: Do not store passwords in cleartext in your database. User databases are routinely hacked, leaked or gleaned through SQL injection, and if you are storing raw, plaintext passwords, that is instant game over for your login security.</source>
          <target state="translated">최근에 우리가 많이 본 해킹과 사용자 데이터 유출 이후에 이것은 일반적인 지식이 될 수 있지만, 데이터베이스에 암호를 일반 텍스트로 저장하지 마십시오. 사용자 데이터베이스는 SQL 주입을 통해 일상적으로 해킹, 유출 또는 수집되며, 일반 텍스트 암호를 저장하는 경우 로그인 보안을위한 즉각적인 게임 오버입니다.</target>
        </trans-unit>
        <trans-unit id="e1ced78f2b800be0fb1dd40392fe018c4ecb6faf" translate="yes" xml:space="preserve">
          <source>This means that you can't send the user their forgotten passwords (because you only have the hash). Don't reset the user's password unless you have authenticated the user (users must prove that they are able to read emails sent to the stored (and validated) email address.)</source>
          <target state="translated">즉, 해시 만 있기 때문에 잊어 버린 암호를 사용자에게 보낼 수 없습니다. 사용자를 인증하지 않은 경우 사용자의 비밀번호를 재설정하지 마십시오 (사용자는 저장된 (확인 ​​된) 이메일 주소로 전송 된 이메일을 읽을 수 있음을 증명해야합니다.)</target>
        </trans-unit>
        <trans-unit id="40c1ddc3ab72f671316ac6d8edab98496078d667" translate="yes" xml:space="preserve">
          <source>Thwarting this requires calculating the entropy of a password and then applying a threshold.  The National Institute of Standards and Technology (NIST) &lt;a href=&quot;https://en.wikipedia.org/wiki/Password_strength#NIST_Special_Publication_800-63&quot;&gt;Special Publication 800-63&lt;/a&gt; has a set of very good suggestions.  That, when combined with a dictionary and keyboard layout analysis (for example, 'qwertyuiop' is a bad password), can &lt;a href=&quot;https://cubicspot.blogspot.com/2012/01/how-to-calculate-password-strength-part.html&quot;&gt;reject 99% of all poorly selected passwords&lt;/a&gt; at a level of 18 bits of entropy.  Simply calculating password strength and &lt;a href=&quot;https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;showing a visual strength meter&lt;/a&gt; to a user is good, but insufficient.  Unless it is enforced, a lot of users will most likely ignore it.</source>
          <target state="translated">이를 막기 위해서는 암호의 엔트로피를 계산 한 다음 임계 값을 적용해야합니다. NIST (National Institute of Standards and Technology) &lt;a href=&quot;https://en.wikipedia.org/wiki/Password_strength#NIST_Special_Publication_800-63&quot;&gt;특별 간행물 800-63&lt;/a&gt; 에는 매우 유용한 제안이 있습니다. 즉, 사전 및 키보드 레이아웃 분석 (예 : 'qwertyuiop'은 잘못된 비밀번호 임)과 결합하면 18 비트 엔트로피 레벨에서 &lt;a href=&quot;https://cubicspot.blogspot.com/2012/01/how-to-calculate-password-strength-part.html&quot;&gt;잘못 선택된 모든 비밀번호의 99 %를 거부&lt;/a&gt; 할 수 있습니다. 단순히 암호 강도를 계산 &lt;a href=&quot;https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/&quot;&gt;하고 시각적 강도 측정기&lt;/a&gt; 를 사용자에게 보여주는 것은 좋지만 충분하지 않습니다. 적용되지 않으면 많은 사용자가이를 무시할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="36f59e7438359f6b6dec486a56fd74055564200a" translate="yes" xml:space="preserve">
          <source>To clarify: The delay is &lt;em&gt;not&lt;/em&gt; a delay before returning the response to the browser. It is more like a timeout or refractory period during which login attempts to a specific account or from a specific IP address will not be accepted or evaluated at all. That is, correct credentials will not return in a successful login, and incorrect credentials will not trigger a delay increase.</source>
          <target state="translated">명확히하기 위해 : 응답은 브라우저에 응답을 반환하기 전에 지연 &lt;em&gt;되지 않습니다&lt;/em&gt; . 특정 계정이나 특정 IP 주소로의 로그인 시도가 전혀 허용되거나 평가되지 않는 시간 초과 또는 내화 기간과 비슷합니다. 즉, 올바른 자격 증명은 성공적인 로그인으로 반환되지 않으며 잘못된 자격 증명은 지연 증가를 유발하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d37cb16ef3fef2e7115eaa0053b26dfbe21af32e" translate="yes" xml:space="preserve">
          <source>Too abstract? Let me rephrase:</source>
          <target state="translated">너무 추상? 다시 말해서 :</target>
        </trans-unit>
        <trans-unit id="94ed89c349e440a548a29267a028903c24ca14a6" translate="yes" xml:space="preserve">
          <source>Uh huh ... it's &lt;em&gt;quite&lt;/em&gt; a mental-switch from the &quot;wild-and-wooly Internet.&quot;</source>
          <target state="translated">어 .. &quot;와일드 앤 울리 인터넷&quot;의 정신 스위치 야</target>
        </trans-unit>
        <trans-unit id="4265473602814216b394ca2290e014784cf52b26" translate="yes" xml:space="preserve">
          <source>Unless the connection is already secure (that is, tunneled through HTTPS using SSL/TLS), your login form values will be sent in cleartext, which allows anyone eavesdropping on the line between browser and web server will be able to read logins as they pass through. This type of wiretapping is done routinely by governments, but in general, we won't address 'owned' wires other than to say this: Just use HTTPS.</source>
          <target state="translated">연결이 이미 안전하지 않은 경우 (즉, SSL / TLS를 사용하여 HTTPS를 통해 터널링 된 경우) 로그인 양식 값이 일반 텍스트로 전송되므로 브라우저와 웹 서버 사이의 회선을 도청하는 사람은 누구나 로그인을 읽을 수 있습니다. 을 통하여. 이러한 유형의 도청은 정부에서 일상적으로 수행하지만 일반적으로 HTTPS를 사용하는 것 외에는 '소유'된 전선을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc20528d51ba47e05223bf0a781ff269bf656c20" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://openid.net/connect/&quot;&gt;OpenID Connect&lt;/a&gt; or &lt;a href=&quot;https://kantarainitiative.org/confluence/display/uma/Home&quot;&gt;User-Managed Access&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://openid.net/connect/&quot;&gt;OpenID Connect&lt;/a&gt; 또는 &lt;a href=&quot;https://kantarainitiative.org/confluence/display/uma/Home&quot;&gt;사용자 관리 액세스를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="569514ecdf06ab5d5875ae06513d8acc92496198" translate="yes" xml:space="preserve">
          <source>Use of &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;nonces&lt;/a&gt; to prevent &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;cross-site request forgeries (CSRF)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_request_forgery&quot;&gt;CSRF (Cross-Site Request Forgeries)&lt;/a&gt; 방지를 위해 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;nonces&lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="5692cfefa5a54d8be531f2dc6d33d0432dc849fe" translate="yes" xml:space="preserve">
          <source>Using secret questions</source>
          <target state="translated">비밀 질문 사용</target>
        </trans-unit>
        <trans-unit id="0082a6cc3e0b2bbeae74eaf89dd9ed0c542121f9" translate="yes" xml:space="preserve">
          <source>Utilize Troy Hunt's &lt;a href=&quot;https://haveibeenpwned.com/API/&quot;&gt;Have I Been Pwned API&lt;/a&gt; to check users passwords against passwords compromised in public data breaches.</source>
          <target state="translated">Troy Hunt 's &lt;a href=&quot;https://haveibeenpwned.com/API/&quot;&gt;I Been Pwned API&lt;/a&gt; 를 사용 하여 공개 데이터 유출로 인해 손상된 비밀번호와 비교하여 사용자 비밀번호를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5a208e8a90fc7c482e752087202866b98cf9ae23" translate="yes" xml:space="preserve">
          <source>We believe that Stack&amp;nbsp;Overflow should not just be a resource for very specific technical questions, but also for general guidelines on how to solve variations on common problems. &quot;Form based authentication for websites&quot; should be a fine topic for such an experiment.</source>
          <target state="translated">스택 오버플로는 매우 구체적인 기술적 인 질문뿐만 아니라 일반적인 문제에 대한 변형을 해결하는 방법에 대한 일반적인 지침이 될 수 있다고 생각합니다. 이러한 실험에서는 &quot;웹 사이트의 양식 기반 인증&quot;이 좋은 주제가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="27c0e1a0723aceee1fa3a38394e3557605e31eaa" translate="yes" xml:space="preserve">
          <source>We'll assume you already know how to build a login+password HTML form which POSTs the values to a script on the server side for authentication. The sections below will deal with patterns for sound practical auth, and how to avoid the most common security pitfalls.</source>
          <target state="translated">인증을 위해 서버 측 스크립트에 값을 POST하는 로그인 + 비밀번호 HTML 양식을 작성하는 방법을 이미 알고 있다고 가정합니다. 아래 섹션에서는 실질적인 인증 방법과 가장 일반적인 보안 위험을 피하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dbd15fa92d23c602686ecb421e837fa5c0100a95" translate="yes" xml:space="preserve">
          <source>When a user is dutifully-connected to the aforesaid network, their identity &lt;em&gt;(&quot;authentication&quot;)&lt;/em&gt; is [already ...] &quot;conclusively known,&quot; as is their permission &lt;em&gt;(&quot;authorization&quot;)&lt;/em&gt; to do certain things ... such as ... &quot;to access this website.&quot;</source>
          <target state="translated">사용자가 상술 한 네트워크에 정식으로 연결되면, 그들의 신원 &lt;em&gt;( &quot;인증&quot;)&lt;/em&gt; 은 &lt;em&gt;&quot;&lt;/em&gt; 이미 확정 된&quot;이고, 어떤 것들을 할 수 &lt;em&gt;있는&lt;/em&gt; 그들의 허가 &lt;em&gt;( &quot;권한&quot;)&lt;/em&gt; 는 ...와 같은 것이다. .. &quot;이 웹 사이트에 액세스합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="6b7e7b430708b466db8f5dc96f8c359bf35d1a98" translate="yes" xml:space="preserve">
          <source>When hashing, don't use fast hash algorithms such as MD5 (many hardware implementations exist).  Use something like SHA-512.  For passwords, slower hashes are better.</source>
          <target state="translated">해싱시 MD5와 같은 빠른 해시 알고리즘을 사용하지 마십시오 (많은 하드웨어 구현이 존재 함). SHA-512와 같은 것을 사용하십시오. 암호의 경우 해시가 느릴수록 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1b1261f95eb01d2a4a663842cd7729c9a950766b" translate="yes" xml:space="preserve">
          <source>When you are validating the form (either client or server side) check if your dummy field has been filled to determine if it was sent by a human or a bot.</source>
          <target state="translated">클라이언트 또는 서버 측에서 양식의 유효성을 검사 할 때 더미 필드가 채워 졌는지 확인하여 사람 또는 봇이 보낸 것인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9990351cb6dc5a037c4956e9bc10cae3faf4b145" translate="yes" xml:space="preserve">
          <source>While it is true that hashing the password &lt;em&gt;can be&lt;/em&gt; effective against &lt;strong&gt;password disclosure&lt;/strong&gt;, it is vulnerable to replay attacks, Man-In-The-Middle attacks / hijackings (if an attacker can inject a few bytes into your unsecured HTML page before it reaches your browser, they can simply comment out the hashing in the JavaScript), or brute-force attacks (since you are handing the attacker both username, salt and hashed password).</source>
          <target state="translated">비밀번호 해싱이 비밀번호 &lt;strong&gt;공개&lt;/strong&gt; 에 대해 효과적 일 &lt;em&gt;수는 있지만&lt;/em&gt; , 재연 공격, 중간자 (Man-In-The-Middle) 공격 / 도용에 취약합니다 (공격자가 보안되지 않은 HTML 페이지에 도달하기 전에 몇 바이트를 삽입 할 수있는 경우) 브라우저를 사용하면 JavaScript에서 해시를 주석 처리하거나 무차별 대입 공격 (사용자가 사용자 이름, 솔트 및 해시 비밀번호를 모두 공격하므로 공격)을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3584882b01cd0f3c5269eeae6ec1a2fd214b72e5" translate="yes" xml:space="preserve">
          <source>While this is a noble thought, it is essentially useless (and can be a &lt;a href=&quot;https://stackoverflow.com/questions/1380168/does-it-make-security-sense-to-hash-password-on-client-end&quot;&gt;security flaw&lt;/a&gt;) unless it is combined with one of the above - that is, either securing the line with strong encryption or using a tried-and-tested challenge-response mechanism (if you don't know what that is, just know that it is one of the most difficult to prove, most difficult to design, and most difficult to implement concepts in digital security).</source>
          <target state="translated">이것은 고귀한 생각이지만, 위의 방법 중 하나와 결합되지 않는 한, 즉 강력한 암호화로 회선을 확보하거나 검증 된 챌린지 응답을 사용하지 않으면 본질적으로 쓸모가 없으며 &lt;a href=&quot;https://stackoverflow.com/questions/1380168/does-it-make-security-sense-to-hash-password-on-client-end&quot;&gt;보안 결함이&lt;/a&gt; 될 수 있습니다. 매커니즘 (무엇이 무엇인지 모른다면, 그것이 입증하기가 가장 어렵고, 설계하기가 어렵고, 디지털 보안에서 개념을 구현하기가 가장 어렵다는 것만 알면됩니다)</target>
        </trans-unit>
        <trans-unit id="33e6a957bfa924b65ff628b30fcdd2dbd1ba74b7" translate="yes" xml:space="preserve">
          <source>Wikipedia article on weaknesses of several password hashing schemes.</source>
          <target state="translated">여러 암호 해싱 체계의 약점에 대한 Wikipedia 기사.</target>
        </trans-unit>
        <trans-unit id="8643406d224fa433c9299efb0492bf78e73bb0e0" translate="yes" xml:space="preserve">
          <source>Wikipedia: HTTP cookie</source>
          <target state="translated">위키 백과 : HTTP 쿠키</target>
        </trans-unit>
        <trans-unit id="c67b948f981569ab7d4f3ea77c17d7b5eb452012" translate="yes" xml:space="preserve">
          <source>You can also vary this up a little by leaving the dummy field visible but outside the boundaries of the screen, but this is totally up to you.</source>
          <target state="translated">더미 필드를 표시하지만 화면 경계 외부에두면이 값을 약간 변경할 수 있지만 이는 전적으로 사용자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0abd0a897c5f9b121995cd958577feb15f7b6ac" translate="yes" xml:space="preserve">
          <source>You're Probably Storing Passwords Incorrectly</source>
          <target state="translated">암호를 잘못 저장했을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fb7f7c94028fe09a6d2d9b3bf0b8501eb7095619" translate="yes" xml:space="preserve">
          <source>etc.</source>
          <target state="translated">etc.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
