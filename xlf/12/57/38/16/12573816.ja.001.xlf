<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/12573816">
    <body>
      <group id="12573816">
        <trans-unit id="c9cbc039ba0dda953e719495f032898e9956f254" translate="yes" xml:space="preserve">
          <source>&quot;An introduction to GCC&quot; &lt;a href=&quot;http://www.network-theory.co.uk/docs/gccintro/gccintro_75.html&quot;&gt;chapter 9&lt;/a&gt;.</source>
          <target state="translated">「GCCの概要」の&lt;a href=&quot;http://www.network-theory.co.uk/docs/gccintro/gccintro_75.html&quot;&gt;第9章&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d7d5b868297c7e069f79fb3331f33b5984b8682" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -c file.cpp&lt;/code&gt; -&amp;gt; compiles file.cpp and file.h to file.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -c file.cpp&lt;/code&gt; &amp;gt; file.cppとfile.hをfile.oにコンパイルします</target>
        </trans-unit>
        <trans-unit id="e49790a3beb1dd7402b4cb606c79667d1433b0a4" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -c main.cpp&lt;/code&gt; -&amp;gt; compiles main.cpp to main.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -c main.cpp&lt;/code&gt; &amp;gt; main.cppをmain.oにコンパイルします</target>
        </trans-unit>
        <trans-unit id="071ec213b517c0a8d3f03b45c60bc9f9f0b55435" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -o executable main.o file.o -lstdc++fs&lt;/code&gt; -&amp;gt; links main.o and file.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -o executable main.o file.o -lstdc++fs&lt;/code&gt; &amp;gt; main.oとfile.oをリンク</target>
        </trans-unit>
        <trans-unit id="bad1abfbbc607215e826cba0225a7e15753aaefc" translate="yes" xml:space="preserve">
          <source>(Or: That linkage worked fine for you on, say, Fedora 23, but fails on Ubuntu 16.04)</source>
          <target state="translated">(または:そのリンクは、あなたのために、例えば、Fedora 23上で正常に動作しましたが、Ubuntu 16.04上で失敗します)</target>
        </trans-unit>
        <trans-unit id="74c25a55039995250f6d3f12bb86f1ae278cee30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://coliru.stacked-crooked.com/a/e9221c4bb23f9cd0&quot;&gt;Code listing showing the techniques above&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://coliru.stacked-crooked.com/a/e9221c4bb23f9cd0&quot;&gt;上記の手法を示すコードリスト&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bf6077b839b27f134871fac7b06a0474aa39b4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; data members must be defined outside the class in a &lt;strong&gt;single translation unit&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; データメンバーは、 &lt;strong&gt;単一の翻訳単位で&lt;/strong&gt;クラスの外部に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="89e5d36fe0239dd24cbe84c6df52545cb824576c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;virtual&lt;/code&gt; methods must either be implemented or defined as pure.</source>
          <target state="translated">&lt;code&gt;virtual&lt;/code&gt; メソッドは、実装するか、純粋として定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="a6e978f78787cb65ba3c48dd61a5ce9874bb1e0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;As a side note to the failing code sample; g++ warns about this as follows&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;失敗したコードサンプルの補足として。&lt;/em&gt; &lt;em&gt;g ++はこれについて次のように警告します&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcdf4af6901fd0be253767cc15e18070c0140d96" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;, when the declaration of the operator (or function) only appears in the class, the name is not available for &quot;normal&quot; lookup, only for argument dependent lookup, from &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend&quot;&gt;cppreference&lt;/a&gt;;</source>
          <target state="translated">演算子（または関数）の宣言がクラスにのみ表示される場合、その名前は&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend&quot;&gt;cppreference&lt;/a&gt;からの「通常の」ルックアップでは使用できず、引数に依存するルックアップでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="66ebd1f43ac511c6c708dab9f44756f21a71765e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Reading is optional from here on&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;以降、読み取りはオプションです&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="2438bd9596a6f2aad81a0222f2c18ffe262f7d81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[footnote]&lt;/em&gt; Implementations must behave as if these separate phases occur, although in practice different phases might be folded together.</source>
          <target state="translated">&lt;em&gt;[脚注]&lt;/em&gt;実際には異なるフェーズが一緒にフォールドされる可能性がありますが、実装はこれらの個別のフェーズが発生するかのように動作する必要があります。</target>
        </trans-unit>
        <trans-unit id="a534858af77623fa6f10f6aa3f2334132487ee64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A wrapper around GNU ld that doesn't support linker scripts&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;リンカースクリプトをサポートしないGNU ldのラッパー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="835e534d0a03e685a5781ca6fe9811f767d58b55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A. What is symbol?&lt;/strong&gt;
In short, a symbol is a name. It can be a variable name, a function name, a class name, a typedef name, or anything except those names and signs that belong to C++ language. It is user defined or introduced by a dependency library (another user-defined).</source>
          <target state="translated">&lt;strong&gt;A.シンボルとは？&lt;/strong&gt; つまり、シンボルは名前です。 変数名、関数名、クラス名、typedef名など、C ++言語に属する名前と記号を除くすべてを指定できます。 これは、依存ライブラリ（別のユーザー定義）によってユーザーが定義または導入したものです。</target>
        </trans-unit>
        <trans-unit id="eec66c59c1dbab98e498c91f5e97e7ff8ab7101f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All external entity references are resolved. Library components are linked to satisfy external references to entities not defined in the
  current translation. All such translator output is collected into a
  program image which contains information needed for execution in its
  execution environment.&lt;/strong&gt; (emphasis mine)</source>
          <target state="translated">&lt;strong&gt;すべての外部エンティティ参照が解決されます。&lt;/strong&gt; &lt;strong&gt;ライブラリコンポーネントは、現在の翻訳で定義されていないエンティティへの外部参照を満たすためにリンクされます。&lt;/strong&gt; &lt;strong&gt;このようなトランスレータの出力はすべて、その実行環境での実行に必要な情報を含むプログラムイメージに収集されます。&lt;/strong&gt; （強調鉱山）</target>
        </trans-unit>
        <trans-unit id="dd8db3de81c77ec485d11b2559fd63ff6023c436" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B. What is external?&lt;/strong&gt;
In VC++, every source file (.cpp,.c,etc.) is considered as a translation unit, the compiler compiles one unit at a time, and generate one object file(.obj) for the current translation unit. (Note that every header file that this source file included will be preprocessed and will be considered as part of this translation unit)Everything within a translation unit is considered as internal, everything else is considered as external. In C++, you may reference an external symbol by using keywords like &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;__declspec (dllimport)&lt;/code&gt; and so on.</source>
          <target state="translated">&lt;strong&gt;B.外部とは何ですか？&lt;/strong&gt; VC ++では、すべてのソースファイル（.cpp、.cなど）は翻訳単位と見なされ、コンパイラは一度に1つの単位をコンパイルし、現在の翻訳単位に対して1つのオブジェクトファイル（.obj）を生成します。 （このソースファイルに含まれるすべてのヘッダーファイルは前処理され、この翻訳単位の一部と見なされます）翻訳単位内のすべてが内部と見なされ、それ以外はすべて外部と見なされます。 C ++では、 &lt;code&gt;extern&lt;/code&gt; 、 &lt;code&gt;__declspec (dllimport)&lt;/code&gt; などのキーワードを使用して外部シンボルを参照できます。</target>
        </trans-unit>
        <trans-unit id="6c2ca1047c2ef8497e41c914c53f8e7ca55ee476" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C. What is &amp;ldquo;resolve&amp;rdquo;?&lt;/strong&gt;
Resolve is a linking-time term. In linking-time, linker attempts to find the external definition for every symbol in object files that cannot find its definition internally. The scope of this searching process including:</source>
          <target state="translated">&lt;strong&gt;C.「解決」とは何ですか？&lt;/strong&gt; 解決はリンク時の用語です。 リンク時、リンカーは、内部で定義を見つけることができないオブジェクトファイル内のすべてのシンボルの外部定義を見つけようとします。 この検索プロセスの範囲：</target>
        </trans-unit>
        <trans-unit id="7342049e2513cd5b99e201cfcb5bf3b14417789e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;D. Finally, why Unresolved External Symbol?&lt;/strong&gt;
If the linker cannot find the external definition for a symbol that has no definition internally, it reports an Unresolved External Symbol error.</source>
          <target state="translated">&lt;strong&gt;D.最後に、なぜ未解決の外部シンボルですか？&lt;/strong&gt; リンカは、内部に定義がないシンボルの外部定義を見つけることができない場合、未解決の外部シンボルエラーを報告します。</target>
        </trans-unit>
        <trans-unit id="5b8a47f4b41b91b3d612aacb048ed208fcac6f16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Different architectures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;異なるアーキテクチャ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be965b14abe7432b5fa433657763c3dc46c94955" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E. Possible causes of LNK2019&lt;/strong&gt;: Unresolved External Symbol error.
We already know that this error is due to the linker failed to find the definition of external symbols, the possible causes can be sorted as:</source>
          <target state="translated">&lt;strong&gt;E. LNK2019の考えられる原因&lt;/strong&gt; ：未解決の外部シンボルエラー。 このエラーは、リンカが外部シンボルの定義を見つけることができなかったことが原因であることがわかっています。考えられる原因は次のように分類できます。</target>
        </trans-unit>
        <trans-unit id="175dc84044f833f83a2c70ee5958f34ffa3867f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How To Solve this kind of error&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;この種のエラーを解決する方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50f9819832db0d81b1174260f918040cd2cf7d74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If all else fails, recompile.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;他のすべてが失敗した場合は、再コンパイルします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cffd218845fdac972017077668b21dcb30366645" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Linked .lib file is associated to a .dll&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;リンクされた.libファイルは.dllに関連付けられています&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06b83ed7c66d61ec7db41c3a6e7b02f8577e43ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Observation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8940eb48005ed796b60ad830078b12d07df43be6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Steps In Linking a project&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;プロジェクトをリンクする手順&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75d4f8b2fa373cf046a6b677d6c35770b0294edb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Visual Studio NuGet package needs to be updated for new toolset version&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Visual Studio NuGetパッケージを新しいツールセットバージョン用に更新する必要がある&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb0c9feeb4bacc0fa3c37312d7a301912ecd4847" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What's the meaning of compilation ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;コンパイルの意味は何ですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1465fad7785625be27309d79cd0e820fa06d98f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eg1.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;eg1.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89c440cfe498cb89e3725891dfd833439ac8312d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eg2.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;eg2.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff073c269c56360873674533870cbf8bfa429227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;file.cpp&lt;/strong&gt;, the implementation of file.h, #include's &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot;</source>
          <target state="translated">&lt;strong&gt;file.cpp&lt;/strong&gt; 、 &lt;strong&gt;file.h&lt;/strong&gt;の実装、#includeの &quot; &lt;strong&gt;file.h&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="f9ae04f6c866dcf587fa6e1e0dae001a09d7888a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;file.h&lt;/strong&gt; #include's &amp;lt;&lt;strong&gt;experimental::filesystem&lt;/strong&gt;&amp;gt; and contains the code above</source>
          <target state="translated">&lt;strong&gt;file.h #include&lt;/strong&gt;の&amp;lt; &lt;strong&gt;experimental :: filesystem&lt;/strong&gt; &amp;gt;および上記のコードが含まれています</target>
        </trans-unit>
        <trans-unit id="fddf0c10ac5731cb589a87bb2c2094c4fa147fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main.cpp&lt;/strong&gt; #include's &amp;lt;&lt;strong&gt;filesystem&lt;/strong&gt;&amp;gt; and &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot;</source>
          <target state="translated">&lt;strong&gt;main.cpp&lt;/strong&gt; &lt;strong&gt;#include&lt;/strong&gt;の&amp;lt; &lt;strong&gt;filesystem&lt;/strong&gt; &amp;gt;および &quot; &lt;strong&gt;file.h&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="2582c85be2b20f3244cd0cd3e45025f73c92ed51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;my_lib.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;my_lib.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c230963946da5a9ed838b6a5933de9f154d5ef91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;my_lib.h&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;my_lib.h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2662021565cbcee02085174aa21cc7ecdb484907" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined reference to &lt;code&gt;WinMain@16&lt;/code&gt; or similar &lt;em&gt;'unusual'&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; entry point reference&lt;/strong&gt; (especially for &lt;a href=&quot;/questions/tagged/visual-studio&quot;&gt;visual-studio&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;WinMain@16&lt;/code&gt; または同様の&lt;em&gt;「異常な」&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; エントリポイント参照への未定義の参照&lt;/strong&gt; （特に&lt;a href=&quot;/questions/tagged/visual-studio&quot;&gt;visual-studioの場合&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0acfceb277492d3fa70c2011c817d088faf04611" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;what is an &quot;undefined reference/unresolved external symbol&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;「未定義の参照/未解決の外部シンボル」とは&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3c395f4232d75cdbc21861202f537c9ca9121e5" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Feel free to edit/add your own.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;自由に編集/追加してください。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d2d1d37fdef4865427a49fbf3bf6a77bd38bb6d1" translate="yes" xml:space="preserve">
          <source>A &quot;clean&quot; of the build can remove the &quot;dead wood&quot; that may be left lying around from previous builds, failed builds, incomplete builds and other build system related build issues.</source>
          <target state="translated">ビルドの「クリーン」は、以前のビルド、失敗したビルド、不完全なビルド、その他のビルドシステムに関連するビルドの問題から、周りに転がっている可能性のある「枯れ木」を取り除くことができます。</target>
        </trans-unit>
        <trans-unit id="189f79f5d1a5faa4467603ef162262cccf65ca78" translate="yes" xml:space="preserve">
          <source>A Windows UNICODE build is built with &lt;code&gt;TCHAR&lt;/code&gt; etc. being defined as &lt;code&gt;wchar_t&lt;/code&gt; etc. When not building with &lt;code&gt;UNICODE&lt;/code&gt; defined as build with &lt;code&gt;TCHAR&lt;/code&gt; defined as &lt;code&gt;char&lt;/code&gt; etc. These &lt;code&gt;UNICODE&lt;/code&gt; and &lt;code&gt;_UNICODE&lt;/code&gt; defines affect all the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx&quot;&gt;&quot;&lt;code&gt;T&lt;/code&gt;&quot; string types&lt;/a&gt;; &lt;code&gt;LPTSTR&lt;/code&gt;, &lt;code&gt;LPCTSTR&lt;/code&gt; and their elk.</source>
          <target state="translated">Windows UNICODEビルドは、 &lt;code&gt;TCHAR&lt;/code&gt; などが &lt;code&gt;wchar_t&lt;/code&gt; などとして定義されてビルドされます &lt;code&gt;TCHAR&lt;/code&gt; ビルドとして定義され、 TCHARが &lt;code&gt;char&lt;/code&gt; などとして定義されてビルドされない場合、これらの &lt;code&gt;UNICODE&lt;/code&gt; および &lt;code&gt;_UNICODE&lt;/code&gt; 定義は、すべての&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx&quot;&gt;「 &lt;code&gt;T&lt;/code&gt; 」文字列タイプに&lt;/a&gt;影響します 。 &lt;code&gt;LPTSTR&lt;/code&gt; 、 &lt;code&gt;LPCTSTR&lt;/code&gt; 、およびそれらのヘラジカ。</target>
        </trans-unit>
        <trans-unit id="90afd285297eb44d41e1f5773ca5cb874cbb19b4" translate="yes" xml:space="preserve">
          <source>A bug in the compiler/IDE</source>
          <target state="translated">compilerIDEのバグ</target>
        </trans-unit>
        <trans-unit id="a31d75bc9dfc18e7b2009004254a487c7ca05013" translate="yes" xml:space="preserve">
          <source>A common mistake is forgetting to qualify the name:</source>
          <target state="translated">よくある間違いは、名前の修飾を忘れてしまうことです。</target>
        </trans-unit>
        <trans-unit id="1f739d01292aa73c37e4aee39f036a3bb2a527ee" translate="yes" xml:space="preserve">
          <source>A minimal example involving a shared system library, the compression library &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">共有システムライブラリ、圧縮ライブラリ &lt;code&gt;libz&lt;/code&gt; を含む最小限の例</target>
        </trans-unit>
        <trans-unit id="01c92916b56793a9454d489c312fa9257acc6107" translate="yes" xml:space="preserve">
          <source>A minimal example involving a static library you built yourself</source>
          <target state="translated">自分で作ったスタティックライブラリを使った最小限の例</target>
        </trans-unit>
        <trans-unit id="6d46bde77adddeb0b72386689fff3e28dd372bb9" translate="yes" xml:space="preserve">
          <source>A name first declared in a friend declaration within class or class template X becomes a member of the innermost enclosing namespace of X, but is not accessible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at the namespace scope is provided...</source>
          <target state="translated">クラスまたはクラステンプレートX内のフレンド宣言で最初に宣言された名前は、Xの最も内側にある名前空間のメンバになりますが、名前空間スコープでマッチする宣言が提供されない限り、検索にはアクセスできません(Xを考慮した引数依存の検索を除く)...</target>
        </trans-unit>
        <trans-unit id="5a03aa49c3c082188ccefd12449a2783226a9d4f" translate="yes" xml:space="preserve">
          <source>A pure &lt;code&gt;virtual&lt;/code&gt; destructor needs an implementation.</source>
          <target state="translated">純粋な &lt;code&gt;virtual&lt;/code&gt; デストラクタには実装が必要です。</target>
        </trans-unit>
        <trans-unit id="ec2d47bd5e6c687188cca18e11b6e3a11fd20b4b" translate="yes" xml:space="preserve">
          <source>A shared library isn't an archive of object files or anything like it. It's
much more like a &lt;em&gt;program&lt;/em&gt; that doesn't have a &lt;code&gt;main&lt;/code&gt; function and
instead exposes multiple other symbols that it defines, so that other
programs can use them at runtime.</source>
          <target state="translated">共有ライブラリは、オブジェクトファイルなどのアーカイブではありません。 これは、 &lt;code&gt;main&lt;/code&gt; 関数を持たず、代わりに、プログラムが定義する他の複数のシンボルを公開して、他のプログラムが実行時にそれらを使用できるようにする&lt;em&gt;プログラムに&lt;/em&gt;はるかに似ています。</target>
        </trans-unit>
        <trans-unit id="4f62d04e30be88d7be65eb3c4d8daefedf696027" translate="yes" xml:space="preserve">
          <source>A static library is an indexed archive of object files. When the linker
finds &lt;code&gt;-lmy_lib&lt;/code&gt; in the linkage sequence and figures out that this refers
to the static library &lt;code&gt;./libmy_lib.a&lt;/code&gt;, it wants to know whether your program
needs any of the object files in &lt;code&gt;libmy_lib.a&lt;/code&gt;.</source>
          <target state="translated">静的ライブラリは、オブジェクトファイルのインデックス付きアーカイブです。 リンカがリンケージシーケンスで &lt;code&gt;-lmy_lib&lt;/code&gt; を見つけ、これが静的ライブラリ &lt;code&gt;./libmy_lib.a&lt;/code&gt; を参照していることを理解すると、プログラムは &lt;code&gt;libmy_lib.a&lt;/code&gt; 内のオブジェクトファイルのいずれかを必要とするかどうかを知りたがります。</target>
        </trans-unit>
        <trans-unit id="8b191d246d34f1e602a3e402976e900a1a875073" translate="yes" xml:space="preserve">
          <source>A typical variable declaration is</source>
          <target state="translated">典型的な変数宣言は</target>
        </trans-unit>
        <trans-unit id="82e2e65a5074a60696904cace45937b63edf3d64" translate="yes" xml:space="preserve">
          <source>Adjacent string literal tokens are concatenated.</source>
          <target state="translated">隣接する文字列リテラルトークンが連結されます。</target>
        </trans-unit>
        <trans-unit id="7fe45da2f4efcc86cb9b6567ee7a4ad6bf699b1f" translate="yes" xml:space="preserve">
          <source>After the assembler phase we have an object file, which contains any symbols to export. 
Look at the symbols</source>
          <target state="translated">アセンブラフェーズの後には、エクスポートするシンボルを含むオブジェクトファイルがあります。シンボルを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="dbf5b9e02583394489628b8d6f4b8f7252c2835c" translate="yes" xml:space="preserve">
          <source>All libraries (.lib) that are either explicitly or implicitly
specified as additional dependencies of this building application.</source>
          <target state="translated">このビルドアプリケーションの追加の依存関係として明示的または暗黙的に指定されているすべてのライブラリ(.lib)。</target>
        </trans-unit>
        <trans-unit id="f594bd06c1caa0ead7f44aab9131622ae2e6ba7e" translate="yes" xml:space="preserve">
          <source>All object files that generated in compiling time</source>
          <target state="translated">コンパイル時に生成された全てのオブジェクトファイル</target>
        </trans-unit>
        <trans-unit id="4091f76b2539a23ecb3681b7960816da46fc1f49" translate="yes" xml:space="preserve">
          <source>All used member methods need to be defined if used.</source>
          <target state="translated">使用されるすべてのメンバ・メソッドは、使用される場合に定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="258953ce5c44b3d94df6a62bf16b94620782ab0b" translate="yes" xml:space="preserve">
          <source>Allowing the friendship to extend to all instantiations of the templates, as follows;</source>
          <target state="translated">以下のように、テンプレートのすべてのインスタンスにフレンドシップを拡張できるようにします。</target>
        </trans-unit>
        <trans-unit id="c827bc9706235eb6e58b62b8ed3b65b6653a561a" translate="yes" xml:space="preserve">
          <source>Also if you're using 3rd party libraries make sure you have the correct 32/64 bit binaries</source>
          <target state="translated">また、サードパーティ製のライブラリを使用している場合は、正しい3264ビットのバイナリを使用していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="fcf665a8f73833aa185cc196d74ef511cdd50687" translate="yes" xml:space="preserve">
          <source>Alternatively one could declare the &lt;code&gt;const&lt;/code&gt; variable in file1.cpp with explicit &lt;code&gt;extern&lt;/code&gt;</source>
          <target state="translated">あるいは、明示的な &lt;code&gt;extern&lt;/code&gt; を使用してfile1.cppで &lt;code&gt;const&lt;/code&gt; 変数を宣言することもできます</target>
        </trans-unit>
        <trans-unit id="6faa1efbd9a22a841dece261aa541458bc6561d1" translate="yes" xml:space="preserve">
          <source>Alternatives include;</source>
          <target state="translated">代替品には以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="9142d2a0c57278cbac1656ede2c51ad79022c5e8" translate="yes" xml:space="preserve">
          <source>An example of how this can happen in the real world is explained below.</source>
          <target state="translated">現実世界でどのようなことが起こるのか、例を挙げて説明します。</target>
        </trans-unit>
        <trans-unit id="0978b0da32a1d538f6533aded9b037a5a632b0e0" translate="yes" xml:space="preserve">
          <source>An initializer can be provided for a &lt;code&gt;static&lt;/code&gt;&lt;code&gt;const&lt;/code&gt; data member of integral or enumeration type within the class definition; however, odr-use of this member will still require a namespace scope definition as described above. C++11 allows initialization inside the class for all &lt;code&gt;static const&lt;/code&gt; data members.</source>
          <target state="translated">初期化子は、クラス定義内の整数型または列挙型の &lt;code&gt;static&lt;/code&gt; &lt;code&gt;const&lt;/code&gt; データメンバーに提供できます。 ただし、このメンバーのodrの使用には、上記の名前空間スコープの定義が必要です。 C ++ 11では、すべての &lt;code&gt;static const&lt;/code&gt; データメンバーのクラス内の初期化が可能です。</target>
        </trans-unit>
        <trans-unit id="fe337499c7cf1304af8bc4b955a047cc2736dc7c" translate="yes" xml:space="preserve">
          <source>And a variation on example 2 involving &lt;code&gt;pkg-config&lt;/code&gt;:</source>
          <target state="translated">そして、 &lt;code&gt;pkg-config&lt;/code&gt; を含む例2のバリエーション：</target>
        </trans-unit>
        <trans-unit id="d551606414a99e264853eca34fd51b96854e0ecd" translate="yes" xml:space="preserve">
          <source>And then you go ahead and include the library in your own project.</source>
          <target state="translated">そして、自分のプロジェクトにライブラリを入れていくのです。</target>
        </trans-unit>
        <trans-unit id="b2245e86d8c2a2258df1e19537be1050df1ac011" translate="yes" xml:space="preserve">
          <source>As this is only a declaration, a &lt;strong&gt;single definition&lt;/strong&gt; is needed. A corresponding definition would be:</source>
          <target state="translated">これは単なる宣言なので、 &lt;strong&gt;1つの定義&lt;/strong&gt;が必要です。 対応する定義は次のようになります。</target>
        </trans-unit>
        <trans-unit id="b13d9a436d6efc6b48e4a9a36b25cc2355a5e4fc" translate="yes" xml:space="preserve">
          <source>At runtime, the system program loader will load a copy of &lt;code&gt;libz&lt;/code&gt; into the
same process as your program whenever it loads a copy of your program, to run it.</source>
          <target state="translated">実行時に、システムプログラムローダーは、プログラムのコピーをロードするたびに、プログラムと同じプロセスに &lt;code&gt;libz&lt;/code&gt; のコピーをロードして実行します。</target>
        </trans-unit>
        <trans-unit id="e5bb89d8a1b39ec5a184b94a75ab271ed2ff9d91" translate="yes" xml:space="preserve">
          <source>At runtime, whenever your program refers to something that is defined in
&lt;code&gt;libz&lt;/code&gt;, that reference uses the definition exported by the copy of &lt;code&gt;libz&lt;/code&gt; in
the same process.</source>
          <target state="translated">実行時に、プログラムが &lt;code&gt;libz&lt;/code&gt; で定義されているものを参照するときはいつでも、その参照は同じプロセスで &lt;code&gt;libz&lt;/code&gt; のコピーによってエクスポートされた定義を使用します。</target>
        </trans-unit>
        <trans-unit id="8706fc513753f8a6ab494b836c139f955dd4de4b" translate="yes" xml:space="preserve">
          <source>Back in the day, it was normal for unix-like systems to link static and shared 
libraries by different rules. Static libraries in a linkage sequence were linked 
on the &lt;em&gt;as-needed&lt;/em&gt; basis explained in example 1, but shared libraries were linked unconditionally.</source>
          <target state="translated">かつて、UNIXライクなシステムでは、静的ライブラリと共有ライブラリを異なるルールでリンクするのが普通でした。 リンケージシーケンスの静的ライブラリは、例1で説明した&lt;em&gt;必要に応じて&lt;/em&gt;リンクされましたが、共有ライブラリは無条件にリンクされました。</target>
        </trans-unit>
        <trans-unit id="4a50aaa9dbdd42f72fdba6a8715e83c2a0a34f3f" translate="yes" xml:space="preserve">
          <source>Be careful that the function you implement exactly matches the one you declared. For example, you may have mismatched cv-qualifiers:</source>
          <target state="translated">実装する関数が宣言した関数と正確に一致するように注意してください。例えば,不一致の cv-qualifier があるかもしれません.</target>
        </trans-unit>
        <trans-unit id="380e27586685053a149a95794ec8ea13cd72b1ae" translate="yes" xml:space="preserve">
          <source>Because compiling and linking with a single command does not change the
order of the linkage sequence.</source>
          <target state="translated">1つのコマンドでコンパイルしてリンクしても、リンク先の順序は変わらないからです。</target>
        </trans-unit>
        <trans-unit id="791862e9f3cc350adeb09357b5234c80bae1d2ca" translate="yes" xml:space="preserve">
          <source>Befriending templates...</source>
          <target state="translated">仲良しテンプレート...</target>
        </trans-unit>
        <trans-unit id="0cadc8aa8215fefdf5f07d0ddc606c6dc435a0e8" translate="yes" xml:space="preserve">
          <source>Boom! You get a linker error and you have no idea why it's failing. The reason is that the common library uses different versions of the same include &lt;code&gt;common_math.h&lt;/code&gt; (I have made it obvious here in the example by including a different path, but it might not always be so obvious. Maybe the include path is different in the compiler settings).</source>
          <target state="translated">ブーム！ リンカエラーが発生し、なぜ失敗するのかわかりません。 その理由は、共通ライブラリが同じinclude &lt;code&gt;common_math.h&lt;/code&gt; の異なるバージョンを使用しているためです（ここでは、例で別のパスを含めることでそれを明らかにしましたが、必ずしもそれほど明確ではない場合があります。インクルードパスがコンパイラ設定）。</target>
        </trans-unit>
        <trans-unit id="6bcaff46ce13c984e730553cee278ae1c9aa1951" translate="yes" xml:space="preserve">
          <source>Building one library with &lt;code&gt;UNICODE&lt;/code&gt; defined and attempting to link it in a project where &lt;code&gt;UNICODE&lt;/code&gt; is not defined will result in linker errors since there will be a mismatch in the definition of &lt;code&gt;TCHAR&lt;/code&gt;; &lt;code&gt;char&lt;/code&gt; vs. &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UNICODE&lt;/code&gt; が定義されたライブラリを1つ構築し、 &lt;code&gt;UNICODE&lt;/code&gt; が定義されていないプロジェクトでそれをリンクしようとすると、 &lt;code&gt;TCHAR&lt;/code&gt; の定義に不一致があるため、リンカーエラーが発生します。 &lt;code&gt;char&lt;/code&gt; 対 &lt;code&gt;wchar_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f699eafa666c4c4782584970203254bd4526ddb" translate="yes" xml:space="preserve">
          <source>But all the undefined &lt;em&gt;something&lt;/em&gt;s are declared in the header files you have
&lt;code&gt;#include&lt;/code&gt;d and are in fact defined in the libraries that you are linking.</source>
          <target state="translated">しかし、未定義の&lt;em&gt;何かは&lt;/em&gt;すべて &lt;code&gt;#include&lt;/code&gt; dを含むヘッダーファイルで宣言され、実際にはリンクしているライブラリで定義されています。</target>
        </trans-unit>
        <trans-unit id="04aa72c8afa3b9d7e1037f71bfc89ece6d7cb2d0" translate="yes" xml:space="preserve">
          <source>But when you try to link the program like:</source>
          <target state="translated">しかし、プログラムのようにリンクさせようとすると</target>
        </trans-unit>
        <trans-unit id="e3bc3b59b5238ebf3734cce36298c84c3eecbc4c" translate="yes" xml:space="preserve">
          <source>By default, a linkage command generated by GCC, on your distro,
consumes the files in the linkage from left to right in
commandline sequence. When it finds that a file refers to &lt;em&gt;something&lt;/em&gt;
and does not contain a definition for it, to will search for a definition
in files further to the right. If it eventually finds a definition, the
reference is resolved. If any references remain unresolved at the end,
the linkage fails: the linker does not search backwards.</source>
          <target state="translated">デフォルトでは、ディストリビューションでGCCによって生成されたリンケージコマンドは、リンケージ内のファイルをコマンドラインシーケンスで左から右に消費します。 ファイルが&lt;em&gt;何か&lt;/em&gt;を参照していて、その定義が含まれていないことがわかった場合、toはさらに右側のファイルで定義を検索します。 最終的に定義が見つかった場合、参照は解決されます。 最後に参照が未解決のままである場合、リンケージは失敗します。リンカは逆方向に検索しません。</target>
        </trans-unit>
        <trans-unit id="3eaf522e8926f987e615fe35f7fd9fdf75b655f7" translate="yes" xml:space="preserve">
          <source>Circular library dependency</source>
          <target state="translated">サーキュラーライブラリの依存性</target>
        </trans-unit>
        <trans-unit id="7241f66efa6b5c24d3508077d13fb171cabcc233" translate="yes" xml:space="preserve">
          <source>Class members:</source>
          <target state="translated">クラスのメンバー。</target>
        </trans-unit>
        <trans-unit id="aab52d092675fa0fe32cd101b3b21eff5dd78e87" translate="yes" xml:space="preserve">
          <source>Clean and rebuild</source>
          <target state="translated">クリーン化と再構築</target>
        </trans-unit>
        <trans-unit id="736a421be03fcda0d1784f7e1b58d5c6120e87ca" translate="yes" xml:space="preserve">
          <source>Clean the project (some IDEs have an option to do this, you can also
manually do it by deleting the object files)</source>
          <target state="translated">プロジェクトのクリーンアップ (IDEによってはこれを行うオプションがあります。オブジェクトファイルを削除することで手動で行うこともできます)</target>
        </trans-unit>
        <trans-unit id="3da20e0c7008360402f61cc375be71c5a21c62fe" translate="yes" xml:space="preserve">
          <source>Common causes include:</source>
          <target state="translated">一般的な原因としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="1d20937e648b620d3e08501c7d2a0f7ca4d36b1e" translate="yes" xml:space="preserve">
          <source>Common error messages are &lt;code&gt;error LNK2001&lt;/code&gt;, &lt;code&gt;error LNK1120&lt;/code&gt;, &lt;code&gt;error LNK2019&lt;/code&gt; for &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt; and &lt;code&gt;undefined reference to&lt;/code&gt;&lt;em&gt;symbolName&lt;/em&gt; for &lt;strong&gt;GCC&lt;/strong&gt;.</source>
          <target state="translated">一般的なエラーメッセージは、 &lt;code&gt;error LNK2001&lt;/code&gt; 、 &lt;code&gt;error LNK1120&lt;/code&gt; 、 &lt;strong&gt;Microsoft Visual Studioの&lt;/strong&gt; &lt;code&gt;error LNK2019&lt;/code&gt; &lt;em&gt;LNK2019&lt;/em&gt; 、および&lt;strong&gt;GCCの&lt;/strong&gt; &lt;em&gt;symbolName&lt;/em&gt;への &lt;code&gt;undefined reference to&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c3af93c7541eebebfdafcdd1eacb37d4febb317b" translate="yes" xml:space="preserve">
          <source>Common issues with class-type members</source>
          <target state="translated">クラスタイプのメンバーに共通する問題</target>
        </trans-unit>
        <trans-unit id="7ad8095ab9f470817988dae41ebaff6c8b167424" translate="yes" xml:space="preserve">
          <source>Commonly, each translation unit will generate an object file that contains the definitions of the symbols defined in that translation unit. 
To use those symbols, you have to link against those object files.</source>
          <target state="translated">一般的に、各翻訳ユニットは、その翻訳ユニットで定義されたシンボルの定義を含むオブジェクトファイルを生成します。これらのシンボルを使用するには、これらのオブジェクトファイルにリンクする必要があります。</target>
        </trans-unit>
        <trans-unit id="e08db17708c9f5aa2791cb6be1dcc8a1c79a541b" translate="yes" xml:space="preserve">
          <source>Compile your program:</source>
          <target state="translated">プログラムをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="db2b08b37977716ce6fab5afd8fb8ea79479ade1" translate="yes" xml:space="preserve">
          <source>Compile:</source>
          <target state="translated">Compile:</target>
        </trans-unit>
        <trans-unit id="679b3ff1ac1d63bde340799dcca67fa30e040c64" translate="yes" xml:space="preserve">
          <source>Compiler Time Error :</source>
          <target state="translated">コンパイラタイムエラー .</target>
        </trans-unit>
        <trans-unit id="c97768ea4c3948ab173981d2a5209cf05f227f68" translate="yes" xml:space="preserve">
          <source>Compiling a C++ program takes place in several steps, as specified by &lt;strong&gt;2.2&lt;/strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/8834196&quot;&gt;(credits to Keith Thompson for the reference)&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;2.2で&lt;/strong&gt;指定されているように、C ++プログラムのコンパイルはいくつかのステップで行われます&lt;a href=&quot;https://stackoverflow.com/a/8834196&quot;&gt;（参照用にキーストンプソンへのクレジット）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c137971fb4bd72b08a0b43c3008b2cca54a397e2" translate="yes" xml:space="preserve">
          <source>Create the libraries:</source>
          <target state="translated">ライブラリを作成します。</target>
        </trans-unit>
        <trans-unit id="7eaf2baed01488559bf5876cc3e60f17aa0d3628" translate="yes" xml:space="preserve">
          <source>DUMPBIN is your friend, if you are using Visual Studio. I'm sure other compilers have other similar tools.</source>
          <target state="translated">Visual Studioを使っているなら、DUMPBINはあなたの味方です。他のコンパイラにも似たようなツールがあると思います。</target>
        </trans-unit>
        <trans-unit id="719eb91a47aa71cdb65cf6c453c5e6fe62c3c90d" translate="yes" xml:space="preserve">
          <source>Data on what libraries are included in the link stage,</source>
          <target state="translated">リンクステージにどのようなライブラリが含まれているかのデータ。</target>
        </trans-unit>
        <trans-unit id="6773b3ac6ff9506cd52f19d8964c02fa4b90c9ba" translate="yes" xml:space="preserve">
          <source>Debugging the linker</source>
          <target state="translated">リンカのデバッグ</target>
        </trans-unit>
        <trans-unit id="849dcbe64c263df85f9b32a99f2eccecff6c214f" translate="yes" xml:space="preserve">
          <source>Declared and undefined variable or function.</source>
          <target state="translated">宣言された未定義の変数または関数。</target>
        </trans-unit>
        <trans-unit id="06460cd515ea02640e903aed7e4d4bb81068a27c" translate="yes" xml:space="preserve">
          <source>Declared but did not define a variable or function.</source>
          <target state="translated">宣言されたが、変数や関数は定義されていない。</target>
        </trans-unit>
        <trans-unit id="b75a543cd5362fb62c8422904fb2c049dcec7474" translate="yes" xml:space="preserve">
          <source>Declaring a destructor pure still requires you to define it (unlike a regular function):</source>
          <target state="translated">デストラクタを純粋に宣言するには、(通常の関数とは異なり)デストラクタを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="567a15d424904d304f2d20a37eae9e3dd0be401d" translate="yes" xml:space="preserve">
          <source>Define all your symbol which you declare in your header files</source>
          <target state="translated">ヘッダーファイルで宣言するすべてのシンボルを定義します。</target>
        </trans-unit>
        <trans-unit id="f5fce9ce350b9263578dfa2c8ab33e5e4582b42f" translate="yes" xml:space="preserve">
          <source>Definition does not exist</source>
          <target state="translated">定義が存在しない</target>
        </trans-unit>
        <trans-unit id="1023459cba9e87450771da5a88dadcad9181c40b" translate="yes" xml:space="preserve">
          <source>Definition exists</source>
          <target state="translated">定義が存在する</target>
        </trans-unit>
        <trans-unit id="1f545375f3315c66c74f5b0635778013cb0153c5" translate="yes" xml:space="preserve">
          <source>Different versions of libraries</source>
          <target state="translated">ライブラリの異なるバージョン</target>
        </trans-unit>
        <trans-unit id="0bee44622c3c31248d76530e7b83a53af7e4ae63" translate="yes" xml:space="preserve">
          <source>Do not forget to be consistent between the &quot;Release&quot; and &quot;Debug&quot; builds as well.</source>
          <target state="translated">リリース」ビルドと「デバッグ」ビルドの間でも一貫性を保つことを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="62a321049a9684009d639a42bfcab348659b0468" translate="yes" xml:space="preserve">
          <source>Dump the exported symbols from the library into a text file.</source>
          <target state="translated">ライブラリからエクスポートしたシンボルをテキストファイルにダンプします。</target>
        </trans-unit>
        <trans-unit id="6ee565a8ad9a2e6032a63ac1db58b7bceef88bc8" translate="yes" xml:space="preserve">
          <source>EDIT 1: Rewrote first section to be easier to understand. Please comment below to let me know if something else needs to be fixed. Thanks!</source>
          <target state="translated">EDIT 1:最初の部分をわかりやすく書き直しました。何か他に修正が必要なものがあれば、下にコメントしてください。ありがとうございます。</target>
        </trans-unit>
        <trans-unit id="80d3f81150da8848a606c766ad627406abc917e5" translate="yes" xml:space="preserve">
          <source>Each instance of a backslash character (\) immediately followed by a new-line character is deleted, splicing physical source lines to
  form logical source lines. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">バックスラッシュ文字（\）の直後に改行文字が続くインスタンスはそれぞれ削除され、物理ソース行が結合されて論理ソース行が形成されます。 &lt;em&gt;[をちょきちょきと切る]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8873c9e0ad822c5ad29c877287ca38e9d0fb8223" translate="yes" xml:space="preserve">
          <source>Each source character set member in a character literal or a string literal, as well as each escape sequence and universal-character-name
  in a character literal or a non-raw string literal, is converted to
  the corresponding member of the execution character set; &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">文字リテラルまたは文字列リテラルの各ソース文字セットメンバー、および文字リテラルまたは非raw文字列リテラルの各エスケープシーケンスとユニバーサル文字名は、実行文字セットの対応するメンバーに変換されます。 &lt;em&gt;[をちょきちょきと切る]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd08fa75ce4c1bea641e5c3ae90f422742fd49a5" translate="yes" xml:space="preserve">
          <source>Equivalently, instead of being defined in a C program, the function (or variable) &lt;code&gt;void foo()&lt;/code&gt; was defined in C++ but with C linkage:</source>
          <target state="translated">同様に、Cプログラムで定義される代わりに、関数（または変数） &lt;code&gt;void foo()&lt;/code&gt; がC ++で定義されましたが、Cリンケージが使用されていました。</target>
        </trans-unit>
        <trans-unit id="50e31b9308416dd3a4f92b2300aa9833c975e02b" translate="yes" xml:space="preserve">
          <source>Even though this is a pretty old questions with multiple accepted answers, I'd like to share how to resolve an &lt;strong&gt;obscure&lt;/strong&gt; &quot;undefined reference to&quot; error.</source>
          <target state="translated">これはかなり古い質問で、複数の回答が受け入れられていますが、 &lt;strong&gt;あいまいな&lt;/strong&gt; 「未定義の参照」エラーを解決する方法を共有したいと思います。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="0f313c64cf7c57de167dfc0b70285d2f1097cf2a" translate="yes" xml:space="preserve">
          <source>Examples are in C. They could equally well be C++</source>
          <target state="translated">例はC言語で書かれていますが、C++でも同様に可能です。</target>
        </trans-unit>
        <trans-unit id="6c8eeaf8a4d91827c91eda47c067002b02303f4f" translate="yes" xml:space="preserve">
          <source>Failure to link against appropriate libraries/object files or compile implementation files</source>
          <target state="translated">適切なライブラリオブジェクトファイルとのリンクや実装ファイルのコンパイルに失敗しました。</target>
        </trans-unit>
        <trans-unit id="c24bada60625ab3c77ffebca4ef956b5b8222f43" translate="yes" xml:space="preserve">
          <source>First, &lt;strong&gt;example 1&lt;/strong&gt;, with static library &lt;code&gt;my_lib.a&lt;/code&gt;</source>
          <target state="translated">最初に、静的ライブラリ &lt;code&gt;my_lib.a&lt;/code&gt; を使用した&lt;strong&gt;例1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c8a30a094da8c776a823c101decae831165f64e" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;XCode&lt;/strong&gt;:  Add the User Header Search Paths -&amp;gt; add the Library Search Path -&amp;gt; drag and drop the actual library reference into the project folder.</source>
          <target state="translated">&lt;strong&gt;XCodeの場合&lt;/strong&gt; ：ユーザーヘッダー検索パスを追加-&amp;gt;ライブラリ検索パスを追加-&amp;gt;実際のライブラリ参照をプロジェクトフォルダーにドラッグアンドドロップします。</target>
        </trans-unit>
        <trans-unit id="ba1b34dc3bbed11c2c9a66d05612d54f9428db05" translate="yes" xml:space="preserve">
          <source>For MSVC, &lt;code&gt;/VERBOSE&lt;/code&gt; (in particular &lt;code&gt;/VERBOSE:LIB&lt;/code&gt;) is added to the link command line.</source>
          <target state="translated">MSVCの場合、 &lt;code&gt;/VERBOSE&lt;/code&gt; （特に &lt;code&gt;/VERBOSE:LIB&lt;/code&gt; ）がリンクコマンドラインに追加されます。</target>
        </trans-unit>
        <trans-unit id="0ac9cca66a7ce03b39143760b921f502a3b2b9ee" translate="yes" xml:space="preserve">
          <source>For each file with extension .cpp is generated an object file .o and also Visual Studio writes the output in a file named &lt;em&gt;ProjectName.Cpp.Clean.txt&lt;/em&gt; which contains all object files that must be processed by the linker.</source>
          <target state="translated">拡張子が.cppのファイルごとにオブジェクトファイル.oが生成され、Visual Studioは出力を&lt;em&gt;ProjectName.Cpp.Clean.txt&lt;/em&gt;という名前のファイルに書き込みます。このファイルには、リンカーで処理する必要のあるすべてのオブジェクトファイルが含まれています。</target>
        </trans-unit>
        <trans-unit id="ce276678b262778ed8f87dcee2e92b419fef8499" translate="yes" xml:space="preserve">
          <source>For example we have some code</source>
          <target state="translated">例えば、次のようなコードがあります。</target>
        </trans-unit>
        <trans-unit id="2fa6951fcb69e2353b69b4e4f3615ca4d9cc266b" translate="yes" xml:space="preserve">
          <source>For example, if we have a function called foo defined in a.cpp:</source>
          <target state="translated">例えば、a.cpp で foo という関数が定義されているとします。</target>
        </trans-unit>
        <trans-unit id="5c105ae3962497b6a56958a1bf2d2d4a31d03dae" translate="yes" xml:space="preserve">
          <source>For example, the following would generate an error:</source>
          <target state="translated">例えば、以下のようにするとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="f2fcc968e71dd0b01c575698c3cd328beb1f8547" translate="yes" xml:space="preserve">
          <source>For further explanation and another possible solution (explicit instantiation) see &lt;a href=&quot;https://stackoverflow.com/questions/495021&quot;&gt;this question and answer&lt;/a&gt;.</source>
          <target state="translated">詳細な説明と考えられる別の解決策（明示的なインスタンス化）については、 &lt;a href=&quot;https://stackoverflow.com/questions/495021&quot;&gt;この質問と回答を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6d26f3d31b9f80c9041094ecd1bfa2cf4a14f452" translate="yes" xml:space="preserve">
          <source>For gcc and clang; you would typically add &lt;code&gt;-v -Wl,--verbose&lt;/code&gt; or &lt;code&gt;-v -Wl,-v&lt;/code&gt; to the command line. More details can be found here;</source>
          <target state="translated">gccおよびclangの場合。 通常は、コマンドラインに &lt;code&gt;-v -Wl,-v&lt;/code&gt; または-v -Wl、-vを追加します。 詳細については、こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="44635ad90325eff295e74bdeb91fbd8d078fabb1" translate="yes" xml:space="preserve">
          <source>For people coming from C it might be a surprise that in C++ global &lt;code&gt;const&lt;/code&gt;variables have internal (or static) linkage. In C this was not the case, as all global variables are implicitly &lt;code&gt;extern&lt;/code&gt; (i.e. when the &lt;code&gt;static&lt;/code&gt; keyword is missing).</source>
          <target state="translated">Cから来た人にとって、C ++ではグローバル &lt;code&gt;const&lt;/code&gt; 変数に内部（または静的）リンケージがあることは驚くかもしれません。 Cでは、すべてのグローバル変数が暗黙的に &lt;code&gt;extern&lt;/code&gt; であるため （つまり、 &lt;code&gt;static&lt;/code&gt; キーワードがない場合）、これは当てはまりませんでした。</target>
        </trans-unit>
        <trans-unit id="02ff37d17fe54fa59b6bdb89b9051f68c4f95602" translate="yes" xml:space="preserve">
          <source>For this to work, declare &lt;code&gt;X::foo()&lt;/code&gt; as pure:</source>
          <target state="translated">これを機能させるには、 &lt;code&gt;X::foo()&lt;/code&gt; を純粋として宣言します。</target>
        </trans-unit>
        <trans-unit id="d3b72bbcef1b0d4a5a3e0732613861aff970d936" translate="yes" xml:space="preserve">
          <source>Function return type, parameter number and types, and calling convention do not all exactly agree.</source>
          <target state="translated">関数の戻り値の型、パラメータ番号と型、呼び出し規則は、すべてが完全に一致しているわけではありません。</target>
        </trans-unit>
        <trans-unit id="adc354e3ed859611982bdeb24ea70c92b2b599b8" translate="yes" xml:space="preserve">
          <source>Function/variable declared as class member, defined as global (or vice versa).</source>
          <target state="translated">クラスのメンバとして宣言された関数変数は、グローバルとして定義されます(またはその逆)。</target>
        </trans-unit>
        <trans-unit id="c9e1736897f86f0f0ebd9367dfa1e73b18c72dbc" translate="yes" xml:space="preserve">
          <source>Function/variable declared in one namespace, defined in another.</source>
          <target state="translated">ある名前空間で宣言され、別の名前空間で定義された関数変数。</target>
        </trans-unit>
        <trans-unit id="47885f9296315b51d23680105388ad37c4f8daa9" translate="yes" xml:space="preserve">
          <source>Further elaboration with an example</source>
          <target state="translated">例を挙げてさらに精緻化</target>
        </trans-unit>
        <trans-unit id="1109ab69f5f30dff37d3dd93730a44c1ec557703" translate="yes" xml:space="preserve">
          <source>Given the code snippet of a template type with a friend operator (or function);</source>
          <target state="translated">フレンド演算子(または関数)を持つテンプレート型のコードスニペットを与えます。</target>
        </trans-unit>
        <trans-unit id="87a3d534ea37016d34d8be0559ae5f64128cdd0b" translate="yes" xml:space="preserve">
          <source>Here are &lt;a href=&quot;https://stackoverflow.com/questions/24715864/problems-importing-libraries-to-my-c-project-how-to-fix-this/24715865#24715865&quot;&gt;case1&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16&quot;&gt;case2&lt;/a&gt; handled in more detail from a &lt;em&gt;real world&lt;/em&gt; problem.</source>
          <target state="translated">以下は、 &lt;em&gt;現実の&lt;/em&gt;問題からより詳細に処理された&lt;a href=&quot;https://stackoverflow.com/questions/24715864/problems-importing-libraries-to-my-c-project-how-to-fix-this/24715865#24715865&quot;&gt;case1&lt;/a&gt;と&lt;a href=&quot;https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16&quot;&gt;case2&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b457236fd45d4cf88f436ca559e82a847ed891f5" translate="yes" xml:space="preserve">
          <source>How do linkers work? The linker matches a function declaration (declared in the header) with its definition (in the shared library) by comparing their signatures. You can get a linker error if the linker doesn't find a function definition that matches perfectly.</source>
          <target state="translated">リンカはどのように動作するのでしょうか?リンカは、関数宣言(ヘッダで宣言されている)とその定義(共有ライブラリ内の)のシグネチャを比較することで一致させます。リンカが完全に一致する関数定義を見つけられなかった場合、リンカエラーが発生することがあります。</target>
        </trans-unit>
        <trans-unit id="a4bca897be232f23b6899495a9467715ee2ea072" translate="yes" xml:space="preserve">
          <source>I can reproduce the problem in example 1, but not in example 2</source>
          <target state="translated">例1では問題を再現できますが、例2では再現できません。</target>
        </trans-unit>
        <trans-unit id="f16eb78437de212d219271bcd70b1ba35516fa2e" translate="yes" xml:space="preserve">
          <source>I edited the package (in the &lt;code&gt;packages&lt;/code&gt; folder inside the solution's directory) by finding &lt;code&gt;packagename\build\native\packagename.targets&lt;/code&gt; and inside that file, copying all the &lt;code&gt;v110&lt;/code&gt; sections.  I changed the &lt;code&gt;v110&lt;/code&gt; to &lt;code&gt;v120&lt;/code&gt; in &lt;strong&gt;the condition fields only&lt;/strong&gt; being very careful to leave the filename paths all as &lt;code&gt;v110&lt;/code&gt;.  This simply allowed Visual Studio 2013 to link to the libraries for 2012, and in this case, it worked.</source>
          <target state="translated">&lt;code&gt;packagename\build\native\packagename.targets&lt;/code&gt; とそのファイル内を検索し、すべての &lt;code&gt;v110&lt;/code&gt; セクションをコピーして、パッケージを（ソリューションのディレクトリ内の &lt;code&gt;packages&lt;/code&gt; フォルダーに）編集しました。 &lt;strong&gt;条件フィールド&lt;/strong&gt;で &lt;code&gt;v110&lt;/code&gt; を &lt;code&gt;v120&lt;/code&gt; に変更しましたが、ファイル名のパスをすべて &lt;code&gt;v110&lt;/code&gt; のままにしておくことに非常に注意しています。 これにより、Visual Studio 2013が2012年のライブラリにリンクできるようになり、この場合は機能しました。</target>
        </trans-unit>
        <trans-unit id="e185b3c33f0b4245c7351066033029dca1ef7148" translate="yes" xml:space="preserve">
          <source>I had the same issue. Say i have projects MyProject and TestProject. I had effectively linked the lib file for MyProject to the TestProject. However, this lib file was produced as the DLL for the MyProject was built. Also, I did not contain source code for all methods in the MyProject, but only access to the DLL's entry points.</source>
          <target state="translated">私も同じ問題を抱えていました。私はMyProjectとTestProjectのプロジェクトを持っているとします。私はMyProjectのlibファイルをTestProjectに効果的にリンクしていました。しかし、この lib ファイルは MyProject の DLL がビルドされたときに生成されました。また、MyProjectのすべてのメソッドのソースコードは含まれていませんでしたが、DLLのエントリーポイントへのアクセスのみが含まれていました。</target>
        </trans-unit>
        <trans-unit id="0436bfc3fe0e52928141662af3daf087596cf26f" translate="yes" xml:space="preserve">
          <source>I have two projects: &lt;code&gt;graphics.lib&lt;/code&gt; and &lt;code&gt;main.exe&lt;/code&gt;. Both projects depend on &lt;code&gt;common_math.h&lt;/code&gt;. Suppose the library exports the following function:</source>
          <target state="translated">&lt;code&gt;graphics.lib&lt;/code&gt; &lt;code&gt;main.exe&lt;/code&gt; とmain.exeの 2つのプロジェクトがあります 。 どちらのプロジェクトも &lt;code&gt;common_math.h&lt;/code&gt; に依存しています 。 ライブラリが次の関数をエクスポートするとします。</target>
        </trans-unit>
        <trans-unit id="956a2ac958701d2f4ab6fa4fc484437f762915e0" translate="yes" xml:space="preserve">
          <source>I just had this problem trying to link libpng with Visual Studio 2013.  The problem is that the package file only had libraries for Visual Studio 2010 and 2012.</source>
          <target state="translated">私は、libpngをVisual Studio 2013にリンクしようとしたときに、この問題が発生しました。問題は、パッケージファイルには Visual Studio 2010 と 2012 用のライブラリしか含まれていなかったことです。</target>
        </trans-unit>
        <trans-unit id="e9b8b4b047b3721fecc60f4fca5ece4ff41298b6" translate="yes" xml:space="preserve">
          <source>I recently had this problem, and it turned out &lt;a href=&quot;https://stackoverflow.com/questions/27748699/unresolved-reference-to-constructor-which-is-defined/27748920#27748920&quot;&gt;it was a bug in Visual Studio Express 2013&lt;/a&gt;. I had to remove a source file from the project and re-add it to overcome the bug.</source>
          <target state="translated">最近この問題が発生しまし&lt;a href=&quot;https://stackoverflow.com/questions/27748699/unresolved-reference-to-constructor-which-is-defined/27748920#27748920&quot;&gt;たが、それはVisual Studio Express 2013のバグであることがわかりました&lt;/a&gt; 。 バグを克服するために、プロジェクトからソースファイルを削除して再度追加する必要がありました。</target>
        </trans-unit>
        <trans-unit id="1f2758b006cc08918b9f02973af12be1faec02a9" translate="yes" xml:space="preserve">
          <source>I was recently able to get rid of an unresolved external error in Visual Studio 2012 just by recompiling the offending file. When I re-built, the error went away.</source>
          <target state="translated">最近、問題のファイルを再コンパイルするだけで、Visual Studio 2012 の未解決の外部エラーを取り除くことができました。再構築したところ、エラーは消えました。</target>
        </trans-unit>
        <trans-unit id="3655c386da677b651bbf58700cb3b35ab01cf79c" translate="yes" xml:space="preserve">
          <source>I was using an alias to refer to &lt;code&gt;std::filesystem::path&lt;/code&gt;: filesystem is in the standard library since C++17 but my program needed to &lt;strong&gt;also compile in C++14&lt;/strong&gt; so I decided to use a variable alias:</source>
          <target state="translated">&lt;code&gt;std::filesystem::path&lt;/code&gt; を参照するためにエイリアスを使用していました：filesystemはC ++ 17以降の標準ライブラリに&lt;strong&gt;あります&lt;/strong&gt;が、プログラム&lt;strong&gt;はC ++ 14でもコンパイルする&lt;/strong&gt;必要があるため、変数エイリアスを使用することにしました。</target>
        </trans-unit>
        <trans-unit id="5173770afade73bcecf7a320d6a1ae32ba13af7d" translate="yes" xml:space="preserve">
          <source>I'll try to explain what is an &quot;undefined reference/unresolved external symbol&quot;.</source>
          <target state="translated">未定義参照未解決外部シンボル」とは何かを説明してみます。</target>
        </trans-unit>
        <trans-unit id="a04cfe5805e064fc6a684cbba78e89796fa1eff1" translate="yes" xml:space="preserve">
          <source>I've rejected some lines from output, because they do not matter</source>
          <target state="translated">出力からいくつかの行を拒否しました。</target>
        </trans-unit>
        <trans-unit id="2bb7febe7f23a580135ec4f7b408f003af4cb53e" translate="yes" xml:space="preserve">
          <source>If .cpp files depends on   additional .h files  in order to find symbols
that may or may not be defined in the file .cpp</source>
          <target state="translated">.cppファイルが追加の.hファイルに依存している場合、.cppファイルで定義されているかどうかわからないシンボルを見つけるために</target>
        </trans-unit>
        <trans-unit id="df67f3ef9d0be7171f81833f9b68966903db7af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;libfoo&lt;/code&gt; depends on &lt;code&gt;libbar&lt;/code&gt;, then your linkage correctly puts &lt;code&gt;libfoo&lt;/code&gt; before &lt;code&gt;libbar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;libbar&lt;/code&gt; に依存している場合、リンケージは &lt;code&gt;libbar&lt;/code&gt; 前に正しく配置します。</target>
        </trans-unit>
        <trans-unit id="461d3e959eb928d5e96fcebb9ba3f3fe9ab2bb40" translate="yes" xml:space="preserve">
          <source>If I just do:</source>
          <target state="translated">私がやるだけなら</target>
        </trans-unit>
        <trans-unit id="da08d2f992c3ccba47f676d81d16d167ac1f33a4" translate="yes" xml:space="preserve">
          <source>If Linker finds an external symbol in one static library he includes the symbol in the output of the project.However, if the library is shared( dynamic ) he doesn't include the code ( symbols ) in output, but  &lt;em&gt;Run-Time&lt;/em&gt; crashes may occur</source>
          <target state="translated">リンカが1つの静的ライブラリで外部シンボルを見つけた場合、そのシンボルはプロジェクトの出力に含まれますが、ライブラリがshared（dynamic）の場合、コード（シンボル）は出力に含まれませんが、 &lt;em&gt;ランタイム&lt;/em&gt;クラッシュが発生する可能性があります起こる</target>
        </trans-unit>
        <trans-unit id="980c254b69ed02be4226999c6e10d518c5a452c3" translate="yes" xml:space="preserve">
          <source>If an entire library is included in a header file (and was compiled as C code); the include will need to be as follows;</source>
          <target state="translated">ライブラリ全体がヘッダファイルに含まれている場合(Cコードとしてコンパイルされている場合)、インクルードは以下のようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="f26256c9ecf88ebe6b32a09b8f863a10b618c2ed" translate="yes" xml:space="preserve">
          <source>If exists one .cpp file in which the compiler could not find one symbol, a &lt;strong&gt;compiler time error&lt;/strong&gt; raises the message &lt;em&gt;Symbol x could not be found&lt;/em&gt;</source>
          <target state="translated">コンパイラーが1つのシンボルを見つけられなかった1つの.cppファイルが存在する場合、 &lt;strong&gt;コンパイラーの時間エラー&lt;/strong&gt;により、メッセージ&lt;em&gt;シンボルxが見つかりませんでした&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b01078c7a78e15aafb190fba7f0e6960757acba2" translate="yes" xml:space="preserve">
          <source>If one symbol could not be found in object files he also is searched in Additional Libraries.For adding a new library to a project &lt;strong&gt;Configuration properties&lt;/strong&gt; -&amp;gt; &lt;strong&gt;VC++ Directories&lt;/strong&gt;  -&amp;gt; &lt;strong&gt;Library Directories&lt;/strong&gt; and here you specified additional folder for searching libraries and &lt;strong&gt;Configuration properties&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Linker&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Input&lt;/strong&gt; for specifying the name of the library. 
-If the Linker could not find the symbol which you write in one .cpp he raises a &lt;strong&gt;linker time error&lt;/strong&gt; which may sound like 
&lt;code&gt;error LNK2001: unresolved external symbol &quot;void __cdecl foo(void)&quot; (?foo@@YAXXZ)&lt;/code&gt;</source>
          <target state="translated">オブジェクトファイルで1つのシンボルが見つからなかった場合は、追加ライブラリでも検索されます。プロジェクトに新しいライブラリを追加するには、 &lt;strong&gt;構成プロパティ&lt;/strong&gt; -&amp;gt; &lt;strong&gt;VC ++ディレクトリ&lt;/strong&gt; -&amp;gt; &lt;strong&gt;ライブラリディレクトリで&lt;/strong&gt; 、ライブラリと&lt;strong&gt;構成プロパティ&lt;/strong&gt;を検索するための追加フォルダーを指定し&lt;strong&gt;ます&lt;/strong&gt; -&amp;gt; &lt;strong&gt;リンカー&lt;/strong&gt; -&amp;gt;ライブラリの名前を指定するための&lt;strong&gt;入力&lt;/strong&gt; 。 -リンカーが1つの.cppで記述したシンボルを見つけられなかった場合、 &lt;strong&gt;リンカーは&lt;/strong&gt; &lt;code&gt;error LNK2001: unresolved external symbol &quot;void __cdecl foo(void)&quot; (?foo@@YAXXZ)&lt;/code&gt; ように聞こえる&lt;strong&gt;リンカー時間エラー&lt;/strong&gt;を発生させます：未解決の外部シンボル &quot;void __cdecl foo（void）&quot;（？foo @@ YAXXZ）</target>
        </trans-unit>
        <trans-unit id="499b77dbfc0604ee9598e32b2d28291c11fb0b8e" translate="yes" xml:space="preserve">
          <source>If that is true, then the linker will &lt;em&gt;not&lt;/em&gt; copy any chunks out of &lt;code&gt;libz&lt;/code&gt; and
add them to your program; instead, it will just doctor the code of your program 
so that:-</source>
          <target state="translated">それが真の場合、リンカは &lt;code&gt;libz&lt;/code&gt; からチャンクをコピーしてプログラムに追加し&lt;em&gt;ません&lt;/em&gt; 。 代わりに、それはあなたのプログラムのコードを単にドクターします：</target>
        </trans-unit>
        <trans-unit id="2c00c20b5f535cd9bc44be19371d9b66f3b65283" translate="yes" xml:space="preserve">
          <source>If that is true, then the linker will extract a copy of &lt;code&gt;my_lib.o&lt;/code&gt; from the library and
add it to your program. Then, your program contains a definition for &lt;code&gt;hw&lt;/code&gt;, so
its references to &lt;code&gt;hw&lt;/code&gt; are &lt;em&gt;resolved&lt;/em&gt;.</source>
          <target state="translated">それが真の場合、リンカはライブラリから &lt;code&gt;my_lib.o&lt;/code&gt; のコピーを抽出し、プログラムに追加します。 次に、プログラムに &lt;code&gt;hw&lt;/code&gt; の定義が含まれているため、 hwへの参照が&lt;em&gt;解決され&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="38c0025e9bec005d4513bd13d86176f0298b0557" translate="yes" xml:space="preserve">
          <source>If the implementation is outside the class definition, but in a header, the methods have to be marked as &lt;code&gt;inline&lt;/code&gt; to prevent a multiple definition.</source>
          <target state="translated">実装がクラス定義の外部にあるがヘッダー内にある場合、複数の定義を防ぐためにメソッドを &lt;code&gt;inline&lt;/code&gt; としてマークする必要があります。</target>
        </trans-unit>
        <trans-unit id="75447576423c30e2c34a784049e8ce92fc59db32" translate="yes" xml:space="preserve">
          <source>If we want to call some functions in a library, but the import library is not added into the additional dependency list (set from: &lt;code&gt;Project | Properties | Configuration Properties | Linker | Input | Additional Dependency&lt;/code&gt;) of your project setting. Now the linker will report a LNK2019 since the definition does not exist in current searching scope.</source>
          <target state="translated">ライブラリの一部の関数を呼び出したいが、インポートライブラリが &lt;code&gt;Project | Properties | Configuration Properties | Linker | Input | Additional Dependency&lt;/code&gt; 設定の追加の依存関係リスト（ プロジェクト|プロパティ|構成プロパティ|リンカー|入力|追加の依存関係から設定）に追加されていない場合。 現在、定義は現在の検索範囲に存在しないため、リンカーはLNK2019を報告します。</target>
        </trans-unit>
        <trans-unit id="fb9269e2b18055a742c1557e6ab1048d1318a42e" translate="yes" xml:space="preserve">
          <source>If you get linker errors about undefined references to symbols that involve types in the std::__cxx11 namespace or the tag [abi:cxx11] then it probably indicates that you are trying to link together object files that were compiled with different values for the _GLIBCXX_USE_CXX11_ABI macro. This commonly happens when linking to a third-party library that was compiled with an older version of GCC. If the third-party library cannot be rebuilt with the new ABI then you will need to recompile your code with the old ABI.</source>
          <target state="translated">std::__cxx11 名前空間またはタグ [abi:cxx11]の型を含むシンボルへの未定義の参照についてリンカエラーが発生した場合、おそらく、_GLIBCXX_USE_CXX11_ABI マクロに対して異なる値でコンパイルされたオブジェクトファイルをリンクしようとしていることを示しています。これは、古いバージョンの GCC でコンパイルされたサードパーティ製のライブラリにリンクする場合によく発生します。サードパーティライブラリを新しい ABI で再構築できない場合は、古い ABI でコードを再コンパイルする必要があります。</target>
        </trans-unit>
        <trans-unit id="f035da38c9a7e86389d0510b74c92ffc7c0c115a" translate="yes" xml:space="preserve">
          <source>If you're using Microsoft Visual Studio, you'll see that projects generate &lt;code&gt;.lib&lt;/code&gt; files. These contain a table of exported symbols, and a table of imported symbols. The imported symbols are resolved against the libraries you link against, and the exported symbols are provided for the libraries that use that &lt;code&gt;.lib&lt;/code&gt; (if any).</source>
          <target state="translated">Microsoft Visual Studioを使用している場合は、プロジェクトが &lt;code&gt;.lib&lt;/code&gt; ファイルを生成することがわかります。 これらには、エクスポートされたシンボルのテーブルとインポートされたシンボルのテーブルが含まれています。 インポートされたシンボルは、リンク先のライブラリに対して解決され、エクスポートされたシンボルは、その &lt;code&gt;.lib&lt;/code&gt; （存在する場合）を使用するライブラリに提供されます。</target>
        </trans-unit>
        <trans-unit id="8833aea382a302f646216649f9921b661839e34c" translate="yes" xml:space="preserve">
          <source>If your IDE supports &lt;em&gt;Plain Console Projects&lt;/em&gt; you might want to choose this project type, instead of a windows application project.</source>
          <target state="translated">IDEが&lt;em&gt;プレーンコンソールプロジェクト&lt;/em&gt;をサポートしている場合は、Windowsアプリケーションプロジェクトではなく、このプロジェクトタイプを選択できます。</target>
        </trans-unit>
        <trans-unit id="3f237fb8dc4cacf36f11d31545ebe99a25aef03b" translate="yes" xml:space="preserve">
          <source>In Windows programming, the tell-tale sign that you did not link a necessary library is that the name of the unresolved symbol begins with &lt;code&gt;__imp_&lt;/code&gt;. Look up the name of the function in the documentation, and it should say which library you need to use. For example, MSDN puts the information in a box at the bottom of each function in a section called &quot;Library&quot;.</source>
          <target state="translated">Windowsプログラミングでは、必要なライブラリをリンクしなかったことを示す兆候は、未解決のシンボルの名前が &lt;code&gt;__imp_&lt;/code&gt; で始まることです 。 ドキュメントで関数の名前を検索すると、使用する必要があるライブラリが示されているはずです。 たとえば、MSDNは、「ライブラリ」というセクションの各関数の下部にあるボックスに情報を配置します。</target>
        </trans-unit>
        <trans-unit id="66430e667fc7f840b097b706996793b9736a8e56" translate="yes" xml:space="preserve">
          <source>In addition to the library path including the directory of the library, this should be the full name of the library.</source>
          <target state="translated">ライブラリのディレクトリを含むライブラリパスに加えて、ライブラリのフルネームである必要があります。</target>
        </trans-unit>
        <trans-unit id="10bf6a64e5446398af8a3ba19c87d193fc7bdd0c" translate="yes" xml:space="preserve">
          <source>In b.cpp we want to call function foo, so we add</source>
          <target state="translated">b.cppでは、関数fooを呼び出したいので</target>
        </trans-unit>
        <trans-unit id="e04d65d1151fc1eecd729107e8faa2882c68cf4a" translate="yes" xml:space="preserve">
          <source>In general the IDE or build will include some form of &quot;clean&quot; function, but this may not be correctly configured (e.g. in a manual makefile) or may fail (e.g. the intermediate or resultant binaries are read-only).</source>
          <target state="translated">一般的に IDE やビルドには何らかの形の &quot;クリーン&quot; 関数が含まれていますが、これが正しく設定されていなかったり (例:手動 makefile)、失敗する可能性があります (例:中間バイナリや結果のバイナリが読み取り専用になっている)。</target>
        </trans-unit>
        <trans-unit id="6703e5641bd382c96b9757b2f2d5f1a0d78b8aef" translate="yes" xml:space="preserve">
          <source>In that case, it means that the available symbols are for a different architecture than the one you are compiling for.</source>
          <target state="translated">この場合、利用可能なシンボルがコンパイルしているものとは異なるアーキテクチャ用のものであることを意味します。</target>
        </trans-unit>
        <trans-unit id="dc33cdb4c80f7ba7f9c92526e532ade7bc8fcd31" translate="yes" xml:space="preserve">
          <source>In the sequence of object files and libraries you want to link to make your
program, you are placing the libraries before the object files that refer to
them. You need to place the libraries &lt;em&gt;after&lt;/em&gt; the object files that refer
to them.</source>
          <target state="translated">プログラムを作成するためにリンクするオブジェクトファイルとライブラリのシーケンスでは、それらを参照するオブジェクトファイルの前にライブラリを配置します。 ライブラリを参照するオブジェクトファイルの&lt;em&gt;後&lt;/em&gt;にライブラリを配置する必要があります。</target>
        </trans-unit>
        <trans-unit id="b2551cda3851296856857b433cfe97a4cfb2b4c9" translate="yes" xml:space="preserve">
          <source>Inconsistent &lt;code&gt;UNICODE&lt;/code&gt; definitions</source>
          <target state="translated">一貫性のない &lt;code&gt;UNICODE&lt;/code&gt; 定義</target>
        </trans-unit>
        <trans-unit id="6fe63eb632221a0ab5535bb76d4c287ae69ff6c4" translate="yes" xml:space="preserve">
          <source>Incorrectly importing/exporting methods/classes across modules/dll (compiler specific).</source>
          <target state="translated">modulesdll (コンパイラ固有)にまたがってメソッドクラスを誤ってインポートしてしまう。</target>
        </trans-unit>
        <trans-unit id="dcc92bce0411701f86858935b384ecc04c852ca4" translate="yes" xml:space="preserve">
          <source>Incorrectly importing/exporting methods/classes across modules/dll. (MSVS specific)</source>
          <target state="translated">modulesdllをまたいでmethodclassを誤ってインポートしてエクスポートしています。(MSVS 固有の)</target>
        </trans-unit>
        <trans-unit id="cb120259d25bd6e5201a19869cfd5a9742881496" translate="yes" xml:space="preserve">
          <source>Interdependent library order</source>
          <target state="translated">相互依存性のあるライブラリオーダー</target>
        </trans-unit>
        <trans-unit id="503e384f0e4e309c11e3d62de8daa731f1a8d2b6" translate="yes" xml:space="preserve">
          <source>Is it possible to still get a linker error even though the declaration and the definition seem to match? Yes! They might look the same in source code, but it really depends on what the compiler sees. Essentially you could end up with a situation like this:</source>
          <target state="translated">宣言と定義が一致しているように見えても、リンカエラーが発生することはありますか?はい、可能です。ソース・コード上では同じように見えるかもしれませんが、コンパイラが何を見ているかによります。基本的にはこのような状況になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="771fa3988067ff8a58eabb454bbc75170f08c3d6" translate="yes" xml:space="preserve">
          <source>It can also happen that you forget to add the file to the compilation, in which case the object file won't be generated. In &lt;strong&gt;gcc&lt;/strong&gt; you'd add the files to the command line. In &lt;strong&gt;MSVS&lt;/strong&gt; adding the file to the project will make it compile it automatically (albeit files can, manually, be individually excluded from the build).</source>
          <target state="translated">また、ファイルをコンパイルに追加するのを忘れている場合もあります。その場合、オブジェクトファイルは生成されません。 &lt;strong&gt;gcc&lt;/strong&gt;では、ファイルをコマンドラインに追加します。 &lt;strong&gt;MSVSでは&lt;/strong&gt; 、ファイルをプロジェクトに追加すると、自動的にコンパイルされます（ただし、ファイルを手動で個別にビルドから除外することはできます）。</target>
        </trans-unit>
        <trans-unit id="fe2ed6691d966ca4bdd41bbcc54c815e1cd0e42a" translate="yes" xml:space="preserve">
          <source>It has happened because our local_var_name is static, i.e. it is not visible for other modules. 
Now more deeply. Get the translation phase output</source>
          <target state="translated">これは、私たちの local_var_name が静的なので、他のモジュールからは見えないようになっています。ここで、より深く掘り下げてみましょう。翻訳フェーズの出力を取得する</target>
        </trans-unit>
        <trans-unit id="627cb145db504cc28647105b8ad1ef86f1340665" translate="yes" xml:space="preserve">
          <source>It is uneconomical at &lt;em&gt;runtime&lt;/em&gt;, because it can cause shared libraries to be
loaded along with a program even if doesn't need them.</source>
          <target state="translated">&lt;em&gt;実行時&lt;/em&gt;に共有ライブラリを必要としない場合でも、プログラムと一緒にロードされる可能性があるため、これは&lt;em&gt;実行時&lt;/em&gt;に不経済です。</target>
        </trans-unit>
        <trans-unit id="13f85c801fb44532a6193ffc156ba3a1273c4b81" translate="yes" xml:space="preserve">
          <source>LLVM &lt;a href=&quot;http://llvm.org/releases/3.6.2/docs/CommandGuide/llvm-link.html#cmdoption-v&quot;&gt;linker page&lt;/a&gt;.</source>
          <target state="translated">LLVM &lt;a href=&quot;http://llvm.org/releases/3.6.2/docs/CommandGuide/llvm-link.html#cmdoption-v&quot;&gt;リンカーページ&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8b4459da7b6461b4c2299ccc79bca1d6aa1bc0f" translate="yes" xml:space="preserve">
          <source>Lastly, the &lt;code&gt;pkg-config&lt;/code&gt; variation of example 2 has a now obvious explanation.
After shell-expansion:</source>
          <target state="translated">最後に、例2の &lt;code&gt;pkg-config&lt;/code&gt; バリエーションには、明らかな説明があります。 シェル展開後：</target>
        </trans-unit>
        <trans-unit id="46640750de5d6c26ef3345516697c4c8de1c5c05" translate="yes" xml:space="preserve">
          <source>Let's say I have three files: main.cpp, file.h, file.cpp:</source>
          <target state="translated">例えば、main.cpp、file.h、file.cppの3つのファイルがあるとします。</target>
        </trans-unit>
        <trans-unit id="8fb4c3c64119c8c2cdfc81bebdd5f927b932e0aa" translate="yes" xml:space="preserve">
          <source>Link example 1 correctly:</source>
          <target state="translated">リンク例1を正しく表示します。</target>
        </trans-unit>
        <trans-unit id="bd65393a1e1fc0de6adb743f6af3918125bb0ecc" translate="yes" xml:space="preserve">
          <source>Link example 2 correctly:</source>
          <target state="translated">リンク例2を正しくリンクします。</target>
        </trans-unit>
        <trans-unit id="eff7b8e1e01a437aa7f86d07bd975b1d3e3d6b4f" translate="yes" xml:space="preserve">
          <source>Link invocation (command line),</source>
          <target state="translated">リンク呼び出し(コマンドライン)。</target>
        </trans-unit>
        <trans-unit id="4da0c7603f707d809b67abb53db4ebf240bc0929" translate="yes" xml:space="preserve">
          <source>Link our object files</source>
          <target state="translated">オブジェクトファイルをリンクする</target>
        </trans-unit>
        <trans-unit id="b4235ce9a11da86196b06273997efb6e1bb09f1b" translate="yes" xml:space="preserve">
          <source>Link the example 2 &lt;code&gt;pkg-config&lt;/code&gt; variation correctly:</source>
          <target state="translated">例2の &lt;code&gt;pkg-config&lt;/code&gt; バリエーションを正しくリンクします。</target>
        </trans-unit>
        <trans-unit id="a67761a97541734d3b1dd08a0be04d93cf4eb6b1" translate="yes" xml:space="preserve">
          <source>Linker Time Error</source>
          <target state="translated">左タイムエラー</target>
        </trans-unit>
        <trans-unit id="93df95814a97d8e558d63057388f44e8335ec3a6" translate="yes" xml:space="preserve">
          <source>Linker errors can happen when a header file and its associated shared library (.lib file) go out of sync. Let me explain.</source>
          <target state="translated">リンカエラーは、ヘッダファイルとそれに関連する共有ライブラリ(.libファイル)が同期しなくなったときに発生することがあります。説明しましょう。</target>
        </trans-unit>
        <trans-unit id="2f12c9c12e76e06c4529ab38bf1b266c849ada4a" translate="yes" xml:space="preserve">
          <source>Linker sees exported symbols and links it. Now we try to uncomment lines in src2.cpp like here</source>
          <target state="translated">リンカはエクスポートされたシンボルを見てリンクします。ここでは src2.cpp の行のコメントを解除してみます。</target>
        </trans-unit>
        <trans-unit id="ff5d8fd0650014513ae22d4ad7c2df789c1613a9" translate="yes" xml:space="preserve">
          <source>Linux &lt;a href=&quot;http://linux.die.net/man/1/ld&quot;&gt;ld man page&lt;/a&gt;.</source>
          <target state="translated">Linux &lt;a href=&quot;http://linux.die.net/man/1/ld&quot;&gt;ldのマニュアルページ&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="1602232f4b5e2f467a8d3b007a0131ae5384e107" translate="yes" xml:space="preserve">
          <source>MSVS requires you to specify which symbols to export and import using &lt;code&gt;__declspec(dllexport)&lt;/code&gt; and &lt;code&gt;__declspec(dllimport)&lt;/code&gt;.</source>
          <target state="translated">MSVSでは、 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; および &lt;code&gt;__declspec(dllimport)&lt;/code&gt; を使用して、エクスポートおよびインポートするシンボルを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="976f170a12de6c4ee60dc922bc6d9db457f350ab" translate="yes" xml:space="preserve">
          <source>Make object files</source>
          <target state="translated">オブジェクトファイルの作成</target>
        </trans-unit>
        <trans-unit id="daa6e7741bcaa1754abaefe5829b55e9e65ff067" translate="yes" xml:space="preserve">
          <source>Make sure that your external library doesn't contain symbols that may enter into conflict with other symbols you defined in your header files</source>
          <target state="translated">外部ライブラリに、ヘッダファイルで定義した他のシンボルと競合する可能性のあるシンボルが含まれていないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="9923a08fcadb46cb599ab38321c7d4b2a14511aa" translate="yes" xml:space="preserve">
          <source>Make sure you write your c++ project syntactical correct.</source>
          <target state="translated">c++プロジェクトを構文的に正しく書くことを確認してください。</target>
        </trans-unit>
        <trans-unit id="90926b930049fc977cdcf047eff29fccda6c34ad" translate="yes" xml:space="preserve">
          <source>Many Linux distros today configure their GCC toolchain so that its language drivers (&lt;code&gt;gcc&lt;/code&gt;,&lt;code&gt;g++&lt;/code&gt;,&lt;code&gt;gfortran&lt;/code&gt; etc)
instruct the system linker (&lt;code&gt;ld&lt;/code&gt;) to link shared libraries on an &lt;em&gt;as-needed&lt;/em&gt; basis.
You have got one of those distros.</source>
          <target state="translated">今日、多くのLinuxディストリビューションは、言語ドライバー（ &lt;code&gt;gcc&lt;/code&gt; 、 &lt;code&gt;g++&lt;/code&gt; 、 &lt;code&gt;gfortran&lt;/code&gt; など）がシステムリンカー（ &lt;code&gt;ld&lt;/code&gt; ）に&lt;em&gt;必要に応じて&lt;/em&gt;共有ライブラリーをリンクするように指示するようにGCCツールチェーンを構成しています。 それらのディストリビューションの1つを入手しました。</target>
        </trans-unit>
        <trans-unit id="1ea292f71f513f2f49b3c0ecc19893f09a021ecf" translate="yes" xml:space="preserve">
          <source>Microsoft offers a &lt;code&gt;#pragma&lt;/code&gt; to reference the correct library at link time;</source>
          <target state="translated">Microsoftは、リンク時に正しいライブラリを参照するための &lt;code&gt;#pragma&lt;/code&gt; を提供しています。</target>
        </trans-unit>
        <trans-unit id="c84452b5c5beed02d4bfc0b6a144ddbc0f9f2c52" translate="yes" xml:space="preserve">
          <source>Missing &quot;extern&quot; in &lt;code&gt;const&lt;/code&gt; variable declarations/definitions (C++ only)</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 変数の宣言/定義に「extern」がない（C ++のみ）</target>
        </trans-unit>
        <trans-unit id="a0b0d93816c556d77f42fe7a2651c42eb165889f" translate="yes" xml:space="preserve">
          <source>Missing &quot;extern&quot; in const variable declarations/definitions (C++ only)</source>
          <target state="translated">const 変数宣言定義に &quot;extern&quot; がない (C++のみ)</target>
        </trans-unit>
        <trans-unit id="5eb6f3aa726cfe18f5057b4aefa2edb20315a029" translate="yes" xml:space="preserve">
          <source>Mistyping or not including the .lib extension when using the &lt;code&gt;#pragma&lt;/code&gt; (Microsoft Visual Studio)</source>
          <target state="translated">&lt;code&gt;#pragma&lt;/code&gt; （Microsoft Visual Studio）を使用するときに.lib拡張子を誤って入力するか、含めない</target>
        </trans-unit>
        <trans-unit id="f54d45d1a4464006ef586499c694d801d5a8d12c" translate="yes" xml:space="preserve">
          <source>More &lt;a href=&quot;https://gcc.gnu.org/wiki/Visibility&quot;&gt;information about visibility&lt;/a&gt; can be found on the gcc wiki.</source>
          <target state="translated">&lt;a href=&quot;https://gcc.gnu.org/wiki/Visibility&quot;&gt;可視性の&lt;/a&gt;詳細については、gcc wikiを参照してください。</target>
        </trans-unit>
        <trans-unit id="641fea9b7a86c80e1745eea04b284d17d7064212" translate="yes" xml:space="preserve">
          <source>Most modern linkers include a verbose option that prints out to varying degrees;</source>
          <target state="translated">最近のリンカの多くは、程度の差こそあれ、出力するための冗長オプションを含んでいます。</target>
        </trans-unit>
        <trans-unit id="e559ced22868458277e7a84fcf34818870da0124" translate="yes" xml:space="preserve">
          <source>Multiple source files of the same name</source>
          <target state="translated">同名の複数のソースファイル</target>
        </trans-unit>
        <trans-unit id="c767224b9650ce630e60df38453f62be584ffe15" translate="yes" xml:space="preserve">
          <source>Next, it finds &lt;code&gt;eg1.o&lt;/code&gt;, and adds it to be program. An object file in the
linkage sequence is always added to the program. Now, the program makes
a reference to &lt;code&gt;hw&lt;/code&gt;, and does not contain a definition of &lt;code&gt;hw&lt;/code&gt;; but
there is nothing left in the linkage sequence that could provide the missing
definition. The reference to &lt;code&gt;hw&lt;/code&gt; ends up &lt;em&gt;unresolved&lt;/em&gt;, and the linkage fails.</source>
          <target state="translated">次に、 &lt;code&gt;eg1.o&lt;/code&gt; を見つけ、それをプログラムとして追加します。 リンケージシーケンスのオブジェクトファイルは常にプログラムに追加されます。 現在、プログラムは &lt;code&gt;hw&lt;/code&gt; への参照を作成しており、 &lt;code&gt;hw&lt;/code&gt; の定義を含んでいません。 ただし、リンケージシーケンスには、定義が不足している可能性のあるものが何も残っていません。 &lt;code&gt;hw&lt;/code&gt; への参照が&lt;em&gt;未解決&lt;/em&gt;になり、リンケージが失敗します。</target>
        </trans-unit>
        <trans-unit id="f0d2f6223f521a208279e081a4e5a7ac2c7dd700" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;virtual&lt;/code&gt; class members</source>
          <target state="translated">非 &lt;code&gt;virtual&lt;/code&gt; クラスのメンバー</target>
        </trans-unit>
        <trans-unit id="117ed9998cfcf9683b519b2cfb916a1303481e8f" translate="yes" xml:space="preserve">
          <source>Note how even though both the function declarations look identical in source code, but they are really different according to the compiler.</source>
          <target state="translated">両方の関数の宣言がソースコード上では同じように見えても、コンパイラによって実際には異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5abbdb9f6a8ffe88fc827af5fbe46e7e3a900154" translate="yes" xml:space="preserve">
          <source>Note in this example, the linker would tell you it couldn't find &lt;code&gt;draw()&lt;/code&gt;, when in reality you know it obviously is being exported by the library. You could spend hours scratching your head wondering what went wrong. The thing is, the linker sees a different signature because the parameter types are slightly different. In the example, &lt;code&gt;vec3&lt;/code&gt; is a different type in both projects as far as the compiler is concerned. This could happen because they come from two slightly different include files (maybe the include files come from two different versions of the library).</source>
          <target state="translated">この例では、実際には明らかにライブラリによってエクスポートされていることがわかっている場合、リンカは &lt;code&gt;draw()&lt;/code&gt; が見つからなかったと通知します。 何がうまくいかないのかと頭を悩ませるのに何時間も費やす可能性があります。 問題は、パラメーターの型がわずかに異なるため、リンカーは異なるシグネチャを参照することです。 この例では、コンパイラに関する限り、 &lt;code&gt;vec3&lt;/code&gt; は両方のプロジェクトで異なるタイプです。 これは、2つのわずかに異なるインクルードファイルから取得されたために発生する可能性があります（インクルードファイルは2つの異なるバージョンのライブラリから取得された可能性があります）。</target>
        </trans-unit>
        <trans-unit id="23d4b3aa6710b3034b123422af2beef9dd73642c" translate="yes" xml:space="preserve">
          <source>Note the &lt;strong&gt;different libraries&lt;/strong&gt; used in main.cpp and file.h. Since main.cpp #include'd &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot; after &amp;lt;&lt;strong&gt;filesystem&lt;/strong&gt;&amp;gt;, the version of filesystem used there was &lt;strong&gt;the C++17 one&lt;/strong&gt;. I used to compile the program with the following commands:</source>
          <target state="translated">main.cppとfile.hで使用されている&lt;strong&gt;さまざまなライブラリに&lt;/strong&gt;注意してください。 main.cppは&amp;lt; &lt;strong&gt;filesystem&lt;/strong&gt; &amp;gt;の後に＃include'd &quot; &lt;strong&gt;file.h&lt;/strong&gt; &quot;したので、そこで使用されているファイルシステムのバージョンは&lt;strong&gt;C ++ 17のもの&lt;/strong&gt;でした。 以前は、次のコマンドを使用してプログラムをコンパイルしていました。</target>
        </trans-unit>
        <trans-unit id="6ce292ed7cabf956b3bed91089eb7d1238831776" translate="yes" xml:space="preserve">
          <source>Note the weird mangled name given in the linker error. (eg. draw@graphics@XYZ).</source>
          <target state="translated">リンカエラーで与えられた奇妙な名前に注意してください。(例:draw@graphics@XYZ)。</target>
        </trans-unit>
        <trans-unit id="3b2cfcdfa403dfa1ba5b0b9b3a8ea1bd2538d22c" translate="yes" xml:space="preserve">
          <source>Now when you build this code you will get a LNK2019 error complaining that foo is an unresolved symbol. In this case, we know that foo() has its definition in a.cpp, but different from the one we are calling(different return value). This is the case that definition exists.</source>
          <target state="translated">さて、このコードをビルドすると、fooが未解決のシンボルであるというLNK2019のエラーが出ます。この場合、foo()はa.cppに定義があることはわかっていますが、呼び出しているものとは違う(戻り値が違う)ことがわかっています。定義が存在する場合です。</target>
        </trans-unit>
        <trans-unit id="3fd0cadfd7a6c67e12488f6b0910e0bf6fc11715" translate="yes" xml:space="preserve">
          <source>OK (no errors), because we only build object file, linking is not done yet.
Try to link</source>
          <target state="translated">OK(エラーは出ません)、オブジェクトファイルをビルドしているだけなので、リンクはまだできていません。リンクしてみます。</target>
        </trans-unit>
        <trans-unit id="e251c8f846836883316a7f1bd7f47a5ca9918668" translate="yes" xml:space="preserve">
          <source>On Linux, it may be due to the wrong library folder (using &lt;code&gt;lib&lt;/code&gt; instead of &lt;code&gt;lib64&lt;/code&gt; for instance).</source>
          <target state="translated">Linuxでは、間違ったライブラリフォルダーが原因である可能性があります（たとえば、 &lt;code&gt;lib64&lt;/code&gt; の代わりに &lt;code&gt;lib&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="86966d8cfc106dd026001fc5ff966b8b3018c853" translate="yes" xml:space="preserve">
          <source>On MacOS, there is the option of shipping both architectures in the same file. It may be that the link expects both versions to be there, but only one is. It can also be an issue with the wrong &lt;code&gt;lib&lt;/code&gt;/&lt;code&gt;lib64&lt;/code&gt; folder where the library is picked up.</source>
          <target state="translated">MacOSでは、両方のアーキテクチャを同じファイルで出荷するオプションがあります。 リンクは両方のバージョンが存在することを期待している可能性がありますが、1つだけです。 また、ライブラリが取得された場所の &lt;code&gt;lib&lt;/code&gt; / &lt;code&gt;lib64&lt;/code&gt; フォルダーが間違っている可能性もあります。</target>
        </trans-unit>
        <trans-unit id="11ea8afa3c6fc752c5cd8f5e66cffa69d7e4417a" translate="yes" xml:space="preserve">
          <source>On Visual Studio, this is due to the wrong &quot;Platform&quot;, and you need to either select the proper one or install the proper version of the library.</source>
          <target state="translated">Visual Studioでは、これは「プラットフォーム」が間違っていることが原因で、適切なものを選択するか、適切なバージョンのライブラリをインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="457c63213d9d88bc27b8181901ab2f67874c5025" translate="yes" xml:space="preserve">
          <source>Once the &quot;clean&quot; has completed, verify that the &quot;clean&quot; has succeeded and all the generated intermediate file (e.g. an automated makefile) have been successfully removed.</source>
          <target state="translated">クリーン」が完了したら、「クリーン」が成功し、生成されたすべての中間ファイル(自動化された makefile など)が正常に削除されたことを確認してください。</target>
        </trans-unit>
        <trans-unit id="6f5728e6f888e3db2ef5e4e2e84aed1bcec411c8" translate="yes" xml:space="preserve">
          <source>Once the Linker find one symbol he doesn't search in other libraries for it</source>
          <target state="translated">一度リンカーが一つのシンボルを見つけると、他のライブラリでそれを検索することはありません。</target>
        </trans-unit>
        <trans-unit id="94e5d03e6bfe739776bcda7bf67b4b04f50d00e4" translate="yes" xml:space="preserve">
          <source>One possible reason for linker errors with GCC 5.2.0 is that a new libstdc++ library ABI is now chosen by default.</source>
          <target state="translated">GCC 5.2.0でリンカエラーが発生する原因として考えられるのは、新しいlibstdc++ライブラリABIがデフォルトで選択されるようになったことです。</target>
        </trans-unit>
        <trans-unit id="e8ebcbceae17e1cbcb7630b4e7cab992bde641ed" translate="yes" xml:space="preserve">
          <source>Or in the project settings;</source>
          <target state="translated">または、プロジェクトの設定で。</target>
        </trans-unit>
        <trans-unit id="3324fb682ba3b5fa0fc5008f94f9c3c6cb160fbe" translate="yes" xml:space="preserve">
          <source>Or on the command line;</source>
          <target state="translated">またはコマンドラインで。</target>
        </trans-unit>
        <trans-unit id="0d8974a160f915d9994dddc618b6681fd0f9d9cf" translate="yes" xml:space="preserve">
          <source>Or you could replace the -l argument with the full path of the .so, e.g. instead of &lt;code&gt;-ltbb&lt;/code&gt; do &lt;code&gt;/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2&lt;/code&gt;</source>
          <target state="translated">または、-l引数を.soの完全パスで置き換えることができます。たとえば、 &lt;code&gt;-ltbb&lt;/code&gt; の代わりに &lt;code&gt;/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="4ae41d11bd46131c063f0debe5a8fdf31f161cd3" translate="yes" xml:space="preserve">
          <source>Or, the implementation for the &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; can be done inline inside the class definition;</source>
          <target state="translated">または、 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 実装は、クラス定義内でインラインで実行できます。</target>
        </trans-unit>
        <trans-unit id="80d315959f3ea9b04eb57b630f050abbf870cc02" translate="yes" xml:space="preserve">
          <source>Other examples of mismatches include</source>
          <target state="translated">他のミスマッチの例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="6a535a2a245f2fac95298b5e9540153ebde66430" translate="yes" xml:space="preserve">
          <source>Parse all the object files and find the definition which was only declared in headers ( eg: The code of one method of a class as is mentioned in previous answers, or event the initialization of a static variable which is member inside a class)</source>
          <target state="translated">すべてのオブジェクトファイルを解析し、ヘッダでのみ宣言された定義を見つける(例:前の回答で述べたように、クラスの1つのメソッドのコード、またはイベントクラス内のメンバーである静的変数の初期化)。</target>
        </trans-unit>
        <trans-unit id="bd4adda29a59ab9ab7bbb53de56745feac90cde3" translate="yes" xml:space="preserve">
          <source>Pay attention to why the mangled names ended up different. You would be able to see that the parameter types are different, even though they look the same in the source code.</source>
          <target state="translated">混乱した名前がなぜ違う名前になってしまったのかに注意してください。ソースコードでは同じように見えても、パラメータの型が違うことがわかるでしょう。</target>
        </trans-unit>
        <trans-unit id="4041537c412b8e8a70cd213105a7f6d55c1d8225" translate="yes" xml:space="preserve">
          <source>Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set
  (introducing new-line characters for end-of-line indicators) if
  necessary. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">物理ソースファイルの文字は、必要に応じて、実装定義の方法で基本ソース文字セット（行末インジケーターの改行文字を導入）にマップされます。 &lt;em&gt;[をちょきちょきと切る]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f7cb050a64d88fed430275cbf21ad78668fd798" translate="yes" xml:space="preserve">
          <source>Preprocessing directives are executed, macro invocations are expanded, and _Pragma unary operator expressions are executed. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">前処理ディレクティブが実行され、マクロ呼び出しが展開され、_Pragma単項演算子式が実行されます。 &lt;em&gt;[をちょきちょきと切る]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6587b16429748e00b4db35eea2d58d775e0d0e77" translate="yes" xml:space="preserve">
          <source>Problems with template friends</source>
          <target state="translated">テンプレートの友達の問題</target>
        </trans-unit>
        <trans-unit id="0721f2ff9d4e8f8c71dbe1300b4338d0f46d327a" translate="yes" xml:space="preserve">
          <source>Project Properties &amp;gt; General &amp;gt; Project Defaults &amp;gt; Character Set</source>
          <target state="translated">プロジェクトプロパティ&amp;gt;一般&amp;gt;プロジェクトデフォルト&amp;gt;文字セット</target>
        </trans-unit>
        <trans-unit id="315cdbd0cc37f2f6eed7311d6a11376e81ab5846" translate="yes" xml:space="preserve">
          <source>Putting interdependent libraries in the wrong order is just one way
in which you can get files that &lt;em&gt;need&lt;/em&gt; definitions of things coming
later in the linkage than the files that &lt;em&gt;provide&lt;/em&gt; the definitions. Putting libraries before the 
object files that refer to them is another way of making the same mistake.</source>
          <target state="translated">相互に依存するライブラリを間違った順序で配置することは、リンケージの中で、定義を&lt;em&gt;提供する&lt;/em&gt;ファイルよりも後に来るものの定義を&lt;em&gt;必要&lt;/em&gt;と&lt;em&gt;する&lt;/em&gt;ファイルを取得できる1つの方法にすぎません。 ライブラリを参照するオブジェクトファイルの前にライブラリを置くことも、同じ間違いを犯す別の方法です。</target>
        </trans-unit>
        <trans-unit id="aa2e87051763ba52eba36f8604042df6dea47a55" translate="yes" xml:space="preserve">
          <source>Reason why they are different. In the example given above, they are different because of different include files.</source>
          <target state="translated">異なる理由。上記の例では、インクルードファイルが異なるため、それらは異なっています。</target>
        </trans-unit>
        <trans-unit id="516aae52959dcf5398a9985414a78b8c24a4f0e5" translate="yes" xml:space="preserve">
          <source>Resolution</source>
          <target state="translated">Resolution</target>
        </trans-unit>
        <trans-unit id="36eb62592e54385368d992e3bfc823feb8a2ecf1" translate="yes" xml:space="preserve">
          <source>Same if you compile and link in one go:</source>
          <target state="translated">コンパイルとリンクを一括で行う場合も同じです。</target>
        </trans-unit>
        <trans-unit id="57b44b45b209c07e2cf396779f22bd7450198c5e" translate="yes" xml:space="preserve">
          <source>Say you defined symbol &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;a.cpp&lt;/code&gt;. Now, &lt;code&gt;b.cpp&lt;/code&gt;&lt;em&gt;declared&lt;/em&gt; that symbol and used it. Before linking, it simply assumes that that symbol was defined &lt;em&gt;somewhere&lt;/em&gt;, but it doesn't yet care where. The linking phase is responsible for finding the symbol and correctly linking it to &lt;code&gt;b.cpp&lt;/code&gt; (well, actually to the object or library that uses it).</source>
          <target state="translated">シンボル &lt;code&gt;a&lt;/code&gt; を &lt;code&gt;a.cpp&lt;/code&gt; で定義したとします 。 現在、 &lt;code&gt;b.cpp&lt;/code&gt; &lt;em&gt;は&lt;/em&gt;そのシンボルを&lt;em&gt;宣言し&lt;/em&gt;て使用しています。 リンクする前に、単にそのシンボルが&lt;em&gt;どこか&lt;/em&gt;で定義されていると仮定しますが、まだ&lt;em&gt;どこ&lt;/em&gt;でもかまいません。 リンクフェーズは、シンボルを見つけて &lt;code&gt;b.cpp&lt;/code&gt; に正しくリンクする責任があります （まあ、実際にはそれを使用するオブジェクトまたはライブラリにリンクしています）。</target>
        </trans-unit>
        <trans-unit id="d88c152a43cb27887978260a5c15f52ecc557b4e" translate="yes" xml:space="preserve">
          <source>Search for the exported symbol of interest, and notice that the mangled name is different.</source>
          <target state="translated">エクスポートされた関心のあるシンボルを検索して、揶揄された名前が違うことに気づく。</target>
        </trans-unit>
        <trans-unit id="f5e40313ea4a701259411817e6ec26f8b27269ef" translate="yes" xml:space="preserve">
          <source>Search paths used.</source>
          <target state="translated">使用されている検索パス。</target>
        </trans-unit>
        <trans-unit id="ef26caaa13a2223b4e5f1013e62b3dd0af211401" translate="yes" xml:space="preserve">
          <source>Second, &lt;strong&gt;example 2&lt;/strong&gt;, with shared library &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">次に、 &lt;strong&gt;例2&lt;/strong&gt; 、共有ライブラリ &lt;code&gt;libz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="31a5c46ba7e3644d87e2c8692f9d7b577d4ff522" translate="yes" xml:space="preserve">
          <source>Similar mechanisms exist for other compilers/ platforms.</source>
          <target state="translated">同様のメカニズムは他のコンパイラプラットフォームにも存在します。</target>
        </trans-unit>
        <trans-unit id="ad1f924b7bbc2bcd7bd047b593952dcaf5c4a6a3" translate="yes" xml:space="preserve">
          <source>Similar remarks apply to functions. Declaring a function without defining it leads to the error:</source>
          <target state="translated">同様のことが関数にも当てはまります。関数を定義せずに宣言するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="44febaad51a1168e7b5495233c9acbc83d1c9397" translate="yes" xml:space="preserve">
          <source>Similar to Windows-dlls, one would mark public functions with a define, for example &lt;code&gt;DLL_PUBLIC&lt;/code&gt; defined as:</source>
          <target state="translated">Windows-dllと同様に、パブリック関数を定義でマークします。たとえば、 &lt;code&gt;DLL_PUBLIC&lt;/code&gt; は次のように定義されます。</target>
        </trans-unit>
        <trans-unit id="3791448e9c466323a781d1053225a28e2ed66066" translate="yes" xml:space="preserve">
          <source>Since it is not implemented, the linker fails to find it and results in the error.</source>
          <target state="translated">実装されていないため、リンカはそれを見つけることに失敗し、エラーとなります。</target>
        </trans-unit>
        <trans-unit id="b88c50d7c2684c92f808dc0bef70ada825c3a195" translate="yes" xml:space="preserve">
          <source>Since people seem to be directed to this question when it comes to linker errors I am going to add this here.</source>
          <target state="translated">リンカエラーが発生したときにこの質問をされるようなので、ここに追加しておきます。</target>
        </trans-unit>
        <trans-unit id="5594c3defe9060176ac055ec30199b6a1925a1a0" translate="yes" xml:space="preserve">
          <source>So if you suddenly get linker errors when switching to a GCC after 5.1.0 this would be a thing to check out.</source>
          <target state="translated">なので、5.1.0以降にGCCに切り替えたときに急にリンカエラーが出るようになったら、これはチェックすべきことだと思います。</target>
        </trans-unit>
        <trans-unit id="7406dccb208de8f7859f688a7bf278cd1e4e822d" translate="yes" xml:space="preserve">
          <source>So the linkage fails just as it does if you &lt;em&gt;do&lt;/em&gt; run those two commands. The
only difference you notice in the failure is that gcc has generated a
temporary object file in the compile + link case, because you're not telling it
to use &lt;code&gt;eg1.o&lt;/code&gt;. We see:</source>
          <target state="translated">したがって、これら2つのコマンドを実行した場合と同様に、リンケージは失敗します。 失敗で気づく唯一の違いは、gccがコンパイル+リンクの場合に一時オブジェクトファイルを生成したことです。これは、 &lt;code&gt;eg1.o&lt;/code&gt; を使用するように指示していないためです。 私たちは見る：</target>
        </trans-unit>
        <trans-unit id="0c7380eb36ac254fde0c5e28aa7521e54819d717" translate="yes" xml:space="preserve">
          <source>So the linker does not add &lt;code&gt;my_lib.o&lt;/code&gt; to the program and has no further
use for &lt;code&gt;libmy_lib.a&lt;/code&gt;.</source>
          <target state="translated">そのため、リンカは &lt;code&gt;my_lib.o&lt;/code&gt; をプログラムに追加せず、 libmy_lib.aをこれ以上使用し &lt;code&gt;libmy_lib.a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="389ef339b38d14a89c45ee18d949e24cc58f1d20" translate="yes" xml:space="preserve">
          <source>So to repeat again, the order &lt;strong&gt;DOES&lt;/strong&gt; matter!</source>
          <target state="translated">繰り返しますが、順序は重要です！</target>
        </trans-unit>
        <trans-unit id="ba83702c0f21aecaaf05b65e1c413ecbfdf89e6e" translate="yes" xml:space="preserve">
          <source>So, as a result - an &quot;undefined reference/unresolved external symbol error&quot; happens when the linker cannot find global symbols in the object files.</source>
          <target state="translated">その結果、リンカがオブジェクト・ファイルでグローバル・シンボルを見つけられない場合、&quot;未定義の参照未解決外部シンボル・エラー &quot;が発生します。</target>
        </trans-unit>
        <trans-unit id="810e61562c0a90ab80a893ffeb7eb498e51ef3b8" translate="yes" xml:space="preserve">
          <source>So, we see follow symbols to export.</source>
          <target state="translated">そのため、以下のような記号でエクスポートすることができます。</target>
        </trans-unit>
        <trans-unit id="889eacaaf63948869a5ddecd71ff4abfdbeb0106" translate="yes" xml:space="preserve">
          <source>So, we've seen there is no label for local_var_name, that's why linker hasn't found it. But we are hackers :) and we can fix it. Open src1.s in your text editor and change</source>
          <target state="translated">ということで、local_var_nameのラベルがないことがわかったので、リンカーが見つけられませんでした。しかし、私たちはハッカーです。テキストエディタで src1.s を開いて</target>
        </trans-unit>
        <trans-unit id="ed306cf6c07bf565cfeaa2c226cbfd2a2acd58af" translate="yes" xml:space="preserve">
          <source>Some .so files are actually &lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-commands.html&quot;&gt;GNU ld linker scripts&lt;/a&gt;, e.g. &lt;a href=&quot;https://www.threadingbuildingblocks.org/download&quot;&gt;libtbb.so&lt;/a&gt; file is an ASCII text file with this contents:</source>
          <target state="translated">一部の.soファイルは実際には&lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-commands.html&quot;&gt;GNU ldリンカースクリプトです&lt;/a&gt; 。たとえば、 &lt;a href=&quot;https://www.threadingbuildingblocks.org/download&quot;&gt;libtbb.so&lt;/a&gt;ファイルは次の内容のASCIIテキストファイルです。</target>
        </trans-unit>
        <trans-unit id="2701d02120f341c911b427c678b1b3ba58ab869e" translate="yes" xml:space="preserve">
          <source>Some members need to be defined even if not used explicitly:</source>
          <target state="translated">明示的に使用されていなくても定義が必要なメンバもあります。</target>
        </trans-unit>
        <trans-unit id="0ce76ec1b7032c9c8bc5feb3b6ece87aff083f39" translate="yes" xml:space="preserve">
          <source>Some more complex builds may not support this. For example, if you include -v in the compiler options, you can see that the &lt;a href=&quot;http://www.mainsoft.com/content/mainsoft-unix-and-linux-overview&quot;&gt;mainwin gcc wrapper mwdip&lt;/a&gt; discards linker script command files in the verbose output list of libraries to link in. A simple work around is to replace the linker script input command file with a copy of the file instead (or a symlink), e.g.</source>
          <target state="translated">いくつかのより複雑なビルドはこれをサポートしないかもしれません。 たとえば、コンパイラオプションに-vを含めると、 &lt;a href=&quot;http://www.mainsoft.com/content/mainsoft-unix-and-linux-overview&quot;&gt;mainwin gccラッパーmwdip&lt;/a&gt;がリンクするライブラリの詳細出力リストにあるリンカースクリプトコマンドファイルを破棄することがわかります。簡単な回避策は、リンカースクリプト入力コマンドを置き換えることです。代わりにファイルのコピーを含むファイル（またはシンボリックリンク）、たとえば</target>
        </trans-unit>
        <trans-unit id="8da255b627a43c5967c21bd733eeffe48c9f7d7b" translate="yes" xml:space="preserve">
          <source>Specialized templates can be implemented in an implementation file and the implementation doesn't have to be visible, but the specialization must be previously declared.</source>
          <target state="translated">特殊化されたテンプレートは実装ファイルに実装することができ、実装は可視化されている必要はありませんが、特殊化は事前に宣言されている必要があります。</target>
        </trans-unit>
        <trans-unit id="2bbb6a7ee8142005a47ef622c25910f07c59d91f" translate="yes" xml:space="preserve">
          <source>Steps to try if you believe it could be a bug in compiler/IDE:</source>
          <target state="translated">compilerIDEのバグかもしれないと思ったら試してみる手順</target>
        </trans-unit>
        <trans-unit id="fe05b5a0cc2b31aa92f2910350d4890d86e8795c" translate="yes" xml:space="preserve">
          <source>Success:</source>
          <target state="translated">Success:</target>
        </trans-unit>
        <trans-unit id="82ca7ce44cf63b62393dd7422ee20047ef95bcd5" translate="yes" xml:space="preserve">
          <source>Suppose you have a big project written in c++ which has a thousand of .cpp files and a thousand of .h files.And let's says the project also depends on ten static libraries. Let's says we are on Windows and we build our project in Visual Studio 20xx. When you press Ctrl + F7 Visual Studio to start compiling the whole solution ( suppose we have just one project in the solution )</source>
          <target state="translated">例えば、1000個の.cppファイルと1000個の.hファイルを持つ、c++で書かれた大きなプロジェクトがあるとします。Windowsで、Visual Studio 20xxでプロジェクトをビルドしたとします。Ctrl+F7を押すと、Visual Studioはソリューション全体のコンパイルを開始します(ソリューションの中にプロジェクトが1つだけあるとします)。</target>
        </trans-unit>
        <trans-unit id="8380d950d527889dc4734ed54b11f16aca5a374d" translate="yes" xml:space="preserve">
          <source>Symbols were defined in a C program and used in C++ code.</source>
          <target state="translated">シンボルはCプログラムで定義され、C++コードで使用されていました。</target>
        </trans-unit>
        <trans-unit id="2a9939fe25550be4dea8b1c736d43f816c2c5f20" translate="yes" xml:space="preserve">
          <source>Template implementations not visible.</source>
          <target state="translated">テンプレートの実装が見えない</target>
        </trans-unit>
        <trans-unit id="8ef7c2da6f851f23bbe511ebc36d3de16160e803" translate="yes" xml:space="preserve">
          <source>That's because the distro on which the linkage works is one of the ones that 
does not configure its GCC toolchain to link shared libraries &lt;em&gt;as-needed&lt;/em&gt;.</source>
          <target state="translated">これは、リンケージが機能するディストリビューションが、共有ライブラリ&lt;em&gt;を必要に応じ&lt;/em&gt;てリンクするようにGCCツールチェーンを構成しないディストリビューションの1つだから&lt;em&gt;です&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="ddd5cfe744cba081a538a7341375f31cf8b1b45a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;libraryName&lt;/code&gt; here is just the bare name of the library, without platform-specific additions. So e.g. on Linux library files are usually called &lt;code&gt;libfoo.so&lt;/code&gt; but you'd only write &lt;code&gt;-lfoo&lt;/code&gt;. On Windows that same file might be called &lt;code&gt;foo.lib&lt;/code&gt;, but you'd use the same argument. You might have to add the directory where those files can be found using &lt;code&gt;-L&amp;lsaquo;directory&amp;rsaquo;&lt;/code&gt;. Make sure to not write a space after &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;-L&lt;/code&gt;.</source>
          <target state="translated">ここでの &lt;code&gt;libraryName&lt;/code&gt; は、プラットフォーム固有の追加を除いた、ライブラリの単なる名前です。 したがって、たとえばLinuxでは、ライブラリファイルは通常 &lt;code&gt;libfoo.so&lt;/code&gt; と呼ばれますが、 &lt;code&gt;-lfoo&lt;/code&gt; のみを記述します 。 Windowsでは、同じファイルが &lt;code&gt;foo.lib&lt;/code&gt; と呼ばれることがありますが、同じ引数を使用します。 &lt;code&gt;-L&amp;lsaquo;directory&amp;rsaquo;&lt;/code&gt; を使用して、これらのファイルが見つかるディレクトリを追加する必要がある場合があります。 &lt;code&gt;-l&lt;/code&gt; または &lt;code&gt;-L&lt;/code&gt; の後にスペースを入れないでください。</target>
        </trans-unit>
        <trans-unit id="bd483f1251beaf7236d9997165b1d451b6bd1e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is being declared as a non-template function. For every type &lt;code&gt;T&lt;/code&gt; used with &lt;code&gt;Foo&lt;/code&gt;, there needs to be a non-templated &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. For example, if there is a type &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; declared, then there must be an operator implementation as follows;</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; が非テンプレート関数として宣言されています。 &lt;code&gt;Foo&lt;/code&gt; で使用されるすべての型 &lt;code&gt;T&lt;/code&gt; には、テンプレート化されていない &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; が必要です。 たとえば、 &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; 型が宣言されている場合、次のような演算子の実装が必要です。</target>
        </trans-unit>
        <trans-unit id="f74bbb502cac87efc036b9625dd07f7ba8c32eb8" translate="yes" xml:space="preserve">
          <source>The C++ linker expects names to be mangled, so you have to declare the function as:</source>
          <target state="translated">C++リンカは名前が乱されることを想定しているので、関数を以下のように宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="fa46de6d6b4941229d8b28acdcc1f6c203f0c516" translate="yes" xml:space="preserve">
          <source>The MSDN page on the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wdsk6as6.aspx&quot;&gt;&lt;code&gt;/VERBOSE&lt;/code&gt; linker option&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wdsk6as6.aspx&quot;&gt; &lt;code&gt;/VERBOSE&lt;/code&gt; リンカーオプション&lt;/a&gt;に関するMSDNページ。</target>
        </trans-unit>
        <trans-unit id="0a964c858e2f8e84f3cc4266073a14ab0c6127b2" translate="yes" xml:space="preserve">
          <source>The Second step of compilation is done by Linker.Linker should merge all the object file and build finally the output ( which may be an executable or a library)</source>
          <target state="translated">コンパイルの第二段階は、Linker.Linkerによって行われます。Linkerは、すべてのオブジェクトファイルをマージし、最終的に出力(実行形式またはライブラリ)を構築しなければなりません。</target>
        </trans-unit>
        <trans-unit id="b2a9f1a0bcdd74e12869a5f78bd29d7084686e17" translate="yes" xml:space="preserve">
          <source>The above code limits the friendship of the operator to the corresponding instantiation of &lt;code&gt;Foo&lt;/code&gt;, i.e. the &lt;code&gt;operator&amp;lt;&amp;lt; &amp;lt;int&amp;gt;&lt;/code&gt; instantiation is limited to access the private members of the instantiation of &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">上記のコードは、オペレーターの友情を対応する &lt;code&gt;Foo&lt;/code&gt; のインスタンス化に制限します。つまり、 &lt;code&gt;operator&amp;lt;&amp;lt; &amp;lt;int&amp;gt;&lt;/code&gt; インスタンス化は、 &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; インスタンス化のプライベートメンバーにアクセスするように制限されます。</target>
        </trans-unit>
        <trans-unit id="7cdbeecfba3fe1508804ada7c0e80ead504f0a5a" translate="yes" xml:space="preserve">
          <source>The alternative is applicable as well, if UNICODE is not intended to be used, make sure the defines are not set, and/or the multi-character setting is used in the projects and consistently applied.</source>
          <target state="translated">UNICODEを使用することを意図していない場合は、定義が設定されていないことを確認するか、プロジェクトで複数文字の設定が使用され、一貫して適用されていることを確認して、代替案も適用されます。</target>
        </trans-unit>
        <trans-unit id="ab517e2a8ba12a27ab2bbd36c075257a2d62e599" translate="yes" xml:space="preserve">
          <source>The code:</source>
          <target state="translated">コードだ</target>
        </trans-unit>
        <trans-unit id="96e15fc342a8a7b8e2a770b1887eaa0b6e5475ae" translate="yes" xml:space="preserve">
          <source>The correct solution is to hope the developer releases an updated package and then upgrade, but it worked for me by hacking in an extra setting for VS2013, pointing at the VS2012 library files.</source>
          <target state="translated">正しい解決策は、開発者が更新されたパッケージをリリースしてからアップグレードすることですが、VS2012 のライブラリファイルを指す VS2013 の追加設定をハックすることで、私の場合はうまくいきました。</target>
        </trans-unit>
        <trans-unit id="39c6a6672a8c45fef828814fbc0a834a3d886d1e" translate="yes" xml:space="preserve">
          <source>The default behavior of gcc is that all symbols are visible. However, when the translation units are built with option &lt;code&gt;-fvisibility=hidden&lt;/code&gt;, only functions/symbols marked with &lt;code&gt;__attribute__ ((visibility (&quot;default&quot;)))&lt;/code&gt; are external in the resulting shared object.</source>
          <target state="translated">gccのデフォルトの動作では、すべてのシンボルが表示されます。 ただし、翻訳単位がオプション &lt;code&gt;-fvisibility=hidden&lt;/code&gt; で構築されている場合、 &lt;code&gt;__attribute__ ((visibility (&quot;default&quot;)))&lt;/code&gt; マークされた関数/シンボルのみが、結果の共有オブジェクトで外部になります。</target>
        </trans-unit>
        <trans-unit id="5d98ae42d70c1284a1b8e74bcfa80f5e6dc64e4b" translate="yes" xml:space="preserve">
          <source>The definition should be</source>
          <target state="translated">定義は</target>
        </trans-unit>
        <trans-unit id="fc35bde94bc482f0aba6406f3ef3e5fec63a5cd8" translate="yes" xml:space="preserve">
          <source>The different linkage rules for static and shared libraries can be confusing
to inexpert programmers, who may not know whether &lt;code&gt;-lfoo&lt;/code&gt; in their linkage
is going to resolve to &lt;code&gt;/some/where/libfoo.a&lt;/code&gt; or to &lt;code&gt;/some/where/libfoo.so&lt;/code&gt;,
and might not understand the difference between shared and static libraries
anyway.</source>
          <target state="translated">静的ライブラリと共有ライブラリの異なるリンケージルールは、リンケージの &lt;code&gt;/some/where/libfoo.a&lt;/code&gt; または/some/where/libfoo.soのどちらに解決されるのかわからない &lt;code&gt;-lfoo&lt;/code&gt; なプログラマを混乱させる可能性があり &lt;code&gt;/some/where/libfoo.so&lt;/code&gt; 。とにかく、共有ライブラリと静的ライブラリの違いを理解していない可能性があります。</target>
        </trans-unit>
        <trans-unit id="aaebebac9d959c2f58827c7b922c7bafe9507b45" translate="yes" xml:space="preserve">
          <source>The error message from the compiler will often give you the full declaration of the variable or function that was declared but never defined. Compare it closely to the definition you provided. &lt;em&gt;Make sure every detail matches.&lt;/em&gt;</source>
          <target state="translated">コンパイラからのエラーメッセージは、宣言されたが定義されていない変数または関数の完全な宣言を提供することがよくあります。 指定した定義とよく比較してください。 &lt;em&gt;すべての詳細が一致していることを確認してください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c2fa91316cfdea05c933e01c86ec8f328458b71" translate="yes" xml:space="preserve">
          <source>The error usually includes a function a value with a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt; derived type, these could include &lt;code&gt;std::basic_string&amp;lt;&amp;gt;&lt;/code&gt; etc. as well. When browsing through the affected function in the code, there will often be a reference to &lt;code&gt;TCHAR&lt;/code&gt; or &lt;code&gt;std::basic_string&amp;lt;TCHAR&amp;gt;&lt;/code&gt; etc. This is a tell-tale sign that the code was originally intended for both a UNICODE and a Multi-Byte Character (or &quot;narrow&quot;) build.</source>
          <target state="translated">エラーには通常、関数または &lt;code&gt;char&lt;/code&gt; または &lt;code&gt;wchar_t&lt;/code&gt; 派生型の値が含まれます。これらには &lt;code&gt;std::basic_string&amp;lt;&amp;gt;&lt;/code&gt; なども含まれます。 コード内の影響を受ける関数を参照する &lt;code&gt;TCHAR&lt;/code&gt; 、 TCHARまたは &lt;code&gt;std::basic_string&amp;lt;TCHAR&amp;gt;&lt;/code&gt; などへの参照がよくあります。これは、コードが最初にUNICODEとマルチバイトの両方を対象としていたことを示す証拠ですキャラクター（または「狭い」）ビルド。</target>
        </trans-unit>
        <trans-unit id="814895756bf4ca3a731ef6c9e3952b7d303ddbd4" translate="yes" xml:space="preserve">
          <source>The explanation</source>
          <target state="translated">説明の内容</target>
        </trans-unit>
        <trans-unit id="2d47f92cdddee137d7131c686bea6ba95385c1dd" translate="yes" xml:space="preserve">
          <source>The following would yield the error:</source>
          <target state="translated">以下のようにするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="dc651a3eb6c90a022d94d96235e9502e73444d46" translate="yes" xml:space="preserve">
          <source>The function (or variable) &lt;code&gt;void foo()&lt;/code&gt; was defined in a C program and you attempt to use it in a C++ program:</source>
          <target state="translated">関数（または変数） &lt;code&gt;void foo()&lt;/code&gt; がCプログラムで定義されており、C ++プログラムでそれを使用しようとしました：</target>
        </trans-unit>
        <trans-unit id="a01682bab1ad942d84e12a4ac6e6ac22aa1e51e4" translate="yes" xml:space="preserve">
          <source>The implementation can be inline, in the class definition itself:</source>
          <target state="translated">実装は、クラス定義自体の中でインラインで行うことができます。</target>
        </trans-unit>
        <trans-unit id="edc532595d46d57575b847133085c91ba2256fee" translate="yes" xml:space="preserve">
          <source>The linkage:</source>
          <target state="translated">連動しています。</target>
        </trans-unit>
        <trans-unit id="de5f587780a7f48b676bf47c006c00b98834b61e" translate="yes" xml:space="preserve">
          <source>The linker will decide that your program needs &lt;code&gt;my_lib.o&lt;/code&gt; if and only if it already knows that
your program refers to &lt;code&gt;hw&lt;/code&gt;, in one or more of the object files it has already
added to the program, and that none of the object files it has already added
contains a definition for &lt;code&gt;hw&lt;/code&gt;.</source>
          <target state="translated">リンカは、プログラムが既にプログラムに追加した1つ以上のオブジェクトファイルで、プログラムが &lt;code&gt;hw&lt;/code&gt; を参照していること、およびプログラムが持っているオブジェクトファイルがないことを知っている場合に限り、プログラムに &lt;code&gt;my_lib.o&lt;/code&gt; が必要であると判断します。すでに追加されているには、 &lt;code&gt;hw&lt;/code&gt; の定義が含まれています。</target>
        </trans-unit>
        <trans-unit id="0a63e56d03967bc268b8093019d175c83dfcea0a" translate="yes" xml:space="preserve">
          <source>The location of the libraries,</source>
          <target state="translated">図書館の場所。</target>
        </trans-unit>
        <trans-unit id="11d6b7b1db5745c2043ea068ebb1b7afa5ed93de" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;THIS_MODULE&lt;/code&gt; would only be defined in the module that exports the function. That way, the declaration:</source>
          <target state="translated">マクロ &lt;code&gt;THIS_MODULE&lt;/code&gt; は、関数をエクスポートするモジュールでのみ定義されます。 そのように、宣言は：</target>
        </trans-unit>
        <trans-unit id="eb453bce3db2538452e63a26b6b80e65d71ce5e3" translate="yes" xml:space="preserve">
          <source>The order in which interdependent linked libraries are specified is wrong</source>
          <target state="translated">相互に依存するリンクライブラリの指定順序がおかしい</target>
        </trans-unit>
        <trans-unit id="89ab932707a61a0d0cca439734dbbccf264ff41a" translate="yes" xml:space="preserve">
          <source>The order in which interdependent linked libraries are specified is wrong.</source>
          <target state="translated">相互依存的にリンクされたライブラリの指定順序が間違っています。</target>
        </trans-unit>
        <trans-unit id="4687e29b604f518f389340188cf76ad7ba3cfeab" translate="yes" xml:space="preserve">
          <source>The order in which libraries are linked DOES matter if the libraries depend on each other. In general, if library &lt;code&gt;A&lt;/code&gt; depends on library &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;libA&lt;/code&gt;&lt;strong&gt;MUST&lt;/strong&gt; appear before &lt;code&gt;libB&lt;/code&gt; in the linker flags.</source>
          <target state="translated">ライブラリが相互に依存している場合は、ライブラリをリンクする順序が重要です。 一般に、ライブラリ &lt;code&gt;A&lt;/code&gt; がライブラリ &lt;code&gt;B&lt;/code&gt; に依存している場合、リンカーフラグでは &lt;code&gt;libB&lt;/code&gt; 前に表示される必要があります。</target>
        </trans-unit>
        <trans-unit id="c77074a1e65055c9b9d790d1eab74306e35ee769" translate="yes" xml:space="preserve">
          <source>The order of linking libraries &lt;strong&gt;does matter&lt;/strong&gt;.</source>
          <target state="translated">ライブラリをリンクする順序&lt;strong&gt;は重要&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="dfadc843995bf96fc6b50f95dc126fbb8c9952b5" translate="yes" xml:space="preserve">
          <source>The precedence among the syntax rules of translation is specified by the following phases &lt;em&gt;[see footnote]&lt;/em&gt;.</source>
          <target state="translated">翻訳の構文規則間の優先順位は、次のフェーズで指定されます&lt;em&gt;[脚注を参照]&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="24af2bb789cacc1f5d7b2771021236eabff0f64c" translate="yes" xml:space="preserve">
          <source>The process goes like this:</source>
          <target state="translated">プロセスはこのようになります。</target>
        </trans-unit>
        <trans-unit id="f9b8eb5b1acfcafd62389be8ee87a10159a198c2" translate="yes" xml:space="preserve">
          <source>The same result if you compile and link in one step, like:</source>
          <target state="translated">のように、コンパイルとリンクを一括で行っても同じ結果になります。</target>
        </trans-unit>
        <trans-unit id="7ebe1560f137cc486a8b481f98db368bc20a5bb3" translate="yes" xml:space="preserve">
          <source>The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters (including comments). &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">ソースファイルは、前処理トークン（2.5）と空白文字のシーケンス（コメントを含む）に分解されます。 &lt;em&gt;[をちょきちょきと切る]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fe7b5fd3c97072d8d933ccaa526d54b2cbe6724" translate="yes" xml:space="preserve">
          <source>The specified errors occur during this last stage of compilation, most commonly referred to as linking. It basically means that you compiled a bunch of implementation files into object files or libraries and now you want to get them to work together.</source>
          <target state="translated">指定されたエラーは、最も一般的にリンクと呼ばれるコンパイルの最終段階で発生します。これは基本的には、実装ファイルの束をオブジェクトファイルやライブラリにコンパイルして、それらを一緒に動作させたいということを意味します。</target>
        </trans-unit>
        <trans-unit id="d25f8b67d426bc902107dbb9bd3d074093733c3c" translate="yes" xml:space="preserve">
          <source>There is further reading on template friends at &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend#Template_friends&quot;&gt;cppreference&lt;/a&gt; and the &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#template-friends&quot;&gt;C++ FAQ&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend#Template_friends&quot;&gt;cppreference&lt;/a&gt;と&lt;a href=&quot;https://isocpp.org/wiki/faq/templates#template-friends&quot;&gt;C ++ FAQにある&lt;/a&gt;テンプレートフレンドの詳細については、 こちらをご覧 ください 。</target>
        </trans-unit>
        <trans-unit id="51d2c1022c793ae6c997851c6c2911c491290dcf" translate="yes" xml:space="preserve">
          <source>There is only object file in &lt;code&gt;libmy_lib.a&lt;/code&gt;, namely &lt;code&gt;my_lib.o&lt;/code&gt;, and there's only one thing defined
in &lt;code&gt;my_lib.o&lt;/code&gt;, namely the function &lt;code&gt;hw&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;libmy_lib.a&lt;/code&gt; にはオブジェクトファイル、つまり &lt;code&gt;my_lib.o&lt;/code&gt; だけがあり、 &lt;code&gt;my_lib.o&lt;/code&gt; で定義されているものは1つだけ、つまり関数 &lt;code&gt;hw&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fd7c821ca3bddaa894ed4036bbbcbeef36efee4a" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;process can be seen as a final resort, but is often a good first step&lt;/em&gt;; especially if the code related to the error has recently been added (either locally or from the source repository).</source>
          <target state="translated">この&lt;em&gt;プロセスは最終的な手段と見なすことができますが、多くの場合、最初のステップとして適切&lt;/em&gt;です。 特に、エラーに関連するコードが最近追加された場合（ローカルまたはソースリポジトリから）。</target>
        </trans-unit>
        <trans-unit id="6ad971ec73e134596db3aa5d8e277e263d65c535" translate="yes" xml:space="preserve">
          <source>This behaviour is economical at linktime because the linker doesn't have to ponder
whether a shared library is needed by the program: if it's a shared library,
link it. And most libraries in most linkages are shared libraries. But there are disadvantages too:-</source>
          <target state="translated">この動作は、リンカが共有ライブラリがプログラムに必要かどうかを考える必要がないので、リンク時に経済的です。そして、ほとんどのリンケージのほとんどのライブラリは共有ライブラリです。しかし、次のような欠点もあります。</target>
        </trans-unit>
        <trans-unit id="b891d63d48abebbaef68ad3645c7352c0b2f6c19" translate="yes" xml:space="preserve">
          <source>This can be done with either;</source>
          <target state="translated">これはどちらでも可能です。</target>
        </trans-unit>
        <trans-unit id="49d63f2a1c780d571d49de8e11cd2c50aaeac867" translate="yes" xml:space="preserve">
          <source>This dual functionality is usually obtained through the use of a macro:</source>
          <target state="translated">この二重の機能は、通常、マクロを使用することで得られます。</target>
        </trans-unit>
        <trans-unit id="83d3af1836050ec99f7b707ceaa03f6ebb1c3de7" translate="yes" xml:space="preserve">
          <source>This happens because base class destructors are called when the object is destroyed implicitly, so a definition is required.</source>
          <target state="translated">これは、オブジェクトが暗黙的に破壊されるときに基底クラスのデストラクタが呼び出されるため、定義が必要になるからです。</target>
        </trans-unit>
        <trans-unit id="24bcd3540cf7ff25e654495899de496726d609d7" translate="yes" xml:space="preserve">
          <source>This is one of most confusing error messages that every VC++ programmers have seen time and time again. Let&amp;rsquo;s make things clarity first.</source>
          <target state="translated">これは、すべてのVC ++プログラマーが何度も何度も目にした最もわかりにくいエラーメッセージの1つです。 最初に物事を明確にしましょう。</target>
        </trans-unit>
        <trans-unit id="fc953ac37a3ffbcc5b71f7b47d29511fb9fc75f9" translate="yes" xml:space="preserve">
          <source>This is similar to non-&lt;code&gt;virtual&lt;/code&gt; methods with no definition, with the added reasoning that 
the pure declaration generates a dummy vtable and you might get the linker error without using the function:</source>
          <target state="translated">これは、定義のない非 &lt;code&gt;virtual&lt;/code&gt; メソッドに似ていますが、純粋な宣言がダミーのvtableを生成し、関数を使用せずにリンカーエラーが発生する可能性があるという理由が追加されています。</target>
        </trans-unit>
        <trans-unit id="f40ecc90472f127aee96a0b27d92ae47b6f13c88" translate="yes" xml:space="preserve">
          <source>This means that when the linker finds &lt;code&gt;-lz&lt;/code&gt; in the linkage sequence, and figures out that this refers 
to the shared library (say) &lt;code&gt;/usr/lib/x86_64-linux-gnu/libz.so&lt;/code&gt;, it wants to know whether any references that it has added to your program that aren't yet defined have definitions that are exported by &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">これは、リンカがリンケージシーケンスで &lt;code&gt;-lz&lt;/code&gt; を見つけ、これが共有ライブラリ（たとえば） &lt;code&gt;/usr/lib/x86_64-linux-gnu/libz.so&lt;/code&gt; を参照していることを見つけたときに、プログラムに追加されましたが、まだ定義されていません。定義は &lt;code&gt;libz&lt;/code&gt; によってエクスポートされます</target>
        </trans-unit>
        <trans-unit id="c7bd9513b51b299b1d7979bb703672c0c803ce8a" translate="yes" xml:space="preserve">
          <source>This searching process is called resolve.</source>
          <target state="translated">この検索処理をresolveといいます。</target>
        </trans-unit>
        <trans-unit id="86854a6361abc1cef804c342988694879f4451d0" translate="yes" xml:space="preserve">
          <source>This trade-off has led to the schismatic situation today. Some distros have
changed their GCC linkage rules for shared libraries so that the &lt;em&gt;as-needed&lt;/em&gt;
principle applies for all libraries. Some distros have stuck with the old
way.</source>
          <target state="translated">このトレードオフは、今日の分裂的な状況につながっています。 一部のディストリビューションでは、 &lt;em&gt;必要に応じて&lt;/em&gt;原則をすべてのライブラリに適用できるように、共有ライブラリのGCCリンケージルールを変更しています。 一部のディストリビューションは古い方法に固執しています。</target>
        </trans-unit>
        <trans-unit id="c6f9c244e10c8db8baeddb7b6f7b289439a89f58" translate="yes" xml:space="preserve">
          <source>This usually happens when two (or more) libraries have a cyclic dependency. Library A attempts to use symbols in B.lib and library B attempts to use symbols from A.lib. Neither exist to start off with. When you attempt to compile A, the link step will fail because it can't find B.lib. A.lib will be generated, but no dll. You then compile B, which will succeed and generate B.lib. Re-compiling A will now work because B.lib is now found.</source>
          <target state="translated">これは通常、2つ以上の(またはそれ以上の)ライブラリが周期的な依存関係を持っている場合に起こります。ライブラリAはB.libのシンボルを使おうとし、ライブラリBはA.libのシンボルを使おうとします。そもそもどちらも存在しません。Aをコンパイルしようとすると、B.libが見つからないため、リンクステップは失敗します。A.libは生成されますが、dllは生成されません。次にBをコンパイルすると、成功してB.libが生成されます。これでB.libが見つかったので、Aを再コンパイルしても動作するようになります。</target>
        </trans-unit>
        <trans-unit id="dde9568d6caff7f7b573e0d0537eb77fffc36423" translate="yes" xml:space="preserve">
          <source>This way &lt;strong&gt;any function&lt;/strong&gt; contained in file.o and used in main.o that &lt;strong&gt;required &lt;code&gt;path_t&lt;/code&gt;&lt;/strong&gt; gave &quot;undefined reference&quot; errors because &lt;strong&gt;main.o&lt;/strong&gt; referred to &lt;strong&gt;&lt;code&gt;std::filesystem::path&lt;/code&gt;&lt;/strong&gt; but &lt;strong&gt;file.o&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;std::experimental::filesystem::path&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">このように&lt;strong&gt;、&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;path_t&lt;/code&gt; &lt;/strong&gt;を&lt;strong&gt;必要&lt;/strong&gt;とするfile.oに含まれ、main.oで使用される&lt;strong&gt;関数&lt;/strong&gt;は、 &lt;strong&gt;main.o&lt;/strong&gt;が&lt;strong&gt; &lt;code&gt;std::filesystem::path&lt;/code&gt; &lt;/strong&gt; 、 &lt;strong&gt;file.o&lt;/strong&gt;を&lt;strong&gt; &lt;code&gt;std::experimental::filesystem::path&lt;/code&gt; &lt;/strong&gt;参照するため、「未定義の参照」エラーが発生しました&lt;strong&gt;。 ：path&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0d35af95e12b0dd0220a819e99aa16dadf25948" translate="yes" xml:space="preserve">
          <source>To correct this, build all the required libraries and projects with a consistent definition of &lt;code&gt;UNICODE&lt;/code&gt; (and &lt;code&gt;_UNICODE&lt;/code&gt;).</source>
          <target state="translated">これを修正するには、 &lt;code&gt;UNICODE&lt;/code&gt; （および &lt;code&gt;_UNICODE&lt;/code&gt; ）の一貫した定義を使用して、必要なすべてのライブラリとプロジェクトをビルドします。</target>
        </trans-unit>
        <trans-unit id="a38dce23594f07d3de4b2b2cc2a5ab210dc62856" translate="yes" xml:space="preserve">
          <source>To correct this, you can declare a template operator before the &lt;code&gt;Foo&lt;/code&gt; type and then declare as a friend, the appropriate instantiation. The syntax is a little awkward, but is looks as follows;</source>
          <target state="translated">これを修正するには、 &lt;code&gt;Foo&lt;/code&gt; 型の前にテンプレート演算子を宣言してから、適切なインスタンス化であるフレンドとして宣言します。 構文は少し厄介ですが、次のようになります。</target>
        </trans-unit>
        <trans-unit id="b278d2255a2fb839042b27cedfdcde4b13d42e77" translate="yes" xml:space="preserve">
          <source>To find which symbols in an object file are hidden run:</source>
          <target state="translated">オブジェクトファイルのどのシンボルが隠されているかを調べるには、実行してください。</target>
        </trans-unit>
        <trans-unit id="f79e5cf712c1cebae4fd911b423526834fd1d23d" translate="yes" xml:space="preserve">
          <source>To fix this I just needed to &lt;strong&gt;change &amp;lt;experimental::filesystem&amp;gt; in file.h to &amp;lt;filesystem&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">これを修正するに&lt;strong&gt;は、file.hの&amp;lt;experimental :: filesystem&amp;gt;を&amp;lt;filesystem&amp;gt;&lt;/strong&gt;に&lt;strong&gt;変更する&lt;/strong&gt;必要がありました。</target>
        </trans-unit>
        <trans-unit id="2243663083f071145668f251171c65a090b9e5f2" translate="yes" xml:space="preserve">
          <source>To fix this, you must move the definition of &lt;code&gt;X::foo&lt;/code&gt; to the header file or some place visible to the translation unit that uses it.</source>
          <target state="translated">これを修正するには、 &lt;code&gt;X::foo&lt;/code&gt; 定義をヘッダーファイルまたはそれを使用する翻訳単位から見える場所に移動する必要があります。</target>
        </trans-unit>
        <trans-unit id="ac8e1b45e6bf97148cb8413c306ad6f5794875ec" translate="yes" xml:space="preserve">
          <source>To solve the issue, i built the MyProject as a LIB, and linked TestProject to this .lib file (i copy paste the generated .lib file into the TestProject folder). I can then build again MyProject as a DLL. It is compiling since the lib to which TestProject is linked does contain code for all methods in classes in MyProject.</source>
          <target state="translated">この問題を解決するために、MyProjectをLIBとしてビルドし、この.libファイルにTestProjectをリンクした(生成された.libファイルをTestProjectフォルダにコピーペーストした)。その後、再度DLLとしてMyProjectをビルドすることができます。TestProjectがリンクされているLIBには、MyProjectのクラスのすべてのメソッドのコードが含まれているので、コンパイルできています。</target>
        </trans-unit>
        <trans-unit id="1f2f0e08ff5b2e59a5a31d4b807b32101fba5f64" translate="yes" xml:space="preserve">
          <source>Translated translation units and instantiation units are combined as follows: &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">翻訳された翻訳単位とインスタンス化単位は次のように組み合わされます： &lt;em&gt;[SNIP]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7aef8e7498486de3cd6699dbe069fa0c309048a" translate="yes" xml:space="preserve">
          <source>Try start a new project,
copying all source code from the original one.</source>
          <target state="translated">元のプロジェクトからすべてのソースコードをコピーして、新しいプロジェクトを開始してみてください。</target>
        </trans-unit>
        <trans-unit id="7715c2c8a7f85ca33fe93cc7817eac47532e5dc6" translate="yes" xml:space="preserve">
          <source>Try to link your program with &lt;code&gt;libz&lt;/code&gt; and fail:</source>
          <target state="translated">プログラムを &lt;code&gt;libz&lt;/code&gt; とリンクして失敗します。</target>
        </trans-unit>
        <trans-unit id="af5e2c5c3e6cb9cebd2829b0e884257cface4ba2" translate="yes" xml:space="preserve">
          <source>Under &lt;strong&gt;MSVS&lt;/strong&gt;, files added to a project automatically have their object files linked together and a &lt;code&gt;lib&lt;/code&gt; file would be generated (in common usage). To use the symbols in a separate project, you'd 
need to include the &lt;code&gt;lib&lt;/code&gt; files in the project settings. This is done in the Linker section of the project properties, in &lt;code&gt;Input -&amp;gt; Additional Dependencies&lt;/code&gt;. (the path to the &lt;code&gt;lib&lt;/code&gt; file should be
added in &lt;code&gt;Linker -&amp;gt; General -&amp;gt; Additional Library Directories&lt;/code&gt;) When using a third-party library that is provided with a &lt;code&gt;lib&lt;/code&gt; file, failure to do so usually results in the error.</source>
          <target state="translated">&lt;strong&gt;MSVSでは&lt;/strong&gt; 、プロジェクトに追加されたファイルは自動的にオブジェクトファイルがリンクされ、 &lt;code&gt;lib&lt;/code&gt; ファイルが生成されます（一般的な使用法）。 別のプロジェクトでシンボルを使用するには、プロジェクト設定に &lt;code&gt;lib&lt;/code&gt; ファイルを含める必要があります。 これは、プロジェクトプロパティの[リンカー]セクションの &lt;code&gt;Input -&amp;gt; Additional Dependencies&lt;/code&gt; ます。 （ &lt;code&gt;lib&lt;/code&gt; ファイルへのパスは、 &lt;code&gt;Linker -&amp;gt; General -&amp;gt; Additional Library Directories&lt;/code&gt; 追加する必要があります） &lt;code&gt;lib&lt;/code&gt; ファイルで提供されるサードパーティのライブラリを使用する場合、失敗すると、通常、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="09353e91d6dc1b681cb300414136507aacd9dc17" translate="yes" xml:space="preserve">
          <source>Under &lt;strong&gt;gcc&lt;/strong&gt; you would specify all object files that are to be linked together in the command line, or compile the implementation files together.</source>
          <target state="translated">&lt;strong&gt;gccの&lt;/strong&gt;下では、コマンドラインでリンクされるすべてのオブジェクトファイルを指定するか、実装ファイルを一緒にコンパイルします。</target>
        </trans-unit>
        <trans-unit id="e8e07a144ac894fbd4a815eef8cb126c9d8444ca" translate="yes" xml:space="preserve">
          <source>Unspecialized templates must have their definitions visible to all translation units that use them. That means you can't separate the definition of a template
to an implementation file. If you must separate the implementation, the usual workaround is to have an &lt;code&gt;impl&lt;/code&gt; file which you include at the end of the header that
declares the template. A common situation is:</source>
          <target state="translated">特殊化されていないテンプレートの定義は、それらを使用するすべての翻訳単位に表示される必要があります。 つまり、テンプレートの定義を実装ファイルに分離することはできません。 実装を分離する必要がある場合、通常の回避策は、テンプレートを宣言するヘッダーの末尾にインプリメントファイルを含めることです。 一般的な状況は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="626a6bfb69f923133176d2288c20c9ad3e266875" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;#pragma once&lt;/code&gt; for allowing compiler not to include one header if it was already included in the current .cpp which are compiled</source>
          <target state="translated">コンパイルされる現在の.cppにすでにヘッダーが含まれている場合、コンパイラーがヘッダーを1つも含めないようにするには、 &lt;code&gt;#pragma once&lt;/code&gt; 使用します</target>
        </trans-unit>
        <trans-unit id="652d6febf33e65c27e03abc9bf57e88d8db07539" translate="yes" xml:space="preserve">
          <source>Use the linker to help diagnose the error</source>
          <target state="translated">リンカを使用してエラーを診断します。</target>
        </trans-unit>
        <trans-unit id="3df12d1763a76db1eb5f9e0c7142ced823b24c14" translate="yes" xml:space="preserve">
          <source>Visual Studio search into file &lt;strong&gt;.vcxproj&lt;/strong&gt; and start compiling each file which has the extension .cpp. Order of compilation is undefined.So you must not assume that the file main.cpp is compiled first</source>
          <target state="translated">Visual Studioはファイル&lt;strong&gt;.vcxproj&lt;/strong&gt;を検索し、拡張子.cppを持つ各ファイルのコンパイルを開始します。 コンパイルの順序は定義されていないため、ファイルmain.cppが最初にコンパイルされると想定しないでください</target>
        </trans-unit>
        <trans-unit id="bc6493aa79682062f1e35506dac73e5d517d7fa9" translate="yes" xml:space="preserve">
          <source>What are undefined reference/unresolved external symbol errors? What are common causes and how to fix/prevent them?</source>
          <target state="translated">未定義の参照未解決の外部シンボル・エラーとは何ですか?一般的な原因は何ですか?</target>
        </trans-unit>
        <trans-unit id="db7e500851b237b0a75617adc43159c4e601d013" translate="yes" xml:space="preserve">
          <source>What are you doing wrong?</source>
          <target state="translated">何を間違ったことをしているの?</target>
        </trans-unit>
        <trans-unit id="2d7204271f918e6dc824c4de713ad791b4dc1110" translate="yes" xml:space="preserve">
          <source>What is an undefined reference/unresolved external symbol error and how do I fix it</source>
          <target state="translated">未定義の参照未解決の外部シンボルエラーとは何か?</target>
        </trans-unit>
        <trans-unit id="4632922517e4c4150df04140a0a11bc46ff27b5a" translate="yes" xml:space="preserve">
          <source>When a translation unit is compiled with &lt;code&gt;-fvisibility=hidden&lt;/code&gt; the resulting symbols have still external linkage (shown with upper case symbol type by &lt;code&gt;nm&lt;/code&gt;) and can be used for external linkage without problem if the object files become part of a static libraries. The linkage becomes local only when the object files are linked into a shared library.</source>
          <target state="translated">翻訳単位が &lt;code&gt;-fvisibility=hidden&lt;/code&gt; でコンパイルされた場合、結果のシンボルは依然として外部リンケージを持ち（ &lt;code&gt;nm&lt;/code&gt; で大文字のシンボルタイプで示されます）、オブジェクトファイルが静的ライブラリの一部になった場合、問題なく外部リンケージに使用できます。 オブジェクトファイルが共有ライブラリにリンクされている場合にのみ、リンケージがローカルになります。</target>
        </trans-unit>
        <trans-unit id="2c08affaeeed528ac9c1fa3dfa4effce084687ac" translate="yes" xml:space="preserve">
          <source>When linking against shared libraries, make sure that the used symbols are not hidden.</source>
          <target state="translated">共有ライブラリに対してリンクする場合は、使用するシンボルが非表示にならないようにしてください。</target>
        </trans-unit>
        <trans-unit id="9ca2a7655109619c5715fb8ca7ccc73f3615a640" translate="yes" xml:space="preserve">
          <source>When you run the command above, &lt;code&gt;gcc&lt;/code&gt; figures out that you want compilation +
linkage. So behind the scenes, it generates a compilation command, and runs
it, then generates a linkage command, and runs it, as if &lt;em&gt;you&lt;/em&gt; had run the
two commands:</source>
          <target state="translated">上記のコマンドを実行すると、 &lt;code&gt;gcc&lt;/code&gt; はコンパイル+リンケージが必要であることを認識します。 したがって、裏で、コンパイルコマンドを生成して実行し、次に2つのコマンドを実行したかのように、リンケージコマンドを生成して実行します。</target>
        </trans-unit>
        <trans-unit id="4567f3b27b39712303adc4658d2e89c9f3ed6ec0" translate="yes" xml:space="preserve">
          <source>When you try to link the program like:</source>
          <target state="translated">のようなプログラムをリンクさせようとすると</target>
        </trans-unit>
        <trans-unit id="b31400492742589d7742b79425b053a4e29f6f8f" translate="yes" xml:space="preserve">
          <source>When you use the template to make sure you include the definition of each template function in the header file for allowing the compiler to generate appropriate code for any instantiations.</source>
          <target state="translated">テンプレートを使用する際には、各テンプレート関数の定義をヘッダファイルに含めてください。</target>
        </trans-unit>
        <trans-unit id="e4d80ad940bb876bd92a024b5ff663f048b0473e" translate="yes" xml:space="preserve">
          <source>When your include paths are different</source>
          <target state="translated">インクルードパスが異なる場合</target>
        </trans-unit>
        <trans-unit id="03365de1caa8827769bae8158a775de517156e6d" translate="yes" xml:space="preserve">
          <source>Which roughly corresponds to Windows'/MSVC-version:</source>
          <target state="translated">WindowsのMSVC版に大体対応しています。</target>
        </trans-unit>
        <trans-unit id="246959a741f4264372238420ebdad97bd89a88ec" translate="yes" xml:space="preserve">
          <source>White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The
  resulting tokens are syntactically and semantically analyzed and
  translated as a translation unit. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">トークンを区切る空白文字は重要ではなくなりました。 各前処理トークンはトークンに変換されます。 （2.7）。 結果のトークンは、構文的および意味的に分析され、翻訳単位として翻訳されます。 &lt;em&gt;[をちょきちょきと切る]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3057b9b641cbee71aae82fe2b981cf8b49a7f80" translate="yes" xml:space="preserve">
          <source>Why do I still get this problem even if I compile-and-link at the same time?</source>
          <target state="translated">コンパイルとリンクを同時に行ってもこの問題が発生するのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="4c6dfe4286bb4038ff6570e5b46f04c49bbf7bf5" translate="yes" xml:space="preserve">
          <source>You are trying to compile and link your program with the GCC toolchain.</source>
          <target state="translated">あなたのプログラムをコンパイルし、GCCツールチェーンとリンクしようとしています。</target>
        </trans-unit>
        <trans-unit id="91c1836cb1d64ed1ad44ab634dca30d630520583" translate="yes" xml:space="preserve">
          <source>You build your static library:</source>
          <target state="translated">静的ライブラリを構築します。</target>
        </trans-unit>
        <trans-unit id="2fd7e03d89627c87bdf0cf1f8eddb4e44c4ee89f" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;nm&lt;/code&gt; with the option &lt;code&gt;-C&lt;/code&gt; to demangle the names (if C++ was used).</source>
          <target state="translated">&lt;code&gt;nm&lt;/code&gt; をオプション &lt;code&gt;-C&lt;/code&gt; とともに使用して、名前をデマングルすることもできます（C ++が使用されている場合）。</target>
        </trans-unit>
        <trans-unit id="eb4ed51d89a6db08d7aac2b244cdb0601cb7bc64" translate="yes" xml:space="preserve">
          <source>You can check whether the symbols your are looking for are external by invoking:</source>
          <target state="translated">探しているシンボルが外部にあるかどうかは、呼び出して確認することができます。</target>
        </trans-unit>
        <trans-unit id="e80a1a5e2677479f692a83c2c89c313fa9e2dc07" translate="yes" xml:space="preserve">
          <source>You can similary import/export classes:</source>
          <target state="translated">同じようにインポート・エクスポートすることができます。</target>
        </trans-unit>
        <trans-unit id="e3de844a4d66034d092d8886a7ce6acf2d81f628" translate="yes" xml:space="preserve">
          <source>You compile your program:</source>
          <target state="translated">あなたのプログラムをコンパイルします。</target>
        </trans-unit>
        <trans-unit id="5f4c7708a6df0a34a544a31a0505e1654dab7e88" translate="yes" xml:space="preserve">
          <source>You may have missed to choose the right project type with your actual IDE. The IDE may want to bind e.g. Windows Application projects to such entry point function (as specified in the missing reference above), instead of the commonly used &lt;code&gt;int main(int argc, char** argv);&lt;/code&gt; signature.</source>
          <target state="translated">実際のIDEで適切なプロジェクトタイプを選択できなかった可能性があります。 IDEは、一般的に使用されている &lt;code&gt;int main(int argc, char** argv);&lt;/code&gt; 代わりに、たとえばWindowsアプリケーションプロジェクトをそのようなエントリポイント関数（上記の欠落している参照で指定されている）にバインドする場合があります。 署名。</target>
        </trans-unit>
        <trans-unit id="9e82259a675941d9948a2eeb64a675ff5f0bac6e" translate="yes" xml:space="preserve">
          <source>You may see a message like:</source>
          <target state="translated">のようなメッセージが表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="0e60f4f947984fbf84f6c4fd28e3b1b296e997d0" translate="yes" xml:space="preserve">
          <source>You might ask how one ends up in a situation like that? &lt;strong&gt;Include paths&lt;/strong&gt; of course! If when compiling the shared library, the include path leads to &lt;code&gt;header1.h&lt;/code&gt; and you end up using &lt;code&gt;header2.h&lt;/code&gt; in your own program, you'll be left scratching your header wondering what happened (pun intended).</source>
          <target state="translated">あなたはそのような状況にどのように終わるか尋ねるかもしれませんか？ もちろん&lt;strong&gt;インクルードパス&lt;/strong&gt; ！ 共有ライブラリをコンパイルするときに、インクルードパスが &lt;code&gt;header1.h&lt;/code&gt; につながり、独自のプログラムで &lt;code&gt;header2.h&lt;/code&gt; を使用してしまうと、何が起こったのかと思ってヘッダーをひっかいてしまうことになります（しゃれつもり）。</target>
        </trans-unit>
        <trans-unit id="2d39d52ae6b215a68d9cf55a1d98a408fa72b8cc" translate="yes" xml:space="preserve">
          <source>You try to link it with &lt;code&gt;libmy_lib.a&lt;/code&gt; and fail:</source>
          <target state="translated">あなたはそれを &lt;code&gt;libmy_lib.a&lt;/code&gt; とリンクしようとして失敗します：</target>
        </trans-unit>
        <trans-unit id="ac3540a5f0b565ea8381987f3a836626c11a6c8e" translate="yes" xml:space="preserve">
          <source>Your linkage consumes libraries before the object files that refer to them</source>
          <target state="translated">リンケージでは、ライブラリを参照するオブジェクトファイルよりも前にライブラリを消費します。</target>
        </trans-unit>
        <trans-unit id="374fcc2688ffa3e097d03ef0cda91f4abae3f9a6" translate="yes" xml:space="preserve">
          <source>Your linkage fails with &lt;code&gt;undefined reference to&lt;/code&gt;&lt;em&gt;something&lt;/em&gt; errors.</source>
          <target state="translated">リンクは、 &lt;em&gt;何か&lt;/em&gt;エラー &lt;code&gt;undefined reference to&lt;/code&gt; 失敗します。</target>
        </trans-unit>
        <trans-unit id="a97d5c4fcdbab0b3e334224158a61c8ab8cdf3b8" translate="yes" xml:space="preserve">
          <source>Your linkage specifies all of the necessary libraries and library search paths</source>
          <target state="translated">リンケージは、必要なライブラリとライブラリ検索パスをすべて指定します。</target>
        </trans-unit>
        <trans-unit id="1ede8f96ef941a4cd4a8b47db4fd4ec6dee457d7" translate="yes" xml:space="preserve">
          <source>Your program wants to refer to just one thing that has a definition exported by &lt;code&gt;libz&lt;/code&gt;,
namely the function &lt;code&gt;zlibVersion&lt;/code&gt;, which is referred to just once, in &lt;code&gt;eg2.c&lt;/code&gt;.
If the linker adds that reference to your program, and then finds the definition
exported by &lt;code&gt;libz&lt;/code&gt;, the reference is &lt;em&gt;resolved&lt;/em&gt;</source>
          <target state="translated">プログラムが &lt;code&gt;libz&lt;/code&gt; によってエクスポートされた定義を持つ1つのもの、つまり &lt;code&gt;zlibVersion&lt;/code&gt; で一度だけ参照される関数zlibVersionを参照する &lt;code&gt;eg2.c&lt;/code&gt; ます。 リンカがその参照をプログラムに追加し、次に &lt;code&gt;libz&lt;/code&gt; によってエクスポートされた定義を見つけた場合、参照は&lt;em&gt;解決されます&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6630645888101f4b1ebaafc85246e04a796c1112" translate="yes" xml:space="preserve">
          <source>[1] By project I mean a set of source files that are linked together to produce either a library or an executable.</source>
          <target state="translated">1]プロジェクトとは、ライブラリまたは実行ファイルのいずれかを生成するためにリンクされたソースファイルのセットを意味します。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="73825e2f27276ce7cc0cb99fe4926aefead625b6" translate="yes" xml:space="preserve">
          <source>and rebuild an object file</source>
          <target state="translated">とオブジェクトファイルを再構築します。</target>
        </trans-unit>
        <trans-unit id="3a85961b64655acfc507843ec1ba2838a9155bab" translate="yes" xml:space="preserve">
          <source>and run it</source>
          <target state="translated">と実行します。</target>
        </trans-unit>
        <trans-unit id="6ab5682fa6ec7ce3b574c508f69fdd94179f902d" translate="yes" xml:space="preserve">
          <source>and similar errors with &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt;:</source>
          <target state="translated">および&lt;strong&gt;Microsoft Visual Studioでの&lt;/strong&gt;同様のエラー：</target>
        </trans-unit>
        <trans-unit id="73d70fffc648342f33ca44795d6cc820d7069f22" translate="yes" xml:space="preserve">
          <source>and tells the compiler that the definition is in one of the libraries you linked against (also see &lt;strong&gt;1)&lt;/strong&gt;).</source>
          <target state="translated">そして、コンパイラーに、定義がリンクしたライブラリーの1つにあることを伝えます（ &lt;strong&gt;1&lt;/strong&gt;も参照）。</target>
        </trans-unit>
        <trans-unit id="a885b4bb68e35a1301318ebf72bf542d958c8233" translate="yes" xml:space="preserve">
          <source>and tells the compiler to export the function, as the current module contains its definition. When including the declaration in a different module, it would expand to</source>
          <target state="translated">は、現在のモジュールにその定義が含まれているため、関数をエクスポートするようにコンパイラに指示します。宣言を別のモジュールに含めると、次のように展開されます。</target>
        </trans-unit>
        <trans-unit id="8081e608d396eb9fd48db5d9cb98df468f9b43c5" translate="yes" xml:space="preserve">
          <source>and you attempt to use it in a C++ program with C++ linkage.</source>
          <target state="translated">で、それをC++連携のあるC++プログラムで使おうとした場合。</target>
        </trans-unit>
        <trans-unit id="c02ceb78ff4863ee1a75d232c4f53af56b182ec9" translate="yes" xml:space="preserve">
          <source>becomes:</source>
          <target state="translated">becomes:</target>
        </trans-unit>
        <trans-unit id="f799f07bf625ffbca0fe04fdd368917957d04df0" translate="yes" xml:space="preserve">
          <source>correct would be to use a header file and include it in file2.cpp &lt;em&gt;and&lt;/em&gt; file1.cpp</source>
          <target state="translated">正しいのは、ヘッダーファイルを使用し、それをfile2.cpp &lt;em&gt;および&lt;/em&gt; file1.cppに含めることです。</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">拡がる</target>
        </trans-unit>
        <trans-unit id="8597eabf07801651c88304087bf20f69ac103fa3" translate="yes" xml:space="preserve">
          <source>i.e. you should have like below</source>
          <target state="translated">つまり、以下のようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="6c8457cd65849bf5a9285f8b862e990e1a44ac09" translate="yes" xml:space="preserve">
          <source>instead of:</source>
          <target state="translated">の代わりに</target>
        </trans-unit>
        <trans-unit id="4f0aa52d656a3d75867f784b7e9c5d23bf1321c0" translate="yes" xml:space="preserve">
          <source>link</source>
          <target state="translated">link</target>
        </trans-unit>
        <trans-unit id="293dce46f676980a9b1278e7251ff73eb7fa797d" translate="yes" xml:space="preserve">
          <source>note: i use g++ and Linux and all examples is for it</source>
          <target state="translated">注意:私は g++と Linux を使用しており、すべての例はそれのためのものです。</target>
        </trans-unit>
        <trans-unit id="36c55470c929c5d5f4d41ac78ab446fd5b77009b" translate="yes" xml:space="preserve">
          <source>now local_var_name has Bind GLOBAL (was LOCAL)</source>
          <target state="translated">local_var_nameがBind GLOBALになりました(以前はLOCALでした)。</target>
        </trans-unit>
        <trans-unit id="fb74205393b3bb80203f54f7a8c9bcb830e8763e" translate="yes" xml:space="preserve">
          <source>ok, see readelf output (symbols)</source>
          <target state="translated">OK,readelf の出力 (シンボル)を参照してください。</target>
        </trans-unit>
        <trans-unit id="3a328af911638e5bfc90b4e0e69e9c25737cc9a5" translate="yes" xml:space="preserve">
          <source>ok, we hack it :)</source>
          <target state="translated">ok,we hack it :)</target>
        </trans-unit>
        <trans-unit id="2328aeacf83c4c55bc1147be999690bfc6241ad3" translate="yes" xml:space="preserve">
          <source>or outside:</source>
          <target state="translated">または外で。</target>
        </trans-unit>
        <trans-unit id="ceeb2cffd5c7262a750a941ceb1e733b45fbb7ca" translate="yes" xml:space="preserve">
          <source>src2.cpp exports nothing and we have seen no its symbols</source>
          <target state="translated">src2.cpp は何もエクスポートしませんし、シンボルも見ていません。</target>
        </trans-unit>
        <trans-unit id="2f0f1d7be52efe820ea8f283992862328386c64a" translate="yes" xml:space="preserve">
          <source>surely gcc has to compile &lt;code&gt;eg1.c&lt;/code&gt; first, and then link the resulting
object file with &lt;code&gt;libmy_lib.a&lt;/code&gt;.  So how can it not know that object file
is needed when it's doing the linking?</source>
          <target state="translated">確かにgccはまず &lt;code&gt;eg1.c&lt;/code&gt; をコンパイルしてから、結果のオブジェクトファイルを &lt;code&gt;libmy_lib.a&lt;/code&gt; にリンクする必要があります。 それでは、リンクを行うときにオブジェクトファイルが必要であることをどのようにして知ることができないのでしょうか。</target>
        </trans-unit>
        <trans-unit id="e01b8bf7137076c13f10eccf3ac7d89d9ac67196" translate="yes" xml:space="preserve">
          <source>the hidden/local symbols are shown by &lt;code&gt;nm&lt;/code&gt; with lowercase symbol type, for example &lt;code&gt;t&lt;/code&gt; instead of `T for code-section:</source>
          <target state="translated">非表示/ローカルシンボルは &lt;code&gt;nm&lt;/code&gt; で小文字のシンボルタイプで表示されます。たとえば、コードセクションの `Tではなく &lt;code&gt;t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="5e0942b4293aac626166820cf457118f4f66b257" translate="yes" xml:space="preserve">
          <source>the linker &lt;em&gt;has not added&lt;/em&gt;&lt;code&gt;eg1.o&lt;/code&gt;&lt;em&gt;to the program&lt;/em&gt; when it sees
&lt;code&gt;-lmy_lib&lt;/code&gt;. Because at that point, it has not seen &lt;code&gt;eg1.o&lt;/code&gt;.
Your program does not yet make any references to &lt;code&gt;hw&lt;/code&gt;: it
does not yet make any references &lt;em&gt;at all&lt;/em&gt;, because all the references it makes
are in &lt;code&gt;eg1.o&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eg1.o&lt;/code&gt; &lt;em&gt;れた&lt;/em&gt;場合、リンカー&lt;em&gt;は&lt;/em&gt; &lt;em&gt;プログラム&lt;/em&gt;にeg1.o &lt;em&gt;を&lt;/em&gt; &lt;em&gt;追加していません&lt;/em&gt; 。 その時点で、それは &lt;code&gt;eg1.o&lt;/code&gt; を見たことがないので 。 プログラムはまだ &lt;code&gt;hw&lt;/code&gt; への参照を作成していません。作成する参照&lt;em&gt;はすべて&lt;/em&gt; &lt;code&gt;eg1.o&lt;/code&gt; にあるため、まだ参照&lt;em&gt;は&lt;/em&gt;作成されていません。</target>
        </trans-unit>
        <trans-unit id="474bf0c29b756b32c6ea11e2c24831191c57e8a2" translate="yes" xml:space="preserve">
          <source>the order of events is wrong in just the same way as with example 1.
At the point when the linker finds &lt;code&gt;-lz&lt;/code&gt;, there are &lt;em&gt;no&lt;/em&gt; references to anything
in the program: they are all in &lt;code&gt;eg2.o&lt;/code&gt;, which has not yet been seen. So the
linker decides it has no use for &lt;code&gt;libz&lt;/code&gt;. When it reaches &lt;code&gt;eg2.o&lt;/code&gt;, adds it to the program,
and then has undefined reference to &lt;code&gt;zlibVersion&lt;/code&gt;, the linkage sequence is finished;
that reference is unresolved, and the linkage fails.</source>
          <target state="translated">例1と同じように、イベントの順序が間違っています。リンカが &lt;code&gt;-lz&lt;/code&gt; を見つけた時点では、プログラムには何も参照されていません。それらはすべて、まだ見られていない &lt;code&gt;eg2.o&lt;/code&gt; にあります。 。 したがって、リンカは &lt;code&gt;libz&lt;/code&gt; を使用しないと判断します。 &lt;code&gt;eg2.o&lt;/code&gt; に達し、それをプログラムに追加し、 &lt;code&gt;zlibVersion&lt;/code&gt; への未定義の参照があると、リンケージシーケンスが終了します。 その参照は解決されず、リンケージは失敗します。</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="7979c3fe74f25deb6892e5101b26610dc97c75eb" translate="yes" xml:space="preserve">
          <source>to declare function foo(), and call it in another function body, say &lt;code&gt;bar()&lt;/code&gt;:</source>
          <target state="translated">関数foo（）を宣言し、それを別の関数本体で呼び出すには、たとえば &lt;code&gt;bar()&lt;/code&gt; とします 。</target>
        </trans-unit>
        <trans-unit id="ec79436cd4ee8fbface339724362fc515088bfd8" translate="yes" xml:space="preserve">
          <source>undefined reference to `WinMain@16'</source>
          <target state="translated">WinMain@16' への未定義の参照</target>
        </trans-unit>
        <trans-unit id="b888bea9cd6729fbf7ebdc759e10b2f2dacf405c" translate="yes" xml:space="preserve">
          <source>we have changed the visibility of local_var_name and set its value to 456789.
Try to build an object file from it</source>
          <target state="translated">local_var_nameの可視性を変更し、その値を456789に設定しました。そこからオブジェクトファイルをビルドしてみます。</target>
        </trans-unit>
        <trans-unit id="a3bc4f467d60d6e7137cb42e5a2693f58a0ffef5" translate="yes" xml:space="preserve">
          <source>which is just example 2 again.</source>
          <target state="translated">というのは、またしても例2にすぎません。</target>
        </trans-unit>
        <trans-unit id="416857d2967c5146284d55951fb33a942176a9f1" translate="yes" xml:space="preserve">
          <source>will generate the following errors with &lt;strong&gt;GCC&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;GCCで&lt;/strong&gt;次のエラーが生成されます。</target>
        </trans-unit>
        <trans-unit id="767ebf562599ebd8219e0bce2533fd52b533baeb" translate="yes" xml:space="preserve">
          <source>works just fine for you!</source>
          <target state="translated">ぴょんぴょん</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
