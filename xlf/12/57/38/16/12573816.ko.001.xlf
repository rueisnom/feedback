<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/12573816">
    <body>
      <group id="12573816">
        <trans-unit id="c9cbc039ba0dda953e719495f032898e9956f254" translate="yes" xml:space="preserve">
          <source>&quot;An introduction to GCC&quot; &lt;a href=&quot;http://www.network-theory.co.uk/docs/gccintro/gccintro_75.html&quot;&gt;chapter 9&lt;/a&gt;.</source>
          <target state="translated">&quot;GCC 소개&quot; &lt;a href=&quot;http://www.network-theory.co.uk/docs/gccintro/gccintro_75.html&quot;&gt;9 장&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7d5b868297c7e069f79fb3331f33b5984b8682" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -c file.cpp&lt;/code&gt; -&amp;gt; compiles file.cpp and file.h to file.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -c file.cpp&lt;/code&gt; &amp;gt; file.cpp 및 file.h를 file.o로 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="e49790a3beb1dd7402b4cb606c79667d1433b0a4" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -c main.cpp&lt;/code&gt; -&amp;gt; compiles main.cpp to main.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -c main.cpp&lt;/code&gt; &amp;gt; main.cpp를 main.o로 컴파일</target>
        </trans-unit>
        <trans-unit id="071ec213b517c0a8d3f03b45c60bc9f9f0b55435" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -o executable main.o file.o -lstdc++fs&lt;/code&gt; -&amp;gt; links main.o and file.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -o executable main.o file.o -lstdc++fs&lt;/code&gt; &amp;gt; main.o와 file.o를 연결</target>
        </trans-unit>
        <trans-unit id="bad1abfbbc607215e826cba0225a7e15753aaefc" translate="yes" xml:space="preserve">
          <source>(Or: That linkage worked fine for you on, say, Fedora 23, but fails on Ubuntu 16.04)</source>
          <target state="translated">(또는 : 페도라 23에서는 링크가 잘 작동했지만 우분투 16.04에서는 실패했습니다)</target>
        </trans-unit>
        <trans-unit id="74c25a55039995250f6d3f12bb86f1ae278cee30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://coliru.stacked-crooked.com/a/e9221c4bb23f9cd0&quot;&gt;Code listing showing the techniques above&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://coliru.stacked-crooked.com/a/e9221c4bb23f9cd0&quot;&gt;위의 기술을 보여주는 코드 목록&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf6077b839b27f134871fac7b06a0474aa39b4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; data members must be defined outside the class in a &lt;strong&gt;single translation unit&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 데이터 멤버는 &lt;strong&gt;단일 변환 단위로&lt;/strong&gt; 클래스 외부에 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="89e5d36fe0239dd24cbe84c6df52545cb824576c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;virtual&lt;/code&gt; methods must either be implemented or defined as pure.</source>
          <target state="translated">&lt;code&gt;virtual&lt;/code&gt; 메소드는 순수하게 구현되거나 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a6e978f78787cb65ba3c48dd61a5ce9874bb1e0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;As a side note to the failing code sample; g++ warns about this as follows&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;실패한 코드 샘플에 대한 참고 사항으로;&lt;/em&gt; &lt;em&gt;g ++는 다음과 같이 경고합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcdf4af6901fd0be253767cc15e18070c0140d96" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;, when the declaration of the operator (or function) only appears in the class, the name is not available for &quot;normal&quot; lookup, only for argument dependent lookup, from &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend&quot;&gt;cppreference&lt;/a&gt;;</source>
          <target state="translated">연산자 (또는 함수)의 선언이 클래스에만 나타나는 경우, 이름은 &quot;정상&quot;조회에는 사용할 수 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend&quot;&gt;없으며 cppreference의&lt;/a&gt; 인수 종속 조회에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66ebd1f43ac511c6c708dab9f44756f21a71765e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Reading is optional from here on&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;읽기는 여기에서 선택 사항입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2438bd9596a6f2aad81a0222f2c18ffe262f7d81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[footnote]&lt;/em&gt; Implementations must behave as if these separate phases occur, although in practice different phases might be folded together.</source>
          <target state="translated">&lt;em&gt;[각주]&lt;/em&gt; 실제로는 다른 단계가 함께 접힐 수 있지만 구현은 이러한 개별 단계가 발생하는 것처럼 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="a534858af77623fa6f10f6aa3f2334132487ee64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A wrapper around GNU ld that doesn't support linker scripts&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;링커 스크립트를 지원하지 않는 GNU ld를 감싸는 래퍼&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="835e534d0a03e685a5781ca6fe9811f767d58b55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A. What is symbol?&lt;/strong&gt;
In short, a symbol is a name. It can be a variable name, a function name, a class name, a typedef name, or anything except those names and signs that belong to C++ language. It is user defined or introduced by a dependency library (another user-defined).</source>
          <target state="translated">&lt;strong&gt;A. 상징이란 무엇입니까?&lt;/strong&gt; 간단히 말해서 기호는 이름입니다. 변수 이름, 함수 이름, 클래스 이름, typedef 이름 또는 C ++ 언어에 속하는 이름 및 부호를 제외한 모든 것이 될 수 있습니다. 종속성 라이브러리 (다른 사용자 정의)에 의해 사용자 정의되거나 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="eec66c59c1dbab98e498c91f5e97e7ff8ab7101f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All external entity references are resolved. Library components are linked to satisfy external references to entities not defined in the
  current translation. All such translator output is collected into a
  program image which contains information needed for execution in its
  execution environment.&lt;/strong&gt; (emphasis mine)</source>
          <target state="translated">&lt;strong&gt;모든 외부 엔티티 참조가 해결되었습니다.&lt;/strong&gt; &lt;strong&gt;라이브러리 구성 요소는 현재 번역에 정의되지 않은 엔터티에 대한 외부 참조를 충족시키기 위해 연결됩니다.&lt;/strong&gt; &lt;strong&gt;이러한 모든 번역기 출력은 실행 환경에서 실행하는 데 필요한 정보가 포함 된 프로그램 이미지로 수집됩니다.&lt;/strong&gt; (강조 광산)</target>
        </trans-unit>
        <trans-unit id="dd8db3de81c77ec485d11b2559fd63ff6023c436" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B. What is external?&lt;/strong&gt;
In VC++, every source file (.cpp,.c,etc.) is considered as a translation unit, the compiler compiles one unit at a time, and generate one object file(.obj) for the current translation unit. (Note that every header file that this source file included will be preprocessed and will be considered as part of this translation unit)Everything within a translation unit is considered as internal, everything else is considered as external. In C++, you may reference an external symbol by using keywords like &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;__declspec (dllimport)&lt;/code&gt; and so on.</source>
          <target state="translated">&lt;strong&gt;B. 외부는 무엇입니까?&lt;/strong&gt; VC ++에서 모든 소스 파일 (.cpp, .c 등)은 변환 단위로 간주되며, 컴파일러는 한 번에 하나의 단위를 컴파일하고 현재 변환 단위에 대해 하나의 오브젝트 파일 (.obj)을 생성합니다. (이 소스 파일에 포함 된 모든 헤더 파일은 사전 처리되어이 번역 단위의 일부로 간주 됨) 번역 단위 내의 모든 항목은 내부로 간주되며 다른 모든 항목은 외부로 간주됩니다. C ++에서 &lt;code&gt;extern&lt;/code&gt; , &lt;code&gt;__declspec (dllimport)&lt;/code&gt; 등과 같은 키워드를 사용하여 외부 심볼을 ​​참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c2ca1047c2ef8497e41c914c53f8e7ca55ee476" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C. What is &amp;ldquo;resolve&amp;rdquo;?&lt;/strong&gt;
Resolve is a linking-time term. In linking-time, linker attempts to find the external definition for every symbol in object files that cannot find its definition internally. The scope of this searching process including:</source>
          <target state="translated">&lt;strong&gt;C.&amp;ldquo;해결&amp;rdquo;이란 무엇입니까?&lt;/strong&gt; 해결은 연결 시간 용어입니다. 연결 시간에 링커는 내부적으로 정의를 찾을 수없는 객체 파일의 모든 심볼에 대한 외부 정의를 찾으려고합니다. 이 검색 프로세스의 범위는 다음을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7342049e2513cd5b99e201cfcb5bf3b14417789e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;D. Finally, why Unresolved External Symbol?&lt;/strong&gt;
If the linker cannot find the external definition for a symbol that has no definition internally, it reports an Unresolved External Symbol error.</source>
          <target state="translated">&lt;strong&gt;D. 마지막으로 왜 미해결 외부 기호인가?&lt;/strong&gt; 링커가 내부적으로 정의가없는 심볼에 대한 외부 정의를 찾을 수없는 경우, 해결되지 않은 외부 심볼 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="5b8a47f4b41b91b3d612aacb048ed208fcac6f16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Different architectures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다른 아키텍처&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be965b14abe7432b5fa433657763c3dc46c94955" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E. Possible causes of LNK2019&lt;/strong&gt;: Unresolved External Symbol error.
We already know that this error is due to the linker failed to find the definition of external symbols, the possible causes can be sorted as:</source>
          <target state="translated">&lt;strong&gt;E. LNK2019의 가능한 원인&lt;/strong&gt; : 해결되지 않은 외부 기호 오류. 링커가 외부 심볼의 정의를 찾지 못했기 때문에이 오류가 발생한다는 것을 이미 알고 있습니다. 가능한 원인은 다음과 같이 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="175dc84044f833f83a2c70ee5958f34ffa3867f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How To Solve this kind of error&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이런 종류의 오류를 해결하는 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50f9819832db0d81b1174260f918040cd2cf7d74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If all else fails, recompile.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다른 모든 방법이 실패하면 다시 컴파일하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cffd218845fdac972017077668b21dcb30366645" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Linked .lib file is associated to a .dll&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;링크 된 .lib 파일은 .dll과 연결됩니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06b83ed7c66d61ec7db41c3a6e7b02f8577e43ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Observation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8940eb48005ed796b60ad830078b12d07df43be6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Steps In Linking a project&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로젝트 연결 단계&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75d4f8b2fa373cf046a6b677d6c35770b0294edb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Visual Studio NuGet package needs to be updated for new toolset version&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;새 도구 세트 버전을 사용하려면 Visual Studio NuGet 패키지를 업데이트해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb0c9feeb4bacc0fa3c37312d7a301912ecd4847" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What's the meaning of compilation ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컴파일의 의미는 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1465fad7785625be27309d79cd0e820fa06d98f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eg1.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;eg1.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89c440cfe498cb89e3725891dfd833439ac8312d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eg2.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;eg2.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff073c269c56360873674533870cbf8bfa429227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;file.cpp&lt;/strong&gt;, the implementation of file.h, #include's &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot;</source>
          <target state="translated">&lt;strong&gt;file.cpp&lt;/strong&gt; , &lt;strong&gt;file.h&lt;/strong&gt; 구현, &lt;strong&gt;#include&lt;/strong&gt; 의 &quot; &lt;strong&gt;file.h&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="f9ae04f6c866dcf587fa6e1e0dae001a09d7888a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;file.h&lt;/strong&gt; #include's &amp;lt;&lt;strong&gt;experimental::filesystem&lt;/strong&gt;&amp;gt; and contains the code above</source>
          <target state="translated">&lt;strong&gt;file.h #include&lt;/strong&gt; 의 &amp;lt; &lt;strong&gt;Experimental :: filesystem&lt;/strong&gt; &amp;gt; 위의 코드를 포함합니다</target>
        </trans-unit>
        <trans-unit id="fddf0c10ac5731cb589a87bb2c2094c4fa147fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main.cpp&lt;/strong&gt; #include's &amp;lt;&lt;strong&gt;filesystem&lt;/strong&gt;&amp;gt; and &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot;</source>
          <target state="translated">&lt;strong&gt;main.cpp #include&lt;/strong&gt; 의 &amp;lt; &lt;strong&gt;파일 시스템&lt;/strong&gt; &amp;gt; 및 &quot; &lt;strong&gt;file.h&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="2582c85be2b20f3244cd0cd3e45025f73c92ed51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;my_lib.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;my_lib.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c230963946da5a9ed838b6a5933de9f154d5ef91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;my_lib.h&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;my_lib.h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2662021565cbcee02085174aa21cc7ecdb484907" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined reference to &lt;code&gt;WinMain@16&lt;/code&gt; or similar &lt;em&gt;'unusual'&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; entry point reference&lt;/strong&gt; (especially for &lt;a href=&quot;/questions/tagged/visual-studio&quot;&gt;visual-studio&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;WinMain@16&lt;/code&gt; 대한 정의되지 않은 참조 또는 유사한 &lt;em&gt;'비정상적인'&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; 진입 점 참조&lt;/strong&gt; (특히 &lt;a href=&quot;/questions/tagged/visual-studio&quot;&gt;visual-studio의 경우&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0acfceb277492d3fa70c2011c817d088faf04611" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;what is an &quot;undefined reference/unresolved external symbol&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;정의되지 않은 참조 / 해결되지 않은 외부 심볼&quot;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3c395f4232d75cdbc21861202f537c9ca9121e5" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Feel free to edit/add your own.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;자유롭게 편집하거나 추가하십시오.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d2d1d37fdef4865427a49fbf3bf6a77bd38bb6d1" translate="yes" xml:space="preserve">
          <source>A &quot;clean&quot; of the build can remove the &quot;dead wood&quot; that may be left lying around from previous builds, failed builds, incomplete builds and other build system related build issues.</source>
          <target state="translated">빌드의 &quot;깨끗한&quot;은 이전 빌드, 실패한 빌드, 불완전한 빌드 및 기타 빌드 시스템 관련 빌드 문제에서 남아있을 수있는 &quot;죽은 나무&quot;를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="189f79f5d1a5faa4467603ef162262cccf65ca78" translate="yes" xml:space="preserve">
          <source>A Windows UNICODE build is built with &lt;code&gt;TCHAR&lt;/code&gt; etc. being defined as &lt;code&gt;wchar_t&lt;/code&gt; etc. When not building with &lt;code&gt;UNICODE&lt;/code&gt; defined as build with &lt;code&gt;TCHAR&lt;/code&gt; defined as &lt;code&gt;char&lt;/code&gt; etc. These &lt;code&gt;UNICODE&lt;/code&gt; and &lt;code&gt;_UNICODE&lt;/code&gt; defines affect all the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx&quot;&gt;&quot;&lt;code&gt;T&lt;/code&gt;&quot; string types&lt;/a&gt;; &lt;code&gt;LPTSTR&lt;/code&gt;, &lt;code&gt;LPCTSTR&lt;/code&gt; and their elk.</source>
          <target state="translated">Windows UNICODE 빌드는 &lt;code&gt;wchar_t&lt;/code&gt; 등으로 정의되는 &lt;code&gt;TCHAR&lt;/code&gt; 등으로 빌드됩니다. &lt;code&gt;char&lt;/code&gt; 등으로 정의 된 &lt;code&gt;TCHAR&lt;/code&gt; 로 빌드로 정의 된 &lt;code&gt;UNICODE&lt;/code&gt; 로 빌드하지 않는 경우 이러한 &lt;code&gt;UNICODE&lt;/code&gt; 및 &lt;code&gt;_UNICODE&lt;/code&gt; 정의는 모든 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx&quot;&gt;&quot; &lt;code&gt;T&lt;/code&gt; &quot;문자열 유형에&lt;/a&gt; 영향을줍니다. &lt;code&gt;LPTSTR&lt;/code&gt; , &lt;code&gt;LPCTSTR&lt;/code&gt; 및 그들의 엘크.</target>
        </trans-unit>
        <trans-unit id="90afd285297eb44d41e1f5773ca5cb874cbb19b4" translate="yes" xml:space="preserve">
          <source>A bug in the compiler/IDE</source>
          <target state="translated">컴파일러 / IDE의 버그</target>
        </trans-unit>
        <trans-unit id="a31d75bc9dfc18e7b2009004254a487c7ca05013" translate="yes" xml:space="preserve">
          <source>A common mistake is forgetting to qualify the name:</source>
          <target state="translated">일반적인 실수는 이름의 자격을 잊는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f739d01292aa73c37e4aee39f036a3bb2a527ee" translate="yes" xml:space="preserve">
          <source>A minimal example involving a shared system library, the compression library &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">공유 시스템 라이브러리 압축 라이브러리 &lt;code&gt;libz&lt;/code&gt; 와 관련된 최소한의 예</target>
        </trans-unit>
        <trans-unit id="01c92916b56793a9454d489c312fa9257acc6107" translate="yes" xml:space="preserve">
          <source>A minimal example involving a static library you built yourself</source>
          <target state="translated">직접 만든 정적 라이브러리와 관련된 최소한의 예</target>
        </trans-unit>
        <trans-unit id="6d46bde77adddeb0b72386689fff3e28dd372bb9" translate="yes" xml:space="preserve">
          <source>A name first declared in a friend declaration within class or class template X becomes a member of the innermost enclosing namespace of X, but is not accessible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at the namespace scope is provided...</source>
          <target state="translated">클래스 또는 클래스 템플릿 X 내의 친구 선언에서 처음 선언 된 이름은 X의 가장 안쪽에있는 네임 스페이스의 멤버가되지만 네임 스페이스 범위에서 일치하는 선언이 없으면 X를 고려하는 인수 종속 조회를 제외하고 액세스 할 수 없습니다. 제공 ...</target>
        </trans-unit>
        <trans-unit id="5a03aa49c3c082188ccefd12449a2783226a9d4f" translate="yes" xml:space="preserve">
          <source>A pure &lt;code&gt;virtual&lt;/code&gt; destructor needs an implementation.</source>
          <target state="translated">순수한 &lt;code&gt;virtual&lt;/code&gt; 소멸자는 구현이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ec2d47bd5e6c687188cca18e11b6e3a11fd20b4b" translate="yes" xml:space="preserve">
          <source>A shared library isn't an archive of object files or anything like it. It's
much more like a &lt;em&gt;program&lt;/em&gt; that doesn't have a &lt;code&gt;main&lt;/code&gt; function and
instead exposes multiple other symbols that it defines, so that other
programs can use them at runtime.</source>
          <target state="translated">공유 라이브러리는 객체 파일 또는 이와 유사한 것의 아카이브가 아닙니다. &lt;code&gt;main&lt;/code&gt; 기능이없는 &lt;em&gt;프로그램&lt;/em&gt; 과 유사하지만 대신 정의 된 여러 개의 다른 기호를 노출하여 다른 프로그램이 런타임에 해당 기호를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f62d04e30be88d7be65eb3c4d8daefedf696027" translate="yes" xml:space="preserve">
          <source>A static library is an indexed archive of object files. When the linker
finds &lt;code&gt;-lmy_lib&lt;/code&gt; in the linkage sequence and figures out that this refers
to the static library &lt;code&gt;./libmy_lib.a&lt;/code&gt;, it wants to know whether your program
needs any of the object files in &lt;code&gt;libmy_lib.a&lt;/code&gt;.</source>
          <target state="translated">정적 라이브러리는 색인화 된 객체 파일 아카이브입니다. 링커가 링크 순서에서 &lt;code&gt;-lmy_lib&lt;/code&gt; 를 찾고 이것이 정적 라이브러리 &lt;code&gt;./libmy_lib.a&lt;/code&gt; 를 참조한다는 것을 알아 내면 프로그램에 &lt;code&gt;libmy_lib.a&lt;/code&gt; 의 오브젝트 파일이 필요한지 알고 싶어합니다.</target>
        </trans-unit>
        <trans-unit id="8b191d246d34f1e602a3e402976e900a1a875073" translate="yes" xml:space="preserve">
          <source>A typical variable declaration is</source>
          <target state="translated">전형적인 변수 선언은</target>
        </trans-unit>
        <trans-unit id="82e2e65a5074a60696904cace45937b63edf3d64" translate="yes" xml:space="preserve">
          <source>Adjacent string literal tokens are concatenated.</source>
          <target state="translated">인접 문자열 리터럴 토큰이 연결되었습니다.</target>
        </trans-unit>
        <trans-unit id="7fe45da2f4efcc86cb9b6567ee7a4ad6bf699b1f" translate="yes" xml:space="preserve">
          <source>After the assembler phase we have an object file, which contains any symbols to export. 
Look at the symbols</source>
          <target state="translated">어셈블러 단계 후에 내보낼 심볼이 포함 된 객체 파일이 있습니다. 상징을보십시오</target>
        </trans-unit>
        <trans-unit id="dbf5b9e02583394489628b8d6f4b8f7252c2835c" translate="yes" xml:space="preserve">
          <source>All libraries (.lib) that are either explicitly or implicitly
specified as additional dependencies of this building application.</source>
          <target state="translated">이 건물 응용 프로그램의 추가 종속성으로 명시 적 또는 암시 적으로 지정된 모든 라이브러리 (.lib).</target>
        </trans-unit>
        <trans-unit id="f594bd06c1caa0ead7f44aab9131622ae2e6ba7e" translate="yes" xml:space="preserve">
          <source>All object files that generated in compiling time</source>
          <target state="translated">컴파일 시간에 생성 된 모든 객체 파일</target>
        </trans-unit>
        <trans-unit id="4091f76b2539a23ecb3681b7960816da46fc1f49" translate="yes" xml:space="preserve">
          <source>All used member methods need to be defined if used.</source>
          <target state="translated">사용 된 모든 멤버 메소드를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="258953ce5c44b3d94df6a62bf16b94620782ab0b" translate="yes" xml:space="preserve">
          <source>Allowing the friendship to extend to all instantiations of the templates, as follows;</source>
          <target state="translated">다음과 같이 우정을 템플릿의 모든 인스턴스화로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c827bc9706235eb6e58b62b8ed3b65b6653a561a" translate="yes" xml:space="preserve">
          <source>Also if you're using 3rd party libraries make sure you have the correct 32/64 bit binaries</source>
          <target state="translated">또한 타사 라이브러리를 사용하는 경우 올바른 32/64 비트 바이너리가 있는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="fcf665a8f73833aa185cc196d74ef511cdd50687" translate="yes" xml:space="preserve">
          <source>Alternatively one could declare the &lt;code&gt;const&lt;/code&gt; variable in file1.cpp with explicit &lt;code&gt;extern&lt;/code&gt;</source>
          <target state="translated">또는 명시적인 &lt;code&gt;extern&lt;/code&gt; 을 사용 하여 file1.cpp의 &lt;code&gt;const&lt;/code&gt; 변수를 선언 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6faa1efbd9a22a841dece261aa541458bc6561d1" translate="yes" xml:space="preserve">
          <source>Alternatives include;</source>
          <target state="translated">대안은 다음과 같습니다;</target>
        </trans-unit>
        <trans-unit id="9142d2a0c57278cbac1656ede2c51ad79022c5e8" translate="yes" xml:space="preserve">
          <source>An example of how this can happen in the real world is explained below.</source>
          <target state="translated">현실에서 어떻게 이런 일이 일어날 수 있는지에 대한 예가 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0978b0da32a1d538f6533aded9b037a5a632b0e0" translate="yes" xml:space="preserve">
          <source>An initializer can be provided for a &lt;code&gt;static&lt;/code&gt;&lt;code&gt;const&lt;/code&gt; data member of integral or enumeration type within the class definition; however, odr-use of this member will still require a namespace scope definition as described above. C++11 allows initialization inside the class for all &lt;code&gt;static const&lt;/code&gt; data members.</source>
          <target state="translated">초기화는 클래스 정의 내에서 정수 또는 열거 유형의 &lt;code&gt;static&lt;/code&gt; &lt;code&gt;const&lt;/code&gt; 데이터 멤버에 제공 될 수 있습니다. 그러나이 멤버의 odr-use를 사용하려면 위에서 설명한 네임 스페이스 범위 정의가 여전히 필요합니다. C ++ 11은 모든 &lt;code&gt;static const&lt;/code&gt; 데이터 멤버에 대해 클래스 내에서 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe337499c7cf1304af8bc4b955a047cc2736dc7c" translate="yes" xml:space="preserve">
          <source>And a variation on example 2 involving &lt;code&gt;pkg-config&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;pkg-config&lt;/code&gt; 와 관련된 예제 2의 변형 :</target>
        </trans-unit>
        <trans-unit id="d551606414a99e264853eca34fd51b96854e0ecd" translate="yes" xml:space="preserve">
          <source>And then you go ahead and include the library in your own project.</source>
          <target state="translated">그런 다음 자신의 프로젝트에 라이브러리를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="b2245e86d8c2a2258df1e19537be1050df1ac011" translate="yes" xml:space="preserve">
          <source>As this is only a declaration, a &lt;strong&gt;single definition&lt;/strong&gt; is needed. A corresponding definition would be:</source>
          <target state="translated">이것은 선언 일 뿐이므로 &lt;strong&gt;단일 정의&lt;/strong&gt; 가 필요합니다. 해당 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b13d9a436d6efc6b48e4a9a36b25cc2355a5e4fc" translate="yes" xml:space="preserve">
          <source>At runtime, the system program loader will load a copy of &lt;code&gt;libz&lt;/code&gt; into the
same process as your program whenever it loads a copy of your program, to run it.</source>
          <target state="translated">런타임시 시스템 프로그램 로더는 프로그램 사본을로드하여 실행할 때마다 프로그램과 동일한 프로세스에 &lt;code&gt;libz&lt;/code&gt; 사본을로드합니다.</target>
        </trans-unit>
        <trans-unit id="e5bb89d8a1b39ec5a184b94a75ab271ed2ff9d91" translate="yes" xml:space="preserve">
          <source>At runtime, whenever your program refers to something that is defined in
&lt;code&gt;libz&lt;/code&gt;, that reference uses the definition exported by the copy of &lt;code&gt;libz&lt;/code&gt; in
the same process.</source>
          <target state="translated">런타임시 프로그램이 &lt;code&gt;libz&lt;/code&gt; 에 정의 된 것을 참조 할 때마다 해당 참조는 동일한 프로세스에서 &lt;code&gt;libz&lt;/code&gt; 사본으로 내 보낸 정의를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8706fc513753f8a6ab494b836c139f955dd4de4b" translate="yes" xml:space="preserve">
          <source>Back in the day, it was normal for unix-like systems to link static and shared 
libraries by different rules. Static libraries in a linkage sequence were linked 
on the &lt;em&gt;as-needed&lt;/em&gt; basis explained in example 1, but shared libraries were linked unconditionally.</source>
          <target state="translated">예전에는 유닉스 계열 시스템이 다른 규칙으로 정적 라이브러리와 공유 라이브러리를 연결하는 것이 일반적이었습니다. 연결 시퀀스의 정적 라이브러리는 예제 1에서 설명한 &lt;em&gt;대로 필요에 따라&lt;/em&gt; 연결되었지만 공유 라이브러리는 무조건 연결되었습니다.</target>
        </trans-unit>
        <trans-unit id="4a50aaa9dbdd42f72fdba6a8715e83c2a0a34f3f" translate="yes" xml:space="preserve">
          <source>Be careful that the function you implement exactly matches the one you declared. For example, you may have mismatched cv-qualifiers:</source>
          <target state="translated">구현 한 함수가 선언 한 함수와 정확히 일치하도록주의하십시오. 예를 들어 cv-qualifier가 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="380e27586685053a149a95794ec8ea13cd72b1ae" translate="yes" xml:space="preserve">
          <source>Because compiling and linking with a single command does not change the
order of the linkage sequence.</source>
          <target state="translated">단일 명령을 사용하여 컴파일하고 연결해도 연결 순서의 순서는 변경되지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="791862e9f3cc350adeb09357b5234c80bae1d2ca" translate="yes" xml:space="preserve">
          <source>Befriending templates...</source>
          <target state="translated">친구 사귀기 ...</target>
        </trans-unit>
        <trans-unit id="0cadc8aa8215fefdf5f07d0ddc606c6dc435a0e8" translate="yes" xml:space="preserve">
          <source>Boom! You get a linker error and you have no idea why it's failing. The reason is that the common library uses different versions of the same include &lt;code&gt;common_math.h&lt;/code&gt; (I have made it obvious here in the example by including a different path, but it might not always be so obvious. Maybe the include path is different in the compiler settings).</source>
          <target state="translated">팔! 링커 오류가 발생하고 왜 실패하는지 알 수 없습니다. 그 이유는 공통 라이브러리가 동일한 include &lt;code&gt;common_math.h&lt;/code&gt; 의 다른 버전을 사용하기 때문입니다 (이 예제에서는 다른 경로를 포함시켜 명확하게 만들었지 만 항상 그렇게 명확하지는 않습니다. 아마도 include 경로가 다를 수 있습니다. 컴파일러 설정).</target>
        </trans-unit>
        <trans-unit id="6bcaff46ce13c984e730553cee278ae1c9aa1951" translate="yes" xml:space="preserve">
          <source>Building one library with &lt;code&gt;UNICODE&lt;/code&gt; defined and attempting to link it in a project where &lt;code&gt;UNICODE&lt;/code&gt; is not defined will result in linker errors since there will be a mismatch in the definition of &lt;code&gt;TCHAR&lt;/code&gt;; &lt;code&gt;char&lt;/code&gt; vs. &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UNICODE&lt;/code&gt; 가 정의 된 라이브러리 하나를 빌드하고 UNICODE가 정의되지 않은 프로젝트에서 라이브러리를 연결하려고하면 &lt;code&gt;TCHAR&lt;/code&gt; 정의에 불일치가 있으므로 링커 오류가 발생합니다. &lt;code&gt;char&lt;/code&gt; 대 &lt;code&gt;wchar_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f699eafa666c4c4782584970203254bd4526ddb" translate="yes" xml:space="preserve">
          <source>But all the undefined &lt;em&gt;something&lt;/em&gt;s are declared in the header files you have
&lt;code&gt;#include&lt;/code&gt;d and are in fact defined in the libraries that you are linking.</source>
          <target state="translated">그러나 정의되지 않은 모든 내용은 &lt;code&gt;#include&lt;/code&gt; d가있는 헤더 파일에 선언되어 있으며 실제로 링크하는 라이브러리에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="04aa72c8afa3b9d7e1037f71bfc89ece6d7cb2d0" translate="yes" xml:space="preserve">
          <source>But when you try to link the program like:</source>
          <target state="translated">그러나 프로그램을 다음과 같이 연결하려고하면 :</target>
        </trans-unit>
        <trans-unit id="e3bc3b59b5238ebf3734cce36298c84c3eecbc4c" translate="yes" xml:space="preserve">
          <source>By default, a linkage command generated by GCC, on your distro,
consumes the files in the linkage from left to right in
commandline sequence. When it finds that a file refers to &lt;em&gt;something&lt;/em&gt;
and does not contain a definition for it, to will search for a definition
in files further to the right. If it eventually finds a definition, the
reference is resolved. If any references remain unresolved at the end,
the linkage fails: the linker does not search backwards.</source>
          <target state="translated">기본적으로 GCC에서 생성 한 연결 명령은 배포판에서 연결의 파일을 명령 줄 순서대로 왼쪽에서 오른쪽으로 사용합니다. 파일이 &lt;em&gt;무언가를&lt;/em&gt; 참조하고 이에 대한 정의를 포함하지 않는 &lt;em&gt;것을&lt;/em&gt; 발견하면 파일의 오른쪽에있는 정의를 검색합니다. 결국 정의를 찾으면 참조가 해결됩니다. 참조가 끝에서 해결되지 않은 상태로 남아 있으면 연결이 실패합니다. 링커는 뒤로 검색하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3eaf522e8926f987e615fe35f7fd9fdf75b655f7" translate="yes" xml:space="preserve">
          <source>Circular library dependency</source>
          <target state="translated">순환 라이브러리 의존성</target>
        </trans-unit>
        <trans-unit id="7241f66efa6b5c24d3508077d13fb171cabcc233" translate="yes" xml:space="preserve">
          <source>Class members:</source>
          <target state="translated">반원 :</target>
        </trans-unit>
        <trans-unit id="aab52d092675fa0fe32cd101b3b21eff5dd78e87" translate="yes" xml:space="preserve">
          <source>Clean and rebuild</source>
          <target state="translated">청소 및 재건</target>
        </trans-unit>
        <trans-unit id="736a421be03fcda0d1784f7e1b58d5c6120e87ca" translate="yes" xml:space="preserve">
          <source>Clean the project (some IDEs have an option to do this, you can also
manually do it by deleting the object files)</source>
          <target state="translated">프로젝트 정리 (일부 IDE에는이를 수행 할 수있는 옵션이 있으며 오브젝트 파일을 삭제하여 수동으로 수행 할 수도 있음)</target>
        </trans-unit>
        <trans-unit id="3da20e0c7008360402f61cc375be71c5a21c62fe" translate="yes" xml:space="preserve">
          <source>Common causes include:</source>
          <target state="translated">일반적인 원인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d20937e648b620d3e08501c7d2a0f7ca4d36b1e" translate="yes" xml:space="preserve">
          <source>Common error messages are &lt;code&gt;error LNK2001&lt;/code&gt;, &lt;code&gt;error LNK1120&lt;/code&gt;, &lt;code&gt;error LNK2019&lt;/code&gt; for &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt; and &lt;code&gt;undefined reference to&lt;/code&gt;&lt;em&gt;symbolName&lt;/em&gt; for &lt;strong&gt;GCC&lt;/strong&gt;.</source>
          <target state="translated">일반적인 오류 메시지는 &lt;strong&gt;Microsoft Visual Studio의&lt;/strong&gt; &lt;code&gt;error LNK2001&lt;/code&gt; , &lt;code&gt;error LNK1120&lt;/code&gt; , &lt;code&gt;error LNK2019&lt;/code&gt; 및 &lt;strong&gt;GCC의&lt;/strong&gt; &lt;em&gt;symbolName에&lt;/em&gt; 대한 &lt;code&gt;undefined reference to&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3af93c7541eebebfdafcdd1eacb37d4febb317b" translate="yes" xml:space="preserve">
          <source>Common issues with class-type members</source>
          <target state="translated">클래스 유형 멤버의 일반적인 문제</target>
        </trans-unit>
        <trans-unit id="7ad8095ab9f470817988dae41ebaff6c8b167424" translate="yes" xml:space="preserve">
          <source>Commonly, each translation unit will generate an object file that contains the definitions of the symbols defined in that translation unit. 
To use those symbols, you have to link against those object files.</source>
          <target state="translated">일반적으로 각 변환 단위는 해당 변환 단위에 정의 된 기호의 정의가 포함 된 객체 파일을 생성합니다. 해당 심볼을 사용하려면 해당 객체 파일과 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="e08db17708c9f5aa2791cb6be1dcc8a1c79a541b" translate="yes" xml:space="preserve">
          <source>Compile your program:</source>
          <target state="translated">프로그램을 컴파일하십시오 :</target>
        </trans-unit>
        <trans-unit id="db2b08b37977716ce6fab5afd8fb8ea79479ade1" translate="yes" xml:space="preserve">
          <source>Compile:</source>
          <target state="translated">Compile:</target>
        </trans-unit>
        <trans-unit id="679b3ff1ac1d63bde340799dcca67fa30e040c64" translate="yes" xml:space="preserve">
          <source>Compiler Time Error :</source>
          <target state="translated">컴파일러 시간 오류 :</target>
        </trans-unit>
        <trans-unit id="c97768ea4c3948ab173981d2a5209cf05f227f68" translate="yes" xml:space="preserve">
          <source>Compiling a C++ program takes place in several steps, as specified by &lt;strong&gt;2.2&lt;/strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/8834196&quot;&gt;(credits to Keith Thompson for the reference)&lt;/a&gt;:</source>
          <target state="translated">&lt;strong&gt;2.2&lt;/strong&gt; 에서 지정한대로 C ++ 프로그램 컴파일은 여러 단계로 수행됩니다 &lt;a href=&quot;https://stackoverflow.com/a/8834196&quot;&gt;(참조 용 Keith Thompson의 신용)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c137971fb4bd72b08a0b43c3008b2cca54a397e2" translate="yes" xml:space="preserve">
          <source>Create the libraries:</source>
          <target state="translated">라이브러리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7eaf2baed01488559bf5876cc3e60f17aa0d3628" translate="yes" xml:space="preserve">
          <source>DUMPBIN is your friend, if you are using Visual Studio. I'm sure other compilers have other similar tools.</source>
          <target state="translated">DUMPBIN은 Visual Studio를 사용하는 경우 친구입니다. 다른 컴파일러에는 다른 유사한 도구가 있다고 확신합니다.</target>
        </trans-unit>
        <trans-unit id="719eb91a47aa71cdb65cf6c453c5e6fe62c3c90d" translate="yes" xml:space="preserve">
          <source>Data on what libraries are included in the link stage,</source>
          <target state="translated">링크 단계에 어떤 라이브러리가 포함되어 있는지에 대한 데이터</target>
        </trans-unit>
        <trans-unit id="6773b3ac6ff9506cd52f19d8964c02fa4b90c9ba" translate="yes" xml:space="preserve">
          <source>Debugging the linker</source>
          <target state="translated">링커 디버깅</target>
        </trans-unit>
        <trans-unit id="849dcbe64c263df85f9b32a99f2eccecff6c214f" translate="yes" xml:space="preserve">
          <source>Declared and undefined variable or function.</source>
          <target state="translated">선언 및 정의되지 않은 변수 또는 함수</target>
        </trans-unit>
        <trans-unit id="06460cd515ea02640e903aed7e4d4bb81068a27c" translate="yes" xml:space="preserve">
          <source>Declared but did not define a variable or function.</source>
          <target state="translated">선언되었지만 변수 나 함수를 정의하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b75a543cd5362fb62c8422904fb2c049dcec7474" translate="yes" xml:space="preserve">
          <source>Declaring a destructor pure still requires you to define it (unlike a regular function):</source>
          <target state="translated">소멸자를 순수로 선언하려면 일반 함수와 달리 여전히 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="567a15d424904d304f2d20a37eae9e3dd0be401d" translate="yes" xml:space="preserve">
          <source>Define all your symbol which you declare in your header files</source>
          <target state="translated">헤더 파일에 선언 한 모든 심볼을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="f5fce9ce350b9263578dfa2c8ab33e5e4582b42f" translate="yes" xml:space="preserve">
          <source>Definition does not exist</source>
          <target state="translated">정의가 존재하지 않습니다</target>
        </trans-unit>
        <trans-unit id="1023459cba9e87450771da5a88dadcad9181c40b" translate="yes" xml:space="preserve">
          <source>Definition exists</source>
          <target state="translated">정의가 존재합니다</target>
        </trans-unit>
        <trans-unit id="1f545375f3315c66c74f5b0635778013cb0153c5" translate="yes" xml:space="preserve">
          <source>Different versions of libraries</source>
          <target state="translated">다른 버전의 라이브러리</target>
        </trans-unit>
        <trans-unit id="0bee44622c3c31248d76530e7b83a53af7e4ae63" translate="yes" xml:space="preserve">
          <source>Do not forget to be consistent between the &quot;Release&quot; and &quot;Debug&quot; builds as well.</source>
          <target state="translated">&quot;릴리스&quot;와 &quot;디버그&quot;빌드간에 일관성을 유지하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="62a321049a9684009d639a42bfcab348659b0468" translate="yes" xml:space="preserve">
          <source>Dump the exported symbols from the library into a text file.</source>
          <target state="translated">라이브러리에서 내 보낸 심볼을 텍스트 파일로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="6ee565a8ad9a2e6032a63ac1db58b7bceef88bc8" translate="yes" xml:space="preserve">
          <source>EDIT 1: Rewrote first section to be easier to understand. Please comment below to let me know if something else needs to be fixed. Thanks!</source>
          <target state="translated">편집 1 : 이해하기 쉽도록 첫 번째 섹션을 다시 작성했습니다. 다른 사항을 수정해야하는지 알려면 아래에 의견을 남겨주세요. 감사!</target>
        </trans-unit>
        <trans-unit id="80d3f81150da8848a606c766ad627406abc917e5" translate="yes" xml:space="preserve">
          <source>Each instance of a backslash character (\) immediately followed by a new-line character is deleted, splicing physical source lines to
  form logical source lines. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">줄 바꿈 문자 바로 뒤에 오는 백 슬래시 문자 (\)의 각 인스턴스는 삭제되어 실제 소스 행을 연결하여 논리 소스 행을 형성합니다. &lt;em&gt;[한조각]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8873c9e0ad822c5ad29c877287ca38e9d0fb8223" translate="yes" xml:space="preserve">
          <source>Each source character set member in a character literal or a string literal, as well as each escape sequence and universal-character-name
  in a character literal or a non-raw string literal, is converted to
  the corresponding member of the execution character set; &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">문자 리터럴 또는 문자열 리터럴의 각 소스 문자 세트 멤버와 문자 리터럴 또는 비원시 문자열 리터럴의 각 이스케이프 시퀀스 및 범용 문자 이름은 실행 문자 세트의 해당 멤버로 변환됩니다. &lt;em&gt;[한조각]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd08fa75ce4c1bea641e5c3ae90f422742fd49a5" translate="yes" xml:space="preserve">
          <source>Equivalently, instead of being defined in a C program, the function (or variable) &lt;code&gt;void foo()&lt;/code&gt; was defined in C++ but with C linkage:</source>
          <target state="translated">마찬가지로 C 프로그램에서 정의되는 대신 함수 (또는 변수) &lt;code&gt;void foo()&lt;/code&gt; 가 C ++에서 정의되었지만 C 연결로 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="50e31b9308416dd3a4f92b2300aa9833c975e02b" translate="yes" xml:space="preserve">
          <source>Even though this is a pretty old questions with multiple accepted answers, I'd like to share how to resolve an &lt;strong&gt;obscure&lt;/strong&gt; &quot;undefined reference to&quot; error.</source>
          <target state="translated">이 답변은 여러 번 받아 들일 수있는 꽤 오래된 질문이지만 &lt;strong&gt;모호한&lt;/strong&gt; &quot;정의되지 않은 참조&quot;오류를 해결하는 방법을 공유하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="0f313c64cf7c57de167dfc0b70285d2f1097cf2a" translate="yes" xml:space="preserve">
          <source>Examples are in C. They could equally well be C++</source>
          <target state="translated">예제는 C로되어 있습니다. C ++ 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c8eeaf8a4d91827c91eda47c067002b02303f4f" translate="yes" xml:space="preserve">
          <source>Failure to link against appropriate libraries/object files or compile implementation files</source>
          <target state="translated">적절한 라이브러리 / 객체 파일 또는 링크 구현 파일에 대한 링크 실패</target>
        </trans-unit>
        <trans-unit id="c24bada60625ab3c77ffebca4ef956b5b8222f43" translate="yes" xml:space="preserve">
          <source>First, &lt;strong&gt;example 1&lt;/strong&gt;, with static library &lt;code&gt;my_lib.a&lt;/code&gt;</source>
          <target state="translated">먼저 정적 라이브러리 &lt;code&gt;my_lib.a&lt;/code&gt; 를 사용하는 &lt;strong&gt;예제 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c8a30a094da8c776a823c101decae831165f64e" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;XCode&lt;/strong&gt;:  Add the User Header Search Paths -&amp;gt; add the Library Search Path -&amp;gt; drag and drop the actual library reference into the project folder.</source>
          <target state="translated">&lt;strong&gt;XCode의 경우&lt;/strong&gt; : 사용자 헤더 검색 경로 추가-&amp;gt; 라이브러리 검색 경로 추가-&amp;gt; 실제 라이브러리 참조를 프로젝트 폴더로 끌어서 놓으십시오.</target>
        </trans-unit>
        <trans-unit id="ba1b34dc3bbed11c2c9a66d05612d54f9428db05" translate="yes" xml:space="preserve">
          <source>For MSVC, &lt;code&gt;/VERBOSE&lt;/code&gt; (in particular &lt;code&gt;/VERBOSE:LIB&lt;/code&gt;) is added to the link command line.</source>
          <target state="translated">MSVC의 경우 &lt;code&gt;/VERBOSE&lt;/code&gt; (특히 &lt;code&gt;/VERBOSE:LIB&lt;/code&gt; )가 링크 명령 줄에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0ac9cca66a7ce03b39143760b921f502a3b2b9ee" translate="yes" xml:space="preserve">
          <source>For each file with extension .cpp is generated an object file .o and also Visual Studio writes the output in a file named &lt;em&gt;ProjectName.Cpp.Clean.txt&lt;/em&gt; which contains all object files that must be processed by the linker.</source>
          <target state="translated">확장자가 .cpp 인 각 파일에 대해 개체 파일 .o가 생성되고 Visual Studio는 링커에서 처리해야하는 모든 개체 파일이 포함 된 &lt;em&gt;ProjectName.Cpp.Clean.txt&lt;/em&gt; 라는 파일에 출력을 씁니다.</target>
        </trans-unit>
        <trans-unit id="ce276678b262778ed8f87dcee2e92b419fef8499" translate="yes" xml:space="preserve">
          <source>For example we have some code</source>
          <target state="translated">예를 들어 코드가 있습니다</target>
        </trans-unit>
        <trans-unit id="2fa6951fcb69e2353b69b4e4f3615ca4d9cc266b" translate="yes" xml:space="preserve">
          <source>For example, if we have a function called foo defined in a.cpp:</source>
          <target state="translated">예를 들어, a.cpp에 foo라는 함수가 정의되어 있다면 :</target>
        </trans-unit>
        <trans-unit id="5c105ae3962497b6a56958a1bf2d2d4a31d03dae" translate="yes" xml:space="preserve">
          <source>For example, the following would generate an error:</source>
          <target state="translated">예를 들어, 다음은 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2fcc968e71dd0b01c575698c3cd328beb1f8547" translate="yes" xml:space="preserve">
          <source>For further explanation and another possible solution (explicit instantiation) see &lt;a href=&quot;https://stackoverflow.com/questions/495021&quot;&gt;this question and answer&lt;/a&gt;.</source>
          <target state="translated">자세한 설명과 가능한 다른 솔루션 (명시 적 인스턴스화) &lt;a href=&quot;https://stackoverflow.com/questions/495021&quot;&gt;은이 질문과 답변을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d26f3d31b9f80c9041094ecd1bfa2cf4a14f452" translate="yes" xml:space="preserve">
          <source>For gcc and clang; you would typically add &lt;code&gt;-v -Wl,--verbose&lt;/code&gt; or &lt;code&gt;-v -Wl,-v&lt;/code&gt; to the command line. More details can be found here;</source>
          <target state="translated">gcc와 clang의 경우; 일반적으로 명령 줄에 &lt;code&gt;-v -Wl,-v&lt;/code&gt; &lt;code&gt;-v -Wl,--verbose&lt;/code&gt; 또는 -v -Wl, -v 를 추가합니다. 자세한 내용은 여기를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="44635ad90325eff295e74bdeb91fbd8d078fabb1" translate="yes" xml:space="preserve">
          <source>For people coming from C it might be a surprise that in C++ global &lt;code&gt;const&lt;/code&gt;variables have internal (or static) linkage. In C this was not the case, as all global variables are implicitly &lt;code&gt;extern&lt;/code&gt; (i.e. when the &lt;code&gt;static&lt;/code&gt; keyword is missing).</source>
          <target state="translated">C에서 온 사람들에게는 C ++ 전역 &lt;code&gt;const&lt;/code&gt; 변수에 내부 (또는 정적) 연결이 있다는 것이 놀랍습니다. C에서는 모든 전역 변수가 내재적으로 &lt;code&gt;extern&lt;/code&gt; 이기 때문에 ( &lt;code&gt;static&lt;/code&gt; 키워드가 누락 된 경우) 그렇지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="02ff37d17fe54fa59b6bdb89b9051f68c4f95602" translate="yes" xml:space="preserve">
          <source>For this to work, declare &lt;code&gt;X::foo()&lt;/code&gt; as pure:</source>
          <target state="translated">이것이 작동하려면 &lt;code&gt;X::foo()&lt;/code&gt; 를 순수한 것으로 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="d3b72bbcef1b0d4a5a3e0732613861aff970d936" translate="yes" xml:space="preserve">
          <source>Function return type, parameter number and types, and calling convention do not all exactly agree.</source>
          <target state="translated">함수 반환 형식, 매개 변수 번호 및 형식 및 호출 규칙이 모두 일치하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="adc354e3ed859611982bdeb24ea70c92b2b599b8" translate="yes" xml:space="preserve">
          <source>Function/variable declared as class member, defined as global (or vice versa).</source>
          <target state="translated">클래스 멤버로 선언 된 함수 / 변수로 전역으로 정의되거나 그 반대로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c9e1736897f86f0f0ebd9367dfa1e73b18c72dbc" translate="yes" xml:space="preserve">
          <source>Function/variable declared in one namespace, defined in another.</source>
          <target state="translated">한 네임 스페이스에서 선언되고 다른 네임 스페이스에서 정의 된 함수 / 변수</target>
        </trans-unit>
        <trans-unit id="47885f9296315b51d23680105388ad37c4f8daa9" translate="yes" xml:space="preserve">
          <source>Further elaboration with an example</source>
          <target state="translated">예제를 통한 추가 설명</target>
        </trans-unit>
        <trans-unit id="1109ab69f5f30dff37d3dd93730a44c1ec557703" translate="yes" xml:space="preserve">
          <source>Given the code snippet of a template type with a friend operator (or function);</source>
          <target state="translated">친구 연산자 (또는 함수)가있는 템플리트 유형의 코드 스 니펫이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="87a3d534ea37016d34d8be0559ae5f64128cdd0b" translate="yes" xml:space="preserve">
          <source>Here are &lt;a href=&quot;https://stackoverflow.com/questions/24715864/problems-importing-libraries-to-my-c-project-how-to-fix-this/24715865#24715865&quot;&gt;case1&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16&quot;&gt;case2&lt;/a&gt; handled in more detail from a &lt;em&gt;real world&lt;/em&gt; problem.</source>
          <target state="translated">&lt;em&gt;실제&lt;/em&gt; 문제에서 &lt;a href=&quot;https://stackoverflow.com/questions/24715864/problems-importing-libraries-to-my-c-project-how-to-fix-this/24715865#24715865&quot;&gt;case1&lt;/a&gt; 과 &lt;a href=&quot;https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16&quot;&gt;case2&lt;/a&gt; 가 더 자세히 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b457236fd45d4cf88f436ca559e82a847ed891f5" translate="yes" xml:space="preserve">
          <source>How do linkers work? The linker matches a function declaration (declared in the header) with its definition (in the shared library) by comparing their signatures. You can get a linker error if the linker doesn't find a function definition that matches perfectly.</source>
          <target state="translated">링커는 어떻게 작동합니까? 링커는 서명을 비교하여 함수 선언 (헤더에 선언 됨)과 정의 (공유 라이브러리에 있음)를 일치시킵니다. 링커가 완벽하게 일치하는 함수 정의를 찾지 못하면 링커 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4bca897be232f23b6899495a9467715ee2ea072" translate="yes" xml:space="preserve">
          <source>I can reproduce the problem in example 1, but not in example 2</source>
          <target state="translated">예제 1에서는 문제를 재현 할 수 있지만 예제 2에서는 재현 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="f16eb78437de212d219271bcd70b1ba35516fa2e" translate="yes" xml:space="preserve">
          <source>I edited the package (in the &lt;code&gt;packages&lt;/code&gt; folder inside the solution's directory) by finding &lt;code&gt;packagename\build\native\packagename.targets&lt;/code&gt; and inside that file, copying all the &lt;code&gt;v110&lt;/code&gt; sections.  I changed the &lt;code&gt;v110&lt;/code&gt; to &lt;code&gt;v120&lt;/code&gt; in &lt;strong&gt;the condition fields only&lt;/strong&gt; being very careful to leave the filename paths all as &lt;code&gt;v110&lt;/code&gt;.  This simply allowed Visual Studio 2013 to link to the libraries for 2012, and in this case, it worked.</source>
          <target state="translated">&lt;code&gt;packagename\build\native\packagename.targets&lt;/code&gt; 및 해당 파일 내부를 찾아서 모든 &lt;code&gt;v110&lt;/code&gt; 섹션을 복사하여 솔루션 디렉토리 내의 &lt;code&gt;packages&lt;/code&gt; 폴더에서 패키지를 편집했습니다. &lt;strong&gt;조건 필드&lt;/strong&gt; 에서 &lt;code&gt;v110&lt;/code&gt; 을 &lt;code&gt;v120&lt;/code&gt; 으로 변경하여 파일 이름 경로를 모두 &lt;code&gt;v110&lt;/code&gt; 으로 남겨 두는 것이 매우주의 깊었 습니다. 이를 통해 Visual Studio 2013은 2012 년의 라이브러리에 연결될 수 있었으며이 경우에는 효과가있었습니다.</target>
        </trans-unit>
        <trans-unit id="e185b3c33f0b4245c7351066033029dca1ef7148" translate="yes" xml:space="preserve">
          <source>I had the same issue. Say i have projects MyProject and TestProject. I had effectively linked the lib file for MyProject to the TestProject. However, this lib file was produced as the DLL for the MyProject was built. Also, I did not contain source code for all methods in the MyProject, but only access to the DLL's entry points.</source>
          <target state="translated">나는 같은 문제가 있었다. MyProject 및 TestProject 프로젝트가 있다고 가정 해보십시오. MyProject의 lib 파일을 TestProject에 효과적으로 연결했습니다. 그러나이 lib 파일은 MyProject의 DLL이 빌드 될 때 생성되었습니다. 또한 MyProject의 모든 메소드에 대한 소스 코드를 포함하지 않았지만 DLL의 진입 점에만 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="0436bfc3fe0e52928141662af3daf087596cf26f" translate="yes" xml:space="preserve">
          <source>I have two projects: &lt;code&gt;graphics.lib&lt;/code&gt; and &lt;code&gt;main.exe&lt;/code&gt;. Both projects depend on &lt;code&gt;common_math.h&lt;/code&gt;. Suppose the library exports the following function:</source>
          <target state="translated">&lt;code&gt;graphics.lib&lt;/code&gt; 와 &lt;code&gt;main.exe&lt;/code&gt; 두 가지 프로젝트가 있습니다. 두 프로젝트는 &lt;code&gt;common_math.h&lt;/code&gt; 에 의존합니다. 라이브러리가 다음 기능을 내보내는 것으로 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="956a2ac958701d2f4ab6fa4fc484437f762915e0" translate="yes" xml:space="preserve">
          <source>I just had this problem trying to link libpng with Visual Studio 2013.  The problem is that the package file only had libraries for Visual Studio 2010 and 2012.</source>
          <target state="translated">이 문제는 libpng를 Visual Studio 2013과 연결하는 데 문제가있었습니다. 패키지 파일에는 Visual Studio 2010 및 2012 용 라이브러리 만 있다는 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9b8b4b047b3721fecc60f4fca5ece4ff41298b6" translate="yes" xml:space="preserve">
          <source>I recently had this problem, and it turned out &lt;a href=&quot;https://stackoverflow.com/questions/27748699/unresolved-reference-to-constructor-which-is-defined/27748920#27748920&quot;&gt;it was a bug in Visual Studio Express 2013&lt;/a&gt;. I had to remove a source file from the project and re-add it to overcome the bug.</source>
          <target state="translated">최근 에이 문제가 발생 &lt;a href=&quot;https://stackoverflow.com/questions/27748699/unresolved-reference-to-constructor-which-is-defined/27748920#27748920&quot;&gt;했으며 Visual Studio Express 2013의 버그였습니다&lt;/a&gt; . 버그를 극복하기 위해 프로젝트에서 소스 파일을 제거하고 다시 추가해야했습니다.</target>
        </trans-unit>
        <trans-unit id="1f2758b006cc08918b9f02973af12be1faec02a9" translate="yes" xml:space="preserve">
          <source>I was recently able to get rid of an unresolved external error in Visual Studio 2012 just by recompiling the offending file. When I re-built, the error went away.</source>
          <target state="translated">최근에 문제를 일으키는 파일을 다시 컴파일하여 Visual Studio 2012에서 해결되지 않은 외부 오류를 제거 할 수있었습니다. 내가 재건하면 오류가 사라졌습니다.</target>
        </trans-unit>
        <trans-unit id="3655c386da677b651bbf58700cb3b35ab01cf79c" translate="yes" xml:space="preserve">
          <source>I was using an alias to refer to &lt;code&gt;std::filesystem::path&lt;/code&gt;: filesystem is in the standard library since C++17 but my program needed to &lt;strong&gt;also compile in C++14&lt;/strong&gt; so I decided to use a variable alias:</source>
          <target state="translated">&lt;code&gt;std::filesystem::path&lt;/code&gt; 를 참조하기 위해 별칭을 사용하고있었습니다. 파일 시스템은 C ++ 17 이후 표준 라이브러리에 있지만 내 프로그램 &lt;strong&gt;은 C ++ 14로 컴파일&lt;/strong&gt; 해야하므로 변수 별칭을 사용하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="5173770afade73bcecf7a320d6a1ae32ba13af7d" translate="yes" xml:space="preserve">
          <source>I'll try to explain what is an &quot;undefined reference/unresolved external symbol&quot;.</source>
          <target state="translated">&quot;정의되지 않은 참조 / 해결되지 않은 외부 심볼&quot;이 무엇인지 설명하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a04cfe5805e064fc6a684cbba78e89796fa1eff1" translate="yes" xml:space="preserve">
          <source>I've rejected some lines from output, because they do not matter</source>
          <target state="translated">출력에서 일부 라인을 거부했습니다.</target>
        </trans-unit>
        <trans-unit id="2bb7febe7f23a580135ec4f7b408f003af4cb53e" translate="yes" xml:space="preserve">
          <source>If .cpp files depends on   additional .h files  in order to find symbols
that may or may not be defined in the file .cpp</source>
          <target state="translated">.cpp 파일이 파일에 정의되어 있거나 정의되어 있지 않은 기호를 찾기 위해 추가 .h 파일에 의존하는 경우</target>
        </trans-unit>
        <trans-unit id="df67f3ef9d0be7171f81833f9b68966903db7af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;libfoo&lt;/code&gt; depends on &lt;code&gt;libbar&lt;/code&gt;, then your linkage correctly puts &lt;code&gt;libfoo&lt;/code&gt; before &lt;code&gt;libbar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;libfoo&lt;/code&gt; 가 &lt;code&gt;libbar&lt;/code&gt; 에 의존하는 경우 링크는 &lt;code&gt;libfoo&lt;/code&gt; 를 &lt;code&gt;libbar&lt;/code&gt; 앞에 올바르게 넣 습니다 .</target>
        </trans-unit>
        <trans-unit id="461d3e959eb928d5e96fcebb9ba3f3fe9ab2bb40" translate="yes" xml:space="preserve">
          <source>If I just do:</source>
          <target state="translated">내가 방금 할 경우 :</target>
        </trans-unit>
        <trans-unit id="da08d2f992c3ccba47f676d81d16d167ac1f33a4" translate="yes" xml:space="preserve">
          <source>If Linker finds an external symbol in one static library he includes the symbol in the output of the project.However, if the library is shared( dynamic ) he doesn't include the code ( symbols ) in output, but  &lt;em&gt;Run-Time&lt;/em&gt; crashes may occur</source>
          <target state="translated">링커가 하나의 정적 라이브러리에서 외부 심볼을 ​​찾으면 프로젝트 출력에 심볼을 포함하지만 라이브러리가 공유되는 경우 (dynamic) 출력에 코드 (symbols)를 포함하지 않지만 &lt;em&gt;런타임&lt;/em&gt; 충돌이 발생할 수 있습니다 나오다</target>
        </trans-unit>
        <trans-unit id="980c254b69ed02be4226999c6e10d518c5a452c3" translate="yes" xml:space="preserve">
          <source>If an entire library is included in a header file (and was compiled as C code); the include will need to be as follows;</source>
          <target state="translated">전체 라이브러리가 헤더 파일에 포함되어 있고 C 코드로 컴파일 된 경우 포함은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="f26256c9ecf88ebe6b32a09b8f863a10b618c2ed" translate="yes" xml:space="preserve">
          <source>If exists one .cpp file in which the compiler could not find one symbol, a &lt;strong&gt;compiler time error&lt;/strong&gt; raises the message &lt;em&gt;Symbol x could not be found&lt;/em&gt;</source>
          <target state="translated">컴파일러에서 하나의 심볼을 찾을 수없는 .cpp 파일이 하나 있으면 &lt;strong&gt;컴파일러 시간 오류로&lt;/strong&gt; 인해 &lt;em&gt;심볼 x를 찾을 수 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b01078c7a78e15aafb190fba7f0e6960757acba2" translate="yes" xml:space="preserve">
          <source>If one symbol could not be found in object files he also is searched in Additional Libraries.For adding a new library to a project &lt;strong&gt;Configuration properties&lt;/strong&gt; -&amp;gt; &lt;strong&gt;VC++ Directories&lt;/strong&gt;  -&amp;gt; &lt;strong&gt;Library Directories&lt;/strong&gt; and here you specified additional folder for searching libraries and &lt;strong&gt;Configuration properties&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Linker&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Input&lt;/strong&gt; for specifying the name of the library. 
-If the Linker could not find the symbol which you write in one .cpp he raises a &lt;strong&gt;linker time error&lt;/strong&gt; which may sound like 
&lt;code&gt;error LNK2001: unresolved external symbol &quot;void __cdecl foo(void)&quot; (?foo@@YAXXZ)&lt;/code&gt;</source>
          <target state="translated">객체 파일에서 하나의 심볼을 찾을 수없는 경우 추가 라이브러리에서도 검색됩니다. 프로젝트에 새 라이브러리 추가-&amp;gt; &lt;strong&gt;VC ++ 디렉토리&lt;/strong&gt; -&amp;gt; &lt;strong&gt;라이브러리 디렉토리&lt;/strong&gt; 및 여기에서 라이브러리 및 &lt;strong&gt;구성 특성&lt;/strong&gt; 검색을위한 추가 폴더를 지정했습니다. &lt;strong&gt;링커&lt;/strong&gt; -&amp;gt; 라이브러리 이름을 지정하기위한 &lt;strong&gt;입력&lt;/strong&gt; . -링커가 한 .cpp에 작성하는 기호를 찾을 수 없으면 &lt;strong&gt;링커 시간 오류&lt;/strong&gt; 가 &lt;code&gt;error LNK2001: unresolved external symbol &quot;void __cdecl foo(void)&quot; (?foo@@YAXXZ)&lt;/code&gt; 와 같이 들릴 수 있습니다 . 해결되지 않은 외부 기호 &quot;void __cdecl foo (void)&quot;(? foo @@ YAXXZ)</target>
        </trans-unit>
        <trans-unit id="499b77dbfc0604ee9598e32b2d28291c11fb0b8e" translate="yes" xml:space="preserve">
          <source>If that is true, then the linker will &lt;em&gt;not&lt;/em&gt; copy any chunks out of &lt;code&gt;libz&lt;/code&gt; and
add them to your program; instead, it will just doctor the code of your program 
so that:-</source>
          <target state="translated">이것이 사실이면 링커는 &lt;code&gt;libz&lt;/code&gt; 에서 청크를 복사하지 &lt;em&gt;않고&lt;/em&gt; 프로그램에 추가 &lt;em&gt;하지 않습니다&lt;/em&gt; . 대신 프로그램 코드를 닥터하여 다음과 같이합니다.</target>
        </trans-unit>
        <trans-unit id="2c00c20b5f535cd9bc44be19371d9b66f3b65283" translate="yes" xml:space="preserve">
          <source>If that is true, then the linker will extract a copy of &lt;code&gt;my_lib.o&lt;/code&gt; from the library and
add it to your program. Then, your program contains a definition for &lt;code&gt;hw&lt;/code&gt;, so
its references to &lt;code&gt;hw&lt;/code&gt; are &lt;em&gt;resolved&lt;/em&gt;.</source>
          <target state="translated">이것이 사실이라면, 링커는 라이브러리에서 &lt;code&gt;my_lib.o&lt;/code&gt; 의 사본을 추출하여 프로그램에 추가합니다. 그런 다음 프로그램에 &lt;code&gt;hw&lt;/code&gt; 에 대한 정의가 포함되어 있으므로 hw 에 대한 참조가 &lt;em&gt;해결&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="38c0025e9bec005d4513bd13d86176f0298b0557" translate="yes" xml:space="preserve">
          <source>If the implementation is outside the class definition, but in a header, the methods have to be marked as &lt;code&gt;inline&lt;/code&gt; to prevent a multiple definition.</source>
          <target state="translated">구현이 클래스 정의 외부에 있지만 헤더에있는 경우 다중 정의를 방지하려면 메소드를 &lt;code&gt;inline&lt;/code&gt; 으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="75447576423c30e2c34a784049e8ce92fc59db32" translate="yes" xml:space="preserve">
          <source>If we want to call some functions in a library, but the import library is not added into the additional dependency list (set from: &lt;code&gt;Project | Properties | Configuration Properties | Linker | Input | Additional Dependency&lt;/code&gt;) of your project setting. Now the linker will report a LNK2019 since the definition does not exist in current searching scope.</source>
          <target state="translated">라이브러리에서 일부 함수를 호출하려고하지만 가져 오기 라이브러리가 &lt;code&gt;Project | Properties | Configuration Properties | Linker | Input | Additional Dependency&lt;/code&gt; 설정의 추가 종속성 목록 ( 프로젝트 | 특성 | 구성 특성 | 링커 | 입력 | 추가 종속성에서 설정)에 추가되지 않은 경우 . 이제 정의는 현재 검색 범위에 없으므로 링커에서 LNK2019를보고합니다.</target>
        </trans-unit>
        <trans-unit id="fb9269e2b18055a742c1557e6ab1048d1318a42e" translate="yes" xml:space="preserve">
          <source>If you get linker errors about undefined references to symbols that involve types in the std::__cxx11 namespace or the tag [abi:cxx11] then it probably indicates that you are trying to link together object files that were compiled with different values for the _GLIBCXX_USE_CXX11_ABI macro. This commonly happens when linking to a third-party library that was compiled with an older version of GCC. If the third-party library cannot be rebuilt with the new ABI then you will need to recompile your code with the old ABI.</source>
          <target state="translated">std :: __ cxx11 네임 스페이스 또는 태그 [abi : cxx11]의 유형을 포함하는 기호에 대한 정의되지 않은 참조에 대한 링커 오류가 발생하면 _GLIBCXX_USE_CXX11_ABI에 대해 서로 다른 값으로 컴파일 된 오브젝트 파일을 함께 연결하려고 함을 나타냅니다. 매크로. 이는 일반적으로 이전 버전의 GCC로 컴파일 된 타사 라이브러리에 연결할 때 발생합니다. 타사 라이브러리를 새 ABI로 다시 빌드 할 수없는 경우 이전 ABI로 코드를 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="f035da38c9a7e86389d0510b74c92ffc7c0c115a" translate="yes" xml:space="preserve">
          <source>If you're using Microsoft Visual Studio, you'll see that projects generate &lt;code&gt;.lib&lt;/code&gt; files. These contain a table of exported symbols, and a table of imported symbols. The imported symbols are resolved against the libraries you link against, and the exported symbols are provided for the libraries that use that &lt;code&gt;.lib&lt;/code&gt; (if any).</source>
          <target state="translated">Microsoft Visual Studio를 사용하는 경우 프로젝트가 &lt;code&gt;.lib&lt;/code&gt; 파일을 생성하는 것을 볼 수 있습니다. 여기에는 내 보낸 심볼 테이블과 가져온 심볼 테이블이 포함됩니다. 가져온 심볼은 링크 한 라이브러리에 대해 분석되고 해당 &lt;code&gt;.lib&lt;/code&gt; (있는 경우)를 사용하는 라이브러리에 대해 내 보낸 심볼이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8833aea382a302f646216649f9921b661839e34c" translate="yes" xml:space="preserve">
          <source>If your IDE supports &lt;em&gt;Plain Console Projects&lt;/em&gt; you might want to choose this project type, instead of a windows application project.</source>
          <target state="translated">IDE가 &lt;em&gt;일반 콘솔 프로젝트&lt;/em&gt; 를 지원하는 경우 Windows 응용 프로그램 프로젝트 대신이 프로젝트 유형을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f237fb8dc4cacf36f11d31545ebe99a25aef03b" translate="yes" xml:space="preserve">
          <source>In Windows programming, the tell-tale sign that you did not link a necessary library is that the name of the unresolved symbol begins with &lt;code&gt;__imp_&lt;/code&gt;. Look up the name of the function in the documentation, and it should say which library you need to use. For example, MSDN puts the information in a box at the bottom of each function in a section called &quot;Library&quot;.</source>
          <target state="translated">Windows 프로그래밍에서, 필요한 라이브러리를 연결하지 않았다는 이야기는 해결되지 않은 기호의 이름이 &lt;code&gt;__imp_&lt;/code&gt; 로 시작 한다는 것 입니다. 설명서에서 함수 이름을 찾아보고 사용해야하는 라이브러리가 있어야합니다. 예를 들어 MSDN은 &quot;라이브러리&quot;라는 섹션의 각 함수 맨 아래에있는 상자에 정보를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="66430e667fc7f840b097b706996793b9736a8e56" translate="yes" xml:space="preserve">
          <source>In addition to the library path including the directory of the library, this should be the full name of the library.</source>
          <target state="translated">라이브러리의 디렉토리를 포함하여 라이브러리 경로 외에도 라이브러리의 전체 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="10bf6a64e5446398af8a3ba19c87d193fc7bdd0c" translate="yes" xml:space="preserve">
          <source>In b.cpp we want to call function foo, so we add</source>
          <target state="translated">b.cpp에서는 foo 함수를 호출하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="e04d65d1151fc1eecd729107e8faa2882c68cf4a" translate="yes" xml:space="preserve">
          <source>In general the IDE or build will include some form of &quot;clean&quot; function, but this may not be correctly configured (e.g. in a manual makefile) or may fail (e.g. the intermediate or resultant binaries are read-only).</source>
          <target state="translated">일반적으로 IDE 또는 빌드에는 어떤 형태의 &quot;clean&quot;기능이 포함되지만, 이는 올바르게 구성되지 않았거나 (예 : 수동 makefile에서) 실패 할 수 있습니다 (예 : 중간 또는 결과 바이너리가 읽기 전용).</target>
        </trans-unit>
        <trans-unit id="6703e5641bd382c96b9757b2f2d5f1a0d78b8aef" translate="yes" xml:space="preserve">
          <source>In that case, it means that the available symbols are for a different architecture than the one you are compiling for.</source>
          <target state="translated">이 경우 사용 가능한 기호가 컴파일하는 것과 다른 아키텍처에 대한 것임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dc33cdb4c80f7ba7f9c92526e532ade7bc8fcd31" translate="yes" xml:space="preserve">
          <source>In the sequence of object files and libraries you want to link to make your
program, you are placing the libraries before the object files that refer to
them. You need to place the libraries &lt;em&gt;after&lt;/em&gt; the object files that refer
to them.</source>
          <target state="translated">프로그램을 만들기 위해 링크하려는 일련의 객체 파일 및 라이브러리에서 라이브러리를 참조하는 객체 파일 앞에 라이브러리를 배치합니다. 라이브러리를 참조하는 오브젝트 파일 &lt;em&gt;뒤에&lt;/em&gt; 라이브러리를 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2551cda3851296856857b433cfe97a4cfb2b4c9" translate="yes" xml:space="preserve">
          <source>Inconsistent &lt;code&gt;UNICODE&lt;/code&gt; definitions</source>
          <target state="translated">일치하지 않는 &lt;code&gt;UNICODE&lt;/code&gt; 정의</target>
        </trans-unit>
        <trans-unit id="6fe63eb632221a0ab5535bb76d4c287ae69ff6c4" translate="yes" xml:space="preserve">
          <source>Incorrectly importing/exporting methods/classes across modules/dll (compiler specific).</source>
          <target state="translated">모듈 / dll (컴파일러 특정)에서 메소드 / 클래스 가져 오기 / 내보내기</target>
        </trans-unit>
        <trans-unit id="dcc92bce0411701f86858935b384ecc04c852ca4" translate="yes" xml:space="preserve">
          <source>Incorrectly importing/exporting methods/classes across modules/dll. (MSVS specific)</source>
          <target state="translated">모듈 / dll에서 메소드 / 클래스 가져 오기 / 내보내기가 잘못되었습니다. (MSVS 특정)</target>
        </trans-unit>
        <trans-unit id="cb120259d25bd6e5201a19869cfd5a9742881496" translate="yes" xml:space="preserve">
          <source>Interdependent library order</source>
          <target state="translated">상호 의존적 라이브러리 순서</target>
        </trans-unit>
        <trans-unit id="503e384f0e4e309c11e3d62de8daa731f1a8d2b6" translate="yes" xml:space="preserve">
          <source>Is it possible to still get a linker error even though the declaration and the definition seem to match? Yes! They might look the same in source code, but it really depends on what the compiler sees. Essentially you could end up with a situation like this:</source>
          <target state="translated">선언과 정의가 일치하는 것처럼 보이지만 링커 오류가 계속 발생할 수 있습니까? 예! 소스 코드에서 동일하게 보일 수 있지만 실제로 컴파일러에서 보는 내용에 따라 다릅니다. 기본적으로 다음과 같은 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="771fa3988067ff8a58eabb454bbc75170f08c3d6" translate="yes" xml:space="preserve">
          <source>It can also happen that you forget to add the file to the compilation, in which case the object file won't be generated. In &lt;strong&gt;gcc&lt;/strong&gt; you'd add the files to the command line. In &lt;strong&gt;MSVS&lt;/strong&gt; adding the file to the project will make it compile it automatically (albeit files can, manually, be individually excluded from the build).</source>
          <target state="translated">컴파일에 파일을 추가하는 것을 잊어 버릴 수도 있습니다.이 경우 개체 파일이 생성되지 않습니다. &lt;strong&gt;gcc&lt;/strong&gt; 에서는 파일을 명령 줄에 추가합니다. &lt;strong&gt;MSVS&lt;/strong&gt; 에서 파일을 프로젝트에 추가하면 파일이 자동으로 컴파일됩니다 (파일은 수동으로 빌드에서 개별적으로 제외 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="fe2ed6691d966ca4bdd41bbcc54c815e1cd0e42a" translate="yes" xml:space="preserve">
          <source>It has happened because our local_var_name is static, i.e. it is not visible for other modules. 
Now more deeply. Get the translation phase output</source>
          <target state="translated">local_var_name이 정적이기 때문에 발생했습니다. 즉, 다른 모듈에서는 볼 수 없습니다. 이제 더 깊이. 번역 단계 출력을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="627cb145db504cc28647105b8ad1ef86f1340665" translate="yes" xml:space="preserve">
          <source>It is uneconomical at &lt;em&gt;runtime&lt;/em&gt;, because it can cause shared libraries to be
loaded along with a program even if doesn't need them.</source>
          <target state="translated">공유 라이브러리가 필요하지 않더라도 공유 라이브러리를 프로그램과 함께로드 할 수 있기 때문에 &lt;em&gt;런타임에&lt;/em&gt; 비 경제적입니다.</target>
        </trans-unit>
        <trans-unit id="13f85c801fb44532a6193ffc156ba3a1273c4b81" translate="yes" xml:space="preserve">
          <source>LLVM &lt;a href=&quot;http://llvm.org/releases/3.6.2/docs/CommandGuide/llvm-link.html#cmdoption-v&quot;&gt;linker page&lt;/a&gt;.</source>
          <target state="translated">LLVM &lt;a href=&quot;http://llvm.org/releases/3.6.2/docs/CommandGuide/llvm-link.html#cmdoption-v&quot;&gt;링커 페이지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8b4459da7b6461b4c2299ccc79bca1d6aa1bc0f" translate="yes" xml:space="preserve">
          <source>Lastly, the &lt;code&gt;pkg-config&lt;/code&gt; variation of example 2 has a now obvious explanation.
After shell-expansion:</source>
          <target state="translated">마지막으로, 예제 2의 &lt;code&gt;pkg-config&lt;/code&gt; 변형은 이제 명백한 설명입니다. 쉘 확장 후 :</target>
        </trans-unit>
        <trans-unit id="46640750de5d6c26ef3345516697c4c8de1c5c05" translate="yes" xml:space="preserve">
          <source>Let's say I have three files: main.cpp, file.h, file.cpp:</source>
          <target state="translated">main.cpp, file.h, file.cpp의 세 파일이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="8fb4c3c64119c8c2cdfc81bebdd5f927b932e0aa" translate="yes" xml:space="preserve">
          <source>Link example 1 correctly:</source>
          <target state="translated">예제 1을 올바르게 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="bd65393a1e1fc0de6adb743f6af3918125bb0ecc" translate="yes" xml:space="preserve">
          <source>Link example 2 correctly:</source>
          <target state="translated">예제 2를 올바르게 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="eff7b8e1e01a437aa7f86d07bd975b1d3e3d6b4f" translate="yes" xml:space="preserve">
          <source>Link invocation (command line),</source>
          <target state="translated">링크 호출 (명령 줄)</target>
        </trans-unit>
        <trans-unit id="4da0c7603f707d809b67abb53db4ebf240bc0929" translate="yes" xml:space="preserve">
          <source>Link our object files</source>
          <target state="translated">객체 파일 연결</target>
        </trans-unit>
        <trans-unit id="b4235ce9a11da86196b06273997efb6e1bb09f1b" translate="yes" xml:space="preserve">
          <source>Link the example 2 &lt;code&gt;pkg-config&lt;/code&gt; variation correctly:</source>
          <target state="translated">예제 2 &lt;code&gt;pkg-config&lt;/code&gt; 변형을 올바르게 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="a67761a97541734d3b1dd08a0be04d93cf4eb6b1" translate="yes" xml:space="preserve">
          <source>Linker Time Error</source>
          <target state="translated">링커 시간 오류</target>
        </trans-unit>
        <trans-unit id="93df95814a97d8e558d63057388f44e8335ec3a6" translate="yes" xml:space="preserve">
          <source>Linker errors can happen when a header file and its associated shared library (.lib file) go out of sync. Let me explain.</source>
          <target state="translated">헤더 파일과 관련 공유 라이브러리 (.lib 파일)가 동기화되지 않으면 링커 오류가 발생할 수 있습니다. 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="2f12c9c12e76e06c4529ab38bf1b266c849ada4a" translate="yes" xml:space="preserve">
          <source>Linker sees exported symbols and links it. Now we try to uncomment lines in src2.cpp like here</source>
          <target state="translated">링커는 내 보낸 심볼을보고 링크합니다. 이제 우리는 src2.cpp에서 줄을 주석 해제하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ff5d8fd0650014513ae22d4ad7c2df789c1613a9" translate="yes" xml:space="preserve">
          <source>Linux &lt;a href=&quot;http://linux.die.net/man/1/ld&quot;&gt;ld man page&lt;/a&gt;.</source>
          <target state="translated">리눅스 &lt;a href=&quot;http://linux.die.net/man/1/ld&quot;&gt;ld man page&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1602232f4b5e2f467a8d3b007a0131ae5384e107" translate="yes" xml:space="preserve">
          <source>MSVS requires you to specify which symbols to export and import using &lt;code&gt;__declspec(dllexport)&lt;/code&gt; and &lt;code&gt;__declspec(dllimport)&lt;/code&gt;.</source>
          <target state="translated">MSVS에서는 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; 및 &lt;code&gt;__declspec(dllimport)&lt;/code&gt; 사용하여 내보내고 가져올 심볼을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="976f170a12de6c4ee60dc922bc6d9db457f350ab" translate="yes" xml:space="preserve">
          <source>Make object files</source>
          <target state="translated">객체 파일 만들기</target>
        </trans-unit>
        <trans-unit id="daa6e7741bcaa1754abaefe5829b55e9e65ff067" translate="yes" xml:space="preserve">
          <source>Make sure that your external library doesn't contain symbols that may enter into conflict with other symbols you defined in your header files</source>
          <target state="translated">외부 라이브러리에 헤더 파일에 정의한 다른 기호와 충돌 할 수있는 기호가 포함되어 있지 않은지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="9923a08fcadb46cb599ab38321c7d4b2a14511aa" translate="yes" xml:space="preserve">
          <source>Make sure you write your c++ project syntactical correct.</source>
          <target state="translated">C ++ 프로젝트의 구문이 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="90926b930049fc977cdcf047eff29fccda6c34ad" translate="yes" xml:space="preserve">
          <source>Many Linux distros today configure their GCC toolchain so that its language drivers (&lt;code&gt;gcc&lt;/code&gt;,&lt;code&gt;g++&lt;/code&gt;,&lt;code&gt;gfortran&lt;/code&gt; etc)
instruct the system linker (&lt;code&gt;ld&lt;/code&gt;) to link shared libraries on an &lt;em&gt;as-needed&lt;/em&gt; basis.
You have got one of those distros.</source>
          <target state="translated">오늘날 많은 Linux 배포판에서 언어 드라이버 ( &lt;code&gt;gcc&lt;/code&gt; , &lt;code&gt;g++&lt;/code&gt; , &lt;code&gt;gfortran&lt;/code&gt; 등) &lt;em&gt;가 필요에 따라&lt;/em&gt; 공유 라이브러리를 링크하도록 시스템 링커 ( &lt;code&gt;ld&lt;/code&gt; )에 지시하도록 GCC 툴체인을 구성합니다. 그 배포판 중 하나가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea292f71f513f2f49b3c0ecc19893f09a021ecf" translate="yes" xml:space="preserve">
          <source>Microsoft offers a &lt;code&gt;#pragma&lt;/code&gt; to reference the correct library at link time;</source>
          <target state="translated">Microsoft는 링크 타임에 올바른 라이브러리를 참조 할 수있는 &lt;code&gt;#pragma&lt;/code&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c84452b5c5beed02d4bfc0b6a144ddbc0f9f2c52" translate="yes" xml:space="preserve">
          <source>Missing &quot;extern&quot; in &lt;code&gt;const&lt;/code&gt; variable declarations/definitions (C++ only)</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 변수 선언 / 정의에서 &quot;extern&quot;이 누락 됨 (C ++ 만 해당)</target>
        </trans-unit>
        <trans-unit id="a0b0d93816c556d77f42fe7a2651c42eb165889f" translate="yes" xml:space="preserve">
          <source>Missing &quot;extern&quot; in const variable declarations/definitions (C++ only)</source>
          <target state="translated">const 변수 선언 / 정의에서 &quot;extern&quot;이 누락 됨 (C ++ 만 해당)</target>
        </trans-unit>
        <trans-unit id="5eb6f3aa726cfe18f5057b4aefa2edb20315a029" translate="yes" xml:space="preserve">
          <source>Mistyping or not including the .lib extension when using the &lt;code&gt;#pragma&lt;/code&gt; (Microsoft Visual Studio)</source>
          <target state="translated">&lt;code&gt;#pragma&lt;/code&gt; (Microsoft Visual Studio)를 사용할 때 .lib 확장자가 잘못되었거나 포함되지 않음</target>
        </trans-unit>
        <trans-unit id="f54d45d1a4464006ef586499c694d801d5a8d12c" translate="yes" xml:space="preserve">
          <source>More &lt;a href=&quot;https://gcc.gnu.org/wiki/Visibility&quot;&gt;information about visibility&lt;/a&gt; can be found on the gcc wiki.</source>
          <target state="translated">&lt;a href=&quot;https://gcc.gnu.org/wiki/Visibility&quot;&gt;가시성에 대한&lt;/a&gt; 자세한 내용은 gcc 위키에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="641fea9b7a86c80e1745eea04b284d17d7064212" translate="yes" xml:space="preserve">
          <source>Most modern linkers include a verbose option that prints out to varying degrees;</source>
          <target state="translated">대부분의 최신 링커에는 다양한 각도로 인쇄하는 자세한 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e559ced22868458277e7a84fcf34818870da0124" translate="yes" xml:space="preserve">
          <source>Multiple source files of the same name</source>
          <target state="translated">같은 이름의 여러 소스 파일</target>
        </trans-unit>
        <trans-unit id="c767224b9650ce630e60df38453f62be584ffe15" translate="yes" xml:space="preserve">
          <source>Next, it finds &lt;code&gt;eg1.o&lt;/code&gt;, and adds it to be program. An object file in the
linkage sequence is always added to the program. Now, the program makes
a reference to &lt;code&gt;hw&lt;/code&gt;, and does not contain a definition of &lt;code&gt;hw&lt;/code&gt;; but
there is nothing left in the linkage sequence that could provide the missing
definition. The reference to &lt;code&gt;hw&lt;/code&gt; ends up &lt;em&gt;unresolved&lt;/em&gt;, and the linkage fails.</source>
          <target state="translated">다음으로 &lt;code&gt;eg1.o&lt;/code&gt; 를 찾아 프로그램으로 추가합니다. 연계 시퀀스의 객체 파일은 항상 프로그램에 추가됩니다. 이제 프로그램은 &lt;code&gt;hw&lt;/code&gt; 를 참조하고 hw 의 정의를 포함하지 않습니다. 그러나 연결 순서에 누락 된 정의를 제공 할 수있는 것은 없습니다. &lt;code&gt;hw&lt;/code&gt; 에 대한 참조는 &lt;em&gt;해결되지 않고&lt;/em&gt; 연결에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f0d2f6223f521a208279e081a4e5a7ac2c7dd700" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;virtual&lt;/code&gt; class members</source>
          <target state="translated">비가 상반 멤버</target>
        </trans-unit>
        <trans-unit id="117ed9998cfcf9683b519b2cfb916a1303481e8f" translate="yes" xml:space="preserve">
          <source>Note how even though both the function declarations look identical in source code, but they are really different according to the compiler.</source>
          <target state="translated">소스 코드에서 두 함수 선언이 동일하게 보이지만 컴파일러에 따라 실제로는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5abbdb9f6a8ffe88fc827af5fbe46e7e3a900154" translate="yes" xml:space="preserve">
          <source>Note in this example, the linker would tell you it couldn't find &lt;code&gt;draw()&lt;/code&gt;, when in reality you know it obviously is being exported by the library. You could spend hours scratching your head wondering what went wrong. The thing is, the linker sees a different signature because the parameter types are slightly different. In the example, &lt;code&gt;vec3&lt;/code&gt; is a different type in both projects as far as the compiler is concerned. This could happen because they come from two slightly different include files (maybe the include files come from two different versions of the library).</source>
          <target state="translated">이 예제에서 링커는 실제로 라이브러리에서 내보내고 있음을 알면 &lt;code&gt;draw()&lt;/code&gt; 찾을 수 없다고 알려줍니다. 무엇이 잘못되었는지 궁금해하는 데 시간을 할애 할 수 있습니다. 문제는 매개 변수 유형이 약간 다르기 때문에 링커에서 다른 서명을 보는 것입니다. 이 예제에서 &lt;code&gt;vec3&lt;/code&gt; 은 컴파일러에 관한 한 두 프로젝트에서 다른 유형입니다. 이것은 파일이 약간 다른 두 개의 포함 파일에서 나왔기 때문에 발생할 수 있습니다 (포함 파일은 두 개의 다른 버전의 라이브러리에서 온 것 같습니다).</target>
        </trans-unit>
        <trans-unit id="23d4b3aa6710b3034b123422af2beef9dd73642c" translate="yes" xml:space="preserve">
          <source>Note the &lt;strong&gt;different libraries&lt;/strong&gt; used in main.cpp and file.h. Since main.cpp #include'd &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot; after &amp;lt;&lt;strong&gt;filesystem&lt;/strong&gt;&amp;gt;, the version of filesystem used there was &lt;strong&gt;the C++17 one&lt;/strong&gt;. I used to compile the program with the following commands:</source>
          <target state="translated">main.cpp 및 file.h에서 사용되는 &lt;strong&gt;다른 라이브러리를&lt;/strong&gt; 참고하십시오. &amp;lt; &lt;strong&gt;filesystem&lt;/strong&gt; &amp;gt; 다음에 main.cpp #include ' &quot;file.h&quot;가 &lt;strong&gt;있으므로&lt;/strong&gt; 사용 된 파일 시스템 버전은 &lt;strong&gt;C ++ 17&lt;/strong&gt; 입니다. 다음 명령으로 프로그램을 컴파일했습니다.</target>
        </trans-unit>
        <trans-unit id="6ce292ed7cabf956b3bed91089eb7d1238831776" translate="yes" xml:space="preserve">
          <source>Note the weird mangled name given in the linker error. (eg. draw@graphics@XYZ).</source>
          <target state="translated">링커 오류에 표시되는 이상한 맹 글링 된 이름에 유의하십시오. (예 : draw @ graphics @ XYZ).</target>
        </trans-unit>
        <trans-unit id="3b2cfcdfa403dfa1ba5b0b9b3a8ea1bd2538d22c" translate="yes" xml:space="preserve">
          <source>Now when you build this code you will get a LNK2019 error complaining that foo is an unresolved symbol. In this case, we know that foo() has its definition in a.cpp, but different from the one we are calling(different return value). This is the case that definition exists.</source>
          <target state="translated">이제이 코드를 빌드하면 LNK2019 오류가 발생하여 foo가 해결되지 않은 기호임을 불평합니다. 이 경우, 우리는 foo ()가 a.cpp에서 그 정의를 가지고 있지만, 우리가 호출하는 것과는 다르다는 것을 알고 있습니다 (다른 반환 값). 정의가 존재하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="3fd0cadfd7a6c67e12488f6b0910e0bf6fc11715" translate="yes" xml:space="preserve">
          <source>OK (no errors), because we only build object file, linking is not done yet.
Try to link</source>
          <target state="translated">OK (오류 없음) : 오브젝트 파일 만 빌드하므로 링크는 아직 완료되지 않았습니다. 연결하려고</target>
        </trans-unit>
        <trans-unit id="e251c8f846836883316a7f1bd7f47a5ca9918668" translate="yes" xml:space="preserve">
          <source>On Linux, it may be due to the wrong library folder (using &lt;code&gt;lib&lt;/code&gt; instead of &lt;code&gt;lib64&lt;/code&gt; for instance).</source>
          <target state="translated">Linux에서는 잘못된 라이브러리 폴더 (예 : &lt;code&gt;lib64&lt;/code&gt; 대신 &lt;code&gt;lib&lt;/code&gt; 를 사용)로 인한 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86966d8cfc106dd026001fc5ff966b8b3018c853" translate="yes" xml:space="preserve">
          <source>On MacOS, there is the option of shipping both architectures in the same file. It may be that the link expects both versions to be there, but only one is. It can also be an issue with the wrong &lt;code&gt;lib&lt;/code&gt;/&lt;code&gt;lib64&lt;/code&gt; folder where the library is picked up.</source>
          <target state="translated">MacOS에는 두 아키텍처를 모두 같은 파일로 제공하는 옵션이 있습니다. 링크는 두 버전이 모두있을 것으로 예상하지만 하나만 있습니다. 라이브러리가 선택되는 잘못된 &lt;code&gt;lib&lt;/code&gt; / &lt;code&gt;lib64&lt;/code&gt; 폴더에 문제가있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="11ea8afa3c6fc752c5cd8f5e66cffa69d7e4417a" translate="yes" xml:space="preserve">
          <source>On Visual Studio, this is due to the wrong &quot;Platform&quot;, and you need to either select the proper one or install the proper version of the library.</source>
          <target state="translated">Visual Studio에서 이는 잘못된 &quot;플랫폼&quot;으로 인한 것이므로 적절한 버전을 선택하거나 올바른 버전의 라이브러리를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="457c63213d9d88bc27b8181901ab2f67874c5025" translate="yes" xml:space="preserve">
          <source>Once the &quot;clean&quot; has completed, verify that the &quot;clean&quot; has succeeded and all the generated intermediate file (e.g. an automated makefile) have been successfully removed.</source>
          <target state="translated">&quot;clean&quot;이 완료되면 &quot;clean&quot;이 성공하고 생성 된 모든 중간 파일 (예 : 자동화 된 makefile)이 성공적으로 제거되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6f5728e6f888e3db2ef5e4e2e84aed1bcec411c8" translate="yes" xml:space="preserve">
          <source>Once the Linker find one symbol he doesn't search in other libraries for it</source>
          <target state="translated">링커가 한 심볼을 찾으면 다른 라이브러리에서 해당 심볼을 검색하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94e5d03e6bfe739776bcda7bf67b4b04f50d00e4" translate="yes" xml:space="preserve">
          <source>One possible reason for linker errors with GCC 5.2.0 is that a new libstdc++ library ABI is now chosen by default.</source>
          <target state="translated">GCC 5.2.0에서 링커 오류가 발생하는 한 가지 이유는 이제 새로운 libstdc ++ 라이브러리 ABI가 기본적으로 선택되어 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e8ebcbceae17e1cbcb7630b4e7cab992bde641ed" translate="yes" xml:space="preserve">
          <source>Or in the project settings;</source>
          <target state="translated">또는 프로젝트 설정에서;</target>
        </trans-unit>
        <trans-unit id="3324fb682ba3b5fa0fc5008f94f9c3c6cb160fbe" translate="yes" xml:space="preserve">
          <source>Or on the command line;</source>
          <target state="translated">또는 명령 행에서;</target>
        </trans-unit>
        <trans-unit id="0d8974a160f915d9994dddc618b6681fd0f9d9cf" translate="yes" xml:space="preserve">
          <source>Or you could replace the -l argument with the full path of the .so, e.g. instead of &lt;code&gt;-ltbb&lt;/code&gt; do &lt;code&gt;/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2&lt;/code&gt;</source>
          <target state="translated">또는 -l 인수를 .so의 전체 경로로 바꿀 수 있습니다 (예 : &lt;code&gt;-ltbb&lt;/code&gt; do &lt;code&gt;/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2&lt;/code&gt; 대신).</target>
        </trans-unit>
        <trans-unit id="4ae41d11bd46131c063f0debe5a8fdf31f161cd3" translate="yes" xml:space="preserve">
          <source>Or, the implementation for the &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; can be done inline inside the class definition;</source>
          <target state="translated">또는 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 의 구현은 클래스 정의 내부에서 인라인으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d315959f3ea9b04eb57b630f050abbf870cc02" translate="yes" xml:space="preserve">
          <source>Other examples of mismatches include</source>
          <target state="translated">불일치의 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a535a2a245f2fac95298b5e9540153ebde66430" translate="yes" xml:space="preserve">
          <source>Parse all the object files and find the definition which was only declared in headers ( eg: The code of one method of a class as is mentioned in previous answers, or event the initialization of a static variable which is member inside a class)</source>
          <target state="translated">모든 객체 파일을 구문 분석하고 헤더에만 선언 된 정의를 찾으십시오 (예 : 이전 답변에서 언급 한 클래스의 한 메소드 코드 또는 클래스 내부의 멤버 인 정적 변수 초기화 이벤트)</target>
        </trans-unit>
        <trans-unit id="bd4adda29a59ab9ab7bbb53de56745feac90cde3" translate="yes" xml:space="preserve">
          <source>Pay attention to why the mangled names ended up different. You would be able to see that the parameter types are different, even though they look the same in the source code.</source>
          <target state="translated">맹 글링 된 이름이 다른 이유에주의하십시오. 매개 변수 유형이 소스 코드에서 동일하게 보이지만 매개 변수 유형이 다르다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4041537c412b8e8a70cd213105a7f6d55c1d8225" translate="yes" xml:space="preserve">
          <source>Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set
  (introducing new-line characters for end-of-line indicators) if
  necessary. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">실제 소스 파일 문자는 구현 정의 방식으로 필요한 경우 기본 소스 문자 세트 (행 끝 표시기의 줄 바꾸기 문자 소개)에 맵핑됩니다. &lt;em&gt;[한조각]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f7cb050a64d88fed430275cbf21ad78668fd798" translate="yes" xml:space="preserve">
          <source>Preprocessing directives are executed, macro invocations are expanded, and _Pragma unary operator expressions are executed. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">전처리 지시문이 실행되고 매크로 호출이 확장되며 _Pragma 단항 연산자식이 실행됩니다. &lt;em&gt;[한조각]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6587b16429748e00b4db35eea2d58d775e0d0e77" translate="yes" xml:space="preserve">
          <source>Problems with template friends</source>
          <target state="translated">템플릿 친구와 관련된 문제</target>
        </trans-unit>
        <trans-unit id="0721f2ff9d4e8f8c71dbe1300b4338d0f46d327a" translate="yes" xml:space="preserve">
          <source>Project Properties &amp;gt; General &amp;gt; Project Defaults &amp;gt; Character Set</source>
          <target state="translated">프로젝트 속성&amp;gt; 일반&amp;gt; 프로젝트 기본값&amp;gt; 문자 세트</target>
        </trans-unit>
        <trans-unit id="315cdbd0cc37f2f6eed7311d6a11376e81ab5846" translate="yes" xml:space="preserve">
          <source>Putting interdependent libraries in the wrong order is just one way
in which you can get files that &lt;em&gt;need&lt;/em&gt; definitions of things coming
later in the linkage than the files that &lt;em&gt;provide&lt;/em&gt; the definitions. Putting libraries before the 
object files that refer to them is another way of making the same mistake.</source>
          <target state="translated">상호 의존적 라이브러리를 잘못된 순서로 놓는 것은 정의를 &lt;em&gt;제공&lt;/em&gt; 하는 파일보다 나중에 링크에서 나중에 &lt;em&gt;필요한&lt;/em&gt; 것들에 &lt;em&gt;대한&lt;/em&gt; 정의가 &lt;em&gt;필요한&lt;/em&gt; 파일을 얻을 수있는 한 가지 방법 일뿐입니다. 라이브러리를 참조하는 오브젝트 파일 앞에 라이브러리를 두는 것도 같은 실수를하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="aa2e87051763ba52eba36f8604042df6dea47a55" translate="yes" xml:space="preserve">
          <source>Reason why they are different. In the example given above, they are different because of different include files.</source>
          <target state="translated">그들이 다른 이유. 위의 예에서 포함 파일이 다르기 때문에 서로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="516aae52959dcf5398a9985414a78b8c24a4f0e5" translate="yes" xml:space="preserve">
          <source>Resolution</source>
          <target state="translated">Resolution</target>
        </trans-unit>
        <trans-unit id="36eb62592e54385368d992e3bfc823feb8a2ecf1" translate="yes" xml:space="preserve">
          <source>Same if you compile and link in one go:</source>
          <target state="translated">한 번에 컴파일하고 링크하면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="57b44b45b209c07e2cf396779f22bd7450198c5e" translate="yes" xml:space="preserve">
          <source>Say you defined symbol &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;a.cpp&lt;/code&gt;. Now, &lt;code&gt;b.cpp&lt;/code&gt;&lt;em&gt;declared&lt;/em&gt; that symbol and used it. Before linking, it simply assumes that that symbol was defined &lt;em&gt;somewhere&lt;/em&gt;, but it doesn't yet care where. The linking phase is responsible for finding the symbol and correctly linking it to &lt;code&gt;b.cpp&lt;/code&gt; (well, actually to the object or library that uses it).</source>
          <target state="translated">&lt;code&gt;a.cpp&lt;/code&gt; 에 symbol &lt;code&gt;a&lt;/code&gt; 를 정의 했다고 가정 해보십시오 . 이제 &lt;code&gt;b.cpp&lt;/code&gt; &lt;em&gt;는&lt;/em&gt; 해당 기호를 &lt;em&gt;선언&lt;/em&gt; 하고 사용했습니다. 연결하기 전에 단순히 해당 기호가 &lt;em&gt;어딘가에&lt;/em&gt; 정의되었다고 가정하지만 아직 어디에도 신경 쓰지 않습니다. 연결 단계는 심볼을 찾아서 &lt;code&gt;b.cpp&lt;/code&gt; (실제로 심볼을 사용하는 객체 또는 라이브러리)에 올바르게 연결하는 역할 을합니다.</target>
        </trans-unit>
        <trans-unit id="d88c152a43cb27887978260a5c15f52ecc557b4e" translate="yes" xml:space="preserve">
          <source>Search for the exported symbol of interest, and notice that the mangled name is different.</source>
          <target state="translated">내 보낸 관심 기호를 검색하고 맹 글링 된 이름이 다른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f5e40313ea4a701259411817e6ec26f8b27269ef" translate="yes" xml:space="preserve">
          <source>Search paths used.</source>
          <target state="translated">사용 된 검색 경로.</target>
        </trans-unit>
        <trans-unit id="ef26caaa13a2223b4e5f1013e62b3dd0af211401" translate="yes" xml:space="preserve">
          <source>Second, &lt;strong&gt;example 2&lt;/strong&gt;, with shared library &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">공유 라이브러리 &lt;code&gt;libz&lt;/code&gt; 를 사용하는 두 번째 &lt;strong&gt;예 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="31a5c46ba7e3644d87e2c8692f9d7b577d4ff522" translate="yes" xml:space="preserve">
          <source>Similar mechanisms exist for other compilers/ platforms.</source>
          <target state="translated">다른 컴파일러 / 플랫폼에도 비슷한 메커니즘이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="ad1f924b7bbc2bcd7bd047b593952dcaf5c4a6a3" translate="yes" xml:space="preserve">
          <source>Similar remarks apply to functions. Declaring a function without defining it leads to the error:</source>
          <target state="translated">기능에도 유사한 설명이 적용됩니다. 함수를 정의하지 않고 선언하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="44febaad51a1168e7b5495233c9acbc83d1c9397" translate="yes" xml:space="preserve">
          <source>Similar to Windows-dlls, one would mark public functions with a define, for example &lt;code&gt;DLL_PUBLIC&lt;/code&gt; defined as:</source>
          <target state="translated">Windows-dll과 유사하게 다음과 같이 정의 된 &lt;code&gt;DLL_PUBLIC&lt;/code&gt; 과 같이 public 함수를 정의로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3791448e9c466323a781d1053225a28e2ed66066" translate="yes" xml:space="preserve">
          <source>Since it is not implemented, the linker fails to find it and results in the error.</source>
          <target state="translated">구현되지 않았기 때문에 링커에서이를 찾지 못하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b88c50d7c2684c92f808dc0bef70ada825c3a195" translate="yes" xml:space="preserve">
          <source>Since people seem to be directed to this question when it comes to linker errors I am going to add this here.</source>
          <target state="translated">링커 오류와 관련하여 사람들 이이 질문에 대한 것으로 보이므로 여기에 이것을 추가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5594c3defe9060176ac055ec30199b6a1925a1a0" translate="yes" xml:space="preserve">
          <source>So if you suddenly get linker errors when switching to a GCC after 5.1.0 this would be a thing to check out.</source>
          <target state="translated">따라서 5.1.0 이후에 GCC로 전환 할 때 갑자기 링커 오류가 발생하면이를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="7406dccb208de8f7859f688a7bf278cd1e4e822d" translate="yes" xml:space="preserve">
          <source>So the linkage fails just as it does if you &lt;em&gt;do&lt;/em&gt; run those two commands. The
only difference you notice in the failure is that gcc has generated a
temporary object file in the compile + link case, because you're not telling it
to use &lt;code&gt;eg1.o&lt;/code&gt;. We see:</source>
          <target state="translated">따라서 두 명령을 실행하는 것처럼 연결이 실패합니다. 실패에서 눈에 &lt;code&gt;eg1.o&lt;/code&gt; 를 사용하도록 지시 하지 않기 때문에 컴파일 + 링크 케이스에서 임시 객체 파일을 생성 했다는 것 입니다. 우리는보다:</target>
        </trans-unit>
        <trans-unit id="0c7380eb36ac254fde0c5e28aa7521e54819d717" translate="yes" xml:space="preserve">
          <source>So the linker does not add &lt;code&gt;my_lib.o&lt;/code&gt; to the program and has no further
use for &lt;code&gt;libmy_lib.a&lt;/code&gt;.</source>
          <target state="translated">따라서 링커는 프로그램에 &lt;code&gt;my_lib.o&lt;/code&gt; 를 추가하지 않으며 libmy_lib.a 를 더 이상 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="389ef339b38d14a89c45ee18d949e24cc58f1d20" translate="yes" xml:space="preserve">
          <source>So to repeat again, the order &lt;strong&gt;DOES&lt;/strong&gt; matter!</source>
          <target state="translated">다시 반복하려면 순서가 중요합니다!</target>
        </trans-unit>
        <trans-unit id="ba83702c0f21aecaaf05b65e1c413ecbfdf89e6e" translate="yes" xml:space="preserve">
          <source>So, as a result - an &quot;undefined reference/unresolved external symbol error&quot; happens when the linker cannot find global symbols in the object files.</source>
          <target state="translated">따라서 링커가 객체 파일에서 전역 심볼을 찾을 수없는 경우 &quot;정의되지 않은 참조 / 해결되지 않은 외부 심볼 오류&quot;가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="810e61562c0a90ab80a893ffeb7eb498e51ef3b8" translate="yes" xml:space="preserve">
          <source>So, we see follow symbols to export.</source>
          <target state="translated">따라서 내보낼 심볼을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="889eacaaf63948869a5ddecd71ff4abfdbeb0106" translate="yes" xml:space="preserve">
          <source>So, we've seen there is no label for local_var_name, that's why linker hasn't found it. But we are hackers :) and we can fix it. Open src1.s in your text editor and change</source>
          <target state="translated">따라서 local_var_name에 대한 레이블이 없다는 것을 알았으므로 링커에서 찾지 못했습니다. 그러나 우리는 해커입니다.) 고칠 수 있습니다. 텍스트 편집기에서 src1.s를 열고 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="ed306cf6c07bf565cfeaa2c226cbfd2a2acd58af" translate="yes" xml:space="preserve">
          <source>Some .so files are actually &lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-commands.html&quot;&gt;GNU ld linker scripts&lt;/a&gt;, e.g. &lt;a href=&quot;https://www.threadingbuildingblocks.org/download&quot;&gt;libtbb.so&lt;/a&gt; file is an ASCII text file with this contents:</source>
          <target state="translated">일부 .so 파일은 실제로 &lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-commands.html&quot;&gt;GNU ld 링커 스크립트입니다&lt;/a&gt; . 예를 들어 &lt;a href=&quot;https://www.threadingbuildingblocks.org/download&quot;&gt;libtbb.so&lt;/a&gt; 파일은 다음 내용이 포함 된 ASCII 텍스트 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2701d02120f341c911b427c678b1b3ba58ab869e" translate="yes" xml:space="preserve">
          <source>Some members need to be defined even if not used explicitly:</source>
          <target state="translated">명시 적으로 사용하지 않더라도 일부 멤버를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ce76ec1b7032c9c8bc5feb3b6ece87aff083f39" translate="yes" xml:space="preserve">
          <source>Some more complex builds may not support this. For example, if you include -v in the compiler options, you can see that the &lt;a href=&quot;http://www.mainsoft.com/content/mainsoft-unix-and-linux-overview&quot;&gt;mainwin gcc wrapper mwdip&lt;/a&gt; discards linker script command files in the verbose output list of libraries to link in. A simple work around is to replace the linker script input command file with a copy of the file instead (or a symlink), e.g.</source>
          <target state="translated">좀 더 복잡한 빌드는 이것을 지원하지 않을 수 있습니다. 예를 들어, 컴파일러 옵션에 -v를 포함하면 &lt;a href=&quot;http://www.mainsoft.com/content/mainsoft-unix-and-linux-overview&quot;&gt;mainwin gcc 래퍼 mwdip&lt;/a&gt; 가 링크 할 자세한 라이브러리 출력 목록에서 링커 스크립트 명령 파일을 삭제한다는 것을 알 수 있습니다. 간단한 해결 방법은 링커 스크립트 입력 명령을 바꾸는 것입니다. 대신 파일 사본이있는 파일 (또는 심볼릭 링크)</target>
        </trans-unit>
        <trans-unit id="8da255b627a43c5967c21bd733eeffe48c9f7d7b" translate="yes" xml:space="preserve">
          <source>Specialized templates can be implemented in an implementation file and the implementation doesn't have to be visible, but the specialization must be previously declared.</source>
          <target state="translated">전문화 된 템플릿은 구현 파일에서 구현할 수 있으며 구현을 볼 필요는 없지만 전문화는 이전에 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bbb6a7ee8142005a47ef622c25910f07c59d91f" translate="yes" xml:space="preserve">
          <source>Steps to try if you believe it could be a bug in compiler/IDE:</source>
          <target state="translated">컴파일러 / IDE에서 버그 일 수 있다고 생각되면 시도하는 단계 :</target>
        </trans-unit>
        <trans-unit id="fe05b5a0cc2b31aa92f2910350d4890d86e8795c" translate="yes" xml:space="preserve">
          <source>Success:</source>
          <target state="translated">Success:</target>
        </trans-unit>
        <trans-unit id="82ca7ce44cf63b62393dd7422ee20047ef95bcd5" translate="yes" xml:space="preserve">
          <source>Suppose you have a big project written in c++ which has a thousand of .cpp files and a thousand of .h files.And let's says the project also depends on ten static libraries. Let's says we are on Windows and we build our project in Visual Studio 20xx. When you press Ctrl + F7 Visual Studio to start compiling the whole solution ( suppose we have just one project in the solution )</source>
          <target state="translated">수천 개의 .cpp 파일과 수천 개의 .h 파일이있는 c ++로 작성된 큰 프로젝트가 있다고 가정하고이 프로젝트는 10 개의 정적 라이브러리에 의존한다고 가정 해 봅시다. 우리가 Windows에 있고 Visual Studio 20xx에서 프로젝트를 빌드한다고 가정 해 봅시다. Ctrl + F7 Visual Studio를 눌러 전체 솔루션 컴파일을 시작하면 (솔루션에 프로젝트가 하나만 있다고 가정하십시오)</target>
        </trans-unit>
        <trans-unit id="8380d950d527889dc4734ed54b11f16aca5a374d" translate="yes" xml:space="preserve">
          <source>Symbols were defined in a C program and used in C++ code.</source>
          <target state="translated">기호는 C 프로그램에서 정의되었으며 C ++ 코드에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="2a9939fe25550be4dea8b1c736d43f816c2c5f20" translate="yes" xml:space="preserve">
          <source>Template implementations not visible.</source>
          <target state="translated">템플릿 구현이 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ef7c2da6f851f23bbe511ebc36d3de16160e803" translate="yes" xml:space="preserve">
          <source>That's because the distro on which the linkage works is one of the ones that 
does not configure its GCC toolchain to link shared libraries &lt;em&gt;as-needed&lt;/em&gt;.</source>
          <target state="translated">연결이 작동하는 배포판 &lt;em&gt;이 필요에 따라&lt;/em&gt; 공유 라이브러리를 연결하도록 GCC 툴체인을 구성하지 않는 배포판 중 하나이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ddd5cfe744cba081a538a7341375f31cf8b1b45a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;libraryName&lt;/code&gt; here is just the bare name of the library, without platform-specific additions. So e.g. on Linux library files are usually called &lt;code&gt;libfoo.so&lt;/code&gt; but you'd only write &lt;code&gt;-lfoo&lt;/code&gt;. On Windows that same file might be called &lt;code&gt;foo.lib&lt;/code&gt;, but you'd use the same argument. You might have to add the directory where those files can be found using &lt;code&gt;-L&amp;lsaquo;directory&amp;rsaquo;&lt;/code&gt;. Make sure to not write a space after &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;-L&lt;/code&gt;.</source>
          <target state="translated">여기의 &lt;code&gt;libraryName&lt;/code&gt; 은 플랫폼 별 추가없이 라이브러리의 이름입니다. 따라서 예를 들어 Linux 라이브러리 파일은 일반적으로 &lt;code&gt;libfoo.so&lt;/code&gt; 이지만 &lt;code&gt;-lfoo&lt;/code&gt; 만 작성합니다. Windows에서는 동일한 파일 이름이 &lt;code&gt;foo.lib&lt;/code&gt; 일 수 있지만 동일한 인수를 사용합니다. &lt;code&gt;-L&amp;lsaquo;directory&amp;rsaquo;&lt;/code&gt; 를 사용하여 해당 파일을 찾을 수있는 디렉토리를 추가해야 할 수도 있습니다. &lt;code&gt;-l&lt;/code&gt; 또는 &lt;code&gt;-L&lt;/code&gt; 뒤에 공백을 쓰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bd483f1251beaf7236d9997165b1d451b6bd1e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is being declared as a non-template function. For every type &lt;code&gt;T&lt;/code&gt; used with &lt;code&gt;Foo&lt;/code&gt;, there needs to be a non-templated &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. For example, if there is a type &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; declared, then there must be an operator implementation as follows;</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 이 템플릿이 아닌 함수로 선언되었습니다. &lt;code&gt;Foo&lt;/code&gt; 와 함께 사용되는 모든 유형 &lt;code&gt;T&lt;/code&gt; 에 대해 템플릿 화되지 않은 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 가 있어야합니다. 예를 들어, &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; 유형이 선언 된 경우 다음과 같이 연산자 구현이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f74bbb502cac87efc036b9625dd07f7ba8c32eb8" translate="yes" xml:space="preserve">
          <source>The C++ linker expects names to be mangled, so you have to declare the function as:</source>
          <target state="translated">C ++ 링커는 이름이 엉망이 될 것으로 예상하므로 함수를 다음과 같이 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa46de6d6b4941229d8b28acdcc1f6c203f0c516" translate="yes" xml:space="preserve">
          <source>The MSDN page on the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wdsk6as6.aspx&quot;&gt;&lt;code&gt;/VERBOSE&lt;/code&gt; linker option&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wdsk6as6.aspx&quot;&gt; &lt;code&gt;/VERBOSE&lt;/code&gt; 링커 옵션&lt;/a&gt; 의 MSDN 페이지</target>
        </trans-unit>
        <trans-unit id="0a964c858e2f8e84f3cc4266073a14ab0c6127b2" translate="yes" xml:space="preserve">
          <source>The Second step of compilation is done by Linker.Linker should merge all the object file and build finally the output ( which may be an executable or a library)</source>
          <target state="translated">두 번째 컴파일 단계는 링커가 수행합니다. 링커는 모든 객체 파일을 병합하고 최종적으로 출력 (실행 파일 또는 라이브러리 일 수 있음)을 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2a9f1a0bcdd74e12869a5f78bd29d7084686e17" translate="yes" xml:space="preserve">
          <source>The above code limits the friendship of the operator to the corresponding instantiation of &lt;code&gt;Foo&lt;/code&gt;, i.e. the &lt;code&gt;operator&amp;lt;&amp;lt; &amp;lt;int&amp;gt;&lt;/code&gt; instantiation is limited to access the private members of the instantiation of &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">위의 코드는 연산자의 우정을 &lt;code&gt;Foo&lt;/code&gt; 의 해당 인스턴스화로 제한합니다. 즉 &lt;code&gt;operator&amp;lt;&amp;lt; &amp;lt;int&amp;gt;&lt;/code&gt; 인스턴스화는 &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; 인스턴스화의 개인 멤버에 액세스하도록 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="7cdbeecfba3fe1508804ada7c0e80ead504f0a5a" translate="yes" xml:space="preserve">
          <source>The alternative is applicable as well, if UNICODE is not intended to be used, make sure the defines are not set, and/or the multi-character setting is used in the projects and consistently applied.</source>
          <target state="translated">UNICODE를 사용하지 않을 경우, 정의가 설정되지 않았는지 및 / 또는 다중 문자 설정이 프로젝트에서 사용되고 일관되게 적용되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ab517e2a8ba12a27ab2bbd36c075257a2d62e599" translate="yes" xml:space="preserve">
          <source>The code:</source>
          <target state="translated">코드:</target>
        </trans-unit>
        <trans-unit id="96e15fc342a8a7b8e2a770b1887eaa0b6e5475ae" translate="yes" xml:space="preserve">
          <source>The correct solution is to hope the developer releases an updated package and then upgrade, but it worked for me by hacking in an extra setting for VS2013, pointing at the VS2012 library files.</source>
          <target state="translated">올바른 해결책은 개발자가 업데이트 된 패키지를 릴리스 한 다음 업그레이드하기를 희망하지만 VS2012 라이브러리 파일을 가리키는 VS2013의 추가 설정을 해킹하여 나에게 도움이되었습니다.</target>
        </trans-unit>
        <trans-unit id="39c6a6672a8c45fef828814fbc0a834a3d886d1e" translate="yes" xml:space="preserve">
          <source>The default behavior of gcc is that all symbols are visible. However, when the translation units are built with option &lt;code&gt;-fvisibility=hidden&lt;/code&gt;, only functions/symbols marked with &lt;code&gt;__attribute__ ((visibility (&quot;default&quot;)))&lt;/code&gt; are external in the resulting shared object.</source>
          <target state="translated">gcc의 기본 동작은 모든 기호가 표시되는 것입니다. 그러나 변환 단위가 &lt;code&gt;-fvisibility=hidden&lt;/code&gt; 옵션으로 빌드되면 &lt;code&gt;__attribute__ ((visibility (&quot;default&quot;)))&lt;/code&gt; 로 표시된 함수 / 기호 만 결과 공유 오브젝트에서 외부입니다.</target>
        </trans-unit>
        <trans-unit id="5d98ae42d70c1284a1b8e74bcfa80f5e6dc64e4b" translate="yes" xml:space="preserve">
          <source>The definition should be</source>
          <target state="translated">정의는</target>
        </trans-unit>
        <trans-unit id="fc35bde94bc482f0aba6406f3ef3e5fec63a5cd8" translate="yes" xml:space="preserve">
          <source>The different linkage rules for static and shared libraries can be confusing
to inexpert programmers, who may not know whether &lt;code&gt;-lfoo&lt;/code&gt; in their linkage
is going to resolve to &lt;code&gt;/some/where/libfoo.a&lt;/code&gt; or to &lt;code&gt;/some/where/libfoo.so&lt;/code&gt;,
and might not understand the difference between shared and static libraries
anyway.</source>
          <target state="translated">정적 라이브러리와 공유 라이브러리에 대한 서로 다른 연결 규칙은 전문가의 프로그래머에게 혼란 스러울 수 있습니다. 프로그래머는 링크의 &lt;code&gt;-lfoo&lt;/code&gt; 가 &lt;code&gt;/some/where/libfoo.a&lt;/code&gt; 또는 /some/where/libfoo.so 로 해석되는지 알지 못할 수 있습니다. 어쨌든 공유 라이브러리와 정적 라이브러리의 차이점을 이해하지 못할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaebebac9d959c2f58827c7b922c7bafe9507b45" translate="yes" xml:space="preserve">
          <source>The error message from the compiler will often give you the full declaration of the variable or function that was declared but never defined. Compare it closely to the definition you provided. &lt;em&gt;Make sure every detail matches.&lt;/em&gt;</source>
          <target state="translated">컴파일러의 오류 메시지는 종종 선언되었지만 정의되지 않은 변수 또는 함수의 전체 선언을 제공합니다. 제공 한 정의와 밀접하게 비교하십시오. &lt;em&gt;모든 세부 사항이 일치하는지 확인하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c2fa91316cfdea05c933e01c86ec8f328458b71" translate="yes" xml:space="preserve">
          <source>The error usually includes a function a value with a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt; derived type, these could include &lt;code&gt;std::basic_string&amp;lt;&amp;gt;&lt;/code&gt; etc. as well. When browsing through the affected function in the code, there will often be a reference to &lt;code&gt;TCHAR&lt;/code&gt; or &lt;code&gt;std::basic_string&amp;lt;TCHAR&amp;gt;&lt;/code&gt; etc. This is a tell-tale sign that the code was originally intended for both a UNICODE and a Multi-Byte Character (or &quot;narrow&quot;) build.</source>
          <target state="translated">오류에는 일반적으로 &lt;code&gt;char&lt;/code&gt; 또는 &lt;code&gt;wchar_t&lt;/code&gt; 파생 유형의 값이 포함되며 &lt;code&gt;std::basic_string&amp;lt;&amp;gt;&lt;/code&gt; 등이 포함될 수 있습니다. 코드에서 영향을받는 함수를 탐색 할 때 종종 &lt;code&gt;TCHAR&lt;/code&gt; 또는 &lt;code&gt;std::basic_string&amp;lt;TCHAR&amp;gt;&lt;/code&gt; 등에 대한 참조가있을 수 있습니다. 이는 코드가 원래 UNICODE 및 멀티 바이트 모두를위한 것임을 말하는 신호입니다. 캐릭터 (또는 &quot;좁은&quot;) 빌드.</target>
        </trans-unit>
        <trans-unit id="814895756bf4ca3a731ef6c9e3952b7d303ddbd4" translate="yes" xml:space="preserve">
          <source>The explanation</source>
          <target state="translated">설명</target>
        </trans-unit>
        <trans-unit id="2d47f92cdddee137d7131c686bea6ba95385c1dd" translate="yes" xml:space="preserve">
          <source>The following would yield the error:</source>
          <target state="translated">다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dc651a3eb6c90a022d94d96235e9502e73444d46" translate="yes" xml:space="preserve">
          <source>The function (or variable) &lt;code&gt;void foo()&lt;/code&gt; was defined in a C program and you attempt to use it in a C++ program:</source>
          <target state="translated">함수 (또는 변수) &lt;code&gt;void foo()&lt;/code&gt; 가 C 프로그램에서 정의되었으며 C ++ 프로그램에서 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a01682bab1ad942d84e12a4ac6e6ac22aa1e51e4" translate="yes" xml:space="preserve">
          <source>The implementation can be inline, in the class definition itself:</source>
          <target state="translated">클래스 정의 자체에서 구현이 인라인 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc532595d46d57575b847133085c91ba2256fee" translate="yes" xml:space="preserve">
          <source>The linkage:</source>
          <target state="translated">연계 :</target>
        </trans-unit>
        <trans-unit id="de5f587780a7f48b676bf47c006c00b98834b61e" translate="yes" xml:space="preserve">
          <source>The linker will decide that your program needs &lt;code&gt;my_lib.o&lt;/code&gt; if and only if it already knows that
your program refers to &lt;code&gt;hw&lt;/code&gt;, in one or more of the object files it has already
added to the program, and that none of the object files it has already added
contains a definition for &lt;code&gt;hw&lt;/code&gt;.</source>
          <target state="translated">링커는 프로그램이 이미 프로그램에 추가 된 하나 이상의 객체 파일에서 프로그램이 &lt;code&gt;hw&lt;/code&gt; 를 참조한다는 것을 이미 알고 있고 그 객체 파일이없는 경우에만 &lt;code&gt;my_lib.o&lt;/code&gt; 가 필요 하다고 결정합니다. 이미 추가 된 &lt;code&gt;hw&lt;/code&gt; 에 대한 정의가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a63e56d03967bc268b8093019d175c83dfcea0a" translate="yes" xml:space="preserve">
          <source>The location of the libraries,</source>
          <target state="translated">도서관의 위치</target>
        </trans-unit>
        <trans-unit id="11d6b7b1db5745c2043ea068ebb1b7afa5ed93de" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;THIS_MODULE&lt;/code&gt; would only be defined in the module that exports the function. That way, the declaration:</source>
          <target state="translated">매크로 &lt;code&gt;THIS_MODULE&lt;/code&gt; 은 함수를 내보내는 모듈에서만 정의됩니다. 그런 식으로 선언 :</target>
        </trans-unit>
        <trans-unit id="eb453bce3db2538452e63a26b6b80e65d71ce5e3" translate="yes" xml:space="preserve">
          <source>The order in which interdependent linked libraries are specified is wrong</source>
          <target state="translated">상호 의존적 인 링크 된 라이브러리가 지정된 순서가 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="89ab932707a61a0d0cca439734dbbccf264ff41a" translate="yes" xml:space="preserve">
          <source>The order in which interdependent linked libraries are specified is wrong.</source>
          <target state="translated">상호 의존적 인 링크 된 라이브러리가 지정된 순서가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="4687e29b604f518f389340188cf76ad7ba3cfeab" translate="yes" xml:space="preserve">
          <source>The order in which libraries are linked DOES matter if the libraries depend on each other. In general, if library &lt;code&gt;A&lt;/code&gt; depends on library &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;libA&lt;/code&gt;&lt;strong&gt;MUST&lt;/strong&gt; appear before &lt;code&gt;libB&lt;/code&gt; in the linker flags.</source>
          <target state="translated">라이브러리가 서로 의존하는 경우 라이브러리가 연결된 순서는 중요합니다. 일반적으로 라이브러리 &lt;code&gt;A&lt;/code&gt; 가 라이브러리 &lt;code&gt;B&lt;/code&gt; 에 의존하는 경우 &lt;code&gt;libB&lt;/code&gt; 는 링커 플래그에서 libB 앞에 &lt;strong&gt;있어야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c77074a1e65055c9b9d790d1eab74306e35ee769" translate="yes" xml:space="preserve">
          <source>The order of linking libraries &lt;strong&gt;does matter&lt;/strong&gt;.</source>
          <target state="translated">라이브러리 연결 순서 &lt;strong&gt;는 중요&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="dfadc843995bf96fc6b50f95dc126fbb8c9952b5" translate="yes" xml:space="preserve">
          <source>The precedence among the syntax rules of translation is specified by the following phases &lt;em&gt;[see footnote]&lt;/em&gt;.</source>
          <target state="translated">번역의 구문 규칙 중 우선 순위는 다음 단계에 따라 지정됩니다 &lt;em&gt;[각주 참조]&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="24af2bb789cacc1f5d7b2771021236eabff0f64c" translate="yes" xml:space="preserve">
          <source>The process goes like this:</source>
          <target state="translated">과정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9b8eb5b1acfcafd62389be8ee87a10159a198c2" translate="yes" xml:space="preserve">
          <source>The same result if you compile and link in one step, like:</source>
          <target state="translated">한 단계에서 컴파일하고 링크하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7ebe1560f137cc486a8b481f98db368bc20a5bb3" translate="yes" xml:space="preserve">
          <source>The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters (including comments). &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">소스 파일은 사전 처리 토큰 (2.5)과 일련의 공백 문자 (주석 포함)로 분해됩니다. &lt;em&gt;[한조각]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fe7b5fd3c97072d8d933ccaa526d54b2cbe6724" translate="yes" xml:space="preserve">
          <source>The specified errors occur during this last stage of compilation, most commonly referred to as linking. It basically means that you compiled a bunch of implementation files into object files or libraries and now you want to get them to work together.</source>
          <target state="translated">지정된 마지막 오류는 컴파일의 마지막 단계에서 발생하며 가장 일반적으로 연결이라고합니다. 기본적으로 많은 구현 파일을 객체 파일이나 라이브러리로 컴파일했으며 이제는 함께 작동하도록 만들고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="d25f8b67d426bc902107dbb9bd3d074093733c3c" translate="yes" xml:space="preserve">
          <source>There is further reading on template friends at &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend#Template_friends&quot;&gt;cppreference&lt;/a&gt; and the &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#template-friends&quot;&gt;C++ FAQ&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend#Template_friends&quot;&gt;cppreference&lt;/a&gt; 및 &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#template-friends&quot;&gt;C ++ FAQ&lt;/a&gt; 에서 템플릿 친구에 대한 추가 자료가 있습니다.</target>
        </trans-unit>
        <trans-unit id="51d2c1022c793ae6c997851c6c2911c491290dcf" translate="yes" xml:space="preserve">
          <source>There is only object file in &lt;code&gt;libmy_lib.a&lt;/code&gt;, namely &lt;code&gt;my_lib.o&lt;/code&gt;, and there's only one thing defined
in &lt;code&gt;my_lib.o&lt;/code&gt;, namely the function &lt;code&gt;hw&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;libmy_lib.a&lt;/code&gt; 에는 객체 파일, 즉 &lt;code&gt;my_lib.o&lt;/code&gt; 만 있으며 &lt;code&gt;my_lib.o&lt;/code&gt; 에는 함수 &lt;code&gt;hw&lt;/code&gt; 라는 단 하나만 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd7c821ca3bddaa894ed4036bbbcbeef36efee4a" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;process can be seen as a final resort, but is often a good first step&lt;/em&gt;; especially if the code related to the error has recently been added (either locally or from the source repository).</source>
          <target state="translated">이 &lt;em&gt;과정은 최종 수단으로 볼 수 있지만 종종 좋은 첫 단계입니다&lt;/em&gt; . 특히 오류와 관련된 코드가 최근에 추가 된 경우 (로컬 또는 소스 리포지토리에서).</target>
        </trans-unit>
        <trans-unit id="6ad971ec73e134596db3aa5d8e277e263d65c535" translate="yes" xml:space="preserve">
          <source>This behaviour is economical at linktime because the linker doesn't have to ponder
whether a shared library is needed by the program: if it's a shared library,
link it. And most libraries in most linkages are shared libraries. But there are disadvantages too:-</source>
          <target state="translated">링커는 프로그램에서 공유 라이브러리가 필요한지 여부를 고려할 필요가 없으므로 링크 타임에 경제적입니다. 공유 라이브러리 인 경우 링크하십시오. 그리고 대부분의 연계에서 대부분의 라이브러리는 공유 라이브러리입니다. 그러나 단점도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b891d63d48abebbaef68ad3645c7352c0b2f6c19" translate="yes" xml:space="preserve">
          <source>This can be done with either;</source>
          <target state="translated">이것은 어느 쪽이든 할 수 있습니다;</target>
        </trans-unit>
        <trans-unit id="49d63f2a1c780d571d49de8e11cd2c50aaeac867" translate="yes" xml:space="preserve">
          <source>This dual functionality is usually obtained through the use of a macro:</source>
          <target state="translated">이 이중 기능은 일반적으로 매크로를 사용하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="83d3af1836050ec99f7b707ceaa03f6ebb1c3de7" translate="yes" xml:space="preserve">
          <source>This happens because base class destructors are called when the object is destroyed implicitly, so a definition is required.</source>
          <target state="translated">오브젝트가 내재적으로 소멸 될 때 기본 클래스 소멸자가 호출되므로 정의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="24bcd3540cf7ff25e654495899de496726d609d7" translate="yes" xml:space="preserve">
          <source>This is one of most confusing error messages that every VC++ programmers have seen time and time again. Let&amp;rsquo;s make things clarity first.</source>
          <target state="translated">이것은 모든 VC ++ 프로그래머가 반복해서 본 가장 혼란스러운 오류 메시지 중 하나입니다. 먼저 명확성을 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="fc953ac37a3ffbcc5b71f7b47d29511fb9fc75f9" translate="yes" xml:space="preserve">
          <source>This is similar to non-&lt;code&gt;virtual&lt;/code&gt; methods with no definition, with the added reasoning that 
the pure declaration generates a dummy vtable and you might get the linker error without using the function:</source>
          <target state="translated">이것은 순수 선언이 더미 vtable을 생성하고 함수를 사용하지 않고 링커 오류가 발생할 수 있다는 추론을 추가로 정의하지 않은 비가 상 메소드와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="f40ecc90472f127aee96a0b27d92ae47b6f13c88" translate="yes" xml:space="preserve">
          <source>This means that when the linker finds &lt;code&gt;-lz&lt;/code&gt; in the linkage sequence, and figures out that this refers 
to the shared library (say) &lt;code&gt;/usr/lib/x86_64-linux-gnu/libz.so&lt;/code&gt;, it wants to know whether any references that it has added to your program that aren't yet defined have definitions that are exported by &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">이것은 링커가 연결 순서에서 &lt;code&gt;-lz&lt;/code&gt; 를 발견하고 공유 라이브러리 (예 : &lt;code&gt;/usr/lib/x86_64-linux-gnu/libz.so&lt;/code&gt; )를 참조한다는 것을 알면 아직 정의되지 않은 프로그램에 &lt;code&gt;libz&lt;/code&gt; 에서 내 보낸 정의가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7bd9513b51b299b1d7979bb703672c0c803ce8a" translate="yes" xml:space="preserve">
          <source>This searching process is called resolve.</source>
          <target state="translated">이 검색 프로세스를 resolve라고합니다.</target>
        </trans-unit>
        <trans-unit id="86854a6361abc1cef804c342988694879f4451d0" translate="yes" xml:space="preserve">
          <source>This trade-off has led to the schismatic situation today. Some distros have
changed their GCC linkage rules for shared libraries so that the &lt;em&gt;as-needed&lt;/em&gt;
principle applies for all libraries. Some distros have stuck with the old
way.</source>
          <target state="translated">이 절충안은 오늘날 제도적 상황을 초래했습니다. 일부 배포판에서는 &lt;em&gt;필요에 따라&lt;/em&gt; 원칙이 모든 라이브러리에 적용되도록 공유 라이브러리에 대한 GCC 연계 규칙을 변경했습니다. 일부 배포판은 옛날 방식으로 고착되었습니다.</target>
        </trans-unit>
        <trans-unit id="c6f9c244e10c8db8baeddb7b6f7b289439a89f58" translate="yes" xml:space="preserve">
          <source>This usually happens when two (or more) libraries have a cyclic dependency. Library A attempts to use symbols in B.lib and library B attempts to use symbols from A.lib. Neither exist to start off with. When you attempt to compile A, the link step will fail because it can't find B.lib. A.lib will be generated, but no dll. You then compile B, which will succeed and generate B.lib. Re-compiling A will now work because B.lib is now found.</source>
          <target state="translated">이는 일반적으로 두 개 이상의 라이브러리에 주기적 종속성이있는 경우 발생합니다. 라이브러리 A는 B.lib의 기호를 사용하려고 시도하고 라이브러리 B는 A.lib의 기호를 사용하려고 시도합니다. 둘 다 처음부터 존재하지 않습니다. A 컴파일을 시도하면 B.lib를 찾을 수 없으므로 링크 단계가 실패합니다. A.lib가 생성되지만 dll은 생성되지 않습니다. 그런 다음 B를 컴파일하면 B.lib가 생성됩니다. B.lib가 발견되었으므로 A를 다시 컴파일하면 이제 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dde9568d6caff7f7b573e0d0537eb77fffc36423" translate="yes" xml:space="preserve">
          <source>This way &lt;strong&gt;any function&lt;/strong&gt; contained in file.o and used in main.o that &lt;strong&gt;required &lt;code&gt;path_t&lt;/code&gt;&lt;/strong&gt; gave &quot;undefined reference&quot; errors because &lt;strong&gt;main.o&lt;/strong&gt; referred to &lt;strong&gt;&lt;code&gt;std::filesystem::path&lt;/code&gt;&lt;/strong&gt; but &lt;strong&gt;file.o&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;std::experimental::filesystem::path&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">이 방법으로 &lt;strong&gt;main.o&lt;/strong&gt; 가 &lt;strong&gt; &lt;code&gt;std::filesystem::path&lt;/code&gt; &lt;/strong&gt; 했지만 &lt;strong&gt;file.o&lt;/strong&gt; 를 &lt;strong&gt; &lt;code&gt;std::experimental::filesystem::path&lt;/code&gt; &lt;/strong&gt; 참조했기 때문에 &lt;strong&gt; &lt;code&gt;path_t&lt;/code&gt; &lt;/strong&gt; 가 &lt;strong&gt;필요 했던&lt;/strong&gt; main.o에 사용되고 &lt;strong&gt;path_t&lt;/strong&gt; 가 &lt;strong&gt;필요한&lt;/strong&gt; main.o에 사용 된 &lt;strong&gt;함수&lt;/strong&gt; 는 다음과 &lt;strong&gt;같습니다. : 경로&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a0d35af95e12b0dd0220a819e99aa16dadf25948" translate="yes" xml:space="preserve">
          <source>To correct this, build all the required libraries and projects with a consistent definition of &lt;code&gt;UNICODE&lt;/code&gt; (and &lt;code&gt;_UNICODE&lt;/code&gt;).</source>
          <target state="translated">이를 정정하려면 일관된 &lt;code&gt;UNICODE&lt;/code&gt; 정의 및 &lt;code&gt;_UNICODE&lt;/code&gt; 로 필요한 모든 라이브러리 및 프로젝트를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="a38dce23594f07d3de4b2b2cc2a5ab210dc62856" translate="yes" xml:space="preserve">
          <source>To correct this, you can declare a template operator before the &lt;code&gt;Foo&lt;/code&gt; type and then declare as a friend, the appropriate instantiation. The syntax is a little awkward, but is looks as follows;</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;code&gt;Foo&lt;/code&gt; 유형 전에 템플릿 연산자를 선언 한 다음 적절한 인스턴스화를 친구로 선언 할 수 있습니다. 구문은 약간 어색하지만 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b278d2255a2fb839042b27cedfdcde4b13d42e77" translate="yes" xml:space="preserve">
          <source>To find which symbols in an object file are hidden run:</source>
          <target state="translated">객체 파일에서 어떤 심볼이 숨겨져 있는지 확인하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f79e5cf712c1cebae4fd911b423526834fd1d23d" translate="yes" xml:space="preserve">
          <source>To fix this I just needed to &lt;strong&gt;change &amp;lt;experimental::filesystem&amp;gt; in file.h to &amp;lt;filesystem&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">이 문제를 해결하려면 &lt;strong&gt;file.h의 &amp;lt;experimental :: filesystem&amp;gt;을 &amp;lt;filesystem&amp;gt;&lt;/strong&gt; 으로 &lt;strong&gt;변경&lt;/strong&gt; 해야했습니다.</target>
        </trans-unit>
        <trans-unit id="2243663083f071145668f251171c65a090b9e5f2" translate="yes" xml:space="preserve">
          <source>To fix this, you must move the definition of &lt;code&gt;X::foo&lt;/code&gt; to the header file or some place visible to the translation unit that uses it.</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;X::foo&lt;/code&gt; 의 정의를 헤더 파일이나이를 사용하는 번역 단위에 보이는 위치로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac8e1b45e6bf97148cb8413c306ad6f5794875ec" translate="yes" xml:space="preserve">
          <source>To solve the issue, i built the MyProject as a LIB, and linked TestProject to this .lib file (i copy paste the generated .lib file into the TestProject folder). I can then build again MyProject as a DLL. It is compiling since the lib to which TestProject is linked does contain code for all methods in classes in MyProject.</source>
          <target state="translated">이 문제를 해결하기 위해 MyProject를 LIB로 빌드하고 TestProject를이 .lib 파일에 링크했습니다 (생성 된 .lib 파일을 TestProject 폴더에 복사하여 붙여 넣기). 그런 다음 MyProject를 DLL로 다시 빌드 할 수 있습니다. TestProject가 연결된 lib에 MyProject 클래스의 모든 메소드에 대한 코드가 포함되어 있으므로 컴파일 중입니다.</target>
        </trans-unit>
        <trans-unit id="1f2f0e08ff5b2e59a5a31d4b807b32101fba5f64" translate="yes" xml:space="preserve">
          <source>Translated translation units and instantiation units are combined as follows: &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">번역 된 번역 단위와 인스턴스화 단위는 다음과 같이 결합됩니다. &lt;em&gt;[SNIP]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7aef8e7498486de3cd6699dbe069fa0c309048a" translate="yes" xml:space="preserve">
          <source>Try start a new project,
copying all source code from the original one.</source>
          <target state="translated">원본 프로젝트의 모든 소스 코드를 복사하여 새 프로젝트를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="7715c2c8a7f85ca33fe93cc7817eac47532e5dc6" translate="yes" xml:space="preserve">
          <source>Try to link your program with &lt;code&gt;libz&lt;/code&gt; and fail:</source>
          <target state="translated">프로그램을 &lt;code&gt;libz&lt;/code&gt; 와 연결하고 실패하십시오.</target>
        </trans-unit>
        <trans-unit id="af5e2c5c3e6cb9cebd2829b0e884257cface4ba2" translate="yes" xml:space="preserve">
          <source>Under &lt;strong&gt;MSVS&lt;/strong&gt;, files added to a project automatically have their object files linked together and a &lt;code&gt;lib&lt;/code&gt; file would be generated (in common usage). To use the symbols in a separate project, you'd 
need to include the &lt;code&gt;lib&lt;/code&gt; files in the project settings. This is done in the Linker section of the project properties, in &lt;code&gt;Input -&amp;gt; Additional Dependencies&lt;/code&gt;. (the path to the &lt;code&gt;lib&lt;/code&gt; file should be
added in &lt;code&gt;Linker -&amp;gt; General -&amp;gt; Additional Library Directories&lt;/code&gt;) When using a third-party library that is provided with a &lt;code&gt;lib&lt;/code&gt; file, failure to do so usually results in the error.</source>
          <target state="translated">&lt;strong&gt;MSVS&lt;/strong&gt; 에서 프로젝트에 추가 된 파일은 자동으로 오브젝트 파일이 서로 링크되며 &lt;code&gt;lib&lt;/code&gt; 파일이 생성됩니다 (일반적인 용도로). 별도의 프로젝트에서 기호를 사용하려면 프로젝트 설정에 &lt;code&gt;lib&lt;/code&gt; 파일을 포함해야합니다. 이는 &lt;code&gt;Input -&amp;gt; Additional Dependencies&lt;/code&gt; 의 프로젝트 속성의 링커 섹션에서 수행됩니다. ( &lt;code&gt;lib&lt;/code&gt; 파일의 경로는 &lt;code&gt;Linker -&amp;gt; General -&amp;gt; Additional Library Directories&lt;/code&gt; 추가되어야합니다.) &lt;code&gt;lib&lt;/code&gt; 파일과 함께 제공되는 타사 라이브러리를 사용하는 경우 일반적으로 그렇게하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="09353e91d6dc1b681cb300414136507aacd9dc17" translate="yes" xml:space="preserve">
          <source>Under &lt;strong&gt;gcc&lt;/strong&gt; you would specify all object files that are to be linked together in the command line, or compile the implementation files together.</source>
          <target state="translated">&lt;strong&gt;gcc&lt;/strong&gt; 에서는 명령 행에서 함께 링크 될 모든 오브젝트 파일을 지정하거나 구현 파일을 함께 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="e8e07a144ac894fbd4a815eef8cb126c9d8444ca" translate="yes" xml:space="preserve">
          <source>Unspecialized templates must have their definitions visible to all translation units that use them. That means you can't separate the definition of a template
to an implementation file. If you must separate the implementation, the usual workaround is to have an &lt;code&gt;impl&lt;/code&gt; file which you include at the end of the header that
declares the template. A common situation is:</source>
          <target state="translated">특수화되지 않은 템플릿은 해당 정의를 사용하는 모든 번역 단위에서 정의를 볼 수 있어야합니다. 즉, 템플릿 정의를 구현 파일로 분리 할 수 ​​없습니다. 구현을 분리해야하는 경우 일반적인 해결 방법은 템플릿을 선언하는 헤더 끝에 포함하는 &lt;code&gt;impl&lt;/code&gt; 파일을 갖는 것입니다. 일반적인 상황은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="626a6bfb69f923133176d2288c20c9ad3e266875" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;#pragma once&lt;/code&gt; for allowing compiler not to include one header if it was already included in the current .cpp which are compiled</source>
          <target state="translated">컴파일러가 현재 .cpp에 이미 포함되어있는 경우 하나의 헤더를 포함하지 않도록 컴파일러에 &lt;code&gt;#pragma once&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="652d6febf33e65c27e03abc9bf57e88d8db07539" translate="yes" xml:space="preserve">
          <source>Use the linker to help diagnose the error</source>
          <target state="translated">링커를 사용하여 오류 진단</target>
        </trans-unit>
        <trans-unit id="3df12d1763a76db1eb5f9e0c7142ced823b24c14" translate="yes" xml:space="preserve">
          <source>Visual Studio search into file &lt;strong&gt;.vcxproj&lt;/strong&gt; and start compiling each file which has the extension .cpp. Order of compilation is undefined.So you must not assume that the file main.cpp is compiled first</source>
          <target state="translated">Visual Studio에서 파일 &lt;strong&gt;.vcxproj를&lt;/strong&gt; 검색하고 확장자가 .cpp 인 각 파일을 컴파일하기 시작합니다. 컴파일 순서는 정의되어 있지 않으므로 main.cpp 파일이 먼저 컴파일되었다고 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bc6493aa79682062f1e35506dac73e5d517d7fa9" translate="yes" xml:space="preserve">
          <source>What are undefined reference/unresolved external symbol errors? What are common causes and how to fix/prevent them?</source>
          <target state="translated">정의되지 않은 참조 / 해결되지 않은 외부 심볼 오류는 무엇입니까? 일반적인 원인은 무엇이고 어떻게 해결 / 방지합니까?</target>
        </trans-unit>
        <trans-unit id="db7e500851b237b0a75617adc43159c4e601d013" translate="yes" xml:space="preserve">
          <source>What are you doing wrong?</source>
          <target state="translated">무슨 일이야?</target>
        </trans-unit>
        <trans-unit id="2d7204271f918e6dc824c4de713ad791b4dc1110" translate="yes" xml:space="preserve">
          <source>What is an undefined reference/unresolved external symbol error and how do I fix it</source>
          <target state="translated">정의되지 않은 참조 / 해결되지 않은 외부 심볼 오류는 무엇이고 어떻게 해결합니까?</target>
        </trans-unit>
        <trans-unit id="4632922517e4c4150df04140a0a11bc46ff27b5a" translate="yes" xml:space="preserve">
          <source>When a translation unit is compiled with &lt;code&gt;-fvisibility=hidden&lt;/code&gt; the resulting symbols have still external linkage (shown with upper case symbol type by &lt;code&gt;nm&lt;/code&gt;) and can be used for external linkage without problem if the object files become part of a static libraries. The linkage becomes local only when the object files are linked into a shared library.</source>
          <target state="translated">변환 단위가 &lt;code&gt;-fvisibility=hidden&lt;/code&gt; 으로 컴파일 될 때 결과 기호는 여전히 외부 링크 ( &lt;code&gt;nm&lt;/code&gt; 로 대문자 기호 유형으로 표시됨)를 가지며 오브젝트 파일이 정적 라이브러리의 일부가되면 문제없이 외부 링크에 사용할 수 있습니다. 오브젝트 파일이 공유 라이브러리에 링크 된 경우에만 링크가 로컬이됩니다.</target>
        </trans-unit>
        <trans-unit id="2c08affaeeed528ac9c1fa3dfa4effce084687ac" translate="yes" xml:space="preserve">
          <source>When linking against shared libraries, make sure that the used symbols are not hidden.</source>
          <target state="translated">공유 라이브러리에 연결할 때 사용 된 기호가 숨겨져 있지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9ca2a7655109619c5715fb8ca7ccc73f3615a640" translate="yes" xml:space="preserve">
          <source>When you run the command above, &lt;code&gt;gcc&lt;/code&gt; figures out that you want compilation +
linkage. So behind the scenes, it generates a compilation command, and runs
it, then generates a linkage command, and runs it, as if &lt;em&gt;you&lt;/em&gt; had run the
two commands:</source>
          <target state="translated">위의 명령을 실행할 때 &lt;code&gt;gcc&lt;/code&gt; 는 컴파일 + 연결을 원한다는 것을 알아냅니다. 따라서 배후에서 컴파일 명령을 생성하고 실행 한 다음 연결 명령을 생성하고 마치 두 명령을 실행 한 것처럼 실행합니다.</target>
        </trans-unit>
        <trans-unit id="4567f3b27b39712303adc4658d2e89c9f3ed6ec0" translate="yes" xml:space="preserve">
          <source>When you try to link the program like:</source>
          <target state="translated">프로그램을 연결하려고 할 때 :</target>
        </trans-unit>
        <trans-unit id="b31400492742589d7742b79425b053a4e29f6f8f" translate="yes" xml:space="preserve">
          <source>When you use the template to make sure you include the definition of each template function in the header file for allowing the compiler to generate appropriate code for any instantiations.</source>
          <target state="translated">템플리트를 사용하여 컴파일러가 인스턴스화에 적합한 코드를 생성 할 수 있도록 헤더 파일에 각 템플리트 함수의 정의를 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="e4d80ad940bb876bd92a024b5ff663f048b0473e" translate="yes" xml:space="preserve">
          <source>When your include paths are different</source>
          <target state="translated">포함 경로가 다른 경우</target>
        </trans-unit>
        <trans-unit id="03365de1caa8827769bae8158a775de517156e6d" translate="yes" xml:space="preserve">
          <source>Which roughly corresponds to Windows'/MSVC-version:</source>
          <target state="translated">다음은 Windows / MSVC 버전에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="246959a741f4264372238420ebdad97bd89a88ec" translate="yes" xml:space="preserve">
          <source>White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The
  resulting tokens are syntactically and semantically analyzed and
  translated as a translation unit. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">토큰을 분리하는 공백 문자는 더 이상 중요하지 않습니다. 각 전처리 토큰은 토큰으로 변환됩니다. (2.7). 결과 토큰은 구문 및 의미 론적으로 분석되고 번역 단위로 번역됩니다. &lt;em&gt;[한조각]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3057b9b641cbee71aae82fe2b981cf8b49a7f80" translate="yes" xml:space="preserve">
          <source>Why do I still get this problem even if I compile-and-link at the same time?</source>
          <target state="translated">동시에 컴파일하고 링크해도이 문제가 계속 발생하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4c6dfe4286bb4038ff6570e5b46f04c49bbf7bf5" translate="yes" xml:space="preserve">
          <source>You are trying to compile and link your program with the GCC toolchain.</source>
          <target state="translated">프로그램을 컴파일하고 GCC 툴체인과 연결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="91c1836cb1d64ed1ad44ab634dca30d630520583" translate="yes" xml:space="preserve">
          <source>You build your static library:</source>
          <target state="translated">정적 라이브러리를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="2fd7e03d89627c87bdf0cf1f8eddb4e44c4ee89f" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;nm&lt;/code&gt; with the option &lt;code&gt;-C&lt;/code&gt; to demangle the names (if C++ was used).</source>
          <target state="translated">&lt;code&gt;nm&lt;/code&gt; 을 &lt;code&gt;-C&lt;/code&gt; 옵션과 함께 사용하여 이름을 엉 키게 할 수도 있습니다 (C ++가 사용 된 경우).</target>
        </trans-unit>
        <trans-unit id="eb4ed51d89a6db08d7aac2b244cdb0601cb7bc64" translate="yes" xml:space="preserve">
          <source>You can check whether the symbols your are looking for are external by invoking:</source>
          <target state="translated">다음 기호를 호출하여 찾고있는 심볼이 외부에 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e80a1a5e2677479f692a83c2c89c313fa9e2dc07" translate="yes" xml:space="preserve">
          <source>You can similary import/export classes:</source>
          <target state="translated">비슷한 가져 오기 / 내보내기 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3de844a4d66034d092d8886a7ce6acf2d81f628" translate="yes" xml:space="preserve">
          <source>You compile your program:</source>
          <target state="translated">프로그램을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="5f4c7708a6df0a34a544a31a0505e1654dab7e88" translate="yes" xml:space="preserve">
          <source>You may have missed to choose the right project type with your actual IDE. The IDE may want to bind e.g. Windows Application projects to such entry point function (as specified in the missing reference above), instead of the commonly used &lt;code&gt;int main(int argc, char** argv);&lt;/code&gt; signature.</source>
          <target state="translated">실제 IDE에 적합한 프로젝트 유형을 선택하지 못한 경우가 있습니다. IDE는 일반적으로 사용되는 &lt;code&gt;int main(int argc, char** argv);&lt;/code&gt; 대신 Windows Application 프로젝트를 이러한 진입 점 함수 (위의 누락 된 참조에 지정된대로)에 바인딩 할 수 있습니다 . 서명.</target>
        </trans-unit>
        <trans-unit id="9e82259a675941d9948a2eeb64a675ff5f0bac6e" translate="yes" xml:space="preserve">
          <source>You may see a message like:</source>
          <target state="translated">다음과 같은 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e60f4f947984fbf84f6c4fd28e3b1b296e997d0" translate="yes" xml:space="preserve">
          <source>You might ask how one ends up in a situation like that? &lt;strong&gt;Include paths&lt;/strong&gt; of course! If when compiling the shared library, the include path leads to &lt;code&gt;header1.h&lt;/code&gt; and you end up using &lt;code&gt;header2.h&lt;/code&gt; in your own program, you'll be left scratching your header wondering what happened (pun intended).</source>
          <target state="translated">그런 상황에서 어떻게 끝날지 물을 수 있습니까? 물론 &lt;strong&gt;경로&lt;/strong&gt; 를 &lt;strong&gt;포함하십시오&lt;/strong&gt; ! 공유 라이브러리를 컴파일 할 때 포함 경로가 &lt;code&gt;header1.h&lt;/code&gt; 로 연결되고 자신의 프로그램에서 &lt;code&gt;header2.h&lt;/code&gt; 를 사용하면 헤더가 긁 혀서 무슨 일이 일어 났는지 궁금해집니다.</target>
        </trans-unit>
        <trans-unit id="2d39d52ae6b215a68d9cf55a1d98a408fa72b8cc" translate="yes" xml:space="preserve">
          <source>You try to link it with &lt;code&gt;libmy_lib.a&lt;/code&gt; and fail:</source>
          <target state="translated">&lt;code&gt;libmy_lib.a&lt;/code&gt; 와 연결하려고하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ac3540a5f0b565ea8381987f3a836626c11a6c8e" translate="yes" xml:space="preserve">
          <source>Your linkage consumes libraries before the object files that refer to them</source>
          <target state="translated">링크는 라이브러리를 참조하는 오브젝트 파일보다 먼저 라이브러리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="374fcc2688ffa3e097d03ef0cda91f4abae3f9a6" translate="yes" xml:space="preserve">
          <source>Your linkage fails with &lt;code&gt;undefined reference to&lt;/code&gt;&lt;em&gt;something&lt;/em&gt; errors.</source>
          <target state="translated">&lt;code&gt;undefined reference to&lt;/code&gt; 오류로 인해 연결이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a97d5c4fcdbab0b3e334224158a61c8ab8cdf3b8" translate="yes" xml:space="preserve">
          <source>Your linkage specifies all of the necessary libraries and library search paths</source>
          <target state="translated">연계는 필요한 모든 라이브러리 및 라이브러리 검색 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1ede8f96ef941a4cd4a8b47db4fd4ec6dee457d7" translate="yes" xml:space="preserve">
          <source>Your program wants to refer to just one thing that has a definition exported by &lt;code&gt;libz&lt;/code&gt;,
namely the function &lt;code&gt;zlibVersion&lt;/code&gt;, which is referred to just once, in &lt;code&gt;eg2.c&lt;/code&gt;.
If the linker adds that reference to your program, and then finds the definition
exported by &lt;code&gt;libz&lt;/code&gt;, the reference is &lt;em&gt;resolved&lt;/em&gt;</source>
          <target state="translated">프로그램은 &lt;code&gt;libz&lt;/code&gt; 에 의해 익스포트 된 정의, 즉 &lt;code&gt;zlibVersion&lt;/code&gt; 함수를 가진 한 가지만을 참조하려고합니다. 예를 들어 eg2.c 에서 한 번만 참조됩니다. 링커가 해당 참조를 프로그램에 추가 한 다음 &lt;code&gt;libz&lt;/code&gt; 에서 내 보낸 정의를 찾으면 참조가 &lt;em&gt;해결됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6630645888101f4b1ebaafc85246e04a796c1112" translate="yes" xml:space="preserve">
          <source>[1] By project I mean a set of source files that are linked together to produce either a library or an executable.</source>
          <target state="translated">[1] 프로젝트 라 함은 라이브러리 또는 실행 파일을 생성하기 위해 서로 링크 된 소스 파일 세트를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="73825e2f27276ce7cc0cb99fe4926aefead625b6" translate="yes" xml:space="preserve">
          <source>and rebuild an object file</source>
          <target state="translated">객체 파일을 다시 작성</target>
        </trans-unit>
        <trans-unit id="3a85961b64655acfc507843ec1ba2838a9155bab" translate="yes" xml:space="preserve">
          <source>and run it</source>
          <target state="translated">그리고 그것을 실행</target>
        </trans-unit>
        <trans-unit id="6ab5682fa6ec7ce3b574c508f69fdd94179f902d" translate="yes" xml:space="preserve">
          <source>and similar errors with &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Microsoft Visual Studio의&lt;/strong&gt; 유사한 오류 :</target>
        </trans-unit>
        <trans-unit id="73d70fffc648342f33ca44795d6cc820d7069f22" translate="yes" xml:space="preserve">
          <source>and tells the compiler that the definition is in one of the libraries you linked against (also see &lt;strong&gt;1)&lt;/strong&gt;).</source>
          <target state="translated">컴파일러에 정의가 링크 한 라이브러리 중 하나에 있음을 컴파일러에 알려줍니다 ( &lt;strong&gt;1 참조&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="a885b4bb68e35a1301318ebf72bf542d958c8233" translate="yes" xml:space="preserve">
          <source>and tells the compiler to export the function, as the current module contains its definition. When including the declaration in a different module, it would expand to</source>
          <target state="translated">현재 모듈에 정의가 포함되어 있으므로 컴파일러에게 함수를 내보내도록 지시합니다. 다른 모듈에 선언을 포함하면 다음과 같이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="8081e608d396eb9fd48db5d9cb98df468f9b43c5" translate="yes" xml:space="preserve">
          <source>and you attempt to use it in a C++ program with C++ linkage.</source>
          <target state="translated">C ++ 연결을 사용하여 C ++ 프로그램에서 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c02ceb78ff4863ee1a75d232c4f53af56b182ec9" translate="yes" xml:space="preserve">
          <source>becomes:</source>
          <target state="translated">becomes:</target>
        </trans-unit>
        <trans-unit id="f799f07bf625ffbca0fe04fdd368917957d04df0" translate="yes" xml:space="preserve">
          <source>correct would be to use a header file and include it in file2.cpp &lt;em&gt;and&lt;/em&gt; file1.cpp</source>
          <target state="translated">헤더 파일을 사용하여 file2.cpp &lt;em&gt;및&lt;/em&gt; file1.cpp에 포함시키는 것이 올바른 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">~로 확장</target>
        </trans-unit>
        <trans-unit id="8597eabf07801651c88304087bf20f69ac103fa3" translate="yes" xml:space="preserve">
          <source>i.e. you should have like below</source>
          <target state="translated">즉, 당신은 아래에 있어야합니다</target>
        </trans-unit>
        <trans-unit id="6c8457cd65849bf5a9285f8b862e990e1a44ac09" translate="yes" xml:space="preserve">
          <source>instead of:</source>
          <target state="translated">대신에:</target>
        </trans-unit>
        <trans-unit id="4f0aa52d656a3d75867f784b7e9c5d23bf1321c0" translate="yes" xml:space="preserve">
          <source>link</source>
          <target state="translated">link</target>
        </trans-unit>
        <trans-unit id="293dce46f676980a9b1278e7251ff73eb7fa797d" translate="yes" xml:space="preserve">
          <source>note: i use g++ and Linux and all examples is for it</source>
          <target state="translated">참고 : 나는 g ++과 Linux를 사용하고 모든 예제는 그것입니다.</target>
        </trans-unit>
        <trans-unit id="36c55470c929c5d5f4d41ac78ab446fd5b77009b" translate="yes" xml:space="preserve">
          <source>now local_var_name has Bind GLOBAL (was LOCAL)</source>
          <target state="translated">이제 local_var_name이 GLOBAL을 바인드했습니다 (기존 LOCAL).</target>
        </trans-unit>
        <trans-unit id="fb74205393b3bb80203f54f7a8c9bcb830e8763e" translate="yes" xml:space="preserve">
          <source>ok, see readelf output (symbols)</source>
          <target state="translated">좋아, readelf 출력 참조 (기호)</target>
        </trans-unit>
        <trans-unit id="3a328af911638e5bfc90b4e0e69e9c25737cc9a5" translate="yes" xml:space="preserve">
          <source>ok, we hack it :)</source>
          <target state="translated">좋아, 우리는 그것을 해킹 :)</target>
        </trans-unit>
        <trans-unit id="2328aeacf83c4c55bc1147be999690bfc6241ad3" translate="yes" xml:space="preserve">
          <source>or outside:</source>
          <target state="translated">또는 외부 :</target>
        </trans-unit>
        <trans-unit id="ceeb2cffd5c7262a750a941ceb1e733b45fbb7ca" translate="yes" xml:space="preserve">
          <source>src2.cpp exports nothing and we have seen no its symbols</source>
          <target state="translated">src2.cpp는 아무것도 내 보내지 않으며 심볼을 보지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="2f0f1d7be52efe820ea8f283992862328386c64a" translate="yes" xml:space="preserve">
          <source>surely gcc has to compile &lt;code&gt;eg1.c&lt;/code&gt; first, and then link the resulting
object file with &lt;code&gt;libmy_lib.a&lt;/code&gt;.  So how can it not know that object file
is needed when it's doing the linking?</source>
          <target state="translated">반드시 gcc는 먼저 &lt;code&gt;eg1.c&lt;/code&gt; 를 컴파일 한 다음 결과 객체 파일을 &lt;code&gt;libmy_lib.a&lt;/code&gt; 와 연결 해야 합니다. 링크를 할 때 객체 파일이 필요한지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e01b8bf7137076c13f10eccf3ac7d89d9ac67196" translate="yes" xml:space="preserve">
          <source>the hidden/local symbols are shown by &lt;code&gt;nm&lt;/code&gt; with lowercase symbol type, for example &lt;code&gt;t&lt;/code&gt; instead of `T for code-section:</source>
          <target state="translated">숨겨진 / 로컬 심볼은 소문자 심볼 유형으로 &lt;code&gt;nm&lt;/code&gt; 로 표시됩니다 (예 : 코드 섹션의 경우`T 대신 &lt;code&gt;t&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="5e0942b4293aac626166820cf457118f4f66b257" translate="yes" xml:space="preserve">
          <source>the linker &lt;em&gt;has not added&lt;/em&gt;&lt;code&gt;eg1.o&lt;/code&gt;&lt;em&gt;to the program&lt;/em&gt; when it sees
&lt;code&gt;-lmy_lib&lt;/code&gt;. Because at that point, it has not seen &lt;code&gt;eg1.o&lt;/code&gt;.
Your program does not yet make any references to &lt;code&gt;hw&lt;/code&gt;: it
does not yet make any references &lt;em&gt;at all&lt;/em&gt;, because all the references it makes
are in &lt;code&gt;eg1.o&lt;/code&gt;.</source>
          <target state="translated">링커 &lt;em&gt;가&lt;/em&gt; &lt;code&gt;eg1.o&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 볼 때 eg1.o &lt;em&gt;를 프로그램에&lt;/em&gt; &lt;em&gt;추가하지 않았습니다&lt;/em&gt; . 그 시점에서 &lt;code&gt;eg1.o&lt;/code&gt; 를 보지 못했습니다 . 프로그램은 아직 &lt;code&gt;hw&lt;/code&gt; 를 참조하지 않습니다. 프로그램은 모든 참조가 &lt;code&gt;eg1.o&lt;/code&gt; 에 있기 때문에 아직 전혀 참조하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="474bf0c29b756b32c6ea11e2c24831191c57e8a2" translate="yes" xml:space="preserve">
          <source>the order of events is wrong in just the same way as with example 1.
At the point when the linker finds &lt;code&gt;-lz&lt;/code&gt;, there are &lt;em&gt;no&lt;/em&gt; references to anything
in the program: they are all in &lt;code&gt;eg2.o&lt;/code&gt;, which has not yet been seen. So the
linker decides it has no use for &lt;code&gt;libz&lt;/code&gt;. When it reaches &lt;code&gt;eg2.o&lt;/code&gt;, adds it to the program,
and then has undefined reference to &lt;code&gt;zlibVersion&lt;/code&gt;, the linkage sequence is finished;
that reference is unresolved, and the linkage fails.</source>
          <target state="translated">이벤트 순서는 예제 1과 같은 방식으로 잘못되었습니다. 링커가 &lt;code&gt;-lz&lt;/code&gt; 를 발견하는 시점에는 프로그램에 아무것도 참조 &lt;em&gt;되지 않습니다&lt;/em&gt; . 이들은 모두 &lt;code&gt;eg2.o&lt;/code&gt; 에 있으며 아직 보지 못했습니다. . 따라서 링커는 &lt;code&gt;libz&lt;/code&gt; 를 사용하지 않기로 결정합니다. &lt;code&gt;eg2.o&lt;/code&gt; 에 도달하여 프로그램에 추가 한 다음 &lt;code&gt;zlibVersion&lt;/code&gt; 에 대한 정의되지 않은 참조가 있으면 연결 순서가 완료됩니다. 해당 참조가 해결되지 않고 연결이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="7979c3fe74f25deb6892e5101b26610dc97c75eb" translate="yes" xml:space="preserve">
          <source>to declare function foo(), and call it in another function body, say &lt;code&gt;bar()&lt;/code&gt;:</source>
          <target state="translated">foo () 함수를 선언하고 다른 함수 본문에서 &lt;code&gt;bar()&lt;/code&gt; 라고 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ec79436cd4ee8fbface339724362fc515088bfd8" translate="yes" xml:space="preserve">
          <source>undefined reference to `WinMain@16'</source>
          <target state="translated">`WinMain @ 16 '에 대한 정의되지 않은 참조</target>
        </trans-unit>
        <trans-unit id="b888bea9cd6729fbf7ebdc759e10b2f2dacf405c" translate="yes" xml:space="preserve">
          <source>we have changed the visibility of local_var_name and set its value to 456789.
Try to build an object file from it</source>
          <target state="translated">local_var_name의 가시성을 변경하고 그 값을 456789로 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="a3bc4f467d60d6e7137cb42e5a2693f58a0ffef5" translate="yes" xml:space="preserve">
          <source>which is just example 2 again.</source>
          <target state="translated">다시 예제 2입니다.</target>
        </trans-unit>
        <trans-unit id="416857d2967c5146284d55951fb33a942176a9f1" translate="yes" xml:space="preserve">
          <source>will generate the following errors with &lt;strong&gt;GCC&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;GCC&lt;/strong&gt; 에서 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="767ebf562599ebd8219e0bce2533fd52b533baeb" translate="yes" xml:space="preserve">
          <source>works just fine for you!</source>
          <target state="translated">당신을 위해 잘 작동합니다!</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
