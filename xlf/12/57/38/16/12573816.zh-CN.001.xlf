<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/12573816">
    <body>
      <group id="12573816">
        <trans-unit id="c9cbc039ba0dda953e719495f032898e9956f254" translate="yes" xml:space="preserve">
          <source>&quot;An introduction to GCC&quot; &lt;a href=&quot;http://www.network-theory.co.uk/docs/gccintro/gccintro_75.html&quot;&gt;chapter 9&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo; GCC简介&amp;rdquo; &lt;a href=&quot;http://www.network-theory.co.uk/docs/gccintro/gccintro_75.html&quot;&gt;第9章&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d7d5b868297c7e069f79fb3331f33b5984b8682" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -c file.cpp&lt;/code&gt; -&amp;gt; compiles file.cpp and file.h to file.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -c file.cpp&lt;/code&gt; &amp;gt;将file.cpp和file.h编译为file.o</target>
        </trans-unit>
        <trans-unit id="e49790a3beb1dd7402b4cb606c79667d1433b0a4" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -c main.cpp&lt;/code&gt; -&amp;gt; compiles main.cpp to main.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -c main.cpp&lt;/code&gt; &amp;gt;将main.cpp编译为main.o</target>
        </trans-unit>
        <trans-unit id="071ec213b517c0a8d3f03b45c60bc9f9f0b55435" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -o executable main.o file.o -lstdc++fs&lt;/code&gt; -&amp;gt; links main.o and file.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -o executable main.o file.o -lstdc++fs&lt;/code&gt; fs-&amp;gt;链接main.o和file.o</target>
        </trans-unit>
        <trans-unit id="bad1abfbbc607215e826cba0225a7e15753aaefc" translate="yes" xml:space="preserve">
          <source>(Or: That linkage worked fine for you on, say, Fedora 23, but fails on Ubuntu 16.04)</source>
          <target state="translated">(或者说:你在Fedora 23上的联动工作很好,但在Ubuntu 16.04上却失败了)</target>
        </trans-unit>
        <trans-unit id="74c25a55039995250f6d3f12bb86f1ae278cee30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://coliru.stacked-crooked.com/a/e9221c4bb23f9cd0&quot;&gt;Code listing showing the techniques above&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://coliru.stacked-crooked.com/a/e9221c4bb23f9cd0&quot;&gt;代码清单显示了上述技术&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bf6077b839b27f134871fac7b06a0474aa39b4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; data members must be defined outside the class in a &lt;strong&gt;single translation unit&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 数据成员必须在类外部以&lt;strong&gt;单个翻译单元定义&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="89e5d36fe0239dd24cbe84c6df52545cb824576c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;virtual&lt;/code&gt; methods must either be implemented or defined as pure.</source>
          <target state="translated">&lt;code&gt;virtual&lt;/code&gt; 方法必须实现或定义为纯方法。</target>
        </trans-unit>
        <trans-unit id="a6e978f78787cb65ba3c48dd61a5ce9874bb1e0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;As a side note to the failing code sample; g++ warns about this as follows&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;附带说明失败的代码示例；&lt;/em&gt; &lt;em&gt;g ++警告如下&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcdf4af6901fd0be253767cc15e18070c0140d96" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;, when the declaration of the operator (or function) only appears in the class, the name is not available for &quot;normal&quot; lookup, only for argument dependent lookup, from &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend&quot;&gt;cppreference&lt;/a&gt;;</source>
          <target state="translated">&lt;em&gt;注意&lt;/em&gt; ，当运算符（或函数）的声明仅出现在类中时，该名称不可用于&amp;ldquo;常规&amp;rdquo;查找，仅可用于&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend&quot;&gt;cppreference中&lt;/a&gt;依赖于参数的查找。</target>
        </trans-unit>
        <trans-unit id="66ebd1f43ac511c6c708dab9f44756f21a71765e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Reading is optional from here on&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;从这里开始阅读是可选的&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="2438bd9596a6f2aad81a0222f2c18ffe262f7d81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[footnote]&lt;/em&gt; Implementations must behave as if these separate phases occur, although in practice different phases might be folded together.</source>
          <target state="translated">&lt;em&gt;[脚注]&lt;/em&gt;尽管实际上不同的阶段可能会折叠在一起，但实现的行为必须好像发生了这些单独的阶段。</target>
        </trans-unit>
        <trans-unit id="a534858af77623fa6f10f6aa3f2334132487ee64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A wrapper around GNU ld that doesn't support linker scripts&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不支持链接程序脚本的GNU ld包装器&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="835e534d0a03e685a5781ca6fe9811f767d58b55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A. What is symbol?&lt;/strong&gt;
In short, a symbol is a name. It can be a variable name, a function name, a class name, a typedef name, or anything except those names and signs that belong to C++ language. It is user defined or introduced by a dependency library (another user-defined).</source>
          <target state="translated">&lt;strong&gt;答：什么是符号？&lt;/strong&gt; 简而言之，符号就是名称。 它可以是变量名称，函数名称，类名称，typedef名称或除属于C ++语言的那些名称和符号以外的任何名称。 它是由用户定义或由依赖项库引入的（另一个用户定义的）。</target>
        </trans-unit>
        <trans-unit id="eec66c59c1dbab98e498c91f5e97e7ff8ab7101f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All external entity references are resolved. Library components are linked to satisfy external references to entities not defined in the
  current translation. All such translator output is collected into a
  program image which contains information needed for execution in its
  execution environment.&lt;/strong&gt; (emphasis mine)</source>
          <target state="translated">&lt;strong&gt;所有外部实体引用均已解决。&lt;/strong&gt; &lt;strong&gt;库组件被链接以满足对当前翻译中未定义的实体的外部引用。&lt;/strong&gt; &lt;strong&gt;所有此类转换器输出都收集到一个程序映像中，该映像包含在其执行环境中执行所需的信息。&lt;/strong&gt; （强调我的）</target>
        </trans-unit>
        <trans-unit id="dd8db3de81c77ec485d11b2559fd63ff6023c436" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B. What is external?&lt;/strong&gt;
In VC++, every source file (.cpp,.c,etc.) is considered as a translation unit, the compiler compiles one unit at a time, and generate one object file(.obj) for the current translation unit. (Note that every header file that this source file included will be preprocessed and will be considered as part of this translation unit)Everything within a translation unit is considered as internal, everything else is considered as external. In C++, you may reference an external symbol by using keywords like &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;__declspec (dllimport)&lt;/code&gt; and so on.</source>
          <target state="translated">&lt;strong&gt;B.什么是外部？&lt;/strong&gt; 在VC ++中，每个源文件（.cpp，.c等）都被视为翻译单元，编译器一次编译一个单元，并为当前翻译单元生成一个目标文件（.obj）。 （请注意，此源文件中包含的每个头文件都将被预处理，并将被视为此翻译单元的一部分。）翻译单元中的所有内容均被视为内部文件，其他所有内容均被视为外部文件。 在C ++中，您可以使用诸如 &lt;code&gt;extern&lt;/code&gt; ， &lt;code&gt;__declspec (dllimport)&lt;/code&gt; 等关键字来引用外部符号。</target>
        </trans-unit>
        <trans-unit id="6c2ca1047c2ef8497e41c914c53f8e7ca55ee476" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C. What is &amp;ldquo;resolve&amp;rdquo;?&lt;/strong&gt;
Resolve is a linking-time term. In linking-time, linker attempts to find the external definition for every symbol in object files that cannot find its definition internally. The scope of this searching process including:</source>
          <target state="translated">&lt;strong&gt;C.什么是&amp;ldquo;解决&amp;rdquo;？&lt;/strong&gt; 解决是一个链接时间项。 在链接时，链接器尝试为无法在内部找到其定义的目标文件中的每个符号查找外部定义。 此搜索过程的范围包括：</target>
        </trans-unit>
        <trans-unit id="7342049e2513cd5b99e201cfcb5bf3b14417789e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;D. Finally, why Unresolved External Symbol?&lt;/strong&gt;
If the linker cannot find the external definition for a symbol that has no definition internally, it reports an Unresolved External Symbol error.</source>
          <target state="translated">&lt;strong&gt;D.最后，为什么未解析的外部符号？&lt;/strong&gt; 如果链接器找不到内部没有定义的符号的外部定义，它将报告&amp;ldquo;未解析的外部符号&amp;rdquo;错误。</target>
        </trans-unit>
        <trans-unit id="5b8a47f4b41b91b3d612aacb048ed208fcac6f16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Different architectures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不同的架构&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be965b14abe7432b5fa433657763c3dc46c94955" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E. Possible causes of LNK2019&lt;/strong&gt;: Unresolved External Symbol error.
We already know that this error is due to the linker failed to find the definition of external symbols, the possible causes can be sorted as:</source>
          <target state="translated">&lt;strong&gt;E.LNK2019的可能原因&lt;/strong&gt; ：未解决的外部符号错误。 我们已经知道此错误是由于链接器未能找到外部符号的定义，可能的原因可以归类为：</target>
        </trans-unit>
        <trans-unit id="175dc84044f833f83a2c70ee5958f34ffa3867f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How To Solve this kind of error&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如何解决这种错误&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50f9819832db0d81b1174260f918040cd2cf7d74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If all else fails, recompile.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果其他所有方法均失败，请重新编译。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cffd218845fdac972017077668b21dcb30366645" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Linked .lib file is associated to a .dll&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;链接的.lib文件与.dll关联&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06b83ed7c66d61ec7db41c3a6e7b02f8577e43ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Observation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8940eb48005ed796b60ad830078b12d07df43be6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Steps In Linking a project&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;链接项目的步骤&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75d4f8b2fa373cf046a6b677d6c35770b0294edb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Visual Studio NuGet package needs to be updated for new toolset version&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;需要为新的工具集版本更新Visual Studio NuGet程序包&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb0c9feeb4bacc0fa3c37312d7a301912ecd4847" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What's the meaning of compilation ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;编译的含义是什么？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1465fad7785625be27309d79cd0e820fa06d98f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eg1.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;eg1.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89c440cfe498cb89e3725891dfd833439ac8312d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eg2.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;eg2.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff073c269c56360873674533870cbf8bfa429227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;file.cpp&lt;/strong&gt;, the implementation of file.h, #include's &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot;</source>
          <target state="translated">&lt;strong&gt;file.cpp&lt;/strong&gt; ， &lt;strong&gt;file.h&lt;/strong&gt;的实现，#include的&amp;ldquo; &lt;strong&gt;file.h&lt;/strong&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="f9ae04f6c866dcf587fa6e1e0dae001a09d7888a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;file.h&lt;/strong&gt; #include's &amp;lt;&lt;strong&gt;experimental::filesystem&lt;/strong&gt;&amp;gt; and contains the code above</source>
          <target state="translated">&lt;strong&gt;file.h #include&lt;/strong&gt;的&amp;lt; &lt;strong&gt;实验性::文件系统&lt;/strong&gt; &amp;gt;并包含上面的代码</target>
        </trans-unit>
        <trans-unit id="fddf0c10ac5731cb589a87bb2c2094c4fa147fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main.cpp&lt;/strong&gt; #include's &amp;lt;&lt;strong&gt;filesystem&lt;/strong&gt;&amp;gt; and &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot;</source>
          <target state="translated">&lt;strong&gt;main.cpp&lt;/strong&gt; &lt;strong&gt;#include&lt;/strong&gt;的&amp;lt; &lt;strong&gt;文件系统&lt;/strong&gt; &amp;gt;和&amp;ldquo; &lt;strong&gt;file.h&lt;/strong&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="2582c85be2b20f3244cd0cd3e45025f73c92ed51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;my_lib.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;my_lib.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c230963946da5a9ed838b6a5933de9f154d5ef91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;my_lib.h&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;my_lib.h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2662021565cbcee02085174aa21cc7ecdb484907" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined reference to &lt;code&gt;WinMain@16&lt;/code&gt; or similar &lt;em&gt;'unusual'&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; entry point reference&lt;/strong&gt; (especially for &lt;a href=&quot;/questions/tagged/visual-studio&quot;&gt;visual-studio&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;对 &lt;code&gt;WinMain@16&lt;/code&gt; 未定义引用或类似的&lt;em&gt;&amp;ldquo;不寻常&amp;rdquo;&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; 入口点引用&lt;/strong&gt; （尤其是&lt;a href=&quot;/questions/tagged/visual-studio&quot;&gt;visual-studio&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0acfceb277492d3fa70c2011c817d088faf04611" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;what is an &quot;undefined reference/unresolved external symbol&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么是&amp;ldquo;未定义的引用/未解析的外部符号&amp;rdquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3c395f4232d75cdbc21861202f537c9ca9121e5" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Feel free to edit/add your own.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;随意编辑/添加自己的。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d2d1d37fdef4865427a49fbf3bf6a77bd38bb6d1" translate="yes" xml:space="preserve">
          <source>A &quot;clean&quot; of the build can remove the &quot;dead wood&quot; that may be left lying around from previous builds, failed builds, incomplete builds and other build system related build issues.</source>
          <target state="translated">对构建进行 &quot;清理&quot;,可以清除之前的构建、失败的构建、不完整的构建以及其他与构建系统相关的构建问题可能留下的 &quot;枯木&quot;。</target>
        </trans-unit>
        <trans-unit id="189f79f5d1a5faa4467603ef162262cccf65ca78" translate="yes" xml:space="preserve">
          <source>A Windows UNICODE build is built with &lt;code&gt;TCHAR&lt;/code&gt; etc. being defined as &lt;code&gt;wchar_t&lt;/code&gt; etc. When not building with &lt;code&gt;UNICODE&lt;/code&gt; defined as build with &lt;code&gt;TCHAR&lt;/code&gt; defined as &lt;code&gt;char&lt;/code&gt; etc. These &lt;code&gt;UNICODE&lt;/code&gt; and &lt;code&gt;_UNICODE&lt;/code&gt; defines affect all the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx&quot;&gt;&quot;&lt;code&gt;T&lt;/code&gt;&quot; string types&lt;/a&gt;; &lt;code&gt;LPTSTR&lt;/code&gt;, &lt;code&gt;LPCTSTR&lt;/code&gt; and their elk.</source>
          <target state="translated">Windows UNICODE构建是用 &lt;code&gt;TCHAR&lt;/code&gt; 等构建的，定义为 &lt;code&gt;wchar_t&lt;/code&gt; 等。当未使用 &lt;code&gt;UNICODE&lt;/code&gt; 定义为 &lt;code&gt;TCHAR&lt;/code&gt; 定义为 &lt;code&gt;char&lt;/code&gt; 等的构建时。这些 &lt;code&gt;UNICODE&lt;/code&gt; 和 &lt;code&gt;_UNICODE&lt;/code&gt; 定义会影响所有&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx&quot;&gt;&amp;ldquo; &lt;code&gt;T&lt;/code&gt; &amp;rdquo;字符串类型&lt;/a&gt; ； &lt;code&gt;LPTSTR&lt;/code&gt; ， &lt;code&gt;LPCTSTR&lt;/code&gt; 及其麋鹿。</target>
        </trans-unit>
        <trans-unit id="90afd285297eb44d41e1f5773ca5cb874cbb19b4" translate="yes" xml:space="preserve">
          <source>A bug in the compiler/IDE</source>
          <target state="translated">编译器IDE中的一个错误</target>
        </trans-unit>
        <trans-unit id="a31d75bc9dfc18e7b2009004254a487c7ca05013" translate="yes" xml:space="preserve">
          <source>A common mistake is forgetting to qualify the name:</source>
          <target state="translated">一个常见的错误是忘记了对名字进行限定。</target>
        </trans-unit>
        <trans-unit id="1f739d01292aa73c37e4aee39f036a3bb2a527ee" translate="yes" xml:space="preserve">
          <source>A minimal example involving a shared system library, the compression library &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">一个涉及共享系统库的最小示例，压缩库 &lt;code&gt;libz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01c92916b56793a9454d489c312fa9257acc6107" translate="yes" xml:space="preserve">
          <source>A minimal example involving a static library you built yourself</source>
          <target state="translated">一个最简单的例子,涉及到你自己建立的静态库。</target>
        </trans-unit>
        <trans-unit id="6d46bde77adddeb0b72386689fff3e28dd372bb9" translate="yes" xml:space="preserve">
          <source>A name first declared in a friend declaration within class or class template X becomes a member of the innermost enclosing namespace of X, but is not accessible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at the namespace scope is provided...</source>
          <target state="translated">首先在类或类模板X中的友方声明中声明的名字会成为X的最内层包围式命名空间的成员,但除非在命名空间范围内提供了匹配的声明,否则无法进行查找(除非在命名空间范围内提供了匹配的声明,否则依赖参数的查找方式除外).....</target>
        </trans-unit>
        <trans-unit id="5a03aa49c3c082188ccefd12449a2783226a9d4f" translate="yes" xml:space="preserve">
          <source>A pure &lt;code&gt;virtual&lt;/code&gt; destructor needs an implementation.</source>
          <target state="translated">纯 &lt;code&gt;virtual&lt;/code&gt; 析构函数需要实现。</target>
        </trans-unit>
        <trans-unit id="ec2d47bd5e6c687188cca18e11b6e3a11fd20b4b" translate="yes" xml:space="preserve">
          <source>A shared library isn't an archive of object files or anything like it. It's
much more like a &lt;em&gt;program&lt;/em&gt; that doesn't have a &lt;code&gt;main&lt;/code&gt; function and
instead exposes multiple other symbols that it defines, so that other
programs can use them at runtime.</source>
          <target state="translated">共享库不是目标文件或类似文件的存档。 它更像是一个没有 &lt;code&gt;main&lt;/code&gt; 功能的&lt;em&gt;程序&lt;/em&gt; ，而是公开了它定义的多个其他符号，以便其他程序可以在运行时使用它们。</target>
        </trans-unit>
        <trans-unit id="4f62d04e30be88d7be65eb3c4d8daefedf696027" translate="yes" xml:space="preserve">
          <source>A static library is an indexed archive of object files. When the linker
finds &lt;code&gt;-lmy_lib&lt;/code&gt; in the linkage sequence and figures out that this refers
to the static library &lt;code&gt;./libmy_lib.a&lt;/code&gt;, it wants to know whether your program
needs any of the object files in &lt;code&gt;libmy_lib.a&lt;/code&gt;.</source>
          <target state="translated">静态库是目标文件的索引存档。 当链接器在链接序列中找到 &lt;code&gt;-lmy_lib&lt;/code&gt; 并指出这是指向静态库 &lt;code&gt;./libmy_lib.a&lt;/code&gt; 时 ，它想知道您的程序是否需要 &lt;code&gt;libmy_lib.a&lt;/code&gt; 中的任何目标文件。</target>
        </trans-unit>
        <trans-unit id="8b191d246d34f1e602a3e402976e900a1a875073" translate="yes" xml:space="preserve">
          <source>A typical variable declaration is</source>
          <target state="translated">一个典型的变量声明是</target>
        </trans-unit>
        <trans-unit id="82e2e65a5074a60696904cace45937b63edf3d64" translate="yes" xml:space="preserve">
          <source>Adjacent string literal tokens are concatenated.</source>
          <target state="translated">相邻的字符串字形令牌被串联起来。</target>
        </trans-unit>
        <trans-unit id="7fe45da2f4efcc86cb9b6567ee7a4ad6bf699b1f" translate="yes" xml:space="preserve">
          <source>After the assembler phase we have an object file, which contains any symbols to export. 
Look at the symbols</source>
          <target state="translated">在装配器阶段之后,我们有了一个对象文件,其中包含任何要导出的符号。看一下这些符号</target>
        </trans-unit>
        <trans-unit id="dbf5b9e02583394489628b8d6f4b8f7252c2835c" translate="yes" xml:space="preserve">
          <source>All libraries (.lib) that are either explicitly or implicitly
specified as additional dependencies of this building application.</source>
          <target state="translated">所有被显式或隐式指定为该构建应用程序的附加依赖的库(.lib)。</target>
        </trans-unit>
        <trans-unit id="f594bd06c1caa0ead7f44aab9131622ae2e6ba7e" translate="yes" xml:space="preserve">
          <source>All object files that generated in compiling time</source>
          <target state="translated">在编译时生成的所有对象文件</target>
        </trans-unit>
        <trans-unit id="4091f76b2539a23ecb3681b7960816da46fc1f49" translate="yes" xml:space="preserve">
          <source>All used member methods need to be defined if used.</source>
          <target state="translated">如果使用过的成员方法,需要对所有使用过的成员方法进行定义。</target>
        </trans-unit>
        <trans-unit id="258953ce5c44b3d94df6a62bf16b94620782ab0b" translate="yes" xml:space="preserve">
          <source>Allowing the friendship to extend to all instantiations of the templates, as follows;</source>
          <target state="translated">允许友谊扩展到模板的所有实例,具体如下:</target>
        </trans-unit>
        <trans-unit id="c827bc9706235eb6e58b62b8ed3b65b6653a561a" translate="yes" xml:space="preserve">
          <source>Also if you're using 3rd party libraries make sure you have the correct 32/64 bit binaries</source>
          <target state="translated">如果你使用的是第三方库,请确保你有正确的3264位的二进制文件。</target>
        </trans-unit>
        <trans-unit id="fcf665a8f73833aa185cc196d74ef511cdd50687" translate="yes" xml:space="preserve">
          <source>Alternatively one could declare the &lt;code&gt;const&lt;/code&gt; variable in file1.cpp with explicit &lt;code&gt;extern&lt;/code&gt;</source>
          <target state="translated">或者，可以使用显式 &lt;code&gt;extern&lt;/code&gt; 在file1.cpp中声明 &lt;code&gt;const&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="6faa1efbd9a22a841dece261aa541458bc6561d1" translate="yes" xml:space="preserve">
          <source>Alternatives include;</source>
          <target state="translated">替代品包括:</target>
        </trans-unit>
        <trans-unit id="9142d2a0c57278cbac1656ede2c51ad79022c5e8" translate="yes" xml:space="preserve">
          <source>An example of how this can happen in the real world is explained below.</source>
          <target state="translated">以下是一个现实世界中如何发生这种情况的例子。</target>
        </trans-unit>
        <trans-unit id="0978b0da32a1d538f6533aded9b037a5a632b0e0" translate="yes" xml:space="preserve">
          <source>An initializer can be provided for a &lt;code&gt;static&lt;/code&gt;&lt;code&gt;const&lt;/code&gt; data member of integral or enumeration type within the class definition; however, odr-use of this member will still require a namespace scope definition as described above. C++11 allows initialization inside the class for all &lt;code&gt;static const&lt;/code&gt; data members.</source>
          <target state="translated">可以在类定义中为整数或枚举类型的 &lt;code&gt;static&lt;/code&gt; &lt;code&gt;const&lt;/code&gt; 数据成员提供初始化程序。 但是，对该成员的odr-use仍然需要如上所述的名称空间范围定义。 C ++ 11允许在类内部对所有 &lt;code&gt;static const&lt;/code&gt; 数据成员进行初始化。</target>
        </trans-unit>
        <trans-unit id="fe337499c7cf1304af8bc4b955a047cc2736dc7c" translate="yes" xml:space="preserve">
          <source>And a variation on example 2 involving &lt;code&gt;pkg-config&lt;/code&gt;:</source>
          <target state="translated">以及涉及 &lt;code&gt;pkg-config&lt;/code&gt; 的示例2的变体：</target>
        </trans-unit>
        <trans-unit id="d551606414a99e264853eca34fd51b96854e0ecd" translate="yes" xml:space="preserve">
          <source>And then you go ahead and include the library in your own project.</source>
          <target state="translated">然后你再去把图书馆纳入自己的项目中。</target>
        </trans-unit>
        <trans-unit id="b2245e86d8c2a2258df1e19537be1050df1ac011" translate="yes" xml:space="preserve">
          <source>As this is only a declaration, a &lt;strong&gt;single definition&lt;/strong&gt; is needed. A corresponding definition would be:</source>
          <target state="translated">由于这只是一个声明，因此需要一个&lt;strong&gt;定义&lt;/strong&gt; 。 相应的定义为：</target>
        </trans-unit>
        <trans-unit id="b13d9a436d6efc6b48e4a9a36b25cc2355a5e4fc" translate="yes" xml:space="preserve">
          <source>At runtime, the system program loader will load a copy of &lt;code&gt;libz&lt;/code&gt; into the
same process as your program whenever it loads a copy of your program, to run it.</source>
          <target state="translated">在运行时，系统程序加载器将在每次加载程序副本时将 &lt;code&gt;libz&lt;/code&gt; 副本加载到与您的程序相同的进程中，以运行它。</target>
        </trans-unit>
        <trans-unit id="e5bb89d8a1b39ec5a184b94a75ab271ed2ff9d91" translate="yes" xml:space="preserve">
          <source>At runtime, whenever your program refers to something that is defined in
&lt;code&gt;libz&lt;/code&gt;, that reference uses the definition exported by the copy of &lt;code&gt;libz&lt;/code&gt; in
the same process.</source>
          <target state="translated">在运行时，只要您的程序引用 &lt;code&gt;libz&lt;/code&gt; 中定义的内容，该引用就使用 &lt;code&gt;libz&lt;/code&gt; 副本在同一进程中导出的定义。</target>
        </trans-unit>
        <trans-unit id="8706fc513753f8a6ab494b836c139f955dd4de4b" translate="yes" xml:space="preserve">
          <source>Back in the day, it was normal for unix-like systems to link static and shared 
libraries by different rules. Static libraries in a linkage sequence were linked 
on the &lt;em&gt;as-needed&lt;/em&gt; basis explained in example 1, but shared libraries were linked unconditionally.</source>
          <target state="translated">过去，类Unix系统通过不同的规则链接静态库和共享库是很正常的。 链接序列中的静态库按示例1中所述&lt;em&gt;按需&lt;/em&gt;链接，但共享库则无条件链接。</target>
        </trans-unit>
        <trans-unit id="4a50aaa9dbdd42f72fdba6a8715e83c2a0a34f3f" translate="yes" xml:space="preserve">
          <source>Be careful that the function you implement exactly matches the one you declared. For example, you may have mismatched cv-qualifiers:</source>
          <target state="translated">注意你所实现的函数是否与你声明的函数完全匹配。例如,你可能有不匹配的cv-qualifiers。</target>
        </trans-unit>
        <trans-unit id="380e27586685053a149a95794ec8ea13cd72b1ae" translate="yes" xml:space="preserve">
          <source>Because compiling and linking with a single command does not change the
order of the linkage sequence.</source>
          <target state="translated">因为用一条命令进行编译和链接,并不会改变链接顺序。</target>
        </trans-unit>
        <trans-unit id="791862e9f3cc350adeb09357b5234c80bae1d2ca" translate="yes" xml:space="preserve">
          <source>Befriending templates...</source>
          <target state="translated">结交模板.....</target>
        </trans-unit>
        <trans-unit id="0cadc8aa8215fefdf5f07d0ddc606c6dc435a0e8" translate="yes" xml:space="preserve">
          <source>Boom! You get a linker error and you have no idea why it's failing. The reason is that the common library uses different versions of the same include &lt;code&gt;common_math.h&lt;/code&gt; (I have made it obvious here in the example by including a different path, but it might not always be so obvious. Maybe the include path is different in the compiler settings).</source>
          <target state="translated">繁荣！ 您会收到一个链接器错误，并且不知道为什么它会失败。 原因是公共库使用相同版本的include include &lt;code&gt;common_math.h&lt;/code&gt; 的不同版本（我在示例中通过包含不同的路径使其很明显，但可能并不总是那么明显。也许include路径在编译器设置）。</target>
        </trans-unit>
        <trans-unit id="6bcaff46ce13c984e730553cee278ae1c9aa1951" translate="yes" xml:space="preserve">
          <source>Building one library with &lt;code&gt;UNICODE&lt;/code&gt; defined and attempting to link it in a project where &lt;code&gt;UNICODE&lt;/code&gt; is not defined will result in linker errors since there will be a mismatch in the definition of &lt;code&gt;TCHAR&lt;/code&gt;; &lt;code&gt;char&lt;/code&gt; vs. &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">构建一个定义了 &lt;code&gt;UNICODE&lt;/code&gt; 的库并尝试在未定义 &lt;code&gt;UNICODE&lt;/code&gt; 的项目中链接它会导致链接器错误，因为 &lt;code&gt;TCHAR&lt;/code&gt; 的定义不匹配； &lt;code&gt;char&lt;/code&gt; vs. &lt;code&gt;wchar_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f699eafa666c4c4782584970203254bd4526ddb" translate="yes" xml:space="preserve">
          <source>But all the undefined &lt;em&gt;something&lt;/em&gt;s are declared in the header files you have
&lt;code&gt;#include&lt;/code&gt;d and are in fact defined in the libraries that you are linking.</source>
          <target state="translated">但是所有未定义的&lt;em&gt;东西&lt;/em&gt;都在您具有 &lt;code&gt;#include&lt;/code&gt; d的头文件中声明，并且实际上在要链接的库中定义。</target>
        </trans-unit>
        <trans-unit id="04aa72c8afa3b9d7e1037f71bfc89ece6d7cb2d0" translate="yes" xml:space="preserve">
          <source>But when you try to link the program like:</source>
          <target state="translated">但是,当你尝试链接程序时,如。</target>
        </trans-unit>
        <trans-unit id="e3bc3b59b5238ebf3734cce36298c84c3eecbc4c" translate="yes" xml:space="preserve">
          <source>By default, a linkage command generated by GCC, on your distro,
consumes the files in the linkage from left to right in
commandline sequence. When it finds that a file refers to &lt;em&gt;something&lt;/em&gt;
and does not contain a definition for it, to will search for a definition
in files further to the right. If it eventually finds a definition, the
reference is resolved. If any references remain unresolved at the end,
the linkage fails: the linker does not search backwards.</source>
          <target state="translated">默认情况下，GCC在您的发行版上生成的链接命令会按命令行顺序从左到右使用链接中的文件。 当发现文件引用了&lt;em&gt;某个东西&lt;/em&gt;并且不包含该文件的定义时，它将在右边的文件中搜索一个定义。 如果最终找到定义，则引用将被解析。 如果最后没有解决任何引用，则链接失败：链接器不会向后搜索。</target>
        </trans-unit>
        <trans-unit id="3eaf522e8926f987e615fe35f7fd9fdf75b655f7" translate="yes" xml:space="preserve">
          <source>Circular library dependency</source>
          <target state="translated">循环图书馆的依赖性</target>
        </trans-unit>
        <trans-unit id="7241f66efa6b5c24d3508077d13fb171cabcc233" translate="yes" xml:space="preserve">
          <source>Class members:</source>
          <target state="translated">班级成员。</target>
        </trans-unit>
        <trans-unit id="aab52d092675fa0fe32cd101b3b21eff5dd78e87" translate="yes" xml:space="preserve">
          <source>Clean and rebuild</source>
          <target state="translated">清洁和重建</target>
        </trans-unit>
        <trans-unit id="736a421be03fcda0d1784f7e1b58d5c6120e87ca" translate="yes" xml:space="preserve">
          <source>Clean the project (some IDEs have an option to do this, you can also
manually do it by deleting the object files)</source>
          <target state="translated">清理项目(有些IDE有一个选项,你也可以通过删除对象文件的方式手动清理项目</target>
        </trans-unit>
        <trans-unit id="3da20e0c7008360402f61cc375be71c5a21c62fe" translate="yes" xml:space="preserve">
          <source>Common causes include:</source>
          <target state="translated">常见的原因包括:</target>
        </trans-unit>
        <trans-unit id="1d20937e648b620d3e08501c7d2a0f7ca4d36b1e" translate="yes" xml:space="preserve">
          <source>Common error messages are &lt;code&gt;error LNK2001&lt;/code&gt;, &lt;code&gt;error LNK1120&lt;/code&gt;, &lt;code&gt;error LNK2019&lt;/code&gt; for &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt; and &lt;code&gt;undefined reference to&lt;/code&gt;&lt;em&gt;symbolName&lt;/em&gt; for &lt;strong&gt;GCC&lt;/strong&gt;.</source>
          <target state="translated">常见错误消息是&lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt; &lt;code&gt;error LNK2001&lt;/code&gt; ， &lt;code&gt;error LNK1120&lt;/code&gt; ， &lt;code&gt;error LNK2019&lt;/code&gt; 和&lt;strong&gt;GCC的&lt;/strong&gt; &lt;code&gt;undefined reference to&lt;/code&gt; &lt;em&gt;symbolName的&lt;/em&gt; 引用 。</target>
        </trans-unit>
        <trans-unit id="c3af93c7541eebebfdafcdd1eacb37d4febb317b" translate="yes" xml:space="preserve">
          <source>Common issues with class-type members</source>
          <target state="translated">班级类型成员的常见问题</target>
        </trans-unit>
        <trans-unit id="7ad8095ab9f470817988dae41ebaff6c8b167424" translate="yes" xml:space="preserve">
          <source>Commonly, each translation unit will generate an object file that contains the definitions of the symbols defined in that translation unit. 
To use those symbols, you have to link against those object files.</source>
          <target state="translated">通常,每个翻译单元都会生成一个对象文件,其中包含该翻译单元中定义的符号的定义。要使用这些符号,你必须与这些对象文件进行链接。</target>
        </trans-unit>
        <trans-unit id="e08db17708c9f5aa2791cb6be1dcc8a1c79a541b" translate="yes" xml:space="preserve">
          <source>Compile your program:</source>
          <target state="translated">编译你的程序。</target>
        </trans-unit>
        <trans-unit id="db2b08b37977716ce6fab5afd8fb8ea79479ade1" translate="yes" xml:space="preserve">
          <source>Compile:</source>
          <target state="translated">Compile:</target>
        </trans-unit>
        <trans-unit id="679b3ff1ac1d63bde340799dcca67fa30e040c64" translate="yes" xml:space="preserve">
          <source>Compiler Time Error :</source>
          <target state="translated">编译器时间错误。</target>
        </trans-unit>
        <trans-unit id="c97768ea4c3948ab173981d2a5209cf05f227f68" translate="yes" xml:space="preserve">
          <source>Compiling a C++ program takes place in several steps, as specified by &lt;strong&gt;2.2&lt;/strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/8834196&quot;&gt;(credits to Keith Thompson for the reference)&lt;/a&gt;:</source>
          <target state="translated">编译C ++程序分&lt;strong&gt;2.2&lt;/strong&gt;步&lt;a href=&quot;https://stackoverflow.com/a/8834196&quot;&gt;（请参考Keith Thompson供参考）&lt;/a&gt;指定，分几个步骤进行 ：</target>
        </trans-unit>
        <trans-unit id="c137971fb4bd72b08a0b43c3008b2cca54a397e2" translate="yes" xml:space="preserve">
          <source>Create the libraries:</source>
          <target state="translated">创建库。</target>
        </trans-unit>
        <trans-unit id="7eaf2baed01488559bf5876cc3e60f17aa0d3628" translate="yes" xml:space="preserve">
          <source>DUMPBIN is your friend, if you are using Visual Studio. I'm sure other compilers have other similar tools.</source>
          <target state="translated">DUMPBIN是你的朋友,如果你使用的是Visual Studio。我相信其他编译器也有类似的工具。</target>
        </trans-unit>
        <trans-unit id="719eb91a47aa71cdb65cf6c453c5e6fe62c3c90d" translate="yes" xml:space="preserve">
          <source>Data on what libraries are included in the link stage,</source>
          <target state="translated">链接阶段包括哪些图书馆的数据。</target>
        </trans-unit>
        <trans-unit id="6773b3ac6ff9506cd52f19d8964c02fa4b90c9ba" translate="yes" xml:space="preserve">
          <source>Debugging the linker</source>
          <target state="translated">调试链接器</target>
        </trans-unit>
        <trans-unit id="849dcbe64c263df85f9b32a99f2eccecff6c214f" translate="yes" xml:space="preserve">
          <source>Declared and undefined variable or function.</source>
          <target state="translated">已声明和未定义的变量或函数。</target>
        </trans-unit>
        <trans-unit id="06460cd515ea02640e903aed7e4d4bb81068a27c" translate="yes" xml:space="preserve">
          <source>Declared but did not define a variable or function.</source>
          <target state="translated">已宣布,但没有定义一个变量或函数。</target>
        </trans-unit>
        <trans-unit id="b75a543cd5362fb62c8422904fb2c049dcec7474" translate="yes" xml:space="preserve">
          <source>Declaring a destructor pure still requires you to define it (unlike a regular function):</source>
          <target state="translated">声明一个纯粹的解构器仍然需要你定义它(与正则函数不同)。</target>
        </trans-unit>
        <trans-unit id="567a15d424904d304f2d20a37eae9e3dd0be401d" translate="yes" xml:space="preserve">
          <source>Define all your symbol which you declare in your header files</source>
          <target state="translated">定义你在头文件中声明的所有符号。</target>
        </trans-unit>
        <trans-unit id="f5fce9ce350b9263578dfa2c8ab33e5e4582b42f" translate="yes" xml:space="preserve">
          <source>Definition does not exist</source>
          <target state="translated">定义不存在</target>
        </trans-unit>
        <trans-unit id="1023459cba9e87450771da5a88dadcad9181c40b" translate="yes" xml:space="preserve">
          <source>Definition exists</source>
          <target state="translated">存在的定义</target>
        </trans-unit>
        <trans-unit id="1f545375f3315c66c74f5b0635778013cb0153c5" translate="yes" xml:space="preserve">
          <source>Different versions of libraries</source>
          <target state="translated">图书馆的不同版本</target>
        </trans-unit>
        <trans-unit id="0bee44622c3c31248d76530e7b83a53af7e4ae63" translate="yes" xml:space="preserve">
          <source>Do not forget to be consistent between the &quot;Release&quot; and &quot;Debug&quot; builds as well.</source>
          <target state="translated">不要忘记在 &quot;发布 &quot;和 &quot;调试 &quot;构建之间也要保持一致。</target>
        </trans-unit>
        <trans-unit id="62a321049a9684009d639a42bfcab348659b0468" translate="yes" xml:space="preserve">
          <source>Dump the exported symbols from the library into a text file.</source>
          <target state="translated">将库中导出的符号转入文本文件。</target>
        </trans-unit>
        <trans-unit id="6ee565a8ad9a2e6032a63ac1db58b7bceef88bc8" translate="yes" xml:space="preserve">
          <source>EDIT 1: Rewrote first section to be easier to understand. Please comment below to let me know if something else needs to be fixed. Thanks!</source>
          <target state="translated">编辑1:重写了第一节,以便于理解。如果还有什么需要修改的地方,请在下面评论,让我知道。谢谢!</target>
        </trans-unit>
        <trans-unit id="80d3f81150da8848a606c766ad627406abc917e5" translate="yes" xml:space="preserve">
          <source>Each instance of a backslash character (\) immediately followed by a new-line character is deleted, splicing physical source lines to
  form logical source lines. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">立即删除紧跟换行符的反斜杠字符（\）的每个实例，将物理源代码行拼接以形成逻辑源代码行。 &lt;em&gt;[SNIP]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8873c9e0ad822c5ad29c877287ca38e9d0fb8223" translate="yes" xml:space="preserve">
          <source>Each source character set member in a character literal or a string literal, as well as each escape sequence and universal-character-name
  in a character literal or a non-raw string literal, is converted to
  the corresponding member of the execution character set; &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">字符文字或字符串文字中的每个源字符集成员，以及字符文字或非原始字符串文字中的每个转义序列和通用字符名称都将转换为执行字符集的相应成员； &lt;em&gt;[SNIP]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd08fa75ce4c1bea641e5c3ae90f422742fd49a5" translate="yes" xml:space="preserve">
          <source>Equivalently, instead of being defined in a C program, the function (or variable) &lt;code&gt;void foo()&lt;/code&gt; was defined in C++ but with C linkage:</source>
          <target state="translated">同样，不是在C程序中定义，而是在C ++中使用C链接定义了函数（或变量） &lt;code&gt;void foo()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="50e31b9308416dd3a4f92b2300aa9833c975e02b" translate="yes" xml:space="preserve">
          <source>Even though this is a pretty old questions with multiple accepted answers, I'd like to share how to resolve an &lt;strong&gt;obscure&lt;/strong&gt; &quot;undefined reference to&quot; error.</source>
          <target state="translated">即使这是一个很老的问题，但有多个可接受的答案，我还是想分享如何解决一个&lt;strong&gt;模糊的&lt;/strong&gt; &amp;ldquo;未定义的引用&amp;rdquo;错误。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="0f313c64cf7c57de167dfc0b70285d2f1097cf2a" translate="yes" xml:space="preserve">
          <source>Examples are in C. They could equally well be C++</source>
          <target state="translated">例子是C语言的,同样也可以是C++。</target>
        </trans-unit>
        <trans-unit id="6c8eeaf8a4d91827c91eda47c067002b02303f4f" translate="yes" xml:space="preserve">
          <source>Failure to link against appropriate libraries/object files or compile implementation files</source>
          <target state="translated">未能链接到适当的库对象文件或编译实现文件,或编译实现文件。</target>
        </trans-unit>
        <trans-unit id="c24bada60625ab3c77ffebca4ef956b5b8222f43" translate="yes" xml:space="preserve">
          <source>First, &lt;strong&gt;example 1&lt;/strong&gt;, with static library &lt;code&gt;my_lib.a&lt;/code&gt;</source>
          <target state="translated">首先， &lt;strong&gt;示例1&lt;/strong&gt; ，带有静态库 &lt;code&gt;my_lib.a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c8a30a094da8c776a823c101decae831165f64e" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;XCode&lt;/strong&gt;:  Add the User Header Search Paths -&amp;gt; add the Library Search Path -&amp;gt; drag and drop the actual library reference into the project folder.</source>
          <target state="translated">对于&lt;strong&gt;XCode&lt;/strong&gt; ：添加用户标题搜索路径-&amp;gt;添加库搜索路径-&amp;gt;将实际库引用拖放到项目文件夹中。</target>
        </trans-unit>
        <trans-unit id="ba1b34dc3bbed11c2c9a66d05612d54f9428db05" translate="yes" xml:space="preserve">
          <source>For MSVC, &lt;code&gt;/VERBOSE&lt;/code&gt; (in particular &lt;code&gt;/VERBOSE:LIB&lt;/code&gt;) is added to the link command line.</source>
          <target state="translated">对于MSVC，将 &lt;code&gt;/VERBOSE&lt;/code&gt; （特别是 &lt;code&gt;/VERBOSE:LIB&lt;/code&gt; ）添加到链接命令行。</target>
        </trans-unit>
        <trans-unit id="0ac9cca66a7ce03b39143760b921f502a3b2b9ee" translate="yes" xml:space="preserve">
          <source>For each file with extension .cpp is generated an object file .o and also Visual Studio writes the output in a file named &lt;em&gt;ProjectName.Cpp.Clean.txt&lt;/em&gt; which contains all object files that must be processed by the linker.</source>
          <target state="translated">对于每个扩展名为.cpp的文件，将生成一个目标文件.o，Visual Studio还将输出写入名为&lt;em&gt;ProjectName.Cpp.Clean.txt&lt;/em&gt;的文件中，该文件包含链接器必须处理的所有目标文件。</target>
        </trans-unit>
        <trans-unit id="ce276678b262778ed8f87dcee2e92b419fef8499" translate="yes" xml:space="preserve">
          <source>For example we have some code</source>
          <target state="translated">例如,我们有一些代码</target>
        </trans-unit>
        <trans-unit id="2fa6951fcb69e2353b69b4e4f3615ca4d9cc266b" translate="yes" xml:space="preserve">
          <source>For example, if we have a function called foo defined in a.cpp:</source>
          <target state="translated">例如,如果我们在a.cpp中定义了一个名为foo的函数。</target>
        </trans-unit>
        <trans-unit id="5c105ae3962497b6a56958a1bf2d2d4a31d03dae" translate="yes" xml:space="preserve">
          <source>For example, the following would generate an error:</source>
          <target state="translated">比如说,下面会产生一个错误。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="f2fcc968e71dd0b01c575698c3cd328beb1f8547" translate="yes" xml:space="preserve">
          <source>For further explanation and another possible solution (explicit instantiation) see &lt;a href=&quot;https://stackoverflow.com/questions/495021&quot;&gt;this question and answer&lt;/a&gt;.</source>
          <target state="translated">有关进一步的说明和其他可能的解决方案（显式实例化），请参阅&lt;a href=&quot;https://stackoverflow.com/questions/495021&quot;&gt;此问题和答案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d26f3d31b9f80c9041094ecd1bfa2cf4a14f452" translate="yes" xml:space="preserve">
          <source>For gcc and clang; you would typically add &lt;code&gt;-v -Wl,--verbose&lt;/code&gt; or &lt;code&gt;-v -Wl,-v&lt;/code&gt; to the command line. More details can be found here;</source>
          <target state="translated">对于gcc和clang； 您通常会在命令行中添加 &lt;code&gt;-v -Wl,--verbose&lt;/code&gt; 或 &lt;code&gt;-v -Wl,-v&lt;/code&gt; 。 更多详情可在这找到;</target>
        </trans-unit>
        <trans-unit id="44635ad90325eff295e74bdeb91fbd8d078fabb1" translate="yes" xml:space="preserve">
          <source>For people coming from C it might be a surprise that in C++ global &lt;code&gt;const&lt;/code&gt;variables have internal (or static) linkage. In C this was not the case, as all global variables are implicitly &lt;code&gt;extern&lt;/code&gt; (i.e. when the &lt;code&gt;static&lt;/code&gt; keyword is missing).</source>
          <target state="translated">对于使用C语言的人来说，在C ++中，全局 &lt;code&gt;const&lt;/code&gt; 变量具有内部（或静态）链接可能会令人惊讶。 在C语言中不是这种情况，因为所有全局变量都是隐式 &lt;code&gt;extern&lt;/code&gt; （即，缺少 &lt;code&gt;static&lt;/code&gt; 关键字时）。</target>
        </trans-unit>
        <trans-unit id="02ff37d17fe54fa59b6bdb89b9051f68c4f95602" translate="yes" xml:space="preserve">
          <source>For this to work, declare &lt;code&gt;X::foo()&lt;/code&gt; as pure:</source>
          <target state="translated">为此，请将 &lt;code&gt;X::foo()&lt;/code&gt; 声明为纯：</target>
        </trans-unit>
        <trans-unit id="d3b72bbcef1b0d4a5a3e0732613861aff970d936" translate="yes" xml:space="preserve">
          <source>Function return type, parameter number and types, and calling convention do not all exactly agree.</source>
          <target state="translated">函数的返回类型、参数数量和类型、调用习惯并不完全一致。</target>
        </trans-unit>
        <trans-unit id="adc354e3ed859611982bdeb24ea70c92b2b599b8" translate="yes" xml:space="preserve">
          <source>Function/variable declared as class member, defined as global (or vice versa).</source>
          <target state="translated">Functionvariable声明为类成员,定义为全局(或反之亦然)。</target>
        </trans-unit>
        <trans-unit id="c9e1736897f86f0f0ebd9367dfa1e73b18c72dbc" translate="yes" xml:space="preserve">
          <source>Function/variable declared in one namespace, defined in another.</source>
          <target state="translated">在一个命名空间中声明的Functionvariable,在另一个命名空间中定义。</target>
        </trans-unit>
        <trans-unit id="47885f9296315b51d23680105388ad37c4f8daa9" translate="yes" xml:space="preserve">
          <source>Further elaboration with an example</source>
          <target state="translated">以一个例子进一步说明</target>
        </trans-unit>
        <trans-unit id="1109ab69f5f30dff37d3dd93730a44c1ec557703" translate="yes" xml:space="preserve">
          <source>Given the code snippet of a template type with a friend operator (or function);</source>
          <target state="translated">给出一个模板类型的代码片段,用友情操作符(或函数)。</target>
        </trans-unit>
        <trans-unit id="87a3d534ea37016d34d8be0559ae5f64128cdd0b" translate="yes" xml:space="preserve">
          <source>Here are &lt;a href=&quot;https://stackoverflow.com/questions/24715864/problems-importing-libraries-to-my-c-project-how-to-fix-this/24715865#24715865&quot;&gt;case1&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16&quot;&gt;case2&lt;/a&gt; handled in more detail from a &lt;em&gt;real world&lt;/em&gt; problem.</source>
          <target state="translated">这是根据&lt;em&gt;实际&lt;/em&gt;问题更详细地处理的&lt;a href=&quot;https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16&quot;&gt;case1&lt;/a&gt;和case2 。</target>
        </trans-unit>
        <trans-unit id="b457236fd45d4cf88f436ca559e82a847ed891f5" translate="yes" xml:space="preserve">
          <source>How do linkers work? The linker matches a function declaration (declared in the header) with its definition (in the shared library) by comparing their signatures. You can get a linker error if the linker doesn't find a function definition that matches perfectly.</source>
          <target state="translated">链接器是如何工作的?链接器通过比较它们的签名来匹配一个函数声明(在头文件中声明)和它的定义(在共享库中)。如果链接器没有找到完全匹配的函数定义,你会得到一个链接器错误。</target>
        </trans-unit>
        <trans-unit id="a4bca897be232f23b6899495a9467715ee2ea072" translate="yes" xml:space="preserve">
          <source>I can reproduce the problem in example 1, but not in example 2</source>
          <target state="translated">我可以重现例1中的问题,但不能在例2中重现。</target>
        </trans-unit>
        <trans-unit id="f16eb78437de212d219271bcd70b1ba35516fa2e" translate="yes" xml:space="preserve">
          <source>I edited the package (in the &lt;code&gt;packages&lt;/code&gt; folder inside the solution's directory) by finding &lt;code&gt;packagename\build\native\packagename.targets&lt;/code&gt; and inside that file, copying all the &lt;code&gt;v110&lt;/code&gt; sections.  I changed the &lt;code&gt;v110&lt;/code&gt; to &lt;code&gt;v120&lt;/code&gt; in &lt;strong&gt;the condition fields only&lt;/strong&gt; being very careful to leave the filename paths all as &lt;code&gt;v110&lt;/code&gt;.  This simply allowed Visual Studio 2013 to link to the libraries for 2012, and in this case, it worked.</source>
          <target state="translated">我通过找到 &lt;code&gt;packagename\build\native\packagename.targets&lt;/code&gt; 和该文件内的内容来编辑包（在解决方案目录内的 &lt;code&gt;packages&lt;/code&gt; 文件夹中），并复制所有 &lt;code&gt;v110&lt;/code&gt; 部分。 我在&lt;strong&gt;条件字段&lt;/strong&gt;中将 &lt;code&gt;v110&lt;/code&gt; 更改为 &lt;code&gt;v120&lt;/code&gt; ， &lt;strong&gt;只是&lt;/strong&gt;非常小心地将文件名路径全部保留为 &lt;code&gt;v110&lt;/code&gt; 。 这仅允许Visual Studio 2013链接到2012年的库，在这种情况下，它可以工作。</target>
        </trans-unit>
        <trans-unit id="e185b3c33f0b4245c7351066033029dca1ef7148" translate="yes" xml:space="preserve">
          <source>I had the same issue. Say i have projects MyProject and TestProject. I had effectively linked the lib file for MyProject to the TestProject. However, this lib file was produced as the DLL for the MyProject was built. Also, I did not contain source code for all methods in the MyProject, but only access to the DLL's entry points.</source>
          <target state="translated">我也有同样的问题。假设我有一个项目MyProject和TestProject。我有效地将MyProject的lib文件链接到TestProject。但是,这个lib文件是在MyProject的DLL被建立时产生的。而且,我没有包含MyProject中所有方法的源代码,只包含了对DLL的入口点的访问。</target>
        </trans-unit>
        <trans-unit id="0436bfc3fe0e52928141662af3daf087596cf26f" translate="yes" xml:space="preserve">
          <source>I have two projects: &lt;code&gt;graphics.lib&lt;/code&gt; and &lt;code&gt;main.exe&lt;/code&gt;. Both projects depend on &lt;code&gt;common_math.h&lt;/code&gt;. Suppose the library exports the following function:</source>
          <target state="translated">我有两个项目： &lt;code&gt;graphics.lib&lt;/code&gt; 和 &lt;code&gt;main.exe&lt;/code&gt; 。 这两个项目都依赖 &lt;code&gt;common_math.h&lt;/code&gt; 。 假设库导出以下功能：</target>
        </trans-unit>
        <trans-unit id="956a2ac958701d2f4ab6fa4fc484437f762915e0" translate="yes" xml:space="preserve">
          <source>I just had this problem trying to link libpng with Visual Studio 2013.  The problem is that the package file only had libraries for Visual Studio 2010 and 2012.</source>
          <target state="translated">我在尝试将libpng与Visual Studio 2013连接时遇到了这个问题。问题是包文件中只有Visual Studio 2010和2012的库。</target>
        </trans-unit>
        <trans-unit id="e9b8b4b047b3721fecc60f4fca5ece4ff41298b6" translate="yes" xml:space="preserve">
          <source>I recently had this problem, and it turned out &lt;a href=&quot;https://stackoverflow.com/questions/27748699/unresolved-reference-to-constructor-which-is-defined/27748920#27748920&quot;&gt;it was a bug in Visual Studio Express 2013&lt;/a&gt;. I had to remove a source file from the project and re-add it to overcome the bug.</source>
          <target state="translated">我最近遇到了这个问题，事实证明&lt;a href=&quot;https://stackoverflow.com/questions/27748699/unresolved-reference-to-constructor-which-is-defined/27748920#27748920&quot;&gt;这是Visual Studio Express 2013中的错误&lt;/a&gt; 。 我必须从项目中删除源文件，然后重新添加它以克服该错误。</target>
        </trans-unit>
        <trans-unit id="1f2758b006cc08918b9f02973af12be1faec02a9" translate="yes" xml:space="preserve">
          <source>I was recently able to get rid of an unresolved external error in Visual Studio 2012 just by recompiling the offending file. When I re-built, the error went away.</source>
          <target state="translated">最近,我在Visual Studio 2012中只需重新编译违规文件,就能摆脱一个未解决的外部错误。当我重新编译后,错误就消失了。</target>
        </trans-unit>
        <trans-unit id="3655c386da677b651bbf58700cb3b35ab01cf79c" translate="yes" xml:space="preserve">
          <source>I was using an alias to refer to &lt;code&gt;std::filesystem::path&lt;/code&gt;: filesystem is in the standard library since C++17 but my program needed to &lt;strong&gt;also compile in C++14&lt;/strong&gt; so I decided to use a variable alias:</source>
          <target state="translated">我使用别名来指代 &lt;code&gt;std::filesystem::path&lt;/code&gt; ：文件系统从C ++ 17开始就在标准库中，但是我的程序&lt;strong&gt;也&lt;/strong&gt;需要&lt;strong&gt;在C ++ 14中进行编译，&lt;/strong&gt;因此我决定使用变量别名：</target>
        </trans-unit>
        <trans-unit id="5173770afade73bcecf7a320d6a1ae32ba13af7d" translate="yes" xml:space="preserve">
          <source>I'll try to explain what is an &quot;undefined reference/unresolved external symbol&quot;.</source>
          <target state="translated">我试着解释一下什么是 &quot;未定义的引用未解决的外部符号&quot;。</target>
        </trans-unit>
        <trans-unit id="a04cfe5805e064fc6a684cbba78e89796fa1eff1" translate="yes" xml:space="preserve">
          <source>I've rejected some lines from output, because they do not matter</source>
          <target state="translated">我已经拒绝了一些行的输出,因为它们并不重要。</target>
        </trans-unit>
        <trans-unit id="2bb7febe7f23a580135ec4f7b408f003af4cb53e" translate="yes" xml:space="preserve">
          <source>If .cpp files depends on   additional .h files  in order to find symbols
that may or may not be defined in the file .cpp</source>
          <target state="translated">如果.cpp文件依赖于额外的.h文件,以找到可能或不可能在.cpp文件中定义的符号。</target>
        </trans-unit>
        <trans-unit id="df67f3ef9d0be7171f81833f9b68966903db7af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;libfoo&lt;/code&gt; depends on &lt;code&gt;libbar&lt;/code&gt;, then your linkage correctly puts &lt;code&gt;libfoo&lt;/code&gt; before &lt;code&gt;libbar&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;libfoo&lt;/code&gt; 依赖 &lt;code&gt;libbar&lt;/code&gt; ，则您的链接正确将 &lt;code&gt;libfoo&lt;/code&gt; 放在libbar之前。</target>
        </trans-unit>
        <trans-unit id="461d3e959eb928d5e96fcebb9ba3f3fe9ab2bb40" translate="yes" xml:space="preserve">
          <source>If I just do:</source>
          <target state="translated">如果我只是做。</target>
        </trans-unit>
        <trans-unit id="da08d2f992c3ccba47f676d81d16d167ac1f33a4" translate="yes" xml:space="preserve">
          <source>If Linker finds an external symbol in one static library he includes the symbol in the output of the project.However, if the library is shared( dynamic ) he doesn't include the code ( symbols ) in output, but  &lt;em&gt;Run-Time&lt;/em&gt; crashes may occur</source>
          <target state="translated">如果Linker在一个静态库中找到一个外部符号，他会将符号包含在项目的输出中，但是，如果该库是shared（dynamic），则他不会在输出中包含代码（symbol），但是&lt;em&gt;运行时&lt;/em&gt;可能会崩溃发生</target>
        </trans-unit>
        <trans-unit id="980c254b69ed02be4226999c6e10d518c5a452c3" translate="yes" xml:space="preserve">
          <source>If an entire library is included in a header file (and was compiled as C code); the include will need to be as follows;</source>
          <target state="translated">如果整个库被包含在一个头文件中(并且被编译为C代码),那么包含的内容将需要如下所示。</target>
        </trans-unit>
        <trans-unit id="f26256c9ecf88ebe6b32a09b8f863a10b618c2ed" translate="yes" xml:space="preserve">
          <source>If exists one .cpp file in which the compiler could not find one symbol, a &lt;strong&gt;compiler time error&lt;/strong&gt; raises the message &lt;em&gt;Symbol x could not be found&lt;/em&gt;</source>
          <target state="translated">如果存在一个.cpp文件，其中编译器无法找到一个符号，则&lt;strong&gt;编译器时间错误&lt;/strong&gt;将引发消息： &lt;em&gt;找不到符号x&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b01078c7a78e15aafb190fba7f0e6960757acba2" translate="yes" xml:space="preserve">
          <source>If one symbol could not be found in object files he also is searched in Additional Libraries.For adding a new library to a project &lt;strong&gt;Configuration properties&lt;/strong&gt; -&amp;gt; &lt;strong&gt;VC++ Directories&lt;/strong&gt;  -&amp;gt; &lt;strong&gt;Library Directories&lt;/strong&gt; and here you specified additional folder for searching libraries and &lt;strong&gt;Configuration properties&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Linker&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Input&lt;/strong&gt; for specifying the name of the library. 
-If the Linker could not find the symbol which you write in one .cpp he raises a &lt;strong&gt;linker time error&lt;/strong&gt; which may sound like 
&lt;code&gt;error LNK2001: unresolved external symbol &quot;void __cdecl foo(void)&quot; (?foo@@YAXXZ)&lt;/code&gt;</source>
          <target state="translated">如果在目标文件中找不到一个符号，也可以在其他库中搜索。将新库添加到项目中&lt;strong&gt;配置属性&lt;/strong&gt; -&amp;gt; &lt;strong&gt;VC ++目录&lt;/strong&gt; -&amp;gt; &lt;strong&gt;库目录，&lt;/strong&gt;并在此处指定用于搜索库和&lt;strong&gt;配置属性的&lt;/strong&gt;附加文件夹-&amp;gt; &lt;strong&gt;链接器&lt;/strong&gt; -&amp;gt; &lt;strong&gt;输入，&lt;/strong&gt;用于指定库的名称。 -如果链接器在一个.cpp文件中找不到您写的符号，他将引发一个&lt;strong&gt;链接器时间错误&lt;/strong&gt; ，听起来像是 &lt;code&gt;error LNK2001: unresolved external symbol &quot;void __cdecl foo(void)&quot; (?foo@@YAXXZ)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="499b77dbfc0604ee9598e32b2d28291c11fb0b8e" translate="yes" xml:space="preserve">
          <source>If that is true, then the linker will &lt;em&gt;not&lt;/em&gt; copy any chunks out of &lt;code&gt;libz&lt;/code&gt; and
add them to your program; instead, it will just doctor the code of your program 
so that:-</source>
          <target state="translated">如果是这样，则链接器将&lt;em&gt;不会&lt;/em&gt;从 &lt;code&gt;libz&lt;/code&gt; 中复制任何块并将其添加到您的程序中。 相反，它只会修改您的程序代码，从而：-</target>
        </trans-unit>
        <trans-unit id="2c00c20b5f535cd9bc44be19371d9b66f3b65283" translate="yes" xml:space="preserve">
          <source>If that is true, then the linker will extract a copy of &lt;code&gt;my_lib.o&lt;/code&gt; from the library and
add it to your program. Then, your program contains a definition for &lt;code&gt;hw&lt;/code&gt;, so
its references to &lt;code&gt;hw&lt;/code&gt; are &lt;em&gt;resolved&lt;/em&gt;.</source>
          <target state="translated">如果是这样，则链接器将从库中提取 &lt;code&gt;my_lib.o&lt;/code&gt; 的副本并将其添加到您的程序中。 然后，您的程序包含 &lt;code&gt;hw&lt;/code&gt; 的定义，因此可以&lt;em&gt;解析&lt;/em&gt;对 &lt;code&gt;hw&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="38c0025e9bec005d4513bd13d86176f0298b0557" translate="yes" xml:space="preserve">
          <source>If the implementation is outside the class definition, but in a header, the methods have to be marked as &lt;code&gt;inline&lt;/code&gt; to prevent a multiple definition.</source>
          <target state="translated">如果实现在类定义之外，但在标头中，则必须将方法标记为 &lt;code&gt;inline&lt;/code&gt; 以防止出现多个定义。</target>
        </trans-unit>
        <trans-unit id="75447576423c30e2c34a784049e8ce92fc59db32" translate="yes" xml:space="preserve">
          <source>If we want to call some functions in a library, but the import library is not added into the additional dependency list (set from: &lt;code&gt;Project | Properties | Configuration Properties | Linker | Input | Additional Dependency&lt;/code&gt;) of your project setting. Now the linker will report a LNK2019 since the definition does not exist in current searching scope.</source>
          <target state="translated">如果我们要调用库中的某些函数，但导入库未添加到 &lt;code&gt;Project | Properties | Configuration Properties | Linker | Input | Additional Dependency&lt;/code&gt; 设置的其他依赖项列表（设置为： 项目|属性|配置属性|链接器|输入|其他依赖项 ）。 现在，链接器将报告LNK2019，因为当前搜索范围中不存在该定义。</target>
        </trans-unit>
        <trans-unit id="fb9269e2b18055a742c1557e6ab1048d1318a42e" translate="yes" xml:space="preserve">
          <source>If you get linker errors about undefined references to symbols that involve types in the std::__cxx11 namespace or the tag [abi:cxx11] then it probably indicates that you are trying to link together object files that were compiled with different values for the _GLIBCXX_USE_CXX11_ABI macro. This commonly happens when linking to a third-party library that was compiled with an older version of GCC. If the third-party library cannot be rebuilt with the new ABI then you will need to recompile your code with the old ABI.</source>
          <target state="translated">如果你收到链接器的错误提示,说是未定义的符号引用涉及到 std:::__cxx11 命名空间中的类型或标记[abi:cxx11]中的类型,那么很可能表明你正在尝试链接使用不同值的_GLIBCXX_USE_CXX11_ABI宏编译的对象文件。这种情况通常发生在链接到用旧版本的GCC编译的第三方库时。如果第三方库不能用新的ABI重建,那么你需要用旧的ABI重新编译你的代码。</target>
        </trans-unit>
        <trans-unit id="f035da38c9a7e86389d0510b74c92ffc7c0c115a" translate="yes" xml:space="preserve">
          <source>If you're using Microsoft Visual Studio, you'll see that projects generate &lt;code&gt;.lib&lt;/code&gt; files. These contain a table of exported symbols, and a table of imported symbols. The imported symbols are resolved against the libraries you link against, and the exported symbols are provided for the libraries that use that &lt;code&gt;.lib&lt;/code&gt; (if any).</source>
          <target state="translated">如果您使用的是Microsoft Visual Studio，则会看到项目会生成 &lt;code&gt;.lib&lt;/code&gt; 文件。 它们包含一个导出符号表和一个导入符号表。 将根据链接的库解析导入的符号，并为使用该 &lt;code&gt;.lib&lt;/code&gt; 的库（如果有）提供导出的符号。</target>
        </trans-unit>
        <trans-unit id="8833aea382a302f646216649f9921b661839e34c" translate="yes" xml:space="preserve">
          <source>If your IDE supports &lt;em&gt;Plain Console Projects&lt;/em&gt; you might want to choose this project type, instead of a windows application project.</source>
          <target state="translated">如果您的IDE支持&lt;em&gt;普通控制台项目&lt;/em&gt; ，则可能要选择此项目类型，而不是Windows应用程序项目。</target>
        </trans-unit>
        <trans-unit id="3f237fb8dc4cacf36f11d31545ebe99a25aef03b" translate="yes" xml:space="preserve">
          <source>In Windows programming, the tell-tale sign that you did not link a necessary library is that the name of the unresolved symbol begins with &lt;code&gt;__imp_&lt;/code&gt;. Look up the name of the function in the documentation, and it should say which library you need to use. For example, MSDN puts the information in a box at the bottom of each function in a section called &quot;Library&quot;.</source>
          <target state="translated">在Windows编程中，您没有链接必要库的迹象表明，未解析符号的名称以 &lt;code&gt;__imp_&lt;/code&gt; 开头 。 在文档中查找该函数的名称，并应说明您需要使用哪个库。 例如，MSDN将信息放置在每个函数底部&amp;ldquo;框&amp;rdquo;中的框内。</target>
        </trans-unit>
        <trans-unit id="66430e667fc7f840b097b706996793b9736a8e56" translate="yes" xml:space="preserve">
          <source>In addition to the library path including the directory of the library, this should be the full name of the library.</source>
          <target state="translated">除了库的路径包括库的目录外,这应该是库的全名。</target>
        </trans-unit>
        <trans-unit id="10bf6a64e5446398af8a3ba19c87d193fc7bdd0c" translate="yes" xml:space="preserve">
          <source>In b.cpp we want to call function foo, so we add</source>
          <target state="translated">在b.cpp中,我们要调用函数foo,所以我们添加了</target>
        </trans-unit>
        <trans-unit id="e04d65d1151fc1eecd729107e8faa2882c68cf4a" translate="yes" xml:space="preserve">
          <source>In general the IDE or build will include some form of &quot;clean&quot; function, but this may not be correctly configured (e.g. in a manual makefile) or may fail (e.g. the intermediate or resultant binaries are read-only).</source>
          <target state="translated">一般情况下,IDE或构建将包含某种形式的 &quot;clean &quot;功能,但这可能没有被正确配置(例如在手动makefile中),或者可能会失败(例如,中间的二进制文件或生成的二进制文件是只读的)。</target>
        </trans-unit>
        <trans-unit id="6703e5641bd382c96b9757b2f2d5f1a0d78b8aef" translate="yes" xml:space="preserve">
          <source>In that case, it means that the available symbols are for a different architecture than the one you are compiling for.</source>
          <target state="translated">在这种情况下,这意味着可用的符号与你所编译的架构不同。</target>
        </trans-unit>
        <trans-unit id="dc33cdb4c80f7ba7f9c92526e532ade7bc8fcd31" translate="yes" xml:space="preserve">
          <source>In the sequence of object files and libraries you want to link to make your
program, you are placing the libraries before the object files that refer to
them. You need to place the libraries &lt;em&gt;after&lt;/em&gt; the object files that refer
to them.</source>
          <target state="translated">在要链接以创建程序的目标文件和库的顺序中，将库放置在引用它们的目标文件之前。 您需要将库放在引用它们的对象文件&lt;em&gt;之后&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2551cda3851296856857b433cfe97a4cfb2b4c9" translate="yes" xml:space="preserve">
          <source>Inconsistent &lt;code&gt;UNICODE&lt;/code&gt; definitions</source>
          <target state="translated">&lt;code&gt;UNICODE&lt;/code&gt; 定义不一致</target>
        </trans-unit>
        <trans-unit id="6fe63eb632221a0ab5535bb76d4c287ae69ff6c4" translate="yes" xml:space="preserve">
          <source>Incorrectly importing/exporting methods/classes across modules/dll (compiler specific).</source>
          <target state="translated">不正确地跨modulesdll导入导出方法类(编译器特有)。</target>
        </trans-unit>
        <trans-unit id="dcc92bce0411701f86858935b384ecc04c852ca4" translate="yes" xml:space="preserve">
          <source>Incorrectly importing/exporting methods/classes across modules/dll. (MSVS specific)</source>
          <target state="translated">不正确地跨modulesdll导入导出方法类。(MSVS专用)</target>
        </trans-unit>
        <trans-unit id="cb120259d25bd6e5201a19869cfd5a9742881496" translate="yes" xml:space="preserve">
          <source>Interdependent library order</source>
          <target state="translated">图书馆秩序的相互依赖性</target>
        </trans-unit>
        <trans-unit id="503e384f0e4e309c11e3d62de8daa731f1a8d2b6" translate="yes" xml:space="preserve">
          <source>Is it possible to still get a linker error even though the declaration and the definition seem to match? Yes! They might look the same in source code, but it really depends on what the compiler sees. Essentially you could end up with a situation like this:</source>
          <target state="translated">即使声明和定义看起来是一致的,是否仍然会出现链接器错误?是的!在源代码中可能看起来是一样的,但这真的要看编译器怎么看。它们可能在源代码中看起来是一样的,但这确实取决于编译器看到的内容。基本上,你可能会出现这样的情况。</target>
        </trans-unit>
        <trans-unit id="771fa3988067ff8a58eabb454bbc75170f08c3d6" translate="yes" xml:space="preserve">
          <source>It can also happen that you forget to add the file to the compilation, in which case the object file won't be generated. In &lt;strong&gt;gcc&lt;/strong&gt; you'd add the files to the command line. In &lt;strong&gt;MSVS&lt;/strong&gt; adding the file to the project will make it compile it automatically (albeit files can, manually, be individually excluded from the build).</source>
          <target state="translated">您还可能忘记将文件添加到编译中，在这种情况下将不会生成目标文件。 在&lt;strong&gt;gcc中，&lt;/strong&gt;您可以将文件添加到命令行中。 在&lt;strong&gt;MSVS中，&lt;/strong&gt;将文件添加到项目将使其自动编译（尽管可以手动将文件从构建中单独排除）。</target>
        </trans-unit>
        <trans-unit id="fe2ed6691d966ca4bdd41bbcc54c815e1cd0e42a" translate="yes" xml:space="preserve">
          <source>It has happened because our local_var_name is static, i.e. it is not visible for other modules. 
Now more deeply. Get the translation phase output</source>
          <target state="translated">出现这种情况是因为我们的local_var_name是静态的,也就是说,其他模块是看不到的。现在更深入的是。获取翻译阶段的输出</target>
        </trans-unit>
        <trans-unit id="627cb145db504cc28647105b8ad1ef86f1340665" translate="yes" xml:space="preserve">
          <source>It is uneconomical at &lt;em&gt;runtime&lt;/em&gt;, because it can cause shared libraries to be
loaded along with a program even if doesn't need them.</source>
          <target state="translated">这在&lt;em&gt;运行时&lt;/em&gt;是不经济的，因为即使不需要共享库，它也会导致将共享库与程序一起加载。</target>
        </trans-unit>
        <trans-unit id="13f85c801fb44532a6193ffc156ba3a1273c4b81" translate="yes" xml:space="preserve">
          <source>LLVM &lt;a href=&quot;http://llvm.org/releases/3.6.2/docs/CommandGuide/llvm-link.html#cmdoption-v&quot;&gt;linker page&lt;/a&gt;.</source>
          <target state="translated">LLVM &lt;a href=&quot;http://llvm.org/releases/3.6.2/docs/CommandGuide/llvm-link.html#cmdoption-v&quot;&gt;链接器页面&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8b4459da7b6461b4c2299ccc79bca1d6aa1bc0f" translate="yes" xml:space="preserve">
          <source>Lastly, the &lt;code&gt;pkg-config&lt;/code&gt; variation of example 2 has a now obvious explanation.
After shell-expansion:</source>
          <target state="translated">最后，示例2的 &lt;code&gt;pkg-config&lt;/code&gt; 变体现在有了明显的解释。 展开外壳后：</target>
        </trans-unit>
        <trans-unit id="46640750de5d6c26ef3345516697c4c8de1c5c05" translate="yes" xml:space="preserve">
          <source>Let's say I have three files: main.cpp, file.h, file.cpp:</source>
          <target state="translated">假设我有三个文件:main.cpp、file.h、file.cpp。</target>
        </trans-unit>
        <trans-unit id="8fb4c3c64119c8c2cdfc81bebdd5f927b932e0aa" translate="yes" xml:space="preserve">
          <source>Link example 1 correctly:</source>
          <target state="translated">链接示例1正确。</target>
        </trans-unit>
        <trans-unit id="bd65393a1e1fc0de6adb743f6af3918125bb0ecc" translate="yes" xml:space="preserve">
          <source>Link example 2 correctly:</source>
          <target state="translated">链接示例2正确。</target>
        </trans-unit>
        <trans-unit id="eff7b8e1e01a437aa7f86d07bd975b1d3e3d6b4f" translate="yes" xml:space="preserve">
          <source>Link invocation (command line),</source>
          <target state="translated">链接调用(命令行)。</target>
        </trans-unit>
        <trans-unit id="4da0c7603f707d809b67abb53db4ebf240bc0929" translate="yes" xml:space="preserve">
          <source>Link our object files</source>
          <target state="translated">链接我们的对象文件</target>
        </trans-unit>
        <trans-unit id="b4235ce9a11da86196b06273997efb6e1bb09f1b" translate="yes" xml:space="preserve">
          <source>Link the example 2 &lt;code&gt;pkg-config&lt;/code&gt; variation correctly:</source>
          <target state="translated">正确链接示例2 &lt;code&gt;pkg-config&lt;/code&gt; 变体：</target>
        </trans-unit>
        <trans-unit id="a67761a97541734d3b1dd08a0be04d93cf4eb6b1" translate="yes" xml:space="preserve">
          <source>Linker Time Error</source>
          <target state="translated">左侧时间错误</target>
        </trans-unit>
        <trans-unit id="93df95814a97d8e558d63057388f44e8335ec3a6" translate="yes" xml:space="preserve">
          <source>Linker errors can happen when a header file and its associated shared library (.lib file) go out of sync. Let me explain.</source>
          <target state="translated">当头文件和它的共享库(.lib文件)不同步时,链接器错误可能会发生。让我解释一下。</target>
        </trans-unit>
        <trans-unit id="2f12c9c12e76e06c4529ab38bf1b266c849ada4a" translate="yes" xml:space="preserve">
          <source>Linker sees exported symbols and links it. Now we try to uncomment lines in src2.cpp like here</source>
          <target state="translated">链接器看到导出的符号并将其链接。现在我们尝试在src2.cpp中取消注释行,就像这里一样</target>
        </trans-unit>
        <trans-unit id="ff5d8fd0650014513ae22d4ad7c2df789c1613a9" translate="yes" xml:space="preserve">
          <source>Linux &lt;a href=&quot;http://linux.die.net/man/1/ld&quot;&gt;ld man page&lt;/a&gt;.</source>
          <target state="translated">Linux &lt;a href=&quot;http://linux.die.net/man/1/ld&quot;&gt;ld手册页&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="1602232f4b5e2f467a8d3b007a0131ae5384e107" translate="yes" xml:space="preserve">
          <source>MSVS requires you to specify which symbols to export and import using &lt;code&gt;__declspec(dllexport)&lt;/code&gt; and &lt;code&gt;__declspec(dllimport)&lt;/code&gt;.</source>
          <target state="translated">MSVS要求您使用 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; 和 &lt;code&gt;__declspec(dllimport)&lt;/code&gt; 指定要导出和导入的符号。</target>
        </trans-unit>
        <trans-unit id="976f170a12de6c4ee60dc922bc6d9db457f350ab" translate="yes" xml:space="preserve">
          <source>Make object files</source>
          <target state="translated">制作对象文件</target>
        </trans-unit>
        <trans-unit id="daa6e7741bcaa1754abaefe5829b55e9e65ff067" translate="yes" xml:space="preserve">
          <source>Make sure that your external library doesn't contain symbols that may enter into conflict with other symbols you defined in your header files</source>
          <target state="translated">确保你的外部库不包含可能与你在头文件中定义的其他符号冲突的符号。</target>
        </trans-unit>
        <trans-unit id="9923a08fcadb46cb599ab38321c7d4b2a14511aa" translate="yes" xml:space="preserve">
          <source>Make sure you write your c++ project syntactical correct.</source>
          <target state="translated">确保你写的C++项目语法正确。</target>
        </trans-unit>
        <trans-unit id="90926b930049fc977cdcf047eff29fccda6c34ad" translate="yes" xml:space="preserve">
          <source>Many Linux distros today configure their GCC toolchain so that its language drivers (&lt;code&gt;gcc&lt;/code&gt;,&lt;code&gt;g++&lt;/code&gt;,&lt;code&gt;gfortran&lt;/code&gt; etc)
instruct the system linker (&lt;code&gt;ld&lt;/code&gt;) to link shared libraries on an &lt;em&gt;as-needed&lt;/em&gt; basis.
You have got one of those distros.</source>
          <target state="translated">如今，许多Linux发行版都配置其GCC工具链，以便其语言驱动程序（ &lt;code&gt;gcc&lt;/code&gt; ， &lt;code&gt;g++&lt;/code&gt; ， &lt;code&gt;gfortran&lt;/code&gt; 等）指示系统链接器（ &lt;code&gt;ld&lt;/code&gt; ）根据需要链接共享库。 您有其中一个发行版。</target>
        </trans-unit>
        <trans-unit id="1ea292f71f513f2f49b3c0ecc19893f09a021ecf" translate="yes" xml:space="preserve">
          <source>Microsoft offers a &lt;code&gt;#pragma&lt;/code&gt; to reference the correct library at link time;</source>
          <target state="translated">Microsoft提供了一个 &lt;code&gt;#pragma&lt;/code&gt; 来在链接时引用正确的库。</target>
        </trans-unit>
        <trans-unit id="c84452b5c5beed02d4bfc0b6a144ddbc0f9f2c52" translate="yes" xml:space="preserve">
          <source>Missing &quot;extern&quot; in &lt;code&gt;const&lt;/code&gt; variable declarations/definitions (C++ only)</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 变量声明/定义中缺少&amp;ldquo; extern&amp;rdquo;（仅C ++）</target>
        </trans-unit>
        <trans-unit id="a0b0d93816c556d77f42fe7a2651c42eb165889f" translate="yes" xml:space="preserve">
          <source>Missing &quot;extern&quot; in const variable declarations/definitions (C++ only)</source>
          <target state="translated">const变量declarationsdefinitions中缺少 &quot;extern&quot;(仅C++)</target>
        </trans-unit>
        <trans-unit id="5eb6f3aa726cfe18f5057b4aefa2edb20315a029" translate="yes" xml:space="preserve">
          <source>Mistyping or not including the .lib extension when using the &lt;code&gt;#pragma&lt;/code&gt; (Microsoft Visual Studio)</source>
          <target state="translated">使用 &lt;code&gt;#pragma&lt;/code&gt; （Microsoft Visual Studio）时是否格式错误或不包括.lib扩展名</target>
        </trans-unit>
        <trans-unit id="f54d45d1a4464006ef586499c694d801d5a8d12c" translate="yes" xml:space="preserve">
          <source>More &lt;a href=&quot;https://gcc.gnu.org/wiki/Visibility&quot;&gt;information about visibility&lt;/a&gt; can be found on the gcc wiki.</source>
          <target state="translated">&lt;a href=&quot;https://gcc.gnu.org/wiki/Visibility&quot;&gt;有关可见性的&lt;/a&gt;更多信息，请参见gcc Wiki。</target>
        </trans-unit>
        <trans-unit id="641fea9b7a86c80e1745eea04b284d17d7064212" translate="yes" xml:space="preserve">
          <source>Most modern linkers include a verbose option that prints out to varying degrees;</source>
          <target state="translated">大多数现代的链接器都包含了一个可打印出不同程度的文字选项。</target>
        </trans-unit>
        <trans-unit id="e559ced22868458277e7a84fcf34818870da0124" translate="yes" xml:space="preserve">
          <source>Multiple source files of the same name</source>
          <target state="translated">同名的多个源文件</target>
        </trans-unit>
        <trans-unit id="c767224b9650ce630e60df38453f62be584ffe15" translate="yes" xml:space="preserve">
          <source>Next, it finds &lt;code&gt;eg1.o&lt;/code&gt;, and adds it to be program. An object file in the
linkage sequence is always added to the program. Now, the program makes
a reference to &lt;code&gt;hw&lt;/code&gt;, and does not contain a definition of &lt;code&gt;hw&lt;/code&gt;; but
there is nothing left in the linkage sequence that could provide the missing
definition. The reference to &lt;code&gt;hw&lt;/code&gt; ends up &lt;em&gt;unresolved&lt;/em&gt;, and the linkage fails.</source>
          <target state="translated">接下来，找到 &lt;code&gt;eg1.o&lt;/code&gt; ，并将其添加为program。 链接序列中的目标文件总是添加到程序中。 现在，该程序引用了 &lt;code&gt;hw&lt;/code&gt; ，并且不包含 &lt;code&gt;hw&lt;/code&gt; 的定义； 但是链接序列中没有任何东西可以提供缺少的定义。 对 &lt;code&gt;hw&lt;/code&gt; 的引用最终&lt;em&gt;未解决&lt;/em&gt; ，并且链接失败。</target>
        </trans-unit>
        <trans-unit id="f0d2f6223f521a208279e081a4e5a7ac2c7dd700" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;virtual&lt;/code&gt; class members</source>
          <target state="translated">非 &lt;code&gt;virtual&lt;/code&gt; 班级成员</target>
        </trans-unit>
        <trans-unit id="117ed9998cfcf9683b519b2cfb916a1303481e8f" translate="yes" xml:space="preserve">
          <source>Note how even though both the function declarations look identical in source code, but they are really different according to the compiler.</source>
          <target state="translated">请注意,尽管这两个函数声明在源代码中看起来完全相同,但根据编译器的说法,它们确实是不同的。</target>
        </trans-unit>
        <trans-unit id="5abbdb9f6a8ffe88fc827af5fbe46e7e3a900154" translate="yes" xml:space="preserve">
          <source>Note in this example, the linker would tell you it couldn't find &lt;code&gt;draw()&lt;/code&gt;, when in reality you know it obviously is being exported by the library. You could spend hours scratching your head wondering what went wrong. The thing is, the linker sees a different signature because the parameter types are slightly different. In the example, &lt;code&gt;vec3&lt;/code&gt; is a different type in both projects as far as the compiler is concerned. This could happen because they come from two slightly different include files (maybe the include files come from two different versions of the library).</source>
          <target state="translated">请注意，在此示例中，链接器将告诉您找不到 &lt;code&gt;draw()&lt;/code&gt; ，而实际上您知道它显然已由库导出。 您可能要花几个小时挠头怀疑问题出在哪里。 事实是，链接器看到了不同的签名，因为参数类型略有不同。 在示例中，就编译器而言， &lt;code&gt;vec3&lt;/code&gt; 在两个项目中都是不同的类型。 之所以会发生这种情况，是因为它们来自两个略有不同的包含文件（也许包含文件来自两个不同版本的库）。</target>
        </trans-unit>
        <trans-unit id="23d4b3aa6710b3034b123422af2beef9dd73642c" translate="yes" xml:space="preserve">
          <source>Note the &lt;strong&gt;different libraries&lt;/strong&gt; used in main.cpp and file.h. Since main.cpp #include'd &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot; after &amp;lt;&lt;strong&gt;filesystem&lt;/strong&gt;&amp;gt;, the version of filesystem used there was &lt;strong&gt;the C++17 one&lt;/strong&gt;. I used to compile the program with the following commands:</source>
          <target state="translated">请注意main.cpp和file.h中使用的&lt;strong&gt;不同库&lt;/strong&gt; 。 由于main.cpp #include &amp;lt; &lt;strong&gt;filesystem&lt;/strong&gt; &amp;gt;之后的&amp;ldquo; &lt;strong&gt;file.h&lt;/strong&gt; &amp;rdquo;，因此使用的文件系统版本为&lt;strong&gt;C ++ 17&lt;/strong&gt; 。 我以前使用以下命令来编译程序：</target>
        </trans-unit>
        <trans-unit id="6ce292ed7cabf956b3bed91089eb7d1238831776" translate="yes" xml:space="preserve">
          <source>Note the weird mangled name given in the linker error. (eg. draw@graphics@XYZ).</source>
          <target state="translated">注意链接器错误中给出的奇怪的名字。(例如:draw@graphics@XYZ)。</target>
        </trans-unit>
        <trans-unit id="3b2cfcdfa403dfa1ba5b0b9b3a8ea1bd2538d22c" translate="yes" xml:space="preserve">
          <source>Now when you build this code you will get a LNK2019 error complaining that foo is an unresolved symbol. In this case, we know that foo() has its definition in a.cpp, but different from the one we are calling(different return value). This is the case that definition exists.</source>
          <target state="translated">现在当你构建这段代码时,你会得到一个LNK2019错误,抱怨foo是一个未解析的符号。在这种情况下,我们知道foo()在a.cpp里有它的定义,但与我们正在调用的定义不同(返回值不同)。这种情况下,定义是存在的。</target>
        </trans-unit>
        <trans-unit id="3fd0cadfd7a6c67e12488f6b0910e0bf6fc11715" translate="yes" xml:space="preserve">
          <source>OK (no errors), because we only build object file, linking is not done yet.
Try to link</source>
          <target state="translated">OK(没有错误),因为我们只是建立对象文件,链接还没有完成。试着链接</target>
        </trans-unit>
        <trans-unit id="e251c8f846836883316a7f1bd7f47a5ca9918668" translate="yes" xml:space="preserve">
          <source>On Linux, it may be due to the wrong library folder (using &lt;code&gt;lib&lt;/code&gt; instead of &lt;code&gt;lib64&lt;/code&gt; for instance).</source>
          <target state="translated">在Linux上，这可能是由于错误的库文件夹（例如，使用 &lt;code&gt;lib&lt;/code&gt; 而不是 &lt;code&gt;lib64&lt;/code&gt; ）造成的。</target>
        </trans-unit>
        <trans-unit id="86966d8cfc106dd026001fc5ff966b8b3018c853" translate="yes" xml:space="preserve">
          <source>On MacOS, there is the option of shipping both architectures in the same file. It may be that the link expects both versions to be there, but only one is. It can also be an issue with the wrong &lt;code&gt;lib&lt;/code&gt;/&lt;code&gt;lib64&lt;/code&gt; folder where the library is picked up.</source>
          <target state="translated">在MacOS上，可以选择将两个体系结构都存储在同一文件中。 链接可能希望这两个版本都存在，但只有一个存在。 拾取库的错误 &lt;code&gt;lib&lt;/code&gt; / &lt;code&gt;lib64&lt;/code&gt; 文件夹也可能是一个问题。</target>
        </trans-unit>
        <trans-unit id="11ea8afa3c6fc752c5cd8f5e66cffa69d7e4417a" translate="yes" xml:space="preserve">
          <source>On Visual Studio, this is due to the wrong &quot;Platform&quot;, and you need to either select the proper one or install the proper version of the library.</source>
          <target state="translated">在Visual Studio上,这是由于错误的 &quot;平台 &quot;造成的,你需要选择合适的平台或者安装合适版本的库。</target>
        </trans-unit>
        <trans-unit id="457c63213d9d88bc27b8181901ab2f67874c5025" translate="yes" xml:space="preserve">
          <source>Once the &quot;clean&quot; has completed, verify that the &quot;clean&quot; has succeeded and all the generated intermediate file (e.g. an automated makefile) have been successfully removed.</source>
          <target state="translated">一旦 &quot;清理 &quot;完成,确认 &quot;清理 &quot;成功,所有生成的中间文件(如自动生成的makefile)都已成功删除。</target>
        </trans-unit>
        <trans-unit id="6f5728e6f888e3db2ef5e4e2e84aed1bcec411c8" translate="yes" xml:space="preserve">
          <source>Once the Linker find one symbol he doesn't search in other libraries for it</source>
          <target state="translated">一旦Linker找到一个符号,他就不会在其他库中搜索它了。</target>
        </trans-unit>
        <trans-unit id="94e5d03e6bfe739776bcda7bf67b4b04f50d00e4" translate="yes" xml:space="preserve">
          <source>One possible reason for linker errors with GCC 5.2.0 is that a new libstdc++ library ABI is now chosen by default.</source>
          <target state="translated">在GCC 5.2.0中出现链接器错误的一个可能原因是现在默认选择了新的libstdc++库ABI。</target>
        </trans-unit>
        <trans-unit id="e8ebcbceae17e1cbcb7630b4e7cab992bde641ed" translate="yes" xml:space="preserve">
          <source>Or in the project settings;</source>
          <target state="translated">或者在项目设置中。</target>
        </trans-unit>
        <trans-unit id="3324fb682ba3b5fa0fc5008f94f9c3c6cb160fbe" translate="yes" xml:space="preserve">
          <source>Or on the command line;</source>
          <target state="translated">或者在命令行中。</target>
        </trans-unit>
        <trans-unit id="0d8974a160f915d9994dddc618b6681fd0f9d9cf" translate="yes" xml:space="preserve">
          <source>Or you could replace the -l argument with the full path of the .so, e.g. instead of &lt;code&gt;-ltbb&lt;/code&gt; do &lt;code&gt;/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2&lt;/code&gt;</source>
          <target state="translated">或者，您可以将-l参数替换为.so的完整路径，例如，代替 &lt;code&gt;-ltbb&lt;/code&gt; 来执行 &lt;code&gt;/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ae41d11bd46131c063f0debe5a8fdf31f161cd3" translate="yes" xml:space="preserve">
          <source>Or, the implementation for the &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; can be done inline inside the class definition;</source>
          <target state="translated">或者，可以在类定义中内联完成 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 的实现；</target>
        </trans-unit>
        <trans-unit id="80d315959f3ea9b04eb57b630f050abbf870cc02" translate="yes" xml:space="preserve">
          <source>Other examples of mismatches include</source>
          <target state="translated">错配的其他例子包括</target>
        </trans-unit>
        <trans-unit id="6a535a2a245f2fac95298b5e9540153ebde66430" translate="yes" xml:space="preserve">
          <source>Parse all the object files and find the definition which was only declared in headers ( eg: The code of one method of a class as is mentioned in previous answers, or event the initialization of a static variable which is member inside a class)</source>
          <target state="translated">解析所有的对象文件,找到只在标题中声明的定义(例如:前面的答案中提到的类的一个方法的代码,或者是类内成员的静态变量的初始化事件</target>
        </trans-unit>
        <trans-unit id="bd4adda29a59ab9ab7bbb53de56745feac90cde3" translate="yes" xml:space="preserve">
          <source>Pay attention to why the mangled names ended up different. You would be able to see that the parameter types are different, even though they look the same in the source code.</source>
          <target state="translated">请注意,为什么篡改后的名字最后会有不同的结果。你会发现参数类型不同,即使在源代码中看起来是一样的。</target>
        </trans-unit>
        <trans-unit id="4041537c412b8e8a70cd213105a7f6d55c1d8225" translate="yes" xml:space="preserve">
          <source>Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set
  (introducing new-line characters for end-of-line indicators) if
  necessary. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">如有必要，物理源文件字符将以实现定义的方式映射到基本源字符集（为行尾指示符引入换行符）。 &lt;em&gt;[SNIP]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f7cb050a64d88fed430275cbf21ad78668fd798" translate="yes" xml:space="preserve">
          <source>Preprocessing directives are executed, macro invocations are expanded, and _Pragma unary operator expressions are executed. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">执行预处理指令，扩展宏调用，并执行_Pragma一元运算符表达式。 &lt;em&gt;[SNIP]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6587b16429748e00b4db35eea2d58d775e0d0e77" translate="yes" xml:space="preserve">
          <source>Problems with template friends</source>
          <target state="translated">模板朋友的问题</target>
        </trans-unit>
        <trans-unit id="0721f2ff9d4e8f8c71dbe1300b4338d0f46d327a" translate="yes" xml:space="preserve">
          <source>Project Properties &amp;gt; General &amp;gt; Project Defaults &amp;gt; Character Set</source>
          <target state="translated">项目属性&amp;gt;常规&amp;gt;项目默认值&amp;gt;字符集</target>
        </trans-unit>
        <trans-unit id="315cdbd0cc37f2f6eed7311d6a11376e81ab5846" translate="yes" xml:space="preserve">
          <source>Putting interdependent libraries in the wrong order is just one way
in which you can get files that &lt;em&gt;need&lt;/em&gt; definitions of things coming
later in the linkage than the files that &lt;em&gt;provide&lt;/em&gt; the definitions. Putting libraries before the 
object files that refer to them is another way of making the same mistake.</source>
          <target state="translated">将相互依存的库放错顺序只是获得&lt;em&gt;需要&lt;/em&gt;定义的文件的一种方式，该文件&lt;em&gt;需要&lt;/em&gt;在链接中晚于&lt;em&gt;提供&lt;/em&gt;定义的文件。 将库放在引用它们的目标文件之前是犯同样错误的另一种方法。</target>
        </trans-unit>
        <trans-unit id="aa2e87051763ba52eba36f8604042df6dea47a55" translate="yes" xml:space="preserve">
          <source>Reason why they are different. In the example given above, they are different because of different include files.</source>
          <target state="translated">它们不同的原因。在上面给出的例子中,它们之所以不同,是因为包含的文件不同。</target>
        </trans-unit>
        <trans-unit id="516aae52959dcf5398a9985414a78b8c24a4f0e5" translate="yes" xml:space="preserve">
          <source>Resolution</source>
          <target state="translated">Resolution</target>
        </trans-unit>
        <trans-unit id="36eb62592e54385368d992e3bfc823feb8a2ecf1" translate="yes" xml:space="preserve">
          <source>Same if you compile and link in one go:</source>
          <target state="translated">如果编译和链接一气呵成,也是一样的。</target>
        </trans-unit>
        <trans-unit id="57b44b45b209c07e2cf396779f22bd7450198c5e" translate="yes" xml:space="preserve">
          <source>Say you defined symbol &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;a.cpp&lt;/code&gt;. Now, &lt;code&gt;b.cpp&lt;/code&gt;&lt;em&gt;declared&lt;/em&gt; that symbol and used it. Before linking, it simply assumes that that symbol was defined &lt;em&gt;somewhere&lt;/em&gt;, but it doesn't yet care where. The linking phase is responsible for finding the symbol and correctly linking it to &lt;code&gt;b.cpp&lt;/code&gt; (well, actually to the object or library that uses it).</source>
          <target state="translated">假设您在 &lt;code&gt;a.cpp&lt;/code&gt; 中定义了符号 &lt;code&gt;a&lt;/code&gt; 。 现在， &lt;code&gt;b.cpp&lt;/code&gt; &lt;em&gt;声明了&lt;/em&gt;该符号并使用了它。 在链接之前，它只是假定该符号已在&lt;em&gt;某处&lt;/em&gt;定义，但尚不在乎。 链接阶段负责查找符号并将其正确链接到 &lt;code&gt;b.cpp&lt;/code&gt; （实际上是使用它的对象或库）。</target>
        </trans-unit>
        <trans-unit id="d88c152a43cb27887978260a5c15f52ecc557b4e" translate="yes" xml:space="preserve">
          <source>Search for the exported symbol of interest, and notice that the mangled name is different.</source>
          <target state="translated">搜索出口的符号,注意到被碾压的名字不一样了。</target>
        </trans-unit>
        <trans-unit id="f5e40313ea4a701259411817e6ec26f8b27269ef" translate="yes" xml:space="preserve">
          <source>Search paths used.</source>
          <target state="translated">使用的搜索路径。</target>
        </trans-unit>
        <trans-unit id="ef26caaa13a2223b4e5f1013e62b3dd0af211401" translate="yes" xml:space="preserve">
          <source>Second, &lt;strong&gt;example 2&lt;/strong&gt;, with shared library &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">其次， &lt;strong&gt;示例2&lt;/strong&gt; ，使用共享库 &lt;code&gt;libz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="31a5c46ba7e3644d87e2c8692f9d7b577d4ff522" translate="yes" xml:space="preserve">
          <source>Similar mechanisms exist for other compilers/ platforms.</source>
          <target state="translated">其他编译器平台也有类似的机制。</target>
        </trans-unit>
        <trans-unit id="ad1f924b7bbc2bcd7bd047b593952dcaf5c4a6a3" translate="yes" xml:space="preserve">
          <source>Similar remarks apply to functions. Declaring a function without defining it leads to the error:</source>
          <target state="translated">类似的说明也适用于函数。在没有定义函数的情况下宣布一个函数会导致错误。</target>
        </trans-unit>
        <trans-unit id="44febaad51a1168e7b5495233c9acbc83d1c9397" translate="yes" xml:space="preserve">
          <source>Similar to Windows-dlls, one would mark public functions with a define, for example &lt;code&gt;DLL_PUBLIC&lt;/code&gt; defined as:</source>
          <target state="translated">与Windows dll相似，将使用定义来标记公共功能，例如 &lt;code&gt;DLL_PUBLIC&lt;/code&gt; 定义为：</target>
        </trans-unit>
        <trans-unit id="3791448e9c466323a781d1053225a28e2ed66066" translate="yes" xml:space="preserve">
          <source>Since it is not implemented, the linker fails to find it and results in the error.</source>
          <target state="translated">因为没有实现,所以链接器找不到,导致错误。</target>
        </trans-unit>
        <trans-unit id="b88c50d7c2684c92f808dc0bef70ada825c3a195" translate="yes" xml:space="preserve">
          <source>Since people seem to be directed to this question when it comes to linker errors I am going to add this here.</source>
          <target state="translated">由于人们在谈到链接器错误时似乎都会被引导到这个问题,所以我在这里补充一下。</target>
        </trans-unit>
        <trans-unit id="5594c3defe9060176ac055ec30199b6a1925a1a0" translate="yes" xml:space="preserve">
          <source>So if you suddenly get linker errors when switching to a GCC after 5.1.0 this would be a thing to check out.</source>
          <target state="translated">所以,如果你在5.1.0之后切换到GCC时突然出现链接器错误,这将是一个需要检查的事情。</target>
        </trans-unit>
        <trans-unit id="7406dccb208de8f7859f688a7bf278cd1e4e822d" translate="yes" xml:space="preserve">
          <source>So the linkage fails just as it does if you &lt;em&gt;do&lt;/em&gt; run those two commands. The
only difference you notice in the failure is that gcc has generated a
temporary object file in the compile + link case, because you're not telling it
to use &lt;code&gt;eg1.o&lt;/code&gt;. We see:</source>
          <target state="translated">因此，链接将失败，就像您运行这两个命令一样。 您在失败中注意到的唯一区别是gcc在compile + link情况 &lt;code&gt;eg1.o&lt;/code&gt; 一个临时目标文件，因为您没有告诉它使用eg1.o。 我们看：</target>
        </trans-unit>
        <trans-unit id="0c7380eb36ac254fde0c5e28aa7521e54819d717" translate="yes" xml:space="preserve">
          <source>So the linker does not add &lt;code&gt;my_lib.o&lt;/code&gt; to the program and has no further
use for &lt;code&gt;libmy_lib.a&lt;/code&gt;.</source>
          <target state="translated">因此，链接器不会将 &lt;code&gt;my_lib.o&lt;/code&gt; 添加到程序中，也不 &lt;code&gt;libmy_lib.a&lt;/code&gt; 进一步使用。</target>
        </trans-unit>
        <trans-unit id="389ef339b38d14a89c45ee18d949e24cc58f1d20" translate="yes" xml:space="preserve">
          <source>So to repeat again, the order &lt;strong&gt;DOES&lt;/strong&gt; matter!</source>
          <target state="translated">因此，要再次重复，顺序&lt;strong&gt;确实很&lt;/strong&gt;重要！</target>
        </trans-unit>
        <trans-unit id="ba83702c0f21aecaaf05b65e1c413ecbfdf89e6e" translate="yes" xml:space="preserve">
          <source>So, as a result - an &quot;undefined reference/unresolved external symbol error&quot; happens when the linker cannot find global symbols in the object files.</source>
          <target state="translated">因此,结果是--当链接器无法在对象文件中找到全局符号时,会出现 &quot;undefined referenceunresolved外部符号错误&quot;。</target>
        </trans-unit>
        <trans-unit id="810e61562c0a90ab80a893ffeb7eb498e51ef3b8" translate="yes" xml:space="preserve">
          <source>So, we see follow symbols to export.</source>
          <target state="translated">所以,我们看到下面的符号输出。</target>
        </trans-unit>
        <trans-unit id="889eacaaf63948869a5ddecd71ff4abfdbeb0106" translate="yes" xml:space="preserve">
          <source>So, we've seen there is no label for local_var_name, that's why linker hasn't found it. But we are hackers :) and we can fix it. Open src1.s in your text editor and change</source>
          <target state="translated">所以,我们看到local_var_name没有标签,这就是为什么linker没有找到它。但是我们是黑客:),我们可以解决这个问题。在你的文本编辑器中打开src1.s,然后修改一下</target>
        </trans-unit>
        <trans-unit id="ed306cf6c07bf565cfeaa2c226cbfd2a2acd58af" translate="yes" xml:space="preserve">
          <source>Some .so files are actually &lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-commands.html&quot;&gt;GNU ld linker scripts&lt;/a&gt;, e.g. &lt;a href=&quot;https://www.threadingbuildingblocks.org/download&quot;&gt;libtbb.so&lt;/a&gt; file is an ASCII text file with this contents:</source>
          <target state="translated">一些.so文件实际上是&lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-commands.html&quot;&gt;GNU ld链接程序脚本&lt;/a&gt; ，例如&lt;a href=&quot;https://www.threadingbuildingblocks.org/download&quot;&gt;libtbb.so&lt;/a&gt;文件是具有以下内容的ASCII文本文件：</target>
        </trans-unit>
        <trans-unit id="2701d02120f341c911b427c678b1b3ba58ab869e" translate="yes" xml:space="preserve">
          <source>Some members need to be defined even if not used explicitly:</source>
          <target state="translated">有些成员即使不明确使用,也需要定义。</target>
        </trans-unit>
        <trans-unit id="0ce76ec1b7032c9c8bc5feb3b6ece87aff083f39" translate="yes" xml:space="preserve">
          <source>Some more complex builds may not support this. For example, if you include -v in the compiler options, you can see that the &lt;a href=&quot;http://www.mainsoft.com/content/mainsoft-unix-and-linux-overview&quot;&gt;mainwin gcc wrapper mwdip&lt;/a&gt; discards linker script command files in the verbose output list of libraries to link in. A simple work around is to replace the linker script input command file with a copy of the file instead (or a symlink), e.g.</source>
          <target state="translated">一些更复杂的版本可能不支持此功能。 例如，如果在编译器选项中包含-v，则可以看到&lt;a href=&quot;http://www.mainsoft.com/content/mainsoft-unix-and-linux-overview&quot;&gt;mainwin gcc包装器mwdip&lt;/a&gt;放弃了要链接的库的详细输出列表中的链接器脚本命令文件。一个简单的解决方法是替换链接器脚本输入命令文件，而不是文件副本（或符号链接），例如</target>
        </trans-unit>
        <trans-unit id="8da255b627a43c5967c21bd733eeffe48c9f7d7b" translate="yes" xml:space="preserve">
          <source>Specialized templates can be implemented in an implementation file and the implementation doesn't have to be visible, but the specialization must be previously declared.</source>
          <target state="translated">专业化模板可以在一个实现文件中实现,实现不一定要可见,但必须事先声明专业化。</target>
        </trans-unit>
        <trans-unit id="2bbb6a7ee8142005a47ef622c25910f07c59d91f" translate="yes" xml:space="preserve">
          <source>Steps to try if you believe it could be a bug in compiler/IDE:</source>
          <target state="translated">如果你认为可能是编译器IDE中的BUG,可以尝试的步骤。</target>
        </trans-unit>
        <trans-unit id="fe05b5a0cc2b31aa92f2910350d4890d86e8795c" translate="yes" xml:space="preserve">
          <source>Success:</source>
          <target state="translated">Success:</target>
        </trans-unit>
        <trans-unit id="82ca7ce44cf63b62393dd7422ee20047ef95bcd5" translate="yes" xml:space="preserve">
          <source>Suppose you have a big project written in c++ which has a thousand of .cpp files and a thousand of .h files.And let's says the project also depends on ten static libraries. Let's says we are on Windows and we build our project in Visual Studio 20xx. When you press Ctrl + F7 Visual Studio to start compiling the whole solution ( suppose we have just one project in the solution )</source>
          <target state="translated">假设你有一个用c++写的大项目,有一千多个.cpp文件和一千多个.h文件。假设我们是在Windows上,我们在Visual Studio 20xx中构建项目。当你按Ctrl+F7 Visual Studio开始编译整个解决方案时(假设我们的解决方案中只有一个项目)。</target>
        </trans-unit>
        <trans-unit id="8380d950d527889dc4734ed54b11f16aca5a374d" translate="yes" xml:space="preserve">
          <source>Symbols were defined in a C program and used in C++ code.</source>
          <target state="translated">在C语言程序中定义了符号,并在C++代码中使用。</target>
        </trans-unit>
        <trans-unit id="2a9939fe25550be4dea8b1c736d43f816c2c5f20" translate="yes" xml:space="preserve">
          <source>Template implementations not visible.</source>
          <target state="translated">模板实现不可见。</target>
        </trans-unit>
        <trans-unit id="8ef7c2da6f851f23bbe511ebc36d3de16160e803" translate="yes" xml:space="preserve">
          <source>That's because the distro on which the linkage works is one of the ones that 
does not configure its GCC toolchain to link shared libraries &lt;em&gt;as-needed&lt;/em&gt;.</source>
          <target state="translated">这是因为链接所使用的发行版是未配置其GCC工具链以&lt;em&gt;按需&lt;/em&gt;链接共享库的发行版之一。</target>
        </trans-unit>
        <trans-unit id="ddd5cfe744cba081a538a7341375f31cf8b1b45a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;libraryName&lt;/code&gt; here is just the bare name of the library, without platform-specific additions. So e.g. on Linux library files are usually called &lt;code&gt;libfoo.so&lt;/code&gt; but you'd only write &lt;code&gt;-lfoo&lt;/code&gt;. On Windows that same file might be called &lt;code&gt;foo.lib&lt;/code&gt;, but you'd use the same argument. You might have to add the directory where those files can be found using &lt;code&gt;-L&amp;lsaquo;directory&amp;rsaquo;&lt;/code&gt;. Make sure to not write a space after &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;-L&lt;/code&gt;.</source>
          <target state="translated">这里的 &lt;code&gt;libraryName&lt;/code&gt; 只是库的裸名，没有特定于平台的添加。 因此，例如在Linux上，库文件通常称为 &lt;code&gt;libfoo.so&lt;/code&gt; ,但您只写 &lt;code&gt;-lfoo&lt;/code&gt; 即可 。 在Windows上，同一文件可能称为 &lt;code&gt;foo.lib&lt;/code&gt; ，但您将使用相同的参数。 您可能必须使用 &lt;code&gt;-L&amp;lsaquo;directory&amp;rsaquo;&lt;/code&gt; 添加可以在其中找到这些文件的目录 。 确保不要在 &lt;code&gt;-l&lt;/code&gt; 或 &lt;code&gt;-L&lt;/code&gt; 之后写空格。</target>
        </trans-unit>
        <trans-unit id="bd483f1251beaf7236d9997165b1d451b6bd1e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is being declared as a non-template function. For every type &lt;code&gt;T&lt;/code&gt; used with &lt;code&gt;Foo&lt;/code&gt;, there needs to be a non-templated &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. For example, if there is a type &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; declared, then there must be an operator implementation as follows;</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 被声明为非模板函数。 对于与 &lt;code&gt;Foo&lt;/code&gt; 一起使用的每种 &lt;code&gt;T&lt;/code&gt; 类型，都需要一个非模板 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 。 例如，如果声明了 &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; 类型，则必须有一个如下的操作符实现；</target>
        </trans-unit>
        <trans-unit id="f74bbb502cac87efc036b9625dd07f7ba8c32eb8" translate="yes" xml:space="preserve">
          <source>The C++ linker expects names to be mangled, so you have to declare the function as:</source>
          <target state="translated">C++链接器期望名称被篡改,所以你必须声明函数为。</target>
        </trans-unit>
        <trans-unit id="fa46de6d6b4941229d8b28acdcc1f6c203f0c516" translate="yes" xml:space="preserve">
          <source>The MSDN page on the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wdsk6as6.aspx&quot;&gt;&lt;code&gt;/VERBOSE&lt;/code&gt; linker option&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wdsk6as6.aspx&quot;&gt; &lt;code&gt;/VERBOSE&lt;/code&gt; 链接器选项&lt;/a&gt;上的MSDN页面。</target>
        </trans-unit>
        <trans-unit id="0a964c858e2f8e84f3cc4266073a14ab0c6127b2" translate="yes" xml:space="preserve">
          <source>The Second step of compilation is done by Linker.Linker should merge all the object file and build finally the output ( which may be an executable or a library)</source>
          <target state="translated">编译的第二步是由Linker完成的,Linker要将所有的对象文件合并,最后建立输出(可以是可执行文件或库)。</target>
        </trans-unit>
        <trans-unit id="b2a9f1a0bcdd74e12869a5f78bd29d7084686e17" translate="yes" xml:space="preserve">
          <source>The above code limits the friendship of the operator to the corresponding instantiation of &lt;code&gt;Foo&lt;/code&gt;, i.e. the &lt;code&gt;operator&amp;lt;&amp;lt; &amp;lt;int&amp;gt;&lt;/code&gt; instantiation is limited to access the private members of the instantiation of &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">上面的代码将操作符的友情限制为 &lt;code&gt;Foo&lt;/code&gt; 的相应实例，即， &lt;code&gt;operator&amp;lt;&amp;lt; &amp;lt;int&amp;gt;&lt;/code&gt; 实例被限制为访问 &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; 实例的私有成员。</target>
        </trans-unit>
        <trans-unit id="7cdbeecfba3fe1508804ada7c0e80ead504f0a5a" translate="yes" xml:space="preserve">
          <source>The alternative is applicable as well, if UNICODE is not intended to be used, make sure the defines are not set, and/or the multi-character setting is used in the projects and consistently applied.</source>
          <target state="translated">替代方案同样适用,如果不打算使用UNICODE,请确保定义不被设置,或者在项目中使用多字符设置并一致应用。</target>
        </trans-unit>
        <trans-unit id="ab517e2a8ba12a27ab2bbd36c075257a2d62e599" translate="yes" xml:space="preserve">
          <source>The code:</source>
          <target state="translated">的代码。</target>
        </trans-unit>
        <trans-unit id="96e15fc342a8a7b8e2a770b1887eaa0b6e5475ae" translate="yes" xml:space="preserve">
          <source>The correct solution is to hope the developer releases an updated package and then upgrade, but it worked for me by hacking in an extra setting for VS2013, pointing at the VS2012 library files.</source>
          <target state="translated">正确的解决办法是希望开发者发布一个更新的软件包,然后升级,但对我来说,只要黑进一个VS2013的额外设置,指向VS2012的库文件,就能奏效。</target>
        </trans-unit>
        <trans-unit id="39c6a6672a8c45fef828814fbc0a834a3d886d1e" translate="yes" xml:space="preserve">
          <source>The default behavior of gcc is that all symbols are visible. However, when the translation units are built with option &lt;code&gt;-fvisibility=hidden&lt;/code&gt;, only functions/symbols marked with &lt;code&gt;__attribute__ ((visibility (&quot;default&quot;)))&lt;/code&gt; are external in the resulting shared object.</source>
          <target state="translated">gcc的默认行为是所有符号都是可见的。 但是，当使用选项 &lt;code&gt;-fvisibility=hidden&lt;/code&gt; 构建转换单元时，只有标记为 &lt;code&gt;__attribute__ ((visibility (&quot;default&quot;)))&lt;/code&gt; 函数/符号在生成的共享库中。</target>
        </trans-unit>
        <trans-unit id="5d98ae42d70c1284a1b8e74bcfa80f5e6dc64e4b" translate="yes" xml:space="preserve">
          <source>The definition should be</source>
          <target state="translated">定义应该是:</target>
        </trans-unit>
        <trans-unit id="fc35bde94bc482f0aba6406f3ef3e5fec63a5cd8" translate="yes" xml:space="preserve">
          <source>The different linkage rules for static and shared libraries can be confusing
to inexpert programmers, who may not know whether &lt;code&gt;-lfoo&lt;/code&gt; in their linkage
is going to resolve to &lt;code&gt;/some/where/libfoo.a&lt;/code&gt; or to &lt;code&gt;/some/where/libfoo.so&lt;/code&gt;,
and might not understand the difference between shared and static libraries
anyway.</source>
          <target state="translated">静态库和共享库的不同链接规则可能会使不熟练的程序员感到困惑，他们可能不知道 &lt;code&gt;-lfoo&lt;/code&gt; 中的-lfoo是否要解析为 &lt;code&gt;/some/where/libfoo.a&lt;/code&gt; 或 &lt;code&gt;/some/where/libfoo.so&lt;/code&gt; ，并且可能仍然无法理解共享库和静态库之间的区别。</target>
        </trans-unit>
        <trans-unit id="aaebebac9d959c2f58827c7b922c7bafe9507b45" translate="yes" xml:space="preserve">
          <source>The error message from the compiler will often give you the full declaration of the variable or function that was declared but never defined. Compare it closely to the definition you provided. &lt;em&gt;Make sure every detail matches.&lt;/em&gt;</source>
          <target state="translated">来自编译器的错误消息通常会为您提供已声明但从未定义的变量或函数的完整声明。 将其与您提供的定义进行比较。 &lt;em&gt;确保每个细节都匹配。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c2fa91316cfdea05c933e01c86ec8f328458b71" translate="yes" xml:space="preserve">
          <source>The error usually includes a function a value with a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt; derived type, these could include &lt;code&gt;std::basic_string&amp;lt;&amp;gt;&lt;/code&gt; etc. as well. When browsing through the affected function in the code, there will often be a reference to &lt;code&gt;TCHAR&lt;/code&gt; or &lt;code&gt;std::basic_string&amp;lt;TCHAR&amp;gt;&lt;/code&gt; etc. This is a tell-tale sign that the code was originally intended for both a UNICODE and a Multi-Byte Character (or &quot;narrow&quot;) build.</source>
          <target state="translated">错误通常包括一个函数，该函数具有 &lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;wchar_t&lt;/code&gt; 派生类型的值，这些值也可能包括 &lt;code&gt;std::basic_string&amp;lt;&amp;gt;&lt;/code&gt; 等。 在代码中浏览受影响的函数时，通常会引用 &lt;code&gt;TCHAR&lt;/code&gt; 或 &lt;code&gt;std::basic_string&amp;lt;TCHAR&amp;gt;&lt;/code&gt; 等。这是一个说明性迹象，表明该代码最初是为UNICODE和Multi-Byte设计的角色（或&amp;ldquo;狭窄&amp;rdquo;）身材。</target>
        </trans-unit>
        <trans-unit id="814895756bf4ca3a731ef6c9e3952b7d303ddbd4" translate="yes" xml:space="preserve">
          <source>The explanation</source>
          <target state="translated">解释</target>
        </trans-unit>
        <trans-unit id="2d47f92cdddee137d7131c686bea6ba95385c1dd" translate="yes" xml:space="preserve">
          <source>The following would yield the error:</source>
          <target state="translated">下面将产生的错误是:</target>
        </trans-unit>
        <trans-unit id="dc651a3eb6c90a022d94d96235e9502e73444d46" translate="yes" xml:space="preserve">
          <source>The function (or variable) &lt;code&gt;void foo()&lt;/code&gt; was defined in a C program and you attempt to use it in a C++ program:</source>
          <target state="translated">函数（或变量） &lt;code&gt;void foo()&lt;/code&gt; 是在C程序中定义的，而您尝试在C ++程序中使用它：</target>
        </trans-unit>
        <trans-unit id="a01682bab1ad942d84e12a4ac6e6ac22aa1e51e4" translate="yes" xml:space="preserve">
          <source>The implementation can be inline, in the class definition itself:</source>
          <target state="translated">实现可以是内嵌式的,在类的定义本身。</target>
        </trans-unit>
        <trans-unit id="edc532595d46d57575b847133085c91ba2256fee" translate="yes" xml:space="preserve">
          <source>The linkage:</source>
          <target state="translated">的联动。</target>
        </trans-unit>
        <trans-unit id="de5f587780a7f48b676bf47c006c00b98834b61e" translate="yes" xml:space="preserve">
          <source>The linker will decide that your program needs &lt;code&gt;my_lib.o&lt;/code&gt; if and only if it already knows that
your program refers to &lt;code&gt;hw&lt;/code&gt;, in one or more of the object files it has already
added to the program, and that none of the object files it has already added
contains a definition for &lt;code&gt;hw&lt;/code&gt;.</source>
          <target state="translated">链接器将在且仅当它已经知道您的程序在已经添加到程序中的一个或多个目标文件中并且没有任何目标文件的情况下，已经知道您的程序引用了 &lt;code&gt;hw&lt;/code&gt; 时 ，才决定您的程序需要 &lt;code&gt;my_lib.o&lt;/code&gt; 。已经添加的包含 &lt;code&gt;hw&lt;/code&gt; 的定义。</target>
        </trans-unit>
        <trans-unit id="0a63e56d03967bc268b8093019d175c83dfcea0a" translate="yes" xml:space="preserve">
          <source>The location of the libraries,</source>
          <target state="translated">图书馆的位置。</target>
        </trans-unit>
        <trans-unit id="11d6b7b1db5745c2043ea068ebb1b7afa5ed93de" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;THIS_MODULE&lt;/code&gt; would only be defined in the module that exports the function. That way, the declaration:</source>
          <target state="translated">只能在导出函数的模块中定义宏 &lt;code&gt;THIS_MODULE&lt;/code&gt; 。 这样，声明：</target>
        </trans-unit>
        <trans-unit id="eb453bce3db2538452e63a26b6b80e65d71ce5e3" translate="yes" xml:space="preserve">
          <source>The order in which interdependent linked libraries are specified is wrong</source>
          <target state="translated">指定相互依赖的链接库的顺序是错误的。</target>
        </trans-unit>
        <trans-unit id="89ab932707a61a0d0cca439734dbbccf264ff41a" translate="yes" xml:space="preserve">
          <source>The order in which interdependent linked libraries are specified is wrong.</source>
          <target state="translated">指定相互依赖的链接库的顺序是错误的。</target>
        </trans-unit>
        <trans-unit id="4687e29b604f518f389340188cf76ad7ba3cfeab" translate="yes" xml:space="preserve">
          <source>The order in which libraries are linked DOES matter if the libraries depend on each other. In general, if library &lt;code&gt;A&lt;/code&gt; depends on library &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;libA&lt;/code&gt;&lt;strong&gt;MUST&lt;/strong&gt; appear before &lt;code&gt;libB&lt;/code&gt; in the linker flags.</source>
          <target state="translated">如果库相互依赖，则链接库的顺序确实很重要。 通常，如果库 &lt;code&gt;A&lt;/code&gt; 依赖于库 &lt;code&gt;B&lt;/code&gt; ，则 &lt;code&gt;libA&lt;/code&gt; &lt;strong&gt;必须&lt;/strong&gt;在链接器标志中的libB之前出现。</target>
        </trans-unit>
        <trans-unit id="c77074a1e65055c9b9d790d1eab74306e35ee769" translate="yes" xml:space="preserve">
          <source>The order of linking libraries &lt;strong&gt;does matter&lt;/strong&gt;.</source>
          <target state="translated">链接库的顺序很&lt;strong&gt;重要&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfadc843995bf96fc6b50f95dc126fbb8c9952b5" translate="yes" xml:space="preserve">
          <source>The precedence among the syntax rules of translation is specified by the following phases &lt;em&gt;[see footnote]&lt;/em&gt;.</source>
          <target state="translated">翻译的语法规则中的优先级由以下阶段指定&lt;em&gt;[请参见脚注]&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="24af2bb789cacc1f5d7b2771021236eabff0f64c" translate="yes" xml:space="preserve">
          <source>The process goes like this:</source>
          <target state="translated">这个过程是这样的。</target>
        </trans-unit>
        <trans-unit id="f9b8eb5b1acfcafd62389be8ee87a10159a198c2" translate="yes" xml:space="preserve">
          <source>The same result if you compile and link in one step, like:</source>
          <target state="translated">如果编译和链接一步到位,结果是一样的,比如。</target>
        </trans-unit>
        <trans-unit id="7ebe1560f137cc486a8b481f98db368bc20a5bb3" translate="yes" xml:space="preserve">
          <source>The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters (including comments). &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">源文件被分解为预处理令牌（2.5）和空白字符序列（包括注释）。 &lt;em&gt;[SNIP]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fe7b5fd3c97072d8d933ccaa526d54b2cbe6724" translate="yes" xml:space="preserve">
          <source>The specified errors occur during this last stage of compilation, most commonly referred to as linking. It basically means that you compiled a bunch of implementation files into object files or libraries and now you want to get them to work together.</source>
          <target state="translated">指定的错误发生在这最后一个编译阶段,最常见的就是链接。它基本上意味着你把一堆实现文件编译成对象文件或库,现在你想让它们一起工作。</target>
        </trans-unit>
        <trans-unit id="d25f8b67d426bc902107dbb9bd3d074093733c3c" translate="yes" xml:space="preserve">
          <source>There is further reading on template friends at &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend#Template_friends&quot;&gt;cppreference&lt;/a&gt; and the &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#template-friends&quot;&gt;C++ FAQ&lt;/a&gt;.</source>
          <target state="translated">有关模板朋友的更多信息，请&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend#Template_friends&quot;&gt;参见cppreference&lt;/a&gt;和&lt;a href=&quot;https://isocpp.org/wiki/faq/templates#template-friends&quot;&gt;C ++ FAQ&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="51d2c1022c793ae6c997851c6c2911c491290dcf" translate="yes" xml:space="preserve">
          <source>There is only object file in &lt;code&gt;libmy_lib.a&lt;/code&gt;, namely &lt;code&gt;my_lib.o&lt;/code&gt;, and there's only one thing defined
in &lt;code&gt;my_lib.o&lt;/code&gt;, namely the function &lt;code&gt;hw&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;libmy_lib.a&lt;/code&gt; 中只有一个目标文件，即 &lt;code&gt;my_lib.o&lt;/code&gt; ，而my_lib.o中只有一个定义的 &lt;code&gt;my_lib.o&lt;/code&gt; ，即函数 &lt;code&gt;hw&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd7c821ca3bddaa894ed4036bbbcbeef36efee4a" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;process can be seen as a final resort, but is often a good first step&lt;/em&gt;; especially if the code related to the error has recently been added (either locally or from the source repository).</source>
          <target state="translated">这个&lt;em&gt;过程可以看作是最后的手段，但是通常是一个很好的第一步&lt;/em&gt; 。 特别是如果最近已添加了与错误相关的代码（无论是本地添加还是从源存储库添加）。</target>
        </trans-unit>
        <trans-unit id="6ad971ec73e134596db3aa5d8e277e263d65c535" translate="yes" xml:space="preserve">
          <source>This behaviour is economical at linktime because the linker doesn't have to ponder
whether a shared library is needed by the program: if it's a shared library,
link it. And most libraries in most linkages are shared libraries. But there are disadvantages too:-</source>
          <target state="translated">这种行为在链接时很经济,因为链接器不需要思索程序是否需要一个共享库:如果是共享库,就链接它。而大多数链接中的大多数库都是共享库。但也有缺点:--</target>
        </trans-unit>
        <trans-unit id="b891d63d48abebbaef68ad3645c7352c0b2f6c19" translate="yes" xml:space="preserve">
          <source>This can be done with either;</source>
          <target state="translated">这可以用任何一种方法。</target>
        </trans-unit>
        <trans-unit id="49d63f2a1c780d571d49de8e11cd2c50aaeac867" translate="yes" xml:space="preserve">
          <source>This dual functionality is usually obtained through the use of a macro:</source>
          <target state="translated">这种双重功能通常是通过使用宏来获得的。</target>
        </trans-unit>
        <trans-unit id="83d3af1836050ec99f7b707ceaa03f6ebb1c3de7" translate="yes" xml:space="preserve">
          <source>This happens because base class destructors are called when the object is destroyed implicitly, so a definition is required.</source>
          <target state="translated">之所以会出现这种情况,是因为当对象被隐式破坏时,基类破坏函数会被调用,所以需要定义。</target>
        </trans-unit>
        <trans-unit id="24bcd3540cf7ff25e654495899de496726d609d7" translate="yes" xml:space="preserve">
          <source>This is one of most confusing error messages that every VC++ programmers have seen time and time again. Let&amp;rsquo;s make things clarity first.</source>
          <target state="translated">这是每个VC ++程序员一次又一次看到的最令人困惑的错误消息之一。 首先让我们弄清楚。</target>
        </trans-unit>
        <trans-unit id="fc953ac37a3ffbcc5b71f7b47d29511fb9fc75f9" translate="yes" xml:space="preserve">
          <source>This is similar to non-&lt;code&gt;virtual&lt;/code&gt; methods with no definition, with the added reasoning that 
the pure declaration generates a dummy vtable and you might get the linker error without using the function:</source>
          <target state="translated">这类似于没有定义的非 &lt;code&gt;virtual&lt;/code&gt; 方法，其另外的原因是纯声明会生成虚拟vtable，并且可能在不使用函数的情况下出现链接器错误：</target>
        </trans-unit>
        <trans-unit id="f40ecc90472f127aee96a0b27d92ae47b6f13c88" translate="yes" xml:space="preserve">
          <source>This means that when the linker finds &lt;code&gt;-lz&lt;/code&gt; in the linkage sequence, and figures out that this refers 
to the shared library (say) &lt;code&gt;/usr/lib/x86_64-linux-gnu/libz.so&lt;/code&gt;, it wants to know whether any references that it has added to your program that aren't yet defined have definitions that are exported by &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">这意味着，当链接 &lt;code&gt;-lz&lt;/code&gt; 在链接顺序中找到-lz并指出此链接是指共享库（例如） &lt;code&gt;/usr/lib/x86_64-linux-gnu/libz.so&lt;/code&gt; 时 ，它想知道是否有任何引用它已添加到尚未定义的程序中，并具有由 &lt;code&gt;libz&lt;/code&gt; 导出的定义</target>
        </trans-unit>
        <trans-unit id="c7bd9513b51b299b1d7979bb703672c0c803ce8a" translate="yes" xml:space="preserve">
          <source>This searching process is called resolve.</source>
          <target state="translated">这个搜索过程叫做解析。</target>
        </trans-unit>
        <trans-unit id="86854a6361abc1cef804c342988694879f4451d0" translate="yes" xml:space="preserve">
          <source>This trade-off has led to the schismatic situation today. Some distros have
changed their GCC linkage rules for shared libraries so that the &lt;em&gt;as-needed&lt;/em&gt;
principle applies for all libraries. Some distros have stuck with the old
way.</source>
          <target state="translated">这种折衷导致了今天的分裂局面。 一些发行版已更改了它们对共享库的GCC链接规则，因此&lt;em&gt;按需&lt;/em&gt;原则适用于所有库。 一些发行版仍然使用旧方法。</target>
        </trans-unit>
        <trans-unit id="c6f9c244e10c8db8baeddb7b6f7b289439a89f58" translate="yes" xml:space="preserve">
          <source>This usually happens when two (or more) libraries have a cyclic dependency. Library A attempts to use symbols in B.lib and library B attempts to use symbols from A.lib. Neither exist to start off with. When you attempt to compile A, the link step will fail because it can't find B.lib. A.lib will be generated, but no dll. You then compile B, which will succeed and generate B.lib. Re-compiling A will now work because B.lib is now found.</source>
          <target state="translated">这通常发生在两个(或多个)库之间有循环依赖关系时。库A试图使用B.lib中的符号,而库B试图使用A.lib中的符号。这两个库都不存在。当你尝试编译A库时,链接步骤将失败,因为它找不到B.lib。A.lib会被生成,但没有dll。然后你再编译B,它将成功并生成B.lib。现在重新编译A就可以工作了,因为B.lib已经找到了。</target>
        </trans-unit>
        <trans-unit id="dde9568d6caff7f7b573e0d0537eb77fffc36423" translate="yes" xml:space="preserve">
          <source>This way &lt;strong&gt;any function&lt;/strong&gt; contained in file.o and used in main.o that &lt;strong&gt;required &lt;code&gt;path_t&lt;/code&gt;&lt;/strong&gt; gave &quot;undefined reference&quot; errors because &lt;strong&gt;main.o&lt;/strong&gt; referred to &lt;strong&gt;&lt;code&gt;std::filesystem::path&lt;/code&gt;&lt;/strong&gt; but &lt;strong&gt;file.o&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;std::experimental::filesystem::path&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">这样，包含在file.o中并在main.o中使用且&lt;strong&gt;需要 &lt;code&gt;path_t&lt;/code&gt; 的&lt;/strong&gt; &lt;strong&gt;任何函数&lt;/strong&gt; &lt;strong&gt;都&lt;/strong&gt;给出了&amp;ldquo;未定义的引用&amp;rdquo;错误，因为&lt;strong&gt;main.o&lt;/strong&gt;引用了&lt;strong&gt; &lt;code&gt;std::filesystem::path&lt;/code&gt; &lt;/strong&gt;但&lt;strong&gt;file.o&lt;/strong&gt;引用了&lt;strong&gt; &lt;code&gt;std::experimental::filesystem::path&lt;/code&gt; &lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0d35af95e12b0dd0220a819e99aa16dadf25948" translate="yes" xml:space="preserve">
          <source>To correct this, build all the required libraries and projects with a consistent definition of &lt;code&gt;UNICODE&lt;/code&gt; (and &lt;code&gt;_UNICODE&lt;/code&gt;).</source>
          <target state="translated">要更正此问题，请使用统一的 &lt;code&gt;UNICODE&lt;/code&gt; （和 &lt;code&gt;_UNICODE&lt;/code&gt; ）定义来构建所有必需的库和项目。</target>
        </trans-unit>
        <trans-unit id="a38dce23594f07d3de4b2b2cc2a5ab210dc62856" translate="yes" xml:space="preserve">
          <source>To correct this, you can declare a template operator before the &lt;code&gt;Foo&lt;/code&gt; type and then declare as a friend, the appropriate instantiation. The syntax is a little awkward, but is looks as follows;</source>
          <target state="translated">若要更正此问题，可以在 &lt;code&gt;Foo&lt;/code&gt; 类型之前声明一个模板运算符，然后将其适当的实例声明为好友。 语法有点尴尬，但是看起来如下：</target>
        </trans-unit>
        <trans-unit id="b278d2255a2fb839042b27cedfdcde4b13d42e77" translate="yes" xml:space="preserve">
          <source>To find which symbols in an object file are hidden run:</source>
          <target state="translated">要查找对象文件中哪些符号是隐藏的,请运行。</target>
        </trans-unit>
        <trans-unit id="f79e5cf712c1cebae4fd911b423526834fd1d23d" translate="yes" xml:space="preserve">
          <source>To fix this I just needed to &lt;strong&gt;change &amp;lt;experimental::filesystem&amp;gt; in file.h to &amp;lt;filesystem&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">为了解决这个问题，我只需要将&lt;strong&gt;file.h中的&amp;lt;experimental :: filesystem&amp;gt;更改为&amp;lt;filesystem&amp;gt;即可&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="2243663083f071145668f251171c65a090b9e5f2" translate="yes" xml:space="preserve">
          <source>To fix this, you must move the definition of &lt;code&gt;X::foo&lt;/code&gt; to the header file or some place visible to the translation unit that uses it.</source>
          <target state="translated">要解决此问题，必须将 &lt;code&gt;X::foo&lt;/code&gt; 的定义移至头文件或使用该文件的翻译单元可见的位置。</target>
        </trans-unit>
        <trans-unit id="ac8e1b45e6bf97148cb8413c306ad6f5794875ec" translate="yes" xml:space="preserve">
          <source>To solve the issue, i built the MyProject as a LIB, and linked TestProject to this .lib file (i copy paste the generated .lib file into the TestProject folder). I can then build again MyProject as a DLL. It is compiling since the lib to which TestProject is linked does contain code for all methods in classes in MyProject.</source>
          <target state="translated">为了解决这个问题,我把MyProject作为一个LIB来构建,并把TestProject链接到这个.lib文件中(我把生成的.lib文件复制粘贴到TestProject文件夹中)。然后,我可以将MyProject作为DLL重新构建为MyProject。由于TestProject所链接的lib文件确实包含了MyProject中所有类中的方法的代码,所以它可以编译。</target>
        </trans-unit>
        <trans-unit id="1f2f0e08ff5b2e59a5a31d4b807b32101fba5f64" translate="yes" xml:space="preserve">
          <source>Translated translation units and instantiation units are combined as follows: &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">翻译的翻译单元和实例化单元的组合如下： &lt;em&gt;[SNIP]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7aef8e7498486de3cd6699dbe069fa0c309048a" translate="yes" xml:space="preserve">
          <source>Try start a new project,
copying all source code from the original one.</source>
          <target state="translated">试着开始一个新的项目,从原来的项目中复制所有的源代码。</target>
        </trans-unit>
        <trans-unit id="7715c2c8a7f85ca33fe93cc7817eac47532e5dc6" translate="yes" xml:space="preserve">
          <source>Try to link your program with &lt;code&gt;libz&lt;/code&gt; and fail:</source>
          <target state="translated">尝试将您的程序与 &lt;code&gt;libz&lt;/code&gt; 链接并失败：</target>
        </trans-unit>
        <trans-unit id="af5e2c5c3e6cb9cebd2829b0e884257cface4ba2" translate="yes" xml:space="preserve">
          <source>Under &lt;strong&gt;MSVS&lt;/strong&gt;, files added to a project automatically have their object files linked together and a &lt;code&gt;lib&lt;/code&gt; file would be generated (in common usage). To use the symbols in a separate project, you'd 
need to include the &lt;code&gt;lib&lt;/code&gt; files in the project settings. This is done in the Linker section of the project properties, in &lt;code&gt;Input -&amp;gt; Additional Dependencies&lt;/code&gt;. (the path to the &lt;code&gt;lib&lt;/code&gt; file should be
added in &lt;code&gt;Linker -&amp;gt; General -&amp;gt; Additional Library Directories&lt;/code&gt;) When using a third-party library that is provided with a &lt;code&gt;lib&lt;/code&gt; file, failure to do so usually results in the error.</source>
          <target state="translated">在&lt;strong&gt;MSVS下&lt;/strong&gt; ，添加到项目中的文件会自动将其目标文件链接在一起，并且会生成一个 &lt;code&gt;lib&lt;/code&gt; 文件（通常使用）。 要在单独的项目中使用这些符号，您需要在项目设置中包含 &lt;code&gt;lib&lt;/code&gt; 文件。 这是在项目属性的&amp;ldquo;链接器&amp;rdquo;部分的&amp;ldquo; &lt;code&gt;Input -&amp;gt; Additional Dependencies&lt;/code&gt; 。 （ &lt;code&gt;lib&lt;/code&gt; 文件的路径应在 &lt;code&gt;Linker -&amp;gt; General -&amp;gt; Additional Library Directories&lt;/code&gt; ）当使用 &lt;code&gt;lib&lt;/code&gt; 文件随附的第三方库时，这样做通常会导致错误。</target>
        </trans-unit>
        <trans-unit id="09353e91d6dc1b681cb300414136507aacd9dc17" translate="yes" xml:space="preserve">
          <source>Under &lt;strong&gt;gcc&lt;/strong&gt; you would specify all object files that are to be linked together in the command line, or compile the implementation files together.</source>
          <target state="translated">在&lt;strong&gt;gcc下，&lt;/strong&gt;您将指定所有要在命令行中链接在一起的目标文件，或者将实现文件编译在一起。</target>
        </trans-unit>
        <trans-unit id="e8e07a144ac894fbd4a815eef8cb126c9d8444ca" translate="yes" xml:space="preserve">
          <source>Unspecialized templates must have their definitions visible to all translation units that use them. That means you can't separate the definition of a template
to an implementation file. If you must separate the implementation, the usual workaround is to have an &lt;code&gt;impl&lt;/code&gt; file which you include at the end of the header that
declares the template. A common situation is:</source>
          <target state="translated">未专业化的模板的定义必须对使用它们的所有翻译单位可见。 这意味着您无法将模板的定义与实现文件分开。 如果必须分开实现，通常的解决方法是在声明模板的标头末尾包含一个 &lt;code&gt;impl&lt;/code&gt; 文件。 常见的情况是：</target>
        </trans-unit>
        <trans-unit id="626a6bfb69f923133176d2288c20c9ad3e266875" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;#pragma once&lt;/code&gt; for allowing compiler not to include one header if it was already included in the current .cpp which are compiled</source>
          <target state="translated">使用 &lt;code&gt;#pragma once&lt;/code&gt; 以允许编译器不包含一个标头（如果已将其包含在当前已编译的.cpp中）</target>
        </trans-unit>
        <trans-unit id="652d6febf33e65c27e03abc9bf57e88d8db07539" translate="yes" xml:space="preserve">
          <source>Use the linker to help diagnose the error</source>
          <target state="translated">使用链接器帮助诊断错误</target>
        </trans-unit>
        <trans-unit id="3df12d1763a76db1eb5f9e0c7142ced823b24c14" translate="yes" xml:space="preserve">
          <source>Visual Studio search into file &lt;strong&gt;.vcxproj&lt;/strong&gt; and start compiling each file which has the extension .cpp. Order of compilation is undefined.So you must not assume that the file main.cpp is compiled first</source>
          <target state="translated">Visual Studio搜索文件&lt;strong&gt;.vcxproj，&lt;/strong&gt;然后开始编译扩展名为.cpp的每个文件。 编译顺序是不确定的，因此您不能假定文件main.cpp首先被编译</target>
        </trans-unit>
        <trans-unit id="bc6493aa79682062f1e35506dac73e5d517d7fa9" translate="yes" xml:space="preserve">
          <source>What are undefined reference/unresolved external symbol errors? What are common causes and how to fix/prevent them?</source>
          <target state="translated">什么是undefined referenceunresolved外部符号错误?常见的原因有哪些,如何预防?</target>
        </trans-unit>
        <trans-unit id="db7e500851b237b0a75617adc43159c4e601d013" translate="yes" xml:space="preserve">
          <source>What are you doing wrong?</source>
          <target state="translated">你做错了什么?</target>
        </trans-unit>
        <trans-unit id="2d7204271f918e6dc824c4de713ad791b4dc1110" translate="yes" xml:space="preserve">
          <source>What is an undefined reference/unresolved external symbol error and how do I fix it</source>
          <target state="translated">什么是undefined referenceunresolved外部符号错误?</target>
        </trans-unit>
        <trans-unit id="4632922517e4c4150df04140a0a11bc46ff27b5a" translate="yes" xml:space="preserve">
          <source>When a translation unit is compiled with &lt;code&gt;-fvisibility=hidden&lt;/code&gt; the resulting symbols have still external linkage (shown with upper case symbol type by &lt;code&gt;nm&lt;/code&gt;) and can be used for external linkage without problem if the object files become part of a static libraries. The linkage becomes local only when the object files are linked into a shared library.</source>
          <target state="translated">当使用 &lt;code&gt;-fvisibility=hidden&lt;/code&gt; 编译转换单元时，生成的符号仍然具有外部链接（以 &lt;code&gt;nm&lt;/code&gt; 显示大写的符号类型），并且如果目标文件成为静态库的一部分，则可以毫无问题地用于外部链接。 仅当将目标文件链接到共享库时，链接才成为本地链接。</target>
        </trans-unit>
        <trans-unit id="2c08affaeeed528ac9c1fa3dfa4effce084687ac" translate="yes" xml:space="preserve">
          <source>When linking against shared libraries, make sure that the used symbols are not hidden.</source>
          <target state="translated">在对共享库进行链接时,确保使用的符号不被隐藏。</target>
        </trans-unit>
        <trans-unit id="9ca2a7655109619c5715fb8ca7ccc73f3615a640" translate="yes" xml:space="preserve">
          <source>When you run the command above, &lt;code&gt;gcc&lt;/code&gt; figures out that you want compilation +
linkage. So behind the scenes, it generates a compilation command, and runs
it, then generates a linkage command, and runs it, as if &lt;em&gt;you&lt;/em&gt; had run the
two commands:</source>
          <target state="translated">当您运行上面的命令时， &lt;code&gt;gcc&lt;/code&gt; 会指出您要进行编译+链接。 因此，在幕后，它将生成一个编译命令，然后运行它，然后生成一个链接命令，然后运行它，就像&lt;em&gt;您&lt;/em&gt;已经运行了这两个命令一样：</target>
        </trans-unit>
        <trans-unit id="4567f3b27b39712303adc4658d2e89c9f3ed6ec0" translate="yes" xml:space="preserve">
          <source>When you try to link the program like:</source>
          <target state="translated">当你尝试链接程序时,如。</target>
        </trans-unit>
        <trans-unit id="b31400492742589d7742b79425b053a4e29f6f8f" translate="yes" xml:space="preserve">
          <source>When you use the template to make sure you include the definition of each template function in the header file for allowing the compiler to generate appropriate code for any instantiations.</source>
          <target state="translated">当你使用模板时,请确保在头文件中包含每个模板函数的定义,以允许编译器为任何实例生成适当的代码。</target>
        </trans-unit>
        <trans-unit id="e4d80ad940bb876bd92a024b5ff663f048b0473e" translate="yes" xml:space="preserve">
          <source>When your include paths are different</source>
          <target state="translated">当你的包含路径不同时</target>
        </trans-unit>
        <trans-unit id="03365de1caa8827769bae8158a775de517156e6d" translate="yes" xml:space="preserve">
          <source>Which roughly corresponds to Windows'/MSVC-version:</source>
          <target state="translated">这大致对应于Windows'MSVC-版本。</target>
        </trans-unit>
        <trans-unit id="246959a741f4264372238420ebdad97bd89a88ec" translate="yes" xml:space="preserve">
          <source>White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The
  resulting tokens are syntactically and semantically analyzed and
  translated as a translation unit. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">分隔标记的空格字符不再重要。 每个预处理令牌都将转换为令牌。 （2.7）。 对生成的令牌进行语法和语义分析，并将其作为翻译单元进行翻译。 &lt;em&gt;[SNIP]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3057b9b641cbee71aae82fe2b981cf8b49a7f80" translate="yes" xml:space="preserve">
          <source>Why do I still get this problem even if I compile-and-link at the same time?</source>
          <target state="translated">为什么我在编译和链接的同时,还是会遇到这个问题?</target>
        </trans-unit>
        <trans-unit id="4c6dfe4286bb4038ff6570e5b46f04c49bbf7bf5" translate="yes" xml:space="preserve">
          <source>You are trying to compile and link your program with the GCC toolchain.</source>
          <target state="translated">你正试图将你的程序与GCC工具链进行编译和链接。</target>
        </trans-unit>
        <trans-unit id="91c1836cb1d64ed1ad44ab634dca30d630520583" translate="yes" xml:space="preserve">
          <source>You build your static library:</source>
          <target state="translated">你建立你的静态库。</target>
        </trans-unit>
        <trans-unit id="2fd7e03d89627c87bdf0cf1f8eddb4e44c4ee89f" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;nm&lt;/code&gt; with the option &lt;code&gt;-C&lt;/code&gt; to demangle the names (if C++ was used).</source>
          <target state="translated">您还可以将 &lt;code&gt;nm&lt;/code&gt; 与选项 &lt;code&gt;-C&lt;/code&gt; 一起使用来对名称进行解密（如果使用了C ++）。</target>
        </trans-unit>
        <trans-unit id="eb4ed51d89a6db08d7aac2b244cdb0601cb7bc64" translate="yes" xml:space="preserve">
          <source>You can check whether the symbols your are looking for are external by invoking:</source>
          <target state="translated">你可以通过调出你要找的符号是否是外部的。</target>
        </trans-unit>
        <trans-unit id="e80a1a5e2677479f692a83c2c89c313fa9e2dc07" translate="yes" xml:space="preserve">
          <source>You can similary import/export classes:</source>
          <target state="translated">你可以类似imilportexport类。</target>
        </trans-unit>
        <trans-unit id="e3de844a4d66034d092d8886a7ce6acf2d81f628" translate="yes" xml:space="preserve">
          <source>You compile your program:</source>
          <target state="translated">你编译你的程序。</target>
        </trans-unit>
        <trans-unit id="5f4c7708a6df0a34a544a31a0505e1654dab7e88" translate="yes" xml:space="preserve">
          <source>You may have missed to choose the right project type with your actual IDE. The IDE may want to bind e.g. Windows Application projects to such entry point function (as specified in the missing reference above), instead of the commonly used &lt;code&gt;int main(int argc, char** argv);&lt;/code&gt; signature.</source>
          <target state="translated">您可能错过了使用实际IDE选择正确的项目类型的机会。 IDE可能希望将例如Windows应用程序项目绑定到此类入口点功能（如上面缺少的参考中所述），而不是通常使用的 &lt;code&gt;int main(int argc, char** argv);&lt;/code&gt; 签名。</target>
        </trans-unit>
        <trans-unit id="9e82259a675941d9948a2eeb64a675ff5f0bac6e" translate="yes" xml:space="preserve">
          <source>You may see a message like:</source>
          <target state="translated">你可能会看到这样一条信息:</target>
        </trans-unit>
        <trans-unit id="0e60f4f947984fbf84f6c4fd28e3b1b296e997d0" translate="yes" xml:space="preserve">
          <source>You might ask how one ends up in a situation like that? &lt;strong&gt;Include paths&lt;/strong&gt; of course! If when compiling the shared library, the include path leads to &lt;code&gt;header1.h&lt;/code&gt; and you end up using &lt;code&gt;header2.h&lt;/code&gt; in your own program, you'll be left scratching your header wondering what happened (pun intended).</source>
          <target state="translated">您可能会问，在这种情况下最终会如何？ 当然要&lt;strong&gt;包括路径&lt;/strong&gt; ！ 如果在编译共享库时，include路径指向 &lt;code&gt;header1.h&lt;/code&gt; ,而您最终在自己的程序中使用 &lt;code&gt;header2.h&lt;/code&gt; ，则您将不停地抓头，想知道发生了什么（双关语）。</target>
        </trans-unit>
        <trans-unit id="2d39d52ae6b215a68d9cf55a1d98a408fa72b8cc" translate="yes" xml:space="preserve">
          <source>You try to link it with &lt;code&gt;libmy_lib.a&lt;/code&gt; and fail:</source>
          <target state="translated">您尝试将其与 &lt;code&gt;libmy_lib.a&lt;/code&gt; 链接并失败：</target>
        </trans-unit>
        <trans-unit id="ac3540a5f0b565ea8381987f3a836626c11a6c8e" translate="yes" xml:space="preserve">
          <source>Your linkage consumes libraries before the object files that refer to them</source>
          <target state="translated">你的联动在引用对象文件之前消耗库,然后再消耗对象文件</target>
        </trans-unit>
        <trans-unit id="374fcc2688ffa3e097d03ef0cda91f4abae3f9a6" translate="yes" xml:space="preserve">
          <source>Your linkage fails with &lt;code&gt;undefined reference to&lt;/code&gt;&lt;em&gt;something&lt;/em&gt; errors.</source>
          <target state="translated">您的链接失败，并带有 &lt;code&gt;undefined reference to&lt;/code&gt; &lt;em&gt;某些&lt;/em&gt;错误的引用 。</target>
        </trans-unit>
        <trans-unit id="a97d5c4fcdbab0b3e334224158a61c8ab8cdf3b8" translate="yes" xml:space="preserve">
          <source>Your linkage specifies all of the necessary libraries and library search paths</source>
          <target state="translated">你的链接指定了所有必要的库和库的搜索路径。</target>
        </trans-unit>
        <trans-unit id="1ede8f96ef941a4cd4a8b47db4fd4ec6dee457d7" translate="yes" xml:space="preserve">
          <source>Your program wants to refer to just one thing that has a definition exported by &lt;code&gt;libz&lt;/code&gt;,
namely the function &lt;code&gt;zlibVersion&lt;/code&gt;, which is referred to just once, in &lt;code&gt;eg2.c&lt;/code&gt;.
If the linker adds that reference to your program, and then finds the definition
exported by &lt;code&gt;libz&lt;/code&gt;, the reference is &lt;em&gt;resolved&lt;/em&gt;</source>
          <target state="translated">您的程序只想引用具有由 &lt;code&gt;libz&lt;/code&gt; 导出的定义的一件事，即函数 &lt;code&gt;zlibVersion&lt;/code&gt; ，该函数在 &lt;code&gt;eg2.c&lt;/code&gt; 中仅被引用一次。 如果链接器将该引用添加到您的程序，然后找到 &lt;code&gt;libz&lt;/code&gt; 导出的定义，则该引用将被&lt;em&gt;解析&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6630645888101f4b1ebaafc85246e04a796c1112" translate="yes" xml:space="preserve">
          <source>[1] By project I mean a set of source files that are linked together to produce either a library or an executable.</source>
          <target state="translated">[1]我所说的项目是指一组源文件,这些源文件被链接在一起产生一个库或可执行文件。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="73825e2f27276ce7cc0cb99fe4926aefead625b6" translate="yes" xml:space="preserve">
          <source>and rebuild an object file</source>
          <target state="translated">并重建一个对象文件</target>
        </trans-unit>
        <trans-unit id="3a85961b64655acfc507843ec1ba2838a9155bab" translate="yes" xml:space="preserve">
          <source>and run it</source>
          <target state="translated">并运行它</target>
        </trans-unit>
        <trans-unit id="6ab5682fa6ec7ce3b574c508f69fdd94179f902d" translate="yes" xml:space="preserve">
          <source>and similar errors with &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt;:</source>
          <target state="translated">以及&lt;strong&gt;Microsoft Visual Studio的&lt;/strong&gt;类似错误：</target>
        </trans-unit>
        <trans-unit id="73d70fffc648342f33ca44795d6cc820d7069f22" translate="yes" xml:space="preserve">
          <source>and tells the compiler that the definition is in one of the libraries you linked against (also see &lt;strong&gt;1)&lt;/strong&gt;).</source>
          <target state="translated">并告诉编译器该定义在您链接的库之一中（另请参见&lt;strong&gt;1）&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a885b4bb68e35a1301318ebf72bf542d958c8233" translate="yes" xml:space="preserve">
          <source>and tells the compiler to export the function, as the current module contains its definition. When including the declaration in a different module, it would expand to</source>
          <target state="translated">并告诉编译器导出该函数,因为当前模块包含了它的定义。当把声明包含在不同的模块中时,它将扩展为</target>
        </trans-unit>
        <trans-unit id="8081e608d396eb9fd48db5d9cb98df468f9b43c5" translate="yes" xml:space="preserve">
          <source>and you attempt to use it in a C++ program with C++ linkage.</source>
          <target state="translated">并尝试在一个C++程序中使用它与C++联动。</target>
        </trans-unit>
        <trans-unit id="c02ceb78ff4863ee1a75d232c4f53af56b182ec9" translate="yes" xml:space="preserve">
          <source>becomes:</source>
          <target state="translated">becomes:</target>
        </trans-unit>
        <trans-unit id="f799f07bf625ffbca0fe04fdd368917957d04df0" translate="yes" xml:space="preserve">
          <source>correct would be to use a header file and include it in file2.cpp &lt;em&gt;and&lt;/em&gt; file1.cpp</source>
          <target state="translated">正确的方法是使用头文件并将其包含在file2.cpp &lt;em&gt;和&lt;/em&gt; file1.cpp中</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">扩大到</target>
        </trans-unit>
        <trans-unit id="8597eabf07801651c88304087bf20f69ac103fa3" translate="yes" xml:space="preserve">
          <source>i.e. you should have like below</source>
          <target state="translated">也就是说,你应该像下面这样</target>
        </trans-unit>
        <trans-unit id="6c8457cd65849bf5a9285f8b862e990e1a44ac09" translate="yes" xml:space="preserve">
          <source>instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="4f0aa52d656a3d75867f784b7e9c5d23bf1321c0" translate="yes" xml:space="preserve">
          <source>link</source>
          <target state="translated">link</target>
        </trans-unit>
        <trans-unit id="293dce46f676980a9b1278e7251ff73eb7fa797d" translate="yes" xml:space="preserve">
          <source>note: i use g++ and Linux and all examples is for it</source>
          <target state="translated">注意:我使用g++和Linux,所有的例子都是针对它的。</target>
        </trans-unit>
        <trans-unit id="36c55470c929c5d5f4d41ac78ab446fd5b77009b" translate="yes" xml:space="preserve">
          <source>now local_var_name has Bind GLOBAL (was LOCAL)</source>
          <target state="translated">现在local_var_name已经绑定了GLOBAL (原来是LOCAL)</target>
        </trans-unit>
        <trans-unit id="fb74205393b3bb80203f54f7a8c9bcb830e8763e" translate="yes" xml:space="preserve">
          <source>ok, see readelf output (symbols)</source>
          <target state="translated">好,见readelf输出(符号)。</target>
        </trans-unit>
        <trans-unit id="3a328af911638e5bfc90b4e0e69e9c25737cc9a5" translate="yes" xml:space="preserve">
          <source>ok, we hack it :)</source>
          <target state="translated">好吧,我们黑了它:)</target>
        </trans-unit>
        <trans-unit id="2328aeacf83c4c55bc1147be999690bfc6241ad3" translate="yes" xml:space="preserve">
          <source>or outside:</source>
          <target state="translated">或外面。</target>
        </trans-unit>
        <trans-unit id="ceeb2cffd5c7262a750a941ceb1e733b45fbb7ca" translate="yes" xml:space="preserve">
          <source>src2.cpp exports nothing and we have seen no its symbols</source>
          <target state="translated">src2.cpp没有输出任何东西,我们也没有看到它的符号。</target>
        </trans-unit>
        <trans-unit id="2f0f1d7be52efe820ea8f283992862328386c64a" translate="yes" xml:space="preserve">
          <source>surely gcc has to compile &lt;code&gt;eg1.c&lt;/code&gt; first, and then link the resulting
object file with &lt;code&gt;libmy_lib.a&lt;/code&gt;.  So how can it not know that object file
is needed when it's doing the linking?</source>
          <target state="translated">当然，gcc必须先编译 &lt;code&gt;eg1.c&lt;/code&gt; ，然后将生成的目标文件与 &lt;code&gt;libmy_lib.a&lt;/code&gt; 链接 。 那么，如何在链接时不知道需要目标文件呢？</target>
        </trans-unit>
        <trans-unit id="e01b8bf7137076c13f10eccf3ac7d89d9ac67196" translate="yes" xml:space="preserve">
          <source>the hidden/local symbols are shown by &lt;code&gt;nm&lt;/code&gt; with lowercase symbol type, for example &lt;code&gt;t&lt;/code&gt; instead of `T for code-section:</source>
          <target state="translated">&lt;code&gt;nm&lt;/code&gt; 表示隐藏/本地符号，并使用小写符号类型，例如 &lt;code&gt;t&lt;/code&gt; 而不是`T表示代码段：</target>
        </trans-unit>
        <trans-unit id="5e0942b4293aac626166820cf457118f4f66b257" translate="yes" xml:space="preserve">
          <source>the linker &lt;em&gt;has not added&lt;/em&gt;&lt;code&gt;eg1.o&lt;/code&gt;&lt;em&gt;to the program&lt;/em&gt; when it sees
&lt;code&gt;-lmy_lib&lt;/code&gt;. Because at that point, it has not seen &lt;code&gt;eg1.o&lt;/code&gt;.
Your program does not yet make any references to &lt;code&gt;hw&lt;/code&gt;: it
does not yet make any references &lt;em&gt;at all&lt;/em&gt;, because all the references it makes
are in &lt;code&gt;eg1.o&lt;/code&gt;.</source>
          <target state="translated">链接器看到 &lt;code&gt;-lmy_lib&lt;/code&gt; 时， &lt;em&gt;尚未将&lt;/em&gt; &lt;code&gt;eg1.o&lt;/code&gt; &lt;em&gt;添加&lt;/em&gt; &lt;em&gt;到程序中&lt;/em&gt; 。 因为到那时，还没有看到 &lt;code&gt;eg1.o&lt;/code&gt; 。 您的程序尚未对 &lt;code&gt;hw&lt;/code&gt; 进行任何引用：它根本未进行任何引用，因为它进行的所有引用都在 &lt;code&gt;eg1.o&lt;/code&gt; 中 。</target>
        </trans-unit>
        <trans-unit id="474bf0c29b756b32c6ea11e2c24831191c57e8a2" translate="yes" xml:space="preserve">
          <source>the order of events is wrong in just the same way as with example 1.
At the point when the linker finds &lt;code&gt;-lz&lt;/code&gt;, there are &lt;em&gt;no&lt;/em&gt; references to anything
in the program: they are all in &lt;code&gt;eg2.o&lt;/code&gt;, which has not yet been seen. So the
linker decides it has no use for &lt;code&gt;libz&lt;/code&gt;. When it reaches &lt;code&gt;eg2.o&lt;/code&gt;, adds it to the program,
and then has undefined reference to &lt;code&gt;zlibVersion&lt;/code&gt;, the linkage sequence is finished;
that reference is unresolved, and the linkage fails.</source>
          <target state="translated">事件的顺序是与示例1相同的方式是错误的。在链接器找到 &lt;code&gt;-lz&lt;/code&gt; 时 ，程序中&lt;em&gt;没有&lt;/em&gt;对任何内容的引用：它们全部在 &lt;code&gt;eg2.o&lt;/code&gt; 中 ，但尚未看到。 因此，链接器认为 &lt;code&gt;libz&lt;/code&gt; 没有用。 当到达 &lt;code&gt;eg2.o&lt;/code&gt; 时 ，将其添加到程序中，然后具有对 &lt;code&gt;zlibVersion&lt;/code&gt; 的未定义引用，链接序列完成； 该引用未解决，并且链接失败。</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="7979c3fe74f25deb6892e5101b26610dc97c75eb" translate="yes" xml:space="preserve">
          <source>to declare function foo(), and call it in another function body, say &lt;code&gt;bar()&lt;/code&gt;:</source>
          <target state="translated">声明函数foo（），并在另一个函数体中调用它，例如 &lt;code&gt;bar()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ec79436cd4ee8fbface339724362fc515088bfd8" translate="yes" xml:space="preserve">
          <source>undefined reference to `WinMain@16'</source>
          <target state="translated">未定义的对`WinMain@16'的引用</target>
        </trans-unit>
        <trans-unit id="b888bea9cd6729fbf7ebdc759e10b2f2dacf405c" translate="yes" xml:space="preserve">
          <source>we have changed the visibility of local_var_name and set its value to 456789.
Try to build an object file from it</source>
          <target state="translated">我们改变了local_var_name的可见性,并将其值设置为456789。尝试用它来建立一个对象文件</target>
        </trans-unit>
        <trans-unit id="a3bc4f467d60d6e7137cb42e5a2693f58a0ffef5" translate="yes" xml:space="preserve">
          <source>which is just example 2 again.</source>
          <target state="translated">这只是例2的又一次。</target>
        </trans-unit>
        <trans-unit id="416857d2967c5146284d55951fb33a942176a9f1" translate="yes" xml:space="preserve">
          <source>will generate the following errors with &lt;strong&gt;GCC&lt;/strong&gt;:</source>
          <target state="translated">会在&lt;strong&gt;GCC中&lt;/strong&gt;产生以下错误：</target>
        </trans-unit>
        <trans-unit id="767ebf562599ebd8219e0bce2533fd52b533baeb" translate="yes" xml:space="preserve">
          <source>works just fine for you!</source>
          <target state="translated">很适合你</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
