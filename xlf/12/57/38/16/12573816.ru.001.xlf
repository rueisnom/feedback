<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/12573816">
    <body>
      <group id="12573816">
        <trans-unit id="c9cbc039ba0dda953e719495f032898e9956f254" translate="yes" xml:space="preserve">
          <source>&quot;An introduction to GCC&quot; &lt;a href=&quot;http://www.network-theory.co.uk/docs/gccintro/gccintro_75.html&quot;&gt;chapter 9&lt;/a&gt;.</source>
          <target state="translated">&amp;laquo;Введение в GCC&amp;raquo; &lt;a href=&quot;http://www.network-theory.co.uk/docs/gccintro/gccintro_75.html&quot;&gt;глава 9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7d5b868297c7e069f79fb3331f33b5984b8682" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -c file.cpp&lt;/code&gt; -&amp;gt; compiles file.cpp and file.h to file.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -c file.cpp&lt;/code&gt; -&amp;gt; компилирует file.cpp и file.h в file.o</target>
        </trans-unit>
        <trans-unit id="e49790a3beb1dd7402b4cb606c79667d1433b0a4" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -c main.cpp&lt;/code&gt; -&amp;gt; compiles main.cpp to main.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -c main.cpp&lt;/code&gt; -&amp;gt; компилирует main.cpp в main.o</target>
        </trans-unit>
        <trans-unit id="071ec213b517c0a8d3f03b45c60bc9f9f0b55435" translate="yes" xml:space="preserve">
          <source>$ &lt;code&gt;g++ -g -std=c++17 -o executable main.o file.o -lstdc++fs&lt;/code&gt; -&amp;gt; links main.o and file.o</source>
          <target state="translated">$ &lt;code&gt;g++ -g -std=c++17 -o executable main.o file.o -lstdc++fs&lt;/code&gt; -&amp;gt; ссылки main.o и file.o</target>
        </trans-unit>
        <trans-unit id="bad1abfbbc607215e826cba0225a7e15753aaefc" translate="yes" xml:space="preserve">
          <source>(Or: That linkage worked fine for you on, say, Fedora 23, but fails on Ubuntu 16.04)</source>
          <target state="translated">(Или:Эта связь отлично сработала,скажем,на Федоре 23,но не сработала на Убунту 16.04).</target>
        </trans-unit>
        <trans-unit id="74c25a55039995250f6d3f12bb86f1ae278cee30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://coliru.stacked-crooked.com/a/e9221c4bb23f9cd0&quot;&gt;Code listing showing the techniques above&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://coliru.stacked-crooked.com/a/e9221c4bb23f9cd0&quot;&gt;Список кодов, показывающий методы выше&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf6077b839b27f134871fac7b06a0474aa39b4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; data members must be defined outside the class in a &lt;strong&gt;single translation unit&lt;/strong&gt;:</source>
          <target state="translated">члены &lt;code&gt;static&lt;/code&gt; данных должны быть определены вне класса в &lt;strong&gt;одной единице перевода&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="89e5d36fe0239dd24cbe84c6df52545cb824576c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;virtual&lt;/code&gt; methods must either be implemented or defined as pure.</source>
          <target state="translated">&lt;code&gt;virtual&lt;/code&gt; методы должны быть либо реализованы, либо определены как чистые.</target>
        </trans-unit>
        <trans-unit id="a6e978f78787cb65ba3c48dd61a5ce9874bb1e0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;As a side note to the failing code sample; g++ warns about this as follows&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Как примечание к ошибочному образцу кода;&lt;/em&gt; &lt;em&gt;G ++ предупреждает об этом следующим образом&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcdf4af6901fd0be253767cc15e18070c0140d96" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;, when the declaration of the operator (or function) only appears in the class, the name is not available for &quot;normal&quot; lookup, only for argument dependent lookup, from &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend&quot;&gt;cppreference&lt;/a&gt;;</source>
          <target state="translated">&lt;em&gt;Обратите внимание&lt;/em&gt; : когда объявление оператора (или функции) появляется только в классе, имя недоступно для &amp;laquo;нормального&amp;raquo; поиска, только для поиска, &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend&quot;&gt;зависящего&lt;/a&gt; от аргумента, из cppreference ;</target>
        </trans-unit>
        <trans-unit id="66ebd1f43ac511c6c708dab9f44756f21a71765e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Reading is optional from here on&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Чтение не является обязательным с этого момента&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2438bd9596a6f2aad81a0222f2c18ffe262f7d81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[footnote]&lt;/em&gt; Implementations must behave as if these separate phases occur, although in practice different phases might be folded together.</source>
          <target state="translated">&lt;em&gt;[сноска]&lt;/em&gt; Реализации должны вести себя так, как если бы эти отдельные фазы происходили, хотя на практике разные фазы могут складываться вместе.</target>
        </trans-unit>
        <trans-unit id="a534858af77623fa6f10f6aa3f2334132487ee64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A wrapper around GNU ld that doesn't support linker scripts&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обертка вокруг GNU ld, которая не поддерживает скрипты компоновщика&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="835e534d0a03e685a5781ca6fe9811f767d58b55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A. What is symbol?&lt;/strong&gt;
In short, a symbol is a name. It can be a variable name, a function name, a class name, a typedef name, or anything except those names and signs that belong to C++ language. It is user defined or introduced by a dependency library (another user-defined).</source>
          <target state="translated">&lt;strong&gt;А. Что такое символ?&lt;/strong&gt; Короче говоря, символ - это имя. Это может быть имя переменной, имя функции, имя класса, имя typedef или что угодно, кроме тех имен и знаков, которые принадлежат языку C ++. Он определяется пользователем или вводится библиотекой зависимостей (другой определяется пользователем).</target>
        </trans-unit>
        <trans-unit id="eec66c59c1dbab98e498c91f5e97e7ff8ab7101f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All external entity references are resolved. Library components are linked to satisfy external references to entities not defined in the
  current translation. All such translator output is collected into a
  program image which contains information needed for execution in its
  execution environment.&lt;/strong&gt; (emphasis mine)</source>
          <target state="translated">&lt;strong&gt;Все ссылки на внешние объекты разрешены.&lt;/strong&gt; &lt;strong&gt;Компоненты библиотеки связаны для удовлетворения внешних ссылок на объекты, не определенные в текущем переводе.&lt;/strong&gt; &lt;strong&gt;Весь такой вывод транслятора собирается в образ программы, который содержит информацию, необходимую для выполнения в среде выполнения.&lt;/strong&gt; (акцент мой)</target>
        </trans-unit>
        <trans-unit id="dd8db3de81c77ec485d11b2559fd63ff6023c436" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B. What is external?&lt;/strong&gt;
In VC++, every source file (.cpp,.c,etc.) is considered as a translation unit, the compiler compiles one unit at a time, and generate one object file(.obj) for the current translation unit. (Note that every header file that this source file included will be preprocessed and will be considered as part of this translation unit)Everything within a translation unit is considered as internal, everything else is considered as external. In C++, you may reference an external symbol by using keywords like &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;__declspec (dllimport)&lt;/code&gt; and so on.</source>
          <target state="translated">&lt;strong&gt;B. Что является внешним?&lt;/strong&gt; В VC ++ каждый исходный файл (.cpp, .c и т. Д.) Рассматривается как модуль перевода, компилятор компилирует один модуль за раз и генерирует один объектный файл (.obj) для текущего модуля перевода. (Обратите внимание, что каждый заголовочный файл, включенный в этот исходный файл, будет предварительно обработан и будет считаться частью этого модуля перевода) Все в модуле перевода рассматривается как внутреннее, все остальное рассматривается как внешнее. В C ++ вы можете ссылаться на внешний символ, используя ключевые слова, такие как &lt;code&gt;extern&lt;/code&gt; , &lt;code&gt;__declspec (dllimport)&lt;/code&gt; и так далее.</target>
        </trans-unit>
        <trans-unit id="6c2ca1047c2ef8497e41c914c53f8e7ca55ee476" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C. What is &amp;ldquo;resolve&amp;rdquo;?&lt;/strong&gt;
Resolve is a linking-time term. In linking-time, linker attempts to find the external definition for every symbol in object files that cannot find its definition internally. The scope of this searching process including:</source>
          <target state="translated">&lt;strong&gt;C. Что такое &amp;laquo;решимость&amp;raquo;?&lt;/strong&gt; Resolve - это термин времени связывания. Во время компоновки компоновщик пытается найти внешнее определение для каждого символа в объектных файлах, которые не могут найти его определение внутри. Объем этого процесса поиска, включая:</target>
        </trans-unit>
        <trans-unit id="7342049e2513cd5b99e201cfcb5bf3b14417789e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;D. Finally, why Unresolved External Symbol?&lt;/strong&gt;
If the linker cannot find the external definition for a symbol that has no definition internally, it reports an Unresolved External Symbol error.</source>
          <target state="translated">&lt;strong&gt;D. Наконец, почему неразрешенный внешний символ?&lt;/strong&gt; Если компоновщик не может найти внешнее определение для символа, который не имеет внутреннего определения, он сообщает об ошибке &amp;laquo;Неразрешенный внешний символ&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5b8a47f4b41b91b3d612aacb048ed208fcac6f16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Different architectures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Разные архитектуры&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be965b14abe7432b5fa433657763c3dc46c94955" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E. Possible causes of LNK2019&lt;/strong&gt;: Unresolved External Symbol error.
We already know that this error is due to the linker failed to find the definition of external symbols, the possible causes can be sorted as:</source>
          <target state="translated">&lt;strong&gt;E. Возможные причины LNK2019&lt;/strong&gt; : Неразрешенная ошибка внешнего символа. Мы уже знаем, что эта ошибка связана с тем, что компоновщику не удалось найти определение внешних символов, возможные причины можно отсортировать по следующим параметрам:</target>
        </trans-unit>
        <trans-unit id="175dc84044f833f83a2c70ee5958f34ffa3867f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How To Solve this kind of error&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как решить эту ошибку&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50f9819832db0d81b1174260f918040cd2cf7d74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If all else fails, recompile.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Если ничего не помогает, перекомпилируйте.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cffd218845fdac972017077668b21dcb30366645" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Linked .lib file is associated to a .dll&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Связанный .lib файл связан с .dll&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06b83ed7c66d61ec7db41c3a6e7b02f8577e43ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Observation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8940eb48005ed796b60ad830078b12d07df43be6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Steps In Linking a project&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Шаги в Связывание проекта&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="75d4f8b2fa373cf046a6b677d6c35770b0294edb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Visual Studio NuGet package needs to be updated for new toolset version&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пакет Visual Studio NuGet необходимо обновить до новой версии набора инструментов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb0c9feeb4bacc0fa3c37312d7a301912ecd4847" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What's the meaning of compilation ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;В чем смысл компиляции?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1465fad7785625be27309d79cd0e820fa06d98f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eg1.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;eg1.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89c440cfe498cb89e3725891dfd833439ac8312d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;eg2.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;eg2.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff073c269c56360873674533870cbf8bfa429227" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;file.cpp&lt;/strong&gt;, the implementation of file.h, #include's &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot;</source>
          <target state="translated">&lt;strong&gt;file.cpp&lt;/strong&gt; , реализация file.h, # include's &lt;strong&gt;file.h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9ae04f6c866dcf587fa6e1e0dae001a09d7888a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;file.h&lt;/strong&gt; #include's &amp;lt;&lt;strong&gt;experimental::filesystem&lt;/strong&gt;&amp;gt; and contains the code above</source>
          <target state="translated">&lt;strong&gt;file.h&lt;/strong&gt; # включает в себя &amp;lt; &lt;strong&gt;экспериментальный :: файловая система&lt;/strong&gt; &amp;gt; и содержит код выше</target>
        </trans-unit>
        <trans-unit id="fddf0c10ac5731cb589a87bb2c2094c4fa147fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;main.cpp&lt;/strong&gt; #include's &amp;lt;&lt;strong&gt;filesystem&lt;/strong&gt;&amp;gt; and &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot;</source>
          <target state="translated">&lt;strong&gt;main.cpp&lt;/strong&gt; # include &amp;lt; &lt;strong&gt;filesystem&lt;/strong&gt; &amp;gt; и &quot; &lt;strong&gt;file.h&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="2582c85be2b20f3244cd0cd3e45025f73c92ed51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;my_lib.c&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;my_lib.c&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c230963946da5a9ed838b6a5933de9f154d5ef91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;my_lib.h&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;my_lib.h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2662021565cbcee02085174aa21cc7ecdb484907" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined reference to &lt;code&gt;WinMain@16&lt;/code&gt; or similar &lt;em&gt;'unusual'&lt;/em&gt; &lt;code&gt;main()&lt;/code&gt; entry point reference&lt;/strong&gt; (especially for &lt;a href=&quot;/questions/tagged/visual-studio&quot;&gt;visual-studio&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;неопределенная ссылка на &lt;code&gt;WinMain@16&lt;/code&gt; или похожая &lt;em&gt;&amp;laquo;необычная&amp;raquo;&lt;/em&gt; ссылка на точку входа &lt;code&gt;main()&lt;/code&gt; &lt;/strong&gt; (особенно для &lt;a href=&quot;/questions/tagged/visual-studio&quot;&gt;visual-studio&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0acfceb277492d3fa70c2011c817d088faf04611" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;what is an &quot;undefined reference/unresolved external symbol&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;что такое &amp;laquo;неопределенная ссылка / неразрешенный внешний символ&amp;raquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3c395f4232d75cdbc21861202f537c9ca9121e5" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;Feel free to edit/add your own.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Не стесняйтесь редактировать / добавлять свои собственные.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d2d1d37fdef4865427a49fbf3bf6a77bd38bb6d1" translate="yes" xml:space="preserve">
          <source>A &quot;clean&quot; of the build can remove the &quot;dead wood&quot; that may be left lying around from previous builds, failed builds, incomplete builds and other build system related build issues.</source>
          <target state="translated">Чистое&quot; здание может удалить &quot;мертвую древесину&quot;,которая может остаться от предыдущих сборок,неудачных,незавершенных и других сборочных проблем,связанных со сборочными системами.</target>
        </trans-unit>
        <trans-unit id="189f79f5d1a5faa4467603ef162262cccf65ca78" translate="yes" xml:space="preserve">
          <source>A Windows UNICODE build is built with &lt;code&gt;TCHAR&lt;/code&gt; etc. being defined as &lt;code&gt;wchar_t&lt;/code&gt; etc. When not building with &lt;code&gt;UNICODE&lt;/code&gt; defined as build with &lt;code&gt;TCHAR&lt;/code&gt; defined as &lt;code&gt;char&lt;/code&gt; etc. These &lt;code&gt;UNICODE&lt;/code&gt; and &lt;code&gt;_UNICODE&lt;/code&gt; defines affect all the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx&quot;&gt;&quot;&lt;code&gt;T&lt;/code&gt;&quot; string types&lt;/a&gt;; &lt;code&gt;LPTSTR&lt;/code&gt;, &lt;code&gt;LPCTSTR&lt;/code&gt; and their elk.</source>
          <target state="translated">&lt;code&gt;TCHAR&lt;/code&gt; Windows UNICODE строится с использованием TCHAR и т. Д., Определяемого как &lt;code&gt;wchar_t&lt;/code&gt; и т. Д. Если сборка не &lt;code&gt;TCHAR&lt;/code&gt; с &lt;code&gt;UNICODE&lt;/code&gt; , определяемой как сборка, с TCHAR, определенным как &lt;code&gt;char&lt;/code&gt; и т. Д. Эти определения &lt;code&gt;UNICODE&lt;/code&gt; и &lt;code&gt;_UNICODE&lt;/code&gt; влияют на все &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/dd374131(v=vs.85).aspx&quot;&gt;строковые типы &quot; &lt;code&gt;T&lt;/code&gt; &quot;&lt;/a&gt; ; &lt;code&gt;LPTSTR&lt;/code&gt; , &lt;code&gt;LPCTSTR&lt;/code&gt; и их лось.</target>
        </trans-unit>
        <trans-unit id="90afd285297eb44d41e1f5773ca5cb874cbb19b4" translate="yes" xml:space="preserve">
          <source>A bug in the compiler/IDE</source>
          <target state="translated">Ошибка в компиляторе</target>
        </trans-unit>
        <trans-unit id="a31d75bc9dfc18e7b2009004254a487c7ca05013" translate="yes" xml:space="preserve">
          <source>A common mistake is forgetting to qualify the name:</source>
          <target state="translated">Обычная ошибка-забыть квалифицировать имя:</target>
        </trans-unit>
        <trans-unit id="1f739d01292aa73c37e4aee39f036a3bb2a527ee" translate="yes" xml:space="preserve">
          <source>A minimal example involving a shared system library, the compression library &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">Минимальный пример, включающий общую системную библиотеку, библиотеку сжатия &lt;code&gt;libz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01c92916b56793a9454d489c312fa9257acc6107" translate="yes" xml:space="preserve">
          <source>A minimal example involving a static library you built yourself</source>
          <target state="translated">Минимальный пример со статической библиотекой,которую вы создали сами.</target>
        </trans-unit>
        <trans-unit id="6d46bde77adddeb0b72386689fff3e28dd372bb9" translate="yes" xml:space="preserve">
          <source>A name first declared in a friend declaration within class or class template X becomes a member of the innermost enclosing namespace of X, but is not accessible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at the namespace scope is provided...</source>
          <target state="translated">Имя,впервые объявленное в дружеской декларации внутри класса или шаблона класса X,становится членом внутреннего пространства имен X,но не доступно для поиска (за исключением поиска в зависимости от аргумента,который учитывает X),если только не предусмотрено соответствующее объявление в области пространства имен...</target>
        </trans-unit>
        <trans-unit id="5a03aa49c3c082188ccefd12449a2783226a9d4f" translate="yes" xml:space="preserve">
          <source>A pure &lt;code&gt;virtual&lt;/code&gt; destructor needs an implementation.</source>
          <target state="translated">Чистый &lt;code&gt;virtual&lt;/code&gt; деструктор нуждается в реализации.</target>
        </trans-unit>
        <trans-unit id="ec2d47bd5e6c687188cca18e11b6e3a11fd20b4b" translate="yes" xml:space="preserve">
          <source>A shared library isn't an archive of object files or anything like it. It's
much more like a &lt;em&gt;program&lt;/em&gt; that doesn't have a &lt;code&gt;main&lt;/code&gt; function and
instead exposes multiple other symbols that it defines, so that other
programs can use them at runtime.</source>
          <target state="translated">Общая библиотека не является архивом объектных файлов или чем-то подобным. Это больше похоже на &lt;em&gt;программу&lt;/em&gt; , которая не имеет &lt;code&gt;main&lt;/code&gt; функции и вместо этого предоставляет множество других символов, которые она определяет, чтобы другие программы могли использовать их во время выполнения.</target>
        </trans-unit>
        <trans-unit id="4f62d04e30be88d7be65eb3c4d8daefedf696027" translate="yes" xml:space="preserve">
          <source>A static library is an indexed archive of object files. When the linker
finds &lt;code&gt;-lmy_lib&lt;/code&gt; in the linkage sequence and figures out that this refers
to the static library &lt;code&gt;./libmy_lib.a&lt;/code&gt;, it wants to know whether your program
needs any of the object files in &lt;code&gt;libmy_lib.a&lt;/code&gt;.</source>
          <target state="translated">Статическая библиотека - это индексированный архив объектных файлов. Когда компоновщик находит &lt;code&gt;-lmy_lib&lt;/code&gt; в последовательности компоновки и выясняет, что это относится к статической библиотеке &lt;code&gt;./libmy_lib.a&lt;/code&gt; , он хочет знать, нужен ли вашей программе какой-либо из объектных файлов в &lt;code&gt;libmy_lib.a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b191d246d34f1e602a3e402976e900a1a875073" translate="yes" xml:space="preserve">
          <source>A typical variable declaration is</source>
          <target state="translated">Типичная переменная объявление</target>
        </trans-unit>
        <trans-unit id="82e2e65a5074a60696904cace45937b63edf3d64" translate="yes" xml:space="preserve">
          <source>Adjacent string literal tokens are concatenated.</source>
          <target state="translated">Соседние строки буквенные жетоны конкапсулированы.</target>
        </trans-unit>
        <trans-unit id="7fe45da2f4efcc86cb9b6567ee7a4ad6bf699b1f" translate="yes" xml:space="preserve">
          <source>After the assembler phase we have an object file, which contains any symbols to export. 
Look at the symbols</source>
          <target state="translated">После фазы ассемблера у нас есть объектный файл,который содержит любые символы для экспорта.Посмотрите на символы</target>
        </trans-unit>
        <trans-unit id="dbf5b9e02583394489628b8d6f4b8f7252c2835c" translate="yes" xml:space="preserve">
          <source>All libraries (.lib) that are either explicitly or implicitly
specified as additional dependencies of this building application.</source>
          <target state="translated">Все библиотеки (.lib),которые явно или неявно указаны в качестве дополнительных зависимостей данного сборочного приложения.</target>
        </trans-unit>
        <trans-unit id="f594bd06c1caa0ead7f44aab9131622ae2e6ba7e" translate="yes" xml:space="preserve">
          <source>All object files that generated in compiling time</source>
          <target state="translated">Все объектные файлы,сгенерированные во время компиляции</target>
        </trans-unit>
        <trans-unit id="4091f76b2539a23ecb3681b7960816da46fc1f49" translate="yes" xml:space="preserve">
          <source>All used member methods need to be defined if used.</source>
          <target state="translated">Все используемые методы членов должны быть определены,если они используются.</target>
        </trans-unit>
        <trans-unit id="258953ce5c44b3d94df6a62bf16b94620782ab0b" translate="yes" xml:space="preserve">
          <source>Allowing the friendship to extend to all instantiations of the templates, as follows;</source>
          <target state="translated">Позволяя дружбе распространиться на все конкретики шаблонов следующим образом;</target>
        </trans-unit>
        <trans-unit id="c827bc9706235eb6e58b62b8ed3b65b6653a561a" translate="yes" xml:space="preserve">
          <source>Also if you're using 3rd party libraries make sure you have the correct 32/64 bit binaries</source>
          <target state="translated">Также,если вы используете сторонние библиотеки,убедитесь,что у вас есть правильные 3264-битные двоичные файлы</target>
        </trans-unit>
        <trans-unit id="fcf665a8f73833aa185cc196d74ef511cdd50687" translate="yes" xml:space="preserve">
          <source>Alternatively one could declare the &lt;code&gt;const&lt;/code&gt; variable in file1.cpp with explicit &lt;code&gt;extern&lt;/code&gt;</source>
          <target state="translated">В качестве альтернативы можно объявить переменную &lt;code&gt;const&lt;/code&gt; в file1.cpp с явным &lt;code&gt;extern&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6faa1efbd9a22a841dece261aa541458bc6561d1" translate="yes" xml:space="preserve">
          <source>Alternatives include;</source>
          <target state="translated">Альтернативы включают в себя;</target>
        </trans-unit>
        <trans-unit id="9142d2a0c57278cbac1656ede2c51ad79022c5e8" translate="yes" xml:space="preserve">
          <source>An example of how this can happen in the real world is explained below.</source>
          <target state="translated">Пример того,как это может произойти в реальном мире,объясняется ниже.</target>
        </trans-unit>
        <trans-unit id="0978b0da32a1d538f6533aded9b037a5a632b0e0" translate="yes" xml:space="preserve">
          <source>An initializer can be provided for a &lt;code&gt;static&lt;/code&gt;&lt;code&gt;const&lt;/code&gt; data member of integral or enumeration type within the class definition; however, odr-use of this member will still require a namespace scope definition as described above. C++11 allows initialization inside the class for all &lt;code&gt;static const&lt;/code&gt; data members.</source>
          <target state="translated">Инициализатор может быть предоставлен для &lt;code&gt;static&lt;/code&gt; члена данных &lt;code&gt;const&lt;/code&gt; целочисленного или перечислимого типа в определении класса; однако использование odr этого члена все равно потребует определения области имен, как описано выше. C ++ 11 позволяет инициализировать внутри класса все &lt;code&gt;static const&lt;/code&gt; члены-данные const .</target>
        </trans-unit>
        <trans-unit id="fe337499c7cf1304af8bc4b955a047cc2736dc7c" translate="yes" xml:space="preserve">
          <source>And a variation on example 2 involving &lt;code&gt;pkg-config&lt;/code&gt;:</source>
          <target state="translated">И вариант в примере 2, включающий &lt;code&gt;pkg-config&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d551606414a99e264853eca34fd51b96854e0ecd" translate="yes" xml:space="preserve">
          <source>And then you go ahead and include the library in your own project.</source>
          <target state="translated">А затем вы включаете библиотеку в свой собственный проект.</target>
        </trans-unit>
        <trans-unit id="b2245e86d8c2a2258df1e19537be1050df1ac011" translate="yes" xml:space="preserve">
          <source>As this is only a declaration, a &lt;strong&gt;single definition&lt;/strong&gt; is needed. A corresponding definition would be:</source>
          <target state="translated">Поскольку это только декларация, необходимо &lt;strong&gt;одно определение&lt;/strong&gt; . Соответствующее определение будет:</target>
        </trans-unit>
        <trans-unit id="b13d9a436d6efc6b48e4a9a36b25cc2355a5e4fc" translate="yes" xml:space="preserve">
          <source>At runtime, the system program loader will load a copy of &lt;code&gt;libz&lt;/code&gt; into the
same process as your program whenever it loads a copy of your program, to run it.</source>
          <target state="translated">Во время выполнения загрузчик системной программы будет загружать копию &lt;code&gt;libz&lt;/code&gt; в тот же процесс, что и ваша программа, всякий раз, когда она загружает копию вашей программы, для ее запуска.</target>
        </trans-unit>
        <trans-unit id="e5bb89d8a1b39ec5a184b94a75ab271ed2ff9d91" translate="yes" xml:space="preserve">
          <source>At runtime, whenever your program refers to something that is defined in
&lt;code&gt;libz&lt;/code&gt;, that reference uses the definition exported by the copy of &lt;code&gt;libz&lt;/code&gt; in
the same process.</source>
          <target state="translated">Во время выполнения, когда ваша программа ссылается на что-то, определенное в &lt;code&gt;libz&lt;/code&gt; , эта ссылка использует определение, экспортированное копией &lt;code&gt;libz&lt;/code&gt; в том же процессе.</target>
        </trans-unit>
        <trans-unit id="8706fc513753f8a6ab494b836c139f955dd4de4b" translate="yes" xml:space="preserve">
          <source>Back in the day, it was normal for unix-like systems to link static and shared 
libraries by different rules. Static libraries in a linkage sequence were linked 
on the &lt;em&gt;as-needed&lt;/em&gt; basis explained in example 1, but shared libraries were linked unconditionally.</source>
          <target state="translated">Раньше для unix-подобных систем было нормальным связывать статические и разделяемые библиотеки по разным правилам. Статические библиотеки в последовательности связывания были связаны по &lt;em&gt;мере необходимости,&lt;/em&gt; объясненной в примере 1, но совместно используемые библиотеки были связаны безоговорочно.</target>
        </trans-unit>
        <trans-unit id="4a50aaa9dbdd42f72fdba6a8715e83c2a0a34f3f" translate="yes" xml:space="preserve">
          <source>Be careful that the function you implement exactly matches the one you declared. For example, you may have mismatched cv-qualifiers:</source>
          <target state="translated">Будьте осторожны,чтобы функция,которую вы реализуете,точно совпадала с той,которую вы объявили.Например,у вас может быть несовпадение cv-квалификаторов:</target>
        </trans-unit>
        <trans-unit id="380e27586685053a149a95794ec8ea13cd72b1ae" translate="yes" xml:space="preserve">
          <source>Because compiling and linking with a single command does not change the
order of the linkage sequence.</source>
          <target state="translated">Потому что компиляция и связывание с помощью одной команды не изменяет порядок следования связывания.</target>
        </trans-unit>
        <trans-unit id="791862e9f3cc350adeb09357b5234c80bae1d2ca" translate="yes" xml:space="preserve">
          <source>Befriending templates...</source>
          <target state="translated">Поддерживающие шаблоны...</target>
        </trans-unit>
        <trans-unit id="0cadc8aa8215fefdf5f07d0ddc606c6dc435a0e8" translate="yes" xml:space="preserve">
          <source>Boom! You get a linker error and you have no idea why it's failing. The reason is that the common library uses different versions of the same include &lt;code&gt;common_math.h&lt;/code&gt; (I have made it obvious here in the example by including a different path, but it might not always be so obvious. Maybe the include path is different in the compiler settings).</source>
          <target state="translated">Boom! Вы получаете ошибку компоновщика, и вы не знаете, почему он не работает. Причина в том, что общая библиотека использует разные версии одного и того же &lt;code&gt;common_math.h&lt;/code&gt; (здесь я продемонстрировал это в примере, добавив другой путь, но это не всегда так очевидно. Возможно, путь включения отличается в настройки компилятора).</target>
        </trans-unit>
        <trans-unit id="6bcaff46ce13c984e730553cee278ae1c9aa1951" translate="yes" xml:space="preserve">
          <source>Building one library with &lt;code&gt;UNICODE&lt;/code&gt; defined and attempting to link it in a project where &lt;code&gt;UNICODE&lt;/code&gt; is not defined will result in linker errors since there will be a mismatch in the definition of &lt;code&gt;TCHAR&lt;/code&gt;; &lt;code&gt;char&lt;/code&gt; vs. &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">Создание одной библиотеки с определенным &lt;code&gt;UNICODE&lt;/code&gt; и попытка связать ее в проекте, где &lt;code&gt;UNICODE&lt;/code&gt; не определен, приведет к ошибкам компоновщика, так как в определении &lt;code&gt;TCHAR&lt;/code&gt; будет несоответствие; &lt;code&gt;char&lt;/code&gt; против &lt;code&gt;wchar_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f699eafa666c4c4782584970203254bd4526ddb" translate="yes" xml:space="preserve">
          <source>But all the undefined &lt;em&gt;something&lt;/em&gt;s are declared in the header files you have
&lt;code&gt;#include&lt;/code&gt;d and are in fact defined in the libraries that you are linking.</source>
          <target state="translated">Но все неопределенные &lt;em&gt;что-то&lt;/em&gt; s объявляются в заголовочных файлах, которые у вас есть &lt;code&gt;#include&lt;/code&gt; d, и фактически определяются в библиотеках, которые вы связываете.</target>
        </trans-unit>
        <trans-unit id="04aa72c8afa3b9d7e1037f71bfc89ece6d7cb2d0" translate="yes" xml:space="preserve">
          <source>But when you try to link the program like:</source>
          <target state="translated">Но когда вы пытаетесь связать программу,например:</target>
        </trans-unit>
        <trans-unit id="e3bc3b59b5238ebf3734cce36298c84c3eecbc4c" translate="yes" xml:space="preserve">
          <source>By default, a linkage command generated by GCC, on your distro,
consumes the files in the linkage from left to right in
commandline sequence. When it finds that a file refers to &lt;em&gt;something&lt;/em&gt;
and does not contain a definition for it, to will search for a definition
in files further to the right. If it eventually finds a definition, the
reference is resolved. If any references remain unresolved at the end,
the linkage fails: the linker does not search backwards.</source>
          <target state="translated">По умолчанию команда связывания, сгенерированная GCC в вашем дистрибутиве, использует файлы в связке слева направо в последовательности командной строки. Когда он обнаруживает, что файл ссылается на &lt;em&gt;что-то&lt;/em&gt; и не содержит определения для него, он будет искать определение в файлах далее справа. Если это в конечном счете находит определение, ссылка разрешена. Если какие-либо ссылки остаются неразрешенными в конце, связывание завершается ошибкой: компоновщик не выполняет поиск в обратном направлении.</target>
        </trans-unit>
        <trans-unit id="3eaf522e8926f987e615fe35f7fd9fdf75b655f7" translate="yes" xml:space="preserve">
          <source>Circular library dependency</source>
          <target state="translated">Циркулярная библиотечная зависимость</target>
        </trans-unit>
        <trans-unit id="7241f66efa6b5c24d3508077d13fb171cabcc233" translate="yes" xml:space="preserve">
          <source>Class members:</source>
          <target state="translated">Члены класса:</target>
        </trans-unit>
        <trans-unit id="aab52d092675fa0fe32cd101b3b21eff5dd78e87" translate="yes" xml:space="preserve">
          <source>Clean and rebuild</source>
          <target state="translated">Чистота и восстановление</target>
        </trans-unit>
        <trans-unit id="736a421be03fcda0d1784f7e1b58d5c6120e87ca" translate="yes" xml:space="preserve">
          <source>Clean the project (some IDEs have an option to do this, you can also
manually do it by deleting the object files)</source>
          <target state="translated">Очистить проект (в некоторых IDE это можно сделать вручную,удалив объектные файлы).</target>
        </trans-unit>
        <trans-unit id="3da20e0c7008360402f61cc375be71c5a21c62fe" translate="yes" xml:space="preserve">
          <source>Common causes include:</source>
          <target state="translated">Обычные причины включают в себя:</target>
        </trans-unit>
        <trans-unit id="1d20937e648b620d3e08501c7d2a0f7ca4d36b1e" translate="yes" xml:space="preserve">
          <source>Common error messages are &lt;code&gt;error LNK2001&lt;/code&gt;, &lt;code&gt;error LNK1120&lt;/code&gt;, &lt;code&gt;error LNK2019&lt;/code&gt; for &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt; and &lt;code&gt;undefined reference to&lt;/code&gt;&lt;em&gt;symbolName&lt;/em&gt; for &lt;strong&gt;GCC&lt;/strong&gt;.</source>
          <target state="translated">Распространенные сообщения об ошибках: &lt;code&gt;error LNK2001&lt;/code&gt; , &lt;code&gt;error LNK1120&lt;/code&gt; , &lt;code&gt;error LNK2019&lt;/code&gt; для &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt; и &lt;code&gt;undefined reference to&lt;/code&gt; &lt;em&gt;symbolName&lt;/em&gt; для &lt;strong&gt;GCC&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c3af93c7541eebebfdafcdd1eacb37d4febb317b" translate="yes" xml:space="preserve">
          <source>Common issues with class-type members</source>
          <target state="translated">Общие вопросы с членами класса</target>
        </trans-unit>
        <trans-unit id="7ad8095ab9f470817988dae41ebaff6c8b167424" translate="yes" xml:space="preserve">
          <source>Commonly, each translation unit will generate an object file that contains the definitions of the symbols defined in that translation unit. 
To use those symbols, you have to link against those object files.</source>
          <target state="translated">Обычно в каждом блоке перевода создается объектный файл,содержащий определения символов,определенных в этом блоке перевода.Чтобы использовать эти символы,необходимо сделать ссылку на эти объектные файлы.</target>
        </trans-unit>
        <trans-unit id="e08db17708c9f5aa2791cb6be1dcc8a1c79a541b" translate="yes" xml:space="preserve">
          <source>Compile your program:</source>
          <target state="translated">Скомпилируй свою программу:</target>
        </trans-unit>
        <trans-unit id="db2b08b37977716ce6fab5afd8fb8ea79479ade1" translate="yes" xml:space="preserve">
          <source>Compile:</source>
          <target state="translated">Compile:</target>
        </trans-unit>
        <trans-unit id="679b3ff1ac1d63bde340799dcca67fa30e040c64" translate="yes" xml:space="preserve">
          <source>Compiler Time Error :</source>
          <target state="translated">Ошибка времени компилятора :</target>
        </trans-unit>
        <trans-unit id="c97768ea4c3948ab173981d2a5209cf05f227f68" translate="yes" xml:space="preserve">
          <source>Compiling a C++ program takes place in several steps, as specified by &lt;strong&gt;2.2&lt;/strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/8834196&quot;&gt;(credits to Keith Thompson for the reference)&lt;/a&gt;:</source>
          <target state="translated">Компиляция программы на C ++ происходит в несколько этапов, как указано в &lt;strong&gt;2.2&lt;/strong&gt; &lt;a href=&quot;https://stackoverflow.com/a/8834196&quot;&gt;(благодарность Кита Томпсону за справку)&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c137971fb4bd72b08a0b43c3008b2cca54a397e2" translate="yes" xml:space="preserve">
          <source>Create the libraries:</source>
          <target state="translated">Создавайте библиотеки:</target>
        </trans-unit>
        <trans-unit id="7eaf2baed01488559bf5876cc3e60f17aa0d3628" translate="yes" xml:space="preserve">
          <source>DUMPBIN is your friend, if you are using Visual Studio. I'm sure other compilers have other similar tools.</source>
          <target state="translated">DUMPBIN-ваш друг,если вы используете Visual Studio.Уверен,что в других компиляторах есть и другие подобные инструменты.</target>
        </trans-unit>
        <trans-unit id="719eb91a47aa71cdb65cf6c453c5e6fe62c3c90d" translate="yes" xml:space="preserve">
          <source>Data on what libraries are included in the link stage,</source>
          <target state="translated">Данные о том,какие библиотеки включены на этапе компоновки,</target>
        </trans-unit>
        <trans-unit id="6773b3ac6ff9506cd52f19d8964c02fa4b90c9ba" translate="yes" xml:space="preserve">
          <source>Debugging the linker</source>
          <target state="translated">Отладка линкера</target>
        </trans-unit>
        <trans-unit id="849dcbe64c263df85f9b32a99f2eccecff6c214f" translate="yes" xml:space="preserve">
          <source>Declared and undefined variable or function.</source>
          <target state="translated">Объявленная и неопределенная переменная или функция.</target>
        </trans-unit>
        <trans-unit id="06460cd515ea02640e903aed7e4d4bb81068a27c" translate="yes" xml:space="preserve">
          <source>Declared but did not define a variable or function.</source>
          <target state="translated">Объявил,но не определил переменную или функцию.</target>
        </trans-unit>
        <trans-unit id="b75a543cd5362fb62c8422904fb2c049dcec7474" translate="yes" xml:space="preserve">
          <source>Declaring a destructor pure still requires you to define it (unlike a regular function):</source>
          <target state="translated">Объявление деструктора чистым по-прежнему требует его определения (в отличие от обычной функции):</target>
        </trans-unit>
        <trans-unit id="567a15d424904d304f2d20a37eae9e3dd0be401d" translate="yes" xml:space="preserve">
          <source>Define all your symbol which you declare in your header files</source>
          <target state="translated">Укажите все символы,которые вы объявляете в заголовочных файлах.</target>
        </trans-unit>
        <trans-unit id="f5fce9ce350b9263578dfa2c8ab33e5e4582b42f" translate="yes" xml:space="preserve">
          <source>Definition does not exist</source>
          <target state="translated">Определения не существует</target>
        </trans-unit>
        <trans-unit id="1023459cba9e87450771da5a88dadcad9181c40b" translate="yes" xml:space="preserve">
          <source>Definition exists</source>
          <target state="translated">Определение существует</target>
        </trans-unit>
        <trans-unit id="1f545375f3315c66c74f5b0635778013cb0153c5" translate="yes" xml:space="preserve">
          <source>Different versions of libraries</source>
          <target state="translated">Различные версии библиотек</target>
        </trans-unit>
        <trans-unit id="0bee44622c3c31248d76530e7b83a53af7e4ae63" translate="yes" xml:space="preserve">
          <source>Do not forget to be consistent between the &quot;Release&quot; and &quot;Debug&quot; builds as well.</source>
          <target state="translated">Не забывайте быть последовательными и между сборками &quot;Release&quot; и &quot;Debug&quot;.</target>
        </trans-unit>
        <trans-unit id="62a321049a9684009d639a42bfcab348659b0468" translate="yes" xml:space="preserve">
          <source>Dump the exported symbols from the library into a text file.</source>
          <target state="translated">Выдавите экспортированные символы из библиотеки в текстовый файл.</target>
        </trans-unit>
        <trans-unit id="6ee565a8ad9a2e6032a63ac1db58b7bceef88bc8" translate="yes" xml:space="preserve">
          <source>EDIT 1: Rewrote first section to be easier to understand. Please comment below to let me know if something else needs to be fixed. Thanks!</source>
          <target state="translated">EDIT 1:Переписать первый раздел,чтобы было легче понять.Пожалуйста,прокомментируйте ниже,чтобы сообщить мне,если что-то еще нужно исправить.Спасибо!</target>
        </trans-unit>
        <trans-unit id="80d3f81150da8848a606c766ad627406abc917e5" translate="yes" xml:space="preserve">
          <source>Each instance of a backslash character (\) immediately followed by a new-line character is deleted, splicing physical source lines to
  form logical source lines. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">Каждый экземпляр символа обратной косой черты (\), за которым сразу следует символ новой строки, удаляется, объединяя физические исходные строки для формирования логических исходных строк. &lt;em&gt;[СНиП]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8873c9e0ad822c5ad29c877287ca38e9d0fb8223" translate="yes" xml:space="preserve">
          <source>Each source character set member in a character literal or a string literal, as well as each escape sequence and universal-character-name
  in a character literal or a non-raw string literal, is converted to
  the corresponding member of the execution character set; &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">Каждый элемент исходного набора символов в символьном литерале или строковом литерале, а также каждая escape-последовательность и универсальное имя-символа в символьном литерале или неочищенном строковом литерале преобразуется в соответствующий элемент набора исполняемых символов; &lt;em&gt;[СНиП]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd08fa75ce4c1bea641e5c3ae90f422742fd49a5" translate="yes" xml:space="preserve">
          <source>Equivalently, instead of being defined in a C program, the function (or variable) &lt;code&gt;void foo()&lt;/code&gt; was defined in C++ but with C linkage:</source>
          <target state="translated">Эквивалентно, вместо того, чтобы быть определенным в программе на C, функция (или переменная) &lt;code&gt;void foo()&lt;/code&gt; была определена в C ++, но с привязкой к C:</target>
        </trans-unit>
        <trans-unit id="50e31b9308416dd3a4f92b2300aa9833c975e02b" translate="yes" xml:space="preserve">
          <source>Even though this is a pretty old questions with multiple accepted answers, I'd like to share how to resolve an &lt;strong&gt;obscure&lt;/strong&gt; &quot;undefined reference to&quot; error.</source>
          <target state="translated">Несмотря на то, что это довольно старые вопросы с несколькими принятыми ответами, я хотел бы поделиться тем, как устранить &lt;strong&gt;неясную&lt;/strong&gt; ошибку &amp;laquo;неопределенная ссылка на&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="0f313c64cf7c57de167dfc0b70285d2f1097cf2a" translate="yes" xml:space="preserve">
          <source>Examples are in C. They could equally well be C++</source>
          <target state="translated">Примеры на C.Они также могут быть на C++.</target>
        </trans-unit>
        <trans-unit id="6c8eeaf8a4d91827c91eda47c067002b02303f4f" translate="yes" xml:space="preserve">
          <source>Failure to link against appropriate libraries/object files or compile implementation files</source>
          <target state="translated">Невозможность связать с соответствующими библиотечными файлами-объектами или скомпилировать реализационные файлы</target>
        </trans-unit>
        <trans-unit id="c24bada60625ab3c77ffebca4ef956b5b8222f43" translate="yes" xml:space="preserve">
          <source>First, &lt;strong&gt;example 1&lt;/strong&gt;, with static library &lt;code&gt;my_lib.a&lt;/code&gt;</source>
          <target state="translated">Сначала &lt;strong&gt;пример 1&lt;/strong&gt; со статической библиотекой &lt;code&gt;my_lib.a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c8a30a094da8c776a823c101decae831165f64e" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;XCode&lt;/strong&gt;:  Add the User Header Search Paths -&amp;gt; add the Library Search Path -&amp;gt; drag and drop the actual library reference into the project folder.</source>
          <target state="translated">Для &lt;strong&gt;XCode&lt;/strong&gt; : добавьте пути поиска по заголовку пользователя -&amp;gt; добавьте путь поиска по библиотеке -&amp;gt; перетащите фактическую ссылку на библиотеку в папку проекта.</target>
        </trans-unit>
        <trans-unit id="ba1b34dc3bbed11c2c9a66d05612d54f9428db05" translate="yes" xml:space="preserve">
          <source>For MSVC, &lt;code&gt;/VERBOSE&lt;/code&gt; (in particular &lt;code&gt;/VERBOSE:LIB&lt;/code&gt;) is added to the link command line.</source>
          <target state="translated">Для MSVC &lt;code&gt;/VERBOSE&lt;/code&gt; (в частности, &lt;code&gt;/VERBOSE:LIB&lt;/code&gt; ) добавляется в командную строку ссылки.</target>
        </trans-unit>
        <trans-unit id="0ac9cca66a7ce03b39143760b921f502a3b2b9ee" translate="yes" xml:space="preserve">
          <source>For each file with extension .cpp is generated an object file .o and also Visual Studio writes the output in a file named &lt;em&gt;ProjectName.Cpp.Clean.txt&lt;/em&gt; which contains all object files that must be processed by the linker.</source>
          <target state="translated">Для каждого файла с расширением .cpp создается объектный файл .o, а также Visual Studio записывает выходные данные в файл с именем &lt;em&gt;ProjectName.Cpp.Clean.txt,&lt;/em&gt; который содержит все объектные файлы, которые должны обрабатываться компоновщиком.</target>
        </trans-unit>
        <trans-unit id="ce276678b262778ed8f87dcee2e92b419fef8499" translate="yes" xml:space="preserve">
          <source>For example we have some code</source>
          <target state="translated">Например,у нас есть какой-то код</target>
        </trans-unit>
        <trans-unit id="2fa6951fcb69e2353b69b4e4f3615ca4d9cc266b" translate="yes" xml:space="preserve">
          <source>For example, if we have a function called foo defined in a.cpp:</source>
          <target state="translated">Например,если у нас есть функция под названием foo,определенная в a.cpp:</target>
        </trans-unit>
        <trans-unit id="5c105ae3962497b6a56958a1bf2d2d4a31d03dae" translate="yes" xml:space="preserve">
          <source>For example, the following would generate an error:</source>
          <target state="translated">Например,ошибка будет вызвана следующими действиями:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="f2fcc968e71dd0b01c575698c3cd328beb1f8547" translate="yes" xml:space="preserve">
          <source>For further explanation and another possible solution (explicit instantiation) see &lt;a href=&quot;https://stackoverflow.com/questions/495021&quot;&gt;this question and answer&lt;/a&gt;.</source>
          <target state="translated">Для дальнейшего объяснения и другого возможного решения (явной реализации) см. &lt;a href=&quot;https://stackoverflow.com/questions/495021&quot;&gt;Этот вопрос и ответ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d26f3d31b9f80c9041094ecd1bfa2cf4a14f452" translate="yes" xml:space="preserve">
          <source>For gcc and clang; you would typically add &lt;code&gt;-v -Wl,--verbose&lt;/code&gt; or &lt;code&gt;-v -Wl,-v&lt;/code&gt; to the command line. More details can be found here;</source>
          <target state="translated">Для gcc и clang; вы обычно добавляете &lt;code&gt;-v -Wl,--verbose&lt;/code&gt; или &lt;code&gt;-v -Wl,-v&lt;/code&gt; в командную строку. Более подробную информацию можно найти здесь;</target>
        </trans-unit>
        <trans-unit id="44635ad90325eff295e74bdeb91fbd8d078fabb1" translate="yes" xml:space="preserve">
          <source>For people coming from C it might be a surprise that in C++ global &lt;code&gt;const&lt;/code&gt;variables have internal (or static) linkage. In C this was not the case, as all global variables are implicitly &lt;code&gt;extern&lt;/code&gt; (i.e. when the &lt;code&gt;static&lt;/code&gt; keyword is missing).</source>
          <target state="translated">Для людей, пришедших из C, может быть удивительным, что в C ++ глобальные &lt;code&gt;const&lt;/code&gt; переменные имеют внутреннюю (или статическую) связь. В Си это было не так, поскольку все глобальные переменные неявно являются &lt;code&gt;extern&lt;/code&gt; (то есть, когда отсутствует ключевое слово &lt;code&gt;static&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="02ff37d17fe54fa59b6bdb89b9051f68c4f95602" translate="yes" xml:space="preserve">
          <source>For this to work, declare &lt;code&gt;X::foo()&lt;/code&gt; as pure:</source>
          <target state="translated">Чтобы это работало, объявите &lt;code&gt;X::foo()&lt;/code&gt; чистым:</target>
        </trans-unit>
        <trans-unit id="d3b72bbcef1b0d4a5a3e0732613861aff970d936" translate="yes" xml:space="preserve">
          <source>Function return type, parameter number and types, and calling convention do not all exactly agree.</source>
          <target state="translated">Тип возвращаемой функции,номер и типы параметров,а также соглашение о вызове не совсем совпадают.</target>
        </trans-unit>
        <trans-unit id="adc354e3ed859611982bdeb24ea70c92b2b599b8" translate="yes" xml:space="preserve">
          <source>Function/variable declared as class member, defined as global (or vice versa).</source>
          <target state="translated">Функциональная переменная,объявленная как член класса,определенная как глобальная (или наоборот).</target>
        </trans-unit>
        <trans-unit id="c9e1736897f86f0f0ebd9367dfa1e73b18c72dbc" translate="yes" xml:space="preserve">
          <source>Function/variable declared in one namespace, defined in another.</source>
          <target state="translated">Функциональная переменная,объявленная в одном пространстве имен,определенная в другом.</target>
        </trans-unit>
        <trans-unit id="47885f9296315b51d23680105388ad37c4f8daa9" translate="yes" xml:space="preserve">
          <source>Further elaboration with an example</source>
          <target state="translated">Дальнейшая разработка на примере</target>
        </trans-unit>
        <trans-unit id="1109ab69f5f30dff37d3dd93730a44c1ec557703" translate="yes" xml:space="preserve">
          <source>Given the code snippet of a template type with a friend operator (or function);</source>
          <target state="translated">Приведен фрагмент кода типа шаблона с оператором (или функцией)&quot;Друг&quot;;</target>
        </trans-unit>
        <trans-unit id="87a3d534ea37016d34d8be0559ae5f64128cdd0b" translate="yes" xml:space="preserve">
          <source>Here are &lt;a href=&quot;https://stackoverflow.com/questions/24715864/problems-importing-libraries-to-my-c-project-how-to-fix-this/24715865#24715865&quot;&gt;case1&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16&quot;&gt;case2&lt;/a&gt; handled in more detail from a &lt;em&gt;real world&lt;/em&gt; problem.</source>
          <target state="translated">Здесь &lt;a href=&quot;https://stackoverflow.com/questions/24715864/problems-importing-libraries-to-my-c-project-how-to-fix-this/24715865#24715865&quot;&gt;case1&lt;/a&gt; и &lt;a href=&quot;https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16&quot;&gt;case2&lt;/a&gt; рассматриваются более подробно из &lt;em&gt;реальной&lt;/em&gt; проблемы.</target>
        </trans-unit>
        <trans-unit id="b457236fd45d4cf88f436ca559e82a847ed891f5" translate="yes" xml:space="preserve">
          <source>How do linkers work? The linker matches a function declaration (declared in the header) with its definition (in the shared library) by comparing their signatures. You can get a linker error if the linker doesn't find a function definition that matches perfectly.</source>
          <target state="translated">Как работают линкеры? Линкер сопоставляет декларацию функции (объявленную в заголовке)с ее определением (в разделяемой библиотеке)путем сравнения их подписей.Вы можете получить ошибку компоновщика,если компоновщик не найдет идеально совпадающего определения функции.</target>
        </trans-unit>
        <trans-unit id="a4bca897be232f23b6899495a9467715ee2ea072" translate="yes" xml:space="preserve">
          <source>I can reproduce the problem in example 1, but not in example 2</source>
          <target state="translated">Я могу воспроизвести проблему в примере 1,но не в примере 2.</target>
        </trans-unit>
        <trans-unit id="f16eb78437de212d219271bcd70b1ba35516fa2e" translate="yes" xml:space="preserve">
          <source>I edited the package (in the &lt;code&gt;packages&lt;/code&gt; folder inside the solution's directory) by finding &lt;code&gt;packagename\build\native\packagename.targets&lt;/code&gt; and inside that file, copying all the &lt;code&gt;v110&lt;/code&gt; sections.  I changed the &lt;code&gt;v110&lt;/code&gt; to &lt;code&gt;v120&lt;/code&gt; in &lt;strong&gt;the condition fields only&lt;/strong&gt; being very careful to leave the filename paths all as &lt;code&gt;v110&lt;/code&gt;.  This simply allowed Visual Studio 2013 to link to the libraries for 2012, and in this case, it worked.</source>
          <target state="translated">Я отредактировал пакет (в папке &lt;code&gt;packages&lt;/code&gt; внутри каталога решения), найдя &lt;code&gt;packagename\build\native\packagename.targets&lt;/code&gt; и внутри этого файла, скопировав все разделы &lt;code&gt;v110&lt;/code&gt; . Я изменил &lt;code&gt;v110&lt;/code&gt; на &lt;code&gt;v120&lt;/code&gt; в &lt;strong&gt;полях условия, только&lt;/strong&gt; очень осторожно оставляя пути к именам файлов как &lt;code&gt;v110&lt;/code&gt; . Это просто позволило Visual Studio 2013 ссылаться на библиотеки на 2012 год, и в этом случае это работало.</target>
        </trans-unit>
        <trans-unit id="e185b3c33f0b4245c7351066033029dca1ef7148" translate="yes" xml:space="preserve">
          <source>I had the same issue. Say i have projects MyProject and TestProject. I had effectively linked the lib file for MyProject to the TestProject. However, this lib file was produced as the DLL for the MyProject was built. Also, I did not contain source code for all methods in the MyProject, but only access to the DLL's entry points.</source>
          <target state="translated">У меня была такая же проблема.Скажем,у меня есть проекты MyProject и TestProject.Я эффективно связал lib файл для MyProject с TestProject.Однако этот lib-файл был создан в процессе сборки DLL для MyProject.Также я не содержал исходный код всех методов в MyProject,а только доступ к точкам входа DLL.</target>
        </trans-unit>
        <trans-unit id="0436bfc3fe0e52928141662af3daf087596cf26f" translate="yes" xml:space="preserve">
          <source>I have two projects: &lt;code&gt;graphics.lib&lt;/code&gt; and &lt;code&gt;main.exe&lt;/code&gt;. Both projects depend on &lt;code&gt;common_math.h&lt;/code&gt;. Suppose the library exports the following function:</source>
          <target state="translated">У меня есть два проекта: &lt;code&gt;graphics.lib&lt;/code&gt; и &lt;code&gt;main.exe&lt;/code&gt; . Оба проекта зависят от &lt;code&gt;common_math.h&lt;/code&gt; . Предположим, библиотека экспортирует следующую функцию:</target>
        </trans-unit>
        <trans-unit id="956a2ac958701d2f4ab6fa4fc484437f762915e0" translate="yes" xml:space="preserve">
          <source>I just had this problem trying to link libpng with Visual Studio 2013.  The problem is that the package file only had libraries for Visual Studio 2010 and 2012.</source>
          <target state="translated">У меня просто возникла проблема при попытке связать libpng с Visual Studio 2013.Проблема в том,что в пакетном файле были только библиотеки для Visual Studio 2010 и 2012.</target>
        </trans-unit>
        <trans-unit id="e9b8b4b047b3721fecc60f4fca5ece4ff41298b6" translate="yes" xml:space="preserve">
          <source>I recently had this problem, and it turned out &lt;a href=&quot;https://stackoverflow.com/questions/27748699/unresolved-reference-to-constructor-which-is-defined/27748920#27748920&quot;&gt;it was a bug in Visual Studio Express 2013&lt;/a&gt;. I had to remove a source file from the project and re-add it to overcome the bug.</source>
          <target state="translated">У меня недавно была эта проблема, и оказалось, что &lt;a href=&quot;https://stackoverflow.com/questions/27748699/unresolved-reference-to-constructor-which-is-defined/27748920#27748920&quot;&gt;это была ошибка в Visual Studio Express 2013&lt;/a&gt; . Мне пришлось удалить исходный файл из проекта и повторно добавить его, чтобы устранить ошибку.</target>
        </trans-unit>
        <trans-unit id="1f2758b006cc08918b9f02973af12be1faec02a9" translate="yes" xml:space="preserve">
          <source>I was recently able to get rid of an unresolved external error in Visual Studio 2012 just by recompiling the offending file. When I re-built, the error went away.</source>
          <target state="translated">Недавно мне удалось избавиться от неразрешённой внешней ошибки в Visual Studio 2012,просто перекомпилировав файл-нарушитель.Когда я перекомпилировал,ошибка исчезла.</target>
        </trans-unit>
        <trans-unit id="3655c386da677b651bbf58700cb3b35ab01cf79c" translate="yes" xml:space="preserve">
          <source>I was using an alias to refer to &lt;code&gt;std::filesystem::path&lt;/code&gt;: filesystem is in the standard library since C++17 but my program needed to &lt;strong&gt;also compile in C++14&lt;/strong&gt; so I decided to use a variable alias:</source>
          <target state="translated">Я использовал псевдоним для ссылки на &lt;code&gt;std::filesystem::path&lt;/code&gt; : filesystem в стандартной библиотеке начиная с C ++ 17, но моя программа должна была &lt;strong&gt;также компилироваться в C ++ 14,&lt;/strong&gt; поэтому я решил использовать переменный псевдоним:</target>
        </trans-unit>
        <trans-unit id="5173770afade73bcecf7a320d6a1ae32ba13af7d" translate="yes" xml:space="preserve">
          <source>I'll try to explain what is an &quot;undefined reference/unresolved external symbol&quot;.</source>
          <target state="translated">Я постараюсь объяснить,что такое &quot;неопределенный не разрешенный опорный внешний символ&quot;.</target>
        </trans-unit>
        <trans-unit id="a04cfe5805e064fc6a684cbba78e89796fa1eff1" translate="yes" xml:space="preserve">
          <source>I've rejected some lines from output, because they do not matter</source>
          <target state="translated">Я отказался от некоторых строк на выходе,потому что они не имеют значения.</target>
        </trans-unit>
        <trans-unit id="2bb7febe7f23a580135ec4f7b408f003af4cb53e" translate="yes" xml:space="preserve">
          <source>If .cpp files depends on   additional .h files  in order to find symbols
that may or may not be defined in the file .cpp</source>
          <target state="translated">Если файлы .cpp зависят от дополнительных .h-файлов для поиска символов,которые могут быть или не быть определены в файле .cpp.</target>
        </trans-unit>
        <trans-unit id="df67f3ef9d0be7171f81833f9b68966903db7af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;libfoo&lt;/code&gt; depends on &lt;code&gt;libbar&lt;/code&gt;, then your linkage correctly puts &lt;code&gt;libfoo&lt;/code&gt; before &lt;code&gt;libbar&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;libfoo&lt;/code&gt; зависит от &lt;code&gt;libbar&lt;/code&gt; , то ваша связь правильно помещает &lt;code&gt;libfoo&lt;/code&gt; перед &lt;code&gt;libbar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="461d3e959eb928d5e96fcebb9ba3f3fe9ab2bb40" translate="yes" xml:space="preserve">
          <source>If I just do:</source>
          <target state="translated">Если я просто сделаю это:</target>
        </trans-unit>
        <trans-unit id="da08d2f992c3ccba47f676d81d16d167ac1f33a4" translate="yes" xml:space="preserve">
          <source>If Linker finds an external symbol in one static library he includes the symbol in the output of the project.However, if the library is shared( dynamic ) he doesn't include the code ( symbols ) in output, but  &lt;em&gt;Run-Time&lt;/em&gt; crashes may occur</source>
          <target state="translated">Если компоновщик находит внешний символ в одной статической библиотеке, он включает этот символ в выходные данные проекта. Однако, если библиотека является общей (динамической), он не включает код (символы) в выходные данные, но сбой во время выполнения может происходить</target>
        </trans-unit>
        <trans-unit id="980c254b69ed02be4226999c6e10d518c5a452c3" translate="yes" xml:space="preserve">
          <source>If an entire library is included in a header file (and was compiled as C code); the include will need to be as follows;</source>
          <target state="translated">Если вся библиотека включена в заголовочный файл (и скомпилирована как C-код),то включить нужно будет следующим образом;</target>
        </trans-unit>
        <trans-unit id="f26256c9ecf88ebe6b32a09b8f863a10b618c2ed" translate="yes" xml:space="preserve">
          <source>If exists one .cpp file in which the compiler could not find one symbol, a &lt;strong&gt;compiler time error&lt;/strong&gt; raises the message &lt;em&gt;Symbol x could not be found&lt;/em&gt;</source>
          <target state="translated">Если существует один файл .cpp, в котором компилятор не может найти один символ, &lt;strong&gt;ошибка времени компилятора&lt;/strong&gt; вызывает сообщение &lt;em&gt;Символ x не найден&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b01078c7a78e15aafb190fba7f0e6960757acba2" translate="yes" xml:space="preserve">
          <source>If one symbol could not be found in object files he also is searched in Additional Libraries.For adding a new library to a project &lt;strong&gt;Configuration properties&lt;/strong&gt; -&amp;gt; &lt;strong&gt;VC++ Directories&lt;/strong&gt;  -&amp;gt; &lt;strong&gt;Library Directories&lt;/strong&gt; and here you specified additional folder for searching libraries and &lt;strong&gt;Configuration properties&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Linker&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Input&lt;/strong&gt; for specifying the name of the library. 
-If the Linker could not find the symbol which you write in one .cpp he raises a &lt;strong&gt;linker time error&lt;/strong&gt; which may sound like 
&lt;code&gt;error LNK2001: unresolved external symbol &quot;void __cdecl foo(void)&quot; (?foo@@YAXXZ)&lt;/code&gt;</source>
          <target state="translated">Если один символ не может быть найден в объектных файлах, его также ищут в дополнительных библиотеках. Для добавления новой библиотеки в &lt;strong&gt;свойства конфигурации&lt;/strong&gt; проекта -&amp;gt; &lt;strong&gt;Каталоги VC ++&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Каталоги библиотеки,&lt;/strong&gt; и здесь вы указали дополнительную папку для поиска библиотек и &lt;strong&gt;Свойства конфигурации&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Линкер&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Вход&lt;/strong&gt; для указания имени библиотеки. -Если компоновщик не может найти символ, который вы пишете в одном .cpp, он вызывает &lt;strong&gt;ошибку времени компоновщика,&lt;/strong&gt; которая может звучать как &lt;code&gt;error LNK2001: unresolved external symbol &quot;void __cdecl foo(void)&quot; (?foo@@YAXXZ)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="499b77dbfc0604ee9598e32b2d28291c11fb0b8e" translate="yes" xml:space="preserve">
          <source>If that is true, then the linker will &lt;em&gt;not&lt;/em&gt; copy any chunks out of &lt;code&gt;libz&lt;/code&gt; and
add them to your program; instead, it will just doctor the code of your program 
so that:-</source>
          <target state="translated">Если это так, то компоновщик &lt;em&gt;не&lt;/em&gt; будет копировать какие-либо фрагменты из &lt;code&gt;libz&lt;/code&gt; и добавлять их в вашу программу; вместо этого он просто изменит код вашей программы, чтобы:</target>
        </trans-unit>
        <trans-unit id="2c00c20b5f535cd9bc44be19371d9b66f3b65283" translate="yes" xml:space="preserve">
          <source>If that is true, then the linker will extract a copy of &lt;code&gt;my_lib.o&lt;/code&gt; from the library and
add it to your program. Then, your program contains a definition for &lt;code&gt;hw&lt;/code&gt;, so
its references to &lt;code&gt;hw&lt;/code&gt; are &lt;em&gt;resolved&lt;/em&gt;.</source>
          <target state="translated">Если это так, то компоновщик извлечет копию &lt;code&gt;my_lib.o&lt;/code&gt; из библиотеки и добавит ее в вашу программу. Затем ваша программа содержит определение &lt;code&gt;hw&lt;/code&gt; , поэтому ее ссылки на &lt;code&gt;hw&lt;/code&gt; &lt;em&gt;разрешены&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="38c0025e9bec005d4513bd13d86176f0298b0557" translate="yes" xml:space="preserve">
          <source>If the implementation is outside the class definition, but in a header, the methods have to be marked as &lt;code&gt;inline&lt;/code&gt; to prevent a multiple definition.</source>
          <target state="translated">Если реализация находится за пределами определения класса, но в заголовке, методы должны быть помечены как &lt;code&gt;inline&lt;/code&gt; чтобы предотвратить множественное определение.</target>
        </trans-unit>
        <trans-unit id="75447576423c30e2c34a784049e8ce92fc59db32" translate="yes" xml:space="preserve">
          <source>If we want to call some functions in a library, but the import library is not added into the additional dependency list (set from: &lt;code&gt;Project | Properties | Configuration Properties | Linker | Input | Additional Dependency&lt;/code&gt;) of your project setting. Now the linker will report a LNK2019 since the definition does not exist in current searching scope.</source>
          <target state="translated">Если мы хотим вызвать некоторые функции в библиотеке, но библиотека импорта не добавляется в дополнительный список зависимостей (задается из: &lt;code&gt;Project | Properties | Configuration Properties | Linker | Input | Additional Dependency&lt;/code&gt; ) вашего проекта. Теперь компоновщик сообщит LNK2019, так как определение не существует в текущей области поиска.</target>
        </trans-unit>
        <trans-unit id="fb9269e2b18055a742c1557e6ab1048d1318a42e" translate="yes" xml:space="preserve">
          <source>If you get linker errors about undefined references to symbols that involve types in the std::__cxx11 namespace or the tag [abi:cxx11] then it probably indicates that you are trying to link together object files that were compiled with different values for the _GLIBCXX_USE_CXX11_ABI macro. This commonly happens when linking to a third-party library that was compiled with an older version of GCC. If the third-party library cannot be rebuilt with the new ABI then you will need to recompile your code with the old ABI.</source>
          <target state="translated">Если вы получаете ошибки компоновщика по поводу неопределенных ссылок на символы,включающие типы в пространстве имен std::__cxx11 или тег [abi:cxx11],то это,вероятно,указывает на то,что вы пытаетесь скомпоновать объектные файлы,которые были скомпилированы с разными значениями для макроса _GLIBCXX_USE_CXX11_ABI.Обычно это происходит при компоновке со сторонней библиотекой,которая была скомпилирована со старой версией GCC.Если сторонняя библиотека не может быть перекомпилирована с новым ABI,то вам потребуется перекомпилировать код со старым ABI.</target>
        </trans-unit>
        <trans-unit id="f035da38c9a7e86389d0510b74c92ffc7c0c115a" translate="yes" xml:space="preserve">
          <source>If you're using Microsoft Visual Studio, you'll see that projects generate &lt;code&gt;.lib&lt;/code&gt; files. These contain a table of exported symbols, and a table of imported symbols. The imported symbols are resolved against the libraries you link against, and the exported symbols are provided for the libraries that use that &lt;code&gt;.lib&lt;/code&gt; (if any).</source>
          <target state="translated">Если вы используете Microsoft Visual Studio, вы увидите, что проекты генерируют &lt;code&gt;.lib&lt;/code&gt; файлы. Они содержат таблицу экспортируемых символов и таблицу импортированных символов. Импортированные символы сопоставляются с библиотеками, с которыми вы ссылаетесь, и экспортируемые символы предоставляются для библиотек, которые используют этот &lt;code&gt;.lib&lt;/code&gt; (если есть).</target>
        </trans-unit>
        <trans-unit id="8833aea382a302f646216649f9921b661839e34c" translate="yes" xml:space="preserve">
          <source>If your IDE supports &lt;em&gt;Plain Console Projects&lt;/em&gt; you might want to choose this project type, instead of a windows application project.</source>
          <target state="translated">Если ваша IDE поддерживает &lt;em&gt;простые консольные проекты,&lt;/em&gt; вы можете выбрать этот тип проекта вместо проекта Windows.</target>
        </trans-unit>
        <trans-unit id="3f237fb8dc4cacf36f11d31545ebe99a25aef03b" translate="yes" xml:space="preserve">
          <source>In Windows programming, the tell-tale sign that you did not link a necessary library is that the name of the unresolved symbol begins with &lt;code&gt;__imp_&lt;/code&gt;. Look up the name of the function in the documentation, and it should say which library you need to use. For example, MSDN puts the information in a box at the bottom of each function in a section called &quot;Library&quot;.</source>
          <target state="translated">В программировании Windows контрольным признаком того, что вы не связали необходимую библиотеку, является то, что имя неразрешенного символа начинается с &lt;code&gt;__imp_&lt;/code&gt; . Посмотрите название функции в документации, и там должно быть указано, какую библиотеку вам нужно использовать. Например, MSDN помещает информацию в поле внизу каждой функции в разделе &amp;laquo;Библиотека&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="66430e667fc7f840b097b706996793b9736a8e56" translate="yes" xml:space="preserve">
          <source>In addition to the library path including the directory of the library, this should be the full name of the library.</source>
          <target state="translated">Кроме пути к библиотеке,включающего каталог библиотеки,это должно быть полное имя библиотеки.</target>
        </trans-unit>
        <trans-unit id="10bf6a64e5446398af8a3ba19c87d193fc7bdd0c" translate="yes" xml:space="preserve">
          <source>In b.cpp we want to call function foo, so we add</source>
          <target state="translated">В b.cpp мы хотим вызвать функцию foo,так что мы добавляем</target>
        </trans-unit>
        <trans-unit id="e04d65d1151fc1eecd729107e8faa2882c68cf4a" translate="yes" xml:space="preserve">
          <source>In general the IDE or build will include some form of &quot;clean&quot; function, but this may not be correctly configured (e.g. in a manual makefile) or may fail (e.g. the intermediate or resultant binaries are read-only).</source>
          <target state="translated">Обычно IDE или сборка включает в себя некую &quot;чистую&quot; функцию,но она может быть неправильно сконфигурирована (например,в ручном makefile)или может выйти из строя (например,промежуточные или результирующие двоичные файлы доступны только для чтения).</target>
        </trans-unit>
        <trans-unit id="6703e5641bd382c96b9757b2f2d5f1a0d78b8aef" translate="yes" xml:space="preserve">
          <source>In that case, it means that the available symbols are for a different architecture than the one you are compiling for.</source>
          <target state="translated">В этом случае это означает,что доступные символы предназначены для архитектуры,отличной от той,для которой вы компилируете.</target>
        </trans-unit>
        <trans-unit id="dc33cdb4c80f7ba7f9c92526e532ade7bc8fcd31" translate="yes" xml:space="preserve">
          <source>In the sequence of object files and libraries you want to link to make your
program, you are placing the libraries before the object files that refer to
them. You need to place the libraries &lt;em&gt;after&lt;/em&gt; the object files that refer
to them.</source>
          <target state="translated">В последовательности объектных файлов и библиотек, которые вы хотите связать для создания своей программы, вы размещаете библиотеки перед объектными файлами, которые к ним относятся. Вам нужно разместить библиотеки &lt;em&gt;после&lt;/em&gt; объектных файлов, которые к ним относятся.</target>
        </trans-unit>
        <trans-unit id="b2551cda3851296856857b433cfe97a4cfb2b4c9" translate="yes" xml:space="preserve">
          <source>Inconsistent &lt;code&gt;UNICODE&lt;/code&gt; definitions</source>
          <target state="translated">&lt;code&gt;UNICODE&lt;/code&gt; определения UNICODE</target>
        </trans-unit>
        <trans-unit id="6fe63eb632221a0ab5535bb76d4c287ae69ff6c4" translate="yes" xml:space="preserve">
          <source>Incorrectly importing/exporting methods/classes across modules/dll (compiler specific).</source>
          <target state="translated">Неправильный импорт классов методов через модулиdll (специфичные для компилятора).</target>
        </trans-unit>
        <trans-unit id="dcc92bce0411701f86858935b384ecc04c852ca4" translate="yes" xml:space="preserve">
          <source>Incorrectly importing/exporting methods/classes across modules/dll. (MSVS specific)</source>
          <target state="translated">Неправильно импортируются методы-классы импорта через модулиdll.(специфический для MSVS)</target>
        </trans-unit>
        <trans-unit id="cb120259d25bd6e5201a19869cfd5a9742881496" translate="yes" xml:space="preserve">
          <source>Interdependent library order</source>
          <target state="translated">Взаимозависимый библиотечный заказ</target>
        </trans-unit>
        <trans-unit id="503e384f0e4e309c11e3d62de8daa731f1a8d2b6" translate="yes" xml:space="preserve">
          <source>Is it possible to still get a linker error even though the declaration and the definition seem to match? Yes! They might look the same in source code, but it really depends on what the compiler sees. Essentially you could end up with a situation like this:</source>
          <target state="translated">Возможно ли по-прежнему получить ошибку компоновщика,несмотря на то,что декларация и определение кажутся совпадающими? Да! Они могут выглядеть одинаково в исходных текстах,но это действительно зависит от того,что видит компилятор.В принципе,можно оказаться в такой ситуации:</target>
        </trans-unit>
        <trans-unit id="771fa3988067ff8a58eabb454bbc75170f08c3d6" translate="yes" xml:space="preserve">
          <source>It can also happen that you forget to add the file to the compilation, in which case the object file won't be generated. In &lt;strong&gt;gcc&lt;/strong&gt; you'd add the files to the command line. In &lt;strong&gt;MSVS&lt;/strong&gt; adding the file to the project will make it compile it automatically (albeit files can, manually, be individually excluded from the build).</source>
          <target state="translated">Может также случиться, что вы забудете добавить файл в компиляцию, и в этом случае объектный файл не будет сгенерирован. В &lt;strong&gt;gcc&lt;/strong&gt; вы добавляете файлы в командную строку. В &lt;strong&gt;MSVS&lt;/strong&gt; добавление файла в проект заставит его автоматически скомпилировать (хотя файлы можно вручную исключить из сборки по отдельности).</target>
        </trans-unit>
        <trans-unit id="fe2ed6691d966ca4bdd41bbcc54c815e1cd0e42a" translate="yes" xml:space="preserve">
          <source>It has happened because our local_var_name is static, i.e. it is not visible for other modules. 
Now more deeply. Get the translation phase output</source>
          <target state="translated">Это произошло из-за того,что наше имя local_var_name статическое,т.е.оно не видно для других модулей.Теперь более глубоко.Получить вывод фазы перевода</target>
        </trans-unit>
        <trans-unit id="627cb145db504cc28647105b8ad1ef86f1340665" translate="yes" xml:space="preserve">
          <source>It is uneconomical at &lt;em&gt;runtime&lt;/em&gt;, because it can cause shared libraries to be
loaded along with a program even if doesn't need them.</source>
          <target state="translated">Это неэкономично во &lt;em&gt;время выполнения&lt;/em&gt; , поскольку может привести к загрузке совместно используемых библиотек вместе с программой, даже если они не нужны.</target>
        </trans-unit>
        <trans-unit id="13f85c801fb44532a6193ffc156ba3a1273c4b81" translate="yes" xml:space="preserve">
          <source>LLVM &lt;a href=&quot;http://llvm.org/releases/3.6.2/docs/CommandGuide/llvm-link.html#cmdoption-v&quot;&gt;linker page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://llvm.org/releases/3.6.2/docs/CommandGuide/llvm-link.html#cmdoption-v&quot;&gt;Страница компоновщика&lt;/a&gt; LLVM.</target>
        </trans-unit>
        <trans-unit id="f8b4459da7b6461b4c2299ccc79bca1d6aa1bc0f" translate="yes" xml:space="preserve">
          <source>Lastly, the &lt;code&gt;pkg-config&lt;/code&gt; variation of example 2 has a now obvious explanation.
After shell-expansion:</source>
          <target state="translated">Наконец, вариант &lt;code&gt;pkg-config&lt;/code&gt; примера 2 теперь имеет очевидное объяснение. После расширения оболочки:</target>
        </trans-unit>
        <trans-unit id="46640750de5d6c26ef3345516697c4c8de1c5c05" translate="yes" xml:space="preserve">
          <source>Let's say I have three files: main.cpp, file.h, file.cpp:</source>
          <target state="translated">Допустим,у меня есть три файла:main.cpp,file.h,file.cpp:</target>
        </trans-unit>
        <trans-unit id="8fb4c3c64119c8c2cdfc81bebdd5f927b932e0aa" translate="yes" xml:space="preserve">
          <source>Link example 1 correctly:</source>
          <target state="translated">Правильно соедините пример 1:</target>
        </trans-unit>
        <trans-unit id="bd65393a1e1fc0de6adb743f6af3918125bb0ecc" translate="yes" xml:space="preserve">
          <source>Link example 2 correctly:</source>
          <target state="translated">Правильно соедините пример 2:</target>
        </trans-unit>
        <trans-unit id="eff7b8e1e01a437aa7f86d07bd975b1d3e3d6b4f" translate="yes" xml:space="preserve">
          <source>Link invocation (command line),</source>
          <target state="translated">Призыв к соединению (командная строка),</target>
        </trans-unit>
        <trans-unit id="4da0c7603f707d809b67abb53db4ebf240bc0929" translate="yes" xml:space="preserve">
          <source>Link our object files</source>
          <target state="translated">Ссылайте наши объектные файлы</target>
        </trans-unit>
        <trans-unit id="b4235ce9a11da86196b06273997efb6e1bb09f1b" translate="yes" xml:space="preserve">
          <source>Link the example 2 &lt;code&gt;pkg-config&lt;/code&gt; variation correctly:</source>
          <target state="translated">Правильно &lt;code&gt;pkg-config&lt;/code&gt; пример варианта 2 pkg-config :</target>
        </trans-unit>
        <trans-unit id="a67761a97541734d3b1dd08a0be04d93cf4eb6b1" translate="yes" xml:space="preserve">
          <source>Linker Time Error</source>
          <target state="translated">Ошибка левого времени</target>
        </trans-unit>
        <trans-unit id="93df95814a97d8e558d63057388f44e8335ec3a6" translate="yes" xml:space="preserve">
          <source>Linker errors can happen when a header file and its associated shared library (.lib file) go out of sync. Let me explain.</source>
          <target state="translated">Ошибки компоновщика могут возникнуть,когда заголовочный файл и связанная с ним общая библиотека (.lib файл)выходят из синхронизации.Позвольте мне объяснить.</target>
        </trans-unit>
        <trans-unit id="2f12c9c12e76e06c4529ab38bf1b266c849ada4a" translate="yes" xml:space="preserve">
          <source>Linker sees exported symbols and links it. Now we try to uncomment lines in src2.cpp like here</source>
          <target state="translated">Линкер видит экспортируемые символы и связывает их.Теперь мы пытаемся разобрать строки в src2.cpp,как здесь.</target>
        </trans-unit>
        <trans-unit id="ff5d8fd0650014513ae22d4ad7c2df789c1613a9" translate="yes" xml:space="preserve">
          <source>Linux &lt;a href=&quot;http://linux.die.net/man/1/ld&quot;&gt;ld man page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://linux.die.net/man/1/ld&quot;&gt;Справочная страница по&lt;/a&gt; Linux ld .</target>
        </trans-unit>
        <trans-unit id="1602232f4b5e2f467a8d3b007a0131ae5384e107" translate="yes" xml:space="preserve">
          <source>MSVS requires you to specify which symbols to export and import using &lt;code&gt;__declspec(dllexport)&lt;/code&gt; and &lt;code&gt;__declspec(dllimport)&lt;/code&gt;.</source>
          <target state="translated">MSVS требует от вас указать, какие символы экспортировать и импортировать, используя &lt;code&gt;__declspec(dllexport)&lt;/code&gt; и &lt;code&gt;__declspec(dllimport)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="976f170a12de6c4ee60dc922bc6d9db457f350ab" translate="yes" xml:space="preserve">
          <source>Make object files</source>
          <target state="translated">Сделать объектные файлы</target>
        </trans-unit>
        <trans-unit id="daa6e7741bcaa1754abaefe5829b55e9e65ff067" translate="yes" xml:space="preserve">
          <source>Make sure that your external library doesn't contain symbols that may enter into conflict with other symbols you defined in your header files</source>
          <target state="translated">Убедитесь,что ваша внешняя библиотека не содержит символов,которые могут вступать в конфликт с другими символами,определенными в заголовочных файлах.</target>
        </trans-unit>
        <trans-unit id="9923a08fcadb46cb599ab38321c7d4b2a14511aa" translate="yes" xml:space="preserve">
          <source>Make sure you write your c++ project syntactical correct.</source>
          <target state="translated">Убедитесь,что Вы написали свой синтаксический код проекта c++правильно.</target>
        </trans-unit>
        <trans-unit id="90926b930049fc977cdcf047eff29fccda6c34ad" translate="yes" xml:space="preserve">
          <source>Many Linux distros today configure their GCC toolchain so that its language drivers (&lt;code&gt;gcc&lt;/code&gt;,&lt;code&gt;g++&lt;/code&gt;,&lt;code&gt;gfortran&lt;/code&gt; etc)
instruct the system linker (&lt;code&gt;ld&lt;/code&gt;) to link shared libraries on an &lt;em&gt;as-needed&lt;/em&gt; basis.
You have got one of those distros.</source>
          <target state="translated">Многие дистрибутивы Linux сегодня настраивают свой инструментарий GCC таким образом, чтобы его языковые драйверы ( &lt;code&gt;gcc&lt;/code&gt; , &lt;code&gt;g++&lt;/code&gt; , &lt;code&gt;gfortran&lt;/code&gt; и т. Д.) Инструктировали системному компоновщику ( &lt;code&gt;ld&lt;/code&gt; ) связывать совместно используемые библиотеки по &lt;em&gt;мере необходимости&lt;/em&gt; . У вас есть один из этих дистрибутивов.</target>
        </trans-unit>
        <trans-unit id="1ea292f71f513f2f49b3c0ecc19893f09a021ecf" translate="yes" xml:space="preserve">
          <source>Microsoft offers a &lt;code&gt;#pragma&lt;/code&gt; to reference the correct library at link time;</source>
          <target state="translated">Microsoft предлагает &lt;code&gt;#pragma&lt;/code&gt; для ссылки на правильную библиотеку во время ссылки;</target>
        </trans-unit>
        <trans-unit id="c84452b5c5beed02d4bfc0b6a144ddbc0f9f2c52" translate="yes" xml:space="preserve">
          <source>Missing &quot;extern&quot; in &lt;code&gt;const&lt;/code&gt; variable declarations/definitions (C++ only)</source>
          <target state="translated">Отсутствует &amp;laquo;extern&amp;raquo; в объявлениях / определениях переменных &lt;code&gt;const&lt;/code&gt; (только C ++)</target>
        </trans-unit>
        <trans-unit id="a0b0d93816c556d77f42fe7a2651c42eb165889f" translate="yes" xml:space="preserve">
          <source>Missing &quot;extern&quot; in const variable declarations/definitions (C++ only)</source>
          <target state="translated">Отсутствие &quot;extern&quot; в объявлениях-определениях константных переменных (только для C++)</target>
        </trans-unit>
        <trans-unit id="5eb6f3aa726cfe18f5057b4aefa2edb20315a029" translate="yes" xml:space="preserve">
          <source>Mistyping or not including the .lib extension when using the &lt;code&gt;#pragma&lt;/code&gt; (Microsoft Visual Studio)</source>
          <target state="translated">Неправильный ввод или отсутствие расширения .lib при использовании &lt;code&gt;#pragma&lt;/code&gt; (Microsoft Visual Studio)</target>
        </trans-unit>
        <trans-unit id="f54d45d1a4464006ef586499c694d801d5a8d12c" translate="yes" xml:space="preserve">
          <source>More &lt;a href=&quot;https://gcc.gnu.org/wiki/Visibility&quot;&gt;information about visibility&lt;/a&gt; can be found on the gcc wiki.</source>
          <target state="translated">Более подробную &lt;a href=&quot;https://gcc.gnu.org/wiki/Visibility&quot;&gt;информацию о видимости&lt;/a&gt; можно найти в gcc wiki.</target>
        </trans-unit>
        <trans-unit id="641fea9b7a86c80e1745eea04b284d17d7064212" translate="yes" xml:space="preserve">
          <source>Most modern linkers include a verbose option that prints out to varying degrees;</source>
          <target state="translated">Большинство современных линковщиков включают многословную опцию,которая распечатывает в различной степени;</target>
        </trans-unit>
        <trans-unit id="e559ced22868458277e7a84fcf34818870da0124" translate="yes" xml:space="preserve">
          <source>Multiple source files of the same name</source>
          <target state="translated">Несколько одноименных исходных файлов</target>
        </trans-unit>
        <trans-unit id="c767224b9650ce630e60df38453f62be584ffe15" translate="yes" xml:space="preserve">
          <source>Next, it finds &lt;code&gt;eg1.o&lt;/code&gt;, and adds it to be program. An object file in the
linkage sequence is always added to the program. Now, the program makes
a reference to &lt;code&gt;hw&lt;/code&gt;, and does not contain a definition of &lt;code&gt;hw&lt;/code&gt;; but
there is nothing left in the linkage sequence that could provide the missing
definition. The reference to &lt;code&gt;hw&lt;/code&gt; ends up &lt;em&gt;unresolved&lt;/em&gt;, and the linkage fails.</source>
          <target state="translated">Затем он находит &lt;code&gt;eg1.o&lt;/code&gt; и добавляет его в программу. Объектный файл в последовательности связей всегда добавляется в программу. Теперь программа ссылается на &lt;code&gt;hw&lt;/code&gt; и не содержит определения &lt;code&gt;hw&lt;/code&gt; ; но в последовательности связей не осталось ничего, что могло бы дать недостающее определение. Ссылка на &lt;code&gt;hw&lt;/code&gt; оказывается &lt;em&gt;неразрешенной&lt;/em&gt; , а связь не выполняется.</target>
        </trans-unit>
        <trans-unit id="f0d2f6223f521a208279e081a4e5a7ac2c7dd700" translate="yes" xml:space="preserve">
          <source>Non-&lt;code&gt;virtual&lt;/code&gt; class members</source>
          <target state="translated">Не &lt;code&gt;virtual&lt;/code&gt; участники класса</target>
        </trans-unit>
        <trans-unit id="117ed9998cfcf9683b519b2cfb916a1303481e8f" translate="yes" xml:space="preserve">
          <source>Note how even though both the function declarations look identical in source code, but they are really different according to the compiler.</source>
          <target state="translated">Обратите внимание на то,что хотя обе декларации функций в исходном коде выглядят одинаково,но,по мнению компилятора,они действительно разные.</target>
        </trans-unit>
        <trans-unit id="5abbdb9f6a8ffe88fc827af5fbe46e7e3a900154" translate="yes" xml:space="preserve">
          <source>Note in this example, the linker would tell you it couldn't find &lt;code&gt;draw()&lt;/code&gt;, when in reality you know it obviously is being exported by the library. You could spend hours scratching your head wondering what went wrong. The thing is, the linker sees a different signature because the parameter types are slightly different. In the example, &lt;code&gt;vec3&lt;/code&gt; is a different type in both projects as far as the compiler is concerned. This could happen because they come from two slightly different include files (maybe the include files come from two different versions of the library).</source>
          <target state="translated">Обратите внимание, что в этом примере компоновщик скажет вам, что он не может найти &lt;code&gt;draw()&lt;/code&gt; , хотя в действительности вы знаете, что он, очевидно, экспортируется библиотекой. Вы могли бы часами чесать голову, задаваясь вопросом, что пошло не так. Дело в том, что компоновщик видит другую подпись, потому что типы параметров немного отличаются. В примере, &lt;code&gt;vec3&lt;/code&gt; - это другой тип в обоих проектах, поскольку это касается компилятора. Это может произойти, потому что они приходят из двух слегка отличающихся файлов включений (возможно, файлы включений происходят из двух разных версий библиотеки).</target>
        </trans-unit>
        <trans-unit id="23d4b3aa6710b3034b123422af2beef9dd73642c" translate="yes" xml:space="preserve">
          <source>Note the &lt;strong&gt;different libraries&lt;/strong&gt; used in main.cpp and file.h. Since main.cpp #include'd &quot;&lt;strong&gt;file.h&lt;/strong&gt;&quot; after &amp;lt;&lt;strong&gt;filesystem&lt;/strong&gt;&amp;gt;, the version of filesystem used there was &lt;strong&gt;the C++17 one&lt;/strong&gt;. I used to compile the program with the following commands:</source>
          <target state="translated">Обратите внимание на &lt;strong&gt;различные библиотеки,&lt;/strong&gt; используемые в main.cpp и file.h. Поскольку main.cpp # include'd &amp;laquo; &lt;strong&gt;file.h&lt;/strong&gt; &amp;raquo; после &amp;lt; &lt;strong&gt;filesystem&lt;/strong&gt; &amp;gt;, используемая там версия файловой системы была &lt;strong&gt;C ++ 17&lt;/strong&gt; . Я использовал для компиляции программы с помощью следующих команд:</target>
        </trans-unit>
        <trans-unit id="6ce292ed7cabf956b3bed91089eb7d1238831776" translate="yes" xml:space="preserve">
          <source>Note the weird mangled name given in the linker error. (eg. draw@graphics@XYZ).</source>
          <target state="translated">Обратите внимание на странное искаженное имя,указанное в ошибке компоновщика.(например,draw@graphics@XYZ).</target>
        </trans-unit>
        <trans-unit id="3b2cfcdfa403dfa1ba5b0b9b3a8ea1bd2538d22c" translate="yes" xml:space="preserve">
          <source>Now when you build this code you will get a LNK2019 error complaining that foo is an unresolved symbol. In this case, we know that foo() has its definition in a.cpp, but different from the one we are calling(different return value). This is the case that definition exists.</source>
          <target state="translated">Теперь при сборке этого кода вы получите ошибку LNK2019,жалующуюся на то,что foo-неразрешенный символ.В этом случае мы знаем,что foo()имеет свое определение в a.cpp,но отличается от того,которое мы вызываем (другое возвращаемое значение).В этом случае такое определение существует.</target>
        </trans-unit>
        <trans-unit id="3fd0cadfd7a6c67e12488f6b0910e0bf6fc11715" translate="yes" xml:space="preserve">
          <source>OK (no errors), because we only build object file, linking is not done yet.
Try to link</source>
          <target state="translated">OK (никаких ошибок),потому что мы только строим объектный файл,связывание еще не сделано.Попробуйте связать</target>
        </trans-unit>
        <trans-unit id="e251c8f846836883316a7f1bd7f47a5ca9918668" translate="yes" xml:space="preserve">
          <source>On Linux, it may be due to the wrong library folder (using &lt;code&gt;lib&lt;/code&gt; instead of &lt;code&gt;lib64&lt;/code&gt; for instance).</source>
          <target state="translated">В Linux это может быть связано с неправильной папкой библиотеки (например, с использованием &lt;code&gt;lib&lt;/code&gt; вместо &lt;code&gt;lib64&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="86966d8cfc106dd026001fc5ff966b8b3018c853" translate="yes" xml:space="preserve">
          <source>On MacOS, there is the option of shipping both architectures in the same file. It may be that the link expects both versions to be there, but only one is. It can also be an issue with the wrong &lt;code&gt;lib&lt;/code&gt;/&lt;code&gt;lib64&lt;/code&gt; folder where the library is picked up.</source>
          <target state="translated">В MacOS есть возможность отправить обе архитектуры в одном файле. Может быть так, что ссылка ожидает, что обе версии будут там, но только одна есть. Это также может быть проблема с неправильной папкой &lt;code&gt;lib&lt;/code&gt; / &lt;code&gt;lib64&lt;/code&gt; ,в которой находится библиотека.</target>
        </trans-unit>
        <trans-unit id="11ea8afa3c6fc752c5cd8f5e66cffa69d7e4417a" translate="yes" xml:space="preserve">
          <source>On Visual Studio, this is due to the wrong &quot;Platform&quot;, and you need to either select the proper one or install the proper version of the library.</source>
          <target state="translated">В Visual Studio это связано с неправильной &quot;Платформой&quot;,и вам необходимо либо выбрать нужную,либо установить нужную версию библиотеки.</target>
        </trans-unit>
        <trans-unit id="457c63213d9d88bc27b8181901ab2f67874c5025" translate="yes" xml:space="preserve">
          <source>Once the &quot;clean&quot; has completed, verify that the &quot;clean&quot; has succeeded and all the generated intermediate file (e.g. an automated makefile) have been successfully removed.</source>
          <target state="translated">После завершения &quot;чистки&quot; убедитесь,что &quot;чистка&quot; прошла успешно и все сгенерированные промежуточные файлы (например,автоматизированный makefile)были успешно удалены.</target>
        </trans-unit>
        <trans-unit id="6f5728e6f888e3db2ef5e4e2e84aed1bcec411c8" translate="yes" xml:space="preserve">
          <source>Once the Linker find one symbol he doesn't search in other libraries for it</source>
          <target state="translated">Как только Линкер находит один символ,он не ищет его в других библиотеках.</target>
        </trans-unit>
        <trans-unit id="94e5d03e6bfe739776bcda7bf67b4b04f50d00e4" translate="yes" xml:space="preserve">
          <source>One possible reason for linker errors with GCC 5.2.0 is that a new libstdc++ library ABI is now chosen by default.</source>
          <target state="translated">Одной из возможных причин ошибок компоновщика с GCC 5.2.0 является то,что теперь по умолчанию выбрана новая библиотека libstdc++ABI.</target>
        </trans-unit>
        <trans-unit id="e8ebcbceae17e1cbcb7630b4e7cab992bde641ed" translate="yes" xml:space="preserve">
          <source>Or in the project settings;</source>
          <target state="translated">Или в настройках проекта;</target>
        </trans-unit>
        <trans-unit id="3324fb682ba3b5fa0fc5008f94f9c3c6cb160fbe" translate="yes" xml:space="preserve">
          <source>Or on the command line;</source>
          <target state="translated">Или по командной строке;</target>
        </trans-unit>
        <trans-unit id="0d8974a160f915d9994dddc618b6681fd0f9d9cf" translate="yes" xml:space="preserve">
          <source>Or you could replace the -l argument with the full path of the .so, e.g. instead of &lt;code&gt;-ltbb&lt;/code&gt; do &lt;code&gt;/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2&lt;/code&gt;</source>
          <target state="translated">Или вы можете заменить аргумент -l на полный путь .so, например, вместо &lt;code&gt;-ltbb&lt;/code&gt; do &lt;code&gt;/home/foo/tbb-4.3/linux/lib/intel64/gcc4.4/libtbb.so.2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ae41d11bd46131c063f0debe5a8fdf31f161cd3" translate="yes" xml:space="preserve">
          <source>Or, the implementation for the &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; can be done inline inside the class definition;</source>
          <target state="translated">Или, реализация для &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; может быть встроена внутри определения класса;</target>
        </trans-unit>
        <trans-unit id="80d315959f3ea9b04eb57b630f050abbf870cc02" translate="yes" xml:space="preserve">
          <source>Other examples of mismatches include</source>
          <target state="translated">Другие примеры несоответствий включают</target>
        </trans-unit>
        <trans-unit id="6a535a2a245f2fac95298b5e9540153ebde66430" translate="yes" xml:space="preserve">
          <source>Parse all the object files and find the definition which was only declared in headers ( eg: The code of one method of a class as is mentioned in previous answers, or event the initialization of a static variable which is member inside a class)</source>
          <target state="translated">Разобрать все объектные файлы и найти определение,которое было объявлено только в заголовках (например:код одного метода класса,как упоминалось в предыдущих ответах,или событие инициализации статической переменной,которая является членом внутри класса)</target>
        </trans-unit>
        <trans-unit id="bd4adda29a59ab9ab7bbb53de56745feac90cde3" translate="yes" xml:space="preserve">
          <source>Pay attention to why the mangled names ended up different. You would be able to see that the parameter types are different, even though they look the same in the source code.</source>
          <target state="translated">Обратите внимание,почему искаженные имена оказались другими.Вы увидите,что типы параметров различны,даже если в исходном коде они выглядят одинаково.</target>
        </trans-unit>
        <trans-unit id="4041537c412b8e8a70cd213105a7f6d55c1d8225" translate="yes" xml:space="preserve">
          <source>Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set
  (introducing new-line characters for end-of-line indicators) if
  necessary. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">Физические символы исходного файла отображаются, в зависимости от реализации, в основной исходный набор символов (ввод символов новой строки для индикаторов конца строки), если это необходимо. &lt;em&gt;[СНиП]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f7cb050a64d88fed430275cbf21ad78668fd798" translate="yes" xml:space="preserve">
          <source>Preprocessing directives are executed, macro invocations are expanded, and _Pragma unary operator expressions are executed. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">Выполняются директивы предварительной обработки, расширяются вызовы макросов и выполняются выражения унарного оператора _Pragma. &lt;em&gt;[СНиП]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6587b16429748e00b4db35eea2d58d775e0d0e77" translate="yes" xml:space="preserve">
          <source>Problems with template friends</source>
          <target state="translated">Проблемы с друзьями-шаблонами</target>
        </trans-unit>
        <trans-unit id="0721f2ff9d4e8f8c71dbe1300b4338d0f46d327a" translate="yes" xml:space="preserve">
          <source>Project Properties &amp;gt; General &amp;gt; Project Defaults &amp;gt; Character Set</source>
          <target state="translated">Свойства проекта&amp;gt; Общие&amp;gt; Проект по умолчанию&amp;gt; Набор символов</target>
        </trans-unit>
        <trans-unit id="315cdbd0cc37f2f6eed7311d6a11376e81ab5846" translate="yes" xml:space="preserve">
          <source>Putting interdependent libraries in the wrong order is just one way
in which you can get files that &lt;em&gt;need&lt;/em&gt; definitions of things coming
later in the linkage than the files that &lt;em&gt;provide&lt;/em&gt; the definitions. Putting libraries before the 
object files that refer to them is another way of making the same mistake.</source>
          <target state="translated">Размещение взаимозависимых библиотек в неправильном порядке - это только один из способов, с помощью которого вы можете получить файлы, которые &lt;em&gt;нуждаются в&lt;/em&gt; определениях вещей, которые появятся позже в связке, чем файлы, которые &lt;em&gt;предоставляют&lt;/em&gt; определения. Размещение библиотек перед объектными файлами, которые ссылаются на них, является еще одним способом сделать ту же ошибку.</target>
        </trans-unit>
        <trans-unit id="aa2e87051763ba52eba36f8604042df6dea47a55" translate="yes" xml:space="preserve">
          <source>Reason why they are different. In the example given above, they are different because of different include files.</source>
          <target state="translated">Причина,почему они разные.В приведенном выше примере они отличаются из-за разных включаемых файлов.</target>
        </trans-unit>
        <trans-unit id="516aae52959dcf5398a9985414a78b8c24a4f0e5" translate="yes" xml:space="preserve">
          <source>Resolution</source>
          <target state="translated">Resolution</target>
        </trans-unit>
        <trans-unit id="36eb62592e54385368d992e3bfc823feb8a2ecf1" translate="yes" xml:space="preserve">
          <source>Same if you compile and link in one go:</source>
          <target state="translated">То же самое,если вы компилируете и соединяете за один заход:</target>
        </trans-unit>
        <trans-unit id="57b44b45b209c07e2cf396779f22bd7450198c5e" translate="yes" xml:space="preserve">
          <source>Say you defined symbol &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;a.cpp&lt;/code&gt;. Now, &lt;code&gt;b.cpp&lt;/code&gt;&lt;em&gt;declared&lt;/em&gt; that symbol and used it. Before linking, it simply assumes that that symbol was defined &lt;em&gt;somewhere&lt;/em&gt;, but it doesn't yet care where. The linking phase is responsible for finding the symbol and correctly linking it to &lt;code&gt;b.cpp&lt;/code&gt; (well, actually to the object or library that uses it).</source>
          <target state="translated">Допустим, вы определили символ &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;a.cpp&lt;/code&gt; . Теперь &lt;code&gt;b.cpp&lt;/code&gt; &lt;em&gt;объявил&lt;/em&gt; этот символ и использовал его. Перед связыванием он просто предполагает, что этот символ был определен &lt;em&gt;где-то&lt;/em&gt; , но ему все равно где. Фаза линковки отвечает за поиск символа и правильное связывание его с &lt;code&gt;b.cpp&lt;/code&gt; (ну, собственно, с объектом или библиотекой, которая его использует).</target>
        </trans-unit>
        <trans-unit id="d88c152a43cb27887978260a5c15f52ecc557b4e" translate="yes" xml:space="preserve">
          <source>Search for the exported symbol of interest, and notice that the mangled name is different.</source>
          <target state="translated">Найдите экспортируемый символ,представляющий интерес,и заметьте,что искаженное имя отличается.</target>
        </trans-unit>
        <trans-unit id="f5e40313ea4a701259411817e6ec26f8b27269ef" translate="yes" xml:space="preserve">
          <source>Search paths used.</source>
          <target state="translated">Использованы поисковые пути.</target>
        </trans-unit>
        <trans-unit id="ef26caaa13a2223b4e5f1013e62b3dd0af211401" translate="yes" xml:space="preserve">
          <source>Second, &lt;strong&gt;example 2&lt;/strong&gt;, with shared library &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">Второй, &lt;strong&gt;пример 2&lt;/strong&gt; , с общей библиотекой &lt;code&gt;libz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">См.также</target>
        </trans-unit>
        <trans-unit id="31a5c46ba7e3644d87e2c8692f9d7b577d4ff522" translate="yes" xml:space="preserve">
          <source>Similar mechanisms exist for other compilers/ platforms.</source>
          <target state="translated">Аналогичные механизмы существуют и для других платформ компиляторов.</target>
        </trans-unit>
        <trans-unit id="ad1f924b7bbc2bcd7bd047b593952dcaf5c4a6a3" translate="yes" xml:space="preserve">
          <source>Similar remarks apply to functions. Declaring a function without defining it leads to the error:</source>
          <target state="translated">Аналогичные замечания относятся и к функциям.Объявление функции без определения приводит к ошибке:</target>
        </trans-unit>
        <trans-unit id="44febaad51a1168e7b5495233c9acbc83d1c9397" translate="yes" xml:space="preserve">
          <source>Similar to Windows-dlls, one would mark public functions with a define, for example &lt;code&gt;DLL_PUBLIC&lt;/code&gt; defined as:</source>
          <target state="translated">Как и в Windows-DLL, публичные функции можно пометить определением, например &lt;code&gt;DLL_PUBLIC&lt;/code&gt; , определенным как:</target>
        </trans-unit>
        <trans-unit id="3791448e9c466323a781d1053225a28e2ed66066" translate="yes" xml:space="preserve">
          <source>Since it is not implemented, the linker fails to find it and results in the error.</source>
          <target state="translated">Так как он не реализован,компоновщик не находит его и приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="b88c50d7c2684c92f808dc0bef70ada825c3a195" translate="yes" xml:space="preserve">
          <source>Since people seem to be directed to this question when it comes to linker errors I am going to add this here.</source>
          <target state="translated">Так как люди,кажется,направлены на этот вопрос,когда речь идет об ошибках компоновщика,я собираюсь добавить это здесь.</target>
        </trans-unit>
        <trans-unit id="5594c3defe9060176ac055ec30199b6a1925a1a0" translate="yes" xml:space="preserve">
          <source>So if you suddenly get linker errors when switching to a GCC after 5.1.0 this would be a thing to check out.</source>
          <target state="translated">Так что если вы внезапно получите ошибки компоновщика при переходе на GCC после 5.1.0,то это стоит проверить.</target>
        </trans-unit>
        <trans-unit id="7406dccb208de8f7859f688a7bf278cd1e4e822d" translate="yes" xml:space="preserve">
          <source>So the linkage fails just as it does if you &lt;em&gt;do&lt;/em&gt; run those two commands. The
only difference you notice in the failure is that gcc has generated a
temporary object file in the compile + link case, because you're not telling it
to use &lt;code&gt;eg1.o&lt;/code&gt;. We see:</source>
          <target state="translated">Таким образом, связь не работает так же, как если бы вы выполнили эти две команды. Единственное отличие, которое вы замечаете в ошибке, состоит в том, что gcc сгенерировал временный объектный файл в случае компиляции + ссылки, потому что вы не говорите ему использовать &lt;code&gt;eg1.o&lt;/code&gt; . Мы видим:</target>
        </trans-unit>
        <trans-unit id="0c7380eb36ac254fde0c5e28aa7521e54819d717" translate="yes" xml:space="preserve">
          <source>So the linker does not add &lt;code&gt;my_lib.o&lt;/code&gt; to the program and has no further
use for &lt;code&gt;libmy_lib.a&lt;/code&gt;.</source>
          <target state="translated">Так что компоновщик не добавляет &lt;code&gt;my_lib.o&lt;/code&gt; в программу и больше не использует &lt;code&gt;libmy_lib.a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="389ef339b38d14a89c45ee18d949e24cc58f1d20" translate="yes" xml:space="preserve">
          <source>So to repeat again, the order &lt;strong&gt;DOES&lt;/strong&gt; matter!</source>
          <target state="translated">Итак, повторюсь, порядок имеет значение!</target>
        </trans-unit>
        <trans-unit id="ba83702c0f21aecaaf05b65e1c413ecbfdf89e6e" translate="yes" xml:space="preserve">
          <source>So, as a result - an &quot;undefined reference/unresolved external symbol error&quot; happens when the linker cannot find global symbols in the object files.</source>
          <target state="translated">Таким образом,в результате-&quot;неопределенная ссылочная ошибка внешнего символа&quot; происходит,когда компоновщик не может найти глобальные символы в объектных файлах.</target>
        </trans-unit>
        <trans-unit id="810e61562c0a90ab80a893ffeb7eb498e51ef3b8" translate="yes" xml:space="preserve">
          <source>So, we see follow symbols to export.</source>
          <target state="translated">Итак,мы видим следующие символы для экспорта.</target>
        </trans-unit>
        <trans-unit id="889eacaaf63948869a5ddecd71ff4abfdbeb0106" translate="yes" xml:space="preserve">
          <source>So, we've seen there is no label for local_var_name, that's why linker hasn't found it. But we are hackers :) and we can fix it. Open src1.s in your text editor and change</source>
          <target state="translated">Итак,мы увидели,что для имени local_var_name нет метки,поэтому компоновщик ее не нашел.Но мы же хакеры :)и можем это исправить.Откройте src1.s в вашем текстовом редакторе и измените</target>
        </trans-unit>
        <trans-unit id="ed306cf6c07bf565cfeaa2c226cbfd2a2acd58af" translate="yes" xml:space="preserve">
          <source>Some .so files are actually &lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-commands.html&quot;&gt;GNU ld linker scripts&lt;/a&gt;, e.g. &lt;a href=&quot;https://www.threadingbuildingblocks.org/download&quot;&gt;libtbb.so&lt;/a&gt; file is an ASCII text file with this contents:</source>
          <target state="translated">Некоторые файлы .so на самом деле являются &lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/simple-commands.html&quot;&gt;сценариями компоновщика GNU ld&lt;/a&gt; , например, файл &lt;a href=&quot;https://www.threadingbuildingblocks.org/download&quot;&gt;libtbb.so&lt;/a&gt; представляет собой текстовый файл ASCII со следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="2701d02120f341c911b427c678b1b3ba58ab869e" translate="yes" xml:space="preserve">
          <source>Some members need to be defined even if not used explicitly:</source>
          <target state="translated">Некоторые члены должны быть определены,даже если они не используются явно:</target>
        </trans-unit>
        <trans-unit id="0ce76ec1b7032c9c8bc5feb3b6ece87aff083f39" translate="yes" xml:space="preserve">
          <source>Some more complex builds may not support this. For example, if you include -v in the compiler options, you can see that the &lt;a href=&quot;http://www.mainsoft.com/content/mainsoft-unix-and-linux-overview&quot;&gt;mainwin gcc wrapper mwdip&lt;/a&gt; discards linker script command files in the verbose output list of libraries to link in. A simple work around is to replace the linker script input command file with a copy of the file instead (or a symlink), e.g.</source>
          <target state="translated">Некоторые более сложные сборки могут не поддерживать это. Например, если вы &lt;a href=&quot;http://www.mainsoft.com/content/mainsoft-unix-and-linux-overview&quot;&gt;включите&lt;/a&gt; параметр -v в опциях компилятора, вы увидите, что оболочка mainwin gcc mwdip отбрасывает командные файлы сценария компоновщика в подробный список вывода библиотек для компоновки. Простой обходной путь - заменить команду ввода сценария компоновщика. вместо этого файл с копией файла (или символической ссылкой), например</target>
        </trans-unit>
        <trans-unit id="8da255b627a43c5967c21bd733eeffe48c9f7d7b" translate="yes" xml:space="preserve">
          <source>Specialized templates can be implemented in an implementation file and the implementation doesn't have to be visible, but the specialization must be previously declared.</source>
          <target state="translated">Специализированные шаблоны могут быть реализованы в файле реализации и реализация не обязательно должна быть видимой,но специализация должна быть предварительно объявлена.</target>
        </trans-unit>
        <trans-unit id="2bbb6a7ee8142005a47ef622c25910f07c59d91f" translate="yes" xml:space="preserve">
          <source>Steps to try if you believe it could be a bug in compiler/IDE:</source>
          <target state="translated">Шаги,чтобы попробовать,если вы считаете,что это может быть ошибкой в компиляторе:</target>
        </trans-unit>
        <trans-unit id="fe05b5a0cc2b31aa92f2910350d4890d86e8795c" translate="yes" xml:space="preserve">
          <source>Success:</source>
          <target state="translated">Success:</target>
        </trans-unit>
        <trans-unit id="82ca7ce44cf63b62393dd7422ee20047ef95bcd5" translate="yes" xml:space="preserve">
          <source>Suppose you have a big project written in c++ which has a thousand of .cpp files and a thousand of .h files.And let's says the project also depends on ten static libraries. Let's says we are on Windows and we build our project in Visual Studio 20xx. When you press Ctrl + F7 Visual Studio to start compiling the whole solution ( suppose we have just one project in the solution )</source>
          <target state="translated">Допустим,у вас есть большой проект,написанный на c++,в котором есть тысяча .cpp файлов и тысяча .h файлов.И допустим,проект также зависит от десяти статических библиотек.Допустим,мы на Windows и собираем наш проект в Visual Studio 20xx.При нажатии Ctrl+F7 Visual Studio начинается компиляция всего решения (допустим,у нас только один проект в решении).</target>
        </trans-unit>
        <trans-unit id="8380d950d527889dc4734ed54b11f16aca5a374d" translate="yes" xml:space="preserve">
          <source>Symbols were defined in a C program and used in C++ code.</source>
          <target state="translated">Символы были определены в программе на Си и использованы в Си++коде.</target>
        </trans-unit>
        <trans-unit id="2a9939fe25550be4dea8b1c736d43f816c2c5f20" translate="yes" xml:space="preserve">
          <source>Template implementations not visible.</source>
          <target state="translated">Реализации шаблонов не видны.</target>
        </trans-unit>
        <trans-unit id="8ef7c2da6f851f23bbe511ebc36d3de16160e803" translate="yes" xml:space="preserve">
          <source>That's because the distro on which the linkage works is one of the ones that 
does not configure its GCC toolchain to link shared libraries &lt;em&gt;as-needed&lt;/em&gt;.</source>
          <target state="translated">Это связано с тем, что дистрибутив, на котором работает связывание, является одним из тех, которые не настраивают свой набор инструментов GCC для связывания разделяемых библиотек по &lt;em&gt;мере необходимости&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ddd5cfe744cba081a538a7341375f31cf8b1b45a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;libraryName&lt;/code&gt; here is just the bare name of the library, without platform-specific additions. So e.g. on Linux library files are usually called &lt;code&gt;libfoo.so&lt;/code&gt; but you'd only write &lt;code&gt;-lfoo&lt;/code&gt;. On Windows that same file might be called &lt;code&gt;foo.lib&lt;/code&gt;, but you'd use the same argument. You might have to add the directory where those files can be found using &lt;code&gt;-L&amp;lsaquo;directory&amp;rsaquo;&lt;/code&gt;. Make sure to not write a space after &lt;code&gt;-l&lt;/code&gt; or &lt;code&gt;-L&lt;/code&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;libraryName&lt;/code&gt; - это просто голое название библиотеки, без специфических для платформы дополнений. Например, в Linux файлы библиотеки обычно называются &lt;code&gt;libfoo.so&lt;/code&gt; , но вы должны написать только &lt;code&gt;-lfoo&lt;/code&gt; . В Windows этот же файл может называться &lt;code&gt;foo.lib&lt;/code&gt; , но вы должны использовать тот же аргумент. Возможно, вам придется добавить каталог, в котором эти файлы можно найти, используя &lt;code&gt;-L&amp;lsaquo;directory&amp;rsaquo;&lt;/code&gt; . Удостоверьтесь, что не пишите пробел после &lt;code&gt;-l&lt;/code&gt; или &lt;code&gt;-L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd483f1251beaf7236d9997165b1d451b6bd1e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is being declared as a non-template function. For every type &lt;code&gt;T&lt;/code&gt; used with &lt;code&gt;Foo&lt;/code&gt;, there needs to be a non-templated &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. For example, if there is a type &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; declared, then there must be an operator implementation as follows;</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; объявляется как не шаблонная функция. Для каждого типа &lt;code&gt;T&lt;/code&gt; , используемого с &lt;code&gt;Foo&lt;/code&gt; , должен быть не шаблонный &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; . Например, если объявлен тип &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; , то должна быть реализация оператора следующим образом;</target>
        </trans-unit>
        <trans-unit id="f74bbb502cac87efc036b9625dd07f7ba8c32eb8" translate="yes" xml:space="preserve">
          <source>The C++ linker expects names to be mangled, so you have to declare the function as:</source>
          <target state="translated">Компоновщик C++ожидает,что имена будут искажены,поэтому необходимо объявить функцию как:</target>
        </trans-unit>
        <trans-unit id="fa46de6d6b4941229d8b28acdcc1f6c203f0c516" translate="yes" xml:space="preserve">
          <source>The MSDN page on the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wdsk6as6.aspx&quot;&gt;&lt;code&gt;/VERBOSE&lt;/code&gt; linker option&lt;/a&gt;.</source>
          <target state="translated">Страница MSDN в &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/wdsk6as6.aspx&quot;&gt;параметре компоновщика &lt;code&gt;/VERBOSE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a964c858e2f8e84f3cc4266073a14ab0c6127b2" translate="yes" xml:space="preserve">
          <source>The Second step of compilation is done by Linker.Linker should merge all the object file and build finally the output ( which may be an executable or a library)</source>
          <target state="translated">На втором этапе компиляции Linker.Linker должен объединить все объектные файлы и собрать окончательно результат (который может быть исполняемым файлом или библиотекой).</target>
        </trans-unit>
        <trans-unit id="b2a9f1a0bcdd74e12869a5f78bd29d7084686e17" translate="yes" xml:space="preserve">
          <source>The above code limits the friendship of the operator to the corresponding instantiation of &lt;code&gt;Foo&lt;/code&gt;, i.e. the &lt;code&gt;operator&amp;lt;&amp;lt; &amp;lt;int&amp;gt;&lt;/code&gt; instantiation is limited to access the private members of the instantiation of &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Приведенный выше код ограничивает дружбу оператора соответствующим экземпляром &lt;code&gt;Foo&lt;/code&gt; , т.е. &lt;code&gt;operator&amp;lt;&amp;lt; &amp;lt;int&amp;gt;&lt;/code&gt; экземпляр ограничен доступом к закрытым членам создания &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cdbeecfba3fe1508804ada7c0e80ead504f0a5a" translate="yes" xml:space="preserve">
          <source>The alternative is applicable as well, if UNICODE is not intended to be used, make sure the defines are not set, and/or the multi-character setting is used in the projects and consistently applied.</source>
          <target state="translated">Альтернатива также применима,если UNICODE не предназначен для использования,убедитесь,что определения не установлены,или что многосимвольная настройка используется в проектах и последовательно применяется.</target>
        </trans-unit>
        <trans-unit id="ab517e2a8ba12a27ab2bbd36c075257a2d62e599" translate="yes" xml:space="preserve">
          <source>The code:</source>
          <target state="translated">Код:</target>
        </trans-unit>
        <trans-unit id="96e15fc342a8a7b8e2a770b1887eaa0b6e5475ae" translate="yes" xml:space="preserve">
          <source>The correct solution is to hope the developer releases an updated package and then upgrade, but it worked for me by hacking in an extra setting for VS2013, pointing at the VS2012 library files.</source>
          <target state="translated">Правильным решением будет надеяться,что разработчик выпустит обновленный пакет,а затем обновит его,но для меня это сработало,взломав дополнительную настройку для VS2013,указав на файлы библиотеки VS2012.</target>
        </trans-unit>
        <trans-unit id="39c6a6672a8c45fef828814fbc0a834a3d886d1e" translate="yes" xml:space="preserve">
          <source>The default behavior of gcc is that all symbols are visible. However, when the translation units are built with option &lt;code&gt;-fvisibility=hidden&lt;/code&gt;, only functions/symbols marked with &lt;code&gt;__attribute__ ((visibility (&quot;default&quot;)))&lt;/code&gt; are external in the resulting shared object.</source>
          <target state="translated">Поведение gcc по умолчанию состоит в том, что все символы видны. Однако, когда единицы перевода создаются с опцией &lt;code&gt;-fvisibility=hidden&lt;/code&gt; , в результирующем общем объекте только внешние функции / символы, отмеченные &lt;code&gt;__attribute__ ((visibility (&quot;default&quot;)))&lt;/code&gt; являются внешними.</target>
        </trans-unit>
        <trans-unit id="5d98ae42d70c1284a1b8e74bcfa80f5e6dc64e4b" translate="yes" xml:space="preserve">
          <source>The definition should be</source>
          <target state="translated">Определение должно быть</target>
        </trans-unit>
        <trans-unit id="fc35bde94bc482f0aba6406f3ef3e5fec63a5cd8" translate="yes" xml:space="preserve">
          <source>The different linkage rules for static and shared libraries can be confusing
to inexpert programmers, who may not know whether &lt;code&gt;-lfoo&lt;/code&gt; in their linkage
is going to resolve to &lt;code&gt;/some/where/libfoo.a&lt;/code&gt; or to &lt;code&gt;/some/where/libfoo.so&lt;/code&gt;,
and might not understand the difference between shared and static libraries
anyway.</source>
          <target state="translated">Различные правила связывания для статических и совместно используемых библиотек могут сбивать с толку неопытных программистов, которые могут не знать, будет ли &lt;code&gt;-lfoo&lt;/code&gt; в их соединении &lt;code&gt;/some/where/libfoo.a&lt;/code&gt; в /some/where/libfoo.a или в &lt;code&gt;/some/where/libfoo.so&lt;/code&gt; , и может не понять разницу между общими и статическими библиотеками в любом случае.</target>
        </trans-unit>
        <trans-unit id="aaebebac9d959c2f58827c7b922c7bafe9507b45" translate="yes" xml:space="preserve">
          <source>The error message from the compiler will often give you the full declaration of the variable or function that was declared but never defined. Compare it closely to the definition you provided. &lt;em&gt;Make sure every detail matches.&lt;/em&gt;</source>
          <target state="translated">Сообщение об ошибке от компилятора часто дает вам полное объявление переменной или функции, которая была объявлена, но никогда не определялась. Сравните это с приведенным вами определением. &lt;em&gt;Убедитесь, что каждая деталь соответствует.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c2fa91316cfdea05c933e01c86ec8f328458b71" translate="yes" xml:space="preserve">
          <source>The error usually includes a function a value with a &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt; derived type, these could include &lt;code&gt;std::basic_string&amp;lt;&amp;gt;&lt;/code&gt; etc. as well. When browsing through the affected function in the code, there will often be a reference to &lt;code&gt;TCHAR&lt;/code&gt; or &lt;code&gt;std::basic_string&amp;lt;TCHAR&amp;gt;&lt;/code&gt; etc. This is a tell-tale sign that the code was originally intended for both a UNICODE and a Multi-Byte Character (or &quot;narrow&quot;) build.</source>
          <target state="translated">Ошибка обычно включает в себя функцию со значением производного типа &lt;code&gt;char&lt;/code&gt; или &lt;code&gt;wchar_t&lt;/code&gt; , в том числе &lt;code&gt;std::basic_string&amp;lt;&amp;gt;&lt;/code&gt; и т. Д. При просмотре &lt;code&gt;TCHAR&lt;/code&gt; функции в коде часто будет ссылка на TCHAR или &lt;code&gt;std::basic_string&amp;lt;TCHAR&amp;gt;&lt;/code&gt; и т. Д. Это контрольный признак того, что код изначально предназначался как для UNICODE, так и для многобайтовых Характер (или &amp;laquo;узкая&amp;raquo;) стройка.</target>
        </trans-unit>
        <trans-unit id="814895756bf4ca3a731ef6c9e3952b7d303ddbd4" translate="yes" xml:space="preserve">
          <source>The explanation</source>
          <target state="translated">Объяснение</target>
        </trans-unit>
        <trans-unit id="2d47f92cdddee137d7131c686bea6ba95385c1dd" translate="yes" xml:space="preserve">
          <source>The following would yield the error:</source>
          <target state="translated">Следующее приведет к ошибке:</target>
        </trans-unit>
        <trans-unit id="dc651a3eb6c90a022d94d96235e9502e73444d46" translate="yes" xml:space="preserve">
          <source>The function (or variable) &lt;code&gt;void foo()&lt;/code&gt; was defined in a C program and you attempt to use it in a C++ program:</source>
          <target state="translated">Функция (или переменная) &lt;code&gt;void foo()&lt;/code&gt; была определена в программе на C, и вы пытаетесь использовать ее в программе на C ++:</target>
        </trans-unit>
        <trans-unit id="a01682bab1ad942d84e12a4ac6e6ac22aa1e51e4" translate="yes" xml:space="preserve">
          <source>The implementation can be inline, in the class definition itself:</source>
          <target state="translated">Реализация может быть встроенной,в самом определении класса:</target>
        </trans-unit>
        <trans-unit id="edc532595d46d57575b847133085c91ba2256fee" translate="yes" xml:space="preserve">
          <source>The linkage:</source>
          <target state="translated">Связь:</target>
        </trans-unit>
        <trans-unit id="de5f587780a7f48b676bf47c006c00b98834b61e" translate="yes" xml:space="preserve">
          <source>The linker will decide that your program needs &lt;code&gt;my_lib.o&lt;/code&gt; if and only if it already knows that
your program refers to &lt;code&gt;hw&lt;/code&gt;, in one or more of the object files it has already
added to the program, and that none of the object files it has already added
contains a definition for &lt;code&gt;hw&lt;/code&gt;.</source>
          <target state="translated">Компоновщик решит, что вашей программе нужен &lt;code&gt;my_lib.o&lt;/code&gt; тогда и только тогда, когда он уже знает, что ваша программа ссылается на &lt;code&gt;hw&lt;/code&gt; в одном или нескольких объектных файлах, которые она уже добавила в программу, и что ни один из объектных файлов не имеет уже добавлено содержит определение для &lt;code&gt;hw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a63e56d03967bc268b8093019d175c83dfcea0a" translate="yes" xml:space="preserve">
          <source>The location of the libraries,</source>
          <target state="translated">Расположение библиотек,</target>
        </trans-unit>
        <trans-unit id="11d6b7b1db5745c2043ea068ebb1b7afa5ed93de" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;THIS_MODULE&lt;/code&gt; would only be defined in the module that exports the function. That way, the declaration:</source>
          <target state="translated">Макрос &lt;code&gt;THIS_MODULE&lt;/code&gt; будет определен только в модуле, который экспортирует функцию. Таким образом, декларация:</target>
        </trans-unit>
        <trans-unit id="eb453bce3db2538452e63a26b6b80e65d71ce5e3" translate="yes" xml:space="preserve">
          <source>The order in which interdependent linked libraries are specified is wrong</source>
          <target state="translated">Порядок указания взаимозависимых связанных библиотек неправилен.</target>
        </trans-unit>
        <trans-unit id="89ab932707a61a0d0cca439734dbbccf264ff41a" translate="yes" xml:space="preserve">
          <source>The order in which interdependent linked libraries are specified is wrong.</source>
          <target state="translated">Порядок указания взаимозависимых связанных библиотек неправильный.</target>
        </trans-unit>
        <trans-unit id="4687e29b604f518f389340188cf76ad7ba3cfeab" translate="yes" xml:space="preserve">
          <source>The order in which libraries are linked DOES matter if the libraries depend on each other. In general, if library &lt;code&gt;A&lt;/code&gt; depends on library &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;libA&lt;/code&gt;&lt;strong&gt;MUST&lt;/strong&gt; appear before &lt;code&gt;libB&lt;/code&gt; in the linker flags.</source>
          <target state="translated">Порядок, в котором библиотеки связаны, имеет значение, если библиотеки зависят друг от друга. В общем, если библиотека &lt;code&gt;A&lt;/code&gt; зависит от библиотеки &lt;code&gt;B&lt;/code&gt; , тогда &lt;code&gt;libA&lt;/code&gt; &lt;strong&gt;ДОЛЖНА&lt;/strong&gt; появляться перед &lt;code&gt;libB&lt;/code&gt; в флагах компоновщика.</target>
        </trans-unit>
        <trans-unit id="c77074a1e65055c9b9d790d1eab74306e35ee769" translate="yes" xml:space="preserve">
          <source>The order of linking libraries &lt;strong&gt;does matter&lt;/strong&gt;.</source>
          <target state="translated">Порядок связывания библиотек &lt;strong&gt;имеет значение&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dfadc843995bf96fc6b50f95dc126fbb8c9952b5" translate="yes" xml:space="preserve">
          <source>The precedence among the syntax rules of translation is specified by the following phases &lt;em&gt;[see footnote]&lt;/em&gt;.</source>
          <target state="translated">Приоритет среди синтаксических правил перевода определяется следующими этапами &lt;em&gt;[см. Сноску]&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="24af2bb789cacc1f5d7b2771021236eabff0f64c" translate="yes" xml:space="preserve">
          <source>The process goes like this:</source>
          <target state="translated">Процесс идет вот так:</target>
        </trans-unit>
        <trans-unit id="f9b8eb5b1acfcafd62389be8ee87a10159a198c2" translate="yes" xml:space="preserve">
          <source>The same result if you compile and link in one step, like:</source>
          <target state="translated">Тот же результат,если вы компилируете и связываете в один шаг,например:</target>
        </trans-unit>
        <trans-unit id="7ebe1560f137cc486a8b481f98db368bc20a5bb3" translate="yes" xml:space="preserve">
          <source>The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters (including comments). &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">Исходный файл разбит на токены предварительной обработки (2.5) и последовательности символов пробела (включая комментарии). &lt;em&gt;[СНиП]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fe7b5fd3c97072d8d933ccaa526d54b2cbe6724" translate="yes" xml:space="preserve">
          <source>The specified errors occur during this last stage of compilation, most commonly referred to as linking. It basically means that you compiled a bunch of implementation files into object files or libraries and now you want to get them to work together.</source>
          <target state="translated">Указанные ошибки возникают на этом последнем этапе компиляции,чаще всего называемом линковкой.В основном это означает,что вы скомпилировали кучу реализационных файлов в объектные файлы или библиотеки и теперь хотите заставить их работать вместе.</target>
        </trans-unit>
        <trans-unit id="d25f8b67d426bc902107dbb9bd3d074093733c3c" translate="yes" xml:space="preserve">
          <source>There is further reading on template friends at &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend#Template_friends&quot;&gt;cppreference&lt;/a&gt; and the &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#template-friends&quot;&gt;C++ FAQ&lt;/a&gt;.</source>
          <target state="translated">Дальнейшее чтение о друзьях шаблонов можно &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/friend#Template_friends&quot;&gt;найти&lt;/a&gt; на cppreference и в &lt;a href=&quot;https://isocpp.org/wiki/faq/templates#template-friends&quot;&gt;C ++ FAQ&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51d2c1022c793ae6c997851c6c2911c491290dcf" translate="yes" xml:space="preserve">
          <source>There is only object file in &lt;code&gt;libmy_lib.a&lt;/code&gt;, namely &lt;code&gt;my_lib.o&lt;/code&gt;, and there's only one thing defined
in &lt;code&gt;my_lib.o&lt;/code&gt;, namely the function &lt;code&gt;hw&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;libmy_lib.a&lt;/code&gt; есть только объектный файл, а именно &lt;code&gt;my_lib.o&lt;/code&gt; , и в &lt;code&gt;my_lib.o&lt;/code&gt; определена только одна вещь, а именно функция &lt;code&gt;hw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7c821ca3bddaa894ed4036bbbcbeef36efee4a" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;process can be seen as a final resort, but is often a good first step&lt;/em&gt;; especially if the code related to the error has recently been added (either locally or from the source repository).</source>
          <target state="translated">Этот &lt;em&gt;процесс можно рассматривать как последнее средство, но часто это хороший первый шаг&lt;/em&gt; ; особенно если недавно был добавлен код, связанный с ошибкой (локально или из исходного репозитория).</target>
        </trans-unit>
        <trans-unit id="6ad971ec73e134596db3aa5d8e277e263d65c535" translate="yes" xml:space="preserve">
          <source>This behaviour is economical at linktime because the linker doesn't have to ponder
whether a shared library is needed by the program: if it's a shared library,
link it. And most libraries in most linkages are shared libraries. But there are disadvantages too:-</source>
          <target state="translated">Такое поведение экономично во время компоновки,потому что компоновщику не нужно задумываться о том,нужна ли программе разделяемая библиотека:если это разделяемая библиотека,компонуйте ее.И большинство библиотек в большинстве линковок являются разделяемыми библиотеками.Но есть и недостатки:-</target>
        </trans-unit>
        <trans-unit id="b891d63d48abebbaef68ad3645c7352c0b2f6c19" translate="yes" xml:space="preserve">
          <source>This can be done with either;</source>
          <target state="translated">Это можно сделать и с тем,и с другим;</target>
        </trans-unit>
        <trans-unit id="49d63f2a1c780d571d49de8e11cd2c50aaeac867" translate="yes" xml:space="preserve">
          <source>This dual functionality is usually obtained through the use of a macro:</source>
          <target state="translated">Эта двойная функциональность обычно достигается с помощью макроса:</target>
        </trans-unit>
        <trans-unit id="83d3af1836050ec99f7b707ceaa03f6ebb1c3de7" translate="yes" xml:space="preserve">
          <source>This happens because base class destructors are called when the object is destroyed implicitly, so a definition is required.</source>
          <target state="translated">Это происходит потому,что деструкторы базового класса вызываются при неявном уничтожении объекта,поэтому требуется определение.</target>
        </trans-unit>
        <trans-unit id="24bcd3540cf7ff25e654495899de496726d609d7" translate="yes" xml:space="preserve">
          <source>This is one of most confusing error messages that every VC++ programmers have seen time and time again. Let&amp;rsquo;s make things clarity first.</source>
          <target state="translated">Это одно из самых запутанных сообщений об ошибках, которые каждый VC ++ программисты видели снова и снова. Давайте сначала проясним ситуацию.</target>
        </trans-unit>
        <trans-unit id="fc953ac37a3ffbcc5b71f7b47d29511fb9fc75f9" translate="yes" xml:space="preserve">
          <source>This is similar to non-&lt;code&gt;virtual&lt;/code&gt; methods with no definition, with the added reasoning that 
the pure declaration generates a dummy vtable and you might get the linker error without using the function:</source>
          <target state="translated">Это похоже на не &lt;code&gt;virtual&lt;/code&gt; методы без определения, с дополнительным объяснением, что чистое объявление генерирует фиктивную vtable, и вы можете получить ошибку компоновщика без использования функции:</target>
        </trans-unit>
        <trans-unit id="f40ecc90472f127aee96a0b27d92ae47b6f13c88" translate="yes" xml:space="preserve">
          <source>This means that when the linker finds &lt;code&gt;-lz&lt;/code&gt; in the linkage sequence, and figures out that this refers 
to the shared library (say) &lt;code&gt;/usr/lib/x86_64-linux-gnu/libz.so&lt;/code&gt;, it wants to know whether any references that it has added to your program that aren't yet defined have definitions that are exported by &lt;code&gt;libz&lt;/code&gt;</source>
          <target state="translated">Это означает, что когда компоновщик находит &lt;code&gt;-lz&lt;/code&gt; в последовательности компоновки и выясняет, что это относится к совместно используемой библиотеке (скажем) &lt;code&gt;/usr/lib/x86_64-linux-gnu/libz.so&lt;/code&gt; , он хочет узнать, есть ли какие-либо ссылки, которые он добавил в вашу программу, которые еще не определены, имеют определения, которые экспортирует &lt;code&gt;libz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7bd9513b51b299b1d7979bb703672c0c803ce8a" translate="yes" xml:space="preserve">
          <source>This searching process is called resolve.</source>
          <target state="translated">Этот процесс поиска называется разрешением.</target>
        </trans-unit>
        <trans-unit id="86854a6361abc1cef804c342988694879f4451d0" translate="yes" xml:space="preserve">
          <source>This trade-off has led to the schismatic situation today. Some distros have
changed their GCC linkage rules for shared libraries so that the &lt;em&gt;as-needed&lt;/em&gt;
principle applies for all libraries. Some distros have stuck with the old
way.</source>
          <target state="translated">Этот компромисс привел к раскольнической ситуации сегодня. Некоторые дистрибутивы изменили свои правила связывания GCC для разделяемых библиотек, так что принцип по &lt;em&gt;мере необходимости&lt;/em&gt; применяется ко всем библиотекам. Некоторые дистрибутивы застряли по-старому.</target>
        </trans-unit>
        <trans-unit id="c6f9c244e10c8db8baeddb7b6f7b289439a89f58" translate="yes" xml:space="preserve">
          <source>This usually happens when two (or more) libraries have a cyclic dependency. Library A attempts to use symbols in B.lib and library B attempts to use symbols from A.lib. Neither exist to start off with. When you attempt to compile A, the link step will fail because it can't find B.lib. A.lib will be generated, but no dll. You then compile B, which will succeed and generate B.lib. Re-compiling A will now work because B.lib is now found.</source>
          <target state="translated">Это обычно происходит,когда две (или более)библиотеки имеют циклическую зависимость.Библиотека A пытается использовать символы в B.lib,а библиотека B пытается использовать символы из A.lib.Ни те,ни другие не существуют для начала.Когда вы пытаетесь скомпилировать A,шаг компоновки будет неудачным,так как не может найти B.lib.A.lib будет сгенерирована,но не будет сгенерирована dll.Затем вы скомпилируете B,которая будет успешной и сгенерирует B.lib.Перекомпиляция А теперь будет работать,потому что B.lib теперь найдена.</target>
        </trans-unit>
        <trans-unit id="dde9568d6caff7f7b573e0d0537eb77fffc36423" translate="yes" xml:space="preserve">
          <source>This way &lt;strong&gt;any function&lt;/strong&gt; contained in file.o and used in main.o that &lt;strong&gt;required &lt;code&gt;path_t&lt;/code&gt;&lt;/strong&gt; gave &quot;undefined reference&quot; errors because &lt;strong&gt;main.o&lt;/strong&gt; referred to &lt;strong&gt;&lt;code&gt;std::filesystem::path&lt;/code&gt;&lt;/strong&gt; but &lt;strong&gt;file.o&lt;/strong&gt; to &lt;strong&gt;&lt;code&gt;std::experimental::filesystem::path&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Таким образом, &lt;strong&gt;любая функция,&lt;/strong&gt; содержащаяся в file.o и используемая в main.o, которая &lt;strong&gt;требует &lt;code&gt;path_t&lt;/code&gt; ,выдает ошибки&lt;/strong&gt; &amp;laquo;неопределенная ссылка&amp;raquo;, потому что &lt;strong&gt;main.o&lt;/strong&gt; ссылается на &lt;strong&gt; &lt;code&gt;std::filesystem::path&lt;/code&gt; &lt;/strong&gt; но &lt;strong&gt;file.o&lt;/strong&gt; на &lt;strong&gt; &lt;code&gt;std::experimental::filesystem::path&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a0d35af95e12b0dd0220a819e99aa16dadf25948" translate="yes" xml:space="preserve">
          <source>To correct this, build all the required libraries and projects with a consistent definition of &lt;code&gt;UNICODE&lt;/code&gt; (and &lt;code&gt;_UNICODE&lt;/code&gt;).</source>
          <target state="translated">Чтобы исправить это, соберите все необходимые библиотеки и проекты с согласованным определением &lt;code&gt;UNICODE&lt;/code&gt; (и &lt;code&gt;_UNICODE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a38dce23594f07d3de4b2b2cc2a5ab210dc62856" translate="yes" xml:space="preserve">
          <source>To correct this, you can declare a template operator before the &lt;code&gt;Foo&lt;/code&gt; type and then declare as a friend, the appropriate instantiation. The syntax is a little awkward, but is looks as follows;</source>
          <target state="translated">Чтобы исправить это, вы можете объявить оператор шаблона перед типом &lt;code&gt;Foo&lt;/code&gt; , а затем объявить в качестве друга соответствующий экземпляр. Синтаксис немного неудобен, но выглядит следующим образом;</target>
        </trans-unit>
        <trans-unit id="b278d2255a2fb839042b27cedfdcde4b13d42e77" translate="yes" xml:space="preserve">
          <source>To find which symbols in an object file are hidden run:</source>
          <target state="translated">Чтобы найти,какие символы в объектном файле скрыты,запустите:</target>
        </trans-unit>
        <trans-unit id="f79e5cf712c1cebae4fd911b423526834fd1d23d" translate="yes" xml:space="preserve">
          <source>To fix this I just needed to &lt;strong&gt;change &amp;lt;experimental::filesystem&amp;gt; in file.h to &amp;lt;filesystem&amp;gt;&lt;/strong&gt;.</source>
          <target state="translated">Чтобы это исправить, мне просто нужно было &lt;strong&gt;изменить &amp;lt;экспериментальный :: файловая система&amp;gt; в file.h на &amp;lt;файловая система&amp;gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2243663083f071145668f251171c65a090b9e5f2" translate="yes" xml:space="preserve">
          <source>To fix this, you must move the definition of &lt;code&gt;X::foo&lt;/code&gt; to the header file or some place visible to the translation unit that uses it.</source>
          <target state="translated">Чтобы это исправить, вы должны переместить определение &lt;code&gt;X::foo&lt;/code&gt; в файл заголовка или в другое место, видимое для модуля перевода, который его использует.</target>
        </trans-unit>
        <trans-unit id="ac8e1b45e6bf97148cb8413c306ad6f5794875ec" translate="yes" xml:space="preserve">
          <source>To solve the issue, i built the MyProject as a LIB, and linked TestProject to this .lib file (i copy paste the generated .lib file into the TestProject folder). I can then build again MyProject as a DLL. It is compiling since the lib to which TestProject is linked does contain code for all methods in classes in MyProject.</source>
          <target state="translated">Чтобы решить эту проблему,я создал MyProject как LIB и связал TestProject с этим .lib файлом (я копирую вставьте сгенерированный .lib файл в папку TestProject).Затем я могу снова собрать MyProject как DLL.Она компилируется,поскольку lib файл,к которому привязан TestProject,содержит код для всех методов в классах MyProject.</target>
        </trans-unit>
        <trans-unit id="1f2f0e08ff5b2e59a5a31d4b807b32101fba5f64" translate="yes" xml:space="preserve">
          <source>Translated translation units and instantiation units are combined as follows: &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">Переведенные единицы перевода и единицы реализации объединяются следующим образом: &lt;em&gt;[SNIP]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7aef8e7498486de3cd6699dbe069fa0c309048a" translate="yes" xml:space="preserve">
          <source>Try start a new project,
copying all source code from the original one.</source>
          <target state="translated">Попробуйте запустить новый проект,скопировав весь исходный код из оригинального.</target>
        </trans-unit>
        <trans-unit id="7715c2c8a7f85ca33fe93cc7817eac47532e5dc6" translate="yes" xml:space="preserve">
          <source>Try to link your program with &lt;code&gt;libz&lt;/code&gt; and fail:</source>
          <target state="translated">Попытайтесь связать вашу программу с &lt;code&gt;libz&lt;/code&gt; и потерпите неудачу:</target>
        </trans-unit>
        <trans-unit id="af5e2c5c3e6cb9cebd2829b0e884257cface4ba2" translate="yes" xml:space="preserve">
          <source>Under &lt;strong&gt;MSVS&lt;/strong&gt;, files added to a project automatically have their object files linked together and a &lt;code&gt;lib&lt;/code&gt; file would be generated (in common usage). To use the symbols in a separate project, you'd 
need to include the &lt;code&gt;lib&lt;/code&gt; files in the project settings. This is done in the Linker section of the project properties, in &lt;code&gt;Input -&amp;gt; Additional Dependencies&lt;/code&gt;. (the path to the &lt;code&gt;lib&lt;/code&gt; file should be
added in &lt;code&gt;Linker -&amp;gt; General -&amp;gt; Additional Library Directories&lt;/code&gt;) When using a third-party library that is provided with a &lt;code&gt;lib&lt;/code&gt; file, failure to do so usually results in the error.</source>
          <target state="translated">В &lt;strong&gt;MSVS к&lt;/strong&gt; файлам, добавляемым в проект, автоматически присоединяются их объектные файлы, и создается файл &lt;code&gt;lib&lt;/code&gt; (при обычном использовании). Чтобы использовать символы в отдельном проекте, вам необходимо включить файлы &lt;code&gt;lib&lt;/code&gt; в настройки проекта. Это делается в разделе Linker свойств проекта, в &lt;code&gt;Input -&amp;gt; Additional Dependencies&lt;/code&gt; . (путь к файлу &lt;code&gt;lib&lt;/code&gt; должен быть добавлен в &lt;code&gt;Linker -&amp;gt; General -&amp;gt; Additional Library Directories&lt;/code&gt; ). При использовании сторонней библиотеки, которая поставляется с файлом &lt;code&gt;lib&lt;/code&gt; , отказ сделать это обычно приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="09353e91d6dc1b681cb300414136507aacd9dc17" translate="yes" xml:space="preserve">
          <source>Under &lt;strong&gt;gcc&lt;/strong&gt; you would specify all object files that are to be linked together in the command line, or compile the implementation files together.</source>
          <target state="translated">В &lt;strong&gt;gcc&lt;/strong&gt; вы должны указать все объектные файлы, которые должны быть связаны вместе в командной строке, или скомпилировать файлы реализации вместе.</target>
        </trans-unit>
        <trans-unit id="e8e07a144ac894fbd4a815eef8cb126c9d8444ca" translate="yes" xml:space="preserve">
          <source>Unspecialized templates must have their definitions visible to all translation units that use them. That means you can't separate the definition of a template
to an implementation file. If you must separate the implementation, the usual workaround is to have an &lt;code&gt;impl&lt;/code&gt; file which you include at the end of the header that
declares the template. A common situation is:</source>
          <target state="translated">Неспециализированные шаблоны должны иметь свои определения, видимые для всех единиц перевода, которые их используют. Это означает, что вы не можете отделить определение шаблона от файла реализации. Если вы должны отделить реализацию, обычный обходной путь должен иметь файл &lt;code&gt;impl&lt;/code&gt; , который вы включаете в конец заголовка, который объявляет шаблон. Распространенная ситуация:</target>
        </trans-unit>
        <trans-unit id="626a6bfb69f923133176d2288c20c9ad3e266875" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;#pragma once&lt;/code&gt; for allowing compiler not to include one header if it was already included in the current .cpp which are compiled</source>
          <target state="translated">Используйте &lt;code&gt;#pragma once&lt;/code&gt; чтобы компилятор не включал один заголовок, если он уже был включен в текущий .cpp, который компилируется</target>
        </trans-unit>
        <trans-unit id="652d6febf33e65c27e03abc9bf57e88d8db07539" translate="yes" xml:space="preserve">
          <source>Use the linker to help diagnose the error</source>
          <target state="translated">Воспользуйтесь компоновщиком для диагностики ошибки</target>
        </trans-unit>
        <trans-unit id="3df12d1763a76db1eb5f9e0c7142ced823b24c14" translate="yes" xml:space="preserve">
          <source>Visual Studio search into file &lt;strong&gt;.vcxproj&lt;/strong&gt; and start compiling each file which has the extension .cpp. Order of compilation is undefined.So you must not assume that the file main.cpp is compiled first</source>
          <target state="translated">Visual Studio ищет файл &lt;strong&gt;.vcxproj&lt;/strong&gt; и начинает компилировать каждый файл с расширением .cpp. Порядок компиляции не определен. Так что вы не должны предполагать, что файл main.cpp компилируется первым</target>
        </trans-unit>
        <trans-unit id="bc6493aa79682062f1e35506dac73e5d517d7fa9" translate="yes" xml:space="preserve">
          <source>What are undefined reference/unresolved external symbol errors? What are common causes and how to fix/prevent them?</source>
          <target state="translated">Что такое неопределённые ошибки нерешённых внешних символов? Каковы общие причины и как их разоблачить?</target>
        </trans-unit>
        <trans-unit id="db7e500851b237b0a75617adc43159c4e601d013" translate="yes" xml:space="preserve">
          <source>What are you doing wrong?</source>
          <target state="translated">Что ты делаешь не так?</target>
        </trans-unit>
        <trans-unit id="2d7204271f918e6dc824c4de713ad791b4dc1110" translate="yes" xml:space="preserve">
          <source>What is an undefined reference/unresolved external symbol error and how do I fix it</source>
          <target state="translated">Что такое неопределенная ошибка неурегулированного внешнего символа и как ее исправить?</target>
        </trans-unit>
        <trans-unit id="4632922517e4c4150df04140a0a11bc46ff27b5a" translate="yes" xml:space="preserve">
          <source>When a translation unit is compiled with &lt;code&gt;-fvisibility=hidden&lt;/code&gt; the resulting symbols have still external linkage (shown with upper case symbol type by &lt;code&gt;nm&lt;/code&gt;) and can be used for external linkage without problem if the object files become part of a static libraries. The linkage becomes local only when the object files are linked into a shared library.</source>
          <target state="translated">Когда модуль трансляции компилируется с &lt;code&gt;-fvisibility=hidden&lt;/code&gt; , результирующие символы все еще имеют внешнюю связь (показывается с символом верхнего регистра в виде &lt;code&gt;nm&lt;/code&gt; ) и могут без проблем использоваться для внешней связи, если объектные файлы становятся частью статических библиотек. Связь становится локальной, только когда объектные файлы связаны в общей библиотеке.</target>
        </trans-unit>
        <trans-unit id="2c08affaeeed528ac9c1fa3dfa4effce084687ac" translate="yes" xml:space="preserve">
          <source>When linking against shared libraries, make sure that the used symbols are not hidden.</source>
          <target state="translated">При линковке с разделяемыми библиотеками убедитесь,что используемые символы не скрыты.</target>
        </trans-unit>
        <trans-unit id="9ca2a7655109619c5715fb8ca7ccc73f3615a640" translate="yes" xml:space="preserve">
          <source>When you run the command above, &lt;code&gt;gcc&lt;/code&gt; figures out that you want compilation +
linkage. So behind the scenes, it generates a compilation command, and runs
it, then generates a linkage command, and runs it, as if &lt;em&gt;you&lt;/em&gt; had run the
two commands:</source>
          <target state="translated">Когда вы запускаете команду, &lt;code&gt;gcc&lt;/code&gt; выше, gcc обнаруживает, что вам нужна компиляция + компоновка. Так что за кулисами он генерирует команду компиляции и запускает ее, затем генерирует команду связывания и запускает ее, как если бы &lt;em&gt;вы&lt;/em&gt; выполнили две команды:</target>
        </trans-unit>
        <trans-unit id="4567f3b27b39712303adc4658d2e89c9f3ed6ec0" translate="yes" xml:space="preserve">
          <source>When you try to link the program like:</source>
          <target state="translated">Когда вы пытаетесь связать программу как:</target>
        </trans-unit>
        <trans-unit id="b31400492742589d7742b79425b053a4e29f6f8f" translate="yes" xml:space="preserve">
          <source>When you use the template to make sure you include the definition of each template function in the header file for allowing the compiler to generate appropriate code for any instantiations.</source>
          <target state="translated">Когда вы используете шаблон,убедитесь,что вы включили определение каждой шаблонной функции в заголовочный файл,чтобы компилятор мог сгенерировать соответствующий код для любых инстанций.</target>
        </trans-unit>
        <trans-unit id="e4d80ad940bb876bd92a024b5ff663f048b0473e" translate="yes" xml:space="preserve">
          <source>When your include paths are different</source>
          <target state="translated">Когда ваши включенные пути отличаются</target>
        </trans-unit>
        <trans-unit id="03365de1caa8827769bae8158a775de517156e6d" translate="yes" xml:space="preserve">
          <source>Which roughly corresponds to Windows'/MSVC-version:</source>
          <target state="translated">Что примерно соответствует Windows'MSVC-версии:</target>
        </trans-unit>
        <trans-unit id="246959a741f4264372238420ebdad97bd89a88ec" translate="yes" xml:space="preserve">
          <source>White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The
  resulting tokens are syntactically and semantically analyzed and
  translated as a translation unit. &lt;em&gt;[SNIP]&lt;/em&gt;</source>
          <target state="translated">Пробелы, разделяющие токены, больше не имеют значения. Каждый токен предварительной обработки преобразуется в токен. (2.7). Полученные токены синтаксически и семантически анализируются и переводятся как единица перевода. &lt;em&gt;[СНиП]&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b3057b9b641cbee71aae82fe2b981cf8b49a7f80" translate="yes" xml:space="preserve">
          <source>Why do I still get this problem even if I compile-and-link at the same time?</source>
          <target state="translated">Почему у меня до сих пор эта проблема,даже если я компилирую и связываюсь одновременно?</target>
        </trans-unit>
        <trans-unit id="4c6dfe4286bb4038ff6570e5b46f04c49bbf7bf5" translate="yes" xml:space="preserve">
          <source>You are trying to compile and link your program with the GCC toolchain.</source>
          <target state="translated">Вы пытаетесь скомпилировать и связать свою программу с инструментальной цепью GCC.</target>
        </trans-unit>
        <trans-unit id="91c1836cb1d64ed1ad44ab634dca30d630520583" translate="yes" xml:space="preserve">
          <source>You build your static library:</source>
          <target state="translated">Ты создаешь свою статическую библиотеку:</target>
        </trans-unit>
        <trans-unit id="2fd7e03d89627c87bdf0cf1f8eddb4e44c4ee89f" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;nm&lt;/code&gt; with the option &lt;code&gt;-C&lt;/code&gt; to demangle the names (if C++ was used).</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;nm&lt;/code&gt; с опцией &lt;code&gt;-C&lt;/code&gt; , чтобы разобрать имена (если использовался C ++).</target>
        </trans-unit>
        <trans-unit id="eb4ed51d89a6db08d7aac2b244cdb0601cb7bc64" translate="yes" xml:space="preserve">
          <source>You can check whether the symbols your are looking for are external by invoking:</source>
          <target state="translated">Вы можете проверить,являются ли символы,которые вы ищете,внешними по ссылке:</target>
        </trans-unit>
        <trans-unit id="e80a1a5e2677479f692a83c2c89c313fa9e2dc07" translate="yes" xml:space="preserve">
          <source>You can similary import/export classes:</source>
          <target state="translated">Вы можете симилировать импорт-экспорт классов:</target>
        </trans-unit>
        <trans-unit id="e3de844a4d66034d092d8886a7ce6acf2d81f628" translate="yes" xml:space="preserve">
          <source>You compile your program:</source>
          <target state="translated">Ты компилируешь свою программу:</target>
        </trans-unit>
        <trans-unit id="5f4c7708a6df0a34a544a31a0505e1654dab7e88" translate="yes" xml:space="preserve">
          <source>You may have missed to choose the right project type with your actual IDE. The IDE may want to bind e.g. Windows Application projects to such entry point function (as specified in the missing reference above), instead of the commonly used &lt;code&gt;int main(int argc, char** argv);&lt;/code&gt; signature.</source>
          <target state="translated">Возможно, вы пропустили выбор правильного типа проекта с вашей фактической IDE. В среде IDE может потребоваться привязать, например, проекты приложений Windows к такой функции точки входа (как указано в отсутствующей ссылке выше), вместо обычно используемого &lt;code&gt;int main(int argc, char** argv);&lt;/code&gt; подпись.</target>
        </trans-unit>
        <trans-unit id="9e82259a675941d9948a2eeb64a675ff5f0bac6e" translate="yes" xml:space="preserve">
          <source>You may see a message like:</source>
          <target state="translated">Ты можешь увидеть такое сообщение:</target>
        </trans-unit>
        <trans-unit id="0e60f4f947984fbf84f6c4fd28e3b1b296e997d0" translate="yes" xml:space="preserve">
          <source>You might ask how one ends up in a situation like that? &lt;strong&gt;Include paths&lt;/strong&gt; of course! If when compiling the shared library, the include path leads to &lt;code&gt;header1.h&lt;/code&gt; and you end up using &lt;code&gt;header2.h&lt;/code&gt; in your own program, you'll be left scratching your header wondering what happened (pun intended).</source>
          <target state="translated">Вы можете спросить, как человек попадает в такую ​​ситуацию? &lt;strong&gt;Включите пути&lt;/strong&gt; конечно! Если при компиляции разделяемой библиотеки путь включения приводит к &lt;code&gt;header1.h&lt;/code&gt; , и вы в конечном итоге используете &lt;code&gt;header2.h&lt;/code&gt; в своей собственной программе, вам останется поцарапать заголовок, задаваясь вопросом, что произошло (каламбур предназначен).</target>
        </trans-unit>
        <trans-unit id="2d39d52ae6b215a68d9cf55a1d98a408fa72b8cc" translate="yes" xml:space="preserve">
          <source>You try to link it with &lt;code&gt;libmy_lib.a&lt;/code&gt; and fail:</source>
          <target state="translated">Вы пытаетесь связать это с &lt;code&gt;libmy_lib.a&lt;/code&gt; и терпите неудачу:</target>
        </trans-unit>
        <trans-unit id="ac3540a5f0b565ea8381987f3a836626c11a6c8e" translate="yes" xml:space="preserve">
          <source>Your linkage consumes libraries before the object files that refer to them</source>
          <target state="translated">Ваша ссылка потребляет библиотеки перед объектными файлами,которые на них ссылаются.</target>
        </trans-unit>
        <trans-unit id="374fcc2688ffa3e097d03ef0cda91f4abae3f9a6" translate="yes" xml:space="preserve">
          <source>Your linkage fails with &lt;code&gt;undefined reference to&lt;/code&gt;&lt;em&gt;something&lt;/em&gt; errors.</source>
          <target state="translated">Ваша связь терпит неудачу с &lt;code&gt;undefined reference to&lt;/code&gt; &lt;em&gt;что-то&lt;/em&gt; ошибки.</target>
        </trans-unit>
        <trans-unit id="a97d5c4fcdbab0b3e334224158a61c8ab8cdf3b8" translate="yes" xml:space="preserve">
          <source>Your linkage specifies all of the necessary libraries and library search paths</source>
          <target state="translated">Ваша ссылка указывает все необходимые библиотеки и пути поиска библиотек</target>
        </trans-unit>
        <trans-unit id="1ede8f96ef941a4cd4a8b47db4fd4ec6dee457d7" translate="yes" xml:space="preserve">
          <source>Your program wants to refer to just one thing that has a definition exported by &lt;code&gt;libz&lt;/code&gt;,
namely the function &lt;code&gt;zlibVersion&lt;/code&gt;, which is referred to just once, in &lt;code&gt;eg2.c&lt;/code&gt;.
If the linker adds that reference to your program, and then finds the definition
exported by &lt;code&gt;libz&lt;/code&gt;, the reference is &lt;em&gt;resolved&lt;/em&gt;</source>
          <target state="translated">Ваша программа хочет сослаться только на одну вещь, которая имеет определение, экспортируемое &lt;code&gt;libz&lt;/code&gt; , а именно на функцию &lt;code&gt;zlibVersion&lt;/code&gt; , на которую ссылаются только один раз, в &lt;code&gt;eg2.c&lt;/code&gt; . Если компоновщик добавляет эту ссылку в вашу программу, а затем находит определение, экспортированное &lt;code&gt;libz&lt;/code&gt; , ссылка &lt;em&gt;разрешается&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6630645888101f4b1ebaafc85246e04a796c1112" translate="yes" xml:space="preserve">
          <source>[1] By project I mean a set of source files that are linked together to produce either a library or an executable.</source>
          <target state="translated">[1]Под проектом я понимаю набор исходных файлов,которые связаны между собой для создания либо библиотеки,либо исполняемого файла.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="73825e2f27276ce7cc0cb99fe4926aefead625b6" translate="yes" xml:space="preserve">
          <source>and rebuild an object file</source>
          <target state="translated">и пересобрать объектный файл</target>
        </trans-unit>
        <trans-unit id="3a85961b64655acfc507843ec1ba2838a9155bab" translate="yes" xml:space="preserve">
          <source>and run it</source>
          <target state="translated">и запустить его</target>
        </trans-unit>
        <trans-unit id="6ab5682fa6ec7ce3b574c508f69fdd94179f902d" translate="yes" xml:space="preserve">
          <source>and similar errors with &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt;:</source>
          <target state="translated">и подобные ошибки с &lt;strong&gt;Microsoft Visual Studio&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="73d70fffc648342f33ca44795d6cc820d7069f22" translate="yes" xml:space="preserve">
          <source>and tells the compiler that the definition is in one of the libraries you linked against (also see &lt;strong&gt;1)&lt;/strong&gt;).</source>
          <target state="translated">и сообщает компилятору, что определение находится в одной из библиотек, с которыми вы связаны (см. также &lt;strong&gt;1)&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="a885b4bb68e35a1301318ebf72bf542d958c8233" translate="yes" xml:space="preserve">
          <source>and tells the compiler to export the function, as the current module contains its definition. When including the declaration in a different module, it would expand to</source>
          <target state="translated">и говорит компилятору экспортировать функцию,так как текущий модуль содержит ее определение.При включении объявления в другой модуль оно будет расширено до</target>
        </trans-unit>
        <trans-unit id="8081e608d396eb9fd48db5d9cb98df468f9b43c5" translate="yes" xml:space="preserve">
          <source>and you attempt to use it in a C++ program with C++ linkage.</source>
          <target state="translated">и вы пытаетесь использовать его в программе на Си++со связью с Си++.</target>
        </trans-unit>
        <trans-unit id="c02ceb78ff4863ee1a75d232c4f53af56b182ec9" translate="yes" xml:space="preserve">
          <source>becomes:</source>
          <target state="translated">becomes:</target>
        </trans-unit>
        <trans-unit id="f799f07bf625ffbca0fe04fdd368917957d04df0" translate="yes" xml:space="preserve">
          <source>correct would be to use a header file and include it in file2.cpp &lt;em&gt;and&lt;/em&gt; file1.cpp</source>
          <target state="translated">правильно будет использовать заголовочный файл и включить его в file2.cpp &lt;em&gt;и&lt;/em&gt; file1.cpp</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">распространиться до</target>
        </trans-unit>
        <trans-unit id="8597eabf07801651c88304087bf20f69ac103fa3" translate="yes" xml:space="preserve">
          <source>i.e. you should have like below</source>
          <target state="translated">т.е.тебе бы хотелось,чтобы внизу</target>
        </trans-unit>
        <trans-unit id="6c8457cd65849bf5a9285f8b862e990e1a44ac09" translate="yes" xml:space="preserve">
          <source>instead of:</source>
          <target state="translated">а не..:</target>
        </trans-unit>
        <trans-unit id="4f0aa52d656a3d75867f784b7e9c5d23bf1321c0" translate="yes" xml:space="preserve">
          <source>link</source>
          <target state="translated">link</target>
        </trans-unit>
        <trans-unit id="293dce46f676980a9b1278e7251ff73eb7fa797d" translate="yes" xml:space="preserve">
          <source>note: i use g++ and Linux and all examples is for it</source>
          <target state="translated">примечание:я использую g++и Linux и все примеры для него.</target>
        </trans-unit>
        <trans-unit id="36c55470c929c5d5f4d41ac78ab446fd5b77009b" translate="yes" xml:space="preserve">
          <source>now local_var_name has Bind GLOBAL (was LOCAL)</source>
          <target state="translated">теперь local_var_name имеет Bind GLOBAL (был LOCAL)</target>
        </trans-unit>
        <trans-unit id="fb74205393b3bb80203f54f7a8c9bcb830e8763e" translate="yes" xml:space="preserve">
          <source>ok, see readelf output (symbols)</source>
          <target state="translated">ок,смотрите вывод (символы)на чтение</target>
        </trans-unit>
        <trans-unit id="3a328af911638e5bfc90b4e0e69e9c25737cc9a5" translate="yes" xml:space="preserve">
          <source>ok, we hack it :)</source>
          <target state="translated">Хорошо,мы взломаем его :)</target>
        </trans-unit>
        <trans-unit id="2328aeacf83c4c55bc1147be999690bfc6241ad3" translate="yes" xml:space="preserve">
          <source>or outside:</source>
          <target state="translated">или снаружи:</target>
        </trans-unit>
        <trans-unit id="ceeb2cffd5c7262a750a941ceb1e733b45fbb7ca" translate="yes" xml:space="preserve">
          <source>src2.cpp exports nothing and we have seen no its symbols</source>
          <target state="translated">src2.cpp ничего не экспортирует и мы не видели его символов.</target>
        </trans-unit>
        <trans-unit id="2f0f1d7be52efe820ea8f283992862328386c64a" translate="yes" xml:space="preserve">
          <source>surely gcc has to compile &lt;code&gt;eg1.c&lt;/code&gt; first, and then link the resulting
object file with &lt;code&gt;libmy_lib.a&lt;/code&gt;.  So how can it not know that object file
is needed when it's doing the linking?</source>
          <target state="translated">конечно, gcc сначала должен скомпилировать &lt;code&gt;eg1.c&lt;/code&gt; , а затем связать полученный объектный файл с &lt;code&gt;libmy_lib.a&lt;/code&gt; . Так как же он не может знать, что объектный файл нужен, когда он выполняет связывание?</target>
        </trans-unit>
        <trans-unit id="e01b8bf7137076c13f10eccf3ac7d89d9ac67196" translate="yes" xml:space="preserve">
          <source>the hidden/local symbols are shown by &lt;code&gt;nm&lt;/code&gt; with lowercase symbol type, for example &lt;code&gt;t&lt;/code&gt; instead of `T for code-section:</source>
          <target state="translated">скрытые / локальные символы обозначаются символом &lt;code&gt;nm&lt;/code&gt; с типом символов нижнего регистра, например, &lt;code&gt;t&lt;/code&gt; вместо `T для секции кода:</target>
        </trans-unit>
        <trans-unit id="5e0942b4293aac626166820cf457118f4f66b257" translate="yes" xml:space="preserve">
          <source>the linker &lt;em&gt;has not added&lt;/em&gt;&lt;code&gt;eg1.o&lt;/code&gt;&lt;em&gt;to the program&lt;/em&gt; when it sees
&lt;code&gt;-lmy_lib&lt;/code&gt;. Because at that point, it has not seen &lt;code&gt;eg1.o&lt;/code&gt;.
Your program does not yet make any references to &lt;code&gt;hw&lt;/code&gt;: it
does not yet make any references &lt;em&gt;at all&lt;/em&gt;, because all the references it makes
are in &lt;code&gt;eg1.o&lt;/code&gt;.</source>
          <target state="translated">компоновщик &lt;em&gt;не добавил&lt;/em&gt; &lt;code&gt;eg1.o&lt;/code&gt; &lt;em&gt;в программу,&lt;/em&gt; когда видит &lt;code&gt;-lmy_lib&lt;/code&gt; . Потому что на тот момент он еще не видел &lt;code&gt;eg1.o&lt;/code&gt; . Ваша программа еще не делает никаких ссылок на &lt;code&gt;hw&lt;/code&gt; : она вообще не делает никаких ссылок, потому что все ссылки, которые она делает, находятся в &lt;code&gt;eg1.o&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="474bf0c29b756b32c6ea11e2c24831191c57e8a2" translate="yes" xml:space="preserve">
          <source>the order of events is wrong in just the same way as with example 1.
At the point when the linker finds &lt;code&gt;-lz&lt;/code&gt;, there are &lt;em&gt;no&lt;/em&gt; references to anything
in the program: they are all in &lt;code&gt;eg2.o&lt;/code&gt;, which has not yet been seen. So the
linker decides it has no use for &lt;code&gt;libz&lt;/code&gt;. When it reaches &lt;code&gt;eg2.o&lt;/code&gt;, adds it to the program,
and then has undefined reference to &lt;code&gt;zlibVersion&lt;/code&gt;, the linkage sequence is finished;
that reference is unresolved, and the linkage fails.</source>
          <target state="translated">порядок событий неправильный точно так же, как в примере 1. В тот момент, когда компоновщик находит &lt;code&gt;-lz&lt;/code&gt; , в программе &lt;em&gt;нет&lt;/em&gt; ссылок на что-либо: все они находятся в &lt;code&gt;eg2.o&lt;/code&gt; , который еще не был замечен , Поэтому компоновщик решает, что он не &lt;code&gt;libz&lt;/code&gt; для libz . Когда он достигает &lt;code&gt;eg2.o&lt;/code&gt; , добавляет его в программу и затем имеет неопределенную ссылку на &lt;code&gt;zlibVersion&lt;/code&gt; , последовательность связывания заканчивается; эта ссылка не разрешена, и связь не работает.</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="7979c3fe74f25deb6892e5101b26610dc97c75eb" translate="yes" xml:space="preserve">
          <source>to declare function foo(), and call it in another function body, say &lt;code&gt;bar()&lt;/code&gt;:</source>
          <target state="translated">объявить функцию foo () и вызвать ее в другом теле функции, скажем &lt;code&gt;bar()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ec79436cd4ee8fbface339724362fc515088bfd8" translate="yes" xml:space="preserve">
          <source>undefined reference to `WinMain@16'</source>
          <target state="translated">неопределенная ссылка на `WinMain@16''</target>
        </trans-unit>
        <trans-unit id="b888bea9cd6729fbf7ebdc759e10b2f2dacf405c" translate="yes" xml:space="preserve">
          <source>we have changed the visibility of local_var_name and set its value to 456789.
Try to build an object file from it</source>
          <target state="translated">мы изменили видимость имени local_var_name и установили его значение на 456789.Попробуйте построить из него объектный файл</target>
        </trans-unit>
        <trans-unit id="a3bc4f467d60d6e7137cb42e5a2693f58a0ffef5" translate="yes" xml:space="preserve">
          <source>which is just example 2 again.</source>
          <target state="translated">а это опять просто пример 2.</target>
        </trans-unit>
        <trans-unit id="416857d2967c5146284d55951fb33a942176a9f1" translate="yes" xml:space="preserve">
          <source>will generate the following errors with &lt;strong&gt;GCC&lt;/strong&gt;:</source>
          <target state="translated">сгенерирует следующие ошибки с &lt;strong&gt;GCC&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="767ebf562599ebd8219e0bce2533fd52b533baeb" translate="yes" xml:space="preserve">
          <source>works just fine for you!</source>
          <target state="translated">отлично работает для тебя!</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
