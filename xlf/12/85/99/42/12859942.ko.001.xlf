<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/12859942">
    <body>
      <group id="12859942">
        <trans-unit id="6cda3a126b38102fb9da9475533aaf3305f7fc81" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;Stored procedures&lt;/a&gt; (can't handle multiple result sets)</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;저장 프로 시저&lt;/a&gt; (여러 결과 집합을 처리 할 수 ​​없음)</target>
        </trans-unit>
        <trans-unit id="b3ded5903fe8ef5cae508b2ae92f896e2213e013" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; is the 'improved' extension for working with MySQL databases. It takes advantage of features that are available in newer versions of the MySQL server, exposes both a function-oriented and an object-oriented interface to the developer and a does few other nifty things.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; 는 MySQL 데이터베이스 작업을위한 '개선 된'확장입니다. 최신 버전의 MySQL 서버에서 사용할 수있는 기능을 활용하고, 기능 지향 및 객체 지향 인터페이스를 개발자에게 노출시키고 다른 멋진 기능은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="d17381afa285d004079efeb7bdb099fd00671abd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; offers an API that consolidates most of the functionality that was previously spread across the major database access extensions, i.e. MySQL, PostgreSQL, SQLite, MSSQL, etc. The interface exposes high-level objects for the programmer to work with database connections, queries and result sets, and low-level drivers perform communication and resource handling with the database server. A lot of discussion and work is going into PDO and it&amp;rsquo;s considered the appropriate method of working with databases in modern, professional code.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; 는 이전에 주요 데이터베이스 액세스 확장 (예 : MySQL, PostgreSQL, SQLite, MSSQL 등)에 분산 된 대부분의 기능을 통합하는 API를 제공합니다.이 인터페이스는 프로그래머가 데이터베이스 연결, 쿼리 및 결과 세트 및 저수준 드라이버는 데이터베이스 서버와의 통신 및 자원 처리를 수행합니다. 많은 토론과 작업이 PDO로 진행되고 있으며 현대적이고 전문적인 코드로 데이터베이스를 사용하는 적절한 방법으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="046ffaee85489e61d2263f509946570f847cc8ea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchall.php&quot;&gt;&lt;code&gt;PDOStatement::fetchAll()&lt;/code&gt;&lt;/a&gt; - Returns an array containing all of the result set rows</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchall.php&quot;&gt; &lt;code&gt;PDOStatement::fetchAll()&lt;/code&gt; &lt;/a&gt; -모든 결과 집합 행을 포함하는 배열을 반환</target>
        </trans-unit>
        <trans-unit id="b28a28e308fceeb11923ec4f6b51a94fdc522831" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchcolumn.php&quot;&gt;&lt;code&gt;PDOStatement::fetchColumn()&lt;/code&gt;&lt;/a&gt; - Returns a single column from the next row of a result set</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchcolumn.php&quot;&gt; &lt;code&gt;PDOStatement::fetchColumn()&lt;/code&gt; &lt;/a&gt; -결과 세트의 다음 행에서 단일 열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f38ca8ad882074ee896d85b8ff9c3b2f2d31a650" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchobject.php&quot;&gt;&lt;code&gt;PDOStatement::fetchObject()&lt;/code&gt;&lt;/a&gt; - Fetches the next row and returns it as an object.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchobject.php&quot;&gt; &lt;code&gt;PDOStatement::fetchObject()&lt;/code&gt; &lt;/a&gt; -다음 행을 가져 와서 객체로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f018387924cb8a35b2d0d50bcf690d933b109aa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/pdostatement.setfetchmode.php&quot;&gt;&lt;code&gt;PDOStatement::setFetchMode()&lt;/code&gt;&lt;/a&gt; - Set the default fetch mode for this statement</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/pdostatement.setfetchmode.php&quot;&gt; &lt;code&gt;PDOStatement::setFetchMode()&lt;/code&gt; &lt;/a&gt; -이 문장에 대한 기본 페치 모드 설정</target>
        </trans-unit>
        <trans-unit id="0fa08d46c3da4c6dbad08eae37dd7aabd954a814" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/q/12859942&quot;&gt;&lt;strong&gt;Please, don't use &lt;code&gt;mysql_*&lt;/code&gt; functions in new code&lt;/strong&gt;&lt;/a&gt;. They are no longer maintained &lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;and are officially deprecated&lt;/a&gt;. See the &lt;a href=&quot;http://uk.php.net/manual/en/function.mysql-connect.php&quot;&gt;&lt;strong&gt;red box&lt;/strong&gt;&lt;/a&gt;? Learn about &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;em&gt;prepared statements&lt;/em&gt;&lt;/a&gt; instead, and use &lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO&lt;/a&gt; or &lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt; - &lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;this article&lt;/a&gt; will help you decide which. If you choose PDO, &lt;a href=&quot;http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers&quot;&gt;here is a good tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/12859942&quot;&gt;&lt;strong&gt;새 코드에서 &lt;code&gt;mysql_*&lt;/code&gt; 함수를 사용하지 마십시오&lt;/strong&gt;&lt;/a&gt; . 더 이상 유지 &lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;관리되지 않으며 공식적으로 더 이상 사용되지 않습니다&lt;/a&gt; . &lt;a href=&quot;http://uk.php.net/manual/en/function.mysql-connect.php&quot;&gt;&lt;strong&gt;빨간 상자를 보&lt;/strong&gt;&lt;/a&gt; 시겠습니까? 대신 &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;em&gt;준비된 명령문에&lt;/em&gt;&lt;/a&gt; 대해 배우고 &lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO&lt;/a&gt; 또는 &lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi를&lt;/a&gt; 사용 &lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;하십시오.이 기사&lt;/a&gt; 는 어느 것을 결정하는 데 도움 이 됩니다. PDO를 선택하면 다음 &lt;a href=&quot;http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers&quot;&gt;은 좋은 튜토리얼&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f6ffdb59a47d534bf1c4ce50a2ab19c2c804aac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OR die()&lt;/code&gt; is not a good way to handle the error since we can not handle the thing in &lt;code&gt;die&lt;/code&gt;. It will just end the script abruptly and then echo the error to the screen which you usually do NOT want to show to your end users, and let bloody hackers discover your schema. Alternately, the return values of &lt;code&gt;mysql_*&lt;/code&gt; functions can often be used in conjunction with &lt;a href=&quot;http://php.net/mysql_error&quot;&gt;mysql_error()&lt;/a&gt; to handle errors.</source>
          <target state="translated">&lt;code&gt;OR die()&lt;/code&gt; 는 die 에서 처리 할 수 ​​없기 때문에 오류를 처리하는 좋은 방법이 아닙니다. 스크립트를 갑자기 종료 한 다음 일반적으로 최종 사용자에게 표시하고 싶지 않은 화면에 오류를 표시하고 피의 해커가 스키마를 발견하게합니다. 또는 &lt;code&gt;mysql_*&lt;/code&gt; 함수의 반환 값을 &lt;a href=&quot;http://php.net/mysql_error&quot;&gt;mysql_error ()&lt;/a&gt; 와 함께 사용하여 오류를 처리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8d90257eb4cba009d9da07c259d01492dd67cb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO::ERRMODE_EXCEPTION&lt;/code&gt;: Throw exceptions. It represents an error raised by PDO. You should not throw a &lt;code&gt;PDOException&lt;/code&gt; from your own code. See &lt;em&gt;Exceptions&lt;/em&gt; for more information about exceptions in PHP. It acts very much like &lt;code&gt;or die(mysql_error());&lt;/code&gt;, when it isn't caught. But unlike &lt;code&gt;or die()&lt;/code&gt;, the &lt;code&gt;PDOException&lt;/code&gt; can be caught and handled gracefully if you choose to do so.</source>
          <target state="translated">&lt;code&gt;PDO::ERRMODE_EXCEPTION&lt;/code&gt; : 예외가 발생합니다. PDO에 의해 발생한 오류를 나타냅니다. 자신의 코드에서 &lt;code&gt;PDOException&lt;/code&gt; 을 발생시키지 않아야합니다. PHP &lt;em&gt;예외에&lt;/em&gt; 대한 자세한 내용은 &lt;em&gt;예외&lt;/em&gt; 를 참조하십시오. 그것은 매우 비슷 &lt;code&gt;or die(mysql_error());&lt;/code&gt; 잡히지 않을 때. 그러나 &lt;code&gt;or die()&lt;/code&gt; 와 달리 &lt;code&gt;PDOException&lt;/code&gt; 은 원하는 경우 올바르게 처리하고 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5515c76631bc1066c78ab2cd9cdef4e2a606b1d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO::ERRMODE_SILENT&lt;/code&gt;. It's just setting error codes and acts pretty much the same as &lt;code&gt;mysql_*&lt;/code&gt; where you must check each result and then look at &lt;code&gt;$db-&amp;gt;errorInfo();&lt;/code&gt; to get the error details.</source>
          <target state="translated">&lt;code&gt;PDO::ERRMODE_SILENT&lt;/code&gt; 그것은 단지 오류 코드를 설정하는 것입니다. 각 결과를 확인한 다음 &lt;code&gt;$db-&amp;gt;errorInfo();&lt;/code&gt; 를 봐야하는 &lt;code&gt;mysql_*&lt;/code&gt; 와 거의 동일하게 작동합니다 . 오류 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7c4b1bce0513c7fb8025092a93478da761f79aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO::ERRMODE_WARNING&lt;/code&gt; Raise &lt;code&gt;E_WARNING&lt;/code&gt;. (Run-time warnings (non-fatal errors). Execution of the script is not halted.)</source>
          <target state="translated">&lt;code&gt;PDO::ERRMODE_WARNING&lt;/code&gt; &lt;code&gt;E_WARNING&lt;/code&gt; 을 올립니다. 런타임 경고 (치명적이지 않은 오류). 스크립트 실행이 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e02705f324751cbe9f1129e09c39ee8bf3c6790e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO::FETCH_ASSOC&lt;/code&gt;: returns an array indexed by column name as returned in your result set</source>
          <target state="translated">&lt;code&gt;PDO::FETCH_ASSOC&lt;/code&gt; : 결과 세트에 리턴 된대로 열 이름으로 색인화 된 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c53f912043ed13d79a8752a65b60437033b9a967" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO::FETCH_BOTH&lt;/code&gt; (default): returns an array indexed by both column name and 0-indexed column number as returned in your result set</source>
          <target state="translated">&lt;code&gt;PDO::FETCH_BOTH&lt;/code&gt; (기본값) : 결과 세트에 리턴 된대로 열 이름 및 0 색인화 된 열 번호로 색인화 된 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="64c39564f8d39a4c2fdc909d2132ee966fa92c95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO&lt;/code&gt; offers a better solution: exceptions. Anything we do with &lt;code&gt;PDO&lt;/code&gt; should be wrapped in a &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; block. We can force &lt;code&gt;PDO&lt;/code&gt; into one of three error modes by setting the error mode attribute. Three error handling modes are below.</source>
          <target state="translated">&lt;code&gt;PDO&lt;/code&gt; 는 더 나은 솔루션을 제공합니다 : 예외. &lt;code&gt;PDO&lt;/code&gt; 로 수행하는 모든 작업은 &lt;code&gt;try&lt;/code&gt; - &lt;code&gt;catch&lt;/code&gt; 블록으로 싸야 합니다. error mode 속성을 설정하여 &lt;code&gt;PDO&lt;/code&gt; 를 세 가지 오류 모드 중 하나로 강제 설정할 수 있습니다. 다음은 세 가지 오류 처리 모드입니다.</target>
        </trans-unit>
        <trans-unit id="b690a13d160e3bb95e6e3e9ad4972ca25987a5b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; prepared queries</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; 준비된 쿼리</target>
        </trans-unit>
        <trans-unit id="8bf705f99d5823b73420e7e85ef046dfddb3f6d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ext/mysql&lt;/code&gt; was built for &lt;strong&gt;MySQL 3.23&lt;/strong&gt; and only got very few additions since then while mostly keeping compatibility with this old version which makes the code a bit harder to maintain. Missing features that is not supported by &lt;code&gt;ext/mysql&lt;/code&gt; include: (&lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;from PHP manual&lt;/a&gt;&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;ext/mysql&lt;/code&gt; 은 &lt;strong&gt;MySQL 3.23&lt;/strong&gt; 용으로 제작되었으며 그 이후로 추가 된 내용이 거의 없었지만 대부분 이전 버전과의 호환성을 유지하여 코드를 유지하기가 조금 더 어려워졌습니다. &lt;code&gt;ext/mysql&lt;/code&gt; 에서 지원하지 않는 기능은 다음을 포함합니다 : ( &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;PHP 매뉴얼에서&lt;/a&gt;&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="616d50367e59cecd8e39af146c7cc40afc851bf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_*&lt;/code&gt; extension does not support &lt;strong&gt;prepared statements&lt;/strong&gt;, which is (among other things) a very effective countermeasure against &lt;strong&gt;SQL Injection&lt;/strong&gt;. It fixed a very serious vulnerability in MySQL dependent applications which allows attackers to gain access to your script and perform &lt;strong&gt;any possible query&lt;/strong&gt; on your database.</source>
          <target state="translated">&lt;code&gt;mysql_*&lt;/code&gt; 확장은 &lt;strong&gt;준비된 명령문을&lt;/strong&gt; 지원하지 않으며, 이는 &lt;strong&gt;SQL 주입&lt;/strong&gt; 에 대한 매우 효과적인 대책입니다. 공격자가 스크립트에 액세스하고 데이터베이스에서 &lt;strong&gt;가능한 쿼리&lt;/strong&gt; 를 수행 &lt;strong&gt;할 수&lt;/strong&gt; 있는 MySQL 종속 응용 프로그램의 매우 심각한 취약점을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="04f4afe04132a28eaf0cf86a418f420d470d506d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pdo_query()&lt;/code&gt; adds very facile support for bound parameters. Converting old code is straightforward:</source>
          <target state="translated">&lt;code&gt;pdo_query()&lt;/code&gt; 는 바운드 매개 변수에 대한 매우 쉬운 지원을 추가합니다. 오래된 코드를 변환하는 것은 간단합니다 :</target>
        </trans-unit>
        <trans-unit id="75528272c8ccd5010c8d8ca46c4a8dfbf9778675" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;and so on...&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;등등...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5237e9f27ed52517cac1144483a5b7980060c686" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;voila&lt;/em&gt;, everything is parameterized and safe.</source>
          <target state="translated">&lt;em&gt;voila&lt;/em&gt; , 모든 것이 매개 변수화되고 안전합니다.</target>
        </trans-unit>
        <trans-unit id="3fcb0c24213528d4e6d53492a70d7a8291036328" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;connect()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;connect()&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;connect()&lt;/code&gt; 는 &lt;b&gt;pdo_connect&lt;/b&gt; () 가된다</target>
        </trans-unit>
        <trans-unit id="5b3d112ed884c4390787d133672862205824e4fd" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;fetch_array()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;fetch_array()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;fetch_array()&lt;/code&gt; 는 &lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;fetch_array()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a21fb7cc60ddb95c041c9f9ded1d45b2a7edf190" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;fetch_assoc()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;fetch_assoc()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;fetch_assoc()&lt;/code&gt; 는 &lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;fetch_assoc()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef13a65638ca5d535b808e90281c25f89511e748" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;insert_id()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;insert_id()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;insert_id()&lt;/code&gt; 는 &lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;insert_id()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc407c0ffce461b779a38bb1fc0dc99251428726" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;num_rows()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;num_rows()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;num_rows()&lt;/code&gt; 는 &lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;num_rows()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f9a2ad43ca1e733f76816229b4aa318182e265e" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;query()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;query()&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;query()&lt;/code&gt; 는 &lt;b&gt;pdo_query&lt;/b&gt; () 가된다</target>
        </trans-unit>
        <trans-unit id="de66ab6b7bdbd02e289701939878dd5dd7d2fb27" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;real_escape_string()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;real_escape_string()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;real_escape_string()&lt;/code&gt; 은 &lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;real_escape_string()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f0b58668ae25ccfe5bdc1cbae5c9ee2cddd631f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;Prepared statements&lt;/a&gt; or parameterized queries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;준비된 명령문&lt;/a&gt; 또는 매개 변수화 된 쿼리&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="375f987ed1362ce8666be1d597bccb89f0a4b4e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="e1373de0a72aae36b8557c0139b699198b6a40ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="ae0641e9808706462aeeee3ff5fada2631f3e370" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="7d55ef0f6c839d55762a2f54ead50913fcbd88be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;UPDATE&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;UPDATE&lt;/code&gt;&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="4af3d4a1c360d57942900ff0fcaf6dc0a9cff4b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ext/mysql&lt;/code&gt;&lt;/strong&gt; was &lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;&lt;strong&gt;officially deprecated as of PHP 5.5&lt;/strong&gt;&lt;/a&gt; and has been &lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7&quot;&gt;&lt;strong&gt;removed as of PHP 7&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;ext/mysql&lt;/code&gt; &lt;/strong&gt; 은 &lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;&lt;strong&gt;PHP 5.5&lt;/strong&gt;&lt;/a&gt; 부터 &lt;strong&gt;공식적으로 사용되지 않으며&lt;/strong&gt; &lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7&quot;&gt;&lt;strong&gt;PHP 7&lt;/strong&gt;&lt;/a&gt; 부터 &lt;strong&gt;제거되었습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="21d3709bc3604de67baa10faab0af9188543ecb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A.&lt;/strong&gt; A prepared statement is a pre-compiled SQL statement that can be executed multiple times by sending only the data to the server.</source>
          <target state="translated">&lt;strong&gt;A.&lt;/strong&gt; 준비된 명령문은 서버로 데이터 만 전송하여 여러 번 실행할 수있는 사전 컴파일 된 SQL 문입니다.</target>
        </trans-unit>
        <trans-unit id="66bcf27ed5345c3e7d140adfa9c56ebb3359dfcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A.&lt;/strong&gt; Let's have an example:</source>
          <target state="translated">&lt;strong&gt;A.&lt;/strong&gt; 예를 들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="7d69176c1f43d19cde596ba2b74bea58f3c1bad5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A.&lt;/strong&gt; Named placeholders. Use descriptive names preceded by a colon, instead of question marks. We don't care about position/order of value in name place holder:</source>
          <target state="translated">&lt;strong&gt;A.&lt;/strong&gt; 명명 된 자리 표시 자. 물음표 대신 설명적인 이름 앞에 콜론을 사용하십시오. 우리는 이름 자리 표시 자의 위치 / 가치 순서에 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1aecc95b507fcd1d0e6fda933de9c7becbbe5a09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Also, there are some false or non-significant reasons, like&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;또한 다음과 같은 허위 또는 중요하지 않은 이유가 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fbda4158ca375d01bee8e519487823e89ac0c2a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can we set attributes after PDO construction?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PDO 생성 후 속성을 설정할 수 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71900205aba19377ace55dba6e80e5d49843cfb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Contemporary database APIs are just &lt;em&gt;easier&lt;/em&gt; to use.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;최신 데이터베이스 API는 사용 &lt;em&gt;하기&lt;/em&gt; 가 &lt;em&gt;더 쉽습니다&lt;/em&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ce243cbd8cc444c680e66a9ca31863339ae7a10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Execute&lt;/strong&gt;: At a later time, the application supplies (or binds) values for the parameters, and the DBMS executes the statement (possibly returning a result). The application may execute the statement as many times as it wants with different values. In this example, it might supply 'Bread' for the first parameter and &lt;code&gt;1.00&lt;/code&gt; for the second parameter.</source>
          <target state="translated">&lt;strong&gt;Execute&lt;/strong&gt; : 나중에 어플리케이션은 매개 변수에 값을 제공 (또는 바인드)하고 DBMS는 명령문을 실행합니다 (결과를 리턴 할 수 있음). 응용 프로그램은 다른 값으로 원하는만큼 명령문을 실행할 수 있습니다. 이 예에서는 첫 번째 매개 변수에 'Bread'를 제공하고 두 번째 매개 변수에 &lt;code&gt;1.00&lt;/code&gt; 을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b76647d0abd6627dc3e3d7aed8eb990660dd95d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting the Last Inserted ID&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;마지막으로 삽입 된 ID 얻기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbeb2123bb627ff2057e11808030689ea471e52f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting the row count&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;행 개수 얻기&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="3d2b4c709812584ec969783a6880ad9830f30c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Good read&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;잘 읽음&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="ca5ca16bcc78e74bfbd4891290090d73b43c0d80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Good read&lt;/strong&gt;: &lt;a href=&quot;http://php.net/manual/en/pdo.connections.php&quot;&gt;Connections and Connection management &amp;para;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;읽기&lt;/strong&gt; : &lt;a href=&quot;http://php.net/manual/en/pdo.connections.php&quot;&gt;연결 및 연결 관리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64787817e9b226c3de70d33bdb039da28b3c4415" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Historic note on magic_quotes.&lt;/strong&gt; That feature is rightly deprecated. It's often incorrectly portrayed as failed &lt;em&gt;security&lt;/em&gt; feature however. But magic_quotes are as much a failed security feature as tennis balls have failed as nutrition source. That simply wasn't their purpose.</source>
          <target state="translated">&lt;strong&gt;magic_quotes에 대한 역사적 메모.&lt;/strong&gt; 이 기능은 더 이상 사용되지 않습니다. 그러나 실패한 &lt;em&gt;보안&lt;/em&gt; 기능으로 잘못 묘사되는 경우가 많습니다. 그러나 magic_quotes는 테니스 공이 영양원만큼 실패한 것처럼 보안 기능이 실패한 것입니다. 그것은 단순히 그들의 목적이 아니 었습니다.</target>
        </trans-unit>
        <trans-unit id="7c2c76a00e13c745b512b4a84fde6bd4d754f51e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instead, you should learn of prepared statements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;대신 준비된 진술에 대해 배워야합니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0dbca28c12bb63433f617f4435842da2de64f12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NEW! - ext/mysql is now &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;officially deprecated as of PHP 5.5!&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;새로운!&lt;/strong&gt; &lt;strong&gt;-ext / mysql은 이제 &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;PHP 5.5부터 공식적으로 사용되지 않습니다!&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f35097e2b1b38de5ec88177ea2b0967e5b0e99a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTE:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bcee5544ef56b940a214706dc29617b2b713720" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: In &lt;strong&gt;unnamed placeholders&lt;/strong&gt; we must take care of the proper order of the elements in the array that we are passing to the &lt;code&gt;PDOStatement::execute()&lt;/code&gt; method.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;strong&gt;명명되지 않은 자리 표시 자&lt;/strong&gt; 에서는 &lt;code&gt;PDOStatement::execute()&lt;/code&gt; 메서드로 전달되는 배열의 요소 순서를 적절하게 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2fb3e1339eb87a7998bdbb7ee4cd05d10c3a4ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Neither mysqli_* nor PDO functions should have appeared in the application code.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mysqli_ * 또는 PDO 함수는 애플리케이션 코드에 나타나지 않아야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dda929987f6bc860e4d7687f0f9b9055c3b38c38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nevertheless, there are also some non-technical issues, which can make your experience a bit harder&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그럼에도 불구하고 약간의 기술적이지 않은 문제도있어 경험을 조금 더 어렵게 만들 수 있습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee452aec63009c2bd7bbfd6f03acd850aab819f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can also use &lt;code&gt;charset=UTF-8&lt;/code&gt;, but sometimes it causes an error, so it's better to use &lt;code&gt;utf8&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; &lt;code&gt;charset=UTF-8&lt;/code&gt; 을 사용할 수도 있지만 때로는 오류가 발생하므로 &lt;code&gt;utf8&lt;/code&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8f722b24d30ed0d049e9217e7bf9e78930a63b61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you are using the method like below (&lt;code&gt;query()&lt;/code&gt;), this method returns a &lt;code&gt;PDOStatement&lt;/code&gt; object. So if you want to fetch the result, use it like above.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 아래와 같은 메소드 ( &lt;code&gt;query()&lt;/code&gt; )를 사용하는 경우이 메소드는 &lt;code&gt;PDOStatement&lt;/code&gt; 오브젝트를 리턴합니다. 결과를 가져 오려면 위와 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1d0a361ba3da0755ad03adc9e9d32cb4ed1a08c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prepare&lt;/strong&gt;: The statement template is created by the application and sent to the database management system (DBMS). Certain values are left unspecified, called parameters, placeholders or bind variables (labelled &lt;code&gt;?&lt;/code&gt; below):</source>
          <target state="translated">&lt;strong&gt;준비&lt;/strong&gt; : 명령문 템플리트는 애플리케이션에 의해 작성되고 데이터베이스 관리 시스템 (DBMS)으로 전송됩니다. 매개 변수, 자리 표시 자 또는 바인드 변수라고하는 특정 값은 지정되지 않은 채로 있습니다 (아래에 &lt;code&gt;?&lt;/code&gt; 로 표시).</target>
        </trans-unit>
        <trans-unit id="8de8d53910fb26580d0d1462d5f15822e1f2f8fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prepared Statements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;준비된 진술&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83772b3402056078699b22b03ae7c71d472d223a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Q.&lt;/strong&gt; So now, what are named placeholders and how do I use them?</source>
          <target state="translated">&lt;strong&gt;Q.&lt;/strong&gt; 이제 명명 된 자리 표시자는 무엇이며 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="bf935138dd58afb317f393a58a87a426e51d9625" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Q.&lt;/strong&gt; So now, what are unnamed placeholders and how do I use them?</source>
          <target state="translated">&lt;strong&gt;Q.&lt;/strong&gt; 이름없는 자리 표시자는 무엇이며 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="246454779aad75d51088bb0de1cda979d51768d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Q.&lt;/strong&gt; What is a prepared statement and why do I need them?</source>
          <target state="translated">&lt;strong&gt;Q.&lt;/strong&gt; 준비된 진술은 무엇이며 왜 필요합니까?</target>
        </trans-unit>
        <trans-unit id="bc3aaa8f04d43e44f616656297e0c78c54e1f172" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reason to not use &lt;code&gt;mysql_*&lt;/code&gt; function&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;mysql_*&lt;/code&gt; 함수를 사용하지 않는 이유&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c7cfb15d4b60ac9b33a75c31e26bd7807779ace0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See the Red Box?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;레드 박스를 보시겠습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eb999dd362a05e63929ca191a77eea6b0e5a6b94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Suppressing deprecation warnings&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;지원 중단 경고 억제&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c1160a54ccd72e93448ddb4bc662e0ee249f6fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They are no longer maintained, and are officially deprecated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 이상 유지 관리되지 않으며 공식적으로 더 이상 사용되지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="14c3edf5863da2e2fc42e3f847cd0cec2427b6c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use either PDO or MySQLi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PDO 또는 MySQLi 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba557ea612da45ee87ea50fbc09e07ea7b1520ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes&lt;/strong&gt;, we can also set some attributes after PDO construction with the &lt;code&gt;setAttribute&lt;/code&gt; method:</source>
          <target state="translated">&lt;strong&gt;예&lt;/strong&gt; , &lt;code&gt;setAttribute&lt;/code&gt; 메소드를 사용하여 PDO 생성 후 일부 속성을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cf01d9490d0b537b44b782fd8131a614ece8d85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql_*&lt;/strong&gt; functions do not support prepared statements.</source>
          <target state="translated">&lt;strong&gt;mysql_ *&lt;/strong&gt; 함수는 준비된 명령문을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e42abeed45b2dfef66fccc34fef34fdbe2a6d2f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql_*&lt;/strong&gt; functions do not support the binding of parameters.</source>
          <target state="translated">&lt;strong&gt;mysql_ *&lt;/strong&gt; 함수는 매개 변수 바인딩을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac0f78e16e8962d33c7f864e2d4cfab79ed85fb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql_*&lt;/strong&gt; functions lack functionality for Object Oriented Programming.</source>
          <target state="translated">&lt;strong&gt;mysql_ *&lt;/strong&gt; 함수에는 객체 지향 프로그래밍 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ab107729188b218548fbdc2bdea183a073fe436" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql_*&lt;/strong&gt; functions were deprecated (as of &lt;strong&gt;PHP 5.5&lt;/strong&gt;) given the fact that better functions and code structures were developed. The fact that the function was deprecated means that no more effort will be placed into improving it in terms of performance and security, &lt;strong&gt;which means it is less future proof&lt;/strong&gt;.</source>
          <target state="translated">더 나은 함수와 코드 구조가 개발되었다는 사실을 감안하면 &lt;strong&gt;mysql_ *&lt;/strong&gt; 함수는 더 이상 사용되지 않습니다 ( &lt;strong&gt;PHP 5.5 기준&lt;/strong&gt; ). 이 기능이 더 이상 사용되지 않는다는 사실은 성능 및 보안 측면에서 더 이상 노력을 기울이지 않아도됨을 의미하며, &lt;strong&gt;이는 향후 증거가 적습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2a9ce00004e2016f2cadb930b22a5cb4bfad93c2" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;em&gt;Insert and delete will be covered later.&lt;/em&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;삽입 및 삭제에 대해서는 나중에 다루겠습니다.&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="4605e640a44a2903dc29f4d7c4d5f1a5d3a737e6" translate="yes" xml:space="preserve">
          <source>A common practice when using &lt;code&gt;mysql_*&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;mysql_*&lt;/code&gt; 를 사용하는 일반적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a13839e20b6d574ce0048134aef78b15481c1e5c" translate="yes" xml:space="preserve">
          <source>A simple and short PDO tutorial</source>
          <target state="translated">간단하고 짧은 PDO 튜토리얼</target>
        </trans-unit>
        <trans-unit id="48250fcdf8841a07f5b1248699a34ceeeef49b50" translate="yes" xml:space="preserve">
          <source>A. &amp;ldquo;&lt;strong&gt;PDO &amp;ndash; PHP Data Objects&lt;/strong&gt; &amp;ndash; is a database access layer providing a uniform method of access to multiple databases.&amp;rdquo;</source>
          <target state="translated">A.&amp;ldquo; &lt;strong&gt;PDO &amp;ndash; PHP Data Objects&lt;/strong&gt; &amp;ndash;는 여러 데이터베이스에 대한 균일 한 액세스 방법을 제공하는 데이터베이스 액세스 계층입니다.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="2f434a1f9a23e4564ea51f72e542f32afebac04b" translate="yes" xml:space="preserve">
          <source>API supports Multiple Statements and all MySQL 4.1+ functionality - Supported by MySQLi and mostly also by PDO</source>
          <target state="translated">API는 다중 명령문 및 모든 MySQL 4.1 이상 기능 지원-MySQLi 및 대부분 PDO에서 지원</target>
        </trans-unit>
        <trans-unit id="1fc3feb37f7a72085af4f28967eb6151ee8d1c5e" translate="yes" xml:space="preserve">
          <source>API supports Stored Procedures: Both MySQLi and PDO</source>
          <target state="translated">API는 저장 프로 시저를 지원합니다 : MySQLi 및 PDO</target>
        </trans-unit>
        <trans-unit id="f09f90c57066a24eee0eb4f850c58410d1012793" translate="yes" xml:space="preserve">
          <source>API supports client-side Prepared Statements: Supported only by PDO</source>
          <target state="translated">API는 클라이언트 측 준비된 명령문을 지원합니다. PDO에서만 지원</target>
        </trans-unit>
        <trans-unit id="bc6bd620a8604b899ec28a40dd9fd604faf87f73" translate="yes" xml:space="preserve">
          <source>API supports server-side Prepared Statements: Supported by MYSQLi and PDO</source>
          <target state="translated">API는 서버 측 준비 명령문을 지원합니다 : MYSQLi 및 PDO에서 지원</target>
        </trans-unit>
        <trans-unit id="34890013f003ff6a72ea8f3325210ceb78fdcc4d" translate="yes" xml:space="preserve">
          <source>Above point quoted from Quentin's answer</source>
          <target state="translated">Quentin의 답변에서 인용 한 위의 내용</target>
        </trans-unit>
        <trans-unit id="fd9035ed506b5a7ea270a5b3e1a41eff0a713ea2" translate="yes" xml:space="preserve">
          <source>Add them as comma delimited function parameters to &lt;code&gt;pdo_query()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pdo_query()&lt;/code&gt; 쉼표로 구분 된 함수 매개 변수로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="01fb17f71e8b9143a9904e6eb49ef6a34b6db1f8" translate="yes" xml:space="preserve">
          <source>Also, you can handle by &lt;code&gt;or die()&lt;/code&gt; or we can say like &lt;code&gt;mysql_*&lt;/code&gt;, but it will be really varied. You can hide the dangerous error messages in production by turning &lt;code&gt;display_errors off&lt;/code&gt; and just reading your error log.</source>
          <target state="translated">또한 by &lt;code&gt;or die()&lt;/code&gt; 처리 하거나 &lt;code&gt;mysql_*&lt;/code&gt; 와 같이 말할 수 있지만 실제로는 다양합니다. &lt;code&gt;display_errors off&lt;/code&gt; 오류 로그를 읽음으로써 프로덕션에서 위험한 오류 메시지를 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65ace5a4919de42d6ac9e8e70a32858585a56919" translate="yes" xml:space="preserve">
          <source>Amazing! Hi-fives all round, the code correctly verified an admin. It's perfect!</source>
          <target state="translated">놀랄 만한! 안녕하십니까, 코드는 관리자를 올바르게 확인했습니다. 그것은 완벽!</target>
        </trans-unit>
        <trans-unit id="67c99697e4cd741a12219ff4ecfee60683efb9b6" translate="yes" xml:space="preserve">
          <source>And a better way is &lt;code&gt;PDO&lt;/code&gt;, and I am now writing a simple &lt;code&gt;PDO&lt;/code&gt; tutorial.</source>
          <target state="translated">그리고 더 좋은 방법은 &lt;code&gt;PDO&lt;/code&gt; 이며, 이제 간단한 &lt;code&gt;PDO&lt;/code&gt; 튜토리얼을 작성하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="120d08ba81249a9f81e7d175247796e5cff77a30" translate="yes" xml:space="preserve">
          <source>And contrary - if you have an abstraction layer between your application code and mysql API - &lt;strong&gt;it doesn't actually matter which engine is used.&lt;/strong&gt; You can use mysql ext until it goes deprecated and then easily rewrite your abstraction class to another engine, &lt;strong&gt;having all the application code intact.&lt;/strong&gt;</source>
          <target state="translated">반대로 응용 프로그램 코드와 mysql API 사이에 추상화 계층이있는 경우 &lt;strong&gt;실제로 사용되는 엔진은 중요하지 않습니다.&lt;/strong&gt; 더 이상 사용되지 않을 때까지 mysql ext를 사용하고 &lt;strong&gt;모든 애플리케이션 코드를 그대로 유지하면서&lt;/strong&gt; 추상화 클래스를 다른 엔진에 쉽게 다시 작성할 수 &lt;strong&gt;있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42319ef1243e1cb43dbc04ce225a03a2d0c6b42e" translate="yes" xml:space="preserve">
          <source>And in pdo, this same thing can be done by:</source>
          <target state="translated">그리고 pdo에서 이와 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0993bf28ecd55614b8bb57ddce1033f985cb8e69" translate="yes" xml:space="preserve">
          <source>And it will be too wordy and most likely unsafe.</source>
          <target state="translated">그리고 너무 장황하고 안전하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f8d456b41786de88a2dbb3af1c629f6c1141c80c" translate="yes" xml:space="preserve">
          <source>And the later PHP developer team has taken the decision to generate &lt;a href=&quot;https://github.com/php/php-src/commit/b7091aaf0137d97cf4aa4a402ec50b3946d369c0&quot;&gt;&lt;strong&gt;&lt;code&gt;E_DEPRECATED&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; errors when users connect to MySQL, whether through &lt;code&gt;mysql_connect()&lt;/code&gt;, &lt;code&gt;mysql_pconnect()&lt;/code&gt; or the implicit connection functionality built into &lt;code&gt;ext/mysql&lt;/code&gt;.</source>
          <target state="translated">그리고 나중에 PHP 개발자 팀은 사용자가 &lt;code&gt;mysql_connect()&lt;/code&gt; , &lt;code&gt;mysql_pconnect()&lt;/code&gt; 또는 &lt;code&gt;ext/mysql&lt;/code&gt; 에 내장 된 암시 적 연결 기능을 통해 MySQL에 연결할 때 &lt;a href=&quot;https://github.com/php/php-src/commit/b7091aaf0137d97cf4aa4a402ec50b3946d369c0&quot;&gt;&lt;strong&gt; &lt;code&gt;E_DEPRECATED&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 오류를 생성하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="ef4d4c6fb57c79a8162041f226c5e4efb9e26af4" translate="yes" xml:space="preserve">
          <source>And the output is:</source>
          <target state="translated">그리고 출력은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="968a4fefe78eb6c9a0fb316c9f7ac9217c1ea9fc" translate="yes" xml:space="preserve">
          <source>And you can wrap it in &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt;, like below:</source>
          <target state="translated">그리고 아래와 같이 &lt;code&gt;try&lt;/code&gt; - &lt;code&gt;catch&lt;/code&gt; 로 감쌀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">또 다른 예:</target>
        </trans-unit>
        <trans-unit id="8899017bb75139a8d05c4ded944ef88bb6b69e08" translate="yes" xml:space="preserve">
          <source>Another nice feature for &lt;code&gt;OOP&lt;/code&gt; friends is that named placeholders have the ability to insert objects directly into your database, assuming the properties match the named fields. For example:</source>
          <target state="translated">&lt;code&gt;OOP&lt;/code&gt; 친구에게 또 다른 좋은 기능은 명명 된 자리 표시자가 속성이 명명 된 필드와 일치한다고 가정 할 때 데이터베이스에 직접 객체를 삽입 할 수 있다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="498040b4cb115e9716562169981fc9fa03b6e734" translate="yes" xml:space="preserve">
          <source>Any of the new functionality in MySQL 5.1 or later</source>
          <target state="translated">MySQL 5.1 이상의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="0e5e1aea7f23bc2927b5d23c2cbc5412b05fce82" translate="yes" xml:space="preserve">
          <source>As an example, someone could use &lt;code&gt;&quot;enhzflep); drop table users&quot;&lt;/code&gt; as a username. The old functions will allow executing multiple statements per query, so something like that nasty bugger can delete a whole table.</source>
          <target state="translated">예를 들어, 누군가 &lt;code&gt;&quot;enhzflep); drop table users&quot;&lt;/code&gt; 를 사용자 이름으로 사용할 수 있습니다. 이전 함수는 쿼리 당 여러 명령문을 실행할 수 있으므로 불쾌한 버그가 전체 테이블을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5ad27cf2144b732b070aaef3f6328e7557022c6" translate="yes" xml:space="preserve">
          <source>As explained in the above answers, the alternatives to mysql are mysqli and PDO (PHP Data Objects).</source>
          <target state="translated">위의 답변에서 설명한 것처럼 mysql의 대안은 mysqli 및 PDO (PHP Data Objects)입니다.</target>
        </trans-unit>
        <trans-unit id="242084bedb9aa3c73ad1bd7da789bee02633449f" translate="yes" xml:space="preserve">
          <source>Because (amongst other reasons) it's much harder to ensure the input data is sanitized. If you use parametrized queries, as one does with PDO or mysqli you can entirely avoid the risk.</source>
          <target state="translated">(다른 이유들 중에서도) 입력 데이터를 위생 처리하는 것이 훨씬 어렵 기 때문입니다. 매개 변수화 된 쿼리를 사용하는 경우 PDO 또는 mysqli와 마찬가지로 위험을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06606943663433f539cbc360dbd06b2bc39a6263" translate="yes" xml:space="preserve">
          <source>Below is an example of how you can do it:</source>
          <target state="translated">다음은이를 수행하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="123eebf3efbb03421b5f4b2571c2660d81b303c7" translate="yes" xml:space="preserve">
          <source>Beware that parameter binding still isn't a magic one-stop solution against &lt;em&gt;all&lt;/em&gt; SQL injections. It handles the most common use for data/values. But can't whitelist column name / table identifiers, help with dynamic clause construction, or just plain array value lists.</source>
          <target state="translated">매개 변수 바인딩은 여전히 &lt;em&gt;모든&lt;/em&gt; SQL 주입에 대한 마법의 원 스톱 솔루션이 아닙니다. 데이터 / 값에 가장 일반적으로 사용됩니다. 그러나 열 이름 / 테이블 식별자를 허용 목록에 추가하거나 동적 절 구성에 도움을 주거나 단순한 배열 값 목록을 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dbf3abea317b3728874b25d75ef5a69530c550f8" translate="yes" xml:space="preserve">
          <source>Both MySQLi and PDO were introduced in PHP 5.0, whereas MySQL was introduced prior to PHP 3.0. A point to note is that MySQL is included in PHP5.x though deprecated in later versions.</source>
          <target state="translated">MySQLi와 PDO는 모두 PHP 5.0에 도입되었으며 MySQL은 PHP 3.0 이전에 도입되었습니다. 주목할 점은 MySQL이 이후 버전에서는 더 이상 사용되지 않지만 PHP5.x에 포함되어 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="51020afda7d0112c97929b784637a312225d970c" translate="yes" xml:space="preserve">
          <source>Bound parameters can be easy to use</source>
          <target state="translated">바운드 매개 변수는 사용하기 쉬울 수 있습니다</target>
        </trans-unit>
        <trans-unit id="300f56277ff5fe0394d55c2ebdaf31a5d9ca5560" translate="yes" xml:space="preserve">
          <source>Brilliant, not enter in the following:</source>
          <target state="translated">훌륭합니다. 다음을 입력하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="13baed15c99f957c80af17236b205876746fb816" translate="yes" xml:space="preserve">
          <source>But as first step just &lt;strong&gt;get rid of the &lt;code&gt;_real_escape_string&lt;/code&gt;&lt;/strong&gt; call.</source>
          <target state="translated">그러나 첫 번째 단계로 &lt;strong&gt; &lt;code&gt;_real_escape_string&lt;/code&gt; &lt;/strong&gt; 호출을 &lt;strong&gt;제거&lt;/strong&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="c2b6b6db7e4e3dfb886e45b51b27e98f7d6f7e48" translate="yes" xml:space="preserve">
          <source>But okay, if you don't like the red box in the manual, a problem of choice arises: mysqli or PDO?</source>
          <target state="translated">그러나 매뉴얼의 빨간색 상자가 마음에 들지 않으면 mysqli 또는 PDO?</target>
        </trans-unit>
        <trans-unit id="0ea2f9f9df0901957a54cc00384ae3ecf9e7598f" translate="yes" xml:space="preserve">
          <source>But, in my opinion, the proposed solution is no better either.</source>
          <target state="translated">그러나 내 의견으로는 제안 된 솔루션도 더 나쁘지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87f8df6d2b63e036157cc4d012be4719078a49b1" translate="yes" xml:space="preserve">
          <source>Can be replaced with just an foreach iteration:</source>
          <target state="translated">foreach 반복으로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98de0e635b4201b0c76f621b74657cf746901ace" translate="yes" xml:space="preserve">
          <source>Compare it with usual PDO inserts, when every single field name being repeated six to ten times - in all these numerous named placeholders, bindings, and query definitions.</source>
          <target state="translated">이름이 지정된 모든 자리 표시 자, 바인딩 및 쿼리 정의에서 모든 단일 필드 이름이 6-10 회 반복 될 때 일반적인 PDO 삽입과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="f2b2bc84e981266a2ed8528d294c0bc718096013" translate="yes" xml:space="preserve">
          <source>Compare this one single line with &lt;a href=&quot;https://stackoverflow.com/a/15991146/285587&quot;&gt;amount of code you will need with PDO&lt;/a&gt;.</source>
          <target state="translated">이 한 줄 &lt;a href=&quot;https://stackoverflow.com/a/15991146/285587&quot;&gt;을 PDO에 필요한 코드 양과&lt;/a&gt; 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="46ead4045fbadbc2f0b37b6046e5803972459710" translate="yes" xml:space="preserve">
          <source>Compression</source>
          <target state="translated">Compression</target>
        </trans-unit>
        <trans-unit id="9f82982d2197b2fb50ef5bc31251b1e69637c99f" translate="yes" xml:space="preserve">
          <source>Congrats, you just allowed me to enter your super-protected admins only section with me entering a false username and a false password. Seriously, if you don't believe me, create the database with the code I provided, and run this PHP code - which at glance REALLY does seem to verify the username and password rather nicely.</source>
          <target state="translated">축하합니다. 잘못된 사용자 이름과 잘못된 비밀번호를 입력하여 완전 보호 된 관리자 전용 섹션을 입력 할 수있었습니다. 진심으로, 당신이 나를 믿지 않는다면, 내가 제공 한 코드로 데이터베이스를 생성 하고이 PHP 코드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9cdd246b67ff3115cf8e58af1aa4662b256a8fa8" translate="yes" xml:space="preserve">
          <source>Connecting to MySQL</source>
          <target state="translated">MySQL에 연결</target>
        </trans-unit>
        <trans-unit id="f84015d92e165e7b3f840594a075b9ee6030c2a1" translate="yes" xml:space="preserve">
          <source>Correct order would have been: deprecatedly &lt;code&gt;stripslashes&lt;/code&gt; as the innermost call, then &lt;code&gt;trim&lt;/code&gt;, afterwards &lt;code&gt;strip_tags&lt;/code&gt;, &lt;code&gt;htmlentities&lt;/code&gt; for output context, and only lastly the &lt;code&gt;_escape_string&lt;/code&gt; as its application should directly preceed the SQL intersparsing.</source>
          <target state="translated">올바른 순서는 다음과 같습니다. 더 이상 사용되지 않는 가장 안쪽의 호출로 &lt;code&gt;_escape_string&lt;/code&gt; 를 제거한 다음 출력 컨텍스트에 대한 &lt;code&gt;htmlentities&lt;/code&gt; 및 나중에 _escape_string을 트리밍 합니다.</target>
        </trans-unit>
        <trans-unit id="274ac70de9ee561047b2d6020375c34942dc13aa" translate="yes" xml:space="preserve">
          <source>Doesn't support &lt;a href=&quot;http://en.wikipedia.org/wiki/Database_transaction&quot;&gt;transactions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Database_transaction&quot;&gt;거래를&lt;/a&gt; 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="5b91190ed508aa1ebccf4667808bf07650ab04f8" translate="yes" xml:space="preserve">
          <source>Doesn't support Multiple Statements (who need them?)</source>
          <target state="translated">여러 문장을 지원하지 않습니다 (누가 필요합니까?)</target>
        </trans-unit>
        <trans-unit id="d44232efd1fd248676980ae2cdc482a57df4a84c" translate="yes" xml:space="preserve">
          <source>Doesn't support Prepared Statements or Parametrized Queries</source>
          <target state="translated">준비된 문장 또는 매개 변수화 된 쿼리를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="6c479d1a8515470d066edea5ea563b89e68cc6f8" translate="yes" xml:space="preserve">
          <source>Doesn't support Stored Procedures (we were using &lt;code&gt;mysql_query(&quot;CALL my_proc&quot;);&lt;/code&gt; for ages)</source>
          <target state="translated">저장 프로 시저를 지원하지 않습니다 (우리는 &lt;code&gt;mysql_query(&quot;CALL my_proc&quot;);&lt;/code&gt; 연령대)</target>
        </trans-unit>
        <trans-unit id="866143011c8a05791bf29b94865c70519ad71e72" translate="yes" xml:space="preserve">
          <source>Doesn't support Transactions (same as above)</source>
          <target state="translated">거래를 지원하지 않습니다 (위와 동일)</target>
        </trans-unit>
        <trans-unit id="fce860154fdb146e5f646b4901b94461c45d68e0" translate="yes" xml:space="preserve">
          <source>Doesn't support all of the functionality in MySQL 5.1</source>
          <target state="translated">MySQL 5.1의 모든 기능을 지원하지는 않습니다</target>
        </trans-unit>
        <trans-unit id="3cf92a22337ed0b5bde371c6efea5d06737ca874" translate="yes" xml:space="preserve">
          <source>Doesn't support multiple statements</source>
          <target state="translated">여러 문장을 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="864e78e1d6a762f1e100177dd6406de3ab443864" translate="yes" xml:space="preserve">
          <source>Doesn't support non-blocking, asynchronous queries</source>
          <target state="translated">비 차단 비동기 쿼리를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="d1636c7a918bc55871631f47bbb14d7249b434bf" translate="yes" xml:space="preserve">
          <source>Doesn't support prepared statements or &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;parameterized queries&lt;/a&gt;</source>
          <target state="translated">준비된 명령문 또는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;매개 변수화 된 쿼리를&lt;/a&gt; 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="2b1078a18b28afd9f7f8df361d462c8be33bb483" translate="yes" xml:space="preserve">
          <source>Doesn't support stored procedures</source>
          <target state="translated">저장 프로 시저를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="913e0c4a5ec4213ac6b0e5bc84a0b4952dd23744" translate="yes" xml:space="preserve">
          <source>Doesn't support:</source>
          <target state="translated">지원하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="3a2186dd09a53f0acfd3661a66ceb59c176eaf88" translate="yes" xml:space="preserve">
          <source>Ease of use</source>
          <target state="translated">사용의 용이성</target>
        </trans-unit>
        <trans-unit id="db8c650e4e279285960b1784a6fbbece934a01e3" translate="yes" xml:space="preserve">
          <source>Embedded server support</source>
          <target state="translated">임베디드 서버 지원</target>
        </trans-unit>
        <trans-unit id="6d7b79456a20370d710fa37e809943165d11f572" translate="yes" xml:space="preserve">
          <source>Encryption (SSL)</source>
          <target state="translated">암호화 (SSL)</target>
        </trans-unit>
        <trans-unit id="5b860d134c5b348f6cc8170ac43f9694cf148a8f" translate="yes" xml:space="preserve">
          <source>Enhanced debugging capabilities</source>
          <target state="translated">향상된 디버깅 기능</target>
        </trans-unit>
        <trans-unit id="6f31dd815c428bc663ce257d3df663a6858bc6b0" translate="yes" xml:space="preserve">
          <source>Enter in the following:</source>
          <target state="translated">다음을 입력하십시오 :</target>
        </trans-unit>
        <trans-unit id="09fa2a067aee2197e8eb1a89b00eefbf6e88e347" translate="yes" xml:space="preserve">
          <source>Equivalent pdo_* functions in place of &lt;s&gt;mysql_*&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;mysql_ *&lt;/s&gt; 대신 동등한 pdo_ * 함수</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="2f3b48eb0edc6001d7879dc58945e065cc2e3e5a" translate="yes" xml:space="preserve">
          <source>Error handling is much easier in &lt;code&gt;PDO&lt;/code&gt; than &lt;code&gt;mysql_*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PDO&lt;/code&gt; 에서 오류 처리는 &lt;code&gt;mysql_*&lt;/code&gt; 보다 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="fec40d777dec6257585f890975134a9cea348678" translate="yes" xml:space="preserve">
          <source>Errors and error handling &amp;para;</source>
          <target state="translated">오류 및 오류 처리</target>
        </trans-unit>
        <trans-unit id="c019ec3bcff0bb2854b0e299ba32a9eee4bd0ee3" translate="yes" xml:space="preserve">
          <source>Et voil&amp;agrave;.</source>
          <target state="translated">Et voil&amp;agrave;.</target>
        </trans-unit>
        <trans-unit id="1286a514865def6edb80f749d66c5420df3e9cc2" translate="yes" xml:space="preserve">
          <source>Exceptions &amp;para;</source>
          <target state="translated">예외</target>
        </trans-unit>
        <trans-unit id="ca51f996bb09297e02939f7b41f4c178b7775704" translate="yes" xml:space="preserve">
          <source>Fetch Modes</source>
          <target state="translated">페치 모드</target>
        </trans-unit>
        <trans-unit id="0cda57057d1816d4de9cdbd01aece5021ed7c626" translate="yes" xml:space="preserve">
          <source>First of all, I explain how to select fetch mode:</source>
          <target state="translated">우선, 가져 오기 모드를 선택하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="17ba645d365edcb5b41c66ee76e97181eab4127f" translate="yes" xml:space="preserve">
          <source>First off, please feel free to create this test mysql database (I have called mine prep):</source>
          <target state="translated">먼저,이 테스트 mysql 데이터베이스를 작성하십시오 (저는 광산 준비라고 불렀습니다).</target>
        </trans-unit>
        <trans-unit id="dde1356568f59e4b14dee0b21b6e2107618e0338" translate="yes" xml:space="preserve">
          <source>First, let's begin with the standard comment we give everyone:</source>
          <target state="translated">먼저 모든 사람에게 제공되는 표준 의견으로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="5659b9d449b5b012e0b098e81e7ed2f20fe0f375" translate="yes" xml:space="preserve">
          <source>Fix or remove any oldschool &lt;a href=&quot;https://stackoverflow.com/questions/3126072/what-are-the-best-php-input-sanitizing-functions&quot;&gt;&lt;code&gt;sanitize()&lt;/code&gt;&lt;/a&gt; function</source>
          <target state="translated">oldschool &lt;a href=&quot;https://stackoverflow.com/questions/3126072/what-are-the-best-php-input-sanitizing-functions&quot;&gt; &lt;code&gt;sanitize()&lt;/code&gt; &lt;/a&gt; 함수 수정 또는 제거</target>
        </trans-unit>
        <trans-unit id="3aa75d58669bb5ac8b40367ea713bcccf7011235" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/60174/best-way-to-prevent-sql-injection-in-php&quot;&gt;How can I prevent SQL injection in PHP?&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">자세한 내용 &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/60174/best-way-to-prevent-sql-injection-in-php&quot;&gt;은 PHP에서 SQL 삽입을 방지하는 방법을&lt;/a&gt;&lt;/strong&gt; 참조하십시오 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07593710668e04f42ef94baca94b6702963b9675" translate="yes" xml:space="preserve">
          <source>Full Charset support</source>
          <target state="translated">완벽한 문자셋 지원</target>
        </trans-unit>
        <trans-unit id="55dc1ba13909c533de685b19d9a8793a296b2045" translate="yes" xml:space="preserve">
          <source>Get rid of &lt;code&gt;'&lt;/code&gt; single quotes that previously enclosed string values/variables.</source>
          <target state="translated">이전에 문자열 값 / 변수를 묶은 작은 따옴표를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6eed48caa38c8545e4fcf00ca0a37b5a7cf30396" translate="yes" xml:space="preserve">
          <source>Has been &lt;strong&gt;&lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7#extmysql&quot;&gt;removed&lt;/a&gt; entirely&lt;/strong&gt; as of PHP 7.0 (released December 2015)</source>
          <target state="translated">PHP 7.0부터 &lt;strong&gt;완전히 &lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7#extmysql&quot;&gt;제거&lt;/a&gt;&lt;/strong&gt; 되었습니다 (2015 년 12 월 출시)</target>
        </trans-unit>
        <trans-unit id="292c37ca19719be96899acb843e9a5c01e00d6c6" translate="yes" xml:space="preserve">
          <source>Here I think you are familiar with all except &lt;code&gt;DSN&lt;/code&gt;; this is new in &lt;code&gt;PDO&lt;/code&gt;. A &lt;code&gt;DSN&lt;/code&gt; is basically a string of options that tell &lt;code&gt;PDO&lt;/code&gt; which driver to use, and connection details. For further reference, check &lt;a href=&quot;http://www.php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;PDO MySQL DSN&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;DSN&lt;/code&gt; 을 제외한 모든 것에 익숙하다고 생각합니다. 이것은 &lt;code&gt;PDO&lt;/code&gt; 의 새로운 기능입니다. &lt;code&gt;DSN&lt;/code&gt; 은 기본적으로 &lt;code&gt;PDO&lt;/code&gt; 에 사용할 드라이버 및 연결 세부 정보를 알려주는 일련의 옵션입니다. 자세한 내용은 &lt;a href=&quot;http://www.php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;PDO MySQL DSN을&lt;/a&gt; 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="019fa0bc748b8d714e14e0a14973bd4b152ee106" translate="yes" xml:space="preserve">
          <source>Here are some examples based on my &lt;a href=&quot;https://github.com/colshrapnel/safemysql/blob/master/safemysql.class.php&quot;&gt;safemysql class&lt;/a&gt; to show how such an abstraction class ought to be:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://github.com/colshrapnel/safemysql/blob/master/safemysql.class.php&quot;&gt;safemysql 클래스&lt;/a&gt; 를 기반으로 이러한 추상화 클래스가 어떻게 작동하는지 보여주는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="e75030adb468b3a20795417b746e352d74186766" translate="yes" xml:space="preserve">
          <source>How about:</source>
          <target state="translated">어때요?</target>
        </trans-unit>
        <trans-unit id="f26d6694fb7f66ecaf4fa1fbfe7bfe24ef194112" translate="yes" xml:space="preserve">
          <source>How prepared statements differ</source>
          <target state="translated">준비된 진술이 어떻게 다른가</target>
        </trans-unit>
        <trans-unit id="ad5800a3aa56f013a36e72eea8f14ecf9737e3a7" translate="yes" xml:space="preserve">
          <source>However &lt;code&gt;PDO&lt;/code&gt; and/or &lt;code&gt;MySQLi&lt;/code&gt; are not completely safe. Check the answer &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/12202218/1723893&quot;&gt;Are PDO prepared statements sufficient to prevent SQL injection?&lt;/a&gt;&lt;/em&gt; by &lt;a href=&quot;https://stackoverflow.com/users/338665/ircmaxell&quot;&gt;ircmaxell&lt;/a&gt;. Also, I am quoting some part from his answer:</source>
          <target state="translated">그러나 &lt;code&gt;PDO&lt;/code&gt; 및 / 또는 &lt;code&gt;MySQLi&lt;/code&gt; 는 완전히 안전하지 않습니다. 답 확인 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/12202218/1723893&quot;&gt;PDO 준비된 명령문이 SQL 삽입을 방지하기에 충분합니까?&lt;/a&gt;&lt;/em&gt; &lt;a href=&quot;https://stackoverflow.com/users/338665/ircmaxell&quot;&gt;ircmaxell에&lt;/a&gt; 의해. 또한, 나는 그의 대답에서 일부를 인용하고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="de3f6b6dffdfbc0e7f9d59202608ca2d11708387" translate="yes" xml:space="preserve">
          <source>However, PDO is not a silver bullet too and has its hardships.</source>
          <target state="translated">그러나 PDO도 은총 알이 아니며 어려움이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2326670ae94db3911611b4826e5793726e96d9a3" translate="yes" xml:space="preserve">
          <source>However, this isn't about folks yelling at you now, this is about showing you how to make your code more secure.</source>
          <target state="translated">그러나 이것은 지금 당신에게 소리 지르는 사람들이 아니라 코드를 더 안전하게 만드는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c9bbba0df8331566d9a670652804604f09ff8317" translate="yes" xml:space="preserve">
          <source>Hybrid PDO use</source>
          <target state="translated">하이브리드 PDO 사용</target>
        </trans-unit>
        <trans-unit id="5e7fba6fe256396d77ecf48550f90f920c0cc0f5" translate="yes" xml:space="preserve">
          <source>I find the above answers really lengthy, so to summarize:</source>
          <target state="translated">위의 답변이 실제로 너무 길어서 요약하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f888fecc5715ba4d43b06bf6c44a1576614e0cd5" translate="yes" xml:space="preserve">
          <source>I will later explain why prepare emulation should be turned off. To find reason please check &lt;a href=&quot;https://stackoverflow.com/a/12202218/1723893&quot;&gt;this post&lt;/a&gt;.</source>
          <target state="translated">나중에 에뮬레이션 준비를 해제해야하는 이유에 대해 설명하겠습니다. 이유를 찾으려면 &lt;a href=&quot;https://stackoverflow.com/a/12202218/1723893&quot;&gt;이 게시물을&lt;/a&gt; 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="28dfd8eb5aa64d92b1531d7f65006651386ac1e5" translate="yes" xml:space="preserve">
          <source>If one were to use PDO of mysqli, the user-name would end-up being &lt;code&gt;&quot;enhzflep); drop table users&quot;&lt;/code&gt;.</source>
          <target state="translated">만약 mysqli의 PDO를 사용한다면, user-name은 &lt;code&gt;&quot;enhzflep); drop table users&quot;&lt;/code&gt; 것이다.</target>
        </trans-unit>
        <trans-unit id="4376248962eeae9e24a09673cabe25c9fe2dda0b" translate="yes" xml:space="preserve">
          <source>If there is any connection error, it will throw a &lt;code&gt;PDOException&lt;/code&gt; object that can be caught to handle &lt;code&gt;Exception&lt;/code&gt; further.</source>
          <target state="translated">연결 오류가 있으면 &lt;code&gt;Exception&lt;/code&gt; 처리를 위해 포착 할 수있는 &lt;code&gt;PDOException&lt;/code&gt; 개체가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="94d17d9e7f39fa252ce5b88628ec7ce8a80613f1" translate="yes" xml:space="preserve">
          <source>If there was any mention of &lt;code&gt;stripslashes()&lt;/code&gt; in your sanitize function, it may indicate a higher level oversight.</source>
          <target state="translated">살균 기능에 &lt;code&gt;stripslashes()&lt;/code&gt; 에 대한 언급이 있으면 더 높은 수준의 감독을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b4c10e7726c178ac937120403512eeb1525dc8e" translate="yes" xml:space="preserve">
          <source>If they don't work on my site, why do I get errors like</source>
          <target state="translated">그들이 내 사이트에서 작동하지 않으면 왜 같은 오류가 발생합니까</target>
        </trans-unit>
        <trans-unit id="846ece56704dd1bb57e31e8af6a84a5ac5a26943" translate="yes" xml:space="preserve">
          <source>If you need more reasons:</source>
          <target state="translated">더 많은 이유가 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="c46e5bd047077b5ae27ca605ac5c2cfb2afbb0b6" translate="yes" xml:space="preserve">
          <source>If you need them - these are no doubt technical reasons to move away from mysql extension toward something more stylish and modern-looking.</source>
          <target state="translated">필요한 경우-이것이 mysql 확장에서 더 세련되고 현대적인 것으로 이동해야 할 기술적 이유입니다.</target>
        </trans-unit>
        <trans-unit id="2407ac2d8afe5ad1d4210ba943dda290fb411756" translate="yes" xml:space="preserve">
          <source>If you understand the necessity of using a &lt;em&gt;database abstraction layer&lt;/em&gt; and looking for an API to create one, &lt;strong&gt;mysqli&lt;/strong&gt; is a very good choice, as it indeed supports many mysql-specific features.</source>
          <target state="translated">&lt;em&gt;데이터베이스 추상화 계층&lt;/em&gt; 을 사용하고 하나를 생성하기위한 API를 찾아야하는 필요성을 이해한다면, &lt;strong&gt;mysqli&lt;/strong&gt; 는 실제로 많은 mysql 관련 기능을 지원하기 때문에 매우 좋은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="d41a7c07f4fd244d7cfdcf97a95a4ac1ba508f7c" translate="yes" xml:space="preserve">
          <source>If you want to simplify your database interaction further, mappers like &lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Paris/Idiorm&lt;/a&gt; are worth a try. Just like nobody uses the bland DOM in JavaScript anymore, you don't have to babysit a raw database interface nowadays.</source>
          <target state="translated">데이터베이스 상호 작용을 더 단순화하려면 &lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Paris / Idiorm&lt;/a&gt; 과 같은 매퍼를 사용해보십시오. 더 이상 JavaScript에서 블랜드 DOM을 사용하지 않는 것처럼 요즘에는 원시 데이터베이스 인터페이스를 보모 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a03e56ddd1d9eaedeb9d91db1610b19c15481de8" translate="yes" xml:space="preserve">
          <source>If, like vast majority of PHP folks, you are using raw API calls right in the application code (which is essentially wrong practice) - &lt;strong&gt;PDO is the only choice&lt;/strong&gt;, as this extension pretends to be not just API but rather a semi-DAL, still incomplete but offers many important features, with two of them makes PDO critically distinguished from mysqli:</source>
          <target state="translated">대다수의 PHP 사용자와 마찬가지로 응용 프로그램 코드에서 원시 API 호출을 사용하는 경우 (실제로 잘못된 관행 임)-이 확장은 API뿐만 아니라 semi-DAL 인 것처럼 가장하기 때문에 &lt;strong&gt;PDO가 유일한 선택입니다&lt;/strong&gt; . 여전히 불완전하지만 많은 중요한 기능을 제공합니다. 그중 두 가지는 PDO를 mysqli와 크게 구별합니다.</target>
        </trans-unit>
        <trans-unit id="5f5e48429d30c2e5c8c7ca18ee430f4c425e3ebe" translate="yes" xml:space="preserve">
          <source>In PDO Data, it is obtained via the &lt;code&gt;-&amp;gt;fetch()&lt;/code&gt;, a method of your statement handle. Before calling fetch, the best approach would be telling PDO how you&amp;rsquo;d like the data to be fetched. In the below section I am explaining this.</source>
          <target state="translated">PDO Data에서는 명령문 핸들의 메소드 인 &lt;code&gt;-&amp;gt;fetch()&lt;/code&gt; 를 통해이를 얻습니다. 가져 오기를 호출하기 전에 가장 좋은 방법은 PDO에게 데이터를 가져 오는 방법을 알려주는 것입니다. 아래 섹션에서 이것을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3859a21002fff48190278b32ba00eefe967fe002" translate="yes" xml:space="preserve">
          <source>In particular you should fix any &lt;code&gt;sanitize&lt;/code&gt; or &lt;code&gt;clean&lt;/code&gt; or &lt;code&gt;filterThis&lt;/code&gt; or &lt;code&gt;clean_data&lt;/code&gt; functions as advertised by dated tutorials in one form or the other:</source>
          <target state="translated">특히 &lt;code&gt;sanitize&lt;/code&gt; 또는 &lt;code&gt;clean&lt;/code&gt; 또는 &lt;code&gt;filterThis&lt;/code&gt; 또는 날짜가 지정된 자습서에서 &lt;code&gt;clean_data&lt;/code&gt; 형식 또는 정리 _ 데이터 기능을 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba93b0ae18afe09edfc1991f28f940835559bcc0" translate="yes" xml:space="preserve">
          <source>In the above query &lt;a href=&quot;http://php.net/manual/en/pdo.exec.php&quot;&gt;&lt;code&gt;PDO::exec&lt;/code&gt;&lt;/a&gt; execute an SQL statement and returns the number of affected rows.</source>
          <target state="translated">위 쿼리에서 &lt;a href=&quot;http://php.net/manual/en/pdo.exec.php&quot;&gt; &lt;code&gt;PDO::exec&lt;/code&gt; &lt;/a&gt; 는 SQL 문을 실행하고 영향을받는 행 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37976e7c9d1ceb09ad128295fdb921a6584e75ca" translate="yes" xml:space="preserve">
          <source>In the above, I have been using &lt;code&gt;fetch()&lt;/code&gt;. You can also use:</source>
          <target state="translated">위에서는 &lt;code&gt;fetch()&lt;/code&gt; 있습니다. 다음을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="838f76e4ca8001fae4cd38b944929578bd91104a" translate="yes" xml:space="preserve">
          <source>In the above, you can see those &lt;code&gt;?&lt;/code&gt; instead of a name like in a name place holder. Now in the first example, we assign variables to the various placeholders (&lt;code&gt;$stmt-&amp;gt;bindValue(1, $name, PDO::PARAM_STR);&lt;/code&gt;). Then, we assign values to those placeholders and execute the statement. In the second example, the first array element goes to the first &lt;code&gt;?&lt;/code&gt; and the second to the second &lt;code&gt;?&lt;/code&gt;.</source>
          <target state="translated">위에서, 당신은 그것들을 볼 수 &lt;code&gt;?&lt;/code&gt; 이름 자리 표시 자와 같은 이름 대신 이제 첫 번째 예에서는 변수를 다양한 자리 표시 자 ( &lt;code&gt;$stmt-&amp;gt;bindValue(1, $name, PDO::PARAM_STR);&lt;/code&gt; )에 할당 합니다. 그런 다음 해당 자리 표시 자에 값을 할당하고 문을 실행합니다. 두 번째 예에서 첫 번째 배열 요소는 첫 번째 &lt;code&gt;?&lt;/code&gt; 두 번째에서 두 번째로 &lt;code&gt;?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51e69d1bd76f27cf149eed630feb3e8bbbe3e693" translate="yes" xml:space="preserve">
          <source>Insert and Update or Delete statements</source>
          <target state="translated">삽입 및 업데이트 또는 삭제 명령문</target>
        </trans-unit>
        <trans-unit id="f6116d88666e16df0efbdad2df064412c9f30a13" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;mysql_num_rows&lt;/code&gt; to get the number of returned rows, you can get a &lt;code&gt;PDOStatement&lt;/code&gt; and do &lt;code&gt;rowCount()&lt;/code&gt;, like:</source>
          <target state="translated">&lt;code&gt;mysql_num_rows&lt;/code&gt; 를 사용하여 리턴 된 행 수를 얻는 대신 &lt;code&gt;PDOStatement&lt;/code&gt; 를 가져 와서 다음 과 같이 &lt;code&gt;rowCount()&lt;/code&gt; 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f4f5b358872d7afce164df88c9ed86e13417775" translate="yes" xml:space="preserve">
          <source>Is &lt;strong&gt;officially &lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;deprecated&lt;/a&gt;&lt;/strong&gt; as of PHP 5.5 (released June 2013).</source>
          <target state="translated">PHP 5.5 (2013 년 6 월 릴리스)부터 &lt;strong&gt;공식적으로 &lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;사용되지 않습니다&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f27190c0d5f51b1ca6eb014f6b10e0503b10a2e9" translate="yes" xml:space="preserve">
          <source>Is not under active development</source>
          <target state="translated">활발한 개발 중이 아님</target>
        </trans-unit>
        <trans-unit id="dcf8be11b129ed1d3fa675563db73c8506041b9b" translate="yes" xml:space="preserve">
          <source>It is only usable if you are using an old version of &lt;code&gt;MySQL&lt;/code&gt; which I do not recommended.</source>
          <target state="translated">내가 권장하지 않는 이전 버전의 &lt;code&gt;MySQL&lt;/code&gt; 을 사용하는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e9565aafd703c4317b924ba9cdbc3c14be98c98" translate="yes" xml:space="preserve">
          <source>It seems to me &lt;strong&gt;too idealistic&lt;/strong&gt; a dream that all those PHP users will learn how to handle SQL queries properly at once. Most likely they would just change mysql_* to mysqli_* mechanically, &lt;strong&gt;leaving the approach the same&lt;/strong&gt;. Especially because mysqli makes prepared statements usage incredible painful and troublesome.</source>
          <target state="translated">모든 PHP 사용자가 SQL 쿼리를 한 번에 올바르게 처리하는 방법을 배우는 것이 &lt;strong&gt;너무 이상적&lt;/strong&gt; 입니다. 대부분의 &lt;strong&gt;경우 접근 방식은 동일하게 유지하면서&lt;/strong&gt; 기계적으로 mysql_ *를 mysqli_ *로 변경했을 것입니다. 특히 mysqli는 준비된 명령문 사용을 엄청나게 고통스럽고 번거롭기 때문에.</target>
        </trans-unit>
        <trans-unit id="ffe81de05696768d78038c224645412434af0ab5" translate="yes" xml:space="preserve">
          <source>It's best to start at simplifying again however. For example the common result fetching:</source>
          <target state="translated">그러나 단순화를 다시 시작하는 것이 가장 좋습니다. 예를 들어 일반적인 결과 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="7bd40f368444a59ce546d97ec42b7235ad3f6390" translate="yes" xml:space="preserve">
          <source>It's mostly the &lt;em&gt;bound parameters&lt;/em&gt; which can simplify code. And with &lt;a href=&quot;https://stackoverflow.com/a/14110189&quot;&gt;excellent tutorials (as seen above)&lt;/a&gt; the transition to &lt;a href=&quot;http://php.net/PDO&quot;&gt;PDO&lt;/a&gt; isn't overly arduous.</source>
          <target state="translated">대부분 코드를 단순화 할 수있는 &lt;em&gt;바운드 매개 변수&lt;/em&gt; 입니다. 그리고 &lt;a href=&quot;https://stackoverflow.com/a/14110189&quot;&gt;훌륭한 튜토리얼을 통해 (위에서 보듯이)&lt;/a&gt; &lt;a href=&quot;http://php.net/PDO&quot;&gt;PDO&lt;/a&gt; 로의 전환이 지나치게 힘들지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="48bb63e397a815a1d4028b30f85fed998e978b00" translate="yes" xml:space="preserve">
          <source>It's possible to define almost all &lt;code&gt;mysql_*&lt;/code&gt; functions using mysqli or PDO. Just include them on top of your old PHP application, and it will work on PHP7. My solution &lt;a href=&quot;https://github.com/sunhater/php7-mysql/blob/master/php7-mysql.php&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">mysqli 또는 PDO를 사용하여 거의 모든 &lt;code&gt;mysql_*&lt;/code&gt; 함수를 정의 할 수 있습니다. 기존 PHP 응용 프로그램 위에 포함하면 PHP7에서 작동합니다. 내 솔루션은 &lt;a href=&quot;https://github.com/sunhater/php7-mysql/blob/master/php7-mysql.php&quot;&gt;여기에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e54f725cef35b6c2a077269e4ced4587f8f5e96" translate="yes" xml:space="preserve">
          <source>Just don't escape a variable &lt;em&gt;and&lt;/em&gt; bind it in the same query.</source>
          <target state="translated">변수를 이스케이프 처리하지 않고 동일한 쿼리에서 바인딩하십시오.</target>
        </trans-unit>
        <trans-unit id="5cc04691e5722139d5540eb38b3f8fdedafc04b3" translate="yes" xml:space="preserve">
          <source>Just switching to &lt;a href=&quot;/questions/tagged/pdo&quot;&gt;pdo&lt;/a&gt; doesn't quite cut it. &lt;code&gt;pdo_query()&lt;/code&gt; is also just a frontend onto it.</source>
          <target state="translated">&lt;a href=&quot;/questions/tagged/pdo&quot;&gt;pdo로&lt;/a&gt; 바꾸는 것만으로는 충분 하지 않습니다. &lt;code&gt;pdo_query()&lt;/code&gt; 는 또한 프론트 엔드입니다.</target>
        </trans-unit>
        <trans-unit id="66ec5c04732160bf6b782f5fc5a7fd3d0a54ffb2" translate="yes" xml:space="preserve">
          <source>Lack of support for prepared statements is particularly important as they provide a clearer, less error prone method of escaping and quoting external data than manually escaping it with a separate function call.</source>
          <target state="translated">준비된 명령문에 대한 지원 부족은 별도의 함수 호출로 외부 데이터를 수동으로 이스케이프 처리하는 것보다 명확하고 오류가 발생하기 쉬운 외부 ​​데이터 이스케이프 및 인용 방법을 제공하므로 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="ef74674a0032ecad5b46a45642e5b320f61a0320" translate="yes" xml:space="preserve">
          <source>Lack of support for prepared statements is particularly important as they provide a clearer, less error-prone method of escaping and quoting external data than manually escaping it with a separate function call.</source>
          <target state="translated">준비된 명령문에 대한 지원 부족은 별도의 함수 호출로 외부 데이터를 수동으로 이스케이프 처리하는 것보다 명확하고 오류가 발생하기 쉬운 외부 ​​데이터 이스케이프 및 인용 방법을 제공하므로 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a5c76c162b06e13ac4bcdfd672e71bd3f45ca6a4" translate="yes" xml:space="preserve">
          <source>Lacks an OO interface</source>
          <target state="translated">OO 인터페이스 부족</target>
        </trans-unit>
        <trans-unit id="f4466bc90729ac480010ac96a72f88b0375e70c8" translate="yes" xml:space="preserve">
          <source>Lacks an OO interface (to create one is a matter of several hours)</source>
          <target state="translated">OO 인터페이스가 부족합니다 (하나를 만드는 데 몇 시간이 걸립니다)</target>
        </trans-unit>
        <trans-unit id="1d16e278bd69ab650d0b2ca2923fa1b532adb204" translate="yes" xml:space="preserve">
          <source>Lastly, this isn't to say that this is PERFECT code. There are many more things that you could do to improve it, use hashed passwords for example, ensure that when you store sensetive information in the database, you don't store it in plain text, have multiple levels of verification - but really, if you just change your old injection prone code to this, you will be WELL along the way to writing good code - and the fact that you have gotten this far and are still reading gives me a sense of hope that you will not only implement this type of code when writing your websites and applications, but that you might go out and research those other things I just mentioned - and more. Write the best code you can, not the most basic code that barely functions.</source>
          <target state="translated">마지막으로 이것이 완벽한 코드라고 말하는 것은 아닙니다. 예를 들어 해시 된 비밀번호를 사용하여 개선하기 위해 할 수있는 일이 더 있습니다. 데이터베이스에 민감한 정보를 저장할 때 일반 텍스트로 저장하지 않고 여러 레벨의 검증을 수행해야합니다. 당신은 당신의 오래된 주입하기 쉬운 코드를 이것으로 변경하면, 좋은 코드를 작성하는 길을 따라갈 것입니다-당신이 지금까지 얻었고 여전히 읽고 있다는 사실은 당신 이이 유형을 구현하지 않을 것이라는 희망을줍니다. 웹 사이트와 애플리케이션을 작성할 때 코드를 작성하지만 방금 언급 한 다른 것들을 조사하고 더 연구 할 수 있습니다. 간신히 작동하는 가장 기본적인 코드가 아니라 가능한 최고의 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d94fac60f2ec2499ed53938148c85015abf6f2b1" translate="yes" xml:space="preserve">
          <source>Let's go through this, sentence by sentence, and explain:</source>
          <target state="translated">이를 통해 문장별로 문장을 살펴보고 설명해 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="e754152995eed2c697af0b43150ac82ad5ccb3c4" translate="yes" xml:space="preserve">
          <source>Lets assume the following script is the verification process for an admin on a website (simplified but working if you copy and use it for testing):</source>
          <target state="translated">다음 스크립트는 웹 사이트의 관리자를위한 검증 프로세스라고 가정합니다 (간단하지만 테스트에 복사하여 사용하면 작동 함).</target>
        </trans-unit>
        <trans-unit id="a707aa190f760150c8ff8256bff3171e748227a0" translate="yes" xml:space="preserve">
          <source>Like:</source>
          <target state="translated">Like:</target>
        </trans-unit>
        <trans-unit id="b11d87a0679fc93bf95cfcb6a2752248f89d290e" translate="yes" xml:space="preserve">
          <source>Maybe I am too ignorant, but I never had an opportunity to use them things like</source>
          <target state="translated">어쩌면 나는 너무 무지하지만, 나는 그들과 같은 것들을 사용할 기회가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="17fe9ca6bbb425d8633e6b31c6b723df16a660db" translate="yes" xml:space="preserve">
          <source>More importantly you can pass $_REQUEST[] variables safely behind any query. When submitted &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; fields match the database structure exactly it's even shorter:</source>
          <target state="translated">더 중요한 것은 모든 쿼리 뒤에 $ _REQUEST [] 변수를 안전하게 전달할 수 있다는 것입니다. 제출 된 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 필드는 데이터베이스 구조와 정확히 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f1587de204fa79f4a4783af5600a077de5317c2d" translate="yes" xml:space="preserve">
          <source>Most glaring bug here is the lack of documentation. More significantly the order of filtering was in exactly the wrong order.</source>
          <target state="translated">여기서 가장 눈에 띄는 버그는 문서가 부족하다는 것입니다. 더 중요한 것은 필터링 순서가 정확히 잘못된 순서였습니다.</target>
        </trans-unit>
        <trans-unit id="f92274be79830199dc63b7643aad05843b510053" translate="yes" xml:space="preserve">
          <source>Move your variables out of the SQL string.</source>
          <target state="translated">SQL 문자열에서 변수를 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="1bdcae0a8ea855d5e4a88cd02e009731df745843" translate="yes" xml:space="preserve">
          <source>Moving away from &lt;code&gt;ext/mysql&lt;/code&gt; is not only about security, but also about having access to all the features of the MySQL database.</source>
          <target state="translated">&lt;code&gt;ext/mysql&lt;/code&gt; 에서 벗어나는 것은 보안뿐만 아니라 MySQL 데이터베이스의 모든 기능에 액세스하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e35ac0203a1fef2dcb5b1881363e036ecd70d1e9" translate="yes" xml:space="preserve">
          <source>Multiple Statements</source>
          <target state="translated">여러 문장</target>
        </trans-unit>
        <trans-unit id="c49860262ec681368ccb9bcf9cb9facc422187d7" translate="yes" xml:space="preserve">
          <source>MySQL deprecated in PHP 5.5.0, and removed in PHP 7.0.0. For a large and old application, this is difficult to search and replace each function.</source>
          <target state="translated">MySQL은 PHP 5.5.0에서 더 이상 사용되지 않으며 PHP 7.0.0에서 제거되었습니다. 크고 오래된 응용 프로그램의 경우 각 기능을 검색하고 교체하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="e8bb7548ab9b8605aff82c9f2282425a263a1641" translate="yes" xml:space="preserve">
          <source>Nevertheless, everyone talking about extensions always missing the &lt;strong&gt;2 important facts&lt;/strong&gt; about Mysqli and PDO:</source>
          <target state="translated">그럼에도 불구하고 확장에 대해 이야기하는 모든 사람들은 항상 Mysqli와 PDO에 대한 &lt;strong&gt;두 가지 중요한 사실을&lt;/strong&gt; 놓치고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d2fa77f8c62d7e4e20bf83f1d23da735eceaaeb" translate="yes" xml:space="preserve">
          <source>Newer! ext/mysql &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7&quot;&gt;has been removed in PHP 7&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">최신! ext / mysql &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7&quot;&gt;은 PHP 7에서 제거되었습니다&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="685d76edff92343d24a20b8ec69b6efaff99726a" translate="yes" xml:space="preserve">
          <source>Non-blocking, asynchronous queries</source>
          <target state="translated">비 차단 비동기식 쿼리</target>
        </trans-unit>
        <trans-unit id="68345c1292e1cc90d4f880a94c3bca3d035eaeb2" translate="yes" xml:space="preserve">
          <source>Not to mention that &lt;em&gt;native&lt;/em&gt; prepared statements &lt;strong&gt;aren't enough to protect&lt;/strong&gt; from SQL injections, and neither mysqli nor PDO offers a solution.</source>
          <target state="translated">말할 것도없이 &lt;em&gt;네이티브&lt;/em&gt; 준비된 명령문으로 &lt;strong&gt;는&lt;/strong&gt; SQL 인젝션 &lt;strong&gt;을 보호하기에 충분&lt;/strong&gt; 하지 않으며 mysqli 나 PDO도 솔루션을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c63f37e1f56dcfbabca1e890130ce1ea2da2597c" translate="yes" xml:space="preserve">
          <source>Not under active development</source>
          <target state="translated">적극적 개발 중이 아님</target>
        </trans-unit>
        <trans-unit id="943cf0ecd5faca4611853075578258bc2002ba56" translate="yes" xml:space="preserve">
          <source>Not under active development (so what? does it affect &lt;em&gt;you&lt;/em&gt; in any practical way?)</source>
          <target state="translated">적극적 개발 중이 아님 (실제로 어떤 영향 &lt;em&gt;을&lt;/em&gt; 미칩니 까?)</target>
        </trans-unit>
        <trans-unit id="bb2ac3999c57f46e2bd9758251dbcf1d84afb4d6" translate="yes" xml:space="preserve">
          <source>Note that this will also hide &lt;strong&gt;other deprecation warnings&lt;/strong&gt;, which, however, may be for things other than MySQL. (&lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation#workarounds&quot;&gt;from PHP manual&lt;/a&gt;&lt;/em&gt;)</source>
          <target state="translated">이것은 또한 &lt;strong&gt;다른 지원 중단 경고를&lt;/strong&gt; 숨길 것입니다. 그러나 이것은 MySQL 이외의 것들에 대한 것일 수도 있습니다. ( &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation#workarounds&quot;&gt;PHP 매뉴얼에서&lt;/a&gt;&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="bda5dde931c8e24b349d67e7a7b806e98b96812c" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;PDO::FETCH_ASSOC&lt;/code&gt; in the &lt;code&gt;fetch()&lt;/code&gt; and &lt;code&gt;fetchAll()&lt;/code&gt; code above. This tells &lt;code&gt;PDO&lt;/code&gt; to return the rows as an associative array with the field names as keys. There are many other fetch modes too which I will explain one by one.</source>
          <target state="translated">위의 &lt;code&gt;fetch()&lt;/code&gt; 및 &lt;code&gt;fetchAll()&lt;/code&gt; 코드에서 &lt;code&gt;PDO::FETCH_ASSOC&lt;/code&gt; 를 사용하십시오. 이것은 &lt;code&gt;PDO&lt;/code&gt; 에게 행을 필드 이름을 키로하는 연관 배열로 리턴하도록 지시합니다. 다른 패치 모드도 많이 있는데, 하나씩 설명해 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="390aff0245fd3f60ed591a199d4ab419c07a3c3d" translate="yes" xml:space="preserve">
          <source>Now I come to fetch mode:</source>
          <target state="translated">이제 가져 오기 모드가되었습니다.</target>
        </trans-unit>
        <trans-unit id="df9f2bb47f2f3240e6cc68b55730527bb6d13c2e" translate="yes" xml:space="preserve">
          <source>Now in &lt;code&gt;PDO&lt;/code&gt;, you can do this like:</source>
          <target state="translated">이제 &lt;code&gt;PDO&lt;/code&gt; 에서 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f01b36c532e5c2589a140fa7f84b5b0a69b50379" translate="yes" xml:space="preserve">
          <source>Now it's time to actually &lt;em&gt;utilize&lt;/em&gt; it.</source>
          <target state="translated">이제 실제로 &lt;em&gt;활용&lt;/em&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="af4e1cd344ecad42d4d3ae20475ecfd47bd9b08f" translate="yes" xml:space="preserve">
          <source>Now, after reading all the things above, you are probably thinking: what the heck is that when I just want to start leaning simple &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; statements? Don't worry, here we go:</source>
          <target state="translated">이제 위의 모든 것을 읽은 후에 생각할 것입니다. 단순한 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 문을 기울이고 싶을 때 어떻게 생각하십니까? 걱정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bb447931ebe2bec10f8d27c32d8b085d4929ad94" translate="yes" xml:space="preserve">
          <source>Now, lets have a look at that code again, this time written using a PDO object:</source>
          <target state="translated">이제이 코드를 다시 살펴 보겠습니다. 이번에는 PDO 객체를 사용하여 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="d95a06cc3375c57a4fb46a5611bf33dc0eac0163" translate="yes" xml:space="preserve">
          <source>Now, lets try the data that a clever chap would enter to try to get past our little verification system:</source>
          <target state="translated">이제 영리한 챕터가 작은 검증 시스템을 통과하기 위해 입력 할 데이터를 사용해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c56d47755ee1354ee2f207be52265612e2153d71" translate="yes" xml:space="preserve">
          <source>Now, you have the better options of using &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;mysqli_&lt;/a&gt; or &lt;a href=&quot;http://www.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt;. I am personally a big fan of PDO, so I will be using PDO in the rest of this answer. There are pro's and con's, but personally I find that the pro's far outweigh the con's. It's portable across multiple database engines - whether you are using MySQL or Oracle or just about bloody anything - just by changing the connection string, it has all the fancy features we want to use and it is nice and clean. I like clean.</source>
          <target state="translated">이제 &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;mysqli_&lt;/a&gt; 또는 &lt;a href=&quot;http://www.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; 를 사용하는 더 나은 옵션이 있습니다. 나는 개인적으로 PDO의 열렬한 팬 이므로이 답변의 나머지 부분에서 PDO를 사용할 것입니다. 찬반 양론이 있지만 개인적으로 나는 찬성이 찬반보다 훨씬 크다는 것을 알았습니다. 연결 문자열을 변경하여 MySQL 또는 Oracle을 사용하거나 피 묻은 것을 막론하고 여러 데이터베이스 엔진에서 이식 할 수 있으며 사용하려는 모든 멋진 기능을 갖추고 있으며 멋지고 깨끗합니다. 나는 청소를 좋아한다.</target>
        </trans-unit>
        <trans-unit id="b4df376bcf338aaf237cc2ceb55bc64301fbe1d9" translate="yes" xml:space="preserve">
          <source>Object-oriented interface</source>
          <target state="translated">객체 지향 인터페이스</target>
        </trans-unit>
        <trans-unit id="79f9618f1912184bc89ea96846cec252f2b5b111" translate="yes" xml:space="preserve">
          <source>Often string variables aren't just interpolated into SQL, but concatenated with escaping calls in between.</source>
          <target state="translated">종종 문자열 변수는 SQL로 보간되는 것이 아니라 그 사이의 이스케이프 호출과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="0842d63b94cdae1d97ca5df8b49fbf2cefb344db" translate="yes" xml:space="preserve">
          <source>Oh, I just got a little excited, it worked: The check passed. We have a verified admin!</source>
          <target state="translated">오, 방금 조금 흥분해서 작동했습니다. 수표가 통과되었습니다. 확인 된 관리자가 있습니다!</target>
        </trans-unit>
        <trans-unit id="94c3dc399cf5b64e36b7c400dadceac39bc77b5b" translate="yes" xml:space="preserve">
          <source>Okay, so what went wrong, and how can we fix it?</source>
          <target state="translated">자, 무엇이 잘못되었고 어떻게 해결할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e33efcc54426fd4f64d01de7305ceab6f21b294b" translate="yes" xml:space="preserve">
          <source>Once you have converted all &lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt; calls to &lt;code&gt;pdo_query&lt;/code&gt; with bound params, remove all redundant &lt;code&gt;pdo_real_escape_string&lt;/code&gt; calls.</source>
          <target state="translated">바인딩 된 매개 변수를 사용하여 모든 &lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; 호출을 &lt;code&gt;pdo_query&lt;/code&gt; 로 변환 한 후 모든 중복 &lt;code&gt;pdo_real_escape_string&lt;/code&gt; 호출을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="dccb816213ce63a2edee44cd16d1bf786620eda9" translate="yes" xml:space="preserve">
          <source>Or better yet a direct and complete array retrieval:</source>
          <target state="translated">또는 직접적이고 완전한 배열 검색이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d291165f3e48fa04de2df661e5577d3237e36a86" translate="yes" xml:space="preserve">
          <source>Other options</source>
          <target state="translated">다른 옵션</target>
        </trans-unit>
        <trans-unit id="80c9afff3fc6e7a45d3cc8c0ba82a6e36345cadc" translate="yes" xml:space="preserve">
          <source>PHP offers three different APIs to connect to MySQL. These are the &lt;a href=&quot;http://in1.php.net/manual/en/book.mysql.php&quot;&gt;&lt;code&gt;mysql&lt;/code&gt;&lt;/a&gt;(removed as of PHP 7), &lt;a href=&quot;http://uk.php.net/manual/en/book.mysqli.php&quot;&gt;&lt;code&gt;mysqli&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;&lt;code&gt;PDO&lt;/code&gt;&lt;/a&gt; extensions.</source>
          <target state="translated">PHP는 MySQL에 연결하기 위해 세 가지 다른 API를 제공합니다. 이들은 &lt;a href=&quot;http://in1.php.net/manual/en/book.mysql.php&quot;&gt; &lt;code&gt;mysql&lt;/code&gt; &lt;/a&gt; (PHP 7에서 제거됨), &lt;a href=&quot;http://uk.php.net/manual/en/book.mysqli.php&quot;&gt; &lt;code&gt;mysqli&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt; &lt;code&gt;PDO&lt;/code&gt; &lt;/a&gt; 확장입니다.</target>
        </trans-unit>
        <trans-unit id="66b1f6ccb868a51c719c54211a58306d2ce6458b" translate="yes" xml:space="preserve">
          <source>Place question marks &lt;code&gt;?&lt;/code&gt; as placeholders where the variables were before.</source>
          <target state="translated">물음표를 배치 &lt;code&gt;?&lt;/code&gt; 변수가 이전에 있던 자리 표시 자로</target>
        </trans-unit>
        <trans-unit id="7478e01a69a59cf96a526ecfcd34a76707511615" translate="yes" xml:space="preserve">
          <source>Prepared statement &lt;strong&gt;isn't a silver bullet&lt;/strong&gt;. There are dynamical identifiers which cannot be bound using prepared statements. There are dynamical queries with an unknown number of parameters which makes query building a difficult task.</source>
          <target state="translated">준비된 진술 &lt;strong&gt;은 은색 총알이 아닙니다&lt;/strong&gt; . 준비된 명령문을 사용하여 바인딩 할 수없는 동적 식별자가 있습니다. 알 수없는 매개 변수를 가진 동적 쿼리가있어 쿼리 작성이 어려운 작업입니다.</target>
        </trans-unit>
        <trans-unit id="88e0e0a0df815f954f20830db35becc23bd2fb02" translate="yes" xml:space="preserve">
          <source>Prepared statements</source>
          <target state="translated">준비된 진술</target>
        </trans-unit>
        <trans-unit id="0b0459e39e775d8d016c9a1b7d9fbb9cf8ae780b" translate="yes" xml:space="preserve">
          <source>Q. First question in my mind was: what is `PDO`?</source>
          <target state="translated">Q. 내 마음의 첫 번째 질문은 'PDO'란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="cb0e0b93a85516a6c4a7283d442e3274fb701224" translate="yes" xml:space="preserve">
          <source>Remember that pdo_* still allows &lt;em&gt;either or&lt;/em&gt;.</source>
          <target state="translated">pdo_ *는 여전히 또는를 허용 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3e04ee6f5fe2cec54a2d0b8c7a1e5d97c3761798" translate="yes" xml:space="preserve">
          <source>Remove the &lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt; function prefix &lt;em&gt;everywhere&lt;/em&gt; and replace it with &lt;strong&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; 함수 접두어를 &lt;em&gt;모든 곳에서&lt;/em&gt; 제거하고 &lt;strong&gt; &lt;code&gt;pdo_&lt;/code&gt; 로&lt;/strong&gt; 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="6e950042d73e706574ab836f1c73abbaeaec437a" translate="yes" xml:space="preserve">
          <source>Removed as of PHP 7</source>
          <target state="translated">PHP 7에서 제거</target>
        </trans-unit>
        <trans-unit id="f71536fa3d10e36d63218592cefa79677819294b" translate="yes" xml:space="preserve">
          <source>Rewriting a larger code base at once however takes time. Raison d'&amp;ecirc;tre for this intermediate alternative:</source>
          <target state="translated">그러나 더 큰 코드 기반을 한 번에 다시 작성하려면 시간이 걸립니다. 이 중간 대안을위한 Raison d' &amp;ecirc;tre :</target>
        </trans-unit>
        <trans-unit id="b7b089287c11c303c7e28345b34bb09873f7b3e2" translate="yes" xml:space="preserve">
          <source>Rewriting doesn't have to stop at using the new pdo_ function names. You could one by one transition each pdo_query() into a plain $pdo-&amp;gt;prepare()-&amp;gt;execute() call.</source>
          <target state="translated">새로운 pdo_ 함수 이름을 사용하여 다시 쓰기를 중단 할 필요는 없습니다. 각 pdo_query ()를 일반 $ pdo-&amp;gt; prepare ()-&amp;gt; execute () 호출로 하나씩 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d18471042a4567ba79deea1a219d4a26d8d8459a" translate="yes" xml:space="preserve">
          <source>SQL injections simply are when &lt;em&gt;data bleeds into code&lt;/em&gt; context. A database server can't later spot where PHP originally glued variables inbetween query clauses.</source>
          <target state="translated">SQL 삽입은 단순히 &lt;em&gt;데이터가 코드&lt;/em&gt; 컨텍스트에서 &lt;em&gt;번질&lt;/em&gt; 때 발생 &lt;em&gt;합니다&lt;/em&gt; . 데이터베이스 서버는 나중에 PHP가 쿼리 절 사이에서 원래 변수를 붙인 위치를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e665bf1f2a0279913bf81f45ec5a5c78ea174425" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://bobby-tables.com/&quot;&gt;bobby-tables.com&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://bobby-tables.com/&quot;&gt;bobby-tables.com을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5434d7a025004202b6c9d1ef189773a1aad44220" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;&lt;strong&gt;the comparison of SQL extensions&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;&lt;strong&gt;SQL 확장 비교를&lt;/strong&gt;&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7489fd89c972450ae2f6ec9bf321744a53fac8d8" translate="yes" xml:space="preserve">
          <source>See how I constructed my &quot;password&quot; so that it would first close the single quote around the password, then introduce a completely new comparison? Then just for safety, I added another &quot;string&quot; so that the single quote would get closed as expected in the code we originally had.</source>
          <target state="translated">&quot;암호&quot;를 구성하여 암호 주위의 작은 따옴표를 먼저 닫은 다음 완전히 새로운 비교를 소개하는 방법을 확인하십시오. 그런 다음 안전을 위해 다른 &quot;문자열&quot;을 추가하여 원래 인용했던 코드에서 작은 따옴표가 예상대로 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="55506229592fa23e7b5870b9dc6c5aa7e1583634" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;comparison of SQL extensions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;SQL 확장 비교를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8332ef556cea9f1f40a6c76849dace653964c7a0" translate="yes" xml:space="preserve">
          <source>Seems legit enough at first glance.</source>
          <target state="translated">언뜻보기에 합법적 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="af912eddd3068889909f441f05cc66e7d588440d" translate="yes" xml:space="preserve">
          <source>Selecting Data</source>
          <target state="translated">데이터 선택</target>
        </trans-unit>
        <trans-unit id="418dc8b027c0175bc948e9cbb66d6a25f398bcb1" translate="yes" xml:space="preserve">
          <source>Simply &lt;code&gt;include_once(&lt;/code&gt;&lt;a href=&quot;http://fossil.include-once.org/upgradephp/artifact/43ab742241e5a3be43d31764dd333ba68e245360&quot;&gt;&lt;code&gt;&quot;pdo_mysql.php&quot;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;);&lt;/code&gt; in each invocation script that has to interact with the database.</source>
          <target state="translated">간단히 &lt;code&gt;include_once(&lt;/code&gt; &lt;a href=&quot;http://fossil.include-once.org/upgradephp/artifact/43ab742241e5a3be43d31764dd333ba68e245360&quot;&gt; &lt;code&gt;&quot;pdo_mysql.php&quot;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;);&lt;/code&gt; 데이터베이스와 상호 작용해야하는 각 호출 스크립트에서</target>
        </trans-unit>
        <trans-unit id="da5002da9abdeebe9fb4cab82878e2462cde36fb" translate="yes" xml:space="preserve">
          <source>Since it is deprecated, using it makes your code less future proof.</source>
          <target state="translated">더 이상 사용되지 않으므로 사용하면 코드의 미래 증거가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="181dff808d342cf7f9e72760d9c8e79ed94e35e7" translate="yes" xml:space="preserve">
          <source>So much simplicity. But let's get back to some more rewriting advises and technical reasons on why you may want to get rid of &lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt; and escaping.</source>
          <target state="translated">매우 단순합니다. 그러나 왜 &lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; 과 이스케이프를 제거하고 싶을 지에 대한 더 많은 재 작성 조언과 기술적 이유로 돌아가 봅시다.</target>
        </trans-unit>
        <trans-unit id="0e06bdf278d741a7d2afe7a65871fe0c7c71210f" translate="yes" xml:space="preserve">
          <source>So this hopefully visualized some &lt;em&gt;practical&lt;/em&gt; reasons and a worthwile pathway to drop &lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;.</source>
          <target state="translated">따라서 이것은 &lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; 을 떨어 뜨릴 &lt;em&gt;실용적인&lt;/em&gt; 이유와 가치있는 경로를 시각화했습니다.</target>
        </trans-unit>
        <trans-unit id="3012707c2195366927599a0dd74ecf1430c805f0" translate="yes" xml:space="preserve">
          <source>So what you are doing in &lt;code&gt;mysql_*&lt;/code&gt; is:</source>
          <target state="translated">따라서 &lt;code&gt;mysql_*&lt;/code&gt; 에서 하는 일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="502276f58db137875cfb6cf92bfa59236b8263ac" translate="yes" xml:space="preserve">
          <source>So, I wrote solutions for all the common pitfalls and complex cases in the &lt;a href=&quot;https://stackoverflow.com/tags/pdo/info&quot;&gt;&lt;strong&gt;PDO tag wiki&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">그래서 &lt;a href=&quot;https://stackoverflow.com/tags/pdo/info&quot;&gt;&lt;strong&gt;PDO 태그 위키&lt;/strong&gt;&lt;/a&gt; 에서 모든 일반적인 함정과 복잡한 사례에 대한 솔루션을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="72d2f3bbb78bd884d0b025adc79a648f2da15e63" translate="yes" xml:space="preserve">
          <source>So, how do we protect your sacred admin section and make it nice and secure? The first thing to do will be to stop using those really old and deprecated &lt;code&gt;mysql_*&lt;/code&gt; functions. I know, you followed a tutorial you found online and it works, but it's old, it's outdated and in the space of a few minutes, I have just broken past it without so much as breaking a sweat.</source>
          <target state="translated">그렇다면 신성한 관리자 섹션을 어떻게 보호하고 멋지고 안전하게 만들 수 있습니까? 가장 먼저 할 일은 실제로 오래되고 더 이상 사용되지 않는 &lt;code&gt;mysql_*&lt;/code&gt; 함수 사용을 중지하는 것입니다. 나는 당신이 온라인에서 찾은 튜토리얼을 따랐으며 작동하지만 오래되었지만 구식이며 몇 분 안에 땀을 흘리지 않고 과거를 지나쳤습니다.</target>
        </trans-unit>
        <trans-unit id="156ae2c1a681018477e990b03ebe020a3aacb23e" translate="yes" xml:space="preserve">
          <source>So, if you are an average PHP user and want to save yourself a ton of headaches when using native prepared statements, PDO - again - is the only choice.</source>
          <target state="translated">따라서 일반적인 PHP 사용자이고 기본 준비 명령문을 사용할 때 많은 두통을 피하고 싶다면 PDO가 유일한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="09bd59ae9fef4f113a6fb3d96fee1aae3a9fb79f" translate="yes" xml:space="preserve">
          <source>So, in answer, THAT IS WHY YOU ARE BEING YELLED AT.</source>
          <target state="translated">따라서, 당신이 왜 고문을 당하고 있는지에 대한 답입니다.</target>
        </trans-unit>
        <trans-unit id="4586573c065a2c5d5186ace73cde0c4532012c55" translate="yes" xml:space="preserve">
          <source>So, instead of fighting this honest extension, I'd prefer to fight wrong practices and educate people in the right ways.</source>
          <target state="translated">따라서이 정직한 확장과 싸우는 대신 잘못된 관행에 맞서 싸우고 올바른 방법으로 사람들을 교육하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="977784c6079621feedaf15de1c0e69f13959d921" translate="yes" xml:space="preserve">
          <source>So, just switching to PDO or mysqli is not enough. One has to use an ORM, or a query builder, or whatever database abstraction class instead of calling raw API functions in their code.</source>
          <target state="translated">따라서 PDO 또는 mysqli로 전환하는 것만으로는 충분하지 않습니다. 코드에서 원시 API 함수를 호출하는 대신 ORM 또는 쿼리 빌더 또는 모든 데이터베이스 추상화 클래스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a4c25a013fc181e44690a0c81f43ed6d49a2760" translate="yes" xml:space="preserve">
          <source>So, lets have a look at what went wrong, and why I just got into your super-admin-only-bat-cave. I took a guess and assumed that you weren't being careful with your inputs and simply passed them to the database directly. I constructed the input in a way tht would CHANGE the query that you were actually running. So, what was it supposed to be, and what did it end up being?</source>
          <target state="translated">그래서 무엇이 잘못되었는지, 왜 방금 슈퍼 관리자 전용 박쥐 동굴에 들어 갔는지 살펴 보겠습니다. 나는 추측을하고 입력에주의를 기울이지 않고 단순히 데이터베이스에 직접 전달했다고 가정했습니다. 실제로 실행중인 쿼리를 변경하는 방식으로 입력을 구성했습니다. 그래서, 무엇이되어야했고, 무엇으로 끝났습니까?</target>
        </trans-unit>
        <trans-unit id="419b0e23c522675ea4d8d7c937461eb95377a4fe" translate="yes" xml:space="preserve">
          <source>So, once more - it is not just raw driver should be your concern but abstraction class, useful not only for silly examples from beginner's manual but to solve whatever real-life problems.</source>
          <target state="translated">따라서 한 번 더-그것은 원시 드라이버 일뿐 아니라 추상화 클래스입니다. 초보자 매뉴얼의 어리석은 예제뿐만 아니라 실제 문제를 해결하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8cf0be74cb1010c94f25e5fc839c648278844902" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;http://us2.php.net/manual/en/mysqli.overview.php&quot;&gt;MySQLi overview&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;http://us2.php.net/manual/en/mysqli.overview.php&quot;&gt;MySQLi 개요&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcb447d1aaebb249a35efcda9785a596a7569ba1" translate="yes" xml:space="preserve">
          <source>Speaking of &lt;em&gt;technical&lt;/em&gt; reasons, there are only a few, extremely specific and rarely used. Most likely you will never ever use them in your life.</source>
          <target state="translated">&lt;em&gt;기술적&lt;/em&gt; 이유에 대해 말하면 극도로 구체적이며 거의 사용되지 않는 경우는 거의 없습니다. 아마 당신은 결코 당신의 인생에서 그들을 사용하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="bf36b631054e4b9ebdd95cb1972bb398da13213f" translate="yes" xml:space="preserve">
          <source>Stored procedures</source>
          <target state="translated">저장 프로 시저</target>
        </trans-unit>
        <trans-unit id="43f21f37b385b47e7aca36f912842875218a10aa" translate="yes" xml:space="preserve">
          <source>String/value handling is delegated to PDO and its parameterized statements.</source>
          <target state="translated">문자열 / 값 처리는 PDO 및 해당 매개 변수화 된 명령문에 위임됩니다.</target>
        </trans-unit>
        <trans-unit id="f330726eae49c3e09ec43d61637f5396a5a55745" translate="yes" xml:space="preserve">
          <source>Super! Working as expected, now lets try the actual username and password:</source>
          <target state="translated">감독자! 예상대로 작동하면 이제 실제 사용자 이름과 비밀번호를 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="dfadaca1a30bce993f932dca13aff0957793e885" translate="yes" xml:space="preserve">
          <source>Support for Multiple Statements</source>
          <target state="translated">여러 문장에 대한 지원</target>
        </trans-unit>
        <trans-unit id="2142d72824641e7c7d357d78453232623a4fd7ff" translate="yes" xml:space="preserve">
          <source>Support for Prepared Statements</source>
          <target state="translated">준비된 진술에 대한 지원</target>
        </trans-unit>
        <trans-unit id="1051e4c201c5f65414e7b143a72570669fd228ca" translate="yes" xml:space="preserve">
          <source>Support for Transactions</source>
          <target state="translated">거래 지원</target>
        </trans-unit>
        <trans-unit id="aa4d81fe71bb245630f293271255fef6e35bbfad" translate="yes" xml:space="preserve">
          <source>That was commonly there to undo damage (double escaping) from the deprecated &lt;a href=&quot;http://php.net/magic_quotes&quot;&gt;&lt;code&gt;magic_quotes&lt;/code&gt;&lt;/a&gt;. Which however is &lt;a href=&quot;https://stackoverflow.com/questions/517008/how-to-turn-off-magic-quotes-on-shared-hosting&quot;&gt;best fixed centrally&lt;/a&gt;, not string by string.</source>
          <target state="translated">그것은 일반적으로 사용되지 않는 &lt;a href=&quot;http://php.net/magic_quotes&quot;&gt; &lt;code&gt;magic_quotes&lt;/code&gt; 로&lt;/a&gt; 인한 피해 (이중 이스케이프)를 취소하기 위해있었습니다. 그러나 문자열별로가 아니라 &lt;a href=&quot;https://stackoverflow.com/questions/517008/how-to-turn-off-magic-quotes-on-shared-hosting&quot;&gt;중앙&lt;/a&gt; 에서 가장 잘 고정 됩니다.</target>
        </trans-unit>
        <trans-unit id="34467e1287edc5b797be2730e35c61969473a83f" translate="yes" xml:space="preserve">
          <source>That's the query, but when we replace the variables with the actual inputs that we used, we get the following:</source>
          <target state="translated">이것이 쿼리이지만 변수를 실제 입력으로 바꾸면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e35c0916a18283d4ea1f81a70d61efa106dd1b1f" translate="yes" xml:space="preserve">
          <source>The &quot;new&quot; password authentication method (on by default in MySQL 5.6; required in 5.7)</source>
          <target state="translated">&quot;새로운&quot;패스워드 인증 방법 (MySQL 5.6에서는 기본적으로; 5.7에서는 필수)</target>
        </trans-unit>
        <trans-unit id="a8deffdde633f6dcdac49482f5db747ce9e171b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mysql_*&lt;/code&gt; functions used to be very popular, but their use is not encouraged anymore. The documentation team is discussing the database security situation, and educating users to move away from the commonly used ext/mysql extension is part of this (check &lt;em&gt;&lt;a href=&quot;http://news.php.net/php.internals/53799&quot;&gt;php.internals: deprecating ext/mysql&lt;/a&gt;&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;mysql_*&lt;/code&gt; 함수는 매우 유명했지만 더 이상 사용하지 않는 것이 좋습니다. 문서화 팀은 데이터베이스 보안 상황에 대해 논의하고 있으며 사용자가 일반적으로 사용되는 ext / mysql 확장에서 벗어나도록 교육하는 것이 이것의 일부입니다 ( &lt;em&gt;&lt;a href=&quot;http://news.php.net/php.internals/53799&quot;&gt;php.internals : deprecating ext / mysql 확인&lt;/a&gt;&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="d67db1d2a3f9c279e59ee7cbab7e7ad484b23610" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mysql_&lt;/code&gt; functions:</source>
          <target state="translated">&lt;code&gt;mysql_&lt;/code&gt; 함수 :</target>
        </trans-unit>
        <trans-unit id="8555deeb46964ebda4fb022ebe48c5e2ada84f62" translate="yes" xml:space="preserve">
          <source>The DBMS parses, compiles, and performs query optimization on the statement template, and stores the result without executing it.</source>
          <target state="translated">DBMS는 명령문 템플리트에서 쿼리 최적화를 구문 분석, 컴파일 및 수행하고 결과를 실행하지 않고 저장합니다.</target>
        </trans-unit>
        <trans-unit id="23a504e237cda5d5bd1d5d68ab647b0abc87ece7" translate="yes" xml:space="preserve">
          <source>The MySQL extension is the oldest of the three and was the original way that developers used to communicate with MySQL. This extension is now being &lt;a href=&quot;http://php.net/manual/en/migration55.deprecated.php&quot;&gt;deprecated&lt;/a&gt; in favor of the other &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;two&lt;/a&gt;&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;alternatives&lt;/a&gt; because of improvements made in newer releases of both PHP and MySQL.</source>
          <target state="translated">MySQL 확장은 3 개 중 가장 오래된 것으로서 개발자가 MySQL과 통신하는 데 사용한 원래 방식이었습니다. 이 확장은 현재 PHP와 MySQL의 새로운 릴리스에서 개선 된 기능 때문에 다른 &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;두 가지&lt;/a&gt; &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;대안&lt;/a&gt; 을 위해 &lt;a href=&quot;http://php.net/manual/en/migration55.deprecated.php&quot;&gt;사용되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a41f267bbe8e8e99d77e3f59457faa0a4e2d32" translate="yes" xml:space="preserve">
          <source>The MySQL extension:</source>
          <target state="translated">MySQL 확장 :</target>
        </trans-unit>
        <trans-unit id="21414d4d700662c909aebc645c1a9d88f9c8e575" translate="yes" xml:space="preserve">
          <source>The PDOException class &amp;para;</source>
          <target state="translated">PDOException 클래스</target>
        </trans-unit>
        <trans-unit id="ceaa748e73e903659c37e91ec7bc481b4aba692e" translate="yes" xml:space="preserve">
          <source>The above method is only useful when you are not using variable in query. But when you need to use a variable in a query, do not ever ever try like the above and there for  &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;strong&gt;prepared statement or parameterized statement&lt;/strong&gt;&lt;/a&gt; is.</source>
          <target state="translated">위의 방법은 쿼리에서 변수를 사용하지 않는 경우에만 유용합니다. 그러나 쿼리에서 변수를 사용해야 할 때 위와 같이 시도하지 마십시오. &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;strong&gt;준비된 명령문이나 매개 변수화 된 명령문&lt;/strong&gt;&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b16db0ed6b33fd376c4271f150426eeb37d5407a" translate="yes" xml:space="preserve">
          <source>The advantage becomes more obvious for lengthier code.</source>
          <target state="translated">코드가 길수록 장점이 더 분명해집니다.</target>
        </trans-unit>
        <trans-unit id="5a186859a541d2250d60b00b21cdf3c3b63312a9" translate="yes" xml:space="preserve">
          <source>The analytic and synthetic reasons were already mentioned. For newcomers there's a more significant incentive to stop using the dated mysql_ functions.</source>
          <target state="translated">분석 및 합성 이유는 이미 언급되었습니다. 신규 이민자에게는 날짜가 지정된 mysql_ 함수 사용을 중단하는 것이 더 큰 동기가됩니다.</target>
        </trans-unit>
        <trans-unit id="27bb7e6155e751876dec5eb5272f609fe02b5ef0" translate="yes" xml:space="preserve">
          <source>The article &lt;em&gt;&lt;a href=&quot;http://net.tutsplus.com/tutorials/php/pdo-vs-mysqli-which-should-you-use/&quot;&gt;PDO vs. MySQLi: Which Should You Use?&lt;/a&gt;&lt;/em&gt; by &lt;a href=&quot;http://webarto.com/&quot;&gt;&lt;strong&gt;Dejan Marjanovic&lt;/strong&gt;&lt;/a&gt; will help you to choose.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://net.tutsplus.com/tutorials/php/pdo-vs-mysqli-which-should-you-use/&quot;&gt;PDO vs. MySQLi&lt;/a&gt;&lt;/em&gt; 기사 &lt;em&gt;: 어느 것을 사용해야합니까?&lt;/em&gt; 에 의해 &lt;a href=&quot;http://webarto.com/&quot;&gt;&lt;strong&gt;Dejan Marjanovic&lt;/strong&gt;&lt;/a&gt; 당신이 선택하는 데 도움이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="99a09cf05588a6ee72d21881c364b7fa6b57bb3e" translate="yes" xml:space="preserve">
          <source>The functions which are as similar to this &lt;code&gt;mysql_connect()&lt;/code&gt;, &lt;code&gt;mysql_query()&lt;/code&gt; type are the previous version PHP i.e(PHP 4) functions and now not in use .</source>
          <target state="translated">이 &lt;code&gt;mysql_connect()&lt;/code&gt; , &lt;code&gt;mysql_query()&lt;/code&gt; 유형과 유사한 함수 는 이전 버전의 PHP ie (PHP 4) 함수이며 현재 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4abbb603d8f2b2afd3d6309a44e29670822a32ff" translate="yes" xml:space="preserve">
          <source>The last one is an interesting point. Although mysql ext do not support &lt;em&gt;native&lt;/em&gt; prepared statements, they aren't required for the safety. We can easily fake prepared statements using manually handled placeholders (just like PDO does):</source>
          <target state="translated">마지막은 흥미로운 점입니다. mysql ext는 &lt;em&gt;기본&lt;/em&gt; 준비된 명령문을 지원하지 않지만 안전을 위해 필요하지는 않습니다. PDO처럼 수동으로 처리 된 자리 표시자를 사용하여 준비된 명령문을 쉽게 위조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dada7706eedc4cc1377e36d4ff7b1cba1c73978" translate="yes" xml:space="preserve">
          <source>The major differences are that there are no more &lt;code&gt;mysql_*&lt;/code&gt; functions. It's all done via a PDO object, secondly, it is using a prepared statement. Now, what's a prepred statement you ask? It's a way to tell the database ahead of running a query, what the query is that we are going to run. In this case, we tell the database: &quot;Hi, I am going to run a select statement wanting id, userid and pass from the table users where the userid is a variable and the pass is also a variable.&quot;.</source>
          <target state="translated">가장 큰 차이점은 더 이상 &lt;code&gt;mysql_*&lt;/code&gt; 함수가 없다는 것입니다. 그것은 모두 PDO 객체를 통해 이루어지며 두 번째로 준비된 문장을 사용하고 있습니다. 자, 당신이 요구하는 prepreed 진술은 무엇입니까? 쿼리를 실행하기 전에 데이터베이스에 알리는 방법입니다. 이 경우 데이터베이스에 다음과 같이 알려줍니다. &quot;저는 id, userid를 원하는 select 문을 실행하고 userid가 변수이고 pass도 변수 인 테이블 사용자에게 전달하려고합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="2dccd3b2ef63bf7cb2dcdbff4e9bf66af2258b71" translate="yes" xml:space="preserve">
          <source>The mysqli extension has a number of
  benefits, the key enhancements over
  the mysql extension being:</source>
          <target state="translated">mysqli 확장은 여러 가지 이점이 있으며 mysql 확장에 비해 다음과 같은 주요 기능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="562dc1125a1bf25b7d1d24db6381f0d3d62bbedd" translate="yes" xml:space="preserve">
          <source>The original implementation in PHP2/FI introduced it explicitly with just &quot;&lt;em&gt;quotes will be automatically escaped making it easier to pass form data directly to msql queries&lt;/em&gt;&quot;. Notably it was accidentially safe to use with &lt;a href=&quot;http://www.hughes.com.au/products/msql/&quot;&gt;mSQL&lt;/a&gt;, as that supported ASCII only.</source>
          <target state="translated">PHP2 / FI의 원래 구현은 &quot; &lt;em&gt;인용 부호가 자동으로 이스케이프되어 양식 데이터를 msql 쿼리에 직접 전달하는 것이 더 쉬워집니다&lt;/em&gt; &quot;라는 명시 적으로 도입되었습니다. 특히 ASCII 만 지원했기 때문에 &lt;a href=&quot;http://www.hughes.com.au/products/msql/&quot;&gt;mSQL&lt;/a&gt; 과 함께 사용하는 것이 우연히 안전했습니다.</target>
        </trans-unit>
        <trans-unit id="aebcc1312a3d5f8dc2dd1e177025cf78c72eda79" translate="yes" xml:space="preserve">
          <source>The other is to turn off prepare emulation which is enabled in the &lt;code&gt;MySQL&lt;/code&gt; driver by default, but prepare emulation should be turned off to use &lt;code&gt;PDO&lt;/code&gt; safely.</source>
          <target state="translated">다른 하나는 &lt;code&gt;MySQL&lt;/code&gt; 드라이버에서 기본적으로 활성화 된 준비 에뮬레이션을 끄는 것입니다. 그러나 &lt;code&gt;PDO&lt;/code&gt; 를 안전하게 사용하려면 준비 에뮬레이션을 꺼야합니다.</target>
        </trans-unit>
        <trans-unit id="e1647f08fd0d03cfed6027ec69a028632d0edcfe" translate="yes" xml:space="preserve">
          <source>The output is as follows:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c80ab0d65d86371430abcdf8ed4202036dd3c5d" translate="yes" xml:space="preserve">
          <source>The placeholder feature is provided by the real PDO behind it.</source>
          <target state="translated">자리 표시 자 기능은 실제 PDO에 의해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b025ee4adb8cf0f65ed9aabff546b7033803e091" translate="yes" xml:space="preserve">
          <source>The results are fantastic. Lets try those username and password combinations from before again:</source>
          <target state="translated">결과는 환상적입니다. 이전부터 다시 사용자 이름과 비밀번호 조합을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6367ed4377cb731bc3493ca0a1f8fb62d7a404f7" translate="yes" xml:space="preserve">
          <source>The typical workflow of using a prepared statement is as follows (&lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;quoted from Wikipedia three 3 point&lt;/a&gt;):</source>
          <target state="translated">준비된 문장을 사용하는 일반적인 워크 플로는 다음과 같습니다 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;Wikipedia 3 3 point 인용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c0663df1a52266fe58480cc90e9a9f1077932a7a" translate="yes" xml:space="preserve">
          <source>The user has to enter a login and password, right?</source>
          <target state="translated">사용자는 로그인과 비밀번호를 입력해야합니까?</target>
        </trans-unit>
        <trans-unit id="bd441197e0d87715716a19344182973372419d2a" translate="yes" xml:space="preserve">
          <source>Then PHP3/Zend reintroduced magic_quotes for MySQL and misdocumented it. But originally it was just a &lt;a href=&quot;https://stackoverflow.com/questions/16098194/why-magic-quotes-has-been-removed-from-php-5-4&quot;&gt;convenience feature&lt;/a&gt;, not intend for security.</source>
          <target state="translated">그런 다음 PHP3 / Zend는 MySQL 용 magic_quotes를 다시 도입하여 잘못 문서화했습니다. 그러나 원래는 보안을위한 것이 아니라 &lt;a href=&quot;https://stackoverflow.com/questions/16098194/why-magic-quotes-has-been-removed-from-php-5-4&quot;&gt;편의 기능&lt;/a&gt; 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="57c2defd4b5ec30df25974856ac6eb0286c19204" translate="yes" xml:space="preserve">
          <source>Then compare with &lt;a href=&quot;https://stackoverflow.com/a/17874410/285587&quot;&gt;crazy amount of code&lt;/a&gt; you will need with raw Mysqli prepared statements.
Note that error handling, profiling, query logging already built in and running.</source>
          <target state="translated">그런 다음 원시 Mysqli 준비 명령문으로 필요한 &lt;a href=&quot;https://stackoverflow.com/a/17874410/285587&quot;&gt;엄청난 양의 코드&lt;/a&gt; 와 비교하십시오. 오류 처리, 프로파일 링, 쿼리 로깅이 이미 내장되어 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="c9c4db9de41823c261f34da4aa90c4b93945d84c" translate="yes" xml:space="preserve">
          <source>Then, in the execute statement, we pass the database an array with all the variables that it now expects.</source>
          <target state="translated">그런 다음 execute 문에서 데이터베이스에 현재 예상되는 모든 변수가 포함 된 배열을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c69679c49c5f8114f4079ae3ec807eb8cad58847" translate="yes" xml:space="preserve">
          <source>There are better, more robust and well-built alternatives, &lt;strong&gt;&lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO - PHP Database Object&lt;/a&gt;&lt;/strong&gt;, which offers a complete OOP approach to database interaction, and &lt;strong&gt;&lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt;&lt;/strong&gt;, which is a MySQL specific improvement.</source>
          <target state="translated">데이터베이스 상호 작용에 대한 완벽한 OOP 접근 방식을 제공하는 &lt;strong&gt;&lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO-PHP 데이터베이스 객체 (PDO-PHP Database Object&lt;/a&gt;&lt;/strong&gt; )와 MySQL 별 개선 &lt;strong&gt;&lt;a href=&quot;http://php.net/mysqli&quot;&gt;기능인 MySQLi가&lt;/a&gt;&lt;/strong&gt; 더 강력하고 잘 구축 된 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="52a787558155f6b79392728bd50c95fa82bc40c0" translate="yes" xml:space="preserve">
          <source>There are even more choices! Read about them all in &lt;a href=&quot;http://www.php.net/manual/en/pdostatement.fetch.php&quot;&gt;&lt;code&gt;PDOStatement&lt;/code&gt; Fetch documentation.&lt;/a&gt;.</source>
          <target state="translated">더 많은 선택이 있습니다! &lt;a href=&quot;http://www.php.net/manual/en/pdostatement.fetch.php&quot;&gt; &lt;code&gt;PDOStatement&lt;/code&gt; Fetch 문서&lt;/a&gt; 에서 이에 대해 모두 읽으십시오 . .</target>
        </trans-unit>
        <trans-unit id="0536d09b1c2f82b31a60e587322bf4e9ae190fe2" translate="yes" xml:space="preserve">
          <source>There are many reasons, but perhaps the most important one is that those functions encourage insecure programming practices because they do not support prepared statements. Prepared statements help prevent SQL injection attacks.</source>
          <target state="translated">여러 가지 이유가 있지만 아마도 가장 중요한 이유는 이러한 함수가 준비된 명령문을 지원하지 않기 때문에 안전하지 않은 프로그래밍 방식을 장려한다는 것입니다. 준비된 명령문은 SQL 삽입 공격을 방지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b5b472b07cd013e7228dcd85aa4b24ebd1742ea3" translate="yes" xml:space="preserve">
          <source>There ought to be an &lt;strong&gt;abstraction layer&lt;/strong&gt; between them and application code, which will do all the dirty job of binding, looping, error handling, etc. inside, making application code DRY and clean. Especially for the complex cases like dynamical query building.</source>
          <target state="translated">응용 프로그램 코드와 응용 프로그램 코드 사이에는 &lt;strong&gt;추상화 계층&lt;/strong&gt; 이 있어야합니다.이 &lt;strong&gt;계층&lt;/strong&gt; 은 바인딩, 루핑, 오류 처리 등의 모든 더러운 작업을 수행하여 응용 프로그램 코드를 건조하고 깨끗하게 만듭니다. 특히 동적 쿼리 작성과 같은 복잡한 경우에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5aa178ec91604559d6a4a1f12b3fe446f5816ce4" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;pdo_*&lt;/code&gt; wrapper functions make a coding-friendly stop-gap API. (It's pretty much what &lt;code&gt;MYSQLI&lt;/code&gt; could have been if it wasn't for the idiosyncratic function signature shift). They also expose the real PDO at most times.</source>
          <target state="translated">이러한 &lt;code&gt;pdo_*&lt;/code&gt; 랩퍼 함수는 코딩 친화적 인 중지 간격 API를 만듭니다. ( &lt;code&gt;MYSQLI&lt;/code&gt; 기능 시그니처 시프트가 아닌 경우 MYSQLI가 될 수 있었던 것입니다). 또한 대부분의 경우 실제 PDO를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="66a2a549e1414faaaca0f781d02836464a0a76dc" translate="yes" xml:space="preserve">
          <source>These are replaced by &lt;code&gt;mysqli_connect()&lt;/code&gt;, &lt;code&gt;mysqli_query()&lt;/code&gt; similarly in the latest PHP5.</source>
          <target state="translated">이것들은 최신 PHP5에서 비슷하게 &lt;code&gt;mysqli_connect()&lt;/code&gt; , &lt;code&gt;mysqli_query()&lt;/code&gt; 로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="b9701d5279e360121f1a9236afe73ce6cdab2437" translate="yes" xml:space="preserve">
          <source>This answer is written to show just how trivial it is to bypass poorly written PHP user-validation code, how (and using what) these attacks work and how to replace the old MySQL functions with a secure prepared statement - and basically, why StackOverflow users (probably with a lot of rep) are barking at new users asking questions to improve their code.</source>
          <target state="translated">이 답변은 잘못 작성된 PHP 사용자 유효성 검사 코드를 우회하는 것이 얼마나 간단한 지, 이러한 공격의 작동 방식 및 사용 방법 및 이전 MySQL 기능을 안전한 준비된 문장으로 대체하는 방법 및 기본적으로 StackOverflow 사용자를 보여주기 위해 작성되었습니다. (아마도 많은 담당자와 함께) 새로운 사용자가 코드를 개선하기 위해 질문을하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="acf591526b7653913fa0342793a9a8eed4e6efa1" translate="yes" xml:space="preserve">
          <source>This is a classic SQL injection attack. One of the simplest for that matter. On the scale of attack vectors, this is a toddler attacking a tank - and winning.</source>
          <target state="translated">이것은 고전적인 SQL 주입 공격입니다. 그 문제에 대한 가장 간단한 것 중 하나입니다. 공격 벡터의 규모에서 이것은 탱크를 공격하고 승리하는 유아입니다.</target>
        </trans-unit>
        <trans-unit id="53d154ecdaa8d6b0fba2af9eefdc52d17f07dcb7" translate="yes" xml:space="preserve">
          <source>This is the reason behind the error.</source>
          <target state="translated">이것이 오류의 원인입니다.</target>
        </trans-unit>
        <trans-unit id="6bafa12ee03b3bf471f9002286e0bb60d99c0b9e" translate="yes" xml:space="preserve">
          <source>This is why you are being yelled at when posting questions - it's because people can see that your code can be bypassed wihout even trying. Please, do use this question and answer to improve your code, to make it more secure and to use functions that are current.</source>
          <target state="translated">그렇기 때문에 질문을 게시 할 때 소리를 지르는 이유가 있습니다. 사람들이 시도하는 동안에도 코드를 무시할 수 있기 때문입니다. 이 질문에 답하고 코드를 개선하고보다 안전하게 만들고 최신 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d8ecdcb3fa76fbbc753f992ef32e06a8691ab30" translate="yes" xml:space="preserve">
          <source>This latter issue is a problem.</source>
          <target state="translated">후자의 문제는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="b327464305947f9b5efea8f1e165dfaa4f7af138" translate="yes" xml:space="preserve">
          <source>This means that as of &lt;a href=&quot;https://www.php.net/eol.php&quot;&gt;31 Dec 2018&lt;/a&gt; it does not exist in any supported version of PHP. If you are using a version of PHP which supports it, you are using a version which doesn't get security problems fixed.</source>
          <target state="translated">이는 &lt;a href=&quot;https://www.php.net/eol.php&quot;&gt;2018 년 12 월 31 일 현재&lt;/a&gt; 지원되는 PHP 버전에 존재하지 않음을 의미합니다. 지원하는 PHP 버전을 사용하는 경우 보안 문제가 해결되지 않은 버전을 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5028f4b1c5e464cbdf5fbc73b406c40f8937746" translate="yes" xml:space="preserve">
          <source>This means that the PHP community is gradually dropping support for these very old functions. They are likely to not exist in a future (recent) version of PHP! Continued use of these functions may break your code in the (not so) far future.</source>
          <target state="translated">이는 PHP 커뮤니티가 이러한 매우 오래된 기능에 대한 지원을 점차적으로 중단하고 있음을 의미합니다. 향후 버전의 PHP에는 존재하지 않을 것입니다! 이 함수를 계속 사용하면 코드가 먼 미래에 깨질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9447e1e24f2f798f77e4acb808ca245ef8e28b9" translate="yes" xml:space="preserve">
          <source>This time, we get the following:</source>
          <target state="translated">이번에 우리는 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7b5d0b0f701ec4934ce62c2d94018de81b4de43f" translate="yes" xml:space="preserve">
          <source>Thus also allowed &lt;code&gt;:named&lt;/code&gt; placeholder lists later.</source>
          <target state="translated">따라서 &lt;code&gt;:named&lt;/code&gt; 자리 표시 자 목록도 나중에 허용되었습니다.</target>
        </trans-unit>
        <trans-unit id="1e3281a962e6db2e54e787f796eb7d2b1582389a" translate="yes" xml:space="preserve">
          <source>Transactions</source>
          <target state="translated">Transactions</target>
        </trans-unit>
        <trans-unit id="5ce32adc4f972e95e060d45591a7aa082f17d9f6" translate="yes" xml:space="preserve">
          <source>Unless you also introduce parameter binding or can utilize something else from the nicer API, it's a pointless switch. I hope it's portrayed simple enough to not further the discouragement to newcomers. (Education usually works better than prohibition.)</source>
          <target state="translated">매개 변수 바인딩을 도입하거나 더 멋진 API의 다른 것을 활용할 수 없다면, 그것은 무의미한 스위치입니다. 나는 새로운 이민자들에게 낙담하지 않을 정도로 간단하게 묘사되기를 바랍니다. (교육은 일반적으로 금지보다 잘 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="9f6d94af323287247ddbdf1bbc2b55dbba5ca657" translate="yes" xml:space="preserve">
          <source>Use one of the &lt;a href=&quot;http://php.net/security.magicquotes.disabling&quot;&gt;userland reversal&lt;/a&gt; approaches. Then remove the &lt;code&gt;stripslashes()&lt;/code&gt; in the &lt;code&gt;sanitize&lt;/code&gt; function.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/security.magicquotes.disabling&quot;&gt;유저 랜드 반전&lt;/a&gt; 접근법 중 하나를 사용하십시오. 그런 다음 &lt;code&gt;sanitize&lt;/code&gt; 기능에서 &lt;code&gt;stripslashes()&lt;/code&gt; 를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="d22feee0d218aca696cac86b7e4deb1dabc1af1d" translate="yes" xml:space="preserve">
          <source>User wasn't verified. Awesome.</source>
          <target state="translated">사용자가 확인되지 않았습니다. 대박.</target>
        </trans-unit>
        <trans-unit id="ef7051e396eea2b5e406d5540802dd68853d889b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://fossil.include-once.org/upgradephp/artifact/43ab742241e5a3be43d31764dd333ba68e245360&quot;&gt;&amp;lt;&lt;strong&gt;pdo_mysql.php&lt;/strong&gt;&amp;gt;&lt;/a&gt; you can switch from the old mysql_ functions with &lt;em&gt;minimal effort&lt;/em&gt;. It adds &lt;code&gt;pdo_&lt;/code&gt; function wrappers which replace their &lt;code&gt;mysql_&lt;/code&gt; counterparts.</source>
          <target state="translated">&lt;a href=&quot;http://fossil.include-once.org/upgradephp/artifact/43ab742241e5a3be43d31764dd333ba68e245360&quot;&gt;&amp;lt; &lt;strong&gt;pdo_mysql.php&lt;/strong&gt; &amp;gt;&lt;/a&gt; 를 사용하면 &lt;em&gt;최소한의 노력으로&lt;/em&gt; 기존 mysql_ 함수에서 전환 할 수 있습니다. &lt;code&gt;mysql_&lt;/code&gt; 대응 부분을 대체하는 &lt;code&gt;pdo_&lt;/code&gt; 함수 래퍼를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a3546de296990f00559369725f6b73e5773d07ec" translate="yes" xml:space="preserve">
          <source>Using prepared statements in &lt;code&gt;PDO&lt;/code&gt; or &lt;code&gt;mysqli&lt;/code&gt; will make it so that these sorts of programming errors are more difficult to make.</source>
          <target state="translated">&lt;code&gt;PDO&lt;/code&gt; 또는 &lt;code&gt;mysqli&lt;/code&gt; 에서 준비된 명령문을 사용하면 이러한 종류의 프로그래밍 오류를 만들기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="486fedcd9d1e44ea49d7fea32a811becae9a5ea2" translate="yes" xml:space="preserve">
          <source>Warning: mysql_connect(): No such file or directory</source>
          <target state="translated">경고 : mysql_connect () : 그런 파일이나 디렉토리가 없습니다</target>
        </trans-unit>
        <trans-unit id="4c5244a83456f7a8a64e8871234ed5b7ddc13050" translate="yes" xml:space="preserve">
          <source>We can use MySQL functions by creating a wrapper function for each below is running code. &lt;a href=&quot;https://www.talkforweb.com.au/php/how-to-use-mysql-in-php-7-version&quot;&gt;Click here&lt;/a&gt;</source>
          <target state="translated">아래에서 실행중인 코드마다 래퍼 함수를 ​​만들어 MySQL 함수를 사용할 수 있습니다. &lt;a href=&quot;https://www.talkforweb.com.au/php/how-to-use-mysql-in-php-7-version&quot;&gt;여기를 클릭하십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75b20bd2200600dac46620c83364968245f98595" translate="yes" xml:space="preserve">
          <source>Well, not really. Lets say the user is a clever little person. Lets say the person is me.</source>
          <target state="translated">글쎄,별로. 사용자가 영리한 작은 사람이라고 가정 해 봅시다. 그 사람이 나라고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7899429896ac711595aff78d7cfe787d90c838cd" translate="yes" xml:space="preserve">
          <source>Well, the answer would be as follows:</source>
          <target state="translated">대답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0fbfa99fed4d886de39ca6ae2e0a7d91af92c318" translate="yes" xml:space="preserve">
          <source>What are the technical reasons for why one shouldn't use &lt;code&gt;mysql_*&lt;/code&gt; functions? (e.g. &lt;code&gt;mysql_query()&lt;/code&gt;, &lt;code&gt;mysql_connect()&lt;/code&gt; or &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;)?</source>
          <target state="translated">&lt;code&gt;mysql_*&lt;/code&gt; 함수를 사용하지 않아야하는 기술적 이유는 무엇입니까? (예 : &lt;code&gt;mysql_query()&lt;/code&gt; , &lt;code&gt;mysql_connect()&lt;/code&gt; 또는 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; )?</target>
        </trans-unit>
        <trans-unit id="cd38c24be39c82544339ccc932bdc9bf31585932" translate="yes" xml:space="preserve">
          <source>What we are doing in &lt;code&gt;mysql_*&lt;/code&gt; function is:</source>
          <target state="translated">우리가 &lt;code&gt;mysql_*&lt;/code&gt; 함수에서하고있는 것은 :</target>
        </trans-unit>
        <trans-unit id="b21a3658c12dc7f9942d92330d6ba7faf54fd2f5" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;mysql_*&lt;/code&gt; functions, you have to remember to run user-supplied parameters through &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;. If you forget in just one place or if you happen to escape only part of the input, your database may be subject to attack.</source>
          <target state="translated">&lt;code&gt;mysql_*&lt;/code&gt; 함수를 사용할 때는 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 통해 사용자 제공 매개 변수를 실행해야합니다. 한곳에서 잊어 버렸거나 입력의 일부만 탈출하면 데이터베이스가 공격받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2931a1a4cd0a0347c48feeaca13f011b624aed4e" translate="yes" xml:space="preserve">
          <source>When you go on any &lt;code&gt;mysql_*&lt;/code&gt; function manual page, you see a red box, explaining it should not be used anymore.</source>
          <target state="translated">&lt;code&gt;mysql_*&lt;/code&gt; 함수 매뉴얼 페이지로 이동하면 더 이상 사용해서는 안되는 빨간색 상자가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cf411fb39b805de367075ecc7671c209fb94fd0c" translate="yes" xml:space="preserve">
          <source>When you go to any &lt;code&gt;mysql&lt;/code&gt; function manual page, you see a red box, explaining it should not be used anymore.</source>
          <target state="translated">&lt;code&gt;mysql&lt;/code&gt; 함수 매뉴얼 페이지로 가면 더 이상 사용해서는 안되는 빨간색 상자가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="de52d720c2b9fc0148a79e4ac0bf6e334c6922de" translate="yes" xml:space="preserve">
          <source>When you scramble string variables into the SQL queries, it doesn't just get more intricate for you to follow. It's also extraneous effort for MySQL to segregate code and data again.</source>
          <target state="translated">문자열 변수를 SQL 쿼리로 스크램블하면 따라하기가 더 복잡해지지 않습니다. 또한 MySQL이 코드와 데이터를 다시 분리하기 위해 많은 노력을 기울이고 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e4f5d49c704cc6527ca62c9c0c5f10e94a3848" translate="yes" xml:space="preserve">
          <source>While code is being converted to &lt;code&gt;MySQLi&lt;/code&gt;/&lt;code&gt;PDO&lt;/code&gt;, &lt;code&gt;E_DEPRECATED&lt;/code&gt; errors can be suppressed by setting &lt;code&gt;error_reporting&lt;/code&gt; in &lt;strong&gt;php.ini&lt;/strong&gt; to exclude &lt;code&gt;E_DEPRECATED:&lt;/code&gt;</source>
          <target state="translated">코드가 &lt;code&gt;MySQLi&lt;/code&gt; / &lt;code&gt;PDO&lt;/code&gt; 로 변환되는 동안 &lt;code&gt;E_DEPRECATED&lt;/code&gt; 를 제외하도록 &lt;strong&gt;php.ini&lt;/strong&gt; 에서 &lt;code&gt;error_reporting&lt;/code&gt; 을 설정하여 E_DEPRECATED 오류를 억제 할 수 있습니다 &lt;code&gt;E_DEPRECATED:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e96fbd5b6300a2987f662d74b0a387a6eaee6777" translate="yes" xml:space="preserve">
          <source>While it qualifies for the simplest-thing-that-could-possibly-work category, it's also still very experimental code. I just wrote it over the weekend. There's a plethora of alternatives however. Just google for &lt;a href=&quot;https://www.google.de/search?client=stackoverflow&amp;amp;q=PHP+database+abstraction&quot;&gt;PHP database abstraction&lt;/a&gt; and browse a little. There always have been and will be lots of excellent libraries for such tasks.</source>
          <target state="translated">가장 간단한 것, 아마도 가능한 작업 범주에 적합하지만 여전히 매우 실험적인 코드입니다. 나는 방금 주말에 그것을 썼다. 그러나 수많은 대안이 있습니다. &lt;a href=&quot;https://www.google.de/search?client=stackoverflow&amp;amp;q=PHP+database+abstraction&quot;&gt;PHP 데이터베이스 추상화를&lt;/a&gt; 위해 Google을 검색하고 조금 탐색하십시오. 그러한 작업을위한 훌륭한 라이브러리는 항상 존재하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3db062dc13c427b5833ae038cf2841371c4940cd" translate="yes" xml:space="preserve">
          <source>While this answer stresses that you should care about the readability advantages of dropping &lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;. There's occasionally also a performance advantage (repeated INSERTs with just differing values) due to this visible and technical data/code separation.</source>
          <target state="translated">이 답변은 &lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; 삭제의 가독성 이점에주의를 기울여야한다고 강조합니다. 이 가시적이고 기술적 인 데이터 / 코드 분리로 인해 때때로 성능상의 이점 (값이 다른 INSERT 반복)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="21e2caea4476d26af34541ca7c909c7ff2fa4a7f" translate="yes" xml:space="preserve">
          <source>Why</source>
          <target state="translated">Why</target>
        </trans-unit>
        <trans-unit id="3ef9f79b5eb449f72b3fdf90c2c98ca4727dbf72" translate="yes" xml:space="preserve">
          <source>Why should I use something else even if they work on my site?</source>
          <target state="translated">사이트에서 작업하는 경우에도 다른 것을 사용해야하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bef272d0089010f98f10750eee469e97be3484f5" translate="yes" xml:space="preserve">
          <source>Why shouldn't I use mysql_* functions in PHP</source>
          <target state="translated">PHP에서 mysql_ * 함수를 사용하지 않아야하는 이유</target>
        </trans-unit>
        <trans-unit id="4ba7de6b07d2790dbe183ff8860e4b3a376efb27" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;?&lt;/code&gt; placeholders applied you don't have to bother with that:</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 자리 표시자를 적용하면 다음과 같이 신경 쓸 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b521949ba1a0d81fe7f7a22ca009f139258af49" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;PDO&lt;/code&gt;: All you need to do is create a new &lt;code&gt;PDO&lt;/code&gt; object. The constructor accepts parameters for specifying the database source &lt;code&gt;PDO&lt;/code&gt;'s constructor mostly takes four parameters which are &lt;code&gt;DSN&lt;/code&gt; (data source name) and  optionally &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PDO&lt;/code&gt; 사용 : 새 &lt;code&gt;PDO&lt;/code&gt; 오브젝트를 작성하기 만하면 됩니다. 생성자는 데이터베이스 소스를 지정하기위한 매개 변수를 승인합니다. &lt;code&gt;PDO&lt;/code&gt; 의 생성자는 대부분 &lt;code&gt;DSN&lt;/code&gt; (데이터 소스 이름) 및 선택적으로 &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;password&lt;/code&gt; 의 네 가지 매개 변수를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="e432386262217c200274bffa28234079d822668e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;mysql_*&lt;/code&gt; function or we can say it the old way (deprecated in PHP 5.5 and above)</source>
          <target state="translated">&lt;code&gt;mysql_*&lt;/code&gt; 함수를 사용하거나 이전 방식으로 말할 수 있습니다 (PHP 5.5 이상에서는 더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="aa425a4526ed951fbc2faa2bf53cf3ac2eedcb7b" translate="yes" xml:space="preserve">
          <source>With bound parameters you separate SQL code and SQL-context values in your PHP code. But it doesn't get shuffled up again behind the scenes (except with PDO::EMULATE_PREPARES). Your database receives the unvaried SQL commands and 1:1 variable values.</source>
          <target state="translated">바인딩 된 매개 변수를 사용하면 PHP 코드에서 SQL 코드와 SQL 컨텍스트 값을 구분합니다. 그러나 PDO :: EMULATE_PREPARES를 제외하고는 뒤에서 뒤섞이지 않습니다. 데이터베이스는 가변 SQL 명령과 1 : 1 변수 값을받습니다.</target>
        </trans-unit>
        <trans-unit id="e7b9c34542bc7220d2b9d0c79dbfc014575aed6b" translate="yes" xml:space="preserve">
          <source>With that done, we can move to our PHP code.</source>
          <target state="translated">이것으로 PHP 코드로 옮길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd1fd1c6043beb37d33d7ef7c193233e05a2152e" translate="yes" xml:space="preserve">
          <source>You can also bind using an execute array as well:</source>
          <target state="translated">실행 배열을 사용하여 바인딩 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="39834359a3e108415bb98b0c8863a7cd433c0634" translate="yes" xml:space="preserve">
          <source>You can also pass in several driver options as an array to the fourth parameter. I recommend passing the parameter which puts &lt;code&gt;PDO&lt;/code&gt; into exception mode. Because some &lt;code&gt;PDO&lt;/code&gt; drivers don't support native prepared statements, so &lt;code&gt;PDO&lt;/code&gt; performs emulation of the prepare. It also lets you manually enable this emulation. To use the native server-side prepared statements, you should explicitly set it &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">여러 드라이버 옵션을 배열로 네 번째 매개 변수에 전달할 수도 있습니다. &lt;code&gt;PDO&lt;/code&gt; 를 예외 모드로 만드는 매개 변수를 전달하는 것이 좋습니다. 일부 &lt;code&gt;PDO&lt;/code&gt; 드라이버는 기본 준비된 명령문을 지원하지 않으므로 &lt;code&gt;PDO&lt;/code&gt; 는 준비 에뮬레이션을 수행합니다. 또한이 에뮬레이션을 수동으로 활성화 할 수 있습니다. 기본 서버 측 준비 명령문을 사용하려면 명시 적으로 &lt;code&gt;false&lt;/code&gt; 로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0106d16cdb27ff2ec30c1b900ece093440a823c3" translate="yes" xml:space="preserve">
          <source>You can hardly find an example for PDO to handle such practical case.</source>
          <target state="translated">PDO가 이러한 실제 사례를 처리 할 수있는 예는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="193b814af13365eaaf93b92758d562e11bdc9a6e" translate="yes" xml:space="preserve">
          <source>You can use a prepared statement by including placeholders in your SQL. There are basically three ones without placeholders (don't try this with variable its above one), one with unnamed placeholders, and one with named placeholders.</source>
          <target state="translated">SQL에 자리 표시자를 포함시켜 준비된 명령문을 사용할 수 있습니다. 기본적으로 자리 표시자가없는 세 가지 (위의 변수를 사용하여 시도하지 마십시오), 명명되지 않은 자리 표시 자 및 명명 된 자리 표시자가있는 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f8aaea6ff6d99acc02af021cf0de60526c70b07" translate="yes" xml:space="preserve">
          <source>You do not have to handle with &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; right now. You can catch it at any time appropriate, but I strongly recommend you to use &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt;. Also it may make more sense to catch it at outside the function that calls the &lt;code&gt;PDO&lt;/code&gt; stuff:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; - &lt;code&gt;catch&lt;/code&gt; 로 처리 할 필요가 없습니다. 언제든지 적절한 시간에 잡을 수 있지만 &lt;code&gt;try&lt;/code&gt; - &lt;code&gt;catch&lt;/code&gt; 를 사용하는 것이 좋습니다. 또한 &lt;code&gt;PDO&lt;/code&gt; 를 호출하는 함수 외부에서 그것을 잡는 것이 더 합리적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6ec43a805132e214cc4951849805b992f1dca6d" translate="yes" xml:space="preserve">
          <source>You just need a less unwieldy API.</source>
          <target state="translated">덜 다루기 어려운 API 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="83c916251fa57138befaf512e453b91c66f1222f" translate="yes" xml:space="preserve">
          <source>You may have to keep the rest of your &lt;code&gt;sanitize()&lt;/code&gt; function for now if your database and application flow expect HTML-context-safe strings. Add a comment that it applies only HTML escaping henceforth.</source>
          <target state="translated">데이터베이스 및 애플리케이션 플로우에 HTML 컨텍스트 안전 문자열이 필요한 경우 나머지 &lt;code&gt;sanitize()&lt;/code&gt; 함수를 유지해야 할 수도 있습니다. HTML 이스케이프 처리에만 적용된다는 의견을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="109ef7c7ad471c0fd553af6c791c965eb0053415" translate="yes" xml:space="preserve">
          <source>You'll get more helpful warnings in most cases than PDO or mysql_ usually provide after failed queries.</source>
          <target state="translated">대부분의 경우 PDO 또는 mysql_이 일반적으로 실패한 쿼리 후 제공하는 것보다 더 유용한 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="00c17ebf04ff3d123b5bf045615793029cdab7eb" translate="yes" xml:space="preserve">
          <source>Your code is &lt;em&gt;using&lt;/em&gt; PDO.</source>
          <target state="translated">귀하의 코드는 PDO를 &lt;em&gt;사용하고&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="114e82ddc86b988c9f233dd5f847ff571f7ead99" translate="yes" xml:space="preserve">
          <source>Your code will work alike and still mostly look the same:</source>
          <target state="translated">코드는 동일하게 작동하며 여전히 대부분 동일하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="09e7d790f3ab05e4f56ffe51297bfcdde73f15bf" translate="yes" xml:space="preserve">
          <source>and submit it.</source>
          <target state="translated">제출하십시오.</target>
        </trans-unit>
        <trans-unit id="12328e72903e2254dcef3aa99b38ab6b1480db8b" translate="yes" xml:space="preserve">
          <source>are out of date - they're not maintained any more</source>
          <target state="translated">오래되었습니다-더 이상 유지되지 않습니다</target>
        </trans-unit>
        <trans-unit id="ed3059ee362c75dcd7469e8cfbf286738600b576" translate="yes" xml:space="preserve">
          <source>being an average PHP user, most likely your idea of using these functions is error-prone and wrong. Just because of all these numerous tutorials and manuals which teach you the wrong way. Not the functions themselves - I have to emphasize it - but the way they are used.</source>
          <target state="translated">일반적인 PHP 사용자라면 이러한 함수를 사용하려는 생각은 오류가 발생하기 쉽습니다. 당신에게 잘못된 길을 가르치는 수많은 튜토리얼과 매뉴얼 때문에 말입니다. 기능 자체가 아니라 강조해야합니다. 그러나 사용 방식.</target>
        </trans-unit>
        <trans-unit id="7a880ef5359c5138ea32e24d56e7ada875ea4f77" translate="yes" xml:space="preserve">
          <source>don't allow you to move easily to another database backend</source>
          <target state="translated">다른 데이터베이스 백엔드로 쉽게 이동할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="830033092d1fd68deec56e78e5679b5bb240badd" translate="yes" xml:space="preserve">
          <source>don't support prepared statements, hence</source>
          <target state="translated">준비된 진술을 지원하지 않으므로</target>
        </trans-unit>
        <trans-unit id="2935b5bb29398649ebd070be72ec96b9e5d1dcad" translate="yes" xml:space="preserve">
          <source>encourage programmers to use concatenation to build queries, leading to SQL injection vulnerabilities</source>
          <target state="translated">프로그래머가 연결을 사용하여 쿼리를 작성하도록 장려하여 SQL 주입 취약점으로 연결</target>
        </trans-unit>
        <trans-unit id="acc54e219ffe07f00fcf43d7c700c28aea05aca4" translate="yes" xml:space="preserve">
          <source>further use of these functions with modern PHP versions will raise deprecated-level notices. They simply can be turned off.</source>
          <target state="translated">최신 PHP 버전에서 이러한 기능을 추가로 사용하면 더 이상 사용되지 않는 수준의 알림이 발생합니다. 그들은 단순히 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d815f35640c25abe234d7b810ff746628e851f0e" translate="yes" xml:space="preserve">
          <source>in a distant future, they can be possibly removed from the default PHP build. Not a big deal too, as mydsql ext will be moved into PECL and every hoster will be happy to compile PHP with it, as they don't want to lose clients whose sites were working for decades.</source>
          <target state="translated">먼 미래에는 기본 PHP 빌드에서 제거 될 수 있습니다. mydsql ext가 PECL로 이동하고 모든 호스팅 업체는 수십 년 동안 사이트를 운영하는 클라이언트를 잃고 싶지 않기 때문에 PHP를 컴파일하는 것을 기뻐할 것이므로 큰 문제는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7f76e98f72dce710ff68c2850ea89b8fb65a8322" translate="yes" xml:space="preserve">
          <source>non-blocking, asynchronous queries</source>
          <target state="translated">비 차단 비동기 쿼리</target>
        </trans-unit>
        <trans-unit id="de7c9165c22b2bbc30bc3ecad1c9e6bf4b9c7c6f" translate="yes" xml:space="preserve">
          <source>stored procedures returning multiple resultsets</source>
          <target state="translated">여러 결과 집합을 반환하는 저장 프로 시저</target>
        </trans-unit>
        <trans-unit id="95b2ac54f95972248a7b13860ea1d8810f52eeb0" translate="yes" xml:space="preserve">
          <source>strong resistance from Stackoverflow community. Еverytime you mention these honest functions, you being told that they are under strict taboo.</source>
          <target state="translated">Stackoverflow 커뮤니티의 강력한 저항. 당신이 정직한 기능을 언급 할 때마다, 당신은 그것들이 엄격한 금기 상태에 있다고 들었습니다.</target>
        </trans-unit>
        <trans-unit id="4ca2ac0512b37905e3e07228b035c03f882fec79" translate="yes" xml:space="preserve">
          <source>the list goes on ...</source>
          <target state="translated">목록은 계속됩니다 ...</target>
        </trans-unit>
        <trans-unit id="2eb74edb23d3b49834fb5098164392d5ce9f9a09" translate="yes" xml:space="preserve">
          <source>unlike mysqli, PDO can always return query result in a simple usual array, while mysqli can do it only on mysqlnd installations.</source>
          <target state="translated">mysqli와 달리 PDO는 항상 간단한 일반 배열로 쿼리 결과를 반환 할 수 있지만 mysqli는 mysqlnd 설치에서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa4f5271f5951ab6344d7de045285abcfe2bf002" translate="yes" xml:space="preserve">
          <source>unlike mysqli, PDO can bind placeholders &lt;em&gt;by value&lt;/em&gt;, which makes dynamically built queries feasible without several screens of quite messy code.</source>
          <target state="translated">mysqli와 달리 PDO는 &lt;em&gt;값으로&lt;/em&gt; 자리 표시자를 바인딩 할 수 있으므로 매우 복잡한 코드의 여러 화면없이 동적으로 작성된 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
