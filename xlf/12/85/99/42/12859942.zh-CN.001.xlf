<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/12859942">
    <body>
      <group id="12859942">
        <trans-unit id="6cda3a126b38102fb9da9475533aaf3305f7fc81" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;Stored procedures&lt;/a&gt; (can't handle multiple result sets)</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Stored_procedure&quot;&gt;存储过程&lt;/a&gt; （无法处理多个结果集）</target>
        </trans-unit>
        <trans-unit id="b3ded5903fe8ef5cae508b2ae92f896e2213e013" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt; is the 'improved' extension for working with MySQL databases. It takes advantage of features that are available in newer versions of the MySQL server, exposes both a function-oriented and an object-oriented interface to the developer and a does few other nifty things.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;MySQLi&lt;/a&gt;是使用MySQL数据库的&amp;ldquo;改进&amp;rdquo;扩展。 它利用了更新版本的MySQL服务器中可用的功能，向开发人员公开了面向函数和面向对象的接口，并且还做了其他一些漂亮的事情。</target>
        </trans-unit>
        <trans-unit id="d17381afa285d004079efeb7bdb099fd00671abd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt; offers an API that consolidates most of the functionality that was previously spread across the major database access extensions, i.e. MySQL, PostgreSQL, SQLite, MSSQL, etc. The interface exposes high-level objects for the programmer to work with database connections, queries and result sets, and low-level drivers perform communication and resource handling with the database server. A lot of discussion and work is going into PDO and it&amp;rsquo;s considered the appropriate method of working with databases in modern, professional code.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt;提供了一个API，该API整合了以前分散在主要数据库访问扩展中的大多数功能，即MySQL，PostgreSQL，SQLite，MSSQL等。该接口公开了高级对象，供程序员使用数据库连接，查询和结果集和低级驱动程序执行与数据库服务器的通信和资源处理。 PDO进行了大量讨论和工作，它被认为是使用现代专业代码处理数据库的适当方法。</target>
        </trans-unit>
        <trans-unit id="046ffaee85489e61d2263f509946570f847cc8ea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchall.php&quot;&gt;&lt;code&gt;PDOStatement::fetchAll()&lt;/code&gt;&lt;/a&gt; - Returns an array containing all of the result set rows</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchall.php&quot;&gt; &lt;code&gt;PDOStatement::fetchAll()&lt;/code&gt; &lt;/a&gt; -返回包含所有结果集行的数组</target>
        </trans-unit>
        <trans-unit id="b28a28e308fceeb11923ec4f6b51a94fdc522831" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchcolumn.php&quot;&gt;&lt;code&gt;PDOStatement::fetchColumn()&lt;/code&gt;&lt;/a&gt; - Returns a single column from the next row of a result set</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchcolumn.php&quot;&gt; &lt;code&gt;PDOStatement::fetchColumn()&lt;/code&gt; &lt;/a&gt; -从结果集的下一行返回单个列</target>
        </trans-unit>
        <trans-unit id="f38ca8ad882074ee896d85b8ff9c3b2f2d31a650" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchobject.php&quot;&gt;&lt;code&gt;PDOStatement::fetchObject()&lt;/code&gt;&lt;/a&gt; - Fetches the next row and returns it as an object.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/pdostatement.fetchobject.php&quot;&gt; &lt;code&gt;PDOStatement::fetchObject()&lt;/code&gt; &lt;/a&gt; - 提取下一行并将其作为对象返回。</target>
        </trans-unit>
        <trans-unit id="6f018387924cb8a35b2d0d50bcf690d933b109aa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/pdostatement.setfetchmode.php&quot;&gt;&lt;code&gt;PDOStatement::setFetchMode()&lt;/code&gt;&lt;/a&gt; - Set the default fetch mode for this statement</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/pdostatement.setfetchmode.php&quot;&gt; &lt;code&gt;PDOStatement::setFetchMode()&lt;/code&gt; &lt;/a&gt; -设置此语句的默认获取模式</target>
        </trans-unit>
        <trans-unit id="0fa08d46c3da4c6dbad08eae37dd7aabd954a814" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/q/12859942&quot;&gt;&lt;strong&gt;Please, don't use &lt;code&gt;mysql_*&lt;/code&gt; functions in new code&lt;/strong&gt;&lt;/a&gt;. They are no longer maintained &lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;and are officially deprecated&lt;/a&gt;. See the &lt;a href=&quot;http://uk.php.net/manual/en/function.mysql-connect.php&quot;&gt;&lt;strong&gt;red box&lt;/strong&gt;&lt;/a&gt;? Learn about &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;em&gt;prepared statements&lt;/em&gt;&lt;/a&gt; instead, and use &lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO&lt;/a&gt; or &lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt; - &lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;this article&lt;/a&gt; will help you decide which. If you choose PDO, &lt;a href=&quot;http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers&quot;&gt;here is a good tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/12859942&quot;&gt;&lt;strong&gt;请不要在新代码中使用 &lt;code&gt;mysql_*&lt;/code&gt; 函数&lt;/strong&gt;&lt;/a&gt; 。 它们不再维护&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;，已正式弃用&lt;/a&gt; 。 看到&lt;a href=&quot;http://uk.php.net/manual/en/function.mysql-connect.php&quot;&gt;&lt;strong&gt;红框了&lt;/strong&gt;&lt;/a&gt;吗？ 相反，要了解&lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;em&gt;准备好的语句&lt;/em&gt;&lt;/a&gt; ，并使用&lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO&lt;/a&gt;或&lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi-&lt;/a&gt; &lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;本文&lt;/a&gt;将帮助您确定哪一个。 如果您选择PDO， &lt;a href=&quot;http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers&quot;&gt;这是一个很好的教程&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6ffdb59a47d534bf1c4ce50a2ab19c2c804aac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OR die()&lt;/code&gt; is not a good way to handle the error since we can not handle the thing in &lt;code&gt;die&lt;/code&gt;. It will just end the script abruptly and then echo the error to the screen which you usually do NOT want to show to your end users, and let bloody hackers discover your schema. Alternately, the return values of &lt;code&gt;mysql_*&lt;/code&gt; functions can often be used in conjunction with &lt;a href=&quot;http://php.net/mysql_error&quot;&gt;mysql_error()&lt;/a&gt; to handle errors.</source>
          <target state="translated">因为我们无法处理 &lt;code&gt;OR die()&lt;/code&gt; 不是处理错误的好方法。 它只会突然结束脚本，然后将错误回显到您通常不希望显示给最终用户的屏幕上，并让流血的黑客发现您的架构。 另外， &lt;code&gt;mysql_*&lt;/code&gt; 函数的返回值通常可以与&lt;a href=&quot;http://php.net/mysql_error&quot;&gt;mysql_error（）&lt;/a&gt;结合使用以处理错误。</target>
        </trans-unit>
        <trans-unit id="f8d90257eb4cba009d9da07c259d01492dd67cb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO::ERRMODE_EXCEPTION&lt;/code&gt;: Throw exceptions. It represents an error raised by PDO. You should not throw a &lt;code&gt;PDOException&lt;/code&gt; from your own code. See &lt;em&gt;Exceptions&lt;/em&gt; for more information about exceptions in PHP. It acts very much like &lt;code&gt;or die(mysql_error());&lt;/code&gt;, when it isn't caught. But unlike &lt;code&gt;or die()&lt;/code&gt;, the &lt;code&gt;PDOException&lt;/code&gt; can be caught and handled gracefully if you choose to do so.</source>
          <target state="translated">&lt;code&gt;PDO::ERRMODE_EXCEPTION&lt;/code&gt; ：引发异常。 它表示PDO引发的错误。 您不应从自己的代码中引发 &lt;code&gt;PDOException&lt;/code&gt; 。 有关PHP中的&lt;em&gt;异常&lt;/em&gt;的更多信息，请参见&lt;em&gt;异常&lt;/em&gt; 。 它的行为非常像 &lt;code&gt;or die(mysql_error());&lt;/code&gt; ，当它未被捕获时。 但是，与 &lt;code&gt;or die()&lt;/code&gt; 不同 ，如果选择这样做，则可以优雅地捕获和处理 &lt;code&gt;PDOException&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5515c76631bc1066c78ab2cd9cdef4e2a606b1d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO::ERRMODE_SILENT&lt;/code&gt;. It's just setting error codes and acts pretty much the same as &lt;code&gt;mysql_*&lt;/code&gt; where you must check each result and then look at &lt;code&gt;$db-&amp;gt;errorInfo();&lt;/code&gt; to get the error details.</source>
          <target state="translated">&lt;code&gt;PDO::ERRMODE_SILENT&lt;/code&gt; 。 它只是设置错误代码，其行为与 &lt;code&gt;mysql_*&lt;/code&gt; 几乎相同，在mysql_ *中 ，您必须检查每个结果，然后查看 &lt;code&gt;$db-&amp;gt;errorInfo();&lt;/code&gt; 获取错误详细信息。</target>
        </trans-unit>
        <trans-unit id="e7c4b1bce0513c7fb8025092a93478da761f79aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO::ERRMODE_WARNING&lt;/code&gt; Raise &lt;code&gt;E_WARNING&lt;/code&gt;. (Run-time warnings (non-fatal errors). Execution of the script is not halted.)</source>
          <target state="translated">&lt;code&gt;PDO::ERRMODE_WARNING&lt;/code&gt; 提高 &lt;code&gt;E_WARNING&lt;/code&gt; 。 （运行时警告（非致命错误）。不会停止执行脚本。）</target>
        </trans-unit>
        <trans-unit id="e02705f324751cbe9f1129e09c39ee8bf3c6790e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO::FETCH_ASSOC&lt;/code&gt;: returns an array indexed by column name as returned in your result set</source>
          <target state="translated">&lt;code&gt;PDO::FETCH_ASSOC&lt;/code&gt; ：返回一个在结果集中返回的按列名索引的数组</target>
        </trans-unit>
        <trans-unit id="c53f912043ed13d79a8752a65b60437033b9a967" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO::FETCH_BOTH&lt;/code&gt; (default): returns an array indexed by both column name and 0-indexed column number as returned in your result set</source>
          <target state="translated">&lt;code&gt;PDO::FETCH_BOTH&lt;/code&gt; （默认值）：返回一个在结果集中返回的同时由列名和0索引列号索引的数组</target>
        </trans-unit>
        <trans-unit id="64c39564f8d39a4c2fdc909d2132ee966fa92c95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PDO&lt;/code&gt; offers a better solution: exceptions. Anything we do with &lt;code&gt;PDO&lt;/code&gt; should be wrapped in a &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; block. We can force &lt;code&gt;PDO&lt;/code&gt; into one of three error modes by setting the error mode attribute. Three error handling modes are below.</source>
          <target state="translated">&lt;code&gt;PDO&lt;/code&gt; 提供了更好的解决方案：异常。 我们对 &lt;code&gt;PDO&lt;/code&gt; 所做的任何事情都应包含在 &lt;code&gt;try&lt;/code&gt; - &lt;code&gt;catch&lt;/code&gt; 块中。 通过设置错误模式属性，我们可以强制 &lt;code&gt;PDO&lt;/code&gt; 进入三种错误模式之一。 下面是三种错误处理模式。</target>
        </trans-unit>
        <trans-unit id="b690a13d160e3bb95e6e3e9ad4972ca25987a5b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; prepared queries</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; ， &lt;code&gt;DELETE&lt;/code&gt; 预备查询</target>
        </trans-unit>
        <trans-unit id="8bf705f99d5823b73420e7e85ef046dfddb3f6d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ext/mysql&lt;/code&gt; was built for &lt;strong&gt;MySQL 3.23&lt;/strong&gt; and only got very few additions since then while mostly keeping compatibility with this old version which makes the code a bit harder to maintain. Missing features that is not supported by &lt;code&gt;ext/mysql&lt;/code&gt; include: (&lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;from PHP manual&lt;/a&gt;&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;ext/mysql&lt;/code&gt; 是为&lt;strong&gt;MySQL 3.23&lt;/strong&gt;构建的，此后仅增加了很少的内容，同时主要保持了与该旧版本的兼容性，这使得代码难以维护。 &lt;code&gt;ext/mysql&lt;/code&gt; 不支持的缺少的功能包括：（ &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;来自PHP手册&lt;/a&gt;&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="616d50367e59cecd8e39af146c7cc40afc851bf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mysql_*&lt;/code&gt; extension does not support &lt;strong&gt;prepared statements&lt;/strong&gt;, which is (among other things) a very effective countermeasure against &lt;strong&gt;SQL Injection&lt;/strong&gt;. It fixed a very serious vulnerability in MySQL dependent applications which allows attackers to gain access to your script and perform &lt;strong&gt;any possible query&lt;/strong&gt; on your database.</source>
          <target state="translated">&lt;code&gt;mysql_*&lt;/code&gt; 扩展名不支持&lt;strong&gt;预处理语句&lt;/strong&gt; ，这是（除其他事项之外）针对&lt;strong&gt;SQL Injection&lt;/strong&gt;的非常有效的对策。 它修复了依赖MySQL的应用程序中的一个非常严重的漏洞，该漏洞使攻击者可以访问您的脚本并在数据库上执行&lt;strong&gt;任何可能的查询&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="04f4afe04132a28eaf0cf86a418f420d470d506d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pdo_query()&lt;/code&gt; adds very facile support for bound parameters. Converting old code is straightforward:</source>
          <target state="translated">&lt;code&gt;pdo_query()&lt;/code&gt; 为绑定参数添加了非常方便的支持。 转换旧代码很简单：</target>
        </trans-unit>
        <trans-unit id="75528272c8ccd5010c8d8ca46c4a8dfbf9778675" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;and so on...&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;等等...&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5237e9f27ed52517cac1144483a5b7980060c686" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;voila&lt;/em&gt;, everything is parameterized and safe.</source>
          <target state="translated">&lt;em&gt;瞧&lt;/em&gt; ，一切&lt;em&gt;都已&lt;/em&gt;参数化且安全。</target>
        </trans-unit>
        <trans-unit id="3fcb0c24213528d4e6d53492a70d7a8291036328" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;connect()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;connect()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;connect()&lt;/code&gt; 成为&lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;connect()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b3d112ed884c4390787d133672862205824e4fd" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;fetch_array()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;fetch_array()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;fetch_array()&lt;/code&gt; 变为&lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;fetch_array()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a21fb7cc60ddb95c041c9f9ded1d45b2a7edf190" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;fetch_assoc()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;fetch_assoc()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;fetch_assoc()&lt;/code&gt; 变为&lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;fetch_assoc()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ef13a65638ca5d535b808e90281c25f89511e748" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;insert_id()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;insert_id()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;insert_id()&lt;/code&gt; 成为&lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;insert_id()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc407c0ffce461b779a38bb1fc0dc99251428726" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;num_rows()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;num_rows()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;num_rows()&lt;/code&gt; 变为&lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;num_rows()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f9a2ad43ca1e733f76816229b4aa318182e265e" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;query()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;query()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;query()&lt;/code&gt; 成为&lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;query()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de66ab6b7bdbd02e289701939878dd5dd7d2fb27" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;&lt;code&gt;real_escape_string()&lt;/code&gt; becomes &lt;b&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/b&gt;&lt;code&gt;real_escape_string()&lt;/code&gt;</source>
          <target state="translated">&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt; &lt;code&gt;real_escape_string()&lt;/code&gt; 变为&lt;b&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/b&gt; &lt;code&gt;real_escape_string()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f0b58668ae25ccfe5bdc1cbae5c9ee2cddd631f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;Prepared statements&lt;/a&gt; or parameterized queries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://php.net/manual/en/mysqli.quickstart.prepared-statements.php&quot;&gt;预备语句&lt;/a&gt;或参数化查询&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="375f987ed1362ce8666be1d597bccb89f0a4b4e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="e1373de0a72aae36b8557c0139b699198b6a40ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="ae0641e9808706462aeeee3ff5fada2631f3e370" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="7d55ef0f6c839d55762a2f54ead50913fcbd88be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;UPDATE&lt;/code&gt;&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;UPDATE&lt;/code&gt;&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="4af3d4a1c360d57942900ff0fcaf6dc0a9cff4b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;ext/mysql&lt;/code&gt;&lt;/strong&gt; was &lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;&lt;strong&gt;officially deprecated as of PHP 5.5&lt;/strong&gt;&lt;/a&gt; and has been &lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7&quot;&gt;&lt;strong&gt;removed as of PHP 7&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;ext/mysql&lt;/code&gt; &lt;/strong&gt; &lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;&lt;strong&gt;自PHP 5.5&lt;/strong&gt;&lt;/a&gt;起&lt;strong&gt;正式弃用&lt;/strong&gt; &lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7&quot;&gt;&lt;strong&gt;，自PHP 7&lt;/strong&gt;&lt;/a&gt;起已被&lt;strong&gt;删除&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="21d3709bc3604de67baa10faab0af9188543ecb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A.&lt;/strong&gt; A prepared statement is a pre-compiled SQL statement that can be executed multiple times by sending only the data to the server.</source>
          <target state="translated">答：prepared语句是预编译的SQL语句，可以通过仅将数据发送到服务器来多次执行。</target>
        </trans-unit>
        <trans-unit id="66bcf27ed5345c3e7d140adfa9c56ebb3359dfcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A.&lt;/strong&gt; Let's have an example:</source>
          <target state="translated">&lt;strong&gt;答：&lt;/strong&gt;让我们举个例子：</target>
        </trans-unit>
        <trans-unit id="7d69176c1f43d19cde596ba2b74bea58f3c1bad5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A.&lt;/strong&gt; Named placeholders. Use descriptive names preceded by a colon, instead of question marks. We don't care about position/order of value in name place holder:</source>
          <target state="translated">&lt;strong&gt;A.&lt;/strong&gt;命名的占位符。 请在描述性名称前加上冒号，而不要使用问号。 我们不在乎名称占位符中的位置/值的顺序：</target>
        </trans-unit>
        <trans-unit id="1aecc95b507fcd1d0e6fda933de9c7becbbe5a09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Also, there are some false or non-significant reasons, like&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;另外，还有一些错误或不重要的原因，例如&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fbda4158ca375d01bee8e519487823e89ac0c2a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can we set attributes after PDO construction?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在PDO构建之后，我们可以设置属性吗？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71900205aba19377ace55dba6e80e5d49843cfb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Contemporary database APIs are just &lt;em&gt;easier&lt;/em&gt; to use.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;当代数据库API &lt;em&gt;更加易于&lt;/em&gt;使用。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ce243cbd8cc444c680e66a9ca31863339ae7a10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Execute&lt;/strong&gt;: At a later time, the application supplies (or binds) values for the parameters, and the DBMS executes the statement (possibly returning a result). The application may execute the statement as many times as it wants with different values. In this example, it might supply 'Bread' for the first parameter and &lt;code&gt;1.00&lt;/code&gt; for the second parameter.</source>
          <target state="translated">&lt;strong&gt;执行&lt;/strong&gt; ：稍后，应用程序提供（或绑定）参数值，然后DBMS执行该语句（可能返回结果）。 应用程序可以使用不同的值多次执行该语句。 在此示例中，它可能会为第一个参数提供&amp;ldquo;面包&amp;rdquo;，为第二个参数提供 &lt;code&gt;1.00&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b76647d0abd6627dc3e3d7aed8eb990660dd95d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting the Last Inserted ID&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;获取最后插入的ID&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bbeb2123bb627ff2057e11808030689ea471e52f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting the row count&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;获取行数&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="3d2b4c709812584ec969783a6880ad9830f30c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Good read&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;好阅读&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="ca5ca16bcc78e74bfbd4891290090d73b43c0d80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Good read&lt;/strong&gt;: &lt;a href=&quot;http://php.net/manual/en/pdo.connections.php&quot;&gt;Connections and Connection management &amp;para;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;阅读&lt;/strong&gt; ： &lt;a href=&quot;http://php.net/manual/en/pdo.connections.php&quot;&gt;连接和连接管理&amp;para;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64787817e9b226c3de70d33bdb039da28b3c4415" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Historic note on magic_quotes.&lt;/strong&gt; That feature is rightly deprecated. It's often incorrectly portrayed as failed &lt;em&gt;security&lt;/em&gt; feature however. But magic_quotes are as much a failed security feature as tennis balls have failed as nutrition source. That simply wasn't their purpose.</source>
          <target state="translated">&lt;strong&gt;关于magic_quotes的历史性注释。&lt;/strong&gt; 该功能已被正确弃用。 但是，通常将它错误地描述为失败的&lt;em&gt;安全&lt;/em&gt;功能。 但是，magic_quotes是一个失败的安全功能，就像网球作为营养源失败一样。 那根本不是他们的目的。</target>
        </trans-unit>
        <trans-unit id="7c2c76a00e13c745b512b4a84fde6bd4d754f51e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instead, you should learn of prepared statements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;相反，您应该学习准备好的语句&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0dbca28c12bb63433f617f4435842da2de64f12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NEW! - ext/mysql is now &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;officially deprecated as of PHP 5.5!&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;新！&lt;/strong&gt; &lt;strong&gt;- &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;自PHP 5.5起，&lt;/a&gt;&lt;/em&gt;现已&lt;em&gt;正式弃用&lt;/em&gt; ext / mysql &lt;em&gt;！&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f35097e2b1b38de5ec88177ea2b0967e5b0e99a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTE:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bcee5544ef56b940a214706dc29617b2b713720" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: In &lt;strong&gt;unnamed placeholders&lt;/strong&gt; we must take care of the proper order of the elements in the array that we are passing to the &lt;code&gt;PDOStatement::execute()&lt;/code&gt; method.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：在&lt;strong&gt;未命名的占位符中，&lt;/strong&gt;我们必须注意传递给 &lt;code&gt;PDOStatement::execute()&lt;/code&gt; 方法的数组中元素的正确顺序。</target>
        </trans-unit>
        <trans-unit id="a2fb3e1339eb87a7998bdbb7ee4cd05d10c3a4ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Neither mysqli_* nor PDO functions should have appeared in the application code.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mysqli_ *和PDO函数都不应出现在应用程序代码中。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dda929987f6bc860e4d7687f0f9b9055c3b38c38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nevertheless, there are also some non-technical issues, which can make your experience a bit harder&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;但是，还有一些非技术性的问题，可能会使您的体验更困难&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee452aec63009c2bd7bbfd6f03acd850aab819f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; you can also use &lt;code&gt;charset=UTF-8&lt;/code&gt;, but sometimes it causes an error, so it's better to use &lt;code&gt;utf8&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;您也可以使用 &lt;code&gt;charset=UTF-8&lt;/code&gt; ，但有时会导致错误，因此最好使用 &lt;code&gt;utf8&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f722b24d30ed0d049e9217e7bf9e78930a63b61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: If you are using the method like below (&lt;code&gt;query()&lt;/code&gt;), this method returns a &lt;code&gt;PDOStatement&lt;/code&gt; object. So if you want to fetch the result, use it like above.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：如果使用的是下面的方法（ &lt;code&gt;query()&lt;/code&gt; ），则此方法返回 &lt;code&gt;PDOStatement&lt;/code&gt; 对象。 因此，如果您想获取结果，请像上面一样使用它。</target>
        </trans-unit>
        <trans-unit id="1d0a361ba3da0755ad03adc9e9d32cb4ed1a08c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prepare&lt;/strong&gt;: The statement template is created by the application and sent to the database management system (DBMS). Certain values are left unspecified, called parameters, placeholders or bind variables (labelled &lt;code&gt;?&lt;/code&gt; below):</source>
          <target state="translated">&lt;strong&gt;准备&lt;/strong&gt; ：语句模板由应用程序创建，并发送到数据库管理系统（DBMS）。 某些值未指定，称为参数，占位符或绑定变量（在下面标记为 &lt;code&gt;?&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="8de8d53910fb26580d0d1462d5f15822e1f2f8fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prepared Statements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;准备的陈述&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83772b3402056078699b22b03ae7c71d472d223a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Q.&lt;/strong&gt; So now, what are named placeholders and how do I use them?</source>
          <target state="translated">&lt;strong&gt;问：&lt;/strong&gt;现在，什么叫占位符，我该如何使用它们？</target>
        </trans-unit>
        <trans-unit id="bf935138dd58afb317f393a58a87a426e51d9625" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Q.&lt;/strong&gt; So now, what are unnamed placeholders and how do I use them?</source>
          <target state="translated">&lt;strong&gt;问：&lt;/strong&gt;那么，什么是未命名的占位符以及如何使用它们？</target>
        </trans-unit>
        <trans-unit id="246454779aad75d51088bb0de1cda979d51768d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Q.&lt;/strong&gt; What is a prepared statement and why do I need them?</source>
          <target state="translated">&lt;strong&gt;问：&lt;/strong&gt;什么是准备好的声明，为什么我需要它们？</target>
        </trans-unit>
        <trans-unit id="bc3aaa8f04d43e44f616656297e0c78c54e1f172" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reason to not use &lt;code&gt;mysql_*&lt;/code&gt; function&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;不使用 &lt;code&gt;mysql_*&lt;/code&gt; 函数的原因&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="c7cfb15d4b60ac9b33a75c31e26bd7807779ace0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See the Red Box?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;看到红框了吗？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eb999dd362a05e63929ca191a77eea6b0e5a6b94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Suppressing deprecation warnings&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;禁止弃用警告&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c1160a54ccd72e93448ddb4bc662e0ee249f6fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They are no longer maintained, and are officially deprecated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;它们已不再维护，并已正式弃用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="14c3edf5863da2e2fc42e3f847cd0cec2427b6c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use either PDO or MySQLi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用PDO或MySQLi&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba557ea612da45ee87ea50fbc09e07ea7b1520ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes&lt;/strong&gt;, we can also set some attributes after PDO construction with the &lt;code&gt;setAttribute&lt;/code&gt; method:</source>
          <target state="translated">&lt;strong&gt;是的&lt;/strong&gt; ，在PDO构建之后，我们还可以使用 &lt;code&gt;setAttribute&lt;/code&gt; 方法设置一些属性：</target>
        </trans-unit>
        <trans-unit id="8cf01d9490d0b537b44b782fd8131a614ece8d85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql_*&lt;/strong&gt; functions do not support prepared statements.</source>
          <target state="translated">&lt;strong&gt;mysql_ *&lt;/strong&gt;函数不支持预备语句。</target>
        </trans-unit>
        <trans-unit id="e42abeed45b2dfef66fccc34fef34fdbe2a6d2f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql_*&lt;/strong&gt; functions do not support the binding of parameters.</source>
          <target state="translated">&lt;strong&gt;mysql_ *&lt;/strong&gt;函数不支持参数绑定。</target>
        </trans-unit>
        <trans-unit id="ac0f78e16e8962d33c7f864e2d4cfab79ed85fb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql_*&lt;/strong&gt; functions lack functionality for Object Oriented Programming.</source>
          <target state="translated">&lt;strong&gt;mysql_ *&lt;/strong&gt;函数缺少面向对象编程的功能。</target>
        </trans-unit>
        <trans-unit id="9ab107729188b218548fbdc2bdea183a073fe436" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mysql_*&lt;/strong&gt; functions were deprecated (as of &lt;strong&gt;PHP 5.5&lt;/strong&gt;) given the fact that better functions and code structures were developed. The fact that the function was deprecated means that no more effort will be placed into improving it in terms of performance and security, &lt;strong&gt;which means it is less future proof&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;鉴于&lt;/strong&gt;已开发出更好的功能和代码结构，不建议使用&lt;strong&gt;mysql_ *&lt;/strong&gt;函数（自&lt;strong&gt;PHP 5.5起&lt;/strong&gt; ）。 该功能已被弃用这一事实意味着，就性能和安全性而言，将不再付出更多的精力来改进它， &lt;strong&gt;这意味着它的未来证明越来越少&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a9ce00004e2016f2cadb930b22a5cb4bfad93c2" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;em&gt;Insert and delete will be covered later.&lt;/em&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;插入和删除将在以后介绍。&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="4605e640a44a2903dc29f4d7c4d5f1a5d3a737e6" translate="yes" xml:space="preserve">
          <source>A common practice when using &lt;code&gt;mysql_*&lt;/code&gt; is:</source>
          <target state="translated">使用 &lt;code&gt;mysql_*&lt;/code&gt; 的常见做法是：</target>
        </trans-unit>
        <trans-unit id="a13839e20b6d574ce0048134aef78b15481c1e5c" translate="yes" xml:space="preserve">
          <source>A simple and short PDO tutorial</source>
          <target state="translated">一个简单而简短的PDO教程</target>
        </trans-unit>
        <trans-unit id="48250fcdf8841a07f5b1248699a34ceeeef49b50" translate="yes" xml:space="preserve">
          <source>A. &amp;ldquo;&lt;strong&gt;PDO &amp;ndash; PHP Data Objects&lt;/strong&gt; &amp;ndash; is a database access layer providing a uniform method of access to multiple databases.&amp;rdquo;</source>
          <target state="translated">&lt;strong&gt;答&lt;/strong&gt; ：&amp;ldquo; &lt;strong&gt;PDO &amp;ndash; PHP数据对象&lt;/strong&gt; &amp;ndash;是数据库访问层，提供了访问多个数据库的统一方法。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="2f434a1f9a23e4564ea51f72e542f32afebac04b" translate="yes" xml:space="preserve">
          <source>API supports Multiple Statements and all MySQL 4.1+ functionality - Supported by MySQLi and mostly also by PDO</source>
          <target state="translated">API支持多语句和所有MySQL 4.1以上的功能-支持MySQLi和PDO。</target>
        </trans-unit>
        <trans-unit id="1fc3feb37f7a72085af4f28967eb6151ee8d1c5e" translate="yes" xml:space="preserve">
          <source>API supports Stored Procedures: Both MySQLi and PDO</source>
          <target state="translated">API支持存储过程。MySQLi和PDO都支持</target>
        </trans-unit>
        <trans-unit id="f09f90c57066a24eee0eb4f850c58410d1012793" translate="yes" xml:space="preserve">
          <source>API supports client-side Prepared Statements: Supported only by PDO</source>
          <target state="translated">API支持客户端的Prepared Statements。仅由PDO支持</target>
        </trans-unit>
        <trans-unit id="bc6bd620a8604b899ec28a40dd9fd604faf87f73" translate="yes" xml:space="preserve">
          <source>API supports server-side Prepared Statements: Supported by MYSQLi and PDO</source>
          <target state="translated">API支持服务器端准备好的语句。支持MYSQLi和PDO</target>
        </trans-unit>
        <trans-unit id="34890013f003ff6a72ea8f3325210ceb78fdcc4d" translate="yes" xml:space="preserve">
          <source>Above point quoted from Quentin's answer</source>
          <target state="translated">以上观点引自昆汀的回答。</target>
        </trans-unit>
        <trans-unit id="fd9035ed506b5a7ea270a5b3e1a41eff0a713ea2" translate="yes" xml:space="preserve">
          <source>Add them as comma delimited function parameters to &lt;code&gt;pdo_query()&lt;/code&gt;.</source>
          <target state="translated">将它们作为逗号分隔的函数参数添加到 &lt;code&gt;pdo_query()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01fb17f71e8b9143a9904e6eb49ef6a34b6db1f8" translate="yes" xml:space="preserve">
          <source>Also, you can handle by &lt;code&gt;or die()&lt;/code&gt; or we can say like &lt;code&gt;mysql_*&lt;/code&gt;, but it will be really varied. You can hide the dangerous error messages in production by turning &lt;code&gt;display_errors off&lt;/code&gt; and just reading your error log.</source>
          <target state="translated">另外，您可以通过 &lt;code&gt;or die()&lt;/code&gt; 进行处理， 或者可以说像 &lt;code&gt;mysql_*&lt;/code&gt; ，但是它确实会有所不同。 您可以通过关闭 &lt;code&gt;display_errors off&lt;/code&gt; 并仅读取错误日志来隐藏生产中的危险错误消息。</target>
        </trans-unit>
        <trans-unit id="65ace5a4919de42d6ac9e8e70a32858585a56919" translate="yes" xml:space="preserve">
          <source>Amazing! Hi-fives all round, the code correctly verified an admin. It's perfect!</source>
          <target state="translated">厉害了! 掌声欢迎,代码正确验证了管理员。太完美了!</target>
        </trans-unit>
        <trans-unit id="67c99697e4cd741a12219ff4ecfee60683efb9b6" translate="yes" xml:space="preserve">
          <source>And a better way is &lt;code&gt;PDO&lt;/code&gt;, and I am now writing a simple &lt;code&gt;PDO&lt;/code&gt; tutorial.</source>
          <target state="translated">更好的方法是 &lt;code&gt;PDO&lt;/code&gt; ，我现在正在编写一个简单的 &lt;code&gt;PDO&lt;/code&gt; 教程。</target>
        </trans-unit>
        <trans-unit id="120d08ba81249a9f81e7d175247796e5cff77a30" translate="yes" xml:space="preserve">
          <source>And contrary - if you have an abstraction layer between your application code and mysql API - &lt;strong&gt;it doesn't actually matter which engine is used.&lt;/strong&gt; You can use mysql ext until it goes deprecated and then easily rewrite your abstraction class to another engine, &lt;strong&gt;having all the application code intact.&lt;/strong&gt;</source>
          <target state="translated">相反，如果您在应用程序代码和mysql API之间有一个抽象层&lt;strong&gt;，则实际上使用哪个引擎并不重要。&lt;/strong&gt; 您可以使用mysql ext直到它被弃用，然后轻松地将抽象类重写到另一个引擎， &lt;strong&gt;同时保留所有应用程序代码。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42319ef1243e1cb43dbc04ce225a03a2d0c6b42e" translate="yes" xml:space="preserve">
          <source>And in pdo, this same thing can be done by:</source>
          <target state="translated">而在pdo中,这种事情也可以通过。</target>
        </trans-unit>
        <trans-unit id="0993bf28ecd55614b8bb57ddce1033f985cb8e69" translate="yes" xml:space="preserve">
          <source>And it will be too wordy and most likely unsafe.</source>
          <target state="translated">而且会过于繁琐,极有可能是不安全的。</target>
        </trans-unit>
        <trans-unit id="f8d456b41786de88a2dbb3af1c629f6c1141c80c" translate="yes" xml:space="preserve">
          <source>And the later PHP developer team has taken the decision to generate &lt;a href=&quot;https://github.com/php/php-src/commit/b7091aaf0137d97cf4aa4a402ec50b3946d369c0&quot;&gt;&lt;strong&gt;&lt;code&gt;E_DEPRECATED&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; errors when users connect to MySQL, whether through &lt;code&gt;mysql_connect()&lt;/code&gt;, &lt;code&gt;mysql_pconnect()&lt;/code&gt; or the implicit connection functionality built into &lt;code&gt;ext/mysql&lt;/code&gt;.</source>
          <target state="translated">后来的PHP开发人员团队决定，当用户连接到MySQL时，无论是通过 &lt;code&gt;mysql_connect()&lt;/code&gt; ， &lt;code&gt;mysql_pconnect()&lt;/code&gt; 还是 &lt;code&gt;ext/mysql&lt;/code&gt; 中内置的隐式连接功能，都会生成&lt;a href=&quot;https://github.com/php/php-src/commit/b7091aaf0137d97cf4aa4a402ec50b3946d369c0&quot;&gt;&lt;strong&gt; &lt;code&gt;E_DEPRECATED&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;错误。</target>
        </trans-unit>
        <trans-unit id="ef4d4c6fb57c79a8162041f226c5e4efb9e26af4" translate="yes" xml:space="preserve">
          <source>And the output is:</source>
          <target state="translated">而输出是。</target>
        </trans-unit>
        <trans-unit id="968a4fefe78eb6c9a0fb316c9f7ac9217c1ea9fc" translate="yes" xml:space="preserve">
          <source>And you can wrap it in &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt;, like below:</source>
          <target state="translated">您可以将其包装在 &lt;code&gt;try&lt;/code&gt; - &lt;code&gt;catch&lt;/code&gt; 中 ，如下所示：</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">又如:</target>
        </trans-unit>
        <trans-unit id="8899017bb75139a8d05c4ded944ef88bb6b69e08" translate="yes" xml:space="preserve">
          <source>Another nice feature for &lt;code&gt;OOP&lt;/code&gt; friends is that named placeholders have the ability to insert objects directly into your database, assuming the properties match the named fields. For example:</source>
          <target state="translated">对于 &lt;code&gt;OOP&lt;/code&gt; 朋友来说，另一个不错的功能是，假设属性与命名字段匹配，命名占位符可以将对象直接插入数据库中。 例如：</target>
        </trans-unit>
        <trans-unit id="498040b4cb115e9716562169981fc9fa03b6e734" translate="yes" xml:space="preserve">
          <source>Any of the new functionality in MySQL 5.1 or later</source>
          <target state="translated">MySQL 5.1或更高版本中的任何新功能</target>
        </trans-unit>
        <trans-unit id="0e5e1aea7f23bc2927b5d23c2cbc5412b05fce82" translate="yes" xml:space="preserve">
          <source>As an example, someone could use &lt;code&gt;&quot;enhzflep); drop table users&quot;&lt;/code&gt; as a username. The old functions will allow executing multiple statements per query, so something like that nasty bugger can delete a whole table.</source>
          <target state="translated">例如，某人可以使用 &lt;code&gt;&quot;enhzflep); drop table users&quot;&lt;/code&gt; 作为用户名。 旧的函数将允许每个查询执行多个语句，因此，诸如此类的臭虫可以删除整个表。</target>
        </trans-unit>
        <trans-unit id="d5ad27cf2144b732b070aaef3f6328e7557022c6" translate="yes" xml:space="preserve">
          <source>As explained in the above answers, the alternatives to mysql are mysqli and PDO (PHP Data Objects).</source>
          <target state="translated">正如上面的答案所解释的那样,mysql的替代品是mysqli和PDO(PHP数据对象)。</target>
        </trans-unit>
        <trans-unit id="242084bedb9aa3c73ad1bd7da789bee02633449f" translate="yes" xml:space="preserve">
          <source>Because (amongst other reasons) it's much harder to ensure the input data is sanitized. If you use parametrized queries, as one does with PDO or mysqli you can entirely avoid the risk.</source>
          <target state="translated">因为(其他原因之一)要确保输入的数据被净化就难多了。如果你使用参数化查询,就像使用PDO或mysqli一样,你完全可以避免这个风险。</target>
        </trans-unit>
        <trans-unit id="06606943663433f539cbc360dbd06b2bc39a6263" translate="yes" xml:space="preserve">
          <source>Below is an example of how you can do it:</source>
          <target state="translated">以下是一个例子。</target>
        </trans-unit>
        <trans-unit id="123eebf3efbb03421b5f4b2571c2660d81b303c7" translate="yes" xml:space="preserve">
          <source>Beware that parameter binding still isn't a magic one-stop solution against &lt;em&gt;all&lt;/em&gt; SQL injections. It handles the most common use for data/values. But can't whitelist column name / table identifiers, help with dynamic clause construction, or just plain array value lists.</source>
          <target state="translated">注意，对于&lt;em&gt;所有&lt;/em&gt; SQL注入，参数绑定仍然不是一个神奇的一站式解决方案。 它处理数据/值的最常见用法。 但是不能将列名/表标识符列入白名单，不能帮助动态子句构造，也不能仅将简单数组值列表列入白名单。</target>
        </trans-unit>
        <trans-unit id="dbf3abea317b3728874b25d75ef5a69530c550f8" translate="yes" xml:space="preserve">
          <source>Both MySQLi and PDO were introduced in PHP 5.0, whereas MySQL was introduced prior to PHP 3.0. A point to note is that MySQL is included in PHP5.x though deprecated in later versions.</source>
          <target state="translated">MySQLi和PDO都是在PHP 5.0中引入的,而MySQL是在PHP 3.0之前引入的。需要注意的一点是,MySQL是包含在PHP5.x中的,虽然在以后的版本中已经被弃用。</target>
        </trans-unit>
        <trans-unit id="51020afda7d0112c97929b784637a312225d970c" translate="yes" xml:space="preserve">
          <source>Bound parameters can be easy to use</source>
          <target state="translated">约束参数可以很容易使用</target>
        </trans-unit>
        <trans-unit id="300f56277ff5fe0394d55c2ebdaf31a5d9ca5560" translate="yes" xml:space="preserve">
          <source>Brilliant, not enter in the following:</source>
          <target state="translated">辉煌,不在下面输入。</target>
        </trans-unit>
        <trans-unit id="13baed15c99f957c80af17236b205876746fb816" translate="yes" xml:space="preserve">
          <source>But as first step just &lt;strong&gt;get rid of the &lt;code&gt;_real_escape_string&lt;/code&gt;&lt;/strong&gt; call.</source>
          <target state="translated">但第一步是&lt;strong&gt;摆脱 &lt;code&gt;_real_escape_string&lt;/code&gt; &lt;/strong&gt;调用。</target>
        </trans-unit>
        <trans-unit id="c2b6b6db7e4e3dfb886e45b51b27e98f7d6f7e48" translate="yes" xml:space="preserve">
          <source>But okay, if you don't like the red box in the manual, a problem of choice arises: mysqli or PDO?</source>
          <target state="translated">不过还好,如果你不喜欢说明书上的红框,那么就会出现一个选择问题:mysqli还是PDO?</target>
        </trans-unit>
        <trans-unit id="0ea2f9f9df0901957a54cc00384ae3ecf9e7598f" translate="yes" xml:space="preserve">
          <source>But, in my opinion, the proposed solution is no better either.</source>
          <target state="translated">但是,我认为,拟议的解决方案也没有更好。</target>
        </trans-unit>
        <trans-unit id="87f8df6d2b63e036157cc4d012be4719078a49b1" translate="yes" xml:space="preserve">
          <source>Can be replaced with just an foreach iteration:</source>
          <target state="translated">可以只用一个foreach迭代来代替。</target>
        </trans-unit>
        <trans-unit id="98de0e635b4201b0c76f621b74657cf746901ace" translate="yes" xml:space="preserve">
          <source>Compare it with usual PDO inserts, when every single field name being repeated six to ten times - in all these numerous named placeholders, bindings, and query definitions.</source>
          <target state="translated">与通常的PDO插入相比,当每一个字段名都被重复六到十次--在所有这些被命名的占位符、绑定和查询定义中。</target>
        </trans-unit>
        <trans-unit id="f2b2bc84e981266a2ed8528d294c0bc718096013" translate="yes" xml:space="preserve">
          <source>Compare this one single line with &lt;a href=&quot;https://stackoverflow.com/a/15991146/285587&quot;&gt;amount of code you will need with PDO&lt;/a&gt;.</source>
          <target state="translated">将这一行&lt;a href=&quot;https://stackoverflow.com/a/15991146/285587&quot;&gt;与PDO所需的代码量进行&lt;/a&gt;比较。</target>
        </trans-unit>
        <trans-unit id="46ead4045fbadbc2f0b37b6046e5803972459710" translate="yes" xml:space="preserve">
          <source>Compression</source>
          <target state="translated">Compression</target>
        </trans-unit>
        <trans-unit id="9f82982d2197b2fb50ef5bc31251b1e69637c99f" translate="yes" xml:space="preserve">
          <source>Congrats, you just allowed me to enter your super-protected admins only section with me entering a false username and a false password. Seriously, if you don't believe me, create the database with the code I provided, and run this PHP code - which at glance REALLY does seem to verify the username and password rather nicely.</source>
          <target state="translated">恭喜你,你让我进入了你的超级保护的管理员区,我输入了一个假用户名和假密码。</target>
        </trans-unit>
        <trans-unit id="9cdd246b67ff3115cf8e58af1aa4662b256a8fa8" translate="yes" xml:space="preserve">
          <source>Connecting to MySQL</source>
          <target state="translated">连接到MySQL</target>
        </trans-unit>
        <trans-unit id="f84015d92e165e7b3f840594a075b9ee6030c2a1" translate="yes" xml:space="preserve">
          <source>Correct order would have been: deprecatedly &lt;code&gt;stripslashes&lt;/code&gt; as the innermost call, then &lt;code&gt;trim&lt;/code&gt;, afterwards &lt;code&gt;strip_tags&lt;/code&gt;, &lt;code&gt;htmlentities&lt;/code&gt; for output context, and only lastly the &lt;code&gt;_escape_string&lt;/code&gt; as its application should directly preceed the SQL intersparsing.</source>
          <target state="translated">正确的顺序应该是：不建议将 &lt;code&gt;stripslashes&lt;/code&gt; 作为最内层的调用，然后将 &lt;code&gt;trim&lt;/code&gt; ，之后 &lt;code&gt;strip_tags&lt;/code&gt; ，用于输出上下文的 &lt;code&gt;htmlentities&lt;/code&gt; ，以及最后 &lt;code&gt;_escape_string&lt;/code&gt; ,因为其应用程序应直接在SQL进行内部插入。</target>
        </trans-unit>
        <trans-unit id="274ac70de9ee561047b2d6020375c34942dc13aa" translate="yes" xml:space="preserve">
          <source>Doesn't support &lt;a href=&quot;http://en.wikipedia.org/wiki/Database_transaction&quot;&gt;transactions&lt;/a&gt;</source>
          <target state="translated">不支持&lt;a href=&quot;http://en.wikipedia.org/wiki/Database_transaction&quot;&gt;交易&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b91190ed508aa1ebccf4667808bf07650ab04f8" translate="yes" xml:space="preserve">
          <source>Doesn't support Multiple Statements (who need them?)</source>
          <target state="translated">不支持多重声明(谁需要?</target>
        </trans-unit>
        <trans-unit id="d44232efd1fd248676980ae2cdc482a57df4a84c" translate="yes" xml:space="preserve">
          <source>Doesn't support Prepared Statements or Parametrized Queries</source>
          <target state="translated">不支持准备好的报表或参数化查询。</target>
        </trans-unit>
        <trans-unit id="6c479d1a8515470d066edea5ea563b89e68cc6f8" translate="yes" xml:space="preserve">
          <source>Doesn't support Stored Procedures (we were using &lt;code&gt;mysql_query(&quot;CALL my_proc&quot;);&lt;/code&gt; for ages)</source>
          <target state="translated">不支持存储过程（我们使用 &lt;code&gt;mysql_query(&quot;CALL my_proc&quot;);&lt;/code&gt; 很久了）</target>
        </trans-unit>
        <trans-unit id="866143011c8a05791bf29b94865c70519ad71e72" translate="yes" xml:space="preserve">
          <source>Doesn't support Transactions (same as above)</source>
          <target state="translated">不支持交易(同上)</target>
        </trans-unit>
        <trans-unit id="fce860154fdb146e5f646b4901b94461c45d68e0" translate="yes" xml:space="preserve">
          <source>Doesn't support all of the functionality in MySQL 5.1</source>
          <target state="translated">不支持MySQL 5.1中的所有功能。</target>
        </trans-unit>
        <trans-unit id="3cf92a22337ed0b5bde371c6efea5d06737ca874" translate="yes" xml:space="preserve">
          <source>Doesn't support multiple statements</source>
          <target state="translated">不支持多重声明</target>
        </trans-unit>
        <trans-unit id="864e78e1d6a762f1e100177dd6406de3ab443864" translate="yes" xml:space="preserve">
          <source>Doesn't support non-blocking, asynchronous queries</source>
          <target state="translated">不支持非阻塞、异步查询。</target>
        </trans-unit>
        <trans-unit id="d1636c7a918bc55871631f47bbb14d7249b434bf" translate="yes" xml:space="preserve">
          <source>Doesn't support prepared statements or &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;parameterized queries&lt;/a&gt;</source>
          <target state="translated">不支持预备语句或&lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;参数化查询&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b1078a18b28afd9f7f8df361d462c8be33bb483" translate="yes" xml:space="preserve">
          <source>Doesn't support stored procedures</source>
          <target state="translated">不支持存储过程</target>
        </trans-unit>
        <trans-unit id="913e0c4a5ec4213ac6b0e5bc84a0b4952dd23744" translate="yes" xml:space="preserve">
          <source>Doesn't support:</source>
          <target state="translated">不支持。</target>
        </trans-unit>
        <trans-unit id="3a2186dd09a53f0acfd3661a66ceb59c176eaf88" translate="yes" xml:space="preserve">
          <source>Ease of use</source>
          <target state="translated">使用方便</target>
        </trans-unit>
        <trans-unit id="db8c650e4e279285960b1784a6fbbece934a01e3" translate="yes" xml:space="preserve">
          <source>Embedded server support</source>
          <target state="translated">嵌入式服务器支持</target>
        </trans-unit>
        <trans-unit id="6d7b79456a20370d710fa37e809943165d11f572" translate="yes" xml:space="preserve">
          <source>Encryption (SSL)</source>
          <target state="translated">加密(SSL)</target>
        </trans-unit>
        <trans-unit id="5b860d134c5b348f6cc8170ac43f9694cf148a8f" translate="yes" xml:space="preserve">
          <source>Enhanced debugging capabilities</source>
          <target state="translated">增强的调试能力</target>
        </trans-unit>
        <trans-unit id="6f31dd815c428bc663ce257d3df663a6858bc6b0" translate="yes" xml:space="preserve">
          <source>Enter in the following:</source>
          <target state="translated">输入以下内容:</target>
        </trans-unit>
        <trans-unit id="09fa2a067aee2197e8eb1a89b00eefbf6e88e347" translate="yes" xml:space="preserve">
          <source>Equivalent pdo_* functions in place of &lt;s&gt;mysql_*&lt;/s&gt;</source>
          <target state="translated">等效的pdo_ *函数代替&lt;s&gt;mysql_ *&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="2f3b48eb0edc6001d7879dc58945e065cc2e3e5a" translate="yes" xml:space="preserve">
          <source>Error handling is much easier in &lt;code&gt;PDO&lt;/code&gt; than &lt;code&gt;mysql_*&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;PDO&lt;/code&gt; 中,错误处理比 &lt;code&gt;mysql_*&lt;/code&gt; 容易得多。</target>
        </trans-unit>
        <trans-unit id="fec40d777dec6257585f890975134a9cea348678" translate="yes" xml:space="preserve">
          <source>Errors and error handling &amp;para;</source>
          <target state="translated">错误和错误处理</target>
        </trans-unit>
        <trans-unit id="c019ec3bcff0bb2854b0e299ba32a9eee4bd0ee3" translate="yes" xml:space="preserve">
          <source>Et voil&amp;agrave;.</source>
          <target state="translated">等等。</target>
        </trans-unit>
        <trans-unit id="1286a514865def6edb80f749d66c5420df3e9cc2" translate="yes" xml:space="preserve">
          <source>Exceptions &amp;para;</source>
          <target state="translated">异常&amp;para;</target>
        </trans-unit>
        <trans-unit id="ca51f996bb09297e02939f7b41f4c178b7775704" translate="yes" xml:space="preserve">
          <source>Fetch Modes</source>
          <target state="translated">获取模式</target>
        </trans-unit>
        <trans-unit id="0cda57057d1816d4de9cdbd01aece5021ed7c626" translate="yes" xml:space="preserve">
          <source>First of all, I explain how to select fetch mode:</source>
          <target state="translated">首先,我介绍一下如何选择获取模式。</target>
        </trans-unit>
        <trans-unit id="17ba645d365edcb5b41c66ee76e97181eab4127f" translate="yes" xml:space="preserve">
          <source>First off, please feel free to create this test mysql database (I have called mine prep):</source>
          <target state="translated">首先,请大家随意创建这个测试mysql数据库(我把我的叫作prep)。</target>
        </trans-unit>
        <trans-unit id="dde1356568f59e4b14dee0b21b6e2107618e0338" translate="yes" xml:space="preserve">
          <source>First, let's begin with the standard comment we give everyone:</source>
          <target state="translated">首先,我们先来说说我们给大家的标准评语。</target>
        </trans-unit>
        <trans-unit id="5659b9d449b5b012e0b098e81e7ed2f20fe0f375" translate="yes" xml:space="preserve">
          <source>Fix or remove any oldschool &lt;a href=&quot;https://stackoverflow.com/questions/3126072/what-are-the-best-php-input-sanitizing-functions&quot;&gt;&lt;code&gt;sanitize()&lt;/code&gt;&lt;/a&gt; function</source>
          <target state="translated">修复或删除任何老式的&lt;a href=&quot;https://stackoverflow.com/questions/3126072/what-are-the-best-php-input-sanitizing-functions&quot;&gt; &lt;code&gt;sanitize()&lt;/code&gt; &lt;/a&gt;函数</target>
        </trans-unit>
        <trans-unit id="3aa75d58669bb5ac8b40367ea713bcccf7011235" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/60174/best-way-to-prevent-sql-injection-in-php&quot;&gt;How can I prevent SQL injection in PHP?&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">有关更多信息，请参见&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/60174/best-way-to-prevent-sql-injection-in-php&quot;&gt;如何防止PHP中的SQL注入？&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07593710668e04f42ef94baca94b6702963b9675" translate="yes" xml:space="preserve">
          <source>Full Charset support</source>
          <target state="translated">全面的字符集支持</target>
        </trans-unit>
        <trans-unit id="55dc1ba13909c533de685b19d9a8793a296b2045" translate="yes" xml:space="preserve">
          <source>Get rid of &lt;code&gt;'&lt;/code&gt; single quotes that previously enclosed string values/variables.</source>
          <target state="translated">摆脱以前用单引号引起来的字符串值/变量。</target>
        </trans-unit>
        <trans-unit id="6eed48caa38c8545e4fcf00ca0a37b5a7cf30396" translate="yes" xml:space="preserve">
          <source>Has been &lt;strong&gt;&lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7#extmysql&quot;&gt;removed&lt;/a&gt; entirely&lt;/strong&gt; as of PHP 7.0 (released December 2015)</source>
          <target state="translated">自PHP 7.0（2015年12月发布）起&lt;strong&gt;&lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7#extmysql&quot;&gt;已&lt;/a&gt;完全删除。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="292c37ca19719be96899acb843e9a5c01e00d6c6" translate="yes" xml:space="preserve">
          <source>Here I think you are familiar with all except &lt;code&gt;DSN&lt;/code&gt;; this is new in &lt;code&gt;PDO&lt;/code&gt;. A &lt;code&gt;DSN&lt;/code&gt; is basically a string of options that tell &lt;code&gt;PDO&lt;/code&gt; which driver to use, and connection details. For further reference, check &lt;a href=&quot;http://www.php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;PDO MySQL DSN&lt;/a&gt;.</source>
          <target state="translated">在这里，我认为除了 &lt;code&gt;DSN&lt;/code&gt; 之外，您都熟悉其他所有内容； 这是 &lt;code&gt;PDO&lt;/code&gt; 中的新功能。 &lt;code&gt;DSN&lt;/code&gt; 基本上是一串选项，可告诉 &lt;code&gt;PDO&lt;/code&gt; 使用哪个驱动程序以及连接详细信息。 有关更多参考，请检查&lt;a href=&quot;http://www.php.net/manual/en/ref.pdo-mysql.connection.php&quot;&gt;PDO MySQL DSN&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="019fa0bc748b8d714e14e0a14973bd4b152ee106" translate="yes" xml:space="preserve">
          <source>Here are some examples based on my &lt;a href=&quot;https://github.com/colshrapnel/safemysql/blob/master/safemysql.class.php&quot;&gt;safemysql class&lt;/a&gt; to show how such an abstraction class ought to be:</source>
          <target state="translated">以下是一些基于我的&lt;a href=&quot;https://github.com/colshrapnel/safemysql/blob/master/safemysql.class.php&quot;&gt;safemysql类的&lt;/a&gt;示例，以说明这种抽象类应如何：</target>
        </trans-unit>
        <trans-unit id="e75030adb468b3a20795417b746e352d74186766" translate="yes" xml:space="preserve">
          <source>How about:</source>
          <target state="translated">怎么样?</target>
        </trans-unit>
        <trans-unit id="f26d6694fb7f66ecaf4fa1fbfe7bfe24ef194112" translate="yes" xml:space="preserve">
          <source>How prepared statements differ</source>
          <target state="translated">准备好的报表有何不同</target>
        </trans-unit>
        <trans-unit id="ad5800a3aa56f013a36e72eea8f14ecf9737e3a7" translate="yes" xml:space="preserve">
          <source>However &lt;code&gt;PDO&lt;/code&gt; and/or &lt;code&gt;MySQLi&lt;/code&gt; are not completely safe. Check the answer &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/12202218/1723893&quot;&gt;Are PDO prepared statements sufficient to prevent SQL injection?&lt;/a&gt;&lt;/em&gt; by &lt;a href=&quot;https://stackoverflow.com/users/338665/ircmaxell&quot;&gt;ircmaxell&lt;/a&gt;. Also, I am quoting some part from his answer:</source>
          <target state="translated">但是， &lt;code&gt;PDO&lt;/code&gt; 和/或 &lt;code&gt;MySQLi&lt;/code&gt; 并不完全安全。 检查答案&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/a/12202218/1723893&quot;&gt;PDO准备好的语句是否足以防止SQL注入？&lt;/a&gt;&lt;/em&gt; 由&lt;a href=&quot;https://stackoverflow.com/users/338665/ircmaxell&quot;&gt;ircmaxell撰写&lt;/a&gt; 。 另外，我引用了他的回答的一部分：</target>
        </trans-unit>
        <trans-unit id="de3f6b6dffdfbc0e7f9d59202608ca2d11708387" translate="yes" xml:space="preserve">
          <source>However, PDO is not a silver bullet too and has its hardships.</source>
          <target state="translated">然而,PDO也不是银子,也有其艰辛。</target>
        </trans-unit>
        <trans-unit id="2326670ae94db3911611b4826e5793726e96d9a3" translate="yes" xml:space="preserve">
          <source>However, this isn't about folks yelling at you now, this is about showing you how to make your code more secure.</source>
          <target state="translated">然而,这并不是说乡亲们现在骂你,而是告诉你如何让你的代码更安全。</target>
        </trans-unit>
        <trans-unit id="c9bbba0df8331566d9a670652804604f09ff8317" translate="yes" xml:space="preserve">
          <source>Hybrid PDO use</source>
          <target state="translated">混合型PDO的使用</target>
        </trans-unit>
        <trans-unit id="5e7fba6fe256396d77ecf48550f90f920c0cc0f5" translate="yes" xml:space="preserve">
          <source>I find the above answers really lengthy, so to summarize:</source>
          <target state="translated">我觉得上面的答案真的很长,所以要总结一下。</target>
        </trans-unit>
        <trans-unit id="f888fecc5715ba4d43b06bf6c44a1576614e0cd5" translate="yes" xml:space="preserve">
          <source>I will later explain why prepare emulation should be turned off. To find reason please check &lt;a href=&quot;https://stackoverflow.com/a/12202218/1723893&quot;&gt;this post&lt;/a&gt;.</source>
          <target state="translated">稍后我将解释为什么应关闭准备仿真。 为了找到原因，请检查&lt;a href=&quot;https://stackoverflow.com/a/12202218/1723893&quot;&gt;这篇文章&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="28dfd8eb5aa64d92b1531d7f65006651386ac1e5" translate="yes" xml:space="preserve">
          <source>If one were to use PDO of mysqli, the user-name would end-up being &lt;code&gt;&quot;enhzflep); drop table users&quot;&lt;/code&gt;.</source>
          <target state="translated">如果要使用mysqli的PDO，则用户名最终将是 &lt;code&gt;&quot;enhzflep); drop table users&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4376248962eeae9e24a09673cabe25c9fe2dda0b" translate="yes" xml:space="preserve">
          <source>If there is any connection error, it will throw a &lt;code&gt;PDOException&lt;/code&gt; object that can be caught to handle &lt;code&gt;Exception&lt;/code&gt; further.</source>
          <target state="translated">如果存在任何连接错误，它将抛出一个 &lt;code&gt;PDOException&lt;/code&gt; 对象，可以捕获该对象以进一步处理 &lt;code&gt;Exception&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94d17d9e7f39fa252ce5b88628ec7ce8a80613f1" translate="yes" xml:space="preserve">
          <source>If there was any mention of &lt;code&gt;stripslashes()&lt;/code&gt; in your sanitize function, it may indicate a higher level oversight.</source>
          <target state="translated">如果您的清理功能中提到了 &lt;code&gt;stripslashes()&lt;/code&gt; ，则可能表明存在更高级别的监督。</target>
        </trans-unit>
        <trans-unit id="4b4c10e7726c178ac937120403512eeb1525dc8e" translate="yes" xml:space="preserve">
          <source>If they don't work on my site, why do I get errors like</source>
          <target state="translated">如果它们在我的网站上不起作用,为什么会出现以下错误,比如</target>
        </trans-unit>
        <trans-unit id="846ece56704dd1bb57e31e8af6a84a5ac5a26943" translate="yes" xml:space="preserve">
          <source>If you need more reasons:</source>
          <target state="translated">如果你需要更多的理由。</target>
        </trans-unit>
        <trans-unit id="c46e5bd047077b5ae27ca605ac5c2cfb2afbb0b6" translate="yes" xml:space="preserve">
          <source>If you need them - these are no doubt technical reasons to move away from mysql extension toward something more stylish and modern-looking.</source>
          <target state="translated">如果你需要它们--这些无疑都是技术上的原因,从mysql扩展转向更时尚、更现代的东西。</target>
        </trans-unit>
        <trans-unit id="2407ac2d8afe5ad1d4210ba943dda290fb411756" translate="yes" xml:space="preserve">
          <source>If you understand the necessity of using a &lt;em&gt;database abstraction layer&lt;/em&gt; and looking for an API to create one, &lt;strong&gt;mysqli&lt;/strong&gt; is a very good choice, as it indeed supports many mysql-specific features.</source>
          <target state="translated">如果您了解使用&lt;em&gt;数据库抽象层&lt;/em&gt;并寻找创建一个API的必要性，则&lt;strong&gt;mysqli&lt;/strong&gt;是一个很好的选择，因为它确实支持许多特定于mysql的功能。</target>
        </trans-unit>
        <trans-unit id="d41a7c07f4fd244d7cfdcf97a95a4ac1ba508f7c" translate="yes" xml:space="preserve">
          <source>If you want to simplify your database interaction further, mappers like &lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Paris/Idiorm&lt;/a&gt; are worth a try. Just like nobody uses the bland DOM in JavaScript anymore, you don't have to babysit a raw database interface nowadays.</source>
          <target state="translated">如果您想进一步简化数据库交互，那么像&lt;a href=&quot;http://j4mie.github.io/idiormandparis/&quot;&gt;Paris / Idiorm&lt;/a&gt;这样的映射器值得一试。 就像没有人在JavaScript中使用平淡的DOM一样，如今您不必再负担原始数据库接口。</target>
        </trans-unit>
        <trans-unit id="a03e56ddd1d9eaedeb9d91db1610b19c15481de8" translate="yes" xml:space="preserve">
          <source>If, like vast majority of PHP folks, you are using raw API calls right in the application code (which is essentially wrong practice) - &lt;strong&gt;PDO is the only choice&lt;/strong&gt;, as this extension pretends to be not just API but rather a semi-DAL, still incomplete but offers many important features, with two of them makes PDO critically distinguished from mysqli:</source>
          <target state="translated">如果像绝大多数PHP人士一样，您在应用程序代码中使用原始API调用（这实际上是错误的做法） &lt;strong&gt;-PDO是唯一的选择&lt;/strong&gt; ，因为此扩展不仅是API，而是半DAL，仍然不完整，但提供了许多重要功能，其中两个使PDO与mysqli形成了鲜明的区别：</target>
        </trans-unit>
        <trans-unit id="5f5e48429d30c2e5c8c7ca18ee430f4c425e3ebe" translate="yes" xml:space="preserve">
          <source>In PDO Data, it is obtained via the &lt;code&gt;-&amp;gt;fetch()&lt;/code&gt;, a method of your statement handle. Before calling fetch, the best approach would be telling PDO how you&amp;rsquo;d like the data to be fetched. In the below section I am explaining this.</source>
          <target state="translated">在PDO数据中，它是通过 &lt;code&gt;-&amp;gt;fetch()&lt;/code&gt; （您的语句句柄的一种方法）获得的。 在调用提取之前，最好的方法是告诉PDO如何获取数据。 在下面的部分中，我将对此进行解释。</target>
        </trans-unit>
        <trans-unit id="3859a21002fff48190278b32ba00eefe967fe002" translate="yes" xml:space="preserve">
          <source>In particular you should fix any &lt;code&gt;sanitize&lt;/code&gt; or &lt;code&gt;clean&lt;/code&gt; or &lt;code&gt;filterThis&lt;/code&gt; or &lt;code&gt;clean_data&lt;/code&gt; functions as advertised by dated tutorials in one form or the other:</source>
          <target state="translated">特别是，您应该按照日期指南以一种或另一种形式修复任何 &lt;code&gt;sanitize&lt;/code&gt; 或 &lt;code&gt;clean&lt;/code&gt; 或 &lt;code&gt;filterThis&lt;/code&gt; 或 &lt;code&gt;clean_data&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="ba93b0ae18afe09edfc1991f28f940835559bcc0" translate="yes" xml:space="preserve">
          <source>In the above query &lt;a href=&quot;http://php.net/manual/en/pdo.exec.php&quot;&gt;&lt;code&gt;PDO::exec&lt;/code&gt;&lt;/a&gt; execute an SQL statement and returns the number of affected rows.</source>
          <target state="translated">在上面的查询中， &lt;a href=&quot;http://php.net/manual/en/pdo.exec.php&quot;&gt; &lt;code&gt;PDO::exec&lt;/code&gt; &lt;/a&gt;执行一条SQL语句并返回受影响的行数。</target>
        </trans-unit>
        <trans-unit id="37976e7c9d1ceb09ad128295fdb921a6584e75ca" translate="yes" xml:space="preserve">
          <source>In the above, I have been using &lt;code&gt;fetch()&lt;/code&gt;. You can also use:</source>
          <target state="translated">在上面，我一直在使用 &lt;code&gt;fetch()&lt;/code&gt; 。 您还可以使用：</target>
        </trans-unit>
        <trans-unit id="838f76e4ca8001fae4cd38b944929578bd91104a" translate="yes" xml:space="preserve">
          <source>In the above, you can see those &lt;code&gt;?&lt;/code&gt; instead of a name like in a name place holder. Now in the first example, we assign variables to the various placeholders (&lt;code&gt;$stmt-&amp;gt;bindValue(1, $name, PDO::PARAM_STR);&lt;/code&gt;). Then, we assign values to those placeholders and execute the statement. In the second example, the first array element goes to the first &lt;code&gt;?&lt;/code&gt; and the second to the second &lt;code&gt;?&lt;/code&gt;.</source>
          <target state="translated">在上面，您可以看到那些 &lt;code&gt;?&lt;/code&gt; 而不是像在名称占位符中那样的名称。 现在在第一个示例中，我们将变量分配给各个占位符（ &lt;code&gt;$stmt-&amp;gt;bindValue(1, $name, PDO::PARAM_STR);&lt;/code&gt; ）。 然后，我们为这些占位符分配值并执行该语句。 在第二个示例中，第一个数组元素转到第一个 &lt;code&gt;?&lt;/code&gt; 第二到第二 &lt;code&gt;?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51e69d1bd76f27cf149eed630feb3e8bbbe3e693" translate="yes" xml:space="preserve">
          <source>Insert and Update or Delete statements</source>
          <target state="translated">插入和更新或删除报表</target>
        </trans-unit>
        <trans-unit id="f6116d88666e16df0efbdad2df064412c9f30a13" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;mysql_num_rows&lt;/code&gt; to get the number of returned rows, you can get a &lt;code&gt;PDOStatement&lt;/code&gt; and do &lt;code&gt;rowCount()&lt;/code&gt;, like:</source>
          <target state="translated">您可以使用 &lt;code&gt;PDOStatement&lt;/code&gt; 并执行 &lt;code&gt;rowCount()&lt;/code&gt; ，而不是使用 &lt;code&gt;mysql_num_rows&lt;/code&gt; 来获取返回的行数，例如：</target>
        </trans-unit>
        <trans-unit id="2f4f5b358872d7afce164df88c9ed86e13417775" translate="yes" xml:space="preserve">
          <source>Is &lt;strong&gt;officially &lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;deprecated&lt;/a&gt;&lt;/strong&gt; as of PHP 5.5 (released June 2013).</source>
          <target state="translated">从PHP 5.5（2013年6月发布）开始&lt;strong&gt;正式&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation&quot;&gt;弃用&lt;/a&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="f27190c0d5f51b1ca6eb014f6b10e0503b10a2e9" translate="yes" xml:space="preserve">
          <source>Is not under active development</source>
          <target state="translated">不在积极开发中</target>
        </trans-unit>
        <trans-unit id="dcf8be11b129ed1d3fa675563db73c8506041b9b" translate="yes" xml:space="preserve">
          <source>It is only usable if you are using an old version of &lt;code&gt;MySQL&lt;/code&gt; which I do not recommended.</source>
          <target state="translated">仅当使用不建议使用的旧版本的 &lt;code&gt;MySQL&lt;/code&gt; 时才可用。</target>
        </trans-unit>
        <trans-unit id="5e9565aafd703c4317b924ba9cdbc3c14be98c98" translate="yes" xml:space="preserve">
          <source>It seems to me &lt;strong&gt;too idealistic&lt;/strong&gt; a dream that all those PHP users will learn how to handle SQL queries properly at once. Most likely they would just change mysql_* to mysqli_* mechanically, &lt;strong&gt;leaving the approach the same&lt;/strong&gt;. Especially because mysqli makes prepared statements usage incredible painful and troublesome.</source>
          <target state="translated">在我看来，所有那些PHP用户都将学习如何立即正确处理SQL查询&lt;strong&gt;实在是太理想化&lt;/strong&gt;的梦想。 很可能他们只是机械地将mysql_ *更改为mysqli_ *， &lt;strong&gt;而方法却保持不变&lt;/strong&gt; 。 尤其是因为mysqli使准备好的语句用法难以置信的痛苦和麻烦。</target>
        </trans-unit>
        <trans-unit id="ffe81de05696768d78038c224645412434af0ab5" translate="yes" xml:space="preserve">
          <source>It's best to start at simplifying again however. For example the common result fetching:</source>
          <target state="translated">不过,最好还是从简化再开始。比如说常见的结果取法。</target>
        </trans-unit>
        <trans-unit id="7bd40f368444a59ce546d97ec42b7235ad3f6390" translate="yes" xml:space="preserve">
          <source>It's mostly the &lt;em&gt;bound parameters&lt;/em&gt; which can simplify code. And with &lt;a href=&quot;https://stackoverflow.com/a/14110189&quot;&gt;excellent tutorials (as seen above)&lt;/a&gt; the transition to &lt;a href=&quot;http://php.net/PDO&quot;&gt;PDO&lt;/a&gt; isn't overly arduous.</source>
          <target state="translated">主要是可以简化代码的&lt;em&gt;绑定参数&lt;/em&gt; 。 而且，通过&lt;a href=&quot;https://stackoverflow.com/a/14110189&quot;&gt;出色的教程（如上所示）&lt;/a&gt; ，向&lt;a href=&quot;http://php.net/PDO&quot;&gt;PDO&lt;/a&gt;的过渡并不困难。</target>
        </trans-unit>
        <trans-unit id="48bb63e397a815a1d4028b30f85fed998e978b00" translate="yes" xml:space="preserve">
          <source>It's possible to define almost all &lt;code&gt;mysql_*&lt;/code&gt; functions using mysqli or PDO. Just include them on top of your old PHP application, and it will work on PHP7. My solution &lt;a href=&quot;https://github.com/sunhater/php7-mysql/blob/master/php7-mysql.php&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">可以使用mysqli或PDO定义几乎所有的 &lt;code&gt;mysql_*&lt;/code&gt; 函数。 只要将它们包括在您的旧PHP应用程序之上，它将在PHP7上运行。 我的解决方案&lt;a href=&quot;https://github.com/sunhater/php7-mysql/blob/master/php7-mysql.php&quot;&gt;在这里&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e54f725cef35b6c2a077269e4ced4587f8f5e96" translate="yes" xml:space="preserve">
          <source>Just don't escape a variable &lt;em&gt;and&lt;/em&gt; bind it in the same query.</source>
          <target state="translated">只是不要转义变量&lt;em&gt;并将其&lt;/em&gt;绑定到同一查询中。</target>
        </trans-unit>
        <trans-unit id="5cc04691e5722139d5540eb38b3f8fdedafc04b3" translate="yes" xml:space="preserve">
          <source>Just switching to &lt;a href=&quot;/questions/tagged/pdo&quot;&gt;pdo&lt;/a&gt; doesn't quite cut it. &lt;code&gt;pdo_query()&lt;/code&gt; is also just a frontend onto it.</source>
          <target state="translated">仅仅切换到&lt;a href=&quot;/questions/tagged/pdo&quot;&gt;pdo&lt;/a&gt;并不能完全消除它。 &lt;code&gt;pdo_query()&lt;/code&gt; 也是它的一个前端。</target>
        </trans-unit>
        <trans-unit id="66ec5c04732160bf6b782f5fc5a7fd3d0a54ffb2" translate="yes" xml:space="preserve">
          <source>Lack of support for prepared statements is particularly important as they provide a clearer, less error prone method of escaping and quoting external data than manually escaping it with a separate function call.</source>
          <target state="translated">缺少对准备好的语句的支持尤为重要,因为它们提供了一种更清晰、更不容易出错的转义和引用外部数据的方法,比起用单独的函数调用手动转义,更容易出错。</target>
        </trans-unit>
        <trans-unit id="ef74674a0032ecad5b46a45642e5b320f61a0320" translate="yes" xml:space="preserve">
          <source>Lack of support for prepared statements is particularly important as they provide a clearer, less error-prone method of escaping and quoting external data than manually escaping it with a separate function call.</source>
          <target state="translated">缺少对准备好的语句的支持尤为重要,因为它们提供了一种更清晰、更不容易出错的转义和引用外部数据的方法,比起用单独的函数调用手动转义,更容易出错。</target>
        </trans-unit>
        <trans-unit id="a5c76c162b06e13ac4bcdfd672e71bd3f45ca6a4" translate="yes" xml:space="preserve">
          <source>Lacks an OO interface</source>
          <target state="translated">缺乏OO接口</target>
        </trans-unit>
        <trans-unit id="f4466bc90729ac480010ac96a72f88b0375e70c8" translate="yes" xml:space="preserve">
          <source>Lacks an OO interface (to create one is a matter of several hours)</source>
          <target state="translated">缺乏OO界面(创建一个OO界面需要几个小时的时间</target>
        </trans-unit>
        <trans-unit id="1d16e278bd69ab650d0b2ca2923fa1b532adb204" translate="yes" xml:space="preserve">
          <source>Lastly, this isn't to say that this is PERFECT code. There are many more things that you could do to improve it, use hashed passwords for example, ensure that when you store sensetive information in the database, you don't store it in plain text, have multiple levels of verification - but really, if you just change your old injection prone code to this, you will be WELL along the way to writing good code - and the fact that you have gotten this far and are still reading gives me a sense of hope that you will not only implement this type of code when writing your websites and applications, but that you might go out and research those other things I just mentioned - and more. Write the best code you can, not the most basic code that barely functions.</source>
          <target state="translated">最后,这并不是说这是完美的代码。还有很多事情可以改进,比如说使用散列密码,确保在数据库中存储敏感信息时,不以纯文本存储,多级验证--但真的,如果你只是把你的旧的容易被注入的代码改成这样,你可以做很多事情来改进。你会在写好代码的道路上走得很好--而事实上,你已经走到了这一步,并且还在阅读,这让我有一种希望,希望你在写网站和应用程序的时候,不仅能实现这种类型的代码,而且你可能会去研究我刚才提到的其他事情--还有更多。写出你能写的最好的代码,而不是最基本的、勉强能发挥作用的代码。</target>
        </trans-unit>
        <trans-unit id="d94fac60f2ec2499ed53938148c85015abf6f2b1" translate="yes" xml:space="preserve">
          <source>Let's go through this, sentence by sentence, and explain:</source>
          <target state="translated">我们再来逐句解释一下。</target>
        </trans-unit>
        <trans-unit id="e754152995eed2c697af0b43150ac82ad5ccb3c4" translate="yes" xml:space="preserve">
          <source>Lets assume the following script is the verification process for an admin on a website (simplified but working if you copy and use it for testing):</source>
          <target state="translated">让我们假设下面的脚本是一个网站上的管理员的验证过程(简化了,但如果你复制并使用它进行测试的话,就可以工作)。</target>
        </trans-unit>
        <trans-unit id="a707aa190f760150c8ff8256bff3171e748227a0" translate="yes" xml:space="preserve">
          <source>Like:</source>
          <target state="translated">Like:</target>
        </trans-unit>
        <trans-unit id="b11d87a0679fc93bf95cfcb6a2752248f89d290e" translate="yes" xml:space="preserve">
          <source>Maybe I am too ignorant, but I never had an opportunity to use them things like</source>
          <target state="translated">也许是我太无知了,但我从来没有机会使用它们的东西,比如说</target>
        </trans-unit>
        <trans-unit id="17fe9ca6bbb425d8633e6b31c6b723df16a660db" translate="yes" xml:space="preserve">
          <source>More importantly you can pass $_REQUEST[] variables safely behind any query. When submitted &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; fields match the database structure exactly it's even shorter:</source>
          <target state="translated">更重要的是，您可以在任何查询后安全地传递$ _REQUEST []变量。 当提交的 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 字段与数据库结构完全匹配时，它甚至更短：</target>
        </trans-unit>
        <trans-unit id="f1587de204fa79f4a4783af5600a077de5317c2d" translate="yes" xml:space="preserve">
          <source>Most glaring bug here is the lack of documentation. More significantly the order of filtering was in exactly the wrong order.</source>
          <target state="translated">这里最明显的错误是缺少文档。更重要的是过滤的顺序完全错了。</target>
        </trans-unit>
        <trans-unit id="f92274be79830199dc63b7643aad05843b510053" translate="yes" xml:space="preserve">
          <source>Move your variables out of the SQL string.</source>
          <target state="translated">将你的变量从SQL字符串中移出。</target>
        </trans-unit>
        <trans-unit id="1bdcae0a8ea855d5e4a88cd02e009731df745843" translate="yes" xml:space="preserve">
          <source>Moving away from &lt;code&gt;ext/mysql&lt;/code&gt; is not only about security, but also about having access to all the features of the MySQL database.</source>
          <target state="translated">离开 &lt;code&gt;ext/mysql&lt;/code&gt; 不仅关系到安全性，而且关系到访问MySQL数据库的所有功能。</target>
        </trans-unit>
        <trans-unit id="e35ac0203a1fef2dcb5b1881363e036ecd70d1e9" translate="yes" xml:space="preserve">
          <source>Multiple Statements</source>
          <target state="translated">多项声明</target>
        </trans-unit>
        <trans-unit id="c49860262ec681368ccb9bcf9cb9facc422187d7" translate="yes" xml:space="preserve">
          <source>MySQL deprecated in PHP 5.5.0, and removed in PHP 7.0.0. For a large and old application, this is difficult to search and replace each function.</source>
          <target state="translated">MySQL在PHP5.5.5.0中已被禁用,在PHP7.0.0中删除。对于一个庞大而老旧的应用程序来说,这对每个功能的搜索和替换都有一定的难度。</target>
        </trans-unit>
        <trans-unit id="e8bb7548ab9b8605aff82c9f2282425a263a1641" translate="yes" xml:space="preserve">
          <source>Nevertheless, everyone talking about extensions always missing the &lt;strong&gt;2 important facts&lt;/strong&gt; about Mysqli and PDO:</source>
          <target state="translated">但是，每个谈论扩展的人都始终缺少关于Mysqli和PDO的&lt;strong&gt;两个重要事实&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="7d2fa77f8c62d7e4e20bf83f1d23da735eceaaeb" translate="yes" xml:space="preserve">
          <source>Newer! ext/mysql &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7&quot;&gt;has been removed in PHP 7&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">较新！ ext / mysql &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7&quot;&gt;已在PHP 7中删除&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="685d76edff92343d24a20b8ec69b6efaff99726a" translate="yes" xml:space="preserve">
          <source>Non-blocking, asynchronous queries</source>
          <target state="translated">非阻塞、异步查询</target>
        </trans-unit>
        <trans-unit id="68345c1292e1cc90d4f880a94c3bca3d035eaeb2" translate="yes" xml:space="preserve">
          <source>Not to mention that &lt;em&gt;native&lt;/em&gt; prepared statements &lt;strong&gt;aren't enough to protect&lt;/strong&gt; from SQL injections, and neither mysqli nor PDO offers a solution.</source>
          <target state="translated">更不用说&lt;em&gt;本地&lt;/em&gt;预备语句&lt;strong&gt;不足以防止&lt;/strong&gt; SQL注入，而且mysqli和PDO都不提供解决方案。</target>
        </trans-unit>
        <trans-unit id="c63f37e1f56dcfbabca1e890130ce1ea2da2597c" translate="yes" xml:space="preserve">
          <source>Not under active development</source>
          <target state="translated">不在积极开发中</target>
        </trans-unit>
        <trans-unit id="943cf0ecd5faca4611853075578258bc2002ba56" translate="yes" xml:space="preserve">
          <source>Not under active development (so what? does it affect &lt;em&gt;you&lt;/em&gt; in any practical way?)</source>
          <target state="translated">不在积极的开发下（那又是什么呢？它会以任何实际方式影响&lt;em&gt;您&lt;/em&gt;吗？）</target>
        </trans-unit>
        <trans-unit id="bb2ac3999c57f46e2bd9758251dbcf1d84afb4d6" translate="yes" xml:space="preserve">
          <source>Note that this will also hide &lt;strong&gt;other deprecation warnings&lt;/strong&gt;, which, however, may be for things other than MySQL. (&lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation#workarounds&quot;&gt;from PHP manual&lt;/a&gt;&lt;/em&gt;)</source>
          <target state="translated">请注意，这还会隐藏&lt;strong&gt;其他弃用警告&lt;/strong&gt; ，但是，这可能是针对MySQL以外的内容的。 （ &lt;em&gt;&lt;a href=&quot;https://wiki.php.net/rfc/mysql_deprecation#workarounds&quot;&gt;摘自PHP手册&lt;/a&gt;&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="bda5dde931c8e24b349d67e7a7b806e98b96812c" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;PDO::FETCH_ASSOC&lt;/code&gt; in the &lt;code&gt;fetch()&lt;/code&gt; and &lt;code&gt;fetchAll()&lt;/code&gt; code above. This tells &lt;code&gt;PDO&lt;/code&gt; to return the rows as an associative array with the field names as keys. There are many other fetch modes too which I will explain one by one.</source>
          <target state="translated">注意上面的 &lt;code&gt;fetch()&lt;/code&gt; 和 &lt;code&gt;fetchAll()&lt;/code&gt; 代码中 &lt;code&gt;PDO::FETCH_ASSOC&lt;/code&gt; 的使用。 这告诉 &lt;code&gt;PDO&lt;/code&gt; 将行作为关联数组（以字段名称作为键）返回。 我也将一一解释其他许多提取模式。</target>
        </trans-unit>
        <trans-unit id="390aff0245fd3f60ed591a199d4ab419c07a3c3d" translate="yes" xml:space="preserve">
          <source>Now I come to fetch mode:</source>
          <target state="translated">现在,我来到了取货模式。</target>
        </trans-unit>
        <trans-unit id="df9f2bb47f2f3240e6cc68b55730527bb6d13c2e" translate="yes" xml:space="preserve">
          <source>Now in &lt;code&gt;PDO&lt;/code&gt;, you can do this like:</source>
          <target state="translated">现在在 &lt;code&gt;PDO&lt;/code&gt; 中 ，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="f01b36c532e5c2589a140fa7f84b5b0a69b50379" translate="yes" xml:space="preserve">
          <source>Now it's time to actually &lt;em&gt;utilize&lt;/em&gt; it.</source>
          <target state="translated">现在是时候实际&lt;em&gt;使用&lt;/em&gt;它了。</target>
        </trans-unit>
        <trans-unit id="af4e1cd344ecad42d4d3ae20475ecfd47bd9b08f" translate="yes" xml:space="preserve">
          <source>Now, after reading all the things above, you are probably thinking: what the heck is that when I just want to start leaning simple &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt;, or &lt;code&gt;DELETE&lt;/code&gt; statements? Don't worry, here we go:</source>
          <target state="translated">现在，在阅读完以上所有内容之后，您可能会想：当我只想开始使用简单的 &lt;code&gt;SELECT&lt;/code&gt; ， &lt;code&gt;INSERT&lt;/code&gt; ， &lt;code&gt;UPDATE&lt;/code&gt; 或 &lt;code&gt;DELETE&lt;/code&gt; 语句时，这到底是什么？ 不用担心，我们开始：</target>
        </trans-unit>
        <trans-unit id="bb447931ebe2bec10f8d27c32d8b085d4929ad94" translate="yes" xml:space="preserve">
          <source>Now, lets have a look at that code again, this time written using a PDO object:</source>
          <target state="translated">现在,我们再来看看那段代码,这次是用PDO对象写的。</target>
        </trans-unit>
        <trans-unit id="d95a06cc3375c57a4fb46a5611bf33dc0eac0163" translate="yes" xml:space="preserve">
          <source>Now, lets try the data that a clever chap would enter to try to get past our little verification system:</source>
          <target state="translated">现在,让我们来试试聪明的小伙伴会输入的数据,试图通过我们的小验证系统。</target>
        </trans-unit>
        <trans-unit id="c56d47755ee1354ee2f207be52265612e2153d71" translate="yes" xml:space="preserve">
          <source>Now, you have the better options of using &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;mysqli_&lt;/a&gt; or &lt;a href=&quot;http://www.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt;. I am personally a big fan of PDO, so I will be using PDO in the rest of this answer. There are pro's and con's, but personally I find that the pro's far outweigh the con's. It's portable across multiple database engines - whether you are using MySQL or Oracle or just about bloody anything - just by changing the connection string, it has all the fancy features we want to use and it is nice and clean. I like clean.</source>
          <target state="translated">现在，您可以使用&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;mysqli_&lt;/a&gt;或&lt;a href=&quot;http://www.php.net/manual/en/book.pdo.php&quot;&gt;PDO&lt;/a&gt;更好的选择。 我个人是PDO的忠实拥护者，因此在本答案的其余部分中，我将使用PDO。 有优点和缺点，但我个人发现，优点远远超过缺点。 它可以跨多个数据库引擎移植-无论您使用的是MySQL还是Oracle，或者几乎是血腥的任何事物-只需更改连接字符串，它就具有我们要使用的所有精美功能，而且非常干净。 我喜欢干净。</target>
        </trans-unit>
        <trans-unit id="b4df376bcf338aaf237cc2ceb55bc64301fbe1d9" translate="yes" xml:space="preserve">
          <source>Object-oriented interface</source>
          <target state="translated">面向对象接口</target>
        </trans-unit>
        <trans-unit id="79f9618f1912184bc89ea96846cec252f2b5b111" translate="yes" xml:space="preserve">
          <source>Often string variables aren't just interpolated into SQL, but concatenated with escaping calls in between.</source>
          <target state="translated">通常情况下,字符串变量并不只是插值到SQL中,而是在这两者之间用转义调用来串联。</target>
        </trans-unit>
        <trans-unit id="0842d63b94cdae1d97ca5df8b49fbf2cefb344db" translate="yes" xml:space="preserve">
          <source>Oh, I just got a little excited, it worked: The check passed. We have a verified admin!</source>
          <target state="translated">哦,我只是有些激动,成功了。检查通过了。我们有一个验证过的管理员!</target>
        </trans-unit>
        <trans-unit id="94c3dc399cf5b64e36b7c400dadceac39bc77b5b" translate="yes" xml:space="preserve">
          <source>Okay, so what went wrong, and how can we fix it?</source>
          <target state="translated">好吧,那么是什么地方出了问题,我们该怎么解决呢?</target>
        </trans-unit>
        <trans-unit id="e33efcc54426fd4f64d01de7305ceab6f21b294b" translate="yes" xml:space="preserve">
          <source>Once you have converted all &lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt; calls to &lt;code&gt;pdo_query&lt;/code&gt; with bound params, remove all redundant &lt;code&gt;pdo_real_escape_string&lt;/code&gt; calls.</source>
          <target state="translated">将所有&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt;调用转换为带有绑定参数的 &lt;code&gt;pdo_query&lt;/code&gt; 后 ，请删除所有冗余的 &lt;code&gt;pdo_real_escape_string&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="dccb816213ce63a2edee44cd16d1bf786620eda9" translate="yes" xml:space="preserve">
          <source>Or better yet a direct and complete array retrieval:</source>
          <target state="translated">或者更好的是直接完整的阵列检索。</target>
        </trans-unit>
        <trans-unit id="d291165f3e48fa04de2df661e5577d3237e36a86" translate="yes" xml:space="preserve">
          <source>Other options</source>
          <target state="translated">其他选择</target>
        </trans-unit>
        <trans-unit id="80c9afff3fc6e7a45d3cc8c0ba82a6e36345cadc" translate="yes" xml:space="preserve">
          <source>PHP offers three different APIs to connect to MySQL. These are the &lt;a href=&quot;http://in1.php.net/manual/en/book.mysql.php&quot;&gt;&lt;code&gt;mysql&lt;/code&gt;&lt;/a&gt;(removed as of PHP 7), &lt;a href=&quot;http://uk.php.net/manual/en/book.mysqli.php&quot;&gt;&lt;code&gt;mysqli&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;&lt;code&gt;PDO&lt;/code&gt;&lt;/a&gt; extensions.</source>
          <target state="translated">PHP提供了三种不同的API连接到MySQL。 这些是&lt;a href=&quot;http://in1.php.net/manual/en/book.mysql.php&quot;&gt; &lt;code&gt;mysql&lt;/code&gt; &lt;/a&gt; （从PHP 7开始删除）， &lt;a href=&quot;http://uk.php.net/manual/en/book.mysqli.php&quot;&gt; &lt;code&gt;mysqli&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt; &lt;code&gt;PDO&lt;/code&gt; &lt;/a&gt;扩展。</target>
        </trans-unit>
        <trans-unit id="66b1f6ccb868a51c719c54211a58306d2ce6458b" translate="yes" xml:space="preserve">
          <source>Place question marks &lt;code&gt;?&lt;/code&gt; as placeholders where the variables were before.</source>
          <target state="translated">放置问号 &lt;code&gt;?&lt;/code&gt; 作为变量之前的占位符。</target>
        </trans-unit>
        <trans-unit id="7478e01a69a59cf96a526ecfcd34a76707511615" translate="yes" xml:space="preserve">
          <source>Prepared statement &lt;strong&gt;isn't a silver bullet&lt;/strong&gt;. There are dynamical identifiers which cannot be bound using prepared statements. There are dynamical queries with an unknown number of parameters which makes query building a difficult task.</source>
          <target state="translated">准备好的声明&lt;strong&gt;不是万灵丹&lt;/strong&gt; 。 有些动态标识符无法使用准备好的语句进行绑定。 有些动态查询带有未知数量的参数，这使查询构建变得困难。</target>
        </trans-unit>
        <trans-unit id="88e0e0a0df815f954f20830db35becc23bd2fb02" translate="yes" xml:space="preserve">
          <source>Prepared statements</source>
          <target state="translated">准备好的报表</target>
        </trans-unit>
        <trans-unit id="0b0459e39e775d8d016c9a1b7d9fbb9cf8ae780b" translate="yes" xml:space="preserve">
          <source>Q. First question in my mind was: what is `PDO`?</source>
          <target state="translated">Q.我心中的第一个问题是:什么是 &quot;PDO&quot;?</target>
        </trans-unit>
        <trans-unit id="cb0e0b93a85516a6c4a7283d442e3274fb701224" translate="yes" xml:space="preserve">
          <source>Remember that pdo_* still allows &lt;em&gt;either or&lt;/em&gt;.</source>
          <target state="translated">请记住，pdo_ *仍然允许&lt;em&gt;或&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e04ee6f5fe2cec54a2d0b8c7a1e5d97c3761798" translate="yes" xml:space="preserve">
          <source>Remove the &lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt; function prefix &lt;em&gt;everywhere&lt;/em&gt; and replace it with &lt;strong&gt;&lt;code&gt;pdo_&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">删除&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt;函数前缀&lt;em&gt;，&lt;/em&gt;并用&lt;strong&gt; &lt;code&gt;pdo_&lt;/code&gt; &lt;/strong&gt;替换它。</target>
        </trans-unit>
        <trans-unit id="6e950042d73e706574ab836f1c73abbaeaec437a" translate="yes" xml:space="preserve">
          <source>Removed as of PHP 7</source>
          <target state="translated">从 PHP 7 起删除</target>
        </trans-unit>
        <trans-unit id="f71536fa3d10e36d63218592cefa79677819294b" translate="yes" xml:space="preserve">
          <source>Rewriting a larger code base at once however takes time. Raison d'&amp;ecirc;tre for this intermediate alternative:</source>
          <target state="translated">但是，立即重写较大的代码库需要花费时间。 Raison d'&amp;ecirc;tre这个中间替代方案：</target>
        </trans-unit>
        <trans-unit id="b7b089287c11c303c7e28345b34bb09873f7b3e2" translate="yes" xml:space="preserve">
          <source>Rewriting doesn't have to stop at using the new pdo_ function names. You could one by one transition each pdo_query() into a plain $pdo-&amp;gt;prepare()-&amp;gt;execute() call.</source>
          <target state="translated">重写并不仅限于使用新的pdo_函数名称。 您可以将每个pdo_query（）逐个转换为普通的$ pdo-&amp;gt; prepare（）-&amp;gt; execute（）调用。</target>
        </trans-unit>
        <trans-unit id="d18471042a4567ba79deea1a219d4a26d8d8459a" translate="yes" xml:space="preserve">
          <source>SQL injections simply are when &lt;em&gt;data bleeds into code&lt;/em&gt; context. A database server can't later spot where PHP originally glued variables inbetween query clauses.</source>
          <target state="translated">SQL注入只是在&lt;em&gt;数据渗入代码&lt;/em&gt;上下文时发生。 数据库服务器以后无法发现PHP最初将变量粘贴在查询子句之间的位置。</target>
        </trans-unit>
        <trans-unit id="e665bf1f2a0279913bf81f45ec5a5c78ea174425" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://bobby-tables.com/&quot;&gt;bobby-tables.com&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;http://bobby-tables.com/&quot;&gt;bobby-tables.com&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="5434d7a025004202b6c9d1ef189773a1aad44220" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;&lt;strong&gt;the comparison of SQL extensions&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">请参见&lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;&lt;strong&gt;SQL扩展的比较&lt;/strong&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7489fd89c972450ae2f6ec9bf321744a53fac8d8" translate="yes" xml:space="preserve">
          <source>See how I constructed my &quot;password&quot; so that it would first close the single quote around the password, then introduce a completely new comparison? Then just for safety, I added another &quot;string&quot; so that the single quote would get closed as expected in the code we originally had.</source>
          <target state="translated">你看我是如何构造我的 &quot;password &quot;的,这样它就会先关闭密码周围的单引号,然后引入一个全新的比较?然后,为了安全起见,我又添加了一个 &quot;字符串&quot;,这样一来,单引号就会像我们最初的代码中预期的那样被关闭。</target>
        </trans-unit>
        <trans-unit id="55506229592fa23e7b5870b9dc6c5aa7e1583634" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;comparison of SQL extensions&lt;/a&gt;.</source>
          <target state="translated">请参见&lt;a href=&quot;http://php.net/manual/en/mysqlinfo.api.choosing.php&quot;&gt;SQL扩展&lt;/a&gt;的比较 。</target>
        </trans-unit>
        <trans-unit id="8332ef556cea9f1f40a6c76849dace653964c7a0" translate="yes" xml:space="preserve">
          <source>Seems legit enough at first glance.</source>
          <target state="translated">乍一看似乎足够合法。</target>
        </trans-unit>
        <trans-unit id="af912eddd3068889909f441f05cc66e7d588440d" translate="yes" xml:space="preserve">
          <source>Selecting Data</source>
          <target state="translated">选择数据</target>
        </trans-unit>
        <trans-unit id="418dc8b027c0175bc948e9cbb66d6a25f398bcb1" translate="yes" xml:space="preserve">
          <source>Simply &lt;code&gt;include_once(&lt;/code&gt;&lt;a href=&quot;http://fossil.include-once.org/upgradephp/artifact/43ab742241e5a3be43d31764dd333ba68e245360&quot;&gt;&lt;code&gt;&quot;pdo_mysql.php&quot;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;);&lt;/code&gt; in each invocation script that has to interact with the database.</source>
          <target state="translated">只需 &lt;code&gt;include_once(&lt;/code&gt; &lt;a href=&quot;http://fossil.include-once.org/upgradephp/artifact/43ab742241e5a3be43d31764dd333ba68e245360&quot;&gt; &lt;code&gt;&quot;pdo_mysql.php&quot;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;);&lt;/code&gt; 在每个必须与数据库进行交互的调用脚本中。</target>
        </trans-unit>
        <trans-unit id="da5002da9abdeebe9fb4cab82878e2462cde36fb" translate="yes" xml:space="preserve">
          <source>Since it is deprecated, using it makes your code less future proof.</source>
          <target state="translated">因为它已经被淘汰了,所以使用它会让你的代码没有那么多的未来感。</target>
        </trans-unit>
        <trans-unit id="181dff808d342cf7f9e72760d9c8e79ed94e35e7" translate="yes" xml:space="preserve">
          <source>So much simplicity. But let's get back to some more rewriting advises and technical reasons on why you may want to get rid of &lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt; and escaping.</source>
          <target state="translated">非常简单。 但是，让我们回到一些重写建议和技术原因上，以了解为什么您可能想要摆脱&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt;和转义。</target>
        </trans-unit>
        <trans-unit id="0e06bdf278d741a7d2afe7a65871fe0c7c71210f" translate="yes" xml:space="preserve">
          <source>So this hopefully visualized some &lt;em&gt;practical&lt;/em&gt; reasons and a worthwile pathway to drop &lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;.</source>
          <target state="translated">因此，这有希望地显示出一些&lt;em&gt;实际的&lt;/em&gt;原因以及删除&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; 的一条有价值的&lt;/s&gt;途径。</target>
        </trans-unit>
        <trans-unit id="3012707c2195366927599a0dd74ecf1430c805f0" translate="yes" xml:space="preserve">
          <source>So what you are doing in &lt;code&gt;mysql_*&lt;/code&gt; is:</source>
          <target state="translated">因此，您在 &lt;code&gt;mysql_*&lt;/code&gt; 中所做的是：</target>
        </trans-unit>
        <trans-unit id="502276f58db137875cfb6cf92bfa59236b8263ac" translate="yes" xml:space="preserve">
          <source>So, I wrote solutions for all the common pitfalls and complex cases in the &lt;a href=&quot;https://stackoverflow.com/tags/pdo/info&quot;&gt;&lt;strong&gt;PDO tag wiki&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">因此，我在&lt;a href=&quot;https://stackoverflow.com/tags/pdo/info&quot;&gt;&lt;strong&gt;PDO标签Wiki中&lt;/strong&gt;&lt;/a&gt;针对所有常见陷阱和复杂案例编写了解决方案</target>
        </trans-unit>
        <trans-unit id="72d2f3bbb78bd884d0b025adc79a648f2da15e63" translate="yes" xml:space="preserve">
          <source>So, how do we protect your sacred admin section and make it nice and secure? The first thing to do will be to stop using those really old and deprecated &lt;code&gt;mysql_*&lt;/code&gt; functions. I know, you followed a tutorial you found online and it works, but it's old, it's outdated and in the space of a few minutes, I have just broken past it without so much as breaking a sweat.</source>
          <target state="translated">那么，我们如何保护您的神圣管理部分并使它变得美观和安全？ 首先要做的是停止使用那些真正过时且已过时的 &lt;code&gt;mysql_*&lt;/code&gt; 函数。 我知道，您遵循了在网上找到的教程并且可以使用，但是它很旧，已经过时了，在几分钟的时间内，我刚刚摆脱了它，却丝毫不费吹灰之力。</target>
        </trans-unit>
        <trans-unit id="156ae2c1a681018477e990b03ebe020a3aacb23e" translate="yes" xml:space="preserve">
          <source>So, if you are an average PHP user and want to save yourself a ton of headaches when using native prepared statements, PDO - again - is the only choice.</source>
          <target state="translated">所以,如果你是一个普通的PHP用户,并且想在使用原生准备好的语句时省去很多麻烦,那么PDO----同样是唯一的选择。</target>
        </trans-unit>
        <trans-unit id="09bd59ae9fef4f113a6fb3d96fee1aae3a9fb79f" translate="yes" xml:space="preserve">
          <source>So, in answer, THAT IS WHY YOU ARE BEING YELLED AT.</source>
          <target state="translated">所以,作为回答,这就是你被人骂的原因。</target>
        </trans-unit>
        <trans-unit id="4586573c065a2c5d5186ace73cde0c4532012c55" translate="yes" xml:space="preserve">
          <source>So, instead of fighting this honest extension, I'd prefer to fight wrong practices and educate people in the right ways.</source>
          <target state="translated">所以,与其跟这种老实的外延抗争,还不如用正确的方法来对抗错误的做法,教育人。</target>
        </trans-unit>
        <trans-unit id="977784c6079621feedaf15de1c0e69f13959d921" translate="yes" xml:space="preserve">
          <source>So, just switching to PDO or mysqli is not enough. One has to use an ORM, or a query builder, or whatever database abstraction class instead of calling raw API functions in their code.</source>
          <target state="translated">所以,仅仅切换到PDO或mysqli是不够的。一个人必须使用ORM,或者查询构建器,或者其他数据库抽象类,而不是在代码中调用原始API函数。</target>
        </trans-unit>
        <trans-unit id="6a4c25a013fc181e44690a0c81f43ed6d49a2760" translate="yes" xml:space="preserve">
          <source>So, lets have a look at what went wrong, and why I just got into your super-admin-only-bat-cave. I took a guess and assumed that you weren't being careful with your inputs and simply passed them to the database directly. I constructed the input in a way tht would CHANGE the query that you were actually running. So, what was it supposed to be, and what did it end up being?</source>
          <target state="translated">那么,我们来看看到底出了什么问题,以及为什么我刚刚进了你的超级admin-only-bat洞。我猜测了一下,假设你在输入时不小心,直接把它们传给了数据库。我构造输入的方式是改变了你实际运行的查询。那么,它应该是什么,最后又是什么呢?</target>
        </trans-unit>
        <trans-unit id="419b0e23c522675ea4d8d7c937461eb95377a4fe" translate="yes" xml:space="preserve">
          <source>So, once more - it is not just raw driver should be your concern but abstraction class, useful not only for silly examples from beginner's manual but to solve whatever real-life problems.</source>
          <target state="translated">所以,再来一次--你应该关注的不仅仅是原始驱动,而是抽象类的,它的用处不仅仅是初学者手册中的傻瓜式的例子,而是解决实际生活中的任何问题。</target>
        </trans-unit>
        <trans-unit id="8cf0be74cb1010c94f25e5fc839c648278844902" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;http://us2.php.net/manual/en/mysqli.overview.php&quot;&gt;MySQLi overview&lt;/a&gt;</source>
          <target state="translated">资料来源： &lt;a href=&quot;http://us2.php.net/manual/en/mysqli.overview.php&quot;&gt;MySQLi概述&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcb447d1aaebb249a35efcda9785a596a7569ba1" translate="yes" xml:space="preserve">
          <source>Speaking of &lt;em&gt;technical&lt;/em&gt; reasons, there are only a few, extremely specific and rarely used. Most likely you will never ever use them in your life.</source>
          <target state="translated">说到&lt;em&gt;技术&lt;/em&gt;原因，只有少数几个非常具体且很少使用。 您很可能永远都不会使用它们。</target>
        </trans-unit>
        <trans-unit id="bf36b631054e4b9ebdd95cb1972bb398da13213f" translate="yes" xml:space="preserve">
          <source>Stored procedures</source>
          <target state="translated">储存程序</target>
        </trans-unit>
        <trans-unit id="43f21f37b385b47e7aca36f912842875218a10aa" translate="yes" xml:space="preserve">
          <source>String/value handling is delegated to PDO and its parameterized statements.</source>
          <target state="translated">字符串值处理被委托给PDO及其参数化语句。</target>
        </trans-unit>
        <trans-unit id="f330726eae49c3e09ec43d61637f5396a5a55745" translate="yes" xml:space="preserve">
          <source>Super! Working as expected, now lets try the actual username and password:</source>
          <target state="translated">超级棒!如预期的那样工作,现在让我们试试实际的用户名和密码。</target>
        </trans-unit>
        <trans-unit id="dfadaca1a30bce993f932dca13aff0957793e885" translate="yes" xml:space="preserve">
          <source>Support for Multiple Statements</source>
          <target state="translated">支持多重声明</target>
        </trans-unit>
        <trans-unit id="2142d72824641e7c7d357d78453232623a4fd7ff" translate="yes" xml:space="preserve">
          <source>Support for Prepared Statements</source>
          <target state="translated">对已编制的报表的支持</target>
        </trans-unit>
        <trans-unit id="1051e4c201c5f65414e7b143a72570669fd228ca" translate="yes" xml:space="preserve">
          <source>Support for Transactions</source>
          <target state="translated">对交易的支持</target>
        </trans-unit>
        <trans-unit id="aa4d81fe71bb245630f293271255fef6e35bbfad" translate="yes" xml:space="preserve">
          <source>That was commonly there to undo damage (double escaping) from the deprecated &lt;a href=&quot;http://php.net/magic_quotes&quot;&gt;&lt;code&gt;magic_quotes&lt;/code&gt;&lt;/a&gt;. Which however is &lt;a href=&quot;https://stackoverflow.com/questions/517008/how-to-turn-off-magic-quotes-on-shared-hosting&quot;&gt;best fixed centrally&lt;/a&gt;, not string by string.</source>
          <target state="translated">这通常是为了消除已弃用的&lt;a href=&quot;http://php.net/magic_quotes&quot;&gt; &lt;code&gt;magic_quotes&lt;/code&gt; &lt;/a&gt;造成的损害（两次转义）。 然而， &lt;a href=&quot;https://stackoverflow.com/questions/517008/how-to-turn-off-magic-quotes-on-shared-hosting&quot;&gt;最好&lt;/a&gt;是集中固定 ，而不是一串一串地固定 。</target>
        </trans-unit>
        <trans-unit id="34467e1287edc5b797be2730e35c61969473a83f" translate="yes" xml:space="preserve">
          <source>That's the query, but when we replace the variables with the actual inputs that we used, we get the following:</source>
          <target state="translated">这就是查询,但当我们用实际输入的变量替换为实际输入时,我们得到的结果如下。</target>
        </trans-unit>
        <trans-unit id="e35c0916a18283d4ea1f81a70d61efa106dd1b1f" translate="yes" xml:space="preserve">
          <source>The &quot;new&quot; password authentication method (on by default in MySQL 5.6; required in 5.7)</source>
          <target state="translated">新 &quot;密码验证方法(在MySQL 5.6中默认开启;在5.7中需要</target>
        </trans-unit>
        <trans-unit id="a8deffdde633f6dcdac49482f5db747ce9e171b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mysql_*&lt;/code&gt; functions used to be very popular, but their use is not encouraged anymore. The documentation team is discussing the database security situation, and educating users to move away from the commonly used ext/mysql extension is part of this (check &lt;em&gt;&lt;a href=&quot;http://news.php.net/php.internals/53799&quot;&gt;php.internals: deprecating ext/mysql&lt;/a&gt;&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;mysql_*&lt;/code&gt; 函数曾经很流行，但是不再鼓励使用它们。 文档团队正在讨论数据库安全状况，并且教育用户远离常用的ext / mysql扩展是其中一部分（请检查&lt;em&gt;&lt;a href=&quot;http://news.php.net/php.internals/53799&quot;&gt;php.internals：不赞成使用ext / mysql&lt;/a&gt;&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d67db1d2a3f9c279e59ee7cbab7e7ad484b23610" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mysql_&lt;/code&gt; functions:</source>
          <target state="translated">&lt;code&gt;mysql_&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="8555deeb46964ebda4fb022ebe48c5e2ada84f62" translate="yes" xml:space="preserve">
          <source>The DBMS parses, compiles, and performs query optimization on the statement template, and stores the result without executing it.</source>
          <target state="translated">DBMS对语句模板进行解析、编译,并对语句模板进行查询优化,并在不执行的情况下存储结果。</target>
        </trans-unit>
        <trans-unit id="23a504e237cda5d5bd1d5d68ab647b0abc87ece7" translate="yes" xml:space="preserve">
          <source>The MySQL extension is the oldest of the three and was the original way that developers used to communicate with MySQL. This extension is now being &lt;a href=&quot;http://php.net/manual/en/migration55.deprecated.php&quot;&gt;deprecated&lt;/a&gt; in favor of the other &lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;two&lt;/a&gt;&lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;alternatives&lt;/a&gt; because of improvements made in newer releases of both PHP and MySQL.</source>
          <target state="translated">MySQL扩展是这三个中最古老的扩展，是开发人员用来与MySQL通信的原始方式。 由于PHP和MySQL的新版本中进行了改进，因此&lt;a href=&quot;http://php.net/manual/en/migration55.deprecated.php&quot;&gt;不建议使用&lt;/a&gt;此扩展，而推荐使用其他&lt;a href=&quot;http://php.net/manual/en/book.mysqli.php&quot;&gt;两个&lt;/a&gt; &lt;a href=&quot;http://php.net/manual/en/book.pdo.php&quot;&gt;替代方法&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8a41f267bbe8e8e99d77e3f59457faa0a4e2d32" translate="yes" xml:space="preserve">
          <source>The MySQL extension:</source>
          <target state="translated">的MySQL扩展。</target>
        </trans-unit>
        <trans-unit id="21414d4d700662c909aebc645c1a9d88f9c8e575" translate="yes" xml:space="preserve">
          <source>The PDOException class &amp;para;</source>
          <target state="translated">PDOException类</target>
        </trans-unit>
        <trans-unit id="ceaa748e73e903659c37e91ec7bc481b4aba692e" translate="yes" xml:space="preserve">
          <source>The above method is only useful when you are not using variable in query. But when you need to use a variable in a query, do not ever ever try like the above and there for  &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;strong&gt;prepared statement or parameterized statement&lt;/strong&gt;&lt;/a&gt; is.</source>
          <target state="translated">仅当您在查询中不使用变量时，以上方法才有用。 但是，当您需要在查询中使用变量时，请不要尝试像上面那样进行操作，那里有&lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;strong&gt;预处理语句或参数化语句&lt;/strong&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b16db0ed6b33fd376c4271f150426eeb37d5407a" translate="yes" xml:space="preserve">
          <source>The advantage becomes more obvious for lengthier code.</source>
          <target state="translated">对于较长的代码,优势变得更加明显。</target>
        </trans-unit>
        <trans-unit id="5a186859a541d2250d60b00b21cdf3c3b63312a9" translate="yes" xml:space="preserve">
          <source>The analytic and synthetic reasons were already mentioned. For newcomers there's a more significant incentive to stop using the dated mysql_ functions.</source>
          <target state="translated">分析和合成的原因已经提到了。对于新手来说,停止使用过时的mysql_函数还有一个更重要的动力。</target>
        </trans-unit>
        <trans-unit id="27bb7e6155e751876dec5eb5272f609fe02b5ef0" translate="yes" xml:space="preserve">
          <source>The article &lt;em&gt;&lt;a href=&quot;http://net.tutsplus.com/tutorials/php/pdo-vs-mysqli-which-should-you-use/&quot;&gt;PDO vs. MySQLi: Which Should You Use?&lt;/a&gt;&lt;/em&gt; by &lt;a href=&quot;http://webarto.com/&quot;&gt;&lt;strong&gt;Dejan Marjanovic&lt;/strong&gt;&lt;/a&gt; will help you to choose.</source>
          <target state="translated">文章&lt;em&gt;&lt;a href=&quot;http://net.tutsplus.com/tutorials/php/pdo-vs-mysqli-which-should-you-use/&quot;&gt;PDO与MySQLi：您应该使用哪个？&lt;/a&gt;&lt;/em&gt; &lt;a href=&quot;http://webarto.com/&quot;&gt;&lt;strong&gt;Dejan Marjanovic撰写的文章&lt;/strong&gt;&lt;/a&gt;将帮助您选择。</target>
        </trans-unit>
        <trans-unit id="99a09cf05588a6ee72d21881c364b7fa6b57bb3e" translate="yes" xml:space="preserve">
          <source>The functions which are as similar to this &lt;code&gt;mysql_connect()&lt;/code&gt;, &lt;code&gt;mysql_query()&lt;/code&gt; type are the previous version PHP i.e(PHP 4) functions and now not in use .</source>
          <target state="translated">类似于此 &lt;code&gt;mysql_connect()&lt;/code&gt; 和 &lt;code&gt;mysql_query()&lt;/code&gt; 类型的函数是以前版本的PHP ie（PHP 4）函数，现在未使用。</target>
        </trans-unit>
        <trans-unit id="4abbb603d8f2b2afd3d6309a44e29670822a32ff" translate="yes" xml:space="preserve">
          <source>The last one is an interesting point. Although mysql ext do not support &lt;em&gt;native&lt;/em&gt; prepared statements, they aren't required for the safety. We can easily fake prepared statements using manually handled placeholders (just like PDO does):</source>
          <target state="translated">最后一点很有趣。 尽管mysql ext不支持&lt;em&gt;本机&lt;/em&gt;预处理语句，但出于安全考虑，它们不是必需的。 我们可以使用手动处理的占位符轻松伪造准备好的语句（就像PDO一样）：</target>
        </trans-unit>
        <trans-unit id="2dada7706eedc4cc1377e36d4ff7b1cba1c73978" translate="yes" xml:space="preserve">
          <source>The major differences are that there are no more &lt;code&gt;mysql_*&lt;/code&gt; functions. It's all done via a PDO object, secondly, it is using a prepared statement. Now, what's a prepred statement you ask? It's a way to tell the database ahead of running a query, what the query is that we are going to run. In this case, we tell the database: &quot;Hi, I am going to run a select statement wanting id, userid and pass from the table users where the userid is a variable and the pass is also a variable.&quot;.</source>
          <target state="translated">主要区别在于不再有 &lt;code&gt;mysql_*&lt;/code&gt; 函数。 所有这些都是通过PDO对象完成的，其次，它使用的是准备好的语句。 现在，您要问什么预先准备好的陈述？ 这是在运行查询之前告诉数据库我们将要运行的查询的一种方式。 在这种情况下，我们告诉数据库：&amp;ldquo;嗨，我要运行一条选择ID，用户ID并从表用户传递的选择语句，其中用户ID是变量，传递也是变量。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="2dccd3b2ef63bf7cb2dcdbff4e9bf66af2258b71" translate="yes" xml:space="preserve">
          <source>The mysqli extension has a number of
  benefits, the key enhancements over
  the mysql extension being:</source>
          <target state="translated">mysqli扩展有很多好处,相对于mysql扩展来说,主要增强的是。</target>
        </trans-unit>
        <trans-unit id="562dc1125a1bf25b7d1d24db6381f0d3d62bbedd" translate="yes" xml:space="preserve">
          <source>The original implementation in PHP2/FI introduced it explicitly with just &quot;&lt;em&gt;quotes will be automatically escaped making it easier to pass form data directly to msql queries&lt;/em&gt;&quot;. Notably it was accidentially safe to use with &lt;a href=&quot;http://www.hughes.com.au/products/msql/&quot;&gt;mSQL&lt;/a&gt;, as that supported ASCII only.</source>
          <target state="translated">PHP2 / FI中的原始实现仅通过&amp;ldquo; &lt;em&gt;引号将自动转义，从而使将表单数据直接传递到msql查询变得更加容易&lt;/em&gt; &amp;rdquo;而明确地引入了它。 值得注意的是，与&lt;a href=&quot;http://www.hughes.com.au/products/msql/&quot;&gt;mSQL&lt;/a&gt;一起使用是偶然安全的，因为它仅支持ASCII。</target>
        </trans-unit>
        <trans-unit id="aebcc1312a3d5f8dc2dd1e177025cf78c72eda79" translate="yes" xml:space="preserve">
          <source>The other is to turn off prepare emulation which is enabled in the &lt;code&gt;MySQL&lt;/code&gt; driver by default, but prepare emulation should be turned off to use &lt;code&gt;PDO&lt;/code&gt; safely.</source>
          <target state="translated">另一种是关闭默认情况下在 &lt;code&gt;MySQL&lt;/code&gt; 驱动程序中启用的准备仿真，但是应关闭准备仿真以安全使用 &lt;code&gt;PDO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1647f08fd0d03cfed6027ec69a028632d0edcfe" translate="yes" xml:space="preserve">
          <source>The output is as follows:</source>
          <target state="translated">产出情况如下:</target>
        </trans-unit>
        <trans-unit id="1c80ab0d65d86371430abcdf8ed4202036dd3c5d" translate="yes" xml:space="preserve">
          <source>The placeholder feature is provided by the real PDO behind it.</source>
          <target state="translated">这个占位符功能是由其背后真正的PDO提供的。</target>
        </trans-unit>
        <trans-unit id="b025ee4adb8cf0f65ed9aabff546b7033803e091" translate="yes" xml:space="preserve">
          <source>The results are fantastic. Lets try those username and password combinations from before again:</source>
          <target state="translated">效果非常好。让我们再次尝试一下之前的用户名和密码组合。</target>
        </trans-unit>
        <trans-unit id="6367ed4377cb731bc3493ca0a1f8fb62d7a404f7" translate="yes" xml:space="preserve">
          <source>The typical workflow of using a prepared statement is as follows (&lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;quoted from Wikipedia three 3 point&lt;/a&gt;):</source>
          <target state="translated">使用准备好的语句的典型工作流程如下（ &lt;a href=&quot;http://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;引自Wikipedia的三分之三&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="c0663df1a52266fe58480cc90e9a9f1077932a7a" translate="yes" xml:space="preserve">
          <source>The user has to enter a login and password, right?</source>
          <target state="translated">用户必须要输入登录和密码,对吧?</target>
        </trans-unit>
        <trans-unit id="bd441197e0d87715716a19344182973372419d2a" translate="yes" xml:space="preserve">
          <source>Then PHP3/Zend reintroduced magic_quotes for MySQL and misdocumented it. But originally it was just a &lt;a href=&quot;https://stackoverflow.com/questions/16098194/why-magic-quotes-has-been-removed-from-php-5-4&quot;&gt;convenience feature&lt;/a&gt;, not intend for security.</source>
          <target state="translated">然后PHP3 / Zend为MySQL重新引入了magic_quotes并错误地记录了它。 但是最初它只是一种&lt;a href=&quot;https://stackoverflow.com/questions/16098194/why-magic-quotes-has-been-removed-from-php-5-4&quot;&gt;便利功能&lt;/a&gt; ，并不是为了安全。</target>
        </trans-unit>
        <trans-unit id="57c2defd4b5ec30df25974856ac6eb0286c19204" translate="yes" xml:space="preserve">
          <source>Then compare with &lt;a href=&quot;https://stackoverflow.com/a/17874410/285587&quot;&gt;crazy amount of code&lt;/a&gt; you will need with raw Mysqli prepared statements.
Note that error handling, profiling, query logging already built in and running.</source>
          <target state="translated">然后将原始Mysqli准备好的语句与&lt;a href=&quot;https://stackoverflow.com/a/17874410/285587&quot;&gt;所需的大量代码&lt;/a&gt;进行比较。 请注意，错误处理，性能分析，查询日志记录已内置并正在运行。</target>
        </trans-unit>
        <trans-unit id="c9c4db9de41823c261f34da4aa90c4b93945d84c" translate="yes" xml:space="preserve">
          <source>Then, in the execute statement, we pass the database an array with all the variables that it now expects.</source>
          <target state="translated">然后,在执行语句中,我们向数据库传递一个数组,其中包含了数据库现在所期望的所有变量。</target>
        </trans-unit>
        <trans-unit id="c69679c49c5f8114f4079ae3ec807eb8cad58847" translate="yes" xml:space="preserve">
          <source>There are better, more robust and well-built alternatives, &lt;strong&gt;&lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO - PHP Database Object&lt;/a&gt;&lt;/strong&gt;, which offers a complete OOP approach to database interaction, and &lt;strong&gt;&lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt;&lt;/strong&gt;, which is a MySQL specific improvement.</source>
          <target state="translated">有更好，更健壮和完善的替代方案， &lt;strong&gt;&lt;a href=&quot;http://php.net/pdo&quot;&gt;PDO-PHP数据库对象&lt;/a&gt;&lt;/strong&gt; （提供完整的OOP方法进行数据库交互），以及&lt;strong&gt;&lt;a href=&quot;http://php.net/mysqli&quot;&gt;MySQLi&lt;/a&gt;&lt;/strong&gt; （这是MySQL的特定改进）。</target>
        </trans-unit>
        <trans-unit id="52a787558155f6b79392728bd50c95fa82bc40c0" translate="yes" xml:space="preserve">
          <source>There are even more choices! Read about them all in &lt;a href=&quot;http://www.php.net/manual/en/pdostatement.fetch.php&quot;&gt;&lt;code&gt;PDOStatement&lt;/code&gt; Fetch documentation.&lt;/a&gt;.</source>
          <target state="translated">还有更多选择！ 在&lt;a href=&quot;http://www.php.net/manual/en/pdostatement.fetch.php&quot;&gt; &lt;code&gt;PDOStatement&lt;/code&gt; Fetch文档中&lt;/a&gt;阅读所有内容。 。</target>
        </trans-unit>
        <trans-unit id="0536d09b1c2f82b31a60e587322bf4e9ae190fe2" translate="yes" xml:space="preserve">
          <source>There are many reasons, but perhaps the most important one is that those functions encourage insecure programming practices because they do not support prepared statements. Prepared statements help prevent SQL injection attacks.</source>
          <target state="translated">原因有很多,但最重要的原因可能是这些函数鼓励不安全的编程实践,因为它们不支持准备好的语句。准备好的语句有助于防止SQL注入攻击。</target>
        </trans-unit>
        <trans-unit id="b5b472b07cd013e7228dcd85aa4b24ebd1742ea3" translate="yes" xml:space="preserve">
          <source>There ought to be an &lt;strong&gt;abstraction layer&lt;/strong&gt; between them and application code, which will do all the dirty job of binding, looping, error handling, etc. inside, making application code DRY and clean. Especially for the complex cases like dynamical query building.</source>
          <target state="translated">它们和应用程序代码之间应该有一个&lt;strong&gt;抽象层&lt;/strong&gt; ，它将在内部进行绑定，循环，错误处理等所有肮脏的工作，从而使应用程序代码变得干燥而干净。 特别是对于复杂的情况，例如动态查询构建。</target>
        </trans-unit>
        <trans-unit id="5aa178ec91604559d6a4a1f12b3fe446f5816ce4" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;pdo_*&lt;/code&gt; wrapper functions make a coding-friendly stop-gap API. (It's pretty much what &lt;code&gt;MYSQLI&lt;/code&gt; could have been if it wasn't for the idiosyncratic function signature shift). They also expose the real PDO at most times.</source>
          <target state="translated">这些 &lt;code&gt;pdo_*&lt;/code&gt; 包装器函数构成了易于编码的Stop-gap API。 （如果不是特殊功能签名转换，这几乎就是 &lt;code&gt;MYSQLI&lt;/code&gt; 的方式 ）。 他们在大多数时候还公开真实的PDO。</target>
        </trans-unit>
        <trans-unit id="66a2a549e1414faaaca0f781d02836464a0a76dc" translate="yes" xml:space="preserve">
          <source>These are replaced by &lt;code&gt;mysqli_connect()&lt;/code&gt;, &lt;code&gt;mysqli_query()&lt;/code&gt; similarly in the latest PHP5.</source>
          <target state="translated">在最新的PHP5中，它们被 &lt;code&gt;mysqli_connect()&lt;/code&gt; ， &lt;code&gt;mysqli_query()&lt;/code&gt; 取代。</target>
        </trans-unit>
        <trans-unit id="b9701d5279e360121f1a9236afe73ce6cdab2437" translate="yes" xml:space="preserve">
          <source>This answer is written to show just how trivial it is to bypass poorly written PHP user-validation code, how (and using what) these attacks work and how to replace the old MySQL functions with a secure prepared statement - and basically, why StackOverflow users (probably with a lot of rep) are barking at new users asking questions to improve their code.</source>
          <target state="translated">写这个答案就是为了说明绕过写得不好的PHP用户验证代码是多么微不足道,这些攻击是如何(和使用什么)起作用的,以及如何用安全的准备好的语句代替旧的MySQL函数--基本上,还有为什么StackOverflow的用户(可能有很多rep)会对新用户提出问题的新用户狂吠,以改进他们的代码。</target>
        </trans-unit>
        <trans-unit id="acf591526b7653913fa0342793a9a8eed4e6efa1" translate="yes" xml:space="preserve">
          <source>This is a classic SQL injection attack. One of the simplest for that matter. On the scale of attack vectors, this is a toddler attacking a tank - and winning.</source>
          <target state="translated">这是一个典型的SQL注入攻击。也是最简单的攻击之一。在攻击载体的规模上,这是一个蹒跚学步的孩子在攻击坦克--而且是胜利的。</target>
        </trans-unit>
        <trans-unit id="53d154ecdaa8d6b0fba2af9eefdc52d17f07dcb7" translate="yes" xml:space="preserve">
          <source>This is the reason behind the error.</source>
          <target state="translated">这就是错误背后的原因。</target>
        </trans-unit>
        <trans-unit id="6bafa12ee03b3bf471f9002286e0bb60d99c0b9e" translate="yes" xml:space="preserve">
          <source>This is why you are being yelled at when posting questions - it's because people can see that your code can be bypassed wihout even trying. Please, do use this question and answer to improve your code, to make it more secure and to use functions that are current.</source>
          <target state="translated">这就是为什么你在发布问题的时候被人骂的原因--这是因为人们可以看到你的代码可以不经意间就被绕过。请你用这个问答来改进你的代码,让你的代码更安全,使用当前的功能。</target>
        </trans-unit>
        <trans-unit id="7d8ecdcb3fa76fbbc753f992ef32e06a8691ab30" translate="yes" xml:space="preserve">
          <source>This latter issue is a problem.</source>
          <target state="translated">后面这个问题是个问题。</target>
        </trans-unit>
        <trans-unit id="b327464305947f9b5efea8f1e165dfaa4f7af138" translate="yes" xml:space="preserve">
          <source>This means that as of &lt;a href=&quot;https://www.php.net/eol.php&quot;&gt;31 Dec 2018&lt;/a&gt; it does not exist in any supported version of PHP. If you are using a version of PHP which supports it, you are using a version which doesn't get security problems fixed.</source>
          <target state="translated">这意味着&lt;a href=&quot;https://www.php.net/eol.php&quot;&gt;截至2018年12月31日&lt;/a&gt; ，任何受支持的PHP版本中都不存在该文件。 如果使用的PHP版本支持该版本，则使用的版本不会解决安全问题。</target>
        </trans-unit>
        <trans-unit id="c5028f4b1c5e464cbdf5fbc73b406c40f8937746" translate="yes" xml:space="preserve">
          <source>This means that the PHP community is gradually dropping support for these very old functions. They are likely to not exist in a future (recent) version of PHP! Continued use of these functions may break your code in the (not so) far future.</source>
          <target state="translated">这意味着PHP社区正在逐渐放弃对这些非常古老的功能的支持。它们很可能在未来(最近的)PHP版本中不存在! 继续使用这些函数可能会在(不是很远的将来)破坏你的代码。</target>
        </trans-unit>
        <trans-unit id="a9447e1e24f2f798f77e4acb808ca245ef8e28b9" translate="yes" xml:space="preserve">
          <source>This time, we get the following:</source>
          <target state="translated">这一次,我们得到的是:</target>
        </trans-unit>
        <trans-unit id="7b5d0b0f701ec4934ce62c2d94018de81b4de43f" translate="yes" xml:space="preserve">
          <source>Thus also allowed &lt;code&gt;:named&lt;/code&gt; placeholder lists later.</source>
          <target state="translated">因此，以后也允许 &lt;code&gt;:named&lt;/code&gt; 占位符列表。</target>
        </trans-unit>
        <trans-unit id="1e3281a962e6db2e54e787f796eb7d2b1582389a" translate="yes" xml:space="preserve">
          <source>Transactions</source>
          <target state="translated">Transactions</target>
        </trans-unit>
        <trans-unit id="5ce32adc4f972e95e060d45591a7aa082f17d9f6" translate="yes" xml:space="preserve">
          <source>Unless you also introduce parameter binding or can utilize something else from the nicer API, it's a pointless switch. I hope it's portrayed simple enough to not further the discouragement to newcomers. (Education usually works better than prohibition.)</source>
          <target state="translated">除非你还引入了参数绑定,或者可以利用其他的一些比较好的API中的东西,否则这是个无意义的切换。我希望把它描绘得足够简单,不要进一步让新人望而却步。(教育通常比禁止的效果要好)。</target>
        </trans-unit>
        <trans-unit id="9f6d94af323287247ddbdf1bbc2b55dbba5ca657" translate="yes" xml:space="preserve">
          <source>Use one of the &lt;a href=&quot;http://php.net/security.magicquotes.disabling&quot;&gt;userland reversal&lt;/a&gt; approaches. Then remove the &lt;code&gt;stripslashes()&lt;/code&gt; in the &lt;code&gt;sanitize&lt;/code&gt; function.</source>
          <target state="translated">使用&lt;a href=&quot;http://php.net/security.magicquotes.disabling&quot;&gt;userland逆转&lt;/a&gt;方法之一。 然后在 &lt;code&gt;sanitize&lt;/code&gt; 函数中删除 &lt;code&gt;stripslashes()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d22feee0d218aca696cac86b7e4deb1dabc1af1d" translate="yes" xml:space="preserve">
          <source>User wasn't verified. Awesome.</source>
          <target state="translated">用户未被验证。厉害了。</target>
        </trans-unit>
        <trans-unit id="ef7051e396eea2b5e406d5540802dd68853d889b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://fossil.include-once.org/upgradephp/artifact/43ab742241e5a3be43d31764dd333ba68e245360&quot;&gt;&amp;lt;&lt;strong&gt;pdo_mysql.php&lt;/strong&gt;&amp;gt;&lt;/a&gt; you can switch from the old mysql_ functions with &lt;em&gt;minimal effort&lt;/em&gt;. It adds &lt;code&gt;pdo_&lt;/code&gt; function wrappers which replace their &lt;code&gt;mysql_&lt;/code&gt; counterparts.</source>
          <target state="translated">使用&lt;a href=&quot;http://fossil.include-once.org/upgradephp/artifact/43ab742241e5a3be43d31764dd333ba68e245360&quot;&gt;&amp;lt; &lt;strong&gt;pdo_mysql.php&lt;/strong&gt; &amp;gt;，&lt;/a&gt;您可以毫不&lt;em&gt;费力地&lt;/em&gt;从旧的mysql_函数切换。 它添加了 &lt;code&gt;pdo_&lt;/code&gt; 函数包装，以替换它们的 &lt;code&gt;mysql_&lt;/code&gt; 对应对象。</target>
        </trans-unit>
        <trans-unit id="a3546de296990f00559369725f6b73e5773d07ec" translate="yes" xml:space="preserve">
          <source>Using prepared statements in &lt;code&gt;PDO&lt;/code&gt; or &lt;code&gt;mysqli&lt;/code&gt; will make it so that these sorts of programming errors are more difficult to make.</source>
          <target state="translated">在 &lt;code&gt;PDO&lt;/code&gt; 或 &lt;code&gt;mysqli&lt;/code&gt; 中使用准备好的语句将使其变得更加困难。</target>
        </trans-unit>
        <trans-unit id="486fedcd9d1e44ea49d7fea32a811becae9a5ea2" translate="yes" xml:space="preserve">
          <source>Warning: mysql_connect(): No such file or directory</source>
          <target state="translated">警告:mysql_connect():没有这样的文件或目录</target>
        </trans-unit>
        <trans-unit id="4c5244a83456f7a8a64e8871234ed5b7ddc13050" translate="yes" xml:space="preserve">
          <source>We can use MySQL functions by creating a wrapper function for each below is running code. &lt;a href=&quot;https://www.talkforweb.com.au/php/how-to-use-mysql-in-php-7-version&quot;&gt;Click here&lt;/a&gt;</source>
          <target state="translated">我们可以通过为下面每个正在运行的代码创建一个包装函数来使用MySQL函数。 &lt;a href=&quot;https://www.talkforweb.com.au/php/how-to-use-mysql-in-php-7-version&quot;&gt;点击这里&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75b20bd2200600dac46620c83364968245f98595" translate="yes" xml:space="preserve">
          <source>Well, not really. Lets say the user is a clever little person. Lets say the person is me.</source>
          <target state="translated">好吧,其实不然。假设这个用户是个聪明的小人物。假设这个人就是我。</target>
        </trans-unit>
        <trans-unit id="7899429896ac711595aff78d7cfe787d90c838cd" translate="yes" xml:space="preserve">
          <source>Well, the answer would be as follows:</source>
          <target state="translated">那么,答案如下:</target>
        </trans-unit>
        <trans-unit id="0fbfa99fed4d886de39ca6ae2e0a7d91af92c318" translate="yes" xml:space="preserve">
          <source>What are the technical reasons for why one shouldn't use &lt;code&gt;mysql_*&lt;/code&gt; functions? (e.g. &lt;code&gt;mysql_query()&lt;/code&gt;, &lt;code&gt;mysql_connect()&lt;/code&gt; or &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;)?</source>
          <target state="translated">为什么不应该使用 &lt;code&gt;mysql_*&lt;/code&gt; 函数的技术原因是什么？ （例如 &lt;code&gt;mysql_query()&lt;/code&gt; ， &lt;code&gt;mysql_connect()&lt;/code&gt; 或 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; ）？</target>
        </trans-unit>
        <trans-unit id="cd38c24be39c82544339ccc932bdc9bf31585932" translate="yes" xml:space="preserve">
          <source>What we are doing in &lt;code&gt;mysql_*&lt;/code&gt; function is:</source>
          <target state="translated">我们在 &lt;code&gt;mysql_*&lt;/code&gt; 函数中正在做的是：</target>
        </trans-unit>
        <trans-unit id="b21a3658c12dc7f9942d92330d6ba7faf54fd2f5" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;mysql_*&lt;/code&gt; functions, you have to remember to run user-supplied parameters through &lt;code&gt;mysql_real_escape_string()&lt;/code&gt;. If you forget in just one place or if you happen to escape only part of the input, your database may be subject to attack.</source>
          <target state="translated">使用 &lt;code&gt;mysql_*&lt;/code&gt; 函数时，必须记住要通过 &lt;code&gt;mysql_real_escape_string()&lt;/code&gt; 运行用户提供的参数。 如果您只忘记一个地方，或者碰巧只对部分输入进行转义，则数据库可能会受到攻击。</target>
        </trans-unit>
        <trans-unit id="2931a1a4cd0a0347c48feeaca13f011b624aed4e" translate="yes" xml:space="preserve">
          <source>When you go on any &lt;code&gt;mysql_*&lt;/code&gt; function manual page, you see a red box, explaining it should not be used anymore.</source>
          <target state="translated">当您进入任何 &lt;code&gt;mysql_*&lt;/code&gt; 函数手册页面时，都会看到一个红色框，说明不再使用它。</target>
        </trans-unit>
        <trans-unit id="cf411fb39b805de367075ecc7671c209fb94fd0c" translate="yes" xml:space="preserve">
          <source>When you go to any &lt;code&gt;mysql&lt;/code&gt; function manual page, you see a red box, explaining it should not be used anymore.</source>
          <target state="translated">当您转到任何 &lt;code&gt;mysql&lt;/code&gt; 功能手册页面时，都会看到一个红色框，说明不再使用它。</target>
        </trans-unit>
        <trans-unit id="de52d720c2b9fc0148a79e4ac0bf6e334c6922de" translate="yes" xml:space="preserve">
          <source>When you scramble string variables into the SQL queries, it doesn't just get more intricate for you to follow. It's also extraneous effort for MySQL to segregate code and data again.</source>
          <target state="translated">当你把字符串变量拼凑到SQL查询中时,不仅会让你的遵循变得更加复杂。对于MySQL来说,再次隔离代码和数据也是多余的努力。</target>
        </trans-unit>
        <trans-unit id="08e4f5d49c704cc6527ca62c9c0c5f10e94a3848" translate="yes" xml:space="preserve">
          <source>While code is being converted to &lt;code&gt;MySQLi&lt;/code&gt;/&lt;code&gt;PDO&lt;/code&gt;, &lt;code&gt;E_DEPRECATED&lt;/code&gt; errors can be suppressed by setting &lt;code&gt;error_reporting&lt;/code&gt; in &lt;strong&gt;php.ini&lt;/strong&gt; to exclude &lt;code&gt;E_DEPRECATED:&lt;/code&gt;</source>
          <target state="translated">将代码转换为 &lt;code&gt;MySQLi&lt;/code&gt; / &lt;code&gt;PDO&lt;/code&gt; 时 ，可以通过在&lt;strong&gt;php.ini&lt;/strong&gt; &lt;code&gt;E_DEPRECATED:&lt;/code&gt; &lt;code&gt;error_reporting&lt;/code&gt; 设置为排除E_DEPRECATED来抑制 &lt;code&gt;E_DEPRECATED&lt;/code&gt; 错误：</target>
        </trans-unit>
        <trans-unit id="e96fbd5b6300a2987f662d74b0a387a6eaee6777" translate="yes" xml:space="preserve">
          <source>While it qualifies for the simplest-thing-that-could-possibly-work category, it's also still very experimental code. I just wrote it over the weekend. There's a plethora of alternatives however. Just google for &lt;a href=&quot;https://www.google.de/search?client=stackoverflow&amp;amp;q=PHP+database+abstraction&quot;&gt;PHP database abstraction&lt;/a&gt; and browse a little. There always have been and will be lots of excellent libraries for such tasks.</source>
          <target state="translated">虽然它符合可以工作的最简单类别的要求，但它仍然是非常试验性的代码。 我只是在周末写的。 但是，还有很多其他选择。 只是谷歌为&lt;a href=&quot;https://www.google.de/search?client=stackoverflow&amp;amp;q=PHP+database+abstraction&quot;&gt;PHP数据库抽象&lt;/a&gt;和浏览一点。 一直存在并且将有许多出色的库来执行此类任务。</target>
        </trans-unit>
        <trans-unit id="3db062dc13c427b5833ae038cf2841371c4940cd" translate="yes" xml:space="preserve">
          <source>While this answer stresses that you should care about the readability advantages of dropping &lt;s&gt;&lt;code&gt;mysql_&lt;/code&gt;&lt;/s&gt;. There's occasionally also a performance advantage (repeated INSERTs with just differing values) due to this visible and technical data/code separation.</source>
          <target state="translated">尽管此答案强调您应该关注删除&lt;s&gt; &lt;code&gt;mysql_&lt;/code&gt; &lt;/s&gt;的可读性优点。 由于这种可见的和技术上的数据/代码分离，有时还具有性能优势（重复的INSERT具有不同的值）。</target>
        </trans-unit>
        <trans-unit id="21e2caea4476d26af34541ca7c909c7ff2fa4a7f" translate="yes" xml:space="preserve">
          <source>Why</source>
          <target state="translated">Why</target>
        </trans-unit>
        <trans-unit id="3ef9f79b5eb449f72b3fdf90c2c98ca4727dbf72" translate="yes" xml:space="preserve">
          <source>Why should I use something else even if they work on my site?</source>
          <target state="translated">即使它们对我的网站有效,我为什么要用其他的东西呢?</target>
        </trans-unit>
        <trans-unit id="bef272d0089010f98f10750eee469e97be3484f5" translate="yes" xml:space="preserve">
          <source>Why shouldn't I use mysql_* functions in PHP</source>
          <target state="translated">为什么我不能在PHP中使用mysql_*函数?</target>
        </trans-unit>
        <trans-unit id="4ba7de6b07d2790dbe183ff8860e4b3a376efb27" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;?&lt;/code&gt; placeholders applied you don't have to bother with that:</source>
          <target state="translated">用 &lt;code&gt;?&lt;/code&gt; 占位符适用于您，您不必为此而烦恼：</target>
        </trans-unit>
        <trans-unit id="1b521949ba1a0d81fe7f7a22ca009f139258af49" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;PDO&lt;/code&gt;: All you need to do is create a new &lt;code&gt;PDO&lt;/code&gt; object. The constructor accepts parameters for specifying the database source &lt;code&gt;PDO&lt;/code&gt;'s constructor mostly takes four parameters which are &lt;code&gt;DSN&lt;/code&gt; (data source name) and  optionally &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;PDO&lt;/code&gt; ：您所需要做的就是创建一个新的 &lt;code&gt;PDO&lt;/code&gt; 对象。 构造函数接受用于指定数据库源的参数 &lt;code&gt;PDO&lt;/code&gt; 的构造函数主要采用四个参数，分别是 &lt;code&gt;DSN&lt;/code&gt; （数据源名称）和可选的 &lt;code&gt;username&lt;/code&gt; ， &lt;code&gt;password&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e432386262217c200274bffa28234079d822668e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;mysql_*&lt;/code&gt; function or we can say it the old way (deprecated in PHP 5.5 and above)</source>
          <target state="translated">使用 &lt;code&gt;mysql_*&lt;/code&gt; 函数或我们可以用旧的方式说（在PHP 5.5及更高版本中已弃用）</target>
        </trans-unit>
        <trans-unit id="aa425a4526ed951fbc2faa2bf53cf3ac2eedcb7b" translate="yes" xml:space="preserve">
          <source>With bound parameters you separate SQL code and SQL-context values in your PHP code. But it doesn't get shuffled up again behind the scenes (except with PDO::EMULATE_PREPARES). Your database receives the unvaried SQL commands and 1:1 variable values.</source>
          <target state="translated">通过绑定参数,你可以在PHP代码中分离出SQL代码和SQL-context值。但是它不会在幕后被重新洗牌(除了使用PDO:::EMULATE_PREPARES)。你的数据库会接收到未变异的SQL命令和1:1的变量值。</target>
        </trans-unit>
        <trans-unit id="e7b9c34542bc7220d2b9d0c79dbfc014575aed6b" translate="yes" xml:space="preserve">
          <source>With that done, we can move to our PHP code.</source>
          <target state="translated">完成了这些,我们就可以转到我们的PHP代码了。</target>
        </trans-unit>
        <trans-unit id="bd1fd1c6043beb37d33d7ef7c193233e05a2152e" translate="yes" xml:space="preserve">
          <source>You can also bind using an execute array as well:</source>
          <target state="translated">你也可以使用执行数组进行绑定。</target>
        </trans-unit>
        <trans-unit id="39834359a3e108415bb98b0c8863a7cd433c0634" translate="yes" xml:space="preserve">
          <source>You can also pass in several driver options as an array to the fourth parameter. I recommend passing the parameter which puts &lt;code&gt;PDO&lt;/code&gt; into exception mode. Because some &lt;code&gt;PDO&lt;/code&gt; drivers don't support native prepared statements, so &lt;code&gt;PDO&lt;/code&gt; performs emulation of the prepare. It also lets you manually enable this emulation. To use the native server-side prepared statements, you should explicitly set it &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">您还可以将多个驱动程序选项作为数组传递给第四个参数。 我建议传递参数，以使 &lt;code&gt;PDO&lt;/code&gt; 进入异常模式。 由于某些 &lt;code&gt;PDO&lt;/code&gt; 驱动程序不支持本机准备语句，因此 &lt;code&gt;PDO&lt;/code&gt; 会执行prepare的仿真。 它还允许您手动启用此仿真。 要使用本机服务器端准备好的语句，应将其显式设置为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0106d16cdb27ff2ec30c1b900ece093440a823c3" translate="yes" xml:space="preserve">
          <source>You can hardly find an example for PDO to handle such practical case.</source>
          <target state="translated">对于PDO来说,你很难找到一个例子来处理这样的实际案例。</target>
        </trans-unit>
        <trans-unit id="193b814af13365eaaf93b92758d562e11bdc9a6e" translate="yes" xml:space="preserve">
          <source>You can use a prepared statement by including placeholders in your SQL. There are basically three ones without placeholders (don't try this with variable its above one), one with unnamed placeholders, and one with named placeholders.</source>
          <target state="translated">你可以通过在SQL中加入占位符来使用准备好的语句。基本上有三个没有占位符的(不要用变量它上面的一个不要尝试这个),一个用未命名的占位符,一个用命名的占位符。</target>
        </trans-unit>
        <trans-unit id="9f8aaea6ff6d99acc02af021cf0de60526c70b07" translate="yes" xml:space="preserve">
          <source>You do not have to handle with &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt; right now. You can catch it at any time appropriate, but I strongly recommend you to use &lt;code&gt;try&lt;/code&gt;-&lt;code&gt;catch&lt;/code&gt;. Also it may make more sense to catch it at outside the function that calls the &lt;code&gt;PDO&lt;/code&gt; stuff:</source>
          <target state="translated">您无需 &lt;code&gt;try&lt;/code&gt; -立即 &lt;code&gt;catch&lt;/code&gt; 。 您可以在任何合适的时间捕获它，但是我强烈建议您使用 &lt;code&gt;try&lt;/code&gt; - &lt;code&gt;catch&lt;/code&gt; 。 另外，将其捕获在调用 &lt;code&gt;PDO&lt;/code&gt; 东西的函数之外可能更有意义：</target>
        </trans-unit>
        <trans-unit id="f6ec43a805132e214cc4951849805b992f1dca6d" translate="yes" xml:space="preserve">
          <source>You just need a less unwieldy API.</source>
          <target state="translated">你只需要一个不那么笨重的API。</target>
        </trans-unit>
        <trans-unit id="83c916251fa57138befaf512e453b91c66f1222f" translate="yes" xml:space="preserve">
          <source>You may have to keep the rest of your &lt;code&gt;sanitize()&lt;/code&gt; function for now if your database and application flow expect HTML-context-safe strings. Add a comment that it applies only HTML escaping henceforth.</source>
          <target state="translated">如果您的数据库和应用程序流需要HTML上下文安全的字符串，则可能必须暂时保留其余的 &lt;code&gt;sanitize()&lt;/code&gt; 函数。 添加注释，此注释仅适用于以后的HTML转义。</target>
        </trans-unit>
        <trans-unit id="109ef7c7ad471c0fd553af6c791c965eb0053415" translate="yes" xml:space="preserve">
          <source>You'll get more helpful warnings in most cases than PDO or mysql_ usually provide after failed queries.</source>
          <target state="translated">大多数情况下,你会得到比PDO或mysql_通常在查询失败后提供的警告更有帮助。</target>
        </trans-unit>
        <trans-unit id="00c17ebf04ff3d123b5bf045615793029cdab7eb" translate="yes" xml:space="preserve">
          <source>Your code is &lt;em&gt;using&lt;/em&gt; PDO.</source>
          <target state="translated">您的代码正在&lt;em&gt;使用&lt;/em&gt; PDO。</target>
        </trans-unit>
        <trans-unit id="114e82ddc86b988c9f233dd5f847ff571f7ead99" translate="yes" xml:space="preserve">
          <source>Your code will work alike and still mostly look the same:</source>
          <target state="translated">你的代码会有类似的效果,而且大部分看起来还是一样的。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="09e7d790f3ab05e4f56ffe51297bfcdde73f15bf" translate="yes" xml:space="preserve">
          <source>and submit it.</source>
          <target state="translated">并提交。</target>
        </trans-unit>
        <trans-unit id="12328e72903e2254dcef3aa99b38ab6b1480db8b" translate="yes" xml:space="preserve">
          <source>are out of date - they're not maintained any more</source>
          <target state="translated">过期了,不复存在了</target>
        </trans-unit>
        <trans-unit id="ed3059ee362c75dcd7469e8cfbf286738600b576" translate="yes" xml:space="preserve">
          <source>being an average PHP user, most likely your idea of using these functions is error-prone and wrong. Just because of all these numerous tutorials and manuals which teach you the wrong way. Not the functions themselves - I have to emphasize it - but the way they are used.</source>
          <target state="translated">作为一个普通的PHP用户,很可能你对使用这些函数的想法是错误的。只是因为所有这些无数的教程和手册教你的方法都是错误的。不是函数本身--我必须强调一下--而是它们的使用方式。</target>
        </trans-unit>
        <trans-unit id="7a880ef5359c5138ea32e24d56e7ada875ea4f77" translate="yes" xml:space="preserve">
          <source>don't allow you to move easily to another database backend</source>
          <target state="translated">不允许你轻松移动到另一个数据库后端</target>
        </trans-unit>
        <trans-unit id="830033092d1fd68deec56e78e5679b5bb240badd" translate="yes" xml:space="preserve">
          <source>don't support prepared statements, hence</source>
          <target state="translated">不支持准备好的报表,因此</target>
        </trans-unit>
        <trans-unit id="2935b5bb29398649ebd070be72ec96b9e5d1dcad" translate="yes" xml:space="preserve">
          <source>encourage programmers to use concatenation to build queries, leading to SQL injection vulnerabilities</source>
          <target state="translated">鼓励程序员使用串联法构建查询,导致SQL注入漏洞。</target>
        </trans-unit>
        <trans-unit id="acc54e219ffe07f00fcf43d7c700c28aea05aca4" translate="yes" xml:space="preserve">
          <source>further use of these functions with modern PHP versions will raise deprecated-level notices. They simply can be turned off.</source>
          <target state="translated">在现代 PHP 版本中进一步使用这些函数会引起过时的通知。它们可以被关闭。</target>
        </trans-unit>
        <trans-unit id="d815f35640c25abe234d7b810ff746628e851f0e" translate="yes" xml:space="preserve">
          <source>in a distant future, they can be possibly removed from the default PHP build. Not a big deal too, as mydsql ext will be moved into PECL and every hoster will be happy to compile PHP with it, as they don't want to lose clients whose sites were working for decades.</source>
          <target state="translated">在遥远的将来,它们可能会被从默认的PHP构建中删除。这也不是什么大问题,因为mydsql ext将被移到PECL中,每个主机商都会很乐意用它来编译PHP,因为他们不想失去那些网站工作了几十年的客户。</target>
        </trans-unit>
        <trans-unit id="7f76e98f72dce710ff68c2850ea89b8fb65a8322" translate="yes" xml:space="preserve">
          <source>non-blocking, asynchronous queries</source>
          <target state="translated">非阻塞、异步查询</target>
        </trans-unit>
        <trans-unit id="de7c9165c22b2bbc30bc3ecad1c9e6bf4b9c7c6f" translate="yes" xml:space="preserve">
          <source>stored procedures returning multiple resultsets</source>
          <target state="translated">存储过程返回多个结果集</target>
        </trans-unit>
        <trans-unit id="95b2ac54f95972248a7b13860ea1d8810f52eeb0" translate="yes" xml:space="preserve">
          <source>strong resistance from Stackoverflow community. Еverytime you mention these honest functions, you being told that they are under strict taboo.</source>
          <target state="translated">来自Stackoverflow社区的强大阻力。每当你提到这些诚实的功能,你就会被告知它们是有严格的禁忌。</target>
        </trans-unit>
        <trans-unit id="4ca2ac0512b37905e3e07228b035c03f882fec79" translate="yes" xml:space="preserve">
          <source>the list goes on ...</source>
          <target state="translated">不胜枚举</target>
        </trans-unit>
        <trans-unit id="2eb74edb23d3b49834fb5098164392d5ce9f9a09" translate="yes" xml:space="preserve">
          <source>unlike mysqli, PDO can always return query result in a simple usual array, while mysqli can do it only on mysqlnd installations.</source>
          <target state="translated">与mysqli不同的是,PDO总是能以一个简单的普通数组返回查询结果,而mysqli只能在mysqlnd安装时才能做到。</target>
        </trans-unit>
        <trans-unit id="aa4f5271f5951ab6344d7de045285abcfe2bf002" translate="yes" xml:space="preserve">
          <source>unlike mysqli, PDO can bind placeholders &lt;em&gt;by value&lt;/em&gt;, which makes dynamically built queries feasible without several screens of quite messy code.</source>
          <target state="translated">与mysqli不同，PDO可以&lt;em&gt;通过value&lt;/em&gt;绑定占位符，这使动态构建的查询变得可行，而无需几个混乱的屏幕。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
