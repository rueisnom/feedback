<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1299871">
    <body>
      <group id="1299871">
        <trans-unit id="d47d7caf030340f041a78d2ceb0b7965bda3093d" translate="yes" xml:space="preserve">
          <source>*_join() no longer reorders column names (#324)</source>
          <target state="translated">* _join ()은 더 이상 열 이름을 재정렬하지 않습니다 (# 324)</target>
        </trans-unit>
        <trans-unit id="487b6c91b5261dd50389ad61b918fe7838afe87f" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/12030932/2490497&quot;&gt;rolling join&lt;/a&gt; - if you want merge to be able to match to values from preceeding/following rows by rolling them forward or backward</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/12030932/2490497&quot;&gt;롤링 조인&lt;/a&gt; -병합이 선행 또는 후속 행의 값을 앞뒤로 롤링하여 일치시킬 수 있도록하려면</target>
        </trans-unit>
        <trans-unit id="84c6f6a09e15ca4a5e7777731b7f61a686126d78" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/25815032/2490497&quot;&gt;overlapping join&lt;/a&gt; - if you want to merge by ranges</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/25815032/2490497&quot;&gt;겹치는 조인&lt;/a&gt; -범위별로 병합하려는 경우</target>
        </trans-unit>
        <trans-unit id="afc219bc005a7c35074b4b7bdeb7c70495859d1b" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/3190118/2490497&quot;&gt;update on join&lt;/a&gt; - if you want to lookup values from another table to your main table</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/3190118/2490497&quot;&gt;조인시 업데이트&lt;/a&gt; -다른 테이블에서 기본 테이블로 값을 조회하려는 경우</target>
        </trans-unit>
        <trans-unit id="890d6745a9399241952baa05d0099615ae7dc270" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/41043047/2490497&quot;&gt;non-equi join&lt;/a&gt; - if your join condition is non-equal</source>
          <target state="translated">-동일 &lt;a href=&quot;https://stackoverflow.com/q/41043047/2490497&quot;&gt;하지 않은 조인&lt;/a&gt; -조인 조건이 같지 않은 경우</target>
        </trans-unit>
        <trans-unit id="92ed8f843671545e7e2acc8d069fdcc2446feaeb" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/41684012/2490497&quot;&gt;aggregate on join&lt;/a&gt; - if you want to aggregate on key you are joining you do not have to materialize all join results</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/41684012/2490497&quot;&gt;가입시 집계&lt;/a&gt; - 가입 한 키를 집계하려는 경우 모든 가입 결과를 구체화 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="07ce8fe7aebda33b8d668e59d9c852c30c95ed33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anti_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x
where there are not matching values in y, keeping just columns from x</source>
          <target state="translated">&lt;code&gt;anti_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : x의 열만 유지하면서 y에 일치하는 값이없는 x의 모든 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="846866e1d2e49dece784b5f56afce637ce3acb5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inner_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from
x where there are matching values in y, and all columns from x and y</source>
          <target state="translated">&lt;code&gt;inner_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : y에 일치하는 값이있는 x의 모든 행과 x와 y의 모든 열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4756dd78d19e6570c93a82eb2702ffcd868aa1a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x, and all columns from x and y</source>
          <target state="translated">&lt;code&gt;left_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : x의 모든 행과 x와 y의 모든 열을 반환</target>
        </trans-unit>
        <trans-unit id="b1ac4ba54b36075fe4e311146847172ffda51a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; also works on data.tables (as it is generic and calls &lt;code&gt;merge.data.table&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 는 data.tables에서도 작동합니다 (일반적이며 &lt;code&gt;merge.data.table&lt;/code&gt; 을 호출 합니다 )</target>
        </trans-unit>
        <trans-unit id="8c0dab1fb7e149efd4ef02ea7323dd1028acf2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;semi_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x where there are matching values in
y, keeping just columns from x.</source>
          <target state="translated">&lt;code&gt;semi_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : x의 열만 유지하면서 y에 일치하는 값이있는 x의 모든 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="64447dc8e6edd1cc9f32821eb103cfca1f89e9cb" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;Just as with the inner join, you would probably want to explicitly pass &quot;CustomerId&quot; to R as the matching variable.&lt;/strike&gt;  I think it's almost always best to explicitly state the identifiers on which you want to merge; it's safer if the input data.frames change unexpectedly and easier to read later on.</source>
          <target state="translated">&lt;strike&gt;내부 조인과 마찬가지로 일치 변수로 &quot;CustomerId&quot;를 R에 명시 적으로 전달할 수 있습니다.&lt;/strike&gt; 거의 항상 병합하려는 식별자를 명시 적으로 언급하는 것이 가장 좋습니다. 입력 데이터 프레임이 예기치 않게 변경되고 나중에 읽기가 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8f2b37c4fd55625fd3e73914491c5bd0dc311ccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Cross join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = NULL)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;교차 조인 :&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = NULL)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8a7da9103d4d41873615a068f57166a2b7778c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Inner join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(df1, df2)&lt;/code&gt; will work for these examples because R automatically joins the frames by common variable names, but you would most likely want to specify &lt;code&gt;merge(df1, df2, by = &quot;CustomerId&quot;)&lt;/code&gt; to make sure that you were matching on only the fields you desired.  You can also use the &lt;code&gt;by.x&lt;/code&gt; and &lt;code&gt;by.y&lt;/code&gt; parameters if the matching variables have different names in the different data frames.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;내부 조인 :&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(df1, df2)&lt;/code&gt; 는 R이 공통 변수 이름으로 프레임을 자동으로 조인하기 때문에 이러한 예제에서 작동하지만, 대부분의 경우 &lt;code&gt;merge(df1, df2, by = &quot;CustomerId&quot;)&lt;/code&gt; 을 지정하려고합니다. 원하는 필드에서만 일치했습니다. 일치하는 변수의 이름이 다른 데이터 프레임에서 다른 경우 &lt;code&gt;by.x&lt;/code&gt; 및 &lt;code&gt;by.y&lt;/code&gt; 매개 변수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="038870ab05a425a137f8fbbc279dda97c77d683f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Left outer:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;왼쪽 외부 :&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72ebaef810f98fc55883bca7f5dfd5acba8a9cae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Outer join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;외부 조인 :&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dab4ebd7ed185ebd97efccd2c02d50ba28589364" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Right outer:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;오른쪽 외부 :&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="feb6dda0b81cd0e64ea3c74f9c8b636b97c7342f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.1.3&lt;/em&gt;&lt;/strong&gt; (4/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.1.3&lt;/em&gt;&lt;/strong&gt; (2014 년 4 월)</target>
        </trans-unit>
        <trans-unit id="977c100088eecd2687b330acb3b61630e1c463ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.2&lt;/em&gt;&lt;/strong&gt; (5/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.2&lt;/em&gt;&lt;/strong&gt; (2014 년 5 월)</target>
        </trans-unit>
        <trans-unit id="9d1100b98263dbf4dd0f99865af468f7b55e605f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.3&lt;/em&gt;&lt;/strong&gt; (10/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.3&lt;/em&gt;&lt;/strong&gt; (2014 년 10 월)</target>
        </trans-unit>
        <trans-unit id="bd8720e189cc792821196cc8bacaf98d3035fecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.4.0&lt;/em&gt;&lt;/strong&gt; (1/2015)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.4.0&lt;/em&gt;&lt;/strong&gt; (2015 년 1 월)</target>
        </trans-unit>
        <trans-unit id="66e75518de390f9fe0e9e80b4cbab16a3bcb592b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.5&lt;/em&gt;&lt;/strong&gt; (6/2016)</source>
          <target state="translated">v0.5 (2016 년 6 월)</target>
        </trans-unit>
        <trans-unit id="7d481f74b71e19ee13eac5a4c57e4f92286ac1b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implement right join and outer join&lt;/strong&gt; (#96)</source>
          <target state="translated">&lt;strong&gt;오른쪽 조인 및 외부 조인 구현&lt;/strong&gt; (# 96)</target>
        </trans-unit>
        <trans-unit id="7d863a7bd89469b75eeee503d3a69a99724f4c9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Merge Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;병합 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="631fffa31418327ad1ceee06912e77e433c2a830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rolling update join.&lt;/strong&gt; Alternately, we may want to take the last state the customer was found in:</source>
          <target state="translated">&lt;strong&gt;롤링 업데이트 조인.&lt;/strong&gt; 또는 고객이 마지막으로 찾은 상태를 유지하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="16a449699f13e0f7577783adc61a84fa6b01f031" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscript Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;첨자 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b809d4e294824a9bd8793db2c442bcc11490e805" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update join with multiple columns.&lt;/strong&gt; The approach above works well when we are joining on only a single column and are satisfied with the first match. Suppose we want the year of measurement in the customer table to match the year of sale.</source>
          <target state="translated">&lt;strong&gt;여러 열로 조인 업데이트&lt;/strong&gt; 위의 방법은 단일 열에서만 결합하고 첫 번째 일치에 만족할 때 효과적입니다. 고객 테이블의 측정 연도가 판매 연도와 일치한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="60c8303c5c795a80894a040e6ad09b86a234618e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update join.&lt;/strong&gt; One other important SQL-style join is an &quot;&lt;a href=&quot;https://stackoverflow.com/q/7869592/&quot;&gt;update join&lt;/a&gt;&quot; where columns in one table are updated (or created) using another table.</source>
          <target state="translated">&lt;strong&gt;조인 업데이트.&lt;/strong&gt; 다른 중요한 SQL 스타일 조인은 한 테이블의 열이 다른 테이블을 사용하여 업데이트 (또는 생성)되는 &quot; &lt;a href=&quot;https://stackoverflow.com/q/7869592/&quot;&gt;업데이트 조인&lt;/a&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d36e434acda5756c7bc2a0734856c0841c167a0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;outer_join&lt;/strong&gt; is basically union(left_join(x, y), right_join(x, y)) - i.e. preserve all rows in both data frames.</source>
          <target state="translated">&lt;strong&gt;outer_join&lt;/strong&gt; 은 기본적으로 union (left_join (x, y), right_join (x, y))입니다. 즉 두 데이터 프레임의 모든 행을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e65d821137f54f3e9e9fa6bf3d532f2edb926dc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;outer_join&lt;/strong&gt; not implemented yet, fallback is use base::merge() (or plyr::join())</source>
          <target state="translated">&lt;strong&gt;outer_join이&lt;/strong&gt; 아직 구현되지 않았으므로 대체는 base :: merge () 또는 plyr :: join ()입니다.</target>
        </trans-unit>
        <trans-unit id="7af98f3c825f135edda87f9c794dac0060279aa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;right_join&lt;/strong&gt;(x,y) is the same as left_join(y,x) in terms of the rows, just the columns will be different orders. Easily worked around with select(new_column_order)</source>
          <target state="translated">&lt;strong&gt;right_join&lt;/strong&gt; (x, y)은 행 측면에서 left_join (y, x)와 동일하지만 열의 순서는 다릅니다. select (new_column_order)로 쉽게 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c8b0aa635a2a6ad43b6f15dacdced43bcb2ee8b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join&quot;&gt;left outer join (or simply left join)&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;df2&lt;/code&gt; 및 df2 의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join&quot;&gt;왼쪽 외부 조인 (또는 간단히 왼쪽 조인)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65bd236cef1312710765c40a2d7ed2b9ae5d1de6" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Right_outer_join&quot;&gt;right outer join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;df2&lt;/code&gt; 과 df2 의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Right_outer_join&quot;&gt;오른쪽 외부 조인&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a995d5ebe59aa37a58c647f553d519dece05faba" translate="yes" xml:space="preserve">
          <source>A left outer join with df1 on the left using a subscript method would be:</source>
          <target state="translated">아래 첨자 방법을 사용하여 왼쪽에서 df1을 사용하는 왼쪽 외부 조인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0085fab60d07cb78647869bd8cefbf2ec4234148" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join&quot;&gt;inner join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;df2&lt;/code&gt; 및 df2 의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join&quot;&gt;내부 조인&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bf81a3ad99c579907678ed7b25d860ad1049d3a1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Outer_join&quot;&gt;outer join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;df2&lt;/code&gt; 및 df2 의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Outer_join&quot;&gt;외부 조인&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="99e1e176cca1b8231019f4dab468ecffc875a219" translate="yes" xml:space="preserve">
          <source>As @bgoldst's answer mentions, &lt;code&gt;match&lt;/code&gt; with &lt;code&gt;interaction&lt;/code&gt; might be an option for this case. More straightforwardly, one could use data.table:</source>
          <target state="translated">@bgoldst의 답변에서 언급했듯이 &lt;code&gt;interaction&lt;/code&gt; &lt;code&gt;match&lt;/code&gt; 하는 것이이 경우 옵션 일 수 있습니다. 더 간단하게 data.table을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abf28bebf45530a8950f4d9293a4c78cef6b6b00" translate="yes" xml:space="preserve">
          <source>As a side note, I briefly looked into possible matching solutions for multicolumn keys. Unfortunately, the only matching solutions I found were:</source>
          <target state="translated">참고로, 다중 열 키에 대해 가능한 일치하는 솔루션을 간단히 살펴 보았습니다. 불행히도, 내가 찾은 유일한 일치 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f166ad2d60f8daeca4449327bda4a7811ee2769" translate="yes" xml:space="preserve">
          <source>As can be seen here, &lt;code&gt;match&lt;/code&gt; selects the first matching row from the customer table.</source>
          <target state="translated">여기에서 볼 수 있듯이 &lt;code&gt;match&lt;/code&gt; 는 고객 테이블에서 첫 번째로 일치하는 행을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b660aa6af5b76fcb666125e5ca3d5a374b6eebf4" translate="yes" xml:space="preserve">
          <source>Be aware there are other types of joins you can perform using &lt;code&gt;data.table&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;data.table&lt;/code&gt; 을 사용하여 수행 할 수있는 다른 유형의 조인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58719bd04f95ef9656fef30a4d66177a963af55f" translate="yes" xml:space="preserve">
          <source>Below benchmark tests base R, sqldf, dplyr and data.table.</source>
          <target state="translated">아래의 벤치 마크는 R, sqldf, dplyr 및 data.table을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="9afae0499a8b49e7f0ef74e289efbf6ff5cc05de" translate="yes" xml:space="preserve">
          <source>Benchmark tests unkeyed/unindexed datasets.
Benchmark is performed on 50M-1 rows datasets, there are 50M-2 common values on join column so each scenario (inner, left, right, full) can be tested and join is still not trivial to perform. It is type of join which well stress join algorithms. Timings are as of &lt;code&gt;sqldf:0.4.11&lt;/code&gt;, &lt;code&gt;dplyr:0.7.8&lt;/code&gt;, &lt;code&gt;data.table:1.12.0&lt;/code&gt;.</source>
          <target state="translated">벤치 마크는 키가없는 / 인덱싱되지 않은 데이터 세트를 테스트합니다. 벤치 마크는 50M-1 행 데이터 세트에서 수행되며, 조인 열에는 50M-2 공통 값이 있으므로 각 시나리오 (내부, 왼쪽, 오른쪽, 전체)를 테스트 할 수 있으며 조인은 여전히 ​​쉽지 않습니다. 결합 알고리즘을 잘 강조하는 결합 유형입니다. 타이밍은 &lt;code&gt;sqldf:0.4.11&lt;/code&gt; , &lt;code&gt;dplyr:0.7.8&lt;/code&gt; , &lt;code&gt;data.table:1.12.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="031a1bb7db92ad832e32717777d34cb324b9c6c7" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;merge&lt;/code&gt; function and its optional parameters:</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 기능 및 선택적 매개 변수를 사용하여 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0850f670fdb08a62b7a39a07049252d4595216df" translate="yes" xml:space="preserve">
          <source>Can now left_join by different variables in each table: df1 %&amp;gt;% left_join(df2, c(&quot;var1&quot; = &quot;var2&quot;))</source>
          <target state="translated">이제 각 테이블에서 다른 변수로 left_join을 수행 할 수 있습니다. df1 %&amp;gt; % left_join (df2, c ( &quot;var1&quot;= &quot;var2&quot;))</target>
        </trans-unit>
        <trans-unit id="c6e5a298734559d60b7bb8a74b34d9ba6755ed0d" translate="yes" xml:space="preserve">
          <source>Code to reproduce:</source>
          <target state="translated">재현 할 코드 :</target>
        </trans-unit>
        <trans-unit id="c85693681142b2f48692df23c7bd83524829e4cc" translate="yes" xml:space="preserve">
          <source>Efficient alternatives to merge for larger data.frames R</source>
          <target state="translated">더 큰 데이터를 위해 병합 할 수있는 효율적인 대안 프레임 R</target>
        </trans-unit>
        <trans-unit id="a0fb268d8865888849541e2461b53e088d173672" translate="yes" xml:space="preserve">
          <source>Especially if you're also interested in data manipulation in general (including sorting, filtering, subsetting, summarizing etc.), you should definitely take a look at &lt;code&gt;dplyr&lt;/code&gt;, which comes with a variety of functions all designed to facilitate your work specifically with data frames and certain other database types. It even offers quite an elaborate SQL interface, and even a function to convert (most) SQL code directly into R.</source>
          <target state="translated">특히 정렬, 필터링, 하위 설정, 요약 등의 일반적인 데이터 조작에 관심이있는 경우 &lt;code&gt;dplyr&lt;/code&gt; 을 확실히 살펴보십시오 .dplyr 에는 데이터를 사용하여 작업을 용이하게하도록 설계된 다양한 기능이 포함되어 있습니다. 프레임 및 기타 특정 데이터베이스 유형 심지어 매우 정교한 SQL 인터페이스와 (대부분의) SQL 코드를 R로 직접 변환하는 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1cb91a4d85314d943d7ed8d0eb363de15a4cfd5d" translate="yes" xml:space="preserve">
          <source>Example data:</source>
          <target state="translated">데이터 예 :</target>
        </trans-unit>
        <trans-unit id="6d830da55607c318b0229bbe871dede8489bbbcd" translate="yes" xml:space="preserve">
          <source>Extra credit:</source>
          <target state="translated">추가 크레딧 :</target>
        </trans-unit>
        <trans-unit id="cb15184868a7170582b96630a6ea5bb279f5d610" translate="yes" xml:space="preserve">
          <source>Filtering joins: filter out rows in df1, don't modify columns</source>
          <target state="translated">필터링 조인 : df1에서 행을 필터링하고 열을 수정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d9513dbbe672535839baa4a6cc570a53345b40d1" translate="yes" xml:space="preserve">
          <source>For an inner join on all columns, you could also use &lt;code&gt;fintersect&lt;/code&gt; from the &lt;em&gt;data.table&lt;/em&gt;-package or &lt;code&gt;intersect&lt;/code&gt; from the &lt;em&gt;dplyr&lt;/em&gt;-package as an alternative to &lt;code&gt;merge&lt;/code&gt; without specifying the &lt;code&gt;by&lt;/code&gt;-columns. this will give the rows that are equal between two dataframes:</source>
          <target state="translated">모든 열에 대한 내부 조인의 경우 &lt;em&gt;data.table&lt;/em&gt; -package에서 &lt;em&gt;fintersect를&lt;/em&gt; 사용하거나 &lt;em&gt;by -columns&lt;/em&gt; 를 지정하지 않고 &lt;code&gt;merge&lt;/code&gt; 하는 대안으로 &lt;em&gt;dplyr&lt;/em&gt; -package와 &lt;code&gt;intersect&lt;/code&gt; 할 수도 있습니다. 이렇게하면 두 데이터 프레임 사이에 동일한 행이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3ecb0b93f83cfe035b561507dbb9ead3739e0215" translate="yes" xml:space="preserve">
          <source>For example, see &lt;a href=&quot;https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r&quot;&gt;Matching multiple columns on different data frames and getting other column as result&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns&quot;&gt;match two columns with two other columns&lt;/a&gt;, &lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html&quot;&gt;Matching on multiple columns&lt;/a&gt;, and the dupe of this question where I originally came up with the in-place solution, &lt;a href=&quot;https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281&quot;&gt;Combine two data frames with different number of rows in R&lt;/a&gt;.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r&quot;&gt;서로 다른 데이터 프레임에서 여러 열 일치 및 결과로 다른 열 가져 오기&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns&quot;&gt;두 열을 다른 열 두 개&lt;/a&gt; &lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html&quot;&gt;일치, 여러 열&lt;/a&gt; 에서 일치 및 원래 위치 솔루션을 제시 한이 질문의 속임수를 참조하십시오. &lt;a href=&quot;https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281&quot;&gt;R의 행 수가 다른 두 개의 데이터 프레임&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6bc9cab91de980063bff0c869e8cd295f71aeae3" translate="yes" xml:space="preserve">
          <source>For the case of a left join with a &lt;code&gt;0..*:0..1&lt;/code&gt; cardinality or a right join with a &lt;code&gt;0..1:0..*&lt;/code&gt; cardinality it is possible to assign in-place the unilateral columns from the joiner (the &lt;code&gt;0..1&lt;/code&gt; table) directly onto the joinee (the &lt;code&gt;0..*&lt;/code&gt; table), and thereby avoid the creation of an entirely new table of data. This requires matching the key columns from the joinee into the joiner and indexing+ordering the joiner's rows accordingly for the assignment.</source>
          <target state="translated">&lt;code&gt;0..*:0..1&lt;/code&gt; 카디널리티가있는 왼쪽 조인 또는 &lt;code&gt;0..1:0..*&lt;/code&gt; 카디널리티가있는 오른쪽 조인의 경우 결합 자에서 일방 열을 제자리에 할당 할 수 있습니다 ( &lt;code&gt;0..1&lt;/code&gt; 테이블)을 조인 ( &lt;code&gt;0..*&lt;/code&gt; 테이블)에 직접 연결하여 완전히 새로운 데이터 테이블을 만들지 않도록합니다. 이를 위해서는 조인의 키 열을 조인자와 일치시키고 할당에 따라 조인자의 행을 인덱싱 + 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8dae3d6dd66cb4a6e969f2c3e876e1163d52462" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;?join&lt;/code&gt;: Unlike &lt;code&gt;merge&lt;/code&gt;, [&lt;code&gt;join&lt;/code&gt;] preserves the order of x no matter what join type is used.</source>
          <target state="translated">&lt;code&gt;?join&lt;/code&gt; : &lt;code&gt;merge&lt;/code&gt; 와 달리 [ &lt;code&gt;join&lt;/code&gt; ]은 어떤 결합 유형을 사용하든 x의 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4e4ea750b40b9f8fb970aa423721dd8f952b8a95" translate="yes" xml:space="preserve">
          <source>Given two data frames:</source>
          <target state="translated">두 개의 데이터 프레임이 주어지면 :</target>
        </trans-unit>
        <trans-unit id="178043d2a18594ddc9371df094f215781386f9a2" translate="yes" xml:space="preserve">
          <source>Hadley mentioning other advantages here</source>
          <target state="translated">해들리가 여기에 다른 장점을 언급</target>
        </trans-unit>
        <trans-unit id="3e9d24ecb34b0ebaafaf47408d72663265376976" translate="yes" xml:space="preserve">
          <source>Handling for POSIXct type, timezones, duplicates, different factor levels. Better errors and warnings.</source>
          <target state="translated">POSIXct 유형, 시간대, 복제본, 다른 요인 수준에 대한 처리. 더 나은 오류 및 경고.</target>
        </trans-unit>
        <trans-unit id="290e06acecaff168c5348f733abafaff96fe9595" translate="yes" xml:space="preserve">
          <source>Here I benchmark on random input data, trying different scales and different patterns of key overlap between the two input tables. This benchmark is still restricted to the case of a single-column integer key. As well, to ensure that the in-place solution would work for both left and right joins of the same tables, all random test data uses &lt;code&gt;0..1:0..1&lt;/code&gt; cardinality. This is implemented by sampling without replacement the key column of the first data.frame when generating the key column of the second data.frame.</source>
          <target state="translated">여기에서는 임의의 입력 데이터를 벤치마킹하여 두 입력 테이블간에 서로 다른 스케일과 다른 패턴의 키 겹침을 시도합니다. 이 벤치 마크는 여전히 단일 열 정수 키의 경우로 제한됩니다. 또한 내부 솔루션이 동일한 테이블의 왼쪽 및 오른쪽 조인 모두에 대해 작동하도록하기 위해 모든 무작위 테스트 데이터는 &lt;code&gt;0..1:0..1&lt;/code&gt; 카디널리티를 사용합니다. 이것은 두 번째 data.frame의 키 열을 생성 할 때 첫 번째 data.frame의 키 열을 대체하지 않고 샘플링함으로써 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d6852d88aa3e327a146c14342fb3fab571a58e" translate="yes" xml:space="preserve">
          <source>Here's a benchmark of the example based on the OP that I demonstrated earlier:</source>
          <target state="translated">앞에서 설명한 OP를 기반으로 한 예제의 벤치 마크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8081890f19c96944894bdd114482dfc9a75ed29" translate="yes" xml:space="preserve">
          <source>Here's a second large-scale benchmark that's more heavy-duty, with respect to the number and types of key columns, as well as cardinality. For this benchmark I use three key columns: one character, one integer, and one logical, with no restrictions on cardinality (that is, &lt;code&gt;0..*:0..*&lt;/code&gt;). (In general it's not advisable to define key columns with double or complex values due to floating-point comparison complications, and basically no one ever uses the raw type, much less for key columns, so I haven't included those types in the key columns. Also, for information's sake, I initially tried to use four key columns by including a POSIXct key column, but the POSIXct type didn't play well with the &lt;code&gt;sqldf.indexed&lt;/code&gt; solution for some reason, possibly due to floating-point comparison anomalies, so I removed it.)</source>
          <target state="translated">다음은 주요 열의 수와 유형 및 카디널리티와 관련하여 더 강력한 두 번째 대규모 벤치 마크입니다. 이 벤치 마크에서는 카디널리티 (즉, &lt;code&gt;0..*:0..*&lt;/code&gt; )에 제한이없는 하나의 문자, 하나의 정수 및 논리의 세 가지 주요 열을 사용합니다. (일반적으로 부동 소수점 비교 복잡성으로 인해 이중 또는 복잡한 값으로 키 열을 정의하는 것은 바람직하지 않으며 기본적으로 아무도 원시 유형을 사용하지 않으며 키 열에 대해서는 훨씬 적으므로 키에 해당 유형을 포함시키지 않았습니다. 또한 정보를 위해 처음에는 POSIXct 키 열을 포함하여 네 개의 키 열을 사용하려고 시도했지만 POSIXct 유형은 어떤 이유로 &lt;code&gt;sqldf.indexed&lt;/code&gt; 솔루션에서 잘 작동하지 않았으며, 아마도 부동 소수점 비교 이상으로 인해 그래서 제거했습니다.)</target>
        </trans-unit>
        <trans-unit id="4097e5d8cc2075da7471c980add60bad0cf09eb0" translate="yes" xml:space="preserve">
          <source>Here's an example based on the OP, except I've added an extra row to &lt;code&gt;df2&lt;/code&gt; with an id of 7 to test the case of a non-matching key in the joiner. This is effectively &lt;code&gt;df1&lt;/code&gt; left join &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">다음은 조이너에서 일치하지 않는 키의 경우를 테스트하기 위해 id가 7 인 &lt;code&gt;df2&lt;/code&gt; 에 추가 행을 추가 한 것을 제외하고는 OP를 기반으로 한 예입니다. 이것은 효과적으로 &lt;code&gt;df2&lt;/code&gt; 왼쪽 조인 df2입니다 .</target>
        </trans-unit>
        <trans-unit id="044af99ba79865956da778a1334f4f8240c2bf7f" translate="yes" xml:space="preserve">
          <source>How can I do a SQL style select statement?</source>
          <target state="translated">SQL 스타일 select 문을 어떻게 수행 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="43090d2742d9081d6bd0ff68f38627e9993c5976" translate="yes" xml:space="preserve">
          <source>How can I do database style, i.e., &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;sql style, joins&lt;/a&gt;? That is, how do I get:</source>
          <target state="translated">데이터베이스 스타일, 즉 &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;SQL 스타일을 조인하려면&lt;/a&gt; 어떻게해야합니까? 즉, 어떻게 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="87f0bedc362f9948f7a3bb794a94bec592f2987f" translate="yes" xml:space="preserve">
          <source>How to do a basic left outer join with data.table in R?</source>
          <target state="translated">R에서 data.table과 기본 왼쪽 외부 조인을 수행하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="662b552b7e40492af7fd79296b2d468005570929" translate="yes" xml:space="preserve">
          <source>How to do a data.table merge operation</source>
          <target state="translated">data.table 병합 조작을 수행하는 방법</target>
        </trans-unit>
        <trans-unit id="b2997a354edf34b9212b5bede79742efdcd92dac" translate="yes" xml:space="preserve">
          <source>How to join (merge) data frames (inner, outer, left, right)</source>
          <target state="translated">데이터 프레임 결합 (병합) 방법 (내부, 외부, 왼쪽, 오른쪽)</target>
        </trans-unit>
        <trans-unit id="be4f4251a4aa264ff1a5045246798a437e872a51" translate="yes" xml:space="preserve">
          <source>I decided to do my own benchmarking to see how the in-place assignment approach compares to the other solutions that have been offered in this question.</source>
          <target state="translated">내부 할당 방식이이 질문에서 제공 한 다른 솔루션과 어떻게 비교되는지 확인하기 위해 자체 벤치마킹을 수행하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="1433555c3736ee7dc33f6787f0ee5e502257ce77" translate="yes" xml:space="preserve">
          <source>I find the SQL syntax to be simpler and more natural than its R equivalent (but this may just reflect my RDBMS bias).</source>
          <target state="translated">SQL 구문이 R과 동등한 것보다 간단하고 자연 스럽다는 것을 알았습니다 (그러나 이것은 내 RDBMS 편향을 반영 할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="850ce2fc8639be910cca8a142e25a33d5a5324bd" translate="yes" xml:space="preserve">
          <source>I think this is a particularly appropriate solution if you have several tables that you want to left join against a single large table. Repeatedly rebuilding the entire table for each merge would be unnecessary and inefficient.</source>
          <target state="translated">하나의 큰 테이블에 대해 조인하려는 여러 테이블이있는 경우 이것이 특히 적합한 솔루션이라고 생각합니다. 각 병합에 대해 전체 테이블을 반복해서 다시 작성하는 것은 불필요하고 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="81dd38b7e015ec1e1a6ff6776efb1705d815b694" translate="yes" xml:space="preserve">
          <source>I used spline interpolation to show a smooth curve for each solution/join type combination, drawn with individual pch symbols. The join type is captured by the pch symbol, using a dot for inner, left and right angle brackets for left and right, and a diamond for full. The solution type is captured by the color as shown in the legend.</source>
          <target state="translated">스플라인 보간법을 사용하여 개별 pch 기호로 그려진 각 솔루션 / 결합 유형 조합에 대해 부드러운 곡선을 표시했습니다. 결합 유형은 내부, 왼쪽 및 오른쪽 꺾쇠 괄호에 도트를 사용하고 왼쪽에 다이아몬드를 사용하여 pch 기호로 캡처합니다. 솔루션 유형은 범례에 표시된대로 색상으로 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="a8ebc4a7bfcf1453154ce5c9cb696149ac776e30" translate="yes" xml:space="preserve">
          <source>I would recommend checking out &lt;a href=&quot;http://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;Gabor Grothendieck's sqldf package&lt;/a&gt;, which allows you to express these operations in SQL.</source>
          <target state="translated">&lt;a href=&quot;http://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;Gabor Grothendieck의 sqldf package를&lt;/a&gt; 확인하여 이러한 작업을 SQL로 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2337e76070232665935ee45908852019881d7dba" translate="yes" xml:space="preserve">
          <source>I wrote some code to create log-log plots of the above results. I generated a separate plot for each overlap percentage. It's a little bit cluttered, but I like having all the solution types and join types represented in the same plot.</source>
          <target state="translated">위의 결과에 대한 로그 로그 플롯을 작성하는 코드를 작성했습니다. 각 중복 비율에 대해 별도의 플롯을 생성했습니다. 약간 혼란 스럽지만 모든 솔루션 유형과 조인 유형이 동일한 플롯으로 표시되는 것을 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="710e748e65ff61225c32f7870e72f52de5d5471e" translate="yes" xml:space="preserve">
          <source>If the column names to merge on are not the same, you can specify, e.g., &lt;code&gt;by.x = &quot;CustomerId_in_df1&quot;, by.y = &quot;CustomerId_in_df2&quot;&lt;/code&gt; where &lt;code&gt;CustomerId_in_df1&lt;/code&gt; is the name of the column in the first data frame and &lt;code&gt;CustomerId_in_df2&lt;/code&gt; is the name of the column in the second data frame. (These can also be vectors if you need to merge on multiple columns.)</source>
          <target state="translated">병합 할 열 이름이 동일하지 않은 경우, 예를 들어 &lt;code&gt;by.x = &quot;CustomerId_in_df1&quot;, by.y = &quot;CustomerId_in_df2&quot;&lt;/code&gt; 지정할 수 있습니다. 여기서 &lt;code&gt;CustomerId_in_df1&lt;/code&gt; 은 첫 번째 데이터 프레임의 열 이름이고 &lt;code&gt;CustomerId_in_df2&lt;/code&gt; 는 두 번째 데이터 프레임의 열 이름입니다. 여러 열에서 병합해야하는 경우 벡터가 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8fa4b6558b0a4f2f657a454fe32716ede7c01cf" translate="yes" xml:space="preserve">
          <source>If the key is a single column, then we can use a single call to &lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; to do the matching. This is the case I'll cover in this answer.</source>
          <target state="translated">키가 단일 열인 경우 &lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 를 단일 호출하여 일치 시킬 수 있습니다. 이 답변에서 다룰 내용입니다.</target>
        </trans-unit>
        <trans-unit id="aa34b093d971a035acaf887e23091153f1492e31" translate="yes" xml:space="preserve">
          <source>In joining two data frames with ~1 million rows each, one with 2 columns and the other with ~20, I've surprisingly found &lt;code&gt;merge(..., all.x = TRUE, all.y = TRUE)&lt;/code&gt; to be faster then &lt;code&gt;dplyr::full_join()&lt;/code&gt;. This is with dplyr v0.4</source>
          <target state="translated">각각 ~ 백만 개의 행, 각각 2 개의 열과 ~ 20의 두 데이터 프레임을 결합 &lt;code&gt;merge(..., all.x = TRUE, all.y = TRUE)&lt;/code&gt; 놀랍게도 merge (..., all.x = TRUE, all.y = TRUE) 가 다음보다 빠릅니다. &lt;code&gt;dplyr::full_join()&lt;/code&gt; . 이것은 dplyr v0.4입니다</target>
        </trans-unit>
        <trans-unit id="5a7ff2d9ec551ba208af43332df0b32a7dc8d5b3" translate="yes" xml:space="preserve">
          <source>In the above I hard-coded an assumption that the key column is the first column of both input tables. I would argue that, in general, this is not an unreasonable assumption, since, if you have a data.frame with a key column, it would be strange if it had not been set up as the first column of the data.frame from the outset. And you can always reorder the columns to make it so. An advantageous consequence of this assumption is that the name of the key column does not have to be hard-coded, although I suppose it's just replacing one assumption with another. Concision is another advantage of integer indexing, as well as speed. In the benchmarks below I'll change the implementation to use string name indexing to match the competing implementations.</source>
          <target state="translated">위에서 키 열이 두 입력 테이블의 첫 번째 열이라는 가정을 하드 코딩했습니다. 키 열이있는 data.frame이있는 경우 data.frame의 첫 번째 열로 설정되지 않은 경우 이상한 일이 있기 때문에 일반적으로 이것은 부당한 가정이 아니라고 주장합니다. 처음. 그리고 열을 항상 재정렬하여 열을 만들 수 있습니다. 이 가정의 유리한 결과는 키 열의 이름을 하드 코딩 할 필요가 없다는 것입니다. 단 하나의 가정을 다른 가정으로 대체한다고 가정합니다. 결정은 속도뿐만 아니라 정수 색인의 또 다른 장점입니다. 아래 벤치 마크에서 문자열 이름 인덱싱을 사용하여 경쟁 구현과 일치하도록 구현을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="6250605ea19f359b4292e4f82913fe0d8caae6ab" translate="yes" xml:space="preserve">
          <source>It's all &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html&quot;&gt;here&lt;/a&gt; in great detail.</source>
          <target state="translated">&lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html&quot;&gt;여기&lt;/a&gt; 에 모두 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b091ee98d4a46bacae49eb5f90e7465fe5df5f71" translate="yes" xml:space="preserve">
          <source>Join-related &lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/news/news.html&quot;&gt;release highlights&lt;/a&gt;:</source>
          <target state="translated">조인 관련 &lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/news/news.html&quot;&gt;릴리즈 하이라이트&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ecc363814d7eeefe97adb1b510ca596b8ac8e949" translate="yes" xml:space="preserve">
          <source>Merge takes ~17 seconds, full_join takes ~65 seconds.</source>
          <target state="translated">병합에는 ~ 17 초가 걸리고 full_join에는 ~ 65 초가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="1d04d0125deda2ba2209b50e785af8edc6c62682" translate="yes" xml:space="preserve">
          <source>Modifying the OP's example tables...</source>
          <target state="translated">OP의 예제 테이블 수정 중 ...</target>
        </trans-unit>
        <trans-unit id="cf0e80f7f1862b16f7353cadc5e580929ed727c8" translate="yes" xml:space="preserve">
          <source>Mutating joins, which add new variables to one table from matching rows in another. Filtering joins, which filter observations from one table based on whether or not they match an observation in the other table.</source>
          <target state="translated">하나의 테이블에 다른 변수와 일치하는 행에서 새 변수를 추가하는 결합 조인. 필터링 조인-다른 테이블의 관측치와 일치하는지 여부에 따라 한 테이블의 관측치를 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="76494af2798aaf4f5297aa9a9455435c0a1baae3" translate="yes" xml:space="preserve">
          <source>Mutating joins: add columns to df1 using matches in df2</source>
          <target state="translated">조인 변경 : df2의 일치 항목을 사용하여 df1에 열 추가</target>
        </trans-unit>
        <trans-unit id="4f7e10e539fcde0fedb67622c28ce2185dc8d4fe" translate="yes" xml:space="preserve">
          <source>New in 2014:</source>
          <target state="translated">2014 년 새로운 기능 :</target>
        </trans-unit>
        <trans-unit id="da097f490eba3885863a0e13ce340e42d5855b1e" translate="yes" xml:space="preserve">
          <source>New suffix argument to control what suffix duplicated variable names receive (#1296)</source>
          <target state="translated">접미사 중복 변수 이름에 수신되는 것을 제어하는 ​​새로운 접미사 인수 (# 1296)</target>
        </trans-unit>
        <trans-unit id="b93e636c4795007ba0754843b031729197bf6b22" translate="yes" xml:space="preserve">
          <source>On the other hand, if you need the joinee to remain unaltered through this operation for whatever reason, then this solution cannot be used, since it modifies the joinee directly. Although in that case you could simply make a copy and perform the in-place assignment(s) on the copy.</source>
          <target state="translated">반면에 어떤 이유로 든이 작업을 통해 변경없이 참여자가 필요하면이 솔루션을 사용하면 참여자가 직접 수정되므로 사용할 수 없습니다. 이 경우 간단하게 사본을 작성하고 사본에서 적절한 위치 지정을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="275a3e036899aeaeaf21926f7f5568683b2bb806" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;type&lt;/code&gt;: &lt;code&gt;inner&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 옵션 : &lt;code&gt;inner&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;full&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff2431181fc9fc2e60070beaa227805ee647ef62" translate="yes" xml:space="preserve">
          <source>R :- &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y =
&quot;CustomerId&quot;)[,names(df2)]&lt;/code&gt;</source>
          <target state="translated">R : &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df2)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a90a1fd62b7cfb3514800d395f4aa530d9d32189" translate="yes" xml:space="preserve">
          <source>R :- &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df1)]&lt;/code&gt;</source>
          <target state="translated">R : &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fe4364f88f74f296de93af3b3599121f64037b6" translate="yes" xml:space="preserve">
          <source>Return all rows from the left table, and any rows with matching keys from the right table.</source>
          <target state="translated">왼쪽 테이블의 모든 행과 오른쪽 테이블의 키가 일치하는 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b075052cf9c2a92043b4c19e839781e4f2bb219e" translate="yes" xml:space="preserve">
          <source>Return all rows from the right table, and any rows with matching keys from the left table.</source>
          <target state="translated">오른쪽 테이블의 모든 행과 왼쪽 테이블의 키가 일치하는 행을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="256ebb1bf5d1b1490ada37135eaa9f3ef9b55410" translate="yes" xml:space="preserve">
          <source>Return only the rows in which the left table have matching keys in the right table.</source>
          <target state="translated">왼쪽 테이블에서 오른쪽 테이블에 일치하는 키가있는 행만 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="e571ab9ca057fdce414c471714347a24e546c952" translate="yes" xml:space="preserve">
          <source>Returns all rows from both tables, join records from the left which have matching keys in the right table.</source>
          <target state="translated">두 테이블에서 모든 행을 리턴하고 오른쪽 테이블에 일치하는 키가있는 왼쪽에서 레코드를 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="9e5d4b98769be55db1d88583ac64d18adb2b96ab" translate="yes" xml:space="preserve">
          <source>SQL :-  &lt;code&gt;select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</source>
          <target state="translated">SQL : &lt;code&gt;select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1040827d8fcc05e6ced9f587ad7e4394f6d46db" translate="yes" xml:space="preserve">
          <source>SQL :- &lt;code&gt;select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</source>
          <target state="translated">SQL : &lt;code&gt;select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="182e27662bc0db38ceece5dd2e17427203440683" translate="yes" xml:space="preserve">
          <source>Same way</source>
          <target state="translated">같은 길</target>
        </trans-unit>
        <trans-unit id="36d2d63aaf03c9e36ebc4dc91950d14a746e0b3d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/ggrothendieck/sqldf#example-4-join&quot;&gt;Gabor's sqldf GitHub&lt;/a&gt; for more information on joins.</source>
          <target state="translated">조인에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/ggrothendieck/sqldf#example-4-join&quot;&gt;Gabor의 sqldf GitHub&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="410c9a8726f8cbd1c1e586b81fe174b89fccc09b" translate="yes" xml:space="preserve">
          <source>Selecting columns can be done by &lt;code&gt;select(df,&quot;column&quot;)&lt;/code&gt;. If that's not SQL-ish enough for you, then there's the &lt;code&gt;sql()&lt;/code&gt; function, into which you can enter SQL code as-is, and it will do the operation you specified just like you were writing in R all along (for more information, please refer to the &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html&quot;&gt;dplyr/databases vignette&lt;/a&gt;). For example, if applied correctly, &lt;code&gt;sql(&quot;SELECT * FROM hflights&quot;)&lt;/code&gt; will select all the columns from the &quot;hflights&quot; dplyr table (a &quot;tbl&quot;).</source>
          <target state="translated">&lt;code&gt;select(df,&quot;column&quot;)&lt;/code&gt; 을 선택할 수 있습니다. 그것이 충분하지 않은 SQL-ish라면 SQL 코드를 그대로 입력 할 수있는 &lt;code&gt;sql()&lt;/code&gt; 함수가 있으며 R로 작성하는 것처럼 지정한 작업을 수행합니다 (자세한 정보는 &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html&quot;&gt;dplyr / databases 비네팅을&lt;/a&gt; 참조하십시오). 예를 들어, 올바르게 적용되면 &lt;code&gt;sql(&quot;SELECT * FROM hflights&quot;)&lt;/code&gt; 은 &quot;hflights&quot;dplyr 테이블 ( &quot;tbl&quot;)에서 모든 열을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="89f032298f21e2eb6484041690c0b5f31f1c9852" translate="yes" xml:space="preserve">
          <source>Since your keys are named the same the short way to do an inner join is merge():</source>
          <target state="translated">키 이름이 동일하기 때문에 내부 조인을 수행하는 짧은 방법은 merge ()입니다.</target>
        </trans-unit>
        <trans-unit id="09f26ff5d7f001a9ebafb1da072687d91833c703" translate="yes" xml:space="preserve">
          <source>Some food for though, since I generally default to dplyr for manipulation tasks.</source>
          <target state="translated">비록 일반적으로 조작 작업을 위해 dplyr을 기본값으로 사용하기 때문에 일부 음식.</target>
        </trans-unit>
        <trans-unit id="fed6f49e983aa5bd71ca7e1155b989e6e3375280" translate="yes" xml:space="preserve">
          <source>Suppose we want to add the customer's state from &lt;code&gt;cust&lt;/code&gt; to the purchases table, &lt;code&gt;sales&lt;/code&gt;, ignoring the year column. With base R, we can identify matching rows and then copy values over:</source>
          <target state="translated">연도 열을 무시하고 고객 상태를 &lt;code&gt;cust&lt;/code&gt; 에서 구매 테이블 인 &lt;code&gt;sales&lt;/code&gt; 에 추가한다고 가정합니다. 기본 R을 사용하면 일치하는 행을 식별 한 후 다음을 통해 값을 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc0804bbd7e4d942d5dec0c858695fe81456d52e" translate="yes" xml:space="preserve">
          <source>Testing code:</source>
          <target state="translated">테스트 코드 :</target>
        </trans-unit>
        <trans-unit id="4d2affb1e17938190686ba88646124834885e979" translate="yes" xml:space="preserve">
          <source>The four joining-related functions in the dplyr package are (to quote):</source>
          <target state="translated">dplyr 패키지의 4 가지 조인 관련 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="975fec70202257751857627844d9ba0efd8ac25c" translate="yes" xml:space="preserve">
          <source>The other combination of outer joins can be created by mungling the left outer join subscript example. (yeah, I know that's the equivalent of saying &quot;I'll leave it as an exercise for the reader...&quot;)</source>
          <target state="translated">외부 외부 조인의 다른 조합은 왼쪽 외부 조인 첨자 예제를 병합하여 만들 수 있습니다. (그렇습니다. &quot;독자의 연습 문제로 남겨 두겠습니다&quot;라고 말하는 것과 같습니다.)</target>
        </trans-unit>
        <trans-unit id="cfb49dc74158670dddef83e622172c7c91441e36" translate="yes" xml:space="preserve">
          <source>The resulting plots, using the same plotting code given above:</source>
          <target state="translated">위에 제공된 동일한 플로팅 코드를 사용한 결과 플롯 :</target>
        </trans-unit>
        <trans-unit id="3fd1810b687b3f6297e5dacac6cd2f293af39cd7" translate="yes" xml:space="preserve">
          <source>The three examples above all focus on creating/adding a new column. See &lt;a href=&quot;https://stackoverflow.com/q/6112260&quot;&gt;the related R FAQ&lt;/a&gt; for an example of updating/modifying an existing column.</source>
          <target state="translated">위의 세 가지 예는 모두 새 열 생성 / 추가에 중점을 둡니다. 기존 열을 업데이트 / 수정하는 예 &lt;a href=&quot;https://stackoverflow.com/q/6112260&quot;&gt;는 관련 R FAQ&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cecd23eb962bc5d6748ad3fb34f5562f803499f5" translate="yes" xml:space="preserve">
          <source>There are some good examples of doing this over at the &lt;a href=&quot;http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge&quot;&gt;R Wiki&lt;/a&gt;. I'll steal a couple here:</source>
          <target state="translated">&lt;a href=&quot;http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge&quot;&gt;R Wiki&lt;/a&gt; 에서이 작업을 수행하는 좋은 예가 있습니다. 나는 여기에 몇을 훔칠 것이다 :</target>
        </trans-unit>
        <trans-unit id="d8d441f0127df63fc7e588978f519a0a7110a1d7" translate="yes" xml:space="preserve">
          <source>There is the &lt;strong&gt;data.table&lt;/strong&gt; approach for an inner join, which is very time and memory efficient (and necessary for some larger data.frames):</source>
          <target state="translated">내부 조인에는 &lt;strong&gt;data.table&lt;/strong&gt; 접근 방식이 있으며 시간과 메모리 효율성이 뛰어나며 더 큰 데이터 프레임에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e97719490cc7ca28a945d219ef810933fffa9275" translate="yes" xml:space="preserve">
          <source>Translating SQL joins on foreign keys to R data.table syntax</source>
          <target state="translated">외래 키의 SQL 조인을 R 데이터로 변환</target>
        </trans-unit>
        <trans-unit id="def30251a119892b32dc57973f51d84d2b8a55a3" translate="yes" xml:space="preserve">
          <source>Update on data.table methods for joining datasets. See below examples for each type of join. There are two methods, one from &lt;code&gt;[.data.table&lt;/code&gt; when passing second data.table as the first argument to subset, another way is to use &lt;code&gt;merge&lt;/code&gt; function which dispatches to fast data.table method.</source>
          <target state="translated">데이터 세트 가입을위한 data.table 메서드 업데이트 각 조인 유형에 대한 아래 예를 참조하십시오. 두 번째 data.table을 하위 인수에 대한 첫 번째 인수로 전달할 때 &lt;code&gt;[.data.table&lt;/code&gt; 에서 두 가지 방법이 있으며, 다른 방법은 빠른 data.table 메서드로 디스패치하는 &lt;code&gt;merge&lt;/code&gt; 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b7fa59fc1d348ab50e552c606a943a4fb3428d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;merge&lt;/code&gt; function we can select the variable of left table or right table, same way like we all familiar with select statement in SQL (EX : Select a.* ...or Select b.* from .....)</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 함수를 사용하면 SQL의 select 문에 익숙한 것처럼 왼쪽 테이블 또는 오른쪽 테이블의 변수를 선택할 수 있습니다 (EX : Select a. * ... 또는 Select b. * from .....)</target>
        </trans-unit>
        <trans-unit id="777e443e9e2269e9c7657e5c1bb5b4ef07dd5d99" translate="yes" xml:space="preserve">
          <source>We have to add extra code which will subset from the newly joined table .</source>
          <target state="translated">우리는 새로 조인 된 테이블에서 부분 집합되는 코드를 추가해야한다.</target>
        </trans-unit>
        <trans-unit id="35f9f5a0a66021813e967af96baa693e8e91102d" translate="yes" xml:space="preserve">
          <source>Workarounds per hadley's comments in that issue:</source>
          <target state="translated">해당 문제에 대한 hadley의 의견에 대한 해결 방법 :</target>
        </trans-unit>
        <trans-unit id="20e71a92fd73f1ea6448c8ce19a1b28c6fd612ab" translate="yes" xml:space="preserve">
          <source>Yet another option is the &lt;code&gt;join&lt;/code&gt; function found in the &lt;a href=&quot;http://cran.r-project.org/web/packages/plyr/index.html&quot;&gt;&lt;strong&gt;plyr&lt;/strong&gt;&lt;/a&gt; package</source>
          <target state="translated">또 다른 옵션은 &lt;a href=&quot;http://cran.r-project.org/web/packages/plyr/index.html&quot;&gt;&lt;strong&gt;plyr&lt;/strong&gt;&lt;/a&gt; 패키지에있는 &lt;code&gt;join&lt;/code&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a4ca82ec6e06c0c6954a4927a77918e335215d61" translate="yes" xml:space="preserve">
          <source>You can do joins as well using Hadley Wickham's awesome &lt;a href=&quot;http://blog.rstudio.org/2014/01/17/introducing-dplyr/&quot;&gt;dplyr&lt;/a&gt; package.</source>
          <target state="translated">Hadley Wickham의 멋진 &lt;a href=&quot;http://blog.rstudio.org/2014/01/17/introducing-dplyr/&quot;&gt;dplyr&lt;/a&gt; 패키지를 사용하여 조인을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5724e67f3f18acb7528650cc64cff7877156db95" translate="yes" xml:space="preserve">
          <source>You can merge on multiple columns by giving &lt;code&gt;by&lt;/code&gt; a vector, e.g., &lt;code&gt;by = c(&quot;CustomerId&quot;, &quot;OrderId&quot;)&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;by = c(&quot;CustomerId&quot;, &quot;OrderId&quot;)&lt;/code&gt; 같이 벡터를 제공 &lt;code&gt;by&lt;/code&gt; 여러 열을 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf2d2dee20b0fe4b4b6a2f7726c0245d830c0168" translate="yes" xml:space="preserve">
          <source>a full inner join (all records from both tables) can be created with the &quot;all&quot; keyword:</source>
          <target state="translated">&quot;all&quot;키워드를 사용하여 전체 내부 조인 (두 테이블의 모든 레코드)을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45b24f5fc4c5960be3b959ba6f2bc3227a86250d" translate="yes" xml:space="preserve">
          <source>a left outer join of df1 and df2:</source>
          <target state="translated">df1 및 df2의 왼쪽 외부 조인 :</target>
        </trans-unit>
        <trans-unit id="6d47d87da3f640b3f3ac9043cf30483af1712d57" translate="yes" xml:space="preserve">
          <source>a right outer join of df1 and df2:</source>
          <target state="translated">df1과 df2의 오른쪽 외부 조인 :</target>
        </trans-unit>
        <trans-unit id="f00d083db7a975f33fd38e2809f8dd64537504aa" translate="yes" xml:space="preserve">
          <source>base R &lt;code&gt;merge()&lt;/code&gt; and equivalent package-based merge functions, which always allocate a new table to return the merged result, and thus are not suitable for an in-place assignment-based solution.</source>
          <target state="translated">기본 R &lt;code&gt;merge()&lt;/code&gt; 및 동등한 패키지 기반 병합 함수. 병합 된 결과를 리턴하기 위해 항상 새 테이블을 할당하므로 인플레 이스 지정 기반 솔루션에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abfb07f46a8b85131c33b5c00be46ae3ec4d825a" translate="yes" xml:space="preserve">
          <source>data.table documented on stackoverflow:</source>
          <target state="translated">stackoverflow에 문서화 된 data.table :</target>
        </trans-unit>
        <trans-unit id="739d53834e2598c061e546b33d4c497722f8aa6e" translate="yes" xml:space="preserve">
          <source>didn't yet &lt;a href=&quot;https://github.com/hadley/dplyr/issues/96&quot;&gt;implement right_join and &lt;strong&gt;outer_join&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/hadley/dplyr/issues/96&quot;&gt;right_join 및 &lt;strong&gt;outer_join을&lt;/strong&gt;&lt;/a&gt; 아직 구현 하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3dc4f0b439d260cec5f45060722ff170e14ccd80" translate="yes" xml:space="preserve">
          <source>dplyr since 0.4 implemented all those joins including &lt;code&gt;outer_join&lt;/code&gt;, but it was worth noting that &lt;strong&gt;for the first few releases prior to 0.4 it used not to offer &lt;code&gt;outer_join&lt;/code&gt;, and as a result there was a lot of really bad hacky workaround user code floating around for quite a while afterwards (you can still find such code in SO, Kaggle answers, github from that period. Hence this answer still serves a useful purpose.)&lt;/strong&gt;</source>
          <target state="translated">0.4 이후 dplyr은 outer_join을 포함하여 모든 조인을 구현했지만 &lt;strong&gt;0.4 이전의 첫 번째 릴리스에서는 &lt;code&gt;outer_join&lt;/code&gt; 을 제공하지 않았 으므로 결과적으로 꽤 나쁜 해킹 해결 방법 사용자 코드가 많이&lt;/strong&gt; 있음을 주목할 가치가 &lt;strong&gt;있습니다. 잠시 후에 (여전히 그 코드를 SO, Kaggle에서 대답하고 그 기간의 github에서 이러한 코드를 찾을 수 있습니다. 따라서이 답변은 여전히 ​​유용한 목적으로 사용됩니다.)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61e2da8dd77d5e292248c9fb83d7a134ac198b3a" translate="yes" xml:space="preserve">
          <source>has &lt;strong&gt;inner_join, left_join, semi_join, anti_join&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;inner_join, left_join, semi_join, anti_join이 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091a85912279e018e930a477c24b367571489c0f" translate="yes" xml:space="preserve">
          <source>inefficient cartesian conjunctions, e.g. &lt;code&gt;outer(df1$a,df2$a,`==`) &amp;amp; outer(df1$b,df2$b,`==`)&lt;/code&gt;.</source>
          <target state="translated">비효율적 인 직교 연결 (예 : &lt;code&gt;outer(df1$a,df2$a,`==`) &amp;amp; outer(df1$b,df2$b,`==`)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a34ccb1aad2f513af7c11ec01144f6ab37837eaf" translate="yes" xml:space="preserve">
          <source>inefficient concatenations. e.g. &lt;code&gt;match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))&lt;/code&gt;, or the same idea with &lt;code&gt;paste()&lt;/code&gt;.</source>
          <target state="translated">비효율적 인 연결. 예를 들어 &lt;code&gt;match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))&lt;/code&gt; 또는 &lt;code&gt;paste()&lt;/code&gt; 와 동일한 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="feb96c8e7073f7b49193f9c3ac2e9abbef5ee89f" translate="yes" xml:space="preserve">
          <source>one minor feature merge currently has that dplyr doesn't is &lt;a href=&quot;https://github.com/hadley/dplyr/issues/177&quot;&gt;the ability to have separate by.x,by.y columns&lt;/a&gt; as e.g. Python pandas does.</source>
          <target state="translated">하나의 사소한 기능 병합은 현재 dplyr이 Python pandas와 같이 &lt;a href=&quot;https://github.com/hadley/dplyr/issues/177&quot;&gt;by.x, by.y 열&lt;/a&gt; 을 분리 할 수있는 능력 이 아니라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="b89a4220d42db1407a2fa042c855a3d4652ddd00" translate="yes" xml:space="preserve">
          <source>you can flip 'em, slap 'em and rub 'em down to get the other two outer joins you asked about :)</source>
          <target state="translated">당신은 그것을 뒤집고, 때리고 그들을 문지르면 다른 두 개의 외부 조인을 얻을 수 있습니다 :)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
