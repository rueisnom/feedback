<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1299871">
    <body>
      <group id="1299871">
        <trans-unit id="d47d7caf030340f041a78d2ceb0b7965bda3093d" translate="yes" xml:space="preserve">
          <source>*_join() no longer reorders column names (#324)</source>
          <target state="translated">*_join()不再对列名进行重新排序 (#324)</target>
        </trans-unit>
        <trans-unit id="487b6c91b5261dd50389ad61b918fe7838afe87f" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/12030932/2490497&quot;&gt;rolling join&lt;/a&gt; - if you want merge to be able to match to values from preceeding/following rows by rolling them forward or backward</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/12030932/2490497&quot;&gt;滚动连接&lt;/a&gt; -如果您希望合并能够通过向前或向后滚动它们来匹配行之前/之后的值</target>
        </trans-unit>
        <trans-unit id="84c6f6a09e15ca4a5e7777731b7f61a686126d78" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/25815032/2490497&quot;&gt;overlapping join&lt;/a&gt; - if you want to merge by ranges</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/25815032/2490497&quot;&gt;重叠连接&lt;/a&gt; -如果要按范围合并</target>
        </trans-unit>
        <trans-unit id="afc219bc005a7c35074b4b7bdeb7c70495859d1b" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/3190118/2490497&quot;&gt;update on join&lt;/a&gt; - if you want to lookup values from another table to your main table</source>
          <target state="translated">-连接&lt;a href=&quot;https://stackoverflow.com/q/3190118/2490497&quot;&gt;更新&lt;/a&gt; -如果您想从另一个表到主表中查找值</target>
        </trans-unit>
        <trans-unit id="890d6745a9399241952baa05d0099615ae7dc270" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/41043047/2490497&quot;&gt;non-equi join&lt;/a&gt; - if your join condition is non-equal</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/41043047/2490497&quot;&gt;非&lt;/a&gt;平等加入 -如果您的加入条件不相等</target>
        </trans-unit>
        <trans-unit id="92ed8f843671545e7e2acc8d069fdcc2446feaeb" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/41684012/2490497&quot;&gt;aggregate on join&lt;/a&gt; - if you want to aggregate on key you are joining you do not have to materialize all join results</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/41684012/2490497&quot;&gt;聚集联接&lt;/a&gt; -如果要聚集正在联接的键，则不必实现所有联接结果</target>
        </trans-unit>
        <trans-unit id="07ce8fe7aebda33b8d668e59d9c852c30c95ed33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anti_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x
where there are not matching values in y, keeping just columns from x</source>
          <target state="translated">&lt;code&gt;anti_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; ：从x返回所有行，其中y中没有匹配值，仅保留x中的列</target>
        </trans-unit>
        <trans-unit id="846866e1d2e49dece784b5f56afce637ce3acb5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inner_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from
x where there are matching values in y, and all columns from x and y</source>
          <target state="translated">&lt;code&gt;inner_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; ：从x中返回所有行，其中y中有匹配值，并且返回来自x和y的所有列</target>
        </trans-unit>
        <trans-unit id="4756dd78d19e6570c93a82eb2702ffcd868aa1a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x, and all columns from x and y</source>
          <target state="translated">&lt;code&gt;left_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; ：返回x的所有行以及x和y的所有列</target>
        </trans-unit>
        <trans-unit id="b1ac4ba54b36075fe4e311146847172ffda51a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; also works on data.tables (as it is generic and calls &lt;code&gt;merge.data.table&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 也适用于data.tables（因为它是通用的，并调用 &lt;code&gt;merge.data.table&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8c0dab1fb7e149efd4ef02ea7323dd1028acf2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;semi_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x where there are matching values in
y, keeping just columns from x.</source>
          <target state="translated">&lt;code&gt;semi_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; ：返回x中的所有行，其中y中有匹配的值，仅保留x中的列。</target>
        </trans-unit>
        <trans-unit id="64447dc8e6edd1cc9f32821eb103cfca1f89e9cb" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;Just as with the inner join, you would probably want to explicitly pass &quot;CustomerId&quot; to R as the matching variable.&lt;/strike&gt;  I think it's almost always best to explicitly state the identifiers on which you want to merge; it's safer if the input data.frames change unexpectedly and easier to read later on.</source>
          <target state="translated">&lt;strike&gt;与内部联接一样，您可能希望将&amp;ldquo; CustomerId&amp;rdquo;显式传递给R作为匹配变量。&lt;/strike&gt; 我认为几乎总是最好明确声明要合并的标识符。 如果输入data.frames发生意外更改，则更安全，以后更易于阅读。</target>
        </trans-unit>
        <trans-unit id="8f2b37c4fd55625fd3e73914491c5bd0dc311ccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Cross join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = NULL)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;交叉&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = NULL)&lt;/code&gt; &lt;strong&gt;&lt;em&gt;：&lt;/em&gt;&lt;/strong&gt; merge（x = df1，y = df2，by = NULL）</target>
        </trans-unit>
        <trans-unit id="a8a7da9103d4d41873615a068f57166a2b7778c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Inner join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(df1, df2)&lt;/code&gt; will work for these examples because R automatically joins the frames by common variable names, but you would most likely want to specify &lt;code&gt;merge(df1, df2, by = &quot;CustomerId&quot;)&lt;/code&gt; to make sure that you were matching on only the fields you desired.  You can also use the &lt;code&gt;by.x&lt;/code&gt; and &lt;code&gt;by.y&lt;/code&gt; parameters if the matching variables have different names in the different data frames.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;内部&lt;/em&gt;&lt;/strong&gt;联接&lt;strong&gt;&lt;em&gt;：&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(df1, df2)&lt;/code&gt; 将适用于这些示例，因为R通过公共变量名称自动联接框架，但是您很可能希望指定 &lt;code&gt;merge(df1, df2, by = &quot;CustomerId&quot;)&lt;/code&gt; 以确保您仅在您想要的字段上匹配。 如果匹配的变量在不同的数据帧中具有不同的名称，则也可以使用 &lt;code&gt;by.x&lt;/code&gt; 和 &lt;code&gt;by.y&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="038870ab05a425a137f8fbbc279dda97c77d683f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Left outer:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;左外侧：&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72ebaef810f98fc55883bca7f5dfd5acba8a9cae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Outer join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;外部&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE)&lt;/code&gt; &lt;strong&gt;&lt;em&gt;：&lt;/em&gt;&lt;/strong&gt; merge（x = df1，y = df2，通过=&amp;ldquo; CustomerId&amp;rdquo;，所有= TRUE）</target>
        </trans-unit>
        <trans-unit id="dab4ebd7ed185ebd97efccd2c02d50ba28589364" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Right outer:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;右外部：&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="feb6dda0b81cd0e64ea3c74f9c8b636b97c7342f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.1.3&lt;/em&gt;&lt;/strong&gt; (4/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.1.3&lt;/em&gt;&lt;/strong&gt; （4/2014）</target>
        </trans-unit>
        <trans-unit id="977c100088eecd2687b330acb3b61630e1c463ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.2&lt;/em&gt;&lt;/strong&gt; (5/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.2&lt;/em&gt;&lt;/strong&gt; （5/2014）</target>
        </trans-unit>
        <trans-unit id="9d1100b98263dbf4dd0f99865af468f7b55e605f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.3&lt;/em&gt;&lt;/strong&gt; (10/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.3&lt;/em&gt;&lt;/strong&gt; （10/2014）</target>
        </trans-unit>
        <trans-unit id="bd8720e189cc792821196cc8bacaf98d3035fecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.4.0&lt;/em&gt;&lt;/strong&gt; (1/2015)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.4.0&lt;/em&gt;&lt;/strong&gt; （1/2015）</target>
        </trans-unit>
        <trans-unit id="66e75518de390f9fe0e9e80b4cbab16a3bcb592b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.5&lt;/em&gt;&lt;/strong&gt; (6/2016)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.5&lt;/em&gt;&lt;/strong&gt; （6/2016）</target>
        </trans-unit>
        <trans-unit id="7d481f74b71e19ee13eac5a4c57e4f92286ac1b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implement right join and outer join&lt;/strong&gt; (#96)</source>
          <target state="translated">&lt;strong&gt;实现右联接和外联接&lt;/strong&gt; （＃96）</target>
        </trans-unit>
        <trans-unit id="7d863a7bd89469b75eeee503d3a69a99724f4c9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Merge Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;合并方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="631fffa31418327ad1ceee06912e77e433c2a830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rolling update join.&lt;/strong&gt; Alternately, we may want to take the last state the customer was found in:</source>
          <target state="translated">&lt;strong&gt;滚动更新联接。&lt;/strong&gt; 或者，我们可能希望采用在以下位置找到客户的最新状态：</target>
        </trans-unit>
        <trans-unit id="16a449699f13e0f7577783adc61a84fa6b01f031" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscript Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;下标方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b809d4e294824a9bd8793db2c442bcc11490e805" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update join with multiple columns.&lt;/strong&gt; The approach above works well when we are joining on only a single column and are satisfied with the first match. Suppose we want the year of measurement in the customer table to match the year of sale.</source>
          <target state="translated">&lt;strong&gt;更新具有多个列的联接。&lt;/strong&gt; 当我们仅在单个列上联接并且对第一个匹配感到满意时，上述方法效果很好。 假设我们希望客户表中的度量年份与销售年份相匹配。</target>
        </trans-unit>
        <trans-unit id="60c8303c5c795a80894a040e6ad09b86a234618e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update join.&lt;/strong&gt; One other important SQL-style join is an &quot;&lt;a href=&quot;https://stackoverflow.com/q/7869592/&quot;&gt;update join&lt;/a&gt;&quot; where columns in one table are updated (or created) using another table.</source>
          <target state="translated">&lt;strong&gt;更新联接。&lt;/strong&gt; 另一种重要的SQL风格的联接是&amp;ldquo; &lt;a href=&quot;https://stackoverflow.com/q/7869592/&quot;&gt;更新&lt;/a&gt;联接&amp;rdquo;，其中使用另一个表更新（或创建）一个表中的列。</target>
        </trans-unit>
        <trans-unit id="d36e434acda5756c7bc2a0734856c0841c167a0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;outer_join&lt;/strong&gt; is basically union(left_join(x, y), right_join(x, y)) - i.e. preserve all rows in both data frames.</source>
          <target state="translated">&lt;strong&gt;external_join&lt;/strong&gt;基本上是union（left_join（x，y），right_join（x，y））-即保留两个数据帧中的所有行。</target>
        </trans-unit>
        <trans-unit id="e65d821137f54f3e9e9fa6bf3d532f2edb926dc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;outer_join&lt;/strong&gt; not implemented yet, fallback is use base::merge() (or plyr::join())</source>
          <target state="translated">&lt;strong&gt;outside_join&lt;/strong&gt;尚未实现，回退使用base :: merge（）（或plyr :: join（））</target>
        </trans-unit>
        <trans-unit id="7af98f3c825f135edda87f9c794dac0060279aa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;right_join&lt;/strong&gt;(x,y) is the same as left_join(y,x) in terms of the rows, just the columns will be different orders. Easily worked around with select(new_column_order)</source>
          <target state="translated">&lt;strong&gt;right_join&lt;/strong&gt; （x，y）在行方面与left_join（y，x）相同，只是列的顺序不同。 使用select（new_column_order）轻松解决</target>
        </trans-unit>
        <trans-unit id="0c8b0aa635a2a6ad43b6f15dacdced43bcb2ee8b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join&quot;&gt;left outer join (or simply left join)&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;df1&lt;/code&gt; 和 &lt;code&gt;df2&lt;/code&gt; 的 &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join&quot;&gt;左外部联接（或简称为左&lt;/a&gt; 联接）</target>
        </trans-unit>
        <trans-unit id="65bd236cef1312710765c40a2d7ed2b9ae5d1de6" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Right_outer_join&quot;&gt;right outer join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;df1&lt;/code&gt; 和 &lt;code&gt;df2&lt;/code&gt; 的 &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Right_outer_join&quot;&gt;右外部连接&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a995d5ebe59aa37a58c647f553d519dece05faba" translate="yes" xml:space="preserve">
          <source>A left outer join with df1 on the left using a subscript method would be:</source>
          <target state="translated">用下标的方法在左边的外侧连接 df1 是:</target>
        </trans-unit>
        <trans-unit id="0085fab60d07cb78647869bd8cefbf2ec4234148" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join&quot;&gt;inner join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;df1&lt;/code&gt; 和 &lt;code&gt;df2&lt;/code&gt; 的&lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join&quot;&gt;内部&lt;/a&gt; 联接 ：</target>
        </trans-unit>
        <trans-unit id="bf81a3ad99c579907678ed7b25d860ad1049d3a1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Outer_join&quot;&gt;outer join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;df1&lt;/code&gt; 和 &lt;code&gt;df2&lt;/code&gt; 的&lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Outer_join&quot;&gt;外部&lt;/a&gt; 联接 ：</target>
        </trans-unit>
        <trans-unit id="99e1e176cca1b8231019f4dab468ecffc875a219" translate="yes" xml:space="preserve">
          <source>As @bgoldst's answer mentions, &lt;code&gt;match&lt;/code&gt; with &lt;code&gt;interaction&lt;/code&gt; might be an option for this case. More straightforwardly, one could use data.table:</source>
          <target state="translated">正如@bgoldst的答案所提到的，在这种情况下，与 &lt;code&gt;interaction&lt;/code&gt; &lt;code&gt;match&lt;/code&gt; 可能是一种选择。 更直接地说，可以使用data.table：</target>
        </trans-unit>
        <trans-unit id="abf28bebf45530a8950f4d9293a4c78cef6b6b00" translate="yes" xml:space="preserve">
          <source>As a side note, I briefly looked into possible matching solutions for multicolumn keys. Unfortunately, the only matching solutions I found were:</source>
          <target state="translated">作为一个侧面的说明,我简单地研究了一下多列键的可能匹配方案。不幸的是,我找到的唯一的匹配方案是。</target>
        </trans-unit>
        <trans-unit id="4f166ad2d60f8daeca4449327bda4a7811ee2769" translate="yes" xml:space="preserve">
          <source>As can be seen here, &lt;code&gt;match&lt;/code&gt; selects the first matching row from the customer table.</source>
          <target state="translated">如此处所示， &lt;code&gt;match&lt;/code&gt; 从客户表中选择第一个匹配行。</target>
        </trans-unit>
        <trans-unit id="b660aa6af5b76fcb666125e5ca3d5a374b6eebf4" translate="yes" xml:space="preserve">
          <source>Be aware there are other types of joins you can perform using &lt;code&gt;data.table&lt;/code&gt;:</source>
          <target state="translated">请注意，您还可以使用 &lt;code&gt;data.table&lt;/code&gt; 执行其他类型的联接：</target>
        </trans-unit>
        <trans-unit id="58719bd04f95ef9656fef30a4d66177a963af55f" translate="yes" xml:space="preserve">
          <source>Below benchmark tests base R, sqldf, dplyr and data.table.</source>
          <target state="translated">下面是基准测试基础R、sqldf、dplyr和data.table。</target>
        </trans-unit>
        <trans-unit id="9afae0499a8b49e7f0ef74e289efbf6ff5cc05de" translate="yes" xml:space="preserve">
          <source>Benchmark tests unkeyed/unindexed datasets.
Benchmark is performed on 50M-1 rows datasets, there are 50M-2 common values on join column so each scenario (inner, left, right, full) can be tested and join is still not trivial to perform. It is type of join which well stress join algorithms. Timings are as of &lt;code&gt;sqldf:0.4.11&lt;/code&gt;, &lt;code&gt;dplyr:0.7.8&lt;/code&gt;, &lt;code&gt;data.table:1.12.0&lt;/code&gt;.</source>
          <target state="translated">基准测试未加密/未索引的数据集。 基准测试是对50M-1行数据集执行的，联接列上有50M-2个公共值，因此可以测试每种情况（内部，左，右，完整），联接仍然不容易执行。 这种连接类型很好地强调了连接算法。 时间从 &lt;code&gt;sqldf:0.4.11&lt;/code&gt; ， &lt;code&gt;dplyr:0.7.8&lt;/code&gt; &lt;code&gt;data.table:1.12.0&lt;/code&gt; ， data.table：1.12.0开始 。</target>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="031a1bb7db92ad832e32717777d34cb324b9c6c7" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;merge&lt;/code&gt; function and its optional parameters:</source>
          <target state="translated">通过使用 &lt;code&gt;merge&lt;/code&gt; 功能及其可选参数：</target>
        </trans-unit>
        <trans-unit id="0850f670fdb08a62b7a39a07049252d4595216df" translate="yes" xml:space="preserve">
          <source>Can now left_join by different variables in each table: df1 %&amp;gt;% left_join(df2, c(&quot;var1&quot; = &quot;var2&quot;))</source>
          <target state="translated">现在可以通过每个表中的不同变量进行left_join了：df1％&amp;gt;％left_join（df2，c（&amp;ldquo; var1&amp;rdquo; =&amp;ldquo; var2&amp;rdquo;））</target>
        </trans-unit>
        <trans-unit id="c6e5a298734559d60b7bb8a74b34d9ba6755ed0d" translate="yes" xml:space="preserve">
          <source>Code to reproduce:</source>
          <target state="translated">代码重现。</target>
        </trans-unit>
        <trans-unit id="c85693681142b2f48692df23c7bd83524829e4cc" translate="yes" xml:space="preserve">
          <source>Efficient alternatives to merge for larger data.frames R</source>
          <target state="translated">合并大数据的有效替代方案 R</target>
        </trans-unit>
        <trans-unit id="a0fb268d8865888849541e2461b53e088d173672" translate="yes" xml:space="preserve">
          <source>Especially if you're also interested in data manipulation in general (including sorting, filtering, subsetting, summarizing etc.), you should definitely take a look at &lt;code&gt;dplyr&lt;/code&gt;, which comes with a variety of functions all designed to facilitate your work specifically with data frames and certain other database types. It even offers quite an elaborate SQL interface, and even a function to convert (most) SQL code directly into R.</source>
          <target state="translated">尤其是如果您也对一般的数据操作（包括排序，过滤，子集，汇总等）感兴趣，那么您绝对应该看看 &lt;code&gt;dplyr&lt;/code&gt; ，它带有多种功能，旨在帮助您专门处理数据框架和某些其他数据库类型。 它甚至提供了相当复杂的SQL接口，甚至提供了将（大多数）SQL代码直接转换为R的功能。</target>
        </trans-unit>
        <trans-unit id="1cb91a4d85314d943d7ed8d0eb363de15a4cfd5d" translate="yes" xml:space="preserve">
          <source>Example data:</source>
          <target state="translated">数据示例:</target>
        </trans-unit>
        <trans-unit id="6d830da55607c318b0229bbe871dede8489bbbcd" translate="yes" xml:space="preserve">
          <source>Extra credit:</source>
          <target state="translated">额外学分。</target>
        </trans-unit>
        <trans-unit id="cb15184868a7170582b96630a6ea5bb279f5d610" translate="yes" xml:space="preserve">
          <source>Filtering joins: filter out rows in df1, don't modify columns</source>
          <target state="translated">筛选合并:在df1中筛选出行,不修改列。</target>
        </trans-unit>
        <trans-unit id="d9513dbbe672535839baa4a6cc570a53345b40d1" translate="yes" xml:space="preserve">
          <source>For an inner join on all columns, you could also use &lt;code&gt;fintersect&lt;/code&gt; from the &lt;em&gt;data.table&lt;/em&gt;-package or &lt;code&gt;intersect&lt;/code&gt; from the &lt;em&gt;dplyr&lt;/em&gt;-package as an alternative to &lt;code&gt;merge&lt;/code&gt; without specifying the &lt;code&gt;by&lt;/code&gt;-columns. this will give the rows that are equal between two dataframes:</source>
          <target state="translated">对于所有列上的内部 &lt;code&gt;fintersect&lt;/code&gt; ，还可以使用data.table -package的&lt;em&gt;fintersect&lt;/em&gt;或&lt;em&gt;dplyr -package的intersect&lt;/em&gt;作为 &lt;code&gt;merge&lt;/code&gt; 的替代方式，而无需指定 &lt;code&gt;by&lt;/code&gt; -columns。 这将使两个数据帧之间的行相等：</target>
        </trans-unit>
        <trans-unit id="3ecb0b93f83cfe035b561507dbb9ead3739e0215" translate="yes" xml:space="preserve">
          <source>For example, see &lt;a href=&quot;https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r&quot;&gt;Matching multiple columns on different data frames and getting other column as result&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns&quot;&gt;match two columns with two other columns&lt;/a&gt;, &lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html&quot;&gt;Matching on multiple columns&lt;/a&gt;, and the dupe of this question where I originally came up with the in-place solution, &lt;a href=&quot;https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281&quot;&gt;Combine two data frames with different number of rows in R&lt;/a&gt;.</source>
          <target state="translated">例如，请参见&lt;a href=&quot;https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r&quot;&gt;在不同数据帧上匹配多个列并获得其他列作为结果&lt;/a&gt; ， &lt;a href=&quot;https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns&quot;&gt;将两个列与另外两个列进行&lt;/a&gt; &lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html&quot;&gt;匹配，在多个列上进行匹配&lt;/a&gt; ，以及我最初提出就地解决方案&lt;a href=&quot;https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281&quot;&gt;Combine的&lt;/a&gt;问题的重复R中具有不同行数的两个数据帧</target>
        </trans-unit>
        <trans-unit id="6bc9cab91de980063bff0c869e8cd295f71aeae3" translate="yes" xml:space="preserve">
          <source>For the case of a left join with a &lt;code&gt;0..*:0..1&lt;/code&gt; cardinality or a right join with a &lt;code&gt;0..1:0..*&lt;/code&gt; cardinality it is possible to assign in-place the unilateral columns from the joiner (the &lt;code&gt;0..1&lt;/code&gt; table) directly onto the joinee (the &lt;code&gt;0..*&lt;/code&gt; table), and thereby avoid the creation of an entirely new table of data. This requires matching the key columns from the joinee into the joiner and indexing+ordering the joiner's rows accordingly for the assignment.</source>
          <target state="translated">对于左连接的基数为 &lt;code&gt;0..*:0..1&lt;/code&gt; 或右连接的基数为 &lt;code&gt;0..1:0..*&lt;/code&gt; 情况，可以从连接器中就地分配单边列（ &lt;code&gt;0..1&lt;/code&gt; 表）直接添加到连接对象（ &lt;code&gt;0..*&lt;/code&gt; 表）上，从而避免创建全新的数据表。 这需要将参与者的键列匹配到参与者中，并相应地索引并排序参与者的行以进行分配。</target>
        </trans-unit>
        <trans-unit id="f8dae3d6dd66cb4a6e969f2c3e876e1163d52462" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;?join&lt;/code&gt;: Unlike &lt;code&gt;merge&lt;/code&gt;, [&lt;code&gt;join&lt;/code&gt;] preserves the order of x no matter what join type is used.</source>
          <target state="translated">From &lt;code&gt;?join&lt;/code&gt; ：与 &lt;code&gt;merge&lt;/code&gt; 不同，无论使用哪种连接类型，[ &lt;code&gt;join&lt;/code&gt; ]都会保留x的顺序。</target>
        </trans-unit>
        <trans-unit id="4e4ea750b40b9f8fb970aa423721dd8f952b8a95" translate="yes" xml:space="preserve">
          <source>Given two data frames:</source>
          <target state="translated">鉴于两个数据帧:</target>
        </trans-unit>
        <trans-unit id="178043d2a18594ddc9371df094f215781386f9a2" translate="yes" xml:space="preserve">
          <source>Hadley mentioning other advantages here</source>
          <target state="translated">哈德利在这里提到了其他优势</target>
        </trans-unit>
        <trans-unit id="3e9d24ecb34b0ebaafaf47408d72663265376976" translate="yes" xml:space="preserve">
          <source>Handling for POSIXct type, timezones, duplicates, different factor levels. Better errors and warnings.</source>
          <target state="translated">对POSIXct类型、时间区间、重复、不同因素级别的处理。更好的错误和警告。</target>
        </trans-unit>
        <trans-unit id="290e06acecaff168c5348f733abafaff96fe9595" translate="yes" xml:space="preserve">
          <source>Here I benchmark on random input data, trying different scales and different patterns of key overlap between the two input tables. This benchmark is still restricted to the case of a single-column integer key. As well, to ensure that the in-place solution would work for both left and right joins of the same tables, all random test data uses &lt;code&gt;0..1:0..1&lt;/code&gt; cardinality. This is implemented by sampling without replacement the key column of the first data.frame when generating the key column of the second data.frame.</source>
          <target state="translated">在这里，我以随机输入数据为基准，尝试在两个输入表之间使用不同的比例和不同的键重叠模式。 此基准仍然仅限于单列整数键的情况。 同样，为了确保就地解决方案适用于同一张表的左右联接，所有随机测试数据都使用 &lt;code&gt;0..1:0..1&lt;/code&gt; 基数。 这是通过在生成第二个data.frame的关键列时进行采样而不替换第一个data.frame的关键列来实现的。</target>
        </trans-unit>
        <trans-unit id="d7d6852d88aa3e327a146c14342fb3fab571a58e" translate="yes" xml:space="preserve">
          <source>Here's a benchmark of the example based on the OP that I demonstrated earlier:</source>
          <target state="translated">下面是根据我之前演示的OP的例子的基准。</target>
        </trans-unit>
        <trans-unit id="e8081890f19c96944894bdd114482dfc9a75ed29" translate="yes" xml:space="preserve">
          <source>Here's a second large-scale benchmark that's more heavy-duty, with respect to the number and types of key columns, as well as cardinality. For this benchmark I use three key columns: one character, one integer, and one logical, with no restrictions on cardinality (that is, &lt;code&gt;0..*:0..*&lt;/code&gt;). (In general it's not advisable to define key columns with double or complex values due to floating-point comparison complications, and basically no one ever uses the raw type, much less for key columns, so I haven't included those types in the key columns. Also, for information's sake, I initially tried to use four key columns by including a POSIXct key column, but the POSIXct type didn't play well with the &lt;code&gt;sqldf.indexed&lt;/code&gt; solution for some reason, possibly due to floating-point comparison anomalies, so I removed it.)</source>
          <target state="translated">关于键列的数量和类型以及基数，这是第二个更大规模的基准测试。 对于此基准测试，我使用三个关键列：一个字符，一个整数和一个逻辑，对基数没有限制（即 &lt;code&gt;0..*:0..*&lt;/code&gt; ）。 （通常，由于浮点比较的复杂性，不建议将键列定义为双精度或复数值，并且基本上没有人使用原始类型，对于键列而言则少得多，因此我没有在键中包含这些类型另外，为了提供信息，我最初尝试通过包含POSIXct键列来使用四个键列，但是POSIXct类型由于某种原因在 &lt;code&gt;sqldf.indexed&lt;/code&gt; 解决方案中不能很好地发挥作用，这可能是由于浮点比较异常，所以我将其删除。）</target>
        </trans-unit>
        <trans-unit id="4097e5d8cc2075da7471c980add60bad0cf09eb0" translate="yes" xml:space="preserve">
          <source>Here's an example based on the OP, except I've added an extra row to &lt;code&gt;df2&lt;/code&gt; with an id of 7 to test the case of a non-matching key in the joiner. This is effectively &lt;code&gt;df1&lt;/code&gt; left join &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">这是一个基于OP的示例，除了我在 &lt;code&gt;df2&lt;/code&gt; 中添加了ID为7的额外行以测试连接器中不匹配键的情况。 这实际上是 &lt;code&gt;df1&lt;/code&gt; 左 &lt;code&gt;df2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="044af99ba79865956da778a1334f4f8240c2bf7f" translate="yes" xml:space="preserve">
          <source>How can I do a SQL style select statement?</source>
          <target state="translated">如何做一个SQL风格的选择语句?</target>
        </trans-unit>
        <trans-unit id="43090d2742d9081d6bd0ff68f38627e9993c5976" translate="yes" xml:space="preserve">
          <source>How can I do database style, i.e., &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;sql style, joins&lt;/a&gt;? That is, how do I get:</source>
          <target state="translated">如何进行数据库样式（即&lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;sql样式）的联接&lt;/a&gt; ？ 也就是说，我如何获得：</target>
        </trans-unit>
        <trans-unit id="87f0bedc362f9948f7a3bb794a94bec592f2987f" translate="yes" xml:space="preserve">
          <source>How to do a basic left outer join with data.table in R?</source>
          <target state="translated">如何在R中用data.table做一个基本的左外连接?</target>
        </trans-unit>
        <trans-unit id="662b552b7e40492af7fd79296b2d468005570929" translate="yes" xml:space="preserve">
          <source>How to do a data.table merge operation</source>
          <target state="translated">如何进行data.table合并操作</target>
        </trans-unit>
        <trans-unit id="b2997a354edf34b9212b5bede79742efdcd92dac" translate="yes" xml:space="preserve">
          <source>How to join (merge) data frames (inner, outer, left, right)</source>
          <target state="translated">如何连接(合并)数据帧(内、外、外、左、右)的方法</target>
        </trans-unit>
        <trans-unit id="be4f4251a4aa264ff1a5045246798a437e872a51" translate="yes" xml:space="preserve">
          <source>I decided to do my own benchmarking to see how the in-place assignment approach compares to the other solutions that have been offered in this question.</source>
          <target state="translated">我决定自己做个标杆,看看原地派位法与本题中的其他方案相比,有什么不同。</target>
        </trans-unit>
        <trans-unit id="1433555c3736ee7dc33f6787f0ee5e502257ce77" translate="yes" xml:space="preserve">
          <source>I find the SQL syntax to be simpler and more natural than its R equivalent (but this may just reflect my RDBMS bias).</source>
          <target state="translated">我发现SQL的语法比它的R对等的语法更简单、更自然(但这可能只是反映了我对RDBMS的偏见)。</target>
        </trans-unit>
        <trans-unit id="850ce2fc8639be910cca8a142e25a33d5a5324bd" translate="yes" xml:space="preserve">
          <source>I think this is a particularly appropriate solution if you have several tables that you want to left join against a single large table. Repeatedly rebuilding the entire table for each merge would be unnecessary and inefficient.</source>
          <target state="translated">我认为,如果你有几个表想对一个大表进行左联接,那么这个解决方案特别合适。每次合并都要重复地重建整个表,这样做是没有必要的,而且效率很低。</target>
        </trans-unit>
        <trans-unit id="81dd38b7e015ec1e1a6ff6776efb1705d815b694" translate="yes" xml:space="preserve">
          <source>I used spline interpolation to show a smooth curve for each solution/join type combination, drawn with individual pch symbols. The join type is captured by the pch symbol, using a dot for inner, left and right angle brackets for left and right, and a diamond for full. The solution type is captured by the color as shown in the legend.</source>
          <target state="translated">我采用花键插值法,用单个的pch符号画出了每一个解Join类型组合的平滑曲线。连接类型由pch符号来捕捉,用圆点表示内角,左、右角括号表示左、右角,菱形表示全长。溶液类型由图例中的颜色来捕捉。</target>
        </trans-unit>
        <trans-unit id="a8ebc4a7bfcf1453154ce5c9cb696149ac776e30" translate="yes" xml:space="preserve">
          <source>I would recommend checking out &lt;a href=&quot;http://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;Gabor Grothendieck's sqldf package&lt;/a&gt;, which allows you to express these operations in SQL.</source>
          <target state="translated">我建议您检出&lt;a href=&quot;http://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;Gabor Grothendieck的sqldf软件包&lt;/a&gt; ，该软件包可让您用SQL表示这些操作。</target>
        </trans-unit>
        <trans-unit id="2337e76070232665935ee45908852019881d7dba" translate="yes" xml:space="preserve">
          <source>I wrote some code to create log-log plots of the above results. I generated a separate plot for each overlap percentage. It's a little bit cluttered, but I like having all the solution types and join types represented in the same plot.</source>
          <target state="translated">我写了一些代码来创建上述结果的log-log图。我为每个重叠百分比生成了一个单独的图。虽然有点杂乱,但我喜欢把所有的解决方案类型和连接类型都表示在同一个情节中。</target>
        </trans-unit>
        <trans-unit id="710e748e65ff61225c32f7870e72f52de5d5471e" translate="yes" xml:space="preserve">
          <source>If the column names to merge on are not the same, you can specify, e.g., &lt;code&gt;by.x = &quot;CustomerId_in_df1&quot;, by.y = &quot;CustomerId_in_df2&quot;&lt;/code&gt; where &lt;code&gt;CustomerId_in_df1&lt;/code&gt; is the name of the column in the first data frame and &lt;code&gt;CustomerId_in_df2&lt;/code&gt; is the name of the column in the second data frame. (These can also be vectors if you need to merge on multiple columns.)</source>
          <target state="translated">如果要合并的列名称不同，则可以指定，例如， &lt;code&gt;by.x = &quot;CustomerId_in_df1&quot;, by.y = &quot;CustomerId_in_df2&quot;&lt;/code&gt; ，其中 &lt;code&gt;CustomerId_in_df1&lt;/code&gt; 是第一个数据框中的列名称，而 &lt;code&gt;CustomerId_in_df2&lt;/code&gt; 是第二个数据框中的列名。 （如果您需要在多列上合并，这些也可以是向量。）</target>
        </trans-unit>
        <trans-unit id="f8fa4b6558b0a4f2f657a454fe32716ede7c01cf" translate="yes" xml:space="preserve">
          <source>If the key is a single column, then we can use a single call to &lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; to do the matching. This is the case I'll cover in this answer.</source>
          <target state="translated">如果键是单列，则可以使用单个调用&lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt;进行匹配。 我将在此答案中介绍这种情况。</target>
        </trans-unit>
        <trans-unit id="aa34b093d971a035acaf887e23091153f1492e31" translate="yes" xml:space="preserve">
          <source>In joining two data frames with ~1 million rows each, one with 2 columns and the other with ~20, I've surprisingly found &lt;code&gt;merge(..., all.x = TRUE, all.y = TRUE)&lt;/code&gt; to be faster then &lt;code&gt;dplyr::full_join()&lt;/code&gt;. This is with dplyr v0.4</source>
          <target state="translated">在连接两个数据帧时，我分别惊奇地发现 &lt;code&gt;merge(..., all.x = TRUE, all.y = TRUE)&lt;/code&gt; 速度快了两个数据帧，每个数据帧有约 100万行，一个有2列，而另一个有〜20行。 &lt;code&gt;dplyr::full_join()&lt;/code&gt; 。 这是dplyr v0.4</target>
        </trans-unit>
        <trans-unit id="5a7ff2d9ec551ba208af43332df0b32a7dc8d5b3" translate="yes" xml:space="preserve">
          <source>In the above I hard-coded an assumption that the key column is the first column of both input tables. I would argue that, in general, this is not an unreasonable assumption, since, if you have a data.frame with a key column, it would be strange if it had not been set up as the first column of the data.frame from the outset. And you can always reorder the columns to make it so. An advantageous consequence of this assumption is that the name of the key column does not have to be hard-coded, although I suppose it's just replacing one assumption with another. Concision is another advantage of integer indexing, as well as speed. In the benchmarks below I'll change the implementation to use string name indexing to match the competing implementations.</source>
          <target state="translated">在上面我硬编码了一个假设,即key列是两个输入表的第一列。我认为,一般来说,这不是一个不合理的假设,因为如果你有一个data.frame.frame,如果不是一开始就设置为data.frame的第一列,那就很奇怪了。而且你可以随时重新排序,使之成为这样的列。这个假设的一个好处是,关键列的名称不需要硬编码,虽然我想这只是把一个假设换成了另一个假设。简洁性是整数索引的另一个优势,也是速度上的优势。在下面的基准测试中,我将改变实现,使用字符串名索引法来匹配竞争的实现。</target>
        </trans-unit>
        <trans-unit id="6250605ea19f359b4292e4f82913fe0d8caae6ab" translate="yes" xml:space="preserve">
          <source>It's all &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html&quot;&gt;here&lt;/a&gt; in great detail.</source>
          <target state="translated">这一切都非常详细。</target>
        </trans-unit>
        <trans-unit id="b091ee98d4a46bacae49eb5f90e7465fe5df5f71" translate="yes" xml:space="preserve">
          <source>Join-related &lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/news/news.html&quot;&gt;release highlights&lt;/a&gt;:</source>
          <target state="translated">与联接有关的&lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/news/news.html&quot;&gt;发行要点&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="ecc363814d7eeefe97adb1b510ca596b8ac8e949" translate="yes" xml:space="preserve">
          <source>Merge takes ~17 seconds, full_join takes ~65 seconds.</source>
          <target state="translated">合并需要约17秒,全连接需要约65秒。</target>
        </trans-unit>
        <trans-unit id="1d04d0125deda2ba2209b50e785af8edc6c62682" translate="yes" xml:space="preserve">
          <source>Modifying the OP's example tables...</source>
          <target state="translated">修改OP的例子表......</target>
        </trans-unit>
        <trans-unit id="cf0e80f7f1862b16f7353cadc5e580929ed727c8" translate="yes" xml:space="preserve">
          <source>Mutating joins, which add new variables to one table from matching rows in another. Filtering joins, which filter observations from one table based on whether or not they match an observation in the other table.</source>
          <target state="translated">Mutating joins,从另一个表的匹配记录中添加新的变量到另一个表。筛选接合,根据一个表中的观察结果是否匹配另一个表中的观察结果来筛选。</target>
        </trans-unit>
        <trans-unit id="76494af2798aaf4f5297aa9a9455435c0a1baae3" translate="yes" xml:space="preserve">
          <source>Mutating joins: add columns to df1 using matches in df2</source>
          <target state="translated">突变连接:使用DF1中的匹配项添加到DF2中的列。</target>
        </trans-unit>
        <trans-unit id="4f7e10e539fcde0fedb67622c28ce2185dc8d4fe" translate="yes" xml:space="preserve">
          <source>New in 2014:</source>
          <target state="translated">2014年新增。</target>
        </trans-unit>
        <trans-unit id="da097f490eba3885863a0e13ce340e42d5855b1e" translate="yes" xml:space="preserve">
          <source>New suffix argument to control what suffix duplicated variable names receive (#1296)</source>
          <target state="translated">新的后缀参数来控制重复的变量名接受什么后缀 (#1296)</target>
        </trans-unit>
        <trans-unit id="b93e636c4795007ba0754843b031729197bf6b22" translate="yes" xml:space="preserve">
          <source>On the other hand, if you need the joinee to remain unaltered through this operation for whatever reason, then this solution cannot be used, since it modifies the joinee directly. Although in that case you could simply make a copy and perform the in-place assignment(s) on the copy.</source>
          <target state="translated">另一方面,如果你需要通过这个操作使被连接体不被修改,那么这个方案不能使用,因为它直接修改了被连接体。虽然在这种情况下,你可以简单地复制一个副本,然后在副本上执行原地赋值。</target>
        </trans-unit>
        <trans-unit id="275a3e036899aeaeaf21926f7f5568683b2bb806" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;type&lt;/code&gt;: &lt;code&gt;inner&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 选项： &lt;code&gt;inner&lt;/code&gt; ， &lt;code&gt;left&lt;/code&gt; ， &lt;code&gt;right&lt;/code&gt; ， &lt;code&gt;full&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff2431181fc9fc2e60070beaa227805ee647ef62" translate="yes" xml:space="preserve">
          <source>R :- &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y =
&quot;CustomerId&quot;)[,names(df2)]&lt;/code&gt;</source>
          <target state="translated">R： &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df2)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a90a1fd62b7cfb3514800d395f4aa530d9d32189" translate="yes" xml:space="preserve">
          <source>R :- &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df1)]&lt;/code&gt;</source>
          <target state="translated">R： &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fe4364f88f74f296de93af3b3599121f64037b6" translate="yes" xml:space="preserve">
          <source>Return all rows from the left table, and any rows with matching keys from the right table.</source>
          <target state="translated">返回左表中的所有记录,以及右表中任何有匹配键的记录。</target>
        </trans-unit>
        <trans-unit id="b075052cf9c2a92043b4c19e839781e4f2bb219e" translate="yes" xml:space="preserve">
          <source>Return all rows from the right table, and any rows with matching keys from the left table.</source>
          <target state="translated">返回右表中的所有记录,以及左表中任何有匹配键的记录。</target>
        </trans-unit>
        <trans-unit id="256ebb1bf5d1b1490ada37135eaa9f3ef9b55410" translate="yes" xml:space="preserve">
          <source>Return only the rows in which the left table have matching keys in the right table.</source>
          <target state="translated">只返回左表有匹配键的右表中的行。</target>
        </trans-unit>
        <trans-unit id="e571ab9ca057fdce414c471714347a24e546c952" translate="yes" xml:space="preserve">
          <source>Returns all rows from both tables, join records from the left which have matching keys in the right table.</source>
          <target state="translated">返回两个表中的所有记录,从左边的记录中加入右表中有匹配键的记录。</target>
        </trans-unit>
        <trans-unit id="9e5d4b98769be55db1d88583ac64d18adb2b96ab" translate="yes" xml:space="preserve">
          <source>SQL :-  &lt;code&gt;select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</source>
          <target state="translated">SQL：- &lt;code&gt;select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1040827d8fcc05e6ced9f587ad7e4394f6d46db" translate="yes" xml:space="preserve">
          <source>SQL :- &lt;code&gt;select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</source>
          <target state="translated">SQL：- &lt;code&gt;select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="182e27662bc0db38ceece5dd2e17427203440683" translate="yes" xml:space="preserve">
          <source>Same way</source>
          <target state="translated">同样的方法</target>
        </trans-unit>
        <trans-unit id="36d2d63aaf03c9e36ebc4dc91950d14a746e0b3d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/ggrothendieck/sqldf#example-4-join&quot;&gt;Gabor's sqldf GitHub&lt;/a&gt; for more information on joins.</source>
          <target state="translated">有关联接的更多信息，请参见&lt;a href=&quot;https://github.com/ggrothendieck/sqldf#example-4-join&quot;&gt;Gabor的sqldf GitHub&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="410c9a8726f8cbd1c1e586b81fe174b89fccc09b" translate="yes" xml:space="preserve">
          <source>Selecting columns can be done by &lt;code&gt;select(df,&quot;column&quot;)&lt;/code&gt;. If that's not SQL-ish enough for you, then there's the &lt;code&gt;sql()&lt;/code&gt; function, into which you can enter SQL code as-is, and it will do the operation you specified just like you were writing in R all along (for more information, please refer to the &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html&quot;&gt;dplyr/databases vignette&lt;/a&gt;). For example, if applied correctly, &lt;code&gt;sql(&quot;SELECT * FROM hflights&quot;)&lt;/code&gt; will select all the columns from the &quot;hflights&quot; dplyr table (a &quot;tbl&quot;).</source>
          <target state="translated">可以通过 &lt;code&gt;select(df,&quot;column&quot;)&lt;/code&gt; 来选择列 。 如果那还不足以满足您的SQL需求，那么您可以使用 &lt;code&gt;sql()&lt;/code&gt; 函数，您可以按原样输入SQL代码，并且它将执行您指定的操作，就像您一直在R中编写代码一样（有关更多信息， ，请参阅&lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html&quot;&gt;dplyr /数据库插图&lt;/a&gt; ）。 例如，如果正确应用，则 &lt;code&gt;sql(&quot;SELECT * FROM hflights&quot;)&lt;/code&gt; 将选择&amp;ldquo; hflights&amp;rdquo; dplyr表（&amp;ldquo; tbl&amp;rdquo;）中的所有列。</target>
        </trans-unit>
        <trans-unit id="89f032298f21e2eb6484041690c0b5f31f1c9852" translate="yes" xml:space="preserve">
          <source>Since your keys are named the same the short way to do an inner join is merge():</source>
          <target state="translated">因为你的键的名称是一样的,所以做内部连接的捷径是merge()。</target>
        </trans-unit>
        <trans-unit id="09f26ff5d7f001a9ebafb1da072687d91833c703" translate="yes" xml:space="preserve">
          <source>Some food for though, since I generally default to dplyr for manipulation tasks.</source>
          <target state="translated">但有些食物,因为我一般默认使用dplyr进行操作任务。</target>
        </trans-unit>
        <trans-unit id="fed6f49e983aa5bd71ca7e1155b989e6e3375280" translate="yes" xml:space="preserve">
          <source>Suppose we want to add the customer's state from &lt;code&gt;cust&lt;/code&gt; to the purchases table, &lt;code&gt;sales&lt;/code&gt;, ignoring the year column. With base R, we can identify matching rows and then copy values over:</source>
          <target state="translated">假设我们想将客户的状态从 &lt;code&gt;cust&lt;/code&gt; 添加到Purchases表 &lt;code&gt;sales&lt;/code&gt; 中 ，而忽略year列。 使用基数R，我们可以识别匹配的行，然后在以下位置复制值：</target>
        </trans-unit>
        <trans-unit id="cc0804bbd7e4d942d5dec0c858695fe81456d52e" translate="yes" xml:space="preserve">
          <source>Testing code:</source>
          <target state="translated">测试代码。</target>
        </trans-unit>
        <trans-unit id="4d2affb1e17938190686ba88646124834885e979" translate="yes" xml:space="preserve">
          <source>The four joining-related functions in the dplyr package are (to quote):</source>
          <target state="translated">dplyr包中的四个与连接相关的函数是(引证一下)。</target>
        </trans-unit>
        <trans-unit id="975fec70202257751857627844d9ba0efd8ac25c" translate="yes" xml:space="preserve">
          <source>The other combination of outer joins can be created by mungling the left outer join subscript example. (yeah, I know that's the equivalent of saying &quot;I'll leave it as an exercise for the reader...&quot;)</source>
          <target state="translated">另一种外接的组合可以通过混搭左边的外接下标的例子来创建。(是的,我知道这相当于说 &quot;我把它作为练习题留给读者..........&quot;)</target>
        </trans-unit>
        <trans-unit id="cfb49dc74158670dddef83e622172c7c91441e36" translate="yes" xml:space="preserve">
          <source>The resulting plots, using the same plotting code given above:</source>
          <target state="translated">所得到的地块,使用上述相同的绘图代码。</target>
        </trans-unit>
        <trans-unit id="3fd1810b687b3f6297e5dacac6cd2f293af39cd7" translate="yes" xml:space="preserve">
          <source>The three examples above all focus on creating/adding a new column. See &lt;a href=&quot;https://stackoverflow.com/q/6112260&quot;&gt;the related R FAQ&lt;/a&gt; for an example of updating/modifying an existing column.</source>
          <target state="translated">最重要的三个示例着重于创建/添加新列。 有关更新/修改现有列的示例，请参见&lt;a href=&quot;https://stackoverflow.com/q/6112260&quot;&gt;相关的R FAQ&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="cecd23eb962bc5d6748ad3fb34f5562f803499f5" translate="yes" xml:space="preserve">
          <source>There are some good examples of doing this over at the &lt;a href=&quot;http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge&quot;&gt;R Wiki&lt;/a&gt;. I'll steal a couple here:</source>
          <target state="translated">在&lt;a href=&quot;http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge&quot;&gt;R Wiki上&lt;/a&gt;有一些很好的例子。 我会在这里偷几个：</target>
        </trans-unit>
        <trans-unit id="d8d441f0127df63fc7e588978f519a0a7110a1d7" translate="yes" xml:space="preserve">
          <source>There is the &lt;strong&gt;data.table&lt;/strong&gt; approach for an inner join, which is very time and memory efficient (and necessary for some larger data.frames):</source>
          <target state="translated">有一个用于内部&lt;strong&gt;联接的data.table&lt;/strong&gt;方法，这种方法非常节省时间和内存（对于某些较大的data.frames是必需的）：</target>
        </trans-unit>
        <trans-unit id="e97719490cc7ca28a945d219ef810933fffa9275" translate="yes" xml:space="preserve">
          <source>Translating SQL joins on foreign keys to R data.table syntax</source>
          <target state="translated">将外键上的SQL联接转换为R data.table语法。</target>
        </trans-unit>
        <trans-unit id="def30251a119892b32dc57973f51d84d2b8a55a3" translate="yes" xml:space="preserve">
          <source>Update on data.table methods for joining datasets. See below examples for each type of join. There are two methods, one from &lt;code&gt;[.data.table&lt;/code&gt; when passing second data.table as the first argument to subset, another way is to use &lt;code&gt;merge&lt;/code&gt; function which dispatches to fast data.table method.</source>
          <target state="translated">更新data.table方法以连接数据集。 有关每种连接类型，请参见以下示例。 有两种方法，一种是从 &lt;code&gt;[.data.table&lt;/code&gt; 传递第二个data.table作为第一个参数传递给子集时，另一种方法是使用 &lt;code&gt;merge&lt;/code&gt; 函数，该函数分派给fast data.table方法。</target>
        </trans-unit>
        <trans-unit id="5b7fa59fc1d348ab50e552c606a943a4fb3428d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;merge&lt;/code&gt; function we can select the variable of left table or right table, same way like we all familiar with select statement in SQL (EX : Select a.* ...or Select b.* from .....)</source>
          <target state="translated">使用 &lt;code&gt;merge&lt;/code&gt; 功能，我们可以选择左侧表或右侧表的变量，就像我们都熟悉SQL中的select语句一样（例如：从.....中选择a。* ...或Select b。*。）</target>
        </trans-unit>
        <trans-unit id="777e443e9e2269e9c7657e5c1bb5b4ef07dd5d99" translate="yes" xml:space="preserve">
          <source>We have to add extra code which will subset from the newly joined table .</source>
          <target state="translated">我们必须添加额外的代码,这些代码将从新加入的表子集。</target>
        </trans-unit>
        <trans-unit id="35f9f5a0a66021813e967af96baa693e8e91102d" translate="yes" xml:space="preserve">
          <source>Workarounds per hadley's comments in that issue:</source>
          <target state="translated">根据哈德利在该问题上的评论,采取了变通的办法。</target>
        </trans-unit>
        <trans-unit id="20e71a92fd73f1ea6448c8ce19a1b28c6fd612ab" translate="yes" xml:space="preserve">
          <source>Yet another option is the &lt;code&gt;join&lt;/code&gt; function found in the &lt;a href=&quot;http://cran.r-project.org/web/packages/plyr/index.html&quot;&gt;&lt;strong&gt;plyr&lt;/strong&gt;&lt;/a&gt; package</source>
          <target state="translated">另一个选择是在&lt;a href=&quot;http://cran.r-project.org/web/packages/plyr/index.html&quot;&gt;&lt;strong&gt;plyr&lt;/strong&gt;&lt;/a&gt;软件包中找到的 &lt;code&gt;join&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="a4ca82ec6e06c0c6954a4927a77918e335215d61" translate="yes" xml:space="preserve">
          <source>You can do joins as well using Hadley Wickham's awesome &lt;a href=&quot;http://blog.rstudio.org/2014/01/17/introducing-dplyr/&quot;&gt;dplyr&lt;/a&gt; package.</source>
          <target state="translated">您也可以使用Hadley Wickham的超棒&lt;a href=&quot;http://blog.rstudio.org/2014/01/17/introducing-dplyr/&quot;&gt;dplyr&lt;/a&gt;软件包进行联接。</target>
        </trans-unit>
        <trans-unit id="5724e67f3f18acb7528650cc64cff7877156db95" translate="yes" xml:space="preserve">
          <source>You can merge on multiple columns by giving &lt;code&gt;by&lt;/code&gt; a vector, e.g., &lt;code&gt;by = c(&quot;CustomerId&quot;, &quot;OrderId&quot;)&lt;/code&gt;.</source>
          <target state="translated">您可以通过给定一个向量来合并多个列，例如 &lt;code&gt;by = c(&quot;CustomerId&quot;, &quot;OrderId&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf2d2dee20b0fe4b4b6a2f7726c0245d830c0168" translate="yes" xml:space="preserve">
          <source>a full inner join (all records from both tables) can be created with the &quot;all&quot; keyword:</source>
          <target state="translated">可以用 &quot;all &quot;关键字创建一个完整的内部连接(两个表的所有记录)。</target>
        </trans-unit>
        <trans-unit id="45b24f5fc4c5960be3b959ba6f2bc3227a86250d" translate="yes" xml:space="preserve">
          <source>a left outer join of df1 and df2:</source>
          <target state="translated">df1和df2的左侧外接。</target>
        </trans-unit>
        <trans-unit id="6d47d87da3f640b3f3ac9043cf30483af1712d57" translate="yes" xml:space="preserve">
          <source>a right outer join of df1 and df2:</source>
          <target state="translated">df1和df2的右外接。</target>
        </trans-unit>
        <trans-unit id="f00d083db7a975f33fd38e2809f8dd64537504aa" translate="yes" xml:space="preserve">
          <source>base R &lt;code&gt;merge()&lt;/code&gt; and equivalent package-based merge functions, which always allocate a new table to return the merged result, and thus are not suitable for an in-place assignment-based solution.</source>
          <target state="translated">base R &lt;code&gt;merge()&lt;/code&gt; 和等效的基于包的合并函数，它们始终分配一个新表以返回合并的结果，因此不适合基于就地分配的解决方案。</target>
        </trans-unit>
        <trans-unit id="abfb07f46a8b85131c33b5c00be46ae3ec4d825a" translate="yes" xml:space="preserve">
          <source>data.table documented on stackoverflow:</source>
          <target state="translated">data.table在stackoverflow上记录了。</target>
        </trans-unit>
        <trans-unit id="739d53834e2598c061e546b33d4c497722f8aa6e" translate="yes" xml:space="preserve">
          <source>didn't yet &lt;a href=&quot;https://github.com/hadley/dplyr/issues/96&quot;&gt;implement right_join and &lt;strong&gt;outer_join&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">尚未&lt;a href=&quot;https://github.com/hadley/dplyr/issues/96&quot;&gt;实现right_join和&lt;strong&gt;external_join&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dc4f0b439d260cec5f45060722ff170e14ccd80" translate="yes" xml:space="preserve">
          <source>dplyr since 0.4 implemented all those joins including &lt;code&gt;outer_join&lt;/code&gt;, but it was worth noting that &lt;strong&gt;for the first few releases prior to 0.4 it used not to offer &lt;code&gt;outer_join&lt;/code&gt;, and as a result there was a lot of really bad hacky workaround user code floating around for quite a while afterwards (you can still find such code in SO, Kaggle answers, github from that period. Hence this answer still serves a useful purpose.)&lt;/strong&gt;</source>
          <target state="translated">dplyr自从0.4实现了所有这些连接，包括 &lt;code&gt;outer_join&lt;/code&gt; ，但是值得注意的是&lt;strong&gt;，在0.4之前的前几个版本中，它以前不提供 &lt;code&gt;outer_join&lt;/code&gt; ，因此存在很多非常糟糕的变通办法，用户代码对于过了一会儿（您仍可以在那个时期在SO，Kaggle的答案和github中找到这样的代码。因此，此答案仍然有用。）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61e2da8dd77d5e292248c9fb83d7a134ac198b3a" translate="yes" xml:space="preserve">
          <source>has &lt;strong&gt;inner_join, left_join, semi_join, anti_join&lt;/strong&gt;</source>
          <target state="translated">具有&lt;strong&gt;inner_join，left_join，semi_join，anti_join&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091a85912279e018e930a477c24b367571489c0f" translate="yes" xml:space="preserve">
          <source>inefficient cartesian conjunctions, e.g. &lt;code&gt;outer(df1$a,df2$a,`==`) &amp;amp; outer(df1$b,df2$b,`==`)&lt;/code&gt;.</source>
          <target state="translated">低效的笛卡尔连词，例如 &lt;code&gt;outer(df1$a,df2$a,`==`) &amp;amp; outer(df1$b,df2$b,`==`)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a34ccb1aad2f513af7c11ec01144f6ab37837eaf" translate="yes" xml:space="preserve">
          <source>inefficient concatenations. e.g. &lt;code&gt;match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))&lt;/code&gt;, or the same idea with &lt;code&gt;paste()&lt;/code&gt;.</source>
          <target state="translated">无效的串联。 例如 &lt;code&gt;match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))&lt;/code&gt; 或与 &lt;code&gt;paste()&lt;/code&gt; 相同的想法。</target>
        </trans-unit>
        <trans-unit id="feb96c8e7073f7b49193f9c3ac2e9abbef5ee89f" translate="yes" xml:space="preserve">
          <source>one minor feature merge currently has that dplyr doesn't is &lt;a href=&quot;https://github.com/hadley/dplyr/issues/177&quot;&gt;the ability to have separate by.x,by.y columns&lt;/a&gt; as e.g. Python pandas does.</source>
          <target state="translated">dplyr目前没有的一个次要功能合并是像Python pandas一样&lt;a href=&quot;https://github.com/hadley/dplyr/issues/177&quot;&gt;具有单独的by.x，by.y列的&lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="b89a4220d42db1407a2fa042c855a3d4652ddd00" translate="yes" xml:space="preserve">
          <source>you can flip 'em, slap 'em and rub 'em down to get the other two outer joins you asked about :)</source>
          <target state="translated">你可以翻转他们,拍打他们,摩擦他们,让他们得到你所问的另外两个外接点:)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
