<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1299871">
    <body>
      <group id="1299871">
        <trans-unit id="d47d7caf030340f041a78d2ceb0b7965bda3093d" translate="yes" xml:space="preserve">
          <source>*_join() no longer reorders column names (#324)</source>
          <target state="translated">*_join()ya no reordena los nombres de las columnas (#324)</target>
        </trans-unit>
        <trans-unit id="487b6c91b5261dd50389ad61b918fe7838afe87f" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/12030932/2490497&quot;&gt;rolling join&lt;/a&gt; - if you want merge to be able to match to values from preceeding/following rows by rolling them forward or backward</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/12030932/2490497&quot;&gt;combinaci&amp;oacute;n progresiva&lt;/a&gt; : si desea fusionar para poder coincidir con los valores de las filas anteriores / posteriores, desliz&amp;aacute;ndolos hacia adelante o hacia atr&amp;aacute;s</target>
        </trans-unit>
        <trans-unit id="84c6f6a09e15ca4a5e7777731b7f61a686126d78" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/25815032/2490497&quot;&gt;overlapping join&lt;/a&gt; - if you want to merge by ranges</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/25815032/2490497&quot;&gt;uni&amp;oacute;n superpuesta&lt;/a&gt; - si desea fusionar por rangos</target>
        </trans-unit>
        <trans-unit id="afc219bc005a7c35074b4b7bdeb7c70495859d1b" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/3190118/2490497&quot;&gt;update on join&lt;/a&gt; - if you want to lookup values from another table to your main table</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/3190118/2490497&quot;&gt;actualizar al unir&lt;/a&gt; - si desea buscar valores de otra tabla a su tabla principal</target>
        </trans-unit>
        <trans-unit id="890d6745a9399241952baa05d0099615ae7dc270" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/41043047/2490497&quot;&gt;non-equi join&lt;/a&gt; - if your join condition is non-equal</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/41043047/2490497&quot;&gt;uni&amp;oacute;n no equi&lt;/a&gt; - si su condici&amp;oacute;n de uni&amp;oacute;n no es igual</target>
        </trans-unit>
        <trans-unit id="92ed8f843671545e7e2acc8d069fdcc2446feaeb" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/41684012/2490497&quot;&gt;aggregate on join&lt;/a&gt; - if you want to aggregate on key you are joining you do not have to materialize all join results</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/41684012/2490497&quot;&gt;agregar en la uni&amp;oacute;n&lt;/a&gt; : si desea agregar en la clave a la que se est&amp;aacute; uniendo, no tiene que materializar todos los resultados de la uni&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="07ce8fe7aebda33b8d668e59d9c852c30c95ed33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anti_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x
where there are not matching values in y, keeping just columns from x</source>
          <target state="translated">&lt;code&gt;anti_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : devuelve todas las filas de x donde no hay valores coincidentes en y, manteniendo solo columnas de x</target>
        </trans-unit>
        <trans-unit id="846866e1d2e49dece784b5f56afce637ce3acb5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inner_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from
x where there are matching values in y, and all columns from x and y</source>
          <target state="translated">&lt;code&gt;inner_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : devuelve todas las filas de x donde hay valores coincidentes en y, y todas las columnas de x e y</target>
        </trans-unit>
        <trans-unit id="4756dd78d19e6570c93a82eb2702ffcd868aa1a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x, and all columns from x and y</source>
          <target state="translated">&lt;code&gt;left_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : devuelve todas las filas de x, y todas las columnas de x e y</target>
        </trans-unit>
        <trans-unit id="b1ac4ba54b36075fe4e311146847172ffda51a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; also works on data.tables (as it is generic and calls &lt;code&gt;merge.data.table&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; tambi&amp;eacute;n funciona en data.tables (ya que es gen&amp;eacute;rico y llama a &lt;code&gt;merge.data.table&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8c0dab1fb7e149efd4ef02ea7323dd1028acf2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;semi_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x where there are matching values in
y, keeping just columns from x.</source>
          <target state="translated">&lt;code&gt;semi_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : devuelve todas las filas de x donde hay valores coincidentes en y, manteniendo solo las columnas de x.</target>
        </trans-unit>
        <trans-unit id="64447dc8e6edd1cc9f32821eb103cfca1f89e9cb" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;Just as with the inner join, you would probably want to explicitly pass &quot;CustomerId&quot; to R as the matching variable.&lt;/strike&gt;  I think it's almost always best to explicitly state the identifiers on which you want to merge; it's safer if the input data.frames change unexpectedly and easier to read later on.</source>
          <target state="translated">&lt;strike&gt;Al igual que con la combinaci&amp;oacute;n interna, es probable que desee pasar expl&amp;iacute;citamente &quot;CustomerId&quot; a R como la variable coincidente.&lt;/strike&gt; Creo que casi siempre es mejor indicar expl&amp;iacute;citamente los identificadores en los que desea fusionarse; es m&amp;aacute;s seguro si los marcos de datos de entrada cambian inesperadamente y son m&amp;aacute;s f&amp;aacute;ciles de leer m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="8f2b37c4fd55625fd3e73914491c5bd0dc311ccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Cross join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = NULL)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Uni&amp;oacute;n cruzada:&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = NULL)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8a7da9103d4d41873615a068f57166a2b7778c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Inner join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(df1, df2)&lt;/code&gt; will work for these examples because R automatically joins the frames by common variable names, but you would most likely want to specify &lt;code&gt;merge(df1, df2, by = &quot;CustomerId&quot;)&lt;/code&gt; to make sure that you were matching on only the fields you desired.  You can also use the &lt;code&gt;by.x&lt;/code&gt; and &lt;code&gt;by.y&lt;/code&gt; parameters if the matching variables have different names in the different data frames.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;La combinaci&amp;oacute;n interna:&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(df1, df2)&lt;/code&gt; funcionar&amp;aacute; para estos ejemplos porque R une autom&amp;aacute;ticamente los marcos por nombres de variables comunes, pero lo m&amp;aacute;s probable es que desee especificar la &lt;code&gt;merge(df1, df2, by = &quot;CustomerId&quot;)&lt;/code&gt; para asegurarse de que coincid&amp;iacute;an solo en los campos que deseaba. Tambi&amp;eacute;n puede usar los par&amp;aacute;metros &lt;code&gt;by.y&lt;/code&gt; si las variables coincidentes tienen nombres diferentes en los diferentes marcos de datos.</target>
        </trans-unit>
        <trans-unit id="038870ab05a425a137f8fbbc279dda97c77d683f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Left outer:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)&lt;/code&gt; &lt;strong&gt;&lt;em&gt;izquierdo:&lt;/em&gt;&lt;/strong&gt; fusionar (x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)</target>
        </trans-unit>
        <trans-unit id="72ebaef810f98fc55883bca7f5dfd5acba8a9cae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Outer join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Uni&amp;oacute;n externa:&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dab4ebd7ed185ebd97efccd2c02d50ba28589364" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Right outer:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)&lt;/code&gt; &lt;strong&gt;&lt;em&gt;derecho:&lt;/em&gt;&lt;/strong&gt; fusionar (x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)</target>
        </trans-unit>
        <trans-unit id="feb6dda0b81cd0e64ea3c74f9c8b636b97c7342f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.1.3&lt;/em&gt;&lt;/strong&gt; (4/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.1.3&lt;/em&gt;&lt;/strong&gt; (4/2014)</target>
        </trans-unit>
        <trans-unit id="977c100088eecd2687b330acb3b61630e1c463ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.2&lt;/em&gt;&lt;/strong&gt; (5/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.2&lt;/em&gt;&lt;/strong&gt; (5/2014)</target>
        </trans-unit>
        <trans-unit id="9d1100b98263dbf4dd0f99865af468f7b55e605f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.3&lt;/em&gt;&lt;/strong&gt; (10/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.3&lt;/em&gt;&lt;/strong&gt; (10/2014)</target>
        </trans-unit>
        <trans-unit id="bd8720e189cc792821196cc8bacaf98d3035fecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.4.0&lt;/em&gt;&lt;/strong&gt; (1/2015)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.4.0&lt;/em&gt;&lt;/strong&gt; (1/2015)</target>
        </trans-unit>
        <trans-unit id="66e75518de390f9fe0e9e80b4cbab16a3bcb592b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.5&lt;/em&gt;&lt;/strong&gt; (6/2016)</source>
          <target state="translated">v0.5 (6/2016)</target>
        </trans-unit>
        <trans-unit id="7d481f74b71e19ee13eac5a4c57e4f92286ac1b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implement right join and outer join&lt;/strong&gt; (#96)</source>
          <target state="translated">&lt;strong&gt;Implementar uni&amp;oacute;n derecha y uni&amp;oacute;n externa&lt;/strong&gt; (# 96)</target>
        </trans-unit>
        <trans-unit id="7d863a7bd89469b75eeee503d3a69a99724f4c9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Merge Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo de fusi&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="631fffa31418327ad1ceee06912e77e433c2a830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rolling update join.&lt;/strong&gt; Alternately, we may want to take the last state the customer was found in:</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n continua unirse.&lt;/strong&gt; Alternativamente, podemos querer tomar el &amp;uacute;ltimo estado en el que se encontr&amp;oacute; al cliente:</target>
        </trans-unit>
        <trans-unit id="16a449699f13e0f7577783adc61a84fa6b01f031" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscript Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo de sub&amp;iacute;ndice&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b809d4e294824a9bd8793db2c442bcc11490e805" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update join with multiple columns.&lt;/strong&gt; The approach above works well when we are joining on only a single column and are satisfied with the first match. Suppose we want the year of measurement in the customer table to match the year of sale.</source>
          <target state="translated">&lt;strong&gt;Actualizaci&amp;oacute;n de unirse con m&amp;uacute;ltiples columnas.&lt;/strong&gt; El enfoque anterior funciona bien cuando nos unimos en una sola columna y estamos satisfechos con la primera coincidencia. Supongamos que queremos que el a&amp;ntilde;o de medici&amp;oacute;n en la tabla del cliente coincida con el a&amp;ntilde;o de venta.</target>
        </trans-unit>
        <trans-unit id="60c8303c5c795a80894a040e6ad09b86a234618e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update join.&lt;/strong&gt; One other important SQL-style join is an &quot;&lt;a href=&quot;https://stackoverflow.com/q/7869592/&quot;&gt;update join&lt;/a&gt;&quot; where columns in one table are updated (or created) using another table.</source>
          <target state="translated">&lt;strong&gt;Actualizar unirse.&lt;/strong&gt; Otra combinaci&amp;oacute;n importante de estilo SQL es una &quot; &lt;a href=&quot;https://stackoverflow.com/q/7869592/&quot;&gt;combinaci&amp;oacute;n de actualizaci&amp;oacute;n&lt;/a&gt; &quot; donde las columnas de una tabla se actualizan (o crean) utilizando otra tabla.</target>
        </trans-unit>
        <trans-unit id="d36e434acda5756c7bc2a0734856c0841c167a0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;outer_join&lt;/strong&gt; is basically union(left_join(x, y), right_join(x, y)) - i.e. preserve all rows in both data frames.</source>
          <target state="translated">&lt;strong&gt;external_join&lt;/strong&gt; es b&amp;aacute;sicamente union (left_join (x, y), right_join (x, y)), es decir, preservar todas las filas en ambos marcos de datos.</target>
        </trans-unit>
        <trans-unit id="e65d821137f54f3e9e9fa6bf3d532f2edb926dc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;outer_join&lt;/strong&gt; not implemented yet, fallback is use base::merge() (or plyr::join())</source>
          <target state="translated">&lt;strong&gt;external_join&lt;/strong&gt; no est&amp;aacute; implementado todav&amp;iacute;a, el respaldo es use base :: merge () (o plyr :: join ())</target>
        </trans-unit>
        <trans-unit id="7af98f3c825f135edda87f9c794dac0060279aa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;right_join&lt;/strong&gt;(x,y) is the same as left_join(y,x) in terms of the rows, just the columns will be different orders. Easily worked around with select(new_column_order)</source>
          <target state="translated">&lt;strong&gt;right_join&lt;/strong&gt; (x, y) es lo mismo que left_join (y, x) en t&amp;eacute;rminos de filas, solo las columnas ser&amp;aacute;n de diferentes &amp;oacute;rdenes. Trabaja f&amp;aacute;cilmente con select (new_column_order)</target>
        </trans-unit>
        <trans-unit id="0c8b0aa635a2a6ad43b6f15dacdced43bcb2ee8b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join&quot;&gt;left outer join (or simply left join)&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;</source>
          <target state="translated">Una &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join&quot;&gt;combinaci&amp;oacute;n externa izquierda (o simplemente combinaci&amp;oacute;n izquierda)&lt;/a&gt; de &lt;code&gt;df1&lt;/code&gt; y &lt;code&gt;df2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65bd236cef1312710765c40a2d7ed2b9ae5d1de6" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Right_outer_join&quot;&gt;right outer join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;</source>
          <target state="translated">Una &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Right_outer_join&quot;&gt;uni&amp;oacute;n externa derecha&lt;/a&gt; de &lt;code&gt;df1&lt;/code&gt; y &lt;code&gt;df2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a995d5ebe59aa37a58c647f553d519dece05faba" translate="yes" xml:space="preserve">
          <source>A left outer join with df1 on the left using a subscript method would be:</source>
          <target state="translated">Una unión exterior izquierda con df1 a la izquierda usando un método de subíndice sería:</target>
        </trans-unit>
        <trans-unit id="0085fab60d07cb78647869bd8cefbf2ec4234148" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join&quot;&gt;inner join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">Una &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join&quot;&gt;uni&amp;oacute;n interna&lt;/a&gt; de &lt;code&gt;df1&lt;/code&gt; y &lt;code&gt;df2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf81a3ad99c579907678ed7b25d860ad1049d3a1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Outer_join&quot;&gt;outer join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">Una &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Outer_join&quot;&gt;uni&amp;oacute;n externa&lt;/a&gt; de &lt;code&gt;df1&lt;/code&gt; y &lt;code&gt;df2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99e1e176cca1b8231019f4dab468ecffc875a219" translate="yes" xml:space="preserve">
          <source>As @bgoldst's answer mentions, &lt;code&gt;match&lt;/code&gt; with &lt;code&gt;interaction&lt;/code&gt; might be an option for this case. More straightforwardly, one could use data.table:</source>
          <target state="translated">Como menciona la respuesta de @ bgoldst, la &lt;code&gt;match&lt;/code&gt; con la &lt;code&gt;interaction&lt;/code&gt; podr&amp;iacute;a ser una opci&amp;oacute;n para este caso. M&amp;aacute;s directamente, uno podr&amp;iacute;a usar data.table:</target>
        </trans-unit>
        <trans-unit id="abf28bebf45530a8950f4d9293a4c78cef6b6b00" translate="yes" xml:space="preserve">
          <source>As a side note, I briefly looked into possible matching solutions for multicolumn keys. Unfortunately, the only matching solutions I found were:</source>
          <target state="translated">Como nota al margen,investigué brevemente las posibles soluciones de coincidencia para las teclas de varias columnas.Desafortunadamente,las únicas soluciones que encontré fueron:</target>
        </trans-unit>
        <trans-unit id="4f166ad2d60f8daeca4449327bda4a7811ee2769" translate="yes" xml:space="preserve">
          <source>As can be seen here, &lt;code&gt;match&lt;/code&gt; selects the first matching row from the customer table.</source>
          <target state="translated">Como se puede ver aqu&amp;iacute;, la &lt;code&gt;match&lt;/code&gt; selecciona la primera fila coincidente de la tabla de clientes.</target>
        </trans-unit>
        <trans-unit id="b660aa6af5b76fcb666125e5ca3d5a374b6eebf4" translate="yes" xml:space="preserve">
          <source>Be aware there are other types of joins you can perform using &lt;code&gt;data.table&lt;/code&gt;:</source>
          <target state="translated">Tenga en cuenta que hay otros tipos de combinaciones que puede realizar utilizando &lt;code&gt;data.table&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="58719bd04f95ef9656fef30a4d66177a963af55f" translate="yes" xml:space="preserve">
          <source>Below benchmark tests base R, sqldf, dplyr and data.table.</source>
          <target state="translated">Debajo de las pruebas de referencia base R,sqldf,dplyr y data.table.</target>
        </trans-unit>
        <trans-unit id="9afae0499a8b49e7f0ef74e289efbf6ff5cc05de" translate="yes" xml:space="preserve">
          <source>Benchmark tests unkeyed/unindexed datasets.
Benchmark is performed on 50M-1 rows datasets, there are 50M-2 common values on join column so each scenario (inner, left, right, full) can be tested and join is still not trivial to perform. It is type of join which well stress join algorithms. Timings are as of &lt;code&gt;sqldf:0.4.11&lt;/code&gt;, &lt;code&gt;dplyr:0.7.8&lt;/code&gt;, &lt;code&gt;data.table:1.12.0&lt;/code&gt;.</source>
          <target state="translated">Las pruebas de referencia prueban conjuntos de datos no codificados / no indexados. El punto de referencia se realiza en conjuntos de datos de filas de 50M-1, hay valores comunes de 50M-2 en la columna de uni&amp;oacute;n, por lo que cada escenario (interno, izquierdo, derecho, completo) se puede probar y la uni&amp;oacute;n a&amp;uacute;n no es trivial de realizar. Es un tipo de uni&amp;oacute;n que tambi&amp;eacute;n enfatiza los algoritmos de uni&amp;oacute;n. Los tiempos son a partir de &lt;code&gt;sqldf:0.4.11&lt;/code&gt; , &lt;code&gt;dplyr:0.7.8&lt;/code&gt; , &lt;code&gt;data.table:1.12.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="031a1bb7db92ad832e32717777d34cb324b9c6c7" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;merge&lt;/code&gt; function and its optional parameters:</source>
          <target state="translated">Mediante el uso de la funci&amp;oacute;n de &lt;code&gt;merge&lt;/code&gt; y sus par&amp;aacute;metros opcionales:</target>
        </trans-unit>
        <trans-unit id="0850f670fdb08a62b7a39a07049252d4595216df" translate="yes" xml:space="preserve">
          <source>Can now left_join by different variables in each table: df1 %&amp;gt;% left_join(df2, c(&quot;var1&quot; = &quot;var2&quot;))</source>
          <target state="translated">Ahora puede left_join por diferentes variables en cada tabla: df1%&amp;gt;% left_join (df2, c (&quot;var1&quot; = &quot;var2&quot;))</target>
        </trans-unit>
        <trans-unit id="c6e5a298734559d60b7bb8a74b34d9ba6755ed0d" translate="yes" xml:space="preserve">
          <source>Code to reproduce:</source>
          <target state="translated">Código para reproducir:</target>
        </trans-unit>
        <trans-unit id="c85693681142b2f48692df23c7bd83524829e4cc" translate="yes" xml:space="preserve">
          <source>Efficient alternatives to merge for larger data.frames R</source>
          <target state="translated">Alternativas eficientes para fusionar para obtener datos más grandes.marcos R</target>
        </trans-unit>
        <trans-unit id="a0fb268d8865888849541e2461b53e088d173672" translate="yes" xml:space="preserve">
          <source>Especially if you're also interested in data manipulation in general (including sorting, filtering, subsetting, summarizing etc.), you should definitely take a look at &lt;code&gt;dplyr&lt;/code&gt;, which comes with a variety of functions all designed to facilitate your work specifically with data frames and certain other database types. It even offers quite an elaborate SQL interface, and even a function to convert (most) SQL code directly into R.</source>
          <target state="translated">Especialmente si tambi&amp;eacute;n est&amp;aacute; interesado en la manipulaci&amp;oacute;n de datos en general (incluida la clasificaci&amp;oacute;n, filtrado, subconjunto, resumen, etc.), definitivamente deber&amp;iacute;a echar un vistazo a &lt;code&gt;dplyr&lt;/code&gt; , que viene con una variedad de funciones, todas dise&amp;ntilde;adas para facilitar su trabajo espec&amp;iacute;ficamente con datos marcos y ciertos otros tipos de bases de datos. Incluso ofrece una interfaz SQL bastante elaborada, e incluso una funci&amp;oacute;n para convertir (la mayor&amp;iacute;a) del c&amp;oacute;digo SQL directamente en R.</target>
        </trans-unit>
        <trans-unit id="1cb91a4d85314d943d7ed8d0eb363de15a4cfd5d" translate="yes" xml:space="preserve">
          <source>Example data:</source>
          <target state="translated">Datos de ejemplo:</target>
        </trans-unit>
        <trans-unit id="6d830da55607c318b0229bbe871dede8489bbbcd" translate="yes" xml:space="preserve">
          <source>Extra credit:</source>
          <target state="translated">Crédito extra:</target>
        </trans-unit>
        <trans-unit id="cb15184868a7170582b96630a6ea5bb279f5d610" translate="yes" xml:space="preserve">
          <source>Filtering joins: filter out rows in df1, don't modify columns</source>
          <target state="translated">Filtrar las uniones:filtrar las filas en df1,no modificar las columnas</target>
        </trans-unit>
        <trans-unit id="d9513dbbe672535839baa4a6cc570a53345b40d1" translate="yes" xml:space="preserve">
          <source>For an inner join on all columns, you could also use &lt;code&gt;fintersect&lt;/code&gt; from the &lt;em&gt;data.table&lt;/em&gt;-package or &lt;code&gt;intersect&lt;/code&gt; from the &lt;em&gt;dplyr&lt;/em&gt;-package as an alternative to &lt;code&gt;merge&lt;/code&gt; without specifying the &lt;code&gt;by&lt;/code&gt;-columns. this will give the rows that are equal between two dataframes:</source>
          <target state="translated">Para una uni&amp;oacute;n interna en todas las columnas, tambi&amp;eacute;n puede usar &lt;code&gt;fintersect&lt;/code&gt; desde &lt;em&gt;data.table -package&lt;/em&gt; o &lt;code&gt;intersect&lt;/code&gt; arse desde &lt;em&gt;dplyr -package&lt;/em&gt; como alternativa para &lt;code&gt;merge&lt;/code&gt; sin especificar las columnas. esto dar&amp;aacute; las filas que son iguales entre dos marcos de datos:</target>
        </trans-unit>
        <trans-unit id="3ecb0b93f83cfe035b561507dbb9ead3739e0215" translate="yes" xml:space="preserve">
          <source>For example, see &lt;a href=&quot;https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r&quot;&gt;Matching multiple columns on different data frames and getting other column as result&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns&quot;&gt;match two columns with two other columns&lt;/a&gt;, &lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html&quot;&gt;Matching on multiple columns&lt;/a&gt;, and the dupe of this question where I originally came up with the in-place solution, &lt;a href=&quot;https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281&quot;&gt;Combine two data frames with different number of rows in R&lt;/a&gt;.</source>
          <target state="translated">Por ejemplo, vea &lt;a href=&quot;https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r&quot;&gt;Hacer coincidir varias columnas en diferentes marcos de datos y obtener otra columna como resultado&lt;/a&gt; , hacer &lt;a href=&quot;https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns&quot;&gt;coincidir dos columnas con otras dos columnas&lt;/a&gt; , &lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html&quot;&gt;Hacer coincidir en m&amp;uacute;ltiples columnas&lt;/a&gt; y el enga&amp;ntilde;o de esta pregunta donde originalmente se me ocurri&amp;oacute; la soluci&amp;oacute;n en el lugar, &lt;a href=&quot;https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281&quot;&gt;Combinar dos marcos de datos con diferente n&amp;uacute;mero de filas en R.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6bc9cab91de980063bff0c869e8cd295f71aeae3" translate="yes" xml:space="preserve">
          <source>For the case of a left join with a &lt;code&gt;0..*:0..1&lt;/code&gt; cardinality or a right join with a &lt;code&gt;0..1:0..*&lt;/code&gt; cardinality it is possible to assign in-place the unilateral columns from the joiner (the &lt;code&gt;0..1&lt;/code&gt; table) directly onto the joinee (the &lt;code&gt;0..*&lt;/code&gt; table), and thereby avoid the creation of an entirely new table of data. This requires matching the key columns from the joinee into the joiner and indexing+ordering the joiner's rows accordingly for the assignment.</source>
          <target state="translated">Para el caso de una uni&amp;oacute;n izquierda con una cardinalidad &lt;code&gt;0..*:0..1&lt;/code&gt; o una uni&amp;oacute;n derecha con una cardinalidad &lt;code&gt;0..1:0..*&lt;/code&gt; es posible asignar en el lugar las columnas unilaterales desde la uni&amp;oacute;n ( la tabla &lt;code&gt;0..1&lt;/code&gt; ) directamente en el participante (la tabla &lt;code&gt;0..*&lt;/code&gt; ), y as&amp;iacute; evitar la creaci&amp;oacute;n de una tabla de datos completamente nueva. Esto requiere hacer coincidir las columnas clave del participante en el ensamblador e indexar + ordenar las filas del ensamblador en consecuencia para la asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f8dae3d6dd66cb4a6e969f2c3e876e1163d52462" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;?join&lt;/code&gt;: Unlike &lt;code&gt;merge&lt;/code&gt;, [&lt;code&gt;join&lt;/code&gt;] preserves the order of x no matter what join type is used.</source>
          <target state="translated">Desde &lt;code&gt;?join&lt;/code&gt; : a diferencia de &lt;code&gt;merge&lt;/code&gt; , [ &lt;code&gt;join&lt;/code&gt; ] conserva el orden de x sin importar el tipo de combinaci&amp;oacute;n que se utilice.</target>
        </trans-unit>
        <trans-unit id="4e4ea750b40b9f8fb970aa423721dd8f952b8a95" translate="yes" xml:space="preserve">
          <source>Given two data frames:</source>
          <target state="translated">Dados dos marcos de datos:</target>
        </trans-unit>
        <trans-unit id="178043d2a18594ddc9371df094f215781386f9a2" translate="yes" xml:space="preserve">
          <source>Hadley mentioning other advantages here</source>
          <target state="translated">Hadley mencionó otras ventajas aquí</target>
        </trans-unit>
        <trans-unit id="3e9d24ecb34b0ebaafaf47408d72663265376976" translate="yes" xml:space="preserve">
          <source>Handling for POSIXct type, timezones, duplicates, different factor levels. Better errors and warnings.</source>
          <target state="translated">Manejo para el tipo POSIXct,zonas horarias,duplicados,diferentes niveles de factor.Mejores errores y advertencias.</target>
        </trans-unit>
        <trans-unit id="290e06acecaff168c5348f733abafaff96fe9595" translate="yes" xml:space="preserve">
          <source>Here I benchmark on random input data, trying different scales and different patterns of key overlap between the two input tables. This benchmark is still restricted to the case of a single-column integer key. As well, to ensure that the in-place solution would work for both left and right joins of the same tables, all random test data uses &lt;code&gt;0..1:0..1&lt;/code&gt; cardinality. This is implemented by sampling without replacement the key column of the first data.frame when generating the key column of the second data.frame.</source>
          <target state="translated">Aqu&amp;iacute; comparo datos de entrada aleatorios, probando diferentes escalas y diferentes patrones de superposici&amp;oacute;n de teclas entre las dos tablas de entrada. Este punto de referencia todav&amp;iacute;a est&amp;aacute; restringido al caso de una clave entera de una sola columna. Adem&amp;aacute;s, para garantizar que la soluci&amp;oacute;n en el lugar funcione para las uniones izquierda y derecha de las mismas tablas, todos los datos de prueba aleatorios usan cardinalidad &lt;code&gt;0..1:0..1&lt;/code&gt; . Esto se implementa mediante el muestreo sin reemplazo de la columna clave del primer data.frame al generar la columna clave del segundo data.frame.</target>
        </trans-unit>
        <trans-unit id="d7d6852d88aa3e327a146c14342fb3fab571a58e" translate="yes" xml:space="preserve">
          <source>Here's a benchmark of the example based on the OP that I demonstrated earlier:</source>
          <target state="translated">Aquí hay un punto de referencia del ejemplo basado en el OP que demostré anteriormente:</target>
        </trans-unit>
        <trans-unit id="e8081890f19c96944894bdd114482dfc9a75ed29" translate="yes" xml:space="preserve">
          <source>Here's a second large-scale benchmark that's more heavy-duty, with respect to the number and types of key columns, as well as cardinality. For this benchmark I use three key columns: one character, one integer, and one logical, with no restrictions on cardinality (that is, &lt;code&gt;0..*:0..*&lt;/code&gt;). (In general it's not advisable to define key columns with double or complex values due to floating-point comparison complications, and basically no one ever uses the raw type, much less for key columns, so I haven't included those types in the key columns. Also, for information's sake, I initially tried to use four key columns by including a POSIXct key column, but the POSIXct type didn't play well with the &lt;code&gt;sqldf.indexed&lt;/code&gt; solution for some reason, possibly due to floating-point comparison anomalies, so I removed it.)</source>
          <target state="translated">Aqu&amp;iacute; hay un segundo punto de referencia a gran escala que es m&amp;aacute;s resistente, con respecto al n&amp;uacute;mero y los tipos de columnas clave, as&amp;iacute; como a la cardinalidad. Para este punto de referencia utilizo tres columnas clave: un car&amp;aacute;cter, un n&amp;uacute;mero entero y uno l&amp;oacute;gico, sin restricciones de cardinalidad (es decir, &lt;code&gt;0..*:0..*&lt;/code&gt; ). (En general, no es aconsejable definir columnas clave con valores dobles o complejos debido a complicaciones de comparaci&amp;oacute;n de punto flotante, y b&amp;aacute;sicamente nadie usa el tipo sin formato, mucho menos para columnas clave, por lo que no he incluido esos tipos en la clave Adem&amp;aacute;s, por el bien de la informaci&amp;oacute;n, inicialmente intent&amp;eacute; usar cuatro columnas clave al incluir una columna de clave POSIXct, pero el tipo POSIXct no funcion&amp;oacute; bien con la soluci&amp;oacute;n &lt;code&gt;sqldf.indexed&lt;/code&gt; por alguna raz&amp;oacute;n, posiblemente debido a anomal&amp;iacute;as de comparaci&amp;oacute;n de punto flotante as&amp;iacute; que lo quit&amp;eacute;)</target>
        </trans-unit>
        <trans-unit id="4097e5d8cc2075da7471c980add60bad0cf09eb0" translate="yes" xml:space="preserve">
          <source>Here's an example based on the OP, except I've added an extra row to &lt;code&gt;df2&lt;/code&gt; with an id of 7 to test the case of a non-matching key in the joiner. This is effectively &lt;code&gt;df1&lt;/code&gt; left join &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo basado en el OP, excepto que he agregado una fila adicional a &lt;code&gt;df2&lt;/code&gt; con una identificaci&amp;oacute;n de 7 para probar el caso de una clave no coincidente en la combinaci&amp;oacute;n. Esto es efectivamente &lt;code&gt;df1&lt;/code&gt; left join &lt;code&gt;df2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="044af99ba79865956da778a1334f4f8240c2bf7f" translate="yes" xml:space="preserve">
          <source>How can I do a SQL style select statement?</source>
          <target state="translated">¿Cómo puedo hacer una declaración de selección de estilo SQL?</target>
        </trans-unit>
        <trans-unit id="43090d2742d9081d6bd0ff68f38627e9993c5976" translate="yes" xml:space="preserve">
          <source>How can I do database style, i.e., &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;sql style, joins&lt;/a&gt;? That is, how do I get:</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo hacer un estilo de base de datos, es decir, &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;estilo sql, une&lt;/a&gt; ? Es decir, c&amp;oacute;mo obtengo:</target>
        </trans-unit>
        <trans-unit id="87f0bedc362f9948f7a3bb794a94bec592f2987f" translate="yes" xml:space="preserve">
          <source>How to do a basic left outer join with data.table in R?</source>
          <target state="translated">¿Cómo hacer una unión básica exterior izquierda con data.table en R?</target>
        </trans-unit>
        <trans-unit id="662b552b7e40492af7fd79296b2d468005570929" translate="yes" xml:space="preserve">
          <source>How to do a data.table merge operation</source>
          <target state="translated">Cómo hacer una operación de fusión de data.table</target>
        </trans-unit>
        <trans-unit id="b2997a354edf34b9212b5bede79742efdcd92dac" translate="yes" xml:space="preserve">
          <source>How to join (merge) data frames (inner, outer, left, right)</source>
          <target state="translated">Cómo unir (fusionar)los marcos de datos (interior,exterior,izquierda,derecha)</target>
        </trans-unit>
        <trans-unit id="be4f4251a4aa264ff1a5045246798a437e872a51" translate="yes" xml:space="preserve">
          <source>I decided to do my own benchmarking to see how the in-place assignment approach compares to the other solutions that have been offered in this question.</source>
          <target state="translated">Decidí hacer mi propia evaluación comparativa para ver cómo el enfoque de la asignación in situ se compara con las otras soluciones que se han ofrecido en esta cuestión.</target>
        </trans-unit>
        <trans-unit id="1433555c3736ee7dc33f6787f0ee5e502257ce77" translate="yes" xml:space="preserve">
          <source>I find the SQL syntax to be simpler and more natural than its R equivalent (but this may just reflect my RDBMS bias).</source>
          <target state="translated">Encuentro que la sintaxis del SQL es más simple y más natural que su equivalente en R (pero esto puede reflejar mi sesgo de RDBMS).</target>
        </trans-unit>
        <trans-unit id="850ce2fc8639be910cca8a142e25a33d5a5324bd" translate="yes" xml:space="preserve">
          <source>I think this is a particularly appropriate solution if you have several tables that you want to left join against a single large table. Repeatedly rebuilding the entire table for each merge would be unnecessary and inefficient.</source>
          <target state="translated">Creo que es una solución particularmente apropiada si tienes varias mesas que quieres dejar unidas contra una sola mesa grande.Reconstruir repetidamente toda la mesa para cada fusión sería innecesario e ineficiente.</target>
        </trans-unit>
        <trans-unit id="81dd38b7e015ec1e1a6ff6776efb1705d815b694" translate="yes" xml:space="preserve">
          <source>I used spline interpolation to show a smooth curve for each solution/join type combination, drawn with individual pch symbols. The join type is captured by the pch symbol, using a dot for inner, left and right angle brackets for left and right, and a diamond for full. The solution type is captured by the color as shown in the legend.</source>
          <target state="translated">Utilicé la interpolación spline para mostrar una curva suave para cada combinación de tipo de unión de solución,dibujada con símbolos pch individuales.El tipo de unión es capturado por el símbolo pch,usando un punto para los ángulos internos,izquierdo y derecho para la izquierda y la derecha,y un diamante para el completo.El tipo de solución es capturado por el color como se muestra en la leyenda.</target>
        </trans-unit>
        <trans-unit id="a8ebc4a7bfcf1453154ce5c9cb696149ac776e30" translate="yes" xml:space="preserve">
          <source>I would recommend checking out &lt;a href=&quot;http://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;Gabor Grothendieck's sqldf package&lt;/a&gt;, which allows you to express these operations in SQL.</source>
          <target state="translated">Recomendar&amp;iacute;a consultar &lt;a href=&quot;http://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;el paquete sqldf de Gabor Grothendieck&lt;/a&gt; , que le permite expresar estas operaciones en SQL.</target>
        </trans-unit>
        <trans-unit id="2337e76070232665935ee45908852019881d7dba" translate="yes" xml:space="preserve">
          <source>I wrote some code to create log-log plots of the above results. I generated a separate plot for each overlap percentage. It's a little bit cluttered, but I like having all the solution types and join types represented in the same plot.</source>
          <target state="translated">Escribí un código para crear gráficos de registro de los resultados anteriores.Generé un gráfico separado para cada porcentaje de superposición.Está un poco desordenado,pero me gusta tener todos los tipos de soluciones y tipos de unión representados en el mismo gráfico.</target>
        </trans-unit>
        <trans-unit id="710e748e65ff61225c32f7870e72f52de5d5471e" translate="yes" xml:space="preserve">
          <source>If the column names to merge on are not the same, you can specify, e.g., &lt;code&gt;by.x = &quot;CustomerId_in_df1&quot;, by.y = &quot;CustomerId_in_df2&quot;&lt;/code&gt; where &lt;code&gt;CustomerId_in_df1&lt;/code&gt; is the name of the column in the first data frame and &lt;code&gt;CustomerId_in_df2&lt;/code&gt; is the name of the column in the second data frame. (These can also be vectors if you need to merge on multiple columns.)</source>
          <target state="translated">Si los nombres de columna para fusionar no son los mismos, puede especificar, por ejemplo, &lt;code&gt;by.x = &quot;CustomerId_in_df1&quot;, by.y = &quot;CustomerId_in_df2&quot;&lt;/code&gt; donde &lt;code&gt;CustomerId_in_df1&lt;/code&gt; es el nombre de la columna en el primer marco de datos y &lt;code&gt;CustomerId_in_df2&lt;/code&gt; es el nombre de la columna en el segundo marco de datos. (Estos tambi&amp;eacute;n pueden ser vectores si necesita fusionarse en varias columnas).</target>
        </trans-unit>
        <trans-unit id="f8fa4b6558b0a4f2f657a454fe32716ede7c01cf" translate="yes" xml:space="preserve">
          <source>If the key is a single column, then we can use a single call to &lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; to do the matching. This is the case I'll cover in this answer.</source>
          <target state="translated">Si la clave es una sola columna, entonces podemos usar una sola llamada para hacer &lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; para hacer la coincidencia. Este es el caso que cubrir&amp;eacute; en esta respuesta.</target>
        </trans-unit>
        <trans-unit id="aa34b093d971a035acaf887e23091153f1492e31" translate="yes" xml:space="preserve">
          <source>In joining two data frames with ~1 million rows each, one with 2 columns and the other with ~20, I've surprisingly found &lt;code&gt;merge(..., all.x = TRUE, all.y = TRUE)&lt;/code&gt; to be faster then &lt;code&gt;dplyr::full_join()&lt;/code&gt;. This is with dplyr v0.4</source>
          <target state="translated">Al unir dos marcos de datos con ~ 1 mill&amp;oacute;n de filas cada uno, uno con 2 columnas y el otro con ~ 20, sorprendentemente he encontrado que la &lt;code&gt;merge(..., all.x = TRUE, all.y = TRUE)&lt;/code&gt; es m&amp;aacute;s r&amp;aacute;pida que &lt;code&gt;dplyr::full_join()&lt;/code&gt; . Esto es con dplyr v0.4</target>
        </trans-unit>
        <trans-unit id="5a7ff2d9ec551ba208af43332df0b32a7dc8d5b3" translate="yes" xml:space="preserve">
          <source>In the above I hard-coded an assumption that the key column is the first column of both input tables. I would argue that, in general, this is not an unreasonable assumption, since, if you have a data.frame with a key column, it would be strange if it had not been set up as the first column of the data.frame from the outset. And you can always reorder the columns to make it so. An advantageous consequence of this assumption is that the name of the key column does not have to be hard-coded, although I suppose it's just replacing one assumption with another. Concision is another advantage of integer indexing, as well as speed. In the benchmarks below I'll change the implementation to use string name indexing to match the competing implementations.</source>
          <target state="translated">En lo anterior codifiqué duramente una suposición de que la columna clave es la primera columna de ambas tablas de entrada.Yo diría que,en general,no se trata de una suposición poco razonable,ya que,si se tiene un data.frame con una columna clave,sería extraño que no se hubiera configurado como la primera columna del data.frame desde el principio.Y siempre puedes reordenar las columnas para que así sea.Una consecuencia ventajosa de esta suposición es que el nombre de la columna clave no tiene que ser codificado,aunque supongo que es sólo reemplazar una suposición por otra.La precisión es otra ventaja de la indexación de números enteros,así como la velocidad.En los siguientes puntos de referencia cambiaré la implementación para usar la indexación de nombres de cadenas para que coincida con las implementaciones de la competencia.</target>
        </trans-unit>
        <trans-unit id="6250605ea19f359b4292e4f82913fe0d8caae6ab" translate="yes" xml:space="preserve">
          <source>It's all &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html&quot;&gt;here&lt;/a&gt; in great detail.</source>
          <target state="translated">Todo est&amp;aacute; &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt; con gran detalle.</target>
        </trans-unit>
        <trans-unit id="b091ee98d4a46bacae49eb5f90e7465fe5df5f71" translate="yes" xml:space="preserve">
          <source>Join-related &lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/news/news.html&quot;&gt;release highlights&lt;/a&gt;:</source>
          <target state="translated">Destacados de &lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/news/news.html&quot;&gt;lanzamiento&lt;/a&gt; relacionados con Join:</target>
        </trans-unit>
        <trans-unit id="ecc363814d7eeefe97adb1b510ca596b8ac8e949" translate="yes" xml:space="preserve">
          <source>Merge takes ~17 seconds, full_join takes ~65 seconds.</source>
          <target state="translated">La fusión toma ~17 segundos,la unión completa toma ~65 segundos.</target>
        </trans-unit>
        <trans-unit id="1d04d0125deda2ba2209b50e785af8edc6c62682" translate="yes" xml:space="preserve">
          <source>Modifying the OP's example tables...</source>
          <target state="translated">Modificando las tablas de ejemplo de la OP...</target>
        </trans-unit>
        <trans-unit id="cf0e80f7f1862b16f7353cadc5e580929ed727c8" translate="yes" xml:space="preserve">
          <source>Mutating joins, which add new variables to one table from matching rows in another. Filtering joins, which filter observations from one table based on whether or not they match an observation in the other table.</source>
          <target state="translated">Las uniones mutantes,que añaden nuevas variables a una tabla desde las filas coincidentes en otra.Uniones filtrantes,que filtran las observaciones de una tabla en base a si coinciden o no con una observación en la otra tabla.</target>
        </trans-unit>
        <trans-unit id="76494af2798aaf4f5297aa9a9455435c0a1baae3" translate="yes" xml:space="preserve">
          <source>Mutating joins: add columns to df1 using matches in df2</source>
          <target state="translated">Uniones mutuas:añadir columnas a df1 usando coincidencias en df2</target>
        </trans-unit>
        <trans-unit id="4f7e10e539fcde0fedb67622c28ce2185dc8d4fe" translate="yes" xml:space="preserve">
          <source>New in 2014:</source>
          <target state="translated">Nuevo en 2014:</target>
        </trans-unit>
        <trans-unit id="da097f490eba3885863a0e13ce340e42d5855b1e" translate="yes" xml:space="preserve">
          <source>New suffix argument to control what suffix duplicated variable names receive (#1296)</source>
          <target state="translated">Nuevo argumento de sufijo para controlar qué sufijo reciben los nombres de las variables duplicadas (#1296)</target>
        </trans-unit>
        <trans-unit id="b93e636c4795007ba0754843b031729197bf6b22" translate="yes" xml:space="preserve">
          <source>On the other hand, if you need the joinee to remain unaltered through this operation for whatever reason, then this solution cannot be used, since it modifies the joinee directly. Although in that case you could simply make a copy and perform the in-place assignment(s) on the copy.</source>
          <target state="translated">Por otra parte,si se necesita que la junta permanezca inalterada a través de esta operación por cualquier razón,entonces esta solución no puede ser utilizada,ya que modifica la junta directamente.Aunque en ese caso usted podría simplemente hacer una copia y realizar la(s)asignación(es)en el lugar de la copia.</target>
        </trans-unit>
        <trans-unit id="275a3e036899aeaeaf21926f7f5568683b2bb806" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;type&lt;/code&gt;: &lt;code&gt;inner&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;.</source>
          <target state="translated">Opciones de &lt;code&gt;type&lt;/code&gt; : &lt;code&gt;inner&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;full&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff2431181fc9fc2e60070beaa227805ee647ef62" translate="yes" xml:space="preserve">
          <source>R :- &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y =
&quot;CustomerId&quot;)[,names(df2)]&lt;/code&gt;</source>
          <target state="translated">R: - &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df2)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a90a1fd62b7cfb3514800d395f4aa530d9d32189" translate="yes" xml:space="preserve">
          <source>R :- &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df1)]&lt;/code&gt;</source>
          <target state="translated">R: - &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fe4364f88f74f296de93af3b3599121f64037b6" translate="yes" xml:space="preserve">
          <source>Return all rows from the left table, and any rows with matching keys from the right table.</source>
          <target state="translated">Devuelve todas las filas de la mesa de la izquierda,y las filas con las teclas correspondientes de la mesa de la derecha.</target>
        </trans-unit>
        <trans-unit id="b075052cf9c2a92043b4c19e839781e4f2bb219e" translate="yes" xml:space="preserve">
          <source>Return all rows from the right table, and any rows with matching keys from the left table.</source>
          <target state="translated">Devuelve todas las filas de la tabla de la derecha,y las filas con las teclas correspondientes de la tabla de la izquierda.</target>
        </trans-unit>
        <trans-unit id="256ebb1bf5d1b1490ada37135eaa9f3ef9b55410" translate="yes" xml:space="preserve">
          <source>Return only the rows in which the left table have matching keys in the right table.</source>
          <target state="translated">Devuelve sólo las filas en las que la tabla izquierda tiene claves de coincidencia en la tabla derecha.</target>
        </trans-unit>
        <trans-unit id="e571ab9ca057fdce414c471714347a24e546c952" translate="yes" xml:space="preserve">
          <source>Returns all rows from both tables, join records from the left which have matching keys in the right table.</source>
          <target state="translated">Devuelve todas las filas de ambas tablas,une los registros de la izquierda que tienen claves coincidentes en la tabla de la derecha.</target>
        </trans-unit>
        <trans-unit id="9e5d4b98769be55db1d88583ac64d18adb2b96ab" translate="yes" xml:space="preserve">
          <source>SQL :-  &lt;code&gt;select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</source>
          <target state="translated">SQL: - &lt;code&gt;select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1040827d8fcc05e6ced9f587ad7e4394f6d46db" translate="yes" xml:space="preserve">
          <source>SQL :- &lt;code&gt;select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</source>
          <target state="translated">SQL: - &lt;code&gt;select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="182e27662bc0db38ceece5dd2e17427203440683" translate="yes" xml:space="preserve">
          <source>Same way</source>
          <target state="translated">De la misma manera</target>
        </trans-unit>
        <trans-unit id="36d2d63aaf03c9e36ebc4dc91950d14a746e0b3d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/ggrothendieck/sqldf#example-4-join&quot;&gt;Gabor's sqldf GitHub&lt;/a&gt; for more information on joins.</source>
          <target state="translated">Consulte &lt;a href=&quot;https://github.com/ggrothendieck/sqldf#example-4-join&quot;&gt;sqldf GitHub de Gabor&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre las combinaciones.</target>
        </trans-unit>
        <trans-unit id="410c9a8726f8cbd1c1e586b81fe174b89fccc09b" translate="yes" xml:space="preserve">
          <source>Selecting columns can be done by &lt;code&gt;select(df,&quot;column&quot;)&lt;/code&gt;. If that's not SQL-ish enough for you, then there's the &lt;code&gt;sql()&lt;/code&gt; function, into which you can enter SQL code as-is, and it will do the operation you specified just like you were writing in R all along (for more information, please refer to the &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html&quot;&gt;dplyr/databases vignette&lt;/a&gt;). For example, if applied correctly, &lt;code&gt;sql(&quot;SELECT * FROM hflights&quot;)&lt;/code&gt; will select all the columns from the &quot;hflights&quot; dplyr table (a &quot;tbl&quot;).</source>
          <target state="translated">La selecci&amp;oacute;n de columnas se puede hacer mediante &lt;code&gt;select(df,&quot;column&quot;)&lt;/code&gt; . Si eso no es suficiente SQL-ish para usted, entonces est&amp;aacute; la funci&amp;oacute;n &lt;code&gt;sql()&lt;/code&gt; , en la que puede ingresar el c&amp;oacute;digo SQL tal como est&amp;aacute;, y realizar&amp;aacute; la operaci&amp;oacute;n que especific&amp;oacute; tal como estaba escribiendo en R todo el tiempo (para obtener m&amp;aacute;s informaci&amp;oacute;n , consulte la &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html&quot;&gt;vi&amp;ntilde;eta dplyr / bases de datos&lt;/a&gt; ). Por ejemplo, si se aplica correctamente, &lt;code&gt;sql(&quot;SELECT * FROM hflights&quot;)&lt;/code&gt; seleccionar&amp;aacute; todas las columnas de la tabla dplyr &quot;hflights&quot; (un &quot;tbl&quot;).</target>
        </trans-unit>
        <trans-unit id="89f032298f21e2eb6484041690c0b5f31f1c9852" translate="yes" xml:space="preserve">
          <source>Since your keys are named the same the short way to do an inner join is merge():</source>
          <target state="translated">Ya que tus llaves tienen el mismo nombre,el camino más corto para hacer una unión interna es fusionarse:</target>
        </trans-unit>
        <trans-unit id="09f26ff5d7f001a9ebafb1da072687d91833c703" translate="yes" xml:space="preserve">
          <source>Some food for though, since I generally default to dplyr for manipulation tasks.</source>
          <target state="translated">Algo de comida,ya que por lo general no me gusta hacer tareas de manipulación.</target>
        </trans-unit>
        <trans-unit id="fed6f49e983aa5bd71ca7e1155b989e6e3375280" translate="yes" xml:space="preserve">
          <source>Suppose we want to add the customer's state from &lt;code&gt;cust&lt;/code&gt; to the purchases table, &lt;code&gt;sales&lt;/code&gt;, ignoring the year column. With base R, we can identify matching rows and then copy values over:</source>
          <target state="translated">Supongamos que queremos agregar el estado del cliente desde el cliente a la tabla de compras, &lt;code&gt;sales&lt;/code&gt; , ignorando la columna del a&amp;ntilde;o. Con la base R, podemos identificar filas coincidentes y luego copiar valores sobre:</target>
        </trans-unit>
        <trans-unit id="cc0804bbd7e4d942d5dec0c858695fe81456d52e" translate="yes" xml:space="preserve">
          <source>Testing code:</source>
          <target state="translated">Probando el código:</target>
        </trans-unit>
        <trans-unit id="4d2affb1e17938190686ba88646124834885e979" translate="yes" xml:space="preserve">
          <source>The four joining-related functions in the dplyr package are (to quote):</source>
          <target state="translated">Las cuatro funciones relacionadas con la unión en el paquete dplyr son (para citar):</target>
        </trans-unit>
        <trans-unit id="975fec70202257751857627844d9ba0efd8ac25c" translate="yes" xml:space="preserve">
          <source>The other combination of outer joins can be created by mungling the left outer join subscript example. (yeah, I know that's the equivalent of saying &quot;I'll leave it as an exercise for the reader...&quot;)</source>
          <target state="translated">La otra combinación de uniones externas puede crearse masticando el ejemplo del subíndice de la unión externa izquierda.(sí,sé que eso es el equivalente a decir &quot;Lo dejaré como un ejercicio para el lector...&quot;)</target>
        </trans-unit>
        <trans-unit id="cfb49dc74158670dddef83e622172c7c91441e36" translate="yes" xml:space="preserve">
          <source>The resulting plots, using the same plotting code given above:</source>
          <target state="translated">Las tramas resultantes,usando el mismo código de trama dado anteriormente:</target>
        </trans-unit>
        <trans-unit id="3fd1810b687b3f6297e5dacac6cd2f293af39cd7" translate="yes" xml:space="preserve">
          <source>The three examples above all focus on creating/adding a new column. See &lt;a href=&quot;https://stackoverflow.com/q/6112260&quot;&gt;the related R FAQ&lt;/a&gt; for an example of updating/modifying an existing column.</source>
          <target state="translated">Los tres ejemplos anteriores se centran en crear / agregar una nueva columna. Consulte &lt;a href=&quot;https://stackoverflow.com/q/6112260&quot;&gt;las preguntas frecuentes relacionadas con R&lt;/a&gt; para ver un ejemplo de actualizaci&amp;oacute;n / modificaci&amp;oacute;n de una columna existente.</target>
        </trans-unit>
        <trans-unit id="cecd23eb962bc5d6748ad3fb34f5562f803499f5" translate="yes" xml:space="preserve">
          <source>There are some good examples of doing this over at the &lt;a href=&quot;http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge&quot;&gt;R Wiki&lt;/a&gt;. I'll steal a couple here:</source>
          <target state="translated">Hay algunos buenos ejemplos de c&amp;oacute;mo hacer esto en &lt;a href=&quot;http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge&quot;&gt;R Wiki&lt;/a&gt; . Robar&amp;eacute; un par aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="d8d441f0127df63fc7e588978f519a0a7110a1d7" translate="yes" xml:space="preserve">
          <source>There is the &lt;strong&gt;data.table&lt;/strong&gt; approach for an inner join, which is very time and memory efficient (and necessary for some larger data.frames):</source>
          <target state="translated">Existe el enfoque de &lt;strong&gt;data.table&lt;/strong&gt; para una uni&amp;oacute;n interna, que es muy eficiente en tiempo y memoria (y necesario para algunos data.frames m&amp;aacute;s grandes):</target>
        </trans-unit>
        <trans-unit id="e97719490cc7ca28a945d219ef810933fffa9275" translate="yes" xml:space="preserve">
          <source>Translating SQL joins on foreign keys to R data.table syntax</source>
          <target state="translated">La traducción de SQL se une a las claves externas de la sintaxis R data.table</target>
        </trans-unit>
        <trans-unit id="def30251a119892b32dc57973f51d84d2b8a55a3" translate="yes" xml:space="preserve">
          <source>Update on data.table methods for joining datasets. See below examples for each type of join. There are two methods, one from &lt;code&gt;[.data.table&lt;/code&gt; when passing second data.table as the first argument to subset, another way is to use &lt;code&gt;merge&lt;/code&gt; function which dispatches to fast data.table method.</source>
          <target state="translated">Actualizaci&amp;oacute;n sobre m&amp;eacute;todos data.table para unir conjuntos de datos. Vea los ejemplos a continuaci&amp;oacute;n para cada tipo de uni&amp;oacute;n. Hay dos m&amp;eacute;todos, uno de &lt;code&gt;[.data.table&lt;/code&gt; al pasar el segundo data.table como el primer argumento para subconjunto, otra forma es utilizar la funci&amp;oacute;n de &lt;code&gt;merge&lt;/code&gt; que se env&amp;iacute;a al m&amp;eacute;todo r&amp;aacute;pido de data.table.</target>
        </trans-unit>
        <trans-unit id="5b7fa59fc1d348ab50e552c606a943a4fb3428d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;merge&lt;/code&gt; function we can select the variable of left table or right table, same way like we all familiar with select statement in SQL (EX : Select a.* ...or Select b.* from .....)</source>
          <target state="translated">Usando la funci&amp;oacute;n de &lt;code&gt;merge&lt;/code&gt; podemos seleccionar la variable de la tabla izquierda o la tabla derecha, de la misma manera que todos estamos familiarizados con la instrucci&amp;oacute;n select en SQL (EX: Seleccione a. * ... o Seleccione b. * De .....)</target>
        </trans-unit>
        <trans-unit id="777e443e9e2269e9c7657e5c1bb5b4ef07dd5d99" translate="yes" xml:space="preserve">
          <source>We have to add extra code which will subset from the newly joined table .</source>
          <target state="translated">Tenemos que añadir código extra que se subconjunto de la tabla recién unida.</target>
        </trans-unit>
        <trans-unit id="35f9f5a0a66021813e967af96baa693e8e91102d" translate="yes" xml:space="preserve">
          <source>Workarounds per hadley's comments in that issue:</source>
          <target state="translated">Los comentarios de Hadley en ese número:</target>
        </trans-unit>
        <trans-unit id="20e71a92fd73f1ea6448c8ce19a1b28c6fd612ab" translate="yes" xml:space="preserve">
          <source>Yet another option is the &lt;code&gt;join&lt;/code&gt; function found in the &lt;a href=&quot;http://cran.r-project.org/web/packages/plyr/index.html&quot;&gt;&lt;strong&gt;plyr&lt;/strong&gt;&lt;/a&gt; package</source>
          <target state="translated">Otra opci&amp;oacute;n es la funci&amp;oacute;n de &lt;code&gt;join&lt;/code&gt; que se encuentra en el paquete &lt;a href=&quot;http://cran.r-project.org/web/packages/plyr/index.html&quot;&gt;&lt;strong&gt;plyr&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a4ca82ec6e06c0c6954a4927a77918e335215d61" translate="yes" xml:space="preserve">
          <source>You can do joins as well using Hadley Wickham's awesome &lt;a href=&quot;http://blog.rstudio.org/2014/01/17/introducing-dplyr/&quot;&gt;dplyr&lt;/a&gt; package.</source>
          <target state="translated">Tambi&amp;eacute;n puedes hacer combinaciones usando el incre&amp;iacute;ble paquete &lt;a href=&quot;http://blog.rstudio.org/2014/01/17/introducing-dplyr/&quot;&gt;dplyr de&lt;/a&gt; Hadley Wickham.</target>
        </trans-unit>
        <trans-unit id="5724e67f3f18acb7528650cc64cff7877156db95" translate="yes" xml:space="preserve">
          <source>You can merge on multiple columns by giving &lt;code&gt;by&lt;/code&gt; a vector, e.g., &lt;code&gt;by = c(&quot;CustomerId&quot;, &quot;OrderId&quot;)&lt;/code&gt;.</source>
          <target state="translated">Puede fusionar en varias columnas dando &lt;code&gt;by&lt;/code&gt; un vector, por ejemplo, &lt;code&gt;by = c(&quot;CustomerId&quot;, &quot;OrderId&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf2d2dee20b0fe4b4b6a2f7726c0245d830c0168" translate="yes" xml:space="preserve">
          <source>a full inner join (all records from both tables) can be created with the &quot;all&quot; keyword:</source>
          <target state="translated">se puede crear una unión interna completa (todos los registros de ambas tablas)con la palabra clave &quot;todos&quot;:</target>
        </trans-unit>
        <trans-unit id="45b24f5fc4c5960be3b959ba6f2bc3227a86250d" translate="yes" xml:space="preserve">
          <source>a left outer join of df1 and df2:</source>
          <target state="translated">una unión exterior izquierda de df1 y df2:</target>
        </trans-unit>
        <trans-unit id="6d47d87da3f640b3f3ac9043cf30483af1712d57" translate="yes" xml:space="preserve">
          <source>a right outer join of df1 and df2:</source>
          <target state="translated">una unión exterior derecha de df1 y df2:</target>
        </trans-unit>
        <trans-unit id="f00d083db7a975f33fd38e2809f8dd64537504aa" translate="yes" xml:space="preserve">
          <source>base R &lt;code&gt;merge()&lt;/code&gt; and equivalent package-based merge functions, which always allocate a new table to return the merged result, and thus are not suitable for an in-place assignment-based solution.</source>
          <target state="translated">base R &lt;code&gt;merge()&lt;/code&gt; y funciones de combinaci&amp;oacute;n basadas en paquetes equivalentes, que siempre asignan una nueva tabla para devolver el resultado combinado y, por lo tanto, no son adecuadas para una soluci&amp;oacute;n basada en asignaci&amp;oacute;n en el lugar.</target>
        </trans-unit>
        <trans-unit id="abfb07f46a8b85131c33b5c00be46ae3ec4d825a" translate="yes" xml:space="preserve">
          <source>data.table documented on stackoverflow:</source>
          <target state="translated">datos.tabla documentada en stackoverflow:</target>
        </trans-unit>
        <trans-unit id="739d53834e2598c061e546b33d4c497722f8aa6e" translate="yes" xml:space="preserve">
          <source>didn't yet &lt;a href=&quot;https://github.com/hadley/dplyr/issues/96&quot;&gt;implement right_join and &lt;strong&gt;outer_join&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">todav&amp;iacute;a no &lt;a href=&quot;https://github.com/hadley/dplyr/issues/96&quot;&gt;implement&amp;oacute; right_join y &lt;strong&gt;external_join&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dc4f0b439d260cec5f45060722ff170e14ccd80" translate="yes" xml:space="preserve">
          <source>dplyr since 0.4 implemented all those joins including &lt;code&gt;outer_join&lt;/code&gt;, but it was worth noting that &lt;strong&gt;for the first few releases prior to 0.4 it used not to offer &lt;code&gt;outer_join&lt;/code&gt;, and as a result there was a lot of really bad hacky workaround user code floating around for quite a while afterwards (you can still find such code in SO, Kaggle answers, github from that period. Hence this answer still serves a useful purpose.)&lt;/strong&gt;</source>
          <target state="translated">dplyr desde 0.4 implement&amp;oacute; todas esas uniones, incluyendo &lt;code&gt;outer_join&lt;/code&gt; , pero vali&amp;oacute; la pena se&amp;ntilde;alar que &lt;strong&gt;para las primeras versiones anteriores a 0.4 sol&amp;iacute;a no ofrecer &lt;code&gt;outer_join&lt;/code&gt; , y como resultado hab&amp;iacute;a una gran cantidad de c&amp;oacute;digo de usuario de soluci&amp;oacute;n hacky realmente malo flotando por bastante un tiempo despu&amp;eacute;s (todav&amp;iacute;a puede encontrar dicho c&amp;oacute;digo en SO, Kaggle responde, github de ese per&amp;iacute;odo. Por lo tanto, esta respuesta todav&amp;iacute;a tiene un prop&amp;oacute;sito &amp;uacute;til).&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61e2da8dd77d5e292248c9fb83d7a134ac198b3a" translate="yes" xml:space="preserve">
          <source>has &lt;strong&gt;inner_join, left_join, semi_join, anti_join&lt;/strong&gt;</source>
          <target state="translated">tiene &lt;strong&gt;inner_join, left_join, semi_join, anti_join&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091a85912279e018e930a477c24b367571489c0f" translate="yes" xml:space="preserve">
          <source>inefficient cartesian conjunctions, e.g. &lt;code&gt;outer(df1$a,df2$a,`==`) &amp;amp; outer(df1$b,df2$b,`==`)&lt;/code&gt;.</source>
          <target state="translated">conjunciones cartesianas ineficientes, por ejemplo, &lt;code&gt;outer(df1$a,df2$a,`==`) &amp;amp; outer(df1$b,df2$b,`==`)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a34ccb1aad2f513af7c11ec01144f6ab37837eaf" translate="yes" xml:space="preserve">
          <source>inefficient concatenations. e.g. &lt;code&gt;match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))&lt;/code&gt;, or the same idea with &lt;code&gt;paste()&lt;/code&gt;.</source>
          <target state="translated">concatenaciones ineficientes. por ejemplo, &lt;code&gt;match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))&lt;/code&gt; , o la misma idea con &lt;code&gt;paste()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feb96c8e7073f7b49193f9c3ac2e9abbef5ee89f" translate="yes" xml:space="preserve">
          <source>one minor feature merge currently has that dplyr doesn't is &lt;a href=&quot;https://github.com/hadley/dplyr/issues/177&quot;&gt;the ability to have separate by.x,by.y columns&lt;/a&gt; as e.g. Python pandas does.</source>
          <target state="translated">Una fusi&amp;oacute;n de caracter&amp;iacute;sticas menores actualmente tiene que dplyr no es &lt;a href=&quot;https://github.com/hadley/dplyr/issues/177&quot;&gt;la capacidad de tener columnas by.x, by.y separadas&lt;/a&gt; como, por ejemplo, los pandas de Python.</target>
        </trans-unit>
        <trans-unit id="b89a4220d42db1407a2fa042c855a3d4652ddd00" translate="yes" xml:space="preserve">
          <source>you can flip 'em, slap 'em and rub 'em down to get the other two outer joins you asked about :)</source>
          <target state="translated">puedes voltearlos,abofetearlos y frotarlos para obtener las otras dos uniones externas por las que preguntaste :)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
