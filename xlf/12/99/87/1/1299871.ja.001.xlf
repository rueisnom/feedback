<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1299871">
    <body>
      <group id="1299871">
        <trans-unit id="d47d7caf030340f041a78d2ceb0b7965bda3093d" translate="yes" xml:space="preserve">
          <source>*_join() no longer reorders column names (#324)</source>
          <target state="translated">*_join()がカラム名の並び替えを行わなくなりました (#324)</target>
        </trans-unit>
        <trans-unit id="487b6c91b5261dd50389ad61b918fe7838afe87f" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/12030932/2490497&quot;&gt;rolling join&lt;/a&gt; - if you want merge to be able to match to values from preceeding/following rows by rolling them forward or backward</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/12030932/2490497&quot;&gt;ローリング結合&lt;/a&gt; -マージを前後にローリングすることにより、前/後のローの値と一致させる場合</target>
        </trans-unit>
        <trans-unit id="84c6f6a09e15ca4a5e7777731b7f61a686126d78" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/25815032/2490497&quot;&gt;overlapping join&lt;/a&gt; - if you want to merge by ranges</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/25815032/2490497&quot;&gt;オーバーラップ結合&lt;/a&gt; -範囲でマージしたい場合</target>
        </trans-unit>
        <trans-unit id="afc219bc005a7c35074b4b7bdeb7c70495859d1b" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/3190118/2490497&quot;&gt;update on join&lt;/a&gt; - if you want to lookup values from another table to your main table</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/3190118/2490497&quot;&gt;結合時に更新&lt;/a&gt; -別のテーブルからメインテーブルに値を検索する場合</target>
        </trans-unit>
        <trans-unit id="890d6745a9399241952baa05d0099615ae7dc270" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/41043047/2490497&quot;&gt;non-equi join&lt;/a&gt; - if your join condition is non-equal</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/41043047/2490497&quot;&gt;非等価結合&lt;/a&gt; -結合条件が等しくない場合</target>
        </trans-unit>
        <trans-unit id="92ed8f843671545e7e2acc8d069fdcc2446feaeb" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/41684012/2490497&quot;&gt;aggregate on join&lt;/a&gt; - if you want to aggregate on key you are joining you do not have to materialize all join results</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/41684012/2490497&quot;&gt;結合時に集計&lt;/a&gt; - 結合するキーについて集計する場合、すべての結合結果を具体化する必要はありません</target>
        </trans-unit>
        <trans-unit id="07ce8fe7aebda33b8d668e59d9c852c30c95ed33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anti_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x
where there are not matching values in y, keeping just columns from x</source>
          <target state="translated">&lt;code&gt;anti_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; ：xの列のみを保持して、yに一致する値がないすべての行をxから返します</target>
        </trans-unit>
        <trans-unit id="846866e1d2e49dece784b5f56afce637ce3acb5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inner_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from
x where there are matching values in y, and all columns from x and y</source>
          <target state="translated">&lt;code&gt;inner_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; ：yに一致する値があるxからすべての行を返し、xとyからすべての列を返します</target>
        </trans-unit>
        <trans-unit id="4756dd78d19e6570c93a82eb2702ffcd868aa1a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x, and all columns from x and y</source>
          <target state="translated">&lt;code&gt;left_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; ：xからすべての行を返し、xとyからすべての列を返します</target>
        </trans-unit>
        <trans-unit id="b1ac4ba54b36075fe4e311146847172ffda51a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; also works on data.tables (as it is generic and calls &lt;code&gt;merge.data.table&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; はdata.tablesでも機能します（汎用であり、 &lt;code&gt;merge.data.table&lt;/code&gt; を呼び出します ）。</target>
        </trans-unit>
        <trans-unit id="8c0dab1fb7e149efd4ef02ea7323dd1028acf2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;semi_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x where there are matching values in
y, keeping just columns from x.</source>
          <target state="translated">&lt;code&gt;semi_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; ：yに一致する値があるxからすべての行を返し、xからの列のみを保持します。</target>
        </trans-unit>
        <trans-unit id="64447dc8e6edd1cc9f32821eb103cfca1f89e9cb" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;Just as with the inner join, you would probably want to explicitly pass &quot;CustomerId&quot; to R as the matching variable.&lt;/strike&gt;  I think it's almost always best to explicitly state the identifiers on which you want to merge; it's safer if the input data.frames change unexpectedly and easier to read later on.</source>
          <target state="translated">&lt;strike&gt;内部結合と同様に、 &quot;CustomerId&quot;を一致する変数としてRに明示的に渡すことをお勧めします。&lt;/strike&gt; ほとんどの場合、マージしたい識別子を明示的に述べるのが最善だと思います。 入力data.framesが予期せず変更され、後で読みやすくなれば、より安全です。</target>
        </trans-unit>
        <trans-unit id="8f2b37c4fd55625fd3e73914491c5bd0dc311ccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Cross join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = NULL)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;クロス結合：&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = NULL)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8a7da9103d4d41873615a068f57166a2b7778c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Inner join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(df1, df2)&lt;/code&gt; will work for these examples because R automatically joins the frames by common variable names, but you would most likely want to specify &lt;code&gt;merge(df1, df2, by = &quot;CustomerId&quot;)&lt;/code&gt; to make sure that you were matching on only the fields you desired.  You can also use the &lt;code&gt;by.x&lt;/code&gt; and &lt;code&gt;by.y&lt;/code&gt; parameters if the matching variables have different names in the different data frames.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;内部結合：&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(df1, df2)&lt;/code&gt; はこれらの例で機能します。これは、Rが共通の変数名でフレームを自動的に結合するためですが、 &lt;code&gt;merge(df1, df2, by = &quot;CustomerId&quot;)&lt;/code&gt; を指定して、必要なフィールドのみに一致しました 一致する変数が異なるデータフレームで異なる名前を持つ場合は、 &lt;code&gt;by.x&lt;/code&gt; および &lt;code&gt;by.y&lt;/code&gt; パラメータを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="038870ab05a425a137f8fbbc279dda97c77d683f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Left outer:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)&lt;/code&gt; &lt;strong&gt;&lt;em&gt;：&lt;/em&gt;&lt;/strong&gt; merge（x = df1、y = df2、by = &quot;CustomerId&quot;、all.x = TRUE）</target>
        </trans-unit>
        <trans-unit id="72ebaef810f98fc55883bca7f5dfd5acba8a9cae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Outer join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;外部結合：&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dab4ebd7ed185ebd97efccd2c02d50ba28589364" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Right outer:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)&lt;/code&gt; &lt;strong&gt;&lt;em&gt;：&lt;/em&gt;&lt;/strong&gt; merge（x = df1、y = df2、by = &quot;CustomerId&quot;、all.y = TRUE）</target>
        </trans-unit>
        <trans-unit id="feb6dda0b81cd0e64ea3c74f9c8b636b97c7342f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.1.3&lt;/em&gt;&lt;/strong&gt; (4/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.1.3&lt;/em&gt;&lt;/strong&gt; （2014年4月）</target>
        </trans-unit>
        <trans-unit id="977c100088eecd2687b330acb3b61630e1c463ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.2&lt;/em&gt;&lt;/strong&gt; (5/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.2&lt;/em&gt;&lt;/strong&gt; （2014年5月）</target>
        </trans-unit>
        <trans-unit id="9d1100b98263dbf4dd0f99865af468f7b55e605f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.3&lt;/em&gt;&lt;/strong&gt; (10/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.3&lt;/em&gt;&lt;/strong&gt; （2014年10月）</target>
        </trans-unit>
        <trans-unit id="bd8720e189cc792821196cc8bacaf98d3035fecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.4.0&lt;/em&gt;&lt;/strong&gt; (1/2015)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.4.0&lt;/em&gt;&lt;/strong&gt; （2015年1月）</target>
        </trans-unit>
        <trans-unit id="66e75518de390f9fe0e9e80b4cbab16a3bcb592b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.5&lt;/em&gt;&lt;/strong&gt; (6/2016)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.5&lt;/em&gt;&lt;/strong&gt; （2016年6月）</target>
        </trans-unit>
        <trans-unit id="7d481f74b71e19ee13eac5a4c57e4f92286ac1b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implement right join and outer join&lt;/strong&gt; (#96)</source>
          <target state="translated">&lt;strong&gt;右結合と外部結合を実装する&lt;/strong&gt; （＃96）</target>
        </trans-unit>
        <trans-unit id="7d863a7bd89469b75eeee503d3a69a99724f4c9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Merge Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;マージ方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="631fffa31418327ad1ceee06912e77e433c2a830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rolling update join.&lt;/strong&gt; Alternately, we may want to take the last state the customer was found in:</source>
          <target state="translated">&lt;strong&gt;ローリング更新結合。&lt;/strong&gt; または、お客様が見つかった最後の状態を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="16a449699f13e0f7577783adc61a84fa6b01f031" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscript Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;下付きメソッド&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b809d4e294824a9bd8793db2c442bcc11490e805" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update join with multiple columns.&lt;/strong&gt; The approach above works well when we are joining on only a single column and are satisfied with the first match. Suppose we want the year of measurement in the customer table to match the year of sale.</source>
          <target state="translated">&lt;strong&gt;複数の列で結合を更新します。&lt;/strong&gt; 上記のアプローチは、単一の列のみで結合していて、最初の一致で満足している場合にうまく機能します。 customerテーブルの測定年を販売年と一致させたいとします。</target>
        </trans-unit>
        <trans-unit id="60c8303c5c795a80894a040e6ad09b86a234618e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update join.&lt;/strong&gt; One other important SQL-style join is an &quot;&lt;a href=&quot;https://stackoverflow.com/q/7869592/&quot;&gt;update join&lt;/a&gt;&quot; where columns in one table are updated (or created) using another table.</source>
          <target state="translated">&lt;strong&gt;結合を更新します。&lt;/strong&gt; もう1つの重要なSQLスタイルの結合は、「 &lt;a href=&quot;https://stackoverflow.com/q/7869592/&quot;&gt;更新結合&lt;/a&gt; 」で、1つのテーブルの列が別のテーブルを使用して更新（または作成）されます。</target>
        </trans-unit>
        <trans-unit id="d36e434acda5756c7bc2a0734856c0841c167a0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;outer_join&lt;/strong&gt; is basically union(left_join(x, y), right_join(x, y)) - i.e. preserve all rows in both data frames.</source>
          <target state="translated">&lt;strong&gt;outer_join&lt;/strong&gt;は基本的にunion（left_join（x、y）、right_join（x、y））です-つまり、両方のデータフレームのすべての行を保持します。</target>
        </trans-unit>
        <trans-unit id="e65d821137f54f3e9e9fa6bf3d532f2edb926dc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;outer_join&lt;/strong&gt; not implemented yet, fallback is use base::merge() (or plyr::join())</source>
          <target state="translated">&lt;strong&gt;outer_join&lt;/strong&gt;はまだ実装されていません。フォールバックはbase :: merge（）（またはplyr :: join（））を使用します</target>
        </trans-unit>
        <trans-unit id="7af98f3c825f135edda87f9c794dac0060279aa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;right_join&lt;/strong&gt;(x,y) is the same as left_join(y,x) in terms of the rows, just the columns will be different orders. Easily worked around with select(new_column_order)</source>
          <target state="translated">&lt;strong&gt;right_join&lt;/strong&gt; （x、y）は、行の点ではleft_join（y、x）と同じですが、列の順序が異なります。 select（new_column_order）で簡単に回避</target>
        </trans-unit>
        <trans-unit id="0c8b0aa635a2a6ad43b6f15dacdced43bcb2ee8b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join&quot;&gt;left outer join (or simply left join)&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;df1&lt;/code&gt; と &lt;code&gt;df2&lt;/code&gt; の左外部 &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join&quot;&gt;結合（または単に左結合）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65bd236cef1312710765c40a2d7ed2b9ae5d1de6" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Right_outer_join&quot;&gt;right outer join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;df1&lt;/code&gt; と &lt;code&gt;df2&lt;/code&gt; の右外部結合</target>
        </trans-unit>
        <trans-unit id="a995d5ebe59aa37a58c647f553d519dece05faba" translate="yes" xml:space="preserve">
          <source>A left outer join with df1 on the left using a subscript method would be:</source>
          <target state="translated">添え字法を使って左にdf1を配置した左外結合は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="0085fab60d07cb78647869bd8cefbf2ec4234148" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join&quot;&gt;inner join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;df1&lt;/code&gt; と &lt;code&gt;df2&lt;/code&gt; の&lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join&quot;&gt;内部結合&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="bf81a3ad99c579907678ed7b25d860ad1049d3a1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Outer_join&quot;&gt;outer join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;df1&lt;/code&gt; と &lt;code&gt;df2&lt;/code&gt; の&lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Outer_join&quot;&gt;外部結合&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="99e1e176cca1b8231019f4dab468ecffc875a219" translate="yes" xml:space="preserve">
          <source>As @bgoldst's answer mentions, &lt;code&gt;match&lt;/code&gt; with &lt;code&gt;interaction&lt;/code&gt; might be an option for this case. More straightforwardly, one could use data.table:</source>
          <target state="translated">@bgoldstの回答が言及しているように、 &lt;code&gt;interaction&lt;/code&gt; との &lt;code&gt;match&lt;/code&gt; はこのケースのオプションかもしれません。 より簡単に言うと、data.tableを使用できます。</target>
        </trans-unit>
        <trans-unit id="abf28bebf45530a8950f4d9293a4c78cef6b6b00" translate="yes" xml:space="preserve">
          <source>As a side note, I briefly looked into possible matching solutions for multicolumn keys. Unfortunately, the only matching solutions I found were:</source>
          <target state="translated">余談ですが、私はマルチカラム・キーにマッチする可能性のある解決策を簡単に調べてみました。残念ながら、私が見つけた唯一のマッチングソリューションは</target>
        </trans-unit>
        <trans-unit id="4f166ad2d60f8daeca4449327bda4a7811ee2769" translate="yes" xml:space="preserve">
          <source>As can be seen here, &lt;code&gt;match&lt;/code&gt; selects the first matching row from the customer table.</source>
          <target state="translated">ここに示すように、 &lt;code&gt;match&lt;/code&gt; は、customerテーブルから最初に一致する行を選択します。</target>
        </trans-unit>
        <trans-unit id="b660aa6af5b76fcb666125e5ca3d5a374b6eebf4" translate="yes" xml:space="preserve">
          <source>Be aware there are other types of joins you can perform using &lt;code&gt;data.table&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;data.table&lt;/code&gt; を使用して実行できる他のタイプの結合があることに注意してください 。</target>
        </trans-unit>
        <trans-unit id="58719bd04f95ef9656fef30a4d66177a963af55f" translate="yes" xml:space="preserve">
          <source>Below benchmark tests base R, sqldf, dplyr and data.table.</source>
          <target state="translated">以下のベンチマークテストでは、ベースとなるR、sqldf、dplyr、data.tableをテストしています。</target>
        </trans-unit>
        <trans-unit id="9afae0499a8b49e7f0ef74e289efbf6ff5cc05de" translate="yes" xml:space="preserve">
          <source>Benchmark tests unkeyed/unindexed datasets.
Benchmark is performed on 50M-1 rows datasets, there are 50M-2 common values on join column so each scenario (inner, left, right, full) can be tested and join is still not trivial to perform. It is type of join which well stress join algorithms. Timings are as of &lt;code&gt;sqldf:0.4.11&lt;/code&gt;, &lt;code&gt;dplyr:0.7.8&lt;/code&gt;, &lt;code&gt;data.table:1.12.0&lt;/code&gt;.</source>
          <target state="translated">ベンチマークは、キーなし/インデックスなしのデータセットをテストします。 ベンチマークは50M-1行のデータセットで実行され、結合列には50M-2の共通値があるため、各シナリオ（内部、左、右、完全）をテストでき、結合はまだ簡単ではありません。 これは、結合アルゴリズムを強調する結合のタイプです。 タイミングは &lt;code&gt;sqldf:0.4.11&lt;/code&gt; 、 &lt;code&gt;dplyr:0.7.8&lt;/code&gt; 、 &lt;code&gt;data.table:1.12.0&lt;/code&gt; の時点です。</target>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="031a1bb7db92ad832e32717777d34cb324b9c6c7" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;merge&lt;/code&gt; function and its optional parameters:</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 機能とそのオプションのパラメーターを使用して：</target>
        </trans-unit>
        <trans-unit id="0850f670fdb08a62b7a39a07049252d4595216df" translate="yes" xml:space="preserve">
          <source>Can now left_join by different variables in each table: df1 %&amp;gt;% left_join(df2, c(&quot;var1&quot; = &quot;var2&quot;))</source>
          <target state="translated">各テーブルの異なる変数でleft_joinできるようになりました：df1％&amp;gt;％left_join（df2、c（ &quot;var1&quot; = &quot;var2&quot;））</target>
        </trans-unit>
        <trans-unit id="c6e5a298734559d60b7bb8a74b34d9ba6755ed0d" translate="yes" xml:space="preserve">
          <source>Code to reproduce:</source>
          <target state="translated">再現するためのコード。</target>
        </trans-unit>
        <trans-unit id="c85693681142b2f48692df23c7bd83524829e4cc" translate="yes" xml:space="preserve">
          <source>Efficient alternatives to merge for larger data.frames R</source>
          <target state="translated">大きなdata.framesのための効率的なマージの代替案 R</target>
        </trans-unit>
        <trans-unit id="a0fb268d8865888849541e2461b53e088d173672" translate="yes" xml:space="preserve">
          <source>Especially if you're also interested in data manipulation in general (including sorting, filtering, subsetting, summarizing etc.), you should definitely take a look at &lt;code&gt;dplyr&lt;/code&gt;, which comes with a variety of functions all designed to facilitate your work specifically with data frames and certain other database types. It even offers quite an elaborate SQL interface, and even a function to convert (most) SQL code directly into R.</source>
          <target state="translated">特に、一般的なデータ操作（ソート、フィルタリング、サブセット化、要約などを含む）にも関心がある場合は、 &lt;code&gt;dplyr&lt;/code&gt; を必ず確認してください。dplyrには 、データでの作業を容易にするために設計されたさまざまな機能がすべて備わっています。フレームおよびその他の特定のデータベースタイプ。 非常に手の込んだSQLインターフェースを提供し、（ほとんどの）SQLコードを直接Rに変換する関数さえ提供します。</target>
        </trans-unit>
        <trans-unit id="1cb91a4d85314d943d7ed8d0eb363de15a4cfd5d" translate="yes" xml:space="preserve">
          <source>Example data:</source>
          <target state="translated">データ例。</target>
        </trans-unit>
        <trans-unit id="6d830da55607c318b0229bbe871dede8489bbbcd" translate="yes" xml:space="preserve">
          <source>Extra credit:</source>
          <target state="translated">余計なお世話だ</target>
        </trans-unit>
        <trans-unit id="cb15184868a7170582b96630a6ea5bb279f5d610" translate="yes" xml:space="preserve">
          <source>Filtering joins: filter out rows in df1, don't modify columns</source>
          <target state="translated">結合のフィルタリング:df1で行をフィルタリングし、列を変更しない</target>
        </trans-unit>
        <trans-unit id="d9513dbbe672535839baa4a6cc570a53345b40d1" translate="yes" xml:space="preserve">
          <source>For an inner join on all columns, you could also use &lt;code&gt;fintersect&lt;/code&gt; from the &lt;em&gt;data.table&lt;/em&gt;-package or &lt;code&gt;intersect&lt;/code&gt; from the &lt;em&gt;dplyr&lt;/em&gt;-package as an alternative to &lt;code&gt;merge&lt;/code&gt; without specifying the &lt;code&gt;by&lt;/code&gt;-columns. this will give the rows that are equal between two dataframes:</source>
          <target state="translated">すべての列の内部結合の場合、 &lt;code&gt;by&lt;/code&gt; -columnsを指定せずに &lt;code&gt;merge&lt;/code&gt; する代わりに、 &lt;em&gt;data.table&lt;/em&gt; -packageのfintersectまたは&lt;em&gt;dplyr&lt;/em&gt; -packageのintersectを使用することもできます。 これにより、2つのデータフレーム間で等しい行が得られます。</target>
        </trans-unit>
        <trans-unit id="3ecb0b93f83cfe035b561507dbb9ead3739e0215" translate="yes" xml:space="preserve">
          <source>For example, see &lt;a href=&quot;https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r&quot;&gt;Matching multiple columns on different data frames and getting other column as result&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns&quot;&gt;match two columns with two other columns&lt;/a&gt;, &lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html&quot;&gt;Matching on multiple columns&lt;/a&gt;, and the dupe of this question where I originally came up with the in-place solution, &lt;a href=&quot;https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281&quot;&gt;Combine two data frames with different number of rows in R&lt;/a&gt;.</source>
          <target state="translated">たとえば、 &lt;a href=&quot;https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r&quot;&gt;さまざまなデータフレームで複数の列&lt;/a&gt;を一致させ、結果として他の列を取得する 、 &lt;a href=&quot;https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns&quot;&gt;2つの列を他の2つの列&lt;/a&gt;で&lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html&quot;&gt;一致させる、複数&lt;/a&gt; の列で一致する 、および最初にインプレースソリューション&lt;a href=&quot;https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281&quot;&gt;Combineを&lt;/a&gt;思いついたこの質問の重複を参照してください。 Rの行数が異なる2つのデータフレーム 。</target>
        </trans-unit>
        <trans-unit id="6bc9cab91de980063bff0c869e8cd295f71aeae3" translate="yes" xml:space="preserve">
          <source>For the case of a left join with a &lt;code&gt;0..*:0..1&lt;/code&gt; cardinality or a right join with a &lt;code&gt;0..1:0..*&lt;/code&gt; cardinality it is possible to assign in-place the unilateral columns from the joiner (the &lt;code&gt;0..1&lt;/code&gt; table) directly onto the joinee (the &lt;code&gt;0..*&lt;/code&gt; table), and thereby avoid the creation of an entirely new table of data. This requires matching the key columns from the joinee into the joiner and indexing+ordering the joiner's rows accordingly for the assignment.</source>
          <target state="translated">カーディナリティが &lt;code&gt;0..*:0..1&lt;/code&gt; 左結合または &lt;code&gt;0..1:0..*&lt;/code&gt; カーディナリティの右結合の場合、結合子から単側の列をインプレースで割り当てることができます（ 0..1テーブル）を直接結合者（ &lt;code&gt;0..*&lt;/code&gt; テーブル）に配置することで、まったく新しいデータテーブルの作成を回避します。 これには、ジョイニーのキー列をジョイナーに一致させ、それに応じてジョイナーの行をインデックス付け+順序付けする必要があります。</target>
        </trans-unit>
        <trans-unit id="f8dae3d6dd66cb4a6e969f2c3e876e1163d52462" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;?join&lt;/code&gt;: Unlike &lt;code&gt;merge&lt;/code&gt;, [&lt;code&gt;join&lt;/code&gt;] preserves the order of x no matter what join type is used.</source>
          <target state="translated">&lt;code&gt;?join&lt;/code&gt; から： &lt;code&gt;merge&lt;/code&gt; とは異なり、[ &lt;code&gt;join&lt;/code&gt; ]は、使用される結合タイプに関係なくxの順序を保持します。</target>
        </trans-unit>
        <trans-unit id="4e4ea750b40b9f8fb970aa423721dd8f952b8a95" translate="yes" xml:space="preserve">
          <source>Given two data frames:</source>
          <target state="translated">2つのデータフレームが与えられています。</target>
        </trans-unit>
        <trans-unit id="178043d2a18594ddc9371df094f215781386f9a2" translate="yes" xml:space="preserve">
          <source>Hadley mentioning other advantages here</source>
          <target state="translated">ハドレーはここで他の利点について言及しています</target>
        </trans-unit>
        <trans-unit id="3e9d24ecb34b0ebaafaf47408d72663265376976" translate="yes" xml:space="preserve">
          <source>Handling for POSIXct type, timezones, duplicates, different factor levels. Better errors and warnings.</source>
          <target state="translated">POSIXctタイプ、タイムゾーン、重複、異なる因子レベルの処理。エラーと警告が改善されました。</target>
        </trans-unit>
        <trans-unit id="290e06acecaff168c5348f733abafaff96fe9595" translate="yes" xml:space="preserve">
          <source>Here I benchmark on random input data, trying different scales and different patterns of key overlap between the two input tables. This benchmark is still restricted to the case of a single-column integer key. As well, to ensure that the in-place solution would work for both left and right joins of the same tables, all random test data uses &lt;code&gt;0..1:0..1&lt;/code&gt; cardinality. This is implemented by sampling without replacement the key column of the first data.frame when generating the key column of the second data.frame.</source>
          <target state="translated">ここでは、2つの入力テーブル間で異なるスケールと異なるパターンのキーオーバーラップを試して、ランダムな入力データのベンチマークを行います。 このベンチマークは、依然として単一列の整数キーの場合に制限されています。 同様に、インプレースソリューションが同じテーブルの左結合と右結合の両方で機能することを保証するために、すべてのランダムテストデータは &lt;code&gt;0..1:0..1&lt;/code&gt; カーディナリティを使用します。 これは、2番目のdata.frameのキー列を生成するときに、最初のdata.frameのキー列を置き換えずにサンプリングすることで実装されます。</target>
        </trans-unit>
        <trans-unit id="d7d6852d88aa3e327a146c14342fb3fab571a58e" translate="yes" xml:space="preserve">
          <source>Here's a benchmark of the example based on the OP that I demonstrated earlier:</source>
          <target state="translated">先ほどデモしたOPを元にした例のベンチマークです。</target>
        </trans-unit>
        <trans-unit id="e8081890f19c96944894bdd114482dfc9a75ed29" translate="yes" xml:space="preserve">
          <source>Here's a second large-scale benchmark that's more heavy-duty, with respect to the number and types of key columns, as well as cardinality. For this benchmark I use three key columns: one character, one integer, and one logical, with no restrictions on cardinality (that is, &lt;code&gt;0..*:0..*&lt;/code&gt;). (In general it's not advisable to define key columns with double or complex values due to floating-point comparison complications, and basically no one ever uses the raw type, much less for key columns, so I haven't included those types in the key columns. Also, for information's sake, I initially tried to use four key columns by including a POSIXct key column, but the POSIXct type didn't play well with the &lt;code&gt;sqldf.indexed&lt;/code&gt; solution for some reason, possibly due to floating-point comparison anomalies, so I removed it.)</source>
          <target state="translated">次に、キー列の数とタイプ、およびカーディナリティに関して、より強力な2つ目の大規模ベンチマークを示します。 このベンチマークでは、カーディナリティに制限なしで（つまり、 &lt;code&gt;0..*:0..*&lt;/code&gt; ）、1つの文字、1つの整数、1つの論理列の3つのキー列を使用します。 （一般に、浮動小数点比較の複雑さのために、キー列を倍精度または複素数の値で定義することはお勧めできません。基本的に、生の型を使用することはなく、キー列にははるかに少ないため、これらの型をキーに含めていませんまた、情報のために、最初にPOSIXctキー列を含めることで4つのキー列を使用しようとしましたが、おそらく浮動小数点比較の異常が原因で、POSIXctタイプは何らかの理由で &lt;code&gt;sqldf.indexed&lt;/code&gt; ソリューションでうまく機能しませんでした。 、それで削除しました。）</target>
        </trans-unit>
        <trans-unit id="4097e5d8cc2075da7471c980add60bad0cf09eb0" translate="yes" xml:space="preserve">
          <source>Here's an example based on the OP, except I've added an extra row to &lt;code&gt;df2&lt;/code&gt; with an id of 7 to test the case of a non-matching key in the joiner. This is effectively &lt;code&gt;df1&lt;/code&gt; left join &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">OPに基づく例を次に示します。ただし、ジョイナーで一致しないキーのケースをテストするために、IDが7の追加の行を &lt;code&gt;df2&lt;/code&gt; に追加しました。 これは事実上 &lt;code&gt;df1&lt;/code&gt; 左結合 &lt;code&gt;df2&lt;/code&gt; です：</target>
        </trans-unit>
        <trans-unit id="044af99ba79865956da778a1334f4f8240c2bf7f" translate="yes" xml:space="preserve">
          <source>How can I do a SQL style select statement?</source>
          <target state="translated">SQLスタイルのセレクト文はどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="43090d2742d9081d6bd0ff68f38627e9993c5976" translate="yes" xml:space="preserve">
          <source>How can I do database style, i.e., &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;sql style, joins&lt;/a&gt;? That is, how do I get:</source>
          <target state="translated">データベーススタイル、つまり&lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;SQLスタイルの結合&lt;/a&gt;はどのように実行できますか？ つまり、どうすれば取得できますか。</target>
        </trans-unit>
        <trans-unit id="87f0bedc362f9948f7a3bb794a94bec592f2987f" translate="yes" xml:space="preserve">
          <source>How to do a basic left outer join with data.table in R?</source>
          <target state="translated">Rでdata.tableで基本的な左外結合を行うには?</target>
        </trans-unit>
        <trans-unit id="662b552b7e40492af7fd79296b2d468005570929" translate="yes" xml:space="preserve">
          <source>How to do a data.table merge operation</source>
          <target state="translated">data.tableのマージ操作を行う方法</target>
        </trans-unit>
        <trans-unit id="b2997a354edf34b9212b5bede79742efdcd92dac" translate="yes" xml:space="preserve">
          <source>How to join (merge) data frames (inner, outer, left, right)</source>
          <target state="translated">データフレーム(内側、外側、左、右)を結合(マージ)する方法</target>
        </trans-unit>
        <trans-unit id="be4f4251a4aa264ff1a5045246798a437e872a51" translate="yes" xml:space="preserve">
          <source>I decided to do my own benchmarking to see how the in-place assignment approach compares to the other solutions that have been offered in this question.</source>
          <target state="translated">私は、現場での課題アプローチがこの問題で提供されている他のソリューションとどのように比較されるかを確認するために、自分自身のベンチマークを行うことにしました。</target>
        </trans-unit>
        <trans-unit id="1433555c3736ee7dc33f6787f0ee5e502257ce77" translate="yes" xml:space="preserve">
          <source>I find the SQL syntax to be simpler and more natural than its R equivalent (but this may just reflect my RDBMS bias).</source>
          <target state="translated">SQLの構文はRと同等のものよりもシンプルで自然なものだと思います(ただし、これは私のRDBMSへの偏見を反映しているだけかもしれません)。</target>
        </trans-unit>
        <trans-unit id="850ce2fc8639be910cca8a142e25a33d5a5324bd" translate="yes" xml:space="preserve">
          <source>I think this is a particularly appropriate solution if you have several tables that you want to left join against a single large table. Repeatedly rebuilding the entire table for each merge would be unnecessary and inefficient.</source>
          <target state="translated">これは、一つの大きなテーブルに対していくつかのテーブルを残して結合したい場合に特に適した解決策だと思います。マージのたびにテーブル全体の再構築を繰り返すのは不必要で非効率的です。</target>
        </trans-unit>
        <trans-unit id="81dd38b7e015ec1e1a6ff6776efb1705d815b694" translate="yes" xml:space="preserve">
          <source>I used spline interpolation to show a smooth curve for each solution/join type combination, drawn with individual pch symbols. The join type is captured by the pch symbol, using a dot for inner, left and right angle brackets for left and right, and a diamond for full. The solution type is captured by the color as shown in the legend.</source>
          <target state="translated">スプライン補間を使用して、個々のpchシンボルで描かれた各解の結合タイプの組み合わせの滑らかな曲線を表示しました。結合タイプは、内側にはドット、左右には左と右の角括弧、完全にはダイヤモンドを使用して、pchシンボルによって捕捉されます。解のタイプは、凡例に示されているように色で表現されます。</target>
        </trans-unit>
        <trans-unit id="a8ebc4a7bfcf1453154ce5c9cb696149ac776e30" translate="yes" xml:space="preserve">
          <source>I would recommend checking out &lt;a href=&quot;http://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;Gabor Grothendieck's sqldf package&lt;/a&gt;, which allows you to express these operations in SQL.</source>
          <target state="translated">これらの操作をSQLで表現できる&lt;a href=&quot;http://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;Gabor Grothendieckのsqldfパッケージを&lt;/a&gt;チェックアウトすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2337e76070232665935ee45908852019881d7dba" translate="yes" xml:space="preserve">
          <source>I wrote some code to create log-log plots of the above results. I generated a separate plot for each overlap percentage. It's a little bit cluttered, but I like having all the solution types and join types represented in the same plot.</source>
          <target state="translated">上記の結果のlog-logプロットを作成するためにいくつかのコードを書きました。重複率ごとに別々のプロットを作成しました。少しごちゃごちゃしていますが、すべての解の型と結合の型が同じプロットで表現されているのが気に入っています。</target>
        </trans-unit>
        <trans-unit id="710e748e65ff61225c32f7870e72f52de5d5471e" translate="yes" xml:space="preserve">
          <source>If the column names to merge on are not the same, you can specify, e.g., &lt;code&gt;by.x = &quot;CustomerId_in_df1&quot;, by.y = &quot;CustomerId_in_df2&quot;&lt;/code&gt; where &lt;code&gt;CustomerId_in_df1&lt;/code&gt; is the name of the column in the first data frame and &lt;code&gt;CustomerId_in_df2&lt;/code&gt; is the name of the column in the second data frame. (These can also be vectors if you need to merge on multiple columns.)</source>
          <target state="translated">マージする列名が同じでない場合、たとえば、 &lt;code&gt;by.x = &quot;CustomerId_in_df1&quot;, by.y = &quot;CustomerId_in_df2&quot;&lt;/code&gt; 指定できます。ここで、 &lt;code&gt;CustomerId_in_df1&lt;/code&gt; は最初のデータフレームの列の名前で、 &lt;code&gt;CustomerId_in_df2&lt;/code&gt; は2番目のデータフレームの列の名前。 （複数の列でマージする必要がある場合、これらはベクトルにすることもできます。）</target>
        </trans-unit>
        <trans-unit id="f8fa4b6558b0a4f2f657a454fe32716ede7c01cf" translate="yes" xml:space="preserve">
          <source>If the key is a single column, then we can use a single call to &lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; to do the matching. This is the case I'll cover in this answer.</source>
          <target state="translated">キーが単一の列の場合、 &lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt;への単一の呼び出しを使用してマッチングを実行できます。 これは、この回答で取り上げるケースです。</target>
        </trans-unit>
        <trans-unit id="aa34b093d971a035acaf887e23091153f1492e31" translate="yes" xml:space="preserve">
          <source>In joining two data frames with ~1 million rows each, one with 2 columns and the other with ~20, I've surprisingly found &lt;code&gt;merge(..., all.x = TRUE, all.y = TRUE)&lt;/code&gt; to be faster then &lt;code&gt;dplyr::full_join()&lt;/code&gt;. This is with dplyr v0.4</source>
          <target state="translated">それぞれが100万行、1列が2列、2列が〜20の2つのデータフレームを結合すると、 &lt;code&gt;merge(..., all.x = TRUE, all.y = TRUE)&lt;/code&gt; 方が高速であることがわかりました &lt;code&gt;dplyr::full_join()&lt;/code&gt; 。 これはdplyr v0.4で</target>
        </trans-unit>
        <trans-unit id="5a7ff2d9ec551ba208af43332df0b32a7dc8d5b3" translate="yes" xml:space="preserve">
          <source>In the above I hard-coded an assumption that the key column is the first column of both input tables. I would argue that, in general, this is not an unreasonable assumption, since, if you have a data.frame with a key column, it would be strange if it had not been set up as the first column of the data.frame from the outset. And you can always reorder the columns to make it so. An advantageous consequence of this assumption is that the name of the key column does not have to be hard-coded, although I suppose it's just replacing one assumption with another. Concision is another advantage of integer indexing, as well as speed. In the benchmarks below I'll change the implementation to use string name indexing to match the competing implementations.</source>
          <target state="translated">上記では、キーカラムが両方の入力テーブルの最初のカラムであるという前提をハードコーディングしてみました。なぜなら、キーカラムを持つdata.frameがある場合、最初からキーカラムがdata.frameの最初のカラムとして設定されていないとおかしいからです。そして、そのようにするために列を並べ替えることはいつでもできます。この仮定の有利な結果として、キーカラムの名前をハードコーディングする必要がないということがあります。整数インデックス化のもう一つの利点は、速度と同様に精確さです。以下のベンチマークでは、競合する実装に合わせて文字列名インデックスを使用するように実装を変更してみます。</target>
        </trans-unit>
        <trans-unit id="6250605ea19f359b4292e4f82913fe0d8caae6ab" translate="yes" xml:space="preserve">
          <source>It's all &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html&quot;&gt;here&lt;/a&gt; in great detail.</source>
          <target state="translated">詳細は&lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html&quot;&gt;こちら&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b091ee98d4a46bacae49eb5f90e7465fe5df5f71" translate="yes" xml:space="preserve">
          <source>Join-related &lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/news/news.html&quot;&gt;release highlights&lt;/a&gt;:</source>
          <target state="translated">参加関連の&lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/news/news.html&quot;&gt;リリースのハイライト&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="ecc363814d7eeefe97adb1b510ca596b8ac8e949" translate="yes" xml:space="preserve">
          <source>Merge takes ~17 seconds, full_join takes ~65 seconds.</source>
          <target state="translated">Merge は ~17 秒、full_join は ~65 秒かかります。</target>
        </trans-unit>
        <trans-unit id="1d04d0125deda2ba2209b50e785af8edc6c62682" translate="yes" xml:space="preserve">
          <source>Modifying the OP's example tables...</source>
          <target state="translated">OPの例の表の修正...。</target>
        </trans-unit>
        <trans-unit id="cf0e80f7f1862b16f7353cadc5e580929ed727c8" translate="yes" xml:space="preserve">
          <source>Mutating joins, which add new variables to one table from matching rows in another. Filtering joins, which filter observations from one table based on whether or not they match an observation in the other table.</source>
          <target state="translated">Mutating joins:別のテーブルの行にマッチする行から、あるテーブルに新しい変数を追加します。フィルタリング結合は、あるテーブルのオブザベーションが他のテーブルのオブザベーションにマッチするかどうかに基づいて、あるテーブルからのオブザベーションをフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="76494af2798aaf4f5297aa9a9455435c0a1baae3" translate="yes" xml:space="preserve">
          <source>Mutating joins: add columns to df1 using matches in df2</source>
          <target state="translated">結合のミューティング:df2のマッチを使用してdf1に列を追加します。</target>
        </trans-unit>
        <trans-unit id="4f7e10e539fcde0fedb67622c28ce2185dc8d4fe" translate="yes" xml:space="preserve">
          <source>New in 2014:</source>
          <target state="translated">2014年に新登場。</target>
        </trans-unit>
        <trans-unit id="da097f490eba3885863a0e13ce340e42d5855b1e" translate="yes" xml:space="preserve">
          <source>New suffix argument to control what suffix duplicated variable names receive (#1296)</source>
          <target state="translated">重複する変数名が受け取るサフィックスを制御するための新しいサフィックス引数を追加しました (#1296)</target>
        </trans-unit>
        <trans-unit id="b93e636c4795007ba0754843b031729197bf6b22" translate="yes" xml:space="preserve">
          <source>On the other hand, if you need the joinee to remain unaltered through this operation for whatever reason, then this solution cannot be used, since it modifies the joinee directly. Although in that case you could simply make a copy and perform the in-place assignment(s) on the copy.</source>
          <target state="translated">一方で、何らかの理由でこの操作でジョニーを変更しないままにしておきたい場合は、ジョニーを直接変更してしまうため、この解決策は使用できません。その場合、単純にコピーを作成して、そのコピーに対してインプレースの代入を実行することができますが。</target>
        </trans-unit>
        <trans-unit id="275a3e036899aeaeaf21926f7f5568683b2bb806" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;type&lt;/code&gt;: &lt;code&gt;inner&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; オプション： &lt;code&gt;inner&lt;/code&gt; 、 &lt;code&gt;left&lt;/code&gt; 、 &lt;code&gt;right&lt;/code&gt; 、 &lt;code&gt;full&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff2431181fc9fc2e60070beaa227805ee647ef62" translate="yes" xml:space="preserve">
          <source>R :- &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y =
&quot;CustomerId&quot;)[,names(df2)]&lt;/code&gt;</source>
          <target state="translated">R： &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df2)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a90a1fd62b7cfb3514800d395f4aa530d9d32189" translate="yes" xml:space="preserve">
          <source>R :- &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df1)]&lt;/code&gt;</source>
          <target state="translated">R： &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fe4364f88f74f296de93af3b3599121f64037b6" translate="yes" xml:space="preserve">
          <source>Return all rows from the left table, and any rows with matching keys from the right table.</source>
          <target state="translated">左のテーブルからすべての行を返し、右のテーブルからキーが一致する行を返します。</target>
        </trans-unit>
        <trans-unit id="b075052cf9c2a92043b4c19e839781e4f2bb219e" translate="yes" xml:space="preserve">
          <source>Return all rows from the right table, and any rows with matching keys from the left table.</source>
          <target state="translated">右のテーブルからすべての行を返し、左のテーブルからキーが一致する行を返します。</target>
        </trans-unit>
        <trans-unit id="256ebb1bf5d1b1490ada37135eaa9f3ef9b55410" translate="yes" xml:space="preserve">
          <source>Return only the rows in which the left table have matching keys in the right table.</source>
          <target state="translated">左のテーブルが右のテーブルにマッチするキーを持つ行のみを返します。</target>
        </trans-unit>
        <trans-unit id="e571ab9ca057fdce414c471714347a24e546c952" translate="yes" xml:space="preserve">
          <source>Returns all rows from both tables, join records from the left which have matching keys in the right table.</source>
          <target state="translated">両方のテーブルからすべての行を返し、右のテーブルで一致するキーを持つ左のテーブルのレコードを結合します。</target>
        </trans-unit>
        <trans-unit id="9e5d4b98769be55db1d88583ac64d18adb2b96ab" translate="yes" xml:space="preserve">
          <source>SQL :-  &lt;code&gt;select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</source>
          <target state="translated">SQL： &lt;code&gt;select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1040827d8fcc05e6ced9f587ad7e4394f6d46db" translate="yes" xml:space="preserve">
          <source>SQL :- &lt;code&gt;select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</source>
          <target state="translated">SQL： &lt;code&gt;select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="182e27662bc0db38ceece5dd2e17427203440683" translate="yes" xml:space="preserve">
          <source>Same way</source>
          <target state="translated">同じように</target>
        </trans-unit>
        <trans-unit id="36d2d63aaf03c9e36ebc4dc91950d14a746e0b3d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/ggrothendieck/sqldf#example-4-join&quot;&gt;Gabor's sqldf GitHub&lt;/a&gt; for more information on joins.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ggrothendieck/sqldf#example-4-join&quot;&gt;結合の&lt;/a&gt;詳細については、 Gaborのsqldf GitHubを参照してください。</target>
        </trans-unit>
        <trans-unit id="410c9a8726f8cbd1c1e586b81fe174b89fccc09b" translate="yes" xml:space="preserve">
          <source>Selecting columns can be done by &lt;code&gt;select(df,&quot;column&quot;)&lt;/code&gt;. If that's not SQL-ish enough for you, then there's the &lt;code&gt;sql()&lt;/code&gt; function, into which you can enter SQL code as-is, and it will do the operation you specified just like you were writing in R all along (for more information, please refer to the &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html&quot;&gt;dplyr/databases vignette&lt;/a&gt;). For example, if applied correctly, &lt;code&gt;sql(&quot;SELECT * FROM hflights&quot;)&lt;/code&gt; will select all the columns from the &quot;hflights&quot; dplyr table (a &quot;tbl&quot;).</source>
          <target state="translated">列の選択は、 &lt;code&gt;select(df,&quot;column&quot;)&lt;/code&gt; ます。 それがあなたにとって十分にSQLっぽくないなら、SQLコードをそのまま入力できる &lt;code&gt;sql()&lt;/code&gt; 関数があります、そしてそれはあなたがRでずっと書いていたようにあなたが指定した操作をします（詳細については） 、 &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html&quot;&gt;dplyr / databasesビネット&lt;/a&gt;を参照してください）。 たとえば、正しく適用された場合、 &lt;code&gt;sql(&quot;SELECT * FROM hflights&quot;)&lt;/code&gt; は、 &quot;hflights&quot; dplyrテーブル（ &quot;tbl&quot;）からすべての列を選択します。</target>
        </trans-unit>
        <trans-unit id="89f032298f21e2eb6484041690c0b5f31f1c9852" translate="yes" xml:space="preserve">
          <source>Since your keys are named the same the short way to do an inner join is merge():</source>
          <target state="translated">キーの名前が同じなので、内部結合を行う簡単な方法は merge()です。</target>
        </trans-unit>
        <trans-unit id="09f26ff5d7f001a9ebafb1da072687d91833c703" translate="yes" xml:space="preserve">
          <source>Some food for though, since I generally default to dplyr for manipulation tasks.</source>
          <target state="translated">私は一般的に操作タスクには dplyr をデフォルトで使用しているので、いくつかの参考になります。</target>
        </trans-unit>
        <trans-unit id="fed6f49e983aa5bd71ca7e1155b989e6e3375280" translate="yes" xml:space="preserve">
          <source>Suppose we want to add the customer's state from &lt;code&gt;cust&lt;/code&gt; to the purchases table, &lt;code&gt;sales&lt;/code&gt;, ignoring the year column. With base R, we can identify matching rows and then copy values over:</source>
          <target state="translated">年の列を無視して、顧客の状態を顧客から購入表 &lt;code&gt;sales&lt;/code&gt; に追加するとします。 ベースRを使用すると、一致する行を識別し、次に値をコピーできます。</target>
        </trans-unit>
        <trans-unit id="cc0804bbd7e4d942d5dec0c858695fe81456d52e" translate="yes" xml:space="preserve">
          <source>Testing code:</source>
          <target state="translated">コードをテストします。</target>
        </trans-unit>
        <trans-unit id="4d2affb1e17938190686ba88646124834885e979" translate="yes" xml:space="preserve">
          <source>The four joining-related functions in the dplyr package are (to quote):</source>
          <target state="translated">dplyrパッケージに含まれる4つの結合関連関数は、(引用すると)以下の通りです。</target>
        </trans-unit>
        <trans-unit id="975fec70202257751857627844d9ba0efd8ac25c" translate="yes" xml:space="preserve">
          <source>The other combination of outer joins can be created by mungling the left outer join subscript example. (yeah, I know that's the equivalent of saying &quot;I'll leave it as an exercise for the reader...&quot;)</source>
          <target state="translated">他の外結合の組み合わせは、左外結合の添え字の例をつぶやくことで作ることができます。(ええ、これは「読者のための演習として残しておきます...」と言っているに等しいことはわかっています)</target>
        </trans-unit>
        <trans-unit id="cfb49dc74158670dddef83e622172c7c91441e36" translate="yes" xml:space="preserve">
          <source>The resulting plots, using the same plotting code given above:</source>
          <target state="translated">上記と同じプロットコードを使用した結果のプロット。</target>
        </trans-unit>
        <trans-unit id="3fd1810b687b3f6297e5dacac6cd2f293af39cd7" translate="yes" xml:space="preserve">
          <source>The three examples above all focus on creating/adding a new column. See &lt;a href=&quot;https://stackoverflow.com/q/6112260&quot;&gt;the related R FAQ&lt;/a&gt; for an example of updating/modifying an existing column.</source>
          <target state="translated">上記の3つの例はすべて、新しい列の作成/追加に重点を置いています。 既存の列を更新/変更する例について&lt;a href=&quot;https://stackoverflow.com/q/6112260&quot;&gt;は、関連するR FAQ&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="cecd23eb962bc5d6748ad3fb34f5562f803499f5" translate="yes" xml:space="preserve">
          <source>There are some good examples of doing this over at the &lt;a href=&quot;http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge&quot;&gt;R Wiki&lt;/a&gt;. I'll steal a couple here:</source>
          <target state="translated">&lt;a href=&quot;http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge&quot;&gt;R Wikiに&lt;/a&gt;は、これを行う良い例がいくつかあります。 ここでカップルを盗みます：</target>
        </trans-unit>
        <trans-unit id="d8d441f0127df63fc7e588978f519a0a7110a1d7" translate="yes" xml:space="preserve">
          <source>There is the &lt;strong&gt;data.table&lt;/strong&gt; approach for an inner join, which is very time and memory efficient (and necessary for some larger data.frames):</source>
          <target state="translated">内部結合には&lt;strong&gt;data.table&lt;/strong&gt;アプローチがあり、時間とメモリ効率が非常に高くなります（一部の大きなdata.framesには必要です）。</target>
        </trans-unit>
        <trans-unit id="e97719490cc7ca28a945d219ef810933fffa9275" translate="yes" xml:space="preserve">
          <source>Translating SQL joins on foreign keys to R data.table syntax</source>
          <target state="translated">外部キーのSQL結合をRのdata.table構文に変換する</target>
        </trans-unit>
        <trans-unit id="def30251a119892b32dc57973f51d84d2b8a55a3" translate="yes" xml:space="preserve">
          <source>Update on data.table methods for joining datasets. See below examples for each type of join. There are two methods, one from &lt;code&gt;[.data.table&lt;/code&gt; when passing second data.table as the first argument to subset, another way is to use &lt;code&gt;merge&lt;/code&gt; function which dispatches to fast data.table method.</source>
          <target state="translated">データセットを結合するためのdata.tableメソッドの更新。 結合のタイプごとの例を以下に示します。 2つのメソッドがあります。1つは &lt;code&gt;[.data.table&lt;/code&gt; から、2つ目のdata.tableを最初の引数としてサブセットに渡すときです。もう1つの方法は、高速のdata.tableメソッドにディスパッチする &lt;code&gt;merge&lt;/code&gt; 関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="5b7fa59fc1d348ab50e552c606a943a4fb3428d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;merge&lt;/code&gt; function we can select the variable of left table or right table, same way like we all familiar with select statement in SQL (EX : Select a.* ...or Select b.* from .....)</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 関数を使用して 、SQLのselectステートメントに慣れているように、左テーブルまたは右テーブルの変数を選択できます（EX：Select a。* ...またはSelect b。* from .....）</target>
        </trans-unit>
        <trans-unit id="777e443e9e2269e9c7657e5c1bb5b4ef07dd5d99" translate="yes" xml:space="preserve">
          <source>We have to add extra code which will subset from the newly joined table .</source>
          <target state="translated">我々は、新たに結合されたテーブルからサブセットされる余分なコードを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="35f9f5a0a66021813e967af96baa693e8e91102d" translate="yes" xml:space="preserve">
          <source>Workarounds per hadley's comments in that issue:</source>
          <target state="translated">その問題のハドリーのコメントにある回避策。</target>
        </trans-unit>
        <trans-unit id="20e71a92fd73f1ea6448c8ce19a1b28c6fd612ab" translate="yes" xml:space="preserve">
          <source>Yet another option is the &lt;code&gt;join&lt;/code&gt; function found in the &lt;a href=&quot;http://cran.r-project.org/web/packages/plyr/index.html&quot;&gt;&lt;strong&gt;plyr&lt;/strong&gt;&lt;/a&gt; package</source>
          <target state="translated">さらに別のオプションは、 &lt;a href=&quot;http://cran.r-project.org/web/packages/plyr/index.html&quot;&gt;&lt;strong&gt;plyr&lt;/strong&gt;&lt;/a&gt;パッケージにある &lt;code&gt;join&lt;/code&gt; 関数です</target>
        </trans-unit>
        <trans-unit id="a4ca82ec6e06c0c6954a4927a77918e335215d61" translate="yes" xml:space="preserve">
          <source>You can do joins as well using Hadley Wickham's awesome &lt;a href=&quot;http://blog.rstudio.org/2014/01/17/introducing-dplyr/&quot;&gt;dplyr&lt;/a&gt; package.</source>
          <target state="translated">Hadley Wickhamの素晴らしい&lt;a href=&quot;http://blog.rstudio.org/2014/01/17/introducing-dplyr/&quot;&gt;dplyr&lt;/a&gt;パッケージを使用して結合を行うこともできます。</target>
        </trans-unit>
        <trans-unit id="5724e67f3f18acb7528650cc64cff7877156db95" translate="yes" xml:space="preserve">
          <source>You can merge on multiple columns by giving &lt;code&gt;by&lt;/code&gt; a vector, e.g., &lt;code&gt;by = c(&quot;CustomerId&quot;, &quot;OrderId&quot;)&lt;/code&gt;.</source>
          <target state="translated">ベクトルで指定すること &lt;code&gt;by&lt;/code&gt; 、複数の列をマージできます。たとえば、 &lt;code&gt;by = c(&quot;CustomerId&quot;, &quot;OrderId&quot;)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="cf2d2dee20b0fe4b4b6a2f7726c0245d830c0168" translate="yes" xml:space="preserve">
          <source>a full inner join (all records from both tables) can be created with the &quot;all&quot; keyword:</source>
          <target state="translated">完全な内部結合(両方のテーブルのすべてのレコード)を &quot;all &quot;キーワードで作成することができます。</target>
        </trans-unit>
        <trans-unit id="45b24f5fc4c5960be3b959ba6f2bc3227a86250d" translate="yes" xml:space="preserve">
          <source>a left outer join of df1 and df2:</source>
          <target state="translated">df1 と df2 の左外側の結合。</target>
        </trans-unit>
        <trans-unit id="6d47d87da3f640b3f3ac9043cf30483af1712d57" translate="yes" xml:space="preserve">
          <source>a right outer join of df1 and df2:</source>
          <target state="translated">df1 と df2 の右外側の結合。</target>
        </trans-unit>
        <trans-unit id="f00d083db7a975f33fd38e2809f8dd64537504aa" translate="yes" xml:space="preserve">
          <source>base R &lt;code&gt;merge()&lt;/code&gt; and equivalent package-based merge functions, which always allocate a new table to return the merged result, and thus are not suitable for an in-place assignment-based solution.</source>
          <target state="translated">ベースRの &lt;code&gt;merge()&lt;/code&gt; および同等のパッケージベースのマージ関数。常に新しいテーブルを割り当ててマージされた結果を返すため、インプレースの割り当てベースのソリューションには適していません。</target>
        </trans-unit>
        <trans-unit id="abfb07f46a8b85131c33b5c00be46ae3ec4d825a" translate="yes" xml:space="preserve">
          <source>data.table documented on stackoverflow:</source>
          <target state="translated">data.table は stackoverflow でドキュメント化されています。</target>
        </trans-unit>
        <trans-unit id="739d53834e2598c061e546b33d4c497722f8aa6e" translate="yes" xml:space="preserve">
          <source>didn't yet &lt;a href=&quot;https://github.com/hadley/dplyr/issues/96&quot;&gt;implement right_join and &lt;strong&gt;outer_join&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">まだ&lt;a href=&quot;https://github.com/hadley/dplyr/issues/96&quot;&gt;right_joinと&lt;strong&gt;outer_joinを&lt;/strong&gt;実装&lt;/a&gt;していません</target>
        </trans-unit>
        <trans-unit id="3dc4f0b439d260cec5f45060722ff170e14ccd80" translate="yes" xml:space="preserve">
          <source>dplyr since 0.4 implemented all those joins including &lt;code&gt;outer_join&lt;/code&gt;, but it was worth noting that &lt;strong&gt;for the first few releases prior to 0.4 it used not to offer &lt;code&gt;outer_join&lt;/code&gt;, and as a result there was a lot of really bad hacky workaround user code floating around for quite a while afterwards (you can still find such code in SO, Kaggle answers, github from that period. Hence this answer still serves a useful purpose.)&lt;/strong&gt;</source>
          <target state="translated">0.4以降のdplyrはouter_joinを含むこれらのすべての結合を実装しましたが、0.4 &lt;strong&gt;より前の最初のいくつかのリリースでは &lt;code&gt;outer_join&lt;/code&gt; を提供していなかっ&lt;/strong&gt;たことに注意する価値&lt;strong&gt;があり、その結果、非常に悪いハッキーな回避策のユーザーコードがかなり浮かびましたしばらくしてから（SOでもそのようなコードを見つけることができます。Kaggleはその期間のgithubで答えます。したがって、この答えは依然として有用な目的に役立ちます。）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61e2da8dd77d5e292248c9fb83d7a134ac198b3a" translate="yes" xml:space="preserve">
          <source>has &lt;strong&gt;inner_join, left_join, semi_join, anti_join&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;inner_join、left_join、semi_join、anti_join&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091a85912279e018e930a477c24b367571489c0f" translate="yes" xml:space="preserve">
          <source>inefficient cartesian conjunctions, e.g. &lt;code&gt;outer(df1$a,df2$a,`==`) &amp;amp; outer(df1$b,df2$b,`==`)&lt;/code&gt;.</source>
          <target state="translated">非効率的なデカルト結合、たとえば &lt;code&gt;outer(df1$a,df2$a,`==`) &amp;amp; outer(df1$b,df2$b,`==`)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a34ccb1aad2f513af7c11ec01144f6ab37837eaf" translate="yes" xml:space="preserve">
          <source>inefficient concatenations. e.g. &lt;code&gt;match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))&lt;/code&gt;, or the same idea with &lt;code&gt;paste()&lt;/code&gt;.</source>
          <target state="translated">非効率的な連結。 例： &lt;code&gt;match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))&lt;/code&gt; 、または &lt;code&gt;paste()&lt;/code&gt; と同じアイデア</target>
        </trans-unit>
        <trans-unit id="feb96c8e7073f7b49193f9c3ac2e9abbef5ee89f" translate="yes" xml:space="preserve">
          <source>one minor feature merge currently has that dplyr doesn't is &lt;a href=&quot;https://github.com/hadley/dplyr/issues/177&quot;&gt;the ability to have separate by.x,by.y columns&lt;/a&gt; as e.g. Python pandas does.</source>
          <target state="translated">現在、マイナーな機能マージの1つに、dplyrにはない、たとえばPython &lt;a href=&quot;https://github.com/hadley/dplyr/issues/177&quot;&gt;pandasのように、by.x、by.yの列&lt;/a&gt;を個別に持つ機能はありません。</target>
        </trans-unit>
        <trans-unit id="b89a4220d42db1407a2fa042c855a3d4652ddd00" translate="yes" xml:space="preserve">
          <source>you can flip 'em, slap 'em and rub 'em down to get the other two outer joins you asked about :)</source>
          <target state="translated">跳ねたり、叩いたり、こすったりして、他の2つの外側の接合部を手に入れることができます。)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
