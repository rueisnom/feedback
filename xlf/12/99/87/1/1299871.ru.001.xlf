<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1299871">
    <body>
      <group id="1299871">
        <trans-unit id="d47d7caf030340f041a78d2ceb0b7965bda3093d" translate="yes" xml:space="preserve">
          <source>*_join() no longer reorders column names (#324)</source>
          <target state="translated">*_join()больше не переупорядочивает имена столбцов (#324)</target>
        </trans-unit>
        <trans-unit id="487b6c91b5261dd50389ad61b918fe7838afe87f" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/12030932/2490497&quot;&gt;rolling join&lt;/a&gt; - if you want merge to be able to match to values from preceeding/following rows by rolling them forward or backward</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/12030932/2490497&quot;&gt;Скользящее соединение&lt;/a&gt; - если вы хотите, чтобы объединение могло соответствовать значениям из предыдущих / следующих строк, прокручивая их вперед или назад</target>
        </trans-unit>
        <trans-unit id="84c6f6a09e15ca4a5e7777731b7f61a686126d78" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/25815032/2490497&quot;&gt;overlapping join&lt;/a&gt; - if you want to merge by ranges</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/25815032/2490497&quot;&gt;перекрывающееся соединение&lt;/a&gt; - если вы хотите объединить по диапазонам</target>
        </trans-unit>
        <trans-unit id="afc219bc005a7c35074b4b7bdeb7c70495859d1b" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/3190118/2490497&quot;&gt;update on join&lt;/a&gt; - if you want to lookup values from another table to your main table</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/3190118/2490497&quot;&gt;обновить при объединении&lt;/a&gt; - если вы хотите искать значения из другой таблицы в вашей основной таблице</target>
        </trans-unit>
        <trans-unit id="890d6745a9399241952baa05d0099615ae7dc270" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/41043047/2490497&quot;&gt;non-equi join&lt;/a&gt; - if your join condition is non-equal</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/41043047/2490497&quot;&gt;неравное соединение&lt;/a&gt; - если ваше условие соединения не равно</target>
        </trans-unit>
        <trans-unit id="92ed8f843671545e7e2acc8d069fdcc2446feaeb" translate="yes" xml:space="preserve">
          <source>- &lt;a href=&quot;https://stackoverflow.com/q/41684012/2490497&quot;&gt;aggregate on join&lt;/a&gt; - if you want to aggregate on key you are joining you do not have to materialize all join results</source>
          <target state="translated">- &lt;a href=&quot;https://stackoverflow.com/q/41684012/2490497&quot;&gt;агрегировать при объединении&lt;/a&gt; - если вы хотите агрегировать по ключу, к которому присоединяетесь, вам не нужно материализовать все результаты объединения</target>
        </trans-unit>
        <trans-unit id="07ce8fe7aebda33b8d668e59d9c852c30c95ed33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anti_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x
where there are not matching values in y, keeping just columns from x</source>
          <target state="translated">&lt;code&gt;anti_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : возвращает все строки из x, где в y нет совпадающих значений, сохраняя только столбцы из x</target>
        </trans-unit>
        <trans-unit id="846866e1d2e49dece784b5f56afce637ce3acb5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inner_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from
x where there are matching values in y, and all columns from x and y</source>
          <target state="translated">&lt;code&gt;inner_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : возвращает все строки из x, где есть совпадающие значения в y, и все столбцы из x и y</target>
        </trans-unit>
        <trans-unit id="4756dd78d19e6570c93a82eb2702ffcd868aa1a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x, and all columns from x and y</source>
          <target state="translated">&lt;code&gt;left_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : возвращает все строки из x и все столбцы из x и y</target>
        </trans-unit>
        <trans-unit id="b1ac4ba54b36075fe4e311146847172ffda51a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; also works on data.tables (as it is generic and calls &lt;code&gt;merge.data.table&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; также работает с data.tables (так как оно является общим и вызывает &lt;code&gt;merge.data.table&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8c0dab1fb7e149efd4ef02ea7323dd1028acf2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;semi_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt;: return all rows from x where there are matching values in
y, keeping just columns from x.</source>
          <target state="translated">&lt;code&gt;semi_join(x, y, by = NULL, copy = FALSE, ...)&lt;/code&gt; : возвращает все строки из x, где есть совпадающие значения в y, сохраняя только столбцы из x.</target>
        </trans-unit>
        <trans-unit id="64447dc8e6edd1cc9f32821eb103cfca1f89e9cb" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;Just as with the inner join, you would probably want to explicitly pass &quot;CustomerId&quot; to R as the matching variable.&lt;/strike&gt;  I think it's almost always best to explicitly state the identifiers on which you want to merge; it's safer if the input data.frames change unexpectedly and easier to read later on.</source>
          <target state="translated">&lt;strike&gt;Как и в случае внутреннего соединения, вы, вероятно, захотите явно передать &amp;laquo;CustomerId&amp;raquo; в R в качестве соответствующей переменной.&lt;/strike&gt; Я думаю, что почти всегда лучше явно указывать идентификаторы, по которым вы хотите объединить; безопаснее, если входные данные изменяются неожиданно и их легче читать позже.</target>
        </trans-unit>
        <trans-unit id="8f2b37c4fd55625fd3e73914491c5bd0dc311ccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Cross join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = NULL)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Перекрестное соединение:&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = NULL)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8a7da9103d4d41873615a068f57166a2b7778c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Inner join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(df1, df2)&lt;/code&gt; will work for these examples because R automatically joins the frames by common variable names, but you would most likely want to specify &lt;code&gt;merge(df1, df2, by = &quot;CustomerId&quot;)&lt;/code&gt; to make sure that you were matching on only the fields you desired.  You can also use the &lt;code&gt;by.x&lt;/code&gt; and &lt;code&gt;by.y&lt;/code&gt; parameters if the matching variables have different names in the different data frames.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Внутреннее соединение:&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(df1, df2)&lt;/code&gt; будет работать для этих примеров, потому что R автоматически объединяет кадры по общим именам переменных, но вы, скорее всего, захотите указать &lt;code&gt;merge(df1, df2, by = &quot;CustomerId&quot;)&lt;/code&gt; чтобы убедиться, что вы были сопоставлены только те поля, которые вы хотели. Вы также можете использовать параметры &lt;code&gt;by.x&lt;/code&gt; и &lt;code&gt;by.y&lt;/code&gt; , если совпадающие переменные имеют разные имена в разных фреймах данных.</target>
        </trans-unit>
        <trans-unit id="038870ab05a425a137f8fbbc279dda97c77d683f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Left outer:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Слева:&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.x = TRUE)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72ebaef810f98fc55883bca7f5dfd5acba8a9cae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Outer join:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Внешнее соединение:&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all = TRUE)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dab4ebd7ed185ebd97efccd2c02d50ba28589364" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Right outer:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Справа:&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;merge(x = df1, y = df2, by = &quot;CustomerId&quot;, all.y = TRUE)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="feb6dda0b81cd0e64ea3c74f9c8b636b97c7342f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.1.3&lt;/em&gt;&lt;/strong&gt; (4/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.1.3&lt;/em&gt;&lt;/strong&gt; (4/2014)</target>
        </trans-unit>
        <trans-unit id="977c100088eecd2687b330acb3b61630e1c463ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.2&lt;/em&gt;&lt;/strong&gt; (5/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;версия 0.2&lt;/em&gt;&lt;/strong&gt; ( &lt;strong&gt;&lt;em&gt;5/2014&lt;/em&gt;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="9d1100b98263dbf4dd0f99865af468f7b55e605f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.3&lt;/em&gt;&lt;/strong&gt; (10/2014)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.3&lt;/em&gt;&lt;/strong&gt; ( &lt;strong&gt;&lt;em&gt;10/2014&lt;/em&gt;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="bd8720e189cc792821196cc8bacaf98d3035fecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.4.0&lt;/em&gt;&lt;/strong&gt; (1/2015)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;v0.4.0&lt;/em&gt;&lt;/strong&gt; (1/2015)</target>
        </trans-unit>
        <trans-unit id="66e75518de390f9fe0e9e80b4cbab16a3bcb592b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;v0.5&lt;/em&gt;&lt;/strong&gt; (6/2016)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;версия 0.5&lt;/em&gt;&lt;/strong&gt; (6/2016)</target>
        </trans-unit>
        <trans-unit id="7d481f74b71e19ee13eac5a4c57e4f92286ac1b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Implement right join and outer join&lt;/strong&gt; (#96)</source>
          <target state="translated">&lt;strong&gt;Реализация правого соединения и внешнего соединения&lt;/strong&gt; (# 96)</target>
        </trans-unit>
        <trans-unit id="7d863a7bd89469b75eeee503d3a69a99724f4c9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Merge Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Метод слияния&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="631fffa31418327ad1ceee06912e77e433c2a830" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rolling update join.&lt;/strong&gt; Alternately, we may want to take the last state the customer was found in:</source>
          <target state="translated">&lt;strong&gt;Скользящее обновление присоединяется.&lt;/strong&gt; Кроме того, мы можем выбрать последнее состояние, в котором был найден клиент:</target>
        </trans-unit>
        <trans-unit id="16a449699f13e0f7577783adc61a84fa6b01f031" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscript Method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Подстрочный метод&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b809d4e294824a9bd8793db2c442bcc11490e805" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update join with multiple columns.&lt;/strong&gt; The approach above works well when we are joining on only a single column and are satisfied with the first match. Suppose we want the year of measurement in the customer table to match the year of sale.</source>
          <target state="translated">&lt;strong&gt;Обновите объединение с несколькими столбцами.&lt;/strong&gt; Приведенный выше подход хорошо работает, когда мы объединяем только один столбец и удовлетворены первым соответствием. Предположим, мы хотим, чтобы год измерения в таблице клиентов соответствовал году продажи.</target>
        </trans-unit>
        <trans-unit id="60c8303c5c795a80894a040e6ad09b86a234618e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update join.&lt;/strong&gt; One other important SQL-style join is an &quot;&lt;a href=&quot;https://stackoverflow.com/q/7869592/&quot;&gt;update join&lt;/a&gt;&quot; where columns in one table are updated (or created) using another table.</source>
          <target state="translated">&lt;strong&gt;Обновление присоединиться.&lt;/strong&gt; Еще одно важное соединение в стиле SQL - это &amp;laquo; &lt;a href=&quot;https://stackoverflow.com/q/7869592/&quot;&gt;соединение обновления&lt;/a&gt; &amp;raquo;, при котором столбцы в одной таблице обновляются (или создаются) с использованием другой таблицы.</target>
        </trans-unit>
        <trans-unit id="d36e434acda5756c7bc2a0734856c0841c167a0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;outer_join&lt;/strong&gt; is basically union(left_join(x, y), right_join(x, y)) - i.e. preserve all rows in both data frames.</source>
          <target state="translated">&lt;strong&gt;external_join&lt;/strong&gt; в основном представляет собой union (left_join (x, y), right_join (x, y)) - т.е. сохраняет все строки в обоих фреймах данных.</target>
        </trans-unit>
        <trans-unit id="e65d821137f54f3e9e9fa6bf3d532f2edb926dc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;outer_join&lt;/strong&gt; not implemented yet, fallback is use base::merge() (or plyr::join())</source>
          <target state="translated">&lt;strong&gt;external_join еще&lt;/strong&gt; не реализован, отступление - использование base :: merge () (или plyr :: join ())</target>
        </trans-unit>
        <trans-unit id="7af98f3c825f135edda87f9c794dac0060279aa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;right_join&lt;/strong&gt;(x,y) is the same as left_join(y,x) in terms of the rows, just the columns will be different orders. Easily worked around with select(new_column_order)</source>
          <target state="translated">&lt;strong&gt;right_join&lt;/strong&gt; (x, y) - это то же самое, что left_join (y, x) в терминах строк, только столбцы будут разных порядков. Легко обходится с помощью select (new_column_order)</target>
        </trans-unit>
        <trans-unit id="0c8b0aa635a2a6ad43b6f15dacdced43bcb2ee8b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join&quot;&gt;left outer join (or simply left join)&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Left_outer_join&quot;&gt;Левое внешнее соединение (или просто левое соединение)&lt;/a&gt; &lt;code&gt;df1&lt;/code&gt; и &lt;code&gt;df2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65bd236cef1312710765c40a2d7ed2b9ae5d1de6" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Right_outer_join&quot;&gt;right outer join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Right_outer_join&quot;&gt;Правое внешнее соединение&lt;/a&gt; &lt;code&gt;df1&lt;/code&gt; и &lt;code&gt;df2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a995d5ebe59aa37a58c647f553d519dece05faba" translate="yes" xml:space="preserve">
          <source>A left outer join with df1 on the left using a subscript method would be:</source>
          <target state="translated">Левое внешнее соединение с df1 слева с помощью метода подписки будет:</target>
        </trans-unit>
        <trans-unit id="0085fab60d07cb78647869bd8cefbf2ec4234148" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join&quot;&gt;inner join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Inner_join&quot;&gt;Внутреннее соединение&lt;/a&gt; &lt;code&gt;df1&lt;/code&gt; и &lt;code&gt;df2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf81a3ad99c579907678ed7b25d860ad1049d3a1" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Outer_join&quot;&gt;outer join&lt;/a&gt; of &lt;code&gt;df1&lt;/code&gt; and &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29#Outer_join&quot;&gt;Внешнее соединение&lt;/a&gt; &lt;code&gt;df1&lt;/code&gt; и &lt;code&gt;df2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99e1e176cca1b8231019f4dab468ecffc875a219" translate="yes" xml:space="preserve">
          <source>As @bgoldst's answer mentions, &lt;code&gt;match&lt;/code&gt; with &lt;code&gt;interaction&lt;/code&gt; might be an option for this case. More straightforwardly, one could use data.table:</source>
          <target state="translated">Как упоминается в ответе @ bgoldst, для этого случая может подойти &lt;code&gt;match&lt;/code&gt; с &lt;code&gt;interaction&lt;/code&gt; . Проще говоря, можно использовать data.table:</target>
        </trans-unit>
        <trans-unit id="abf28bebf45530a8950f4d9293a4c78cef6b6b00" translate="yes" xml:space="preserve">
          <source>As a side note, I briefly looked into possible matching solutions for multicolumn keys. Unfortunately, the only matching solutions I found were:</source>
          <target state="translated">В качестве примечания,я вкратце рассмотрел возможные решения для многоколоночных клавиш.К сожалению,единственными подходящими решениями,которые я нашел,были:</target>
        </trans-unit>
        <trans-unit id="4f166ad2d60f8daeca4449327bda4a7811ee2769" translate="yes" xml:space="preserve">
          <source>As can be seen here, &lt;code&gt;match&lt;/code&gt; selects the first matching row from the customer table.</source>
          <target state="translated">Как можно увидеть здесь, &lt;code&gt;match&lt;/code&gt; выбирает первую подходящую строку из таблицы клиентов.</target>
        </trans-unit>
        <trans-unit id="b660aa6af5b76fcb666125e5ca3d5a374b6eebf4" translate="yes" xml:space="preserve">
          <source>Be aware there are other types of joins you can perform using &lt;code&gt;data.table&lt;/code&gt;:</source>
          <target state="translated">Имейте в &lt;code&gt;data.table&lt;/code&gt; что есть другие типы объединений, которые вы можете выполнить с помощью data.table :</target>
        </trans-unit>
        <trans-unit id="58719bd04f95ef9656fef30a4d66177a963af55f" translate="yes" xml:space="preserve">
          <source>Below benchmark tests base R, sqldf, dplyr and data.table.</source>
          <target state="translated">Ниже приведены эталонные тесты базы R,sqldf,dplyr и data.table.</target>
        </trans-unit>
        <trans-unit id="9afae0499a8b49e7f0ef74e289efbf6ff5cc05de" translate="yes" xml:space="preserve">
          <source>Benchmark tests unkeyed/unindexed datasets.
Benchmark is performed on 50M-1 rows datasets, there are 50M-2 common values on join column so each scenario (inner, left, right, full) can be tested and join is still not trivial to perform. It is type of join which well stress join algorithms. Timings are as of &lt;code&gt;sqldf:0.4.11&lt;/code&gt;, &lt;code&gt;dplyr:0.7.8&lt;/code&gt;, &lt;code&gt;data.table:1.12.0&lt;/code&gt;.</source>
          <target state="translated">Бенчмарк тестирует наборы данных без ключей / без индекса. Тестирование выполняется для наборов данных 50M-1, в столбце объединения есть общие значения 50M-2, поэтому каждый сценарий (внутренний, левый, правый, полный) можно протестировать, и объединение все еще не является тривиальным. Это тип объединения, который хорошо подчеркивает алгоритмы объединения. По состоянию на &lt;code&gt;sqldf:0.4.11&lt;/code&gt; , &lt;code&gt;dplyr:0.7.8&lt;/code&gt; , &lt;code&gt;data.table:1.12.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="031a1bb7db92ad832e32717777d34cb324b9c6c7" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;merge&lt;/code&gt; function and its optional parameters:</source>
          <target state="translated">Используя функцию &lt;code&gt;merge&lt;/code&gt; и ее необязательные параметры:</target>
        </trans-unit>
        <trans-unit id="0850f670fdb08a62b7a39a07049252d4595216df" translate="yes" xml:space="preserve">
          <source>Can now left_join by different variables in each table: df1 %&amp;gt;% left_join(df2, c(&quot;var1&quot; = &quot;var2&quot;))</source>
          <target state="translated">Теперь можно left_join по различным переменным в каждой таблице: df1%&amp;gt;% left_join (df2, c (&quot;var1&quot; = &quot;var2&quot;))</target>
        </trans-unit>
        <trans-unit id="c6e5a298734559d60b7bb8a74b34d9ba6755ed0d" translate="yes" xml:space="preserve">
          <source>Code to reproduce:</source>
          <target state="translated">Код для размножения:</target>
        </trans-unit>
        <trans-unit id="c85693681142b2f48692df23c7bd83524829e4cc" translate="yes" xml:space="preserve">
          <source>Efficient alternatives to merge for larger data.frames R</source>
          <target state="translated">Эффективные альтернативы слиянию для больших объемов данных.кадров R</target>
        </trans-unit>
        <trans-unit id="a0fb268d8865888849541e2461b53e088d173672" translate="yes" xml:space="preserve">
          <source>Especially if you're also interested in data manipulation in general (including sorting, filtering, subsetting, summarizing etc.), you should definitely take a look at &lt;code&gt;dplyr&lt;/code&gt;, which comes with a variety of functions all designed to facilitate your work specifically with data frames and certain other database types. It even offers quite an elaborate SQL interface, and even a function to convert (most) SQL code directly into R.</source>
          <target state="translated">Особенно, если вы также заинтересованы в манипулировании данными в целом (включая сортировку, фильтрацию, поднаборы, суммирование и т. Д.), Вам определенно следует взглянуть на &lt;code&gt;dplyr&lt;/code&gt; , который поставляется с множеством функций, предназначенных для облегчения вашей работы именно с данными. кадры и некоторые другие типы баз данных. Он даже предлагает довольно сложный интерфейс SQL и даже функцию для преобразования (большей части) кода SQL непосредственно в R.</target>
        </trans-unit>
        <trans-unit id="1cb91a4d85314d943d7ed8d0eb363de15a4cfd5d" translate="yes" xml:space="preserve">
          <source>Example data:</source>
          <target state="translated">Примеры данных:</target>
        </trans-unit>
        <trans-unit id="6d830da55607c318b0229bbe871dede8489bbbcd" translate="yes" xml:space="preserve">
          <source>Extra credit:</source>
          <target state="translated">Дополнительный кредит:</target>
        </trans-unit>
        <trans-unit id="cb15184868a7170582b96630a6ea5bb279f5d610" translate="yes" xml:space="preserve">
          <source>Filtering joins: filter out rows in df1, don't modify columns</source>
          <target state="translated">Фильтрующие соединения:отфильтровать строки в df1,не изменять колонки</target>
        </trans-unit>
        <trans-unit id="d9513dbbe672535839baa4a6cc570a53345b40d1" translate="yes" xml:space="preserve">
          <source>For an inner join on all columns, you could also use &lt;code&gt;fintersect&lt;/code&gt; from the &lt;em&gt;data.table&lt;/em&gt;-package or &lt;code&gt;intersect&lt;/code&gt; from the &lt;em&gt;dplyr&lt;/em&gt;-package as an alternative to &lt;code&gt;merge&lt;/code&gt; without specifying the &lt;code&gt;by&lt;/code&gt;-columns. this will give the rows that are equal between two dataframes:</source>
          <target state="translated">Для внутреннего объединения всех столбцов вы также можете использовать &lt;code&gt;fintersect&lt;/code&gt; из &lt;em&gt;data.table -package&lt;/em&gt; или &lt;code&gt;intersect&lt;/code&gt; из &lt;em&gt;dplyr -package&lt;/em&gt; в качестве альтернативы &lt;code&gt;merge&lt;/code&gt; без указания &lt;code&gt;by&lt;/code&gt; -columns. это даст строки, которые равны между двумя кадрами данных:</target>
        </trans-unit>
        <trans-unit id="3ecb0b93f83cfe035b561507dbb9ead3739e0215" translate="yes" xml:space="preserve">
          <source>For example, see &lt;a href=&quot;https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r&quot;&gt;Matching multiple columns on different data frames and getting other column as result&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns&quot;&gt;match two columns with two other columns&lt;/a&gt;, &lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html&quot;&gt;Matching on multiple columns&lt;/a&gt;, and the dupe of this question where I originally came up with the in-place solution, &lt;a href=&quot;https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281&quot;&gt;Combine two data frames with different number of rows in R&lt;/a&gt;.</source>
          <target state="translated">Например, см. &amp;laquo; &lt;a href=&quot;https://stackoverflow.com/questions/13286881/matching-multiple-columns-on-different-data-frames-and-getting-other-column-as-r&quot;&gt;Сопоставление нескольких столбцов в разных фреймах данных и получение другого столбца в качестве результата&amp;raquo;&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/questions/6880450/match-two-columns-with-two-other-columns&quot;&gt;сопоставление двух столбцов с двумя другими столбцами&lt;/a&gt; , &amp;laquo; &lt;a href=&quot;https://stat.ethz.ch/pipermail/r-help/2007-January/123488.html&quot;&gt;Совпадение в нескольких столбцах&amp;raquo;&lt;/a&gt; и ответ на этот вопрос, в котором я изначально придумал решение на месте, &amp;laquo; &lt;a href=&quot;https://stackoverflow.com/questions/38066077/combine-two-data-frames-with-different-number-of-rows-in-r/38066281#38066281&quot;&gt;Объединить&amp;raquo;. два фрейма данных с разным количеством строк в R.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6bc9cab91de980063bff0c869e8cd295f71aeae3" translate="yes" xml:space="preserve">
          <source>For the case of a left join with a &lt;code&gt;0..*:0..1&lt;/code&gt; cardinality or a right join with a &lt;code&gt;0..1:0..*&lt;/code&gt; cardinality it is possible to assign in-place the unilateral columns from the joiner (the &lt;code&gt;0..1&lt;/code&gt; table) directly onto the joinee (the &lt;code&gt;0..*&lt;/code&gt; table), and thereby avoid the creation of an entirely new table of data. This requires matching the key columns from the joinee into the joiner and indexing+ordering the joiner's rows accordingly for the assignment.</source>
          <target state="translated">В случае левого соединения с кардинальностью &lt;code&gt;0..*:0..1&lt;/code&gt; или правого соединения с кардинальностью &lt;code&gt;0..1:0..*&lt;/code&gt; можно назначить на месте односторонние столбцы от столяра ( таблицу &lt;code&gt;0..1&lt;/code&gt; ) непосредственно на пользователя (таблица &lt;code&gt;0..*&lt;/code&gt; ), что позволяет избежать создания совершенно новой таблицы данных. Для этого необходимо сопоставить ключевые столбцы от joinee в joiner и проиндексировать + упорядочить строки joiner соответственно для назначения.</target>
        </trans-unit>
        <trans-unit id="f8dae3d6dd66cb4a6e969f2c3e876e1163d52462" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;?join&lt;/code&gt;: Unlike &lt;code&gt;merge&lt;/code&gt;, [&lt;code&gt;join&lt;/code&gt;] preserves the order of x no matter what join type is used.</source>
          <target state="translated">From &lt;code&gt;?join&lt;/code&gt; : В отличие от &lt;code&gt;merge&lt;/code&gt; [ &lt;code&gt;join&lt;/code&gt; ] сохраняет порядок x независимо от того, какой тип соединения используется.</target>
        </trans-unit>
        <trans-unit id="4e4ea750b40b9f8fb970aa423721dd8f952b8a95" translate="yes" xml:space="preserve">
          <source>Given two data frames:</source>
          <target state="translated">Учитывая два фрейма данных:</target>
        </trans-unit>
        <trans-unit id="178043d2a18594ddc9371df094f215781386f9a2" translate="yes" xml:space="preserve">
          <source>Hadley mentioning other advantages here</source>
          <target state="translated">Хэдли упомянул здесь другие преимущества</target>
        </trans-unit>
        <trans-unit id="3e9d24ecb34b0ebaafaf47408d72663265376976" translate="yes" xml:space="preserve">
          <source>Handling for POSIXct type, timezones, duplicates, different factor levels. Better errors and warnings.</source>
          <target state="translated">Обработка для типа POSIXct,часовых поясов,дубликатов,различных уровней коэффициентов.Лучшие ошибки и предупреждения.</target>
        </trans-unit>
        <trans-unit id="290e06acecaff168c5348f733abafaff96fe9595" translate="yes" xml:space="preserve">
          <source>Here I benchmark on random input data, trying different scales and different patterns of key overlap between the two input tables. This benchmark is still restricted to the case of a single-column integer key. As well, to ensure that the in-place solution would work for both left and right joins of the same tables, all random test data uses &lt;code&gt;0..1:0..1&lt;/code&gt; cardinality. This is implemented by sampling without replacement the key column of the first data.frame when generating the key column of the second data.frame.</source>
          <target state="translated">Здесь я сравниваю случайные входные данные, пробуя разные шкалы и разные комбинации клавиш для двух таблиц ввода. Этот тест по-прежнему ограничен случаем целочисленного ключа из одного столбца. Кроме того, чтобы гарантировать, что решение на месте будет работать как для левого, так и для правого объединений одних и тех же таблиц, все данные случайных тестов используют количество &lt;code&gt;0..1:0..1&lt;/code&gt; . Это реализуется путем выборки без замены ключевого столбца первого data.frame при генерации ключевого столбца второго data.frame.</target>
        </trans-unit>
        <trans-unit id="d7d6852d88aa3e327a146c14342fb3fab571a58e" translate="yes" xml:space="preserve">
          <source>Here's a benchmark of the example based on the OP that I demonstrated earlier:</source>
          <target state="translated">Вот эталон примера,основанный на ОП,который я продемонстрировал ранее:</target>
        </trans-unit>
        <trans-unit id="e8081890f19c96944894bdd114482dfc9a75ed29" translate="yes" xml:space="preserve">
          <source>Here's a second large-scale benchmark that's more heavy-duty, with respect to the number and types of key columns, as well as cardinality. For this benchmark I use three key columns: one character, one integer, and one logical, with no restrictions on cardinality (that is, &lt;code&gt;0..*:0..*&lt;/code&gt;). (In general it's not advisable to define key columns with double or complex values due to floating-point comparison complications, and basically no one ever uses the raw type, much less for key columns, so I haven't included those types in the key columns. Also, for information's sake, I initially tried to use four key columns by including a POSIXct key column, but the POSIXct type didn't play well with the &lt;code&gt;sqldf.indexed&lt;/code&gt; solution for some reason, possibly due to floating-point comparison anomalies, so I removed it.)</source>
          <target state="translated">Вот второй крупномасштабный тест, который более тяжелый, с точки зрения количества и типов ключевых столбцов, а также количества элементов. Для этого теста я использую три ключевых столбца: один символ, одно целое и один логический, без ограничений по количеству элементов (то есть &lt;code&gt;0..*:0..*&lt;/code&gt; ). (В общем случае не рекомендуется определять ключевые столбцы с двойными или сложными значениями из-за сложностей сравнения с плавающей точкой, и в основном никто никогда не использует необработанный тип, тем более для ключевых столбцов, поэтому я не включил эти типы в ключ Кроме того, ради информации, я изначально пытался использовать четыре ключевых столбца, включая ключевой столбец POSIXct, но тип &lt;code&gt;sqldf.indexed&lt;/code&gt; по какой-то причине не очень хорошо работал с решением sqldf.indexed , возможно, из-за аномалий сравнения с плавающей точкой вот так я его убрал.)</target>
        </trans-unit>
        <trans-unit id="4097e5d8cc2075da7471c980add60bad0cf09eb0" translate="yes" xml:space="preserve">
          <source>Here's an example based on the OP, except I've added an extra row to &lt;code&gt;df2&lt;/code&gt; with an id of 7 to test the case of a non-matching key in the joiner. This is effectively &lt;code&gt;df1&lt;/code&gt; left join &lt;code&gt;df2&lt;/code&gt;:</source>
          <target state="translated">Вот пример, основанный на OP, за исключением того, что я добавил дополнительную строку в &lt;code&gt;df2&lt;/code&gt; с идентификатором 7, чтобы проверить случай несовпадающего ключа в столяре. Это фактически &lt;code&gt;df1&lt;/code&gt; left join &lt;code&gt;df2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="044af99ba79865956da778a1334f4f8240c2bf7f" translate="yes" xml:space="preserve">
          <source>How can I do a SQL style select statement?</source>
          <target state="translated">Как сделать оператор выбора в стиле SQL?</target>
        </trans-unit>
        <trans-unit id="43090d2742d9081d6bd0ff68f38627e9993c5976" translate="yes" xml:space="preserve">
          <source>How can I do database style, i.e., &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;sql style, joins&lt;/a&gt;? That is, how do I get:</source>
          <target state="translated">Как я могу сделать стиль базы данных, то есть, &lt;a href=&quot;http://en.wikipedia.org/wiki/Join_%28SQL%29&quot;&gt;стиль SQL, объединяет&lt;/a&gt; ? То есть как я могу получить:</target>
        </trans-unit>
        <trans-unit id="87f0bedc362f9948f7a3bb794a94bec592f2987f" translate="yes" xml:space="preserve">
          <source>How to do a basic left outer join with data.table in R?</source>
          <target state="translated">Как сделать основное левое внешнее соединение с data.table в R?</target>
        </trans-unit>
        <trans-unit id="662b552b7e40492af7fd79296b2d468005570929" translate="yes" xml:space="preserve">
          <source>How to do a data.table merge operation</source>
          <target state="translated">Как выполнить операцию слияния data.table</target>
        </trans-unit>
        <trans-unit id="b2997a354edf34b9212b5bede79742efdcd92dac" translate="yes" xml:space="preserve">
          <source>How to join (merge) data frames (inner, outer, left, right)</source>
          <target state="translated">Как соединить (объединить)фреймы данных (внутренний,внешний,левый,правый)</target>
        </trans-unit>
        <trans-unit id="be4f4251a4aa264ff1a5045246798a437e872a51" translate="yes" xml:space="preserve">
          <source>I decided to do my own benchmarking to see how the in-place assignment approach compares to the other solutions that have been offered in this question.</source>
          <target state="translated">Я решил провести свой собственный бенчмаркинг,чтобы посмотреть,как подход к заданиям на месте сравнивается с другими решениями,которые были предложены в этом вопросе.</target>
        </trans-unit>
        <trans-unit id="1433555c3736ee7dc33f6787f0ee5e502257ce77" translate="yes" xml:space="preserve">
          <source>I find the SQL syntax to be simpler and more natural than its R equivalent (but this may just reflect my RDBMS bias).</source>
          <target state="translated">Я нахожу синтаксис SQL более простым и естественным,чем его R-эквивалент (но это может просто отражать мою предвзятость к СУБД).</target>
        </trans-unit>
        <trans-unit id="850ce2fc8639be910cca8a142e25a33d5a5324bd" translate="yes" xml:space="preserve">
          <source>I think this is a particularly appropriate solution if you have several tables that you want to left join against a single large table. Repeatedly rebuilding the entire table for each merge would be unnecessary and inefficient.</source>
          <target state="translated">Я думаю,что это особенно подходящее решение,если у вас есть несколько таблиц,которые вы хотите оставить присоединиться к одному большому столу.Повторная перестройка всей таблицы для каждого слияния будет ненужной и неэффективной.</target>
        </trans-unit>
        <trans-unit id="81dd38b7e015ec1e1a6ff6776efb1705d815b694" translate="yes" xml:space="preserve">
          <source>I used spline interpolation to show a smooth curve for each solution/join type combination, drawn with individual pch symbols. The join type is captured by the pch symbol, using a dot for inner, left and right angle brackets for left and right, and a diamond for full. The solution type is captured by the color as shown in the legend.</source>
          <target state="translated">Я использовал сплайн-интерполяцию,чтобы показать гладкую кривую для каждой комбинации типа соединения решений,нарисованную отдельными символами pch.Тип соединения фиксируется символом pch,используя точку для внутренних,левых и правых угловых скобок для левых и правых,и бриллиант для полных.Тип соединения фиксируется цветом,как показано в легенде.</target>
        </trans-unit>
        <trans-unit id="a8ebc4a7bfcf1453154ce5c9cb696149ac776e30" translate="yes" xml:space="preserve">
          <source>I would recommend checking out &lt;a href=&quot;http://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;Gabor Grothendieck's sqldf package&lt;/a&gt;, which allows you to express these operations in SQL.</source>
          <target state="translated">Я бы порекомендовал проверить &lt;a href=&quot;http://cran.r-project.org/web/packages/sqldf/index.html&quot;&gt;пакет sqldf Габора Гротендика&lt;/a&gt; , который позволяет вам выражать эти операции в SQL.</target>
        </trans-unit>
        <trans-unit id="2337e76070232665935ee45908852019881d7dba" translate="yes" xml:space="preserve">
          <source>I wrote some code to create log-log plots of the above results. I generated a separate plot for each overlap percentage. It's a little bit cluttered, but I like having all the solution types and join types represented in the same plot.</source>
          <target state="translated">Я написал код для создания лог-графиков вышеуказанных результатов.Я сгенерировал отдельный график для каждого процента перекрытия.Он немного загроможден,но мне нравится,когда все типы решений и соединений представлены в одном графике.</target>
        </trans-unit>
        <trans-unit id="710e748e65ff61225c32f7870e72f52de5d5471e" translate="yes" xml:space="preserve">
          <source>If the column names to merge on are not the same, you can specify, e.g., &lt;code&gt;by.x = &quot;CustomerId_in_df1&quot;, by.y = &quot;CustomerId_in_df2&quot;&lt;/code&gt; where &lt;code&gt;CustomerId_in_df1&lt;/code&gt; is the name of the column in the first data frame and &lt;code&gt;CustomerId_in_df2&lt;/code&gt; is the name of the column in the second data frame. (These can also be vectors if you need to merge on multiple columns.)</source>
          <target state="translated">Если имена столбцов для объединения не совпадают, вы можете указать, например, &lt;code&gt;by.x = &quot;CustomerId_in_df1&quot;, by.y = &quot;CustomerId_in_df2&quot;&lt;/code&gt; где &lt;code&gt;CustomerId_in_df1&lt;/code&gt; - это имя столбца в первом фрейме данных, а &lt;code&gt;CustomerId_in_df2&lt;/code&gt; - это имя столбца во втором фрейме данных. (Это также могут быть векторы, если вам нужно объединить несколько столбцов.)</target>
        </trans-unit>
        <trans-unit id="f8fa4b6558b0a4f2f657a454fe32716ede7c01cf" translate="yes" xml:space="preserve">
          <source>If the key is a single column, then we can use a single call to &lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; to do the matching. This is the case I'll cover in this answer.</source>
          <target state="translated">Если ключ представляет собой один столбец, то мы можем использовать один вызов метода &lt;a href=&quot;https://stat.ethz.ch/R-manual/R-devel/library/base/html/match.html&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; для сопоставления. Это тот случай, который я расскажу в этом ответе.</target>
        </trans-unit>
        <trans-unit id="aa34b093d971a035acaf887e23091153f1492e31" translate="yes" xml:space="preserve">
          <source>In joining two data frames with ~1 million rows each, one with 2 columns and the other with ~20, I've surprisingly found &lt;code&gt;merge(..., all.x = TRUE, all.y = TRUE)&lt;/code&gt; to be faster then &lt;code&gt;dplyr::full_join()&lt;/code&gt;. This is with dplyr v0.4</source>
          <target state="translated">Соединяя два фрейма данных с ~ 1 миллионом строк, один с двумя столбцами, а другой с ~ 20, я неожиданно обнаружил, что &lt;code&gt;merge(..., all.x = TRUE, all.y = TRUE)&lt;/code&gt; быстрее, чем &lt;code&gt;dplyr::full_join()&lt;/code&gt; . Это с dplyr v0.4</target>
        </trans-unit>
        <trans-unit id="5a7ff2d9ec551ba208af43332df0b32a7dc8d5b3" translate="yes" xml:space="preserve">
          <source>In the above I hard-coded an assumption that the key column is the first column of both input tables. I would argue that, in general, this is not an unreasonable assumption, since, if you have a data.frame with a key column, it would be strange if it had not been set up as the first column of the data.frame from the outset. And you can always reorder the columns to make it so. An advantageous consequence of this assumption is that the name of the key column does not have to be hard-coded, although I suppose it's just replacing one assumption with another. Concision is another advantage of integer indexing, as well as speed. In the benchmarks below I'll change the implementation to use string name indexing to match the competing implementations.</source>
          <target state="translated">В вышеуказанном я жестко закодировал предположение,что ключевой столбец является первым столбцом обеих входных таблиц.Я бы возразил,что в целом это не является необоснованным предположением,так как,если у вас есть data.frame с ключевым столбцом,было бы странно,если бы он с самого начала не был установлен в качестве первого столбца data.frame.И вы всегда можете переупорядочить столбцы,чтобы сделать это.Преимущественным следствием этого предположения является то,что название ключевого столбца не обязательно должно быть жестко закодировано,хотя я полагаю,что это просто замена одного предположения на другое.Согласованность-еще одно преимущество целочисленного индексирования,так же как и скорость.В приведенных ниже бенчмарках я изменю реализацию,чтобы использовать индексацию по имени строки в соответствии с конкурирующими реализациями.</target>
        </trans-unit>
        <trans-unit id="6250605ea19f359b4292e4f82913fe0d8caae6ab" translate="yes" xml:space="preserve">
          <source>It's all &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html&quot;&gt;here&lt;/a&gt; in great detail.</source>
          <target state="translated">Это все &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/introduction.html&quot;&gt;здесь&lt;/a&gt; очень подробно.</target>
        </trans-unit>
        <trans-unit id="b091ee98d4a46bacae49eb5f90e7465fe5df5f71" translate="yes" xml:space="preserve">
          <source>Join-related &lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/news/news.html&quot;&gt;release highlights&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://cran.r-project.org/web/packages/dplyr/news/news.html&quot;&gt;Основные моменты релиза,&lt;/a&gt; связанные с присоединением:</target>
        </trans-unit>
        <trans-unit id="ecc363814d7eeefe97adb1b510ca596b8ac8e949" translate="yes" xml:space="preserve">
          <source>Merge takes ~17 seconds, full_join takes ~65 seconds.</source>
          <target state="translated">Слияние занимает ~17 секунд,полное_соединение-~65 секунд.</target>
        </trans-unit>
        <trans-unit id="1d04d0125deda2ba2209b50e785af8edc6c62682" translate="yes" xml:space="preserve">
          <source>Modifying the OP's example tables...</source>
          <target state="translated">Изменение таблиц примеров ОП...</target>
        </trans-unit>
        <trans-unit id="cf0e80f7f1862b16f7353cadc5e580929ed727c8" translate="yes" xml:space="preserve">
          <source>Mutating joins, which add new variables to one table from matching rows in another. Filtering joins, which filter observations from one table based on whether or not they match an observation in the other table.</source>
          <target state="translated">Мутирующие соединения,которые добавляют новые переменные в одну таблицу из совпадающих строк в другую.Фильтрация соединений,которые фильтруют наблюдения из одной таблицы на основании того,совпадают ли они с наблюдениями из другой таблицы или нет.</target>
        </trans-unit>
        <trans-unit id="76494af2798aaf4f5297aa9a9455435c0a1baae3" translate="yes" xml:space="preserve">
          <source>Mutating joins: add columns to df1 using matches in df2</source>
          <target state="translated">Мутирующие соединения:добавьте колонки в df1,используя спички в df2.</target>
        </trans-unit>
        <trans-unit id="4f7e10e539fcde0fedb67622c28ce2185dc8d4fe" translate="yes" xml:space="preserve">
          <source>New in 2014:</source>
          <target state="translated">Новое в 2014 году:</target>
        </trans-unit>
        <trans-unit id="da097f490eba3885863a0e13ce340e42d5855b1e" translate="yes" xml:space="preserve">
          <source>New suffix argument to control what suffix duplicated variable names receive (#1296)</source>
          <target state="translated">Новый суффиксный аргумент для управления тем,какой суффикс получают дублирующие друг друга имена переменных (#1296)</target>
        </trans-unit>
        <trans-unit id="b93e636c4795007ba0754843b031729197bf6b22" translate="yes" xml:space="preserve">
          <source>On the other hand, if you need the joinee to remain unaltered through this operation for whatever reason, then this solution cannot be used, since it modifies the joinee directly. Although in that case you could simply make a copy and perform the in-place assignment(s) on the copy.</source>
          <target state="translated">С другой стороны,если по каким-либо причинам вам нужно,чтобы участник остался неизменным посредством этой операции,то данное решение не может быть использовано,так как оно изменяет участника непосредственно.Хотя в этом случае вы можете просто сделать копию и выполнить назначение(и)для копии.</target>
        </trans-unit>
        <trans-unit id="275a3e036899aeaeaf21926f7f5568683b2bb806" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;type&lt;/code&gt;: &lt;code&gt;inner&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;.</source>
          <target state="translated">Варианты &lt;code&gt;type&lt;/code&gt; : &lt;code&gt;inner&lt;/code&gt; , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; , &lt;code&gt;full&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff2431181fc9fc2e60070beaa227805ee647ef62" translate="yes" xml:space="preserve">
          <source>R :- &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y =
&quot;CustomerId&quot;)[,names(df2)]&lt;/code&gt;</source>
          <target state="translated">R: - &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df2)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a90a1fd62b7cfb3514800d395f4aa530d9d32189" translate="yes" xml:space="preserve">
          <source>R :- &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df1)]&lt;/code&gt;</source>
          <target state="translated">R: - &lt;code&gt;merge(df1, df2, by.x = &quot;CustomerId&quot;, by.y = &quot;CustomerId&quot;)[,names(df1)]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fe4364f88f74f296de93af3b3599121f64037b6" translate="yes" xml:space="preserve">
          <source>Return all rows from the left table, and any rows with matching keys from the right table.</source>
          <target state="translated">Верните все строки из левой таблицы,а также любые строки с совпадающими клавишами из правой таблицы.</target>
        </trans-unit>
        <trans-unit id="b075052cf9c2a92043b4c19e839781e4f2bb219e" translate="yes" xml:space="preserve">
          <source>Return all rows from the right table, and any rows with matching keys from the left table.</source>
          <target state="translated">Верните все строки из правой таблицы,а также любые строки с совпадающими клавишами из левой таблицы.</target>
        </trans-unit>
        <trans-unit id="256ebb1bf5d1b1490ada37135eaa9f3ef9b55410" translate="yes" xml:space="preserve">
          <source>Return only the rows in which the left table have matching keys in the right table.</source>
          <target state="translated">Возвращайте только те строки,в которых левая таблица имеет соответствующие клавиши в правой таблице.</target>
        </trans-unit>
        <trans-unit id="e571ab9ca057fdce414c471714347a24e546c952" translate="yes" xml:space="preserve">
          <source>Returns all rows from both tables, join records from the left which have matching keys in the right table.</source>
          <target state="translated">Возвращает все строки из обеих таблиц,объединяет записи слева,которые имеют соответствующие клавиши в правой таблице.</target>
        </trans-unit>
        <trans-unit id="9e5d4b98769be55db1d88583ac64d18adb2b96ab" translate="yes" xml:space="preserve">
          <source>SQL :-  &lt;code&gt;select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</source>
          <target state="translated">SQL: - &lt;code&gt;select a.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1040827d8fcc05e6ced9f587ad7e4394f6d46db" translate="yes" xml:space="preserve">
          <source>SQL :- &lt;code&gt;select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</source>
          <target state="translated">SQL: - &lt;code&gt;select b.* from df1 a inner join df2 b on a.CustomerId=b.CustomerId&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="182e27662bc0db38ceece5dd2e17427203440683" translate="yes" xml:space="preserve">
          <source>Same way</source>
          <target state="translated">Точно так же</target>
        </trans-unit>
        <trans-unit id="36d2d63aaf03c9e36ebc4dc91950d14a746e0b3d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/ggrothendieck/sqldf#example-4-join&quot;&gt;Gabor's sqldf GitHub&lt;/a&gt; for more information on joins.</source>
          <target state="translated">Посмотрите &lt;a href=&quot;https://github.com/ggrothendieck/sqldf#example-4-join&quot;&gt;sqlf GitHub Gabor&lt;/a&gt; для получения дополнительной информации о присоединениях.</target>
        </trans-unit>
        <trans-unit id="410c9a8726f8cbd1c1e586b81fe174b89fccc09b" translate="yes" xml:space="preserve">
          <source>Selecting columns can be done by &lt;code&gt;select(df,&quot;column&quot;)&lt;/code&gt;. If that's not SQL-ish enough for you, then there's the &lt;code&gt;sql()&lt;/code&gt; function, into which you can enter SQL code as-is, and it will do the operation you specified just like you were writing in R all along (for more information, please refer to the &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html&quot;&gt;dplyr/databases vignette&lt;/a&gt;). For example, if applied correctly, &lt;code&gt;sql(&quot;SELECT * FROM hflights&quot;)&lt;/code&gt; will select all the columns from the &quot;hflights&quot; dplyr table (a &quot;tbl&quot;).</source>
          <target state="translated">Выбор столбцов может быть сделан с помощью &lt;code&gt;select(df,&quot;column&quot;)&lt;/code&gt; . Если вам недостаточно SQL-кода, то есть функция &lt;code&gt;sql()&lt;/code&gt; , в которую вы можете ввести SQL-код как есть, и он выполнит указанную вами операцию так же, как вы писали в R все время (для получения дополнительной информации). Пожалуйста, обратитесь к &lt;a href=&quot;http://cran.r-project.org/web/packages/dplyr/vignettes/databases.html&quot;&gt;виньетке dplyr / database&lt;/a&gt; ). Например, при правильном применении &lt;code&gt;sql(&quot;SELECT * FROM hflights&quot;)&lt;/code&gt; выберет все столбцы из таблицы dplyr &amp;laquo;hflights&amp;raquo; (&amp;laquo;tbl&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="89f032298f21e2eb6484041690c0b5f31f1c9852" translate="yes" xml:space="preserve">
          <source>Since your keys are named the same the short way to do an inner join is merge():</source>
          <target state="translated">Так как ваши ключи именуются одинаково,то короткий способ сделать внутреннее соединение-это merge():</target>
        </trans-unit>
        <trans-unit id="09f26ff5d7f001a9ebafb1da072687d91833c703" translate="yes" xml:space="preserve">
          <source>Some food for though, since I generally default to dplyr for manipulation tasks.</source>
          <target state="translated">Пища для некоторых,хотя,так как я обычно по умолчанию dplyr для манипуляционных задач.</target>
        </trans-unit>
        <trans-unit id="fed6f49e983aa5bd71ca7e1155b989e6e3375280" translate="yes" xml:space="preserve">
          <source>Suppose we want to add the customer's state from &lt;code&gt;cust&lt;/code&gt; to the purchases table, &lt;code&gt;sales&lt;/code&gt;, ignoring the year column. With base R, we can identify matching rows and then copy values over:</source>
          <target state="translated">Предположим, мы хотим добавить состояние клиента от &lt;code&gt;cust&lt;/code&gt; к таблице покупок, &lt;code&gt;sales&lt;/code&gt; , игнорируя столбец year. С помощью базы R мы можем определить совпадающие строки и затем скопировать значения в:</target>
        </trans-unit>
        <trans-unit id="cc0804bbd7e4d942d5dec0c858695fe81456d52e" translate="yes" xml:space="preserve">
          <source>Testing code:</source>
          <target state="translated">Тестировочный код:</target>
        </trans-unit>
        <trans-unit id="4d2affb1e17938190686ba88646124834885e979" translate="yes" xml:space="preserve">
          <source>The four joining-related functions in the dplyr package are (to quote):</source>
          <target state="translated">Четырьмя связанными с соединением функциями в пакете dplyr являются (для цитирования):</target>
        </trans-unit>
        <trans-unit id="975fec70202257751857627844d9ba0efd8ac25c" translate="yes" xml:space="preserve">
          <source>The other combination of outer joins can be created by mungling the left outer join subscript example. (yeah, I know that's the equivalent of saying &quot;I'll leave it as an exercise for the reader...&quot;)</source>
          <target state="translated">Другая комбинация внешних соединений может быть создана на примере левого абонемента внешнего соединения.(да,я знаю,что это эквивалентно слову &quot;Я оставлю это как упражнение для читателя...&quot;)</target>
        </trans-unit>
        <trans-unit id="cfb49dc74158670dddef83e622172c7c91441e36" translate="yes" xml:space="preserve">
          <source>The resulting plots, using the same plotting code given above:</source>
          <target state="translated">Результирующие графики,используя тот же код построения графиков,что и выше:</target>
        </trans-unit>
        <trans-unit id="3fd1810b687b3f6297e5dacac6cd2f293af39cd7" translate="yes" xml:space="preserve">
          <source>The three examples above all focus on creating/adding a new column. See &lt;a href=&quot;https://stackoverflow.com/q/6112260&quot;&gt;the related R FAQ&lt;/a&gt; for an example of updating/modifying an existing column.</source>
          <target state="translated">Три приведенных выше примера сосредоточены на создании / добавлении нового столбца. См. &lt;a href=&quot;https://stackoverflow.com/q/6112260&quot;&gt;Соответствующий R FAQ&lt;/a&gt; для примера обновления / изменения существующего столбца.</target>
        </trans-unit>
        <trans-unit id="cecd23eb962bc5d6748ad3fb34f5562f803499f5" translate="yes" xml:space="preserve">
          <source>There are some good examples of doing this over at the &lt;a href=&quot;http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge&quot;&gt;R Wiki&lt;/a&gt;. I'll steal a couple here:</source>
          <target state="translated">Есть несколько хороших примеров этого в &lt;a href=&quot;http://wiki.r-project.org/rwiki/doku.php?id=tips:data-frames:merge&quot;&gt;R Wiki&lt;/a&gt; . Я украду пару здесь:</target>
        </trans-unit>
        <trans-unit id="d8d441f0127df63fc7e588978f519a0a7110a1d7" translate="yes" xml:space="preserve">
          <source>There is the &lt;strong&gt;data.table&lt;/strong&gt; approach for an inner join, which is very time and memory efficient (and necessary for some larger data.frames):</source>
          <target state="translated">Существует метод &lt;strong&gt;data.table&lt;/strong&gt; для внутреннего объединения, который очень &lt;strong&gt;экономит&lt;/strong&gt; время и память (и необходим для некоторых больших data.frames):</target>
        </trans-unit>
        <trans-unit id="e97719490cc7ca28a945d219ef810933fffa9275" translate="yes" xml:space="preserve">
          <source>Translating SQL joins on foreign keys to R data.table syntax</source>
          <target state="translated">Трансляция SQL соединений на иностранных ключах в синтаксис R data.table</target>
        </trans-unit>
        <trans-unit id="def30251a119892b32dc57973f51d84d2b8a55a3" translate="yes" xml:space="preserve">
          <source>Update on data.table methods for joining datasets. See below examples for each type of join. There are two methods, one from &lt;code&gt;[.data.table&lt;/code&gt; when passing second data.table as the first argument to subset, another way is to use &lt;code&gt;merge&lt;/code&gt; function which dispatches to fast data.table method.</source>
          <target state="translated">Обновление методов data.table для объединения наборов данных. Ниже приведены примеры для каждого типа соединения. Есть два метода: один из &lt;code&gt;[.data.table&lt;/code&gt; при передаче второго data.table в качестве первого аргумента подмножеству, другой способ - использовать функцию &lt;code&gt;merge&lt;/code&gt; которая отправляет быстрый метод data.table.</target>
        </trans-unit>
        <trans-unit id="5b7fa59fc1d348ab50e552c606a943a4fb3428d2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;merge&lt;/code&gt; function we can select the variable of left table or right table, same way like we all familiar with select statement in SQL (EX : Select a.* ...or Select b.* from .....)</source>
          <target state="translated">Используя функцию &lt;code&gt;merge&lt;/code&gt; мы можем выбрать переменную левой или правой таблицы точно так же, как мы все знакомы с оператором select в SQL (EX: выберите a. * ... или выберите b. * Из .....)</target>
        </trans-unit>
        <trans-unit id="777e443e9e2269e9c7657e5c1bb5b4ef07dd5d99" translate="yes" xml:space="preserve">
          <source>We have to add extra code which will subset from the newly joined table .</source>
          <target state="translated">Мы должны добавить дополнительный код,который будет подмножеством из новой объединенной таблицы .</target>
        </trans-unit>
        <trans-unit id="35f9f5a0a66021813e967af96baa693e8e91102d" translate="yes" xml:space="preserve">
          <source>Workarounds per hadley's comments in that issue:</source>
          <target state="translated">Обходные пути для комментариев Хадли в этом выпуске:</target>
        </trans-unit>
        <trans-unit id="20e71a92fd73f1ea6448c8ce19a1b28c6fd612ab" translate="yes" xml:space="preserve">
          <source>Yet another option is the &lt;code&gt;join&lt;/code&gt; function found in the &lt;a href=&quot;http://cran.r-project.org/web/packages/plyr/index.html&quot;&gt;&lt;strong&gt;plyr&lt;/strong&gt;&lt;/a&gt; package</source>
          <target state="translated">Еще одним вариантом является функция &lt;code&gt;join&lt;/code&gt; , найденная в пакете &lt;a href=&quot;http://cran.r-project.org/web/packages/plyr/index.html&quot;&gt;&lt;strong&gt;plyr.&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a4ca82ec6e06c0c6954a4927a77918e335215d61" translate="yes" xml:space="preserve">
          <source>You can do joins as well using Hadley Wickham's awesome &lt;a href=&quot;http://blog.rstudio.org/2014/01/17/introducing-dplyr/&quot;&gt;dplyr&lt;/a&gt; package.</source>
          <target state="translated">Вы также можете делать объединения, используя удивительный пакет &lt;a href=&quot;http://blog.rstudio.org/2014/01/17/introducing-dplyr/&quot;&gt;dplyr&lt;/a&gt; Хэдли Уикхэма.</target>
        </trans-unit>
        <trans-unit id="5724e67f3f18acb7528650cc64cff7877156db95" translate="yes" xml:space="preserve">
          <source>You can merge on multiple columns by giving &lt;code&gt;by&lt;/code&gt; a vector, e.g., &lt;code&gt;by = c(&quot;CustomerId&quot;, &quot;OrderId&quot;)&lt;/code&gt;.</source>
          <target state="translated">Вы можете объединить несколько столбцов, задавая вектором, например, с &lt;code&gt;by = c(&quot;CustomerId&quot;, &quot;OrderId&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf2d2dee20b0fe4b4b6a2f7726c0245d830c0168" translate="yes" xml:space="preserve">
          <source>a full inner join (all records from both tables) can be created with the &quot;all&quot; keyword:</source>
          <target state="translated">полное внутреннее соединение (все записи из обеих таблиц)может быть создано с помощью ключевого слова &quot;все&quot;:</target>
        </trans-unit>
        <trans-unit id="45b24f5fc4c5960be3b959ba6f2bc3227a86250d" translate="yes" xml:space="preserve">
          <source>a left outer join of df1 and df2:</source>
          <target state="translated">левое внешнее соединение df1 и df2:</target>
        </trans-unit>
        <trans-unit id="6d47d87da3f640b3f3ac9043cf30483af1712d57" translate="yes" xml:space="preserve">
          <source>a right outer join of df1 and df2:</source>
          <target state="translated">правое внешнее соединение df1 и df2:</target>
        </trans-unit>
        <trans-unit id="f00d083db7a975f33fd38e2809f8dd64537504aa" translate="yes" xml:space="preserve">
          <source>base R &lt;code&gt;merge()&lt;/code&gt; and equivalent package-based merge functions, which always allocate a new table to return the merged result, and thus are not suitable for an in-place assignment-based solution.</source>
          <target state="translated">base R &lt;code&gt;merge()&lt;/code&gt; и эквивалентные функции слияния на основе пакетов, которые всегда выделяют новую таблицу для возврата объединенного результата и, следовательно, не подходят для решения на основе назначения на месте.</target>
        </trans-unit>
        <trans-unit id="abfb07f46a8b85131c33b5c00be46ae3ec4d825a" translate="yes" xml:space="preserve">
          <source>data.table documented on stackoverflow:</source>
          <target state="translated">data.table,задокументированной на переполнении стека:</target>
        </trans-unit>
        <trans-unit id="739d53834e2598c061e546b33d4c497722f8aa6e" translate="yes" xml:space="preserve">
          <source>didn't yet &lt;a href=&quot;https://github.com/hadley/dplyr/issues/96&quot;&gt;implement right_join and &lt;strong&gt;outer_join&lt;/strong&gt;&lt;/a&gt;</source>
          <target state="translated">еще не &lt;a href=&quot;https://github.com/hadley/dplyr/issues/96&quot;&gt;реализовал right_join и &lt;strong&gt;outer_join&lt;/strong&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dc4f0b439d260cec5f45060722ff170e14ccd80" translate="yes" xml:space="preserve">
          <source>dplyr since 0.4 implemented all those joins including &lt;code&gt;outer_join&lt;/code&gt;, but it was worth noting that &lt;strong&gt;for the first few releases prior to 0.4 it used not to offer &lt;code&gt;outer_join&lt;/code&gt;, and as a result there was a lot of really bad hacky workaround user code floating around for quite a while afterwards (you can still find such code in SO, Kaggle answers, github from that period. Hence this answer still serves a useful purpose.)&lt;/strong&gt;</source>
          <target state="translated">В dplyr начиная с 0.4 реализованы все эти объединения, включая &lt;code&gt;outer_join&lt;/code&gt; , но стоит отметить, что &lt;strong&gt;в первых нескольких выпусках, предшествующих 0.4, раньше не предлагалось &lt;code&gt;outer_join&lt;/code&gt; , и в результате было много действительно плохого хакерского пользовательского кода, обходившегося довольно быстро. Некоторое время спустя (вы все еще можете найти такой код в SO, Kaggle отвечает, Github из того периода. Следовательно, этот ответ по-прежнему служит полезной цели.)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61e2da8dd77d5e292248c9fb83d7a134ac198b3a" translate="yes" xml:space="preserve">
          <source>has &lt;strong&gt;inner_join, left_join, semi_join, anti_join&lt;/strong&gt;</source>
          <target state="translated">имеет &lt;strong&gt;inner_join, left_join, semi_join, anti_join&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="091a85912279e018e930a477c24b367571489c0f" translate="yes" xml:space="preserve">
          <source>inefficient cartesian conjunctions, e.g. &lt;code&gt;outer(df1$a,df2$a,`==`) &amp;amp; outer(df1$b,df2$b,`==`)&lt;/code&gt;.</source>
          <target state="translated">неэффективные декартовы конъюнкции, например, &lt;code&gt;outer(df1$a,df2$a,`==`) &amp;amp; outer(df1$b,df2$b,`==`)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a34ccb1aad2f513af7c11ec01144f6ab37837eaf" translate="yes" xml:space="preserve">
          <source>inefficient concatenations. e.g. &lt;code&gt;match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))&lt;/code&gt;, or the same idea with &lt;code&gt;paste()&lt;/code&gt;.</source>
          <target state="translated">неэффективные объединения. например, &lt;code&gt;match(interaction(df1$a,df1$b),interaction(df2$a,df2$b))&lt;/code&gt; или та же идея с &lt;code&gt;paste()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feb96c8e7073f7b49193f9c3ac2e9abbef5ee89f" translate="yes" xml:space="preserve">
          <source>one minor feature merge currently has that dplyr doesn't is &lt;a href=&quot;https://github.com/hadley/dplyr/issues/177&quot;&gt;the ability to have separate by.x,by.y columns&lt;/a&gt; as e.g. Python pandas does.</source>
          <target state="translated">одно незначительное слияние функций, которого в настоящее время нет у dplyr, - &lt;a href=&quot;https://github.com/hadley/dplyr/issues/177&quot;&gt;возможность иметь отдельные столбцы by.x, by.y,&lt;/a&gt; как, например, в Python pandas</target>
        </trans-unit>
        <trans-unit id="b89a4220d42db1407a2fa042c855a3d4652ddd00" translate="yes" xml:space="preserve">
          <source>you can flip 'em, slap 'em and rub 'em down to get the other two outer joins you asked about :)</source>
          <target state="translated">вы можете перевернуть их,дать пощечину и натереть,чтобы получить два других внешних соединения,о которых вы спрашивали :)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
