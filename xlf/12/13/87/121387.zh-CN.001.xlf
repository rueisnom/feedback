<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/121387">
    <body>
      <group id="121387">
        <trans-unit id="088d6bfd13fdd1c7523360c5e5bebc3ada83c101" translate="yes" xml:space="preserve">
          <source>&quot;Analytic functions rock&quot;</source>
          <target state="translated">&quot;分析功能的岩石&quot;</target>
        </trans-unit>
        <trans-unit id="413da9addd1811fab78614e45fc2d047da891fce" translate="yes" xml:space="preserve">
          <source>&quot;The default window in Oracle is from the first row in the partition to the current one&quot;</source>
          <target state="translated">&quot;Oracle中的默认窗口是从分区的第一行到当前分区的第一行&quot;</target>
        </trans-unit>
        <trans-unit id="e80f653c17fe6a899c1ae74484172eefa0dd0c5c" translate="yes" xml:space="preserve">
          <source>&quot;using analytic queries and a self-join defeats the purpose of analytic queries&quot;</source>
          <target state="translated">&quot;使用分析性查询和自连接有悖于分析性查询的目的&quot;</target>
        </trans-unit>
        <trans-unit id="e3d423c44d0b57efd24da450f35feeed5c11ae47" translate="yes" xml:space="preserve">
          <source>(I put the identifier &quot;Date&quot; in delimiters because it's an SQL reserved word.)</source>
          <target state="translated">(我把标识符 &quot;Date &quot;放在分隔符中,因为它是一个SQL的保留词)。</target>
        </trans-unit>
        <trans-unit id="58d03f6fac5b12cde98025a1436e9a3fd045c82a" translate="yes" xml:space="preserve">
          <source>(T-SQL) First get all the users and their maxdate. Join with the table to find the corresponding values for the users on the maxdates.</source>
          <target state="translated">T-SQL)首先得到所有的用户和他们的maxdate。与表进行联接,找到用户在maxdates上的对应值。</target>
        </trans-unit>
        <trans-unit id="de6ab6da15e1403a174ce26bee9a06147f49f3f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; Apologies for any ambiguity: I need to get ALL the UserIds. But for each UserId, only that row where that user has the latest date.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更新：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于任何歧义，我们深表歉意：我需要获取所有UserIds。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是对于每个UserId，仅该用户具有最新日期的那一行。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5253313e4d21a0c4fb3cf956b4c943650047fc54" translate="yes" xml:space="preserve">
          <source>Accepted answer</source>
          <target state="translated">接受的答案</target>
        </trans-unit>
        <trans-unit id="fd0c7bcaca1e8f700846a874d952217de8ff9f3d" translate="yes" xml:space="preserve">
          <source>An outer join attempts to join &lt;code&gt;t1&lt;/code&gt; with &lt;code&gt;t2&lt;/code&gt;.  By default, all results of &lt;code&gt;t1&lt;/code&gt; are returned, and &lt;em&gt;if&lt;/em&gt; there is a match in &lt;code&gt;t2&lt;/code&gt;, it is also returned.  If there is no match in &lt;code&gt;t2&lt;/code&gt; for a given row of &lt;code&gt;t1&lt;/code&gt;, then the query still returns the row of &lt;code&gt;t1&lt;/code&gt;, and uses &lt;code&gt;NULL&lt;/code&gt; as a placeholder for all of &lt;code&gt;t2&lt;/code&gt;'s columns.  That's just how outer joins work in general.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;外部联接尝试将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; 联接&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。默认情况下，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将返回&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有结果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;存在匹配项&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则还将返回它。如果在没有匹配&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于一个给定的行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，那么查询仍返回的行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;NULL&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为所有的占位符&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的列。通常，外部联接就是这样工作的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fd49a5debb75caf7f1a7c5fdfdfdb817e1bea03e" translate="yes" xml:space="preserve">
          <source>And a more difficult example, which need some explanation, for which I don't have time atm:</source>
          <target state="translated">还有一个更难的例子,需要解释一下,我现在没有时间。</target>
        </trans-unit>
        <trans-unit id="904c7473e98d9c980acb1d06bbb7b004f1465dbc" translate="yes" xml:space="preserve">
          <source>Assuming Date is unique for a given UserID, here's some TSQL:</source>
          <target state="translated">假设Date对于给定的UserID是唯一的,下面是一些TSQL。</target>
        </trans-unit>
        <trans-unit id="f6e3e2c62ae12a54199ac2ab1fff0081fedf5490" translate="yes" xml:space="preserve">
          <source>Both queries return the same results as the accepted answer. See SQLFiddles:</source>
          <target state="translated">这两个查询都会返回与接受答案相同的结果。参见SQLFiddles。</target>
        </trans-unit>
        <trans-unit id="b176631d670bf7d1d6f81ac328b2bbce2391928d" translate="yes" xml:space="preserve">
          <source>Columns:
UserId, Value, Date</source>
          <target state="translated">列。UserId,Value,日期</target>
        </trans-unit>
        <trans-unit id="edbdf8261b8b53cd2c44f0e6bebecc51bc79ad98" translate="yes" xml:space="preserve">
          <source>EDIT: Also misread the question! Corrected the query...</source>
          <target state="translated">EDIT:也是误读了问题! 纠正了这个问题.....</target>
        </trans-unit>
        <trans-unit id="1ea6ef1589771cfbfbd0792b8c9dad50b8ca110e" translate="yes" xml:space="preserve">
          <source>EDIT: Just tried it for real:</source>
          <target state="translated">EDIT:刚试了一下真的。</target>
        </trans-unit>
        <trans-unit id="b5b09b3e814746064c06e631b56dafa6faf9dbc2" translate="yes" xml:space="preserve">
          <source>Edit: With regard to the first comment ...</source>
          <target state="translated">编辑:关于第一条评论.....。</target>
        </trans-unit>
        <trans-unit id="ba3940b609eb3a39ab46f269a794269140341fff" translate="yes" xml:space="preserve">
          <source>Fetch the row which has the Max value for a column</source>
          <target state="translated">读取某列的最大值的行。</target>
        </trans-unit>
        <trans-unit id="1b260f18fab6eb46ce941a4a30f3fd2c37e1b125" translate="yes" xml:space="preserve">
          <source>First try I misread the question, following the top answer, here is a complete example with correct results:</source>
          <target state="translated">首先试题我看错了,按照上面的答案,下面是一个完整的例题,有正确的结果。</target>
        </trans-unit>
        <trans-unit id="eabe3a3e55f28b62b73250aedaee7ad6c8953f98" translate="yes" xml:space="preserve">
          <source>For context, on Teradata here a decent size test of this runs in 17s with this QUALIFY version and in 23s with the 'inline view'/Aldridge solution #1.</source>
          <target state="translated">对于上下文,在Teradata上,用这个QUALIFY版本在17s内运行,而用'inline view'Aldridge解决方案#1在23s内运行。</target>
        </trans-unit>
        <trans-unit id="97456deba4b3218e51dd6451f33cd580f0c385eb" translate="yes" xml:space="preserve">
          <source>Give the book (ISBN and title) that is most popular in 2008, i.e., which is borrowed most often in 2008.</source>
          <target state="translated">给出2008年最流行的书(ISBN和书名),也就是2008年借阅次数最多的书。</target>
        </trans-unit>
        <trans-unit id="408cc7448fc02af904bd8630ec14f49fe54d3430" translate="yes" xml:space="preserve">
          <source>Here's a more detailed explanation:</source>
          <target state="translated">下面就给大家详细讲解一下。</target>
        </trans-unit>
        <trans-unit id="0e7723428750aa5b89daf45442ac23987c1eef2c" translate="yes" xml:space="preserve">
          <source>Hope this helps (anyone).. :)</source>
          <target state="translated">希望这能帮助到你(任何人)。</target>
        </trans-unit>
        <trans-unit id="2bbf482ff901d3844f91bfe54e66619489d39ca7" translate="yes" xml:space="preserve">
          <source>I don't have Oracle to test it, but the most efficient solution is to use analytic queries.  It should look something like this:</source>
          <target state="translated">我没有Oracle的测试,但最有效的解决方案是使用分析查询。它应该是这样的样子。</target>
        </trans-unit>
        <trans-unit id="17d726823c642c9f173dc0861e890311392528d5" translate="yes" xml:space="preserve">
          <source>I don't know your exact columns names, but it would be something like this:</source>
          <target state="translated">我不知道你确切的列名,但应该是这样的。</target>
        </trans-unit>
        <trans-unit id="a1eff8ad086330ae5e1e2ee55b8de66b074d47e2" translate="yes" xml:space="preserve">
          <source>I know you asked for Oracle, but in SQL 2005 we now use this:</source>
          <target state="translated">我知道你问的是Oracle,但在SQL 2005中,我们现在用的是这个。</target>
        </trans-unit>
        <trans-unit id="b561086a4ee19bf7e418a63264c6e9c9fe3d5f3a" translate="yes" xml:space="preserve">
          <source>I see many people use subqueries or else vendor-specific features to do this, but I often do this kind of query without subqueries in the following way.  It uses plain, standard SQL so it should work in any brand of RDBMS.</source>
          <target state="translated">我看到很多人使用子查询或其他厂商的特定功能来做这个,但我经常用下面的方法来做这种没有子查询的查询。它使用普通的标准SQL,所以它应该可以在任何品牌的RDBMS中工作。</target>
        </trans-unit>
        <trans-unit id="d4b1e7b7cbe681b8954882bb2466203c755bea9e" translate="yes" xml:space="preserve">
          <source>I suspect that you can get rid of the outer query and put distinct on the inner, but I'm not sure.  In the meantime I know this one works.</source>
          <target state="translated">我怀疑你可以把外边的查询去掉,在内边放上分明,但我不确定。在这期间,我知道这个可以用。</target>
        </trans-unit>
        <trans-unit id="878e6b6608d887b9531664f493478e9c59a33d15" translate="yes" xml:space="preserve">
          <source>I think something like this. (Forgive me for any syntax mistakes; I'm used to using HQL at this point!)</source>
          <target state="translated">我想是这样的。(请原谅我的语法错误;在这一点上,我已经习惯了使用HQL!)</target>
        </trans-unit>
        <trans-unit id="c0f8b758a6465f7c6be80b9cafc6e63879977c3b" translate="yes" xml:space="preserve">
          <source>I think this should work?</source>
          <target state="translated">我想这应该可以吧?</target>
        </trans-unit>
        <trans-unit id="8cbb409c988a6df1954d3c399c0b5414c6185821" translate="yes" xml:space="preserve">
          <source>I want to get the UserId, Value for the max(Date) for each UserId. That is, the Value for each UserId that has the latest date. Is there a way to do this simply in SQL? (Preferably Oracle)</source>
          <target state="translated">我想得到每个UserId的最大值(Date)的UserId,Value。也就是说,每一个UserId的最大日期的Value。有什么方法可以简单地在SQL中实现吗?(最好是Oracle)</target>
        </trans-unit>
        <trans-unit id="cd2ca7dae2209e0e59d6d3dd4b8f60e2dcc5cae9" translate="yes" xml:space="preserve">
          <source>I'm not familiar with Oracle. This is what I came up with</source>
          <target state="translated">我对甲骨文不熟悉。我是这样想出来的</target>
        </trans-unit>
        <trans-unit id="490454b390a9bb71c5960d6bffae85a8d7596408" translate="yes" xml:space="preserve">
          <source>I'm quite late to the party but the following hack will outperform both correlated subqueries and any analytics function but has one restriction: values must convert to strings. So it works for dates, numbers and other strings. The code does not look good but the execution profile is great.</source>
          <target state="translated">我对这个问题已经很晚了,但是下面这个黑客的效果会比关联子查询和任何分析函数都好,但是有一个限制:值必须转换为字符串。所以它对日期、数字和其他字符串都有效。这段代码看起来并不好看,但执行效果很好。</target>
        </trans-unit>
        <trans-unit id="650ac70d7051011690338160d400eb5df589f9db" translate="yes" xml:space="preserve">
          <source>IMHO this works. HTH</source>
          <target state="translated">IMHO这样做是可行的。HTH</target>
        </trans-unit>
        <trans-unit id="122ef6cf39940e2210618fd865896d0a4584120f" translate="yes" xml:space="preserve">
          <source>If (UserID, Date) is unique, i.e. no date appears twice for the same user then:</source>
          <target state="translated">如果(UserID,Date)是唯一的,也就是说,同一个用户没有两次出现日期,那么:</target>
        </trans-unit>
        <trans-unit id="54b972ede6c9b119c5143cc8883f6f74091b5ebf" translate="yes" xml:space="preserve">
          <source>If you want only one row with max date, then replace the &lt;code&gt;rank&lt;/code&gt; with &lt;code&gt;row_number&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果你想只有一排，最大日期，然后更换&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rank&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;row_number&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bdfe0d65369806ce41db47d66aa8148f91207fe" translate="yes" xml:space="preserve">
          <source>If you want to learn about analytic queries, I'd suggest reading &lt;a href=&quot;http://www.orafaq.com/node/55&quot;&gt;http://www.orafaq.com/node/55&lt;/a&gt; and &lt;strike&gt;&lt;a href=&quot;http://www.akadia.com/services/ora_analytic_functions.html&quot;&gt;http://www.akadia.com/services/ora_analytic_functions.html&lt;/a&gt;&lt;/strike&gt;.  Here is the short summary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您想了解解析查询，建议阅读&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.orafaq.com/node/55&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.orafaq.com/node/55&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;strike&gt;&lt;a href=&quot;http://www.akadia.com/services/ora_analytic_functions.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.akadia.com/services/ora_analytic_functions.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是简短的摘要。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="944198ed78a48e6347cc0427c09b348bfacb86a2" translate="yes" xml:space="preserve">
          <source>If you're using Postgres, you can use &lt;code&gt;array_agg&lt;/code&gt; like</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果你使用的是Postgres，您可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;array_agg&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;像&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="458c3501c385ce8920f8fd35c19791e744639d2a" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;&lt;code&gt;Oracle 12c+&lt;/code&gt;&lt;/strong&gt;, you can use &lt;em&gt;Top n&lt;/em&gt; queries along with analytic function &lt;code&gt;rank&lt;/code&gt; to achieve this very concisely &lt;em&gt;without&lt;/em&gt; subqueries:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;strong&gt; &lt;code&gt;Oracle 12c+&lt;/code&gt; &lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您可以将&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Top n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;查询与解析函数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rank&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一起使用，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以非常简洁地实现此目的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而无需&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子查询：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c873798c90b4aa35114a37fda41e084ff1a6a67c" translate="yes" xml:space="preserve">
          <source>In case if &lt;code&gt;t1.&quot;Date&quot; = t2.&quot;Date&quot;&lt;/code&gt;, doubling appears. Usually tables has &lt;code&gt;auto_inc(seq)&lt;/code&gt; key, e.g. &lt;code&gt;id&lt;/code&gt;.
To avoid doubling can be used follows:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1.&quot;Date&quot; = t2.&quot;Date&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则出现双倍。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常，表具有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_inc(seq)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;键，例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为避免加倍，可以使用以下方法：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c8bae46c2bd19848ac4027530c6be507061b142a" translate="yes" xml:space="preserve">
          <source>In other words: fetch the row from &lt;code&gt;t1&lt;/code&gt; where no other row exists with the same &lt;code&gt;UserId&lt;/code&gt; and a greater Date.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;换句话说：从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;获取行，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其中没有其他行具有相同的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;UserId&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和更大的Date。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ecb6427a441808e4acda1af43f82bf01e1e93d7d" translate="yes" xml:space="preserve">
          <source>In this case here is what the inner query does.  The whole dataset is sorted by UserId then Date DESC.  Then it processes it in one pass.  For each row you return the UserId and the first Date seen for that UserId (since dates are sorted DESC, that's the max date).  This gives you your answer with duplicated rows.  Then the outer DISTINCT squashes duplicates.</source>
          <target state="translated">在这种情况下,内部查询是这样做的。整个数据集按UserId排序,然后是Date DESC。然后,它一次性处理它。对于每一条记录,你会返回UserId和该UserId的第一个日期(因为日期是按DESC排序的,这就是最大日期)。这样就可以得到有重复记录的答案。然后,外部的DISTINCT会把重复的记录挤掉。</target>
        </trans-unit>
        <trans-unit id="402085a89e3d90f5847116008a388b9c03c122c3" translate="yes" xml:space="preserve">
          <source>In those cases (when there's no match), the columns of &lt;code&gt;t2&lt;/code&gt; will be &lt;code&gt;NULL&lt;/code&gt; -- even the columns specified in the join condition.  So that's why we use &lt;code&gt;WHERE t2.UserId IS NULL&lt;/code&gt;, because we're searching for the cases where no row was found with a greater &lt;code&gt;date&lt;/code&gt; for the given &lt;code&gt;userid&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这些情况下（当没有匹配项时），&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的列&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;NULL&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;－甚至连接条件中指定的列。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这就是为什么我们使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;WHERE t2.UserId IS NULL&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原因，因为我们正在寻找找不到&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给定&lt;/font&gt; &lt;code&gt;userid&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行具有较大&lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的情况&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cff87308f0f5a44185f055a550f067dcf137883" translate="yes" xml:space="preserve">
          <source>Just had to write a &quot;live&quot; example at work :)</source>
          <target state="translated">只是在工作中不得不写一个 &quot;活 &quot;的例子:)</target>
        </trans-unit>
        <trans-unit id="b6a63b1d6787b611e979efb5a06d6ad2f19ac027" translate="yes" xml:space="preserve">
          <source>Just tested this and it seems to work on a logging table</source>
          <target state="translated">刚刚测试了一下,似乎在记录表上也能正常工作。</target>
        </trans-unit>
        <trans-unit id="9924f5c47b2ff7e5e41049935735440618c1048d" translate="yes" xml:space="preserve">
          <source>My solution with Oracle</source>
          <target state="translated">我与Oracle的解决方案</target>
        </trans-unit>
        <trans-unit id="0854d80218ef44ea7683517c112af7afa0afb923" translate="yes" xml:space="preserve">
          <source>My solution with Postgres</source>
          <target state="translated">我对Postgres的解决方案</target>
        </trans-unit>
        <trans-unit id="6d7d9479e022df45c509f62303629e302818e343" translate="yes" xml:space="preserve">
          <source>Not being at work, I don't have Oracle to hand, but I seem to recall that Oracle allows multiple columns to be matched in an IN clause, which should at least avoid the options that use a correlated subquery, which is seldom a good idea.</source>
          <target state="translated">不是在工作中,我手头没有Oracle,但我似乎记得Oracle允许在一个IN子句中匹配多个列,这至少应该可以避免使用关联子查询的选项,这很少是个好主意。</target>
        </trans-unit>
        <trans-unit id="78f19667512f67f6edbd1038c70b7a9d51178f51" translate="yes" xml:space="preserve">
          <source>Of course, if searching through huge tables, it's probably better if you use FULL hints in your query.</source>
          <target state="translated">当然,如果是通过庞大的表进行搜索,在查询中使用FULL提示可能会更好。</target>
        </trans-unit>
        <trans-unit id="3a99454b317198c63b1df2fb84afc34bca04b1da" translate="yes" xml:space="preserve">
          <source>Re comment from @Farhan:</source>
          <target state="translated">Re comment from @Farhan:</target>
        </trans-unit>
        <trans-unit id="91dd7bf9acb8e164d089c0b82ff5455ebf0e4e1b" translate="yes" xml:space="preserve">
          <source>Reference:  &lt;a href=&quot;http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&quot;&gt;http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参考：&lt;/font&gt;&lt;a href=&quot;http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;： &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ddc49f0f6adc2cd9d3bf460ac52d21542f4206c9" translate="yes" xml:space="preserve">
          <source>Regards,
Guus</source>
          <target state="translated">Regards,
Guus</target>
        </trans-unit>
        <trans-unit id="0e2f476037e1df44c739f0dcf843dcbb014c8ce9" translate="yes" xml:space="preserve">
          <source>So it works, although some of the new-fangly stuff mentioned elsewhere may be more performant.</source>
          <target state="translated">所以说,虽然在其他地方提到的一些新方的东西可能会有更大的表现,但还是很管用的。</target>
        </trans-unit>
        <trans-unit id="5abb1005b1df2014e64d5a3ea5204e066aa4d22d" translate="yes" xml:space="preserve">
          <source>Solution for MySQL which doesn't have concepts of partition KEEP, DENSE_RANK.</source>
          <target state="translated">MySQL没有分区KEEP、DENSE_RANK等概念的解决方案。</target>
        </trans-unit>
        <trans-unit id="a0ea07fd432672f88944816067af33a3b69a9dfd" translate="yes" xml:space="preserve">
          <source>Something like this, perhaps (can't remember if the column list should be parenthesised or not):</source>
          <target state="translated">大概是这样的吧(不记得列列表是否应该加括号了)。</target>
        </trans-unit>
        <trans-unit id="692eeda053a902d4e745a16c8a01f8e08799e9da" translate="yes" xml:space="preserve">
          <source>Table:</source>
          <target state="translated">Table:</target>
        </trans-unit>
        <trans-unit id="2ec91b0ba834071567a1b897882c5f8d7d2283a0" translate="yes" xml:space="preserve">
          <source>The above returns all the rows with max my_date per user.</source>
          <target state="translated">上面返回每个用户最大my_date的所有行。</target>
        </trans-unit>
        <trans-unit id="8d3e713aa786fc02e56c8895b9c1d995d120bebe" translate="yes" xml:space="preserve">
          <source>The answer here is Oracle only. Here's a bit more sophisticated answer in all SQL:</source>
          <target state="translated">这里的答案只有Oracle才有。以下是所有SQL中比较复杂的答案。</target>
        </trans-unit>
        <trans-unit id="4353e0def2ef1b8f34b3b1aa60bce748c3a87605" translate="yes" xml:space="preserve">
          <source>The code works.</source>
          <target state="translated">代码有效。</target>
        </trans-unit>
        <trans-unit id="001780d4c917b7750f44869c8b1a6078ab99dc2b" translate="yes" xml:space="preserve">
          <source>The reason why this code works so well is that it only needs to scan the table once. It does not require any indexes and most importantly it does not need to sort the table, which most analytics functions do. Indexes will help though if you need to filter the result for a single userid.</source>
          <target state="translated">这个代码之所以工作得这么好,是因为它只需要扫描一次表。它不需要任何索引,最重要的是它不需要对表进行排序,而大多数分析函数都是这样做的。如果你需要过滤单个用户ID的结果,索引会有帮助。</target>
        </trans-unit>
        <trans-unit id="c6014dffd001c57d401c4d7842342f05810101fc" translate="yes" xml:space="preserve">
          <source>The trick in this query is to design the join's matching condition such that &lt;code&gt;t2&lt;/code&gt; must match the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;userid&lt;/code&gt;, and a &lt;em&gt;greater&lt;/em&gt;&lt;code&gt;date&lt;/code&gt;.  The idea being if a row exists in &lt;code&gt;t2&lt;/code&gt; that has a greater &lt;code&gt;date&lt;/code&gt;, then the row in &lt;code&gt;t1&lt;/code&gt; it's compared against &lt;em&gt;can't&lt;/em&gt; be the greatest &lt;code&gt;date&lt;/code&gt; for that &lt;code&gt;userid&lt;/code&gt;.  But if there is no match -- i.e. if no row exists in &lt;code&gt;t2&lt;/code&gt; with a greater &lt;code&gt;date&lt;/code&gt; than the row in &lt;code&gt;t1&lt;/code&gt; -- we know that the row in &lt;code&gt;t1&lt;/code&gt; was the row with the greatest &lt;code&gt;date&lt;/code&gt; for the given &lt;code&gt;userid&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此查询的诀窍是设计联接的匹配条件，以使&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须匹配&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相同的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;userid&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更大的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果存在连续的想法是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有更大的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后在该行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它比较对&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不能&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是最大的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;userid&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果没有匹配项-即如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不存在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-我们知道&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是给定&lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最大的行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;userid&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74ec296dd8eea149cfea8dabc86cdbbe23944c02" translate="yes" xml:space="preserve">
          <source>The windowing clause is only applicable in the presence of the order by clause. With no order by clause, no windowing clause is applied by default and none can be explicitly specified.</source>
          <target state="translated">窗口化子句只适用于有顺序子句的情况下。如果没有订单子句,默认情况下不会应用窗口化子句,也不能明确指定任何窗口化子句。</target>
        </trans-unit>
        <trans-unit id="3f80e81ca09a8d54b3d7b1bc02b699033ba414d4" translate="yes" xml:space="preserve">
          <source>There is no self-join in this code. There is instead a predicate placed on the result of the inline view that contains the analytic function -- a very different matter, and completely standard practice.</source>
          <target state="translated">这个代码中没有自连接。相反,在包含分析函数的内联视图的结果上有一个谓词,这是一个非常不同的问题,也是完全标准的做法。</target>
        </trans-unit>
        <trans-unit id="417d65b805b35d5c15d4aea7b1f5ed9939b7c4f9" translate="yes" xml:space="preserve">
          <source>This is not a particularly spectacular example of analytic queries.  For a much bigger win consider taking a table of financial receipts and calculating for each user and receipt, a running total of what they paid.  Analytic queries solve that efficiently.  Other solutions are less efficient.  Which is why they are part of the 2003 SQL standard.  (Unfortunately Postgres doesn't have them yet.  Grrr...)</source>
          <target state="translated">这不是一个特别引人注目的分析性查询的例子。要想获得更大的胜利,可以考虑把一个财务收据的表格,并为每个用户和收据计算出他们所支付的总金额。分析性查询可以有效地解决这个问题。其他解决方案的效率较低。这就是为什么它们是2003年SQL标准的一部分。不幸的是,Postgres还没有这些功能。</target>
        </trans-unit>
        <trans-unit id="9b351c8e5383c024d336f4c4676d56ad1e01764a" translate="yes" xml:space="preserve">
          <source>This one supports multiple values for UserId on the &lt;strong&gt;same&lt;/strong&gt; date.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;日期&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同一&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;日期&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;支持UserId的多个值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d16f16a7850ad9d6fcbd08c93139735c8d1ea52" translate="yes" xml:space="preserve">
          <source>This should be as simple as:</source>
          <target state="translated">这应该很简单:</target>
        </trans-unit>
        <trans-unit id="74044189c4916dff7c911674a13790ac36611367" translate="yes" xml:space="preserve">
          <source>This will also take care of duplicates (return one row for each user_id):</source>
          <target state="translated">这也将处理重复的问题(每个用户ID返回一行)。</target>
        </trans-unit>
        <trans-unit id="1def462e50e268c36bf6f217bc5abc380ab0d78a" translate="yes" xml:space="preserve">
          <source>This will retrieve all rows for which the my_date column value is equal to the maximum value of my_date for that userid. This may retrieve multiple rows for the userid where the maximum date is on multiple rows.</source>
          <target state="translated">这将检索出所有my_date列值等于该用户ID的最大值的记录。当最大日期在多条记录上时,这可能会检索到多个用户ID的多条记录。</target>
        </trans-unit>
        <trans-unit id="5205e796ec7ffd8163ecb77f3c45f1fac6457576" translate="yes" xml:space="preserve">
          <source>Under the hood analytic queries sort the whole dataset, then process it sequentially.  As you process it you partition the dataset according to certain criteria, and then for each row looks at some window (defaults to the first value in the partition to the current row - that default is also the most efficient) and can compute values using a number of analytic functions (the list of which is very similar to the aggregate functions).</source>
          <target state="translated">在引擎盖下的分析查询对整个数据集进行排序,然后按顺序处理。在处理过程中,你会根据一定的标准对数据集进行分区,然后对每一行看一些窗口(默认为分区中的第一个值到当前行的第一个值--这个默认值也是最有效的),并可以使用一些分析函数来计算值(其列表与聚合函数非常相似)。</target>
        </trans-unit>
        <trans-unit id="486d2cd95331c431746adb0c34738a8f8fc649da" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://docs.oracle.com/database/121/SQLRF/functions170.htm&quot;&gt;&lt;code&gt;ROW_NUMBER()&lt;/code&gt;&lt;/a&gt; to assign a unique ranking on descending &lt;code&gt;Date&lt;/code&gt; for each &lt;code&gt;UserId&lt;/code&gt;, then filter to the first row for each &lt;code&gt;UserId&lt;/code&gt; (i.e., &lt;code&gt;ROW_NUMBER&lt;/code&gt; = 1).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/database/121/SQLRF/functions170.htm&quot;&gt; &lt;code&gt;ROW_NUMBER()&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为每个&lt;/font&gt; &lt;code&gt;UserId&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;在降序&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上分配唯一的排名&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后过滤到每个&lt;/font&gt; &lt;code&gt;UserId&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的第一行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（即&lt;/font&gt; &lt;code&gt;ROW_NUMBER&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; = 1）。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="634ddf9e50d4818ae830580634e53d59baaaaf8c" translate="yes" xml:space="preserve">
          <source>Who has the best overall homework result (maximum sum of homework points)?</source>
          <target state="translated">谁的家庭作业总成绩最好(家庭作业分数最高总和)?</target>
        </trans-unit>
        <trans-unit id="2d31c4f46226c06eebb0e3b640d209b7ca660ab2" translate="yes" xml:space="preserve">
          <source>With PostgreSQL 8.4 or later, you can use this:</source>
          <target state="translated">在PostgreSQL 8.4或更高的版本中,你可以使用这个。</target>
        </trans-unit>
        <trans-unit id="f64129fb961a33a22771978794a8e0a0d726116f" translate="yes" xml:space="preserve">
          <source>Wouldn't a QUALIFY clause be both simplest and best?</source>
          <target state="translated">QUALIFY条款不是最简单也是最好的吗?</target>
        </trans-unit>
        <trans-unit id="ffa6eb21d2116e5f16b555965563b9a6967dd503" translate="yes" xml:space="preserve">
          <source>You can use FIRST_VALUE instead of MAX and look it up in the explain plan. I didn't have the time to play with it.</source>
          <target state="translated">你可以用FIRST_VALUE代替MAX,在解释计划中查一下。我没时间玩了。</target>
        </trans-unit>
        <trans-unit id="8496c9898467401252142da5c395b4bd2148fb13" translate="yes" xml:space="preserve">
          <source>i thing you shuold make this variant to previous query:</source>
          <target state="translated">我想你应该把这个变体变成以前的查询。</target>
        </trans-unit>
        <trans-unit id="32f066ab49d567aa0dda290679007c2477ad1732" translate="yes" xml:space="preserve">
          <source>results:</source>
          <target state="translated">results:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
