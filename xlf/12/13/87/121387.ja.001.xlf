<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/121387">
    <body>
      <group id="121387">
        <trans-unit id="088d6bfd13fdd1c7523360c5e5bebc3ada83c101" translate="yes" xml:space="preserve">
          <source>&quot;Analytic functions rock&quot;</source>
          <target state="translated">&quot;分析機能はロック&quot;</target>
        </trans-unit>
        <trans-unit id="413da9addd1811fab78614e45fc2d047da891fce" translate="yes" xml:space="preserve">
          <source>&quot;The default window in Oracle is from the first row in the partition to the current one&quot;</source>
          <target state="translated">&quot;Oracleのデフォルトのウィンドウはパーティションの最初の行から現在の行までです&quot;</target>
        </trans-unit>
        <trans-unit id="e80f653c17fe6a899c1ae74484172eefa0dd0c5c" translate="yes" xml:space="preserve">
          <source>&quot;using analytic queries and a self-join defeats the purpose of analytic queries&quot;</source>
          <target state="translated">&quot;分析クエリと自己結合を使用すると、分析クエリの目的を打ち破る&quot;</target>
        </trans-unit>
        <trans-unit id="e3d423c44d0b57efd24da450f35feeed5c11ae47" translate="yes" xml:space="preserve">
          <source>(I put the identifier &quot;Date&quot; in delimiters because it's an SQL reserved word.)</source>
          <target state="translated">(識別子「Date」はSQL予約語なのでデリミタに入れました)</target>
        </trans-unit>
        <trans-unit id="58d03f6fac5b12cde98025a1436e9a3fd045c82a" translate="yes" xml:space="preserve">
          <source>(T-SQL) First get all the users and their maxdate. Join with the table to find the corresponding values for the users on the maxdates.</source>
          <target state="translated">(T-SQL)最初にすべてのユーザとその最大日付を取得します。テーブルに結合して、maxdatesのユーザの対応する値を見つけます。</target>
        </trans-unit>
        <trans-unit id="de6ab6da15e1403a174ce26bee9a06147f49f3f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; Apologies for any ambiguity: I need to get ALL the UserIds. But for each UserId, only that row where that user has the latest date.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更新：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あいまいさをお詫びし&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます：&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべてのユーザーIDを取得する必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、各UserIdについては、そのユーザーが最新の日付を持っている行のみ。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5253313e4d21a0c4fb3cf956b4c943650047fc54" translate="yes" xml:space="preserve">
          <source>Accepted answer</source>
          <target state="translated">受け入れられた答え</target>
        </trans-unit>
        <trans-unit id="fd0c7bcaca1e8f700846a874d952217de8ff9f3d" translate="yes" xml:space="preserve">
          <source>An outer join attempts to join &lt;code&gt;t1&lt;/code&gt; with &lt;code&gt;t2&lt;/code&gt;.  By default, all results of &lt;code&gt;t1&lt;/code&gt; are returned, and &lt;em&gt;if&lt;/em&gt; there is a match in &lt;code&gt;t2&lt;/code&gt;, it is also returned.  If there is no match in &lt;code&gt;t2&lt;/code&gt; for a given row of &lt;code&gt;t1&lt;/code&gt;, then the query still returns the row of &lt;code&gt;t1&lt;/code&gt;, and uses &lt;code&gt;NULL&lt;/code&gt; as a placeholder for all of &lt;code&gt;t2&lt;/code&gt;'s columns.  That's just how outer joins work in general.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;外部結合は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を結合しようとし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。デフォルトでは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべての結果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が返さ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;れます&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一致がある&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、それも返されます。&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特定の行に対して&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一致するものがない場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でも、クエリは&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;の行を返し、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべての&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;の列の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プレースホルダーとして&lt;/font&gt; &lt;code&gt;NULL&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これが、一般的に外部結合が機能する方法です。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fd49a5debb75caf7f1a7c5fdfdfdb817e1bea03e" translate="yes" xml:space="preserve">
          <source>And a more difficult example, which need some explanation, for which I don't have time atm:</source>
          <target state="translated">そして、もっと難しい例として、いくつかの説明を必要としていますが、私には時間がありません。</target>
        </trans-unit>
        <trans-unit id="904c7473e98d9c980acb1d06bbb7b004f1465dbc" translate="yes" xml:space="preserve">
          <source>Assuming Date is unique for a given UserID, here's some TSQL:</source>
          <target state="translated">与えられたUserIDに対してDateが一意であると仮定して、以下にいくつかのTSQLを示します。</target>
        </trans-unit>
        <trans-unit id="f6e3e2c62ae12a54199ac2ab1fff0081fedf5490" translate="yes" xml:space="preserve">
          <source>Both queries return the same results as the accepted answer. See SQLFiddles:</source>
          <target state="translated">どちらのクエリも、受け入れられた答えと同じ結果を返します。SQLFiddles を参照してください。</target>
        </trans-unit>
        <trans-unit id="b176631d670bf7d1d6f81ac328b2bbce2391928d" translate="yes" xml:space="preserve">
          <source>Columns:
UserId, Value, Date</source>
          <target state="translated">カラム。UserId、値、日付</target>
        </trans-unit>
        <trans-unit id="edbdf8261b8b53cd2c44f0e6bebecc51bc79ad98" translate="yes" xml:space="preserve">
          <source>EDIT: Also misread the question! Corrected the query...</source>
          <target state="translated">EDIT:また、質問を読み違えました クエリを修正しました...</target>
        </trans-unit>
        <trans-unit id="1ea6ef1589771cfbfbd0792b8c9dad50b8ca110e" translate="yes" xml:space="preserve">
          <source>EDIT: Just tried it for real:</source>
          <target state="translated">EDIT:ちょうどそれを実際に試してみました。</target>
        </trans-unit>
        <trans-unit id="b5b09b3e814746064c06e631b56dafa6faf9dbc2" translate="yes" xml:space="preserve">
          <source>Edit: With regard to the first comment ...</source>
          <target state="translated">編集:最初のコメントに関して・・・。</target>
        </trans-unit>
        <trans-unit id="ba3940b609eb3a39ab46f269a794269140341fff" translate="yes" xml:space="preserve">
          <source>Fetch the row which has the Max value for a column</source>
          <target state="translated">列の最大値を持つ行を取得します。</target>
        </trans-unit>
        <trans-unit id="1b260f18fab6eb46ce941a4a30f3fd2c37e1b125" translate="yes" xml:space="preserve">
          <source>First try I misread the question, following the top answer, here is a complete example with correct results:</source>
          <target state="translated">最初に試してみて、私はトップの答えに続いて、質問を誤読し、ここでは正しい結果を持つ完全な例です。</target>
        </trans-unit>
        <trans-unit id="eabe3a3e55f28b62b73250aedaee7ad6c8953f98" translate="yes" xml:space="preserve">
          <source>For context, on Teradata here a decent size test of this runs in 17s with this QUALIFY version and in 23s with the 'inline view'/Aldridge solution #1.</source>
          <target state="translated">文脈のために、Teradataでは、このQUALIFYバージョンでは17秒、Aldridgeソリューション#1の'インラインビュー'では23秒で実行されます。</target>
        </trans-unit>
        <trans-unit id="97456deba4b3218e51dd6451f33cd580f0c385eb" translate="yes" xml:space="preserve">
          <source>Give the book (ISBN and title) that is most popular in 2008, i.e., which is borrowed most often in 2008.</source>
          <target state="translated">2008年に最も人気のある本、つまり2008年に最も多く借りている本(ISBNとタイトル)を与えてください。</target>
        </trans-unit>
        <trans-unit id="408cc7448fc02af904bd8630ec14f49fe54d3430" translate="yes" xml:space="preserve">
          <source>Here's a more detailed explanation:</source>
          <target state="translated">ここでさらに詳しい説明をします。</target>
        </trans-unit>
        <trans-unit id="0e7723428750aa5b89daf45442ac23987c1eef2c" translate="yes" xml:space="preserve">
          <source>Hope this helps (anyone).. :)</source>
          <target state="translated">これが助けになることを願っています(誰でも):)</target>
        </trans-unit>
        <trans-unit id="2bbf482ff901d3844f91bfe54e66619489d39ca7" translate="yes" xml:space="preserve">
          <source>I don't have Oracle to test it, but the most efficient solution is to use analytic queries.  It should look something like this:</source>
          <target state="translated">テストするためのOracleは持っていませんが、最も効率的な解決策は分析クエリを使うことです。こんな感じになるはずです。</target>
        </trans-unit>
        <trans-unit id="17d726823c642c9f173dc0861e890311392528d5" translate="yes" xml:space="preserve">
          <source>I don't know your exact columns names, but it would be something like this:</source>
          <target state="translated">正確なカラム名はわかりませんが、以下のような感じになります。</target>
        </trans-unit>
        <trans-unit id="a1eff8ad086330ae5e1e2ee55b8de66b074d47e2" translate="yes" xml:space="preserve">
          <source>I know you asked for Oracle, but in SQL 2005 we now use this:</source>
          <target state="translated">Oracleを頼まれたのは知っていますが、SQL 2005ではこれを使うようになりました。</target>
        </trans-unit>
        <trans-unit id="b561086a4ee19bf7e418a63264c6e9c9fe3d5f3a" translate="yes" xml:space="preserve">
          <source>I see many people use subqueries or else vendor-specific features to do this, but I often do this kind of query without subqueries in the following way.  It uses plain, standard SQL so it should work in any brand of RDBMS.</source>
          <target state="translated">多くの人がサブクエリなどのベンダー固有の機能を使っているのを見かけるが、私は以下のようにサブクエリを使わずにこの種のクエリを行うことが多い。これはプレーンで標準的なSQLを使用しているので、どのブランドのRDBMSでも動作するはずです。</target>
        </trans-unit>
        <trans-unit id="d4b1e7b7cbe681b8954882bb2466203c755bea9e" translate="yes" xml:space="preserve">
          <source>I suspect that you can get rid of the outer query and put distinct on the inner, but I'm not sure.  In the meantime I know this one works.</source>
          <target state="translated">私は、外側のクエリを削除して、内側のクエリにdistinctを置くことができるのではないかと疑っていますが、私は確信していません。その間に、私はこれが動作することを知っています。</target>
        </trans-unit>
        <trans-unit id="878e6b6608d887b9531664f493478e9c59a33d15" translate="yes" xml:space="preserve">
          <source>I think something like this. (Forgive me for any syntax mistakes; I'm used to using HQL at this point!)</source>
          <target state="translated">私はこのようなことを考えています。(構文の間違いをお許しください。この時点でHQLを使い慣れています!)</target>
        </trans-unit>
        <trans-unit id="c0f8b758a6465f7c6be80b9cafc6e63879977c3b" translate="yes" xml:space="preserve">
          <source>I think this should work?</source>
          <target state="translated">これでいいのかな?</target>
        </trans-unit>
        <trans-unit id="8cbb409c988a6df1954d3c399c0b5414c6185821" translate="yes" xml:space="preserve">
          <source>I want to get the UserId, Value for the max(Date) for each UserId. That is, the Value for each UserId that has the latest date. Is there a way to do this simply in SQL? (Preferably Oracle)</source>
          <target state="translated">UserId,Value for the max(Date)for each UserIdを取得したい。つまり、最新の日付を持つ各UserIdのValueを取得したいのです。これをSQLで簡単に行う方法はありますか?(できればOracle)</target>
        </trans-unit>
        <trans-unit id="cd2ca7dae2209e0e59d6d3dd4b8f60e2dcc5cae9" translate="yes" xml:space="preserve">
          <source>I'm not familiar with Oracle. This is what I came up with</source>
          <target state="translated">オラクルには詳しくないのですが 思いついたのはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="490454b390a9bb71c5960d6bffae85a8d7596408" translate="yes" xml:space="preserve">
          <source>I'm quite late to the party but the following hack will outperform both correlated subqueries and any analytics function but has one restriction: values must convert to strings. So it works for dates, numbers and other strings. The code does not look good but the execution profile is great.</source>
          <target state="translated">かなり遅れての参加ですが、以下のハックは相関のある副問い合わせとあらゆる分析関数の両方を凌駕しますが、1つの制限があります:値は文字列に変換しなければなりません。つまり、日付、数字、その他の文字列で動作します。コードは良く見えませんが、実行プロファイルは素晴らしいです。</target>
        </trans-unit>
        <trans-unit id="650ac70d7051011690338160d400eb5df589f9db" translate="yes" xml:space="preserve">
          <source>IMHO this works. HTH</source>
          <target state="translated">IMHOこれが効く。HTH</target>
        </trans-unit>
        <trans-unit id="122ef6cf39940e2210618fd865896d0a4584120f" translate="yes" xml:space="preserve">
          <source>If (UserID, Date) is unique, i.e. no date appears twice for the same user then:</source>
          <target state="translated">(UserID,Date)が一意である場合、つまり、同じユーザーに対して日付が二重に表示されない場合。</target>
        </trans-unit>
        <trans-unit id="54b972ede6c9b119c5143cc8883f6f74091b5ebf" translate="yes" xml:space="preserve">
          <source>If you want only one row with max date, then replace the &lt;code&gt;rank&lt;/code&gt; with &lt;code&gt;row_number&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最大日付の1行のみが必要な場合は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rank&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt; &lt;code&gt;row_number&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;置き換え&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bdfe0d65369806ce41db47d66aa8148f91207fe" translate="yes" xml:space="preserve">
          <source>If you want to learn about analytic queries, I'd suggest reading &lt;a href=&quot;http://www.orafaq.com/node/55&quot;&gt;http://www.orafaq.com/node/55&lt;/a&gt; and &lt;strike&gt;&lt;a href=&quot;http://www.akadia.com/services/ora_analytic_functions.html&quot;&gt;http://www.akadia.com/services/ora_analytic_functions.html&lt;/a&gt;&lt;/strike&gt;.  Here is the short summary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分析クエリについて知りたい場合は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;strike&gt;&lt;a href=&quot;http://www.akadia.com/services/ora_analytic_functions.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http:&lt;/font&gt;&lt;/a&gt;&lt;/strike&gt;&lt;/font&gt;&lt;a href=&quot;http://www.orafaq.com/node/55&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; //www.orafaq.com/node/55&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;および&lt;/font&gt;&lt;/font&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.akadia.com/services/ora_analytic_functions.htmlを&lt;/font&gt;&lt;/font&gt;&lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;読むことをお勧め&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;し&lt;/font&gt;&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここに短い要約があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="944198ed78a48e6347cc0427c09b348bfacb86a2" translate="yes" xml:space="preserve">
          <source>If you're using Postgres, you can use &lt;code&gt;array_agg&lt;/code&gt; like</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Postgresを使用している場合は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;array_agg&lt;/code&gt; を次の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ように&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="458c3501c385ce8920f8fd35c19791e744639d2a" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;&lt;code&gt;Oracle 12c+&lt;/code&gt;&lt;/strong&gt;, you can use &lt;em&gt;Top n&lt;/em&gt; queries along with analytic function &lt;code&gt;rank&lt;/code&gt; to achieve this very concisely &lt;em&gt;without&lt;/em&gt; subqueries:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt; &lt;code&gt;Oracle 12c+&lt;/code&gt; &lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、使用することができます&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;トップN&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分析関数と一緒にクエリを&lt;/font&gt;&lt;/font&gt; &lt;code&gt;rank&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非常に簡潔これを達成するために&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;することなく、&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;サブクエリ：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c873798c90b4aa35114a37fda41e084ff1a6a67c" translate="yes" xml:space="preserve">
          <source>In case if &lt;code&gt;t1.&quot;Date&quot; = t2.&quot;Date&quot;&lt;/code&gt;, doubling appears. Usually tables has &lt;code&gt;auto_inc(seq)&lt;/code&gt; key, e.g. &lt;code&gt;id&lt;/code&gt;.
To avoid doubling can be used follows:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下の場合であれば&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1.&quot;Date&quot; = t2.&quot;Date&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、倍増が表示されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常のテーブルがあり&lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_inc(seq)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、キー、例えば&lt;/font&gt;&lt;/font&gt; &lt;code&gt;id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重複を回避するには、次のように使用できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c8bae46c2bd19848ac4027530c6be507061b142a" translate="yes" xml:space="preserve">
          <source>In other words: fetch the row from &lt;code&gt;t1&lt;/code&gt; where no other row exists with the same &lt;code&gt;UserId&lt;/code&gt; and a greater Date.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つまり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、同じ&lt;/font&gt; &lt;code&gt;UserId&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;とより大きい日付を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;持つ他の行が存在しない&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から行をフェッチし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ecb6427a441808e4acda1af43f82bf01e1e93d7d" translate="yes" xml:space="preserve">
          <source>In this case here is what the inner query does.  The whole dataset is sorted by UserId then Date DESC.  Then it processes it in one pass.  For each row you return the UserId and the first Date seen for that UserId (since dates are sorted DESC, that's the max date).  This gives you your answer with duplicated rows.  Then the outer DISTINCT squashes duplicates.</source>
          <target state="translated">この場合、内部クエリが行うことは次のようになります。データセット全体がUserIdでソートされ、次にDate DESCでソートされます。そして、それを一度に処理します。各行に対して UserId と、その UserId で最初に見た Date を返します (日付は DESC でソートされているので、それが最大の日付となります)。これにより、重複した行を含む回答が得られます。そして、外側のDISTINCTが重複を排除します。</target>
        </trans-unit>
        <trans-unit id="402085a89e3d90f5847116008a388b9c03c122c3" translate="yes" xml:space="preserve">
          <source>In those cases (when there's no match), the columns of &lt;code&gt;t2&lt;/code&gt; will be &lt;code&gt;NULL&lt;/code&gt; -- even the columns specified in the join condition.  So that's why we use &lt;code&gt;WHERE t2.UserId IS NULL&lt;/code&gt;, because we're searching for the cases where no row was found with a greater &lt;code&gt;date&lt;/code&gt; for the given &lt;code&gt;userid&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それらの場合（一致がない場合）、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の列は、結合条件で指定された列であっても&lt;/font&gt;&lt;/font&gt; &lt;code&gt;NULL&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;になり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのため、ここでは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;WHERE t2.UserId IS NULL&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ています&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、指定された&lt;/font&gt;&lt;/font&gt; &lt;code&gt;userid&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;日付&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それよりも長い行が見つからなかった場合を検索するためです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cff87308f0f5a44185f055a550f067dcf137883" translate="yes" xml:space="preserve">
          <source>Just had to write a &quot;live&quot; example at work :)</source>
          <target state="translated">仕事で「生きた」例を書かなければならなかっただけです。)</target>
        </trans-unit>
        <trans-unit id="b6a63b1d6787b611e979efb5a06d6ad2f19ac027" translate="yes" xml:space="preserve">
          <source>Just tested this and it seems to work on a logging table</source>
          <target state="translated">これをテストしただけですが、ロギングテーブルで動作するようです。</target>
        </trans-unit>
        <trans-unit id="9924f5c47b2ff7e5e41049935735440618c1048d" translate="yes" xml:space="preserve">
          <source>My solution with Oracle</source>
          <target state="translated">オラクルを使った私のソリューション</target>
        </trans-unit>
        <trans-unit id="0854d80218ef44ea7683517c112af7afa0afb923" translate="yes" xml:space="preserve">
          <source>My solution with Postgres</source>
          <target state="translated">Postgresでの解決策</target>
        </trans-unit>
        <trans-unit id="6d7d9479e022df45c509f62303629e302818e343" translate="yes" xml:space="preserve">
          <source>Not being at work, I don't have Oracle to hand, but I seem to recall that Oracle allows multiple columns to be matched in an IN clause, which should at least avoid the options that use a correlated subquery, which is seldom a good idea.</source>
          <target state="translated">仕事ではない、私は手にOracleを持っていないが、私は、Oracleは、少なくとも相関副問い合わせを使用してオプションを避ける必要がありますIN句で一致するように複数の列を許可することを思い出すようだが、これはめったに良いアイデアではありませんが、相関副問い合わせを使用してオプションを避ける必要があります。</target>
        </trans-unit>
        <trans-unit id="78f19667512f67f6edbd1038c70b7a9d51178f51" translate="yes" xml:space="preserve">
          <source>Of course, if searching through huge tables, it's probably better if you use FULL hints in your query.</source>
          <target state="translated">もちろん、巨大なテーブルを検索する場合は、クエリにFULLヒントを使用した方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="3a99454b317198c63b1df2fb84afc34bca04b1da" translate="yes" xml:space="preserve">
          <source>Re comment from @Farhan:</source>
          <target state="translated">Re:@Farhanさんからのコメントです。</target>
        </trans-unit>
        <trans-unit id="91dd7bf9acb8e164d089c0b82ff5455ebf0e4e1b" translate="yes" xml:space="preserve">
          <source>Reference:  &lt;a href=&quot;http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&quot;&gt;http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;リファレンス：&lt;/font&gt;&lt;a href=&quot;http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ddc49f0f6adc2cd9d3bf460ac52d21542f4206c9" translate="yes" xml:space="preserve">
          <source>Regards,
Guus</source>
          <target state="translated">Regards,
Guus</target>
        </trans-unit>
        <trans-unit id="0e2f476037e1df44c739f0dcf843dcbb014c8ce9" translate="yes" xml:space="preserve">
          <source>So it works, although some of the new-fangly stuff mentioned elsewhere may be more performant.</source>
          <target state="translated">だから、他の場所で言及されている新しいファンキーなもののいくつかは、よりパフォーマンスが高いかもしれませんが、それは動作します。</target>
        </trans-unit>
        <trans-unit id="5abb1005b1df2014e64d5a3ea5204e066aa4d22d" translate="yes" xml:space="preserve">
          <source>Solution for MySQL which doesn't have concepts of partition KEEP, DENSE_RANK.</source>
          <target state="translated">パーティションKEEP、DENSE_RANKの概念を持たないMySQLのソリューション。</target>
        </trans-unit>
        <trans-unit id="a0ea07fd432672f88944816067af33a3b69a9dfd" translate="yes" xml:space="preserve">
          <source>Something like this, perhaps (can't remember if the column list should be parenthesised or not):</source>
          <target state="translated">こんな感じでしょうか(カラムリストを括弧で括るべきかどうかは覚えていません)。</target>
        </trans-unit>
        <trans-unit id="692eeda053a902d4e745a16c8a01f8e08799e9da" translate="yes" xml:space="preserve">
          <source>Table:</source>
          <target state="translated">Table:</target>
        </trans-unit>
        <trans-unit id="2ec91b0ba834071567a1b897882c5f8d7d2283a0" translate="yes" xml:space="preserve">
          <source>The above returns all the rows with max my_date per user.</source>
          <target state="translated">上記は、ユーザごとに最大のmy_dateを持つすべての行を返します。</target>
        </trans-unit>
        <trans-unit id="8d3e713aa786fc02e56c8895b9c1d995d120bebe" translate="yes" xml:space="preserve">
          <source>The answer here is Oracle only. Here's a bit more sophisticated answer in all SQL:</source>
          <target state="translated">ここでの答えはOracleのみです。ここではもう少し洗練された答えを全SQLで。</target>
        </trans-unit>
        <trans-unit id="4353e0def2ef1b8f34b3b1aa60bce748c3a87605" translate="yes" xml:space="preserve">
          <source>The code works.</source>
          <target state="translated">コードは機能しています。</target>
        </trans-unit>
        <trans-unit id="001780d4c917b7750f44869c8b1a6078ab99dc2b" translate="yes" xml:space="preserve">
          <source>The reason why this code works so well is that it only needs to scan the table once. It does not require any indexes and most importantly it does not need to sort the table, which most analytics functions do. Indexes will help though if you need to filter the result for a single userid.</source>
          <target state="translated">このコードが非常にうまく機能する理由は、テーブルを一度だけスキャンする必要があるからです。インデックスを必要とせず、最も重要なのは、ほとんどの分析関数が行うようなテーブルのソートを必要としないことです。単一のユーザーIDの結果をフィルタリングする必要がある場合は、インデックスが役立ちます。</target>
        </trans-unit>
        <trans-unit id="c6014dffd001c57d401c4d7842342f05810101fc" translate="yes" xml:space="preserve">
          <source>The trick in this query is to design the join's matching condition such that &lt;code&gt;t2&lt;/code&gt; must match the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;userid&lt;/code&gt;, and a &lt;em&gt;greater&lt;/em&gt;&lt;code&gt;date&lt;/code&gt;.  The idea being if a row exists in &lt;code&gt;t2&lt;/code&gt; that has a greater &lt;code&gt;date&lt;/code&gt;, then the row in &lt;code&gt;t1&lt;/code&gt; it's compared against &lt;em&gt;can't&lt;/em&gt; be the greatest &lt;code&gt;date&lt;/code&gt; for that &lt;code&gt;userid&lt;/code&gt;.  But if there is no match -- i.e. if no row exists in &lt;code&gt;t2&lt;/code&gt; with a greater &lt;code&gt;date&lt;/code&gt; than the row in &lt;code&gt;t1&lt;/code&gt; -- we know that the row in &lt;code&gt;t1&lt;/code&gt; was the row with the greatest &lt;code&gt;date&lt;/code&gt; for the given &lt;code&gt;userid&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このクエリの秘訣は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同じ&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;userid&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;より大きな&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一致するように結合の一致条件を設計&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;する&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;こと&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行が中に存在する場合、アイデアは、ある&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;より大きいの持つ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で、行、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それが比較だ&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ができない&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最大こと&lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのための&lt;/font&gt;&lt;/font&gt; &lt;code&gt;userid&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、一致するものが存在しない場合-つまり何行が中に存在しない場合&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大きいので&lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の行よりも&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -我々は内の行ということを知っている&lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; が&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最大と行だった&lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与えられたため&lt;/font&gt;&lt;/font&gt; &lt;code&gt;userid&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74ec296dd8eea149cfea8dabc86cdbbe23944c02" translate="yes" xml:space="preserve">
          <source>The windowing clause is only applicable in the presence of the order by clause. With no order by clause, no windowing clause is applied by default and none can be explicitly specified.</source>
          <target state="translated">ウインドウイング句は、order by句の存在下でのみ適用されます。order by 句がない場合、windowing 句はデフォルトでは適用されず、明示的に指定することもできません。</target>
        </trans-unit>
        <trans-unit id="3f80e81ca09a8d54b3d7b1bc02b699033ba414d4" translate="yes" xml:space="preserve">
          <source>There is no self-join in this code. There is instead a predicate placed on the result of the inline view that contains the analytic function -- a very different matter, and completely standard practice.</source>
          <target state="translated">このコードには自己結合はありません。その代わりに、分析関数を含むインラインビューの結果に述語が置かれています。</target>
        </trans-unit>
        <trans-unit id="417d65b805b35d5c15d4aea7b1f5ed9939b7c4f9" translate="yes" xml:space="preserve">
          <source>This is not a particularly spectacular example of analytic queries.  For a much bigger win consider taking a table of financial receipts and calculating for each user and receipt, a running total of what they paid.  Analytic queries solve that efficiently.  Other solutions are less efficient.  Which is why they are part of the 2003 SQL standard.  (Unfortunately Postgres doesn't have them yet.  Grrr...)</source>
          <target state="translated">これは、分析クエリの特に目を見張るような例ではありません。より大きな利益を得るためには、財務レシートのテーブルを取って、各ユーザーとレシートごとに、そのユーザーが支払った金額の合計を計算することを考えてみてください。分析クエリはこれを効率的に解決します。他のソリューションは効率的ではありません。これが2003年のSQL標準の一部となっている理由です。残念ながらPostgresにはまだありません。</target>
        </trans-unit>
        <trans-unit id="9b351c8e5383c024d336f4c4676d56ad1e01764a" translate="yes" xml:space="preserve">
          <source>This one supports multiple values for UserId on the &lt;strong&gt;same&lt;/strong&gt; date.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同じ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;日付の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;UserIdの複数の値をサポートし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d16f16a7850ad9d6fcbd08c93139735c8d1ea52" translate="yes" xml:space="preserve">
          <source>This should be as simple as:</source>
          <target state="translated">と同じくらい簡単なはずです。</target>
        </trans-unit>
        <trans-unit id="74044189c4916dff7c911674a13790ac36611367" translate="yes" xml:space="preserve">
          <source>This will also take care of duplicates (return one row for each user_id):</source>
          <target state="translated">これは重複も処理します(各user_idに対して1行を返します)。</target>
        </trans-unit>
        <trans-unit id="1def462e50e268c36bf6f217bc5abc380ab0d78a" translate="yes" xml:space="preserve">
          <source>This will retrieve all rows for which the my_date column value is equal to the maximum value of my_date for that userid. This may retrieve multiple rows for the userid where the maximum date is on multiple rows.</source>
          <target state="translated">これは、my_date列の値がそのユーザIDのmy_dateの最大値と等しいすべての行を取得します。これは、日付の最大値が複数の行にあるユーザーIDについて、複数の行を取得することができます。</target>
        </trans-unit>
        <trans-unit id="5205e796ec7ffd8163ecb77f3c45f1fac6457576" translate="yes" xml:space="preserve">
          <source>Under the hood analytic queries sort the whole dataset, then process it sequentially.  As you process it you partition the dataset according to certain criteria, and then for each row looks at some window (defaults to the first value in the partition to the current row - that default is also the most efficient) and can compute values using a number of analytic functions (the list of which is very similar to the aggregate functions).</source>
          <target state="translated">分析クエリは、データセット全体をソートし、それを順次処理します。データセットを処理する際には、特定の基準に従ってデータセットをパーティショニングし、各行のウィンドウを見て (デフォルトは現在の行へのパーティショニングの最初の値になります-このデフォルトが最も効率的です)、多くの解析関数を使用して値を計算することができます (そのリストは集約関数と非常によく似ています)。</target>
        </trans-unit>
        <trans-unit id="486d2cd95331c431746adb0c34738a8f8fc649da" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://docs.oracle.com/database/121/SQLRF/functions170.htm&quot;&gt;&lt;code&gt;ROW_NUMBER()&lt;/code&gt;&lt;/a&gt; to assign a unique ranking on descending &lt;code&gt;Date&lt;/code&gt; for each &lt;code&gt;UserId&lt;/code&gt;, then filter to the first row for each &lt;code&gt;UserId&lt;/code&gt; (i.e., &lt;code&gt;ROW_NUMBER&lt;/code&gt; = 1).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/database/121/SQLRF/functions170.htm&quot;&gt; &lt;code&gt;ROW_NUMBER()&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;固有の降順にランク割り当てる&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;各々に対する&lt;/font&gt;&lt;/font&gt; &lt;code&gt;UserId&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それぞれの最初の行に、次に、フィルタ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;UserId&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（すなわち、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ROW_NUMBER&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = 1）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="634ddf9e50d4818ae830580634e53d59baaaaf8c" translate="yes" xml:space="preserve">
          <source>Who has the best overall homework result (maximum sum of homework points)?</source>
          <target state="translated">宿題の総合成績(宿題の点数の最大合計)が一番良いのは誰ですか?</target>
        </trans-unit>
        <trans-unit id="2d31c4f46226c06eebb0e3b640d209b7ca660ab2" translate="yes" xml:space="preserve">
          <source>With PostgreSQL 8.4 or later, you can use this:</source>
          <target state="translated">PostgreSQL 8.4以降では、これが使えます。</target>
        </trans-unit>
        <trans-unit id="f64129fb961a33a22771978794a8e0a0d726116f" translate="yes" xml:space="preserve">
          <source>Wouldn't a QUALIFY clause be both simplest and best?</source>
          <target state="translated">QUALIFY句が一番シンプルで最高なのではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="ffa6eb21d2116e5f16b555965563b9a6967dd503" translate="yes" xml:space="preserve">
          <source>You can use FIRST_VALUE instead of MAX and look it up in the explain plan. I didn't have the time to play with it.</source>
          <target state="translated">maxではなくfirst_valueを使って、説明プランで調べてみてください。遊ぶ時間がなかったので。</target>
        </trans-unit>
        <trans-unit id="8496c9898467401252142da5c395b4bd2148fb13" translate="yes" xml:space="preserve">
          <source>i thing you shuold make this variant to previous query:</source>
          <target state="translated">私はあなたが前のクエリにこのバリアントを作成することをshuoldと思います。</target>
        </trans-unit>
        <trans-unit id="32f066ab49d567aa0dda290679007c2477ad1732" translate="yes" xml:space="preserve">
          <source>results:</source>
          <target state="translated">results:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
