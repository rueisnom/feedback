<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/121387">
    <body>
      <group id="121387">
        <trans-unit id="088d6bfd13fdd1c7523360c5e5bebc3ada83c101" translate="yes" xml:space="preserve">
          <source>&quot;Analytic functions rock&quot;</source>
          <target state="translated">&quot;Las funciones analíticas rockean&quot;</target>
        </trans-unit>
        <trans-unit id="413da9addd1811fab78614e45fc2d047da891fce" translate="yes" xml:space="preserve">
          <source>&quot;The default window in Oracle is from the first row in the partition to the current one&quot;</source>
          <target state="translated">&quot;La ventana por defecto en el Oráculo es desde la primera fila de la partición hasta la actual&quot;</target>
        </trans-unit>
        <trans-unit id="e80f653c17fe6a899c1ae74484172eefa0dd0c5c" translate="yes" xml:space="preserve">
          <source>&quot;using analytic queries and a self-join defeats the purpose of analytic queries&quot;</source>
          <target state="translated">&quot;El uso de consultas analíticas y una auto-unión derrota el propósito de las consultas analíticas&quot;</target>
        </trans-unit>
        <trans-unit id="e3d423c44d0b57efd24da450f35feeed5c11ae47" translate="yes" xml:space="preserve">
          <source>(I put the identifier &quot;Date&quot; in delimiters because it's an SQL reserved word.)</source>
          <target state="translated">(Puse el identificador &quot;Fecha&quot; en los delimitadores porque es una palabra reservada de SQL.)</target>
        </trans-unit>
        <trans-unit id="58d03f6fac5b12cde98025a1436e9a3fd045c82a" translate="yes" xml:space="preserve">
          <source>(T-SQL) First get all the users and their maxdate. Join with the table to find the corresponding values for the users on the maxdates.</source>
          <target state="translated">(T-SQL)Primero consigue todos los usuarios y su maxdate.Únete a la tabla para encontrar los valores correspondientes a los usuarios en los maxdates.</target>
        </trans-unit>
        <trans-unit id="de6ab6da15e1403a174ce26bee9a06147f49f3f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; Apologies for any ambiguity: I need to get ALL the UserIds. But for each UserId, only that row where that user has the latest date.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Actualizaci&amp;oacute;n:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; disculpas por cualquier ambig&amp;uuml;edad: necesito obtener TODOS los ID de usuario. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero para cada UserId, solo esa fila donde ese usuario tiene la &amp;uacute;ltima fecha.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5253313e4d21a0c4fb3cf956b4c943650047fc54" translate="yes" xml:space="preserve">
          <source>Accepted answer</source>
          <target state="translated">Respuesta aceptada</target>
        </trans-unit>
        <trans-unit id="fd0c7bcaca1e8f700846a874d952217de8ff9f3d" translate="yes" xml:space="preserve">
          <source>An outer join attempts to join &lt;code&gt;t1&lt;/code&gt; with &lt;code&gt;t2&lt;/code&gt;.  By default, all results of &lt;code&gt;t1&lt;/code&gt; are returned, and &lt;em&gt;if&lt;/em&gt; there is a match in &lt;code&gt;t2&lt;/code&gt;, it is also returned.  If there is no match in &lt;code&gt;t2&lt;/code&gt; for a given row of &lt;code&gt;t1&lt;/code&gt;, then the query still returns the row of &lt;code&gt;t1&lt;/code&gt;, and uses &lt;code&gt;NULL&lt;/code&gt; as a placeholder for all of &lt;code&gt;t2&lt;/code&gt;'s columns.  That's just how outer joins work in general.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una combinaci&amp;oacute;n externa intenta unir &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Por defecto, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;se devuelven &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;todos los resultados de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;si&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; hay una coincidencia en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , tambi&amp;eacute;n se devuelve. Si no hay coincidencia en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para una fila dada de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , la consulta a&amp;uacute;n devuelve la fila de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y usa &lt;/font&gt;&lt;/font&gt; &lt;code&gt;NULL&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como marcador de posici&amp;oacute;n para todas &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;las columnas &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . As&amp;iacute; es como funcionan las uniones externas en general.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fd49a5debb75caf7f1a7c5fdfdfdb817e1bea03e" translate="yes" xml:space="preserve">
          <source>And a more difficult example, which need some explanation, for which I don't have time atm:</source>
          <target state="translated">Y un ejemplo más difícil,que necesita alguna explicación,para el cual no tengo tiempo atm:</target>
        </trans-unit>
        <trans-unit id="904c7473e98d9c980acb1d06bbb7b004f1465dbc" translate="yes" xml:space="preserve">
          <source>Assuming Date is unique for a given UserID, here's some TSQL:</source>
          <target state="translated">Asumiendo que la fecha es única para un determinado ID de usuario,aquí hay algo de TSQL:</target>
        </trans-unit>
        <trans-unit id="f6e3e2c62ae12a54199ac2ab1fff0081fedf5490" translate="yes" xml:space="preserve">
          <source>Both queries return the same results as the accepted answer. See SQLFiddles:</source>
          <target state="translated">Ambas consultas devuelven los mismos resultados que la respuesta aceptada.Ver SQLFiddles:</target>
        </trans-unit>
        <trans-unit id="b176631d670bf7d1d6f81ac328b2bbce2391928d" translate="yes" xml:space="preserve">
          <source>Columns:
UserId, Value, Date</source>
          <target state="translated">Columnas:UserId,Valor,Fecha</target>
        </trans-unit>
        <trans-unit id="edbdf8261b8b53cd2c44f0e6bebecc51bc79ad98" translate="yes" xml:space="preserve">
          <source>EDIT: Also misread the question! Corrected the query...</source>
          <target state="translated">EDITORIAL:¡También leyó mal la pregunta! Corregido la pregunta...</target>
        </trans-unit>
        <trans-unit id="1ea6ef1589771cfbfbd0792b8c9dad50b8ca110e" translate="yes" xml:space="preserve">
          <source>EDIT: Just tried it for real:</source>
          <target state="translated">EDITORIAL:Acabo de intentarlo de verdad:</target>
        </trans-unit>
        <trans-unit id="b5b09b3e814746064c06e631b56dafa6faf9dbc2" translate="yes" xml:space="preserve">
          <source>Edit: With regard to the first comment ...</source>
          <target state="translated">Edición:Con respecto al primer comentario...</target>
        </trans-unit>
        <trans-unit id="ba3940b609eb3a39ab46f269a794269140341fff" translate="yes" xml:space="preserve">
          <source>Fetch the row which has the Max value for a column</source>
          <target state="translated">Busca la fila que tiene el valor máximo para una columna</target>
        </trans-unit>
        <trans-unit id="1b260f18fab6eb46ce941a4a30f3fd2c37e1b125" translate="yes" xml:space="preserve">
          <source>First try I misread the question, following the top answer, here is a complete example with correct results:</source>
          <target state="translated">En el primer intento leí mal la pregunta,siguiendo la respuesta de arriba,aquí hay un ejemplo completo con los resultados correctos:</target>
        </trans-unit>
        <trans-unit id="eabe3a3e55f28b62b73250aedaee7ad6c8953f98" translate="yes" xml:space="preserve">
          <source>For context, on Teradata here a decent size test of this runs in 17s with this QUALIFY version and in 23s with the 'inline view'/Aldridge solution #1.</source>
          <target state="translated">Para el contexto,en Teradata aquí una prueba de tamaño decente de esto funciona en 17s con esta versión QUALIFY y en 23s con la solución #1 de Aldridge &quot;inline view&quot;.</target>
        </trans-unit>
        <trans-unit id="97456deba4b3218e51dd6451f33cd580f0c385eb" translate="yes" xml:space="preserve">
          <source>Give the book (ISBN and title) that is most popular in 2008, i.e., which is borrowed most often in 2008.</source>
          <target state="translated">Dar el libro (ISBN y título)que es más popular en 2008,es decir,que se presta más a menudo en 2008.</target>
        </trans-unit>
        <trans-unit id="408cc7448fc02af904bd8630ec14f49fe54d3430" translate="yes" xml:space="preserve">
          <source>Here's a more detailed explanation:</source>
          <target state="translated">Aquí hay una explicación más detallada:</target>
        </trans-unit>
        <trans-unit id="0e7723428750aa5b89daf45442ac23987c1eef2c" translate="yes" xml:space="preserve">
          <source>Hope this helps (anyone).. :)</source>
          <target state="translated">Espero que esto ayude (a cualquiera)...:)</target>
        </trans-unit>
        <trans-unit id="2bbf482ff901d3844f91bfe54e66619489d39ca7" translate="yes" xml:space="preserve">
          <source>I don't have Oracle to test it, but the most efficient solution is to use analytic queries.  It should look something like this:</source>
          <target state="translated">No tengo a Oracle para probarlo,pero la solución más eficiente es usar consultas analíticas.Debería verse algo como esto:</target>
        </trans-unit>
        <trans-unit id="17d726823c642c9f173dc0861e890311392528d5" translate="yes" xml:space="preserve">
          <source>I don't know your exact columns names, but it would be something like this:</source>
          <target state="translated">No sé los nombres exactos de sus columnas,pero sería algo así:</target>
        </trans-unit>
        <trans-unit id="a1eff8ad086330ae5e1e2ee55b8de66b074d47e2" translate="yes" xml:space="preserve">
          <source>I know you asked for Oracle, but in SQL 2005 we now use this:</source>
          <target state="translated">Sé que pediste a Oracle,pero en SQL 2005 ahora usamos esto:</target>
        </trans-unit>
        <trans-unit id="b561086a4ee19bf7e418a63264c6e9c9fe3d5f3a" translate="yes" xml:space="preserve">
          <source>I see many people use subqueries or else vendor-specific features to do this, but I often do this kind of query without subqueries in the following way.  It uses plain, standard SQL so it should work in any brand of RDBMS.</source>
          <target state="translated">Veo que muchas personas utilizan subconsultas o bien características específicas del proveedor para hacerlo,pero a menudo hago este tipo de consulta sin subconsultas de la siguiente manera.Utiliza SQL estándar,por lo que debería funcionar en cualquier marca de SGBDR.</target>
        </trans-unit>
        <trans-unit id="d4b1e7b7cbe681b8954882bb2466203c755bea9e" translate="yes" xml:space="preserve">
          <source>I suspect that you can get rid of the outer query and put distinct on the inner, but I'm not sure.  In the meantime I know this one works.</source>
          <target state="translated">Sospecho que puede deshacerse de la consulta externa y poner distintivo en la interna,pero no estoy seguro.Mientras tanto,sé que esta funciona.</target>
        </trans-unit>
        <trans-unit id="878e6b6608d887b9531664f493478e9c59a33d15" translate="yes" xml:space="preserve">
          <source>I think something like this. (Forgive me for any syntax mistakes; I'm used to using HQL at this point!)</source>
          <target state="translated">Creo que algo así.(Perdóneme por cualquier error de sintaxis;¡estoy acostumbrado a usar HQL en este punto!)</target>
        </trans-unit>
        <trans-unit id="c0f8b758a6465f7c6be80b9cafc6e63879977c3b" translate="yes" xml:space="preserve">
          <source>I think this should work?</source>
          <target state="translated">Creo que esto debería funcionar.</target>
        </trans-unit>
        <trans-unit id="8cbb409c988a6df1954d3c399c0b5414c6185821" translate="yes" xml:space="preserve">
          <source>I want to get the UserId, Value for the max(Date) for each UserId. That is, the Value for each UserId that has the latest date. Is there a way to do this simply in SQL? (Preferably Oracle)</source>
          <target state="translated">Quiero obtener el UserId,Valor para el max(Fecha)para cada UserId.Es decir,el valor para cada UserId que tenga la última fecha.¿Hay alguna manera de hacer esto simplemente en SQL? (Preferentemente Oracle)</target>
        </trans-unit>
        <trans-unit id="cd2ca7dae2209e0e59d6d3dd4b8f60e2dcc5cae9" translate="yes" xml:space="preserve">
          <source>I'm not familiar with Oracle. This is what I came up with</source>
          <target state="translated">No estoy familiarizado con el Oráculo.Esto es lo que se me ocurrió</target>
        </trans-unit>
        <trans-unit id="490454b390a9bb71c5960d6bffae85a8d7596408" translate="yes" xml:space="preserve">
          <source>I'm quite late to the party but the following hack will outperform both correlated subqueries and any analytics function but has one restriction: values must convert to strings. So it works for dates, numbers and other strings. The code does not look good but the execution profile is great.</source>
          <target state="translated">Llego bastante tarde a la fiesta pero el siguiente hack superará tanto las subconsultas correlacionadas como cualquier función de análisis pero tiene una restricción:los valores deben convertirse en cadenas.Así que funciona para fechas,números y otras cadenas.El código no se ve bien pero el perfil de ejecución es genial.</target>
        </trans-unit>
        <trans-unit id="650ac70d7051011690338160d400eb5df589f9db" translate="yes" xml:space="preserve">
          <source>IMHO this works. HTH</source>
          <target state="translated">IMHO esto funciona.HTH</target>
        </trans-unit>
        <trans-unit id="122ef6cf39940e2210618fd865896d0a4584120f" translate="yes" xml:space="preserve">
          <source>If (UserID, Date) is unique, i.e. no date appears twice for the same user then:</source>
          <target state="translated">Si (UserID,Date)es único,es decir,no aparece ninguna fecha dos veces para el mismo usuario entonces:</target>
        </trans-unit>
        <trans-unit id="54b972ede6c9b119c5143cc8883f6f74091b5ebf" translate="yes" xml:space="preserve">
          <source>If you want only one row with max date, then replace the &lt;code&gt;rank&lt;/code&gt; with &lt;code&gt;row_number&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si solo desea una fila con la fecha m&amp;aacute;xima, reemplace el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rank&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;row_number&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bdfe0d65369806ce41db47d66aa8148f91207fe" translate="yes" xml:space="preserve">
          <source>If you want to learn about analytic queries, I'd suggest reading &lt;a href=&quot;http://www.orafaq.com/node/55&quot;&gt;http://www.orafaq.com/node/55&lt;/a&gt; and &lt;strike&gt;&lt;a href=&quot;http://www.akadia.com/services/ora_analytic_functions.html&quot;&gt;http://www.akadia.com/services/ora_analytic_functions.html&lt;/a&gt;&lt;/strike&gt;.  Here is the short summary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si desea obtener informaci&amp;oacute;n sobre consultas anal&amp;iacute;ticas, le sugiero que lea &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.orafaq.com/node/55&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.orafaq.com/node/55&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt;&lt;strike&gt;&lt;a href=&quot;http://www.akadia.com/services/ora_analytic_functions.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.akadia.com/services/ora_analytic_functions.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; est&amp;aacute; el breve resumen.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="944198ed78a48e6347cc0427c09b348bfacb86a2" translate="yes" xml:space="preserve">
          <source>If you're using Postgres, you can use &lt;code&gt;array_agg&lt;/code&gt; like</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si est&amp;aacute; usando Postgres, puede usar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;array_agg&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="458c3501c385ce8920f8fd35c19791e744639d2a" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;&lt;code&gt;Oracle 12c+&lt;/code&gt;&lt;/strong&gt;, you can use &lt;em&gt;Top n&lt;/em&gt; queries along with analytic function &lt;code&gt;rank&lt;/code&gt; to achieve this very concisely &lt;em&gt;without&lt;/em&gt; subqueries:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En &lt;/font&gt;&lt;/font&gt;&lt;strong&gt; &lt;code&gt;Oracle 12c+&lt;/code&gt; &lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , puede usar las &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;consultas &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Top n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; junto con el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;rank&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; funci&amp;oacute;n anal&amp;iacute;tica &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;para lograr esto de manera concisa &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sin&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; subconsultas:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c873798c90b4aa35114a37fda41e084ff1a6a67c" translate="yes" xml:space="preserve">
          <source>In case if &lt;code&gt;t1.&quot;Date&quot; = t2.&quot;Date&quot;&lt;/code&gt;, doubling appears. Usually tables has &lt;code&gt;auto_inc(seq)&lt;/code&gt; key, e.g. &lt;code&gt;id&lt;/code&gt;.
To avoid doubling can be used follows:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En caso de que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1.&quot;Date&quot; = t2.&quot;Date&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , aparece el doble. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo general, las tablas tienen la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;auto_inc(seq)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por ejemplo, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;id&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para evitar duplicar se puede utilizar de la siguiente manera:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c8bae46c2bd19848ac4027530c6be507061b142a" translate="yes" xml:space="preserve">
          <source>In other words: fetch the row from &lt;code&gt;t1&lt;/code&gt; where no other row exists with the same &lt;code&gt;UserId&lt;/code&gt; and a greater Date.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En otras palabras: busque la fila de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; donde no exista otra fila con el mismo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;UserId&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y una Fecha mayor.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ecb6427a441808e4acda1af43f82bf01e1e93d7d" translate="yes" xml:space="preserve">
          <source>In this case here is what the inner query does.  The whole dataset is sorted by UserId then Date DESC.  Then it processes it in one pass.  For each row you return the UserId and the first Date seen for that UserId (since dates are sorted DESC, that's the max date).  This gives you your answer with duplicated rows.  Then the outer DISTINCT squashes duplicates.</source>
          <target state="translated">En este caso,esto es lo que hace la consulta interna.Todo el conjunto de datos se ordena por UserId y luego por Date DESC.Luego lo procesa en una sola pasada.Para cada fila devuelve el UserId y la primera fecha vista para ese UserId (ya que las fechas están ordenadas DESC,esa es la fecha máxima).Esto te da tu respuesta con filas duplicadas.Luego el DISTINTO exterior aplasta los duplicados.</target>
        </trans-unit>
        <trans-unit id="402085a89e3d90f5847116008a388b9c03c122c3" translate="yes" xml:space="preserve">
          <source>In those cases (when there's no match), the columns of &lt;code&gt;t2&lt;/code&gt; will be &lt;code&gt;NULL&lt;/code&gt; -- even the columns specified in the join condition.  So that's why we use &lt;code&gt;WHERE t2.UserId IS NULL&lt;/code&gt;, because we're searching for the cases where no row was found with a greater &lt;code&gt;date&lt;/code&gt; for the given &lt;code&gt;userid&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En esos casos (cuando no hay coincidencia), las columnas de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ser&amp;aacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;NULL&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , incluso las columnas especificadas en la condici&amp;oacute;n de uni&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por eso usamos &lt;/font&gt;&lt;/font&gt; &lt;code&gt;WHERE t2.UserId IS NULL&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , porque estamos buscando los casos en los que no se encontr&amp;oacute; ninguna fila con una &lt;/font&gt;&lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; mayor &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;para el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;userid&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; dado &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cff87308f0f5a44185f055a550f067dcf137883" translate="yes" xml:space="preserve">
          <source>Just had to write a &quot;live&quot; example at work :)</source>
          <target state="translated">Sólo tenía que escribir un ejemplo &quot;en vivo&quot; en el trabajo :)</target>
        </trans-unit>
        <trans-unit id="b6a63b1d6787b611e979efb5a06d6ad2f19ac027" translate="yes" xml:space="preserve">
          <source>Just tested this and it seems to work on a logging table</source>
          <target state="translated">Acabo de probar esto y parece funcionar en una mesa de registro</target>
        </trans-unit>
        <trans-unit id="9924f5c47b2ff7e5e41049935735440618c1048d" translate="yes" xml:space="preserve">
          <source>My solution with Oracle</source>
          <target state="translated">Mi solución con Oracle</target>
        </trans-unit>
        <trans-unit id="0854d80218ef44ea7683517c112af7afa0afb923" translate="yes" xml:space="preserve">
          <source>My solution with Postgres</source>
          <target state="translated">Mi solución con Postgres</target>
        </trans-unit>
        <trans-unit id="6d7d9479e022df45c509f62303629e302818e343" translate="yes" xml:space="preserve">
          <source>Not being at work, I don't have Oracle to hand, but I seem to recall that Oracle allows multiple columns to be matched in an IN clause, which should at least avoid the options that use a correlated subquery, which is seldom a good idea.</source>
          <target state="translated">Al no estar en el trabajo,no tengo a mano el Oracle,pero me parece recordar que el Oracle permite hacer coincidir múltiples columnas en una cláusula IN,lo que debería al menos evitar las opciones que utilizan una subconsulta correlacionada,lo que rara vez es una buena idea.</target>
        </trans-unit>
        <trans-unit id="78f19667512f67f6edbd1038c70b7a9d51178f51" translate="yes" xml:space="preserve">
          <source>Of course, if searching through huge tables, it's probably better if you use FULL hints in your query.</source>
          <target state="translated">Por supuesto,si se busca a través de grandes tablas,es probablemente mejor si se utilizan pistas completas en su consulta.</target>
        </trans-unit>
        <trans-unit id="3a99454b317198c63b1df2fb84afc34bca04b1da" translate="yes" xml:space="preserve">
          <source>Re comment from @Farhan:</source>
          <target state="translated">Re comentario de @Farhan:</target>
        </trans-unit>
        <trans-unit id="91dd7bf9acb8e164d089c0b82ff5455ebf0e4e1b" translate="yes" xml:space="preserve">
          <source>Reference:  &lt;a href=&quot;http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&quot;&gt;http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Referencia: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://benincampus.blogspot.com/2013/08/select-rows-which-have-maxmin-value-in.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ddc49f0f6adc2cd9d3bf460ac52d21542f4206c9" translate="yes" xml:space="preserve">
          <source>Regards,
Guus</source>
          <target state="translated">Regards,
Guus</target>
        </trans-unit>
        <trans-unit id="0e2f476037e1df44c739f0dcf843dcbb014c8ce9" translate="yes" xml:space="preserve">
          <source>So it works, although some of the new-fangly stuff mentioned elsewhere may be more performant.</source>
          <target state="translated">Así que funciona,aunque algunos de los nuevos colmillos que se mencionan en otros lugares pueden ser más eficaces.</target>
        </trans-unit>
        <trans-unit id="5abb1005b1df2014e64d5a3ea5204e066aa4d22d" translate="yes" xml:space="preserve">
          <source>Solution for MySQL which doesn't have concepts of partition KEEP, DENSE_RANK.</source>
          <target state="translated">Solución para MySQL que no tiene conceptos de partición KEEP,DENSE_RANK.</target>
        </trans-unit>
        <trans-unit id="a0ea07fd432672f88944816067af33a3b69a9dfd" translate="yes" xml:space="preserve">
          <source>Something like this, perhaps (can't remember if the column list should be parenthesised or not):</source>
          <target state="translated">Algo así,tal vez (no puedo recordar si la lista de columnas debe estar entre paréntesis o no):</target>
        </trans-unit>
        <trans-unit id="692eeda053a902d4e745a16c8a01f8e08799e9da" translate="yes" xml:space="preserve">
          <source>Table:</source>
          <target state="translated">Table:</target>
        </trans-unit>
        <trans-unit id="2ec91b0ba834071567a1b897882c5f8d7d2283a0" translate="yes" xml:space="preserve">
          <source>The above returns all the rows with max my_date per user.</source>
          <target state="translated">Lo anterior devuelve todas las filas con el máximo de mi_fecha por usuario.</target>
        </trans-unit>
        <trans-unit id="8d3e713aa786fc02e56c8895b9c1d995d120bebe" translate="yes" xml:space="preserve">
          <source>The answer here is Oracle only. Here's a bit more sophisticated answer in all SQL:</source>
          <target state="translated">La respuesta aquí es sólo el Oráculo.Aquí hay una respuesta un poco más sofisticada en todo SQL:</target>
        </trans-unit>
        <trans-unit id="4353e0def2ef1b8f34b3b1aa60bce748c3a87605" translate="yes" xml:space="preserve">
          <source>The code works.</source>
          <target state="translated">El código funciona.</target>
        </trans-unit>
        <trans-unit id="001780d4c917b7750f44869c8b1a6078ab99dc2b" translate="yes" xml:space="preserve">
          <source>The reason why this code works so well is that it only needs to scan the table once. It does not require any indexes and most importantly it does not need to sort the table, which most analytics functions do. Indexes will help though if you need to filter the result for a single userid.</source>
          <target state="translated">La razón por la que este código funciona tan bien es que sólo necesita escanear la mesa una vez.No requiere ningún índice y lo más importante es que no necesita clasificar la tabla,lo que hacen la mayoría de las funciones de análisis.Los índices ayudarán sin embargo si necesitas filtrar el resultado para un solo usuario.</target>
        </trans-unit>
        <trans-unit id="c6014dffd001c57d401c4d7842342f05810101fc" translate="yes" xml:space="preserve">
          <source>The trick in this query is to design the join's matching condition such that &lt;code&gt;t2&lt;/code&gt; must match the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;userid&lt;/code&gt;, and a &lt;em&gt;greater&lt;/em&gt;&lt;code&gt;date&lt;/code&gt;.  The idea being if a row exists in &lt;code&gt;t2&lt;/code&gt; that has a greater &lt;code&gt;date&lt;/code&gt;, then the row in &lt;code&gt;t1&lt;/code&gt; it's compared against &lt;em&gt;can't&lt;/em&gt; be the greatest &lt;code&gt;date&lt;/code&gt; for that &lt;code&gt;userid&lt;/code&gt;.  But if there is no match -- i.e. if no row exists in &lt;code&gt;t2&lt;/code&gt; with a greater &lt;code&gt;date&lt;/code&gt; than the row in &lt;code&gt;t1&lt;/code&gt; -- we know that the row in &lt;code&gt;t1&lt;/code&gt; was the row with the greatest &lt;code&gt;date&lt;/code&gt; for the given &lt;code&gt;userid&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El truco en esta consulta es dise&amp;ntilde;ar la condici&amp;oacute;n de coincidencia de la uni&amp;oacute;n de modo que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; debe coincidir con el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mismo &lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;userid&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y una &lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mayor&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La idea es que si existe una fila en &lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; que tiene una &lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; mayor &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, entonces la fila en &lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; con la&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que se compara &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no puede&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ser la mejor &lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; para ese &lt;/font&gt; &lt;code&gt;userid&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero si no hay coincidencia, es decir, si no existe una fila en &lt;/font&gt; &lt;code&gt;t2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; con una &lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; mayor &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;que la fila en &lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; , sabemos que la fila en &lt;/font&gt; &lt;code&gt;t1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; fue la fila con la mayor &lt;/font&gt; &lt;code&gt;date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; para el dado&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;userid&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74ec296dd8eea149cfea8dabc86cdbbe23944c02" translate="yes" xml:space="preserve">
          <source>The windowing clause is only applicable in the presence of the order by clause. With no order by clause, no windowing clause is applied by default and none can be explicitly specified.</source>
          <target state="translated">La cláusula de ventana sólo es aplicable en presencia de la orden por cláusula.Sin orden por cláusula,no se aplica por defecto ninguna cláusula &quot;windowing&quot; y no se puede especificar ninguna explícitamente.</target>
        </trans-unit>
        <trans-unit id="3f80e81ca09a8d54b3d7b1bc02b699033ba414d4" translate="yes" xml:space="preserve">
          <source>There is no self-join in this code. There is instead a predicate placed on the result of the inline view that contains the analytic function -- a very different matter, and completely standard practice.</source>
          <target state="translated">No hay auto-unión en este código.En su lugar hay un predicado colocado en el resultado de la vista en línea que contiene la función analítica-un asunto muy diferente,y una práctica completamente estándar.</target>
        </trans-unit>
        <trans-unit id="417d65b805b35d5c15d4aea7b1f5ed9939b7c4f9" translate="yes" xml:space="preserve">
          <source>This is not a particularly spectacular example of analytic queries.  For a much bigger win consider taking a table of financial receipts and calculating for each user and receipt, a running total of what they paid.  Analytic queries solve that efficiently.  Other solutions are less efficient.  Which is why they are part of the 2003 SQL standard.  (Unfortunately Postgres doesn't have them yet.  Grrr...)</source>
          <target state="translated">Este no es un ejemplo particularmente espectacular de consultas analíticas.Para una ganancia mucho mayor considere tomar una tabla de recibos financieros y calcular para cada usuario y recibo,un total corriente de lo que pagaron.Las consultas analíticas resuelven eso eficientemente.Otras soluciones son menos eficientes.Por eso son parte del estándar SQL 2003.(Desafortunadamente Postgres no las tiene todavía.Grrr...)</target>
        </trans-unit>
        <trans-unit id="9b351c8e5383c024d336f4c4676d56ad1e01764a" translate="yes" xml:space="preserve">
          <source>This one supports multiple values for UserId on the &lt;strong&gt;same&lt;/strong&gt; date.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;Eacute;ste admite m&amp;uacute;ltiples valores para UserId en la &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;misma&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; fecha.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d16f16a7850ad9d6fcbd08c93139735c8d1ea52" translate="yes" xml:space="preserve">
          <source>This should be as simple as:</source>
          <target state="translated">Esto debería ser tan simple como:</target>
        </trans-unit>
        <trans-unit id="74044189c4916dff7c911674a13790ac36611367" translate="yes" xml:space="preserve">
          <source>This will also take care of duplicates (return one row for each user_id):</source>
          <target state="translated">Esto también se encargará de los duplicados (devuelve una fila por cada user_id):</target>
        </trans-unit>
        <trans-unit id="1def462e50e268c36bf6f217bc5abc380ab0d78a" translate="yes" xml:space="preserve">
          <source>This will retrieve all rows for which the my_date column value is equal to the maximum value of my_date for that userid. This may retrieve multiple rows for the userid where the maximum date is on multiple rows.</source>
          <target state="translated">Esto recuperará todas las filas para las cuales el valor de la columna mi_fecha es igual al valor máximo de mi_fecha para ese userid.Esto puede recuperar múltiples filas para el userid donde la fecha máxima está en múltiples filas.</target>
        </trans-unit>
        <trans-unit id="5205e796ec7ffd8163ecb77f3c45f1fac6457576" translate="yes" xml:space="preserve">
          <source>Under the hood analytic queries sort the whole dataset, then process it sequentially.  As you process it you partition the dataset according to certain criteria, and then for each row looks at some window (defaults to the first value in the partition to the current row - that default is also the most efficient) and can compute values using a number of analytic functions (the list of which is very similar to the aggregate functions).</source>
          <target state="translated">Bajo el capó las consultas analíticas clasifican todo el conjunto de datos,y luego lo procesan secuencialmente.A medida que lo procesa,divide el conjunto de datos según ciertos criterios,y luego para cada fila mira alguna ventana (por defecto el primer valor de la partición de la fila actual-ese valor por defecto es también el más eficiente)y puede calcular los valores utilizando una serie de funciones analíticas (cuya lista es muy similar a las funciones agregadas).</target>
        </trans-unit>
        <trans-unit id="486d2cd95331c431746adb0c34738a8f8fc649da" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://docs.oracle.com/database/121/SQLRF/functions170.htm&quot;&gt;&lt;code&gt;ROW_NUMBER()&lt;/code&gt;&lt;/a&gt; to assign a unique ranking on descending &lt;code&gt;Date&lt;/code&gt; for each &lt;code&gt;UserId&lt;/code&gt;, then filter to the first row for each &lt;code&gt;UserId&lt;/code&gt; (i.e., &lt;code&gt;ROW_NUMBER&lt;/code&gt; = 1).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Use &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.oracle.com/database/121/SQLRF/functions170.htm&quot;&gt; &lt;code&gt;ROW_NUMBER()&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para asignar una clasificaci&amp;oacute;n &amp;uacute;nica en la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Date&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; descendente &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;para cada &lt;/font&gt;&lt;/font&gt; &lt;code&gt;UserId&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , luego filtre a la primera fila para cada &lt;/font&gt;&lt;/font&gt; &lt;code&gt;UserId&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (es decir, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ROW_NUMBER&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; = 1).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="634ddf9e50d4818ae830580634e53d59baaaaf8c" translate="yes" xml:space="preserve">
          <source>Who has the best overall homework result (maximum sum of homework points)?</source>
          <target state="translated">¿Quién tiene el mejor resultado general de deberes (suma máxima de puntos de deberes)?</target>
        </trans-unit>
        <trans-unit id="2d31c4f46226c06eebb0e3b640d209b7ca660ab2" translate="yes" xml:space="preserve">
          <source>With PostgreSQL 8.4 or later, you can use this:</source>
          <target state="translated">Con PostgreSQL 8.4 o posterior,puedes usar esto:</target>
        </trans-unit>
        <trans-unit id="f64129fb961a33a22771978794a8e0a0d726116f" translate="yes" xml:space="preserve">
          <source>Wouldn't a QUALIFY clause be both simplest and best?</source>
          <target state="translated">¿No sería una cláusula de CALIFICACIÓN la más simple y la mejor?</target>
        </trans-unit>
        <trans-unit id="ffa6eb21d2116e5f16b555965563b9a6967dd503" translate="yes" xml:space="preserve">
          <source>You can use FIRST_VALUE instead of MAX and look it up in the explain plan. I didn't have the time to play with it.</source>
          <target state="translated">Puedes usar PRIMER_VALOR en lugar de MAX y buscarlo en el plan de explicación.No tuve tiempo de jugar con él.</target>
        </trans-unit>
        <trans-unit id="8496c9898467401252142da5c395b4bd2148fb13" translate="yes" xml:space="preserve">
          <source>i thing you shuold make this variant to previous query:</source>
          <target state="translated">Creo que has hecho esta variante de la consulta anterior:</target>
        </trans-unit>
        <trans-unit id="32f066ab49d567aa0dda290679007c2477ad1732" translate="yes" xml:space="preserve">
          <source>results:</source>
          <target state="translated">results:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
