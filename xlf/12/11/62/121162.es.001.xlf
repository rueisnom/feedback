<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/121162">
    <body>
      <group id="121162">
        <trans-unit id="6e909f16da04e6b4ba7a3dc42d76fb1fc131016b" translate="yes" xml:space="preserve">
          <source>1) A constructor declared without the function-specifier explicit specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a converting constructor.</source>
          <target state="translated">1)Un constructor declarado sin el especificador de la función especifica explícitamente una conversión de los tipos de sus parámetros al tipo de su clase.Tal constructor se llama constructor convertidor.</target>
        </trans-unit>
        <trans-unit id="40075093fa2de375513bd7806fbfa585f1ccb88d" translate="yes" xml:space="preserve">
          <source>2) A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion for direct-initialization (8.5). Otherwise, user-defined conversions are not restricted to use in assignments
  and initializations.</source>
          <target state="translated">2)Una función de conversión puede ser explícita (7.1.2),en cuyo caso sólo se considera como una conversión definida por el usuario para la iniciación directa (8.5).Por lo demás,las conversiones definidas por el usuario no se limitan a su utilización en asignaciones e inicializaciones.</target>
        </trans-unit>
        <trans-unit id="82c5d71d8413126d3518e4c637002b6b8aa3fbf6" translate="yes" xml:space="preserve">
          <source>2) An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or valueinitialization
  (8.5).</source>
          <target state="translated">2)Un constructor explícito construye los objetos igual que los constructores no explícitos,pero sólo lo hace cuando se utiliza explícitamente la sintaxis de inicialización directa (8.5)o cuando se utilizan moldes (5.2.9,5.4).Un constructor por defecto puede ser un constructor explícito;tal constructor se utilizará para realizar la inicialización por defecto o la inicialización de valor (8.5).</target>
        </trans-unit>
        <trans-unit id="7f26b74b665e2acdf88f5ec7e221b4624394b35b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx&quot;&gt;Here&lt;/a&gt; is a good write-up on explicit constructors.</source>
          <target state="translated">&lt;a href=&quot;http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx&quot;&gt;Aqu&amp;iacute;&lt;/a&gt; hay una buena rese&amp;ntilde;a sobre constructores expl&amp;iacute;citos.</target>
        </trans-unit>
        <trans-unit id="fb9d903b66d4b86f2a3d5b0e7ce99773805eec0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ [class.conv.ctor]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ [class.conv.ctor]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e76638e98bf8cd3442bd39601d1b5f75737ea3a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ [class.conv.fct]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ [class.conv.fct]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dcec192ad51b7af512d87c6084e215eb361da2a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion constructors and non-explicit conversion functions may introduce ambiguity.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Los constructores de conversi&amp;oacute;n y las funciones de conversi&amp;oacute;n no expl&amp;iacute;citas pueden introducir ambig&amp;uuml;edad.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e074b33cdf4fd9146a172fd109876e5aaa6831fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion constructors and non-explicit conversion functions may lead to unexpected behaviour.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Los constructores de conversi&amp;oacute;n y las funciones de conversi&amp;oacute;n no expl&amp;iacute;citas pueden conducir a un comportamiento inesperado.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="404f447a2f27e2777f7b751f552e0208232d38cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explicit conversion constructors (C++ only)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Constructores de conversi&amp;oacute;n expl&amp;iacute;cita (solo C ++)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9e1424d19737c3e0e14bad461887396f1689093" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;a constructor of class X that cannot be used to implicitly convert the first (any only) parameter to type X&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Un constructor de clase X que no se puede utilizar para convertir impl&amp;iacute;citamente el primer par&amp;aacute;metro (cualquiera) al tipo X&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0b9c3a76bec2b3865fa08d11db98c0d983d43a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;or a conversion function that is only considered for direct initialization and explicit conversion.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;o una funci&amp;oacute;n de conversi&amp;oacute;n que solo se considera para la inicializaci&amp;oacute;n directa y la conversi&amp;oacute;n expl&amp;iacute;cita.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90931b1495f819faf9ec90d5e4e0e1fc229bdff3" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;f&lt;/code&gt; is ambiguous if passing an object of type &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Una llamada a &lt;code&gt;f&lt;/code&gt; es ambigua si pasa un objeto de tipo &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef58e46d65d0f651d7e99ff4af68f72c49935b2e" translate="yes" xml:space="preserve">
          <source>An example when you would deliberately &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; want to make your single-argument constructor explicit is if you're creating a functor (look at the 'add_x' struct declared in &lt;a href=&quot;https://stackoverflow.com/a/356993/793930&quot;&gt;this&lt;/a&gt; answer). In such a case, creating an object as &lt;code&gt;add_x add30 = 30;&lt;/code&gt; would probably make sense.</source>
          <target state="translated">Un ejemplo en el que deliberadamente &lt;strong&gt;&lt;em&gt;no&lt;/em&gt;&lt;/strong&gt; desea hacer expl&amp;iacute;cito su constructor de argumento &amp;uacute;nico es si est&amp;aacute; creando un functor (mire la estructura 'add_x' declarada en &lt;a href=&quot;https://stackoverflow.com/a/356993/793930&quot;&gt;esta&lt;/a&gt; respuesta). En tal caso, crear un objeto como &lt;code&gt;add_x add30 = 30;&lt;/code&gt; probablemente tendr&amp;iacute;a sentido.</target>
        </trans-unit>
        <trans-unit id="023d40884b32ae99ad8ee9224964e2bf68369ac5" translate="yes" xml:space="preserve">
          <source>Another good practice for classes is to make copy construction and assignment private (a.k.a. disable it) unless you really need to implement it. This avoids having eventual copies of pointers when using the methods that C++ will create for you by default. An other way to do this is derive from boost::noncopyable.</source>
          <target state="translated">Otra buena práctica para las clases es hacer que la construcción de la copia y la asignación sea privada (también conocida como deshabilitarla)a menos que realmente necesites implementarla.Esto evita tener eventuales copias de punteros al usar los métodos que C++creará para ti por defecto.Otra forma de hacerlo es derivar de boost::noncopyable.</target>
        </trans-unit>
        <trans-unit id="93fa74ff062a4f43bee8427c70d3f3e8e2eb398e" translate="yes" xml:space="preserve">
          <source>As Bjarne Stroustrup  puts it (in &quot;The C++ Programming Language&quot;, 4th Ed., 35.2.1, pp. 1011) on the question why &lt;code&gt;std::duration&lt;/code&gt; cannot be implicitly constructed from a plain number:</source>
          <target state="translated">Como dice Bjarne Stroustrup (en &quot;The C ++ Programming Language&quot;, 4th Ed., 35.2.1, pp. 1011) sobre la pregunta por qu&amp;eacute; &lt;code&gt;std::duration&lt;/code&gt; Duration no puede construirse impl&amp;iacute;citamente a partir de un n&amp;uacute;mero simple:</target>
        </trans-unit>
        <trans-unit id="91abe90d799140d96614d181c106b32f8cccead0" translate="yes" xml:space="preserve">
          <source>Besides, it is always a good coding practice to make your one argument constructors (including those with default values for arg2,arg3,...) as already stated. 
Like always with C++: if you don't - you'll wish you did...</source>
          <target state="translated">Además,siempre es una buena práctica de codificación hacer sus constructores de un argumento (incluyendo aquellos con valores por defecto para arg2,arg3,...)como ya se ha dicho.Como siempre con C++:si no lo haces-desearás haberlo hecho...</target>
        </trans-unit>
        <trans-unit id="8056a96d70581f55a1f36421d40b18baa0983d53" translate="yes" xml:space="preserve">
          <source>Consider a function printing some vector:</source>
          <target state="translated">Considere una función que imprima algún vector:</target>
        </trans-unit>
        <trans-unit id="ffabce6768c306d54af29bfe6cecee317c83c262" translate="yes" xml:space="preserve">
          <source>Consider a structure &lt;code&gt;V&lt;/code&gt;, convertible to &lt;code&gt;int&lt;/code&gt;, a structure &lt;code&gt;U&lt;/code&gt; implicitly constructible from &lt;code&gt;V&lt;/code&gt; and a function &lt;code&gt;f&lt;/code&gt; overloaded for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; respectively.</source>
          <target state="translated">Considere una estructura &lt;code&gt;V&lt;/code&gt; , convertible en &lt;code&gt;int&lt;/code&gt; , una estructura &lt;code&gt;U&lt;/code&gt; impl&amp;iacute;citamente construible desde &lt;code&gt;V&lt;/code&gt; y una funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; sobrecargada para &lt;code&gt;U&lt;/code&gt; y &lt;code&gt;bool&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="019b9c3fbcd9fbed06290bc41f9a48781e74ba91" translate="yes" xml:space="preserve">
          <source>Consider the following class without an explicit constructor:</source>
          <target state="translated">Considere la siguiente clase sin un constructor explícito:</target>
        </trans-unit>
        <trans-unit id="f1f6cc578a73fda02c3a246d96eb579f34559dea" translate="yes" xml:space="preserve">
          <source>Constructors append implicit conversion. To suppress this implicit conversion it is required to declare a constructor with a parameter explicit.</source>
          <target state="translated">Los constructores añaden la conversión implícita.Para suprimir esta conversión implícita se requiere declarar un constructor con un parámetro explícito.</target>
        </trans-unit>
        <trans-unit id="18f1b770126acc40cb179db8016ea3c6af74a605" translate="yes" xml:space="preserve">
          <source>Conversion of a function argument:</source>
          <target state="translated">Conversión de un argumento de función:</target>
        </trans-unit>
        <trans-unit id="c8f4b2cde6b3fe7edba64d7e515a710a2e2df98c" translate="yes" xml:space="preserve">
          <source>Cpp Reference is always helpful!!! Details about explicit specifier can be found &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;here&lt;/a&gt;.  You may need to look at &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/implicit_conversion&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; too.</source>
          <target state="translated">&amp;iexcl;La referencia de Cpp siempre es &amp;uacute;til! Los detalles sobre el especificador expl&amp;iacute;cito se pueden encontrar &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;aqu&amp;iacute;&lt;/a&gt; . Es posible que tambi&amp;eacute;n necesite mirar las &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/implicit_conversion&quot;&gt;conversiones impl&amp;iacute;citas&lt;/a&gt; y &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_initialization&quot;&gt;la inicializaci&amp;oacute;n de copia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e32c5521f2cec3f8f4baa216e8f949d5b512fcca" translate="yes" xml:space="preserve">
          <source>Depending upon the implementation, the second manner of instantiating class Foo may be confusing, or not what the programmer intended. Prefixing the &lt;code&gt;explicit&lt;/code&gt; keyword to the constructor would generate a compiler error at &lt;code&gt;Foo bar2 = 20;&lt;/code&gt;.</source>
          <target state="translated">Dependiendo de la implementaci&amp;oacute;n, la segunda forma de instanciar la clase Foo puede ser confusa o no lo que pretend&amp;iacute;a el programador. Prefijar la palabra clave &lt;code&gt;explicit&lt;/code&gt; al constructor generar&amp;iacute;a un error de compilaci&amp;oacute;n en &lt;code&gt;Foo bar2 = 20;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30a2e91c6246a99a6f1219373a019d7d3616ee87" translate="yes" xml:space="preserve">
          <source>Example as follows:</source>
          <target state="translated">El ejemplo es el siguiente:</target>
        </trans-unit>
        <trans-unit id="6f3ba8e6e3b35cf9dfa1800107ec407650feff17" translate="yes" xml:space="preserve">
          <source>Example using structures &lt;code&gt;X, Y, Z&lt;/code&gt; and functions &lt;code&gt;foo, bar, baz&lt;/code&gt;:</source>
          <target state="translated">Ejemplo usando estructuras &lt;code&gt;X, Y, Z&lt;/code&gt; y funciones &lt;code&gt;foo, bar, baz&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c4391c5871b2591466f38ed051125c3a6b72b655" translate="yes" xml:space="preserve">
          <source>Examples regarding constructor:</source>
          <target state="translated">Ejemplos sobre el constructor:</target>
        </trans-unit>
        <trans-unit id="6a4208acecf2caa67ad142db501f1e7edba9301f" translate="yes" xml:space="preserve">
          <source>Examples regarding conversion functions:</source>
          <target state="translated">Ejemplos relativos a las funciones de conversión:</target>
        </trans-unit>
        <trans-unit id="63cd5534db30ee33eabaed9b35dad8b9682be58f" translate="yes" xml:space="preserve">
          <source>Explicit conversion functions and constructors can only be used for explicit conversions (direct initialization or explicit cast operation) while non-explicit constructors and conversion functions can be used for implicit as well as explicit conversions.</source>
          <target state="translated">Las funciones de conversión y los constructores explícitos sólo pueden utilizarse para conversiones explícitas (inicialización directa u operación de fundición explícita),mientras que los constructores y las funciones de conversión no explícitas pueden utilizarse tanto para conversiones implícitas como explícitas.</target>
        </trans-unit>
        <trans-unit id="483334b7421e283b810cc10b297ff1ff94e618b1" translate="yes" xml:space="preserve">
          <source>For example, if you declare the class as:</source>
          <target state="translated">Por ejemplo,si declaras la clase como:</target>
        </trans-unit>
        <trans-unit id="a20de6e76729d51851c56bf373b29f18ff5bb561" translate="yes" xml:space="preserve">
          <source>For example, if you have a string class with constructor &lt;code&gt;String(const char* s)&lt;/code&gt;, that's probably exactly what you want.  You can pass a &lt;code&gt;const char*&lt;/code&gt; to a function expecting a &lt;code&gt;String&lt;/code&gt;, and the compiler will automatically construct a temporary &lt;code&gt;String&lt;/code&gt; object for you.</source>
          <target state="translated">Por ejemplo, si tiene una clase de cadena con el constructor &lt;code&gt;String(const char* s)&lt;/code&gt; , eso es probablemente exactamente lo que desea. Puede pasar un &lt;code&gt;const char*&lt;/code&gt; a una funci&amp;oacute;n que espera un &lt;code&gt;String&lt;/code&gt; , y el compilador construir&amp;aacute; autom&amp;aacute;ticamente un objeto &lt;code&gt;String&lt;/code&gt; temporal para usted.</target>
        </trans-unit>
        <trans-unit id="03739c543e63532d2e0ee64e937635e148313674" translate="yes" xml:space="preserve">
          <source>For example, the following statements are legal:</source>
          <target state="translated">Por ejemplo,las siguientes declaraciones son legales:</target>
        </trans-unit>
        <trans-unit id="05fa6736aea3a744782881e661a2c437953ca80b" translate="yes" xml:space="preserve">
          <source>Here's a simple function that takes a &lt;code&gt;Foo&lt;/code&gt; object:</source>
          <target state="translated">Aqu&amp;iacute; hay una funci&amp;oacute;n simple que toma un objeto &lt;code&gt;Foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1e43ffb6522ca8f869078d171d24a79cea9ba5d3" translate="yes" xml:space="preserve">
          <source>Here's an example class with a constructor that can be used for implicit conversions:</source>
          <target state="translated">Aquí hay una clase de ejemplo con un constructor que puede ser usado para conversiones implícitas:</target>
        </trans-unit>
        <trans-unit id="fc9d2bdfb3652039da2c1f77188f4475b0334b02" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;explicit&lt;/code&gt;-keyword enforces only explicit casts to be valid, so &lt;code&gt;bool b = c;&lt;/code&gt; would be an invalid cast in this case. In situations like these &lt;code&gt;explicit&lt;/code&gt;-keyword can help programmer to avoid implicit, unintended casts. This usage has been standardized in &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cast_operator&quot;&gt;C++11&lt;/a&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;explicit&lt;/code&gt; palabra clave expl&amp;iacute;cita exige que solo las conversiones expl&amp;iacute;citas sean v&amp;aacute;lidas, por lo que &lt;code&gt;bool b = c;&lt;/code&gt; ser&amp;iacute;a un elenco inv&amp;aacute;lido en este caso. En situaciones como estas, &lt;code&gt;explicit&lt;/code&gt; palabra clave expl&amp;iacute;cita puede ayudar al programador a evitar conversiones impl&amp;iacute;citas e involuntarias. Este uso se ha estandarizado en &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cast_operator&quot;&gt;C ++ 11&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ecde5e33b6842aae9586216bde3d7c062492300" translate="yes" xml:space="preserve">
          <source>If either the constructor of &lt;code&gt;U&lt;/code&gt; or the conversion function of &lt;code&gt;V&lt;/code&gt; would be &lt;code&gt;explicit&lt;/code&gt;, there would be no ambiguity since only the non-explicit conversion would be considered. If both are explicit the call to &lt;code&gt;f&lt;/code&gt; using an object of type &lt;code&gt;V&lt;/code&gt; would have to be done using an explicit conversion or cast operation.</source>
          <target state="translated">Si el constructor de &lt;code&gt;U&lt;/code&gt; o la funci&amp;oacute;n de conversi&amp;oacute;n de &lt;code&gt;V&lt;/code&gt; fuera &lt;code&gt;explicit&lt;/code&gt; , no habr&amp;iacute;a ambig&amp;uuml;edad ya que solo se considerar&amp;iacute;a la conversi&amp;oacute;n no expl&amp;iacute;cita. Si ambos son expl&amp;iacute;citos, la llamada a &lt;code&gt;f&lt;/code&gt; usando un objeto de tipo &lt;code&gt;V&lt;/code&gt; deber&amp;iacute;a hacerse usando una conversi&amp;oacute;n expl&amp;iacute;cita o una operaci&amp;oacute;n de conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="24f97f1f66fe055c12d92257a5a1d131d926faa9" translate="yes" xml:space="preserve">
          <source>If the size-constructor of the vector would not be explicit it would be possible to call the function like this:</source>
          <target state="translated">Si el tamaño constructor del vector no fuera explícito,se podría llamar a la función así:</target>
        </trans-unit>
        <trans-unit id="124132f57abb337ccbdded8265bd7ff12e02cb28" translate="yes" xml:space="preserve">
          <source>If you declare the constructor of the class as &lt;code&gt;explicit&lt;/code&gt;, the previous declarations would be illegal.</source>
          <target state="translated">Si declara &lt;code&gt;explicit&lt;/code&gt; el constructor de la clase, las declaraciones anteriores ser&amp;iacute;an ilegales.</target>
        </trans-unit>
        <trans-unit id="dcfb0600299ba6b050382cf5b290106184e86d09" translate="yes" xml:space="preserve">
          <source>If you know what you mean, be explicit about it.</source>
          <target state="translated">Si sabes lo que quieres decir,sé explícito al respecto.</target>
        </trans-unit>
        <trans-unit id="2a7badbe21782e07fa940bd63da839e4f99542d5" translate="yes" xml:space="preserve">
          <source>In C++, a constructor with only one required parameter is considered an implicit conversion function.  It converts the parameter type to the class type.  Whether this is a good thing or not depends on the semantics of the constructor.</source>
          <target state="translated">En C++,un constructor con un solo parámetro requerido se considera una función de conversión implícita.Convierte el tipo de parámetro en el tipo de clase.Que esto sea bueno o no depende de la semántica del constructor.</target>
        </trans-unit>
        <trans-unit id="96a5269e608660ea6a121ce099af5f98a9d89d48" translate="yes" xml:space="preserve">
          <source>In C++11 you can also specify an &quot;operator type()&quot; with such keyword &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;http://en.cppreference.com/w/cpp/language/explicit&lt;/a&gt; With such specification you can use operator in terms of explicit conversions, and direct initialization of object.</source>
          <target state="translated">En C ++ 11 tambi&amp;eacute;n puede especificar un &quot;tipo de operador ()&quot; con dicha palabra clave &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;http://en.cppreference.com/w/cpp/language/explicit&lt;/a&gt; Con dicha especificaci&amp;oacute;n puede usar el operador en t&amp;eacute;rminos de conversiones expl&amp;iacute;citas, y Inicializaci&amp;oacute;n directa del objeto.</target>
        </trans-unit>
        <trans-unit id="0f99c78ff8610e39b8faa30a4b5ef71196baf577" translate="yes" xml:space="preserve">
          <source>In summary, if your single-parameter constructor converts the parameter into an object of your class, you probably don't want to use the &lt;code&gt;explicit&lt;/code&gt; keyword.  But if you have a constructor that simply happens to take a single parameter, you should declare it as &lt;code&gt;explicit&lt;/code&gt; to prevent the compiler from surprising you with unexpected conversions.</source>
          <target state="translated">En resumen, si su constructor de un solo par&amp;aacute;metro convierte el par&amp;aacute;metro en un objeto de su clase, probablemente no quiera usar la palabra clave &lt;code&gt;explicit&lt;/code&gt; . Pero si tiene un constructor que simplemente toma un &amp;uacute;nico par&amp;aacute;metro, debe declararlo como &lt;code&gt;explicit&lt;/code&gt; para evitar que el compilador lo sorprenda con conversiones inesperadas.</target>
        </trans-unit>
        <trans-unit id="b2cb9e61565f9bb201c8b94447f641b04a3f7c24" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;usually&lt;/em&gt; good practice to declare single-argument constructors as &lt;code&gt;explicit&lt;/code&gt;, unless your implementation specifically prohibits it.</source>
          <target state="translated">Por lo &lt;em&gt;general,&lt;/em&gt; es una buena pr&amp;aacute;ctica declarar los constructores de argumento &amp;uacute;nico como &lt;code&gt;explicit&lt;/code&gt; , a menos que su implementaci&amp;oacute;n lo proh&amp;iacute;ba espec&amp;iacute;ficamente.</target>
        </trans-unit>
        <trans-unit id="76e264a3ab2feb73628e60003fbf19c73f2596d8" translate="yes" xml:space="preserve">
          <source>Let's look at a small setup of structures and functions to see the difference between &lt;code&gt;explicit&lt;/code&gt; and non-&lt;code&gt;explicit&lt;/code&gt; conversions.</source>
          <target state="translated">Veamos una peque&amp;ntilde;a configuraci&amp;oacute;n de estructuras y funciones para ver la diferencia entre conversiones &lt;code&gt;explicit&lt;/code&gt; y no &lt;code&gt;explicit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1efdc398882ef52a5c56f27be4e597b6de6ca5f" translate="yes" xml:space="preserve">
          <source>Note also that constructors with</source>
          <target state="translated">Nótese también que los constructores con</target>
        </trans-unit>
        <trans-unit id="0caae2186a2fb9fc2295d889a7ef4e74ade7ad33" translate="yes" xml:space="preserve">
          <source>Now, if you try:</source>
          <target state="translated">Ahora,si lo intentas:</target>
        </trans-unit>
        <trans-unit id="207a36c11ea6ea8e3440a8af2255c0d19b55487e" translate="yes" xml:space="preserve">
          <source>Object initialization:</source>
          <target state="translated">Inicialización del objeto:</target>
        </trans-unit>
        <trans-unit id="d5ddf0ad260d5cf6434f9b9c3e83655bd62daf1e" translate="yes" xml:space="preserve">
          <source>Objects of class Foo can be created in 2 ways:</source>
          <target state="translated">Los objetos de la clase Foo pueden ser creados de dos maneras:</target>
        </trans-unit>
        <trans-unit id="be69b1d70c47420d0477f00402fb1ba65d040235" translate="yes" xml:space="preserve">
          <source>On the other hand, if you have a buffer class whose constructor &lt;code&gt;Buffer(int size)&lt;/code&gt; takes the size of the buffer in bytes, you probably don't want the compiler to quietly turn &lt;code&gt;int&lt;/code&gt;s into &lt;code&gt;Buffer&lt;/code&gt;s.  To prevent that, you declare the constructor with the &lt;code&gt;explicit&lt;/code&gt; keyword:</source>
          <target state="translated">Por otro lado, si tiene una clase de b&amp;uacute;fer cuyo constructor &lt;code&gt;Buffer(int size)&lt;/code&gt; toma el tama&amp;ntilde;o del b&amp;uacute;fer en bytes, probablemente no desee que el compilador convierta silenciosamente &lt;code&gt;int&lt;/code&gt; s en &lt;code&gt;Buffer&lt;/code&gt; s. Para evitar eso, declara el constructor con la palabra clave &lt;code&gt;explicit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="d6cedf5b2ccb7066d6607cd21993a85101529ead" translate="yes" xml:space="preserve">
          <source>P.S. When using transformations defined BY USER (via constructors and type conversion operator) it is allowed only one level of implicit conversions used.
But you can combine this conversions with other language conversions</source>
          <target state="translated">P.D.Cuando se utilizan las transformaciones definidas POR EL USUARIO (a través de los constructores y el operador de conversión de tipos)sólo se permite un nivel de conversiones implícitas utilizadas.Pero se pueden combinar estas conversiones con otras conversiones de idiomas</target>
        </trans-unit>
        <trans-unit id="286bbf56a4eca72de3e0e6073d3b5007f5367c70" translate="yes" xml:space="preserve">
          <source>Prefixing the &lt;code&gt;explicit&lt;/code&gt; keyword to the constructor prevents the compiler from using that constructor for implicit conversions. Adding it to the above class will create a compiler error at the function call &lt;code&gt;DoBar (42)&lt;/code&gt;.  It is now necessary to call for conversion explicitly with  &lt;code&gt;DoBar (Foo (42))&lt;/code&gt;</source>
          <target state="translated">Prefijar la palabra clave &lt;code&gt;explicit&lt;/code&gt; en el constructor evita que el compilador use ese constructor para conversiones impl&amp;iacute;citas. Agregarlo a la clase anterior crear&amp;aacute; un error de compilaci&amp;oacute;n en la funci&amp;oacute;n llamada &lt;code&gt;DoBar (42)&lt;/code&gt; . Ahora es necesario llamar a la conversi&amp;oacute;n expl&amp;iacute;citamente con &lt;code&gt;DoBar (Foo (42))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76d5f62f8c52d90be7570576601501fb73d2b55f" translate="yes" xml:space="preserve">
          <source>Quick look</source>
          <target state="translated">Mirada rápida...</target>
        </trans-unit>
        <trans-unit id="f1021233aa532c3c5b4aa4bd03d6d0aa9b54f1cc" translate="yes" xml:space="preserve">
          <source>Suppose, you have a class &lt;code&gt;String&lt;/code&gt;:</source>
          <target state="translated">Supongamos que tiene una clase &lt;code&gt;String&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9ee6744ba51fc0295fd21067924362836fa5a24a" translate="yes" xml:space="preserve">
          <source>That way,</source>
          <target state="translated">Por ahí,</target>
        </trans-unit>
        <trans-unit id="1b7d5994338fd9ab33346c917fa397adc9476570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt; keyword makes a conversion constructor to non-conversion constructor. As a result, the code is less error prone.</source>
          <target state="translated">La palabra clave &lt;code&gt;explicit&lt;/code&gt; convierte un constructor de conversi&amp;oacute;n en un constructor de no conversi&amp;oacute;n. Como resultado, el c&amp;oacute;digo es menos propenso a errores.</target>
        </trans-unit>
        <trans-unit id="ddf9af1fc865c8001f9a0f7215ab0e3404df6b4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt;-keyword can also be used in user-defined type cast operators:</source>
          <target state="translated">La palabra clave &lt;code&gt;explicit&lt;/code&gt; tambi&amp;eacute;n se puede utilizar en operadores de conversi&amp;oacute;n de tipos definidos por el usuario:</target>
        </trans-unit>
        <trans-unit id="ce6a7532fd040432382447d8f75000df06c8721a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt;-keyword can be used to enforce a constructor to be called &lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">La palabra clave &lt;code&gt;explicit&lt;/code&gt; se puede usar para exigir que se llame &lt;em&gt;expl&amp;iacute;citamente&lt;/em&gt; a un constructor.</target>
        </trans-unit>
        <trans-unit id="a4c3f68e64b6d51aac772aa88db8426afc50c8aa" translate="yes" xml:space="preserve">
          <source>The argument is not a &lt;code&gt;Foo&lt;/code&gt; object, but an &lt;code&gt;int&lt;/code&gt;. However, there exists a constructor for &lt;code&gt;Foo&lt;/code&gt; that takes an &lt;code&gt;int&lt;/code&gt; so this constructor can be used to convert the parameter to the correct type.</source>
          <target state="translated">El argumento no es un objeto &lt;code&gt;Foo&lt;/code&gt; , sino un &lt;code&gt;int&lt;/code&gt; . Sin embargo, existe un constructor para &lt;code&gt;Foo&lt;/code&gt; que toma un &lt;code&gt;int&lt;/code&gt; para que este constructor se pueda usar para convertir el par&amp;aacute;metro al tipo correcto.</target>
        </trans-unit>
        <trans-unit id="3049d136f55a475626db3dad948b02469e9778f9" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;'x'&lt;/code&gt; will be implicitly converted to &lt;code&gt;int&lt;/code&gt; and then the &lt;code&gt;String(int)&lt;/code&gt; constructor will be called. But, this is not what the user might have intended. So, to prevent such conditions, we shall define the constructor as &lt;code&gt;explicit&lt;/code&gt;:</source>
          <target state="translated">El car&amp;aacute;cter &lt;code&gt;'x'&lt;/code&gt; se convertir&amp;aacute; impl&amp;iacute;citamente en &lt;code&gt;int&lt;/code&gt; y luego se llamar&amp;aacute; al constructor &lt;code&gt;String(int)&lt;/code&gt; . Pero, esto no es lo que el usuario podr&amp;iacute;a haber pretendido. Entonces, para evitar tales condiciones, definiremos el constructor como &lt;code&gt;explicit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2067a14f8d7ec35e3e14dc1571c9ef15e462e679" translate="yes" xml:space="preserve">
          <source>The compiler does not know wether to use the constructor of &lt;code&gt;U&lt;/code&gt; or the conversion function to convert the &lt;code&gt;V&lt;/code&gt; object into a type for passing to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">El compilador no sabe si usar el constructor de &lt;code&gt;U&lt;/code&gt; o la funci&amp;oacute;n de conversi&amp;oacute;n para convertir el objeto &lt;code&gt;V&lt;/code&gt; en un tipo para pasar a &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd2c9fb6422b9a6c94f550ada7376764badd6b9a" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to do this once for each parameter.</source>
          <target state="translated">El compilador puede hacer esto una vez para cada parámetro.</target>
        </trans-unit>
        <trans-unit id="c61dcda5620fa9ba492d6ebe7eca3691f7dedb65" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to make one implicit conversion to resolve the parameters to a function. What this means is that the compiler can use constructors callable with a &lt;strong&gt;single parameter&lt;/strong&gt; to convert from one type to another in order to get the right type for a parameter.</source>
          <target state="translated">El compilador puede realizar una conversi&amp;oacute;n impl&amp;iacute;cita para resolver los par&amp;aacute;metros a una funci&amp;oacute;n. Lo que esto significa es que el compilador puede usar constructores invocables con un &lt;strong&gt;solo par&amp;aacute;metro&lt;/strong&gt; para convertir de un tipo a otro para obtener el tipo correcto para un par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="c506586127aafb4571605139fe82715ddb3cb0e6" translate="yes" xml:space="preserve">
          <source>The explicit function specifier controls unwanted implicit type
  conversions. It can only be used in declarations of constructors
  within a class declaration. For example, except for the default
  constructor, the constructors in the following class are conversion
  constructors.</source>
          <target state="translated">El especificador de funciones explícitas controla las conversiones de tipos implícitos no deseados.Sólo puede utilizarse en declaraciones de constructores dentro de una declaración de clase.Por ejemplo,salvo el constructor por defecto,los constructores de la siguiente clase son constructores de conversión.</target>
        </trans-unit>
        <trans-unit id="aaaed950d829699c6b369f21001642be0a85ccc4" translate="yes" xml:space="preserve">
          <source>The explicit specifier specifies that a constructor or conversion function (since C++11) doesn't allow implicit conversions or copy-initialization.</source>
          <target state="translated">El especificador explícito especifica que una función de construcción o conversión (desde C++11)no permite conversiones implícitas o inicialización de copias.</target>
        </trans-unit>
        <trans-unit id="9e22fa09c228ce6e248691a575f81838d40d2ea5" translate="yes" xml:space="preserve">
          <source>The first declaration is equivalent to &lt;code&gt;A c = A( 1 );&lt;/code&gt;.</source>
          <target state="translated">La primera declaraci&amp;oacute;n es equivalente a &lt;code&gt;A c = A( 1 );&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80f1e63e6386d4a9d89289f1bf6b566c60d0ab41" translate="yes" xml:space="preserve">
          <source>The following declarations are legal:</source>
          <target state="translated">Las siguientes declaraciones son legales:</target>
        </trans-unit>
        <trans-unit id="1169f772595bc8ae74d724d600a7a87c62ff125b" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;explicit&lt;/code&gt; accompanies either</source>
          <target state="translated">La palabra clave &lt;code&gt;explicit&lt;/code&gt; acompa&amp;ntilde;a bien</target>
        </trans-unit>
        <trans-unit id="9c61164f85ca5b809d267efbbbea8840b12030f5" translate="yes" xml:space="preserve">
          <source>The reason you might want to do this is to avoid accidental construction that can hide bugs.  Contrived example:</source>
          <target state="translated">La razón por la que podrías querer hacer esto es para evitar la construcción accidental que puede ocultar los bichos.Ejemplo inventado:</target>
        </trans-unit>
        <trans-unit id="b4ba231f0faf7a6a4e919e6912719f1780af4a1e" translate="yes" xml:space="preserve">
          <source>This answer is about object creation with/without an explicit constructor since it is not covered in the other answers.</source>
          <target state="translated">Esta respuesta trata sobre la creación de objetos sin un constructor explícito ya que no está cubierta en las otras respuestas.</target>
        </trans-unit>
        <trans-unit id="78c2215507e93f78a74406cf7cb8018f79940750" translate="yes" xml:space="preserve">
          <source>This has already been discussed (&lt;a href=&quot;https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319&quot;&gt;what is explicit constructor&lt;/a&gt;). But I must say, that it lacks the detailed descriptions found here.</source>
          <target state="translated">Esto ya ha sido discutido ( &lt;a href=&quot;https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319&quot;&gt;qu&amp;eacute; es el constructor expl&amp;iacute;cito&lt;/a&gt; ). Pero debo decir que carece de las descripciones detalladas que se encuentran aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="77c49e3ca9f1370e49c1a2a3fdbf65a3dc598015" translate="yes" xml:space="preserve">
          <source>Using the explicit keyword in a class interface enforces the user of the interface to be explicit about a desired conversion.</source>
          <target state="translated">El uso de la palabra clave explícita en una interfaz de clase obliga al usuario de la interfaz a ser explícito sobre una conversión deseada.</target>
        </trans-unit>
        <trans-unit id="e281673a57e5bea475598290ff974afa1741081a" translate="yes" xml:space="preserve">
          <source>What does the &lt;code&gt;explicit&lt;/code&gt; keyword mean in C++?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; significa la palabra clave &lt;code&gt;explicit&lt;/code&gt; en C ++?</target>
        </trans-unit>
        <trans-unit id="ed5d4b7337e6a32f69ef31abb6b7b842c48d6f29" translate="yes" xml:space="preserve">
          <source>What does the explicit keyword mean</source>
          <target state="translated">¿Qué significa la palabra clave explícita</target>
        </trans-unit>
        <trans-unit id="5edb7164eb8327c49e3246ab6a67c8cc6391b808" translate="yes" xml:space="preserve">
          <source>What would one expect from such a call? One line containing &lt;code&gt;3&lt;/code&gt; or three lines containing &lt;code&gt;0&lt;/code&gt;? (Where the second one is what happens.)</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; esperar&amp;iacute;a uno de tal llamada? &amp;iquest;Una l&amp;iacute;nea que contiene &lt;code&gt;3&lt;/code&gt; o tres l&amp;iacute;neas que contienen &lt;code&gt;0&lt;/code&gt; ? (Donde el segundo es lo que sucede).</target>
        </trans-unit>
        <trans-unit id="35b2cad2dc0f1377d98ff2f0f160c44250275905" translate="yes" xml:space="preserve">
          <source>Why use &lt;code&gt;explicit&lt;/code&gt; conversion functions or constructors?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; usar funciones de conversi&amp;oacute;n &lt;code&gt;explicit&lt;/code&gt; o constructores?</target>
        </trans-unit>
        <trans-unit id="c22c511044cbc64591d114b9cd769d00a98cfe0f" translate="yes" xml:space="preserve">
          <source>You can only assign values that match the values of the class type.</source>
          <target state="translated">Sólo puede asignar valores que coincidan con los valores del tipo de clase.</target>
        </trans-unit>
        <trans-unit id="e087e20de6eff6911f7c8fa41bb5e3f6bb2cb100" translate="yes" xml:space="preserve">
          <source>You have a &lt;code&gt;MyString(int size)&lt;/code&gt; class with a constructor that constructs a string of the given size.  You have a function &lt;code&gt;print(const MyString&amp;amp;)&lt;/code&gt;, and you call &lt;code&gt;print(3)&lt;/code&gt; (when you &lt;em&gt;actually&lt;/em&gt; intended to call &lt;code&gt;print(&quot;3&quot;)&lt;/code&gt;).  You expect it to print &quot;3&quot;, but it prints an empty string of length 3 instead.</source>
          <target state="translated">Tiene una &lt;code&gt;MyString(int size)&lt;/code&gt; con un constructor que construye una cadena del tama&amp;ntilde;o dado. Tiene una funci&amp;oacute;n &lt;code&gt;print(const MyString&amp;amp;)&lt;/code&gt; , y llama a &lt;code&gt;print(3)&lt;/code&gt; (cuando &lt;em&gt;realmente&lt;/em&gt; ten&amp;iacute;a la intenci&amp;oacute;n de llamar a &lt;code&gt;print(&quot;3&quot;)&lt;/code&gt; ). Espera que imprima &quot;3&quot;, pero imprime una cadena vac&amp;iacute;a de longitud 3 en su lugar.</target>
        </trans-unit>
        <trans-unit id="3c93f07a155ea96a0b57d63ea157ae1ba6c82880" translate="yes" xml:space="preserve">
          <source>and here's where the &lt;code&gt;DoBar&lt;/code&gt; function is called.</source>
          <target state="translated">y aqu&amp;iacute; es donde se &lt;code&gt;DoBar&lt;/code&gt; funci&amp;oacute;n DoBar .</target>
        </trans-unit>
        <trans-unit id="80e76fd5e13a34f76dc82f7374cbbedf25d22621" translate="yes" xml:space="preserve">
          <source>becomes a compile-time error.  If you want to pass a temporary &lt;code&gt;Buffer&lt;/code&gt; object, you have to do so explicitly:</source>
          <target state="translated">se convierte en un error en tiempo de compilaci&amp;oacute;n. Si desea pasar un objeto &lt;code&gt;Buffer&lt;/code&gt; temporal, debe hacerlo expl&amp;iacute;citamente:</target>
        </trans-unit>
        <trans-unit id="d0bc31847e397dc9ce6f32057f43c91554466982" translate="yes" xml:space="preserve">
          <source>can both be used as single-argument constructors. So you may want to make these also &lt;code&gt;explicit&lt;/code&gt;.</source>
          <target state="translated">ambos pueden usarse como constructores de un solo argumento. Por lo tanto, es posible que desee hacer esto tambi&amp;eacute;n &lt;code&gt;explicit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1112e4645e1c510e383ffdb6d150959b4f130d21" translate="yes" xml:space="preserve">
          <source>convert pointers of objects to base class and to void*;</source>
          <target state="translated">convertir los punteros de los objetos a la clase base y al vacío*;</target>
        </trans-unit>
        <trans-unit id="19f768b20de266f72b8bd3b42fe489a61513ccf9" translate="yes" xml:space="preserve">
          <source>default arguments for all parameters, or</source>
          <target state="translated">argumentos por defecto para todos los parámetros,o</target>
        </trans-unit>
        <trans-unit id="fc3ae7b739a0d4b0a8161d16c99bc4a63b0ccc76" translate="yes" xml:space="preserve">
          <source>default arguments for the second parameter onwards</source>
          <target state="translated">argumentos por defecto para el segundo parámetro en adelante</target>
        </trans-unit>
        <trans-unit id="d9f4df0fccc3324ca442bc5a16211b9f8e047d00" translate="yes" xml:space="preserve">
          <source>standart conversions (int to double);</source>
          <target state="translated">conversiones estándar (int a doble);</target>
        </trans-unit>
        <trans-unit id="492f05458909b4e400b0f5f301b1c1261874ae73" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;explicit&lt;/code&gt;-keyword in front of the constructor &lt;code&gt;C(void)&lt;/code&gt; tells the compiler that only explicit call to this constructor is allowed.</source>
          <target state="translated">la palabra clave &lt;code&gt;explicit&lt;/code&gt; frente al constructor &lt;code&gt;C(void)&lt;/code&gt; le dice al compilador que solo se permite la llamada expl&amp;iacute;cita a este constructor.</target>
        </trans-unit>
        <trans-unit id="ba087709da18b56c1d734fe563e840114679f1d9" translate="yes" xml:space="preserve">
          <source>up integral ranks (char to int, float to double);</source>
          <target state="translated">...en los rangos integrales (char a int,flotar a doble);</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
