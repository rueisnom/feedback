<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/121162">
    <body>
      <group id="121162">
        <trans-unit id="6e909f16da04e6b4ba7a3dc42d76fb1fc131016b" translate="yes" xml:space="preserve">
          <source>1) A constructor declared without the function-specifier explicit specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a converting constructor.</source>
          <target state="translated">1) 명시 적으로 함수 지정자없이 선언 된 생성자는 매개 변수 유형에서 클래스 유형으로의 변환을 지정합니다. 이러한 생성자를 변환 생성자라고합니다.</target>
        </trans-unit>
        <trans-unit id="40075093fa2de375513bd7806fbfa585f1ccb88d" translate="yes" xml:space="preserve">
          <source>2) A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion for direct-initialization (8.5). Otherwise, user-defined conversions are not restricted to use in assignments
  and initializations.</source>
          <target state="translated">2) 변환 함수는 명시적일 수 있으며 (7.1.2)이 경우 직접 초기화를위한 사용자 정의 변환 (8.5)으로 만 간주됩니다. 그렇지 않으면 사용자 정의 변환이 할당 및 초기화에 사용되도록 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82c5d71d8413126d3518e4c637002b6b8aa3fbf6" translate="yes" xml:space="preserve">
          <source>2) An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or valueinitialization
  (8.5).</source>
          <target state="translated">2) 명시 적 생성자는 비명 시적 생성자와 같이 객체를 생성하지만 직접 초기화 구문 (8.5) 또는 캐스트 (5.2.9, 5.4)가 명시 적으로 사용되는 경우에만 생성합니다. 기본 생성자는 명시 적 생성자 일 수 있습니다. 이러한 생성자는 기본 초기화 또는 값 초기화 (8.5)를 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f26b74b665e2acdf88f5ec7e221b4624394b35b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx&quot;&gt;Here&lt;/a&gt; is a good write-up on explicit constructors.</source>
          <target state="translated">&lt;a href=&quot;http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx&quot;&gt;다음&lt;/a&gt; 은 명시 적 생성자에 대한 좋은 글입니다.</target>
        </trans-unit>
        <trans-unit id="fb9d903b66d4b86f2a3d5b0e7ce99773805eec0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ [class.conv.ctor]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ [class.conv.ctor]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e76638e98bf8cd3442bd39601d1b5f75737ea3a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ [class.conv.fct]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ [class.conv.fct]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dcec192ad51b7af512d87c6084e215eb361da2a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion constructors and non-explicit conversion functions may introduce ambiguity.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;변환 생성자와 명시 적이 지 않은 변환 함수는 모호성을 유발할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e074b33cdf4fd9146a172fd109876e5aaa6831fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion constructors and non-explicit conversion functions may lead to unexpected behaviour.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;변환 생성자와 명시 적이 지 않은 변환 함수는 예기치 않은 동작을 유발할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="404f447a2f27e2777f7b751f552e0208232d38cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explicit conversion constructors (C++ only)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;명시 적 변환 생성자 (C ++ 만 해당)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9e1424d19737c3e0e14bad461887396f1689093" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;a constructor of class X that cannot be used to implicitly convert the first (any only) parameter to type X&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;암시 적으로 첫 번째 매개 변수를 유형 X로 변환하는 데 사용할 수없는 클래스 X의 생성자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0b9c3a76bec2b3865fa08d11db98c0d983d43a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;or a conversion function that is only considered for direct initialization and explicit conversion.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;또는 직접 초기화 및 명시 적 변환에만 고려되는 변환 함수.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90931b1495f819faf9ec90d5e4e0e1fc229bdff3" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;f&lt;/code&gt; is ambiguous if passing an object of type &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 유형의 객체를 전달하면 &lt;code&gt;f&lt;/code&gt; 에 대한 호출이 모호합니다.</target>
        </trans-unit>
        <trans-unit id="ef58e46d65d0f651d7e99ff4af68f72c49935b2e" translate="yes" xml:space="preserve">
          <source>An example when you would deliberately &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; want to make your single-argument constructor explicit is if you're creating a functor (look at the 'add_x' struct declared in &lt;a href=&quot;https://stackoverflow.com/a/356993/793930&quot;&gt;this&lt;/a&gt; answer). In such a case, creating an object as &lt;code&gt;add_x add30 = 30;&lt;/code&gt; would probably make sense.</source>
          <target state="translated">의도적으로 단일 인수 생성자를 명시 적으로 만들고 싶지 &lt;strong&gt;&lt;em&gt;않은&lt;/em&gt;&lt;/strong&gt; 예는 functor를 만드는 경우입니다 ( &lt;a href=&quot;https://stackoverflow.com/a/356993/793930&quot;&gt;이&lt;/a&gt; 답변에 선언 된 'add_x'구조를보십시오). 이 경우 &lt;code&gt;add_x add30 = 30;&lt;/code&gt; 과 같은 객체를 생성합니다 . 아마 이해가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="023d40884b32ae99ad8ee9224964e2bf68369ac5" translate="yes" xml:space="preserve">
          <source>Another good practice for classes is to make copy construction and assignment private (a.k.a. disable it) unless you really need to implement it. This avoids having eventual copies of pointers when using the methods that C++ will create for you by default. An other way to do this is derive from boost::noncopyable.</source>
          <target state="translated">수업에 대한 또 다른 모범 사례는 실제로 구현해야 할 경우가 아니라면 복사본 구성 및 할당을 비공개로 만드는 것입니다 (일명 비활성화). 이렇게하면 C ++에서 기본적으로 생성 할 메서드를 사용할 때 최종 포인터 복사본이 생기지 않습니다. 이를 수행하는 다른 방법은 boost :: noncopyable에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="93fa74ff062a4f43bee8427c70d3f3e8e2eb398e" translate="yes" xml:space="preserve">
          <source>As Bjarne Stroustrup  puts it (in &quot;The C++ Programming Language&quot;, 4th Ed., 35.2.1, pp. 1011) on the question why &lt;code&gt;std::duration&lt;/code&gt; cannot be implicitly constructed from a plain number:</source>
          <target state="translated">Bjarne Stroustrup이 &lt;code&gt;std::duration&lt;/code&gt; 을 일반 숫자로 암시 적으로 구성 할 수없는 이유에 대한 질문에 대해 &quot;C ++ Programming Language&quot;, 4th Ed., 35.2.1, pp. 1011)에 설명했습니다.</target>
        </trans-unit>
        <trans-unit id="91abe90d799140d96614d181c106b32f8cccead0" translate="yes" xml:space="preserve">
          <source>Besides, it is always a good coding practice to make your one argument constructors (including those with default values for arg2,arg3,...) as already stated. 
Like always with C++: if you don't - you'll wish you did...</source>
          <target state="translated">게다가, 이미 언급 한대로 하나의 인수 생성자 (arg2, arg3, ...에 대한 기본값을 가진 것을 포함)를 만드는 것이 항상 좋은 코딩 관행입니다. C ++에서와 마찬가지로 항상 그렇지 않은 경우</target>
        </trans-unit>
        <trans-unit id="8056a96d70581f55a1f36421d40b18baa0983d53" translate="yes" xml:space="preserve">
          <source>Consider a function printing some vector:</source>
          <target state="translated">벡터를 인쇄하는 함수를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ffabce6768c306d54af29bfe6cecee317c83c262" translate="yes" xml:space="preserve">
          <source>Consider a structure &lt;code&gt;V&lt;/code&gt;, convertible to &lt;code&gt;int&lt;/code&gt;, a structure &lt;code&gt;U&lt;/code&gt; implicitly constructible from &lt;code&gt;V&lt;/code&gt; and a function &lt;code&gt;f&lt;/code&gt; overloaded for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 로 변환 가능한 구조 &lt;code&gt;V&lt;/code&gt; , V 에서 암시 적으로 구성 가능한 구조 &lt;code&gt;U&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 와 &lt;code&gt;bool&lt;/code&gt; 에 각각 오버로드 된 함수 &lt;code&gt;f&lt;/code&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="019b9c3fbcd9fbed06290bc41f9a48781e74ba91" translate="yes" xml:space="preserve">
          <source>Consider the following class without an explicit constructor:</source>
          <target state="translated">명시적인 생성자가없는 다음 클래스를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f1f6cc578a73fda02c3a246d96eb579f34559dea" translate="yes" xml:space="preserve">
          <source>Constructors append implicit conversion. To suppress this implicit conversion it is required to declare a constructor with a parameter explicit.</source>
          <target state="translated">생성자는 암시 적 변환을 추가합니다. 이 암시 적 변환을 억제하려면 명시 적 매개 변수를 사용하여 생성자를 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="18f1b770126acc40cb179db8016ea3c6af74a605" translate="yes" xml:space="preserve">
          <source>Conversion of a function argument:</source>
          <target state="translated">함수 인수의 변환 :</target>
        </trans-unit>
        <trans-unit id="c8f4b2cde6b3fe7edba64d7e515a710a2e2df98c" translate="yes" xml:space="preserve">
          <source>Cpp Reference is always helpful!!! Details about explicit specifier can be found &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;here&lt;/a&gt;.  You may need to look at &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/implicit_conversion&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; too.</source>
          <target state="translated">Cpp 참조는 항상 도움이됩니다 !!! 명시 적 지정자에 대한 자세한 내용은 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;여기를 참조하십시오&lt;/a&gt; . &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/implicit_conversion&quot;&gt;암시 적 변환&lt;/a&gt; 과 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_initialization&quot;&gt;복사 초기화&lt;/a&gt; 도 살펴 봐야합니다.</target>
        </trans-unit>
        <trans-unit id="e32c5521f2cec3f8f4baa216e8f949d5b512fcca" translate="yes" xml:space="preserve">
          <source>Depending upon the implementation, the second manner of instantiating class Foo may be confusing, or not what the programmer intended. Prefixing the &lt;code&gt;explicit&lt;/code&gt; keyword to the constructor would generate a compiler error at &lt;code&gt;Foo bar2 = 20;&lt;/code&gt;.</source>
          <target state="translated">구현에 따라, 클래스 Foo를 인스턴스화하는 두 번째 방법은 혼란 스럽거나 프로그래머가 의도 한 것과 다를 수 있습니다. &lt;code&gt;explicit&lt;/code&gt; 키워드를 생성자 &lt;code&gt;Foo bar2 = 20;&lt;/code&gt; 에서 컴파일러 오류가 발생합니다 . .</target>
        </trans-unit>
        <trans-unit id="30a2e91c6246a99a6f1219373a019d7d3616ee87" translate="yes" xml:space="preserve">
          <source>Example as follows:</source>
          <target state="translated">다음과 같은 예 :</target>
        </trans-unit>
        <trans-unit id="6f3ba8e6e3b35cf9dfa1800107ec407650feff17" translate="yes" xml:space="preserve">
          <source>Example using structures &lt;code&gt;X, Y, Z&lt;/code&gt; and functions &lt;code&gt;foo, bar, baz&lt;/code&gt;:</source>
          <target state="translated">구조 &lt;code&gt;X, Y, Z&lt;/code&gt; 하고 &lt;code&gt;foo, bar, baz&lt;/code&gt; 함수를 사용하는 예제 :</target>
        </trans-unit>
        <trans-unit id="c4391c5871b2591466f38ed051125c3a6b72b655" translate="yes" xml:space="preserve">
          <source>Examples regarding constructor:</source>
          <target state="translated">생성자 관련 예제 :</target>
        </trans-unit>
        <trans-unit id="6a4208acecf2caa67ad142db501f1e7edba9301f" translate="yes" xml:space="preserve">
          <source>Examples regarding conversion functions:</source>
          <target state="translated">변환 함수에 관한 예 :</target>
        </trans-unit>
        <trans-unit id="63cd5534db30ee33eabaed9b35dad8b9682be58f" translate="yes" xml:space="preserve">
          <source>Explicit conversion functions and constructors can only be used for explicit conversions (direct initialization or explicit cast operation) while non-explicit constructors and conversion functions can be used for implicit as well as explicit conversions.</source>
          <target state="translated">명시 적 변환 함수 및 생성자는 명시 적 변환 (직접 초기화 또는 명시 적 캐스트 작업)에만 사용할 수 있으며, 명시 적이 지 않은 생성자와 변환 함수는 명시 적 변환뿐만 아니라 암시 적 변환에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="483334b7421e283b810cc10b297ff1ff94e618b1" translate="yes" xml:space="preserve">
          <source>For example, if you declare the class as:</source>
          <target state="translated">예를 들어 클래스를 다음과 같이 선언하면</target>
        </trans-unit>
        <trans-unit id="a20de6e76729d51851c56bf373b29f18ff5bb561" translate="yes" xml:space="preserve">
          <source>For example, if you have a string class with constructor &lt;code&gt;String(const char* s)&lt;/code&gt;, that's probably exactly what you want.  You can pass a &lt;code&gt;const char*&lt;/code&gt; to a function expecting a &lt;code&gt;String&lt;/code&gt;, and the compiler will automatically construct a temporary &lt;code&gt;String&lt;/code&gt; object for you.</source>
          <target state="translated">예를 들어, 생성자 &lt;code&gt;String(const char* s)&lt;/code&gt; 가진 문자열 클래스가 있다면 아마도 원하는 것입니다. &lt;code&gt;String&lt;/code&gt; 을 기대하는 함수에 &lt;code&gt;const char*&lt;/code&gt; 를 전달하면 컴파일러가 자동으로 임시 &lt;code&gt;String&lt;/code&gt; 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="03739c543e63532d2e0ee64e937635e148313674" translate="yes" xml:space="preserve">
          <source>For example, the following statements are legal:</source>
          <target state="translated">예를 들어, 다음 내용은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="05fa6736aea3a744782881e661a2c437953ca80b" translate="yes" xml:space="preserve">
          <source>Here's a simple function that takes a &lt;code&gt;Foo&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; 객체를 취하는 간단한 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e43ffb6522ca8f869078d171d24a79cea9ba5d3" translate="yes" xml:space="preserve">
          <source>Here's an example class with a constructor that can be used for implicit conversions:</source>
          <target state="translated">암시 적 변환에 사용할 수있는 생성자가있는 예제 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc9d2bdfb3652039da2c1f77188f4475b0334b02" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;explicit&lt;/code&gt;-keyword enforces only explicit casts to be valid, so &lt;code&gt;bool b = c;&lt;/code&gt; would be an invalid cast in this case. In situations like these &lt;code&gt;explicit&lt;/code&gt;-keyword can help programmer to avoid implicit, unintended casts. This usage has been standardized in &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cast_operator&quot;&gt;C++11&lt;/a&gt;.</source>
          <target state="translated">여기에서 &lt;code&gt;explicit&lt;/code&gt; -keyword는 명시 적 캐스트 만 유효하게하므로 &lt;code&gt;bool b = c;&lt;/code&gt; 이 경우 유효하지 않은 캐스트입니다. 이러한 &lt;code&gt;explicit&lt;/code&gt; 키워드와 같은 상황에서 프로그래머는 의도하지 않은 암시 적 캐스트를 피할 수 있습니다. 이 사용법은 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cast_operator&quot;&gt;C ++ 11&lt;/a&gt; 에서 표준화되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ecde5e33b6842aae9586216bde3d7c062492300" translate="yes" xml:space="preserve">
          <source>If either the constructor of &lt;code&gt;U&lt;/code&gt; or the conversion function of &lt;code&gt;V&lt;/code&gt; would be &lt;code&gt;explicit&lt;/code&gt;, there would be no ambiguity since only the non-explicit conversion would be considered. If both are explicit the call to &lt;code&gt;f&lt;/code&gt; using an object of type &lt;code&gt;V&lt;/code&gt; would have to be done using an explicit conversion or cast operation.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; 의 생성자 또는 &lt;code&gt;V&lt;/code&gt; 의 변환 함수가 &lt;code&gt;explicit&lt;/code&gt; 이면 비명 시적 변환 만 고려되므로 모호성이 없습니다. 둘 다 명시 적이면 &lt;code&gt;V&lt;/code&gt; 유형의 오브젝트를 사용하여 &lt;code&gt;f&lt;/code&gt; 를 호출하면 명시 적 변환 또는 캐스트 조작을 사용하여 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="24f97f1f66fe055c12d92257a5a1d131d926faa9" translate="yes" xml:space="preserve">
          <source>If the size-constructor of the vector would not be explicit it would be possible to call the function like this:</source>
          <target state="translated">벡터의 크기 생성자가 명시 적이 지 않으면 다음과 같이 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="124132f57abb337ccbdded8265bd7ff12e02cb28" translate="yes" xml:space="preserve">
          <source>If you declare the constructor of the class as &lt;code&gt;explicit&lt;/code&gt;, the previous declarations would be illegal.</source>
          <target state="translated">클래스의 생성자를 &lt;code&gt;explicit&lt;/code&gt; 로 선언하면 위의 선언은 불법입니다.</target>
        </trans-unit>
        <trans-unit id="dcfb0600299ba6b050382cf5b290106184e86d09" translate="yes" xml:space="preserve">
          <source>If you know what you mean, be explicit about it.</source>
          <target state="translated">당신이 무슨 뜻인지 알면 그것에 대해 명시하십시오.</target>
        </trans-unit>
        <trans-unit id="2a7badbe21782e07fa940bd63da839e4f99542d5" translate="yes" xml:space="preserve">
          <source>In C++, a constructor with only one required parameter is considered an implicit conversion function.  It converts the parameter type to the class type.  Whether this is a good thing or not depends on the semantics of the constructor.</source>
          <target state="translated">C ++에서 필수 매개 변수가 하나만있는 생성자는 암시 적 변환 함수로 간주됩니다. 매개 변수 유형을 클래스 유형으로 변환합니다. 이것이 좋은지 아닌지는 생성자의 의미에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="96a5269e608660ea6a121ce099af5f98a9d89d48" translate="yes" xml:space="preserve">
          <source>In C++11 you can also specify an &quot;operator type()&quot; with such keyword &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;http://en.cppreference.com/w/cpp/language/explicit&lt;/a&gt; With such specification you can use operator in terms of explicit conversions, and direct initialization of object.</source>
          <target state="translated">C ++ 11에서는 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;http://en.cppreference.com/w/cpp/language/explicit&lt;/a&gt; 키워드를 사용하여 &quot;연산자 유형 ()&quot;을 지정할 수도 있습니다. 이러한 사양에서는 명시 적 변환 측면에서 연산자를 사용할 수 있으며 객체의 직접 초기화.</target>
        </trans-unit>
        <trans-unit id="0f99c78ff8610e39b8faa30a4b5ef71196baf577" translate="yes" xml:space="preserve">
          <source>In summary, if your single-parameter constructor converts the parameter into an object of your class, you probably don't want to use the &lt;code&gt;explicit&lt;/code&gt; keyword.  But if you have a constructor that simply happens to take a single parameter, you should declare it as &lt;code&gt;explicit&lt;/code&gt; to prevent the compiler from surprising you with unexpected conversions.</source>
          <target state="translated">요약하면, 단일 매개 변수 생성자가 매개 변수를 클래스의 오브젝트로 변환하는 경우 &lt;code&gt;explicit&lt;/code&gt; 키워드를 사용하지 않을 수 있습니다. 그러나 단순히 단일 매개 변수를 취하는 생성자가있는 경우 컴파일러가 예기치 않은 변환으로 놀라지 않도록 &lt;code&gt;explicit&lt;/code&gt; 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2cb9e61565f9bb201c8b94447f641b04a3f7c24" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;usually&lt;/em&gt; good practice to declare single-argument constructors as &lt;code&gt;explicit&lt;/code&gt;, unless your implementation specifically prohibits it.</source>
          <target state="translated">구현에서 특별히 금지하지 않는 한 단일 인수 생성자를 &lt;code&gt;explicit&lt;/code&gt; 으로 선언하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="76e264a3ab2feb73628e60003fbf19c73f2596d8" translate="yes" xml:space="preserve">
          <source>Let's look at a small setup of structures and functions to see the difference between &lt;code&gt;explicit&lt;/code&gt; and non-&lt;code&gt;explicit&lt;/code&gt; conversions.</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; 변환과 명시 적이 지 않은 변환의 차이점을 확인하기 위해 작은 구조와 함수 설정을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a1efdc398882ef52a5c56f27be4e597b6de6ca5f" translate="yes" xml:space="preserve">
          <source>Note also that constructors with</source>
          <target state="translated">또한 생성자가</target>
        </trans-unit>
        <trans-unit id="0caae2186a2fb9fc2295d889a7ef4e74ade7ad33" translate="yes" xml:space="preserve">
          <source>Now, if you try:</source>
          <target state="translated">시도하면</target>
        </trans-unit>
        <trans-unit id="207a36c11ea6ea8e3440a8af2255c0d19b55487e" translate="yes" xml:space="preserve">
          <source>Object initialization:</source>
          <target state="translated">객체 초기화 :</target>
        </trans-unit>
        <trans-unit id="d5ddf0ad260d5cf6434f9b9c3e83655bd62daf1e" translate="yes" xml:space="preserve">
          <source>Objects of class Foo can be created in 2 ways:</source>
          <target state="translated">Foo 클래스의 객체는 두 가지 방법으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be69b1d70c47420d0477f00402fb1ba65d040235" translate="yes" xml:space="preserve">
          <source>On the other hand, if you have a buffer class whose constructor &lt;code&gt;Buffer(int size)&lt;/code&gt; takes the size of the buffer in bytes, you probably don't want the compiler to quietly turn &lt;code&gt;int&lt;/code&gt;s into &lt;code&gt;Buffer&lt;/code&gt;s.  To prevent that, you declare the constructor with the &lt;code&gt;explicit&lt;/code&gt; keyword:</source>
          <target state="translated">반면에 생성자 &lt;code&gt;Buffer(int size)&lt;/code&gt; 가 버퍼의 크기를 바이트 단위로하는 버퍼 클래스가 있다면 컴파일러가 &lt;code&gt;int&lt;/code&gt; 를 &lt;code&gt;Buffer&lt;/code&gt; 로 조용히 바꾸고 싶지 않을 것입니다. 이를 방지하기 위해 &lt;code&gt;explicit&lt;/code&gt; 키워드를 사용하여 생성자를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="d6cedf5b2ccb7066d6607cd21993a85101529ead" translate="yes" xml:space="preserve">
          <source>P.S. When using transformations defined BY USER (via constructors and type conversion operator) it is allowed only one level of implicit conversions used.
But you can combine this conversions with other language conversions</source>
          <target state="translated">PS USER가 정의한 변환 (생성자 및 유형 변환 연산자를 통해)을 사용하는 경우 한 수준의 암시 적 변환 만 사용할 수 있습니다. 그러나이 변환을 다른 언어 변환과 결합 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="286bbf56a4eca72de3e0e6073d3b5007f5367c70" translate="yes" xml:space="preserve">
          <source>Prefixing the &lt;code&gt;explicit&lt;/code&gt; keyword to the constructor prevents the compiler from using that constructor for implicit conversions. Adding it to the above class will create a compiler error at the function call &lt;code&gt;DoBar (42)&lt;/code&gt;.  It is now necessary to call for conversion explicitly with  &lt;code&gt;DoBar (Foo (42))&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; 키워드를 생성자 앞에 추가하면 컴파일러가 암시 적 변환에 해당 생성자를 사용하지 못합니다. 위 클래스에 추가하면 함수 호출 &lt;code&gt;DoBar (42)&lt;/code&gt; 에서 컴파일러 오류가 발생합니다. 이제 &lt;code&gt;DoBar (Foo (42))&lt;/code&gt; 하여 명시 적으로 변환을 호출해야합니다 (Foo (42)).</target>
        </trans-unit>
        <trans-unit id="76d5f62f8c52d90be7570576601501fb73d2b55f" translate="yes" xml:space="preserve">
          <source>Quick look</source>
          <target state="translated">한눈에</target>
        </trans-unit>
        <trans-unit id="f1021233aa532c3c5b4aa4bd03d6d0aa9b54f1cc" translate="yes" xml:space="preserve">
          <source>Suppose, you have a class &lt;code&gt;String&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 클래스가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="9ee6744ba51fc0295fd21067924362836fa5a24a" translate="yes" xml:space="preserve">
          <source>That way,</source>
          <target state="translated">그런 식으로,</target>
        </trans-unit>
        <trans-unit id="1b7d5994338fd9ab33346c917fa397adc9476570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt; keyword makes a conversion constructor to non-conversion constructor. As a result, the code is less error prone.</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; 키워드는 변환 생성자를 비 변환 생성자로 만듭니다. 결과적으로 코드 오류가 적습니다.</target>
        </trans-unit>
        <trans-unit id="ddf9af1fc865c8001f9a0f7215ab0e3404df6b4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt;-keyword can also be used in user-defined type cast operators:</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; -keyword는 사용자 정의 유형 캐스트 ​​연산자에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce6a7532fd040432382447d8f75000df06c8721a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt;-keyword can be used to enforce a constructor to be called &lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; 키워드를 사용하여 생성자가 &lt;em&gt;명시 적&lt;/em&gt; 으로 호출되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c3f68e64b6d51aac772aa88db8426afc50c8aa" translate="yes" xml:space="preserve">
          <source>The argument is not a &lt;code&gt;Foo&lt;/code&gt; object, but an &lt;code&gt;int&lt;/code&gt;. However, there exists a constructor for &lt;code&gt;Foo&lt;/code&gt; that takes an &lt;code&gt;int&lt;/code&gt; so this constructor can be used to convert the parameter to the correct type.</source>
          <target state="translated">인수는 &lt;code&gt;Foo&lt;/code&gt; 객체가 아니라 &lt;code&gt;int&lt;/code&gt; 입니다. 그러나 &lt;code&gt;int&lt;/code&gt; 를 사용하는 &lt;code&gt;Foo&lt;/code&gt; 용 생성자가 있으므로이 생성자를 사용하여 매개 변수를 올바른 유형으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3049d136f55a475626db3dad948b02469e9778f9" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;'x'&lt;/code&gt; will be implicitly converted to &lt;code&gt;int&lt;/code&gt; and then the &lt;code&gt;String(int)&lt;/code&gt; constructor will be called. But, this is not what the user might have intended. So, to prevent such conditions, we shall define the constructor as &lt;code&gt;explicit&lt;/code&gt;:</source>
          <target state="translated">문자 &lt;code&gt;'x'&lt;/code&gt; 는 암시 적으로 &lt;code&gt;int&lt;/code&gt; 로 변환 된 다음 &lt;code&gt;String(int)&lt;/code&gt; 생성자가 호출됩니다. 그러나 이것은 사용자가 의도 한 것이 아닙니다. 따라서 이러한 조건을 방지하기 위해 생성자를 &lt;code&gt;explicit&lt;/code&gt; 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="2067a14f8d7ec35e3e14dc1571c9ef15e462e679" translate="yes" xml:space="preserve">
          <source>The compiler does not know wether to use the constructor of &lt;code&gt;U&lt;/code&gt; or the conversion function to convert the &lt;code&gt;V&lt;/code&gt; object into a type for passing to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 &lt;code&gt;U&lt;/code&gt; 의 생성자 또는 변환 함수를 사용하여 &lt;code&gt;V&lt;/code&gt; 객체를 &lt;code&gt;f&lt;/code&gt; 로 전달하기위한 유형으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd2c9fb6422b9a6c94f550ada7376764badd6b9a" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to do this once for each parameter.</source>
          <target state="translated">컴파일러는 각 매개 변수에 대해이 작업을 한 번 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c61dcda5620fa9ba492d6ebe7eca3691f7dedb65" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to make one implicit conversion to resolve the parameters to a function. What this means is that the compiler can use constructors callable with a &lt;strong&gt;single parameter&lt;/strong&gt; to convert from one type to another in order to get the right type for a parameter.</source>
          <target state="translated">컴파일러는 매개 변수를 함수로 해석하기 위해 하나의 암시 적 변환을 수행 할 수 있습니다. 이것은 컴파일러가 &lt;strong&gt;단일 매개 변수&lt;/strong&gt; 로 호출 가능한 생성자를 사용하여 매개 변수에 적합한 유형을 얻기 위해 한 유형에서 다른 유형으로 변환 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c506586127aafb4571605139fe82715ddb3cb0e6" translate="yes" xml:space="preserve">
          <source>The explicit function specifier controls unwanted implicit type
  conversions. It can only be used in declarations of constructors
  within a class declaration. For example, except for the default
  constructor, the constructors in the following class are conversion
  constructors.</source>
          <target state="translated">명시 적 함수 지정자는 원치 않는 암시 적 유형 변환을 제어합니다. 클래스 선언 내에서 생성자 선언에만 사용할 수 있습니다. 예를 들어 기본 생성자를 제외하고 다음 클래스의 생성자는 변환 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="aaaed950d829699c6b369f21001642be0a85ccc4" translate="yes" xml:space="preserve">
          <source>The explicit specifier specifies that a constructor or conversion function (since C++11) doesn't allow implicit conversions or copy-initialization.</source>
          <target state="translated">명시 적 지정자는 생성자 또는 변환 함수 (C ++ 11부터)가 암시 적 변환 또는 복사 초기화를 허용하지 않도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9e22fa09c228ce6e248691a575f81838d40d2ea5" translate="yes" xml:space="preserve">
          <source>The first declaration is equivalent to &lt;code&gt;A c = A( 1 );&lt;/code&gt;.</source>
          <target state="translated">첫 번째 선언은 &lt;code&gt;A c = A( 1 );&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80f1e63e6386d4a9d89289f1bf6b566c60d0ab41" translate="yes" xml:space="preserve">
          <source>The following declarations are legal:</source>
          <target state="translated">다음 선언은 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="1169f772595bc8ae74d724d600a7a87c62ff125b" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;explicit&lt;/code&gt; accompanies either</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; 키워드는</target>
        </trans-unit>
        <trans-unit id="9c61164f85ca5b809d267efbbbea8840b12030f5" translate="yes" xml:space="preserve">
          <source>The reason you might want to do this is to avoid accidental construction that can hide bugs.  Contrived example:</source>
          <target state="translated">이렇게하려면 버그를 숨길 수있는 우발적 인 구성을 피해야합니다. 고안된 예 :</target>
        </trans-unit>
        <trans-unit id="b4ba231f0faf7a6a4e919e6912719f1780af4a1e" translate="yes" xml:space="preserve">
          <source>This answer is about object creation with/without an explicit constructor since it is not covered in the other answers.</source>
          <target state="translated">이 답변은 다른 답변에서 다루지 않기 때문에 명시 적 생성자가 있거나없는 객체 생성에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="78c2215507e93f78a74406cf7cb8018f79940750" translate="yes" xml:space="preserve">
          <source>This has already been discussed (&lt;a href=&quot;https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319&quot;&gt;what is explicit constructor&lt;/a&gt;). But I must say, that it lacks the detailed descriptions found here.</source>
          <target state="translated">이것은 이미 논의되었습니다 ( &lt;a href=&quot;https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319&quot;&gt;명시적인 생성자&lt;/a&gt; ). 그러나 여기에는 자세한 설명이 없습니다.</target>
        </trans-unit>
        <trans-unit id="77c49e3ca9f1370e49c1a2a3fdbf65a3dc598015" translate="yes" xml:space="preserve">
          <source>Using the explicit keyword in a class interface enforces the user of the interface to be explicit about a desired conversion.</source>
          <target state="translated">클래스 인터페이스에서 explicit 키워드를 사용하면 인터페이스 사용자가 원하는 변환에 대해 명시 적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e281673a57e5bea475598290ff974afa1741081a" translate="yes" xml:space="preserve">
          <source>What does the &lt;code&gt;explicit&lt;/code&gt; keyword mean in C++?</source>
          <target state="translated">C ++에서 &lt;code&gt;explicit&lt;/code&gt; 키워드는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="ed5d4b7337e6a32f69ef31abb6b7b842c48d6f29" translate="yes" xml:space="preserve">
          <source>What does the explicit keyword mean</source>
          <target state="translated">명시 적 키워드의 의미</target>
        </trans-unit>
        <trans-unit id="5edb7164eb8327c49e3246ab6a67c8cc6391b808" translate="yes" xml:space="preserve">
          <source>What would one expect from such a call? One line containing &lt;code&gt;3&lt;/code&gt; or three lines containing &lt;code&gt;0&lt;/code&gt;? (Where the second one is what happens.)</source>
          <target state="translated">그러한 부름에서 무엇을 기대할 수 있습니까? &lt;code&gt;0&lt;/code&gt; 을 포함하는 &lt;code&gt;3&lt;/code&gt; 개 또는 3 개의 행을 포함하는 한 줄? (두 번째가 일어나는 곳).</target>
        </trans-unit>
        <trans-unit id="35b2cad2dc0f1377d98ff2f0f160c44250275905" translate="yes" xml:space="preserve">
          <source>Why use &lt;code&gt;explicit&lt;/code&gt; conversion functions or constructors?</source>
          <target state="translated">왜 &lt;code&gt;explicit&lt;/code&gt; 변환 함수 나 생성자를 사용합니까?</target>
        </trans-unit>
        <trans-unit id="c22c511044cbc64591d114b9cd769d00a98cfe0f" translate="yes" xml:space="preserve">
          <source>You can only assign values that match the values of the class type.</source>
          <target state="translated">클래스 유형의 값과 일치하는 값만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e087e20de6eff6911f7c8fa41bb5e3f6bb2cb100" translate="yes" xml:space="preserve">
          <source>You have a &lt;code&gt;MyString(int size)&lt;/code&gt; class with a constructor that constructs a string of the given size.  You have a function &lt;code&gt;print(const MyString&amp;amp;)&lt;/code&gt;, and you call &lt;code&gt;print(3)&lt;/code&gt; (when you &lt;em&gt;actually&lt;/em&gt; intended to call &lt;code&gt;print(&quot;3&quot;)&lt;/code&gt;).  You expect it to print &quot;3&quot;, but it prints an empty string of length 3 instead.</source>
          <target state="translated">주어진 크기의 문자열을 생성하는 생성자를 가진 &lt;code&gt;MyString(int size)&lt;/code&gt; 클래스가 있습니다. &lt;code&gt;print(const MyString&amp;amp;)&lt;/code&gt; 함수가 있고 &lt;code&gt;print(3)&lt;/code&gt; 을 호출합니다 ( &lt;em&gt;실제로&lt;/em&gt; &lt;code&gt;print(&quot;3&quot;)&lt;/code&gt; 을 호출하려는 경우). &quot;3&quot;을 인쇄 할 것으로 예상되지만 대신 길이가 3 인 빈 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3c93f07a155ea96a0b57d63ea157ae1ba6c82880" translate="yes" xml:space="preserve">
          <source>and here's where the &lt;code&gt;DoBar&lt;/code&gt; function is called.</source>
          <target state="translated">여기 &lt;code&gt;DoBar&lt;/code&gt; 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="80e76fd5e13a34f76dc82f7374cbbedf25d22621" translate="yes" xml:space="preserve">
          <source>becomes a compile-time error.  If you want to pass a temporary &lt;code&gt;Buffer&lt;/code&gt; object, you have to do so explicitly:</source>
          <target state="translated">컴파일 타임 오류가됩니다. 임시 &lt;code&gt;Buffer&lt;/code&gt; 객체를 전달하려면 명시 적으로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0bc31847e397dc9ce6f32057f43c91554466982" translate="yes" xml:space="preserve">
          <source>can both be used as single-argument constructors. So you may want to make these also &lt;code&gt;explicit&lt;/code&gt;.</source>
          <target state="translated">둘 다 단일 인수 생성자로 사용할 수 있습니다. 따라서이를 &lt;code&gt;explicit&lt;/code&gt; 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1112e4645e1c510e383ffdb6d150959b4f130d21" translate="yes" xml:space="preserve">
          <source>convert pointers of objects to base class and to void*;</source>
          <target state="translated">객체의 포인터를 기본 클래스와 void *로 변환;</target>
        </trans-unit>
        <trans-unit id="19f768b20de266f72b8bd3b42fe489a61513ccf9" translate="yes" xml:space="preserve">
          <source>default arguments for all parameters, or</source>
          <target state="translated">모든 매개 변수에 대한 기본 인수 또는</target>
        </trans-unit>
        <trans-unit id="fc3ae7b739a0d4b0a8161d16c99bc4a63b0ccc76" translate="yes" xml:space="preserve">
          <source>default arguments for the second parameter onwards</source>
          <target state="translated">두 번째 매개 변수의 기본 인수</target>
        </trans-unit>
        <trans-unit id="d9f4df0fccc3324ca442bc5a16211b9f8e047d00" translate="yes" xml:space="preserve">
          <source>standart conversions (int to double);</source>
          <target state="translated">표준 변환 (int to double);</target>
        </trans-unit>
        <trans-unit id="492f05458909b4e400b0f5f301b1c1261874ae73" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;explicit&lt;/code&gt;-keyword in front of the constructor &lt;code&gt;C(void)&lt;/code&gt; tells the compiler that only explicit call to this constructor is allowed.</source>
          <target state="translated">생성자 &lt;code&gt;C(void)&lt;/code&gt; 앞에있는 &lt;code&gt;explicit&lt;/code&gt; -keyword는 컴파일러에게이 생성자에 대한 명시 적 호출 만 허용됨을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="ba087709da18b56c1d734fe563e840114679f1d9" translate="yes" xml:space="preserve">
          <source>up integral ranks (char to int, float to double);</source>
          <target state="translated">적분 랭크 (char to int, float to double);</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
