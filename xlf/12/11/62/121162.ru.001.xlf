<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/121162">
    <body>
      <group id="121162">
        <trans-unit id="6e909f16da04e6b4ba7a3dc42d76fb1fc131016b" translate="yes" xml:space="preserve">
          <source>1) A constructor declared without the function-specifier explicit specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a converting constructor.</source>
          <target state="translated">1)Конструктор,объявленный без функции-спецификатора,явно указывает на приведение типов своих параметров к типу своего класса.Такой конструктор называется конструктором преобразования.</target>
        </trans-unit>
        <trans-unit id="40075093fa2de375513bd7806fbfa585f1ccb88d" translate="yes" xml:space="preserve">
          <source>2) A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion for direct-initialization (8.5). Otherwise, user-defined conversions are not restricted to use in assignments
  and initializations.</source>
          <target state="translated">2)Функция преобразования может быть явной (7.1.2),и в этом случае она рассматривается только как определяемое пользователем преобразование для прямой инициализации (8.5).В противном случае пользовательское преобразование не ограничивается использованием при назначении и инициализации.</target>
        </trans-unit>
        <trans-unit id="82c5d71d8413126d3518e4c637002b6b8aa3fbf6" translate="yes" xml:space="preserve">
          <source>2) An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or valueinitialization
  (8.5).</source>
          <target state="translated">2)Явный конструктор конструирует объекты так же,как и неявные конструкторы,но делает это только в тех случаях,когда явно используется синтаксис прямой инициализации (8.5)или когда явно используются касты (5.2.9,5.4).Конструктор по умолчанию может быть явным конструктором;такой конструктор будет использоваться для выполнения инициализации по умолчанию или значения по умолчанию (8.5).</target>
        </trans-unit>
        <trans-unit id="7f26b74b665e2acdf88f5ec7e221b4624394b35b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx&quot;&gt;Here&lt;/a&gt; is a good write-up on explicit constructors.</source>
          <target state="translated">&lt;a href=&quot;http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx&quot;&gt;Вот&lt;/a&gt; хорошее описание явных конструкторов.</target>
        </trans-unit>
        <trans-unit id="fb9d903b66d4b86f2a3d5b0e7ce99773805eec0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ [class.conv.ctor]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ [class.conv.ctor]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e76638e98bf8cd3442bd39601d1b5f75737ea3a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ [class.conv.fct]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ [class.conv.fct]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dcec192ad51b7af512d87c6084e215eb361da2a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion constructors and non-explicit conversion functions may introduce ambiguity.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Конструкторы преобразования и неявные функции преобразования могут вносить неоднозначность.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e074b33cdf4fd9146a172fd109876e5aaa6831fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion constructors and non-explicit conversion functions may lead to unexpected behaviour.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Конструкторы преобразования и неявные функции преобразования могут привести к неожиданному поведению.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="404f447a2f27e2777f7b751f552e0208232d38cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explicit conversion constructors (C++ only)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Конструкторы явного преобразования (только C ++)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9e1424d19737c3e0e14bad461887396f1689093" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;a constructor of class X that cannot be used to implicitly convert the first (any only) parameter to type X&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;конструктор класса X, который нельзя использовать для неявного преобразования первого (любого единственного) параметра в тип X&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0b9c3a76bec2b3865fa08d11db98c0d983d43a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;or a conversion function that is only considered for direct initialization and explicit conversion.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;или функция преобразования, которая рассматривается только для прямой инициализации и явного преобразования.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90931b1495f819faf9ec90d5e4e0e1fc229bdff3" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;f&lt;/code&gt; is ambiguous if passing an object of type &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Вызов &lt;code&gt;f&lt;/code&gt; неоднозначен, если передать объект типа &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef58e46d65d0f651d7e99ff4af68f72c49935b2e" translate="yes" xml:space="preserve">
          <source>An example when you would deliberately &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; want to make your single-argument constructor explicit is if you're creating a functor (look at the 'add_x' struct declared in &lt;a href=&quot;https://stackoverflow.com/a/356993/793930&quot;&gt;this&lt;/a&gt; answer). In such a case, creating an object as &lt;code&gt;add_x add30 = 30;&lt;/code&gt; would probably make sense.</source>
          <target state="translated">Пример, когда вы намеренно &lt;strong&gt;&lt;em&gt;не&lt;/em&gt;&lt;/strong&gt; хотите делать явным свой конструктор с одним аргументом, это если вы создаете функтор (посмотрите на структуру 'add_x', объявленную в &lt;a href=&quot;https://stackoverflow.com/a/356993/793930&quot;&gt;этом&lt;/a&gt; ответе). В таком случае создание объекта как &lt;code&gt;add_x add30 = 30;&lt;/code&gt; вероятно, имеет смысл.</target>
        </trans-unit>
        <trans-unit id="023d40884b32ae99ad8ee9224964e2bf68369ac5" translate="yes" xml:space="preserve">
          <source>Another good practice for classes is to make copy construction and assignment private (a.k.a. disable it) unless you really need to implement it. This avoids having eventual copies of pointers when using the methods that C++ will create for you by default. An other way to do this is derive from boost::noncopyable.</source>
          <target state="translated">Другая хорошая практика для классов-сделать конструкцию копирования и присваивание приватными (так называемое отключение),если только вам действительно не нужно это реализовывать.Это позволяет избежать возможных копий указателей при использовании методов,которые C++создаст для вас по умолчанию.Другой способ сделать это-это использовать boost::noncopyable.</target>
        </trans-unit>
        <trans-unit id="93fa74ff062a4f43bee8427c70d3f3e8e2eb398e" translate="yes" xml:space="preserve">
          <source>As Bjarne Stroustrup  puts it (in &quot;The C++ Programming Language&quot;, 4th Ed., 35.2.1, pp. 1011) on the question why &lt;code&gt;std::duration&lt;/code&gt; cannot be implicitly constructed from a plain number:</source>
          <target state="translated">Как говорит Бьярн Страуструп (в &amp;laquo;Языке программирования C ++&amp;raquo;, 4-е издание, 35.2.1, стр. 1011), на вопрос, почему &lt;code&gt;std::duration&lt;/code&gt; неявно может быть сконструирован из простого числа:</target>
        </trans-unit>
        <trans-unit id="91abe90d799140d96614d181c106b32f8cccead0" translate="yes" xml:space="preserve">
          <source>Besides, it is always a good coding practice to make your one argument constructors (including those with default values for arg2,arg3,...) as already stated. 
Like always with C++: if you don't - you'll wish you did...</source>
          <target state="translated">Кроме того,хорошей практикой кодирования всегда является создание конструкторов с одним аргументом (в том числе и со значениями по умолчанию для arg2,arg3,...),как уже было сказано.Как всегда с C++:если вы этого не сделаете-вы пожалеете,что не сделали....</target>
        </trans-unit>
        <trans-unit id="8056a96d70581f55a1f36421d40b18baa0983d53" translate="yes" xml:space="preserve">
          <source>Consider a function printing some vector:</source>
          <target state="translated">Рассмотрим функцию печати какого-нибудь вектора:</target>
        </trans-unit>
        <trans-unit id="ffabce6768c306d54af29bfe6cecee317c83c262" translate="yes" xml:space="preserve">
          <source>Consider a structure &lt;code&gt;V&lt;/code&gt;, convertible to &lt;code&gt;int&lt;/code&gt;, a structure &lt;code&gt;U&lt;/code&gt; implicitly constructible from &lt;code&gt;V&lt;/code&gt; and a function &lt;code&gt;f&lt;/code&gt; overloaded for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; respectively.</source>
          <target state="translated">Рассмотрим структуру &lt;code&gt;V&lt;/code&gt; , конвертируемую в &lt;code&gt;int&lt;/code&gt; , структуру &lt;code&gt;U&lt;/code&gt; , неявно конструируемую из &lt;code&gt;V&lt;/code&gt; , и функцию &lt;code&gt;f&lt;/code&gt; , перегруженную для &lt;code&gt;U&lt;/code&gt; и &lt;code&gt;bool&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="019b9c3fbcd9fbed06290bc41f9a48781e74ba91" translate="yes" xml:space="preserve">
          <source>Consider the following class without an explicit constructor:</source>
          <target state="translated">Рассмотрим следующий класс без явного конструктора:</target>
        </trans-unit>
        <trans-unit id="f1f6cc578a73fda02c3a246d96eb579f34559dea" translate="yes" xml:space="preserve">
          <source>Constructors append implicit conversion. To suppress this implicit conversion it is required to declare a constructor with a parameter explicit.</source>
          <target state="translated">Строители добавляют неявное преобразование.Для подавления этого неявного преобразования необходимо объявить конструктор с параметром explicit.</target>
        </trans-unit>
        <trans-unit id="18f1b770126acc40cb179db8016ea3c6af74a605" translate="yes" xml:space="preserve">
          <source>Conversion of a function argument:</source>
          <target state="translated">Преобразование аргумента функции:</target>
        </trans-unit>
        <trans-unit id="c8f4b2cde6b3fe7edba64d7e515a710a2e2df98c" translate="yes" xml:space="preserve">
          <source>Cpp Reference is always helpful!!! Details about explicit specifier can be found &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;here&lt;/a&gt;.  You may need to look at &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/implicit_conversion&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; too.</source>
          <target state="translated">Cpp Reference всегда полезен !!! Подробности о явном спецификаторе можно найти &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;здесь&lt;/a&gt; . Возможно, вам придется посмотреть на &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/implicit_conversion&quot;&gt;неявные преобразования&lt;/a&gt; и &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_initialization&quot;&gt;инициализацию копирования&lt;/a&gt; тоже.</target>
        </trans-unit>
        <trans-unit id="e32c5521f2cec3f8f4baa216e8f949d5b512fcca" translate="yes" xml:space="preserve">
          <source>Depending upon the implementation, the second manner of instantiating class Foo may be confusing, or not what the programmer intended. Prefixing the &lt;code&gt;explicit&lt;/code&gt; keyword to the constructor would generate a compiler error at &lt;code&gt;Foo bar2 = 20;&lt;/code&gt;.</source>
          <target state="translated">В зависимости от реализации, второй способ создания экземпляра класса Foo может сбивать с толку, или не то, что задумал программист. Префикс &lt;code&gt;explicit&lt;/code&gt; ключевого слова к конструктору вызовет ошибку компилятора при &lt;code&gt;Foo bar2 = 20;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="30a2e91c6246a99a6f1219373a019d7d3616ee87" translate="yes" xml:space="preserve">
          <source>Example as follows:</source>
          <target state="translated">Приведите следующий пример:</target>
        </trans-unit>
        <trans-unit id="6f3ba8e6e3b35cf9dfa1800107ec407650feff17" translate="yes" xml:space="preserve">
          <source>Example using structures &lt;code&gt;X, Y, Z&lt;/code&gt; and functions &lt;code&gt;foo, bar, baz&lt;/code&gt;:</source>
          <target state="translated">Пример использования структур &lt;code&gt;X, Y, Z&lt;/code&gt; и функций &lt;code&gt;foo, bar, baz&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c4391c5871b2591466f38ed051125c3a6b72b655" translate="yes" xml:space="preserve">
          <source>Examples regarding constructor:</source>
          <target state="translated">Примеры относительно конструктора:</target>
        </trans-unit>
        <trans-unit id="6a4208acecf2caa67ad142db501f1e7edba9301f" translate="yes" xml:space="preserve">
          <source>Examples regarding conversion functions:</source>
          <target state="translated">Примеры,касающиеся функций преобразования:</target>
        </trans-unit>
        <trans-unit id="63cd5534db30ee33eabaed9b35dad8b9682be58f" translate="yes" xml:space="preserve">
          <source>Explicit conversion functions and constructors can only be used for explicit conversions (direct initialization or explicit cast operation) while non-explicit constructors and conversion functions can be used for implicit as well as explicit conversions.</source>
          <target state="translated">Явные функции преобразования и конструкторы могут использоваться только для явных преобразований (прямая инициализация или явное приведение),в то время как неявные конструкторы и функции преобразования могут использоваться как для неявных,так и для явных преобразований.</target>
        </trans-unit>
        <trans-unit id="483334b7421e283b810cc10b297ff1ff94e618b1" translate="yes" xml:space="preserve">
          <source>For example, if you declare the class as:</source>
          <target state="translated">Например,если вы объявите класс как:</target>
        </trans-unit>
        <trans-unit id="a20de6e76729d51851c56bf373b29f18ff5bb561" translate="yes" xml:space="preserve">
          <source>For example, if you have a string class with constructor &lt;code&gt;String(const char* s)&lt;/code&gt;, that's probably exactly what you want.  You can pass a &lt;code&gt;const char*&lt;/code&gt; to a function expecting a &lt;code&gt;String&lt;/code&gt;, and the compiler will automatically construct a temporary &lt;code&gt;String&lt;/code&gt; object for you.</source>
          <target state="translated">Например, если у вас есть строковый класс с конструктором &lt;code&gt;String(const char* s)&lt;/code&gt; , это, вероятно, именно то, что вы хотите. Вы можете передать &lt;code&gt;const char*&lt;/code&gt; функции, ожидающей &lt;code&gt;String&lt;/code&gt; , и компилятор автоматически создаст для вас временный объект &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03739c543e63532d2e0ee64e937635e148313674" translate="yes" xml:space="preserve">
          <source>For example, the following statements are legal:</source>
          <target state="translated">Например,следующие утверждения являются юридическими:</target>
        </trans-unit>
        <trans-unit id="05fa6736aea3a744782881e661a2c437953ca80b" translate="yes" xml:space="preserve">
          <source>Here's a simple function that takes a &lt;code&gt;Foo&lt;/code&gt; object:</source>
          <target state="translated">Вот простая функция, которая принимает объект &lt;code&gt;Foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1e43ffb6522ca8f869078d171d24a79cea9ba5d3" translate="yes" xml:space="preserve">
          <source>Here's an example class with a constructor that can be used for implicit conversions:</source>
          <target state="translated">Приведем пример класса с конструктором,который может быть использован для неявных преобразований:</target>
        </trans-unit>
        <trans-unit id="fc9d2bdfb3652039da2c1f77188f4475b0334b02" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;explicit&lt;/code&gt;-keyword enforces only explicit casts to be valid, so &lt;code&gt;bool b = c;&lt;/code&gt; would be an invalid cast in this case. In situations like these &lt;code&gt;explicit&lt;/code&gt;-keyword can help programmer to avoid implicit, unintended casts. This usage has been standardized in &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cast_operator&quot;&gt;C++11&lt;/a&gt;.</source>
          <target state="translated">Здесь &lt;code&gt;explicit&lt;/code&gt; -keyword заставляет только явные приведения быть действительными, поэтому &lt;code&gt;bool b = c;&lt;/code&gt; будет неверным приведением в этом случае. В подобных ситуациях -keyword может помочь программисту избежать неявных, непреднамеренных приведений. Это использование было стандартизировано в &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cast_operator&quot;&gt;C ++ 11&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ecde5e33b6842aae9586216bde3d7c062492300" translate="yes" xml:space="preserve">
          <source>If either the constructor of &lt;code&gt;U&lt;/code&gt; or the conversion function of &lt;code&gt;V&lt;/code&gt; would be &lt;code&gt;explicit&lt;/code&gt;, there would be no ambiguity since only the non-explicit conversion would be considered. If both are explicit the call to &lt;code&gt;f&lt;/code&gt; using an object of type &lt;code&gt;V&lt;/code&gt; would have to be done using an explicit conversion or cast operation.</source>
          <target state="translated">Если бы конструктор &lt;code&gt;U&lt;/code&gt; или функция преобразования &lt;code&gt;V&lt;/code&gt; были бы &lt;code&gt;explicit&lt;/code&gt; , не было бы никакой двусмысленности, поскольку рассматривалось бы только неявное преобразование. Если оба являются явными, вызов &lt;code&gt;f&lt;/code&gt; с использованием объекта типа &lt;code&gt;V&lt;/code&gt; должен быть выполнен с использованием явного преобразования или операции приведения.</target>
        </trans-unit>
        <trans-unit id="24f97f1f66fe055c12d92257a5a1d131d926faa9" translate="yes" xml:space="preserve">
          <source>If the size-constructor of the vector would not be explicit it would be possible to call the function like this:</source>
          <target state="translated">Если размер-конструктор вектора не был бы явным,то можно было бы вызвать такую функцию:</target>
        </trans-unit>
        <trans-unit id="124132f57abb337ccbdded8265bd7ff12e02cb28" translate="yes" xml:space="preserve">
          <source>If you declare the constructor of the class as &lt;code&gt;explicit&lt;/code&gt;, the previous declarations would be illegal.</source>
          <target state="translated">Если вы объявите конструктор класса как &lt;code&gt;explicit&lt;/code&gt; , предыдущие объявления будут недопустимыми.</target>
        </trans-unit>
        <trans-unit id="dcfb0600299ba6b050382cf5b290106184e86d09" translate="yes" xml:space="preserve">
          <source>If you know what you mean, be explicit about it.</source>
          <target state="translated">Если ты понимаешь,что ты имеешь в виду,будь откровенен.</target>
        </trans-unit>
        <trans-unit id="2a7badbe21782e07fa940bd63da839e4f99542d5" translate="yes" xml:space="preserve">
          <source>In C++, a constructor with only one required parameter is considered an implicit conversion function.  It converts the parameter type to the class type.  Whether this is a good thing or not depends on the semantics of the constructor.</source>
          <target state="translated">В языке Си++конструктор,имеющий только один требуемый параметр,считается неявной функцией преобразования.Она преобразует тип параметра в тип класса.Хорошо это или плохо зависит от семантики конструктора.</target>
        </trans-unit>
        <trans-unit id="96a5269e608660ea6a121ce099af5f98a9d89d48" translate="yes" xml:space="preserve">
          <source>In C++11 you can also specify an &quot;operator type()&quot; with such keyword &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;http://en.cppreference.com/w/cpp/language/explicit&lt;/a&gt; With such specification you can use operator in terms of explicit conversions, and direct initialization of object.</source>
          <target state="translated">В C ++ 11 вы также можете указать &amp;laquo;оператор type ()&amp;raquo; с таким ключевым словом &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;http://en.cppreference.com/w/cpp/language/explicit&lt;/a&gt; С такой спецификацией вы можете использовать оператор в терминах явных преобразований, и прямая инициализация объекта.</target>
        </trans-unit>
        <trans-unit id="0f99c78ff8610e39b8faa30a4b5ef71196baf577" translate="yes" xml:space="preserve">
          <source>In summary, if your single-parameter constructor converts the parameter into an object of your class, you probably don't want to use the &lt;code&gt;explicit&lt;/code&gt; keyword.  But if you have a constructor that simply happens to take a single parameter, you should declare it as &lt;code&gt;explicit&lt;/code&gt; to prevent the compiler from surprising you with unexpected conversions.</source>
          <target state="translated">Таким образом, если ваш однопараметрический конструктор преобразует параметр в объект вашего класса, вы, вероятно, не хотите использовать &lt;code&gt;explicit&lt;/code&gt; ключевое слово. Но если у вас есть конструктор, который просто принимает один параметр, вы должны объявить его как &lt;code&gt;explicit&lt;/code&gt; чтобы компилятор не удивил вас неожиданными преобразованиями.</target>
        </trans-unit>
        <trans-unit id="b2cb9e61565f9bb201c8b94447f641b04a3f7c24" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;usually&lt;/em&gt; good practice to declare single-argument constructors as &lt;code&gt;explicit&lt;/code&gt;, unless your implementation specifically prohibits it.</source>
          <target state="translated">&lt;em&gt;Обычно&lt;/em&gt; рекомендуется объявлять конструкторы с одним аргументом как &lt;code&gt;explicit&lt;/code&gt; , если ваша реализация специально не запрещает это.</target>
        </trans-unit>
        <trans-unit id="76e264a3ab2feb73628e60003fbf19c73f2596d8" translate="yes" xml:space="preserve">
          <source>Let's look at a small setup of structures and functions to see the difference between &lt;code&gt;explicit&lt;/code&gt; and non-&lt;code&gt;explicit&lt;/code&gt; conversions.</source>
          <target state="translated">Давайте рассмотрим небольшую настройку структур и функций, чтобы увидеть разницу между &lt;code&gt;explicit&lt;/code&gt; и неявным преобразованием.</target>
        </trans-unit>
        <trans-unit id="a1efdc398882ef52a5c56f27be4e597b6de6ca5f" translate="yes" xml:space="preserve">
          <source>Note also that constructors with</source>
          <target state="translated">Отметим также,что конструкторы с</target>
        </trans-unit>
        <trans-unit id="0caae2186a2fb9fc2295d889a7ef4e74ade7ad33" translate="yes" xml:space="preserve">
          <source>Now, if you try:</source>
          <target state="translated">Теперь,если ты попытаешься:</target>
        </trans-unit>
        <trans-unit id="207a36c11ea6ea8e3440a8af2255c0d19b55487e" translate="yes" xml:space="preserve">
          <source>Object initialization:</source>
          <target state="translated">Инициализация объекта:</target>
        </trans-unit>
        <trans-unit id="d5ddf0ad260d5cf6434f9b9c3e83655bd62daf1e" translate="yes" xml:space="preserve">
          <source>Objects of class Foo can be created in 2 ways:</source>
          <target state="translated">Объекты класса Foo могут быть созданы двумя способами:</target>
        </trans-unit>
        <trans-unit id="be69b1d70c47420d0477f00402fb1ba65d040235" translate="yes" xml:space="preserve">
          <source>On the other hand, if you have a buffer class whose constructor &lt;code&gt;Buffer(int size)&lt;/code&gt; takes the size of the buffer in bytes, you probably don't want the compiler to quietly turn &lt;code&gt;int&lt;/code&gt;s into &lt;code&gt;Buffer&lt;/code&gt;s.  To prevent that, you declare the constructor with the &lt;code&gt;explicit&lt;/code&gt; keyword:</source>
          <target state="translated">С другой стороны, если у вас есть буферный класс, чей конструктор &lt;code&gt;Buffer(int size)&lt;/code&gt; принимает размер буфера в байтах, вы, вероятно, не хотите, чтобы компилятор тихо превращал &lt;code&gt;int&lt;/code&gt; в &lt;code&gt;Buffer&lt;/code&gt; . Чтобы предотвратить это, вы объявляете конструктор с &lt;code&gt;explicit&lt;/code&gt; ключевым словом:</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="d6cedf5b2ccb7066d6607cd21993a85101529ead" translate="yes" xml:space="preserve">
          <source>P.S. When using transformations defined BY USER (via constructors and type conversion operator) it is allowed only one level of implicit conversions used.
But you can combine this conversions with other language conversions</source>
          <target state="translated">P.S.При использовании преобразований,определенных ПОЛЬЗОВАТЕЛЕМ (через конструкторы и оператор приведения типов),допускается только один уровень неявных приведений.Однако,вы можете комбинировать эти преобразования с другими языковыми преобразованиями.</target>
        </trans-unit>
        <trans-unit id="286bbf56a4eca72de3e0e6073d3b5007f5367c70" translate="yes" xml:space="preserve">
          <source>Prefixing the &lt;code&gt;explicit&lt;/code&gt; keyword to the constructor prevents the compiler from using that constructor for implicit conversions. Adding it to the above class will create a compiler error at the function call &lt;code&gt;DoBar (42)&lt;/code&gt;.  It is now necessary to call for conversion explicitly with  &lt;code&gt;DoBar (Foo (42))&lt;/code&gt;</source>
          <target state="translated">Префикс &lt;code&gt;explicit&lt;/code&gt; ключевого слова к конструктору не позволяет компилятору использовать этот конструктор для неявных преобразований. Добавление его в вышеприведенный класс создаст ошибку компилятора при вызове функции &lt;code&gt;DoBar (42)&lt;/code&gt; . Теперь необходимо явно вызвать преобразование с помощью &lt;code&gt;DoBar (Foo (42))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76d5f62f8c52d90be7570576601501fb73d2b55f" translate="yes" xml:space="preserve">
          <source>Quick look</source>
          <target state="translated">Быстрый взгляд</target>
        </trans-unit>
        <trans-unit id="f1021233aa532c3c5b4aa4bd03d6d0aa9b54f1cc" translate="yes" xml:space="preserve">
          <source>Suppose, you have a class &lt;code&gt;String&lt;/code&gt;:</source>
          <target state="translated">Предположим, у вас есть класс &lt;code&gt;String&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9ee6744ba51fc0295fd21067924362836fa5a24a" translate="yes" xml:space="preserve">
          <source>That way,</source>
          <target state="translated">Сюда,</target>
        </trans-unit>
        <trans-unit id="1b7d5994338fd9ab33346c917fa397adc9476570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt; keyword makes a conversion constructor to non-conversion constructor. As a result, the code is less error prone.</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; ключевое слово создает конструктор преобразования в конструктор без преобразования. В результате код менее подвержен ошибкам.</target>
        </trans-unit>
        <trans-unit id="ddf9af1fc865c8001f9a0f7215ab0e3404df6b4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt;-keyword can also be used in user-defined type cast operators:</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; ключевое слово также можно использовать в пользовательских операторах приведения типов:</target>
        </trans-unit>
        <trans-unit id="ce6a7532fd040432382447d8f75000df06c8721a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt;-keyword can be used to enforce a constructor to be called &lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; ключевое слово может использоваться для принудительного вызова конструктора.</target>
        </trans-unit>
        <trans-unit id="a4c3f68e64b6d51aac772aa88db8426afc50c8aa" translate="yes" xml:space="preserve">
          <source>The argument is not a &lt;code&gt;Foo&lt;/code&gt; object, but an &lt;code&gt;int&lt;/code&gt;. However, there exists a constructor for &lt;code&gt;Foo&lt;/code&gt; that takes an &lt;code&gt;int&lt;/code&gt; so this constructor can be used to convert the parameter to the correct type.</source>
          <target state="translated">Аргумент не объект &lt;code&gt;Foo&lt;/code&gt; , а &lt;code&gt;int&lt;/code&gt; . Однако существует конструктор для &lt;code&gt;Foo&lt;/code&gt; , который принимает &lt;code&gt;int&lt;/code&gt; , поэтому этот конструктор можно использовать для преобразования параметра в правильный тип.</target>
        </trans-unit>
        <trans-unit id="3049d136f55a475626db3dad948b02469e9778f9" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;'x'&lt;/code&gt; will be implicitly converted to &lt;code&gt;int&lt;/code&gt; and then the &lt;code&gt;String(int)&lt;/code&gt; constructor will be called. But, this is not what the user might have intended. So, to prevent such conditions, we shall define the constructor as &lt;code&gt;explicit&lt;/code&gt;:</source>
          <target state="translated">Символ &lt;code&gt;'x'&lt;/code&gt; будет неявно преобразован в &lt;code&gt;int&lt;/code&gt; , а затем будет вызван конструктор &lt;code&gt;String(int)&lt;/code&gt; . Но это не то, что мог задумать пользователь. Итак, чтобы предотвратить такие условия, мы определим конструктор как &lt;code&gt;explicit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2067a14f8d7ec35e3e14dc1571c9ef15e462e679" translate="yes" xml:space="preserve">
          <source>The compiler does not know wether to use the constructor of &lt;code&gt;U&lt;/code&gt; or the conversion function to convert the &lt;code&gt;V&lt;/code&gt; object into a type for passing to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Компилятор не знает, использовать ли конструктор &lt;code&gt;U&lt;/code&gt; или функцию преобразования для преобразования объекта &lt;code&gt;V&lt;/code&gt; в тип для передачи в &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd2c9fb6422b9a6c94f550ada7376764badd6b9a" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to do this once for each parameter.</source>
          <target state="translated">Компилятору разрешено делать это один раз для каждого параметра.</target>
        </trans-unit>
        <trans-unit id="c61dcda5620fa9ba492d6ebe7eca3691f7dedb65" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to make one implicit conversion to resolve the parameters to a function. What this means is that the compiler can use constructors callable with a &lt;strong&gt;single parameter&lt;/strong&gt; to convert from one type to another in order to get the right type for a parameter.</source>
          <target state="translated">Компилятору разрешено делать одно неявное преобразование для разрешения параметров функции. Это означает, что компилятор может использовать конструкторы, вызываемые с &lt;strong&gt;одним параметром,&lt;/strong&gt; для преобразования из одного типа в другой, чтобы получить правильный тип для параметра.</target>
        </trans-unit>
        <trans-unit id="c506586127aafb4571605139fe82715ddb3cb0e6" translate="yes" xml:space="preserve">
          <source>The explicit function specifier controls unwanted implicit type
  conversions. It can only be used in declarations of constructors
  within a class declaration. For example, except for the default
  constructor, the constructors in the following class are conversion
  constructors.</source>
          <target state="translated">Явный спецификатор функции контролирует нежелательные неявные приведения типов.Он может быть использован только в объявлениях конструкторов внутри объявления класса.Например,кроме конструктора по умолчанию,конструкторы следующего класса являются конструкторами преобразования.</target>
        </trans-unit>
        <trans-unit id="aaaed950d829699c6b369f21001642be0a85ccc4" translate="yes" xml:space="preserve">
          <source>The explicit specifier specifies that a constructor or conversion function (since C++11) doesn't allow implicit conversions or copy-initialization.</source>
          <target state="translated">Явный спецификатор указывает,что конструктор или функция преобразования (начиная с C++11)не допускают неявных преобразований или инициализации копирования.</target>
        </trans-unit>
        <trans-unit id="9e22fa09c228ce6e248691a575f81838d40d2ea5" translate="yes" xml:space="preserve">
          <source>The first declaration is equivalent to &lt;code&gt;A c = A( 1 );&lt;/code&gt;.</source>
          <target state="translated">Первое объявление эквивалентно &lt;code&gt;A c = A( 1 );&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="80f1e63e6386d4a9d89289f1bf6b566c60d0ab41" translate="yes" xml:space="preserve">
          <source>The following declarations are legal:</source>
          <target state="translated">Следующие декларации являются юридическими:</target>
        </trans-unit>
        <trans-unit id="1169f772595bc8ae74d724d600a7a87c62ff125b" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;explicit&lt;/code&gt; accompanies either</source>
          <target state="translated">Ключевое слово &lt;code&gt;explicit&lt;/code&gt; сопровождает либо</target>
        </trans-unit>
        <trans-unit id="9c61164f85ca5b809d267efbbbea8840b12030f5" translate="yes" xml:space="preserve">
          <source>The reason you might want to do this is to avoid accidental construction that can hide bugs.  Contrived example:</source>
          <target state="translated">Причина,по которой вы,возможно,захотите это сделать,заключается в том,чтобы избежать случайной конструкции,которая может скрыть ошибки.Продуманный пример:</target>
        </trans-unit>
        <trans-unit id="b4ba231f0faf7a6a4e919e6912719f1780af4a1e" translate="yes" xml:space="preserve">
          <source>This answer is about object creation with/without an explicit constructor since it is not covered in the other answers.</source>
          <target state="translated">Этот ответ касается создания объектов без явного конструктора,так как он не охватывается другими ответами.</target>
        </trans-unit>
        <trans-unit id="78c2215507e93f78a74406cf7cb8018f79940750" translate="yes" xml:space="preserve">
          <source>This has already been discussed (&lt;a href=&quot;https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319&quot;&gt;what is explicit constructor&lt;/a&gt;). But I must say, that it lacks the detailed descriptions found here.</source>
          <target state="translated">Это уже обсуждалось ( &lt;a href=&quot;https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319&quot;&gt;что такое явный конструктор&lt;/a&gt; ). Но я должен сказать, что в нем отсутствуют подробные описания, найденные здесь.</target>
        </trans-unit>
        <trans-unit id="77c49e3ca9f1370e49c1a2a3fdbf65a3dc598015" translate="yes" xml:space="preserve">
          <source>Using the explicit keyword in a class interface enforces the user of the interface to be explicit about a desired conversion.</source>
          <target state="translated">Использование явного ключевого слова в интерфейсе класса заставляет пользователя интерфейса быть явно выраженным о желаемом преобразовании.</target>
        </trans-unit>
        <trans-unit id="e281673a57e5bea475598290ff974afa1741081a" translate="yes" xml:space="preserve">
          <source>What does the &lt;code&gt;explicit&lt;/code&gt; keyword mean in C++?</source>
          <target state="translated">Что означает &lt;code&gt;explicit&lt;/code&gt; ключевое слово в C ++?</target>
        </trans-unit>
        <trans-unit id="ed5d4b7337e6a32f69ef31abb6b7b842c48d6f29" translate="yes" xml:space="preserve">
          <source>What does the explicit keyword mean</source>
          <target state="translated">Что означает явное ключевое слово</target>
        </trans-unit>
        <trans-unit id="5edb7164eb8327c49e3246ab6a67c8cc6391b808" translate="yes" xml:space="preserve">
          <source>What would one expect from such a call? One line containing &lt;code&gt;3&lt;/code&gt; or three lines containing &lt;code&gt;0&lt;/code&gt;? (Where the second one is what happens.)</source>
          <target state="translated">Что можно ожидать от такого звонка? Одна строка, содержащая &lt;code&gt;3&lt;/code&gt; или три строки, содержащие &lt;code&gt;0&lt;/code&gt; ? (Где второй, что происходит.)</target>
        </trans-unit>
        <trans-unit id="35b2cad2dc0f1377d98ff2f0f160c44250275905" translate="yes" xml:space="preserve">
          <source>Why use &lt;code&gt;explicit&lt;/code&gt; conversion functions or constructors?</source>
          <target state="translated">Зачем использовать &lt;code&gt;explicit&lt;/code&gt; функции преобразования или конструкторы?</target>
        </trans-unit>
        <trans-unit id="c22c511044cbc64591d114b9cd769d00a98cfe0f" translate="yes" xml:space="preserve">
          <source>You can only assign values that match the values of the class type.</source>
          <target state="translated">Можно назначить только те значения,которые соответствуют значениям типа класса.</target>
        </trans-unit>
        <trans-unit id="e087e20de6eff6911f7c8fa41bb5e3f6bb2cb100" translate="yes" xml:space="preserve">
          <source>You have a &lt;code&gt;MyString(int size)&lt;/code&gt; class with a constructor that constructs a string of the given size.  You have a function &lt;code&gt;print(const MyString&amp;amp;)&lt;/code&gt;, and you call &lt;code&gt;print(3)&lt;/code&gt; (when you &lt;em&gt;actually&lt;/em&gt; intended to call &lt;code&gt;print(&quot;3&quot;)&lt;/code&gt;).  You expect it to print &quot;3&quot;, but it prints an empty string of length 3 instead.</source>
          <target state="translated">У вас есть класс &lt;code&gt;MyString(int size)&lt;/code&gt; с конструктором, который создает строку заданного размера. У вас есть функция &lt;code&gt;print(const MyString&amp;amp;)&lt;/code&gt; , и вы вызываете &lt;code&gt;print(3)&lt;/code&gt; (когда вы &lt;em&gt;действительно&lt;/em&gt; намеревались вызвать &lt;code&gt;print(&quot;3&quot;)&lt;/code&gt; ). Вы ожидаете, что он напечатает &amp;laquo;3&amp;raquo;, но вместо этого он напечатает пустую строку длиной 3.</target>
        </trans-unit>
        <trans-unit id="3c93f07a155ea96a0b57d63ea157ae1ba6c82880" translate="yes" xml:space="preserve">
          <source>and here's where the &lt;code&gt;DoBar&lt;/code&gt; function is called.</source>
          <target state="translated">и вот где &lt;code&gt;DoBar&lt;/code&gt; функция DoBar .</target>
        </trans-unit>
        <trans-unit id="80e76fd5e13a34f76dc82f7374cbbedf25d22621" translate="yes" xml:space="preserve">
          <source>becomes a compile-time error.  If you want to pass a temporary &lt;code&gt;Buffer&lt;/code&gt; object, you have to do so explicitly:</source>
          <target state="translated">становится ошибкой во время компиляции. Если вы хотите передать временный объект &lt;code&gt;Buffer&lt;/code&gt; , вы должны сделать это явно:</target>
        </trans-unit>
        <trans-unit id="d0bc31847e397dc9ce6f32057f43c91554466982" translate="yes" xml:space="preserve">
          <source>can both be used as single-argument constructors. So you may want to make these also &lt;code&gt;explicit&lt;/code&gt;.</source>
          <target state="translated">оба могут использоваться как конструкторы с одним аргументом. Таким образом, вы можете сделать это также &lt;code&gt;explicit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1112e4645e1c510e383ffdb6d150959b4f130d21" translate="yes" xml:space="preserve">
          <source>convert pointers of objects to base class and to void*;</source>
          <target state="translated">преобразовывать указатели объектов в базовый класс и в void*;</target>
        </trans-unit>
        <trans-unit id="19f768b20de266f72b8bd3b42fe489a61513ccf9" translate="yes" xml:space="preserve">
          <source>default arguments for all parameters, or</source>
          <target state="translated">аргументы по умолчанию для всех параметров,или</target>
        </trans-unit>
        <trans-unit id="fc3ae7b739a0d4b0a8161d16c99bc4a63b0ccc76" translate="yes" xml:space="preserve">
          <source>default arguments for the second parameter onwards</source>
          <target state="translated">аргументы по умолчанию для второго параметра далее</target>
        </trans-unit>
        <trans-unit id="d9f4df0fccc3324ca442bc5a16211b9f8e047d00" translate="yes" xml:space="preserve">
          <source>standart conversions (int to double);</source>
          <target state="translated">стандартное преобразование (int to double);</target>
        </trans-unit>
        <trans-unit id="492f05458909b4e400b0f5f301b1c1261874ae73" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;explicit&lt;/code&gt;-keyword in front of the constructor &lt;code&gt;C(void)&lt;/code&gt; tells the compiler that only explicit call to this constructor is allowed.</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; ключевое слово перед конструктором &lt;code&gt;C(void)&lt;/code&gt; сообщает компилятору, что разрешен только явный вызов этого конструктора.</target>
        </trans-unit>
        <trans-unit id="ba087709da18b56c1d734fe563e840114679f1d9" translate="yes" xml:space="preserve">
          <source>up integral ranks (char to int, float to double);</source>
          <target state="translated">вверх по интегральным рядам (char to int,float to double);</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
