<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/121162">
    <body>
      <group id="121162">
        <trans-unit id="6e909f16da04e6b4ba7a3dc42d76fb1fc131016b" translate="yes" xml:space="preserve">
          <source>1) A constructor declared without the function-specifier explicit specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a converting constructor.</source>
          <target state="translated">1)一个没有明文声明的构造函数指定了从参数类型到类的类型的转换。这样的构造函数被称为转换构造函数。</target>
        </trans-unit>
        <trans-unit id="40075093fa2de375513bd7806fbfa585f1ccb88d" translate="yes" xml:space="preserve">
          <source>2) A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion for direct-initialization (8.5). Otherwise, user-defined conversions are not restricted to use in assignments
  and initializations.</source>
          <target state="translated">2)转换函数可以是显式的(7.1.2),在这种情况下,它只被认为是用户定义的转换,用于直接初始化(8.5)。否则,用户定义的转换函数不限于在赋值和初始化中使用。</target>
        </trans-unit>
        <trans-unit id="82c5d71d8413126d3518e4c637002b6b8aa3fbf6" translate="yes" xml:space="preserve">
          <source>2) An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or valueinitialization
  (8.5).</source>
          <target state="translated">2)显式构造函数就像非显式构造函数一样构造对象,但只有在直接初始化语法(8.5)或明确使用了cast(5.2.9,5.4)的情况下才会这样做。缺省构造函数可以是一个显式构造函数;这样的构造函数将被用来执行default-initialization或valueinitialization (8.5)。</target>
        </trans-unit>
        <trans-unit id="7f26b74b665e2acdf88f5ec7e221b4624394b35b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx&quot;&gt;Here&lt;/a&gt; is a good write-up on explicit constructors.</source>
          <target state="translated">&lt;a href=&quot;http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx&quot;&gt;这&lt;/a&gt;是关于显式构造函数的不错的文章。</target>
        </trans-unit>
        <trans-unit id="fb9d903b66d4b86f2a3d5b0e7ce99773805eec0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ [class.conv.ctor]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ [class.conv.ctor]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e76638e98bf8cd3442bd39601d1b5f75737ea3a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ [class.conv.fct]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ [class.conv.fct]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dcec192ad51b7af512d87c6084e215eb361da2a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion constructors and non-explicit conversion functions may introduce ambiguity.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;转换构造函数和非明确转换函数可能会引起歧义。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e074b33cdf4fd9146a172fd109876e5aaa6831fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion constructors and non-explicit conversion functions may lead to unexpected behaviour.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;转换构造函数和非明确转换函数可能会导致意外行为。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="404f447a2f27e2777f7b751f552e0208232d38cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explicit conversion constructors (C++ only)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;显式转换构造函数（仅C ++）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9e1424d19737c3e0e14bad461887396f1689093" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;a constructor of class X that cannot be used to implicitly convert the first (any only) parameter to type X&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;X类的构造函数，不能用于将第一个（仅任何一个）参数隐式转换为X类型&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0b9c3a76bec2b3865fa08d11db98c0d983d43a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;or a conversion function that is only considered for direct initialization and explicit conversion.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;或仅用于直接初始化和显式转换的转换函数。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90931b1495f819faf9ec90d5e4e0e1fc229bdff3" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;f&lt;/code&gt; is ambiguous if passing an object of type &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果传递 &lt;code&gt;V&lt;/code&gt; 类型的对象，则对 &lt;code&gt;f&lt;/code&gt; 的调用是不明确的。</target>
        </trans-unit>
        <trans-unit id="ef58e46d65d0f651d7e99ff4af68f72c49935b2e" translate="yes" xml:space="preserve">
          <source>An example when you would deliberately &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; want to make your single-argument constructor explicit is if you're creating a functor (look at the 'add_x' struct declared in &lt;a href=&quot;https://stackoverflow.com/a/356993/793930&quot;&gt;this&lt;/a&gt; answer). In such a case, creating an object as &lt;code&gt;add_x add30 = 30;&lt;/code&gt; would probably make sense.</source>
          <target state="translated">如果您要创建函子（请看&lt;a href=&quot;https://stackoverflow.com/a/356993/793930&quot;&gt;此&lt;/a&gt;答案中声明的&amp;ldquo; add_x&amp;rdquo;结构），则有意&lt;strong&gt;&lt;em&gt;避免&lt;/em&gt;&lt;/strong&gt;使单参数构造函数显式的示例。 在这种情况下，将对象创建为 &lt;code&gt;add_x add30 = 30;&lt;/code&gt; 可能是有道理的。</target>
        </trans-unit>
        <trans-unit id="023d40884b32ae99ad8ee9224964e2bf68369ac5" translate="yes" xml:space="preserve">
          <source>Another good practice for classes is to make copy construction and assignment private (a.k.a. disable it) unless you really need to implement it. This avoids having eventual copies of pointers when using the methods that C++ will create for you by default. An other way to do this is derive from boost::noncopyable.</source>
          <target state="translated">对于类的另一个好的做法是,除非你真的需要实现,否则就把复制构造和赋值变成私有的(又名禁用)。这就避免了在使用C++默认为你创建的方法时,最终会有指针的副本。另一种方法是从boosty:::noncopyable派生出来的。</target>
        </trans-unit>
        <trans-unit id="93fa74ff062a4f43bee8427c70d3f3e8e2eb398e" translate="yes" xml:space="preserve">
          <source>As Bjarne Stroustrup  puts it (in &quot;The C++ Programming Language&quot;, 4th Ed., 35.2.1, pp. 1011) on the question why &lt;code&gt;std::duration&lt;/code&gt; cannot be implicitly constructed from a plain number:</source>
          <target state="translated">正如Bjarne Stroustrup所言（在&amp;ldquo; C ++编程语言&amp;rdquo;，第4版，35.2.1，第1011页）中，为什么不能从纯数字隐式构造 &lt;code&gt;std::duration&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="91abe90d799140d96614d181c106b32f8cccead0" translate="yes" xml:space="preserve">
          <source>Besides, it is always a good coding practice to make your one argument constructors (including those with default values for arg2,arg3,...) as already stated. 
Like always with C++: if you don't - you'll wish you did...</source>
          <target state="translated">此外,正如前面所说的那样,让你的单参数构造函数(包括那些默认值为arg2,arg3,...的构造函数)成为一个很好的编码实践。就像C++一样:如果你不这样做,你会希望你这样做......</target>
        </trans-unit>
        <trans-unit id="8056a96d70581f55a1f36421d40b18baa0983d53" translate="yes" xml:space="preserve">
          <source>Consider a function printing some vector:</source>
          <target state="translated">考虑一个函数打印一些矢量。</target>
        </trans-unit>
        <trans-unit id="ffabce6768c306d54af29bfe6cecee317c83c262" translate="yes" xml:space="preserve">
          <source>Consider a structure &lt;code&gt;V&lt;/code&gt;, convertible to &lt;code&gt;int&lt;/code&gt;, a structure &lt;code&gt;U&lt;/code&gt; implicitly constructible from &lt;code&gt;V&lt;/code&gt; and a function &lt;code&gt;f&lt;/code&gt; overloaded for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; respectively.</source>
          <target state="translated">考虑一个可转换为 &lt;code&gt;int&lt;/code&gt; 的结构 &lt;code&gt;V&lt;/code&gt; ，一个可从 &lt;code&gt;V&lt;/code&gt; 隐式构造的结构 &lt;code&gt;U&lt;/code&gt; ，以及一个分别为 &lt;code&gt;U&lt;/code&gt; 和 &lt;code&gt;bool&lt;/code&gt; 重载的函数 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="019b9c3fbcd9fbed06290bc41f9a48781e74ba91" translate="yes" xml:space="preserve">
          <source>Consider the following class without an explicit constructor:</source>
          <target state="translated">考虑一下下面这个没有显式构造函数的类。</target>
        </trans-unit>
        <trans-unit id="f1f6cc578a73fda02c3a246d96eb579f34559dea" translate="yes" xml:space="preserve">
          <source>Constructors append implicit conversion. To suppress this implicit conversion it is required to declare a constructor with a parameter explicit.</source>
          <target state="translated">构造函数附加了隐式转换。为了抑制这种隐式转换,需要声明一个带参数显式的构造函数。</target>
        </trans-unit>
        <trans-unit id="18f1b770126acc40cb179db8016ea3c6af74a605" translate="yes" xml:space="preserve">
          <source>Conversion of a function argument:</source>
          <target state="translated">函数参数的转换。</target>
        </trans-unit>
        <trans-unit id="c8f4b2cde6b3fe7edba64d7e515a710a2e2df98c" translate="yes" xml:space="preserve">
          <source>Cpp Reference is always helpful!!! Details about explicit specifier can be found &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;here&lt;/a&gt;.  You may need to look at &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/implicit_conversion&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; too.</source>
          <target state="translated">Cpp参考总是有帮助的！！！ 有关显式说明符的详细信息可以在&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;这里&lt;/a&gt;找到。 您可能还需要查看&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/implicit_conversion&quot;&gt;隐式转换&lt;/a&gt;和&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_initialization&quot;&gt;复制初始化&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="e32c5521f2cec3f8f4baa216e8f949d5b512fcca" translate="yes" xml:space="preserve">
          <source>Depending upon the implementation, the second manner of instantiating class Foo may be confusing, or not what the programmer intended. Prefixing the &lt;code&gt;explicit&lt;/code&gt; keyword to the constructor would generate a compiler error at &lt;code&gt;Foo bar2 = 20;&lt;/code&gt;.</source>
          <target state="translated">取决于实现方式，实例化类Foo的第二种方式可能会令人困惑，或者可能不是程序员想要的。 在 &lt;code&gt;explicit&lt;/code&gt; 关键字 &lt;code&gt;Foo bar2 = 20;&lt;/code&gt; 加上构造函数会在Foo bar2 = 20时产生编译器错误。 。</target>
        </trans-unit>
        <trans-unit id="30a2e91c6246a99a6f1219373a019d7d3616ee87" translate="yes" xml:space="preserve">
          <source>Example as follows:</source>
          <target state="translated">例子如下:</target>
        </trans-unit>
        <trans-unit id="6f3ba8e6e3b35cf9dfa1800107ec407650feff17" translate="yes" xml:space="preserve">
          <source>Example using structures &lt;code&gt;X, Y, Z&lt;/code&gt; and functions &lt;code&gt;foo, bar, baz&lt;/code&gt;:</source>
          <target state="translated">使用结构 &lt;code&gt;X, Y, Z&lt;/code&gt; 和函数 &lt;code&gt;foo, bar, baz&lt;/code&gt; 示例：</target>
        </trans-unit>
        <trans-unit id="c4391c5871b2591466f38ed051125c3a6b72b655" translate="yes" xml:space="preserve">
          <source>Examples regarding constructor:</source>
          <target state="translated">关于构造函数的例子。</target>
        </trans-unit>
        <trans-unit id="6a4208acecf2caa67ad142db501f1e7edba9301f" translate="yes" xml:space="preserve">
          <source>Examples regarding conversion functions:</source>
          <target state="translated">关于转换功能的例子。</target>
        </trans-unit>
        <trans-unit id="63cd5534db30ee33eabaed9b35dad8b9682be58f" translate="yes" xml:space="preserve">
          <source>Explicit conversion functions and constructors can only be used for explicit conversions (direct initialization or explicit cast operation) while non-explicit constructors and conversion functions can be used for implicit as well as explicit conversions.</source>
          <target state="translated">显式转换函数和构造函数只能用于显式转换(直接初始化或显式投射操作),而非显式构造函数和转换函数既可以用于隐式转换,也可以用于显式转换。</target>
        </trans-unit>
        <trans-unit id="483334b7421e283b810cc10b297ff1ff94e618b1" translate="yes" xml:space="preserve">
          <source>For example, if you declare the class as:</source>
          <target state="translated">例如,如果你声明类为。</target>
        </trans-unit>
        <trans-unit id="a20de6e76729d51851c56bf373b29f18ff5bb561" translate="yes" xml:space="preserve">
          <source>For example, if you have a string class with constructor &lt;code&gt;String(const char* s)&lt;/code&gt;, that's probably exactly what you want.  You can pass a &lt;code&gt;const char*&lt;/code&gt; to a function expecting a &lt;code&gt;String&lt;/code&gt;, and the compiler will automatically construct a temporary &lt;code&gt;String&lt;/code&gt; object for you.</source>
          <target state="translated">例如，如果您有一个带有构造函数 &lt;code&gt;String(const char* s)&lt;/code&gt; 的字符串类，那可能正是您想要的。 您可以将 &lt;code&gt;const char*&lt;/code&gt; 传递给需要 &lt;code&gt;String&lt;/code&gt; 的函数，编译器会自动为您构造一个临时 &lt;code&gt;String&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="03739c543e63532d2e0ee64e937635e148313674" translate="yes" xml:space="preserve">
          <source>For example, the following statements are legal:</source>
          <target state="translated">例如,以下说法是合法的。</target>
        </trans-unit>
        <trans-unit id="05fa6736aea3a744782881e661a2c437953ca80b" translate="yes" xml:space="preserve">
          <source>Here's a simple function that takes a &lt;code&gt;Foo&lt;/code&gt; object:</source>
          <target state="translated">这是一个带有 &lt;code&gt;Foo&lt;/code&gt; 对象的简单函数：</target>
        </trans-unit>
        <trans-unit id="1e43ffb6522ca8f869078d171d24a79cea9ba5d3" translate="yes" xml:space="preserve">
          <source>Here's an example class with a constructor that can be used for implicit conversions:</source>
          <target state="translated">这里有一个可以用于隐式转换的构造函数的示例类。</target>
        </trans-unit>
        <trans-unit id="fc9d2bdfb3652039da2c1f77188f4475b0334b02" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;explicit&lt;/code&gt;-keyword enforces only explicit casts to be valid, so &lt;code&gt;bool b = c;&lt;/code&gt; would be an invalid cast in this case. In situations like these &lt;code&gt;explicit&lt;/code&gt;-keyword can help programmer to avoid implicit, unintended casts. This usage has been standardized in &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cast_operator&quot;&gt;C++11&lt;/a&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;explicit&lt;/code&gt; -keyword仅强制执行显式强制转换有效，因此 &lt;code&gt;bool b = c;&lt;/code&gt; 在这种情况下将是无效的转换。 在这种情况下， &lt;code&gt;explicit&lt;/code&gt; -keyword可以帮助程序员避免隐式，意外转换。 此用法已在&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cast_operator&quot;&gt;C ++ 11中&lt;/a&gt;标准化。</target>
        </trans-unit>
        <trans-unit id="4ecde5e33b6842aae9586216bde3d7c062492300" translate="yes" xml:space="preserve">
          <source>If either the constructor of &lt;code&gt;U&lt;/code&gt; or the conversion function of &lt;code&gt;V&lt;/code&gt; would be &lt;code&gt;explicit&lt;/code&gt;, there would be no ambiguity since only the non-explicit conversion would be considered. If both are explicit the call to &lt;code&gt;f&lt;/code&gt; using an object of type &lt;code&gt;V&lt;/code&gt; would have to be done using an explicit conversion or cast operation.</source>
          <target state="translated">如果 &lt;code&gt;U&lt;/code&gt; 的构造函数或 &lt;code&gt;V&lt;/code&gt; 的转换函数是 &lt;code&gt;explicit&lt;/code&gt; ，则不会有歧义，因为将仅考虑非显式转换。 如果两者都是显式的，则必须使用显式转换或强制转换操作来使用类型 &lt;code&gt;V&lt;/code&gt; 的对象对 &lt;code&gt;f&lt;/code&gt; 进行调用。</target>
        </trans-unit>
        <trans-unit id="24f97f1f66fe055c12d92257a5a1d131d926faa9" translate="yes" xml:space="preserve">
          <source>If the size-constructor of the vector would not be explicit it would be possible to call the function like this:</source>
          <target state="translated">如果向量的大小构造函数不是显式的,那么可以这样调用这个函数。</target>
        </trans-unit>
        <trans-unit id="124132f57abb337ccbdded8265bd7ff12e02cb28" translate="yes" xml:space="preserve">
          <source>If you declare the constructor of the class as &lt;code&gt;explicit&lt;/code&gt;, the previous declarations would be illegal.</source>
          <target state="translated">如果将类的构造函数声明为 &lt;code&gt;explicit&lt;/code&gt; ，则先前的声明将是非法的。</target>
        </trans-unit>
        <trans-unit id="dcfb0600299ba6b050382cf5b290106184e86d09" translate="yes" xml:space="preserve">
          <source>If you know what you mean, be explicit about it.</source>
          <target state="translated">如果你知道你的意思,那就明确的说出来。</target>
        </trans-unit>
        <trans-unit id="2a7badbe21782e07fa940bd63da839e4f99542d5" translate="yes" xml:space="preserve">
          <source>In C++, a constructor with only one required parameter is considered an implicit conversion function.  It converts the parameter type to the class type.  Whether this is a good thing or not depends on the semantics of the constructor.</source>
          <target state="translated">在C++中,一个只有一个必要参数的构造函数被认为是一个隐式转换函数。它将参数类型转换为类的类型。这是否是一件好事,取决于构造函数的语义。</target>
        </trans-unit>
        <trans-unit id="96a5269e608660ea6a121ce099af5f98a9d89d48" translate="yes" xml:space="preserve">
          <source>In C++11 you can also specify an &quot;operator type()&quot; with such keyword &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;http://en.cppreference.com/w/cpp/language/explicit&lt;/a&gt; With such specification you can use operator in terms of explicit conversions, and direct initialization of object.</source>
          <target state="translated">在C ++ 11中，您还可以使用关键字&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;http://en.cppreference.com/w/cpp/language/explicit&lt;/a&gt;指定&amp;ldquo; operator type（）&amp;rdquo;，通过这种规范，您可以在显式转换方面使用operator，并且直接初始化对象。</target>
        </trans-unit>
        <trans-unit id="0f99c78ff8610e39b8faa30a4b5ef71196baf577" translate="yes" xml:space="preserve">
          <source>In summary, if your single-parameter constructor converts the parameter into an object of your class, you probably don't want to use the &lt;code&gt;explicit&lt;/code&gt; keyword.  But if you have a constructor that simply happens to take a single parameter, you should declare it as &lt;code&gt;explicit&lt;/code&gt; to prevent the compiler from surprising you with unexpected conversions.</source>
          <target state="translated">总之，如果您的单参数构造函数将参数转换为类的对象，则您可能不想使用 &lt;code&gt;explicit&lt;/code&gt; 关键字。 但是，如果您有一个恰好采用单个参数的构造函数，则应将其声明为 &lt;code&gt;explicit&lt;/code&gt; 以防止编译器因意外的转换而使您感到惊讶。</target>
        </trans-unit>
        <trans-unit id="b2cb9e61565f9bb201c8b94447f641b04a3f7c24" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;usually&lt;/em&gt; good practice to declare single-argument constructors as &lt;code&gt;explicit&lt;/code&gt;, unless your implementation specifically prohibits it.</source>
          <target state="translated">&lt;em&gt;通常，&lt;/em&gt;将单参数构造函数声明为 &lt;code&gt;explicit&lt;/code&gt; &lt;em&gt;通常是一个&lt;/em&gt;好习惯，除非您的实现明确禁止这样做。</target>
        </trans-unit>
        <trans-unit id="76e264a3ab2feb73628e60003fbf19c73f2596d8" translate="yes" xml:space="preserve">
          <source>Let's look at a small setup of structures and functions to see the difference between &lt;code&gt;explicit&lt;/code&gt; and non-&lt;code&gt;explicit&lt;/code&gt; conversions.</source>
          <target state="translated">让我们看一下结构和函数的小型设置，以了解 &lt;code&gt;explicit&lt;/code&gt; 和非 &lt;code&gt;explicit&lt;/code&gt; 转换之间的区别。</target>
        </trans-unit>
        <trans-unit id="a1efdc398882ef52a5c56f27be4e597b6de6ca5f" translate="yes" xml:space="preserve">
          <source>Note also that constructors with</source>
          <target state="translated">还请注意,构造者的</target>
        </trans-unit>
        <trans-unit id="0caae2186a2fb9fc2295d889a7ef4e74ade7ad33" translate="yes" xml:space="preserve">
          <source>Now, if you try:</source>
          <target state="translated">现在,如果你试过了。</target>
        </trans-unit>
        <trans-unit id="207a36c11ea6ea8e3440a8af2255c0d19b55487e" translate="yes" xml:space="preserve">
          <source>Object initialization:</source>
          <target state="translated">对象初始化。</target>
        </trans-unit>
        <trans-unit id="d5ddf0ad260d5cf6434f9b9c3e83655bd62daf1e" translate="yes" xml:space="preserve">
          <source>Objects of class Foo can be created in 2 ways:</source>
          <target state="translated">类Foo的对象可以通过2种方式创建。</target>
        </trans-unit>
        <trans-unit id="be69b1d70c47420d0477f00402fb1ba65d040235" translate="yes" xml:space="preserve">
          <source>On the other hand, if you have a buffer class whose constructor &lt;code&gt;Buffer(int size)&lt;/code&gt; takes the size of the buffer in bytes, you probably don't want the compiler to quietly turn &lt;code&gt;int&lt;/code&gt;s into &lt;code&gt;Buffer&lt;/code&gt;s.  To prevent that, you declare the constructor with the &lt;code&gt;explicit&lt;/code&gt; keyword:</source>
          <target state="translated">另一方面，如果您有一个缓冲区类，其构造函数 &lt;code&gt;Buffer(int size)&lt;/code&gt; 占用缓冲区的大小（以字节为单位），则您可能不希望编译器将 &lt;code&gt;int&lt;/code&gt; 悄悄地转换为 &lt;code&gt;Buffer&lt;/code&gt; 。 为防止这种情况，请使用 &lt;code&gt;explicit&lt;/code&gt; 关键字声明构造函数：</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="d6cedf5b2ccb7066d6607cd21993a85101529ead" translate="yes" xml:space="preserve">
          <source>P.S. When using transformations defined BY USER (via constructors and type conversion operator) it is allowed only one level of implicit conversions used.
But you can combine this conversions with other language conversions</source>
          <target state="translated">P.S.当使用由USER定义的转换(通过构造函数和类型转换操作符)时,只允许使用一个级别的隐式转换。但你可以将这种转换与其他语言的转换结合在一起。</target>
        </trans-unit>
        <trans-unit id="286bbf56a4eca72de3e0e6073d3b5007f5367c70" translate="yes" xml:space="preserve">
          <source>Prefixing the &lt;code&gt;explicit&lt;/code&gt; keyword to the constructor prevents the compiler from using that constructor for implicit conversions. Adding it to the above class will create a compiler error at the function call &lt;code&gt;DoBar (42)&lt;/code&gt;.  It is now necessary to call for conversion explicitly with  &lt;code&gt;DoBar (Foo (42))&lt;/code&gt;</source>
          <target state="translated">在构造函数前加上 &lt;code&gt;explicit&lt;/code&gt; 关键字可以防止编译器使用该构造函数进行隐式转换。 将其添加到上述类中将在函数调用 &lt;code&gt;DoBar (42)&lt;/code&gt; 创建编译器错误。 现在必须使用 &lt;code&gt;DoBar (Foo (42))&lt;/code&gt; 明确调用转换（Foo（42））</target>
        </trans-unit>
        <trans-unit id="76d5f62f8c52d90be7570576601501fb73d2b55f" translate="yes" xml:space="preserve">
          <source>Quick look</source>
          <target state="translated">快速查看</target>
        </trans-unit>
        <trans-unit id="f1021233aa532c3c5b4aa4bd03d6d0aa9b54f1cc" translate="yes" xml:space="preserve">
          <source>Suppose, you have a class &lt;code&gt;String&lt;/code&gt;:</source>
          <target state="translated">假设您有一个 &lt;code&gt;String&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="9ee6744ba51fc0295fd21067924362836fa5a24a" translate="yes" xml:space="preserve">
          <source>That way,</source>
          <target state="translated">这样一来。</target>
        </trans-unit>
        <trans-unit id="1b7d5994338fd9ab33346c917fa397adc9476570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt; keyword makes a conversion constructor to non-conversion constructor. As a result, the code is less error prone.</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; 关键字使转换构造函数变为非转换构造函数。 结果，该代码不太容易出错。</target>
        </trans-unit>
        <trans-unit id="ddf9af1fc865c8001f9a0f7215ab0e3404df6b4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt;-keyword can also be used in user-defined type cast operators:</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; -keyword也可以在用户定义的类型转换运算符中使用：</target>
        </trans-unit>
        <trans-unit id="ce6a7532fd040432382447d8f75000df06c8721a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt;-keyword can be used to enforce a constructor to be called &lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;explicit&lt;/code&gt; - keyword强制将构造函数调用为&lt;em&gt;explicitly&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4c3f68e64b6d51aac772aa88db8426afc50c8aa" translate="yes" xml:space="preserve">
          <source>The argument is not a &lt;code&gt;Foo&lt;/code&gt; object, but an &lt;code&gt;int&lt;/code&gt;. However, there exists a constructor for &lt;code&gt;Foo&lt;/code&gt; that takes an &lt;code&gt;int&lt;/code&gt; so this constructor can be used to convert the parameter to the correct type.</source>
          <target state="translated">该参数不是 &lt;code&gt;Foo&lt;/code&gt; 对象，而是 &lt;code&gt;int&lt;/code&gt; 。 但是， &lt;code&gt;Foo&lt;/code&gt; 有一个采用 &lt;code&gt;int&lt;/code&gt; 的构造函数，因此可以使用该构造函数将参数转换为正确的类型。</target>
        </trans-unit>
        <trans-unit id="3049d136f55a475626db3dad948b02469e9778f9" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;'x'&lt;/code&gt; will be implicitly converted to &lt;code&gt;int&lt;/code&gt; and then the &lt;code&gt;String(int)&lt;/code&gt; constructor will be called. But, this is not what the user might have intended. So, to prevent such conditions, we shall define the constructor as &lt;code&gt;explicit&lt;/code&gt;:</source>
          <target state="translated">字符 &lt;code&gt;'x'&lt;/code&gt; 将隐式转换为 &lt;code&gt;int&lt;/code&gt; ，然后将调用 &lt;code&gt;String(int)&lt;/code&gt; 构造函数。 但是，这不是用户可能想要的。 因此，为防止出现这种情况，我们将构造函数定义为 &lt;code&gt;explicit&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2067a14f8d7ec35e3e14dc1571c9ef15e462e679" translate="yes" xml:space="preserve">
          <source>The compiler does not know wether to use the constructor of &lt;code&gt;U&lt;/code&gt; or the conversion function to convert the &lt;code&gt;V&lt;/code&gt; object into a type for passing to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">编译器不知道是否使用 &lt;code&gt;U&lt;/code&gt; 的构造函数或转换函数将 &lt;code&gt;V&lt;/code&gt; 对象转换为类型以传递给 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd2c9fb6422b9a6c94f550ada7376764badd6b9a" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to do this once for each parameter.</source>
          <target state="translated">允许编译器为每个参数做一次。</target>
        </trans-unit>
        <trans-unit id="c61dcda5620fa9ba492d6ebe7eca3691f7dedb65" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to make one implicit conversion to resolve the parameters to a function. What this means is that the compiler can use constructors callable with a &lt;strong&gt;single parameter&lt;/strong&gt; to convert from one type to another in order to get the right type for a parameter.</source>
          <target state="translated">允许编译器进行一次隐式转换，以将参数解析为函数。 这意味着编译器可以使用可通过&lt;strong&gt;单个参数&lt;/strong&gt;调用的构造函数从一种类型转换为另一种类型，以便获得参数的正确类型。</target>
        </trans-unit>
        <trans-unit id="c506586127aafb4571605139fe82715ddb3cb0e6" translate="yes" xml:space="preserve">
          <source>The explicit function specifier controls unwanted implicit type
  conversions. It can only be used in declarations of constructors
  within a class declaration. For example, except for the default
  constructor, the constructors in the following class are conversion
  constructors.</source>
          <target state="translated">显式函数指定器控制了不需要的隐式类型转换。它只能在类声明中的构造函数的声明中使用。例如,除了默认构造函数外,下面的类中的构造函数都是转换构造函数。</target>
        </trans-unit>
        <trans-unit id="aaaed950d829699c6b369f21001642be0a85ccc4" translate="yes" xml:space="preserve">
          <source>The explicit specifier specifies that a constructor or conversion function (since C++11) doesn't allow implicit conversions or copy-initialization.</source>
          <target state="translated">显式指定器指定构造函数或转换函数(自C++11以来)不允许隐式转换或复制初始化。</target>
        </trans-unit>
        <trans-unit id="9e22fa09c228ce6e248691a575f81838d40d2ea5" translate="yes" xml:space="preserve">
          <source>The first declaration is equivalent to &lt;code&gt;A c = A( 1 );&lt;/code&gt;.</source>
          <target state="translated">第一个声明等效于 &lt;code&gt;A c = A( 1 );&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80f1e63e6386d4a9d89289f1bf6b566c60d0ab41" translate="yes" xml:space="preserve">
          <source>The following declarations are legal:</source>
          <target state="translated">下列声明是合法的:</target>
        </trans-unit>
        <trans-unit id="1169f772595bc8ae74d724d600a7a87c62ff125b" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;explicit&lt;/code&gt; accompanies either</source>
          <target state="translated">关键字 &lt;code&gt;explicit&lt;/code&gt; 随同</target>
        </trans-unit>
        <trans-unit id="9c61164f85ca5b809d267efbbbea8840b12030f5" translate="yes" xml:space="preserve">
          <source>The reason you might want to do this is to avoid accidental construction that can hide bugs.  Contrived example:</source>
          <target state="translated">你可能会想这样做的原因是为了避免意外的施工会隐藏BUG。对立的例子。</target>
        </trans-unit>
        <trans-unit id="b4ba231f0faf7a6a4e919e6912719f1780af4a1e" translate="yes" xml:space="preserve">
          <source>This answer is about object creation with/without an explicit constructor since it is not covered in the other answers.</source>
          <target state="translated">这个答案是关于没有显式构造函数的对象创建,因为其他答案中没有涉及。</target>
        </trans-unit>
        <trans-unit id="78c2215507e93f78a74406cf7cb8018f79940750" translate="yes" xml:space="preserve">
          <source>This has already been discussed (&lt;a href=&quot;https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319&quot;&gt;what is explicit constructor&lt;/a&gt;). But I must say, that it lacks the detailed descriptions found here.</source>
          <target state="translated">已经讨论过了（ &lt;a href=&quot;https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319&quot;&gt;什么是显式构造函数&lt;/a&gt; ）。 但是我必须说，它缺少此处的详细描述。</target>
        </trans-unit>
        <trans-unit id="77c49e3ca9f1370e49c1a2a3fdbf65a3dc598015" translate="yes" xml:space="preserve">
          <source>Using the explicit keyword in a class interface enforces the user of the interface to be explicit about a desired conversion.</source>
          <target state="translated">在类接口中使用显式关键字,可以强制接口的用户对所需的转换进行显式化。</target>
        </trans-unit>
        <trans-unit id="e281673a57e5bea475598290ff974afa1741081a" translate="yes" xml:space="preserve">
          <source>What does the &lt;code&gt;explicit&lt;/code&gt; keyword mean in C++?</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; 关键字在C ++中是什么意思？</target>
        </trans-unit>
        <trans-unit id="ed5d4b7337e6a32f69ef31abb6b7b842c48d6f29" translate="yes" xml:space="preserve">
          <source>What does the explicit keyword mean</source>
          <target state="translated">明确的关键词是什么意思</target>
        </trans-unit>
        <trans-unit id="5edb7164eb8327c49e3246ab6a67c8cc6391b808" translate="yes" xml:space="preserve">
          <source>What would one expect from such a call? One line containing &lt;code&gt;3&lt;/code&gt; or three lines containing &lt;code&gt;0&lt;/code&gt;? (Where the second one is what happens.)</source>
          <target state="translated">这样的电话会带来什么？ 1行包含 &lt;code&gt;3&lt;/code&gt; 个或3行包含 &lt;code&gt;0&lt;/code&gt; ？ （第二个是发生什么情况。）</target>
        </trans-unit>
        <trans-unit id="35b2cad2dc0f1377d98ff2f0f160c44250275905" translate="yes" xml:space="preserve">
          <source>Why use &lt;code&gt;explicit&lt;/code&gt; conversion functions or constructors?</source>
          <target state="translated">为什么要使用 &lt;code&gt;explicit&lt;/code&gt; 转换函数或构造函数？</target>
        </trans-unit>
        <trans-unit id="c22c511044cbc64591d114b9cd769d00a98cfe0f" translate="yes" xml:space="preserve">
          <source>You can only assign values that match the values of the class type.</source>
          <target state="translated">你只能分配与类类型的值匹配的值。</target>
        </trans-unit>
        <trans-unit id="e087e20de6eff6911f7c8fa41bb5e3f6bb2cb100" translate="yes" xml:space="preserve">
          <source>You have a &lt;code&gt;MyString(int size)&lt;/code&gt; class with a constructor that constructs a string of the given size.  You have a function &lt;code&gt;print(const MyString&amp;amp;)&lt;/code&gt;, and you call &lt;code&gt;print(3)&lt;/code&gt; (when you &lt;em&gt;actually&lt;/em&gt; intended to call &lt;code&gt;print(&quot;3&quot;)&lt;/code&gt;).  You expect it to print &quot;3&quot;, but it prints an empty string of length 3 instead.</source>
          <target state="translated">您有一个 &lt;code&gt;MyString(int size)&lt;/code&gt; 类，该类的构造函数构造了给定大小的字符串。 您有一个函数 &lt;code&gt;print(const MyString&amp;amp;)&lt;/code&gt; ，并且您调用了 &lt;code&gt;print(3)&lt;/code&gt; （当您&lt;em&gt;实际上&lt;/em&gt;打算调用 &lt;code&gt;print(&quot;3&quot;)&lt;/code&gt; ）。 您希望它打印&amp;ldquo; 3&amp;rdquo;，但是它将打印一个长度为3的空字符串。</target>
        </trans-unit>
        <trans-unit id="3c93f07a155ea96a0b57d63ea157ae1ba6c82880" translate="yes" xml:space="preserve">
          <source>and here's where the &lt;code&gt;DoBar&lt;/code&gt; function is called.</source>
          <target state="translated">这就是 &lt;code&gt;DoBar&lt;/code&gt; 函数的调用位置。</target>
        </trans-unit>
        <trans-unit id="80e76fd5e13a34f76dc82f7374cbbedf25d22621" translate="yes" xml:space="preserve">
          <source>becomes a compile-time error.  If you want to pass a temporary &lt;code&gt;Buffer&lt;/code&gt; object, you have to do so explicitly:</source>
          <target state="translated">成为编译时错误。 如果要传递一个临时的 &lt;code&gt;Buffer&lt;/code&gt; 对象，则必须明确地这样做：</target>
        </trans-unit>
        <trans-unit id="d0bc31847e397dc9ce6f32057f43c91554466982" translate="yes" xml:space="preserve">
          <source>can both be used as single-argument constructors. So you may want to make these also &lt;code&gt;explicit&lt;/code&gt;.</source>
          <target state="translated">都可以用作单参数构造函数。 因此，您可能想使它们也 &lt;code&gt;explicit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1112e4645e1c510e383ffdb6d150959b4f130d21" translate="yes" xml:space="preserve">
          <source>convert pointers of objects to base class and to void*;</source>
          <target state="translated">将对象的指针转换为基类并转换为void*。</target>
        </trans-unit>
        <trans-unit id="19f768b20de266f72b8bd3b42fe489a61513ccf9" translate="yes" xml:space="preserve">
          <source>default arguments for all parameters, or</source>
          <target state="translated">所有参数的默认参数,或</target>
        </trans-unit>
        <trans-unit id="fc3ae7b739a0d4b0a8161d16c99bc4a63b0ccc76" translate="yes" xml:space="preserve">
          <source>default arguments for the second parameter onwards</source>
          <target state="translated">第二个参数的默认参数</target>
        </trans-unit>
        <trans-unit id="d9f4df0fccc3324ca442bc5a16211b9f8e047d00" translate="yes" xml:space="preserve">
          <source>standart conversions (int to double);</source>
          <target state="translated">(int to double)。</target>
        </trans-unit>
        <trans-unit id="492f05458909b4e400b0f5f301b1c1261874ae73" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;explicit&lt;/code&gt;-keyword in front of the constructor &lt;code&gt;C(void)&lt;/code&gt; tells the compiler that only explicit call to this constructor is allowed.</source>
          <target state="translated">构造函数 &lt;code&gt;C(void)&lt;/code&gt; 前面的 &lt;code&gt;explicit&lt;/code&gt; -keyword告诉编译器仅允许对此构造函数的显式调用。</target>
        </trans-unit>
        <trans-unit id="ba087709da18b56c1d734fe563e840114679f1d9" translate="yes" xml:space="preserve">
          <source>up integral ranks (char to int, float to double);</source>
          <target state="translated">上调积分等级(char到int,float到double)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
