<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/121162">
    <body>
      <group id="121162">
        <trans-unit id="6e909f16da04e6b4ba7a3dc42d76fb1fc131016b" translate="yes" xml:space="preserve">
          <source>1) A constructor declared without the function-specifier explicit specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a converting constructor.</source>
          <target state="translated">1)function-specifier を明示的に指定せずに宣言されたコンストラクタは,パラメータの型からクラスの型への変換を指定します.このようなコンストラクタを変換コンストラクタと呼びます.</target>
        </trans-unit>
        <trans-unit id="40075093fa2de375513bd7806fbfa585f1ccb88d" translate="yes" xml:space="preserve">
          <source>2) A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion for direct-initialization (8.5). Otherwise, user-defined conversions are not restricted to use in assignments
  and initializations.</source>
          <target state="translated">2)変換関数は明示的であってもよく(7.1.2),その場合は,直接初期化(8.5)のためのユーザ定義の変換としか考えられません。そうでなければ,ユーザ定義の変換は,代入や初期化での使用に制限されません。</target>
        </trans-unit>
        <trans-unit id="82c5d71d8413126d3518e4c637002b6b8aa3fbf6" translate="yes" xml:space="preserve">
          <source>2) An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or valueinitialization
  (8.5).</source>
          <target state="translated">2)明示的なコンストラクタは、非明示的なコンストラクタと同様にオブジェクトを構築しますが、直接初期化構文 (8.5)またはキャスト (5.2.9,5.4)が明示的に使用される場合にのみ使用します。デフォルトのコンストラクタは明示的なコンストラクタである可能性があり、そのようなコンストラクタはデフォルトの初期化や値の初期化 (8.5)を行うために使用されます。</target>
        </trans-unit>
        <trans-unit id="7f26b74b665e2acdf88f5ec7e221b4624394b35b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx&quot;&gt;Here&lt;/a&gt; is a good write-up on explicit constructors.</source>
          <target state="translated">&lt;a href=&quot;http://weblogs.asp.net/kennykerr/archive/2004/08/31/Explicit-Constructors.aspx&quot;&gt;以下&lt;/a&gt;は、明示的なコンストラクターに関する優れた記事です。</target>
        </trans-unit>
        <trans-unit id="fb9d903b66d4b86f2a3d5b0e7ce99773805eec0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ [class.conv.ctor]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ [class.conv.ctor]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e76638e98bf8cd3442bd39601d1b5f75737ea3a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ [class.conv.fct]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C ++ [class.conv.fct]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dcec192ad51b7af512d87c6084e215eb361da2a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion constructors and non-explicit conversion functions may introduce ambiguity.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;変換コンストラクターと非明示的な変換関数により、あいまいさが生じる場合があります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e074b33cdf4fd9146a172fd109876e5aaa6831fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conversion constructors and non-explicit conversion functions may lead to unexpected behaviour.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;変換コンストラクターおよび非明示的な変換関数は、予期しない動作を引き起こす可能性があります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="404f447a2f27e2777f7b751f552e0208232d38cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explicit conversion constructors (C++ only)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;明示的な変換コンストラクター（C ++のみ）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9e1424d19737c3e0e14bad461887396f1689093" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;a constructor of class X that cannot be used to implicitly convert the first (any only) parameter to type X&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最初の（任意の）パラメータをタイプXに暗黙的に変換するために使用できないクラスXのコンストラクタ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0b9c3a76bec2b3865fa08d11db98c0d983d43a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;or a conversion function that is only considered for direct initialization and explicit conversion.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;または、直接初期化と明示的な変換のみが考慮される変換関数。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90931b1495f819faf9ec90d5e4e0e1fc229bdff3" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;f&lt;/code&gt; is ambiguous if passing an object of type &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 型のオブジェクトを渡す場合、 &lt;code&gt;f&lt;/code&gt; の呼び出しはあいまいです。</target>
        </trans-unit>
        <trans-unit id="ef58e46d65d0f651d7e99ff4af68f72c49935b2e" translate="yes" xml:space="preserve">
          <source>An example when you would deliberately &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; want to make your single-argument constructor explicit is if you're creating a functor (look at the 'add_x' struct declared in &lt;a href=&quot;https://stackoverflow.com/a/356993/793930&quot;&gt;this&lt;/a&gt; answer). In such a case, creating an object as &lt;code&gt;add_x add30 = 30;&lt;/code&gt; would probably make sense.</source>
          <target state="translated">単一引数コンストラクターを意図的に明示的にしたく&lt;strong&gt;&lt;em&gt;ない&lt;/em&gt;&lt;/strong&gt;場合の例は、ファンクターを作成している場合です（ &lt;a href=&quot;https://stackoverflow.com/a/356993/793930&quot;&gt;この&lt;/a&gt;回答で宣言されている 'add_x'構造体を見てください）。 このような場合、オブジェクトを &lt;code&gt;add_x add30 = 30;&lt;/code&gt; として作成します。 おそらく意味があります。</target>
        </trans-unit>
        <trans-unit id="023d40884b32ae99ad8ee9224964e2bf68369ac5" translate="yes" xml:space="preserve">
          <source>Another good practice for classes is to make copy construction and assignment private (a.k.a. disable it) unless you really need to implement it. This avoids having eventual copies of pointers when using the methods that C++ will create for you by default. An other way to do this is derive from boost::noncopyable.</source>
          <target state="translated">クラスのもう 1 つの良い習慣は、本当に実装する必要がない限り、コピーの作成と代入を非公開にすることです (別名、それを無効にする)。これにより、C++がデフォルトで作成してくれるメソッドを使用する際に、最終的にポインタのコピーが発生することを避けることができます。他の方法としては、boost::noncopyableから派生したものがあります。</target>
        </trans-unit>
        <trans-unit id="93fa74ff062a4f43bee8427c70d3f3e8e2eb398e" translate="yes" xml:space="preserve">
          <source>As Bjarne Stroustrup  puts it (in &quot;The C++ Programming Language&quot;, 4th Ed., 35.2.1, pp. 1011) on the question why &lt;code&gt;std::duration&lt;/code&gt; cannot be implicitly constructed from a plain number:</source>
          <target state="translated">Bjarne Stroustrupが &lt;code&gt;std::duration&lt;/code&gt; を単純な数値から暗黙的に構築できない理由についての質問（「C ++プログラミング言語」、第4版、35.2.1、pp。1011）に次のように述べています。</target>
        </trans-unit>
        <trans-unit id="91abe90d799140d96614d181c106b32f8cccead0" translate="yes" xml:space="preserve">
          <source>Besides, it is always a good coding practice to make your one argument constructors (including those with default values for arg2,arg3,...) as already stated. 
Like always with C++: if you don't - you'll wish you did...</source>
          <target state="translated">その上、すでに述べたように1引数のコンストラクタ(arg2,arg3,...のデフォルト値を持つものを含む)を作成することは、常に良いコーディングの練習になります。C++ではいつものように:もしそうしないと-したことを後悔することになるでしょう...</target>
        </trans-unit>
        <trans-unit id="8056a96d70581f55a1f36421d40b18baa0983d53" translate="yes" xml:space="preserve">
          <source>Consider a function printing some vector:</source>
          <target state="translated">あるベクトルを印刷する関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="ffabce6768c306d54af29bfe6cecee317c83c262" translate="yes" xml:space="preserve">
          <source>Consider a structure &lt;code&gt;V&lt;/code&gt;, convertible to &lt;code&gt;int&lt;/code&gt;, a structure &lt;code&gt;U&lt;/code&gt; implicitly constructible from &lt;code&gt;V&lt;/code&gt; and a function &lt;code&gt;f&lt;/code&gt; overloaded for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; に変換可能な構造体 &lt;code&gt;V&lt;/code&gt; 、 Vから暗黙的に構築可能な構造体 &lt;code&gt;U&lt;/code&gt; 、および &lt;code&gt;U&lt;/code&gt; と &lt;code&gt;bool&lt;/code&gt; に対してそれぞれオーバーロードされた関数 &lt;code&gt;f&lt;/code&gt; を考えます。</target>
        </trans-unit>
        <trans-unit id="019b9c3fbcd9fbed06290bc41f9a48781e74ba91" translate="yes" xml:space="preserve">
          <source>Consider the following class without an explicit constructor:</source>
          <target state="translated">明示的なコンストラクタを持たない以下のクラスを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="f1f6cc578a73fda02c3a246d96eb579f34559dea" translate="yes" xml:space="preserve">
          <source>Constructors append implicit conversion. To suppress this implicit conversion it is required to declare a constructor with a parameter explicit.</source>
          <target state="translated">コンストラクタは暗黙の変換を追加します。この暗黙の変換を抑制するには、パラメータを明示的に指定してコンストラクタを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="18f1b770126acc40cb179db8016ea3c6af74a605" translate="yes" xml:space="preserve">
          <source>Conversion of a function argument:</source>
          <target state="translated">関数の引数の変換。</target>
        </trans-unit>
        <trans-unit id="c8f4b2cde6b3fe7edba64d7e515a710a2e2df98c" translate="yes" xml:space="preserve">
          <source>Cpp Reference is always helpful!!! Details about explicit specifier can be found &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;here&lt;/a&gt;.  You may need to look at &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/implicit_conversion&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; too.</source>
          <target state="translated">Cppリファレンスは常に役に立ちます!!! 明示的な指定子の詳細については、 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;こちらをご覧ください&lt;/a&gt; 。 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/implicit_conversion&quot;&gt;暗黙の変換&lt;/a&gt;と&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/copy_initialization&quot;&gt;コピーの初期化&lt;/a&gt;も確認する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="e32c5521f2cec3f8f4baa216e8f949d5b512fcca" translate="yes" xml:space="preserve">
          <source>Depending upon the implementation, the second manner of instantiating class Foo may be confusing, or not what the programmer intended. Prefixing the &lt;code&gt;explicit&lt;/code&gt; keyword to the constructor would generate a compiler error at &lt;code&gt;Foo bar2 = 20;&lt;/code&gt;.</source>
          <target state="translated">実装によっては、クラスFooをインスタンス化する2番目の方法は混乱するか、プログラマーの意図とは異なる場合があります。 コンストラクタに &lt;code&gt;explicit&lt;/code&gt; キーワードをプレフィックスすると、 &lt;code&gt;Foo bar2 = 20;&lt;/code&gt; でコンパイラエラーが発生します。 。</target>
        </trans-unit>
        <trans-unit id="30a2e91c6246a99a6f1219373a019d7d3616ee87" translate="yes" xml:space="preserve">
          <source>Example as follows:</source>
          <target state="translated">以下のような例。</target>
        </trans-unit>
        <trans-unit id="6f3ba8e6e3b35cf9dfa1800107ec407650feff17" translate="yes" xml:space="preserve">
          <source>Example using structures &lt;code&gt;X, Y, Z&lt;/code&gt; and functions &lt;code&gt;foo, bar, baz&lt;/code&gt;:</source>
          <target state="translated">構造 &lt;code&gt;X, Y, Z&lt;/code&gt; および関数 &lt;code&gt;foo, bar, baz&lt;/code&gt; を使用した例：</target>
        </trans-unit>
        <trans-unit id="c4391c5871b2591466f38ed051125c3a6b72b655" translate="yes" xml:space="preserve">
          <source>Examples regarding constructor:</source>
          <target state="translated">コンストラクタに関する例。</target>
        </trans-unit>
        <trans-unit id="6a4208acecf2caa67ad142db501f1e7edba9301f" translate="yes" xml:space="preserve">
          <source>Examples regarding conversion functions:</source>
          <target state="translated">変換機能に関する例</target>
        </trans-unit>
        <trans-unit id="63cd5534db30ee33eabaed9b35dad8b9682be58f" translate="yes" xml:space="preserve">
          <source>Explicit conversion functions and constructors can only be used for explicit conversions (direct initialization or explicit cast operation) while non-explicit constructors and conversion functions can be used for implicit as well as explicit conversions.</source>
          <target state="translated">明示的な変換関数やコンストラクタは,明示的な変換(直接初期化や明示的なキャスト操作)にのみ使用できますが,非明示的なコンストラクタや変換関数は,明示的な変換だけでなく暗黙的な変換にも使用できます。</target>
        </trans-unit>
        <trans-unit id="483334b7421e283b810cc10b297ff1ff94e618b1" translate="yes" xml:space="preserve">
          <source>For example, if you declare the class as:</source>
          <target state="translated">例えば、クラスを以下のように宣言した場合。</target>
        </trans-unit>
        <trans-unit id="a20de6e76729d51851c56bf373b29f18ff5bb561" translate="yes" xml:space="preserve">
          <source>For example, if you have a string class with constructor &lt;code&gt;String(const char* s)&lt;/code&gt;, that's probably exactly what you want.  You can pass a &lt;code&gt;const char*&lt;/code&gt; to a function expecting a &lt;code&gt;String&lt;/code&gt;, and the compiler will automatically construct a temporary &lt;code&gt;String&lt;/code&gt; object for you.</source>
          <target state="translated">たとえば、コンストラクター &lt;code&gt;String(const char* s)&lt;/code&gt; を含む文字列クラスがある場合、それはおそらくまさにあなたが望むものです。 &lt;code&gt;String&lt;/code&gt; が必要な関数に &lt;code&gt;const char*&lt;/code&gt; を渡すと、コンパイラーが自動的に一時的な &lt;code&gt;String&lt;/code&gt; オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="03739c543e63532d2e0ee64e937635e148313674" translate="yes" xml:space="preserve">
          <source>For example, the following statements are legal:</source>
          <target state="translated">例えば、以下のような記述は合法です。</target>
        </trans-unit>
        <trans-unit id="05fa6736aea3a744782881e661a2c437953ca80b" translate="yes" xml:space="preserve">
          <source>Here's a simple function that takes a &lt;code&gt;Foo&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; オブジェクトを取得する簡単な関数を次に示します。</target>
        </trans-unit>
        <trans-unit id="1e43ffb6522ca8f869078d171d24a79cea9ba5d3" translate="yes" xml:space="preserve">
          <source>Here's an example class with a constructor that can be used for implicit conversions:</source>
          <target state="translated">ここでは、暗黙の変換に使用できるコンストラクタを持つクラスの例を示します。</target>
        </trans-unit>
        <trans-unit id="fc9d2bdfb3652039da2c1f77188f4475b0334b02" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;explicit&lt;/code&gt;-keyword enforces only explicit casts to be valid, so &lt;code&gt;bool b = c;&lt;/code&gt; would be an invalid cast in this case. In situations like these &lt;code&gt;explicit&lt;/code&gt;-keyword can help programmer to avoid implicit, unintended casts. This usage has been standardized in &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cast_operator&quot;&gt;C++11&lt;/a&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;explicit&lt;/code&gt; -keywordは明示的なキャストのみを有効にするため、 &lt;code&gt;bool b = c;&lt;/code&gt; この場合、無効なキャストになります。 これらの &lt;code&gt;explicit&lt;/code&gt; -keywordのような状況では、プログラマが暗黙の意図しないキャストを回避するのに役立ちます。 この使用法は&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/cast_operator&quot;&gt;C ++ 11で&lt;/a&gt;標準化されています。</target>
        </trans-unit>
        <trans-unit id="4ecde5e33b6842aae9586216bde3d7c062492300" translate="yes" xml:space="preserve">
          <source>If either the constructor of &lt;code&gt;U&lt;/code&gt; or the conversion function of &lt;code&gt;V&lt;/code&gt; would be &lt;code&gt;explicit&lt;/code&gt;, there would be no ambiguity since only the non-explicit conversion would be considered. If both are explicit the call to &lt;code&gt;f&lt;/code&gt; using an object of type &lt;code&gt;V&lt;/code&gt; would have to be done using an explicit conversion or cast operation.</source>
          <target state="translated">&lt;code&gt;U&lt;/code&gt; のコンストラクタまたは &lt;code&gt;V&lt;/code&gt; の変換関数が &lt;code&gt;explicit&lt;/code&gt; である場合、非明示的変換のみが考慮されるため、あいまいさはありません。 両方が明示的である場合、タイプ &lt;code&gt;V&lt;/code&gt; のオブジェクトを使用した &lt;code&gt;f&lt;/code&gt; の呼び出しは、明示的な変換またはキャスト演算を使用して実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="24f97f1f66fe055c12d92257a5a1d131d926faa9" translate="yes" xml:space="preserve">
          <source>If the size-constructor of the vector would not be explicit it would be possible to call the function like this:</source>
          <target state="translated">ベクトルのサイズコンストラクタが明示的でない場合は,このような関数を呼び出すことができます.</target>
        </trans-unit>
        <trans-unit id="124132f57abb337ccbdded8265bd7ff12e02cb28" translate="yes" xml:space="preserve">
          <source>If you declare the constructor of the class as &lt;code&gt;explicit&lt;/code&gt;, the previous declarations would be illegal.</source>
          <target state="translated">クラスのコンストラクタを &lt;code&gt;explicit&lt;/code&gt; として宣言すると、以前の宣言は無効になります。</target>
        </trans-unit>
        <trans-unit id="dcfb0600299ba6b050382cf5b290106184e86d09" translate="yes" xml:space="preserve">
          <source>If you know what you mean, be explicit about it.</source>
          <target state="translated">言いたいことがわかっているのであれば、露骨に言いましょう。</target>
        </trans-unit>
        <trans-unit id="2a7badbe21782e07fa940bd63da839e4f99542d5" translate="yes" xml:space="preserve">
          <source>In C++, a constructor with only one required parameter is considered an implicit conversion function.  It converts the parameter type to the class type.  Whether this is a good thing or not depends on the semantics of the constructor.</source>
          <target state="translated">C++では、必要なパラメータが1つだけのコンストラクタは暗黙の変換関数とみなされます。これは、パラメータの型をクラスの型に変換します。これが良いことかどうかは、コンストラクタのセマンティクスに依存します。</target>
        </trans-unit>
        <trans-unit id="96a5269e608660ea6a121ce099af5f98a9d89d48" translate="yes" xml:space="preserve">
          <source>In C++11 you can also specify an &quot;operator type()&quot; with such keyword &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/explicit&quot;&gt;http://en.cppreference.com/w/cpp/language/explicit&lt;/a&gt; With such specification you can use operator in terms of explicit conversions, and direct initialization of object.</source>
          <target state="translated">C ++ 11では、次のキーワードを使用して「operator type（）」を指定することもできます。オブジェクトの直接初期化。</target>
        </trans-unit>
        <trans-unit id="0f99c78ff8610e39b8faa30a4b5ef71196baf577" translate="yes" xml:space="preserve">
          <source>In summary, if your single-parameter constructor converts the parameter into an object of your class, you probably don't want to use the &lt;code&gt;explicit&lt;/code&gt; keyword.  But if you have a constructor that simply happens to take a single parameter, you should declare it as &lt;code&gt;explicit&lt;/code&gt; to prevent the compiler from surprising you with unexpected conversions.</source>
          <target state="translated">要約すると、単一パラメーターのコンストラクターがパラメーターをクラスのオブジェクトに変換する場合、おそらく &lt;code&gt;explicit&lt;/code&gt; キーワードを使用したくないでしょう。 ただし、たまたま単一のパラメーターをとるコンストラクターがある場合は、それを &lt;code&gt;explicit&lt;/code&gt; に宣言して、コンパイラーが予期しない変換で驚かないようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="b2cb9e61565f9bb201c8b94447f641b04a3f7c24" translate="yes" xml:space="preserve">
          <source>It is &lt;em&gt;usually&lt;/em&gt; good practice to declare single-argument constructors as &lt;code&gt;explicit&lt;/code&gt;, unless your implementation specifically prohibits it.</source>
          <target state="translated">実装で &lt;code&gt;explicit&lt;/code&gt; 的に禁止されていない限り、 &lt;em&gt;通常、&lt;/em&gt;単一引数のコンストラクターを明示的に宣言することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="76e264a3ab2feb73628e60003fbf19c73f2596d8" translate="yes" xml:space="preserve">
          <source>Let's look at a small setup of structures and functions to see the difference between &lt;code&gt;explicit&lt;/code&gt; and non-&lt;code&gt;explicit&lt;/code&gt; conversions.</source>
          <target state="translated">構造体と関数の小さな設定を見て、 &lt;code&gt;explicit&lt;/code&gt; 変換と非明示的な変換の違いを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="a1efdc398882ef52a5c56f27be4e597b6de6ca5f" translate="yes" xml:space="preserve">
          <source>Note also that constructors with</source>
          <target state="translated">また</target>
        </trans-unit>
        <trans-unit id="0caae2186a2fb9fc2295d889a7ef4e74ade7ad33" translate="yes" xml:space="preserve">
          <source>Now, if you try:</source>
          <target state="translated">さて、やってみると。</target>
        </trans-unit>
        <trans-unit id="207a36c11ea6ea8e3440a8af2255c0d19b55487e" translate="yes" xml:space="preserve">
          <source>Object initialization:</source>
          <target state="translated">オブジェクトの初期化。</target>
        </trans-unit>
        <trans-unit id="d5ddf0ad260d5cf6434f9b9c3e83655bd62daf1e" translate="yes" xml:space="preserve">
          <source>Objects of class Foo can be created in 2 ways:</source>
          <target state="translated">クラスFooのオブジェクトは2つの方法で作成することができます。</target>
        </trans-unit>
        <trans-unit id="be69b1d70c47420d0477f00402fb1ba65d040235" translate="yes" xml:space="preserve">
          <source>On the other hand, if you have a buffer class whose constructor &lt;code&gt;Buffer(int size)&lt;/code&gt; takes the size of the buffer in bytes, you probably don't want the compiler to quietly turn &lt;code&gt;int&lt;/code&gt;s into &lt;code&gt;Buffer&lt;/code&gt;s.  To prevent that, you declare the constructor with the &lt;code&gt;explicit&lt;/code&gt; keyword:</source>
          <target state="translated">一方、コンストラクター &lt;code&gt;Buffer(int size)&lt;/code&gt; がバッファーのサイズをバイト単位で取得するバッファークラスがある場合、コンパイラーが静かに &lt;code&gt;int&lt;/code&gt; を &lt;code&gt;Buffer&lt;/code&gt; に変換することは望ましくありません。 これを防ぐには、 &lt;code&gt;explicit&lt;/code&gt; キーワードを使用してコンストラクタを宣言します。</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="d6cedf5b2ccb7066d6607cd21993a85101529ead" translate="yes" xml:space="preserve">
          <source>P.S. When using transformations defined BY USER (via constructors and type conversion operator) it is allowed only one level of implicit conversions used.
But you can combine this conversions with other language conversions</source>
          <target state="translated">追伸:(コンストラクタと型変換演算子を介して)ユーザによって定義された変換を使用する場合、使用される暗黙の変換は1つのレベルしか許可されていません。しかし、この変換を他の言語変換と組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="286bbf56a4eca72de3e0e6073d3b5007f5367c70" translate="yes" xml:space="preserve">
          <source>Prefixing the &lt;code&gt;explicit&lt;/code&gt; keyword to the constructor prevents the compiler from using that constructor for implicit conversions. Adding it to the above class will create a compiler error at the function call &lt;code&gt;DoBar (42)&lt;/code&gt;.  It is now necessary to call for conversion explicitly with  &lt;code&gt;DoBar (Foo (42))&lt;/code&gt;</source>
          <target state="translated">コンストラクターに &lt;code&gt;explicit&lt;/code&gt; キーワードをプレフィックスすると、コンパイラーはそのコンストラクターを暗黙的な変換に使用できなくなります。 上記のクラスに追加すると、関数呼び出し &lt;code&gt;DoBar (42)&lt;/code&gt; でコンパイラエラーが発生します。 &lt;code&gt;DoBar (Foo (42))&lt;/code&gt; 明示的に変換を呼び出す必要がある</target>
        </trans-unit>
        <trans-unit id="76d5f62f8c52d90be7570576601501fb73d2b55f" translate="yes" xml:space="preserve">
          <source>Quick look</source>
          <target state="translated">クイックルック</target>
        </trans-unit>
        <trans-unit id="f1021233aa532c3c5b4aa4bd03d6d0aa9b54f1cc" translate="yes" xml:space="preserve">
          <source>Suppose, you have a class &lt;code&gt;String&lt;/code&gt;:</source>
          <target state="translated">あなたがクラス &lt;code&gt;String&lt;/code&gt; を持っているとしましょう：</target>
        </trans-unit>
        <trans-unit id="9ee6744ba51fc0295fd21067924362836fa5a24a" translate="yes" xml:space="preserve">
          <source>That way,</source>
          <target state="translated">あっちだ</target>
        </trans-unit>
        <trans-unit id="1b7d5994338fd9ab33346c917fa397adc9476570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt; keyword makes a conversion constructor to non-conversion constructor. As a result, the code is less error prone.</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; キーワードは、変換コンストラクタを非変換コンストラクタにします。 その結果、コードはエラーが発生しにくくなります。</target>
        </trans-unit>
        <trans-unit id="ddf9af1fc865c8001f9a0f7215ab0e3404df6b4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt;-keyword can also be used in user-defined type cast operators:</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; -keywordは、ユーザー定義の型キャスト演算子でも使用できます。</target>
        </trans-unit>
        <trans-unit id="ce6a7532fd040432382447d8f75000df06c8721a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;explicit&lt;/code&gt;-keyword can be used to enforce a constructor to be called &lt;em&gt;explicitly&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; -keywordを使用すると、コンストラクタを明示的に呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="a4c3f68e64b6d51aac772aa88db8426afc50c8aa" translate="yes" xml:space="preserve">
          <source>The argument is not a &lt;code&gt;Foo&lt;/code&gt; object, but an &lt;code&gt;int&lt;/code&gt;. However, there exists a constructor for &lt;code&gt;Foo&lt;/code&gt; that takes an &lt;code&gt;int&lt;/code&gt; so this constructor can be used to convert the parameter to the correct type.</source>
          <target state="translated">引数は &lt;code&gt;Foo&lt;/code&gt; オブジェクトではなく、 &lt;code&gt;int&lt;/code&gt; です。 ただし、 &lt;code&gt;int&lt;/code&gt; を取る &lt;code&gt;Foo&lt;/code&gt; のコンストラクターが存在するため、このコンストラクターを使用してパラメーターを正しい型に変換できます。</target>
        </trans-unit>
        <trans-unit id="3049d136f55a475626db3dad948b02469e9778f9" translate="yes" xml:space="preserve">
          <source>The character &lt;code&gt;'x'&lt;/code&gt; will be implicitly converted to &lt;code&gt;int&lt;/code&gt; and then the &lt;code&gt;String(int)&lt;/code&gt; constructor will be called. But, this is not what the user might have intended. So, to prevent such conditions, we shall define the constructor as &lt;code&gt;explicit&lt;/code&gt;:</source>
          <target state="translated">文字 &lt;code&gt;'x'&lt;/code&gt; は暗黙的に &lt;code&gt;int&lt;/code&gt; に変換され、次に &lt;code&gt;String(int)&lt;/code&gt; コンストラクターが呼び出されます。 しかし、これはユーザーが意図したものではありません。 したがって、このような状態を防ぐために、コンストラクタを &lt;code&gt;explicit&lt;/code&gt; 定義します。</target>
        </trans-unit>
        <trans-unit id="2067a14f8d7ec35e3e14dc1571c9ef15e462e679" translate="yes" xml:space="preserve">
          <source>The compiler does not know wether to use the constructor of &lt;code&gt;U&lt;/code&gt; or the conversion function to convert the &lt;code&gt;V&lt;/code&gt; object into a type for passing to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">コンパイラーは、 &lt;code&gt;U&lt;/code&gt; のコンストラクターまたは変換関数を使用して &lt;code&gt;V&lt;/code&gt; オブジェクトを &lt;code&gt;f&lt;/code&gt; に渡すための型に変換するかどうかを知りません。</target>
        </trans-unit>
        <trans-unit id="dd2c9fb6422b9a6c94f550ada7376764badd6b9a" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to do this once for each parameter.</source>
          <target state="translated">コンパイラはパラメータごとに一度だけこの処理を行うことができます。</target>
        </trans-unit>
        <trans-unit id="c61dcda5620fa9ba492d6ebe7eca3691f7dedb65" translate="yes" xml:space="preserve">
          <source>The compiler is allowed to make one implicit conversion to resolve the parameters to a function. What this means is that the compiler can use constructors callable with a &lt;strong&gt;single parameter&lt;/strong&gt; to convert from one type to another in order to get the right type for a parameter.</source>
          <target state="translated">コンパイラーは、パラメーターを関数に解決するために1つの暗黙的な変換を行うことができます。 つまり、コンパイラーは、パラメーターの正しい型を取得するために、 &lt;strong&gt;単一のパラメーターで&lt;/strong&gt;呼び出し可能なコンストラクターを使用して、ある型から別の型に変換できます。</target>
        </trans-unit>
        <trans-unit id="c506586127aafb4571605139fe82715ddb3cb0e6" translate="yes" xml:space="preserve">
          <source>The explicit function specifier controls unwanted implicit type
  conversions. It can only be used in declarations of constructors
  within a class declaration. For example, except for the default
  constructor, the constructors in the following class are conversion
  constructors.</source>
          <target state="translated">明示関数指定子は、不要な暗黙の型変換を制御します。これは,クラス宣言内のコンストラクタの宣言でのみ使用することができます。例えば、デフォルトのコンストラクタを除いて、次のクラスのコンストラクタは変換コンストラクタです。</target>
        </trans-unit>
        <trans-unit id="aaaed950d829699c6b369f21001642be0a85ccc4" translate="yes" xml:space="preserve">
          <source>The explicit specifier specifies that a constructor or conversion function (since C++11) doesn't allow implicit conversions or copy-initialization.</source>
          <target state="translated">明示的指定子は、コンストラクタまたは変換関数(C++11 以降)が暗黙の変換やコピー初期化を許可しないことを指定します。</target>
        </trans-unit>
        <trans-unit id="9e22fa09c228ce6e248691a575f81838d40d2ea5" translate="yes" xml:space="preserve">
          <source>The first declaration is equivalent to &lt;code&gt;A c = A( 1 );&lt;/code&gt;.</source>
          <target state="translated">最初の宣言は、 &lt;code&gt;A c = A( 1 );&lt;/code&gt; と同等です。 。</target>
        </trans-unit>
        <trans-unit id="80f1e63e6386d4a9d89289f1bf6b566c60d0ab41" translate="yes" xml:space="preserve">
          <source>The following declarations are legal:</source>
          <target state="translated">以下の宣言は合法です。</target>
        </trans-unit>
        <trans-unit id="1169f772595bc8ae74d724d600a7a87c62ff125b" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;explicit&lt;/code&gt; accompanies either</source>
          <target state="translated">キーワード &lt;code&gt;explicit&lt;/code&gt; はどちらかを伴います</target>
        </trans-unit>
        <trans-unit id="9c61164f85ca5b809d267efbbbea8840b12030f5" translate="yes" xml:space="preserve">
          <source>The reason you might want to do this is to avoid accidental construction that can hide bugs.  Contrived example:</source>
          <target state="translated">なぜそうしたいのかというと、バグを隠してしまうような偶発的な施工を避けるためです。対照的な例。</target>
        </trans-unit>
        <trans-unit id="b4ba231f0faf7a6a4e919e6912719f1780af4a1e" translate="yes" xml:space="preserve">
          <source>This answer is about object creation with/without an explicit constructor since it is not covered in the other answers.</source>
          <target state="translated">この回答は、他の回答ではカバーされていないので、明示的なコンストラクタを使用せずにオブジェクトを作成することについての回答です。</target>
        </trans-unit>
        <trans-unit id="78c2215507e93f78a74406cf7cb8018f79940750" translate="yes" xml:space="preserve">
          <source>This has already been discussed (&lt;a href=&quot;https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319&quot;&gt;what is explicit constructor&lt;/a&gt;). But I must say, that it lacks the detailed descriptions found here.</source>
          <target state="translated">これはすでに説明されています（ &lt;a href=&quot;https://stackoverflow.com/questions/1336297/what-is-explicit-constructor/1336319#1336319&quot;&gt;明示的なコンストラクタとは&lt;/a&gt; ）。 しかし、私は、ここにある詳細な説明が不足していることを言わなければなりません。</target>
        </trans-unit>
        <trans-unit id="77c49e3ca9f1370e49c1a2a3fdbf65a3dc598015" translate="yes" xml:space="preserve">
          <source>Using the explicit keyword in a class interface enforces the user of the interface to be explicit about a desired conversion.</source>
          <target state="translated">クラスインタフェースで明示的なキーワードを使用すると,インタフェースのユーザが希望する変換について明示的であることを強制します。</target>
        </trans-unit>
        <trans-unit id="e281673a57e5bea475598290ff974afa1741081a" translate="yes" xml:space="preserve">
          <source>What does the &lt;code&gt;explicit&lt;/code&gt; keyword mean in C++?</source>
          <target state="translated">C ++での &lt;code&gt;explicit&lt;/code&gt; キーワードの意味は何ですか？</target>
        </trans-unit>
        <trans-unit id="ed5d4b7337e6a32f69ef31abb6b7b842c48d6f29" translate="yes" xml:space="preserve">
          <source>What does the explicit keyword mean</source>
          <target state="translated">明示的なキーワードの意味</target>
        </trans-unit>
        <trans-unit id="5edb7164eb8327c49e3246ab6a67c8cc6391b808" translate="yes" xml:space="preserve">
          <source>What would one expect from such a call? One line containing &lt;code&gt;3&lt;/code&gt; or three lines containing &lt;code&gt;0&lt;/code&gt;? (Where the second one is what happens.)</source>
          <target state="translated">そのような電話から何を期待できますか？ &lt;code&gt;0&lt;/code&gt; を含む3行または3行を含む1行？ （2つ目は何が起こるかです。）</target>
        </trans-unit>
        <trans-unit id="35b2cad2dc0f1377d98ff2f0f160c44250275905" translate="yes" xml:space="preserve">
          <source>Why use &lt;code&gt;explicit&lt;/code&gt; conversion functions or constructors?</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; 変換関数またはコンストラクターを使用する理由</target>
        </trans-unit>
        <trans-unit id="c22c511044cbc64591d114b9cd769d00a98cfe0f" translate="yes" xml:space="preserve">
          <source>You can only assign values that match the values of the class type.</source>
          <target state="translated">クラスタイプの値と一致する値のみを割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="e087e20de6eff6911f7c8fa41bb5e3f6bb2cb100" translate="yes" xml:space="preserve">
          <source>You have a &lt;code&gt;MyString(int size)&lt;/code&gt; class with a constructor that constructs a string of the given size.  You have a function &lt;code&gt;print(const MyString&amp;amp;)&lt;/code&gt;, and you call &lt;code&gt;print(3)&lt;/code&gt; (when you &lt;em&gt;actually&lt;/em&gt; intended to call &lt;code&gt;print(&quot;3&quot;)&lt;/code&gt;).  You expect it to print &quot;3&quot;, but it prints an empty string of length 3 instead.</source>
          <target state="translated">指定されたサイズの文字列を構築するコンストラクターを持つ &lt;code&gt;MyString(int size)&lt;/code&gt; クラスがあります。 関数 &lt;code&gt;print(const MyString&amp;amp;)&lt;/code&gt; があり 、 &lt;code&gt;print(3)&lt;/code&gt; を呼び出し &lt;code&gt;print(&quot;3&quot;)&lt;/code&gt; &lt;em&gt;実際に&lt;/em&gt; print（ &quot;3&quot;）を呼び出すつもりだった場合）。 「3」を出力するはずですが、代わりに長さ3の空の文字列を出力します。</target>
        </trans-unit>
        <trans-unit id="3c93f07a155ea96a0b57d63ea157ae1ba6c82880" translate="yes" xml:space="preserve">
          <source>and here's where the &lt;code&gt;DoBar&lt;/code&gt; function is called.</source>
          <target state="translated">ここで、 &lt;code&gt;DoBar&lt;/code&gt; 関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="80e76fd5e13a34f76dc82f7374cbbedf25d22621" translate="yes" xml:space="preserve">
          <source>becomes a compile-time error.  If you want to pass a temporary &lt;code&gt;Buffer&lt;/code&gt; object, you have to do so explicitly:</source>
          <target state="translated">コンパイル時エラーになります。 一時的な &lt;code&gt;Buffer&lt;/code&gt; オブジェクトを渡したい場合は、明示的に渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="d0bc31847e397dc9ce6f32057f43c91554466982" translate="yes" xml:space="preserve">
          <source>can both be used as single-argument constructors. So you may want to make these also &lt;code&gt;explicit&lt;/code&gt;.</source>
          <target state="translated">どちらも単一引数のコンストラクタとして使用できます。 したがって、これらを &lt;code&gt;explicit&lt;/code&gt; にすることもできます。</target>
        </trans-unit>
        <trans-unit id="1112e4645e1c510e383ffdb6d150959b4f130d21" translate="yes" xml:space="preserve">
          <source>convert pointers of objects to base class and to void*;</source>
          <target state="translated">オブジェクトのポインタを基底クラスとvoid*に変換します。</target>
        </trans-unit>
        <trans-unit id="19f768b20de266f72b8bd3b42fe489a61513ccf9" translate="yes" xml:space="preserve">
          <source>default arguments for all parameters, or</source>
          <target state="translated">すべてのパラメータのデフォルト引数、または</target>
        </trans-unit>
        <trans-unit id="fc3ae7b739a0d4b0a8161d16c99bc4a63b0ccc76" translate="yes" xml:space="preserve">
          <source>default arguments for the second parameter onwards</source>
          <target state="translated">2番目のパラメータ以降のデフォルト引数</target>
        </trans-unit>
        <trans-unit id="d9f4df0fccc3324ca442bc5a16211b9f8e047d00" translate="yes" xml:space="preserve">
          <source>standart conversions (int to double);</source>
          <target state="translated">スタンドアート変換(intからdoubleへの変換)。</target>
        </trans-unit>
        <trans-unit id="492f05458909b4e400b0f5f301b1c1261874ae73" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;explicit&lt;/code&gt;-keyword in front of the constructor &lt;code&gt;C(void)&lt;/code&gt; tells the compiler that only explicit call to this constructor is allowed.</source>
          <target state="translated">コンストラクター &lt;code&gt;C(void)&lt;/code&gt; の前の &lt;code&gt;explicit&lt;/code&gt; -keywordは、このコンストラクターへの明示的な呼び出しのみが許可されることをコンパイラーに通知します。</target>
        </trans-unit>
        <trans-unit id="ba087709da18b56c1d734fe563e840114679f1d9" translate="yes" xml:space="preserve">
          <source>up integral ranks (char to int, float to double);</source>
          <target state="translated">積分ランクを上げます(charからint、floatからdouble)。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
