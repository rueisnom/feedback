<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1207406">
    <body>
      <group id="1207406">
        <trans-unit id="3b2c92f73dff63b7b88c756e8c6c4ea763db1c81" translate="yes" xml:space="preserve">
          <source>1) When using remove(), you attempt to remove integers whereas you need to remove a tuple.</source>
          <target state="translated">1)当使用 remove()时,你试图删除整数,而你需要删除元组。</target>
        </trans-unit>
        <trans-unit id="c26bec6ae55dfa38b757d819eb9fa58107cda58b" translate="yes" xml:space="preserve">
          <source>2) The for loop will skip items in your list.</source>
          <target state="translated">2)for循环会跳过你的列表中的项目。</target>
        </trans-unit>
        <trans-unit id="41f1f874fa2b979825cd5672d52c9f672bb63674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Filter&lt;/code&gt; receives a function and a sequence. &lt;code&gt;Filter&lt;/code&gt; applies the passed function to each element in turn, and then decides whether to retain or discard the element depending on whether the function return value is &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filter&lt;/code&gt; 接收一个函数和一个序列。 &lt;code&gt;Filter&lt;/code&gt; 依次将传递的函数应用于每个元素，然后根据函数返回值是 &lt;code&gt;True&lt;/code&gt; 还是 &lt;code&gt;False&lt;/code&gt; 决定保留还是丢弃该元素。</target>
        </trans-unit>
        <trans-unit id="1f7e48e862214b7809d0460c5e1af926208bd696" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enumerate&lt;/code&gt; gives you access to the item and the index at once. &lt;code&gt;reversed&lt;/code&gt; is so that the indices that you're going to later delete don't change on you.</source>
          <target state="translated">&lt;code&gt;enumerate&lt;/code&gt; 使您可以立即访问项目和索引。 &lt;code&gt;reversed&lt;/code&gt; 是为了使您以后要删除的索引不会改变。</target>
        </trans-unit>
        <trans-unit id="4de7ada0839383f54f19d7f396d39fb507f52e99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What I have chosen is a randomly chosen example. &lt;strong&gt;Feel free to change&lt;/strong&gt; the &lt;strong&gt;list of tuples&lt;/strong&gt; and the &lt;strong&gt;condition&lt;/strong&gt; that I have chosen.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;我选择的是一个随机选择的示例。&lt;/em&gt; &lt;em&gt;&lt;strong&gt;随意更改&lt;/strong&gt; &lt;strong&gt;元组列表&lt;/strong&gt;和我选择的&lt;strong&gt;条件&lt;/strong&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41cfd101eef50f2ce2c163096a74fa93f38da56b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best workarounds&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最佳解决方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccd82364b395036f5280ff13da623f258d9644df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution: You can also not handle iterators. Iterators are sometimes better than sequences.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;警告：您也不能处理迭代器。&lt;/strong&gt; &lt;strong&gt;迭代器有时比序列更好。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81b8bc03967964ba1eea500b2bc7787b4b23c68e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Could Python do this better?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Python可以做得更好吗？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="788e3773d2b7d304ae70795cc020d884336ac974" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1 and method 2 are faster than method 3&lt;/strong&gt;. Method2 and method3 are more efficient than method1. I &lt;strong&gt;prefer method2&lt;/strong&gt;. For the aforementioned example, &lt;code&gt;time(method1) : time(method2) : time(method3) = 1 : 1 : 1.7&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;方法1和方法2比方法3快&lt;/strong&gt; 。 方法2和方法3比方法1更有效。 我&lt;strong&gt;更喜欢method2&lt;/strong&gt; 。 对于上述示例， &lt;code&gt;time(method1) : time(method2) : time(method3) = 1 : 1 : 1.7&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6dcc3dfb40a81d59ef252bee9510d3a8af5cdc6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1.&amp;gt;&lt;/strong&gt; Use the framework that you had suggested (where one fills in a code inside a for loop). I use a small code with &lt;code&gt;del&lt;/code&gt; to delete a tuple that meets the said condition. However, this method will miss a tuple (which satisfies the said condition) if two consecutively placed tuples meet the given condition.</source>
          <target state="translated">&lt;strong&gt;方法1.&amp;gt;&lt;/strong&gt;使用您建议的框架（其中一个在for循环内填写代码）。 我使用带有 &lt;code&gt;del&lt;/code&gt; 的小代码删除满足上述条件的元组。 但是，如果两个连续放置的元组满足给定条件，则此方法将丢失一个元组（满足所述条件）。</target>
        </trans-unit>
        <trans-unit id="8a87ff388a2cd2a3b0c5940103c76fd9ebd422c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 2.&amp;gt;&lt;/strong&gt; Construct a new list which contains elements (tuples) where the given condition is not met (this is the same thing as removing elements of list where the given condition is met). Following is the code for that:</source>
          <target state="translated">&lt;strong&gt;方法2.&amp;gt;&lt;/strong&gt;构造一个新列表，其中包含不满足给定条件的元素（元组）（这与删除满足给定条件的list的元素相同）。 以下是该代码：</target>
        </trans-unit>
        <trans-unit id="63bda6e7a91b63c3a620d3c5e06adb18cc1e0fc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 3.&amp;gt;&lt;/strong&gt; Find indices where the given condition is met, and then use remove elements (tuples) corresponding to those indices. Following is the code for that.</source>
          <target state="translated">&lt;strong&gt;方法3.&amp;gt;&lt;/strong&gt;查找满足给定条件的索引，然后使用与这些索引相对应的remove元素（元组）。 以下是该代码。</target>
        </trans-unit>
        <trans-unit id="5b34cc7bf01f9d2e80a510543d0a68d2bbdb4dfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Official Python 2 tutorial 4.2. &quot;for Statements&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;官方Python 2教程4.2。&lt;/strong&gt; &lt;strong&gt;&amp;ldquo;用于声明&amp;rdquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="557cafd24827735707266d1c1085114004a6d458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 2 documentation 7.3. &quot;The for statement&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Python 2文档7.3。&lt;/strong&gt; &lt;strong&gt;&amp;ldquo; for声明&amp;rdquo;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fc8a02d37d7e4516e492ebd254cc004a1d0b7e9" translate="yes" xml:space="preserve">
          <source>Above we have used the &lt;code&gt;pop&lt;/code&gt; method on the fluid list object. Other common iterable methods are also implemented such as &lt;code&gt;del fluidL[i]&lt;/code&gt;, &lt;code&gt;.remove&lt;/code&gt;, &lt;code&gt;.insert&lt;/code&gt;, &lt;code&gt;.append&lt;/code&gt;, &lt;code&gt;.extend&lt;/code&gt;. The list can also be modified using slices (&lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;reverse&lt;/code&gt; methods are not implemented).</source>
          <target state="translated">上面我们在流体列表对象上使用了 &lt;code&gt;pop&lt;/code&gt; 方法。 还可以实现其他常见的可迭代方法，例如 &lt;code&gt;del fluidL[i]&lt;/code&gt; ， &lt;code&gt;.insert&lt;/code&gt; ， &lt;code&gt;.append&lt;/code&gt; 和 &lt;code&gt;.extend&lt;/code&gt; 。 也可以使用切片修改列表（未实现 &lt;code&gt;sort&lt;/code&gt; 和 &lt;code&gt;reverse&lt;/code&gt; 方法）。</target>
        </trans-unit>
        <trans-unit id="16670fb950d5c5fdd6c0fd65ad6b86d68d95e137" translate="yes" xml:space="preserve">
          <source>Aha! Each element of L1 is actually a tuple. So that's what we need to be passing to remove(). Tuples in python are very easy, they're simply made by enclosing values in parentheses. &quot;a, b&quot; is not a tuple, but &quot;(a, b)&quot; is a tuple. So we modify your code and run it again:</source>
          <target state="translated">啊哈,L1的每个元素实际上是一个元组。所以这就是我们需要传递给 remove()的内容。python中的tuple非常简单,它们只是通过在括号中加上值来实现。&quot;a,b &quot;不是一个元组,但&quot;(a,b)&quot;是一个元组。所以我们修改一下你的代码,再运行一次。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">举个例子:</target>
        </trans-unit>
        <trans-unit id="6289272e180651017551f0d23619c6b843207579" translate="yes" xml:space="preserve">
          <source>As I stated to start with: this is a complicated solution that will hurt the readability of your code and make it more difficult to debug. Therefore other solutions such as the list comprehensions mentioned in David Raznick's &lt;a href=&quot;https://stackoverflow.com/a/1207461/4451578&quot;&gt;answer&lt;/a&gt; should be considered first. That being said, I have found times where this class has been useful to me and has been easier to use than keeping track of the indices of elements that need deleting.</source>
          <target state="translated">就像我刚开始所说的那样：这是一个复杂的解决方案，将损害代码的可读性，并使调试更加困难。 因此，应首先考虑其他解决方案，例如David Raznick的&lt;a href=&quot;https://stackoverflow.com/a/1207461/4451578&quot;&gt;答案中&lt;/a&gt;提到的列表理解。 话虽如此，但我发现此类对我很有用，并且比跟踪需要删除的元素的索引更容易使用。</target>
        </trans-unit>
        <trans-unit id="b0de2e5d5f6712623237e9fe813e112b1056e691" translate="yes" xml:space="preserve">
          <source>As you can infer from that result, every time that the conditional statement evaluates to true and a list item is removed, the next iteration of the loop will skip evaluation of the next item in the list because its values are now located at different indices.</source>
          <target state="translated">从这个结果可以推断出,每当条件语句评价为真时,每当条件语句评价为真并删除一个列表项时,循环的下一次迭代就会跳过对列表中的下一个项的评价,因为它的值现在位于不同的索引处。</target>
        </trans-unit>
        <trans-unit id="f9468c326a4a729e70975ea2231fdda83d27f476" translate="yes" xml:space="preserve">
          <source>But what if the result of the &lt;code&gt;testFunc&lt;/code&gt; depends on the elements that have been added to &lt;code&gt;newList&lt;/code&gt; already? Or the elements still in &lt;code&gt;oldList&lt;/code&gt; that might be added next? There might still be a way to use a list comprehension but it will begin to lose it's elegance, and for me it feels easier to modify a list in place.</source>
          <target state="translated">但是，如果 &lt;code&gt;testFunc&lt;/code&gt; 的结果取决于已经添加到 &lt;code&gt;newList&lt;/code&gt; 的元素怎么办？ 还是可能 &lt;code&gt;oldList&lt;/code&gt; 添加到oldList中的元素？ 仍然可能有一种使用列表理解的方法，但是它将开始失去它的优雅性，对我来说，修改就地列表更容易。</target>
        </trans-unit>
        <trans-unit id="ab99bb95d0a8563a2528243c1af734b49825dea8" translate="yes" xml:space="preserve">
          <source>C++ &lt;a href=&quot;https://en.cppreference.com/w/cpp/container/vector/erase&quot;&gt;&lt;code&gt;std::vector::erase&lt;/code&gt;&lt;/a&gt; which returns a valid interator to the element after the one removed</source>
          <target state="translated">C ++ &lt;a href=&quot;https://en.cppreference.com/w/cpp/container/vector/erase&quot;&gt; &lt;code&gt;std::vector::erase&lt;/code&gt; &lt;/a&gt;在删除元素后将有效插入器返回到元素</target>
        </trans-unit>
        <trans-unit id="70de89a9d1057697c722db9334aea9338d7d9424" translate="yes" xml:space="preserve">
          <source>Copying the list using &lt;code&gt;remove&lt;/code&gt; might make your code look a little cleaner, as described in one of the answers below.  You should definitely not do this for extremely large lists, since this involves first copying the entire list, and also performing an &lt;code&gt;O(n)&lt;/code&gt;&lt;code&gt;remove&lt;/code&gt; operation for each element being removed, making this an &lt;code&gt;O(n^2)&lt;/code&gt; algorithm.</source>
          <target state="translated">使用 &lt;code&gt;remove&lt;/code&gt; 复制列表可能会使您的代码看起来更简洁，如以下答案之一所述。 您绝对不应该对非常大的列表执行此操作，因为这涉及到首先复制整个列表，然后对要删除的每个元素执行 &lt;code&gt;O(n)&lt;/code&gt; &lt;code&gt;remove&lt;/code&gt; 操作，从而使其成为 &lt;code&gt;O(n^2)&lt;/code&gt; 算法。</target>
        </trans-unit>
        <trans-unit id="cf79941ef09fc206b51225e5da9c16355e55b212" translate="yes" xml:space="preserve">
          <source>Download &lt;code&gt;fluidIter.py&lt;/code&gt; from &lt;a href=&quot;https://github.com/alanbacon/FluidIterator&quot;&gt;here&lt;/a&gt;&lt;code&gt;https://github.com/alanbacon/FluidIterator&lt;/code&gt;, it is just a single file so no need to install git. There is no installer so you will need to make sure that the file is in the python path your self. The code has been written for python 3 and is untested on python 2.</source>
          <target state="translated">从&lt;a href=&quot;https://github.com/alanbacon/FluidIterator&quot;&gt;这里&lt;/a&gt; &lt;code&gt;https://github.com/alanbacon/FluidIterator&lt;/code&gt; 下载 &lt;code&gt;fluidIter.py&lt;/code&gt; ，它只是一个文件，因此无需安装git。 没有安装程序，因此您需要确保该文件位于您自己的python路径中。 该代码是为python 3编写的，未经python 2的测试。</target>
        </trans-unit>
        <trans-unit id="1a2545867f0ca9597a7db53881bd6afe7c73dffe" translate="yes" xml:space="preserve">
          <source>Edit: As mentioned in the comments, this answer does not really present a problem for which this approach provides a solution. I will try to address that here:</source>
          <target state="translated">编辑:正如评论中提到的那样,这个答案并没有提出一个真正的问题,而这个方法提供了一个解决方案。我将在此尝试解决这个问题。</target>
        </trans-unit>
        <trans-unit id="a788b2421c51b170010ec2c266d516cb0be3f175" translate="yes" xml:space="preserve">
          <source>Edit: The last code example in this answer gives a use case for &lt;strong&gt;&lt;em&gt;why&lt;/em&gt;&lt;/strong&gt; you might sometimes want to modify a list in place rather than use a list comprehension. The first part of the answers serves as tutorial of &lt;strong&gt;&lt;em&gt;how&lt;/em&gt;&lt;/strong&gt; an array can be modified in place.</source>
          <target state="translated">编辑：此答案中的最后一个代码示例给出了一个用例， &lt;strong&gt;&lt;em&gt;说明了为什么&lt;/em&gt;&lt;/strong&gt;有时您可能想在适当位置修改列表而不是使用列表理解。 答案的第一部分用作&lt;strong&gt;&lt;em&gt;如何&lt;/em&gt;&lt;/strong&gt;在适当位置修改数组的教程。</target>
        </trans-unit>
        <trans-unit id="c8078d924b19f64b223a6df8142a489104063237" translate="yes" xml:space="preserve">
          <source>Either:</source>
          <target state="translated">Either:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2e016639bfdc35ff47021bee07e0442c9bf6e95a" translate="yes" xml:space="preserve">
          <source>Finally, there is one cleaner solution than having to make an entirely new copy of L1. The reversed() function:</source>
          <target state="translated">最后,还有一个更干净的解决方案,那就是对L1进行全新的复制。reversed()函数。</target>
        </trans-unit>
        <trans-unit id="c44ea041349ed36728514202e8abfa264d478d68" translate="yes" xml:space="preserve">
          <source>First of all you'll need to &lt;strong&gt;replace foreach loop with while loop&lt;/strong&gt;,</source>
          <target state="translated">首先，您需要将&lt;strong&gt;while循环替换为foreach循环&lt;/strong&gt; ，</target>
        </trans-unit>
        <trans-unit id="a4bbfc8e8879463ee80d588ea8bff37fe8625e66" translate="yes" xml:space="preserve">
          <source>For anything that has the potential to be really big, I use the following.</source>
          <target state="translated">对于任何有潜力的事情,我都会用下面的方法来做。</target>
        </trans-unit>
        <trans-unit id="c9d41ff6b00990841a094958bdca36f5ecbef710" translate="yes" xml:space="preserve">
          <source>For example (depends on what type of list):</source>
          <target state="translated">例如(看是什么类型的清单)。</target>
        </trans-unit>
        <trans-unit id="d3826d07dc82c819a2952d0b19069cf2dcd53dc5" translate="yes" xml:space="preserve">
          <source>For more details &lt;a href=&quot;http://docs.python.org/library/functions.html#filter&quot;&gt;check here&lt;/a&gt;</source>
          <target state="translated">欲了解更多详情， &lt;a href=&quot;http://docs.python.org/library/functions.html#filter&quot;&gt;请点击这里&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0682dfde6b8575edaa27bd1c03020cbce20014a8" translate="yes" xml:space="preserve">
          <source>For those that like functional programming:</source>
          <target state="translated">对于那些喜欢函数式编程的人来说。</target>
        </trans-unit>
        <trans-unit id="a74dc39ba82bf47d723236da822a90c8ff7a3ec2" translate="yes" xml:space="preserve">
          <source>Fortunately, it's extremely easy to get both the speed of list comprehensions AND the required semantics of in-place alteration -- just code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36edd270beeffac5974b87eb6c988c0cf556914" translate="yes" xml:space="preserve">
          <source>Full answer:</source>
          <target state="translated">全部答案:</target>
        </trans-unit>
        <trans-unit id="56e8e2cad0c7d16346946903b1f1df0e011a6ba1" translate="yes" xml:space="preserve">
          <source>Generally you just want to go for the faster &lt;code&gt;.append()&lt;/code&gt; option by default unless memory is a big concern.</source>
          <target state="translated">通常，除非内存是一个大问题，否则默认情况下，您只想默认使用更快的 &lt;code&gt;.append()&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="88f8f55fdd9b1ef963f6e91ea73765a38063d284" translate="yes" xml:space="preserve">
          <source>Here is an example where copying the list beforehand is incorrect, reverse iteration is impossible and a list comprehension is also not an option.</source>
          <target state="translated">这里有一个例子,事先复制列表是不正确的,逆向迭代是不可能的,列表理解也是不可能的。</target>
        </trans-unit>
        <trans-unit id="015e2b33e48d8c457bdeefa7777500d6753f17a6" translate="yes" xml:space="preserve">
          <source>How to remove items from a list while iterating</source>
          <target state="translated">如何在迭代时从列表中删除项目?</target>
        </trans-unit>
        <trans-unit id="c77620b856d20a8819f9b0b470a56a1277c2fb40" translate="yes" xml:space="preserve">
          <source>However, I disagree with this implementation, since &lt;code&gt;.remove()&lt;/code&gt; has to iterate the &lt;em&gt;entire list&lt;/em&gt; to find the value.</source>
          <target state="translated">但是，我不同意此实现，因为 &lt;code&gt;.remove()&lt;/code&gt; 必须迭代&lt;em&gt;整个列表&lt;/em&gt;以查找值。</target>
        </trans-unit>
        <trans-unit id="69b67973d6a8e6ef36e2888307c19b186e7df019" translate="yes" xml:space="preserve">
          <source>However, the output will be identical to before:</source>
          <target state="translated">但是,输出会和以前一样。</target>
        </trans-unit>
        <trans-unit id="3f4aacab5e7adbd49358dc9debb14a93fa23eb41" translate="yes" xml:space="preserve">
          <source>I can think of three approaches to solve your problem. As an example, I will create a random list of tuples &lt;code&gt;somelist = [(1,2,3), (4,5,6), (3,6,6), (7,8,9), (15,0,0), (10,11,12)]&lt;/code&gt;. The condition that I choose is &lt;code&gt;sum of elements of a tuple = 15&lt;/code&gt;. In the final list we will only have those tuples whose sum is not equal to 15.</source>
          <target state="translated">我可以想到三种解决问题的方法。 例如，我将创建一个元组的随机列表 &lt;code&gt;somelist = [(1,2,3), (4,5,6), (3,6,6), (7,8,9), (15,0,0), (10,11,12)]&lt;/code&gt; 。 我选择的条件是 &lt;code&gt;sum of elements of a tuple = 15&lt;/code&gt; 。 在最终列表中，我们将只有那些总和不等于15的元组。</target>
        </trans-unit>
        <trans-unit id="a368dea51582938f2ab67c94c9f3b922d05e401f" translate="yes" xml:space="preserve">
          <source>I needed to do something similar and in my case the problem was memory - I needed to merge multiple dataset objects within a list, after doing some stuff with them, as a new object, and needed to get rid of each entry I was merging to avoid duplicating all of them and blowing up memory. In my case having the objects in a dictionary instead of a list worked fine:</source>
          <target state="translated">我需要做一些类似的事情,在我的情况下,问题是内存问题--我需要在一个列表中合并多个数据集对象,在对它们做了一些事情后,作为一个新的对象,并需要删除我正在合并的每个条目,以避免重复使用所有的条目,并占用内存。在我的情况下,将对象放在字典中而不是列表中,效果很好。</target>
        </trans-unit>
        <trans-unit id="cd970f7da56e80281558904a4e1d263b5a3fa2d2" translate="yes" xml:space="preserve">
          <source>I needed to do this with a huge list, and duplicating the list seemed expensive, especially since in my case the number of deletions would be few compared to the items that remain. I took this low-level approach.</source>
          <target state="translated">我需要用一个庞大的列表来做这件事,而复制这个列表似乎很昂贵,尤其是在我的情况下,删除的数量会比留下的项目少。我采用了这种低级的方法。</target>
        </trans-unit>
        <trans-unit id="61eac64b85c8bcbd86114f439152c5f3727dc586" translate="yes" xml:space="preserve">
          <source>I wrote a library that allows you to do this:</source>
          <target state="translated">我写了一个图书馆,可以让你做这个。</target>
        </trans-unit>
        <trans-unit id="93e8f9e56c8391ff4d8114fdd92027090dcb5149" translate="yes" xml:space="preserve">
          <source>I'm iterating over a list of tuples in Python, and am attempting to remove them if they meet certain criteria.</source>
          <target state="translated">我正在用Python迭代一个图元组列表,如果它们满足一定的条件,我试图将其删除。</target>
        </trans-unit>
        <trans-unit id="40067d779a3f3245e65a2ab2e94f2fec69eb4c56" translate="yes" xml:space="preserve">
          <source>If we want to access the current index value of the list we cannot use enumerate, as this only counts how many times the for loop has run. Instead we will use the iterator object directly.</source>
          <target state="translated">如果我们想访问列表的当前索引值,我们不能使用枚举,因为这只能计算for循环运行了多少次。相反,我们将直接使用迭代器对象。</target>
        </trans-unit>
        <trans-unit id="7baf994253e5422333a06fc8988fe24496aaf2a2" translate="yes" xml:space="preserve">
          <source>If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy. The slice notation makes this especially convenient:</source>
          <target state="translated">如果你在循环中需要修改你正在迭代的序列(例如,复制所选项目),建议你先进行复制。迭代一个序列并不隐含复制。片段符号使这一点特别方便。</target>
        </trans-unit>
        <trans-unit id="d87b562086fac008b600e2b8d4a9b5150a639c97" translate="yes" xml:space="preserve">
          <source>If you want to delete elements from a list while iterating, use a while-loop so you can alter the current index and end index after each deletion.</source>
          <target state="translated">如果你想在迭代时从列表中删除元素,可以使用while-loop,这样每次删除后可以改变当前索引和结束索引。</target>
        </trans-unit>
        <trans-unit id="da17f6befdc523de38569c671e0632dd8feef1a1" translate="yes" xml:space="preserve">
          <source>If you want to do anything else during the iteration, it may be nice to get both the index (which guarantees you being able to reference it, for example if you have a list of dicts) and the actual list item contents.</source>
          <target state="translated">如果你想在迭代过程中做其他事情,可能既能得到索引(保证你能够引用它,比如说如果你有一个dicts列表),又能得到实际的列表项内容,这可能会很好。</target>
        </trans-unit>
        <trans-unit id="a9b71d2114bfedf22c95c100902b07fb9eda5c92" translate="yes" xml:space="preserve">
          <source>If you will use the new list later, you can simply set the elem to None, and then judge it in the later loop, like this</source>
          <target state="translated">如果你以后要使用新的列表,你可以简单地将elem设置为None,然后在后面的循环中判断它,就像这样</target>
        </trans-unit>
        <trans-unit id="cff757980d44c8978d107712bbd9c8346debf46a" translate="yes" xml:space="preserve">
          <source>In cases where you're doing something more complex than calling a &lt;code&gt;determine&lt;/code&gt; function, I prefer constructing a new list and simply appending to it as I go.  For example</source>
          <target state="translated">如果您要做的事情比调用 &lt;code&gt;determine&lt;/code&gt; 函数还要复杂，我更喜欢构造一个新列表，然后随便添加它。 例如</target>
        </trans-unit>
        <trans-unit id="245dc2132cc9d15cb2653900c35e1e34efd80517" translate="yes" xml:space="preserve">
          <source>In some situations, where you're doing more than simply filtering a list one item at time, you want your iteration to change while iterating.</source>
          <target state="translated">在某些情况下,如果你要做的不仅仅是简单地逐一筛选一个列表,你希望你的迭代在迭代的同时改变。</target>
        </trans-unit>
        <trans-unit id="25a3509e025bfbab60c4594a7314dfe96eee8d5a" translate="yes" xml:space="preserve">
          <source>In this way, you dont't need copy the list and it's easier to understand.</source>
          <target state="translated">这样一来,你不需要复制列表,也更容易理解。</target>
        </trans-unit>
        <trans-unit id="125406bb8e98603cdb6cb34508b6a4174012d403" translate="yes" xml:space="preserve">
          <source>Instead of a comprehension, you could also use &lt;code&gt;itertools&lt;/code&gt;. In Python 2:</source>
          <target state="translated">除了理解之外，您还可以使用 &lt;code&gt;itertools&lt;/code&gt; 。 在Python 2中：</target>
        </trans-unit>
        <trans-unit id="f56af88d3f92e6edf9b095e4969fca472d8ed69b" translate="yes" xml:space="preserve">
          <source>It might be smart to also just create a new list if the current list item meets the desired criteria.</source>
          <target state="translated">如果当前列表项目符合所需的标准,也可以直接创建一个新的列表。</target>
        </trans-unit>
        <trans-unit id="55998da221cafd68f95026750947ab3d3b827cb2" translate="yes" xml:space="preserve">
          <source>It seems like this particular Python API could be improved. Compare it, for instance, with:</source>
          <target state="translated">看起来这个特殊的Python API似乎还可以改进。例如,将其与。</target>
        </trans-unit>
        <trans-unit id="046f43ead4620ec5bc9285795e2a5ebcbbd51ae9" translate="yes" xml:space="preserve">
          <source>It's best to use another method if possible that doesn't require modifying your iterable while iterating over it, but for some algorithms it might not be that straight forward. And so if you are sure that you really do want the code pattern described in the original question, it is possible.</source>
          <target state="translated">如果可能的话,最好使用其他的方法,在迭代的同时不需要修改你的迭代,但对于某些算法来说,可能不是那么直接。所以,如果你确定你真的要的是原问题中描述的代码模式,那是可以的。</target>
        </trans-unit>
        <trans-unit id="f87de0493fb3d04591d84b9514a64a8b1b2433ae" translate="yes" xml:space="preserve">
          <source>Java &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html&quot;&gt;ListIterator::remove&lt;/a&gt; which documents &quot;This call can only be made once per call to next or previous&quot;</source>
          <target state="translated">Java &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html&quot;&gt;ListIterator :: remove&lt;/a&gt;哪些文档&amp;ldquo;此调用只能对下一个或上一个调用进行一次&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="b8f5fc225cfb3362fa3e16aaa8090b08eeb8d9d7" translate="yes" xml:space="preserve">
          <source>Let's run through what happens when we execute your code:</source>
          <target state="translated">让我们运行一下当我们执行你的代码时会发生什么。</target>
        </trans-unit>
        <trans-unit id="f8a9a21683177e7cde4a5592c377a6e74a389d1e" translate="yes" xml:space="preserve">
          <source>List comprehensions provide a way to generate a new list but these approaches tend to look at each element in isolation rather than the current state of the list as a whole.</source>
          <target state="translated">列表理解提供了一种生成新的列表的方法,但这些方法往往是孤立地看待每一个元素,而不是将列表的当前状态作为一个整体来看待。</target>
        </trans-unit>
        <trans-unit id="d2e359d0150a691e0d84043306b8fdd090ce18d0" translate="yes" xml:space="preserve">
          <source>More examples / tests can be found in the &lt;code&gt;if __name__ is &quot;__main__&quot;:&lt;/code&gt; section at the bottom of &lt;code&gt;fluidIter.py&lt;/code&gt;. These are worth looking at because they explain what happens in various situations. Such as: Replacing a large sections of the list using a slice. Or using (and modifying) the same iterable in nested for loops.</source>
          <target state="translated">&lt;code&gt;if __name__ is &quot;__main__&quot;:&lt;/code&gt; &lt;code&gt;fluidIter.py&lt;/code&gt; 在FluidIter.py底部的更多示例/测试中可以找到。 这些值得一看，因为它们解释了在各种情况下会发生什么。 例如：使用切片替换列表的大部分。 或在嵌套for循环中使用（并修改）相同的可迭代对象。</target>
        </trans-unit>
        <trans-unit id="da2749c0165cf2060c3dbe8c050ade5cfc962757" translate="yes" xml:space="preserve">
          <source>Most of the answers here want you to create a copy of the list. I had a use case where the list was quite long (110K items) and it was smarter to keep reducing the list instead.</source>
          <target state="translated">这里的大多数答案都是希望你创建一个列表的副本。我曾有过一个使用案例,在这个案例中,列表相当长(110K项目),而继续减少列表是比较明智的做法。</target>
        </trans-unit>
        <trans-unit id="c80f5de1207f487c252821cc6bb7b9fc8eccb956" translate="yes" xml:space="preserve">
          <source>Note the subtle difference with other answers: this one is NOT assigning to a barename - it's assigning to a list slice that just happens to be the entire list, thereby replacing the list &lt;em&gt;contents&lt;/em&gt;&lt;strong&gt;within the same Python list object&lt;/strong&gt;, rather than just reseating one reference (from previous list object to new list object) like the other answers.</source>
          <target state="translated">请注意与其他答案的细微差别：这不是分配给裸名-而是分配给恰好是整个列表的列表切片，从而替换&lt;strong&gt;同一Python列表对象中&lt;/strong&gt;的列表&lt;em&gt;内容&lt;/em&gt; ，而不仅仅是重新&lt;strong&gt;放置&lt;/strong&gt;一个引用（从先前的列表对象到新的列表对象），就像其他答案一样。</target>
        </trans-unit>
        <trans-unit id="b2ac388e56496c2c3c957f43d877dd1d7fda2c8a" translate="yes" xml:space="preserve">
          <source>Note: There is a subtlety when the sequence is being modified by the loop (this can only occur for mutable sequences, i.e. lists). An internal counter is used to keep track of which item is used next, and this is incremented on each iteration. When this counter has reached the length of the sequence the loop terminates. This means that if the suite deletes the current (or a previous) item from the sequence, the next item will be skipped (since it gets the index of the current item which has already been treated). Likewise, if the suite inserts an item in the sequence before the current item, the current item will be treated again the next time through the loop. This can lead to nasty bugs that can be avoided by making a temporary copy using a slice of the whole sequence, e.g.,</source>
          <target state="translated">注意:当序列被循环修改时,有一个微妙的变化(这只能发生在可变序列,即列表中)。一个内部的计数器用来跟踪下一步使用哪个项,这个计数器在每次迭代时都会递增。当这个计数器达到序列的长度时,循环就会终止。这意味着,如果套件从序列中删除了当前(或前一个)项,下一个项将被跳过(因为它得到了当前项的索引,而这个索引已经被处理过)。同样的,如果套件在序列中插入一个项在当前项之前,在下一次循环时,当前项将被再次处理。这可能会导致讨厌的BUG,可以通过使用整个序列的一个片断进行临时拷贝来避免,例如。</target>
        </trans-unit>
        <trans-unit id="17fc589ddf453f77430cdfb24061a48d22055a0b" translate="yes" xml:space="preserve">
          <source>One possible solution, useful if you want not only remove some things, but also do something with all elements in a single loop:</source>
          <target state="translated">一个可能的解决方案,如果你不仅想删除一些东西,而且还想在一个循环中对所有元素做一些事情,那么这个解决方案很有用。</target>
        </trans-unit>
        <trans-unit id="9989cc03f8130b33e38ebbe097e363902bb2ab71" translate="yes" xml:space="preserve">
          <source>Or in Python 3:</source>
          <target state="translated">或者是在Python 3中。</target>
        </trans-unit>
        <trans-unit id="360486488323ae5b9c4a62711e3b574d44955347" translate="yes" xml:space="preserve">
          <source>Or, by assigning to the slice &lt;code&gt;somelist[:]&lt;/code&gt;, you can mutate the existing list to contain only the items you want:</source>
          <target state="translated">或者，通过将切片分配给 &lt;code&gt;somelist[:]&lt;/code&gt; ，您可以将现有列表突变为仅包含所需的项目：</target>
        </trans-unit>
        <trans-unit id="79e5e39f10693e0d3d7f9bbd6e8a79ae8f411a56" translate="yes" xml:space="preserve">
          <source>Perhaps the underlying rationale is that Python lists are assumed to be dynamic array backed, and therefore any type of removal will be time inefficient anyways, while Java has a nicer interface hierarchy with both &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;ListIterator&lt;/code&gt;.</source>
          <target state="translated">可能的基本原理是，假定Python列表是由动态数组支持的，因此任何类型的删除都将在时间上效率低下，而Java具有更好的接口层次结构，同时具有ListIterator的&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="0ea5407d1e5d315fb9f7357791702e7406ce3cfa" translate="yes" xml:space="preserve">
          <source>Problem is you removed a value from a list during iteration then your list index will collapse.</source>
          <target state="translated">问题是你在迭代过程中从列表中删除了一个值,那么你的列表索引就会崩溃。</target>
        </trans-unit>
        <trans-unit id="a12a2e961432337248947c29211654dd9db80cac" translate="yes" xml:space="preserve">
          <source>Python 2 users: replace &lt;code&gt;range&lt;/code&gt; by &lt;code&gt;xrange&lt;/code&gt; to avoid creating a hardcoded list</source>
          <target state="translated">Python 2用户：用 &lt;code&gt;xrange&lt;/code&gt; 替换 &lt;code&gt;range&lt;/code&gt; 以避免创建硬编码列表</target>
        </trans-unit>
        <trans-unit id="48bce7473e48f3146f9e6a87451c0a6b7a287a30" translate="yes" xml:space="preserve">
          <source>Should work on all mutable sequences not just lists.</source>
          <target state="translated">应该适用于所有可变异序列,而不仅仅是列表。</target>
        </trans-unit>
        <trans-unit id="d69dabce4725955fd5cfe5474202e42df310b5ad" translate="yes" xml:space="preserve">
          <source>TLDR:</source>
          <target state="translated">TLDR:</target>
        </trans-unit>
        <trans-unit id="152d20f48429364f6ffc8bed8d7c4ab140cd6e27" translate="yes" xml:space="preserve">
          <source>That should be significantly faster than anything else.</source>
          <target state="translated">这应该比其他任何事情都要快得多。</target>
        </trans-unit>
        <trans-unit id="270175c65f9ab178c1fec6d7dd95d939a77fd791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FluidIterable&lt;/code&gt; class just provides a wrapper for the original list object. The original object can be accessed as a property of the fluid object like so:</source>
          <target state="translated">&lt;code&gt;FluidIterable&lt;/code&gt; 类仅提供原始列表对象的包装。 可以将原始对象作为流体对象的属性进行访问，如下所示：</target>
        </trans-unit>
        <trans-unit id="3cfb5094c7c78cca9a3962e635d233764ced9056" translate="yes" xml:space="preserve">
          <source>The answers suggesting list comprehensions are ALMOST correct -- except that they build a completely new list and then give it the same name the old list as, they do NOT modify the old list in place. That's different from what you'd be doing by selective removal, as in &lt;a href=&quot;https://stackoverflow.com/a/1207427/3064538&quot;&gt;@Lennart's suggestion&lt;/a&gt; -- it's faster, but if your list is accessed via multiple references the fact that you're just reseating one of the references and NOT altering the list object itself can lead to subtle, disastrous bugs.</source>
          <target state="translated">暗示列表理解的答案几乎是正确的-除了它们会建立一个全新的列表，然后为其命名与旧列表相同外，它们不会修改旧列表。 这与&lt;a href=&quot;https://stackoverflow.com/a/1207427/3064538&quot;&gt;@Lennart的建议中&lt;/a&gt;的选择性删除操作不同-速度更快，但是如果通过多个引用访问列表，则说明您只是在重新放置其中一个引用而不更改列表对象本身可能会导致微妙的灾难性错误。</target>
        </trans-unit>
        <trans-unit id="5191c36b79d049087e12a7d61cc7919fff9ceeaf" translate="yes" xml:space="preserve">
          <source>The code below is one example of an algorithm that suffers from the above problem. The algorithm will reduce a list so that no element is a multiple of any other element.</source>
          <target state="translated">下面的代码是一个受上述问题困扰的算法的一个例子。该算法将减少一个列表,使任何元素都不是其他元素的倍数。</target>
        </trans-unit>
        <trans-unit id="1dd15e2a02b9bd225a28fb73bd761fec970d34a4" translate="yes" xml:space="preserve">
          <source>The first problem is that you are passing both 'a' and 'b' to remove(), but remove() only accepts a single argument. So how can we get remove() to work properly with your list? We need to figure out what each element of your list is. In this case, each one is a tuple. To see this, let's access one element of the list (indexing starts at 0):</source>
          <target state="translated">第一个问题是,你把'a'和'b'都传给了 remove(),但 remove()只接受一个参数。那么,我们如何让 remove()在你的列表中正常工作呢?我们需要弄清楚你的列表中的每个元素是什么。在这种情况下,每个元素都是一个tuple。为了了解这个问题,让我们访问列表中的一个元素(索引从0开始)。</target>
        </trans-unit>
        <trans-unit id="03c421e2f742eb0a3f0b40bf613c9d58c162b963" translate="yes" xml:space="preserve">
          <source>The most effective method is list comprehension, many people show their case, of course, it is also a good way to get an &lt;code&gt;iterator&lt;/code&gt; through &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">最有效的方法是列表理解，很多人都展示了他们的案例，当然，这也是通过 &lt;code&gt;filter&lt;/code&gt; 获得 &lt;code&gt;iterator&lt;/code&gt; 的好方法。</target>
        </trans-unit>
        <trans-unit id="82e722be14da8e292e19c55197fc9f40afbc622f" translate="yes" xml:space="preserve">
          <source>The most intuitive solution is to copy the list, then iterate over the original list and only modify the copy. You can try doing so like this:</source>
          <target state="translated">最直观的解决方案是复制列表,然后迭代原始列表,只修改副本。你可以尝试这样做。</target>
        </trans-unit>
        <trans-unit id="218e1c2432d3d651eb5aa8d840e5878a648c2f64" translate="yes" xml:space="preserve">
          <source>The only condition is that you must only modify the list in place, if at any point &lt;code&gt;fluidL&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt; were reassigned to a different list object the code would not work. The original &lt;code&gt;fluidL&lt;/code&gt; object would still be used by the for loop but would become out of scope for us to modify.</source>
          <target state="translated">唯一的条件是，您必须仅在适当位置修改列表，如果在任何时候将 &lt;code&gt;fluidL&lt;/code&gt; 或 &lt;code&gt;l&lt;/code&gt; 重新分配给其他列表对象，代码将无法正常工作。 最初的 &lt;code&gt;fluidL&lt;/code&gt; 对象仍将由for循环使用，但将超出我们的修改范围。</target>
        </trans-unit>
        <trans-unit id="0232391e9ed0b3f4e1884c82ce7b756054004e76" translate="yes" xml:space="preserve">
          <source>The other answers are correct that it is usually a bad idea to delete from a list that you're iterating. Reverse iterating avoids the pitfalls, but it is much more difficult to follow code that does that, so usually you're better off using a list comprehension or &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">其他答案是正确的，因为从要迭代的列表中删除通常不是一个好主意。 反向迭代避免了陷阱，但是遵循这样做的代码要困难得多，因此通常最好使用列表推导或 &lt;code&gt;filter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d83b85da1737342dd5460982dd9c13f4ec834959" translate="yes" xml:space="preserve">
          <source>The output and the final reduced list are shown below</source>
          <target state="translated">输出和最终减少的列表如下图所示</target>
        </trans-unit>
        <trans-unit id="6f7fb1a9757b6b77ad3c9a0db78e51afbee729bf" translate="yes" xml:space="preserve">
          <source>The solution follows on from &lt;a href=&quot;https://stackoverflow.com/a/6260097/4451578&quot;&gt;this&lt;/a&gt; answer (for a related question) from senderle. Which explains how the the array index is updated while iterating through a list that has been modified. The solution below is designed to correctly track the array index even if the list is modified.</source>
          <target state="translated">从senderle的&lt;a href=&quot;https://stackoverflow.com/a/6260097/4451578&quot;&gt;此&lt;/a&gt;答案（针对相关问题）可以得出解决方案。 这说明了在遍历已修改的列表时如何更新数组索引。 即使解决方案列表被修改，下面的解决方案旨在正确跟踪数组索引。</target>
        </trans-unit>
        <trans-unit id="2551885fd9f082f01224604f6182eec3c30229ae" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;i&lt;/code&gt; is not changed in the if block because you'll want to get value of the new item FROM THE SAME INDEX, once the old item is deleted.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 的值在if块中未更改，因为一旦删除了旧项，您将希望从相同索引中获取新项的值。</target>
        </trans-unit>
        <trans-unit id="f7562a2c2dc431ee3d16ebf6cd88cf92dd3094ad" translate="yes" xml:space="preserve">
          <source>There are two problems in your code:</source>
          <target state="translated">你的代码里有两个问题。</target>
        </trans-unit>
        <trans-unit id="1a99f253b2b161ab64e883f8d5fbc4dedcf4f028" translate="yes" xml:space="preserve">
          <source>There doesn't seem to be an explicit linked list type in the Python stdlib either: &lt;a href=&quot;https://stackoverflow.com/questions/280243/python-linked-list/280286&quot;&gt;Python Linked List&lt;/a&gt;</source>
          <target state="translated">Python stdlib中似乎也没有明确的链接列表类型： &lt;a href=&quot;https://stackoverflow.com/questions/280243/python-linked-list/280286&quot;&gt;Python链接列表&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e347b0acd45b91cadf43f2803affd98ff60eebb" translate="yes" xml:space="preserve">
          <source>There is an example  (get the odds in the tuple):</source>
          <target state="translated">有这样一个例子(得到的赔率在元组中)。</target>
        </trans-unit>
        <trans-unit id="55432bab27968e16616ffe608379fb64757d1359" translate="yes" xml:space="preserve">
          <source>There is, however, one case where it is safe to remove elements from a sequence that you are iterating: if you're only removing one item while you're iterating. This can be ensured using a &lt;code&gt;return&lt;/code&gt; or a &lt;code&gt;break&lt;/code&gt;. For example:</source>
          <target state="translated">但是，在一种情况下，可以安全地从要迭代的序列中删除元素：如果仅在迭代时删除一个项目。 这可以通过使用 &lt;code&gt;return&lt;/code&gt; 或 &lt;code&gt;break&lt;/code&gt; 来确保。 例如：</target>
        </trans-unit>
        <trans-unit id="1bce386bfd881c91ca88506633592e0f9e08efc1" translate="yes" xml:space="preserve">
          <source>This answer was originally written in response to a question which has since been marked as duplicate:
&lt;a href=&quot;https://stackoverflow.com/questions/40175149/removing-coordinates-from-list-on-python&quot;&gt;Removing coordinates from list on python&lt;/a&gt;</source>
          <target state="translated">此答案最初是为回答一个问题而编写的，此问题已被标记为重复： &lt;a href=&quot;https://stackoverflow.com/questions/40175149/removing-coordinates-from-list-on-python&quot;&gt;从python列表中删除坐标&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e7f8dab783005add34279bd95b8e79966d3770f" translate="yes" xml:space="preserve">
          <source>This approach could be useful if there are other references to &lt;code&gt;somelist&lt;/code&gt; that need to reflect the changes.</source>
          <target state="translated">如果还有其他引用要反映更改的 &lt;code&gt;somelist&lt;/code&gt; ，则此方法可能很有用。</target>
        </trans-unit>
        <trans-unit id="d30f448b4b0f64b3cc1bd7c5a8e371250849c4a4" translate="yes" xml:space="preserve">
          <source>This code runs without any error, but let's look at the list it outputs:</source>
          <target state="translated">这段代码运行时没有任何错误,但我们来看看它输出的列表。</target>
        </trans-unit>
        <trans-unit id="e6775b34984f46006cc69465d54fe83b78053739" translate="yes" xml:space="preserve">
          <source>This is because when we created L2, python did not actually create a new object. Instead, it merely referenced L2 to the same object as L1. We can verify this with 'is' which is different from merely &quot;equals&quot; (==).</source>
          <target state="translated">这是因为当我们创建L2时,python并没有实际创建一个新对象。相反,它只是将L2引用到与L1相同的对象。我们可以用 &quot;is &quot;来验证这一点,它不同于单纯的 &quot;等价&quot;(===)。</target>
        </trans-unit>
        <trans-unit id="5e26fd0b44d14a076fccd9b06568c15d5d11763c" translate="yes" xml:space="preserve">
          <source>This is more space efficient since it dispenses the array copy, but it is less time efficient because CPython lists &lt;a href=&quot;https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented&quot;&gt;are implemented with dynamic arrays&lt;/a&gt;.</source>
          <target state="translated">由于它分配了数组副本，因此空间使用效率更高，但由于CPython列表&lt;a href=&quot;https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented&quot;&gt;是使用动态数组实现的，&lt;/a&gt;因此时间效率较低。</target>
        </trans-unit>
        <trans-unit id="167c700ccc2cf194c88b1e29817f0e5473200686" translate="yes" xml:space="preserve">
          <source>This is often easier to understand than a list comprehension when you're doing some operations with side effects on the first item in a list that meets some condition and then removing that item from the list immediately after.</source>
          <target state="translated">当你对列表中的第一个符合某种条件的项目进行一些有副作用的操作,然后紧接着把这个项目从列表中删除,这往往比列表理解更容易理解。</target>
        </trans-unit>
        <trans-unit id="9e832ffbc7b8159e0dacf897dec246a0c433e2de" translate="yes" xml:space="preserve">
          <source>This means that item removal requires shifting all following items back by one, which is O(N).</source>
          <target state="translated">也就是说,物品的移除需要将下面的物品全部移回一个,也就是O(N)。</target>
        </trans-unit>
        <trans-unit id="6d3f755498b86d4d64c1f495ead2913089f82af0" translate="yes" xml:space="preserve">
          <source>This part of the docs makes it clear that:</source>
          <target state="translated">这一部分的docs明确指出:</target>
        </trans-unit>
        <trans-unit id="4dfe1b1a882c87ca174edca828cf5ca59cfa1421" translate="yes" xml:space="preserve">
          <source>This part of the docs says once again that you have to make a copy, and gives an actual removal example:</source>
          <target state="translated">这部分的文件再次说了一遍,你必须要做一个副本,并给出了一个实际的删除例子。</target>
        </trans-unit>
        <trans-unit id="23a9c4672ae391fc627eba417316401219f51f2f" translate="yes" xml:space="preserve">
          <source>This time efficient, but less space efficient because it keeps a copy of the array around during iteration.</source>
          <target state="translated">这样的时间效率很高,但空间效率较低,因为在迭代过程中,它把数组的副本保留在周围。</target>
        </trans-unit>
        <trans-unit id="526b1bb0411da1ec481ceb845008bac5dfa4b12c" translate="yes" xml:space="preserve">
          <source>This way the index is aligned and doesn't suffer from the list updates (regardless whether you pop cur element or not).</source>
          <target state="translated">这样索引是对齐的,不会受到列表更新的影响(不管你是否弹出CUR元素)。</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">这将输出以下内容:</target>
        </trans-unit>
        <trans-unit id="f906bf0437d1189835cd8ddcd60d8f965fa2c44a" translate="yes" xml:space="preserve">
          <source>This will produce the following output:</source>
          <target state="translated">这将产生以下输出:</target>
        </trans-unit>
        <trans-unit id="de0da919165bd723f966b10f2b6d39bef73fe836" translate="yes" xml:space="preserve">
          <source>Unfortunately, I cannot adequately describe how reversed() works. It returns a 'listreverseiterator' object when a list is passed to it. For practical purposes, you can think of it as creating a reversed copy of its argument. This is the solution I recommend.</source>
          <target state="translated">不幸的是,我无法充分描述 reversed()的工作原理。当一个列表被传递给它时,它返回一个 &quot;listreverseiterator &quot;对象。在实际应用中,你可以把它看成是创建一个反转参数的副本。这就是我推荐的解决方案。</target>
        </trans-unit>
        <trans-unit id="8b2d2221789d986c7ae56d80c76907b6412db859" translate="yes" xml:space="preserve">
          <source>We can make a true copy using copy.copy(). Then everything works as expected:</source>
          <target state="translated">我们可以使用copy.copy()进行真正的复制。然后,一切都能正常工作。</target>
        </trans-unit>
        <trans-unit id="23784d9f68162c9269e0a23fd4ac91e3cbbffbaa" translate="yes" xml:space="preserve">
          <source>What I don't know is how efficient a couple of deletes are compared to copying a large list. Please comment if you have any insight.</source>
          <target state="translated">我不知道的是,与复制一个大的列表相比,几次删除的效率如何?如果你有什么见解,请评论一下。</target>
        </trans-unit>
        <trans-unit id="b617b1edd0d3f10931aa29fbdeee51bf2c7348cc" translate="yes" xml:space="preserve">
          <source>What should I use in place of &lt;code&gt;code_to_remove_tup&lt;/code&gt;? I can't figure out how to remove the item in this fashion.</source>
          <target state="translated">我应该使用什么来代替 &lt;code&gt;code_to_remove_tup&lt;/code&gt; ？ 我不知道如何以这种方式删除项目。</target>
        </trans-unit>
        <trans-unit id="943d5a56f866fd2745375a8579ced2fc5bc9d4aa" translate="yes" xml:space="preserve">
          <source>Why is (1,-2) still in your list? It turns out modifying the list while using a loop to iterate over it is a very bad idea without special care. The reason that (1, -2) remains in the list is that the locations of each item within the list changed between iterations of the for loop. Let's look at what happens if we feed the above code a longer list:</source>
          <target state="translated">为什么(1,-2)还在你的列表中?事实证明,在使用循环迭代的同时修改列表是一个非常糟糕的想法,如果没有特别注意的话。之所以(1,-2)还在列表中,是因为在for循环的迭代之间,列表中每个项的位置都发生了变化。让我们来看看如果我们给上面的代码喂入一个较长的列表会发生什么情况。</target>
        </trans-unit>
        <trans-unit id="cba5525fdc4b748be86f6f7a8d4839e16d248545" translate="yes" xml:space="preserve">
          <source>You can try for-looping in reverse so for some_list you'll do something like:</source>
          <target state="translated">你可以尝试反向的for-loop,所以对于some_list,你可以做这样的事情。</target>
        </trans-unit>
        <trans-unit id="fef932e24c895baf0179ccaa420e2bd7d0954340" translate="yes" xml:space="preserve">
          <source>You can use a list comprehension to create a new list containing only the elements you don't want to remove:</source>
          <target state="translated">你可以使用列表理解来创建一个新的列表,只包含你不想删除的元素。</target>
        </trans-unit>
        <trans-unit id="0fe88cac7a8c1d65c953157de58c81088b07d23d" translate="yes" xml:space="preserve">
          <source>You might want to use &lt;code&gt;filter()&lt;/code&gt; available as the built-in.</source>
          <target state="translated">您可能要使用内置的 &lt;code&gt;filter()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76db65aa7d7889fbb23154214040d2a4fa6894c1" translate="yes" xml:space="preserve">
          <source>You need to go backwards otherwise it's a bit like sawing off the tree-branch that you are sitting on :-)</source>
          <target state="translated">你需要倒着走,否则就有点像锯掉你坐着的树枝一样:-)</target>
        </trans-unit>
        <trans-unit id="80b0cf2331c96b3507f2cb33293c954612fab365" translate="yes" xml:space="preserve">
          <source>You need to take a copy of the list and iterate over it first, or the iteration will fail with what may be unexpected results.</source>
          <target state="translated">你需要先拿一个列表的副本,然后对其进行迭代,否则迭代失败,可能会出现意想不到的结果。</target>
        </trans-unit>
        <trans-unit id="adfd09eef6d8d4afdd5310e5f03eb9a705d7ec94" translate="yes" xml:space="preserve">
          <source>Your best approach for such an example would be a &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;list comprehension&lt;/a&gt;</source>
          <target state="translated">此类示例的最佳方法是&lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;列表理解&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbc0aff80688baeb01a5a4cb720794fe808ad957" translate="yes" xml:space="preserve">
          <source>```</source>
          <target state="translated">```</target>
        </trans-unit>
        <trans-unit id="dfd3b60d353170b5585a8909968d17705c98f55e" translate="yes" xml:space="preserve">
          <source>and then &lt;strong&gt;next value (65)&lt;/strong&gt; move on to previous index.</source>
          <target state="translated">然后&lt;strong&gt;下一个值（65）&lt;/strong&gt;移至上一个索引。</target>
        </trans-unit>
        <trans-unit id="256773140eb61f1cd6dd994baf6076f0cbda5306" translate="yes" xml:space="preserve">
          <source>and to avoid having to re-code the entire project with the new lists name:</source>
          <target state="translated">并避免用新的列表名称重新编码整个项目。</target>
        </trans-unit>
        <trans-unit id="7c9ee5a07e5b78059e78b86ca4241fb482333081" translate="yes" xml:space="preserve">
          <source>both of which make it crystal clear that you cannot modify a list being iterated except with the iterator itself, and gives you efficient ways to do so without copying the list.</source>
          <target state="translated">两者都清楚地表明,除了使用迭代器本身之外,你不能修改被迭代的列表,并给出了不复制列表的有效方法。</target>
        </trans-unit>
        <trans-unit id="6d12700c2217a6fd0f4bff860dfcd30dd2761df6" translate="yes" xml:space="preserve">
          <source>consider you have a list,</source>
          <target state="translated">认为你有一个名单。</target>
        </trans-unit>
        <trans-unit id="877d45d55490879d4296a7fe796015d42f80527e" translate="yes" xml:space="preserve">
          <source>copy.copy(x) 
  Return a shallow copy of x.</source>
          <target state="translated">copy.copy(x)返回一个x的浅层副本。</target>
        </trans-unit>
        <trans-unit id="e379d3ba5b6ab3903a95b94fa0aad486fec92cef" translate="yes" xml:space="preserve">
          <source>copy.deepcopy(x) 
  Return a deep copy of x.</source>
          <target state="translated">copy.deepcopy(x)返回一个x的深度副本。</target>
        </trans-unit>
        <trans-unit id="7b4c418dc9f6bec70118f7721079c58620f7e7c8" translate="yes" xml:space="preserve">
          <source>during 5th iteration,</source>
          <target state="translated">在第五次迭代期间。</target>
        </trans-unit>
        <trans-unit id="fb5bc8bbd4a82ff3b60e90dcd93261b98bd06448" translate="yes" xml:space="preserve">
          <source>for loop will be iterate through index..</source>
          <target state="translated">for循环将通过索引进行迭代。</target>
        </trans-unit>
        <trans-unit id="2c3a0ef6ef4316e6e5d1c614dce6be8faad1cb40" translate="yes" xml:space="preserve">
          <source>i.e.</source>
          <target state="translated">i.e.</target>
        </trans-unit>
        <trans-unit id="f9a405f5d71953928e26ce3b09f8a952c37a7815" translate="yes" xml:space="preserve">
          <source>note, from Python documentation:</source>
          <target state="translated">注,来自Python文档。</target>
        </trans-unit>
        <trans-unit id="3c7aec3e12f7c3f23e559160305465cb5a2d42df" translate="yes" xml:space="preserve">
          <source>now you it will give,</source>
          <target state="translated">现在,你会给。</target>
        </trans-unit>
        <trans-unit id="952d109808fc70092cb9652c674259cd795c7282" translate="yes" xml:space="preserve">
          <source>one way to do it is with the slice notation &lt;code&gt;[:]&lt;/code&gt;</source>
          <target state="translated">一种方法是使用切片符号 &lt;code&gt;[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="9440205f7b297bb97378c8ee9cd6dd38026733b0" translate="yes" xml:space="preserve">
          <source>so 4th iteration done pointer moved onto 5th..</source>
          <target state="translated">所以第4次迭代完成后,指针移至第5次.....</target>
        </trans-unit>
        <trans-unit id="32303bd0019c71856b3bd0ca577afa9b20a6f1d4" translate="yes" xml:space="preserve">
          <source>so do copy of list using &lt;code&gt;list[::]&lt;/code&gt;</source>
          <target state="translated">所以使用 &lt;code&gt;list[::]&lt;/code&gt; 复制列表</target>
        </trans-unit>
        <trans-unit id="b67a61431e78c0efef0f8344a3155b585fc957b6" translate="yes" xml:space="preserve">
          <source>so you can try comprehension instead.</source>
          <target state="translated">所以你可以试着理解一下</target>
        </trans-unit>
        <trans-unit id="c56b5b45bd0c8acb29daa7a9f24462a60d123bd4" translate="yes" xml:space="preserve">
          <source>so you shouldn't reference list into another variable which still reference original instead of copy.</source>
          <target state="translated">所以,你不应该把列表引用到另一个变量中,而不是复制,而是引用原件。</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="0b64514082f4dab14fe23e3dcbcb92cea9f748ba" translate="yes" xml:space="preserve">
          <source>start a new array from scratch, and &lt;code&gt;.append()&lt;/code&gt; back at the end: &lt;a href=&quot;https://stackoverflow.com/a/1207460/895245&quot;&gt;https://stackoverflow.com/a/1207460/895245&lt;/a&gt;</source>
          <target state="translated">从头开始创建新数组，然后在末尾返回 &lt;code&gt;.append()&lt;/code&gt; ： &lt;a href=&quot;https://stackoverflow.com/a/1207460/895245&quot;&gt;https&lt;/a&gt; : //stackoverflow.com/a/1207460/895245</target>
        </trans-unit>
        <trans-unit id="0166462591b186a6ce777cfdce9d2d4e230d1977" translate="yes" xml:space="preserve">
          <source>thats why your loop doesnt cover 65 since its moved into previous index.</source>
          <target state="translated">这就是为什么你的循环不包括65,因为它被移到了之前的指数。</target>
        </trans-unit>
        <trans-unit id="3c060051ec2702c90517f75bb0955c4fed00b1ad" translate="yes" xml:space="preserve">
          <source>uppose a list of number and you want to remove all no which are divisible by 3,</source>
          <target state="translated">uppose a list of number and you want to remove all no which are dividedable by 3,</target>
        </trans-unit>
        <trans-unit id="c2c2f6b4aca96b4db1ec0779cbfab2e190a97931" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;del&lt;/code&gt; with an index: &lt;a href=&quot;https://stackoverflow.com/a/1207485/895245&quot;&gt;https://stackoverflow.com/a/1207485/895245&lt;/a&gt;</source>
          <target state="translated">使用带有索引的 &lt;code&gt;del&lt;/code&gt; ： &lt;a href=&quot;https://stackoverflow.com/a/1207485/895245&quot;&gt;https&lt;/a&gt; : //stackoverflow.com/a/1207485/895245</target>
        </trans-unit>
        <trans-unit id="c77354b6717d46ffe5ad4fcd2e94f33c21d88f30" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;lambda filter&lt;/code&gt; function, this will create resultant new list and consume memeory space</source>
          <target state="translated">使用 &lt;code&gt;lambda filter&lt;/code&gt; 功能，这将创建结果新列表并消耗内存空间</target>
        </trans-unit>
        <trans-unit id="b1c7e2bae9e038687eb2d3cce815acc3dcac458c" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;list comprehension&lt;/code&gt;,this will careate a new list and create new memory space</source>
          <target state="translated">使用 &lt;code&gt;list comprehension&lt;/code&gt; ，这将创建一个新列表并创建新的内存空间</target>
        </trans-unit>
        <trans-unit id="5c3c89eedc5f3e318d8c78de0dae591b09b494ef" translate="yes" xml:space="preserve">
          <source>which supports all the iterable like, list, tuple, dict, string etc</source>
          <target state="translated">支持所有的迭代,如 list,tuple,dict,string 等。</target>
        </trans-unit>
        <trans-unit id="c9ac37e61a632309fe6ac352cebdb1140b02c11f" translate="yes" xml:space="preserve">
          <source>without consuming memory space for new list and modify existing list</source>
          <target state="translated">在不消耗内存空间的情况下新建列表和修改现有的列表</target>
        </trans-unit>
        <trans-unit id="e6eb9174b0a0f9124941d34b2c9c2b9375d4cb20" translate="yes" xml:space="preserve">
          <source>you have using list variable called &lt;code&gt;lis&lt;/code&gt;. and you using same to remove..</source>
          <target state="translated">您使用了名为 &lt;code&gt;lis&lt;/code&gt; 的列表变量。 并且您使用它删除。</target>
        </trans-unit>
        <trans-unit id="f4735f130b7506791a866079cea171cee93ee923" translate="yes" xml:space="preserve">
          <source>you need to make a copy of the iterated list to modify it</source>
          <target state="translated">你需要复制一个迭代列表来修改它。</target>
        </trans-unit>
        <trans-unit id="9c0c41a37eef8bb146367129bb2695642d431ffa" translate="yes" xml:space="preserve">
          <source>your &lt;strong&gt;number 35&lt;/strong&gt; was not a prime so you removed it from a list.</source>
          <target state="translated">您的&lt;strong&gt;数字35&lt;/strong&gt;不是素数，因此您将其从列表中删除。</target>
        </trans-unit>
        <trans-unit id="c3e100f0c1beaa3886a138699e84f88bf0090a45" translate="yes" xml:space="preserve">
          <source>your variable</source>
          <target state="translated">你的变量</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
