<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1207406">
    <body>
      <group id="1207406">
        <trans-unit id="3b2c92f73dff63b7b88c756e8c6c4ea763db1c81" translate="yes" xml:space="preserve">
          <source>1) When using remove(), you attempt to remove integers whereas you need to remove a tuple.</source>
          <target state="translated">1) remove ()를 사용할 때 정수를 제거하려고 시도하지만 튜플을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="c26bec6ae55dfa38b757d819eb9fa58107cda58b" translate="yes" xml:space="preserve">
          <source>2) The for loop will skip items in your list.</source>
          <target state="translated">2) for 루프는 목록의 항목을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="41f1f874fa2b979825cd5672d52c9f672bb63674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Filter&lt;/code&gt; receives a function and a sequence. &lt;code&gt;Filter&lt;/code&gt; applies the passed function to each element in turn, and then decides whether to retain or discard the element depending on whether the function return value is &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filter&lt;/code&gt; 는 함수와 시퀀스를받습니다. &lt;code&gt;Filter&lt;/code&gt; 는 전달 된 함수를 각 요소에 차례로 적용한 다음 함수 반환 값이 &lt;code&gt;True&lt;/code&gt; 인지 &lt;code&gt;False&lt;/code&gt; 인지에 따라 요소를 유지할지 또는 삭제할지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="1f7e48e862214b7809d0460c5e1af926208bd696" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enumerate&lt;/code&gt; gives you access to the item and the index at once. &lt;code&gt;reversed&lt;/code&gt; is so that the indices that you're going to later delete don't change on you.</source>
          <target state="translated">&lt;code&gt;enumerate&lt;/code&gt; 하면 항목과 색인에 한 번에 액세스 할 수 있습니다. 나중에 삭제하려는 인덱스가 변경되지 않도록 &lt;code&gt;reversed&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4de7ada0839383f54f19d7f396d39fb507f52e99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What I have chosen is a randomly chosen example. &lt;strong&gt;Feel free to change&lt;/strong&gt; the &lt;strong&gt;list of tuples&lt;/strong&gt; and the &lt;strong&gt;condition&lt;/strong&gt; that I have chosen.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;내가 선택한 것은 무작위로 선택된 예입니다.&lt;/em&gt; &lt;em&gt;&lt;strong&gt;튜플 목록&lt;/strong&gt; 과 내가 선택한 &lt;strong&gt;조건&lt;/strong&gt; 을 &lt;strong&gt;자유롭게 변경&lt;/strong&gt; 하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41cfd101eef50f2ce2c163096a74fa93f38da56b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best workarounds&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;최상의 해결 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccd82364b395036f5280ff13da623f258d9644df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution: You can also not handle iterators. Iterators are sometimes better than sequences.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;주의 : 반복자를 처리 할 수도 없습니다.&lt;/strong&gt; &lt;strong&gt;반복자는 때때로 시퀀스보다 낫습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81b8bc03967964ba1eea500b2bc7787b4b23c68e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Could Python do this better?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;파이썬이 더 잘 할 수 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="788e3773d2b7d304ae70795cc020d884336ac974" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1 and method 2 are faster than method 3&lt;/strong&gt;. Method2 and method3 are more efficient than method1. I &lt;strong&gt;prefer method2&lt;/strong&gt;. For the aforementioned example, &lt;code&gt;time(method1) : time(method2) : time(method3) = 1 : 1 : 1.7&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;방법 1과 방법 2는 방법 3보다 빠릅니다&lt;/strong&gt; . Method2와 method3이 method1보다 효율적입니다. 나는 &lt;strong&gt;method2 선호한다&lt;/strong&gt; . 전술 한 예에서, &lt;code&gt;time(method1) : time(method2) : time(method3) = 1 : 1 : 1.7&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6dcc3dfb40a81d59ef252bee9510d3a8af5cdc6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1.&amp;gt;&lt;/strong&gt; Use the framework that you had suggested (where one fills in a code inside a for loop). I use a small code with &lt;code&gt;del&lt;/code&gt; to delete a tuple that meets the said condition. However, this method will miss a tuple (which satisfies the said condition) if two consecutively placed tuples meet the given condition.</source>
          <target state="translated">&lt;strong&gt;방법 1.&amp;gt;&lt;/strong&gt; 제안한 프레임 워크를 사용하십시오 (for 루프 안에 코드를 채우는 곳). 나는 &lt;code&gt;del&lt;/code&gt; 과 함께 작은 코드를 사용하여 상기 조건을 충족시키는 튜플을 삭제합니다. 그러나, 연속적으로 배치 된 2 개의 튜플이 주어진 조건을 만족시키는 경우,이 방법은 (상기 조건을 만족하는) 튜플을 놓칠 것이다.</target>
        </trans-unit>
        <trans-unit id="8a87ff388a2cd2a3b0c5940103c76fd9ebd422c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 2.&amp;gt;&lt;/strong&gt; Construct a new list which contains elements (tuples) where the given condition is not met (this is the same thing as removing elements of list where the given condition is met). Following is the code for that:</source>
          <target state="translated">&lt;strong&gt;방법 2.&amp;gt;&lt;/strong&gt; 주어진 조건이 충족되지 않는 요소 (튜플)를 포함하는 새로운 목록을 구성하십시오 (이는 주어진 조건이 충족되는 목록의 요소를 제거하는 것과 같습니다). 다음은 그 코드입니다.</target>
        </trans-unit>
        <trans-unit id="63bda6e7a91b63c3a620d3c5e06adb18cc1e0fc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 3.&amp;gt;&lt;/strong&gt; Find indices where the given condition is met, and then use remove elements (tuples) corresponding to those indices. Following is the code for that.</source>
          <target state="translated">&lt;strong&gt;방법 3.&amp;gt;&lt;/strong&gt; 주어진 조건이 충족되는 색인을 찾은 다음 해당 색인에 해당하는 요소 제거 (튜플)를 사용하십시오. 다음은 그 코드입니다.</target>
        </trans-unit>
        <trans-unit id="5b34cc7bf01f9d2e80a510543d0a68d2bbdb4dfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Official Python 2 tutorial 4.2. &quot;for Statements&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;공식 파이썬 2 튜토리얼 4.2.&lt;/strong&gt; &lt;strong&gt;&quot;명세서&quot;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="557cafd24827735707266d1c1085114004a6d458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 2 documentation 7.3. &quot;The for statement&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;파이썬 2 문서 7.3.&lt;/strong&gt; &lt;strong&gt;&quot;for 문&quot;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fc8a02d37d7e4516e492ebd254cc004a1d0b7e9" translate="yes" xml:space="preserve">
          <source>Above we have used the &lt;code&gt;pop&lt;/code&gt; method on the fluid list object. Other common iterable methods are also implemented such as &lt;code&gt;del fluidL[i]&lt;/code&gt;, &lt;code&gt;.remove&lt;/code&gt;, &lt;code&gt;.insert&lt;/code&gt;, &lt;code&gt;.append&lt;/code&gt;, &lt;code&gt;.extend&lt;/code&gt;. The list can also be modified using slices (&lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;reverse&lt;/code&gt; methods are not implemented).</source>
          <target state="translated">위에서 우리는 유체리스트 객체에 &lt;code&gt;pop&lt;/code&gt; 메소드를 사용했습니다. &lt;code&gt;del fluidL[i]&lt;/code&gt; , &lt;code&gt;.remove&lt;/code&gt; , &lt;code&gt;.insert&lt;/code&gt; , &lt;code&gt;.append&lt;/code&gt; , &lt;code&gt;.extend&lt;/code&gt; 와 같은 다른 일반적인 반복 가능한 메소드도 구현됩니다. 슬라이스를 사용하여 목록을 수정할 수도 있습니다 ( &lt;code&gt;sort&lt;/code&gt; 및 &lt;code&gt;reverse&lt;/code&gt; 방법은 구현되지 않음).</target>
        </trans-unit>
        <trans-unit id="16670fb950d5c5fdd6c0fd65ad6b86d68d95e137" translate="yes" xml:space="preserve">
          <source>Aha! Each element of L1 is actually a tuple. So that's what we need to be passing to remove(). Tuples in python are very easy, they're simply made by enclosing values in parentheses. &quot;a, b&quot; is not a tuple, but &quot;(a, b)&quot; is a tuple. So we modify your code and run it again:</source>
          <target state="translated">아하! L1의 각 요소는 실제로 튜플입니다. 이것이 바로 remove ()에 전달해야하는 것입니다. 파이썬의 튜플은 매우 쉽습니다. 간단히 괄호 안에 값을 넣는 것입니다. &quot;a, b&quot;는 튜플이 아니지만 &quot;(a, b)&quot;는 튜플입니다. 따라서 코드를 수정하고 다시 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="6289272e180651017551f0d23619c6b843207579" translate="yes" xml:space="preserve">
          <source>As I stated to start with: this is a complicated solution that will hurt the readability of your code and make it more difficult to debug. Therefore other solutions such as the list comprehensions mentioned in David Raznick's &lt;a href=&quot;https://stackoverflow.com/a/1207461/4451578&quot;&gt;answer&lt;/a&gt; should be considered first. That being said, I have found times where this class has been useful to me and has been easier to use than keeping track of the indices of elements that need deleting.</source>
          <target state="translated">처음부터 언급했듯이 : 이것은 코드의 가독성을 손상시키고 디버그하기가 더 어려운 복잡한 솔루션입니다. 따라서 David Raznick의 &lt;a href=&quot;https://stackoverflow.com/a/1207461/4451578&quot;&gt;답변에&lt;/a&gt; 언급 된 목록 이해와 같은 다른 솔루션을 먼저 고려해야합니다. 즉,이 클래스가 나에게 유용하고 삭제해야 할 요소의 색인을 추적하는 것보다 사용하기 쉬운 시간을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="b0de2e5d5f6712623237e9fe813e112b1056e691" translate="yes" xml:space="preserve">
          <source>As you can infer from that result, every time that the conditional statement evaluates to true and a list item is removed, the next iteration of the loop will skip evaluation of the next item in the list because its values are now located at different indices.</source>
          <target state="translated">해당 결과에서 유추 할 수 있듯이 조건문이 true로 평가되고 목록 항목이 제거 될 때마다 루프의 다음 반복은 값이 다른 색인에 있으므로 목록의 다음 항목 평가를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="f9468c326a4a729e70975ea2231fdda83d27f476" translate="yes" xml:space="preserve">
          <source>But what if the result of the &lt;code&gt;testFunc&lt;/code&gt; depends on the elements that have been added to &lt;code&gt;newList&lt;/code&gt; already? Or the elements still in &lt;code&gt;oldList&lt;/code&gt; that might be added next? There might still be a way to use a list comprehension but it will begin to lose it's elegance, and for me it feels easier to modify a list in place.</source>
          <target state="translated">그러나 &lt;code&gt;testFunc&lt;/code&gt; 의 결과가 &lt;code&gt;newList&lt;/code&gt; 에 이미 추가 된 요소에 의존한다면 어떨까요 ? 아니면 여전히 &lt;code&gt;oldList&lt;/code&gt; 에 있는 요소들이 다음에 추가 될 수 있습니까? 여전히 목록 이해력을 사용하는 방법이있을 수 있지만 우아함을 잃기 시작할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ab99bb95d0a8563a2528243c1af734b49825dea8" translate="yes" xml:space="preserve">
          <source>C++ &lt;a href=&quot;https://en.cppreference.com/w/cpp/container/vector/erase&quot;&gt;&lt;code&gt;std::vector::erase&lt;/code&gt;&lt;/a&gt; which returns a valid interator to the element after the one removed</source>
          <target state="translated">C ++ &lt;a href=&quot;https://en.cppreference.com/w/cpp/container/vector/erase&quot;&gt; &lt;code&gt;std::vector::erase&lt;/code&gt; &lt;/a&gt; 는 요소를 제거한 후 요소에 유효한 인터 레이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="70de89a9d1057697c722db9334aea9338d7d9424" translate="yes" xml:space="preserve">
          <source>Copying the list using &lt;code&gt;remove&lt;/code&gt; might make your code look a little cleaner, as described in one of the answers below.  You should definitely not do this for extremely large lists, since this involves first copying the entire list, and also performing an &lt;code&gt;O(n)&lt;/code&gt;&lt;code&gt;remove&lt;/code&gt; operation for each element being removed, making this an &lt;code&gt;O(n^2)&lt;/code&gt; algorithm.</source>
          <target state="translated">&lt;code&gt;remove&lt;/code&gt; 를 사용하여 목록을 복사하면 아래 답변 중 하나에 설명 된대로 코드가 좀 더 깔끔해 보일 수 있습니다. 전체 목록을 먼저 복사하고 &lt;code&gt;remove&lt;/code&gt; 되는 각 요소에 대해 &lt;code&gt;O(n)&lt;/code&gt; 제거 작업을 수행하여 &lt;code&gt;O(n^2)&lt;/code&gt; 알고리즘으로 만들기 때문에 매우 큰 목록에 대해서는이 작업을 수행하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="cf79941ef09fc206b51225e5da9c16355e55b212" translate="yes" xml:space="preserve">
          <source>Download &lt;code&gt;fluidIter.py&lt;/code&gt; from &lt;a href=&quot;https://github.com/alanbacon/FluidIterator&quot;&gt;here&lt;/a&gt;&lt;code&gt;https://github.com/alanbacon/FluidIterator&lt;/code&gt;, it is just a single file so no need to install git. There is no installer so you will need to make sure that the file is in the python path your self. The code has been written for python 3 and is untested on python 2.</source>
          <target state="translated">&lt;code&gt;https://github.com/alanbacon/FluidIterator&lt;/code&gt; 에서 &lt;code&gt;fluidIter.py&lt;/code&gt; 를 다운로드하면 단일 파일이므로 git을 설치할 필요가 없습니다. 설치 프로그램이 없으므로 파일이 파이썬 경로에 있는지 확인해야합니다. 이 코드는 Python 3 용으로 작성되었으며 Python 2에서 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1a2545867f0ca9597a7db53881bd6afe7c73dffe" translate="yes" xml:space="preserve">
          <source>Edit: As mentioned in the comments, this answer does not really present a problem for which this approach provides a solution. I will try to address that here:</source>
          <target state="translated">편집 : 의견에서 언급 했듯이이 답변은 실제로이 접근법이 해결책을 제공하는 문제를 제시하지는 않습니다. 나는 그것을 해결하려고 노력할 것이다.</target>
        </trans-unit>
        <trans-unit id="a788b2421c51b170010ec2c266d516cb0be3f175" translate="yes" xml:space="preserve">
          <source>Edit: The last code example in this answer gives a use case for &lt;strong&gt;&lt;em&gt;why&lt;/em&gt;&lt;/strong&gt; you might sometimes want to modify a list in place rather than use a list comprehension. The first part of the answers serves as tutorial of &lt;strong&gt;&lt;em&gt;how&lt;/em&gt;&lt;/strong&gt; an array can be modified in place.</source>
          <target state="translated">편집 :이 답변의 마지막 코드 예제는 목록 이해를 사용하지 않고 대신 목록을 수정하려는 &lt;strong&gt;&lt;em&gt;이유에&lt;/em&gt;&lt;/strong&gt; 대한 사용 사례를 제공합니다. 답변의 첫 부분은 배열을 &lt;strong&gt;&lt;em&gt;어떻게&lt;/em&gt;&lt;/strong&gt; 수정 &lt;strong&gt;&lt;em&gt;하는 지에&lt;/em&gt;&lt;/strong&gt; 대한 자습서 역할을 &lt;strong&gt;&lt;em&gt;합니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c8078d924b19f64b223a6df8142a489104063237" translate="yes" xml:space="preserve">
          <source>Either:</source>
          <target state="translated">Either:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2e016639bfdc35ff47021bee07e0442c9bf6e95a" translate="yes" xml:space="preserve">
          <source>Finally, there is one cleaner solution than having to make an entirely new copy of L1. The reversed() function:</source>
          <target state="translated">마지막으로 완전히 새로운 L1 복사본을 만드는 것보다 하나의 더 깨끗한 솔루션이 있습니다. reversed () 함수 :</target>
        </trans-unit>
        <trans-unit id="c44ea041349ed36728514202e8abfa264d478d68" translate="yes" xml:space="preserve">
          <source>First of all you'll need to &lt;strong&gt;replace foreach loop with while loop&lt;/strong&gt;,</source>
          <target state="translated">우선 &lt;strong&gt;foreach 루프를 while 루프&lt;/strong&gt; 로 &lt;strong&gt;교체&lt;/strong&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4bbfc8e8879463ee80d588ea8bff37fe8625e66" translate="yes" xml:space="preserve">
          <source>For anything that has the potential to be really big, I use the following.</source>
          <target state="translated">정말로 큰 잠재력을 가진 것은 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c9d41ff6b00990841a094958bdca36f5ecbef710" translate="yes" xml:space="preserve">
          <source>For example (depends on what type of list):</source>
          <target state="translated">예를 들어 (목록 유형에 따라 다름) :</target>
        </trans-unit>
        <trans-unit id="d3826d07dc82c819a2952d0b19069cf2dcd53dc5" translate="yes" xml:space="preserve">
          <source>For more details &lt;a href=&quot;http://docs.python.org/library/functions.html#filter&quot;&gt;check here&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://docs.python.org/library/functions.html#filter&quot;&gt;여기를 확인하십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0682dfde6b8575edaa27bd1c03020cbce20014a8" translate="yes" xml:space="preserve">
          <source>For those that like functional programming:</source>
          <target state="translated">기능적 프로그래밍을 좋아하는 사람들을 위해 :</target>
        </trans-unit>
        <trans-unit id="a74dc39ba82bf47d723236da822a90c8ff7a3ec2" translate="yes" xml:space="preserve">
          <source>Fortunately, it's extremely easy to get both the speed of list comprehensions AND the required semantics of in-place alteration -- just code:</source>
          <target state="translated">다행스럽게도 목록 이해 속도와 내부 변경에 필요한 의미를 모두 쉽게 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36edd270beeffac5974b87eb6c988c0cf556914" translate="yes" xml:space="preserve">
          <source>Full answer:</source>
          <target state="translated">전체 답변 :</target>
        </trans-unit>
        <trans-unit id="56e8e2cad0c7d16346946903b1f1df0e011a6ba1" translate="yes" xml:space="preserve">
          <source>Generally you just want to go for the faster &lt;code&gt;.append()&lt;/code&gt; option by default unless memory is a big concern.</source>
          <target state="translated">일반적으로 메모리가 큰 문제가 아닌 한 기본적으로 더 빠른 &lt;code&gt;.append()&lt;/code&gt; 옵션을 원합니다 .</target>
        </trans-unit>
        <trans-unit id="88f8f55fdd9b1ef963f6e91ea73765a38063d284" translate="yes" xml:space="preserve">
          <source>Here is an example where copying the list beforehand is incorrect, reverse iteration is impossible and a list comprehension is also not an option.</source>
          <target state="translated">다음은 미리 목록을 복사하는 것이 올바르지 않고 역 반복이 불가능하며 목록 이해도 옵션이 아닌 예입니다.</target>
        </trans-unit>
        <trans-unit id="015e2b33e48d8c457bdeefa7777500d6753f17a6" translate="yes" xml:space="preserve">
          <source>How to remove items from a list while iterating</source>
          <target state="translated">반복하는 동안 목록에서 항목을 제거하는 방법</target>
        </trans-unit>
        <trans-unit id="c77620b856d20a8819f9b0b470a56a1277c2fb40" translate="yes" xml:space="preserve">
          <source>However, I disagree with this implementation, since &lt;code&gt;.remove()&lt;/code&gt; has to iterate the &lt;em&gt;entire list&lt;/em&gt; to find the value.</source>
          <target state="translated">그러나 &lt;code&gt;.remove()&lt;/code&gt; 는 값을 찾기 위해 &lt;em&gt;전체 목록&lt;/em&gt; 을 반복해야하기 때문에이 구현에 동의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69b67973d6a8e6ef36e2888307c19b186e7df019" translate="yes" xml:space="preserve">
          <source>However, the output will be identical to before:</source>
          <target state="translated">그러나 출력은 이전과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3f4aacab5e7adbd49358dc9debb14a93fa23eb41" translate="yes" xml:space="preserve">
          <source>I can think of three approaches to solve your problem. As an example, I will create a random list of tuples &lt;code&gt;somelist = [(1,2,3), (4,5,6), (3,6,6), (7,8,9), (15,0,0), (10,11,12)]&lt;/code&gt;. The condition that I choose is &lt;code&gt;sum of elements of a tuple = 15&lt;/code&gt;. In the final list we will only have those tuples whose sum is not equal to 15.</source>
          <target state="translated">문제를 해결하기위한 세 가지 접근 방식을 생각할 수 있습니다. 예를 들어, 임의리스트 튜플 &lt;code&gt;somelist = [(1,2,3), (4,5,6), (3,6,6), (7,8,9), (15,0,0), (10,11,12)]&lt;/code&gt; . 내가 선택한 조건 &lt;code&gt;sum of elements of a tuple = 15&lt;/code&gt; 입니다. 최종 목록에는 합계가 15가 아닌 튜플 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="a368dea51582938f2ab67c94c9f3b922d05e401f" translate="yes" xml:space="preserve">
          <source>I needed to do something similar and in my case the problem was memory - I needed to merge multiple dataset objects within a list, after doing some stuff with them, as a new object, and needed to get rid of each entry I was merging to avoid duplicating all of them and blowing up memory. In my case having the objects in a dictionary instead of a list worked fine:</source>
          <target state="translated">비슷한 일을해야했고 내 경우에는 문제가 메모리였습니다. 목록에 여러 데이터 세트 객체를 병합 한 다음 새 객체로 사용하고 병합하려는 각 항목을 제거해야했습니다. 그들 모두를 복제하고 메모리를 폭파시키지 마십시오. 필자의 경우 목록 대신 사전에 객체를 갖는 것이 잘 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="cd970f7da56e80281558904a4e1d263b5a3fa2d2" translate="yes" xml:space="preserve">
          <source>I needed to do this with a huge list, and duplicating the list seemed expensive, especially since in my case the number of deletions would be few compared to the items that remain. I took this low-level approach.</source>
          <target state="translated">거대한 목록 으로이 작업을 수행해야했으며 목록을 복제하면 비용이 많이 들었습니다. 특히 필자의 경우 삭제 항목 수가 남아있는 항목에 비해 적기 때문입니다. 나는이 저수준 접근법을 취했다.</target>
        </trans-unit>
        <trans-unit id="61eac64b85c8bcbd86114f439152c5f3727dc586" translate="yes" xml:space="preserve">
          <source>I wrote a library that allows you to do this:</source>
          <target state="translated">나는 당신이 이것을 할 수있는 도서관을 썼습니다 :</target>
        </trans-unit>
        <trans-unit id="93e8f9e56c8391ff4d8114fdd92027090dcb5149" translate="yes" xml:space="preserve">
          <source>I'm iterating over a list of tuples in Python, and am attempting to remove them if they meet certain criteria.</source>
          <target state="translated">파이썬에서 튜플 목록을 반복하고 특정 기준을 충족하면 제거하려고합니다.</target>
        </trans-unit>
        <trans-unit id="40067d779a3f3245e65a2ab2e94f2fec69eb4c56" translate="yes" xml:space="preserve">
          <source>If we want to access the current index value of the list we cannot use enumerate, as this only counts how many times the for loop has run. Instead we will use the iterator object directly.</source>
          <target state="translated">목록의 현재 인덱스 값에 액세스하려면 열거를 사용할 수 없습니다. 이는 for 루프가 몇 번이나 실행되었는지를 계산하기 때문입니다. 대신 반복자 객체를 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7baf994253e5422333a06fc8988fe24496aaf2a2" translate="yes" xml:space="preserve">
          <source>If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy. The slice notation makes this especially convenient:</source>
          <target state="translated">루프 내에서 반복하는 시퀀스를 수정해야하는 경우 (예 : 선택한 항목 복제) 먼저 복사하는 것이 좋습니다. 시퀀스를 반복해도 암시 적으로 복사되지 않습니다. 슬라이스 표기법은 이것을 특히 편리하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d87b562086fac008b600e2b8d4a9b5150a639c97" translate="yes" xml:space="preserve">
          <source>If you want to delete elements from a list while iterating, use a while-loop so you can alter the current index and end index after each deletion.</source>
          <target state="translated">반복하는 동안 목록에서 요소를 삭제하려면 while 루프를 사용하여 각 삭제 후 현재 색인 및 종료 색인을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da17f6befdc523de38569c671e0632dd8feef1a1" translate="yes" xml:space="preserve">
          <source>If you want to do anything else during the iteration, it may be nice to get both the index (which guarantees you being able to reference it, for example if you have a list of dicts) and the actual list item contents.</source>
          <target state="translated">반복 중에 다른 작업을 수행하려는 경우 인덱스 (예 : dict 목록이있는 경우 색인을 참조 할 수 있음)와 실제 목록 항목 컨텐츠를 모두 얻는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a9b71d2114bfedf22c95c100902b07fb9eda5c92" translate="yes" xml:space="preserve">
          <source>If you will use the new list later, you can simply set the elem to None, and then judge it in the later loop, like this</source>
          <target state="translated">나중에 새 목록을 사용할 경우 elem을 없음으로 설정 한 후 다음과 같이 나중에 루프에서 판단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cff757980d44c8978d107712bbd9c8346debf46a" translate="yes" xml:space="preserve">
          <source>In cases where you're doing something more complex than calling a &lt;code&gt;determine&lt;/code&gt; function, I prefer constructing a new list and simply appending to it as I go.  For example</source>
          <target state="translated">&lt;code&gt;determine&lt;/code&gt; 함수를 호출하는 것보다 복잡한 작업을 수행하는 경우 새 목록을 작성하고 단순히 추가 할 때 추가하는 것이 좋습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="245dc2132cc9d15cb2653900c35e1e34efd80517" translate="yes" xml:space="preserve">
          <source>In some situations, where you're doing more than simply filtering a list one item at time, you want your iteration to change while iterating.</source>
          <target state="translated">한 번에 한 항목 씩 목록을 필터링하는 것 이상의 작업을 수행하는 경우에는 반복하는 동안 반복이 변경되기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="25a3509e025bfbab60c4594a7314dfe96eee8d5a" translate="yes" xml:space="preserve">
          <source>In this way, you dont't need copy the list and it's easier to understand.</source>
          <target state="translated">이런 식으로 목록을 복사 할 필요가 없으며 이해하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="125406bb8e98603cdb6cb34508b6a4174012d403" translate="yes" xml:space="preserve">
          <source>Instead of a comprehension, you could also use &lt;code&gt;itertools&lt;/code&gt;. In Python 2:</source>
          <target state="translated">이해하는 대신 &lt;code&gt;itertools&lt;/code&gt; 를 사용할 수도 있습니다. 파이썬 2에서 :</target>
        </trans-unit>
        <trans-unit id="f56af88d3f92e6edf9b095e4969fca472d8ed69b" translate="yes" xml:space="preserve">
          <source>It might be smart to also just create a new list if the current list item meets the desired criteria.</source>
          <target state="translated">현재 목록 항목이 원하는 기준을 충족하는 경우 새 목록을 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="55998da221cafd68f95026750947ab3d3b827cb2" translate="yes" xml:space="preserve">
          <source>It seems like this particular Python API could be improved. Compare it, for instance, with:</source>
          <target state="translated">이 특정 Python API가 개선 될 수있는 것 같습니다. 예를 들어 다음과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="046f43ead4620ec5bc9285795e2a5ebcbbd51ae9" translate="yes" xml:space="preserve">
          <source>It's best to use another method if possible that doesn't require modifying your iterable while iterating over it, but for some algorithms it might not be that straight forward. And so if you are sure that you really do want the code pattern described in the original question, it is possible.</source>
          <target state="translated">가능하면 반복 가능한 동안 iterable을 수정하지 않아도되는 다른 방법을 사용하는 것이 가장 좋지만 일부 알고리즘의 경우에는 그다지 간단하지 않을 수 있습니다. 따라서 원래 질문에 설명 된 코드 패턴을 정말로 원한다면 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87de0493fb3d04591d84b9514a64a8b1b2433ae" translate="yes" xml:space="preserve">
          <source>Java &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html&quot;&gt;ListIterator::remove&lt;/a&gt; which documents &quot;This call can only be made once per call to next or previous&quot;</source>
          <target state="translated">Java &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html&quot;&gt;ListIterator :: 다음&lt;/a&gt; 중 어느 문서를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="b8f5fc225cfb3362fa3e16aaa8090b08eeb8d9d7" translate="yes" xml:space="preserve">
          <source>Let's run through what happens when we execute your code:</source>
          <target state="translated">코드를 실행할 때 발생하는 작업을 살펴 ​​보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f8a9a21683177e7cde4a5592c377a6e74a389d1e" translate="yes" xml:space="preserve">
          <source>List comprehensions provide a way to generate a new list but these approaches tend to look at each element in isolation rather than the current state of the list as a whole.</source>
          <target state="translated">리스트 이해는 새로운리스트를 생성하는 방법을 제공하지만, 이러한 접근법은리스트의 현재 상태가 아닌 개별적으로 각 요소를 보는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2e359d0150a691e0d84043306b8fdd090ce18d0" translate="yes" xml:space="preserve">
          <source>More examples / tests can be found in the &lt;code&gt;if __name__ is &quot;__main__&quot;:&lt;/code&gt; section at the bottom of &lt;code&gt;fluidIter.py&lt;/code&gt;. These are worth looking at because they explain what happens in various situations. Such as: Replacing a large sections of the list using a slice. Or using (and modifying) the same iterable in nested for loops.</source>
          <target state="translated">더 많은 예제 / 테스트는 &lt;code&gt;if __name__ is &quot;__main__&quot;:&lt;/code&gt; &lt;code&gt;fluidIter.py&lt;/code&gt; 의 맨 아래에있는 섹션에서 찾을 수 있습니다. 이것들은 다양한 상황에서 일어나는 일을 설명하기 때문에 가치가 있습니다. 예 : 슬라이스를 사용하여 목록의 큰 섹션 교체 또는 중첩 된 for 루프에서 동일한 iterable을 사용하고 수정합니다.</target>
        </trans-unit>
        <trans-unit id="da2749c0165cf2060c3dbe8c050ade5cfc962757" translate="yes" xml:space="preserve">
          <source>Most of the answers here want you to create a copy of the list. I had a use case where the list was quite long (110K items) and it was smarter to keep reducing the list instead.</source>
          <target state="translated">여기에있는 대부분의 답변은 목록의 사본을 작성하기를 원합니다. 나는 목록이 꽤 길었던 유스 케이스 (110K 항목)를 가지고 있었고 대신 목록을 계속 줄이는 것이 더 똑똑했습니다.</target>
        </trans-unit>
        <trans-unit id="c80f5de1207f487c252821cc6bb7b9fc8eccb956" translate="yes" xml:space="preserve">
          <source>Note the subtle difference with other answers: this one is NOT assigning to a barename - it's assigning to a list slice that just happens to be the entire list, thereby replacing the list &lt;em&gt;contents&lt;/em&gt;&lt;strong&gt;within the same Python list object&lt;/strong&gt;, rather than just reseating one reference (from previous list object to new list object) like the other answers.</source>
          <target state="translated">다른 답변과의 미묘한 차이점에 주목하십시오.이 이름은 베어 이름에 할당되지 않습니다. 목록 전체에 발생하는 목록 조각에 할당되므로 하나의 참조를 다시 가져 &lt;strong&gt;오는&lt;/strong&gt; 대신 &lt;strong&gt;동일한 Python 목록 객체 내에서&lt;/strong&gt; 목록 &lt;em&gt;내용&lt;/em&gt; 을 대체합니다. 다른 답변과 같이 (이전 목록 객체에서 새 목록 객체로).</target>
        </trans-unit>
        <trans-unit id="b2ac388e56496c2c3c957f43d877dd1d7fda2c8a" translate="yes" xml:space="preserve">
          <source>Note: There is a subtlety when the sequence is being modified by the loop (this can only occur for mutable sequences, i.e. lists). An internal counter is used to keep track of which item is used next, and this is incremented on each iteration. When this counter has reached the length of the sequence the loop terminates. This means that if the suite deletes the current (or a previous) item from the sequence, the next item will be skipped (since it gets the index of the current item which has already been treated). Likewise, if the suite inserts an item in the sequence before the current item, the current item will be treated again the next time through the loop. This can lead to nasty bugs that can be avoided by making a temporary copy using a slice of the whole sequence, e.g.,</source>
          <target state="translated">참고 : 루프에 의해 시퀀스가 ​​수정 될 때 미묘한 부분이 있습니다 (이는 변경 가능한 시퀀스, 즉 목록에 대해서만 발생할 수 있음). 내부 카운터는 다음에 어떤 항목이 사용되는지 추적하는 데 사용되며 각 반복마다 증가합니다. 이 카운터가 시퀀스 길이에 도달하면 루프가 종료됩니다. 즉, 스위트가 시퀀스에서 현재 (또는 이전) 항목을 삭제하면 다음 항목은 건너 뜁니다 (이미 처리 된 현재 항목의 색인을 가져 오기 때문에). 마찬가지로 스위트가 현재 항목 앞에 순서대로 항목을 삽입하면 다음에 루프를 통해 현재 항목이 다시 처리됩니다. 이로 인해 전체 시퀀스 조각을 사용하여 임시 복사본을 만들어 피할 수있는 불쾌한 버그가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17fc589ddf453f77430cdfb24061a48d22055a0b" translate="yes" xml:space="preserve">
          <source>One possible solution, useful if you want not only remove some things, but also do something with all elements in a single loop:</source>
          <target state="translated">하나의 가능한 해결책은 일부를 제거 할뿐만 아니라 단일 루프에서 모든 요소로 무언가를 수행하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9989cc03f8130b33e38ebbe097e363902bb2ab71" translate="yes" xml:space="preserve">
          <source>Or in Python 3:</source>
          <target state="translated">또는 파이썬 3에서 :</target>
        </trans-unit>
        <trans-unit id="360486488323ae5b9c4a62711e3b574d44955347" translate="yes" xml:space="preserve">
          <source>Or, by assigning to the slice &lt;code&gt;somelist[:]&lt;/code&gt;, you can mutate the existing list to contain only the items you want:</source>
          <target state="translated">또는 슬라이스 &lt;code&gt;somelist[:]&lt;/code&gt; 에 할당하여 기존 항목을 변경하여 원하는 항목 만 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79e5e39f10693e0d3d7f9bbd6e8a79ae8f411a56" translate="yes" xml:space="preserve">
          <source>Perhaps the underlying rationale is that Python lists are assumed to be dynamic array backed, and therefore any type of removal will be time inefficient anyways, while Java has a nicer interface hierarchy with both &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;ListIterator&lt;/code&gt;.</source>
          <target state="translated">아마도 기본 이론적 근거는 파이썬 목록이 동적 배열을 지원한다고 가정하기 때문에 어쨌든 모든 유형의 제거는 시간이 비효율적이며 Java는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt; 및 LinkedList 구현을 통해 더 나은 인터페이스 계층 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0ea5407d1e5d315fb9f7357791702e7406ce3cfa" translate="yes" xml:space="preserve">
          <source>Problem is you removed a value from a list during iteration then your list index will collapse.</source>
          <target state="translated">문제는 반복하는 동안 목록에서 값을 제거하면 목록 색인이 축소되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a12a2e961432337248947c29211654dd9db80cac" translate="yes" xml:space="preserve">
          <source>Python 2 users: replace &lt;code&gt;range&lt;/code&gt; by &lt;code&gt;xrange&lt;/code&gt; to avoid creating a hardcoded list</source>
          <target state="translated">Python 2 사용자 : 하드 코딩 된 목록을 생성하지 않도록 &lt;code&gt;range&lt;/code&gt; 를 &lt;code&gt;xrange&lt;/code&gt; 로 대체</target>
        </trans-unit>
        <trans-unit id="48bce7473e48f3146f9e6a87451c0a6b7a287a30" translate="yes" xml:space="preserve">
          <source>Should work on all mutable sequences not just lists.</source>
          <target state="translated">목록뿐만 아니라 모든 가변 시퀀스에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d69dabce4725955fd5cfe5474202e42df310b5ad" translate="yes" xml:space="preserve">
          <source>TLDR:</source>
          <target state="translated">TLDR:</target>
        </trans-unit>
        <trans-unit id="152d20f48429364f6ffc8bed8d7c4ab140cd6e27" translate="yes" xml:space="preserve">
          <source>That should be significantly faster than anything else.</source>
          <target state="translated">다른 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="270175c65f9ab178c1fec6d7dd95d939a77fd791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FluidIterable&lt;/code&gt; class just provides a wrapper for the original list object. The original object can be accessed as a property of the fluid object like so:</source>
          <target state="translated">&lt;code&gt;FluidIterable&lt;/code&gt; 클래스는 원래 목록 객체에 대한 래퍼를 제공합니다. 원본 객체는 다음과 같이 유동 객체의 속성으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cfb5094c7c78cca9a3962e635d233764ced9056" translate="yes" xml:space="preserve">
          <source>The answers suggesting list comprehensions are ALMOST correct -- except that they build a completely new list and then give it the same name the old list as, they do NOT modify the old list in place. That's different from what you'd be doing by selective removal, as in &lt;a href=&quot;https://stackoverflow.com/a/1207427/3064538&quot;&gt;@Lennart's suggestion&lt;/a&gt; -- it's faster, but if your list is accessed via multiple references the fact that you're just reseating one of the references and NOT altering the list object itself can lead to subtle, disastrous bugs.</source>
          <target state="translated">목록 이해를 제안하는 답변은 완전히 정확합니다. 단지 완전히 새로운 목록을 작성한 다음 이전 목록과 동일한 이름을 지정하면 이전 목록을 수정하지 않습니다. &lt;a href=&quot;https://stackoverflow.com/a/1207427/3064538&quot;&gt;@Lennart의 제안&lt;/a&gt; 에서와 같이 선택적 제거로 수행하는 것과는 다릅니다. 더 빠르지 만 여러 참조를 통해 목록에 액세스하면 참조 중 하나만 다시하고 목록 객체를 변경하지 않는다는 사실 그 자체는 미묘하고 비참한 버그로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5191c36b79d049087e12a7d61cc7919fff9ceeaf" translate="yes" xml:space="preserve">
          <source>The code below is one example of an algorithm that suffers from the above problem. The algorithm will reduce a list so that no element is a multiple of any other element.</source>
          <target state="translated">아래 코드는 위의 문제가 발생하는 알고리즘의 한 예입니다. 이 알고리즘은 어떤 요소도 다른 요소의 배수가되지 않도록 목록을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="1dd15e2a02b9bd225a28fb73bd761fec970d34a4" translate="yes" xml:space="preserve">
          <source>The first problem is that you are passing both 'a' and 'b' to remove(), but remove() only accepts a single argument. So how can we get remove() to work properly with your list? We need to figure out what each element of your list is. In this case, each one is a tuple. To see this, let's access one element of the list (indexing starts at 0):</source>
          <target state="translated">첫 번째 문제는 remove ()에 'a'와 'b'를 모두 전달하지만 remove ()는 단일 인수 만 허용한다는 것입니다. 그렇다면 목록에서 제대로 작동하도록 remove ()를 어떻게 얻을 수 있습니까? 리스트의 각 요소가 무엇인지 파악해야합니다. 이 경우, 각각은 튜플입니다. 이를 확인하려면 목록의 한 요소에 액세스하십시오 (인덱싱은 0에서 시작).</target>
        </trans-unit>
        <trans-unit id="03c421e2f742eb0a3f0b40bf613c9d58c162b963" translate="yes" xml:space="preserve">
          <source>The most effective method is list comprehension, many people show their case, of course, it is also a good way to get an &lt;code&gt;iterator&lt;/code&gt; through &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">가장 효과적인 방법은 목록 이해이며 많은 사람들이 자신의 사례를 보여줍니다. 물론 &lt;code&gt;filter&lt;/code&gt; 통해 &lt;code&gt;iterator&lt;/code&gt; 를 얻는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="82e722be14da8e292e19c55197fc9f40afbc622f" translate="yes" xml:space="preserve">
          <source>The most intuitive solution is to copy the list, then iterate over the original list and only modify the copy. You can try doing so like this:</source>
          <target state="translated">가장 직관적 인 해결책은 목록을 복사 한 다음 원본 목록을 반복하고 사본 만 수정하는 것입니다. 다음과 같이 해보십시오.</target>
        </trans-unit>
        <trans-unit id="218e1c2432d3d651eb5aa8d840e5878a648c2f64" translate="yes" xml:space="preserve">
          <source>The only condition is that you must only modify the list in place, if at any point &lt;code&gt;fluidL&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt; were reassigned to a different list object the code would not work. The original &lt;code&gt;fluidL&lt;/code&gt; object would still be used by the for loop but would become out of scope for us to modify.</source>
          <target state="translated">유일한 조건은, 어떤 시점에서 &lt;code&gt;fluidL&lt;/code&gt; 또는 &lt;code&gt;l&lt;/code&gt; 이 다른 목록 객체에 재 할당 된 경우 코드가 작동하지 않을 경우에만 목록을 수정해야한다는 것입니다. 원래 &lt;code&gt;fluidL&lt;/code&gt; 객체는 여전히 for 루프에 의해 사용 되나 우리가 수정할 수있는 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="0232391e9ed0b3f4e1884c82ce7b756054004e76" translate="yes" xml:space="preserve">
          <source>The other answers are correct that it is usually a bad idea to delete from a list that you're iterating. Reverse iterating avoids the pitfalls, but it is much more difficult to follow code that does that, so usually you're better off using a list comprehension or &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">다른 답변은 일반적으로 반복하는 목록에서 삭제하는 것이 좋지 않다는 것이 맞습니다. 역 반복은 함정을 피하지만 코드를 따르는 것은 훨씬 어렵 기 때문에 일반적으로 목록 이해 또는 &lt;code&gt;filter&lt;/code&gt; 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d83b85da1737342dd5460982dd9c13f4ec834959" translate="yes" xml:space="preserve">
          <source>The output and the final reduced list are shown below</source>
          <target state="translated">출력 및 최종 축소 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f7fb1a9757b6b77ad3c9a0db78e51afbee729bf" translate="yes" xml:space="preserve">
          <source>The solution follows on from &lt;a href=&quot;https://stackoverflow.com/a/6260097/4451578&quot;&gt;this&lt;/a&gt; answer (for a related question) from senderle. Which explains how the the array index is updated while iterating through a list that has been modified. The solution below is designed to correctly track the array index even if the list is modified.</source>
          <target state="translated">해결책은 senderle &lt;a href=&quot;https://stackoverflow.com/a/6260097/4451578&quot;&gt;의이&lt;/a&gt; 답변 (관련 질문에 대한)에서 따릅니다. 배열 목록이 수정 된 목록을 반복하면서 업데이트되는 방법을 설명합니다. 아래 솔루션은 목록이 수정 된 경우에도 배열 인덱스를 올바르게 추적하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2551885fd9f082f01224604f6182eec3c30229ae" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;i&lt;/code&gt; is not changed in the if block because you'll want to get value of the new item FROM THE SAME INDEX, once the old item is deleted.</source>
          <target state="translated">이전 항목이 삭제되면 동일한 색인에서 새 항목의 값을 얻으려고하기 때문에 &lt;code&gt;i&lt;/code&gt; 블록의 값은 if 블록에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7562a2c2dc431ee3d16ebf6cd88cf92dd3094ad" translate="yes" xml:space="preserve">
          <source>There are two problems in your code:</source>
          <target state="translated">코드에는 두 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a99f253b2b161ab64e883f8d5fbc4dedcf4f028" translate="yes" xml:space="preserve">
          <source>There doesn't seem to be an explicit linked list type in the Python stdlib either: &lt;a href=&quot;https://stackoverflow.com/questions/280243/python-linked-list/280286&quot;&gt;Python Linked List&lt;/a&gt;</source>
          <target state="translated">파이썬 stdlib에는 명시 적으로 링크 된 목록 유형이없는 것 같습니다 : &lt;a href=&quot;https://stackoverflow.com/questions/280243/python-linked-list/280286&quot;&gt;Python Linked List&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e347b0acd45b91cadf43f2803affd98ff60eebb" translate="yes" xml:space="preserve">
          <source>There is an example  (get the odds in the tuple):</source>
          <target state="translated">예가 있습니다 (튜플에서 확률을 얻으십시오).</target>
        </trans-unit>
        <trans-unit id="55432bab27968e16616ffe608379fb64757d1359" translate="yes" xml:space="preserve">
          <source>There is, however, one case where it is safe to remove elements from a sequence that you are iterating: if you're only removing one item while you're iterating. This can be ensured using a &lt;code&gt;return&lt;/code&gt; or a &lt;code&gt;break&lt;/code&gt;. For example:</source>
          <target state="translated">그러나 반복하는 시퀀스에서 요소를 제거하는 것이 안전한 경우가 있습니다. 반복하는 동안 하나의 항목 만 제거하는 경우입니다. 이것은 &lt;code&gt;return&lt;/code&gt; 또는 &lt;code&gt;break&lt;/code&gt; 사용하여 보장 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bce386bfd881c91ca88506633592e0f9e08efc1" translate="yes" xml:space="preserve">
          <source>This answer was originally written in response to a question which has since been marked as duplicate:
&lt;a href=&quot;https://stackoverflow.com/questions/40175149/removing-coordinates-from-list-on-python&quot;&gt;Removing coordinates from list on python&lt;/a&gt;</source>
          <target state="translated">이 답변은 원래 중복으로 표시 된 질문에 대한 답변으로 작성되었습니다 .python의 &lt;a href=&quot;https://stackoverflow.com/questions/40175149/removing-coordinates-from-list-on-python&quot;&gt;목록에서 좌표 제거&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e7f8dab783005add34279bd95b8e79966d3770f" translate="yes" xml:space="preserve">
          <source>This approach could be useful if there are other references to &lt;code&gt;somelist&lt;/code&gt; that need to reflect the changes.</source>
          <target state="translated">이 접근 방식은 변경 사항을 반영해야하는 &lt;code&gt;somelist&lt;/code&gt; 에 대한 다른 참조가있는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d30f448b4b0f64b3cc1bd7c5a8e371250849c4a4" translate="yes" xml:space="preserve">
          <source>This code runs without any error, but let's look at the list it outputs:</source>
          <target state="translated">이 코드는 오류없이 실행되지만 출력되는 목록을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e6775b34984f46006cc69465d54fe83b78053739" translate="yes" xml:space="preserve">
          <source>This is because when we created L2, python did not actually create a new object. Instead, it merely referenced L2 to the same object as L1. We can verify this with 'is' which is different from merely &quot;equals&quot; (==).</source>
          <target state="translated">L2를 만들 때 파이썬이 실제로 새 객체를 만들지 않았기 때문입니다. 대신 L2를 L1과 동일한 객체로 참조했습니다. 단순히 &quot;같음&quot;(==)과 다른 'is'로이를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e26fd0b44d14a076fccd9b06568c15d5d11763c" translate="yes" xml:space="preserve">
          <source>This is more space efficient since it dispenses the array copy, but it is less time efficient because CPython lists &lt;a href=&quot;https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented&quot;&gt;are implemented with dynamic arrays&lt;/a&gt;.</source>
          <target state="translated">이는 배열 사본을 분배하므로 공간 효율적이지만 CPython 목록 &lt;a href=&quot;https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented&quot;&gt;이 동적 배열로 구현&lt;/a&gt; 되므로 시간이 덜 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="167c700ccc2cf194c88b1e29817f0e5473200686" translate="yes" xml:space="preserve">
          <source>This is often easier to understand than a list comprehension when you're doing some operations with side effects on the first item in a list that meets some condition and then removing that item from the list immediately after.</source>
          <target state="translated">어떤 조건을 충족하는 목록의 첫 번째 항목에 부작용이있는 작업을 수행 한 다음 목록에서 즉시 해당 항목을 제거 할 때 목록 이해보다 이해하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="9e832ffbc7b8159e0dacf897dec246a0c433e2de" translate="yes" xml:space="preserve">
          <source>This means that item removal requires shifting all following items back by one, which is O(N).</source>
          <target state="translated">즉, 항목을 제거하려면 모든 다음 항목을 하나씩 뒤로 이동해야합니다 (O (N)).</target>
        </trans-unit>
        <trans-unit id="6d3f755498b86d4d64c1f495ead2913089f82af0" translate="yes" xml:space="preserve">
          <source>This part of the docs makes it clear that:</source>
          <target state="translated">문서 의이 부분은 다음을 분명히합니다.</target>
        </trans-unit>
        <trans-unit id="4dfe1b1a882c87ca174edca828cf5ca59cfa1421" translate="yes" xml:space="preserve">
          <source>This part of the docs says once again that you have to make a copy, and gives an actual removal example:</source>
          <target state="translated">문서 의이 부분은 다시 한 번 복사해야한다고 말하고 실제 제거 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="23a9c4672ae391fc627eba417316401219f51f2f" translate="yes" xml:space="preserve">
          <source>This time efficient, but less space efficient because it keeps a copy of the array around during iteration.</source>
          <target state="translated">이 시간은 효율적이지만 반복하는 동안 어레이의 사본을 유지하기 때문에 공간이 덜 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="526b1bb0411da1ec481ceb845008bac5dfa4b12c" translate="yes" xml:space="preserve">
          <source>This way the index is aligned and doesn't suffer from the list updates (regardless whether you pop cur element or not).</source>
          <target state="translated">이렇게하면 인덱스가 정렬되고 목록 요소가 발생하지 않더라도 목록 업데이트가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">이것은 다음을 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="f906bf0437d1189835cd8ddcd60d8f965fa2c44a" translate="yes" xml:space="preserve">
          <source>This will produce the following output:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de0da919165bd723f966b10f2b6d39bef73fe836" translate="yes" xml:space="preserve">
          <source>Unfortunately, I cannot adequately describe how reversed() works. It returns a 'listreverseiterator' object when a list is passed to it. For practical purposes, you can think of it as creating a reversed copy of its argument. This is the solution I recommend.</source>
          <target state="translated">불행히도 reversed () 작동 방식을 적절하게 설명 할 수 없습니다. 리스트가 전달 될 때 'listreverseiterator'오브젝트를 리턴합니다. 실용적인 목적으로, 당신은 그것의 주장의 역전 된 사본을 만드는 것으로 생각할 수 있습니다. 이것이 내가 권장하는 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="8b2d2221789d986c7ae56d80c76907b6412db859" translate="yes" xml:space="preserve">
          <source>We can make a true copy using copy.copy(). Then everything works as expected:</source>
          <target state="translated">copy.copy ()를 사용하여 실제 복사본을 만들 수 있습니다. 그런 다음 모든 것이 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="23784d9f68162c9269e0a23fd4ac91e3cbbffbaa" translate="yes" xml:space="preserve">
          <source>What I don't know is how efficient a couple of deletes are compared to copying a large list. Please comment if you have any insight.</source>
          <target state="translated">내가 모르는 것은 큰 목록을 복사하는 것보다 몇 번의 삭제가 얼마나 효율적인지입니다. 통찰력이 있으면 의견을 말하십시오.</target>
        </trans-unit>
        <trans-unit id="b617b1edd0d3f10931aa29fbdeee51bf2c7348cc" translate="yes" xml:space="preserve">
          <source>What should I use in place of &lt;code&gt;code_to_remove_tup&lt;/code&gt;? I can't figure out how to remove the item in this fashion.</source>
          <target state="translated">&lt;code&gt;code_to_remove_tup&lt;/code&gt; 대신 무엇을 사용해야합니까? 이 방식으로 항목을 제거하는 방법을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="943d5a56f866fd2745375a8579ced2fc5bc9d4aa" translate="yes" xml:space="preserve">
          <source>Why is (1,-2) still in your list? It turns out modifying the list while using a loop to iterate over it is a very bad idea without special care. The reason that (1, -2) remains in the list is that the locations of each item within the list changed between iterations of the for loop. Let's look at what happens if we feed the above code a longer list:</source>
          <target state="translated">왜 (1, -2)가 여전히 목록에 있습니까? 루프를 사용하여 목록을 반복하는 동안 목록을 수정하는 것은 특별한주의없이 매우 나쁜 생각입니다. (1, -2)가 목록에 남아있는 이유는 목록 내의 각 항목의 위치가 for 루프의 반복 사이에서 변경 되었기 때문입니다. 위의 코드에 더 긴 목록을 제공하면 어떻게되는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="cba5525fdc4b748be86f6f7a8d4839e16d248545" translate="yes" xml:space="preserve">
          <source>You can try for-looping in reverse so for some_list you'll do something like:</source>
          <target state="translated">for_looping을 반대로 시도하면 some_list에 대해 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fef932e24c895baf0179ccaa420e2bd7d0954340" translate="yes" xml:space="preserve">
          <source>You can use a list comprehension to create a new list containing only the elements you don't want to remove:</source>
          <target state="translated">목록 이해를 사용하여 제거하지 않으려는 요소 만 포함하는 새 목록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fe88cac7a8c1d65c953157de58c81088b07d23d" translate="yes" xml:space="preserve">
          <source>You might want to use &lt;code&gt;filter()&lt;/code&gt; available as the built-in.</source>
          <target state="translated">내장으로 사용 가능한 &lt;code&gt;filter()&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76db65aa7d7889fbb23154214040d2a4fa6894c1" translate="yes" xml:space="preserve">
          <source>You need to go backwards otherwise it's a bit like sawing off the tree-branch that you are sitting on :-)</source>
          <target state="translated">그렇지 않으면 거꾸로 가야합니다. 그렇지 않으면 앉아있는 나뭇 가지를 톱질하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80b0cf2331c96b3507f2cb33293c954612fab365" translate="yes" xml:space="preserve">
          <source>You need to take a copy of the list and iterate over it first, or the iteration will fail with what may be unexpected results.</source>
          <target state="translated">목록의 복사본을 가져 와서 먼저 반복해야합니다. 그렇지 않으면 예기치 않은 결과가 발생할 수 있으므로 반복이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="adfd09eef6d8d4afdd5310e5f03eb9a705d7ec94" translate="yes" xml:space="preserve">
          <source>Your best approach for such an example would be a &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;list comprehension&lt;/a&gt;</source>
          <target state="translated">이러한 예에 대한 가장 좋은 방법은 &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;목록 이해입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbc0aff80688baeb01a5a4cb720794fe808ad957" translate="yes" xml:space="preserve">
          <source>```</source>
          <target state="translated">```</target>
        </trans-unit>
        <trans-unit id="dfd3b60d353170b5585a8909968d17705c98f55e" translate="yes" xml:space="preserve">
          <source>and then &lt;strong&gt;next value (65)&lt;/strong&gt; move on to previous index.</source>
          <target state="translated">&lt;strong&gt;다음 값 (65)&lt;/strong&gt; 은 이전 색인으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="256773140eb61f1cd6dd994baf6076f0cbda5306" translate="yes" xml:space="preserve">
          <source>and to avoid having to re-code the entire project with the new lists name:</source>
          <target state="translated">새 목록 이름으로 전체 프로젝트를 다시 코딩하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="7c9ee5a07e5b78059e78b86ca4241fb482333081" translate="yes" xml:space="preserve">
          <source>both of which make it crystal clear that you cannot modify a list being iterated except with the iterator itself, and gives you efficient ways to do so without copying the list.</source>
          <target state="translated">두 가지 모두 반복자 자체를 제외하고 반복되는 목록을 수정할 수 없다는 것을 분명히하고 목록을 복사하지 않고 효율적인 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6d12700c2217a6fd0f4bff860dfcd30dd2761df6" translate="yes" xml:space="preserve">
          <source>consider you have a list,</source>
          <target state="translated">목록이 있다고 생각해</target>
        </trans-unit>
        <trans-unit id="877d45d55490879d4296a7fe796015d42f80527e" translate="yes" xml:space="preserve">
          <source>copy.copy(x) 
  Return a shallow copy of x.</source>
          <target state="translated">copy.copy (x) x의 얕은 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e379d3ba5b6ab3903a95b94fa0aad486fec92cef" translate="yes" xml:space="preserve">
          <source>copy.deepcopy(x) 
  Return a deep copy of x.</source>
          <target state="translated">copy.deepcopy (x) x의 깊은 사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b4c418dc9f6bec70118f7721079c58620f7e7c8" translate="yes" xml:space="preserve">
          <source>during 5th iteration,</source>
          <target state="translated">5 번 반복하는 동안</target>
        </trans-unit>
        <trans-unit id="fb5bc8bbd4a82ff3b60e90dcd93261b98bd06448" translate="yes" xml:space="preserve">
          <source>for loop will be iterate through index..</source>
          <target state="translated">for 루프는 인덱스를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="2c3a0ef6ef4316e6e5d1c614dce6be8faad1cb40" translate="yes" xml:space="preserve">
          <source>i.e.</source>
          <target state="translated">i.e.</target>
        </trans-unit>
        <trans-unit id="f9a405f5d71953928e26ce3b09f8a952c37a7815" translate="yes" xml:space="preserve">
          <source>note, from Python documentation:</source>
          <target state="translated">파이썬 문서에서 참고하십시오 :</target>
        </trans-unit>
        <trans-unit id="3c7aec3e12f7c3f23e559160305465cb5a2d42df" translate="yes" xml:space="preserve">
          <source>now you it will give,</source>
          <target state="translated">지금 당신은 그것을 줄 것이다</target>
        </trans-unit>
        <trans-unit id="952d109808fc70092cb9652c674259cd795c7282" translate="yes" xml:space="preserve">
          <source>one way to do it is with the slice notation &lt;code&gt;[:]&lt;/code&gt;</source>
          <target state="translated">한 가지 방법은 슬라이스 표기법을 사용하는 것입니다. &lt;code&gt;[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="9440205f7b297bb97378c8ee9cd6dd38026733b0" translate="yes" xml:space="preserve">
          <source>so 4th iteration done pointer moved onto 5th..</source>
          <target state="translated">그래서 네 번째 반복 완료 포인터가 다섯 번째로 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="32303bd0019c71856b3bd0ca577afa9b20a6f1d4" translate="yes" xml:space="preserve">
          <source>so do copy of list using &lt;code&gt;list[::]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;list[::]&lt;/code&gt; 사용하여 리스트를 복사하십시오 .</target>
        </trans-unit>
        <trans-unit id="b67a61431e78c0efef0f8344a3155b585fc957b6" translate="yes" xml:space="preserve">
          <source>so you can try comprehension instead.</source>
          <target state="translated">대신 이해력을 시험해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c56b5b45bd0c8acb29daa7a9f24462a60d123bd4" translate="yes" xml:space="preserve">
          <source>so you shouldn't reference list into another variable which still reference original instead of copy.</source>
          <target state="translated">따라서 복사 대신 원본을 여전히 참조하는 다른 변수로 목록을 참조해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="0b64514082f4dab14fe23e3dcbcb92cea9f748ba" translate="yes" xml:space="preserve">
          <source>start a new array from scratch, and &lt;code&gt;.append()&lt;/code&gt; back at the end: &lt;a href=&quot;https://stackoverflow.com/a/1207460/895245&quot;&gt;https://stackoverflow.com/a/1207460/895245&lt;/a&gt;</source>
          <target state="translated">처음부터 새 배열을 시작하고 &lt;code&gt;.append()&lt;/code&gt; 다시 시작하십시오. &lt;a href=&quot;https://stackoverflow.com/a/1207460/895245&quot;&gt;https://stackoverflow.com/a/1207460/895245&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0166462591b186a6ce777cfdce9d2d4e230d1977" translate="yes" xml:space="preserve">
          <source>thats why your loop doesnt cover 65 since its moved into previous index.</source>
          <target state="translated">그렇기 때문에 루프가 이전 인덱스로 이동 한 이후 루프가 65를 커버하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3c060051ec2702c90517f75bb0955c4fed00b1ad" translate="yes" xml:space="preserve">
          <source>uppose a list of number and you want to remove all no which are divisible by 3,</source>
          <target state="translated">숫자 목록을 세우고 3으로 나눌 수있는 모든 no를 제거하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c2c2f6b4aca96b4db1ec0779cbfab2e190a97931" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;del&lt;/code&gt; with an index: &lt;a href=&quot;https://stackoverflow.com/a/1207485/895245&quot;&gt;https://stackoverflow.com/a/1207485/895245&lt;/a&gt;</source>
          <target state="translated">색인과 함께 &lt;code&gt;del&lt;/code&gt; 을 사용 &lt;a href=&quot;https://stackoverflow.com/a/1207485/895245&quot;&gt;하십시오&lt;/a&gt; : https : //.com/a/1207485/895245</target>
        </trans-unit>
        <trans-unit id="c77354b6717d46ffe5ad4fcd2e94f33c21d88f30" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;lambda filter&lt;/code&gt; function, this will create resultant new list and consume memeory space</source>
          <target state="translated">&lt;code&gt;lambda filter&lt;/code&gt; 기능을 사용하면 결과적으로 새로운 목록이 생성되고 memeory 공간이 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="b1c7e2bae9e038687eb2d3cce815acc3dcac458c" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;list comprehension&lt;/code&gt;,this will careate a new list and create new memory space</source>
          <target state="translated">&lt;code&gt;list comprehension&lt;/code&gt; 사용하면 새 목록을 관리하고 새 메모리 공간을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5c3c89eedc5f3e318d8c78de0dae591b09b494ef" translate="yes" xml:space="preserve">
          <source>which supports all the iterable like, list, tuple, dict, string etc</source>
          <target state="translated">목록, 튜플, dict, 문자열 등과 같은 모든 반복 가능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c9ac37e61a632309fe6ac352cebdb1140b02c11f" translate="yes" xml:space="preserve">
          <source>without consuming memory space for new list and modify existing list</source>
          <target state="translated">새 목록을위한 메모리 공간을 소비하지 않고 기존 목록을 수정</target>
        </trans-unit>
        <trans-unit id="e6eb9174b0a0f9124941d34b2c9c2b9375d4cb20" translate="yes" xml:space="preserve">
          <source>you have using list variable called &lt;code&gt;lis&lt;/code&gt;. and you using same to remove..</source>
          <target state="translated">&lt;code&gt;lis&lt;/code&gt; 라는 목록 변수를 사용하고 있습니다. 같은 것을 사용하여 제거합니다 ..</target>
        </trans-unit>
        <trans-unit id="f4735f130b7506791a866079cea171cee93ee923" translate="yes" xml:space="preserve">
          <source>you need to make a copy of the iterated list to modify it</source>
          <target state="translated">반복 목록을 복사하여 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c0c41a37eef8bb146367129bb2695642d431ffa" translate="yes" xml:space="preserve">
          <source>your &lt;strong&gt;number 35&lt;/strong&gt; was not a prime so you removed it from a list.</source>
          <target state="translated">&lt;strong&gt;35&lt;/strong&gt; 번은 소수가 아니므로 목록에서 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="c3e100f0c1beaa3886a138699e84f88bf0090a45" translate="yes" xml:space="preserve">
          <source>your variable</source>
          <target state="translated">당신의 변수</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
