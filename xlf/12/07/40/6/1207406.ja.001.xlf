<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1207406">
    <body>
      <group id="1207406">
        <trans-unit id="3b2c92f73dff63b7b88c756e8c6c4ea763db1c81" translate="yes" xml:space="preserve">
          <source>1) When using remove(), you attempt to remove integers whereas you need to remove a tuple.</source>
          <target state="translated">1)remove()を使用する場合、タプルを削除する必要があるのに対し、整数を削除しようとします。</target>
        </trans-unit>
        <trans-unit id="c26bec6ae55dfa38b757d819eb9fa58107cda58b" translate="yes" xml:space="preserve">
          <source>2) The for loop will skip items in your list.</source>
          <target state="translated">2)forループはリストの項目をスキップします。</target>
        </trans-unit>
        <trans-unit id="41f1f874fa2b979825cd5672d52c9f672bb63674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Filter&lt;/code&gt; receives a function and a sequence. &lt;code&gt;Filter&lt;/code&gt; applies the passed function to each element in turn, and then decides whether to retain or discard the element depending on whether the function return value is &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filter&lt;/code&gt; は関数とシーケンスを受け取ります。 &lt;code&gt;Filter&lt;/code&gt; は渡された関数を各要素に順番に適用し、関数の戻り値が &lt;code&gt;True&lt;/code&gt; か &lt;code&gt;False&lt;/code&gt; かによって、要素を保持するか破棄するかを決定します。</target>
        </trans-unit>
        <trans-unit id="1f7e48e862214b7809d0460c5e1af926208bd696" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enumerate&lt;/code&gt; gives you access to the item and the index at once. &lt;code&gt;reversed&lt;/code&gt; is so that the indices that you're going to later delete don't change on you.</source>
          <target state="translated">&lt;code&gt;enumerate&lt;/code&gt; は、アイテムとインデックスに一度にアクセスできるようにします。 &lt;code&gt;reversed&lt;/code&gt; にすると、後で削除するインデックスが変更されません。</target>
        </trans-unit>
        <trans-unit id="4de7ada0839383f54f19d7f396d39fb507f52e99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What I have chosen is a randomly chosen example. &lt;strong&gt;Feel free to change&lt;/strong&gt; the &lt;strong&gt;list of tuples&lt;/strong&gt; and the &lt;strong&gt;condition&lt;/strong&gt; that I have chosen.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;私が選んだのは、ランダムに選ばれた例です。&lt;/em&gt; &lt;em&gt;&lt;strong&gt;タプル&lt;/strong&gt;の&lt;strong&gt;リストと&lt;/strong&gt;選択した&lt;strong&gt;条件&lt;/strong&gt;を&lt;strong&gt;自由に変更し&lt;/strong&gt;て&lt;strong&gt;ください&lt;/strong&gt; 。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41cfd101eef50f2ce2c163096a74fa93f38da56b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best workarounds&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最善の回避策&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccd82364b395036f5280ff13da623f258d9644df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution: You can also not handle iterators. Iterators are sometimes better than sequences.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注意：イテレータを処理することもできません。&lt;/strong&gt; &lt;strong&gt;イテレータはシーケンスよりも優れている場合があります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81b8bc03967964ba1eea500b2bc7787b4b23c68e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Could Python do this better?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pythonはこれをもっとうまくできるでしょうか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="788e3773d2b7d304ae70795cc020d884336ac974" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1 and method 2 are faster than method 3&lt;/strong&gt;. Method2 and method3 are more efficient than method1. I &lt;strong&gt;prefer method2&lt;/strong&gt;. For the aforementioned example, &lt;code&gt;time(method1) : time(method2) : time(method3) = 1 : 1 : 1.7&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;方法1と方法2は方法3よりも高速です&lt;/strong&gt; 。 Method2とmethod3はmethod1よりも効率的です。 私は&lt;strong&gt;method2&lt;/strong&gt;を&lt;strong&gt;好みます&lt;/strong&gt; 。 前述の例の場合、 &lt;code&gt;time(method1) : time(method2) : time(method3) = 1 : 1 : 1.7&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6dcc3dfb40a81d59ef252bee9510d3a8af5cdc6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1.&amp;gt;&lt;/strong&gt; Use the framework that you had suggested (where one fills in a code inside a for loop). I use a small code with &lt;code&gt;del&lt;/code&gt; to delete a tuple that meets the said condition. However, this method will miss a tuple (which satisfies the said condition) if two consecutively placed tuples meet the given condition.</source>
          <target state="translated">&lt;strong&gt;方法1.&amp;gt;&lt;/strong&gt;提案したフレームワークを使用します（forループ内のコードを埋めます）。 &lt;code&gt;del&lt;/code&gt; で小さなコードを使用して、上記の条件を満たすタプルを削除します。 ただし、このメソッドは、2つの連続して配置されたタプルが指定された条件を満たす場合、（上記の条件を満たす）タプルを見落とします。</target>
        </trans-unit>
        <trans-unit id="8a87ff388a2cd2a3b0c5940103c76fd9ebd422c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 2.&amp;gt;&lt;/strong&gt; Construct a new list which contains elements (tuples) where the given condition is not met (this is the same thing as removing elements of list where the given condition is met). Following is the code for that:</source>
          <target state="translated">&lt;strong&gt;方法2.&amp;gt;&lt;/strong&gt;指定された条件が満たされていない要素（タプル）を含む新しいリストを作成します（これは、指定された条件が満たされたリストの要素を削除するのと同じことです）。 以下はそのためのコードです：</target>
        </trans-unit>
        <trans-unit id="63bda6e7a91b63c3a620d3c5e06adb18cc1e0fc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 3.&amp;gt;&lt;/strong&gt; Find indices where the given condition is met, and then use remove elements (tuples) corresponding to those indices. Following is the code for that.</source>
          <target state="translated">&lt;strong&gt;方法3.&amp;gt;&lt;/strong&gt;与えられた条件が満たされているインデックスを見つけ、それらのインデックスに対応する要素の削除（タプル）を使用します。 以下はそのためのコードです。</target>
        </trans-unit>
        <trans-unit id="5b34cc7bf01f9d2e80a510543d0a68d2bbdb4dfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Official Python 2 tutorial 4.2. &quot;for Statements&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;公式のPython 2チュートリアル4.2。&lt;/strong&gt; &lt;strong&gt;「ステートメント用」&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="557cafd24827735707266d1c1085114004a6d458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 2 documentation 7.3. &quot;The for statement&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Python 2ドキュメント7.3。&lt;/strong&gt; &lt;strong&gt;「forステートメント」&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fc8a02d37d7e4516e492ebd254cc004a1d0b7e9" translate="yes" xml:space="preserve">
          <source>Above we have used the &lt;code&gt;pop&lt;/code&gt; method on the fluid list object. Other common iterable methods are also implemented such as &lt;code&gt;del fluidL[i]&lt;/code&gt;, &lt;code&gt;.remove&lt;/code&gt;, &lt;code&gt;.insert&lt;/code&gt;, &lt;code&gt;.append&lt;/code&gt;, &lt;code&gt;.extend&lt;/code&gt;. The list can also be modified using slices (&lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;reverse&lt;/code&gt; methods are not implemented).</source>
          <target state="translated">上記では、流体リストオブジェクトで &lt;code&gt;pop&lt;/code&gt; メソッドを使用しました。 &lt;code&gt;del fluidL[i]&lt;/code&gt; &lt;code&gt;.remove&lt;/code&gt; 、 &lt;code&gt;.insert&lt;/code&gt; 、 &lt;code&gt;.append&lt;/code&gt; 、 &lt;code&gt;.extend&lt;/code&gt; などの他の一般的な反復可能なメソッドも実装されています。 リストはスライスを使用して変更することもできます（ &lt;code&gt;sort&lt;/code&gt; および &lt;code&gt;reverse&lt;/code&gt; メソッドは実装されていません）。</target>
        </trans-unit>
        <trans-unit id="16670fb950d5c5fdd6c0fd65ad6b86d68d95e137" translate="yes" xml:space="preserve">
          <source>Aha! Each element of L1 is actually a tuple. So that's what we need to be passing to remove(). Tuples in python are very easy, they're simply made by enclosing values in parentheses. &quot;a, b&quot; is not a tuple, but &quot;(a, b)&quot; is a tuple. So we modify your code and run it again:</source>
          <target state="translated">嗚呼!L1の各要素は実際にはタプルです。つまり、これが remove()に渡す必要があるものです。pythonのタプルはとても簡単で、値を括弧で囲んで作るだけです。&quot;a,b &quot;はタプルではありませんが、&quot;(a,b)&quot;はタプルです。なので、コードを修正してもう一度実行します。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一例です。</target>
        </trans-unit>
        <trans-unit id="6289272e180651017551f0d23619c6b843207579" translate="yes" xml:space="preserve">
          <source>As I stated to start with: this is a complicated solution that will hurt the readability of your code and make it more difficult to debug. Therefore other solutions such as the list comprehensions mentioned in David Raznick's &lt;a href=&quot;https://stackoverflow.com/a/1207461/4451578&quot;&gt;answer&lt;/a&gt; should be considered first. That being said, I have found times where this class has been useful to me and has been easier to use than keeping track of the indices of elements that need deleting.</source>
          <target state="translated">最初に述べたように、これはコードの読みやすさを損ない、デバッグをより困難にする複雑なソリューションです。 したがって、David Raznickの&lt;a href=&quot;https://stackoverflow.com/a/1207461/4451578&quot;&gt;回答で&lt;/a&gt;言及されているリスト内包表記など、他のソリューションを最初に検討する必要があります。 そうは言っても、このクラスが私にとって便利で、削除が必要な要素のインデックスを追跡するよりも使いやすいクラスを見つけました。</target>
        </trans-unit>
        <trans-unit id="b0de2e5d5f6712623237e9fe813e112b1056e691" translate="yes" xml:space="preserve">
          <source>As you can infer from that result, every time that the conditional statement evaluates to true and a list item is removed, the next iteration of the loop will skip evaluation of the next item in the list because its values are now located at different indices.</source>
          <target state="translated">この結果から推測できるように、条件文が true に評価されてリストの項目が削除されるたびに、次のループの反復はリストの次の項目の評価をスキップします。</target>
        </trans-unit>
        <trans-unit id="f9468c326a4a729e70975ea2231fdda83d27f476" translate="yes" xml:space="preserve">
          <source>But what if the result of the &lt;code&gt;testFunc&lt;/code&gt; depends on the elements that have been added to &lt;code&gt;newList&lt;/code&gt; already? Or the elements still in &lt;code&gt;oldList&lt;/code&gt; that might be added next? There might still be a way to use a list comprehension but it will begin to lose it's elegance, and for me it feels easier to modify a list in place.</source>
          <target state="translated">しかし、 &lt;code&gt;testFunc&lt;/code&gt; の結果が &lt;code&gt;newList&lt;/code&gt; にすでに追加されている要素に依存している場合はどうでしょうか。 または、次に追加される可能性のある &lt;code&gt;oldList&lt;/code&gt; の要素はまだですか？ リスト内包表記を使用する方法はまだあるかもしれませんが、それは優雅さを失い始めるでしょう、そして私にとっては適所でリストを修正する方が簡単に感じます。</target>
        </trans-unit>
        <trans-unit id="ab99bb95d0a8563a2528243c1af734b49825dea8" translate="yes" xml:space="preserve">
          <source>C++ &lt;a href=&quot;https://en.cppreference.com/w/cpp/container/vector/erase&quot;&gt;&lt;code&gt;std::vector::erase&lt;/code&gt;&lt;/a&gt; which returns a valid interator to the element after the one removed</source>
          <target state="translated">C ++ &lt;a href=&quot;https://en.cppreference.com/w/cpp/container/vector/erase&quot;&gt; &lt;code&gt;std::vector::erase&lt;/code&gt; &lt;/a&gt;は、要素を削除した後、要素に有効なインタレータを返します</target>
        </trans-unit>
        <trans-unit id="70de89a9d1057697c722db9334aea9338d7d9424" translate="yes" xml:space="preserve">
          <source>Copying the list using &lt;code&gt;remove&lt;/code&gt; might make your code look a little cleaner, as described in one of the answers below.  You should definitely not do this for extremely large lists, since this involves first copying the entire list, and also performing an &lt;code&gt;O(n)&lt;/code&gt;&lt;code&gt;remove&lt;/code&gt; operation for each element being removed, making this an &lt;code&gt;O(n^2)&lt;/code&gt; algorithm.</source>
          <target state="translated">以下の回答の1つで説明されているように、 &lt;code&gt;remove&lt;/code&gt; を使用してリストをコピーすると、コードが少しきれいに見える場合があります。 これは、最初にリスト全体をコピーし、 &lt;code&gt;remove&lt;/code&gt; される各要素に対して &lt;code&gt;O(n)&lt;/code&gt; 削除操作を実行してこれを &lt;code&gt;O(n^2)&lt;/code&gt; アルゴリズムにするため、極端に大きなリストに対しては絶対に行わないでください。</target>
        </trans-unit>
        <trans-unit id="cf79941ef09fc206b51225e5da9c16355e55b212" translate="yes" xml:space="preserve">
          <source>Download &lt;code&gt;fluidIter.py&lt;/code&gt; from &lt;a href=&quot;https://github.com/alanbacon/FluidIterator&quot;&gt;here&lt;/a&gt;&lt;code&gt;https://github.com/alanbacon/FluidIterator&lt;/code&gt;, it is just a single file so no need to install git. There is no installer so you will need to make sure that the file is in the python path your self. The code has been written for python 3 and is untested on python 2.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/alanbacon/FluidIterator&quot;&gt;ここ&lt;/a&gt;から &lt;code&gt;https://github.com/alanbacon/FluidIterator&lt;/code&gt; から &lt;code&gt;fluidIter.py&lt;/code&gt; をダウンロードします 。これは単一ファイルなので、gitをインストールする必要はありません。 インストーラーはないので、ファイルが自分のpythonパスにあることを確認する必要があります。 コードはpython 3用に作成されており、python 2ではテストされていません。</target>
        </trans-unit>
        <trans-unit id="1a2545867f0ca9597a7db53881bd6afe7c73dffe" translate="yes" xml:space="preserve">
          <source>Edit: As mentioned in the comments, this answer does not really present a problem for which this approach provides a solution. I will try to address that here:</source>
          <target state="translated">編集:コメントにもありましたが、この回答では、このアプローチが解決策となる問題を提示していません。私はここでそれに対処しようとします。</target>
        </trans-unit>
        <trans-unit id="a788b2421c51b170010ec2c266d516cb0be3f175" translate="yes" xml:space="preserve">
          <source>Edit: The last code example in this answer gives a use case for &lt;strong&gt;&lt;em&gt;why&lt;/em&gt;&lt;/strong&gt; you might sometimes want to modify a list in place rather than use a list comprehension. The first part of the answers serves as tutorial of &lt;strong&gt;&lt;em&gt;how&lt;/em&gt;&lt;/strong&gt; an array can be modified in place.</source>
          <target state="translated">編集：この回答の最後のコード例は、リスト内包表記を使用するのではなく、その場でリストを変更したい場合がある&lt;strong&gt;&lt;em&gt;理由の&lt;/em&gt;&lt;/strong&gt;ユースケースを&lt;strong&gt;&lt;em&gt;示してい&lt;/em&gt;&lt;/strong&gt;ます。 回答の最初の部分は、配列を適切に変更する&lt;strong&gt;&lt;em&gt;方法の&lt;/em&gt;&lt;/strong&gt;チュートリアルとして機能します。</target>
        </trans-unit>
        <trans-unit id="c8078d924b19f64b223a6df8142a489104063237" translate="yes" xml:space="preserve">
          <source>Either:</source>
          <target state="translated">Either:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2e016639bfdc35ff47021bee07e0442c9bf6e95a" translate="yes" xml:space="preserve">
          <source>Finally, there is one cleaner solution than having to make an entirely new copy of L1. The reversed() function:</source>
          <target state="translated">最後に、L1 の完全な新しいコピーを作成するよりもすっきりとした解決策があります。それが reversed()関数です。</target>
        </trans-unit>
        <trans-unit id="c44ea041349ed36728514202e8abfa264d478d68" translate="yes" xml:space="preserve">
          <source>First of all you'll need to &lt;strong&gt;replace foreach loop with while loop&lt;/strong&gt;,</source>
          <target state="translated">まず、 &lt;strong&gt;foreachループをwhileループ&lt;/strong&gt;に&lt;strong&gt;置き換える&lt;/strong&gt;必要があり&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4bbfc8e8879463ee80d588ea8bff37fe8625e66" translate="yes" xml:space="preserve">
          <source>For anything that has the potential to be really big, I use the following.</source>
          <target state="translated">本当に大きな可能性を秘めているものには</target>
        </trans-unit>
        <trans-unit id="c9d41ff6b00990841a094958bdca36f5ecbef710" translate="yes" xml:space="preserve">
          <source>For example (depends on what type of list):</source>
          <target state="translated">例えば(リストの種類にもよるが)。</target>
        </trans-unit>
        <trans-unit id="d3826d07dc82c819a2952d0b19069cf2dcd53dc5" translate="yes" xml:space="preserve">
          <source>For more details &lt;a href=&quot;http://docs.python.org/library/functions.html#filter&quot;&gt;check here&lt;/a&gt;</source>
          <target state="translated">詳しくは&lt;a href=&quot;http://docs.python.org/library/functions.html#filter&quot;&gt;こちらをチェック&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0682dfde6b8575edaa27bd1c03020cbce20014a8" translate="yes" xml:space="preserve">
          <source>For those that like functional programming:</source>
          <target state="translated">関数型プログラミングが好きな方</target>
        </trans-unit>
        <trans-unit id="a74dc39ba82bf47d723236da822a90c8ff7a3ec2" translate="yes" xml:space="preserve">
          <source>Fortunately, it's extremely easy to get both the speed of list comprehensions AND the required semantics of in-place alteration -- just code:</source>
          <target state="translated">幸いなことに、リスト内包の速度と必要とされるインプレース変更のセマンティクスの両方を得ることは非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="c36edd270beeffac5974b87eb6c988c0cf556914" translate="yes" xml:space="preserve">
          <source>Full answer:</source>
          <target state="translated">フルアンサー。</target>
        </trans-unit>
        <trans-unit id="56e8e2cad0c7d16346946903b1f1df0e011a6ba1" translate="yes" xml:space="preserve">
          <source>Generally you just want to go for the faster &lt;code&gt;.append()&lt;/code&gt; option by default unless memory is a big concern.</source>
          <target state="translated">一般的には、メモリが大きな問題でない限り、デフォルトでより高速な &lt;code&gt;.append()&lt;/code&gt; オプションを使用したいだけです。</target>
        </trans-unit>
        <trans-unit id="88f8f55fdd9b1ef963f6e91ea73765a38063d284" translate="yes" xml:space="preserve">
          <source>Here is an example where copying the list beforehand is incorrect, reverse iteration is impossible and a list comprehension is also not an option.</source>
          <target state="translated">ここでは、あらかじめリストをコピーしておくと正しくなく、逆反復ができず、リスト理解もできない例を紹介します。</target>
        </trans-unit>
        <trans-unit id="015e2b33e48d8c457bdeefa7777500d6753f17a6" translate="yes" xml:space="preserve">
          <source>How to remove items from a list while iterating</source>
          <target state="translated">イテレーション中にリストから項目を削除する方法</target>
        </trans-unit>
        <trans-unit id="c77620b856d20a8819f9b0b470a56a1277c2fb40" translate="yes" xml:space="preserve">
          <source>However, I disagree with this implementation, since &lt;code&gt;.remove()&lt;/code&gt; has to iterate the &lt;em&gt;entire list&lt;/em&gt; to find the value.</source>
          <target state="translated">ただし、 &lt;code&gt;.remove()&lt;/code&gt; は&lt;em&gt;リスト全体&lt;/em&gt;を反復して値を見つける必要があるため、この実装には同意しません。</target>
        </trans-unit>
        <trans-unit id="69b67973d6a8e6ef36e2888307c19b186e7df019" translate="yes" xml:space="preserve">
          <source>However, the output will be identical to before:</source>
          <target state="translated">ただし、出力は以前と同じになります。</target>
        </trans-unit>
        <trans-unit id="3f4aacab5e7adbd49358dc9debb14a93fa23eb41" translate="yes" xml:space="preserve">
          <source>I can think of three approaches to solve your problem. As an example, I will create a random list of tuples &lt;code&gt;somelist = [(1,2,3), (4,5,6), (3,6,6), (7,8,9), (15,0,0), (10,11,12)]&lt;/code&gt;. The condition that I choose is &lt;code&gt;sum of elements of a tuple = 15&lt;/code&gt;. In the final list we will only have those tuples whose sum is not equal to 15.</source>
          <target state="translated">あなたの問題を解決するための3つのアプローチを考えることができます。 例として、タプルのランダムリスト &lt;code&gt;somelist = [(1,2,3), (4,5,6), (3,6,6), (7,8,9), (15,0,0), (10,11,12)]&lt;/code&gt; 。 私が選択する条件 &lt;code&gt;sum of elements of a tuple = 15&lt;/code&gt; です。 最後のリストには、合計が15に等しくないタプルのみが含まれます。</target>
        </trans-unit>
        <trans-unit id="a368dea51582938f2ab67c94c9f3b922d05e401f" translate="yes" xml:space="preserve">
          <source>I needed to do something similar and in my case the problem was memory - I needed to merge multiple dataset objects within a list, after doing some stuff with them, as a new object, and needed to get rid of each entry I was merging to avoid duplicating all of them and blowing up memory. In my case having the objects in a dictionary instead of a list worked fine:</source>
          <target state="translated">同じようなことをする必要があり、私の場合はメモリの問題でした。複数のデータセットオブジェクトをリスト内にマージする必要がありました。私の場合は、オブジェクトをリストではなく辞書に入れておけば問題ありませんでした。</target>
        </trans-unit>
        <trans-unit id="cd970f7da56e80281558904a4e1d263b5a3fa2d2" translate="yes" xml:space="preserve">
          <source>I needed to do this with a huge list, and duplicating the list seemed expensive, especially since in my case the number of deletions would be few compared to the items that remain. I took this low-level approach.</source>
          <target state="translated">これを巨大なリストで行う必要があり、リストを複製するのはコストがかかりそうでした。私はこのような低レベルのアプローチをとりました。</target>
        </trans-unit>
        <trans-unit id="61eac64b85c8bcbd86114f439152c5f3727dc586" translate="yes" xml:space="preserve">
          <source>I wrote a library that allows you to do this:</source>
          <target state="translated">こんなことができるライブラリを書いてみました。</target>
        </trans-unit>
        <trans-unit id="93e8f9e56c8391ff4d8114fdd92027090dcb5149" translate="yes" xml:space="preserve">
          <source>I'm iterating over a list of tuples in Python, and am attempting to remove them if they meet certain criteria.</source>
          <target state="translated">私はPythonでタプルのリストを反復処理していて、それらが特定の条件を満たしている場合にそれらを削除しようとしています。</target>
        </trans-unit>
        <trans-unit id="40067d779a3f3245e65a2ab2e94f2fec69eb4c56" translate="yes" xml:space="preserve">
          <source>If we want to access the current index value of the list we cannot use enumerate, as this only counts how many times the for loop has run. Instead we will use the iterator object directly.</source>
          <target state="translated">リストの現在のインデックス値にアクセスしたい場合は、forループが何回実行されたかをカウントするだけなので、enumerateを使用することはできません。代わりに、イテレータオブジェクトを直接使用します。</target>
        </trans-unit>
        <trans-unit id="7baf994253e5422333a06fc8988fe24496aaf2a2" translate="yes" xml:space="preserve">
          <source>If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy. The slice notation makes this especially convenient:</source>
          <target state="translated">ループ内で反復処理しているシーケンスを変更する必要がある場合(例えば、選択された項目を複製するなど)、最初にコピーを作成することをお勧めします。シーケンスを繰り返し処理しても、暗黙のうちにコピーが作成されるわけではありません。スライス記法はこれを特に便利にしています。</target>
        </trans-unit>
        <trans-unit id="d87b562086fac008b600e2b8d4a9b5150a639c97" translate="yes" xml:space="preserve">
          <source>If you want to delete elements from a list while iterating, use a while-loop so you can alter the current index and end index after each deletion.</source>
          <target state="translated">反復処理中にリストから要素を削除したい場合は、削除のたびに現在のインデックスと終了インデックスを変更できるようにwhileループを使用します。</target>
        </trans-unit>
        <trans-unit id="da17f6befdc523de38569c671e0632dd8feef1a1" translate="yes" xml:space="preserve">
          <source>If you want to do anything else during the iteration, it may be nice to get both the index (which guarantees you being able to reference it, for example if you have a list of dicts) and the actual list item contents.</source>
          <target state="translated">反復の間に何か他のことをしたい場合は、インデックス(例えばディクトのリストを持っている場合などに参照できることを保証してくれます)と実際のリスト項目の内容の両方を取得しておくといいかもしれません。</target>
        </trans-unit>
        <trans-unit id="a9b71d2114bfedf22c95c100902b07fb9eda5c92" translate="yes" xml:space="preserve">
          <source>If you will use the new list later, you can simply set the elem to None, and then judge it in the later loop, like this</source>
          <target state="translated">後で新しいリストを使用する場合は、単に elem を None に設定して、後のループで次のように判定することができます。</target>
        </trans-unit>
        <trans-unit id="cff757980d44c8978d107712bbd9c8346debf46a" translate="yes" xml:space="preserve">
          <source>In cases where you're doing something more complex than calling a &lt;code&gt;determine&lt;/code&gt; function, I prefer constructing a new list and simply appending to it as I go.  For example</source>
          <target state="translated">&lt;code&gt;determine&lt;/code&gt; 関数を呼び出すよりも複雑なことをしている場合は、新しいリストを作成して、それに合わせて追加するだけです。 例えば</target>
        </trans-unit>
        <trans-unit id="245dc2132cc9d15cb2653900c35e1e34efd80517" translate="yes" xml:space="preserve">
          <source>In some situations, where you're doing more than simply filtering a list one item at time, you want your iteration to change while iterating.</source>
          <target state="translated">単にリストを一項目ずつフィルタリングするだけではなく、それ以上のことをしている状況では、反復処理中に反復処理を変更したい場合もあるでしょう。</target>
        </trans-unit>
        <trans-unit id="25a3509e025bfbab60c4594a7314dfe96eee8d5a" translate="yes" xml:space="preserve">
          <source>In this way, you dont't need copy the list and it's easier to understand.</source>
          <target state="translated">このように、リストをコピーする必要がなく、わかりやすくなります。</target>
        </trans-unit>
        <trans-unit id="125406bb8e98603cdb6cb34508b6a4174012d403" translate="yes" xml:space="preserve">
          <source>Instead of a comprehension, you could also use &lt;code&gt;itertools&lt;/code&gt;. In Python 2:</source>
          <target state="translated">理解の代わりに、 &lt;code&gt;itertools&lt;/code&gt; を使用することもできます 。 Python 2の場合：</target>
        </trans-unit>
        <trans-unit id="f56af88d3f92e6edf9b095e4969fca472d8ed69b" translate="yes" xml:space="preserve">
          <source>It might be smart to also just create a new list if the current list item meets the desired criteria.</source>
          <target state="translated">現在のリスト項目が希望の条件を満たしている場合は、新しいリストを作成するだけでもスマートかもしれません。</target>
        </trans-unit>
        <trans-unit id="55998da221cafd68f95026750947ab3d3b827cb2" translate="yes" xml:space="preserve">
          <source>It seems like this particular Python API could be improved. Compare it, for instance, with:</source>
          <target state="translated">この特定のPython APIは改良されているように思えます。例えば、比較してみてください。</target>
        </trans-unit>
        <trans-unit id="046f43ead4620ec5bc9285795e2a5ebcbbd51ae9" translate="yes" xml:space="preserve">
          <source>It's best to use another method if possible that doesn't require modifying your iterable while iterating over it, but for some algorithms it might not be that straight forward. And so if you are sure that you really do want the code pattern described in the original question, it is possible.</source>
          <target state="translated">可能であれば、反復処理中にイテレータブルを修正する必要のない別の方法を使うのがベストですが、アルゴリズムによってはそう簡単ではないかもしれません。そして、もしあなたが本当に元の質問で説明したコードパターンが欲しいと確信しているのであれば、それは可能です。</target>
        </trans-unit>
        <trans-unit id="f87de0493fb3d04591d84b9514a64a8b1b2433ae" translate="yes" xml:space="preserve">
          <source>Java &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html&quot;&gt;ListIterator::remove&lt;/a&gt; which documents &quot;This call can only be made once per call to next or previous&quot;</source>
          <target state="translated">Java &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html&quot;&gt;ListIterator :: remove&lt;/a&gt; 「この呼び出しは、次または前の呼び出しごとに1回だけ実行できます」</target>
        </trans-unit>
        <trans-unit id="b8f5fc225cfb3362fa3e16aaa8090b08eeb8d9d7" translate="yes" xml:space="preserve">
          <source>Let's run through what happens when we execute your code:</source>
          <target state="translated">コードを実行すると何が起こるのかを説明しましょう。</target>
        </trans-unit>
        <trans-unit id="f8a9a21683177e7cde4a5592c377a6e74a389d1e" translate="yes" xml:space="preserve">
          <source>List comprehensions provide a way to generate a new list but these approaches tend to look at each element in isolation rather than the current state of the list as a whole.</source>
          <target state="translated">リスト内包は新しいリストを生成する方法を提供しますが、これらのアプローチは、リスト全体の現在の状態よりも各要素を分離して見る傾向があります。</target>
        </trans-unit>
        <trans-unit id="d2e359d0150a691e0d84043306b8fdd090ce18d0" translate="yes" xml:space="preserve">
          <source>More examples / tests can be found in the &lt;code&gt;if __name__ is &quot;__main__&quot;:&lt;/code&gt; section at the bottom of &lt;code&gt;fluidIter.py&lt;/code&gt;. These are worth looking at because they explain what happens in various situations. Such as: Replacing a large sections of the list using a slice. Or using (and modifying) the same iterable in nested for loops.</source>
          <target state="translated">その他の例/テストは、 &lt;code&gt;fluidIter.py&lt;/code&gt; の下部にある &lt;code&gt;if __name__ is &quot;__main__&quot;:&lt;/code&gt; セクションにあります 。 これらは、さまざまな状況で何が起こるかを説明しているため、一見の価値があります。 例：スライスを使用してリストの大きなセクションを置き換える。 または、ネストされたforループで同じイテラブルを使用（および変更）します。</target>
        </trans-unit>
        <trans-unit id="da2749c0165cf2060c3dbe8c050ade5cfc962757" translate="yes" xml:space="preserve">
          <source>Most of the answers here want you to create a copy of the list. I had a use case where the list was quite long (110K items) and it was smarter to keep reducing the list instead.</source>
          <target state="translated">ここでの回答のほとんどは、リストのコピーを作成することを求めています。私はリストが非常に長く(110K項目)、リストを減らし続けた方がスマートだったというユースケースがありました。</target>
        </trans-unit>
        <trans-unit id="c80f5de1207f487c252821cc6bb7b9fc8eccb956" translate="yes" xml:space="preserve">
          <source>Note the subtle difference with other answers: this one is NOT assigning to a barename - it's assigning to a list slice that just happens to be the entire list, thereby replacing the list &lt;em&gt;contents&lt;/em&gt;&lt;strong&gt;within the same Python list object&lt;/strong&gt;, rather than just reseating one reference (from previous list object to new list object) like the other answers.</source>
          <target state="translated">他の答えとの微妙な違いに注意してください：これはベアネームに割り当てられていません-たまたまリスト全体であるリストスライスに割り当てられているため、1つの参照を再配置するのではなく&lt;strong&gt;、同じPythonリストオブジェクト内の&lt;/strong&gt;リスト&lt;em&gt;コンテンツ&lt;/em&gt;を置き換えます（前のリストオブジェクトから新しいリストオブジェクトへ）他の回答と同様です。</target>
        </trans-unit>
        <trans-unit id="b2ac388e56496c2c3c957f43d877dd1d7fda2c8a" translate="yes" xml:space="preserve">
          <source>Note: There is a subtlety when the sequence is being modified by the loop (this can only occur for mutable sequences, i.e. lists). An internal counter is used to keep track of which item is used next, and this is incremented on each iteration. When this counter has reached the length of the sequence the loop terminates. This means that if the suite deletes the current (or a previous) item from the sequence, the next item will be skipped (since it gets the index of the current item which has already been treated). Likewise, if the suite inserts an item in the sequence before the current item, the current item will be treated again the next time through the loop. This can lead to nasty bugs that can be avoided by making a temporary copy using a slice of the whole sequence, e.g.,</source>
          <target state="translated">注意:シーケンスがループによって変更されているときには微妙な違いがあります(これはリストなどの変異可能なシーケンスに対してのみ発生します).次にどの項目を使用するかを追跡するために内部カウンタが使用されており,これは繰り返しのたびに増加します.このカウンタがシーケンスの長さに達すると、ループは終了します。これは、もしスイートが現在の (あるいは前の)アイテムをシーケンスから削除した場合、次のアイテムはスキップされることを意味します (すでに処理されている現在のアイテムのインデックスを取得するため)。同様に、現在のアイテムの前にアイテムを挿入した場合は、次回のループでは現在のアイテムが再び扱われることになります。これは厄介なバグを引き起こす可能性がありますが、シーケンス全体のスライスを使って一時的なコピーを作成することで回避することができます。</target>
        </trans-unit>
        <trans-unit id="17fc589ddf453f77430cdfb24061a48d22055a0b" translate="yes" xml:space="preserve">
          <source>One possible solution, useful if you want not only remove some things, but also do something with all elements in a single loop:</source>
          <target state="translated">いくつかのものを削除するだけでなく、1つのループの中ですべての要素を使って何かをしたい場合に便利な解決策の1つです。</target>
        </trans-unit>
        <trans-unit id="9989cc03f8130b33e38ebbe097e363902bb2ab71" translate="yes" xml:space="preserve">
          <source>Or in Python 3:</source>
          <target state="translated">もしくはPython 3で。</target>
        </trans-unit>
        <trans-unit id="360486488323ae5b9c4a62711e3b574d44955347" translate="yes" xml:space="preserve">
          <source>Or, by assigning to the slice &lt;code&gt;somelist[:]&lt;/code&gt;, you can mutate the existing list to contain only the items you want:</source>
          <target state="translated">または、スライス &lt;code&gt;somelist[:]&lt;/code&gt; に割り当てることにより、既存のリストを変更して、必要な項目のみを含めることができます。</target>
        </trans-unit>
        <trans-unit id="79e5e39f10693e0d3d7f9bbd6e8a79ae8f411a56" translate="yes" xml:space="preserve">
          <source>Perhaps the underlying rationale is that Python lists are assumed to be dynamic array backed, and therefore any type of removal will be time inefficient anyways, while Java has a nicer interface hierarchy with both &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;ListIterator&lt;/code&gt;.</source>
          <target state="translated">おそらく、根本的な根拠は、Pythonリストは動的配列に対応していると想定されているため、いずれのタイプの削除も時間効率が悪いということ&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt;が、Javaには、 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; ArrayList実装とLinkedList実装の両方を備えた優れたインターフェース階層があり &lt;code&gt;ListIterator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ea5407d1e5d315fb9f7357791702e7406ce3cfa" translate="yes" xml:space="preserve">
          <source>Problem is you removed a value from a list during iteration then your list index will collapse.</source>
          <target state="translated">問題は、反復処理中にリストから値を削除した場合、リストのインデックスが崩れてしまうことです。</target>
        </trans-unit>
        <trans-unit id="a12a2e961432337248947c29211654dd9db80cac" translate="yes" xml:space="preserve">
          <source>Python 2 users: replace &lt;code&gt;range&lt;/code&gt; by &lt;code&gt;xrange&lt;/code&gt; to avoid creating a hardcoded list</source>
          <target state="translated">Python 2ユーザー：ハードコードされたリストの作成を避けるために、 &lt;code&gt;range&lt;/code&gt; を &lt;code&gt;xrange&lt;/code&gt; で置き換えます</target>
        </trans-unit>
        <trans-unit id="48bce7473e48f3146f9e6a87451c0a6b7a287a30" translate="yes" xml:space="preserve">
          <source>Should work on all mutable sequences not just lists.</source>
          <target state="translated">リストだけでなく、すべての変異可能な配列で動作するようにしてください。</target>
        </trans-unit>
        <trans-unit id="d69dabce4725955fd5cfe5474202e42df310b5ad" translate="yes" xml:space="preserve">
          <source>TLDR:</source>
          <target state="translated">TLDR:</target>
        </trans-unit>
        <trans-unit id="152d20f48429364f6ffc8bed8d7c4ab140cd6e27" translate="yes" xml:space="preserve">
          <source>That should be significantly faster than anything else.</source>
          <target state="translated">それは何よりもはるかに早いはずです。</target>
        </trans-unit>
        <trans-unit id="270175c65f9ab178c1fec6d7dd95d939a77fd791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FluidIterable&lt;/code&gt; class just provides a wrapper for the original list object. The original object can be accessed as a property of the fluid object like so:</source>
          <target state="translated">&lt;code&gt;FluidIterable&lt;/code&gt; クラスは、元のリストオブジェクトのラッパーを提供するだけです。 元のオブジェクトには、次のように流動オブジェクトのプロパティとしてアクセスできます。</target>
        </trans-unit>
        <trans-unit id="3cfb5094c7c78cca9a3962e635d233764ced9056" translate="yes" xml:space="preserve">
          <source>The answers suggesting list comprehensions are ALMOST correct -- except that they build a completely new list and then give it the same name the old list as, they do NOT modify the old list in place. That's different from what you'd be doing by selective removal, as in &lt;a href=&quot;https://stackoverflow.com/a/1207427/3064538&quot;&gt;@Lennart's suggestion&lt;/a&gt; -- it's faster, but if your list is accessed via multiple references the fact that you're just reseating one of the references and NOT altering the list object itself can lead to subtle, disastrous bugs.</source>
          <target state="translated">リストの内包を示唆する回答はほぼ正しいです。ただし、完全に新しいリストを作成し、古いリストと同じ名前を付けた場合を除き、古いリストは変更されません。 これは、 &lt;a href=&quot;https://stackoverflow.com/a/1207427/3064538&quot;&gt;@ Lennartの提案の&lt;/a&gt;ように、選択的な削除によって行うこととは異なります-高速ですが、リストが複数の参照を介してアクセスされる場合、参照の1つを再配置し、リストオブジェクトを変更しないという事実それ自体が、微妙で悲惨なバグにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5191c36b79d049087e12a7d61cc7919fff9ceeaf" translate="yes" xml:space="preserve">
          <source>The code below is one example of an algorithm that suffers from the above problem. The algorithm will reduce a list so that no element is a multiple of any other element.</source>
          <target state="translated">以下のコードは、上記の問題に悩まされるアルゴリズムの一例です。このアルゴリズムは,どの要素も他の要素の倍数にならないようにリストを削減します.</target>
        </trans-unit>
        <trans-unit id="1dd15e2a02b9bd225a28fb73bd761fec970d34a4" translate="yes" xml:space="preserve">
          <source>The first problem is that you are passing both 'a' and 'b' to remove(), but remove() only accepts a single argument. So how can we get remove() to work properly with your list? We need to figure out what each element of your list is. In this case, each one is a tuple. To see this, let's access one element of the list (indexing starts at 0):</source>
          <target state="translated">最初の問題は、'a' と 'b' の両方を remove()に渡しているのに、 remove()は単一の引数しか受け付けないということです。では、どのようにして remove()をリストで正しく動作させるのでしょうか?リストの各要素が何であるかを把握する必要があります。この場合、それぞれの要素はタプルです。これを確認するために、リストの 1 つの要素にアクセスしてみましょう (インデックスは 0 から始まります)。</target>
        </trans-unit>
        <trans-unit id="03c421e2f742eb0a3f0b40bf613c9d58c162b963" translate="yes" xml:space="preserve">
          <source>The most effective method is list comprehension, many people show their case, of course, it is also a good way to get an &lt;code&gt;iterator&lt;/code&gt; through &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">最も効果的な方法はリストを理解することであり、多くの人が自分のケースを示します。もちろん、 &lt;code&gt;filter&lt;/code&gt; 介して &lt;code&gt;iterator&lt;/code&gt; を取得するのにも良い方法です。</target>
        </trans-unit>
        <trans-unit id="82e722be14da8e292e19c55197fc9f40afbc622f" translate="yes" xml:space="preserve">
          <source>The most intuitive solution is to copy the list, then iterate over the original list and only modify the copy. You can try doing so like this:</source>
          <target state="translated">最も直感的な解決策は、リストをコピーしてから、元のリストの上で反復処理を行い、コピーを修正することです。このようにしてみてください。</target>
        </trans-unit>
        <trans-unit id="218e1c2432d3d651eb5aa8d840e5878a648c2f64" translate="yes" xml:space="preserve">
          <source>The only condition is that you must only modify the list in place, if at any point &lt;code&gt;fluidL&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt; were reassigned to a different list object the code would not work. The original &lt;code&gt;fluidL&lt;/code&gt; object would still be used by the for loop but would become out of scope for us to modify.</source>
          <target state="translated">唯一の条件は、リストを変更する必要があることだけです。いずれかの時点で、 &lt;code&gt;fluidL&lt;/code&gt; または &lt;code&gt;l&lt;/code&gt; が別のリストオブジェクトに再割り当てされた場合、コードは機能しません。 元の &lt;code&gt;fluidL&lt;/code&gt; オブジェクトは引き続きforループで使用されますが、変更する範囲外になります。</target>
        </trans-unit>
        <trans-unit id="0232391e9ed0b3f4e1884c82ce7b756054004e76" translate="yes" xml:space="preserve">
          <source>The other answers are correct that it is usually a bad idea to delete from a list that you're iterating. Reverse iterating avoids the pitfalls, but it is much more difficult to follow code that does that, so usually you're better off using a list comprehension or &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">他の答えは正解です。通常、反復しているリストから削除することは悪い考えです。 逆反復は落とし穴を回避しますが、それを行うコードに従うのははるかに難しいので、通常はリスト内包または &lt;code&gt;filter&lt;/code&gt; を使用する方がよいでしょう。</target>
        </trans-unit>
        <trans-unit id="d83b85da1737342dd5460982dd9c13f4ec834959" translate="yes" xml:space="preserve">
          <source>The output and the final reduced list are shown below</source>
          <target state="translated">出力と最終的に縮小されたリストを以下に示します。</target>
        </trans-unit>
        <trans-unit id="6f7fb1a9757b6b77ad3c9a0db78e51afbee729bf" translate="yes" xml:space="preserve">
          <source>The solution follows on from &lt;a href=&quot;https://stackoverflow.com/a/6260097/4451578&quot;&gt;this&lt;/a&gt; answer (for a related question) from senderle. Which explains how the the array index is updated while iterating through a list that has been modified. The solution below is designed to correctly track the array index even if the list is modified.</source>
          <target state="translated">解決策は、senderleからの（関連する質問に対する） &lt;a href=&quot;https://stackoverflow.com/a/6260097/4451578&quot;&gt;この&lt;/a&gt;回答から続きます。 これは、変更されたリストを反復処理するときに配列インデックスが更新される方法を説明しています。 以下のソリューションは、リストが変更された場合でも配列のインデックスを正しく追跡するように設計されています。</target>
        </trans-unit>
        <trans-unit id="2551885fd9f082f01224604f6182eec3c30229ae" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;i&lt;/code&gt; is not changed in the if block because you'll want to get value of the new item FROM THE SAME INDEX, once the old item is deleted.</source>
          <target state="translated">古い項目が削除されると、同じ項目から新しい項目の値を取得するため、 &lt;code&gt;i&lt;/code&gt; ブロックのiの値は変更されません。</target>
        </trans-unit>
        <trans-unit id="f7562a2c2dc431ee3d16ebf6cd88cf92dd3094ad" translate="yes" xml:space="preserve">
          <source>There are two problems in your code:</source>
          <target state="translated">あなたのコードには2つの問題があります。</target>
        </trans-unit>
        <trans-unit id="1a99f253b2b161ab64e883f8d5fbc4dedcf4f028" translate="yes" xml:space="preserve">
          <source>There doesn't seem to be an explicit linked list type in the Python stdlib either: &lt;a href=&quot;https://stackoverflow.com/questions/280243/python-linked-list/280286&quot;&gt;Python Linked List&lt;/a&gt;</source>
          <target state="translated">Python stdlibにも明示的なリンクリストタイプがないようです： &lt;a href=&quot;https://stackoverflow.com/questions/280243/python-linked-list/280286&quot;&gt;Python Linked List&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e347b0acd45b91cadf43f2803affd98ff60eebb" translate="yes" xml:space="preserve">
          <source>There is an example  (get the odds in the tuple):</source>
          <target state="translated">例があります(タプルの中のオッズを取得する)。</target>
        </trans-unit>
        <trans-unit id="55432bab27968e16616ffe608379fb64757d1359" translate="yes" xml:space="preserve">
          <source>There is, however, one case where it is safe to remove elements from a sequence that you are iterating: if you're only removing one item while you're iterating. This can be ensured using a &lt;code&gt;return&lt;/code&gt; or a &lt;code&gt;break&lt;/code&gt;. For example:</source>
          <target state="translated">ただし、反復しているシーケンスから要素を削除しても安全なケースが1つあります。それは、反復中に1つのアイテムのみを削除する場合です。 これは、 &lt;code&gt;return&lt;/code&gt; または &lt;code&gt;break&lt;/code&gt; を使用して確認できます。 例えば：</target>
        </trans-unit>
        <trans-unit id="1bce386bfd881c91ca88506633592e0f9e08efc1" translate="yes" xml:space="preserve">
          <source>This answer was originally written in response to a question which has since been marked as duplicate:
&lt;a href=&quot;https://stackoverflow.com/questions/40175149/removing-coordinates-from-list-on-python&quot;&gt;Removing coordinates from list on python&lt;/a&gt;</source>
          <target state="translated">この回答はもともと、重複としてマークされている質問への応答として書かれました： &lt;a href=&quot;https://stackoverflow.com/questions/40175149/removing-coordinates-from-list-on-python&quot;&gt;pythonのリストから座標を削除しています&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e7f8dab783005add34279bd95b8e79966d3770f" translate="yes" xml:space="preserve">
          <source>This approach could be useful if there are other references to &lt;code&gt;somelist&lt;/code&gt; that need to reflect the changes.</source>
          <target state="translated">このアプローチは、変更を反映する必要がある &lt;code&gt;somelist&lt;/code&gt; への他の参照がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="d30f448b4b0f64b3cc1bd7c5a8e371250849c4a4" translate="yes" xml:space="preserve">
          <source>This code runs without any error, but let's look at the list it outputs:</source>
          <target state="translated">このコードは何のエラーもなく実行されますが、出力されるリストを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="e6775b34984f46006cc69465d54fe83b78053739" translate="yes" xml:space="preserve">
          <source>This is because when we created L2, python did not actually create a new object. Instead, it merely referenced L2 to the same object as L1. We can verify this with 'is' which is different from merely &quot;equals&quot; (==).</source>
          <target state="translated">これは、L2を作成したときに、pythonは実際には新しいオブジェクトを作成しなかったからです。その代わりに、単にL1と同じオブジェクトにL2を参照しています。これは単に &quot;equals&quot; (==)とは異なる'is'で検証することができます。</target>
        </trans-unit>
        <trans-unit id="5e26fd0b44d14a076fccd9b06568c15d5d11763c" translate="yes" xml:space="preserve">
          <source>This is more space efficient since it dispenses the array copy, but it is less time efficient because CPython lists &lt;a href=&quot;https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented&quot;&gt;are implemented with dynamic arrays&lt;/a&gt;.</source>
          <target state="translated">これは、配列のコピーが不要になるためスペース効率が向上します&lt;a href=&quot;https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented&quot;&gt;が&lt;/a&gt; 、CPythonリストは動的配列で実装されるため、時間効率が低下します 。</target>
        </trans-unit>
        <trans-unit id="167c700ccc2cf194c88b1e29817f0e5473200686" translate="yes" xml:space="preserve">
          <source>This is often easier to understand than a list comprehension when you're doing some operations with side effects on the first item in a list that meets some condition and then removing that item from the list immediately after.</source>
          <target state="translated">これは、リストの最初の項目で何らかの条件を満たしている項目に副作用のある操作をして、その直後にその項目をリストから削除するというような場合には、リスト理解よりもわかりやすいことが多いです。</target>
        </trans-unit>
        <trans-unit id="9e832ffbc7b8159e0dacf897dec246a0c433e2de" translate="yes" xml:space="preserve">
          <source>This means that item removal requires shifting all following items back by one, which is O(N).</source>
          <target state="translated">つまり、アイテムの除去には、以下のアイテムを1つずつずらして戻す必要があり、O(N)となります。</target>
        </trans-unit>
        <trans-unit id="6d3f755498b86d4d64c1f495ead2913089f82af0" translate="yes" xml:space="preserve">
          <source>This part of the docs makes it clear that:</source>
          <target state="translated">ドキュメントのこの部分を見れば一目瞭然です。</target>
        </trans-unit>
        <trans-unit id="4dfe1b1a882c87ca174edca828cf5ca59cfa1421" translate="yes" xml:space="preserve">
          <source>This part of the docs says once again that you have to make a copy, and gives an actual removal example:</source>
          <target state="translated">ドキュメントのこの部分は、コピーを取らなければならないと改めて言い、実際の削除例を示しています。</target>
        </trans-unit>
        <trans-unit id="23a9c4672ae391fc627eba417316401219f51f2f" translate="yes" xml:space="preserve">
          <source>This time efficient, but less space efficient because it keeps a copy of the array around during iteration.</source>
          <target state="translated">これは時間的には効率的ですが、繰り返しの間に配列のコピーを保持するため、スペース的にはあまり効率的ではありません。</target>
        </trans-unit>
        <trans-unit id="526b1bb0411da1ec481ceb845008bac5dfa4b12c" translate="yes" xml:space="preserve">
          <source>This way the index is aligned and doesn't suffer from the list updates (regardless whether you pop cur element or not).</source>
          <target state="translated">こうすることでインデックスが整列し、リストの更新に悩まされることがなくなります(cur要素をポップするかどうかに関係なく)。</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">これで以下のように出力されます。</target>
        </trans-unit>
        <trans-unit id="f906bf0437d1189835cd8ddcd60d8f965fa2c44a" translate="yes" xml:space="preserve">
          <source>This will produce the following output:</source>
          <target state="translated">これにより、以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="de0da919165bd723f966b10f2b6d39bef73fe836" translate="yes" xml:space="preserve">
          <source>Unfortunately, I cannot adequately describe how reversed() works. It returns a 'listreverseiterator' object when a list is passed to it. For practical purposes, you can think of it as creating a reversed copy of its argument. This is the solution I recommend.</source>
          <target state="translated">残念ながら、私は reversed()がどのように動作するかを十分に説明することができません。これはリストが渡されると 'listreverseiterator' オブジェクトを返します。実用的な目的では、引数の逆コピーを作成すると考えることができます。これが私のお勧めする解決策です。</target>
        </trans-unit>
        <trans-unit id="8b2d2221789d986c7ae56d80c76907b6412db859" translate="yes" xml:space="preserve">
          <source>We can make a true copy using copy.copy(). Then everything works as expected:</source>
          <target state="translated">copy.copy()を使用して真のコピーを作成することができます。そうすれば、すべてが期待通りに動作します。</target>
        </trans-unit>
        <trans-unit id="23784d9f68162c9269e0a23fd4ac91e3cbbffbaa" translate="yes" xml:space="preserve">
          <source>What I don't know is how efficient a couple of deletes are compared to copying a large list. Please comment if you have any insight.</source>
          <target state="translated">私が知らないのは、大きなリストをコピーするのに比べて、数回の削除がどれだけ効率的なのかということです。何か見識のある方はコメントをお願いします。</target>
        </trans-unit>
        <trans-unit id="b617b1edd0d3f10931aa29fbdeee51bf2c7348cc" translate="yes" xml:space="preserve">
          <source>What should I use in place of &lt;code&gt;code_to_remove_tup&lt;/code&gt;? I can't figure out how to remove the item in this fashion.</source>
          <target state="translated">&lt;code&gt;code_to_remove_tup&lt;/code&gt; の代わりに何を使用すればよいですか？ この方法でアイテムを削除する方法がわかりません。</target>
        </trans-unit>
        <trans-unit id="943d5a56f866fd2745375a8579ced2fc5bc9d4aa" translate="yes" xml:space="preserve">
          <source>Why is (1,-2) still in your list? It turns out modifying the list while using a loop to iterate over it is a very bad idea without special care. The reason that (1, -2) remains in the list is that the locations of each item within the list changed between iterations of the for loop. Let's look at what happens if we feed the above code a longer list:</source>
          <target state="translated">なぜ(1,-2)がリストに残っているのでしょうか?ループを使ってリストを反復している間にリストを修正するのは、特別な注意を払わなければ非常に悪い考えであることがわかりました。(1,-2)がリストに残っている理由は、リスト内の各項目の位置が for ループの反復の間に変化したからです。上のコードにもっと長いリストを与えた場合にどうなるか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="cba5525fdc4b748be86f6f7a8d4839e16d248545" translate="yes" xml:space="preserve">
          <source>You can try for-looping in reverse so for some_list you'll do something like:</source>
          <target state="translated">for-loopingを逆に試してみて、some_listの場合は次のようにします。</target>
        </trans-unit>
        <trans-unit id="fef932e24c895baf0179ccaa420e2bd7d0954340" translate="yes" xml:space="preserve">
          <source>You can use a list comprehension to create a new list containing only the elements you don't want to remove:</source>
          <target state="translated">リスト内包を使って、削除したくない要素だけを含むリストを新たに作成することができます。</target>
        </trans-unit>
        <trans-unit id="0fe88cac7a8c1d65c953157de58c81088b07d23d" translate="yes" xml:space="preserve">
          <source>You might want to use &lt;code&gt;filter()&lt;/code&gt; available as the built-in.</source>
          <target state="translated">組み込みとして利用可能な &lt;code&gt;filter()&lt;/code&gt; を使用したい場合があります。</target>
        </trans-unit>
        <trans-unit id="76db65aa7d7889fbb23154214040d2a4fa6894c1" translate="yes" xml:space="preserve">
          <source>You need to go backwards otherwise it's a bit like sawing off the tree-branch that you are sitting on :-)</source>
          <target state="translated">そうしないと、あなたが座っている木の枝を切り落とすのと同じような感じになってしまうので、後ろに行く必要があります。)</target>
        </trans-unit>
        <trans-unit id="80b0cf2331c96b3507f2cb33293c954612fab365" translate="yes" xml:space="preserve">
          <source>You need to take a copy of the list and iterate over it first, or the iteration will fail with what may be unexpected results.</source>
          <target state="translated">最初にリストのコピーを取って、それを反復する必要があります。</target>
        </trans-unit>
        <trans-unit id="adfd09eef6d8d4afdd5310e5f03eb9a705d7ec94" translate="yes" xml:space="preserve">
          <source>Your best approach for such an example would be a &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;list comprehension&lt;/a&gt;</source>
          <target state="translated">そのような例に対するあなたの最善のアプローチは、 &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;リストの理解です&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbc0aff80688baeb01a5a4cb720794fe808ad957" translate="yes" xml:space="preserve">
          <source>```</source>
          <target state="translated">```</target>
        </trans-unit>
        <trans-unit id="dfd3b60d353170b5585a8909968d17705c98f55e" translate="yes" xml:space="preserve">
          <source>and then &lt;strong&gt;next value (65)&lt;/strong&gt; move on to previous index.</source>
          <target state="translated">次に、 &lt;strong&gt;次の値（65）&lt;/strong&gt;が前のインデックスに移動します。</target>
        </trans-unit>
        <trans-unit id="256773140eb61f1cd6dd994baf6076f0cbda5306" translate="yes" xml:space="preserve">
          <source>and to avoid having to re-code the entire project with the new lists name:</source>
          <target state="translated">と、プロジェクト全体を新しいリスト名で再コード化する必要がないようにするためのものです。</target>
        </trans-unit>
        <trans-unit id="7c9ee5a07e5b78059e78b86ca4241fb482333081" translate="yes" xml:space="preserve">
          <source>both of which make it crystal clear that you cannot modify a list being iterated except with the iterator itself, and gives you efficient ways to do so without copying the list.</source>
          <target state="translated">これらは、イテレータ自身以外ではイテレータされているリストを変更することができないことを明確にし、リストをコピーすることなく効率的な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="6d12700c2217a6fd0f4bff860dfcd30dd2761df6" translate="yes" xml:space="preserve">
          <source>consider you have a list,</source>
          <target state="translated">リストを持っていると考えてください。</target>
        </trans-unit>
        <trans-unit id="877d45d55490879d4296a7fe796015d42f80527e" translate="yes" xml:space="preserve">
          <source>copy.copy(x) 
  Return a shallow copy of x.</source>
          <target state="translated">copy.copy(x)x の浅いコピーを返します。</target>
        </trans-unit>
        <trans-unit id="e379d3ba5b6ab3903a95b94fa0aad486fec92cef" translate="yes" xml:space="preserve">
          <source>copy.deepcopy(x) 
  Return a deep copy of x.</source>
          <target state="translated">copy.deepcopy(x)x のディープコピーを返します。</target>
        </trans-unit>
        <trans-unit id="7b4c418dc9f6bec70118f7721079c58620f7e7c8" translate="yes" xml:space="preserve">
          <source>during 5th iteration,</source>
          <target state="translated">5回目のイテレーションでは</target>
        </trans-unit>
        <trans-unit id="fb5bc8bbd4a82ff3b60e90dcd93261b98bd06448" translate="yes" xml:space="preserve">
          <source>for loop will be iterate through index..</source>
          <target state="translated">forループはインデックスを反復処理します。</target>
        </trans-unit>
        <trans-unit id="2c3a0ef6ef4316e6e5d1c614dce6be8faad1cb40" translate="yes" xml:space="preserve">
          <source>i.e.</source>
          <target state="translated">i.e.</target>
        </trans-unit>
        <trans-unit id="f9a405f5d71953928e26ce3b09f8a952c37a7815" translate="yes" xml:space="preserve">
          <source>note, from Python documentation:</source>
          <target state="translated">note、Pythonドキュメントより。</target>
        </trans-unit>
        <trans-unit id="3c7aec3e12f7c3f23e559160305465cb5a2d42df" translate="yes" xml:space="preserve">
          <source>now you it will give,</source>
          <target state="translated">今、あなたはそれが与えるでしょう。</target>
        </trans-unit>
        <trans-unit id="952d109808fc70092cb9652c674259cd795c7282" translate="yes" xml:space="preserve">
          <source>one way to do it is with the slice notation &lt;code&gt;[:]&lt;/code&gt;</source>
          <target state="translated">これを行う1つの方法は、スライス表記 &lt;code&gt;[:]&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="9440205f7b297bb97378c8ee9cd6dd38026733b0" translate="yes" xml:space="preserve">
          <source>so 4th iteration done pointer moved onto 5th..</source>
          <target state="translated">4回目の反復は、ポインタが5回目に移動しました...</target>
        </trans-unit>
        <trans-unit id="32303bd0019c71856b3bd0ca577afa9b20a6f1d4" translate="yes" xml:space="preserve">
          <source>so do copy of list using &lt;code&gt;list[::]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;list[::]&lt;/code&gt; を使用してリストのコピーを行う</target>
        </trans-unit>
        <trans-unit id="b67a61431e78c0efef0f8344a3155b585fc957b6" translate="yes" xml:space="preserve">
          <source>so you can try comprehension instead.</source>
          <target state="translated">あなたは理解力を試すことができます。</target>
        </trans-unit>
        <trans-unit id="c56b5b45bd0c8acb29daa7a9f24462a60d123bd4" translate="yes" xml:space="preserve">
          <source>so you shouldn't reference list into another variable which still reference original instead of copy.</source>
          <target state="translated">のように、リストを別の変数に参照してはいけないので、コピーではなくオリジナルを参照するような変数にリストを参照するべきではありません。</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="0b64514082f4dab14fe23e3dcbcb92cea9f748ba" translate="yes" xml:space="preserve">
          <source>start a new array from scratch, and &lt;code&gt;.append()&lt;/code&gt; back at the end: &lt;a href=&quot;https://stackoverflow.com/a/1207460/895245&quot;&gt;https://stackoverflow.com/a/1207460/895245&lt;/a&gt;</source>
          <target state="translated">新しい配列を最初から開始し、最後に &lt;code&gt;.append()&lt;/code&gt; を戻し&lt;a href=&quot;https://stackoverflow.com/a/1207460/895245&quot;&gt;ます&lt;/a&gt; ： https : //stackoverflow.com/a/1207460/895245</target>
        </trans-unit>
        <trans-unit id="0166462591b186a6ce777cfdce9d2d4e230d1977" translate="yes" xml:space="preserve">
          <source>thats why your loop doesnt cover 65 since its moved into previous index.</source>
          <target state="translated">それはあなたのループが65をカバーしていない理由は、その前のインデックスに移動してからです。</target>
        </trans-unit>
        <trans-unit id="3c060051ec2702c90517f75bb0955c4fed00b1ad" translate="yes" xml:space="preserve">
          <source>uppose a list of number and you want to remove all no which are divisible by 3,</source>
          <target state="translated">数のリストをアップロードして、3で割り切れるものをすべて削除したい場合。</target>
        </trans-unit>
        <trans-unit id="c2c2f6b4aca96b4db1ec0779cbfab2e190a97931" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;del&lt;/code&gt; with an index: &lt;a href=&quot;https://stackoverflow.com/a/1207485/895245&quot;&gt;https://stackoverflow.com/a/1207485/895245&lt;/a&gt;</source>
          <target state="translated">インデックスで &lt;code&gt;del&lt;/code&gt; を使用： &lt;a href=&quot;https://stackoverflow.com/a/1207485/895245&quot;&gt;https&lt;/a&gt; : //stackoverflow.com/a/1207485/895245</target>
        </trans-unit>
        <trans-unit id="c77354b6717d46ffe5ad4fcd2e94f33c21d88f30" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;lambda filter&lt;/code&gt; function, this will create resultant new list and consume memeory space</source>
          <target state="translated">&lt;code&gt;lambda filter&lt;/code&gt; 関数を使用すると、結果の新しいリストが作成され、メモリ領域が消費されます</target>
        </trans-unit>
        <trans-unit id="b1c7e2bae9e038687eb2d3cce815acc3dcac458c" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;list comprehension&lt;/code&gt;,this will careate a new list and create new memory space</source>
          <target state="translated">&lt;code&gt;list comprehension&lt;/code&gt; を使用して、これは新しいリストを気遣い、新しいメモリ空間を作成します</target>
        </trans-unit>
        <trans-unit id="5c3c89eedc5f3e318d8c78de0dae591b09b494ef" translate="yes" xml:space="preserve">
          <source>which supports all the iterable like, list, tuple, dict, string etc</source>
          <target state="translated">リスト、タプル、dict、文字列など、すべての反復可能なものをサポートしています。</target>
        </trans-unit>
        <trans-unit id="c9ac37e61a632309fe6ac352cebdb1140b02c11f" translate="yes" xml:space="preserve">
          <source>without consuming memory space for new list and modify existing list</source>
          <target state="translated">新しいリストのためにメモリを消費することなく、既存のリストを変更することなく</target>
        </trans-unit>
        <trans-unit id="e6eb9174b0a0f9124941d34b2c9c2b9375d4cb20" translate="yes" xml:space="preserve">
          <source>you have using list variable called &lt;code&gt;lis&lt;/code&gt;. and you using same to remove..</source>
          <target state="translated">&lt;code&gt;lis&lt;/code&gt; というリスト変数を使用しています。 同じものを使って削除します</target>
        </trans-unit>
        <trans-unit id="f4735f130b7506791a866079cea171cee93ee923" translate="yes" xml:space="preserve">
          <source>you need to make a copy of the iterated list to modify it</source>
          <target state="translated">を変更するには、反復リストのコピーを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="9c0c41a37eef8bb146367129bb2695642d431ffa" translate="yes" xml:space="preserve">
          <source>your &lt;strong&gt;number 35&lt;/strong&gt; was not a prime so you removed it from a list.</source>
          <target state="translated">&lt;strong&gt;35&lt;/strong&gt;は素数ではなかったので、リストから削除しました。</target>
        </trans-unit>
        <trans-unit id="c3e100f0c1beaa3886a138699e84f88bf0090a45" translate="yes" xml:space="preserve">
          <source>your variable</source>
          <target state="translated">おたくのへんすう</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
