<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1207406">
    <body>
      <group id="1207406">
        <trans-unit id="3b2c92f73dff63b7b88c756e8c6c4ea763db1c81" translate="yes" xml:space="preserve">
          <source>1) When using remove(), you attempt to remove integers whereas you need to remove a tuple.</source>
          <target state="translated">1)Cuando se utiliza remove(),se intenta eliminar los números enteros mientras que se necesita eliminar una tupla.</target>
        </trans-unit>
        <trans-unit id="c26bec6ae55dfa38b757d819eb9fa58107cda58b" translate="yes" xml:space="preserve">
          <source>2) The for loop will skip items in your list.</source>
          <target state="translated">2)El bucle &quot;for&quot; salteará los elementos de su lista.</target>
        </trans-unit>
        <trans-unit id="41f1f874fa2b979825cd5672d52c9f672bb63674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Filter&lt;/code&gt; receives a function and a sequence. &lt;code&gt;Filter&lt;/code&gt; applies the passed function to each element in turn, and then decides whether to retain or discard the element depending on whether the function return value is &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Filter&lt;/code&gt; recibe una funci&amp;oacute;n y una secuencia. &lt;code&gt;Filter&lt;/code&gt; aplica la funci&amp;oacute;n pasada a cada elemento por turno y luego decide si desea retener o descartar el elemento dependiendo de si el valor de retorno de la funci&amp;oacute;n es &lt;code&gt;True&lt;/code&gt; o &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f7e48e862214b7809d0460c5e1af926208bd696" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enumerate&lt;/code&gt; gives you access to the item and the index at once. &lt;code&gt;reversed&lt;/code&gt; is so that the indices that you're going to later delete don't change on you.</source>
          <target state="translated">&lt;code&gt;enumerate&lt;/code&gt; le da acceso al elemento y al &amp;iacute;ndice a la vez. &lt;code&gt;reversed&lt;/code&gt; es para que los &amp;iacute;ndices que va a eliminar m&amp;aacute;s tarde no cambien en usted.</target>
        </trans-unit>
        <trans-unit id="4de7ada0839383f54f19d7f396d39fb507f52e99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What I have chosen is a randomly chosen example. &lt;strong&gt;Feel free to change&lt;/strong&gt; the &lt;strong&gt;list of tuples&lt;/strong&gt; and the &lt;strong&gt;condition&lt;/strong&gt; that I have chosen.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Lo que he elegido es un ejemplo elegido al azar.&lt;/em&gt; &lt;em&gt;&lt;strong&gt;Si&amp;eacute;ntase libre de cambiar&lt;/strong&gt; la &lt;strong&gt;lista de tuplas&lt;/strong&gt; y la &lt;strong&gt;condici&amp;oacute;n&lt;/strong&gt; que he elegido.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41cfd101eef50f2ce2c163096a74fa93f38da56b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best workarounds&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Las mejores soluciones&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ccd82364b395036f5280ff13da623f258d9644df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution: You can also not handle iterators. Iterators are sometimes better than sequences.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Precauci&amp;oacute;n: tampoco puede manejar iteradores.&lt;/strong&gt; &lt;strong&gt;Los iteradores son a veces mejores que las secuencias.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81b8bc03967964ba1eea500b2bc7787b4b23c68e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Could Python do this better?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Podr&amp;iacute;a Python hacer esto mejor?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="788e3773d2b7d304ae70795cc020d884336ac974" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1 and method 2 are faster than method 3&lt;/strong&gt;. Method2 and method3 are more efficient than method1. I &lt;strong&gt;prefer method2&lt;/strong&gt;. For the aforementioned example, &lt;code&gt;time(method1) : time(method2) : time(method3) = 1 : 1 : 1.7&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;El m&amp;eacute;todo 1 y el m&amp;eacute;todo 2 son m&amp;aacute;s r&amp;aacute;pidos que el m&amp;eacute;todo 3&lt;/strong&gt; . M&amp;eacute;todo2 y m&amp;eacute;todo3 son m&amp;aacute;s eficientes que m&amp;eacute;todo1. &lt;strong&gt;Prefiero el m&amp;eacute;todo 2&lt;/strong&gt; . Para el ejemplo mencionado anteriormente, &lt;code&gt;time(method1) : time(method2) : time(method3) = 1 : 1 : 1.7&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6dcc3dfb40a81d59ef252bee9510d3a8af5cdc6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1.&amp;gt;&lt;/strong&gt; Use the framework that you had suggested (where one fills in a code inside a for loop). I use a small code with &lt;code&gt;del&lt;/code&gt; to delete a tuple that meets the said condition. However, this method will miss a tuple (which satisfies the said condition) if two consecutively placed tuples meet the given condition.</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo 1.&amp;gt;&lt;/strong&gt; Use el marco que hab&amp;iacute;a sugerido (donde se completa un c&amp;oacute;digo dentro de un bucle for). Utilizo un peque&amp;ntilde;o c&amp;oacute;digo con &lt;code&gt;del&lt;/code&gt; para eliminar una tupla que cumple con dicha condici&amp;oacute;n. Sin embargo, este m&amp;eacute;todo perder&amp;aacute; una tupla (que satisface dicha condici&amp;oacute;n) si dos tuplas colocadas consecutivamente cumplen la condici&amp;oacute;n dada.</target>
        </trans-unit>
        <trans-unit id="8a87ff388a2cd2a3b0c5940103c76fd9ebd422c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 2.&amp;gt;&lt;/strong&gt; Construct a new list which contains elements (tuples) where the given condition is not met (this is the same thing as removing elements of list where the given condition is met). Following is the code for that:</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo 2.&amp;gt;&lt;/strong&gt; Construya una nueva lista que contenga elementos (tuplas) donde no se cumpla la condici&amp;oacute;n dada (esto es lo mismo que eliminar elementos de la lista donde se cumple la condici&amp;oacute;n dada). El siguiente es el c&amp;oacute;digo para eso:</target>
        </trans-unit>
        <trans-unit id="63bda6e7a91b63c3a620d3c5e06adb18cc1e0fc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 3.&amp;gt;&lt;/strong&gt; Find indices where the given condition is met, and then use remove elements (tuples) corresponding to those indices. Following is the code for that.</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo 3.&amp;gt;&lt;/strong&gt; Encuentre &amp;iacute;ndices donde se cumpla la condici&amp;oacute;n dada y luego use elementos de eliminaci&amp;oacute;n (tuplas) correspondientes a esos &amp;iacute;ndices. El siguiente es el c&amp;oacute;digo para eso.</target>
        </trans-unit>
        <trans-unit id="5b34cc7bf01f9d2e80a510543d0a68d2bbdb4dfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Official Python 2 tutorial 4.2. &quot;for Statements&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tutorial oficial de Python 2 4.2.&lt;/strong&gt; &lt;strong&gt;&quot;para declaraciones&quot;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="557cafd24827735707266d1c1085114004a6d458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 2 documentation 7.3. &quot;The for statement&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Documentaci&amp;oacute;n de Python 2 7.3.&lt;/strong&gt; &lt;strong&gt;&quot;El para declaraci&amp;oacute;n&quot;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fc8a02d37d7e4516e492ebd254cc004a1d0b7e9" translate="yes" xml:space="preserve">
          <source>Above we have used the &lt;code&gt;pop&lt;/code&gt; method on the fluid list object. Other common iterable methods are also implemented such as &lt;code&gt;del fluidL[i]&lt;/code&gt;, &lt;code&gt;.remove&lt;/code&gt;, &lt;code&gt;.insert&lt;/code&gt;, &lt;code&gt;.append&lt;/code&gt;, &lt;code&gt;.extend&lt;/code&gt;. The list can also be modified using slices (&lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;reverse&lt;/code&gt; methods are not implemented).</source>
          <target state="translated">Arriba hemos usado el m&amp;eacute;todo &lt;code&gt;pop&lt;/code&gt; en el objeto de la lista de fluidos. Tambi&amp;eacute;n se implementan otros m&amp;eacute;todos iterables comunes, como &lt;code&gt;del fluidL[i]&lt;/code&gt; , &lt;code&gt;.remove&lt;/code&gt; , &lt;code&gt;.insert&lt;/code&gt; , &lt;code&gt;.append&lt;/code&gt; , &lt;code&gt;.extend&lt;/code&gt; . La lista tambi&amp;eacute;n se puede modificar mediante sectores (no se implementan los m&amp;eacute;todos de &lt;code&gt;sort&lt;/code&gt; e &lt;code&gt;reverse&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="16670fb950d5c5fdd6c0fd65ad6b86d68d95e137" translate="yes" xml:space="preserve">
          <source>Aha! Each element of L1 is actually a tuple. So that's what we need to be passing to remove(). Tuples in python are very easy, they're simply made by enclosing values in parentheses. &quot;a, b&quot; is not a tuple, but &quot;(a, b)&quot; is a tuple. So we modify your code and run it again:</source>
          <target state="translated">¡Ajá! Cada elemento de L1 es en realidad una tupla.Así que eso es lo que tenemos que pasar para eliminarlo.Las tuplas en pitón son muy fáciles,se hacen simplemente encerrando los valores entre paréntesis.&quot;a,b&quot; no es una tupla,pero &quot;a,b&quot; es una tupla.Así que modificamos su código y lo ejecutamos de nuevo:</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Un ejemplo:</target>
        </trans-unit>
        <trans-unit id="6289272e180651017551f0d23619c6b843207579" translate="yes" xml:space="preserve">
          <source>As I stated to start with: this is a complicated solution that will hurt the readability of your code and make it more difficult to debug. Therefore other solutions such as the list comprehensions mentioned in David Raznick's &lt;a href=&quot;https://stackoverflow.com/a/1207461/4451578&quot;&gt;answer&lt;/a&gt; should be considered first. That being said, I have found times where this class has been useful to me and has been easier to use than keeping track of the indices of elements that need deleting.</source>
          <target state="translated">Como dije para comenzar: esta es una soluci&amp;oacute;n complicada que da&amp;ntilde;ar&amp;aacute; la legibilidad de su c&amp;oacute;digo y dificultar&amp;aacute; la depuraci&amp;oacute;n. Por lo tanto, otras soluciones, como las comprensiones de listas mencionadas en la &lt;a href=&quot;https://stackoverflow.com/a/1207461/4451578&quot;&gt;respuesta de&lt;/a&gt; David Raznick, deben considerarse primero. Dicho esto, he encontrado momentos en los que esta clase me ha sido &amp;uacute;til y ha sido m&amp;aacute;s f&amp;aacute;cil de usar que hacer un seguimiento de los &amp;iacute;ndices de elementos que deben eliminarse.</target>
        </trans-unit>
        <trans-unit id="b0de2e5d5f6712623237e9fe813e112b1056e691" translate="yes" xml:space="preserve">
          <source>As you can infer from that result, every time that the conditional statement evaluates to true and a list item is removed, the next iteration of the loop will skip evaluation of the next item in the list because its values are now located at different indices.</source>
          <target state="translated">Como se puede deducir de ese resultado,cada vez que la declaración condicional se evalúa como verdadera y se elimina un elemento de la lista,la siguiente iteración del bucle salteará la evaluación del siguiente elemento de la lista porque sus valores se encuentran ahora en índices diferentes.</target>
        </trans-unit>
        <trans-unit id="f9468c326a4a729e70975ea2231fdda83d27f476" translate="yes" xml:space="preserve">
          <source>But what if the result of the &lt;code&gt;testFunc&lt;/code&gt; depends on the elements that have been added to &lt;code&gt;newList&lt;/code&gt; already? Or the elements still in &lt;code&gt;oldList&lt;/code&gt; that might be added next? There might still be a way to use a list comprehension but it will begin to lose it's elegance, and for me it feels easier to modify a list in place.</source>
          <target state="translated">Pero, &amp;iquest;qu&amp;eacute; &lt;code&gt;testFunc&lt;/code&gt; si el resultado de testFunc depende de los elementos que ya se han agregado a &lt;code&gt;newList&lt;/code&gt; ? &amp;iquest;O los elementos que todav&amp;iacute;a est&amp;aacute;n en &lt;code&gt;oldList&lt;/code&gt; que podr&amp;iacute;an agregarse a continuaci&amp;oacute;n? Puede que todav&amp;iacute;a haya una manera de utilizar la comprensi&amp;oacute;n de una lista, pero comenzar&amp;aacute; a perder su elegancia, y para m&amp;iacute; es m&amp;aacute;s f&amp;aacute;cil modificar una lista en su lugar.</target>
        </trans-unit>
        <trans-unit id="ab99bb95d0a8563a2528243c1af734b49825dea8" translate="yes" xml:space="preserve">
          <source>C++ &lt;a href=&quot;https://en.cppreference.com/w/cpp/container/vector/erase&quot;&gt;&lt;code&gt;std::vector::erase&lt;/code&gt;&lt;/a&gt; which returns a valid interator to the element after the one removed</source>
          <target state="translated">C ++ &lt;a href=&quot;https://en.cppreference.com/w/cpp/container/vector/erase&quot;&gt; &lt;code&gt;std::vector::erase&lt;/code&gt; &lt;/a&gt; que devuelve un interador v&amp;aacute;lido al elemento despu&amp;eacute;s del eliminado</target>
        </trans-unit>
        <trans-unit id="70de89a9d1057697c722db9334aea9338d7d9424" translate="yes" xml:space="preserve">
          <source>Copying the list using &lt;code&gt;remove&lt;/code&gt; might make your code look a little cleaner, as described in one of the answers below.  You should definitely not do this for extremely large lists, since this involves first copying the entire list, and also performing an &lt;code&gt;O(n)&lt;/code&gt;&lt;code&gt;remove&lt;/code&gt; operation for each element being removed, making this an &lt;code&gt;O(n^2)&lt;/code&gt; algorithm.</source>
          <target state="translated">Copiar la lista usando &lt;code&gt;remove&lt;/code&gt; puede hacer que su c&amp;oacute;digo se vea un poco m&amp;aacute;s limpio, como se describe en una de las respuestas a continuaci&amp;oacute;n. Definitivamente, no debe hacer esto para listas extremadamente grandes, ya que esto implica copiar primero la lista completa y tambi&amp;eacute;n realizar una operaci&amp;oacute;n de &lt;code&gt;remove&lt;/code&gt; &lt;code&gt;O(n)&lt;/code&gt; para cada elemento que se elimina, lo que lo convierte en un algoritmo &lt;code&gt;O(n^2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf79941ef09fc206b51225e5da9c16355e55b212" translate="yes" xml:space="preserve">
          <source>Download &lt;code&gt;fluidIter.py&lt;/code&gt; from &lt;a href=&quot;https://github.com/alanbacon/FluidIterator&quot;&gt;here&lt;/a&gt;&lt;code&gt;https://github.com/alanbacon/FluidIterator&lt;/code&gt;, it is just a single file so no need to install git. There is no installer so you will need to make sure that the file is in the python path your self. The code has been written for python 3 and is untested on python 2.</source>
          <target state="translated">Descargue &lt;code&gt;fluidIter.py&lt;/code&gt; desde &lt;a href=&quot;https://github.com/alanbacon/FluidIterator&quot;&gt;aqu&amp;iacute;&lt;/a&gt; &lt;code&gt;https://github.com/alanbacon/FluidIterator&lt;/code&gt; , es solo un archivo, por lo que no es necesario instalar git. No hay instalador, por lo que deber&amp;aacute; asegurarse de que el archivo est&amp;eacute; en la ruta de Python. El c&amp;oacute;digo ha sido escrito para python 3 y no ha sido probado en python 2.</target>
        </trans-unit>
        <trans-unit id="1a2545867f0ca9597a7db53881bd6afe7c73dffe" translate="yes" xml:space="preserve">
          <source>Edit: As mentioned in the comments, this answer does not really present a problem for which this approach provides a solution. I will try to address that here:</source>
          <target state="translated">Editar:Como se mencionó en los comentarios,esta respuesta no presenta realmente un problema para el que este enfoque proporcione una solución.Trataré de abordar eso aquí:</target>
        </trans-unit>
        <trans-unit id="a788b2421c51b170010ec2c266d516cb0be3f175" translate="yes" xml:space="preserve">
          <source>Edit: The last code example in this answer gives a use case for &lt;strong&gt;&lt;em&gt;why&lt;/em&gt;&lt;/strong&gt; you might sometimes want to modify a list in place rather than use a list comprehension. The first part of the answers serves as tutorial of &lt;strong&gt;&lt;em&gt;how&lt;/em&gt;&lt;/strong&gt; an array can be modified in place.</source>
          <target state="translated">Editar: el &amp;uacute;ltimo ejemplo de c&amp;oacute;digo en esta respuesta ofrece un caso de uso de por &lt;strong&gt;&lt;em&gt;qu&amp;eacute;&lt;/em&gt;&lt;/strong&gt; a veces es posible que desee modificar una lista en lugar de utilizar una comprensi&amp;oacute;n de la lista. La primera parte de las respuestas sirve como tutorial de &lt;strong&gt;&lt;em&gt;c&amp;oacute;mo&lt;/em&gt;&lt;/strong&gt; se puede modificar una matriz en su lugar.</target>
        </trans-unit>
        <trans-unit id="c8078d924b19f64b223a6df8142a489104063237" translate="yes" xml:space="preserve">
          <source>Either:</source>
          <target state="translated">Either:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2e016639bfdc35ff47021bee07e0442c9bf6e95a" translate="yes" xml:space="preserve">
          <source>Finally, there is one cleaner solution than having to make an entirely new copy of L1. The reversed() function:</source>
          <target state="translated">Finalmente,hay una solución más limpia que tener que hacer una copia completamente nueva de L1.La función reverse():</target>
        </trans-unit>
        <trans-unit id="c44ea041349ed36728514202e8abfa264d478d68" translate="yes" xml:space="preserve">
          <source>First of all you'll need to &lt;strong&gt;replace foreach loop with while loop&lt;/strong&gt;,</source>
          <target state="translated">En primer lugar, deber&amp;aacute; &lt;strong&gt;reemplazar el bucle foreach con el bucle while&lt;/strong&gt; ,</target>
        </trans-unit>
        <trans-unit id="a4bbfc8e8879463ee80d588ea8bff37fe8625e66" translate="yes" xml:space="preserve">
          <source>For anything that has the potential to be really big, I use the following.</source>
          <target state="translated">Para cualquier cosa que tenga el potencial de ser realmente grande,utilizo lo siguiente.</target>
        </trans-unit>
        <trans-unit id="c9d41ff6b00990841a094958bdca36f5ecbef710" translate="yes" xml:space="preserve">
          <source>For example (depends on what type of list):</source>
          <target state="translated">Por ejemplo (depende de qué tipo de lista):</target>
        </trans-unit>
        <trans-unit id="d3826d07dc82c819a2952d0b19069cf2dcd53dc5" translate="yes" xml:space="preserve">
          <source>For more details &lt;a href=&quot;http://docs.python.org/library/functions.html#filter&quot;&gt;check here&lt;/a&gt;</source>
          <target state="translated">Para m&amp;aacute;s detalles &lt;a href=&quot;http://docs.python.org/library/functions.html#filter&quot;&gt;ver aqu&amp;iacute;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0682dfde6b8575edaa27bd1c03020cbce20014a8" translate="yes" xml:space="preserve">
          <source>For those that like functional programming:</source>
          <target state="translated">Para los que les gusta la programación funcional:</target>
        </trans-unit>
        <trans-unit id="a74dc39ba82bf47d723236da822a90c8ff7a3ec2" translate="yes" xml:space="preserve">
          <source>Fortunately, it's extremely easy to get both the speed of list comprehensions AND the required semantics of in-place alteration -- just code:</source>
          <target state="translated">Afortunadamente,es extremadamente fácil obtener tanto la velocidad de comprensión de la lista como la semántica necesaria de la alteración en el lugar...sólo el código:</target>
        </trans-unit>
        <trans-unit id="c36edd270beeffac5974b87eb6c988c0cf556914" translate="yes" xml:space="preserve">
          <source>Full answer:</source>
          <target state="translated">Respuesta completa:</target>
        </trans-unit>
        <trans-unit id="56e8e2cad0c7d16346946903b1f1df0e011a6ba1" translate="yes" xml:space="preserve">
          <source>Generally you just want to go for the faster &lt;code&gt;.append()&lt;/code&gt; option by default unless memory is a big concern.</source>
          <target state="translated">En general, solo desea &lt;code&gt;.append()&lt;/code&gt; opci&amp;oacute;n .append () m&amp;aacute;s r&amp;aacute;pida de forma predeterminada a menos que la memoria sea una gran preocupaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="88f8f55fdd9b1ef963f6e91ea73765a38063d284" translate="yes" xml:space="preserve">
          <source>Here is an example where copying the list beforehand is incorrect, reverse iteration is impossible and a list comprehension is also not an option.</source>
          <target state="translated">He aquí un ejemplo en el que copiar la lista de antemano es incorrecto,la iteración inversa es imposible y la comprensión de la lista tampoco es una opción.</target>
        </trans-unit>
        <trans-unit id="015e2b33e48d8c457bdeefa7777500d6753f17a6" translate="yes" xml:space="preserve">
          <source>How to remove items from a list while iterating</source>
          <target state="translated">Cómo eliminar elementos de una lista mientras se itera</target>
        </trans-unit>
        <trans-unit id="c77620b856d20a8819f9b0b470a56a1277c2fb40" translate="yes" xml:space="preserve">
          <source>However, I disagree with this implementation, since &lt;code&gt;.remove()&lt;/code&gt; has to iterate the &lt;em&gt;entire list&lt;/em&gt; to find the value.</source>
          <target state="translated">Sin embargo, no estoy de acuerdo con esta implementaci&amp;oacute;n, ya que &lt;code&gt;.remove()&lt;/code&gt; tiene que iterar &lt;em&gt;toda la lista&lt;/em&gt; para encontrar el valor.</target>
        </trans-unit>
        <trans-unit id="69b67973d6a8e6ef36e2888307c19b186e7df019" translate="yes" xml:space="preserve">
          <source>However, the output will be identical to before:</source>
          <target state="translated">Sin embargo,la salida será idéntica a la de antes:</target>
        </trans-unit>
        <trans-unit id="3f4aacab5e7adbd49358dc9debb14a93fa23eb41" translate="yes" xml:space="preserve">
          <source>I can think of three approaches to solve your problem. As an example, I will create a random list of tuples &lt;code&gt;somelist = [(1,2,3), (4,5,6), (3,6,6), (7,8,9), (15,0,0), (10,11,12)]&lt;/code&gt;. The condition that I choose is &lt;code&gt;sum of elements of a tuple = 15&lt;/code&gt;. In the final list we will only have those tuples whose sum is not equal to 15.</source>
          <target state="translated">Se me ocurren tres enfoques para resolver su problema. Como ejemplo, crear&amp;eacute; una lista aleatoria de tuplas &lt;code&gt;somelist = [(1,2,3), (4,5,6), (3,6,6), (7,8,9), (15,0,0), (10,11,12)]&lt;/code&gt; . La condici&amp;oacute;n que elijo es la &lt;code&gt;sum of elements of a tuple = 15&lt;/code&gt; . En la lista final solo tendremos esas tuplas cuya suma no es igual a 15.</target>
        </trans-unit>
        <trans-unit id="a368dea51582938f2ab67c94c9f3b922d05e401f" translate="yes" xml:space="preserve">
          <source>I needed to do something similar and in my case the problem was memory - I needed to merge multiple dataset objects within a list, after doing some stuff with them, as a new object, and needed to get rid of each entry I was merging to avoid duplicating all of them and blowing up memory. In my case having the objects in a dictionary instead of a list worked fine:</source>
          <target state="translated">Necesitaba hacer algo similar y en mi caso el problema era la memoria-necesitaba fusionar múltiples objetos de conjuntos de datos dentro de una lista,después de hacer algunas cosas con ellos,como un nuevo objeto,y necesitaba deshacerme de cada entrada que estaba fusionando para evitar duplicarlas todas y hacer explotar la memoria.En mi caso,tener los objetos en un diccionario en lugar de una lista funcionaba bien:</target>
        </trans-unit>
        <trans-unit id="cd970f7da56e80281558904a4e1d263b5a3fa2d2" translate="yes" xml:space="preserve">
          <source>I needed to do this with a huge list, and duplicating the list seemed expensive, especially since in my case the number of deletions would be few compared to the items that remain. I took this low-level approach.</source>
          <target state="translated">Necesitaba hacerlo con una lista enorme,y duplicar la lista parecía caro,sobre todo porque en mi caso el número de eliminaciones sería escaso en comparación con los elementos que quedan.Tomé este enfoque de bajo nivel.</target>
        </trans-unit>
        <trans-unit id="61eac64b85c8bcbd86114f439152c5f3727dc586" translate="yes" xml:space="preserve">
          <source>I wrote a library that allows you to do this:</source>
          <target state="translated">Escribí una biblioteca que te permite hacer esto:</target>
        </trans-unit>
        <trans-unit id="93e8f9e56c8391ff4d8114fdd92027090dcb5149" translate="yes" xml:space="preserve">
          <source>I'm iterating over a list of tuples in Python, and am attempting to remove them if they meet certain criteria.</source>
          <target state="translated">Estoy iterando sobre una lista de tuplas en Python,y estoy intentando eliminarlas si cumplen ciertos criterios.</target>
        </trans-unit>
        <trans-unit id="40067d779a3f3245e65a2ab2e94f2fec69eb4c56" translate="yes" xml:space="preserve">
          <source>If we want to access the current index value of the list we cannot use enumerate, as this only counts how many times the for loop has run. Instead we will use the iterator object directly.</source>
          <target state="translated">Si queremos acceder al valor actual del índice de la lista no podemos utilizar enumerar,ya que esto sólo cuenta cuántas veces se ha ejecutado el bucle for.En su lugar utilizaremos directamente el objeto iterador.</target>
        </trans-unit>
        <trans-unit id="7baf994253e5422333a06fc8988fe24496aaf2a2" translate="yes" xml:space="preserve">
          <source>If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy. The slice notation makes this especially convenient:</source>
          <target state="translated">Si necesita modificar la secuencia sobre la que está iterando mientras está dentro del bucle (por ejemplo,para duplicar elementos seleccionados),se recomienda hacer primero una copia.Iterar sobre una secuencia no implica hacer una copia.La notación de rebanada hace que esto sea especialmente conveniente:</target>
        </trans-unit>
        <trans-unit id="d87b562086fac008b600e2b8d4a9b5150a639c97" translate="yes" xml:space="preserve">
          <source>If you want to delete elements from a list while iterating, use a while-loop so you can alter the current index and end index after each deletion.</source>
          <target state="translated">Si desea eliminar elementos de una lista mientras itera,utilice un bucle while para poder alterar el índice actual y el índice final después de cada eliminación.</target>
        </trans-unit>
        <trans-unit id="da17f6befdc523de38569c671e0632dd8feef1a1" translate="yes" xml:space="preserve">
          <source>If you want to do anything else during the iteration, it may be nice to get both the index (which guarantees you being able to reference it, for example if you have a list of dicts) and the actual list item contents.</source>
          <target state="translated">Si desea hacer algo más durante la iteración,puede ser bueno obtener tanto el índice (que le garantiza poder referirse a él,por ejemplo si tiene una lista de dictados)como el contenido real de los elementos de la lista.</target>
        </trans-unit>
        <trans-unit id="a9b71d2114bfedf22c95c100902b07fb9eda5c92" translate="yes" xml:space="preserve">
          <source>If you will use the new list later, you can simply set the elem to None, and then judge it in the later loop, like this</source>
          <target state="translated">Si vas a usar la nueva lista más tarde,puedes simplemente poner el elemento en Ninguno,y luego juzgarlo en el bucle posterior,así</target>
        </trans-unit>
        <trans-unit id="cff757980d44c8978d107712bbd9c8346debf46a" translate="yes" xml:space="preserve">
          <source>In cases where you're doing something more complex than calling a &lt;code&gt;determine&lt;/code&gt; function, I prefer constructing a new list and simply appending to it as I go.  For example</source>
          <target state="translated">En los casos en que est&amp;aacute; haciendo algo m&amp;aacute;s complejo que llamar a una funci&amp;oacute;n de &lt;code&gt;determine&lt;/code&gt; , prefiero construir una nueva lista y simplemente agregarla a medida que avanzo. Por ejemplo</target>
        </trans-unit>
        <trans-unit id="245dc2132cc9d15cb2653900c35e1e34efd80517" translate="yes" xml:space="preserve">
          <source>In some situations, where you're doing more than simply filtering a list one item at time, you want your iteration to change while iterating.</source>
          <target state="translated">En algunas situaciones,en las que se hace algo más que filtrar un elemento de la lista de una en una,se quiere que la iteración cambie mientras se itera.</target>
        </trans-unit>
        <trans-unit id="25a3509e025bfbab60c4594a7314dfe96eee8d5a" translate="yes" xml:space="preserve">
          <source>In this way, you dont't need copy the list and it's easier to understand.</source>
          <target state="translated">De esta manera,no necesitas copiar la lista y es más fácil de entender.</target>
        </trans-unit>
        <trans-unit id="125406bb8e98603cdb6cb34508b6a4174012d403" translate="yes" xml:space="preserve">
          <source>Instead of a comprehension, you could also use &lt;code&gt;itertools&lt;/code&gt;. In Python 2:</source>
          <target state="translated">En lugar de una comprensi&amp;oacute;n, tambi&amp;eacute;n puede usar &lt;code&gt;itertools&lt;/code&gt; . En Python 2:</target>
        </trans-unit>
        <trans-unit id="f56af88d3f92e6edf9b095e4969fca472d8ed69b" translate="yes" xml:space="preserve">
          <source>It might be smart to also just create a new list if the current list item meets the desired criteria.</source>
          <target state="translated">Sería inteligente también crear una nueva lista si el elemento de la lista actual cumple con los criterios deseados.</target>
        </trans-unit>
        <trans-unit id="55998da221cafd68f95026750947ab3d3b827cb2" translate="yes" xml:space="preserve">
          <source>It seems like this particular Python API could be improved. Compare it, for instance, with:</source>
          <target state="translated">Parece que este API de Python en particular podría ser mejorado.Compáralo,por ejemplo,con:</target>
        </trans-unit>
        <trans-unit id="046f43ead4620ec5bc9285795e2a5ebcbbd51ae9" translate="yes" xml:space="preserve">
          <source>It's best to use another method if possible that doesn't require modifying your iterable while iterating over it, but for some algorithms it might not be that straight forward. And so if you are sure that you really do want the code pattern described in the original question, it is possible.</source>
          <target state="translated">Es mejor usar otro método si es posible que no requiera modificar su iterable mientras itera sobre él,pero para algunos algoritmos puede no ser tan sencillo.Así que si estás seguro de que realmente quieres el patrón de código descrito en la pregunta original,es posible.</target>
        </trans-unit>
        <trans-unit id="f87de0493fb3d04591d84b9514a64a8b1b2433ae" translate="yes" xml:space="preserve">
          <source>Java &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html&quot;&gt;ListIterator::remove&lt;/a&gt; which documents &quot;This call can only be made once per call to next or previous&quot;</source>
          <target state="translated">Java &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html&quot;&gt;ListIterator :: eliminar&lt;/a&gt; qu&amp;eacute; documentos &quot;Esta llamada solo se puede hacer una vez por llamada a la siguiente o anterior&quot;</target>
        </trans-unit>
        <trans-unit id="b8f5fc225cfb3362fa3e16aaa8090b08eeb8d9d7" translate="yes" xml:space="preserve">
          <source>Let's run through what happens when we execute your code:</source>
          <target state="translated">Repasemos lo que sucede cuando ejecutamos tu código:</target>
        </trans-unit>
        <trans-unit id="f8a9a21683177e7cde4a5592c377a6e74a389d1e" translate="yes" xml:space="preserve">
          <source>List comprehensions provide a way to generate a new list but these approaches tend to look at each element in isolation rather than the current state of the list as a whole.</source>
          <target state="translated">La comprensión de la lista proporciona una forma de generar una nueva lista,pero estos enfoques tienden a considerar cada elemento de forma aislada en lugar del estado actual de la lista en su conjunto.</target>
        </trans-unit>
        <trans-unit id="d2e359d0150a691e0d84043306b8fdd090ce18d0" translate="yes" xml:space="preserve">
          <source>More examples / tests can be found in the &lt;code&gt;if __name__ is &quot;__main__&quot;:&lt;/code&gt; section at the bottom of &lt;code&gt;fluidIter.py&lt;/code&gt;. These are worth looking at because they explain what happens in various situations. Such as: Replacing a large sections of the list using a slice. Or using (and modifying) the same iterable in nested for loops.</source>
          <target state="translated">Se pueden encontrar m&amp;aacute;s ejemplos / pruebas en la secci&amp;oacute;n &lt;code&gt;if __name__ is &quot;__main__&quot;:&lt;/code&gt; en la parte inferior de &lt;code&gt;fluidIter.py&lt;/code&gt; . Vale la pena mirarlos porque explican lo que sucede en diversas situaciones. Tales como: Reemplazar grandes secciones de la lista usando un segmento. O usando (y modificando) el mismo iterable en bucles anidados.</target>
        </trans-unit>
        <trans-unit id="da2749c0165cf2060c3dbe8c050ade5cfc962757" translate="yes" xml:space="preserve">
          <source>Most of the answers here want you to create a copy of the list. I had a use case where the list was quite long (110K items) and it was smarter to keep reducing the list instead.</source>
          <target state="translated">La mayoría de las respuestas aquí quieren que crees una copia de la lista.Tuve un caso de uso en el que la lista era bastante larga (110K artículos)y fue más inteligente seguir reduciendo la lista en su lugar.</target>
        </trans-unit>
        <trans-unit id="c80f5de1207f487c252821cc6bb7b9fc8eccb956" translate="yes" xml:space="preserve">
          <source>Note the subtle difference with other answers: this one is NOT assigning to a barename - it's assigning to a list slice that just happens to be the entire list, thereby replacing the list &lt;em&gt;contents&lt;/em&gt;&lt;strong&gt;within the same Python list object&lt;/strong&gt;, rather than just reseating one reference (from previous list object to new list object) like the other answers.</source>
          <target state="translated">Tenga en cuenta la sutil diferencia con otras respuestas: esta NO se asigna a un nombre desnudo: se asigna a un segmento de lista que resulta ser la lista completa, reemplazando as&amp;iacute; el &lt;em&gt;contenido de&lt;/em&gt; la lista &lt;strong&gt;dentro del mismo objeto de lista de Python&lt;/strong&gt; , en lugar de simplemente restablecer una referencia (desde el objeto de lista anterior al nuevo objeto de lista) como las otras respuestas.</target>
        </trans-unit>
        <trans-unit id="b2ac388e56496c2c3c957f43d877dd1d7fda2c8a" translate="yes" xml:space="preserve">
          <source>Note: There is a subtlety when the sequence is being modified by the loop (this can only occur for mutable sequences, i.e. lists). An internal counter is used to keep track of which item is used next, and this is incremented on each iteration. When this counter has reached the length of the sequence the loop terminates. This means that if the suite deletes the current (or a previous) item from the sequence, the next item will be skipped (since it gets the index of the current item which has already been treated). Likewise, if the suite inserts an item in the sequence before the current item, the current item will be treated again the next time through the loop. This can lead to nasty bugs that can be avoided by making a temporary copy using a slice of the whole sequence, e.g.,</source>
          <target state="translated">Nota:Hay una sutileza cuando la secuencia está siendo modificada por el bucle (esto sólo puede ocurrir en el caso de secuencias mutables,es decir,listas).Se utiliza un contador interno para llevar la cuenta de qué elemento se utiliza a continuación,y éste se incrementa en cada iteración.Cuando este contador ha alcanzado la longitud de la secuencia el bucle termina.Esto significa que si la suite borra el elemento actual (o uno anterior)de la secuencia,el siguiente elemento se salta (ya que obtiene el índice del elemento actual que ya ha sido tratado).De la misma manera,si la suite inserta un ítem en la secuencia antes del ítem actual,el ítem actual será tratado nuevamente la próxima vez a través del bucle.Esto puede dar lugar a errores desagradables que pueden evitarse haciendo una copia temporal utilizando un trozo de toda la secuencia,por ejemplo,</target>
        </trans-unit>
        <trans-unit id="17fc589ddf453f77430cdfb24061a48d22055a0b" translate="yes" xml:space="preserve">
          <source>One possible solution, useful if you want not only remove some things, but also do something with all elements in a single loop:</source>
          <target state="translated">Una posible solución,útil si quieres no sólo eliminar algunas cosas,sino también hacer algo con todos los elementos en un solo bucle:</target>
        </trans-unit>
        <trans-unit id="9989cc03f8130b33e38ebbe097e363902bb2ab71" translate="yes" xml:space="preserve">
          <source>Or in Python 3:</source>
          <target state="translated">O en Python 3:</target>
        </trans-unit>
        <trans-unit id="360486488323ae5b9c4a62711e3b574d44955347" translate="yes" xml:space="preserve">
          <source>Or, by assigning to the slice &lt;code&gt;somelist[:]&lt;/code&gt;, you can mutate the existing list to contain only the items you want:</source>
          <target state="translated">O, al asignar a la lista &lt;code&gt;somelist[:]&lt;/code&gt; , puede mutar la lista existente para que contenga solo los elementos que desee:</target>
        </trans-unit>
        <trans-unit id="79e5e39f10693e0d3d7f9bbd6e8a79ae8f411a56" translate="yes" xml:space="preserve">
          <source>Perhaps the underlying rationale is that Python lists are assumed to be dynamic array backed, and therefore any type of removal will be time inefficient anyways, while Java has a nicer interface hierarchy with both &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;/code&gt;&lt;/a&gt; implementations of &lt;code&gt;ListIterator&lt;/code&gt;.</source>
          <target state="translated">Quiz&amp;aacute;s la raz&amp;oacute;n subyacente es que se supone que las listas de Python est&amp;aacute;n respaldadas por una matriz din&amp;aacute;mica y, por lo tanto, cualquier tipo de eliminaci&amp;oacute;n ser&amp;aacute; ineficaz en el tiempo de todos modos, mientras que Java tiene una jerarqu&amp;iacute;a de interfaz m&amp;aacute;s agradable con las implementaciones &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html&quot;&gt; &lt;code&gt;LinkedList&lt;/code&gt; &lt;/a&gt; de &lt;code&gt;ListIterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ea5407d1e5d315fb9f7357791702e7406ce3cfa" translate="yes" xml:space="preserve">
          <source>Problem is you removed a value from a list during iteration then your list index will collapse.</source>
          <target state="translated">El problema es que si eliminas un valor de una lista durante la iteración,el índice de la lista se colapsará.</target>
        </trans-unit>
        <trans-unit id="a12a2e961432337248947c29211654dd9db80cac" translate="yes" xml:space="preserve">
          <source>Python 2 users: replace &lt;code&gt;range&lt;/code&gt; by &lt;code&gt;xrange&lt;/code&gt; to avoid creating a hardcoded list</source>
          <target state="translated">Usuarios de Python 2: reemplace el &lt;code&gt;range&lt;/code&gt; por &lt;code&gt;xrange&lt;/code&gt; para evitar crear una lista codificada</target>
        </trans-unit>
        <trans-unit id="48bce7473e48f3146f9e6a87451c0a6b7a287a30" translate="yes" xml:space="preserve">
          <source>Should work on all mutable sequences not just lists.</source>
          <target state="translated">Debería funcionar en todas las secuencias mutables,no sólo en las listas.</target>
        </trans-unit>
        <trans-unit id="d69dabce4725955fd5cfe5474202e42df310b5ad" translate="yes" xml:space="preserve">
          <source>TLDR:</source>
          <target state="translated">TLDR:</target>
        </trans-unit>
        <trans-unit id="152d20f48429364f6ffc8bed8d7c4ab140cd6e27" translate="yes" xml:space="preserve">
          <source>That should be significantly faster than anything else.</source>
          <target state="translated">Eso debería ser significativamente más rápido que cualquier otra cosa.</target>
        </trans-unit>
        <trans-unit id="270175c65f9ab178c1fec6d7dd95d939a77fd791" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FluidIterable&lt;/code&gt; class just provides a wrapper for the original list object. The original object can be accessed as a property of the fluid object like so:</source>
          <target state="translated">La clase &lt;code&gt;FluidIterable&lt;/code&gt; solo proporciona un contenedor para el objeto de lista original. Se puede acceder al objeto original como una propiedad del objeto fluido de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="3cfb5094c7c78cca9a3962e635d233764ced9056" translate="yes" xml:space="preserve">
          <source>The answers suggesting list comprehensions are ALMOST correct -- except that they build a completely new list and then give it the same name the old list as, they do NOT modify the old list in place. That's different from what you'd be doing by selective removal, as in &lt;a href=&quot;https://stackoverflow.com/a/1207427/3064538&quot;&gt;@Lennart's suggestion&lt;/a&gt; -- it's faster, but if your list is accessed via multiple references the fact that you're just reseating one of the references and NOT altering the list object itself can lead to subtle, disastrous bugs.</source>
          <target state="translated">Las respuestas que sugieren la comprensi&amp;oacute;n de la lista son casi correctas, excepto que crean una lista completamente nueva y luego le dan el mismo nombre que la lista anterior, ya que NO modifican la lista anterior en su lugar. Eso es diferente de lo que estar&amp;iacute;a haciendo mediante la eliminaci&amp;oacute;n selectiva, como en &lt;a href=&quot;https://stackoverflow.com/a/1207427/3064538&quot;&gt;la sugerencia de @ Lennart&lt;/a&gt; : es m&amp;aacute;s r&amp;aacute;pido, pero si se accede a su lista a trav&amp;eacute;s de m&amp;uacute;ltiples referencias, el hecho de que simplemente est&amp;aacute; volviendo a colocar una de las referencias y NO alterando el objeto de la lista en s&amp;iacute; mismo puede conducir a errores sutiles y desastrosos.</target>
        </trans-unit>
        <trans-unit id="5191c36b79d049087e12a7d61cc7919fff9ceeaf" translate="yes" xml:space="preserve">
          <source>The code below is one example of an algorithm that suffers from the above problem. The algorithm will reduce a list so that no element is a multiple of any other element.</source>
          <target state="translated">El código que figura a continuación es un ejemplo de un algoritmo que sufre el problema anterior.El algoritmo reducirá una lista de manera que ningún elemento sea múltiplo de ningún otro elemento.</target>
        </trans-unit>
        <trans-unit id="1dd15e2a02b9bd225a28fb73bd761fec970d34a4" translate="yes" xml:space="preserve">
          <source>The first problem is that you are passing both 'a' and 'b' to remove(), but remove() only accepts a single argument. So how can we get remove() to work properly with your list? We need to figure out what each element of your list is. In this case, each one is a tuple. To see this, let's access one element of the list (indexing starts at 0):</source>
          <target state="translated">El primer problema es que se pasa tanto &quot;a&quot; como &quot;b&quot; para eliminar(),pero eliminar()sólo acepta un único argumento.Entonces,¿cómo podemos hacer que remove()funcione correctamente con su lista? Tenemos que averiguar qué es cada elemento de su lista.En este caso,cada uno es una tupla.Para verlo,accedamos a un elemento de la lista (la indexación comienza en 0):</target>
        </trans-unit>
        <trans-unit id="03c421e2f742eb0a3f0b40bf613c9d58c162b963" translate="yes" xml:space="preserve">
          <source>The most effective method is list comprehension, many people show their case, of course, it is also a good way to get an &lt;code&gt;iterator&lt;/code&gt; through &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">El m&amp;eacute;todo m&amp;aacute;s efectivo es la comprensi&amp;oacute;n de la lista, muchas personas muestran su caso, por supuesto, tambi&amp;eacute;n es una buena manera de obtener un &lt;code&gt;iterator&lt;/code&gt; trav&amp;eacute;s del &lt;code&gt;filter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82e722be14da8e292e19c55197fc9f40afbc622f" translate="yes" xml:space="preserve">
          <source>The most intuitive solution is to copy the list, then iterate over the original list and only modify the copy. You can try doing so like this:</source>
          <target state="translated">La solución más intuitiva es copiar la lista,luego iterar sobre la lista original y sólo modificar la copia.Puedes intentar hacerlo así:</target>
        </trans-unit>
        <trans-unit id="218e1c2432d3d651eb5aa8d840e5878a648c2f64" translate="yes" xml:space="preserve">
          <source>The only condition is that you must only modify the list in place, if at any point &lt;code&gt;fluidL&lt;/code&gt; or &lt;code&gt;l&lt;/code&gt; were reassigned to a different list object the code would not work. The original &lt;code&gt;fluidL&lt;/code&gt; object would still be used by the for loop but would become out of scope for us to modify.</source>
          <target state="translated">La &amp;uacute;nica condici&amp;oacute;n es que solo debe modificar la lista en su lugar, si en alg&amp;uacute;n momento &lt;code&gt;fluidL&lt;/code&gt; o I fueron reasignados a un objeto de lista diferente, el c&amp;oacute;digo no funcionar&amp;iacute;a. El objeto &lt;code&gt;fluidL&lt;/code&gt; a&amp;uacute;n ser&amp;iacute;a utilizado por el bucle for, pero quedar&amp;iacute;a fuera de alcance para que lo modifiquemos.</target>
        </trans-unit>
        <trans-unit id="0232391e9ed0b3f4e1884c82ce7b756054004e76" translate="yes" xml:space="preserve">
          <source>The other answers are correct that it is usually a bad idea to delete from a list that you're iterating. Reverse iterating avoids the pitfalls, but it is much more difficult to follow code that does that, so usually you're better off using a list comprehension or &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">Las otras respuestas son correctas, por lo general es una mala idea eliminar de una lista que est&amp;aacute; iterando. La iteraci&amp;oacute;n inversa evita las trampas, pero es mucho m&amp;aacute;s dif&amp;iacute;cil seguir el c&amp;oacute;digo que hace eso, por lo que generalmente es mejor usar una lista de comprensi&amp;oacute;n o &lt;code&gt;filter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d83b85da1737342dd5460982dd9c13f4ec834959" translate="yes" xml:space="preserve">
          <source>The output and the final reduced list are shown below</source>
          <target state="translated">El resultado y la lista reducida final se muestran a continuación</target>
        </trans-unit>
        <trans-unit id="6f7fb1a9757b6b77ad3c9a0db78e51afbee729bf" translate="yes" xml:space="preserve">
          <source>The solution follows on from &lt;a href=&quot;https://stackoverflow.com/a/6260097/4451578&quot;&gt;this&lt;/a&gt; answer (for a related question) from senderle. Which explains how the the array index is updated while iterating through a list that has been modified. The solution below is designed to correctly track the array index even if the list is modified.</source>
          <target state="translated">La soluci&amp;oacute;n se deriva de &lt;a href=&quot;https://stackoverflow.com/a/6260097/4451578&quot;&gt;esta&lt;/a&gt; respuesta (para una pregunta relacionada) de senderle. Lo que explica c&amp;oacute;mo se actualiza el &amp;iacute;ndice de matriz mientras se itera a trav&amp;eacute;s de una lista que se ha modificado. La soluci&amp;oacute;n a continuaci&amp;oacute;n est&amp;aacute; dise&amp;ntilde;ada para rastrear correctamente el &amp;iacute;ndice de matriz incluso si se modifica la lista.</target>
        </trans-unit>
        <trans-unit id="2551885fd9f082f01224604f6182eec3c30229ae" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;i&lt;/code&gt; is not changed in the if block because you'll want to get value of the new item FROM THE SAME INDEX, once the old item is deleted.</source>
          <target state="translated">El valor de &lt;code&gt;i&lt;/code&gt; no cambia en el bloque if porque querr&amp;aacute; obtener el valor del nuevo elemento DEL MISMO &amp;Iacute;NDICE, una vez que se elimine el elemento anterior.</target>
        </trans-unit>
        <trans-unit id="f7562a2c2dc431ee3d16ebf6cd88cf92dd3094ad" translate="yes" xml:space="preserve">
          <source>There are two problems in your code:</source>
          <target state="translated">Hay dos problemas en su código:</target>
        </trans-unit>
        <trans-unit id="1a99f253b2b161ab64e883f8d5fbc4dedcf4f028" translate="yes" xml:space="preserve">
          <source>There doesn't seem to be an explicit linked list type in the Python stdlib either: &lt;a href=&quot;https://stackoverflow.com/questions/280243/python-linked-list/280286&quot;&gt;Python Linked List&lt;/a&gt;</source>
          <target state="translated">Tampoco parece haber un tipo de lista enlazada expl&amp;iacute;cita en Python stdlib: &lt;a href=&quot;https://stackoverflow.com/questions/280243/python-linked-list/280286&quot;&gt;Lista enlazada de Python&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e347b0acd45b91cadf43f2803affd98ff60eebb" translate="yes" xml:space="preserve">
          <source>There is an example  (get the odds in the tuple):</source>
          <target state="translated">Hay un ejemplo (obtener las probabilidades en la tupla):</target>
        </trans-unit>
        <trans-unit id="55432bab27968e16616ffe608379fb64757d1359" translate="yes" xml:space="preserve">
          <source>There is, however, one case where it is safe to remove elements from a sequence that you are iterating: if you're only removing one item while you're iterating. This can be ensured using a &lt;code&gt;return&lt;/code&gt; or a &lt;code&gt;break&lt;/code&gt;. For example:</source>
          <target state="translated">Sin embargo, hay un caso en el que es seguro eliminar elementos de una secuencia que est&amp;aacute; iterando: si solo est&amp;aacute; eliminando un elemento mientras est&amp;aacute; iterando. Esto se puede garantizar mediante un &lt;code&gt;return&lt;/code&gt; o un &lt;code&gt;break&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="1bce386bfd881c91ca88506633592e0f9e08efc1" translate="yes" xml:space="preserve">
          <source>This answer was originally written in response to a question which has since been marked as duplicate:
&lt;a href=&quot;https://stackoverflow.com/questions/40175149/removing-coordinates-from-list-on-python&quot;&gt;Removing coordinates from list on python&lt;/a&gt;</source>
          <target state="translated">Esta respuesta se escribi&amp;oacute; originalmente en respuesta a una pregunta que desde entonces se ha marcado como duplicada: &lt;a href=&quot;https://stackoverflow.com/questions/40175149/removing-coordinates-from-list-on-python&quot;&gt;Eliminar coordenadas de la lista en Python&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4e7f8dab783005add34279bd95b8e79966d3770f" translate="yes" xml:space="preserve">
          <source>This approach could be useful if there are other references to &lt;code&gt;somelist&lt;/code&gt; that need to reflect the changes.</source>
          <target state="translated">Este enfoque podr&amp;iacute;a ser &amp;uacute;til si hay otras referencias a una &lt;code&gt;somelist&lt;/code&gt; de reproducci&amp;oacute;n que necesitan reflejar los cambios.</target>
        </trans-unit>
        <trans-unit id="d30f448b4b0f64b3cc1bd7c5a8e371250849c4a4" translate="yes" xml:space="preserve">
          <source>This code runs without any error, but let's look at the list it outputs:</source>
          <target state="translated">Este código funciona sin ningún error,pero veamos la lista que da:</target>
        </trans-unit>
        <trans-unit id="e6775b34984f46006cc69465d54fe83b78053739" translate="yes" xml:space="preserve">
          <source>This is because when we created L2, python did not actually create a new object. Instead, it merely referenced L2 to the same object as L1. We can verify this with 'is' which is different from merely &quot;equals&quot; (==).</source>
          <target state="translated">Esto se debe a que cuando creamos L2,la pitón no creó realmente un nuevo objeto.En su lugar,se refirió a L2 como el mismo objeto que L1.Podemos verificar esto con &quot;es&quot;,que es diferente de simplemente &quot;igual&quot; (==).</target>
        </trans-unit>
        <trans-unit id="5e26fd0b44d14a076fccd9b06568c15d5d11763c" translate="yes" xml:space="preserve">
          <source>This is more space efficient since it dispenses the array copy, but it is less time efficient because CPython lists &lt;a href=&quot;https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented&quot;&gt;are implemented with dynamic arrays&lt;/a&gt;.</source>
          <target state="translated">Esto es m&amp;aacute;s eficiente en el espacio ya que distribuye la copia de la matriz, pero es menos eficiente en el tiempo porque las listas de CPython &lt;a href=&quot;https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented&quot;&gt;se implementan con matrices din&amp;aacute;micas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="167c700ccc2cf194c88b1e29817f0e5473200686" translate="yes" xml:space="preserve">
          <source>This is often easier to understand than a list comprehension when you're doing some operations with side effects on the first item in a list that meets some condition and then removing that item from the list immediately after.</source>
          <target state="translated">Esto suele ser más fácil de entender que la comprensión de una lista cuando se realizan algunas operaciones con efectos secundarios en el primer elemento de una lista que cumple alguna condición y luego se elimina ese elemento de la lista inmediatamente después.</target>
        </trans-unit>
        <trans-unit id="9e832ffbc7b8159e0dacf897dec246a0c433e2de" translate="yes" xml:space="preserve">
          <source>This means that item removal requires shifting all following items back by one, which is O(N).</source>
          <target state="translated">Esto significa que la eliminación de los artículos requiere cambiar todos los siguientes artículos de vuelta por uno,que es O(N).</target>
        </trans-unit>
        <trans-unit id="6d3f755498b86d4d64c1f495ead2913089f82af0" translate="yes" xml:space="preserve">
          <source>This part of the docs makes it clear that:</source>
          <target state="translated">Esta parte de los documentos deja claro que:</target>
        </trans-unit>
        <trans-unit id="4dfe1b1a882c87ca174edca828cf5ca59cfa1421" translate="yes" xml:space="preserve">
          <source>This part of the docs says once again that you have to make a copy, and gives an actual removal example:</source>
          <target state="translated">Esta parte de los documentos dice una vez más que hay que hacer una copia,y da un ejemplo de eliminación real:</target>
        </trans-unit>
        <trans-unit id="23a9c4672ae391fc627eba417316401219f51f2f" translate="yes" xml:space="preserve">
          <source>This time efficient, but less space efficient because it keeps a copy of the array around during iteration.</source>
          <target state="translated">Esta es eficiente en el tiempo,pero menos eficiente en el espacio porque mantiene una copia de la matriz alrededor durante la iteración.</target>
        </trans-unit>
        <trans-unit id="526b1bb0411da1ec481ceb845008bac5dfa4b12c" translate="yes" xml:space="preserve">
          <source>This way the index is aligned and doesn't suffer from the list updates (regardless whether you pop cur element or not).</source>
          <target state="translated">De esta manera el índice está alineado y no sufre las actualizaciones de la lista (independientemente de si se hace estallar el elemento o no).</target>
        </trans-unit>
        <trans-unit id="b5b85ab1e962bdcb10ff35cb96c42d807c436122" translate="yes" xml:space="preserve">
          <source>This will output the following:</source>
          <target state="translated">Esto producirá lo siguiente:</target>
        </trans-unit>
        <trans-unit id="f906bf0437d1189835cd8ddcd60d8f965fa2c44a" translate="yes" xml:space="preserve">
          <source>This will produce the following output:</source>
          <target state="translated">Esto producirá el siguiente resultado:</target>
        </trans-unit>
        <trans-unit id="de0da919165bd723f966b10f2b6d39bef73fe836" translate="yes" xml:space="preserve">
          <source>Unfortunately, I cannot adequately describe how reversed() works. It returns a 'listreverseiterator' object when a list is passed to it. For practical purposes, you can think of it as creating a reversed copy of its argument. This is the solution I recommend.</source>
          <target state="translated">Desafortunadamente,no puedo describir adecuadamente cómo funciona lo invertido.Devuelve un objeto 'listreverseiterator' cuando se le pasa una lista.A efectos prácticos,se puede pensar que crea una copia invertida de su argumento.Esta es la solución que recomiendo.</target>
        </trans-unit>
        <trans-unit id="8b2d2221789d986c7ae56d80c76907b6412db859" translate="yes" xml:space="preserve">
          <source>We can make a true copy using copy.copy(). Then everything works as expected:</source>
          <target state="translated">Podemos hacer una copia real usando copy.copy().Entonces todo funciona como se espera:</target>
        </trans-unit>
        <trans-unit id="23784d9f68162c9269e0a23fd4ac91e3cbbffbaa" translate="yes" xml:space="preserve">
          <source>What I don't know is how efficient a couple of deletes are compared to copying a large list. Please comment if you have any insight.</source>
          <target state="translated">Lo que no sé es lo eficiente que es un par de borrados comparado con copiar una lista grande.Por favor,comente si tiene alguna idea.</target>
        </trans-unit>
        <trans-unit id="b617b1edd0d3f10931aa29fbdeee51bf2c7348cc" translate="yes" xml:space="preserve">
          <source>What should I use in place of &lt;code&gt;code_to_remove_tup&lt;/code&gt;? I can't figure out how to remove the item in this fashion.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; debo usar en lugar de &lt;code&gt;code_to_remove_tup&lt;/code&gt; ? No puedo entender c&amp;oacute;mo quitar el art&amp;iacute;culo de esta manera.</target>
        </trans-unit>
        <trans-unit id="943d5a56f866fd2745375a8579ced2fc5bc9d4aa" translate="yes" xml:space="preserve">
          <source>Why is (1,-2) still in your list? It turns out modifying the list while using a loop to iterate over it is a very bad idea without special care. The reason that (1, -2) remains in the list is that the locations of each item within the list changed between iterations of the for loop. Let's look at what happens if we feed the above code a longer list:</source>
          <target state="translated">¿Por qué está (1,-2)todavía en tu lista? Resulta que modificar la lista mientras se usa un bucle para iterar sobre ella es una muy mala idea sin un cuidado especial.La razón por la que (1,-2)permanece en la lista es que las ubicaciones de cada elemento dentro de la lista cambiaron entre las iteraciones del bucle for.Veamos lo que sucede si alimentamos el código anterior con una lista más larga:</target>
        </trans-unit>
        <trans-unit id="cba5525fdc4b748be86f6f7a8d4839e16d248545" translate="yes" xml:space="preserve">
          <source>You can try for-looping in reverse so for some_list you'll do something like:</source>
          <target state="translated">Puedes intentar hacer un bucle al revés,así que para alguna lista harás algo como:</target>
        </trans-unit>
        <trans-unit id="fef932e24c895baf0179ccaa420e2bd7d0954340" translate="yes" xml:space="preserve">
          <source>You can use a list comprehension to create a new list containing only the elements you don't want to remove:</source>
          <target state="translated">Puede utilizar la comprensión de la lista para crear una nueva lista que contenga sólo los elementos que no desea eliminar:</target>
        </trans-unit>
        <trans-unit id="0fe88cac7a8c1d65c953157de58c81088b07d23d" translate="yes" xml:space="preserve">
          <source>You might want to use &lt;code&gt;filter()&lt;/code&gt; available as the built-in.</source>
          <target state="translated">Es posible que desee utilizar &lt;code&gt;filter()&lt;/code&gt; disponible como integrado.</target>
        </trans-unit>
        <trans-unit id="76db65aa7d7889fbb23154214040d2a4fa6894c1" translate="yes" xml:space="preserve">
          <source>You need to go backwards otherwise it's a bit like sawing off the tree-branch that you are sitting on :-)</source>
          <target state="translated">Tienes que ir hacia atrás,de lo contrario es un poco como serrar la rama del árbol en el que estás sentado :-)</target>
        </trans-unit>
        <trans-unit id="80b0cf2331c96b3507f2cb33293c954612fab365" translate="yes" xml:space="preserve">
          <source>You need to take a copy of the list and iterate over it first, or the iteration will fail with what may be unexpected results.</source>
          <target state="translated">Debes tomar una copia de la lista e iterar sobre ella primero,o la iteración fallará con lo que pueden ser resultados inesperados.</target>
        </trans-unit>
        <trans-unit id="adfd09eef6d8d4afdd5310e5f03eb9a705d7ec94" translate="yes" xml:space="preserve">
          <source>Your best approach for such an example would be a &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;list comprehension&lt;/a&gt;</source>
          <target state="translated">Su mejor enfoque para tal ejemplo ser&amp;iacute;a una &lt;a href=&quot;http://docs.python.org/tutorial/datastructures.html#list-comprehensions&quot;&gt;comprensi&amp;oacute;n de la lista&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bbc0aff80688baeb01a5a4cb720794fe808ad957" translate="yes" xml:space="preserve">
          <source>```</source>
          <target state="translated">```</target>
        </trans-unit>
        <trans-unit id="dfd3b60d353170b5585a8909968d17705c98f55e" translate="yes" xml:space="preserve">
          <source>and then &lt;strong&gt;next value (65)&lt;/strong&gt; move on to previous index.</source>
          <target state="translated">y luego el &lt;strong&gt;siguiente valor (65)&lt;/strong&gt; pasa al &amp;iacute;ndice anterior.</target>
        </trans-unit>
        <trans-unit id="256773140eb61f1cd6dd994baf6076f0cbda5306" translate="yes" xml:space="preserve">
          <source>and to avoid having to re-code the entire project with the new lists name:</source>
          <target state="translated">y para evitar tener que recodificar todo el proyecto con el nuevo nombre de la lista:</target>
        </trans-unit>
        <trans-unit id="7c9ee5a07e5b78059e78b86ca4241fb482333081" translate="yes" xml:space="preserve">
          <source>both of which make it crystal clear that you cannot modify a list being iterated except with the iterator itself, and gives you efficient ways to do so without copying the list.</source>
          <target state="translated">ambas cosas dejan muy claro que no se puede modificar una lista que se está iterando excepto con el propio iterador,y le da maneras eficientes de hacerlo sin copiar la lista.</target>
        </trans-unit>
        <trans-unit id="6d12700c2217a6fd0f4bff860dfcd30dd2761df6" translate="yes" xml:space="preserve">
          <source>consider you have a list,</source>
          <target state="translated">considera que tienes una lista,</target>
        </trans-unit>
        <trans-unit id="877d45d55490879d4296a7fe796015d42f80527e" translate="yes" xml:space="preserve">
          <source>copy.copy(x) 
  Return a shallow copy of x.</source>
          <target state="translated">copia.copia(x)Devuelve una copia superficial de x.</target>
        </trans-unit>
        <trans-unit id="e379d3ba5b6ab3903a95b94fa0aad486fec92cef" translate="yes" xml:space="preserve">
          <source>copy.deepcopy(x) 
  Return a deep copy of x.</source>
          <target state="translated">copy.deepcopy(x)Devuelve una copia profunda de x.</target>
        </trans-unit>
        <trans-unit id="7b4c418dc9f6bec70118f7721079c58620f7e7c8" translate="yes" xml:space="preserve">
          <source>during 5th iteration,</source>
          <target state="translated">durante la quinta iteración,</target>
        </trans-unit>
        <trans-unit id="fb5bc8bbd4a82ff3b60e90dcd93261b98bd06448" translate="yes" xml:space="preserve">
          <source>for loop will be iterate through index..</source>
          <target state="translated">para el bucle será iterado a través del índice..</target>
        </trans-unit>
        <trans-unit id="2c3a0ef6ef4316e6e5d1c614dce6be8faad1cb40" translate="yes" xml:space="preserve">
          <source>i.e.</source>
          <target state="translated">i.e.</target>
        </trans-unit>
        <trans-unit id="f9a405f5d71953928e26ce3b09f8a952c37a7815" translate="yes" xml:space="preserve">
          <source>note, from Python documentation:</source>
          <target state="translated">nota,de la documentación de Python:</target>
        </trans-unit>
        <trans-unit id="3c7aec3e12f7c3f23e559160305465cb5a2d42df" translate="yes" xml:space="preserve">
          <source>now you it will give,</source>
          <target state="translated">ahora te dará,</target>
        </trans-unit>
        <trans-unit id="952d109808fc70092cb9652c674259cd795c7282" translate="yes" xml:space="preserve">
          <source>one way to do it is with the slice notation &lt;code&gt;[:]&lt;/code&gt;</source>
          <target state="translated">Una forma de hacerlo es con la notaci&amp;oacute;n de corte &lt;code&gt;[:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="9440205f7b297bb97378c8ee9cd6dd38026733b0" translate="yes" xml:space="preserve">
          <source>so 4th iteration done pointer moved onto 5th..</source>
          <target state="translated">así que la cuarta iteración hecha puntero se movió a la quinta...</target>
        </trans-unit>
        <trans-unit id="32303bd0019c71856b3bd0ca577afa9b20a6f1d4" translate="yes" xml:space="preserve">
          <source>so do copy of list using &lt;code&gt;list[::]&lt;/code&gt;</source>
          <target state="translated">entonces haga una copia de la lista usando la &lt;code&gt;list[::]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b67a61431e78c0efef0f8344a3155b585fc957b6" translate="yes" xml:space="preserve">
          <source>so you can try comprehension instead.</source>
          <target state="translated">así que puedes intentar la comprensión en su lugar.</target>
        </trans-unit>
        <trans-unit id="c56b5b45bd0c8acb29daa7a9f24462a60d123bd4" translate="yes" xml:space="preserve">
          <source>so you shouldn't reference list into another variable which still reference original instead of copy.</source>
          <target state="translated">así que no deberías referirte a la lista en otra variable que aún haga referencia al original en vez de a la copia.</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="0b64514082f4dab14fe23e3dcbcb92cea9f748ba" translate="yes" xml:space="preserve">
          <source>start a new array from scratch, and &lt;code&gt;.append()&lt;/code&gt; back at the end: &lt;a href=&quot;https://stackoverflow.com/a/1207460/895245&quot;&gt;https://stackoverflow.com/a/1207460/895245&lt;/a&gt;</source>
          <target state="translated">inicie una nueva matriz desde cero y &lt;code&gt;.append()&lt;/code&gt; al final: &lt;a href=&quot;https://stackoverflow.com/a/1207460/895245&quot;&gt;https://stackoverflow.com/a/1207460/895245&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0166462591b186a6ce777cfdce9d2d4e230d1977" translate="yes" xml:space="preserve">
          <source>thats why your loop doesnt cover 65 since its moved into previous index.</source>
          <target state="translated">por eso tu bucle no cubre 65 desde que se movió al índice anterior.</target>
        </trans-unit>
        <trans-unit id="3c060051ec2702c90517f75bb0955c4fed00b1ad" translate="yes" xml:space="preserve">
          <source>uppose a list of number and you want to remove all no which are divisible by 3,</source>
          <target state="translated">...y quieres eliminar todos los no que son divisibles por 3,</target>
        </trans-unit>
        <trans-unit id="c2c2f6b4aca96b4db1ec0779cbfab2e190a97931" translate="yes" xml:space="preserve">
          <source>use &lt;code&gt;del&lt;/code&gt; with an index: &lt;a href=&quot;https://stackoverflow.com/a/1207485/895245&quot;&gt;https://stackoverflow.com/a/1207485/895245&lt;/a&gt;</source>
          <target state="translated">use &lt;code&gt;del&lt;/code&gt; con un &amp;iacute;ndice: &lt;a href=&quot;https://stackoverflow.com/a/1207485/895245&quot;&gt;https://stackoverflow.com/a/1207485/895245&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c77354b6717d46ffe5ad4fcd2e94f33c21d88f30" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;lambda filter&lt;/code&gt; function, this will create resultant new list and consume memeory space</source>
          <target state="translated">usando la funci&amp;oacute;n de &lt;code&gt;lambda filter&lt;/code&gt; , esto crear&amp;aacute; una nueva lista resultante y consumir&amp;aacute; espacio de memoria</target>
        </trans-unit>
        <trans-unit id="b1c7e2bae9e038687eb2d3cce815acc3dcac458c" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;list comprehension&lt;/code&gt;,this will careate a new list and create new memory space</source>
          <target state="translated">usando la &lt;code&gt;list comprehension&lt;/code&gt; , esto crear&amp;aacute; una nueva lista y crear&amp;aacute; un nuevo espacio de memoria</target>
        </trans-unit>
        <trans-unit id="5c3c89eedc5f3e318d8c78de0dae591b09b494ef" translate="yes" xml:space="preserve">
          <source>which supports all the iterable like, list, tuple, dict, string etc</source>
          <target state="translated">que soporta todo lo iterable como,lista,tupla,dict,cuerda,etc.</target>
        </trans-unit>
        <trans-unit id="c9ac37e61a632309fe6ac352cebdb1140b02c11f" translate="yes" xml:space="preserve">
          <source>without consuming memory space for new list and modify existing list</source>
          <target state="translated">sin consumir espacio de memoria para la nueva lista y modificar la lista existente</target>
        </trans-unit>
        <trans-unit id="e6eb9174b0a0f9124941d34b2c9c2b9375d4cb20" translate="yes" xml:space="preserve">
          <source>you have using list variable called &lt;code&gt;lis&lt;/code&gt;. and you using same to remove..</source>
          <target state="translated">tiene una variable de lista llamada &lt;code&gt;lis&lt;/code&gt; . y usas lo mismo para eliminar ..</target>
        </trans-unit>
        <trans-unit id="f4735f130b7506791a866079cea171cee93ee923" translate="yes" xml:space="preserve">
          <source>you need to make a copy of the iterated list to modify it</source>
          <target state="translated">necesitas hacer una copia de la lista iterada para modificarla</target>
        </trans-unit>
        <trans-unit id="9c0c41a37eef8bb146367129bb2695642d431ffa" translate="yes" xml:space="preserve">
          <source>your &lt;strong&gt;number 35&lt;/strong&gt; was not a prime so you removed it from a list.</source>
          <target state="translated">su &lt;strong&gt;n&amp;uacute;mero 35&lt;/strong&gt; no era primo, por lo que lo elimin&amp;oacute; de una lista.</target>
        </trans-unit>
        <trans-unit id="c3e100f0c1beaa3886a138699e84f88bf0090a45" translate="yes" xml:space="preserve">
          <source>your variable</source>
          <target state="translated">tu variable</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
