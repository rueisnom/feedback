<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/122102">
    <body>
      <group id="122102">
        <trans-unit id="6a1296019722c59836161005f2200651d85a2d6b" translate="yes" xml:space="preserve">
          <source>(Disclaimer: I&amp;rsquo;m the author of the library.)</source>
          <target state="translated">（免责声明：我是图书馆的作者。）</target>
        </trans-unit>
        <trans-unit id="64955ad90328a8d466dc77f2dc2279f37ae3662c" translate="yes" xml:space="preserve">
          <source>1) ES5+, Using a simple function to do the copy for you:</source>
          <target state="translated">1)ES5+,用一个简单的功能为你做副本。</target>
        </trans-unit>
        <trans-unit id="d473002fec1572f2b85186598bc9517a11e355ea" translate="yes" xml:space="preserve">
          <source>2) ES5+, using JSON.parse and JSON.stringify.</source>
          <target state="translated">2)ES5+,使用JSON.parse和JSON.stringify。</target>
        </trans-unit>
        <trans-unit id="595e78f83439199dfd79678374efbded89fb7322" translate="yes" xml:space="preserve">
          <source>3) AngularJs:</source>
          <target state="translated">3)AngularJs。</target>
        </trans-unit>
        <trans-unit id="5f0e185e8e5b75478a2f357848aa4f772facd6c6" translate="yes" xml:space="preserve">
          <source>4) jQuery:</source>
          <target state="translated">4)jQuery。</target>
        </trans-unit>
        <trans-unit id="9b53c147c3475ec22efa77190558bea107a83b7b" translate="yes" xml:space="preserve">
          <source>5) UnderscoreJs &amp;amp; Loadash:</source>
          <target state="translated">5）UnderscoreJs和Loadash：</target>
        </trans-unit>
        <trans-unit id="901156299a6be7b4f59b3097131ee9dbc77718da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;&lt;code&gt;angular.copy&lt;/code&gt;&lt;/a&gt; also provides a method of deep copying objects and arrays.</source>
          <target state="translated">&lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt; &lt;code&gt;angular.copy&lt;/code&gt; &lt;/a&gt;还提供了深度复制对象和数组的方法。</target>
        </trans-unit>
        <trans-unit id="009bfcf1b070cdc110e58ad916aeb0ebdd5fb726" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt;'s _.clone (string arrays, number arrays - only)</source>
          <target state="translated">Underscore.js的_.clone（仅字符串数组，数字数组）</target>
        </trans-unit>
        <trans-unit id="d9cf8b86d9893dcf61ff2d65c7eb23e635af6fe1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Cloning&lt;/code&gt; an Object was always a concern in JS, but it was all about before ES6, I list different ways of copying an object in JavaScript below, imagine you have the Object below and would like to have a deep copy of that:</source>
          <target state="translated">&lt;code&gt;Cloning&lt;/code&gt; 对象一直是JS中关注的问题，但是这是ES6之前的所有问题，我在下面列出了在JavaScript中复制对象的不同方法，假设您在下面有对象，并希望对其进行深入的复制：</target>
        </trans-unit>
        <trans-unit id="e3149223c859806faae33f5160b811c702a73d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;history.pushState()&lt;/code&gt; and &lt;code&gt;history.replaceState()&lt;/code&gt; both create a structured clone of their first argument, and assign that value to &lt;code&gt;history.state&lt;/code&gt;. You can use this to create a structured clone of any object like this:</source>
          <target state="translated">&lt;code&gt;history.pushState()&lt;/code&gt; 和 &lt;code&gt;history.replaceState()&lt;/code&gt; 都创建其第一个参数的结构化克隆，并将该值分配给 &lt;code&gt;history.state&lt;/code&gt; 。 您可以使用它来创建任何对象的结构化克隆，如下所示：</target>
        </trans-unit>
        <trans-unit id="4161b70173526960cb9aed49c9b88b668cf10704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Using JSON.parse(JSON.stringify(object));&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.使用JSON.parse（JSON.stringify（object））;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1902f5bf21360f09c0db26295028d1ff7489b4b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.Using created method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.使用创建的方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e25db176022db52099ed443a6726dba8845a1e00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Using Lo-Dash's _.cloneDeep&lt;/strong&gt; link &lt;a href=&quot;https://lodash.com/docs/4.17.10#cloneDeep&quot;&gt;lodash&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;3.使用Lo-Dash的_.cloneDeep&lt;/strong&gt;链接&lt;a href=&quot;https://lodash.com/docs/4.17.10#cloneDeep&quot;&gt;lodash&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f624b1179f0402d969c1657cc787f2504858735b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. Using Object.assign() method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.使用Object.assign（）方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cac2e850fe6d5af9f8c9a6142b37ad1f9f7009f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.Using Underscore.js _.clone&lt;/strong&gt; link &lt;a href=&quot;https://underscorejs.org/#clone&quot;&gt;Underscore.js&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;5，使用Underscore.js _.clone&lt;/strong&gt;链接&lt;strong&gt;Underscore.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="494d7a306558ccca865e63d4652b0aa9495ea94a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Update for ES6&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;ES6更新&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42934660e07ea14a1593287aab8a40230f206a26" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BUT WRONG WHEN&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;但是错误&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98bbf0f0be2eb3fe8c5b2688cd063913ea643d9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deep copy an array of objects (two or more levels - reference pointers):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;深度复制对象数组（两个或多个级别-参考指针）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b73a8e5416d0ea62f53c8ecdcde1fb969db3c61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deep copy an array of strings or numbers (one level - no reference pointers):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;深度复制字符串或数字数组（一个级别-无引用指针）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e52cb53b46101153f1ec8feb581dd78c9635e122" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deep copy by performance:&lt;/strong&gt;
Ranked from best to worst</source>
          <target state="translated">&lt;strong&gt;按性能进行深度复制：&lt;/strong&gt;从最佳到最差</target>
        </trans-unit>
        <trans-unit id="0b010fb26c7bfe7fd7f5a621d8d8ff63f4765e61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deep copying objects in JavaScript (I think the best and the simplest)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;用JavaScript深度复制对象（我认为最好和最简单）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="687c20fc62b97668702acfaf2fdc65e95783fd7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSBEN.CH Performance Benchmarking Playground 1~3 &lt;a href=&quot;http://jsben.ch/KVQLd&quot;&gt;http://jsben.ch/KVQLd&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JSBEN.CH性能基准测试场1〜3 &lt;a href=&quot;http://jsben.ch/KVQLd&quot;&gt;http://jsben.ch/KVQLd&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ca11451a7949aedbb8d25daa4c6e2c9c733a532d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Jsben&lt;/strong&gt; from the answer above updated to show that a recursive deep clone beats all the others mentioned: &lt;a href=&quot;http://jsben.ch/13YKQ&quot;&gt;http://jsben.ch/13YKQ&lt;/a&gt;</source>
          <target state="translated">上面答案中的&lt;strong&gt;Jsben&lt;/strong&gt;进行了更新，以显示递归深层克隆击败了所有其他提到的问题： &lt;a href=&quot;http://jsben.ch/13YKQ&quot;&gt;http&lt;/a&gt; : //jsben.ch/13YKQ</target>
        </trans-unit>
        <trans-unit id="2555b6b4406c27e0b54955990463a4b720d6d0cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Jsperf&lt;/strong&gt; ranks it number one here: &lt;a href=&quot;https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5&quot;&gt;https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Jsperf&lt;/strong&gt;在这里排名第一： &lt;a href=&quot;https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5&quot;&gt;https&lt;/a&gt; : &lt;strong&gt;//jsperf.com/deep-copy-vs-json-stringify-json-parse/5&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e99feda972b8e68f59dd8de4c023595f522160c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt;  If you use some of this, you may have problems with some iteration who use &lt;code&gt;hasOwnProperty&lt;/code&gt;. Because, &lt;code&gt;create&lt;/code&gt; create new empty object who inherits &lt;code&gt;oldObject&lt;/code&gt;. But it is still useful and practical for cloning objects.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;如果使用其中的一些，则使用 &lt;code&gt;hasOwnProperty&lt;/code&gt; 的某些迭代可能会遇到问题。 因为， &lt;code&gt;create&lt;/code&gt; 一个继承了 &lt;code&gt;oldObject&lt;/code&gt; 的新的空对象。 但是它对于克隆对象仍然有用且实用。</target>
        </trans-unit>
        <trans-unit id="65ffb366670c8905ce2cbfbc0625f63dca2cef8b" translate="yes" xml:space="preserve">
          <source>Additionally, please note that, in Chrome 65 at least, native cloning is not the way to go. According to JSPerf, performing native cloning by creating a new function is nearly &lt;strong&gt;800x&lt;/strong&gt; slower than using JSON.stringify which is incredibly fast all the way across the board.</source>
          <target state="translated">此外，请注意，至少在Chrome 65中，本机克隆不是可行的方法。 根据JSPerf的说法，通过创建新函数执行本机克隆比使用JSON.stringify的速度要快近&lt;strong&gt;800倍，&lt;/strong&gt;而JSON.stringify的整个过程都非常快。</target>
        </trans-unit>
        <trans-unit id="e9fbc91983624098eab0a0b9d68cfc16ffd38c16" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign&lt;/code&gt;&lt;/a&gt; method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign&lt;/code&gt; &lt;/a&gt;方法是ECMAScript 2015（ES6）标准的一部分，可以完全满足您的需求。</target>
        </trans-unit>
        <trans-unit id="a0c9d534b25ad917673b687d062bc3704ac1ff81" translate="yes" xml:space="preserve">
          <source>And .slice() has better performance than .concat(),
&lt;a href=&quot;http://jsperf.com/duplicate-array-slice-vs-concat/3&quot;&gt;http://jsperf.com/duplicate-array-slice-vs-concat/3&lt;/a&gt;</source>
          <target state="translated">而且.slice（）的性能优于.concat（）， &lt;a href=&quot;http://jsperf.com/duplicate-array-slice-vs-concat/3&quot;&gt;http：&lt;/a&gt; //jsperf.com/duplicate-array-slice-vs-concat/3</target>
        </trans-unit>
        <trans-unit id="2a237d4316f291003b4b86dad80c344ac6f420dc" translate="yes" xml:space="preserve">
          <source>And here's the function for quick reference:</source>
          <target state="translated">下面是功能,供大家快速参考。</target>
        </trans-unit>
        <trans-unit id="cc865b9cd1412c3a1c78268236049f2cf0ff478f" translate="yes" xml:space="preserve">
          <source>And shallow copy one-liner (&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6th edition&lt;/a&gt;, 2015):</source>
          <target state="translated">浅拷贝单线（ &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript第6版&lt;/a&gt; ，2015年）：</target>
        </trans-unit>
        <trans-unit id="2a3de4a9dc7c9f3bd23b0b53226033777b1c013b" translate="yes" xml:space="preserve">
          <source>AngularJS</source>
          <target state="translated">AngularJS</target>
        </trans-unit>
        <trans-unit id="38e2141eb9ea203ffeb32d4cd55e0a65c6cf0af8" translate="yes" xml:space="preserve">
          <source>AngularJS - &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;&lt;code&gt;angular.copy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">AngularJS- &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt; &lt;code&gt;angular.copy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dbb5fb1e128b60678a581b67d84a563bc06d30de" translate="yes" xml:space="preserve">
          <source>As long as you don't assign an object to anything it maintains no reference in memory.  So to make an object that you want to share among other objects, you'll have to create a factory like so:</source>
          <target state="translated">只要你不给一个对象分配任何东西,它就不会在内存中维护任何引用。所以要想让一个对象在其他对象之间共享,你必须创建一个像这样的工厂。</target>
        </trans-unit>
        <trans-unit id="113eae0600518a1898dafd21a63c05f2d981cee1" translate="yes" xml:space="preserve">
          <source>Assuming that you have only variables and not any functions in your object, you can  just use:</source>
          <target state="translated">假设你的对象中只有变量而没有任何函数,你可以直接使用。</target>
        </trans-unit>
        <trans-unit id="885484b4ce4212e28b9e1f43dae9669bda2c3f25" translate="yes" xml:space="preserve">
          <source>Asynchronous Workaround: Usable. 😕</source>
          <target state="translated">异步工作法。可使用。😕</target>
        </trans-unit>
        <trans-unit id="45d1707d26f931a8d5a0db1965460102f4e3ff0c" translate="yes" xml:space="preserve">
          <source>Beware using the &lt;code&gt;JSON.parse(JSON.stringify(obj))&lt;/code&gt; method on &lt;code&gt;Date&lt;/code&gt; objects - &lt;code&gt;JSON.stringify(new Date())&lt;/code&gt; returns a string representation of the date in ISO format, which &lt;code&gt;JSON.parse()&lt;/code&gt;&lt;strong&gt;doesn't&lt;/strong&gt; convert back to a &lt;code&gt;Date&lt;/code&gt; object. &lt;a href=&quot;https://stackoverflow.com/questions/11491938/issues-with-date-when-using-json-stringify-and-json-parse/11491993#11491993&quot;&gt;See this answer for more details&lt;/a&gt;.</source>
          <target state="translated">当心在 &lt;code&gt;Date&lt;/code&gt; 对象上使用 &lt;code&gt;JSON.parse(JSON.stringify(obj))&lt;/code&gt; 方法 &lt;code&gt;JSON.stringify(new Date())&lt;/code&gt; 以ISO格式返回日期的字符串表示形式， &lt;code&gt;JSON.parse()&lt;/code&gt; &lt;strong&gt;不会&lt;/strong&gt;转换回 &lt;code&gt;Date&lt;/code&gt; 对象。 &lt;a href=&quot;https://stackoverflow.com/questions/11491938/issues-with-date-when-using-json-stringify-and-json-parse/11491993#11491993&quot;&gt;有关更多详细信息，请参见此答案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2973236548453f38ead1f38928c94284e9ecced4" translate="yes" xml:space="preserve">
          <source>Browsers do not currently provide a direct interface for the structured cloning algorithm, but a global &lt;code&gt;structuredClone()&lt;/code&gt; function has been discussed in &lt;a href=&quot;https://github.com/whatwg/html/issues/793&quot;&gt;whatwg/html#793 on GitHub&lt;/a&gt;. As currently proposed, using it for most purposes would be as simple as:</source>
          <target state="translated">浏览器当前不为结构化克隆算法提供直接接口，但是&lt;a href=&quot;https://github.com/whatwg/html/issues/793&quot;&gt;在GitHub上的whatwg / html＃793中&lt;/a&gt;已经讨论了全局的 &lt;code&gt;structuredClone()&lt;/code&gt; 化Clone （）函数。 按照目前的建议，将其用于大多数目的将非常简单：</target>
        </trans-unit>
        <trans-unit id="12dd3382e21919424cc1c91dd85712739a9d2a65" translate="yes" xml:space="preserve">
          <source>Checkout this benchmark: &lt;a href=&quot;http://jsben.ch/#/bWfk9&quot;&gt;http://jsben.ch/#/bWfk9&lt;/a&gt;</source>
          <target state="translated">查看此基准测试： &lt;a href=&quot;http://jsben.ch/#/bWfk9&quot;&gt;http&lt;/a&gt; : //jsben.ch/#/bWfk9</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="33f64e6db7d2271df61b32aa8af7e37929c89a90" translate="yes" xml:space="preserve">
          <source>Concatenation (string arrays, number arrays - only)</source>
          <target state="translated">串联(字符串数组、数字数组-仅限字符串数组)。</target>
        </trans-unit>
        <trans-unit id="62deea81938f50a7bee5245055544936da12eca8" translate="yes" xml:space="preserve">
          <source>Crockford suggests (and I prefer) using this function:</source>
          <target state="translated">Crockford建议(我更喜欢)使用这个功能。</target>
        </trans-unit>
        <trans-unit id="b03a8e60580e981cb3346f2471707bf40078fbfc" translate="yes" xml:space="preserve">
          <source>Custom function: for-loop or recursive copy</source>
          <target state="translated">自定义函数:for-loop或递归复制</target>
        </trans-unit>
        <trans-unit id="2a51e59697fbe92dbb2e644bf2b96a60a7492a59" translate="yes" xml:space="preserve">
          <source>Cyclic array test...</source>
          <target state="translated">循环阵列测试.....</target>
        </trans-unit>
        <trans-unit id="6132b55eb09b417ca145535639ce3a5e8b1dabcd" translate="yes" xml:space="preserve">
          <source>Direct Support in Browsers: Maybe Eventually? 😐</source>
          <target state="translated">浏览器中直接支持。也许最终会是这样?😐</target>
        </trans-unit>
        <trans-unit id="f340712260381d35a53813a65d261137ac25e7e6" translate="yes" xml:space="preserve">
          <source>ES6</source>
          <target state="translated">ES6</target>
        </trans-unit>
        <trans-unit id="c59815c7f257e5f2bd8a4266850beddb6342fb92" translate="yes" xml:space="preserve">
          <source>Example Use:</source>
          <target state="translated">使用示例。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="16ba7f824c47b8dd6421330a2246967e2e7b4d98" translate="yes" xml:space="preserve">
          <source>Fast cloning with data loss - JSON.parse/stringify</source>
          <target state="translated">快速克隆与数据丢失-JSON.parsestringify</target>
        </trans-unit>
        <trans-unit id="5df81ffa82179b458e1d55e350db9d88805a69b2" translate="yes" xml:space="preserve">
          <source>Features:</source>
          <target state="translated">Features:</target>
        </trans-unit>
        <trans-unit id="548b5bb5625e9995c9b6a6c0c6caa954f3d6146a" translate="yes" xml:space="preserve">
          <source>For completeness, note that ES6 offers two shallow copy mechanisms: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread syntax&lt;/a&gt;.
which copies values of all enumerable own properties from one object to another. For example:</source>
          <target state="translated">为了完整起见，请注意ES6提供了两种浅表复制机制： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread语法&lt;/a&gt; 。 它将所有可枚举的自身属性的值从一个对象复制到另一个对象。 例如：</target>
        </trans-unit>
        <trans-unit id="f44cbbef6a62693cba2e071062336ff3dc94bb80" translate="yes" xml:space="preserve">
          <source>For exemple if  &lt;code&gt;oldObject.a = 5;&lt;/code&gt;</source>
          <target state="translated">例如 &lt;code&gt;oldObject.a = 5;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f57eb53b7c897cb1b501d5248fb863801dd72556" translate="yes" xml:space="preserve">
          <source>For plain old JavaScript objects, a tried and true good way to clone an object in modern runtimes is quite simply:</source>
          <target state="translated">对于普通的老式JavaScript对象,在现代运行时,一个久经考验的好方法就是克隆一个对象。</target>
        </trans-unit>
        <trans-unit id="290ba1968d5c0e35790807a7d71890b939dd1191" translate="yes" xml:space="preserve">
          <source>For the people who want to use the &lt;code&gt;JSON.parse(JSON.stringify(obj))&lt;/code&gt; version, but without losing the Date objects, you can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter&quot;&gt;second argument of &lt;code&gt;parse&lt;/code&gt; method&lt;/a&gt; to convert the strings back to Date:</source>
          <target state="translated">对于想要使用 &lt;code&gt;JSON.parse(JSON.stringify(obj))&lt;/code&gt; 版本但又不会丢失Date对象的人们，可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter&quot;&gt; &lt;code&gt;parse&lt;/code&gt; 方法&lt;/a&gt;的第二个参数将字符串转换回Date：</target>
        </trans-unit>
        <trans-unit id="819886a4425ab8b131d38de099cf7d21b2593149" translate="yes" xml:space="preserve">
          <source>Function test...</source>
          <target state="translated">功能测试.....</target>
        </trans-unit>
        <trans-unit id="283604d15a7ac67eabe5b3c0f40f636ecca3c9e6" translate="yes" xml:space="preserve">
          <source>Here is an example on how to use it:</source>
          <target state="translated">下面是一个使用方法的例子。</target>
        </trans-unit>
        <trans-unit id="986b97ae19544455c19671d7339eadc9fb9e0e07" translate="yes" xml:space="preserve">
          <source>Here's a more robust version (thanks to Justin McCandless this now supports cyclic references as well):</source>
          <target state="translated">这里是一个更强大的版本(感谢Justin McCandless,现在也支持循环引用)。</target>
        </trans-unit>
        <trans-unit id="a5601ce43e9ecb2f018a4f09ccd9028408b86893" translate="yes" xml:space="preserve">
          <source>Here's a version of ConroyP's answer above that works even if the constructor has required parameters:</source>
          <target state="translated">这里有一个ConroyP上面的答案,即使构造函数有必要的参数,也可以使用。</target>
        </trans-unit>
        <trans-unit id="43785ecb3cc28739be6434fed6fb0759ce3749d8" translate="yes" xml:space="preserve">
          <source>Hope these help...</source>
          <target state="translated">希望这些能帮到你.....</target>
        </trans-unit>
        <trans-unit id="9049385ac01962cfa840cada7563fa5809874c60" translate="yes" xml:space="preserve">
          <source>I disagree with the answer with the greatest votes &lt;a href=&quot;https://stackoverflow.com/a/5344074/1110941&quot;&gt;here&lt;/a&gt;. A &lt;strong&gt;Recursive Deep Clone&lt;/strong&gt; is &lt;strong&gt;much faster&lt;/strong&gt; than the &lt;em&gt;JSON.parse(JSON.stringify(obj))&lt;/em&gt; approach mentioned.</source>
          <target state="translated">我不同意&lt;a href=&quot;https://stackoverflow.com/a/5344074/1110941&quot;&gt;这里&lt;/a&gt;的最高票数。 &lt;strong&gt;递归深层&lt;/strong&gt; &lt;em&gt;克隆比提&lt;/em&gt;到的&lt;em&gt;JSON.parse（JSON.stringify（obj））&lt;/em&gt;方法&lt;strong&gt;要快得多&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8d10e7469763c4fa551d6c8215a34b7f532b787" translate="yes" xml:space="preserve">
          <source>I have two good answers depending on whether your objective is to clone a &quot;plain old JavaScript object&quot; or not.</source>
          <target state="translated">我有两个很好的答案,这取决于你的目标是否是克隆一个 &quot;普通的JavaScript对象&quot;。</target>
        </trans-unit>
        <trans-unit id="a7fc0603da96abdae3ed58d9e47ceb2a514ed8c2" translate="yes" xml:space="preserve">
          <source>I know this is an old post, but I thought this may be of some help to the next person who stumbles along.</source>
          <target state="translated">我知道这是一个老帖子了,但我想这可能会对下一个跌跌撞撞的人有所帮助。</target>
        </trans-unit>
        <trans-unit id="770b6fd856a41550954cd1546783c443b5849773" translate="yes" xml:space="preserve">
          <source>I'm surprised no canonical solution exists.</source>
          <target state="translated">我很惊讶于没有一个经典的解决方案。</target>
        </trans-unit>
        <trans-unit id="489f920024365227ffd4310703cdb9fed08a94ca" translate="yes" xml:space="preserve">
          <source>I've also seen recursive copying functions with various flaws.</source>
          <target state="translated">我也看到过递归复制函数有各种缺陷。</target>
        </trans-unit>
        <trans-unit id="0ab70149b7f9dac23be9515659eb536b44c9781b" translate="yes" xml:space="preserve">
          <source>I've done things like &lt;code&gt;obj = JSON.parse(JSON.stringify(o));&lt;/code&gt; but question the efficiency.</source>
          <target state="translated">我已经完成了 &lt;code&gt;obj = JSON.parse(JSON.stringify(o));&lt;/code&gt; 但质疑效率。</target>
        </trans-unit>
        <trans-unit id="2adf921803ec4757f8d2c2ba821f04b210f4ff78" translate="yes" xml:space="preserve">
          <source>If there wasn't any builtin one, you could try:</source>
          <target state="translated">如果没有内建的,你可以试试。</target>
        </trans-unit>
        <trans-unit id="9398424fd79f967ba29c3a2b98b9498a1b81b153" translate="yes" xml:space="preserve">
          <source>If you are using Javascript ES6 try this native method for cloning or shallow copy.</source>
          <target state="translated">如果你使用的是Javascript ES6,请尝试用这个原生方法进行克隆或浅层复制。</target>
        </trans-unit>
        <trans-unit id="9090a40c83a01a70b916e0798f48cfa367bb40e1" translate="yes" xml:space="preserve">
          <source>If you do not use &lt;code&gt;Date&lt;/code&gt;s, functions, &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays or other complex types within your object, a very simple one liner to deep clone an object is:</source>
          <target state="translated">如果您不使用 &lt;code&gt;Date&lt;/code&gt; ，函数， &lt;code&gt;undefined&lt;/code&gt; ， &lt;code&gt;Infinity&lt;/code&gt; ，RegExps，Maps，Sets，Blobs，FileLists，ImageDatas，Sparse Arrays，Typed Arrays或对象中的其他复杂类型，则可以使用一个非常简单的方法来深度克隆对象：</target>
        </trans-unit>
        <trans-unit id="07552e6b07e4b59604aa421015a02d6d4053e7f4" translate="yes" xml:space="preserve">
          <source>If you know the structure of the objects you are trying to clone or can avoid deep nested arrays you can write a simple &lt;code&gt;for (var i in obj)&lt;/code&gt; loop to clone your object while checking hasOwnProperty and it will be much much faster than jQuery.</source>
          <target state="translated">如果您知道要克隆的对象的结构，或者可以避免使用深层嵌套的数组，则可以在检查hasOwnProperty时编写一个简单的 &lt;code&gt;for (var i in obj)&lt;/code&gt; 循环来克隆对象，这将比jQuery快得多。</target>
        </trans-unit>
        <trans-unit id="50c28e80de0f4e89573c3db98a84c97a95a95f4a" translate="yes" xml:space="preserve">
          <source>If you're using it, the &lt;a href=&quot;http://documentcloud.github.com/underscore/&quot;&gt;Underscore.js&lt;/a&gt; library has a &lt;a href=&quot;http://documentcloud.github.com/underscore/#clone&quot;&gt;clone&lt;/a&gt; method.</source>
          <target state="translated">如果您使用它，则&lt;a href=&quot;http://documentcloud.github.com/underscore/&quot;&gt;Underscore.js&lt;/a&gt;库具有&lt;a href=&quot;http://documentcloud.github.com/underscore/#clone&quot;&gt;克隆&lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="32c99c466e4a0911b1659ab32d74fd72754b74b4" translate="yes" xml:space="preserve">
          <source>In my previous tests where speed was a main concern I found</source>
          <target state="translated">在我之前的测试中,我发现,在我之前的测试中,速度是我最关心的问题。</target>
        </trans-unit>
        <trans-unit id="401b0ccb46c432dff2afad559300cc0def5cbae9" translate="yes" xml:space="preserve">
          <source>Install it with</source>
          <target state="translated">装上它,用</target>
        </trans-unit>
        <trans-unit id="6cee4a345e292df7d0d5add981b24de0948ebe09" translate="yes" xml:space="preserve">
          <source>Is it efficient? Heck yes. We've tried all kinds of cloning methods and this works best. I'm sure some ninja could conjure up a faster method. But I suspect we're talking about marginal gains.</source>
          <target state="translated">它的效率高吗?当然有效。我们试过各种克隆的方法,这个最有效。我相信有些忍者能想出一个更快的方法 I'm sure some ninja could conjure up a faster method.但我怀疑我们说的是边际收益。</target>
        </trans-unit>
        <trans-unit id="552c5e4d033ed42b95333527705d38f03287c127" translate="yes" xml:space="preserve">
          <source>Is this efficient? Heck yes. Given that the goal is to produce a true deep-copy clone, then you're going to have to walk the members of the source object graph. With this approach, you can tweak exactly which child members to treat and how to manually handle custom types.</source>
          <target state="translated">这样有效吗?当然有效。考虑到目标是产生一个真正的深拷贝克隆,那么你就必须走源对象图的成员。使用这种方法,你可以精确地调整要处理哪些子成员,以及如何手动处理自定义类型。</target>
        </trans-unit>
        <trans-unit id="c94a08f19c18e9bc889cd680ef7113eda1f000c9" translate="yes" xml:space="preserve">
          <source>It's called &quot;structured cloning&quot;, works experimentally in Node 11 and later, and hopefully will land in browsers. See &lt;a href=&quot;https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/10916838#10916838&quot;&gt;this answer&lt;/a&gt; for more details.</source>
          <target state="translated">它被称为&amp;ldquo;结构化克隆&amp;rdquo;，可在Node 11及更高版本上进行实验性工作，并有望登陆浏览器。 有关更多详细信息，请参&lt;a href=&quot;https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/10916838#10916838&quot;&gt;见此答案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a50766b911feda7edb7ebbbfa654117a491b7986" translate="yes" xml:space="preserve">
          <source>It's terse, works as expected and you don't need a library.</source>
          <target state="translated">它很简洁,能如愿以偿,而且你不需要图书馆。</target>
        </trans-unit>
        <trans-unit id="8bed1ab98bd53aec22f5714f0cb05545fe888159" translate="yes" xml:space="preserve">
          <source>JSON.parse (string arrays, number arrays, object arrays - only)</source>
          <target state="translated">JSON.parse (字符串数组、数字数组、对象数组-仅限对象数组)</target>
        </trans-unit>
        <trans-unit id="c8e5e57858ab0b5524280bd8428db7c8b55655d8" translate="yes" xml:space="preserve">
          <source>JavaScript trace engines suck at optimizing &lt;code&gt;for..in&lt;/code&gt; loops and checking hasOwnProperty will slow you down as well. Manual clone when speed is an absolute must.</source>
          <target state="translated">JavaScript跟踪引擎在优化 &lt;code&gt;for..in&lt;/code&gt; 循环中很麻烦，并且检查hasOwnProperty也会使您变慢。 绝对必要时，请手动克隆。</target>
        </trans-unit>
        <trans-unit id="12a1fd73ed0eae8ce0f0c007e80a4dec94139630" translate="yes" xml:space="preserve">
          <source>Just because I didn't see &lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt; mentioned and thought that people might want to know...</source>
          <target state="translated">只是因为我没有看到&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt;并以为人们可能想知道...</target>
        </trans-unit>
        <trans-unit id="b5aceb860a4a7199d83d003b87e1425b7dd2c21b" translate="yes" xml:space="preserve">
          <source>Lastly if you are attempting to clone a known object structure in a hot loop you can get MUCH MUCH MORE PERFORMANCE by simply in-lining the clone procedure and manually constructing the object.</source>
          <target state="translated">最后,如果你试图在热循环中克隆一个已知的对象结构,你可以通过简单的内嵌克隆过程和手动构造对象来获得更多的性能。</target>
        </trans-unit>
        <trans-unit id="79bcce380c0ce7e7dd7c24c0657c08ae5b245de7" translate="yes" xml:space="preserve">
          <source>Let's also assume that your intention is to create a complete clone with no prototype references back to the source object. If you're not interested in a complete clone, then you can use many of the Object.clone() routines provided in some of the other answers (Crockford's pattern).</source>
          <target state="translated">让我们也假设你的意图是创建一个完整的克隆,没有原型引用回源对象。如果你对一个完整的克隆对象不感兴趣,那么你可以使用其他一些答案中提供的Object.clone()例程(Crockford的模式)。</target>
        </trans-unit>
        <trans-unit id="520d8bb109a39b45dd5e79bd3747a98f5ff3f2e3" translate="yes" xml:space="preserve">
          <source>Lo-Dash's _.cloneDeep</source>
          <target state="translated">Lo-Dash的_.cloneDeep</target>
        </trans-unit>
        <trans-unit id="209152665b8c481035d0e6dfb91586cec34a0c79" translate="yes" xml:space="preserve">
          <source>Lodash has a nice &lt;a href=&quot;http://lodash.com/docs#cloneDeep&quot;&gt;_.cloneDeep(value)&lt;/a&gt; method:</source>
          <target state="translated">Lodash有一个不错的&lt;a href=&quot;http://lodash.com/docs#cloneDeep&quot;&gt;_.cloneDeep（value）&lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="d05e9acdcff333355c411ee686bab6ff0133f9cc" translate="yes" xml:space="preserve">
          <source>Native deep cloning</source>
          <target state="translated">原生深度克隆</target>
        </trans-unit>
        <trans-unit id="e6539f71531625a7144c73c7a36f5fd478b0b5fe" translate="yes" xml:space="preserve">
          <source>Not only is this code brief, but it's also very readable. It's pretty easy to extend.</source>
          <target state="translated">这个代码不仅简短,而且可读性也很强。扩展起来也相当容易。</target>
        </trans-unit>
        <trans-unit id="d4bf0db1b60eef8c1813d1041bc18495d9ce39ca" translate="yes" xml:space="preserve">
          <source>Note that the source object must be a pure JSON object. This is to say, all of its nested properties must be scalars (like boolean, string, array, object, etc). Any functions or special objects like RegExp or Date will not be cloned.</source>
          <target state="translated">注意,源对象必须是一个纯JSON对象。也就是说,它所有的嵌套属性必须是标量(如布尔、字符串、数组、对象等)。任何函数或特殊对象(如 RegExp 或 Date)都不会被克隆。</target>
        </trans-unit>
        <trans-unit id="92030dffe19cafc2b1d2c1490105e85367237388" translate="yes" xml:space="preserve">
          <source>Now, for non-plain JavaScript objects, there isn't a really simple answer.  In fact, there can't be because of the dynamic nature of JavaScript functions and inner object state. Deep cloning a JSON structure with functions inside requires you recreate those functions and their inner context. And JavaScript simply doesn't have a standardized way of doing that.</source>
          <target state="translated">现在,对于非普通的JavaScript对象,并没有一个真正简单的答案。事实上,不可能有,因为JavaScript函数和内部对象状态的动态性质。深度克隆一个带有函数的JSON结构,需要你重新创建这些函数和内部上下文。而JavaScript根本就没有一个标准化的方法来做这件事。</target>
        </trans-unit>
        <trans-unit id="2dddac477d2fc4da4f071b02ecb0e5c67e1c4eec" translate="yes" xml:space="preserve">
          <source>Only when you can use &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Source-to-source_compiler&quot;&gt;transpilers&lt;/a&gt;.</source>
          <target state="translated">仅当您可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6&lt;/a&gt;或&lt;a href=&quot;https://en.wikipedia.org/wiki/Source-to-source_compiler&quot;&gt;编译器时&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a146c2606b2683fa89a081df852f2344d61d9122" translate="yes" xml:space="preserve">
          <source>Preserves getter/setter.</source>
          <target state="translated">脯饯取器。</target>
        </trans-unit>
        <trans-unit id="ead9d710f07a34e7916d508ba40f3bfe0a8e2dec" translate="yes" xml:space="preserve">
          <source>Preserves prototype informations.</source>
          <target state="translated">保存原型信息。</target>
        </trans-unit>
        <trans-unit id="b94a461fa5defe5b279c9608d6e61c90faa2d659" translate="yes" xml:space="preserve">
          <source>Read more...</source>
          <target state="translated">阅读更多.....</target>
        </trans-unit>
        <trans-unit id="8497cdbe15233a52b824e49dffae225b8ff72450" translate="yes" xml:space="preserve">
          <source>Reassignment &quot;=&quot; (string arrays, number arrays - only)</source>
          <target state="translated">重新赋值&quot;=&quot;(字符串数组、数字数组-仅限字符串数组</target>
        </trans-unit>
        <trans-unit id="9081c30a10752ce26712d2709bcc2abcd45f5c59" translate="yes" xml:space="preserve">
          <source>Reliable cloning using a library</source>
          <target state="translated">使用图书馆进行可靠的克隆</target>
        </trans-unit>
        <trans-unit id="471c7b148e65bf588090efbb408cf2fb82ab9380" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/5344074#5344074&quot;&gt;Corban's answer&lt;/a&gt; for benchmarks.</source>
          <target state="translated">有关基准，请参见&lt;a href=&quot;https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/5344074#5344074&quot;&gt;Corban的答案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="436e1d9882fcfbc9f3b2875a8d9852f501984dbe" translate="yes" xml:space="preserve">
          <source>Shallow copy one-liner (&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#5th_Edition&quot;&gt;ECMAScript 5th edition&lt;/a&gt;):</source>
          <target state="translated">浅拷贝&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#5th_Edition&quot;&gt;单线版&lt;/a&gt; （ ECMAScript第5版 ）：</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">显示代码片段</target>
        </trans-unit>
        <trans-unit id="d9cc20901b278592274b450a481e3147b18f747f" translate="yes" xml:space="preserve">
          <source>Since cloning objects is not trivial (complex types, circular references, function etc.), most major libraries provide function to clone objects. &lt;strong&gt;Don't reinvent the wheel&lt;/strong&gt; - if you're already using a library, check if it has an object cloning function. For example,</source>
          <target state="translated">由于克隆对象并非易事（复杂类型，循环引用，函数等），因此大多数主要库都提供了用于克隆对象的函数。 &lt;strong&gt;不要重新发明轮子&lt;/strong&gt; -如果您已经在使用库，请检查它是否具有对象克隆功能。 例如，</target>
        </trans-unit>
        <trans-unit id="77920747b65548ba6059a3d815b6120916ef3d84" translate="yes" xml:space="preserve">
          <source>Slice (string arrays, number arrays - only)</source>
          <target state="translated">Slice (字符串数组、数字数组----仅限字符串数组)</target>
        </trans-unit>
        <trans-unit id="1ffe9a46d7be9b8028812dac880cc2994ed293c7" translate="yes" xml:space="preserve">
          <source>So there you go. Two approaches. Both are efficient in my view.</source>
          <target state="translated">所以,你去那里。有两种方法。在我看来,这两种方法都很有效率。</target>
        </trans-unit>
        <trans-unit id="6ad3b82357863678ee1004a1578b7bbd9d5bb008" translate="yes" xml:space="preserve">
          <source>Structured Cloning</source>
          <target state="translated">结构化克隆</target>
        </trans-unit>
        <trans-unit id="23f01f984def29d2ca8450b6649412c885cc1ab0" translate="yes" xml:space="preserve">
          <source>Support in Node.js: Experimental 🙂</source>
          <target state="translated">Node.js中的支持:实验性的 🙂</target>
        </trans-unit>
        <trans-unit id="59e328d320b19ac5a6aaa19e1f21c6d03c007174" translate="yes" xml:space="preserve">
          <source>Synchronous Workarounds: Awful! 🤢</source>
          <target state="translated">同步的工作方法。太可怕了! 🤢</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="a5e11aaef6d86dbb08ddecaba334a8d38a925a15" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt; constructor&lt;/a&gt; creates a structured clone of its associated data. It also attempts to display a browser notification to the user, but this will silently fail unless you have requested notification permission. In case you have the permission for other purposes, we'll immediately close the notification we've created.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; 构造函数&lt;/a&gt;创建其关联数据的结构化克隆。 它还尝试向用户显示浏览器通知，但是除非您请求了通知权限，否则这将以静默方式失败。 如果您获得其他目的的许可，我们将立即关闭我们创建的通知。</target>
        </trans-unit>
        <trans-unit id="33abd86738e91ddf762ad34b84e77510ca29a298" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v8&lt;/code&gt; module in Node.js currently (as of Node 11) &lt;a href=&quot;https://nodejs.org/api/all.html#v8_serialization_api&quot;&gt;exposes the structured serialization API directly&lt;/a&gt;, but this functionality is still marked as &quot;experimental&quot;, and subject to change or removal in future versions. If you're using a compatible version, cloning an object is as simple as:</source>
          <target state="translated">当前（从节点11开始）Node.js中的 &lt;code&gt;v8&lt;/code&gt; 模块&lt;a href=&quot;https://nodejs.org/api/all.html#v8_serialization_api&quot;&gt;直接公开结构化序列化API&lt;/a&gt; ，但是此功能仍标记为&amp;ldquo;实验性&amp;rdquo;，并且在将来的版本中可能会更改或删除。 如果使用兼容版本，则克隆对象非常简单：</target>
        </trans-unit>
        <trans-unit id="4ebf0771ba83c4cde2f39337676c4fc1f72d4b19" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;polyfill&lt;/strong&gt; to support older browsers:</source>
          <target state="translated">支持旧版浏览器的&lt;strong&gt;polyfill&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="6ad8ed5785225ec56294ca4522abde5f0721c0e0" translate="yes" xml:space="preserve">
          <source>The HTML standard includes &lt;a href=&quot;https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data&quot;&gt;&lt;strong&gt;an internal structured cloning/serialization algorithm&lt;/strong&gt;&lt;/a&gt; that can create deep clones of objects. It is still limited to certain built-in types, but in addition to the few types supported by JSON it also supports Dates, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays, and probably more in the future. It also preserves references within the cloned data, allowing it to support cyclical and recursive structures that would cause errors for JSON.</source>
          <target state="translated">HTML标准包括&lt;a href=&quot;https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data&quot;&gt;&lt;strong&gt;一个内部结构化克隆/序列化算法&lt;/strong&gt;&lt;/a&gt; ，该&lt;strong&gt;算法&lt;/strong&gt;可以创建对象的深层克隆。 它仍然仅限于某些内置类型，但除JSON支持的几种类型外，它还支持日期，RegExps，地图，集合，Blob，FileList，ImageData，稀疏数组，类型数组，并且将来可能还会更多。 它还会在克隆的数据中保留引用，从而使其支持可能会导致JSON错误的循环和递归结构。</target>
        </trans-unit>
        <trans-unit id="7db166788c70c64b3e72f12a43552987dd23d268" translate="yes" xml:space="preserve">
          <source>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.</source>
          <target state="translated">Object.assign()方法用于将一个或多个源对象中的所有可枚举的自身属性的值复制到目标对象中。</target>
        </trans-unit>
        <trans-unit id="ea189bc649e6f71823539572e783a6707400ee47" translate="yes" xml:space="preserve">
          <source>The correct way to do this, once again, is via a convenience method that you declare and reuse within your code. The convenience method can be endowed with some understanding of your own objects so you can make sure to properly recreate the graph within the new object.</source>
          <target state="translated">正确的方法是通过一个方便方法,在你的代码中声明并重用这个方便方法。这个方便方法可以被赋予一些对自己的对象的理解,这样你就可以确保在新对象中正确地重新创建图形。</target>
        </trans-unit>
        <trans-unit id="9863ec7b812e3f1bc60cd8d2b37675bbd39e8ece" translate="yes" xml:space="preserve">
          <source>The efficient way to clone(not deep-clone) an object in one line of code</source>
          <target state="translated">在一行代码中克隆(而不是深度克隆)对象的有效方法</target>
        </trans-unit>
        <trans-unit id="68231b93a0105cba9f5b826511c388f535a2a982" translate="yes" xml:space="preserve">
          <source>The following creates two instances of the same object. I found it and am using it currently. It's simple and easy to use.</source>
          <target state="translated">下面这个方法可以为同一个对象创建两个实例。我找到了它,目前正在使用它。它很简单,也很好用。</target>
        </trans-unit>
        <trans-unit id="81c869f74b5ea4e2a848d31cc904d67ee6808a0c" translate="yes" xml:space="preserve">
          <source>The lower-overhead way to create a structured clone with existing APIs is to post the data through one port of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel&quot;&gt;MessageChannels&lt;/a&gt;. The other port will emit a &lt;code&gt;message&lt;/code&gt; event with a structured clone of the attached &lt;code&gt;.data&lt;/code&gt;. Unfortunately, listening for these events is necessarily asynchronous, and the synchronous alternatives are less practical.</source>
          <target state="translated">使用现有API创建结构化克隆的一种较低开销的方法是通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel&quot;&gt;MessageChannels的&lt;/a&gt;一个端口发布数据。 另一个端口将发出 &lt;code&gt;message&lt;/code&gt; 事件，并带有附加的 &lt;code&gt;.data&lt;/code&gt; 的结构化克隆。 不幸的是，侦听这些事件必然是异步的，而同步替代方法则不太实用。</target>
        </trans-unit>
        <trans-unit id="536fc99bec8cacfcec8ccb3299a2a1474cf19dcb" translate="yes" xml:space="preserve">
          <source>The main idea is that you need to special handle the instantiation of your functions (or prototypal classes, so to speak) on a per-type basis. Here, he's provided a few examples for RegExp and Date.</source>
          <target state="translated">主要的想法是,你需要在每个类型的基础上特别处理你的函数(或原型类,可以说是原型类)的实例化。这里,他提供了几个RegExp和Date的例子。</target>
        </trans-unit>
        <trans-unit id="1d03570e2e4e838e8bb030726d270bea7041f2a1" translate="yes" xml:space="preserve">
          <source>Then you can use it in your source code.</source>
          <target state="translated">那么你可以在你的源码中使用它。</target>
        </trans-unit>
        <trans-unit id="7e11c30d9fea076d912b290d667b8727da4dc4c8" translate="yes" xml:space="preserve">
          <source>There are few ways to copy this object, without changing the origin:</source>
          <target state="translated">在不改变原点的情况下,复制这个对象的方法很少。</target>
        </trans-unit>
        <trans-unit id="9cffbdc2a939f45667c5e54f6158fadd340d9c4f" translate="yes" xml:space="preserve">
          <source>There are no good options for creating structured clones synchronously. Here are a couple of impractical hacks instead.</source>
          <target state="translated">对于同步创建结构化克隆,没有好的选择。这里有几个不切实际的黑客来代替。</target>
        </trans-unit>
        <trans-unit id="8f852663584757d02b70dc28699f14dc551eb913" translate="yes" xml:space="preserve">
          <source>There seems to be no ideal deep clone operator yet for array-like objects.  As the code below illustrates, John Resig's jQuery cloner turns arrays with non-numeric properties into objects that are not arrays, and RegDwight's JSON cloner drops the non-numeric properties. The following tests illustrate these points on multiple browsers:</source>
          <target state="translated">对于类似数组的对象,似乎还没有一个理想的深度克隆操作者。正如下面的代码所示,John Resig的jQuery cloner将具有非数字属性的数组变成了非数组的对象,而RegDwight的JSON cloner则将非数字属性的对象丢弃。下面的测试在多个浏览器上说明了这些要点。</target>
        </trans-unit>
        <trans-unit id="84ff52d11742048bbbf7e36d51403e124337ed31" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a &lt;a href=&quot;https://github.com/pvorb/node-clone&quot;&gt;library (called &amp;ldquo;clone&amp;rdquo;)&lt;/a&gt;, that does this quite well. It provides the most complete recursive cloning/copying of arbitrary objects that I know of. It also supports circular references, which is not covered by the other answers, yet.</source>
          <target state="translated">有一个&lt;a href=&quot;https://github.com/pvorb/node-clone&quot;&gt;库（称为&amp;ldquo;克隆&amp;rdquo;）&lt;/a&gt; ，可以很好地完成此任务。 它提供了我所知道的任意对象的最完整的递归克隆/复制。 它还支持循环引用，但其他答案尚未涵盖。</target>
        </trans-unit>
        <trans-unit id="e7b585b51a7333981d26696014816bccfeeada81" translate="yes" xml:space="preserve">
          <source>This approach is just simple and easy to implement. Wrap it into a convenience function and if you really need to squeeze out some gain, go for at a later time.</source>
          <target state="translated">这个方法只是简单易行,容易实现。把它包装成一个方便的功能,如果你真的需要挤出一些收益,以后再去争取。</target>
        </trans-unit>
        <trans-unit id="a4c2ce0bbf189255ab3b0ca57da43d56b020264a" translate="yes" xml:space="preserve">
          <source>This function is also available in my &lt;a href=&quot;https://github.com/mbrowne/simpleoo.js&quot;&gt;simpleoo&lt;/a&gt; library.</source>
          <target state="translated">我的&lt;a href=&quot;https://github.com/mbrowne/simpleoo.js&quot;&gt;simpleoo&lt;/a&gt;库中也提供了此功能。</target>
        </trans-unit>
        <trans-unit id="a2600c189d23edb0a999cab533a05c507062b041" translate="yes" xml:space="preserve">
          <source>This is a polyfill for &lt;code&gt;Object.create&lt;/code&gt;, so you also can use this.</source>
          <target state="translated">这是 &lt;code&gt;Object.create&lt;/code&gt; 的polyfill ，因此您也可以使用它。</target>
        </trans-unit>
        <trans-unit id="b0774eac90a9b638a66235a82ded80aefa2940d1" translate="yes" xml:space="preserve">
          <source>This is the right idea. The author (David Walsh) has commented out the cloning of generalized functions. This is something you might choose to do, depending on your use case.</source>
          <target state="translated">这个想法是正确的。作者(David Walsh)已经评论出了泛化函数的克隆。这是你可能会选择做的事情,这要看你的用例。</target>
        </trans-unit>
        <trans-unit id="261e9b62de8d2e123bde54a815e45553f2317283" translate="yes" xml:space="preserve">
          <source>This is what I'm using:</source>
          <target state="translated">我就是用的这个。</target>
        </trans-unit>
        <trans-unit id="659e6c4ea4f37da8a5c31506b04d0f7b8ce21552" translate="yes" xml:space="preserve">
          <source>This isn't generally the most efficient solution, but it does what I need. Simple test cases below...</source>
          <target state="translated">这不是一般最有效的解决方案,但它能满足我的需求。下面是一些简单的测试案例.....</target>
        </trans-unit>
        <trans-unit id="b052950d236ec1a18041eaee77d62414407e7bd9" translate="yes" xml:space="preserve">
          <source>Though synchronous, this can be extremely slow. It incurs all of the overhead associated with manipulating the browser history. Calling this method repeatedly can cause Chrome to become temporarily unresponsive.</source>
          <target state="translated">虽然是同步的,但这可能是非常缓慢的。它产生了所有与操纵浏览器历史记录相关的开销。反复调用此方法会导致Chrome浏览器暂时没有响应。</target>
        </trans-unit>
        <trans-unit id="4c7029866039c44326f3319eb1294370f86d4564" translate="yes" xml:space="preserve">
          <source>Unless this is shipped, browsers' structured clone implementations are only exposed indirectly.</source>
          <target state="translated">除非这一点被屏蔽了,否则浏览器的结构化克隆实现只能间接暴露。</target>
        </trans-unit>
        <trans-unit id="b2c5543687bd4d6c54ea15dfda6268506dab5876" translate="yes" xml:space="preserve">
          <source>Use third-party utility functions:</source>
          <target state="translated">使用第三方的实用功能。</target>
        </trans-unit>
        <trans-unit id="12afa7c8b04e82eddbbfa9613e488fc9ac57905e" translate="yes" xml:space="preserve">
          <source>We're written our own, but the best general approach I've seen is covered here:</source>
          <target state="translated">我们是自己写的,但我看到的最好的一般方法在这里都有涉及。</target>
        </trans-unit>
        <trans-unit id="15e0b646854548e9595e09e3f8c81bad137eacfc" translate="yes" xml:space="preserve">
          <source>Well if you're using angular you could do this too</source>
          <target state="translated">如果你用的是Angular,你也可以这样做。</target>
        </trans-unit>
        <trans-unit id="3be707e8e7ad5100370791fab3839100ec17bea8" translate="yes" xml:space="preserve">
          <source>What is the most efficient way to clone a JavaScript object? I've seen &lt;code&gt;obj = eval(uneval(o));&lt;/code&gt; being used, but &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/uneval&quot;&gt;that's non-standard and only supported by Firefox&lt;/a&gt;.</source>
          <target state="translated">克隆JavaScript对象的最有效方法是什么？ 我见过 &lt;code&gt;obj = eval(uneval(o));&lt;/code&gt; 正在使用，但这&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/uneval&quot;&gt;是非标准的，仅受Firefox支持&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c95066fb63f8c02592924418250d8d1861631e67" translate="yes" xml:space="preserve">
          <source>What is the most efficient way to deep clone an object in JavaScript</source>
          <target state="translated">在JavaScript中,什么是最有效的深度克隆对象的方法?</target>
        </trans-unit>
        <trans-unit id="7a2a34b88909df7977df57d0390303941a8129af" translate="yes" xml:space="preserve">
          <source>When an array contains numbers and strings - functions like .slice(), .concat(), .splice(), the assignment operator &quot;=&quot;, and Underscore.js's clone function; will make a deep copy of the array's elements.</source>
          <target state="translated">当一个数组包含数字和字符串时,像.slice()、.concat()、.plice()、赋值运算符&quot;=&quot;和Underscore.js的克隆函数等函数将对数组元素进行深度复制。</target>
        </trans-unit>
        <trans-unit id="cdf361e2d01fbaaba5c870b9a5cc0ddc1970f725" translate="yes" xml:space="preserve">
          <source>Where jQuery's $.extend has better performance:</source>
          <target state="translated">其中jQuery的$.extend的性能更好。</target>
        </trans-unit>
        <trans-unit id="1e686536bd3ad6cc14390d72268d9b52abcfd59c" translate="yes" xml:space="preserve">
          <source>Where reassignment has the fastest performance:</source>
          <target state="translated">其中重新分配性能最快的是:</target>
        </trans-unit>
        <trans-unit id="432e630fa9f7810fc1984a5382863e495968b087" translate="yes" xml:space="preserve">
          <source>Won't trigger getter/setter while copying.</source>
          <target state="translated">不会在复制时触发采集器。</target>
        </trans-unit>
        <trans-unit id="b2f232831d9d24acc20b048dfb05151b87a88152" translate="yes" xml:space="preserve">
          <source>Works with both &lt;strong&gt;object-literal&lt;/strong&gt; and &lt;strong&gt;functional&lt;/strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;OO&lt;/a&gt; writing styles.</source>
          <target state="translated">适用于&lt;strong&gt;对象文字&lt;/strong&gt;和&lt;strong&gt;功能性&lt;/strong&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;OO&lt;/a&gt;写作风格。</target>
        </trans-unit>
        <trans-unit id="84c744fef8c48f835b1712f23263e95be8178b11" translate="yes" xml:space="preserve">
          <source>Write a custom function (has faster performance than $.extend() or JSON.parse):</source>
          <target state="translated">编写一个自定义函数(比$.extend()或JSON.parse性能更快)。</target>
        </trans-unit>
        <trans-unit id="24eeec13a5cfa1b9871ffaa5ffc4932c30eb71ee" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://npmjs.org/package/clone&quot;&gt;find it on npm&lt;/a&gt;, too. It can be used for the browser as well as Node.js.</source>
          <target state="translated">您也&lt;a href=&quot;https://npmjs.org/package/clone&quot;&gt;可以在npm上找到它&lt;/a&gt; 。 它可以用于浏览器以及Node.js。</target>
        </trans-unit>
        <trans-unit id="4f425e9cb6e5145a30b05e659d988d2ffe18b8f1" translate="yes" xml:space="preserve">
          <source>You can also download the source code manually.</source>
          <target state="translated">你也可以手动下载源码。</target>
        </trans-unit>
        <trans-unit id="b94da3599274cc93c9ee4f4d4dce4fea875b2503" translate="yes" xml:space="preserve">
          <source>but:</source>
          <target state="translated">but:</target>
        </trans-unit>
        <trans-unit id="e74b9178c2fa31f951a6a374c99e4397640909b4" translate="yes" xml:space="preserve">
          <source>jQuery - &lt;a href=&quot;https://api.jquery.com/jquery.extend/#jQuery-extend-deep-target-object1-objectN&quot;&gt;&lt;code&gt;jQuery.extend(true, { }, oldObject)&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;.clone()&lt;/code&gt; only clones DOM elements</source>
          <target state="translated">jQuery- &lt;a href=&quot;https://api.jquery.com/jquery.extend/#jQuery-extend-deep-target-object1-objectN&quot;&gt; &lt;code&gt;jQuery.extend(true, { }, oldObject)&lt;/code&gt; &lt;/a&gt; ; &lt;code&gt;.clone()&lt;/code&gt; 仅克隆DOM元素</target>
        </trans-unit>
        <trans-unit id="aff43fd35dc0a7127d413fb9abde08f7e745d659" translate="yes" xml:space="preserve">
          <source>jQuery's $.extend</source>
          <target state="translated">jQuery的$.extend</target>
        </trans-unit>
        <trans-unit id="d76c148e34e5a1d4cd7e4820e11d94f69b142c70" translate="yes" xml:space="preserve">
          <source>jQuery.extend is pretty fast when the &lt;code&gt;deep&lt;/code&gt; flag is set to &lt;code&gt;false&lt;/code&gt; (shallow clone). It is a good option, because it includes some extra logic for type validation and doesn't copy over undefined properties, etc., but this will also slow you down a little.</source>
          <target state="translated">当 &lt;code&gt;deep&lt;/code&gt; 标志设置为 &lt;code&gt;false&lt;/code&gt; （浅克隆）时，jQuery.extend非常快。 这是一个很好的选择，因为它包括一些用于类型验证的额外逻辑，并且不会复制未定义的属性等，但这也会使您慢一点。</target>
        </trans-unit>
        <trans-unit id="72cb6f36022d5578d8037e1ec22bab7293805704" translate="yes" xml:space="preserve">
          <source>lodash - &lt;a href=&quot;https://lodash.com/docs#cloneDeep&quot;&gt;&lt;code&gt;cloneDeep&lt;/code&gt;&lt;/a&gt;; can be imported separately via the &lt;a href=&quot;https://www.npmjs.com/package/lodash.clonedeep&quot;&gt;lodash.clonedeep&lt;/a&gt; module and is probably your best choice if you're not already using a library that provides a deep cloning function</source>
          <target state="translated">lodash- &lt;a href=&quot;https://lodash.com/docs#cloneDeep&quot;&gt; &lt;code&gt;cloneDeep&lt;/code&gt; &lt;/a&gt; ; 可以通过&lt;a href=&quot;https://www.npmjs.com/package/lodash.clonedeep&quot;&gt;lodash.clonedeep&lt;/a&gt;模块单独导入，如果您尚未使用提供深度克隆功能的库，则可能是您的最佳选择</target>
        </trans-unit>
        <trans-unit id="22d04dec45befefb1dfdd91ef937ed7da722a1c5" translate="yes" xml:space="preserve">
          <source>or package it with &lt;a href=&quot;https://github.com/ender-js/Ender&quot;&gt;Ender&lt;/a&gt;.</source>
          <target state="translated">或与&lt;a href=&quot;https://github.com/ender-js/Ender&quot;&gt;Ender&lt;/a&gt;打包。</target>
        </trans-unit>
        <trans-unit id="636610f807f175806bd4985783c71d6617b0dcdb" translate="yes" xml:space="preserve">
          <source>to be the slowest way to deep clone an object (it is slower than &lt;a href=&quot;https://api.jquery.com/jQuery.extend/&quot;&gt;jQuery.extend&lt;/a&gt; with &lt;code&gt;deep&lt;/code&gt; flag set true by 10-20%).</source>
          <target state="translated">是深度克隆对象的最慢方法（它比&lt;a href=&quot;https://api.jquery.com/jQuery.extend/&quot;&gt;jQuery.extend&lt;/a&gt;的 &lt;code&gt;deep&lt;/code&gt; flag将true设置为10-20％慢）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
