<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/122102">
    <body>
      <group id="122102">
        <trans-unit id="6a1296019722c59836161005f2200651d85a2d6b" translate="yes" xml:space="preserve">
          <source>(Disclaimer: I&amp;rsquo;m the author of the library.)</source>
          <target state="translated">(면책 조항 : 나는 도서관의 저자입니다.)</target>
        </trans-unit>
        <trans-unit id="64955ad90328a8d466dc77f2dc2279f37ae3662c" translate="yes" xml:space="preserve">
          <source>1) ES5+, Using a simple function to do the copy for you:</source>
          <target state="translated">1) ES5 +, 간단한 기능으로 복사하기 :</target>
        </trans-unit>
        <trans-unit id="d473002fec1572f2b85186598bc9517a11e355ea" translate="yes" xml:space="preserve">
          <source>2) ES5+, using JSON.parse and JSON.stringify.</source>
          <target state="translated">2) ES5 +, JSON.parse 및 JSON.stringify를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="595e78f83439199dfd79678374efbded89fb7322" translate="yes" xml:space="preserve">
          <source>3) AngularJs:</source>
          <target state="translated">3) AngularJs :</target>
        </trans-unit>
        <trans-unit id="5f0e185e8e5b75478a2f357848aa4f772facd6c6" translate="yes" xml:space="preserve">
          <source>4) jQuery:</source>
          <target state="translated">4) jQuery :</target>
        </trans-unit>
        <trans-unit id="9b53c147c3475ec22efa77190558bea107a83b7b" translate="yes" xml:space="preserve">
          <source>5) UnderscoreJs &amp;amp; Loadash:</source>
          <target state="translated">5) 밑줄 Js &amp;amp; Loadash :</target>
        </trans-unit>
        <trans-unit id="901156299a6be7b4f59b3097131ee9dbc77718da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;&lt;code&gt;angular.copy&lt;/code&gt;&lt;/a&gt; also provides a method of deep copying objects and arrays.</source>
          <target state="translated">&lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt; &lt;code&gt;angular.copy&lt;/code&gt; &lt;/a&gt; 는 객체와 배열을 딥 카피하는 방법도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="009bfcf1b070cdc110e58ad916aeb0ebdd5fb726" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt;'s _.clone (string arrays, number arrays - only)</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; 의 _.clone (문자열 배열, 숫자 배열-전용)</target>
        </trans-unit>
        <trans-unit id="d9cf8b86d9893dcf61ff2d65c7eb23e635af6fe1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Cloning&lt;/code&gt; an Object was always a concern in JS, but it was all about before ES6, I list different ways of copying an object in JavaScript below, imagine you have the Object below and would like to have a deep copy of that:</source>
          <target state="translated">객체 &lt;code&gt;Cloning&lt;/code&gt; 는 항상 JS의 관심사이지만 ES6 이전의 모든 문제였습니다. 아래에 JavaScript로 객체를 복사하는 다른 방법을 나열하고 아래에 객체가 있고 그 사본을 원한다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="e3149223c859806faae33f5160b811c702a73d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;history.pushState()&lt;/code&gt; and &lt;code&gt;history.replaceState()&lt;/code&gt; both create a structured clone of their first argument, and assign that value to &lt;code&gt;history.state&lt;/code&gt;. You can use this to create a structured clone of any object like this:</source>
          <target state="translated">&lt;code&gt;history.pushState()&lt;/code&gt; 및 &lt;code&gt;history.replaceState()&lt;/code&gt; 는 첫 번째 인수의 구조화 된 클론을 생성하고 해당 값을 &lt;code&gt;history.state&lt;/code&gt; 에 할당합니다. 이것을 사용하여 다음과 같은 객체의 구조화 된 복제본을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4161b70173526960cb9aed49c9b88b668cf10704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Using JSON.parse(JSON.stringify(object));&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. JSON.parse (JSON.stringify (object)) 사용;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1902f5bf21360f09c0db26295028d1ff7489b4b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.Using created method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. 생성 된 방법 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e25db176022db52099ed443a6726dba8845a1e00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Using Lo-Dash's _.cloneDeep&lt;/strong&gt; link &lt;a href=&quot;https://lodash.com/docs/4.17.10#cloneDeep&quot;&gt;lodash&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;3. Lo-Dash의 _.cloneDeep&lt;/strong&gt; 링크 &lt;a href=&quot;https://lodash.com/docs/4.17.10#cloneDeep&quot;&gt;lodash 사용&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f624b1179f0402d969c1657cc787f2504858735b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4. Using Object.assign() method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4. Object.assign () 메소드 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cac2e850fe6d5af9f8c9a6142b37ad1f9f7009f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.Using Underscore.js _.clone&lt;/strong&gt; link &lt;a href=&quot;https://underscorejs.org/#clone&quot;&gt;Underscore.js&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;5. Underscore.js 사용 _.clone&lt;/strong&gt; 링크 &lt;a href=&quot;https://underscorejs.org/#clone&quot;&gt;Underscore.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="494d7a306558ccca865e63d4652b0aa9495ea94a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;Update for ES6&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;ES6 업데이트&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42934660e07ea14a1593287aab8a40230f206a26" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BUT WRONG WHEN&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그러나 잘못되었을 때&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="98bbf0f0be2eb3fe8c5b2688cd063913ea643d9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deep copy an array of objects (two or more levels - reference pointers):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;객체 배열 딥 카피 (2 개 이상의 레벨-참조 포인터) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b73a8e5416d0ea62f53c8ecdcde1fb969db3c61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deep copy an array of strings or numbers (one level - no reference pointers):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;문자열 또는 숫자 배열을 딥 카피 (한 수준-참조 포인터 없음) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e52cb53b46101153f1ec8feb581dd78c9635e122" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deep copy by performance:&lt;/strong&gt;
Ranked from best to worst</source>
          <target state="translated">&lt;strong&gt;성능 별 딥 카피 :&lt;/strong&gt; 최고에서 최고로 순위가 매겨 짐</target>
        </trans-unit>
        <trans-unit id="0b010fb26c7bfe7fd7f5a621d8d8ff63f4765e61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deep copying objects in JavaScript (I think the best and the simplest)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JavaScript로 객체를 딥 카피 (가장 좋고 간단하다고 생각합니다)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="687c20fc62b97668702acfaf2fdc65e95783fd7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JSBEN.CH Performance Benchmarking Playground 1~3 &lt;a href=&quot;http://jsben.ch/KVQLd&quot;&gt;http://jsben.ch/KVQLd&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JSBEN.CH 성능 벤치마킹 놀이터 1 ~ 3 &lt;a href=&quot;http://jsben.ch/KVQLd&quot;&gt;http://jsben.ch/KVQLd&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ca11451a7949aedbb8d25daa4c6e2c9c733a532d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Jsben&lt;/strong&gt; from the answer above updated to show that a recursive deep clone beats all the others mentioned: &lt;a href=&quot;http://jsben.ch/13YKQ&quot;&gt;http://jsben.ch/13YKQ&lt;/a&gt;</source>
          <target state="translated">위의 답변에서 &lt;strong&gt;Jsben&lt;/strong&gt; 은 재귀 딥 클론이 언급 된 다른 모든 것을 능가한다는 것을 보여주기 위해 업데이트되었습니다 : &lt;a href=&quot;http://jsben.ch/13YKQ&quot;&gt;http://jsben.ch/13YKQ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2555b6b4406c27e0b54955990463a4b720d6d0cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Jsperf&lt;/strong&gt; ranks it number one here: &lt;a href=&quot;https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5&quot;&gt;https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;JSperf&lt;/strong&gt; 는 여기에서 1 위를 차지했습니다 : &lt;a href=&quot;https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5&quot;&gt;https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e99feda972b8e68f59dd8de4c023595f522160c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt;  If you use some of this, you may have problems with some iteration who use &lt;code&gt;hasOwnProperty&lt;/code&gt;. Because, &lt;code&gt;create&lt;/code&gt; create new empty object who inherits &lt;code&gt;oldObject&lt;/code&gt;. But it is still useful and practical for cloning objects.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 중 일부를 사용하면 &lt;code&gt;hasOwnProperty&lt;/code&gt; 를 사용하는 일부 반복에 문제가있을 수 있습니다. &lt;code&gt;oldObject&lt;/code&gt; 를 상속받은 새로운 빈 객체를 생성하기 때문 이다. 그러나 여전히 객체 복제에 유용하고 실용적입니다.</target>
        </trans-unit>
        <trans-unit id="65ffb366670c8905ce2cbfbc0625f63dca2cef8b" translate="yes" xml:space="preserve">
          <source>Additionally, please note that, in Chrome 65 at least, native cloning is not the way to go. According to JSPerf, performing native cloning by creating a new function is nearly &lt;strong&gt;800x&lt;/strong&gt; slower than using JSON.stringify which is incredibly fast all the way across the board.</source>
          <target state="translated">또한 Chrome 65에서는 최소한 기본 복제가 불가능합니다. JSPerf에 따르면, 새로운 기능을 생성하여 네이티브 복제를 수행하는 것은 JSON.stringify를 사용하는 것보다 거의 &lt;strong&gt;800 배&lt;/strong&gt; 느리게 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="e9fbc91983624098eab0a0b9d68cfc16ffd38c16" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign&lt;/code&gt;&lt;/a&gt; method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign&lt;/code&gt; &lt;/a&gt; 메서드는 ECMAScript 2015 (ES6) 표준의 일부이며 필요한 것을 정확하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a0c9d534b25ad917673b687d062bc3704ac1ff81" translate="yes" xml:space="preserve">
          <source>And .slice() has better performance than .concat(),
&lt;a href=&quot;http://jsperf.com/duplicate-array-slice-vs-concat/3&quot;&gt;http://jsperf.com/duplicate-array-slice-vs-concat/3&lt;/a&gt;</source>
          <target state="translated">그리고 .slice ()는 .concat (), &lt;a href=&quot;http://jsperf.com/duplicate-array-slice-vs-concat/3&quot;&gt;http://jsperf.com/duplicate-array-slice-vs-concat/3&lt;/a&gt; 보다 성능이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="2a237d4316f291003b4b86dad80c344ac6f420dc" translate="yes" xml:space="preserve">
          <source>And here's the function for quick reference:</source>
          <target state="translated">빠른 참조를위한 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc865b9cd1412c3a1c78268236049f2cf0ff478f" translate="yes" xml:space="preserve">
          <source>And shallow copy one-liner (&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6th edition&lt;/a&gt;, 2015):</source>
          <target state="translated">얕은 사본 한 줄짜리 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6th edition&lt;/a&gt; , 2015) :</target>
        </trans-unit>
        <trans-unit id="2a3de4a9dc7c9f3bd23b0b53226033777b1c013b" translate="yes" xml:space="preserve">
          <source>AngularJS</source>
          <target state="translated">AngularJS</target>
        </trans-unit>
        <trans-unit id="38e2141eb9ea203ffeb32d4cd55e0a65c6cf0af8" translate="yes" xml:space="preserve">
          <source>AngularJS - &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt;&lt;code&gt;angular.copy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">AngularJS- &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.copy&quot;&gt; &lt;code&gt;angular.copy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dbb5fb1e128b60678a581b67d84a563bc06d30de" translate="yes" xml:space="preserve">
          <source>As long as you don't assign an object to anything it maintains no reference in memory.  So to make an object that you want to share among other objects, you'll have to create a factory like so:</source>
          <target state="translated">객체를 객체에 할당하지 않는 한 메모리에서 참조를 유지하지 않습니다. 따라서 다른 객체와 공유하려는 객체를 만들려면 다음과 같이 팩토리를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="113eae0600518a1898dafd21a63c05f2d981cee1" translate="yes" xml:space="preserve">
          <source>Assuming that you have only variables and not any functions in your object, you can  just use:</source>
          <target state="translated">객체에 함수가 아닌 변수 만 있다고 가정하면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="885484b4ce4212e28b9e1f43dae9669bda2c3f25" translate="yes" xml:space="preserve">
          <source>Asynchronous Workaround: Usable. 😕</source>
          <target state="translated">비동기 해결 방법 : 사용 가능 😕</target>
        </trans-unit>
        <trans-unit id="45d1707d26f931a8d5a0db1965460102f4e3ff0c" translate="yes" xml:space="preserve">
          <source>Beware using the &lt;code&gt;JSON.parse(JSON.stringify(obj))&lt;/code&gt; method on &lt;code&gt;Date&lt;/code&gt; objects - &lt;code&gt;JSON.stringify(new Date())&lt;/code&gt; returns a string representation of the date in ISO format, which &lt;code&gt;JSON.parse()&lt;/code&gt;&lt;strong&gt;doesn't&lt;/strong&gt; convert back to a &lt;code&gt;Date&lt;/code&gt; object. &lt;a href=&quot;https://stackoverflow.com/questions/11491938/issues-with-date-when-using-json-stringify-and-json-parse/11491993#11491993&quot;&gt;See this answer for more details&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 객체에서 &lt;code&gt;JSON.parse(JSON.stringify(obj))&lt;/code&gt; 메서드를 사용하는 것에주의하십시오. &lt;code&gt;JSON.stringify(new Date())&lt;/code&gt; 는 ISO 형식으로 날짜의 문자열 표현을 반환하며 &lt;code&gt;JSON.parse()&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 다시 변환 &lt;strong&gt;되지 않습니다.&lt;/strong&gt; &lt;code&gt;Date&lt;/code&gt; 객체에. &lt;a href=&quot;https://stackoverflow.com/questions/11491938/issues-with-date-when-using-json-stringify-and-json-parse/11491993#11491993&quot;&gt;자세한 내용은이 답변을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2973236548453f38ead1f38928c94284e9ecced4" translate="yes" xml:space="preserve">
          <source>Browsers do not currently provide a direct interface for the structured cloning algorithm, but a global &lt;code&gt;structuredClone()&lt;/code&gt; function has been discussed in &lt;a href=&quot;https://github.com/whatwg/html/issues/793&quot;&gt;whatwg/html#793 on GitHub&lt;/a&gt;. As currently proposed, using it for most purposes would be as simple as:</source>
          <target state="translated">브라우저는 현재 구조적 클로닝 알고리즘을위한 직접적인 인터페이스를 제공하지 않지만, 전역 적 &lt;code&gt;structuredClone()&lt;/code&gt; 함수는 &lt;a href=&quot;https://github.com/whatwg/html/issues/793&quot;&gt;GitHub의 whatwg / html # 793에서&lt;/a&gt; 논의되었습니다. 현재 제안한 바와 같이 대부분의 목적으로 사용하는 것은 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="12dd3382e21919424cc1c91dd85712739a9d2a65" translate="yes" xml:space="preserve">
          <source>Checkout this benchmark: &lt;a href=&quot;http://jsben.ch/#/bWfk9&quot;&gt;http://jsben.ch/#/bWfk9&lt;/a&gt;</source>
          <target state="translated">이 벤치 마크를 확인하십시오 : &lt;a href=&quot;http://jsben.ch/#/bWfk9&quot;&gt;http://jsben.ch/#/bWfk9&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="33f64e6db7d2271df61b32aa8af7e37929c89a90" translate="yes" xml:space="preserve">
          <source>Concatenation (string arrays, number arrays - only)</source>
          <target state="translated">연결 (문자열 배열, 숫자 배열-전용)</target>
        </trans-unit>
        <trans-unit id="62deea81938f50a7bee5245055544936da12eca8" translate="yes" xml:space="preserve">
          <source>Crockford suggests (and I prefer) using this function:</source>
          <target state="translated">Crockford는이 기능을 사용하도록 제안하고 선호합니다.</target>
        </trans-unit>
        <trans-unit id="b03a8e60580e981cb3346f2471707bf40078fbfc" translate="yes" xml:space="preserve">
          <source>Custom function: for-loop or recursive copy</source>
          <target state="translated">사용자 정의 기능 : for-loop 또는 재귀 복사</target>
        </trans-unit>
        <trans-unit id="2a51e59697fbe92dbb2e644bf2b96a60a7492a59" translate="yes" xml:space="preserve">
          <source>Cyclic array test...</source>
          <target state="translated">주기적 배열 테스트 ...</target>
        </trans-unit>
        <trans-unit id="6132b55eb09b417ca145535639ce3a5e8b1dabcd" translate="yes" xml:space="preserve">
          <source>Direct Support in Browsers: Maybe Eventually? 😐</source>
          <target state="translated">브라우저에서 직접 지원 : 어쩌면 결국? 😐</target>
        </trans-unit>
        <trans-unit id="f340712260381d35a53813a65d261137ac25e7e6" translate="yes" xml:space="preserve">
          <source>ES6</source>
          <target state="translated">ES6</target>
        </trans-unit>
        <trans-unit id="c59815c7f257e5f2bd8a4266850beddb6342fb92" translate="yes" xml:space="preserve">
          <source>Example Use:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="16ba7f824c47b8dd6421330a2246967e2e7b4d98" translate="yes" xml:space="preserve">
          <source>Fast cloning with data loss - JSON.parse/stringify</source>
          <target state="translated">데이터 손실로 빠른 복제-JSON.parse / stringify</target>
        </trans-unit>
        <trans-unit id="5df81ffa82179b458e1d55e350db9d88805a69b2" translate="yes" xml:space="preserve">
          <source>Features:</source>
          <target state="translated">Features:</target>
        </trans-unit>
        <trans-unit id="548b5bb5625e9995c9b6a6c0c6caa954f3d6146a" translate="yes" xml:space="preserve">
          <source>For completeness, note that ES6 offers two shallow copy mechanisms: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread syntax&lt;/a&gt;.
which copies values of all enumerable own properties from one object to another. For example:</source>
          <target state="translated">완벽을 기하기 위해 ES6는 두 가지 얕은 복사 메커니즘을 제공합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread syntax&lt;/a&gt; . 열거 가능한 모든 자체 속성 값을 한 개체에서 다른 개체로 복사합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f44cbbef6a62693cba2e071062336ff3dc94bb80" translate="yes" xml:space="preserve">
          <source>For exemple if  &lt;code&gt;oldObject.a = 5;&lt;/code&gt;</source>
          <target state="translated">예를 들어 &lt;code&gt;oldObject.a = 5;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f57eb53b7c897cb1b501d5248fb863801dd72556" translate="yes" xml:space="preserve">
          <source>For plain old JavaScript objects, a tried and true good way to clone an object in modern runtimes is quite simply:</source>
          <target state="translated">평범한 오래된 JavaScript 객체의 경우 현대 런타임에서 객체를 복제하는 가장 좋은 방법은 간단합니다.</target>
        </trans-unit>
        <trans-unit id="290ba1968d5c0e35790807a7d71890b939dd1191" translate="yes" xml:space="preserve">
          <source>For the people who want to use the &lt;code&gt;JSON.parse(JSON.stringify(obj))&lt;/code&gt; version, but without losing the Date objects, you can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter&quot;&gt;second argument of &lt;code&gt;parse&lt;/code&gt; method&lt;/a&gt; to convert the strings back to Date:</source>
          <target state="translated">&lt;code&gt;JSON.parse(JSON.stringify(obj))&lt;/code&gt; 버전을 사용하고 싶지만 Date 객체를 잃지 않으면 서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter&quot;&gt; &lt;code&gt;parse&lt;/code&gt; 메소드&lt;/a&gt; 의 두 번째 인수를 사용하여 문자열을 다시 Date로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="819886a4425ab8b131d38de099cf7d21b2593149" translate="yes" xml:space="preserve">
          <source>Function test...</source>
          <target state="translated">기능 검사...</target>
        </trans-unit>
        <trans-unit id="283604d15a7ac67eabe5b3c0f40f636ecca3c9e6" translate="yes" xml:space="preserve">
          <source>Here is an example on how to use it:</source>
          <target state="translated">사용 방법에 대한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="986b97ae19544455c19671d7339eadc9fb9e0e07" translate="yes" xml:space="preserve">
          <source>Here's a more robust version (thanks to Justin McCandless this now supports cyclic references as well):</source>
          <target state="translated">보다 강력한 버전이 있습니다 (Justin McCandless 덕분에 이제 순환 참조도 지원함).</target>
        </trans-unit>
        <trans-unit id="a5601ce43e9ecb2f018a4f09ccd9028408b86893" translate="yes" xml:space="preserve">
          <source>Here's a version of ConroyP's answer above that works even if the constructor has required parameters:</source>
          <target state="translated">다음은 생성자가 매개 변수를 요구 한 경우에도 작동하는 ConroyP의 답변 버전입니다.</target>
        </trans-unit>
        <trans-unit id="43785ecb3cc28739be6434fed6fb0759ce3749d8" translate="yes" xml:space="preserve">
          <source>Hope these help...</source>
          <target state="translated">도움이 되길 바랍니다 ...</target>
        </trans-unit>
        <trans-unit id="9049385ac01962cfa840cada7563fa5809874c60" translate="yes" xml:space="preserve">
          <source>I disagree with the answer with the greatest votes &lt;a href=&quot;https://stackoverflow.com/a/5344074/1110941&quot;&gt;here&lt;/a&gt;. A &lt;strong&gt;Recursive Deep Clone&lt;/strong&gt; is &lt;strong&gt;much faster&lt;/strong&gt; than the &lt;em&gt;JSON.parse(JSON.stringify(obj))&lt;/em&gt; approach mentioned.</source>
          <target state="translated">나는 &lt;a href=&quot;https://stackoverflow.com/a/5344074/1110941&quot;&gt;여기서&lt;/a&gt; 가장 큰 표를 얻은 답변에 동의하지 않습니다. &lt;strong&gt;재귀 딥 클론&lt;/strong&gt; 은 언급 된 &lt;em&gt;JSON.parse (JSON.stringify (obj))&lt;/em&gt; 방식보다 &lt;strong&gt;훨씬 빠릅니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d8d10e7469763c4fa551d6c8215a34b7f532b787" translate="yes" xml:space="preserve">
          <source>I have two good answers depending on whether your objective is to clone a &quot;plain old JavaScript object&quot; or not.</source>
          <target state="translated">당신의 목표가 &quot;일반 자바 스크립트 객체를 복제하는 것&quot;인지 아닌지에 따라 두 가지 좋은 답변이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7fc0603da96abdae3ed58d9e47ceb2a514ed8c2" translate="yes" xml:space="preserve">
          <source>I know this is an old post, but I thought this may be of some help to the next person who stumbles along.</source>
          <target state="translated">나는 이것이 오래된 게시물이라는 것을 알고 있지만 이것이 넘어 질 다음 사람에게 도움이 될 것이라고 생각했다.</target>
        </trans-unit>
        <trans-unit id="770b6fd856a41550954cd1546783c443b5849773" translate="yes" xml:space="preserve">
          <source>I'm surprised no canonical solution exists.</source>
          <target state="translated">정식 해결책이 없다는 것에 놀랐습니다.</target>
        </trans-unit>
        <trans-unit id="489f920024365227ffd4310703cdb9fed08a94ca" translate="yes" xml:space="preserve">
          <source>I've also seen recursive copying functions with various flaws.</source>
          <target state="translated">또한 다양한 결함이있는 재귀 복사 기능을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="0ab70149b7f9dac23be9515659eb536b44c9781b" translate="yes" xml:space="preserve">
          <source>I've done things like &lt;code&gt;obj = JSON.parse(JSON.stringify(o));&lt;/code&gt; but question the efficiency.</source>
          <target state="translated">&lt;code&gt;obj = JSON.parse(JSON.stringify(o));&lt;/code&gt; 그러나 효율성에 의문을 제기하십시오.</target>
        </trans-unit>
        <trans-unit id="2adf921803ec4757f8d2c2ba821f04b210f4ff78" translate="yes" xml:space="preserve">
          <source>If there wasn't any builtin one, you could try:</source>
          <target state="translated">내장 된 것이 없다면 다음을 시도해보십시오.</target>
        </trans-unit>
        <trans-unit id="9398424fd79f967ba29c3a2b98b9498a1b81b153" translate="yes" xml:space="preserve">
          <source>If you are using Javascript ES6 try this native method for cloning or shallow copy.</source>
          <target state="translated">Javascript ES6을 사용하는 경우 복제 또는 단순 복사를 위해이 기본 방법을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="9090a40c83a01a70b916e0798f48cfa367bb40e1" translate="yes" xml:space="preserve">
          <source>If you do not use &lt;code&gt;Date&lt;/code&gt;s, functions, &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays or other complex types within your object, a very simple one liner to deep clone an object is:</source>
          <target state="translated">객체 내에서 &lt;code&gt;Date&lt;/code&gt; , 함수, &lt;code&gt;undefined&lt;/code&gt; , &lt;code&gt;Infinity&lt;/code&gt; , RegExps, 맵, 세트, ​​얼룩, 파일 목록, 이미지 데이터, 희소 배열, 유형 배열 또는 기타 복잡한 유형을 사용하지 않는 경우 객체를 깊게 복제하는 매우 간단한 라이너 :</target>
        </trans-unit>
        <trans-unit id="07552e6b07e4b59604aa421015a02d6d4053e7f4" translate="yes" xml:space="preserve">
          <source>If you know the structure of the objects you are trying to clone or can avoid deep nested arrays you can write a simple &lt;code&gt;for (var i in obj)&lt;/code&gt; loop to clone your object while checking hasOwnProperty and it will be much much faster than jQuery.</source>
          <target state="translated">복제하려는 객체의 구조를 알고 있거나 깊은 중첩 배열을 피할 수있는 경우 hasOwnProperty를 확인하면서 객체를 복제하는 간단한 &lt;code&gt;for (var i in obj)&lt;/code&gt; 루프를 작성할 수 있으며 jQuery보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="50c28e80de0f4e89573c3db98a84c97a95a95f4a" translate="yes" xml:space="preserve">
          <source>If you're using it, the &lt;a href=&quot;http://documentcloud.github.com/underscore/&quot;&gt;Underscore.js&lt;/a&gt; library has a &lt;a href=&quot;http://documentcloud.github.com/underscore/#clone&quot;&gt;clone&lt;/a&gt; method.</source>
          <target state="translated">사용중인 경우 &lt;a href=&quot;http://documentcloud.github.com/underscore/&quot;&gt;Underscore.js&lt;/a&gt; 라이브러리에는 &lt;a href=&quot;http://documentcloud.github.com/underscore/#clone&quot;&gt;복제&lt;/a&gt; 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32c99c466e4a0911b1659ab32d74fd72754b74b4" translate="yes" xml:space="preserve">
          <source>In my previous tests where speed was a main concern I found</source>
          <target state="translated">속도가 주요 관심사였던 이전 테스트에서</target>
        </trans-unit>
        <trans-unit id="401b0ccb46c432dff2afad559300cc0def5cbae9" translate="yes" xml:space="preserve">
          <source>Install it with</source>
          <target state="translated">함께 설치</target>
        </trans-unit>
        <trans-unit id="6cee4a345e292df7d0d5add981b24de0948ebe09" translate="yes" xml:space="preserve">
          <source>Is it efficient? Heck yes. We've tried all kinds of cloning methods and this works best. I'm sure some ninja could conjure up a faster method. But I suspect we're talking about marginal gains.</source>
          <target state="translated">효율적입니까? 그렇습니다. 우리는 모든 종류의 복제 방법을 시도했으며 이것이 가장 효과적입니다. 일부 닌자가 더 빠른 방법을 사용할 수 있다고 확신합니다. 그러나 나는 우리가 한계 이득에 대해 이야기하고 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="552c5e4d033ed42b95333527705d38f03287c127" translate="yes" xml:space="preserve">
          <source>Is this efficient? Heck yes. Given that the goal is to produce a true deep-copy clone, then you're going to have to walk the members of the source object graph. With this approach, you can tweak exactly which child members to treat and how to manually handle custom types.</source>
          <target state="translated">이것이 효율적입니까? 그렇습니다. 목표는 진정한 딥 카피 클론을 생성하는 것이므로 소스 객체 그래프의 멤버를 따라야합니다. 이 방법을 사용하면 처리 할 하위 멤버와 사용자 정의 유형을 수동으로 처리하는 방법을 정확하게 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c94a08f19c18e9bc889cd680ef7113eda1f000c9" translate="yes" xml:space="preserve">
          <source>It's called &quot;structured cloning&quot;, works experimentally in Node 11 and later, and hopefully will land in browsers. See &lt;a href=&quot;https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/10916838#10916838&quot;&gt;this answer&lt;/a&gt; for more details.</source>
          <target state="translated">이를 &quot;구조적 복제&quot;라고하며 노드 11 이상에서 실험적으로 작동하며 브라우저에 들어가기를 희망합니다. 자세한 내용은 &lt;a href=&quot;https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/10916838#10916838&quot;&gt;이 답변&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a50766b911feda7edb7ebbbfa654117a491b7986" translate="yes" xml:space="preserve">
          <source>It's terse, works as expected and you don't need a library.</source>
          <target state="translated">간결하고 예상대로 작동하며 라이브러리가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bed1ab98bd53aec22f5714f0cb05545fe888159" translate="yes" xml:space="preserve">
          <source>JSON.parse (string arrays, number arrays, object arrays - only)</source>
          <target state="translated">JSON.parse (문자열 배열, 숫자 배열, 객체 배열-전용)</target>
        </trans-unit>
        <trans-unit id="c8e5e57858ab0b5524280bd8428db7c8b55655d8" translate="yes" xml:space="preserve">
          <source>JavaScript trace engines suck at optimizing &lt;code&gt;for..in&lt;/code&gt; loops and checking hasOwnProperty will slow you down as well. Manual clone when speed is an absolute must.</source>
          <target state="translated">JavaScript 추적 엔진은 &lt;code&gt;for..in&lt;/code&gt; 루프를 최적화하고 hasOwnProperty를 확인하면 속도가 느려집니다. 속도가 절대적인 경우 수동 복제.</target>
        </trans-unit>
        <trans-unit id="12a1fd73ed0eae8ce0f0c007e80a4dec94139630" translate="yes" xml:space="preserve">
          <source>Just because I didn't see &lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS&lt;/a&gt; mentioned and thought that people might want to know...</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/AngularJS&quot;&gt;AngularJS가&lt;/a&gt; 언급하지 않고 사람들이 알고 싶어 할 것이라고 생각했기 때문에 ...</target>
        </trans-unit>
        <trans-unit id="b5aceb860a4a7199d83d003b87e1425b7dd2c21b" translate="yes" xml:space="preserve">
          <source>Lastly if you are attempting to clone a known object structure in a hot loop you can get MUCH MUCH MORE PERFORMANCE by simply in-lining the clone procedure and manually constructing the object.</source>
          <target state="translated">마지막으로 핫 루프에서 알려진 객체 구조를 복제하려는 경우 단순히 복제 프로 시저를 인라인하고 수동으로 객체를 구성하여 훨씬 더 많은 성능을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79bcce380c0ce7e7dd7c24c0657c08ae5b245de7" translate="yes" xml:space="preserve">
          <source>Let's also assume that your intention is to create a complete clone with no prototype references back to the source object. If you're not interested in a complete clone, then you can use many of the Object.clone() routines provided in some of the other answers (Crockford's pattern).</source>
          <target state="translated">또한 소스 객체에 대한 프로토 타입 참조가없는 완전한 클론을 생성하려는 의도가 있다고 가정 해 봅시다. 완전한 클론에 관심이 없다면 다른 답변 (Crockford의 패턴)에서 제공되는 많은 Object.clone () 루틴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="520d8bb109a39b45dd5e79bd3747a98f5ff3f2e3" translate="yes" xml:space="preserve">
          <source>Lo-Dash's _.cloneDeep</source>
          <target state="translated">Lo-Dash의 _.cloneDeep</target>
        </trans-unit>
        <trans-unit id="209152665b8c481035d0e6dfb91586cec34a0c79" translate="yes" xml:space="preserve">
          <source>Lodash has a nice &lt;a href=&quot;http://lodash.com/docs#cloneDeep&quot;&gt;_.cloneDeep(value)&lt;/a&gt; method:</source>
          <target state="translated">Lodash에는 멋진 &lt;a href=&quot;http://lodash.com/docs#cloneDeep&quot;&gt;_.cloneDeep (value)&lt;/a&gt; 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d05e9acdcff333355c411ee686bab6ff0133f9cc" translate="yes" xml:space="preserve">
          <source>Native deep cloning</source>
          <target state="translated">네이티브 딥 클로닝</target>
        </trans-unit>
        <trans-unit id="e6539f71531625a7144c73c7a36f5fd478b0b5fe" translate="yes" xml:space="preserve">
          <source>Not only is this code brief, but it's also very readable. It's pretty easy to extend.</source>
          <target state="translated">이 코드는 간단 할뿐만 아니라 읽기도 쉽습니다. 확장하기가 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="d4bf0db1b60eef8c1813d1041bc18495d9ce39ca" translate="yes" xml:space="preserve">
          <source>Note that the source object must be a pure JSON object. This is to say, all of its nested properties must be scalars (like boolean, string, array, object, etc). Any functions or special objects like RegExp or Date will not be cloned.</source>
          <target state="translated">소스 객체는 순수한 JSON 객체 여야합니다. 즉, 모든 중첩 속성은 스칼라 여야합니다 (예 : 부울, 문자열, 배열, 객체 등). RegExp 또는 Date와 같은 기능이나 특수 객체는 복제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92030dffe19cafc2b1d2c1490105e85367237388" translate="yes" xml:space="preserve">
          <source>Now, for non-plain JavaScript objects, there isn't a really simple answer.  In fact, there can't be because of the dynamic nature of JavaScript functions and inner object state. Deep cloning a JSON structure with functions inside requires you recreate those functions and their inner context. And JavaScript simply doesn't have a standardized way of doing that.</source>
          <target state="translated">이제 평범하지 않은 JavaScript 객체의 경우 실제로 간단한 대답이 없습니다. 실제로 JavaScript 함수의 동적 특성과 내부 객체 상태로 인해 발생할 수 없습니다. 내부에 함수가있는 JSON 구조를 깊게 복제하려면 해당 함수와 내부 컨텍스트를 다시 작성해야합니다. 그리고 JavaScript에는 단순히 표준화 된 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2dddac477d2fc4da4f071b02ecb0e5c67e1c4eec" translate="yes" xml:space="preserve">
          <source>Only when you can use &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Source-to-source_compiler&quot;&gt;transpilers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015&quot;&gt;ECMAScript 6&lt;/a&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Source-to-source_compiler&quot;&gt;트랜스 필러를&lt;/a&gt; 사용할 수있는 경우에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="a146c2606b2683fa89a081df852f2344d61d9122" translate="yes" xml:space="preserve">
          <source>Preserves getter/setter.</source>
          <target state="translated">게터 / 세터를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ead9d710f07a34e7916d508ba40f3bfe0a8e2dec" translate="yes" xml:space="preserve">
          <source>Preserves prototype informations.</source>
          <target state="translated">프로토 타입 정보를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="b94a461fa5defe5b279c9608d6e61c90faa2d659" translate="yes" xml:space="preserve">
          <source>Read more...</source>
          <target state="translated">더 읽어보기 ...</target>
        </trans-unit>
        <trans-unit id="8497cdbe15233a52b824e49dffae225b8ff72450" translate="yes" xml:space="preserve">
          <source>Reassignment &quot;=&quot; (string arrays, number arrays - only)</source>
          <target state="translated">재 할당 &quot;=&quot;(문자열 배열, 숫자 배열-전용)</target>
        </trans-unit>
        <trans-unit id="9081c30a10752ce26712d2709bcc2abcd45f5c59" translate="yes" xml:space="preserve">
          <source>Reliable cloning using a library</source>
          <target state="translated">라이브러리를 사용한 안정적인 복제</target>
        </trans-unit>
        <trans-unit id="471c7b148e65bf588090efbb408cf2fb82ab9380" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/5344074#5344074&quot;&gt;Corban's answer&lt;/a&gt; for benchmarks.</source>
          <target state="translated">벤치 마크에 대해서는 &lt;a href=&quot;https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/5344074#5344074&quot;&gt;Corban의 답변&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="436e1d9882fcfbc9f3b2875a8d9852f501984dbe" translate="yes" xml:space="preserve">
          <source>Shallow copy one-liner (&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#5th_Edition&quot;&gt;ECMAScript 5th edition&lt;/a&gt;):</source>
          <target state="translated">얕은 복사본 한 줄짜리 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#5th_Edition&quot;&gt;ECMAScript 5 판&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="d9cc20901b278592274b450a481e3147b18f747f" translate="yes" xml:space="preserve">
          <source>Since cloning objects is not trivial (complex types, circular references, function etc.), most major libraries provide function to clone objects. &lt;strong&gt;Don't reinvent the wheel&lt;/strong&gt; - if you're already using a library, check if it has an object cloning function. For example,</source>
          <target state="translated">객체 복제는 사소한 것이 아니기 때문에 (복잡한 유형, 순환 참조, 함수 등) 대부분의 주요 라이브러리는 객체를 복제하는 기능을 제공합니다. &lt;strong&gt;바퀴를 재발 명하지 마십시오.&lt;/strong&gt; 이미 라이브러리를 사용하고 있다면 객체 복제 기능이 있는지 확인하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="77920747b65548ba6059a3d815b6120916ef3d84" translate="yes" xml:space="preserve">
          <source>Slice (string arrays, number arrays - only)</source>
          <target state="translated">슬라이스 (문자열 배열, 숫자 배열-전용)</target>
        </trans-unit>
        <trans-unit id="1ffe9a46d7be9b8028812dac880cc2994ed293c7" translate="yes" xml:space="preserve">
          <source>So there you go. Two approaches. Both are efficient in my view.</source>
          <target state="translated">그래서 당신은 간다. 두 가지 접근 방식. 둘 다 내 관점에서 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="6ad3b82357863678ee1004a1578b7bbd9d5bb008" translate="yes" xml:space="preserve">
          <source>Structured Cloning</source>
          <target state="translated">구조화 된 복제</target>
        </trans-unit>
        <trans-unit id="23f01f984def29d2ca8450b6649412c885cc1ab0" translate="yes" xml:space="preserve">
          <source>Support in Node.js: Experimental 🙂</source>
          <target state="translated">Node.js 지원 : 실험적 🙂</target>
        </trans-unit>
        <trans-unit id="59e328d320b19ac5a6aaa19e1f21c6d03c007174" translate="yes" xml:space="preserve">
          <source>Synchronous Workarounds: Awful! 🤢</source>
          <target state="translated">동기 해결 방법 : 끔찍한! 🤢</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="a5e11aaef6d86dbb08ddecaba334a8d38a925a15" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt; constructor&lt;/a&gt; creates a structured clone of its associated data. It also attempts to display a browser notification to the user, but this will silently fail unless you have requested notification permission. In case you have the permission for other purposes, we'll immediately close the notification we've created.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; 생성자&lt;/a&gt; 는 관련 데이터의 구조화 된 복제본을 만듭니다. 또한 사용자에게 브라우저 알림을 표시하려고 시도하지만 알림 권한을 요청하지 않으면 자동으로 실패합니다. 다른 목적으로 권한을 보유한 경우 Google이 생성 한 알림을 즉시 닫습니다.</target>
        </trans-unit>
        <trans-unit id="33abd86738e91ddf762ad34b84e77510ca29a298" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;v8&lt;/code&gt; module in Node.js currently (as of Node 11) &lt;a href=&quot;https://nodejs.org/api/all.html#v8_serialization_api&quot;&gt;exposes the structured serialization API directly&lt;/a&gt;, but this functionality is still marked as &quot;experimental&quot;, and subject to change or removal in future versions. If you're using a compatible version, cloning an object is as simple as:</source>
          <target state="translated">Node.js의 Node.js에있는 &lt;code&gt;v8&lt;/code&gt; 모듈은 현재 &lt;a href=&quot;https://nodejs.org/api/all.html#v8_serialization_api&quot;&gt;구조화 된 직렬화 API를 직접 노출&lt;/a&gt; 하지만이 기능은 여전히 ​​&quot;실험&quot;으로 표시되며 이후 버전에서는 변경되거나 제거 될 수 있습니다. 호환 가능한 버전을 사용하는 경우 객체 복제는 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="4ebf0771ba83c4cde2f39337676c4fc1f72d4b19" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;polyfill&lt;/strong&gt; to support older browsers:</source>
          <target state="translated">구형 브라우저를 지원하는 &lt;strong&gt;폴리 필&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="6ad8ed5785225ec56294ca4522abde5f0721c0e0" translate="yes" xml:space="preserve">
          <source>The HTML standard includes &lt;a href=&quot;https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data&quot;&gt;&lt;strong&gt;an internal structured cloning/serialization algorithm&lt;/strong&gt;&lt;/a&gt; that can create deep clones of objects. It is still limited to certain built-in types, but in addition to the few types supported by JSON it also supports Dates, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays, and probably more in the future. It also preserves references within the cloned data, allowing it to support cyclical and recursive structures that would cause errors for JSON.</source>
          <target state="translated">HTML 표준에는 개체의 깊은 복제본을 만들 수 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data&quot;&gt;&lt;strong&gt;있는 내부 구조화 된 복제 / 직렬화 알고리즘&lt;/strong&gt;&lt;/a&gt; 이 포함되어 있습니다. 여전히 특정 내장 유형으로 제한되지만 JSON에서 지원하는 몇 가지 유형 외에도 날짜, RegExps, 맵, 세트, ​​Blob, FileLists, ImageDatas, 스파 스 배열, 유형 배열 등을 지원합니다. . 또한 복제 된 데이터 내에서 참조를 유지하므로 JSON에 오류가 발생할 수있는 순환 및 재귀 구조를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7db166788c70c64b3e72f12a43552987dd23d268" translate="yes" xml:space="preserve">
          <source>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.</source>
          <target state="translated">Object.assign () 메소드는 열거 가능한 모든 고유 특성의 값을 하나 이상의 소스 오브젝트에서 대상 오브젝트로 복사하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea189bc649e6f71823539572e783a6707400ee47" translate="yes" xml:space="preserve">
          <source>The correct way to do this, once again, is via a convenience method that you declare and reuse within your code. The convenience method can be endowed with some understanding of your own objects so you can make sure to properly recreate the graph within the new object.</source>
          <target state="translated">이 작업을 다시 수행하는 올바른 방법은 코드 내에서 선언하고 재사용하는 편리한 방법을 사용하는 것입니다. 편리한 방법은 자신의 객체에 대한 이해가 주어 지므로 새 객체 내에서 그래프를 올바르게 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9863ec7b812e3f1bc60cd8d2b37675bbd39e8ece" translate="yes" xml:space="preserve">
          <source>The efficient way to clone(not deep-clone) an object in one line of code</source>
          <target state="translated">한 줄의 코드로 객체를 복제 (심층 복제하지 않음)하는 효율적인 방법</target>
        </trans-unit>
        <trans-unit id="68231b93a0105cba9f5b826511c388f535a2a982" translate="yes" xml:space="preserve">
          <source>The following creates two instances of the same object. I found it and am using it currently. It's simple and easy to use.</source>
          <target state="translated">다음은 동일한 객체의 두 인스턴스를 만듭니다. 나는 그것을 발견하고 현재 그것을 사용하고 있습니다. 간단하고 사용하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="81c869f74b5ea4e2a848d31cc904d67ee6808a0c" translate="yes" xml:space="preserve">
          <source>The lower-overhead way to create a structured clone with existing APIs is to post the data through one port of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel&quot;&gt;MessageChannels&lt;/a&gt;. The other port will emit a &lt;code&gt;message&lt;/code&gt; event with a structured clone of the attached &lt;code&gt;.data&lt;/code&gt;. Unfortunately, listening for these events is necessarily asynchronous, and the synchronous alternatives are less practical.</source>
          <target state="translated">기존 API로 구조화 된 복제본을 만드는 오버 헤드가 낮은 방법은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel&quot;&gt;MessageChannels의&lt;/a&gt; 한 포트를 통해 데이터를 게시하는 것입니다. 다른 포트는 연결된 &lt;code&gt;.data&lt;/code&gt; 의 구조화 된 클론과 함께 &lt;code&gt;message&lt;/code&gt; 이벤트를 생성합니다. 불행히도 이러한 이벤트를 수신하는 것은 반드시 비동기식이며 동기식 대안은 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="536fc99bec8cacfcec8ccb3299a2a1474cf19dcb" translate="yes" xml:space="preserve">
          <source>The main idea is that you need to special handle the instantiation of your functions (or prototypal classes, so to speak) on a per-type basis. Here, he's provided a few examples for RegExp and Date.</source>
          <target state="translated">주요 아이디어는 유형별로 함수 (또는 프로토 타입 클래스)의 인스턴스화를 특수하게 처리해야한다는 것입니다. 여기에서는 RegExp 및 Date에 대한 몇 가지 예를 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="1d03570e2e4e838e8bb030726d270bea7041f2a1" translate="yes" xml:space="preserve">
          <source>Then you can use it in your source code.</source>
          <target state="translated">그런 다음 소스 코드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e11c30d9fea076d912b290d667b8727da4dc4c8" translate="yes" xml:space="preserve">
          <source>There are few ways to copy this object, without changing the origin:</source>
          <target state="translated">원점을 변경하지 않고이 객체를 복사하는 방법은 몇 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cffbdc2a939f45667c5e54f6158fadd340d9c4f" translate="yes" xml:space="preserve">
          <source>There are no good options for creating structured clones synchronously. Here are a couple of impractical hacks instead.</source>
          <target state="translated">구조적 클론을 동 기적으로 생성하기위한 좋은 옵션은 없습니다. 대신 몇 가지 비현실적인 해킹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f852663584757d02b70dc28699f14dc551eb913" translate="yes" xml:space="preserve">
          <source>There seems to be no ideal deep clone operator yet for array-like objects.  As the code below illustrates, John Resig's jQuery cloner turns arrays with non-numeric properties into objects that are not arrays, and RegDwight's JSON cloner drops the non-numeric properties. The following tests illustrate these points on multiple browsers:</source>
          <target state="translated">배열 형 객체에는 아직 이상적인 딥 클론 연산자가없는 것 같습니다. 아래 코드에서 알 수 있듯이 John Resig의 jQuery 복제기는 숫자가 아닌 속성을 가진 배열을 배열이 아닌 객체로 변환하고 RegDwight의 JSON 복제기는 숫자가 아닌 속성을 삭제합니다. 다음 테스트는 여러 브라우저에서 이러한 점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="84ff52d11742048bbbf7e36d51403e124337ed31" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a &lt;a href=&quot;https://github.com/pvorb/node-clone&quot;&gt;library (called &amp;ldquo;clone&amp;rdquo;)&lt;/a&gt;, that does this quite well. It provides the most complete recursive cloning/copying of arbitrary objects that I know of. It also supports circular references, which is not covered by the other answers, yet.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pvorb/node-clone&quot;&gt;라이브러리 (&amp;ldquo;clone&amp;rdquo;이라고 함)&lt;/a&gt; 가 있습니다. 내가 아는 임의의 객체에 대한 가장 완벽한 재귀 복제 / 복사를 제공합니다. 또한 다른 답변으로는 다루지 않는 순환 참조를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e7b585b51a7333981d26696014816bccfeeada81" translate="yes" xml:space="preserve">
          <source>This approach is just simple and easy to implement. Wrap it into a convenience function and if you really need to squeeze out some gain, go for at a later time.</source>
          <target state="translated">이 방법은 간단하고 구현하기 쉽습니다. 편의 기능으로 감싸고 실제로 게인을 짜야하는 경우 나중에 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="a4c2ce0bbf189255ab3b0ca57da43d56b020264a" translate="yes" xml:space="preserve">
          <source>This function is also available in my &lt;a href=&quot;https://github.com/mbrowne/simpleoo.js&quot;&gt;simpleoo&lt;/a&gt; library.</source>
          <target state="translated">이 기능은 내 &lt;a href=&quot;https://github.com/mbrowne/simpleoo.js&quot;&gt;simpleoo&lt;/a&gt; 라이브러리에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2600c189d23edb0a999cab533a05c507062b041" translate="yes" xml:space="preserve">
          <source>This is a polyfill for &lt;code&gt;Object.create&lt;/code&gt;, so you also can use this.</source>
          <target state="translated">&lt;code&gt;Object.create&lt;/code&gt; 의 폴리 필이므로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0774eac90a9b638a66235a82ded80aefa2940d1" translate="yes" xml:space="preserve">
          <source>This is the right idea. The author (David Walsh) has commented out the cloning of generalized functions. This is something you might choose to do, depending on your use case.</source>
          <target state="translated">이것이 올바른 생각입니다. 저자 (David Walsh)는 일반화 된 기능의 복제에 대해 언급했다. 이것은 사용 사례에 따라 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="261e9b62de8d2e123bde54a815e45553f2317283" translate="yes" xml:space="preserve">
          <source>This is what I'm using:</source>
          <target state="translated">이것이 내가 사용하는 것입니다 :</target>
        </trans-unit>
        <trans-unit id="659e6c4ea4f37da8a5c31506b04d0f7b8ce21552" translate="yes" xml:space="preserve">
          <source>This isn't generally the most efficient solution, but it does what I need. Simple test cases below...</source>
          <target state="translated">이것은 일반적으로 가장 효율적인 솔루션은 아니지만 필요한 작업을 수행합니다. 아래의 간단한 테스트 사례 ...</target>
        </trans-unit>
        <trans-unit id="b052950d236ec1a18041eaee77d62414407e7bd9" translate="yes" xml:space="preserve">
          <source>Though synchronous, this can be extremely slow. It incurs all of the overhead associated with manipulating the browser history. Calling this method repeatedly can cause Chrome to become temporarily unresponsive.</source>
          <target state="translated">동기식이지만 매우 느릴 수 있습니다. 브라우저 기록 조작과 관련된 모든 오버 헤드가 발생합니다. 이 메소드를 반복해서 호출하면 Chrome이 일시적으로 응답하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c7029866039c44326f3319eb1294370f86d4564" translate="yes" xml:space="preserve">
          <source>Unless this is shipped, browsers' structured clone implementations are only exposed indirectly.</source>
          <target state="translated">이것이 제공되지 않는 한, 브라우저의 구조화 된 클론 구현은 간접적으로 만 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="b2c5543687bd4d6c54ea15dfda6268506dab5876" translate="yes" xml:space="preserve">
          <source>Use third-party utility functions:</source>
          <target state="translated">타사 유틸리티 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="12afa7c8b04e82eddbbfa9613e488fc9ac57905e" translate="yes" xml:space="preserve">
          <source>We're written our own, but the best general approach I've seen is covered here:</source>
          <target state="translated">우리는 우리 자신이 작성했지만 내가 본 가장 일반적인 접근 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15e0b646854548e9595e09e3f8c81bad137eacfc" translate="yes" xml:space="preserve">
          <source>Well if you're using angular you could do this too</source>
          <target state="translated">앵귤러를 사용하는 경우 에도이 작업을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3be707e8e7ad5100370791fab3839100ec17bea8" translate="yes" xml:space="preserve">
          <source>What is the most efficient way to clone a JavaScript object? I've seen &lt;code&gt;obj = eval(uneval(o));&lt;/code&gt; being used, but &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/uneval&quot;&gt;that's non-standard and only supported by Firefox&lt;/a&gt;.</source>
          <target state="translated">JavaScript 객체를 복제하는 가장 효율적인 방법은 무엇입니까? &lt;code&gt;obj = eval(uneval(o));&lt;/code&gt; 사용되지만 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/uneval&quot;&gt;비표준이며 Firefox에서만 지원됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c95066fb63f8c02592924418250d8d1861631e67" translate="yes" xml:space="preserve">
          <source>What is the most efficient way to deep clone an object in JavaScript</source>
          <target state="translated">JavaScript에서 객체를 딥 복제하는 가장 효율적인 방법은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="7a2a34b88909df7977df57d0390303941a8129af" translate="yes" xml:space="preserve">
          <source>When an array contains numbers and strings - functions like .slice(), .concat(), .splice(), the assignment operator &quot;=&quot;, and Underscore.js's clone function; will make a deep copy of the array's elements.</source>
          <target state="translated">배열에 숫자와 문자열이 포함 된 경우 .slice (), .concat (), .splice ()와 같은 함수, 대입 연산자 &quot;=&quot;및 Underscore.js의 복제 함수; 배열 요소의 깊은 사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cdf361e2d01fbaaba5c870b9a5cc0ddc1970f725" translate="yes" xml:space="preserve">
          <source>Where jQuery's $.extend has better performance:</source>
          <target state="translated">jQuery의 $ .extend가 더 나은 성능을 제공하는 경우 :</target>
        </trans-unit>
        <trans-unit id="1e686536bd3ad6cc14390d72268d9b52abcfd59c" translate="yes" xml:space="preserve">
          <source>Where reassignment has the fastest performance:</source>
          <target state="translated">재 할당이 가장 빠른 성능을 발휘하는 경우 :</target>
        </trans-unit>
        <trans-unit id="432e630fa9f7810fc1984a5382863e495968b087" translate="yes" xml:space="preserve">
          <source>Won't trigger getter/setter while copying.</source>
          <target state="translated">복사하는 동안 게터 / 세터를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2f232831d9d24acc20b048dfb05151b87a88152" translate="yes" xml:space="preserve">
          <source>Works with both &lt;strong&gt;object-literal&lt;/strong&gt; and &lt;strong&gt;functional&lt;/strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;OO&lt;/a&gt; writing styles.</source>
          <target state="translated">&lt;strong&gt;객체 리터럴&lt;/strong&gt; 및 &lt;strong&gt;기능적&lt;/strong&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;OO&lt;/a&gt; 쓰기 스타일 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="84c744fef8c48f835b1712f23263e95be8178b11" translate="yes" xml:space="preserve">
          <source>Write a custom function (has faster performance than $.extend() or JSON.parse):</source>
          <target state="translated">사용자 정의 함수를 작성하십시오 ($ .extend () 또는 JSON.parse보다 성능이 빠름).</target>
        </trans-unit>
        <trans-unit id="24eeec13a5cfa1b9871ffaa5ffc4932c30eb71ee" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://npmjs.org/package/clone&quot;&gt;find it on npm&lt;/a&gt;, too. It can be used for the browser as well as Node.js.</source>
          <target state="translated">&lt;a href=&quot;https://npmjs.org/package/clone&quot;&gt;npm&lt;/a&gt; 에서도 찾을 수 있습니다. Node.js뿐만 아니라 브라우저에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f425e9cb6e5145a30b05e659d988d2ffe18b8f1" translate="yes" xml:space="preserve">
          <source>You can also download the source code manually.</source>
          <target state="translated">소스 코드를 수동으로 다운로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b94da3599274cc93c9ee4f4d4dce4fea875b2503" translate="yes" xml:space="preserve">
          <source>but:</source>
          <target state="translated">but:</target>
        </trans-unit>
        <trans-unit id="e74b9178c2fa31f951a6a374c99e4397640909b4" translate="yes" xml:space="preserve">
          <source>jQuery - &lt;a href=&quot;https://api.jquery.com/jquery.extend/#jQuery-extend-deep-target-object1-objectN&quot;&gt;&lt;code&gt;jQuery.extend(true, { }, oldObject)&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;.clone()&lt;/code&gt; only clones DOM elements</source>
          <target state="translated">jQuery- &lt;a href=&quot;https://api.jquery.com/jquery.extend/#jQuery-extend-deep-target-object1-objectN&quot;&gt; &lt;code&gt;jQuery.extend(true, { }, oldObject)&lt;/code&gt; &lt;/a&gt; ; &lt;code&gt;.clone()&lt;/code&gt; 은 DOM 요소 만 복제합니다</target>
        </trans-unit>
        <trans-unit id="aff43fd35dc0a7127d413fb9abde08f7e745d659" translate="yes" xml:space="preserve">
          <source>jQuery's $.extend</source>
          <target state="translated">jQuery의 $ .extend</target>
        </trans-unit>
        <trans-unit id="d76c148e34e5a1d4cd7e4820e11d94f69b142c70" translate="yes" xml:space="preserve">
          <source>jQuery.extend is pretty fast when the &lt;code&gt;deep&lt;/code&gt; flag is set to &lt;code&gt;false&lt;/code&gt; (shallow clone). It is a good option, because it includes some extra logic for type validation and doesn't copy over undefined properties, etc., but this will also slow you down a little.</source>
          <target state="translated">&lt;code&gt;deep&lt;/code&gt; 플래그가 &lt;code&gt;false&lt;/code&gt; (얕은 복제)로 설정되면 jQuery.extend가 매우 빠릅니다. 형식 유효성 검사를위한 몇 가지 추가 논리가 포함되어 있고 정의되지 않은 속성 등을 복사하지 않기 때문에 좋은 옵션이지만 약간 느려질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="72cb6f36022d5578d8037e1ec22bab7293805704" translate="yes" xml:space="preserve">
          <source>lodash - &lt;a href=&quot;https://lodash.com/docs#cloneDeep&quot;&gt;&lt;code&gt;cloneDeep&lt;/code&gt;&lt;/a&gt;; can be imported separately via the &lt;a href=&quot;https://www.npmjs.com/package/lodash.clonedeep&quot;&gt;lodash.clonedeep&lt;/a&gt; module and is probably your best choice if you're not already using a library that provides a deep cloning function</source>
          <target state="translated">lodash- &lt;a href=&quot;https://lodash.com/docs#cloneDeep&quot;&gt; &lt;code&gt;cloneDeep&lt;/code&gt; &lt;/a&gt; ; &lt;a href=&quot;https://www.npmjs.com/package/lodash.clonedeep&quot;&gt;lodash.clonedeep&lt;/a&gt; 모듈을 통해 별도로 가져올 수 있으며 이미 딥 클로닝 기능을 제공하는 라이브러리를 사용하지 않는 경우 최선의 선택입니다</target>
        </trans-unit>
        <trans-unit id="22d04dec45befefb1dfdd91ef937ed7da722a1c5" translate="yes" xml:space="preserve">
          <source>or package it with &lt;a href=&quot;https://github.com/ender-js/Ender&quot;&gt;Ender&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;https://github.com/ender-js/Ender&quot;&gt;Ender로&lt;/a&gt; 패키지하십시오.</target>
        </trans-unit>
        <trans-unit id="636610f807f175806bd4985783c71d6617b0dcdb" translate="yes" xml:space="preserve">
          <source>to be the slowest way to deep clone an object (it is slower than &lt;a href=&quot;https://api.jquery.com/jQuery.extend/&quot;&gt;jQuery.extend&lt;/a&gt; with &lt;code&gt;deep&lt;/code&gt; flag set true by 10-20%).</source>
          <target state="translated">객체를 딥 복제하는 가장 느린 방법입니다 ( &lt;a href=&quot;https://api.jquery.com/jQuery.extend/&quot;&gt;심플&lt;/a&gt; 플래그가 10-20 %로 설정되어 jQuery.extend 보다 느립니다).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
