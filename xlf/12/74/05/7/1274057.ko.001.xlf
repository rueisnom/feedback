<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1274057">
    <body>
      <group id="1274057">
        <trans-unit id="1b1b1894ca2eb1b577deb9d1c135b98a8bea6403" translate="yes" xml:space="preserve">
          <source>(Under Linux), I wanted to use the posts here suggesting the &lt;code&gt;ls-files --ignored --exclude-standard | xargs git rm -r --cached&lt;/code&gt; approach.  However, (some of) the files to be removed had an embedded newline/LF/&lt;code&gt;\n&lt;/code&gt; in their names.  Neither of the solutions:</source>
          <target state="translated">(Linux에서) &lt;code&gt;ls-files --ignored --exclude-standard | xargs git rm -r --cached&lt;/code&gt; xargs git rm -r-캐시 된 접근. 그러나 제거 될 파일 중 일부에는 이름에 개행 / LF / &lt;code&gt;\n&lt;/code&gt; 되어있었습니다. 해결책 중 어느 것도 :</target>
        </trans-unit>
        <trans-unit id="e165ff5a12e79393f418cbab5ffb6044b4b14192" translate="yes" xml:space="preserve">
          <source>1. You want to untrack a lot of files, or</source>
          <target state="translated">1. 많은 파일을 추적 해제하거나</target>
        </trans-unit>
        <trans-unit id="7291077bbcfea136ea78ae06fee8fb069775f45a" translate="yes" xml:space="preserve">
          <source>1.&lt;strong&gt;remove&lt;/strong&gt; the mistakenly added files &lt;strong&gt;from the directory/storage&lt;/strong&gt;. You can use &quot;rm -r&quot;(for linux) command or delete them by browsing the directories. Or move them to another location on your PC.[You maybe need to close the IDE if running for &lt;strong&gt;moving/removing&lt;/strong&gt;]</source>
          <target state="translated">1. 실수로 추가 한 파일 &lt;strong&gt;을 디렉토리 / 스토리지에서&lt;/strong&gt; &lt;strong&gt;제거&lt;/strong&gt; 하십시오. &quot;rm -r&quot;(linux의 경우) 명령을 사용하거나 디렉토리를 찾아서 삭제할 수 있습니다. 또는 PC의 다른 위치로 옮기십시오. [ &lt;strong&gt;이동 / 제거를&lt;/strong&gt; 위해 실행중인 경우 IDE를 닫아야합니다.]</target>
        </trans-unit>
        <trans-unit id="d29051284b7186e88c71b70107bdfe4f554cc6df" translate="yes" xml:space="preserve">
          <source>2. You updated your gitignore file</source>
          <target state="translated">2. gitignore 파일을 업데이트했습니다</target>
        </trans-unit>
        <trans-unit id="3eee398533d29dfa830054675fbecc16f086d5fd" translate="yes" xml:space="preserve">
          <source>2.add the files / directories to &lt;code&gt;gitignore&lt;/code&gt; file now and save it.</source>
          <target state="translated">2. 파일 / 디렉토리를 &lt;code&gt;gitignore&lt;/code&gt; 파일에 추가하고 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="67d7bf6b04b2072f859546335ca89f354bd6d7ad" translate="yes" xml:space="preserve">
          <source>3.now &lt;strong&gt;remove&lt;/strong&gt; them from &lt;strong&gt;git cache&lt;/strong&gt; by using these commands (if there are more than one directory, remove them one by one by repeatedly issuing this command)</source>
          <target state="translated">3. 이러한 명령을 사용하여 &lt;strong&gt;자식 캐시&lt;/strong&gt; 에서 &lt;strong&gt;제거하십시오&lt;/strong&gt; (두 개 이상의 디렉토리가있는 경우이 명령을 반복적으로 실행하여 하나씩 제거하십시오)</target>
        </trans-unit>
        <trans-unit id="3ea998bdf09e60d9d8abd1f7b841f09d1336d5a1" translate="yes" xml:space="preserve">
          <source>4.now &lt;strong&gt;do&lt;/strong&gt; a &lt;strong&gt;commit and push&lt;/strong&gt;, use these commands. This will &lt;em&gt;remove those files from git remote&lt;/em&gt; and make git &lt;em&gt;stop tracking&lt;/em&gt; those files.</source>
          <target state="translated">4. 이제 &lt;strong&gt;커밋하고 푸시하십시오&lt;/strong&gt; .이 명령을 사용하십시오. 이렇게하면 &lt;em&gt;git remote에서 해당 파일&lt;/em&gt; 이 &lt;em&gt;제거되고 git이&lt;/em&gt; 해당 파일 &lt;em&gt;추적을 중지&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="17ceece8d84cea60549ab352bf79b07ec65dbb55" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://fallengamer.livejournal.com/93321.html&quot;&gt;git assume-unchanged vs skip-worktree&lt;/a&gt;
 and &lt;a href=&quot;http://blog.stephan-partzsch.de/how-to-ignore-changes-in-tracked-files-with-git/&quot;&gt;How to ignore changes in tracked files with Git&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://fallengamer.livejournal.com/93321.html&quot;&gt;자식 가정 변경되지 않은 대 건너 뛰기 작업 트리&lt;/a&gt; 및 &lt;a href=&quot;http://blog.stephan-partzsch.de/how-to-ignore-changes-in-tracked-files-with-git/&quot;&gt;Git을 사용하여 추적 된 파일의 변경 사항을 무시하는 방법&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78e15ae328e1a2411f65d28cc06b7824a162f954" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://git-scm.com/docs/git-rm&quot;&gt;rm&lt;/a&gt; is the remove command</source>
          <target state="translated">&lt;a href=&quot;https://git-scm.com/docs/git-rm&quot;&gt;rm&lt;/a&gt; 은 제거 명령입니다</target>
        </trans-unit>
        <trans-unit id="78fa9ca23f190aad15123aa1d43278ef66819081" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.gitignore&lt;/code&gt; will prevent untracked files from being added (without an &lt;code&gt;add -f&lt;/code&gt;) to the set of files tracked by git, however git will continue to track any files that are already being tracked.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; 는 추적되지 않은 파일이 git에 의해 추적 된 파일 세트에 &lt;code&gt;add -f&lt;/code&gt; 되지 않도록 ( add -f 없이), git은 이미 추적중인 파일을 계속 추적합니다.</target>
        </trans-unit>
        <trans-unit id="b026808a99fb865ebb4e469dc20949169d8d3ebb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add .&lt;/code&gt; &amp;ndash; All files will be added back in, except those in &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git add .&lt;/code&gt; &amp;ndash; &lt;code&gt;.gitignore&lt;/code&gt; 파일을 제외한 모든 파일이 다시 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="cefd39b5696f3a5f3d24162aa70995ec62aae245" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rm -r --cached .&lt;/code&gt; &amp;ndash; Remove all tracked files, including wanted and unwanted. Your code will be safe as long as you have saved locally.</source>
          <target state="translated">&lt;code&gt;git rm -r --cached .&lt;/code&gt; &amp;ndash; 원하거나 원치 않는 것을 포함하여 모든 추적 된 파일을 제거하십시오. 로컬에 저장 한 코드는 안전합니다.</target>
        </trans-unit>
        <trans-unit id="83a9f5eece9214779a020dba22cb30bd64224718" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;ndash;cached&lt;/strong&gt; will only remove files from the index. Your files will still be there.</source>
          <target state="translated">&lt;strong&gt;&amp;ndash;cached&lt;/strong&gt; 는 색인에서 파일 만 제거합니다. 파일은 여전히 ​​존재합니다.</target>
        </trans-unit>
        <trans-unit id="9e0c75fb491e1244c9b2b4f6a21f09d08b9a34ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-r&lt;/strong&gt; will allow recursive removal</source>
          <target state="translated">&lt;strong&gt;-r&lt;/strong&gt; 재귀 제거를 허용합니다</target>
        </trans-unit>
        <trans-unit id="297d9ab2be574ee69d4645675e8640e0fd945953" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;First:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="77360b0eda618b65d4f5b9ac454d8549ce9b33ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This solution is actually independent on &lt;code&gt;.gitignore&lt;/code&gt; as gitignore is only for untracked files.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 솔루션은 실제로 &lt;code&gt;.gitignore&lt;/code&gt; 와 독립적입니다 .gitignore 는 추적되지 않은 파일에만 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3c6108204e2f399b187def4c0bd951a6d5898341" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source link:&lt;/strong&gt;&lt;a href=&quot;http://www.codeblocq.com/2016/01/Untrack-files-already-added-to-git-repository-based-on-gitignore/&quot;&gt;http://www.codeblocq.com/2016/01/Untrack-files-already-added-to-git-repository-based-on-gitignore/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;소스 링크 :&lt;/strong&gt; &lt;a href=&quot;http://www.codeblocq.com/2016/01/Untrack-files-already-added-to-git-repository-based-on-gitignore/&quot;&gt;http://www.codeblocq.com/2016/01/Untrack-files-already-added-to-git-repository-based-on-gitignore/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb20ad117f5ff375c73839d2b25fd98bfdfb7835" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Then:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Then:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bd7c18fe821283d0a4d492412ca53a9045e75db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is no longer an issue in the latest git&lt;/strong&gt; (v2.17.1 at the time of writing).</source>
          <target state="translated">&lt;strong&gt;이것은 더 이상 최신 git&lt;/strong&gt; (작성 당시 v2.17.1) &lt;strong&gt;의 문제가 아닙니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9a6beca2c5a4d325c54a1e8c74ed539c6d15f6f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING: While this will not remove the physical file from your local, it will remove the files from other developers machines on next &lt;code&gt;git pull&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;경고 : 로컬에서 실제 파일을 제거하지는 않지만 다음 &lt;code&gt;git pull&lt;/code&gt; 에서 다른 개발자 컴퓨터에서 파일을 제거합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df8624410ba32bf182a54a6f8f84d790e9343215" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: this will delete the file from your entire history</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 전체 기록에서 파일을 삭제합니다</target>
        </trans-unit>
        <trans-unit id="1658da8ba77a3841c3a93544fd41a158b4742abf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;edit:&lt;/strong&gt; Since this answer was posted, a new option has been created and that should be prefered.  You should use &lt;strong&gt;&lt;code&gt;--skip-worktree&lt;/code&gt;&lt;/strong&gt; which is for modified tracked files that the user don't want to commit anymore and keep &lt;code&gt;--assume-unchanged&lt;/code&gt; for performance to prevent git to check status of big tracked files. See &lt;a href=&quot;https://stackoverflow.com/a/13631525/717372&quot;&gt;https://stackoverflow.com/a/13631525/717372&lt;/a&gt; for more details...</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 이 답변이 게시 된 후 새로운 옵션이 생성되었으며 선호해야합니다. 사용자가 더 이상 커밋하지 않으려는 수정 된 추적 파일에 대해 &lt;strong&gt; &lt;code&gt;--skip-worktree&lt;/code&gt; &lt;/strong&gt; 를 사용하고 git이 큰 추적 파일의 상태를 확인하지 못하도록 성능을 &lt;code&gt;--assume-unchanged&lt;/code&gt; 것으로 가정하십시오. 자세한 내용은 &lt;a href=&quot;https://stackoverflow.com/a/13631525/717372&quot;&gt;https://stackoverflow.com/a/13631525/717372&lt;/a&gt; 를 참조하십시오 ...</target>
        </trans-unit>
        <trans-unit id="21eb2ac0cdcc1bc65e7e9901f8bd153ae5987665" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;git update-index&lt;/strong&gt; does the job for me:</source>
          <target state="translated">&lt;strong&gt;git update-index&lt;/strong&gt; 는 나를 위해 일합니다.</target>
        </trans-unit>
        <trans-unit id="7b7d160b9ed59263729d1515ccfa762f8c20cadf" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt; Because &lt;code&gt;/.git/info/exclude&lt;/code&gt; can be applied to all historical commits using the instructions above, perhaps details about getting a &lt;code&gt;.gitignore&lt;/code&gt; file &lt;em&gt;into&lt;/em&gt; the historical commit(s) that need it is beyond the scope of this answer.  I wanted a proper &lt;code&gt;.gitignore&lt;/code&gt; to be in the root commit, as if it was the first thing I did.  Others may not care since &lt;code&gt;/.git/info/exclude&lt;/code&gt; can accomplish the same thing regardless where the &lt;code&gt;.gitignore&lt;/code&gt; exists in the commit history, and clearly re-writing history is a &lt;strong&gt;very&lt;/strong&gt; touchy subject, even when aware of the &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;ramifications&lt;/a&gt;.</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;code&gt;/.git/info/exclude&lt;/code&gt; 는 위의 지침을 사용하여 모든 기록 커밋에 적용 할 수 있기 때문에 &lt;code&gt;.gitignore&lt;/code&gt; 파일 &lt;em&gt;을&lt;/em&gt; 기록 커밋에 가져 오는 방법에 대한 자세한 내용은이 답변의 범위를 벗어납니다. 내가 한 첫 번째 것처럼 루트 커밋에 적절한 &lt;code&gt;.gitignore&lt;/code&gt; 가 있기를 원했습니다. 커밋 히스토리에서 &lt;code&gt;.gitignore&lt;/code&gt; 가 존재하는 위치에 관계없이 &lt;code&gt;/.git/info/exclude&lt;/code&gt; 가 동일한 것을 수행 할 수 있기 때문에 다른 사람들은 신경 쓰지 않을 수 있으며, &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;파급 효과를&lt;/a&gt; 알고 있더라도 히스토리를 분명히 다시 작성하는 &lt;strong&gt;것은 매우 중요한&lt;/strong&gt; 주제입니다.</target>
        </trans-unit>
        <trans-unit id="8b6da13045058d13d3e3a649a46432a4e053b78f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; Enforcing git ignore behavior after-the-fact by committing the results of a standalone &lt;code&gt;git rm --cached&lt;/code&gt; command may result in newly-ignored file &lt;strong&gt;deletion&lt;/strong&gt; in future pulls from the force-pushed remote. The &lt;code&gt;--prune-empty&lt;/code&gt; flag in the following &lt;code&gt;git filter-branch&lt;/code&gt; command avoids this problem by automatically removing the previous &quot;delete all ignored files&quot; index-only commit.  Re-writing git history also changes commit hashes, which will &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;wreak havoc&lt;/a&gt; on future pulls from public/shared/collaborative repos.  Please understand the &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;ramifications&lt;/a&gt; fully before doing this to such a repo. &lt;a href=&quot;https://help.github.com/en/articles/removing-sensitive-data-from-a-repository&quot;&gt;This GitHub guide&lt;/a&gt; specifies the following:</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; 독립형 &lt;code&gt;git rm --cached&lt;/code&gt; 명령의 결과를 커밋하여 실제로 git 무시 동작을 강제로 실행하면 강제로 푸시 된 원격에서 향후 끌어 올 때 새로 무시 된 파일이 &lt;strong&gt;삭제&lt;/strong&gt; 될 수 있습니다. 다음 &lt;code&gt;git filter-branch&lt;/code&gt; 명령의 &lt;code&gt;--prune-empty&lt;/code&gt; 플래그는 이전의 &quot;무시 된 파일 모두 삭제&quot;인덱스 전용 커밋을 자동으로 제거하여이 문제를 방지합니다. git history를 다시 쓰면 커밋 해시가 변경되어 공개 / 공유 / 협업 리포지토리에서 향후 가져 오기를 방해 할 수 있습니다. 이러한 리포지토리에이를 수행하기 전에 &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;파급 효과를&lt;/a&gt; 완전히 이해하십시오. &lt;a href=&quot;https://help.github.com/en/articles/removing-sensitive-data-from-a-repository&quot;&gt;이 GitHub 안내서&lt;/a&gt; 는 다음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="35bcd509556e93a5b4f240c0aaa275f71d83fd11" translate="yes" xml:space="preserve">
          <source>All methods of enforcing git ignore behavior after-the-fact effectively re-write history and thus have &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;significant ramifications&lt;/a&gt; for any public/shared/collaborative repos that might be pulled after this process. &lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">git을 적용하는 모든 방법은 사후 행동을 무시하고 이력을 효과적으로 다시 작성 하므로이 프로세스 후에 가져올 수있는 공개 / 공유 / 공동 작업 저장소에 &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;상당한 영향&lt;/a&gt; 을 미칩니다. &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7e9e185f8553a03fd2bb4775718d5197931af7f1" translate="yes" xml:space="preserve">
          <source>Also, the comments/&lt;a href=&quot;https://stackoverflow.com/posts/57454176/revisions&quot;&gt;revision history&lt;/a&gt; of &lt;a href=&quot;https://stackoverflow.com/a/57454176&quot;&gt;this answer&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/posts/57418769/revisions&quot;&gt;and revision history&lt;/a&gt; of &lt;a href=&quot;https://stackoverflow.com/posts/57418769&quot;&gt;this question&lt;/a&gt;) may be useful/enlightening.</source>
          <target state="translated">또한, &lt;a href=&quot;https://stackoverflow.com/a/57454176&quot;&gt;이 답변&lt;/a&gt; 의 의견 / &lt;a href=&quot;https://stackoverflow.com/posts/57454176/revisions&quot;&gt;개정 이력&lt;/a&gt; ( &lt;a href=&quot;https://stackoverflow.com/posts/57418769/revisions&quot;&gt;및&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/posts/57418769&quot;&gt;이 질문&lt;/a&gt; 의 개정 이력 ) 이 유용하고 밝아 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1837dc932cb205db53c46200c2d6db222867832" translate="yes" xml:space="preserve">
          <source>Alternative solutions that &lt;strong&gt;do not&lt;/strong&gt; affect the remote repo are &lt;code&gt;git update-index --assume-unchanged &amp;lt;/path/file&amp;gt;&lt;/code&gt; or &lt;code&gt;git update-index --skip-worktree &amp;lt;file&amp;gt;&lt;/code&gt;, examples of which can be found &lt;a href=&quot;https://stackoverflow.com/a/20241145&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">원격 저장소에 영향을 미치지 &lt;strong&gt;않는&lt;/strong&gt; 대체 솔루션은 &lt;code&gt;git update-index --assume-unchanged &amp;lt;/path/file&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;git update-index --skip-worktree &amp;lt;file&amp;gt;&lt;/code&gt; 이며 &lt;a href=&quot;https://stackoverflow.com/a/20241145&quot;&gt;여기&lt;/a&gt; 에서 예제를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a41eb1605b5c4997fa5c53a67b3bccfeac6b535" translate="yes" xml:space="preserve">
          <source>Anti-recommentation: Don't use assume-unchanged, it will only end in tears (because having git lie to itself will cause bad things to happen, like your change being lost forever).</source>
          <target state="translated">반 추천 : 변경하지 않은 채로 사용하지 마십시오. 눈물로만 끝납니다 (git 거짓말 자체가 변경 사항이 영원히 손실되는 것처럼 나쁜 일이 발생할 수 있기 때문에).</target>
        </trans-unit>
        <trans-unit id="d67fefbf8e2fd8148f6312fb95b34f9b6c28c3ac" translate="yes" xml:space="preserve">
          <source>Basing on it I do the following, if file is already tracked:</source>
          <target state="translated">파일을 이미 추적 한 경우 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ee0e2ab0d04aa5d054177f7139fe2f2993169040" translate="yes" xml:space="preserve">
          <source>Before proceeding, make sure all your changes are committed, including your .gitignore file.</source>
          <target state="translated">계속하기 전에 .gitignore 파일을 포함하여 모든 변경 사항이 적용되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="202ec7e461ae2d976889f5c200423159e33e4cff" translate="yes" xml:space="preserve">
          <source>But in Git every time you commit, or save the state of your project, it basically takes a picture of what &lt;strong&gt;&lt;em&gt;all your files&lt;/em&gt;&lt;/strong&gt; look like at that moment and stores a reference to that snapshot. So, if you added file once, it will always be present  in that snapshot.</source>
          <target state="translated">그러나 Git에서는 프로젝트 상태를 커밋하거나 저장할 때마다 기본적으로 &lt;strong&gt;&lt;em&gt;모든 파일의&lt;/em&gt;&lt;/strong&gt; 모양을 파악하고 해당 스냅 샷에 대한 참조를 저장합니다. 따라서 파일을 한 번 추가하면 해당 스냅 샷에 항상 파일이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="34982d9388d501a1c59663bb20321f9e535e5325" translate="yes" xml:space="preserve">
          <source>Commit file config-sample.ini and ignore file config.ini, have a script or similar copy the file as necessary if necessary.</source>
          <target state="translated">config-sample.ini 파일을 커밋하고 config.ini 파일을 무시하고 필요한 경우 파일을 스크립트 또는 이와 유사한 복사본으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5e69dfeea1ca71ec5cba8ba3812cefb3dde8a6d7" translate="yes" xml:space="preserve">
          <source>Do the following steps serially,you will be fine.</source>
          <target state="translated">다음 단계를 순차적으로 수행하면 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="7efbf048e80845e59aa478983b3f909934d4ee15" translate="yes" xml:space="preserve">
          <source>Doing this went into each folder under the 'root' of where I was at and excluded all files that matched the pattern.</source>
          <target state="translated">이렇게하면 내가있는 '루트'아래의 각 폴더로 이동하여 패턴과 일치하는 모든 파일을 제외했습니다.</target>
        </trans-unit>
        <trans-unit id="ce417ee80599859b918672e3deab176250d6a6fa" translate="yes" xml:space="preserve">
          <source>Especially for the IDE based files, I use this:</source>
          <target state="translated">특히 IDE 기반 파일의 경우 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5f23cb20c4075e9581d1185b5b7df71903a476f7" translate="yes" xml:space="preserve">
          <source>FWIW, potential methods may include &lt;code&gt;git rebase&lt;/code&gt; or a &lt;code&gt;git filter-branch&lt;/code&gt; that copies an &lt;em&gt;external&lt;/em&gt;&lt;code&gt;.gitignore&lt;/code&gt; into each commit, like the answers to &lt;a href=&quot;https://stackoverflow.com/q/43463687&quot;&gt;this question&lt;/a&gt;</source>
          <target state="translated">FWIW, 잠재적 인 방법에는 &lt;code&gt;git rebase&lt;/code&gt; 또는 &lt;code&gt;git filter-branch&lt;/code&gt; 가 포함될 수 있습니다. &lt;a href=&quot;https://stackoverflow.com/q/43463687&quot;&gt;이 질문에&lt;/a&gt; 대한 답변과 같이 각 커밋에 &lt;em&gt;외부&lt;/em&gt; &lt;code&gt;.gitignore&lt;/code&gt; 를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="f9934c535834db75b1af736d96add4343490deca" translate="yes" xml:space="preserve">
          <source>File content will be replaced by the remote content. Paste your changes from safe place to file and perform again:</source>
          <target state="translated">파일 내용은 원격 내용으로 대체됩니다. 안전한 장소에서 파일로 변경 사항을 붙여넣고 다시 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="fbe38db5f25e43c80761fee281d19a80da24dfe5" translate="yes" xml:space="preserve">
          <source>Finally, follow the rest of &lt;a href=&quot;https://help.github.com/en/articles/removing-sensitive-data-from-a-repository&quot;&gt;this GitHub guide&lt;/a&gt; (starting at step 6) &lt;strong&gt;which includes important warnings/information about the commands below&lt;/strong&gt;.</source>
          <target state="translated">마지막으로 &lt;strong&gt;아래 명령에 대한 중요한 경고 / 정보가 포함 된&lt;/strong&gt; &lt;a href=&quot;https://help.github.com/en/articles/removing-sensitive-data-from-a-repository&quot;&gt;이 GitHub 안내서&lt;/a&gt; (6 단계에서 시작)의 나머지 부분을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="0ba0b957e82e6fe3a824c66fd56f4787439fab3c" translate="yes" xml:space="preserve">
          <source>Finally, make a commit!</source>
          <target state="translated">마지막으로 커밋하십시오!</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="3377231d1621da920e2f6d01f618d62a65db90db" translate="yes" xml:space="preserve">
          <source>For instance the slnx.sqlite, I just got rid off it completely like following:</source>
          <target state="translated">예를 들어 slnx.sqlite는 방금 다음과 같이 완전히 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="3bc29b2292be0b2cd02509d2f723c4a7e560576e" translate="yes" xml:space="preserve">
          <source>From this moment all local changes in this file will be ignored and will not go to remote. If file is changed on remote, conflict will occure, when &lt;code&gt;git pull&lt;/code&gt;. Stash won't work. To resolve it, &lt;em&gt;copy file content to the safe place&lt;/em&gt; and follow these steps:</source>
          <target state="translated">이 순간부터이 파일의 모든 로컬 변경 사항이 무시되고 원격으로 이동하지 않습니다. 원격에서 파일을 변경하면 &lt;code&gt;git pull&lt;/code&gt; 때 충돌이 발생합니다. 스 태쉬가 작동하지 않습니다. 이를 해결하려면 &lt;em&gt;파일 컨텐츠를 안전한 곳에 복사&lt;/em&gt; 하고 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="fbab929a9779a2ee3e87320c92fff544c9f8051f" translate="yes" xml:space="preserve">
          <source>General advice: &lt;strong&gt;start with a clean repo&lt;/strong&gt; - everything committed, nothing pending in working directory or index, &lt;strong&gt;and make a backup&lt;/strong&gt;!</source>
          <target state="translated">일반적인 조언 : &lt;strong&gt;깨끗한 저장소로 시작&lt;/strong&gt; -커밋 된 모든 것, 작업 디렉토리 나 인덱스에 보류중인 &lt;strong&gt;것 없음, 백업을 만드십시오&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="383228a7a69a177f4167123e5eea04fe6397b184" translate="yes" xml:space="preserve">
          <source>Hat tip to @AkiraYamamoto for pointing us in the right direction.</source>
          <target state="translated">올바른 방향으로 우리를 가리키는 @AkiraYamamoto에게 모자 팁.</target>
        </trans-unit>
        <trans-unit id="566e08627539a7d2ecb5033b1abbdc58839c476c" translate="yes" xml:space="preserve">
          <source>Have your application look for an ignored file config-overide.ini and use that over the committed file config.ini (or alternately, look for ~/.config/myapp.ini, or $MYCONFIGFILE)</source>
          <target state="translated">응용 프로그램이 무시 된 파일 config-overide.ini를 찾도록하고 커밋 된 파일 config.ini에서이 파일을 사용하도록하십시오 (또는 ~ / .config / myapp.ini 또는 $ MYCONFIGFILE)</target>
        </trans-unit>
        <trans-unit id="5bf6447b60376b1563849f40943b48a5d87e3cf8" translate="yes" xml:space="preserve">
          <source>Hope this helps others!</source>
          <target state="translated">이것이 다른 사람들을 돕기를 바랍니다!</target>
        </trans-unit>
        <trans-unit id="a1f359c689bb3b599c937d2b3bde4bbcb5336415" translate="yes" xml:space="preserve">
          <source>How do you force &lt;code&gt;git&lt;/code&gt; to completely forget about [a file]?</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 이 어떻게 [파일]을 완전히 잊도록 강요합니까?</target>
        </trans-unit>
        <trans-unit id="3f4c43dc61508984fa8447acacd10ea274b878cc" translate="yes" xml:space="preserve">
          <source>How to make Git “forget” about a file that was tracked but is now in .gitignore</source>
          <target state="translated">추적되었지만 현재 .gitignore에있는 파일에 대해 Git을&amp;ldquo;잊어 버리는&amp;rdquo;방법</target>
        </trans-unit>
        <trans-unit id="ffb3146d4b977e8077d09a9c235b576b6fb6a3df" translate="yes" xml:space="preserve">
          <source>However, that file keeps showing up in &lt;code&gt;git status&lt;/code&gt; after it's edited. How do you force &lt;code&gt;git&lt;/code&gt; to completely forget about it?</source>
          <target state="translated">그러나 해당 파일은 편집 된 후에도 &lt;code&gt;git status&lt;/code&gt; 계속 표시됩니다. &lt;code&gt;git&lt;/code&gt; 이 어떻게 완전히 잊어 버릴 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="3da73f13e2ca68488453d76581d10690fca48b23" translate="yes" xml:space="preserve">
          <source>I accomplished this by using &lt;a href=&quot;http://git-scm.com/docs/git-filter-branch&quot;&gt;git filter-branch&lt;/a&gt;. The exact command I used was taken from the man page:</source>
          <target state="translated">&lt;a href=&quot;http://git-scm.com/docs/git-filter-branch&quot;&gt;git filter-branch&lt;/a&gt; 사용 하여이 작업을 수행했습니다. 내가 사용한 정확한 명령은 맨 페이지에서 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="e3d824cfebc37780973279c6ef69aebdc266297a" translate="yes" xml:space="preserve">
          <source>I always use this command to remove those untracked files. 
One-line, Unix-style, clean output:</source>
          <target state="translated">추적되지 않은 파일을 제거하기 위해 항상이 명령을 사용합니다. 한 줄의 유닉스 스타일의 깨끗한 출력 :</target>
        </trans-unit>
        <trans-unit id="30df5b0bdab26d64e3f314c5f82d939e368718be" translate="yes" xml:space="preserve">
          <source>I liked JonBrave's answer but I have messy enough working directories that commit -a scares me a bit, so here's what I've done:</source>
          <target state="translated">JonBrave의 답변이 마음에 들었지만 커밋하는 작업 디렉토리가 너무 어려워서 조금 무섭습니다. 그래서 내가 한 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae997b72f572c164f9db73d00da169b807fa2145" translate="yes" xml:space="preserve">
          <source>I recommend reading the documentation, but basically:</source>
          <target state="translated">설명서를 읽는 것이 좋지만 기본적으로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="298daaa4a77ce41f5637f4872a4f45b4106bf606" translate="yes" xml:space="preserve">
          <source>I think, that maybe git can't totally forget about file because of its conception (&lt;a href=&quot;https://git-scm.com/book/en/v2/Getting-Started-Git-Basics&quot;&gt;section &quot;Snapshots, Not Differences&quot;&lt;/a&gt;).</source>
          <target state="translated">아마도 git은 그 개념 때문에 파일을 완전히 잊을 수 없다고 생각합니다 &lt;a href=&quot;https://git-scm.com/book/en/v2/Getting-Started-Git-Basics&quot;&gt;( &quot;스냅 샷, 차이가 아닌&quot;섹션&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="39a2708982ad9e80eba23666c91b4ae5bdb874e7" translate="yes" xml:space="preserve">
          <source>If anyone having hard time on Windows and you wanna ignore entire folder, 'cd' to desired the 'folder' and do 'Git Bash Here'.</source>
          <target state="translated">Windows에서 어려움을 겪고 있고 전체 폴더를 무시하려면 'cd'를 '폴더'에 놓고 'Git Bash Here'를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0e021844325108de6923cd018135a48813b2d1b1" translate="yes" xml:space="preserve">
          <source>If everyone, who works with project, will perform &lt;code&gt;git update-index --skip-worktree &amp;lt;file&amp;gt;&lt;/code&gt;, problems with &lt;code&gt;pull&lt;/code&gt; should be absent. This solution is OK for configurations files, when every developer has their own project configuration.</source>
          <target state="translated">프로젝트로 작업하는 모든 사람이 &lt;code&gt;git update-index --skip-worktree &amp;lt;file&amp;gt;&lt;/code&gt; 을 수행 하면 &lt;code&gt;pull&lt;/code&gt; 문제가 없어야합니다. 이 솔루션은 모든 개발자가 자신의 프로젝트 구성을 가질 때 구성 파일에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="25e96f5e32b3e98d46d6a3c82c2a38e2f06e1122" translate="yes" xml:space="preserve">
          <source>If you cannot &lt;code&gt;git rm&lt;/code&gt; a tracked file because other people might need it (warning, even if &lt;em&gt;you&lt;/em&gt;&lt;code&gt;git rm --cached&lt;/code&gt;, when someone else gets this change, their files will be deleted in their filesystem).  These are often done due to config file overrides, authentication credentials, etc. Please look at &lt;a href=&quot;https://gist.github.com/1423106&quot;&gt;https://gist.github.com/1423106&lt;/a&gt; for ways people have worked around the problem.</source>
          <target state="translated">추적 된 파일을 다른 사람이 필요로 할 수 있기 때문에 추적 할 수없는 경우 ( &lt;code&gt;git rm --cached&lt;/code&gt; 하더라도 다른 사람이이 변경 사항을 가져 오면 해당 파일은 파일 시스템에서 삭제됨) 이는 구성 파일 재정의, 인증 자격 증명 등으로 인해 종종 수행됩니다. 사람들이 문제를 해결 한 방법은 &lt;a href=&quot;https://gist.github.com/1423106&quot;&gt;https://gist.github.com/1423106&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9143aec05a9d0455022a9d3efa538b3f3f9385bc" translate="yes" xml:space="preserve">
          <source>If you don't want to use the CLI and are working on Windows, a very simple solution is to use &lt;a href=&quot;https://tortoisegit.org/&quot;&gt;TortoiseGit&lt;/a&gt;, it has the &quot;Delete (keep local)&quot; Action in the menu which works fine.</source>
          <target state="translated">CLI를 사용하지 않고 Windows에서 작업하는 경우 매우 간단한 해결책은 &lt;a href=&quot;https://tortoisegit.org/&quot;&gt;TortoiseGit&lt;/a&gt; 을 사용하는 것입니다. 메뉴에 &quot;삭제 (로컬 유지)&quot;작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d71f20100d6c8cc8bd6973525e16dd6ba961dbd" translate="yes" xml:space="preserve">
          <source>If you want to remove a whole folder, you need to remove all files in it recursively.</source>
          <target state="translated">전체 폴더를 제거하려면 해당 폴더의 모든 파일을 재귀 적으로 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="15d61d53688648e59ae0d7cc465a1adfc9f32e65" translate="yes" xml:space="preserve">
          <source>If you'd like to specify files by name, you can do that too:</source>
          <target state="translated">이름으로 파일을 지정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5903c3f8465c60a50db152209be8cfcd2f531ee6" translate="yes" xml:space="preserve">
          <source>Ignore them by:</source>
          <target state="translated">다음과 같이 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="6909856450b8468ce19ecf4aa7c57653169fd9a9" translate="yes" xml:space="preserve">
          <source>In case of already committed &lt;code&gt;DS_Store&lt;/code&gt;:</source>
          <target state="translated">이미 커밋 된 &lt;code&gt;DS_Store&lt;/code&gt; 의 경우 :</target>
        </trans-unit>
        <trans-unit id="cb61bbad89d4ac5b475150e04f8ff4d53d867cc4" translate="yes" xml:space="preserve">
          <source>In fact, this solution will cause the file to be &lt;strong&gt;deleted&lt;/strong&gt; in every other instance of the repository when executing a &lt;code&gt;git pull&lt;/code&gt;!</source>
          <target state="translated">실제로이 솔루션은 &lt;code&gt;git pull&lt;/code&gt; !을 실행할 때 파일이 저장소의 다른 모든 인스턴스에서 &lt;strong&gt;삭제&lt;/strong&gt; 되도록합니다!</target>
        </trans-unit>
        <trans-unit id="b6281cb7098a9a1bf8ab74eea9cf623585f3557d" translate="yes" xml:space="preserve">
          <source>In my case here, I had several .lock files in several directories that I needed to remove. I ran the following and it worked without having to go into each directory to remove them:</source>
          <target state="translated">내 경우에는 제거해야 할 여러 디렉토리에 여러 개의 .lock 파일이 있습니다. 나는 다음을 실행했고 그것을 제거하기 위해 각 디렉토리로 이동할 필요가 없었습니다.</target>
        </trans-unit>
        <trans-unit id="f2ee46b5bf348489144ff43d13bb1f9db4b9e4cc" translate="yes" xml:space="preserve">
          <source>In the manual page &lt;strong&gt;git-ls-files(1)&lt;/strong&gt;, it states:</source>
          <target state="translated">매뉴얼 페이지 &lt;strong&gt;git-ls-files (1)&lt;/strong&gt; 에는 다음과 같이 명시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e3a8ac2b04f693dce99c91c6d013b19a784ceac" translate="yes" xml:space="preserve">
          <source>It is not very convenient to do this every time, when file has been changed on remote, but can protect it from overwriting by remote content.</source>
          <target state="translated">원격에서 파일이 변경 될 때마다이 작업을 수행하는 것이 매우 편리하지는 않지만 원격 컨텐츠로 덮어 쓰지 않도록 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da0a30820d35bda263d21ef6c921be754b4fb2b" translate="yes" xml:space="preserve">
          <source>It lists all your ignored files, replace every output line with a quoted line instead to handle paths with spaces inside, and pass everything to &lt;code&gt;git rm -r --cached&lt;/code&gt; to remove the paths/files/dirs from the index.</source>
          <target state="translated">무시 된 모든 파일을 나열하고 모든 출력 줄을 인용 된 줄로 바꾸고 대신 공백이있는 경로를 처리하고 모든 것을 &lt;code&gt;git rm -r --cached&lt;/code&gt; 에 전달하여 색인에서 경로 / 파일 / 디렉토리를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="427dd941220a11cde80854cae040581bf7a7bc39" translate="yes" xml:space="preserve">
          <source>Just keep that in mind that some of those files stores some local user settings and preferences for projects (like what files you had open). So every time you navigate or do some changes in your IDE, that file is changed and therefore it checks it out and show as there are uncommitted changes.</source>
          <target state="translated">이러한 파일 중 일부는 프로젝트에 대한 일부 로컬 사용자 설정 및 환경 설정 (열린 파일과 같은)을 저장한다는 점을 명심하십시오. 따라서 IDE에서 탐색하거나 일부 변경을 수행 할 때마다 해당 파일이 변경되므로 커밋되지 않은 변경이있을 때 파일을 확인하고 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1e1f9446808bef2a81577b3811952c9be0140995" translate="yes" xml:space="preserve">
          <source>Keep the config file on a deploy branch dedicated to it that is never merged to master.  When you want to deploy/compile/test you merge to that branch and get that file.  This is essentially the smudge/clean approach except using human merge policies and extra-git modules.</source>
          <target state="translated">구성 파일은 마스터에 병합되지 않는 전용 배치 브랜치에 보관하십시오. 배포 / 컴파일 / 테스트하려는 경우 해당 분기로 병합하고 해당 파일을 가져옵니다. 이는 휴먼 머지 정책 및 여분의 git 모듈을 사용하는 것을 제외하고는 기본적으로 얼룩 / 깨끗한 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="6b5335338767809a90c12fd0a6cc98271bc8581c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have already added/committed some files to your git repository and you then add them to your .gitignore; these files will still be present in your repository index. This article we will see how to get rid of them.</source>
          <target state="translated">git 저장소에 이미 일부 파일을 추가 / 커밋 한 다음 .gitignore에 추가한다고 가정 해 봅시다. 이러한 파일은 여전히 ​​저장소 색인에 있습니다. 이 기사에서는 그것들을 제거하는 방법을 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d06145c701eb9f7bcded9868ffbb9cfbfbf4af3" translate="yes" xml:space="preserve">
          <source>Move or copy the file to a safe location, so you don't lose it. Then git rm the file and commit. The file will still show up if you revert to one of those earlier commits, or another branch where it has not been removed. However, in all future commits, you will not see the file again. If the file is in the git ignore, then you can move it back into the folder, and git won't see it.</source>
          <target state="translated">파일을 안전한 위치로 옮기거나 복사하면 손실되지 않습니다. 그런 다음 파일을 git rm하고 커밋하십시오. 이전 커밋 중 하나 또는 제거되지 않은 다른 브랜치로 되 돌리면 파일이 계속 표시됩니다. 그러나 이후의 모든 커밋에서 파일을 다시 볼 수는 없습니다. 파일이 git ignore에 있으면 파일을 폴더로 다시 이동할 수 있으며 git은 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b531fabd41eb9da9a0ba874d765d34f24cb5c8b2" translate="yes" xml:space="preserve">
          <source>Or one-liner:</source>
          <target state="translated">또는 하나의 라이너 :</target>
        </trans-unit>
        <trans-unit id="41da50eece3db9d79a767edff75028a53b36f061" translate="yes" xml:space="preserve">
          <source>Other devs that pull from now-modified remote repo should make a backup and then:</source>
          <target state="translated">현재 수정 된 원격 저장소에서 가져온 다른 개발자는 백업을 수행 한 후 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b54a2d9b41681e32ea54dbeeffc97236f62a7a92" translate="yes" xml:space="preserve">
          <source>Push the changes to your remote to see the changes effective there as well.</source>
          <target state="translated">변경 사항을 리모컨으로 푸시하여 변경 사항을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="d5809414f5464acab9aa7ba79e8f76e8e3a3a51a" translate="yes" xml:space="preserve">
          <source>So I offer</source>
          <target state="translated">그래서 나는 제안한다</target>
        </trans-unit>
        <trans-unit id="960fb31d4493678100902bc9586b9c046362e226" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://confluence.atlassian.com/bitbucket/reduce-repository-size-321848262.html&quot;&gt;https://confluence.atlassian.com/bitbucket/reduce-repository-size-321848262.html&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;https://confluence.atlassian.com/bitbucket/reduce-repository-size-321848262.html&quot;&gt;https://confluence.atlassian.com/bitbucket/reduce-repository-size-321848262.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="612e5a5b717eb6a345fff1875325e4e780814272" translate="yes" xml:space="preserve">
          <source>Step 1: Commit all your changes</source>
          <target state="translated">1 단계 : 모든 변경 사항 커밋</target>
        </trans-unit>
        <trans-unit id="77880434b84506c14708316521c7f71b103ddbdc" translate="yes" xml:space="preserve">
          <source>Step 2: Remove everything from the repository</source>
          <target state="translated">2 단계 : 저장소에서 모든 항목 제거</target>
        </trans-unit>
        <trans-unit id="9c2ed963345aea24138333def583839f931c4674" translate="yes" xml:space="preserve">
          <source>Step 3: Re add everything</source>
          <target state="translated">3 단계 : 모든 것을 다시 추가</target>
        </trans-unit>
        <trans-unit id="1a2dff51a26bbc76eec72ab492cccbb8f3c8089b" translate="yes" xml:space="preserve">
          <source>Step 4: Commit</source>
          <target state="translated">4 단계 : 커밋</target>
        </trans-unit>
        <trans-unit id="62e557118db016748e85b8aff058461061ff972e" translate="yes" xml:space="preserve">
          <source>Tell your collaborators to &lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Rebasing&quot;&gt;rebase&lt;/a&gt;, &lt;em&gt;not&lt;/em&gt; merge, any branches they created off of your old (tainted) repository history. One merge commit could reintroduce some or all of the tainted history that you just went to the trouble of purging.</source>
          <target state="translated">협업 자에게 이전 (오염 된) 저장소 히스토리에서 작성된 브랜치를 병합 &lt;em&gt;하지 말고&lt;/em&gt; &lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Rebasing&quot;&gt;리베이스&lt;/a&gt; 하도록 지시하십시오. 한 번의 병합 커밋을 통해 방금 퍼지 문제를 겪은 오염 된 기록의 일부 또는 전부를 다시 소개 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0507b4cf9226f930b3c47ada0f53498a6301526a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/&quot;&gt;BFG&lt;/a&gt; is specifically designed for removing unwanted data like big files or passwords from Git repos, so it has a simple flag that will remove any large historical (not-in-your-current-commit) files: '--strip-blobs-bigger-than'</source>
          <target state="translated">&lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/&quot;&gt;BFG&lt;/a&gt; 는 Git 저장소에서 큰 파일이나 암호와 같은 원치 않는 데이터를 제거하기 위해 특별히 설계되었으므로 현재 사용중인 커밋되지 않은 큰 파일을 제거하는 간단한 플래그가 있습니다. '--strip-blobs- 보다 큰'</target>
        </trans-unit>
        <trans-unit id="cf74012f43e3173d4f2f3a304c076743addefd4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitignore&lt;/code&gt; finally ignores tracked-but-deleted files. You can test this for yourself by running the following script. The final &lt;code&gt;git status&lt;/code&gt; statement should report &quot;nothing to commit&quot;.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; 는 결국 추적되었지만 삭제 된 파일을 무시합니다. 다음 스크립트를 실행하여 직접 테스트 할 수 있습니다. 마지막 &lt;code&gt;git status&lt;/code&gt; statement는 &quot;No commits&quot;를보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="18bd883e64a162aac02dba83baaf242c9aba9d6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rm&lt;/code&gt; command can be unforgiving. If you wish to try what it does beforehand, add the &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--dry-run&lt;/code&gt; flag to test things out.</source>
          <target state="translated">&lt;code&gt;rm&lt;/code&gt; 명령은 용서할 수 없습니다. 미리 수행하려는 작업을 시도하려면 &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;--dry-run&lt;/code&gt; 플래그를 추가하여 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="e219646ce5997a53b1eec4fddf7d5da98274f8a7" translate="yes" xml:space="preserve">
          <source>The BFG is 10-1000x faster than git filter-branch, and generally much easier to use - check the &lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/#usage&quot;&gt;full usage instructions&lt;/a&gt; and &lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/#examples&quot;&gt;examples&lt;/a&gt; for more details.</source>
          <target state="translated">BFG는 git filter-branch보다 10-1000 배 빠르며 일반적으로 사용하기가 훨씬 쉽습니다. 자세한 내용은 &lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/#usage&quot;&gt;전체 사용 지침&lt;/a&gt; 및 &lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/#examples&quot;&gt;예제&lt;/a&gt; 를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4e1d1bc82d1b78eb89712cf8828bb7c8cc774d0a" translate="yes" xml:space="preserve">
          <source>The accepted answer does not &quot;make Git &lt;strong&gt;&quot;forget&quot;&lt;/strong&gt; about a file...&quot; (historically).  It only makes git &lt;strong&gt;ignore&lt;/strong&gt; the file in the present/future.</source>
          <target state="translated">받아 들여진 대답은 &quot;파일에 대해 Git을 &lt;strong&gt;&quot;잊어 버린다 &quot;&lt;/strong&gt; ... (역사적으로) 아닙니다. 현재 / 미래의 파일을 git이 &lt;strong&gt;무시&lt;/strong&gt; 하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bd8f4258fd7f17f2cbd6e097a5da666229f8a59c" translate="yes" xml:space="preserve">
          <source>The answer from Matt Fear was the most effective IMHO. The following is just a PowerShell script for those in windows to only remove files from their git repo that matches their exclusion list.</source>
          <target state="translated">Matt Fear의 답변이 가장 효과적인 IMHO였습니다. 다음은 Windows의 사용자가 제외 목록과 일치하는 git repo에서 파일을 제거하는 PowerShell 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="67e52d337d22c9b5bfb6014db3c396cfda77accb" translate="yes" xml:space="preserve">
          <source>The copy/paste answer is &lt;code&gt;git rm --cached -r .; git add .; git status&lt;/code&gt;</source>
          <target state="translated">복사 / 붙여 넣기 답변은 &lt;code&gt;git rm --cached -r .; git add .; git status&lt;/code&gt; 자식 추가.; 자식 상태</target>
        </trans-unit>
        <trans-unit id="78a25064d23dc897dd87d00c940f9b4e4c4ffb99" translate="yes" xml:space="preserve">
          <source>The correct way to force git to forget about a file is documented by GitHub &lt;a href=&quot;https://help.github.com/en/articles/removing-sensitive-data-from-a-repository&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">git이 파일을 잊게하는 올바른 방법은 GitHub에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7351c780e287a42a26ece70eefbcf456f1046dd" translate="yes" xml:space="preserve">
          <source>The removal of the file from the head revision will happen on the next commit.</source>
          <target state="translated">헤드 개정에서 파일 제거는 다음 커밋에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aef3fa74c8e59e395be7f68fe29a155144721883" translate="yes" xml:space="preserve">
          <source>The series of commands below will remove all of the items from the Git Index (not from the working directory or local repo), and then updates the Git Index, while respecting git ignores. &lt;em&gt;PS. Index = Cache&lt;/em&gt;</source>
          <target state="translated">아래의 일련의 명령은 작업 디렉토리 또는 로컬 저장소가 아닌 Git 인덱스에서 모든 항목을 제거한 다음 git 무시를 고려하면서 Git 인덱스를 업데이트합니다. &lt;em&gt;추신.&lt;/em&gt; &lt;em&gt;인덱스 = 캐시&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="059b6a3f58c111d094d712b8584163f9e7b63336" translate="yes" xml:space="preserve">
          <source>There is a file that was being tracked by &lt;code&gt;git&lt;/code&gt;, but now the file is on the &lt;code&gt;.gitignore&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 에 의해 추적되는 파일이 있지만 이제 파일이 &lt;code&gt;.gitignore&lt;/code&gt; 목록에 있습니다.</target>
        </trans-unit>
        <trans-unit id="99eb079a0b8763cc9243db3017fce8f2b5f1c2b1" translate="yes" xml:space="preserve">
          <source>These 2 articles were helpful for me:</source>
          <target state="translated">이 두 기사가 도움이되었습니다.</target>
        </trans-unit>
        <trans-unit id="9b99e56bf3215466d4bcb6510e8f2ab3c18e92a1" translate="yes" xml:space="preserve">
          <source>This command will ignore the files that have already been committed to a Git repository but now we have added them to &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">이 명령은 이미 Git 리포지토리에 커밋 된 파일은 무시하지만 이제는 &lt;code&gt;.gitignore&lt;/code&gt; 에 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="6a80256c88620e0c46466e120451785a26291aed" translate="yes" xml:space="preserve">
          <source>This command will recreate the entire commit history, executing &lt;code&gt;git rm&lt;/code&gt; before each commit and so will get rid of the specified file. Don't forget to back it up before running the command as it &lt;em&gt;will&lt;/em&gt; be lost.</source>
          <target state="translated">이 명령은 전체 커밋 히스토리를 다시 작성하여 각 커밋 전에 &lt;code&gt;git rm&lt;/code&gt; 을 실행 하므로 지정된 파일을 제거합니다. 명령을 실행하기 전에 백업하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="aace7ffcc2632aa8ca6dcf3aeb06c1b3b98defb7" translate="yes" xml:space="preserve">
          <source>This method makes git &lt;strong&gt;completely forget&lt;/strong&gt; ignored files (&lt;strong&gt;past&lt;/strong&gt;/present/future), but does &lt;strong&gt;not&lt;/strong&gt; delete anything from working directory (even when re-pulled from remote).</source>
          <target state="translated">이 방법은 git이 무시 된 파일 ( &lt;strong&gt;과거의&lt;/strong&gt; / present / future)을 &lt;strong&gt;완전히 잊게&lt;/strong&gt; 하지만 작업 디렉토리에서 아무것도 삭제하지 &lt;strong&gt;않습니다&lt;/strong&gt; (원격에서 다시 당기더라도).</target>
        </trans-unit>
        <trans-unit id="0fd8d975ab3598d0501dc78d1c2086af30973cad" translate="yes" xml:space="preserve">
          <source>This method requires usage of &lt;code&gt;/.git/info/exclude&lt;/code&gt; (preferred) &lt;strong&gt;OR&lt;/strong&gt; a &lt;strong&gt;pre-existing&lt;/strong&gt;&lt;code&gt;.gitignore&lt;/code&gt; in &lt;strong&gt;all&lt;/strong&gt; the commits that have files to be ignored/forgotten. &lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">이 방법을 사용하려면 &lt;code&gt;/.git/info/exclude&lt;/code&gt; (선호)를 사용 하거나 무시하거나 잊어 버린 파일이있는 &lt;strong&gt;모든&lt;/strong&gt; 커밋에서 &lt;strong&gt;기존&lt;/strong&gt; &lt;code&gt;.gitignore&lt;/code&gt; 를 사용해야합니다. &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ee4e1a639a65a59982342cdd0d5f935792f354b4" translate="yes" xml:space="preserve">
          <source>This problem is absent, for example, when using CVS. CVS stores information as a list of file-based changes. Information for CVS is a set of files and the changes made to each file over time.</source>
          <target state="translated">예를 들어 CVS를 사용할 때이 문제는 없습니다. CVS는 정보를 파일 기반 변경 목록으로 저장합니다. CVS에 대한 정보는 일련의 파일과 시간에 따른 각 파일의 변경 사항입니다.</target>
        </trans-unit>
        <trans-unit id="a3d360038ad27ca130f73142cff92cf439acd687" translate="yes" xml:space="preserve">
          <source>This takes the list of the ignored files and removes them from the index, then commits the changes.</source>
          <target state="translated">무시 된 파일 목록을 가져 와서 인덱스에서 제거한 다음 변경 사항을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="8ef3809914d0a4bf55ad9dbd46e75e9ee26c43d4" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;-z&lt;/code&gt; argument to &lt;strong&gt;ls-files&lt;/strong&gt;, and the &lt;code&gt;-0&lt;/code&gt; argument to &lt;strong&gt;xargs&lt;/strong&gt; to cater safely/correctly for &quot;nasty&quot; characters in filenames.</source>
          <target state="translated">이것은 &lt;strong&gt;ls-files에&lt;/strong&gt; &lt;code&gt;-z&lt;/code&gt; 인수를 사용하고 &lt;strong&gt;xargs&lt;/strong&gt; 에 &lt;code&gt;-0&lt;/code&gt; 인수를 사용하여 파일 이름의 &quot;불쾌한&quot;문자를 안전하게 / 정확하게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fac1fa39e67b6dbe6a9e8961a2ebbe207fd0a129" translate="yes" xml:space="preserve">
          <source>To clear your repo, use:</source>
          <target state="translated">저장소를 지우려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9ece9b71ac3beff566f8bc63a178b67231ef3864" translate="yes" xml:space="preserve">
          <source>To stop tracking a file you need to remove it from the index. This can be achieved with this command.</source>
          <target state="translated">파일 추적을 중지하려면 색인에서 파일을 제거해야합니다. 이것은이 명령으로 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e28adc0562a325e3e096fedb43aec2bcfc26cc2" translate="yes" xml:space="preserve">
          <source>To summarize:</source>
          <target state="translated">요약:</target>
        </trans-unit>
        <trans-unit id="9ef7a39f54d24e9a0a605a35fb91afa4588e67b8" translate="yes" xml:space="preserve">
          <source>Try to use gitattributes clean/smudge magic to apply and remove the changes for you, for instance smudge the config file as a checkout from an alternate branch and clean the config file as a checkout from HEAD.  This is tricky stuff, I don't recommend it for the novice user.</source>
          <target state="translated">gitattributes clean / smudge 마술을 사용하여 변경 사항을 적용하고 제거하십시오 (예 : 대체 브랜치에서 구성 파일을 체크 아웃으로 번지거나 HEAD에서 구성 파일을 체크 아웃으로 정리). 이것은 까다로운 일이므로 초보자에게는 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e966285e3158a217aa4fa3d2055f125148a7452f" translate="yes" xml:space="preserve">
          <source>Update your &lt;code&gt;.gitignore&lt;/code&gt; file &amp;ndash; for instance, add a folder you don't want to track to &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; 파일을 업데이트합니다 . 예를 들어 추적하지 않으려는 폴더를 &lt;code&gt;.gitignore&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c04f0b185dde023e1da3e23b5abf4ebb68539583" translate="yes" xml:space="preserve">
          <source>Use this when:</source>
          <target state="translated">다음과 같은 경우에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="87f831e2d4c6393d9fcee8d70bc3691c05dbf836" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;git rm --cached&lt;/code&gt; command does not answer the original question:</source>
          <target state="translated">&lt;code&gt;git rm --cached&lt;/code&gt; 명령을 사용해도 원래 질문에 대답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe9e905994f09d5cd0a93eec644ef1b6cc083fae" translate="yes" xml:space="preserve">
          <source>What didn't work for me</source>
          <target state="translated">나에게 효과가 없었던 것</target>
        </trans-unit>
        <trans-unit id="cfaea70ee7364b7f2f10a028c48a9b68308aecdb" translate="yes" xml:space="preserve">
          <source>When -z option is not used, TAB, LF, and backslash characters in
  pathnames are represented as \t, \n, and \\, respectively.</source>
          <target state="translated">-z 옵션을 사용하지 않으면 경로 이름의 TAB, LF 및 백 슬래시 문자는 각각 \ t, \ n 및 \\로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d3840d4562480d2399ecf6afe2d819b1729baa" translate="yes" xml:space="preserve">
          <source>You'll also need to (temporarily) &lt;a href=&quot;https://stackoverflow.com/a/10544328/4901390&quot;&gt;allow non-fast-forward pushes to your repository&lt;/a&gt;, since you're changing your git history.</source>
          <target state="translated">git history를 변경하기 때문에 &lt;a href=&quot;https://stackoverflow.com/a/10544328/4901390&quot;&gt;저장소에 빨리 감기가 아닌 푸시&lt;/a&gt; 를 (일시적으로) 허용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ed971b2dd1c9a5b86271f2c62c00a985a6982cc2" translate="yes" xml:space="preserve">
          <source>Your repository is clean :)</source>
          <target state="translated">귀하의 저장소는 깨끗합니다 :)</target>
        </trans-unit>
        <trans-unit id="84cbaf0a5f2e76b1082a2ed9f1526561e8163981" translate="yes" xml:space="preserve">
          <source>breaking it down:</source>
          <target state="translated">그것을 분해 :</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="824c64b13bca2d2655a812f22946c1edd153a100" translate="yes" xml:space="preserve">
          <source>cope with this situation (get errors about files not found).</source>
          <target state="translated">이 상황에 대처하십시오 (파일을 찾을 수 없다는 오류가 발생합니다).</target>
        </trans-unit>
        <trans-unit id="e1f5dc1388efa7feb527c501975cbf1f88f8ed54" translate="yes" xml:space="preserve">
          <source>git config --global alias.exclude-ignored '!git ls-files -z --ignored --exclude-standard | xargs -0 git rm -r --cached &amp;amp;&amp;amp;  git ls-files -z --ignored --exclude-standard | xargs -0 git stage &amp;amp;&amp;amp;  git stage .gitignore &amp;amp;&amp;amp; git commit -m &quot;new gitignore and remove ignored files from index&quot;'</source>
          <target state="translated">git config --global alias.exclude-ignored '! git ls-files -z --ignored --exclude-standard | xargs -0 git rm -r-캐시 &amp;amp;&amp;amp; git ls-files -z --ignored --exclude-standard | xargs -0 git stage &amp;amp;&amp;amp; git stage .gitignore &amp;amp;&amp;amp; git commit -m &quot;새로운 gitignore 및 인덱스에서 무시 된 파일 제거&quot; '</target>
        </trans-unit>
        <trans-unit id="ef4d26678574a73b0e350a9a486783df032bc301" translate="yes" xml:space="preserve">
          <source>just replace &lt;code&gt;full/path/to/file&lt;/code&gt; with the full path of the file. Make sure you've added the file to your &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;full/path/to/file&lt;/code&gt; 을 파일 의 전체 경로로 바꾸십시오. 파일을 &lt;code&gt;.gitignore&lt;/code&gt; 에 추가했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d57cea54209eef1efd8a4421791d849849a82490" translate="yes" xml:space="preserve">
          <source>move it out, commit, then move it back in. This has worked for me in the past. There is probably a 'gittier' way to accomplish this.</source>
          <target state="translated">그것을 밖으로 옮기고, 저지른 다음 다시 안으로 옮기십시오. 이것은 과거에 저에게 효과적이었습니다. 이것을 달성하는 'gittier'방법이있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="305ae145517f107f30ff7601792a2642c8676b9b" translate="yes" xml:space="preserve">
          <source>remove ignored files from index</source>
          <target state="translated">색인에서 무시 된 파일 제거</target>
        </trans-unit>
        <trans-unit id="1ccf2fbbfa1279aaf960c3ec391069e720298640" translate="yes" xml:space="preserve">
          <source>so I think my solution is needed if filenames have any of these characters in them.</source>
          <target state="translated">파일 이름에 이러한 문자가 있으면 솔루션이 필요하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="478f9e84d9950a571b6e0c79abdf30102aa37957" translate="yes" xml:space="preserve">
          <source>stage .gitignore and the files you just removed</source>
          <target state="translated">스테이지 .gitignore 및 방금 제거한 파일</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
