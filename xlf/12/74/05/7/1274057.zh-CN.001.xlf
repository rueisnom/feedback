<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1274057">
    <body>
      <group id="1274057">
        <trans-unit id="1b1b1894ca2eb1b577deb9d1c135b98a8bea6403" translate="yes" xml:space="preserve">
          <source>(Under Linux), I wanted to use the posts here suggesting the &lt;code&gt;ls-files --ignored --exclude-standard | xargs git rm -r --cached&lt;/code&gt; approach.  However, (some of) the files to be removed had an embedded newline/LF/&lt;code&gt;\n&lt;/code&gt; in their names.  Neither of the solutions:</source>
          <target state="translated">（在Linux下），我想使用此处的帖子建议 &lt;code&gt;ls-files --ignored --exclude-standard | xargs git rm -r --cached&lt;/code&gt; xargs git rm -r-缓存方法。 但是，（某些）要删除的文件的名称中带有嵌入式换行符/ LF / &lt;code&gt;\n&lt;/code&gt; 。 两种解决方案都没有：</target>
        </trans-unit>
        <trans-unit id="e165ff5a12e79393f418cbab5ffb6044b4b14192" translate="yes" xml:space="preserve">
          <source>1. You want to untrack a lot of files, or</source>
          <target state="translated">1.你想解锁很多文件,或</target>
        </trans-unit>
        <trans-unit id="7291077bbcfea136ea78ae06fee8fb069775f45a" translate="yes" xml:space="preserve">
          <source>1.&lt;strong&gt;remove&lt;/strong&gt; the mistakenly added files &lt;strong&gt;from the directory/storage&lt;/strong&gt;. You can use &quot;rm -r&quot;(for linux) command or delete them by browsing the directories. Or move them to another location on your PC.[You maybe need to close the IDE if running for &lt;strong&gt;moving/removing&lt;/strong&gt;]</source>
          <target state="translated">1. &lt;strong&gt;从目录/存储中&lt;/strong&gt; &lt;strong&gt;删除&lt;/strong&gt;错误添加的文件。 您可以使用&amp;ldquo; rm -r&amp;rdquo;（对于linux）命令或通过浏览目录将其删除。 或将它们移动到PC上的另一个位置。[如果正在运行以进行&lt;strong&gt;移动/移动，&lt;/strong&gt;则可能需要关闭IDE]</target>
        </trans-unit>
        <trans-unit id="d29051284b7186e88c71b70107bdfe4f554cc6df" translate="yes" xml:space="preserve">
          <source>2. You updated your gitignore file</source>
          <target state="translated">2.2.你更新了你的gitignore文件</target>
        </trans-unit>
        <trans-unit id="3eee398533d29dfa830054675fbecc16f086d5fd" translate="yes" xml:space="preserve">
          <source>2.add the files / directories to &lt;code&gt;gitignore&lt;/code&gt; file now and save it.</source>
          <target state="translated">2.现在将文件/目录添加到 &lt;code&gt;gitignore&lt;/code&gt; 文件并保存。</target>
        </trans-unit>
        <trans-unit id="67d7bf6b04b2072f859546335ca89f354bd6d7ad" translate="yes" xml:space="preserve">
          <source>3.now &lt;strong&gt;remove&lt;/strong&gt; them from &lt;strong&gt;git cache&lt;/strong&gt; by using these commands (if there are more than one directory, remove them one by one by repeatedly issuing this command)</source>
          <target state="translated">3，现在使用这些命令&lt;strong&gt;将&lt;/strong&gt;它们从&lt;strong&gt;git cache中&lt;/strong&gt; &lt;strong&gt;删除&lt;/strong&gt; （如果目录不止一个，则通过重复发出此命令将它们一个一个地删除）</target>
        </trans-unit>
        <trans-unit id="3ea998bdf09e60d9d8abd1f7b841f09d1336d5a1" translate="yes" xml:space="preserve">
          <source>4.now &lt;strong&gt;do&lt;/strong&gt; a &lt;strong&gt;commit and push&lt;/strong&gt;, use these commands. This will &lt;em&gt;remove those files from git remote&lt;/em&gt; and make git &lt;em&gt;stop tracking&lt;/em&gt; those files.</source>
          <target state="translated">4.now &lt;strong&gt;执行&lt;/strong&gt; &lt;strong&gt;提交并推送&lt;/strong&gt; ，使用这些命令。 这&lt;em&gt;将从git remote删除那些文件&lt;/em&gt; ，并使git &lt;em&gt;停止跟踪&lt;/em&gt;那些文件。</target>
        </trans-unit>
        <trans-unit id="17ceece8d84cea60549ab352bf79b07ec65dbb55" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://fallengamer.livejournal.com/93321.html&quot;&gt;git assume-unchanged vs skip-worktree&lt;/a&gt;
 and &lt;a href=&quot;http://blog.stephan-partzsch.de/how-to-ignore-changes-in-tracked-files-with-git/&quot;&gt;How to ignore changes in tracked files with Git&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://fallengamer.livejournal.com/93321.html&quot;&gt;git假定未更改vs跳过工作树&lt;/a&gt;以及&lt;a href=&quot;http://blog.stephan-partzsch.de/how-to-ignore-changes-in-tracked-files-with-git/&quot;&gt;如何使用Git忽略跟踪文件中的更改&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78e15ae328e1a2411f65d28cc06b7824a162f954" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://git-scm.com/docs/git-rm&quot;&gt;rm&lt;/a&gt; is the remove command</source>
          <target state="translated">&lt;a href=&quot;https://git-scm.com/docs/git-rm&quot;&gt;rm&lt;/a&gt;是删除命令</target>
        </trans-unit>
        <trans-unit id="78fa9ca23f190aad15123aa1d43278ef66819081" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.gitignore&lt;/code&gt; will prevent untracked files from being added (without an &lt;code&gt;add -f&lt;/code&gt;) to the set of files tracked by git, however git will continue to track any files that are already being tracked.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; 将阻止将未跟踪的文件添加（不 &lt;code&gt;add -f&lt;/code&gt; ）到git跟踪的文件集中，但是git将继续跟踪已被跟踪的所有文件。</target>
        </trans-unit>
        <trans-unit id="b026808a99fb865ebb4e469dc20949169d8d3ebb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add .&lt;/code&gt; &amp;ndash; All files will be added back in, except those in &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git add .&lt;/code&gt; &amp;ndash;除了 &lt;code&gt;.gitignore&lt;/code&gt; 中的文件以外，所有文件都将重新添加。</target>
        </trans-unit>
        <trans-unit id="cefd39b5696f3a5f3d24162aa70995ec62aae245" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rm -r --cached .&lt;/code&gt; &amp;ndash; Remove all tracked files, including wanted and unwanted. Your code will be safe as long as you have saved locally.</source>
          <target state="translated">&lt;code&gt;git rm -r --cached .&lt;/code&gt; &amp;ndash;删除所有跟踪的文件，包括有用和不需要的文件。 只要您保存在本地，您的代码就将是安全的。</target>
        </trans-unit>
        <trans-unit id="83a9f5eece9214779a020dba22cb30bd64224718" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;ndash;cached&lt;/strong&gt; will only remove files from the index. Your files will still be there.</source>
          <target state="translated">&lt;strong&gt;&amp;ndash;cached&lt;/strong&gt;仅从索引中删除文件。 您的文件仍然在那里。</target>
        </trans-unit>
        <trans-unit id="9e0c75fb491e1244c9b2b4f6a21f09d08b9a34ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;-r&lt;/strong&gt; will allow recursive removal</source>
          <target state="translated">&lt;strong&gt;-r&lt;/strong&gt;将允许递归删除</target>
        </trans-unit>
        <trans-unit id="297d9ab2be574ee69d4645675e8640e0fd945953" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;First:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;First:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="77360b0eda618b65d4f5b9ac454d8549ce9b33ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This solution is actually independent on &lt;code&gt;.gitignore&lt;/code&gt; as gitignore is only for untracked files.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;该解决方案实际上独立于 &lt;code&gt;.gitignore&lt;/code&gt; ,因为gitignore仅适用于未跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="3c6108204e2f399b187def4c0bd951a6d5898341" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source link:&lt;/strong&gt;&lt;a href=&quot;http://www.codeblocq.com/2016/01/Untrack-files-already-added-to-git-repository-based-on-gitignore/&quot;&gt;http://www.codeblocq.com/2016/01/Untrack-files-already-added-to-git-repository-based-on-gitignore/&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;来源连结：&lt;/strong&gt; &lt;a href=&quot;http://www.codeblocq.com/2016/01/Untrack-files-already-added-to-git-repository-based-on-gitignore/&quot;&gt;http&lt;/a&gt; &lt;strong&gt;:&lt;/strong&gt; //www.codeblocq.com/2016/01/Untrack-files-already-add-to-git-repository-based-on-gitignore/</target>
        </trans-unit>
        <trans-unit id="eb20ad117f5ff375c73839d2b25fd98bfdfb7835" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Then:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Then:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bd7c18fe821283d0a4d492412ca53a9045e75db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is no longer an issue in the latest git&lt;/strong&gt; (v2.17.1 at the time of writing).</source>
          <target state="translated">&lt;strong&gt;在最新的git&lt;/strong&gt; （撰写本文时为v2.17.1）中， &lt;strong&gt;这不再是问题&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a6beca2c5a4d325c54a1e8c74ed539c6d15f6f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING: While this will not remove the physical file from your local, it will remove the files from other developers machines on next &lt;code&gt;git pull&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;警告：虽然这不会从本地删除物理文件，但会在下次 &lt;code&gt;git pull&lt;/code&gt; 上从其他开发人员的计算机删除文件。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df8624410ba32bf182a54a6f8f84d790e9343215" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;: this will delete the file from your entire history</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ：这将从您的整个历史记录中删除该文件</target>
        </trans-unit>
        <trans-unit id="1658da8ba77a3841c3a93544fd41a158b4742abf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;edit:&lt;/strong&gt; Since this answer was posted, a new option has been created and that should be prefered.  You should use &lt;strong&gt;&lt;code&gt;--skip-worktree&lt;/code&gt;&lt;/strong&gt; which is for modified tracked files that the user don't want to commit anymore and keep &lt;code&gt;--assume-unchanged&lt;/code&gt; for performance to prevent git to check status of big tracked files. See &lt;a href=&quot;https://stackoverflow.com/a/13631525/717372&quot;&gt;https://stackoverflow.com/a/13631525/717372&lt;/a&gt; for more details...</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;自从发布此答案以来，已经创建了一个新选项，应该优先使用。 您应该使用&lt;strong&gt; &lt;code&gt;--skip-worktree&lt;/code&gt; &lt;/strong&gt; ，用于用户不想再提交的已修改跟踪文件，并保持 &lt;code&gt;--assume-unchanged&lt;/code&gt; 的性能，以防止git检查大跟踪文件的状态。 有关更多详细信息，请参见&lt;a href=&quot;https://stackoverflow.com/a/13631525/717372&quot;&gt;https：//stackoverflow.com/a/13631525/717372&lt;/a&gt; ...</target>
        </trans-unit>
        <trans-unit id="21eb2ac0cdcc1bc65e7e9901f8bd153ae5987665" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;git update-index&lt;/strong&gt; does the job for me:</source>
          <target state="translated">&lt;strong&gt;git update-index&lt;/strong&gt;为我完成了这项工作：</target>
        </trans-unit>
        <trans-unit id="7b7d160b9ed59263729d1515ccfa762f8c20cadf" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt; Because &lt;code&gt;/.git/info/exclude&lt;/code&gt; can be applied to all historical commits using the instructions above, perhaps details about getting a &lt;code&gt;.gitignore&lt;/code&gt; file &lt;em&gt;into&lt;/em&gt; the historical commit(s) that need it is beyond the scope of this answer.  I wanted a proper &lt;code&gt;.gitignore&lt;/code&gt; to be in the root commit, as if it was the first thing I did.  Others may not care since &lt;code&gt;/.git/info/exclude&lt;/code&gt; can accomplish the same thing regardless where the &lt;code&gt;.gitignore&lt;/code&gt; exists in the commit history, and clearly re-writing history is a &lt;strong&gt;very&lt;/strong&gt; touchy subject, even when aware of the &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;ramifications&lt;/a&gt;.</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt;因为可以使用上述说明将 &lt;code&gt;/.git/info/exclude&lt;/code&gt; 应用于所有历史提交，所以有关将 &lt;code&gt;.gitignore&lt;/code&gt; 文件&lt;em&gt;放入需要&lt;/em&gt;的历史提交中的详细信息可能不在此答案的范围内。 我希望在root提交中使用适当的 &lt;code&gt;.gitignore&lt;/code&gt; ，好像这是我做的第一件事。 其他人可能不在乎，因为 &lt;code&gt;/.git/info/exclude&lt;/code&gt; 可以完成相同的操作，而不管提交历史记录中的 &lt;code&gt;.gitignore&lt;/code&gt; 存在什么地方，并且即使重写了，显然重写历史也是&lt;strong&gt;非常&lt;/strong&gt;敏感的主题。</target>
        </trans-unit>
        <trans-unit id="8b6da13045058d13d3e3a649a46432a4e053b78f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt; Enforcing git ignore behavior after-the-fact by committing the results of a standalone &lt;code&gt;git rm --cached&lt;/code&gt; command may result in newly-ignored file &lt;strong&gt;deletion&lt;/strong&gt; in future pulls from the force-pushed remote. The &lt;code&gt;--prune-empty&lt;/code&gt; flag in the following &lt;code&gt;git filter-branch&lt;/code&gt; command avoids this problem by automatically removing the previous &quot;delete all ignored files&quot; index-only commit.  Re-writing git history also changes commit hashes, which will &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;wreak havoc&lt;/a&gt; on future pulls from public/shared/collaborative repos.  Please understand the &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;ramifications&lt;/a&gt; fully before doing this to such a repo. &lt;a href=&quot;https://help.github.com/en/articles/removing-sensitive-data-from-a-repository&quot;&gt;This GitHub guide&lt;/a&gt; specifies the following:</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt;通过提交独立的 &lt;code&gt;git rm --cached&lt;/code&gt; 命令的结果来强制执行git事后忽略行为，这可能会导致在将来从强制推送的远程操作中&lt;strong&gt;删除&lt;/strong&gt;新忽略的文件。 以下 &lt;code&gt;git filter-branch&lt;/code&gt; 命令中的 &lt;code&gt;--prune-empty&lt;/code&gt; 标志通过自动删除以前的&amp;ldquo;删除所有被忽略的文件&amp;rdquo;仅索引提交来避免此问题。 重写git历史记录也会更改提交哈希，这将对将来来自公共/共享/协作存储库的请求&lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;造成严重破坏&lt;/a&gt; 。 在执行此&lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;仓库&lt;/a&gt;之前，请充分了解其后果 。 &lt;a href=&quot;https://help.github.com/en/articles/removing-sensitive-data-from-a-repository&quot;&gt;该GitHub指南&lt;/a&gt;指定了以下内容：</target>
        </trans-unit>
        <trans-unit id="35bcd509556e93a5b4f240c0aaa275f71d83fd11" translate="yes" xml:space="preserve">
          <source>All methods of enforcing git ignore behavior after-the-fact effectively re-write history and thus have &lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;significant ramifications&lt;/a&gt; for any public/shared/collaborative repos that might be pulled after this process. &lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">所有强制执行git的方法都会在事后忽略行为，从而有效地重写了历史记录，因此对于在此过程之后可能被拉出的任何公共/共享/协作存储库都有&lt;a href=&quot;https://stackoverflow.com/q/1491001&quot;&gt;明显的影响&lt;/a&gt; 。 &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7e9e185f8553a03fd2bb4775718d5197931af7f1" translate="yes" xml:space="preserve">
          <source>Also, the comments/&lt;a href=&quot;https://stackoverflow.com/posts/57454176/revisions&quot;&gt;revision history&lt;/a&gt; of &lt;a href=&quot;https://stackoverflow.com/a/57454176&quot;&gt;this answer&lt;/a&gt; (&lt;a href=&quot;https://stackoverflow.com/posts/57418769/revisions&quot;&gt;and revision history&lt;/a&gt; of &lt;a href=&quot;https://stackoverflow.com/posts/57418769&quot;&gt;this question&lt;/a&gt;) may be useful/enlightening.</source>
          <target state="translated">另外， &lt;a href=&quot;https://stackoverflow.com/a/57454176&quot;&gt;此答案&lt;/a&gt;的评论/ &lt;a href=&quot;https://stackoverflow.com/posts/57454176/revisions&quot;&gt;修订历史记录&lt;/a&gt; （ &lt;a href=&quot;https://stackoverflow.com/posts/57418769/revisions&quot;&gt;以及&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/posts/57418769&quot;&gt;该问题的&lt;/a&gt; 修订历史记录 ）可能很有用/很有启发性。</target>
        </trans-unit>
        <trans-unit id="f1837dc932cb205db53c46200c2d6db222867832" translate="yes" xml:space="preserve">
          <source>Alternative solutions that &lt;strong&gt;do not&lt;/strong&gt; affect the remote repo are &lt;code&gt;git update-index --assume-unchanged &amp;lt;/path/file&amp;gt;&lt;/code&gt; or &lt;code&gt;git update-index --skip-worktree &amp;lt;file&amp;gt;&lt;/code&gt;, examples of which can be found &lt;a href=&quot;https://stackoverflow.com/a/20241145&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;不&lt;/strong&gt;影响远程 &lt;code&gt;git update-index --assume-unchanged &amp;lt;/path/file&amp;gt;&lt;/code&gt; 替代解决方案是git update-index --assume-unchanged &amp;lt;/ path / file&amp;gt;或 &lt;code&gt;git update-index --skip-worktree &amp;lt;file&amp;gt;&lt;/code&gt; ，可以在&lt;a href=&quot;https://stackoverflow.com/a/20241145&quot;&gt;此处&lt;/a&gt;找到示例。</target>
        </trans-unit>
        <trans-unit id="6a41eb1605b5c4997fa5c53a67b3bccfeac6b535" translate="yes" xml:space="preserve">
          <source>Anti-recommentation: Don't use assume-unchanged, it will only end in tears (because having git lie to itself will cause bad things to happen, like your change being lost forever).</source>
          <target state="translated">反修正。不要使用assume-unchanged,这样只会以泪洗面(因为让git对自己说谎会导致不好的事情发生,比如你的改变永远失去了)。</target>
        </trans-unit>
        <trans-unit id="d67fefbf8e2fd8148f6312fb95b34f9b6c28c3ac" translate="yes" xml:space="preserve">
          <source>Basing on it I do the following, if file is already tracked:</source>
          <target state="translated">在此基础上,如果文件已经被跟踪,我就会做如下操作。</target>
        </trans-unit>
        <trans-unit id="ee0e2ab0d04aa5d054177f7139fe2f2993169040" translate="yes" xml:space="preserve">
          <source>Before proceeding, make sure all your changes are committed, including your .gitignore file.</source>
          <target state="translated">在继续进行之前,请确保你的所有修改都已提交,包括你的.gitignore文件。</target>
        </trans-unit>
        <trans-unit id="202ec7e461ae2d976889f5c200423159e33e4cff" translate="yes" xml:space="preserve">
          <source>But in Git every time you commit, or save the state of your project, it basically takes a picture of what &lt;strong&gt;&lt;em&gt;all your files&lt;/em&gt;&lt;/strong&gt; look like at that moment and stores a reference to that snapshot. So, if you added file once, it will always be present  in that snapshot.</source>
          <target state="translated">但是，每次您提交或保存项目状态时，在Git中，它基本上都会拍下当时&lt;strong&gt;&lt;em&gt;所有文件的&lt;/em&gt;&lt;/strong&gt;样子，并存储对该快照的引用。 因此，如果一次添加文件，该文件将始终存在于该快照中。</target>
        </trans-unit>
        <trans-unit id="34982d9388d501a1c59663bb20321f9e535e5325" translate="yes" xml:space="preserve">
          <source>Commit file config-sample.ini and ignore file config.ini, have a script or similar copy the file as necessary if necessary.</source>
          <target state="translated">提交文件config-sample.ini,而忽略文件config.ini,必要时可以用脚本或类似的方法复制该文件。</target>
        </trans-unit>
        <trans-unit id="5e69dfeea1ca71ec5cba8ba3812cefb3dde8a6d7" translate="yes" xml:space="preserve">
          <source>Do the following steps serially,you will be fine.</source>
          <target state="translated">按以下步骤连续进行,就可以了。</target>
        </trans-unit>
        <trans-unit id="7efbf048e80845e59aa478983b3f909934d4ee15" translate="yes" xml:space="preserve">
          <source>Doing this went into each folder under the 'root' of where I was at and excluded all files that matched the pattern.</source>
          <target state="translated">这样做会进入每个文件夹下的 &quot;根目录&quot;,并排除所有与模式匹配的文件。</target>
        </trans-unit>
        <trans-unit id="ce417ee80599859b918672e3deab176250d6a6fa" translate="yes" xml:space="preserve">
          <source>Especially for the IDE based files, I use this:</source>
          <target state="translated">尤其是基于IDE的文件,我用的是这个。</target>
        </trans-unit>
        <trans-unit id="5f23cb20c4075e9581d1185b5b7df71903a476f7" translate="yes" xml:space="preserve">
          <source>FWIW, potential methods may include &lt;code&gt;git rebase&lt;/code&gt; or a &lt;code&gt;git filter-branch&lt;/code&gt; that copies an &lt;em&gt;external&lt;/em&gt;&lt;code&gt;.gitignore&lt;/code&gt; into each commit, like the answers to &lt;a href=&quot;https://stackoverflow.com/q/43463687&quot;&gt;this question&lt;/a&gt;</source>
          <target state="translated">FWIW，可能的方法可能包括 &lt;code&gt;git rebase&lt;/code&gt; 或 &lt;code&gt;git filter-branch&lt;/code&gt; ，它将一个&lt;em&gt;外部&lt;/em&gt; &lt;code&gt;.gitignore&lt;/code&gt; 复制到每个提交中，例如&lt;a href=&quot;https://stackoverflow.com/q/43463687&quot;&gt;该问题&lt;/a&gt;的答案</target>
        </trans-unit>
        <trans-unit id="f9934c535834db75b1af736d96add4343490deca" translate="yes" xml:space="preserve">
          <source>File content will be replaced by the remote content. Paste your changes from safe place to file and perform again:</source>
          <target state="translated">文件内容将被远程内容所取代。把你的修改从安全的地方粘贴到文件中,再执行一次。</target>
        </trans-unit>
        <trans-unit id="fbe38db5f25e43c80761fee281d19a80da24dfe5" translate="yes" xml:space="preserve">
          <source>Finally, follow the rest of &lt;a href=&quot;https://help.github.com/en/articles/removing-sensitive-data-from-a-repository&quot;&gt;this GitHub guide&lt;/a&gt; (starting at step 6) &lt;strong&gt;which includes important warnings/information about the commands below&lt;/strong&gt;.</source>
          <target state="translated">最后，遵循&lt;a href=&quot;https://help.github.com/en/articles/removing-sensitive-data-from-a-repository&quot;&gt;本GitHub指南&lt;/a&gt;的其余部分（从第6步开始） &lt;strong&gt;，其中包括有关以下命令的重要警告/信息&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ba0b957e82e6fe3a824c66fd56f4787439fab3c" translate="yes" xml:space="preserve">
          <source>Finally, make a commit!</source>
          <target state="translated">终于承诺了!</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="3377231d1621da920e2f6d01f618d62a65db90db" translate="yes" xml:space="preserve">
          <source>For instance the slnx.sqlite, I just got rid off it completely like following:</source>
          <target state="translated">比如说slnx.sqlite,我只是把它完全去掉了,就像下面这样。</target>
        </trans-unit>
        <trans-unit id="3bc29b2292be0b2cd02509d2f723c4a7e560576e" translate="yes" xml:space="preserve">
          <source>From this moment all local changes in this file will be ignored and will not go to remote. If file is changed on remote, conflict will occure, when &lt;code&gt;git pull&lt;/code&gt;. Stash won't work. To resolve it, &lt;em&gt;copy file content to the safe place&lt;/em&gt; and follow these steps:</source>
          <target state="translated">从这一刻起，此文件中的所有本地更改将被忽略，并且不会转到远程。 如果在远程更改文件，则在 &lt;code&gt;git pull&lt;/code&gt; 时会发生冲突。 藏匿将无法正常工作。 要解决此问题， &lt;em&gt;请将文件内容复制到安全的地方，&lt;/em&gt;然后执行以下步骤：</target>
        </trans-unit>
        <trans-unit id="fbab929a9779a2ee3e87320c92fff544c9f8051f" translate="yes" xml:space="preserve">
          <source>General advice: &lt;strong&gt;start with a clean repo&lt;/strong&gt; - everything committed, nothing pending in working directory or index, &lt;strong&gt;and make a backup&lt;/strong&gt;!</source>
          <target state="translated">一般建议： &lt;strong&gt;从干净的仓库开始&lt;/strong&gt; -提交的所有东西，在工作目录或索引中没有任何未决的东西， &lt;strong&gt;然后进行备份&lt;/strong&gt; ！</target>
        </trans-unit>
        <trans-unit id="383228a7a69a177f4167123e5eea04fe6397b184" translate="yes" xml:space="preserve">
          <source>Hat tip to @AkiraYamamoto for pointing us in the right direction.</source>
          <target state="translated">感谢@AkiraYamamoto为我们指明了正确的方向。</target>
        </trans-unit>
        <trans-unit id="566e08627539a7d2ecb5033b1abbdc58839c476c" translate="yes" xml:space="preserve">
          <source>Have your application look for an ignored file config-overide.ini and use that over the committed file config.ini (or alternately, look for ~/.config/myapp.ini, or $MYCONFIGFILE)</source>
          <target state="translated">让你的应用程序寻找一个被忽略的文件config-overide.ini,并在已提交的文件config.ini上使用该文件(或者寻找~.configmyapp.ini,或$MYCONFIGFILE)。</target>
        </trans-unit>
        <trans-unit id="5bf6447b60376b1563849f40943b48a5d87e3cf8" translate="yes" xml:space="preserve">
          <source>Hope this helps others!</source>
          <target state="translated">希望这对别人有帮助!</target>
        </trans-unit>
        <trans-unit id="a1f359c689bb3b599c937d2b3bde4bbcb5336415" translate="yes" xml:space="preserve">
          <source>How do you force &lt;code&gt;git&lt;/code&gt; to completely forget about [a file]?</source>
          <target state="translated">您如何迫使 &lt;code&gt;git&lt;/code&gt; 完全忘记[文件]？</target>
        </trans-unit>
        <trans-unit id="3f4c43dc61508984fa8447acacd10ea274b878cc" translate="yes" xml:space="preserve">
          <source>How to make Git “forget” about a file that was tracked but is now in .gitignore</source>
          <target state="translated">如何让Git &quot;忘记 &quot;一个被跟踪但现在在.gitignore中的文件?</target>
        </trans-unit>
        <trans-unit id="ffb3146d4b977e8077d09a9c235b576b6fb6a3df" translate="yes" xml:space="preserve">
          <source>However, that file keeps showing up in &lt;code&gt;git status&lt;/code&gt; after it's edited. How do you force &lt;code&gt;git&lt;/code&gt; to completely forget about it?</source>
          <target state="translated">但是，该文件在编辑后一直以 &lt;code&gt;git status&lt;/code&gt; 显示。 您如何迫使 &lt;code&gt;git&lt;/code&gt; 完全忘记它？</target>
        </trans-unit>
        <trans-unit id="3da73f13e2ca68488453d76581d10690fca48b23" translate="yes" xml:space="preserve">
          <source>I accomplished this by using &lt;a href=&quot;http://git-scm.com/docs/git-filter-branch&quot;&gt;git filter-branch&lt;/a&gt;. The exact command I used was taken from the man page:</source>
          <target state="translated">我通过使用&lt;a href=&quot;http://git-scm.com/docs/git-filter-branch&quot;&gt;git filter-branch&lt;/a&gt;实现了这一点。 我使用的确切命令来自手册页：</target>
        </trans-unit>
        <trans-unit id="e3d824cfebc37780973279c6ef69aebdc266297a" translate="yes" xml:space="preserve">
          <source>I always use this command to remove those untracked files. 
One-line, Unix-style, clean output:</source>
          <target state="translated">我总是用这个命令来删除那些未被跟踪的文件。单行,Unix风格的,干净的输出。</target>
        </trans-unit>
        <trans-unit id="30df5b0bdab26d64e3f314c5f82d939e368718be" translate="yes" xml:space="preserve">
          <source>I liked JonBrave's answer but I have messy enough working directories that commit -a scares me a bit, so here's what I've done:</source>
          <target state="translated">我喜欢JonBrave的回答,但我的工作目录已经够乱了,提交-a让我有点害怕,所以我是这么做的。</target>
        </trans-unit>
        <trans-unit id="ae997b72f572c164f9db73d00da169b807fa2145" translate="yes" xml:space="preserve">
          <source>I recommend reading the documentation, but basically:</source>
          <target state="translated">我建议大家看一下文档,但基本上。</target>
        </trans-unit>
        <trans-unit id="298daaa4a77ce41f5637f4872a4f45b4106bf606" translate="yes" xml:space="preserve">
          <source>I think, that maybe git can't totally forget about file because of its conception (&lt;a href=&quot;https://git-scm.com/book/en/v2/Getting-Started-Git-Basics&quot;&gt;section &quot;Snapshots, Not Differences&quot;&lt;/a&gt;).</source>
          <target state="translated">我认为，也许git不能完全忽略文件，因为它的概念（ &lt;a href=&quot;https://git-scm.com/book/en/v2/Getting-Started-Git-Basics&quot;&gt;&amp;ldquo;快照，&lt;/a&gt;不尽相同&amp;rdquo;一节 ）。</target>
        </trans-unit>
        <trans-unit id="39a2708982ad9e80eba23666c91b4ae5bdb874e7" translate="yes" xml:space="preserve">
          <source>If anyone having hard time on Windows and you wanna ignore entire folder, 'cd' to desired the 'folder' and do 'Git Bash Here'.</source>
          <target state="translated">如果有人在Windows系统中遇到困难,想忽略整个文件夹,可以'cd'到想要的'文件夹',然后在这里做'Git Bash'。</target>
        </trans-unit>
        <trans-unit id="0e021844325108de6923cd018135a48813b2d1b1" translate="yes" xml:space="preserve">
          <source>If everyone, who works with project, will perform &lt;code&gt;git update-index --skip-worktree &amp;lt;file&amp;gt;&lt;/code&gt;, problems with &lt;code&gt;pull&lt;/code&gt; should be absent. This solution is OK for configurations files, when every developer has their own project configuration.</source>
          <target state="translated">如果每个与项目一起工作的人都将执行 &lt;code&gt;git update-index --skip-worktree &amp;lt;file&amp;gt;&lt;/code&gt; ，则应该没有关于 &lt;code&gt;pull&lt;/code&gt; 的问题。 当每个开发人员都有自己的项目配置时，此解决方案适用于配置文件。</target>
        </trans-unit>
        <trans-unit id="25e96f5e32b3e98d46d6a3c82c2a38e2f06e1122" translate="yes" xml:space="preserve">
          <source>If you cannot &lt;code&gt;git rm&lt;/code&gt; a tracked file because other people might need it (warning, even if &lt;em&gt;you&lt;/em&gt;&lt;code&gt;git rm --cached&lt;/code&gt;, when someone else gets this change, their files will be deleted in their filesystem).  These are often done due to config file overrides, authentication credentials, etc. Please look at &lt;a href=&quot;https://gist.github.com/1423106&quot;&gt;https://gist.github.com/1423106&lt;/a&gt; for ways people have worked around the problem.</source>
          <target state="translated">如果由于其他人可能需要而无法 &lt;code&gt;git rm&lt;/code&gt; 跟踪的文件（警告，即使&lt;em&gt;您&lt;/em&gt; &lt;code&gt;git rm --cached&lt;/code&gt; ，当其他人获得此更改时，其文件也会在其文件系统中删除）。 这些通常是由于配置文件覆盖，身份验证凭据等导致的。请查看&lt;a href=&quot;https://gist.github.com/1423106&quot;&gt;https://gist.github.com/1423106，&lt;/a&gt;了解人们如何解决此问题。</target>
        </trans-unit>
        <trans-unit id="9143aec05a9d0455022a9d3efa538b3f3f9385bc" translate="yes" xml:space="preserve">
          <source>If you don't want to use the CLI and are working on Windows, a very simple solution is to use &lt;a href=&quot;https://tortoisegit.org/&quot;&gt;TortoiseGit&lt;/a&gt;, it has the &quot;Delete (keep local)&quot; Action in the menu which works fine.</source>
          <target state="translated">如果您不想使用CLI并在Windows上运行，则非常简单的解决方案是使用&lt;a href=&quot;https://tortoisegit.org/&quot;&gt;TortoiseGit&lt;/a&gt; ，它在菜单中具有&amp;ldquo;删除（保持本地）&amp;rdquo;操作，效果很好。</target>
        </trans-unit>
        <trans-unit id="0d71f20100d6c8cc8bd6973525e16dd6ba961dbd" translate="yes" xml:space="preserve">
          <source>If you want to remove a whole folder, you need to remove all files in it recursively.</source>
          <target state="translated">如果你想删除整个文件夹,你需要递归删除其中的所有文件。</target>
        </trans-unit>
        <trans-unit id="15d61d53688648e59ae0d7cc465a1adfc9f32e65" translate="yes" xml:space="preserve">
          <source>If you'd like to specify files by name, you can do that too:</source>
          <target state="translated">如果你想用名字来指定文件,也可以这样做。</target>
        </trans-unit>
        <trans-unit id="5903c3f8465c60a50db152209be8cfcd2f531ee6" translate="yes" xml:space="preserve">
          <source>Ignore them by:</source>
          <target state="translated">不理睬他们由。</target>
        </trans-unit>
        <trans-unit id="6909856450b8468ce19ecf4aa7c57653169fd9a9" translate="yes" xml:space="preserve">
          <source>In case of already committed &lt;code&gt;DS_Store&lt;/code&gt;:</source>
          <target state="translated">如果已经提交 &lt;code&gt;DS_Store&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cb61bbad89d4ac5b475150e04f8ff4d53d867cc4" translate="yes" xml:space="preserve">
          <source>In fact, this solution will cause the file to be &lt;strong&gt;deleted&lt;/strong&gt; in every other instance of the repository when executing a &lt;code&gt;git pull&lt;/code&gt;!</source>
          <target state="translated">实际上，此解决方案将导致在执行 &lt;code&gt;git pull&lt;/code&gt; ！时在存储库的其他每个实例中&lt;strong&gt;删除&lt;/strong&gt;文件。</target>
        </trans-unit>
        <trans-unit id="b6281cb7098a9a1bf8ab74eea9cf623585f3557d" translate="yes" xml:space="preserve">
          <source>In my case here, I had several .lock files in several directories that I needed to remove. I ran the following and it worked without having to go into each directory to remove them:</source>
          <target state="translated">在我这里,我有几个目录中的.lock文件需要删除。我运行了下面的程序,不需要进入每个目录就可以删除它们。</target>
        </trans-unit>
        <trans-unit id="f2ee46b5bf348489144ff43d13bb1f9db4b9e4cc" translate="yes" xml:space="preserve">
          <source>In the manual page &lt;strong&gt;git-ls-files(1)&lt;/strong&gt;, it states:</source>
          <target state="translated">在手册页&lt;strong&gt;git-ls-files（1）中&lt;/strong&gt; ，它指出：</target>
        </trans-unit>
        <trans-unit id="1e3a8ac2b04f693dce99c91c6d013b19a784ceac" translate="yes" xml:space="preserve">
          <source>It is not very convenient to do this every time, when file has been changed on remote, but can protect it from overwriting by remote content.</source>
          <target state="translated">每次都这样做,在远程修改文件的时候,不是很方便,但是可以保护它不被远程内容覆盖。</target>
        </trans-unit>
        <trans-unit id="7da0a30820d35bda263d21ef6c921be754b4fb2b" translate="yes" xml:space="preserve">
          <source>It lists all your ignored files, replace every output line with a quoted line instead to handle paths with spaces inside, and pass everything to &lt;code&gt;git rm -r --cached&lt;/code&gt; to remove the paths/files/dirs from the index.</source>
          <target state="translated">它列出了所有被忽略的文件，将每条输出行替换为带引号的行，以处理内部带有空格的路径，并将所有内容传递给 &lt;code&gt;git rm -r --cached&lt;/code&gt; 从索引中删除路径/文件/目录。</target>
        </trans-unit>
        <trans-unit id="427dd941220a11cde80854cae040581bf7a7bc39" translate="yes" xml:space="preserve">
          <source>Just keep that in mind that some of those files stores some local user settings and preferences for projects (like what files you had open). So every time you navigate or do some changes in your IDE, that file is changed and therefore it checks it out and show as there are uncommitted changes.</source>
          <target state="translated">只要记住,这些文件中的一些文件会存储一些本地用户设置和项目的偏好(比如你打开了哪些文件)。因此,每次你在IDE中导航或做一些更改时,那个文件都会被更改,因此它会把它检查出来,并显示为有未提交的更改。</target>
        </trans-unit>
        <trans-unit id="1e1f9446808bef2a81577b3811952c9be0140995" translate="yes" xml:space="preserve">
          <source>Keep the config file on a deploy branch dedicated to it that is never merged to master.  When you want to deploy/compile/test you merge to that branch and get that file.  This is essentially the smudge/clean approach except using human merge policies and extra-git modules.</source>
          <target state="translated">将配置文件保存在一个专门的部署分支上,这个分支永远不会合并到master。当你想部署compiletest时,你就合并到那个分支,然后得到那个文件。这本质上就是smudgeclean方法,除了使用了人为的合并策略和额外的git模块。</target>
        </trans-unit>
        <trans-unit id="6b5335338767809a90c12fd0a6cc98271bc8581c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have already added/committed some files to your git repository and you then add them to your .gitignore; these files will still be present in your repository index. This article we will see how to get rid of them.</source>
          <target state="translated">假设您已经向git仓库添加/提交了一些文件，然后将它们添加到.gitignore;中。 这些文件仍将存在于您的存储库索引中。 本文我们将看到如何摆脱它们。</target>
        </trans-unit>
        <trans-unit id="3d06145c701eb9f7bcded9868ffbb9cfbfbf4af3" translate="yes" xml:space="preserve">
          <source>Move or copy the file to a safe location, so you don't lose it. Then git rm the file and commit. The file will still show up if you revert to one of those earlier commits, or another branch where it has not been removed. However, in all future commits, you will not see the file again. If the file is in the git ignore, then you can move it back into the folder, and git won't see it.</source>
          <target state="translated">将文件移动或复制到安全的地方,以免丢失。然后 git rm 文件并提交。如果你恢复到之前的提交中的某个提交,或者是另一个没有被删除的分支,这个文件仍然会显示出来。但是,在以后的所有提交中,你将不会再看到这个文件。如果该文件在 git ignore 中,那么你可以将其移回该文件夹,而 git 不会看到它。</target>
        </trans-unit>
        <trans-unit id="b531fabd41eb9da9a0ba874d765d34f24cb5c8b2" translate="yes" xml:space="preserve">
          <source>Or one-liner:</source>
          <target state="translated">或者说是单行本。</target>
        </trans-unit>
        <trans-unit id="41da50eece3db9d79a767edff75028a53b36f061" translate="yes" xml:space="preserve">
          <source>Other devs that pull from now-modified remote repo should make a backup and then:</source>
          <target state="translated">其他从现在修改过的远程repo中拉取的开发者应该做一个备份,然后。</target>
        </trans-unit>
        <trans-unit id="b54a2d9b41681e32ea54dbeeffc97236f62a7a92" translate="yes" xml:space="preserve">
          <source>Push the changes to your remote to see the changes effective there as well.</source>
          <target state="translated">将更改推送到您的远程,查看更改也有效。</target>
        </trans-unit>
        <trans-unit id="d5809414f5464acab9aa7ba79e8f76e8e3a3a51a" translate="yes" xml:space="preserve">
          <source>So I offer</source>
          <target state="translated">所以,我提供</target>
        </trans-unit>
        <trans-unit id="960fb31d4493678100902bc9586b9c046362e226" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://confluence.atlassian.com/bitbucket/reduce-repository-size-321848262.html&quot;&gt;https://confluence.atlassian.com/bitbucket/reduce-repository-size-321848262.html&lt;/a&gt;</source>
          <target state="translated">资料来源： &lt;a href=&quot;https://confluence.atlassian.com/bitbucket/reduce-repository-size-321848262.html&quot;&gt;https&lt;/a&gt; : //confluence.atlassian.com/bitbucket/reduce-repository-size-321848262.html</target>
        </trans-unit>
        <trans-unit id="612e5a5b717eb6a345fff1875325e4e780814272" translate="yes" xml:space="preserve">
          <source>Step 1: Commit all your changes</source>
          <target state="translated">步骤1:承诺你所有的更改</target>
        </trans-unit>
        <trans-unit id="77880434b84506c14708316521c7f71b103ddbdc" translate="yes" xml:space="preserve">
          <source>Step 2: Remove everything from the repository</source>
          <target state="translated">第二步:从存储库中删除所有内容</target>
        </trans-unit>
        <trans-unit id="9c2ed963345aea24138333def583839f931c4674" translate="yes" xml:space="preserve">
          <source>Step 3: Re add everything</source>
          <target state="translated">第三步:重新添加一切</target>
        </trans-unit>
        <trans-unit id="1a2dff51a26bbc76eec72ab492cccbb8f3c8089b" translate="yes" xml:space="preserve">
          <source>Step 4: Commit</source>
          <target state="translated">第四步:承诺</target>
        </trans-unit>
        <trans-unit id="62e557118db016748e85b8aff058461061ff972e" translate="yes" xml:space="preserve">
          <source>Tell your collaborators to &lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Rebasing&quot;&gt;rebase&lt;/a&gt;, &lt;em&gt;not&lt;/em&gt; merge, any branches they created off of your old (tainted) repository history. One merge commit could reintroduce some or all of the tainted history that you just went to the trouble of purging.</source>
          <target state="translated">告诉您的协作者根据旧的（受污染的）存储库历史记录对他们创建的任何分支进行基础设置， &lt;em&gt;而不是&lt;/em&gt;合并。 一次合并提交可能会重新引入您刚刚遇到清除麻烦的部分或全部历史记录。</target>
        </trans-unit>
        <trans-unit id="0507b4cf9226f930b3c47ada0f53498a6301526a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/&quot;&gt;BFG&lt;/a&gt; is specifically designed for removing unwanted data like big files or passwords from Git repos, so it has a simple flag that will remove any large historical (not-in-your-current-commit) files: '--strip-blobs-bigger-than'</source>
          <target state="translated">&lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/&quot;&gt;BFG&lt;/a&gt;是专门为从Git存储库中删除不需要的数据（例如大文件或密码）而设计的，因此它具有一个简单的标志，可以删除任何大的历史（不在您当前提交的文件）文件：'--strip-blobs-大于</target>
        </trans-unit>
        <trans-unit id="cf74012f43e3173d4f2f3a304c076743addefd4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitignore&lt;/code&gt; finally ignores tracked-but-deleted files. You can test this for yourself by running the following script. The final &lt;code&gt;git status&lt;/code&gt; statement should report &quot;nothing to commit&quot;.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; 最终会忽略跟踪但已删除的文件。 您可以通过运行以下脚本自行测试。 最终的 &lt;code&gt;git status&lt;/code&gt; 语句应报告&amp;ldquo;没有要提交的内容&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="18bd883e64a162aac02dba83baaf242c9aba9d6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rm&lt;/code&gt; command can be unforgiving. If you wish to try what it does beforehand, add the &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--dry-run&lt;/code&gt; flag to test things out.</source>
          <target state="translated">&lt;code&gt;rm&lt;/code&gt; 命令可能无法原谅。 如果您想事先尝试它的功能，请添加 &lt;code&gt;-n&lt;/code&gt; 或 &lt;code&gt;--dry-run&lt;/code&gt; 标志以进行测试。</target>
        </trans-unit>
        <trans-unit id="e219646ce5997a53b1eec4fddf7d5da98274f8a7" translate="yes" xml:space="preserve">
          <source>The BFG is 10-1000x faster than git filter-branch, and generally much easier to use - check the &lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/#usage&quot;&gt;full usage instructions&lt;/a&gt; and &lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/#examples&quot;&gt;examples&lt;/a&gt; for more details.</source>
          <target state="translated">BFG比git filter-branch快10-1000倍，并且通常更容易使用-请查看&lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/#usage&quot;&gt;完整的使用说明&lt;/a&gt;和&lt;a href=&quot;https://rtyley.github.io/bfg-repo-cleaner/#examples&quot;&gt;示例&lt;/a&gt;以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="4e1d1bc82d1b78eb89712cf8828bb7c8cc774d0a" translate="yes" xml:space="preserve">
          <source>The accepted answer does not &quot;make Git &lt;strong&gt;&quot;forget&quot;&lt;/strong&gt; about a file...&quot; (historically).  It only makes git &lt;strong&gt;ignore&lt;/strong&gt; the file in the present/future.</source>
          <target state="translated">接受的答案不会&amp;ldquo;使Git &lt;strong&gt;忘记&lt;/strong&gt;文件...&amp;rdquo;（历史上）。 它只会使git &lt;strong&gt;忽略&lt;/strong&gt;当前/将来的文件。</target>
        </trans-unit>
        <trans-unit id="bd8f4258fd7f17f2cbd6e097a5da666229f8a59c" translate="yes" xml:space="preserve">
          <source>The answer from Matt Fear was the most effective IMHO. The following is just a PowerShell script for those in windows to only remove files from their git repo that matches their exclusion list.</source>
          <target state="translated">Matt Fear 提供的答案是最有效的,IMHO。以下只是一个PowerShell脚本,用于windows下的人只从他们的git repo中删除符合排除列表的文件。</target>
        </trans-unit>
        <trans-unit id="67e52d337d22c9b5bfb6014db3c396cfda77accb" translate="yes" xml:space="preserve">
          <source>The copy/paste answer is &lt;code&gt;git rm --cached -r .; git add .; git status&lt;/code&gt;</source>
          <target state="translated">复制/粘贴答案是 &lt;code&gt;git rm --cached -r .; git add .; git status&lt;/code&gt; git add。; git状态</target>
        </trans-unit>
        <trans-unit id="78a25064d23dc897dd87d00c940f9b4e4c4ffb99" translate="yes" xml:space="preserve">
          <source>The correct way to force git to forget about a file is documented by GitHub &lt;a href=&quot;https://help.github.com/en/articles/removing-sensitive-data-from-a-repository&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">GitHub记录了迫使git忘记文件的正确方法。</target>
        </trans-unit>
        <trans-unit id="e7351c780e287a42a26ece70eefbcf456f1046dd" translate="yes" xml:space="preserve">
          <source>The removal of the file from the head revision will happen on the next commit.</source>
          <target state="translated">在下一次提交时,将从头部修改中删除文件。</target>
        </trans-unit>
        <trans-unit id="aef3fa74c8e59e395be7f68fe29a155144721883" translate="yes" xml:space="preserve">
          <source>The series of commands below will remove all of the items from the Git Index (not from the working directory or local repo), and then updates the Git Index, while respecting git ignores. &lt;em&gt;PS. Index = Cache&lt;/em&gt;</source>
          <target state="translated">下面的一系列命令将从Git索引中删除所有项（而不是从工作目录或本地存储库中删除），然后更新Git索引，同时注意git忽略。 &lt;em&gt;PS。&lt;/em&gt; &lt;em&gt;索引=缓存&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="059b6a3f58c111d094d712b8584163f9e7b63336" translate="yes" xml:space="preserve">
          <source>There is a file that was being tracked by &lt;code&gt;git&lt;/code&gt;, but now the file is on the &lt;code&gt;.gitignore&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 正在跟踪一个文件，但是现在该文件在 &lt;code&gt;.gitignore&lt;/code&gt; 列表中。</target>
        </trans-unit>
        <trans-unit id="99eb079a0b8763cc9243db3017fce8f2b5f1c2b1" translate="yes" xml:space="preserve">
          <source>These 2 articles were helpful for me:</source>
          <target state="translated">这2篇文章对我很有帮助。</target>
        </trans-unit>
        <trans-unit id="9b99e56bf3215466d4bcb6510e8f2ab3c18e92a1" translate="yes" xml:space="preserve">
          <source>This command will ignore the files that have already been committed to a Git repository but now we have added them to &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">该命令将忽略已经提交到Git存储库的文件，但是现在我们将它们添加到 &lt;code&gt;.gitignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a80256c88620e0c46466e120451785a26291aed" translate="yes" xml:space="preserve">
          <source>This command will recreate the entire commit history, executing &lt;code&gt;git rm&lt;/code&gt; before each commit and so will get rid of the specified file. Don't forget to back it up before running the command as it &lt;em&gt;will&lt;/em&gt; be lost.</source>
          <target state="translated">该命令将重新创建整个提交历史记录，在每次提交之前执行 &lt;code&gt;git rm&lt;/code&gt; ，因此将删除指定的文件。 运行命令之前，请不要忘记备份它，因为它&lt;em&gt;会&lt;/em&gt;丢失。</target>
        </trans-unit>
        <trans-unit id="aace7ffcc2632aa8ca6dcf3aeb06c1b3b98defb7" translate="yes" xml:space="preserve">
          <source>This method makes git &lt;strong&gt;completely forget&lt;/strong&gt; ignored files (&lt;strong&gt;past&lt;/strong&gt;/present/future), but does &lt;strong&gt;not&lt;/strong&gt; delete anything from working directory (even when re-pulled from remote).</source>
          <target state="translated">这种方法使git &lt;strong&gt;完全忘记了&lt;/strong&gt;被忽略的文件（ &lt;strong&gt;过去&lt;/strong&gt; / present / future），但不会从工作目录中删除任何内容（即使从远程重新拉出）。</target>
        </trans-unit>
        <trans-unit id="0fd8d975ab3598d0501dc78d1c2086af30973cad" translate="yes" xml:space="preserve">
          <source>This method requires usage of &lt;code&gt;/.git/info/exclude&lt;/code&gt; (preferred) &lt;strong&gt;OR&lt;/strong&gt; a &lt;strong&gt;pre-existing&lt;/strong&gt;&lt;code&gt;.gitignore&lt;/code&gt; in &lt;strong&gt;all&lt;/strong&gt; the commits that have files to be ignored/forgotten. &lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">此方法要求在&lt;strong&gt;所有&lt;/strong&gt;具有要忽略/忘记的文件的提交中使用 &lt;code&gt;/.git/info/exclude&lt;/code&gt; （首选） &lt;strong&gt;或&lt;/strong&gt; &lt;strong&gt;预先存在的&lt;/strong&gt; &lt;code&gt;.gitignore&lt;/code&gt; 。 &lt;sup&gt;1个&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ee4e1a639a65a59982342cdd0d5f935792f354b4" translate="yes" xml:space="preserve">
          <source>This problem is absent, for example, when using CVS. CVS stores information as a list of file-based changes. Information for CVS is a set of files and the changes made to each file over time.</source>
          <target state="translated">例如,在使用CVS时,这个问题就不存在。CVS将信息存储为基于文件的变化列表。CVS的信息是一组文件,以及随着时间的推移对每个文件所做的更改。</target>
        </trans-unit>
        <trans-unit id="a3d360038ad27ca130f73142cff92cf439acd687" translate="yes" xml:space="preserve">
          <source>This takes the list of the ignored files and removes them from the index, then commits the changes.</source>
          <target state="translated">这就把被忽略的文件列表从索引中删除,然后提交更改。</target>
        </trans-unit>
        <trans-unit id="8ef3809914d0a4bf55ad9dbd46e75e9ee26c43d4" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;-z&lt;/code&gt; argument to &lt;strong&gt;ls-files&lt;/strong&gt;, and the &lt;code&gt;-0&lt;/code&gt; argument to &lt;strong&gt;xargs&lt;/strong&gt; to cater safely/correctly for &quot;nasty&quot; characters in filenames.</source>
          <target state="translated">它使用&lt;strong&gt;ls-files&lt;/strong&gt;的 &lt;code&gt;-z&lt;/code&gt; 参数和&lt;strong&gt;xargs&lt;/strong&gt;的 &lt;code&gt;-0&lt;/code&gt; 参数安全/正确地满足文件名中的&amp;ldquo;讨厌&amp;rdquo;字符。</target>
        </trans-unit>
        <trans-unit id="fac1fa39e67b6dbe6a9e8961a2ebbe207fd0a129" translate="yes" xml:space="preserve">
          <source>To clear your repo, use:</source>
          <target state="translated">要清除你的Repo,请使用:</target>
        </trans-unit>
        <trans-unit id="9ece9b71ac3beff566f8bc63a178b67231ef3864" translate="yes" xml:space="preserve">
          <source>To stop tracking a file you need to remove it from the index. This can be achieved with this command.</source>
          <target state="translated">要停止跟踪一个文件,你需要从索引中删除它。这可以通过以下命令来实现。</target>
        </trans-unit>
        <trans-unit id="4e28adc0562a325e3e096fedb43aec2bcfc26cc2" translate="yes" xml:space="preserve">
          <source>To summarize:</source>
          <target state="translated">总而言之:</target>
        </trans-unit>
        <trans-unit id="9ef7a39f54d24e9a0a605a35fb91afa4588e67b8" translate="yes" xml:space="preserve">
          <source>Try to use gitattributes clean/smudge magic to apply and remove the changes for you, for instance smudge the config file as a checkout from an alternate branch and clean the config file as a checkout from HEAD.  This is tricky stuff, I don't recommend it for the novice user.</source>
          <target state="translated">试着用gitattributes cleansmudge魔法来为你应用和删除修改,比如把配置文件作为备用分支的checkout从另一个分支中的checkout,然后把配置文件作为head的checkout来清理。这是个很棘手的东西,我不建议新手使用。</target>
        </trans-unit>
        <trans-unit id="e966285e3158a217aa4fa3d2055f125148a7452f" translate="yes" xml:space="preserve">
          <source>Update your &lt;code&gt;.gitignore&lt;/code&gt; file &amp;ndash; for instance, add a folder you don't want to track to &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">更新您的 &lt;code&gt;.gitignore&lt;/code&gt; 文件-例如，将您不想跟踪的文件夹添加到 &lt;code&gt;.gitignore&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c04f0b185dde023e1da3e23b5abf4ebb68539583" translate="yes" xml:space="preserve">
          <source>Use this when:</source>
          <target state="translated">用这个当。</target>
        </trans-unit>
        <trans-unit id="87f831e2d4c6393d9fcee8d70bc3691c05dbf836" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;git rm --cached&lt;/code&gt; command does not answer the original question:</source>
          <target state="translated">使用 &lt;code&gt;git rm --cached&lt;/code&gt; 命令不能回答原始问题：</target>
        </trans-unit>
        <trans-unit id="fe9e905994f09d5cd0a93eec644ef1b6cc083fae" translate="yes" xml:space="preserve">
          <source>What didn't work for me</source>
          <target state="translated">对我来说没有用的东西</target>
        </trans-unit>
        <trans-unit id="cfaea70ee7364b7f2f10a028c48a9b68308aecdb" translate="yes" xml:space="preserve">
          <source>When -z option is not used, TAB, LF, and backslash characters in
  pathnames are represented as \t, \n, and \\, respectively.</source>
          <target state="translated">当不使用 -z 选项时,路径名中的 TAB、LF 和反斜线字符分别表示为 \t、\n 和\n。</target>
        </trans-unit>
        <trans-unit id="a1d3840d4562480d2399ecf6afe2d819b1729baa" translate="yes" xml:space="preserve">
          <source>You'll also need to (temporarily) &lt;a href=&quot;https://stackoverflow.com/a/10544328/4901390&quot;&gt;allow non-fast-forward pushes to your repository&lt;/a&gt;, since you're changing your git history.</source>
          <target state="translated">您还需要（临时） &lt;a href=&quot;https://stackoverflow.com/a/10544328/4901390&quot;&gt;允许非快进推送到存储库&lt;/a&gt; ，因为您正在更改git历史记录。</target>
        </trans-unit>
        <trans-unit id="ed971b2dd1c9a5b86271f2c62c00a985a6982cc2" translate="yes" xml:space="preserve">
          <source>Your repository is clean :)</source>
          <target state="translated">你的存储库是干净的:)</target>
        </trans-unit>
        <trans-unit id="84cbaf0a5f2e76b1082a2ed9f1526561e8163981" translate="yes" xml:space="preserve">
          <source>breaking it down:</source>
          <target state="translated">掰开来看。</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="824c64b13bca2d2655a812f22946c1edd153a100" translate="yes" xml:space="preserve">
          <source>cope with this situation (get errors about files not found).</source>
          <target state="translated">应对这种情况(得到关于未找到文件的错误)。</target>
        </trans-unit>
        <trans-unit id="e1f5dc1388efa7feb527c501975cbf1f88f8ed54" translate="yes" xml:space="preserve">
          <source>git config --global alias.exclude-ignored '!git ls-files -z --ignored --exclude-standard | xargs -0 git rm -r --cached &amp;amp;&amp;amp;  git ls-files -z --ignored --exclude-standard | xargs -0 git stage &amp;amp;&amp;amp;  git stage .gitignore &amp;amp;&amp;amp; git commit -m &quot;new gitignore and remove ignored files from index&quot;'</source>
          <target state="translated">git config --global alias.exclude-ignored'！git ls-files -z --ignored --exclude-standard | xargs -0 git rm -r --cached &amp;amp;&amp;amp; git ls-files -z --ignored --exclude-standard | xargs -0 git stage &amp;amp;&amp;amp; git stage .gitignore &amp;amp;&amp;amp; git commit -m&amp;ldquo;新的gitignore并从索引中删除被忽略的文件&amp;rdquo;'</target>
        </trans-unit>
        <trans-unit id="ef4d26678574a73b0e350a9a486783df032bc301" translate="yes" xml:space="preserve">
          <source>just replace &lt;code&gt;full/path/to/file&lt;/code&gt; with the full path of the file. Make sure you've added the file to your &lt;code&gt;.gitignore&lt;/code&gt;.</source>
          <target state="translated">只需将 &lt;code&gt;full/path/to/file&lt;/code&gt; 替换为文件的完整路径即可。 确保已将文件添加到 &lt;code&gt;.gitignore&lt;/code&gt; 中 。</target>
        </trans-unit>
        <trans-unit id="d57cea54209eef1efd8a4421791d849849a82490" translate="yes" xml:space="preserve">
          <source>move it out, commit, then move it back in. This has worked for me in the past. There is probably a 'gittier' way to accomplish this.</source>
          <target state="translated">把它搬出来,承诺,然后再搬回来。这在过去对我来说是有效的。可能有一个 &quot;吉特尔 &quot;的方法来完成这个任务。</target>
        </trans-unit>
        <trans-unit id="305ae145517f107f30ff7601792a2642c8676b9b" translate="yes" xml:space="preserve">
          <source>remove ignored files from index</source>
          <target state="translated">从索引中删除被忽略的文件</target>
        </trans-unit>
        <trans-unit id="1ccf2fbbfa1279aaf960c3ec391069e720298640" translate="yes" xml:space="preserve">
          <source>so I think my solution is needed if filenames have any of these characters in them.</source>
          <target state="translated">所以我想,如果文件名里有这些字符,我的解决方案是需要的。</target>
        </trans-unit>
        <trans-unit id="478f9e84d9950a571b6e0c79abdf30102aa37957" translate="yes" xml:space="preserve">
          <source>stage .gitignore and the files you just removed</source>
          <target state="translated">阶段的.gitignore和你刚刚删除的文件</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
