<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/123559">
    <body>
      <group id="123559">
        <trans-unit id="46bd2bf2dbfcdbbcdc91543315903ec8d9fa7110" translate="yes" xml:space="preserve">
          <source>(416)555-3456</source>
          <target state="translated">(416)555-3456</target>
        </trans-unit>
        <trans-unit id="922db0fa7e91b0835c2ba07c721ee9be3dca5c9c" translate="yes" xml:space="preserve">
          <source>(926) 1234567</source>
          <target state="translated">(926) 1234567</target>
        </trans-unit>
        <trans-unit id="a35c2a47e8479c61161487357ed2255f62b29768" translate="yes" xml:space="preserve">
          <source>+1-(800)-123-4567</source>
          <target state="translated">+1-(800)-123-4567</target>
        </trans-unit>
        <trans-unit id="01040e6fe4beb6bd4429c3545016bdd99a84e9c8" translate="yes" xml:space="preserve">
          <source>+42 555.123.4567</source>
          <target state="translated">+42 555.123.4567</target>
        </trans-unit>
        <trans-unit id="c65e2689191172b5a4409a3edf9e2821a1a502a3" translate="yes" xml:space="preserve">
          <source>+7 555 1234567</source>
          <target state="translated">+7 555 1234567</target>
        </trans-unit>
        <trans-unit id="958572d35dce6a727de99eecd46fe65f713990a5" translate="yes" xml:space="preserve">
          <source>+7(926)1234567</source>
          <target state="translated">+7(926)1234567</target>
        </trans-unit>
        <trans-unit id="1b3ba023e29fe0db6f746c89dc0d2c3994ff3ec0" translate="yes" xml:space="preserve">
          <source>+79261234567</source>
          <target state="translated">+79261234567</target>
        </trans-unit>
        <trans-unit id="4d92d488728ea2b58d1e8dafe06109f59bd1d6b3" translate="yes" xml:space="preserve">
          <source>-Adam</source>
          <target state="translated">-Adam</target>
        </trans-unit>
        <trans-unit id="12550a116a592ec6145716a1c1d7f7816709bbef" translate="yes" xml:space="preserve">
          <source>1 416 555 9292</source>
          <target state="translated">1416555 9292</target>
        </trans-unit>
        <trans-unit id="ee1884442ea911f3046d5aeade966104f58bf91c" translate="yes" xml:space="preserve">
          <source>123-4567</source>
          <target state="translated">123-4567</target>
        </trans-unit>
        <trans-unit id="44d6bfea854e4d538cb4e6c4daaf2e3534086b3a" translate="yes" xml:space="preserve">
          <source>123-89-01</source>
          <target state="translated">123-89-01</target>
        </trans-unit>
        <trans-unit id="20eabe5d64b0e216796e834f52d61fd0b70332fc" translate="yes" xml:space="preserve">
          <source>1234567</source>
          <target state="translated">1234567</target>
        </trans-unit>
        <trans-unit id="0b97f0509411d69a0661b070e86679e931a50f51" translate="yes" xml:space="preserve">
          <source>202 555 4567</source>
          <target state="translated">202555 4567</target>
        </trans-unit>
        <trans-unit id="0f82b1cdc77d7852a909e872fa51b4f38ae87f78" translate="yes" xml:space="preserve">
          <source>4035555678</source>
          <target state="translated">4035555678</target>
        </trans-unit>
        <trans-unit id="d3af04306c750f12c8537841140ec19e68eb80d7" translate="yes" xml:space="preserve">
          <source>415-555-1234</source>
          <target state="translated">415-555-1234</target>
        </trans-unit>
        <trans-unit id="caa42b7c1aa9577623f00ff8ee9a70689bc689dd" translate="yes" xml:space="preserve">
          <source>469 123 45 67</source>
          <target state="translated">469 123 45 67</target>
        </trans-unit>
        <trans-unit id="666c16448d37b6c46e857ce94f27858056aa06bb" translate="yes" xml:space="preserve">
          <source>495 1234567</source>
          <target state="translated">495 1234567</target>
        </trans-unit>
        <trans-unit id="6545ceeda2d631b6102dd498f087e3043a70a1c9" translate="yes" xml:space="preserve">
          <source>650-555-2345</source>
          <target state="translated">650-555-2345</target>
        </trans-unit>
        <trans-unit id="bda8273b562ee4d450607f5f1eeee381a0db0d12" translate="yes" xml:space="preserve">
          <source>8 (926) 1234567</source>
          <target state="translated">8 (926) 1234567</target>
        </trans-unit>
        <trans-unit id="b466f2b1ab3e14efbabb3362cb7f3b191004a81f" translate="yes" xml:space="preserve">
          <source>8 800 600-APPLE</source>
          <target state="translated">8800600- 애플</target>
        </trans-unit>
        <trans-unit id="c8f6d1b7f2dee5ecd696a27ce9a49f0ad87455d7" translate="yes" xml:space="preserve">
          <source>89261234567</source>
          <target state="translated">89261234567</target>
        </trans-unit>
        <trans-unit id="26b7a98f37ccc4ad6acbb28aac670ca8271322db" translate="yes" xml:space="preserve">
          <source>926 1234567</source>
          <target state="translated">926 1234567</target>
        </trans-unit>
        <trans-unit id="e44cfa11f63bc4c02c7877f31888a5041b157e04" translate="yes" xml:space="preserve">
          <source>926 3 4</source>
          <target state="translated">926 3 4</target>
        </trans-unit>
        <trans-unit id="8a1892e3f407adfe6fe96d1d939c9807978cebcb" translate="yes" xml:space="preserve">
          <source>926.123.4567</source>
          <target state="translated">926.123.4567</target>
        </trans-unit>
        <trans-unit id="12b3277a907665b90ff11b244a17ee74d8ea444c" translate="yes" xml:space="preserve">
          <source>9261234567</source>
          <target state="translated">9261234567</target>
        </trans-unit>
        <trans-unit id="7136bc4473fb12d41af3223d4c129fbba798d30d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.codeitive.com/0QNggPXPgW/international-and-irish-phone-number-form-validation-using-jquery.html&quot;&gt;Source&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.codeitive.com/0QNggPXPgW/international-and-irish-phone-number-form-validation-using-jquery.html&quot;&gt;Source&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0a38a09b5464fc1e52499ce243b4bec7e7585d1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$/&lt;/code&gt; : End the expression</source>
          <target state="translated">&lt;code&gt;$/&lt;/code&gt; : 식 끝내기</target>
        </trans-unit>
        <trans-unit id="a1b68d4d6936a232eda26e679236a1605101efed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(02) 9999 9999&lt;/code&gt; is also a &lt;strong&gt;valid&lt;/strong&gt; Australian number</source>
          <target state="translated">&lt;code&gt;(02) 9999 9999&lt;/code&gt; 또한 &lt;strong&gt;유효한&lt;/strong&gt; 호주 번호입니다</target>
        </trans-unit>
        <trans-unit id="3633256ac8b591b550060c60eaf7b37a2230361d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(09) 9999 9999&lt;/code&gt; is &lt;strong&gt;not a valid&lt;/strong&gt; Australian number</source>
          <target state="translated">&lt;code&gt;(09) 9999 9999&lt;/code&gt; 는 &lt;strong&gt;유효한&lt;/strong&gt; 호주 번호가 &lt;strong&gt;아닙니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d7edae792248e451ea60a485b12fd0eb603d7062" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(408) 974&amp;ndash;2042&lt;/code&gt; is a &lt;strong&gt;valid&lt;/strong&gt; US number</source>
          <target state="translated">&lt;code&gt;(408) 974&amp;ndash;2042&lt;/code&gt; 는 &lt;strong&gt;유효한&lt;/strong&gt; 미국 번호입니다.</target>
        </trans-unit>
        <trans-unit id="53ba90e16905883e3b69639432a64176bac521b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(999) 974&amp;ndash;2042&lt;/code&gt; is &lt;strong&gt;not a valid&lt;/strong&gt; US number</source>
          <target state="translated">&lt;code&gt;(999) 974&amp;ndash;2042&lt;/code&gt; 는 &lt;strong&gt;유효한&lt;/strong&gt; 미국 번호가 &lt;strong&gt;아닙니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b683d55971afcff131f4e90fca39caf9b54c7553" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(\+|1\s)?&lt;/code&gt; : Accept a &quot;plus&quot; or a 1 and a space (pipe character, &lt;code&gt;|&lt;/code&gt;, is &quot;or&quot;), and make it optional.  The &quot;plus&quot; sign must be escaped.</source>
          <target state="translated">&lt;code&gt;(\+|1\s)?&lt;/code&gt; : &quot;plus&quot;또는 1과 공백 (파이프 문자 &lt;code&gt;|&lt;/code&gt; 은 &quot;또는&quot;)을 승인하고 선택 사항으로 만드십시오. &quot;더하기&quot;부호는 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a90008edd365f07eb413c9fb2102990009c39d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0404 999 999&lt;/code&gt; is a &lt;strong&gt;valid&lt;/strong&gt; Australian number</source>
          <target state="translated">&lt;code&gt;0404 999 999&lt;/code&gt; 는 &lt;strong&gt;유효한&lt;/strong&gt; 호주 번호입니다.</target>
        </trans-unit>
        <trans-unit id="f4c6a8656c9ac3ff7006494b88234b76534c313b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AsYouTypeFormatter&lt;/code&gt; - formats phone numbers on-the-fly when users enter each digit.</source>
          <target state="translated">&lt;code&gt;AsYouTypeFormatter&lt;/code&gt; - 사용자가 각 숫자를 입력 할 때 즉시 전화 번호를 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="ff709eb0cb6873a644d25a1ff6e17489e4eccbb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PhoneNumberOfflineGeocoder&lt;/code&gt; - provides geographical information related to a phone number.</source>
          <target state="translated">&lt;code&gt;PhoneNumberOfflineGeocoder&lt;/code&gt; - 전화 번호와 관련된 지리적 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="41901e4b3e46b93b8cdd2df707362b4e960bc6af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[2-9]&lt;/code&gt; :  Requires a digit 2-9 for that slot.</source>
          <target state="translated">&lt;code&gt;[2-9]&lt;/code&gt; : 해당 슬롯에 숫자 2-9가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="30ae1ff0a2a51fc47926c273807c8f3801af0d4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d{3}&lt;/code&gt; :  Requires a 3-digit number:  000-999.  Shorthand for
&lt;code&gt;[0-9][0-9][0-9]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\d{3}&lt;/code&gt; : 000-999의 3 자리 숫자가 필요합니다. &lt;code&gt;[0-9][0-9][0-9]&lt;/code&gt; 의 약어 입니다.</target>
        </trans-unit>
        <trans-unit id="40a52a3d72da33a1e4f4bd90588fa2259da597df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findNumbers&lt;/code&gt; - finds numbers in text input.</source>
          <target state="translated">&lt;code&gt;findNumbers&lt;/code&gt; - 텍스트 입력에서 숫자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="2028f080264773ae0782713fe0fa5bf8434dcb78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getExampleNumber&lt;/code&gt;/&lt;code&gt;getExampleNumberByType&lt;/code&gt; - provides valid example numbers for all countries/regions, with the option of specifying which type of example phone number is needed.</source>
          <target state="translated">&lt;code&gt;getExampleNumber&lt;/code&gt; / &lt;code&gt;getExampleNumberByType&lt;/code&gt; - 필요한 전화 번호의 유형을 지정하는 옵션과 함께 모든 국가 / 지역에 유효한 예제 번호를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8ae5d2eb6cb5560a9b58ef49e842be7c328f5354" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getNumberType&lt;/code&gt; - gets the type of the number based on the number itself; able to distinguish Fixed-line, Mobile, Toll-free, Premium Rate, Shared Cost, VoIP and Personal Numbers (whenever feasible).</source>
          <target state="translated">&lt;code&gt;getNumberType&lt;/code&gt; - 숫자 자체에 따라 숫자의 유형을 가져옵니다. 유선, 모바일, 무료, 프리미엄 요금, 공유 비용, VoIP 및 개인 번호 (가능한 경우)를 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de6f3026a2a806857a02c158c3f3516ca3203953" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isNumberMatch&lt;/code&gt; - gets a confidence level on whether two numbers could be the same.</source>
          <target state="translated">&lt;code&gt;isNumberMatch&lt;/code&gt; - 두 숫자가 같은지 여부에 대한 신뢰 수준을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d95332e339f288fa1055f04e2fdd1f00f614a359" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isPossibleNumber&lt;/code&gt; - quickly guessing whether a number is a possible phonenumber by using only the length information, much faster than a full validation.</source>
          <target state="translated">&lt;code&gt;isPossibleNumber&lt;/code&gt; - 전체 유효성 검사보다 훨씬 빠른 길이 정보 만 사용하여 숫자가 가능한 전화 번호인지 빠르게 추측합니다.</target>
        </trans-unit>
        <trans-unit id="8dff01c36dabb4875658933ef3c1a9112bae41d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isValidNumber&lt;/code&gt; - full validation of a phone number for a region using length and prefix information.</source>
          <target state="translated">&lt;code&gt;isValidNumber&lt;/code&gt; - 길이 및 접두사 정보를 사용하여 지역의 전화 번호에 대한 전체 유효성 검사</target>
        </trans-unit>
        <trans-unit id="9f561e466531ebcda547d50fab19e7b5430d8922" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;America&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;America&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93680b7e2fa033f259e12bd2f56b2b1593e4d7f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Australia&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Australia&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="033fc1fbbea67f031c319e448ee0ee8ce320d484" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C#&lt;/strong&gt;: &lt;a href=&quot;https://github.com/twcclegg/libphonenumber-csharp&quot;&gt;https://github.com/twcclegg/libphonenumber-csharp&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;C #&lt;/strong&gt; : &lt;a href=&quot;https://github.com/twcclegg/libphonenumber-csharp&quot;&gt;https://github.com/twcclegg/libphonenumber-csharp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5fbf4a00d6a882121a802d2725d98940aaaeb108" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Edit:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="24605bd984aabecf300ff94f55f51e1114adcd40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Elixir&lt;/strong&gt;: &lt;a href=&quot;https://github.com/socialpaymentsbv/ex_phone_number&quot;&gt;https://github.com/socialpaymentsbv/ex_phone_number&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;엘릭서&lt;/strong&gt; : &lt;a href=&quot;https://github.com/socialpaymentsbv/ex_phone_number&quot;&gt;https://github.com/socialpaymentsbv/ex_phone_number&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dbac505176c7d070a0ce804c63b6347e23f78d30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Highlights of functionality:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기능의 하이라이트 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30a3db4832247f60fba1a2168df67582ae88b7f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JavaScript&lt;/strong&gt;: &lt;a href=&quot;https://github.com/ruimarinho/google-libphonenumber&quot;&gt;https://github.com/ruimarinho/google-libphonenumber&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;자바 스크립트&lt;/strong&gt; : &lt;a href=&quot;https://github.com/ruimarinho/google-libphonenumber&quot;&gt;https://github.com/ruimarinho/google-libphonenumber&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b825c9117f16fec2c2885e9738341494f979c39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Objective-C&lt;/strong&gt;: &lt;a href=&quot;https://github.com/iziz/libPhoneNumber-iOS&quot;&gt;https://github.com/iziz/libPhoneNumber-iOS&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Objective-C&lt;/strong&gt; : &lt;a href=&quot;https://github.com/iziz/libPhoneNumber-iOS&quot;&gt;https://github.com/iziz/libPhoneNumber-iOS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59ccb2fa2dfb42e44cf55acf54cdcb9e47466e0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP&lt;/strong&gt;: &lt;a href=&quot;https://github.com/giggsey/libphonenumber-for-php&quot;&gt;https://github.com/giggsey/libphonenumber-for-php&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;PHP&lt;/strong&gt; : &lt;a href=&quot;https://github.com/giggsey/libphonenumber-for-php&quot;&gt;https://github.com/giggsey/libphonenumber-for-php&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="638642d05d74b4159689f3ed5a7c0e4fdbb817a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python&lt;/strong&gt;: &lt;a href=&quot;https://github.com/daviddrysdale/python-phonenumbers&quot;&gt;https://github.com/daviddrysdale/python-phonenumbers&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;파이썬&lt;/strong&gt; : &lt;a href=&quot;https://github.com/daviddrysdale/python-phonenumbers&quot;&gt;https://github.com/daviddrysdale/python-phonenumbers&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01dc2621b96b7722fd431829f5d867d46c77593f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ruby&lt;/strong&gt;: &lt;a href=&quot;https://github.com/sstephenson/global_phone&quot;&gt;https://github.com/sstephenson/global_phone&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;루비&lt;/strong&gt; : &lt;a href=&quot;https://github.com/sstephenson/global_phone&quot;&gt;https://github.com/sstephenson/global_phone&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="488aeff36a84e59f02d58068108b1919630e3440" translate="yes" xml:space="preserve">
          <source>A couple simple perl expressions might be:</source>
          <target state="translated">몇 가지 간단한 펄 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca6b2583d0e9a3c4be4eb43eacf5aa17d784da0c" translate="yes" xml:space="preserve">
          <source>A regular expression is fine for checking the format of a phone number, but it's not really going to be able to check the &lt;em&gt;validity&lt;/em&gt; of a phone number.</source>
          <target state="translated">정규식은 전화 번호의 형식을 확인하는 데는 좋지만 실제로 전화 번호의 &lt;em&gt;유효성&lt;/em&gt; 을 확인할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="59aae6ebbd36ac7b0e708dcdbfe7b57ca5fcb0e0" translate="yes" xml:space="preserve">
          <source>Accepts:</source>
          <target state="translated">Accepts:</target>
        </trans-unit>
        <trans-unit id="aadf0b7cafc7f742c185a01cdda7569411bce26e" translate="yes" xml:space="preserve">
          <source>After reading through these answers, it looks like there wasn't a straightforward regular expression that can parse through a bunch of text and pull out phone numbers in any format (including international with and without the plus sign).</source>
          <target state="translated">이 답변을 읽은 후에는 많은 텍스트를 구문 분석하고 모든 형식 (더하기 부호가 있거나없는 국제 전화 포함)으로 전화 번호를 가져올 수있는 간단한 정규 표현식이없는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="400bb35a87523373a5deaa7cf3dda1d5543b1fad" translate="yes" xml:space="preserve">
          <source>Although the answer to strip all whitespace is neat, it doesn't really solve the problem that's posed, which is to find a regex.  Take, for instance, my test script that downloads a web page and extracts all phone numbers using the regex.  Since you'd need a regex anyway, you might as well have the regex do all the work.  I came up with this:</source>
          <target state="translated">모든 공백을 제거하는 대답은 깔끔하지만 실제로 발생하는 문제를 해결하지는 못합니다. 즉 정규 표현식을 찾는 것입니다. 예를 들어 웹 페이지를 다운로드하고 정규식을 사용하여 모든 전화 번호를 추출하는 테스트 스크립트를 생각해보십시오. 어쨌든 정규식이 필요하기 때문에 정규식이 모든 작업을 수행하도록 할 수도 있습니다. 나는 이것을 생각해 냈다.</target>
        </trans-unit>
        <trans-unit id="ac8fd7a0e55b893ddc9967e7ee080a882160e910" translate="yes" xml:space="preserve">
          <source>And while stripping all/most non-numeric characters may work well on the server side (especially if you are planning on passing these values to a dialer), you may not want to thrash the user's input during validation, particularly if you want them to make corrections in another field.</source>
          <target state="translated">그리고 숫자가 아닌 모든 문자를 제거하면 서버 측에서 잘 작동 할 수 있지만 (특히이 값을 다이얼러에 전달하려는 경우) 특히 사용자가 원하는 경우 유효성 검사 중에 사용자 입력을 스 래시하지 않을 수 있습니다 다른 분야에서 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="97fbcada001f55ac5e505e92a5396afd1f06169b" translate="yes" xml:space="preserve">
          <source>As a bonus, &lt;code&gt;libphonenumber&lt;/code&gt; has a number of datasets to check the validity of phone numbers, as well, so checking a number such as &lt;code&gt;+61299999999&lt;/code&gt; (the international version of &lt;a href=&quot;https://libphonenumber.appspot.com/phonenumberparser?number=+61299999999&amp;amp;country=AU&amp;amp;geocodingLocale=en-US&quot;&gt;&lt;code&gt;(02) 9999 9999&lt;/code&gt;&lt;/a&gt;) returns as a valid number with formatting:</source>
          <target state="translated">보너스로 &lt;code&gt;libphonenumber&lt;/code&gt; 에는 전화 번호의 유효성을 검사하기위한 많은 데이터 세트가 있으므로 &lt;code&gt;+61299999999&lt;/code&gt; (국제 버전 &lt;a href=&quot;https://libphonenumber.appspot.com/phonenumberparser?number=+61299999999&amp;amp;country=AU&amp;amp;geocodingLocale=en-US&quot;&gt; &lt;code&gt;(02) 9999 9999&lt;/code&gt; &lt;/a&gt; )와 같은 숫자를 확인하면 형식이 지정된 유효한 숫자로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3d196df3b26d8c379e3dd5b18cdf5c6e24cb329d" translate="yes" xml:space="preserve">
          <source>As mentioned below, it checks only for characters, not its structure/order</source>
          <target state="translated">아래에서 언급했듯이, 구조 / 순서가 아닌 문자 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="cac51434fcdc8532c06654edfe20ccf273510fab" translate="yes" xml:space="preserve">
          <source>Better option... just strip all non-digit characters on input (except 'x' and leading '+' signs), taking care because of the British tendency to write numbers in the non-standard form &lt;code&gt;+44 (0) ...&lt;/code&gt; when asked to use the international prefix (in that specific case, you should discard the &lt;code&gt;(0)&lt;/code&gt; entirely).</source>
          <target state="translated">더 나은 옵션은 ... 영국이 비표준 형식 &lt;code&gt;+44 (0) ...&lt;/code&gt; 숫자를 쓰는 경향 때문에주의하여 입력시 숫자가 아닌 모든 문자를 제거하십시오 ( 'x'및 앞의 '+'부호 제외 ). 국제 접두사를 사용하라는 요청을받은 경우 (특정 경우 &lt;code&gt;(0)&lt;/code&gt; 을 완전히 폐기해야합니다).</target>
        </trans-unit>
        <trans-unit id="4a225d2f9965fe34ea538413a35d7b335c066858" translate="yes" xml:space="preserve">
          <source>Beyond that - the list you gave does not include another common US format - leaving off the initial 1.  Most cell phones in the US don't require it, and it'll start to baffle the younger generation unless they've dialed internationally.</source>
          <target state="translated">그 외에도-귀하가 제공 한 목록에는 다른 일반적인 미국 형식이 포함되어 있지 않습니다-초기 1 제외</target>
        </trans-unit>
        <trans-unit id="43a5906151aeae7631de0c8088ed4d4982f3bea6" translate="yes" xml:space="preserve">
          <source>Breaking a complex regexp like this can be just as effective, but much more simple.</source>
          <target state="translated">이와 같은 복잡한 정규 표현식을 깨는 것은 효과적이지만 훨씬 간단합니다.</target>
        </trans-unit>
        <trans-unit id="37d42d17f06037bfcdb7e90603c5fb51b34fbb15" translate="yes" xml:space="preserve">
          <source>But the invalid Australian phone number (&lt;a href=&quot;https://libphonenumber.appspot.com/phonenumberparser?number=01161999999999&amp;amp;country=US&amp;amp;geocodingLocale=en-US&quot;&gt;&lt;code&gt;(09) 9999 9999&lt;/code&gt;&lt;/a&gt;) returns that it is not a valid phone number.</source>
          <target state="translated">그러나 잘못된 호주 전화 번호 ( &lt;a href=&quot;https://libphonenumber.appspot.com/phonenumberparser?number=01161999999999&amp;amp;country=US&amp;amp;geocodingLocale=en-US&quot;&gt; &lt;code&gt;(09) 9999 9999&lt;/code&gt; &lt;/a&gt; )는 올바른 전화 번호가 아님을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd97f611de650fc07dfa1c4d6992198b072a7f30" translate="yes" xml:space="preserve">
          <source>Country indicator</source>
          <target state="translated">국가 표시기</target>
        </trans-unit>
        <trans-unit id="fdfe09df639dcc072e670324ee0209f2debec6ec" translate="yes" xml:space="preserve">
          <source>Do a replace on formatting characters, then check the remaining for phone validity.  In PHP,</source>
          <target state="translated">서식 문자를 바꾸고 나머지 전화 유효 여부를 확인하십시오. PHP에서</target>
        </trans-unit>
        <trans-unit id="16a0b451f01e21349e7ff6a5419e8ec27f88d8d0" translate="yes" xml:space="preserve">
          <source>EDIT:</source>
          <target state="translated">EDIT:</target>
        </trans-unit>
        <trans-unit id="0f86093f5a5fbb42dbd59a0c2d1a4b6e838479a1" translate="yes" xml:space="preserve">
          <source>Entering US phone number brought back quite a list of possibilities.</source>
          <target state="translated">미국 전화 번호를 입력하면 가능성이 상당히 높아졌습니다.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="9c06f2a299923d862630566d22b27441c053e469" translate="yes" xml:space="preserve">
          <source>For anyone interested in doing something similar with Irish mobile phone numbers, here's a straightforward way of accomplishing it:</source>
          <target state="translated">아일랜드 휴대 전화 번호와 유사한 작업에 관심이있는 사람은 다음과 같이 간단한 방법으로이를 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f953f99de4fc84ba1451d0528f96f4405157617d" translate="yes" xml:space="preserve">
          <source>For example, it will recognize that:</source>
          <target state="translated">예를 들어 다음을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="d6057320fd68061629731fe2fbb1d427361c6696" translate="yes" xml:space="preserve">
          <source>For further analysis you can subscribe to one of many providers that will give you access to a database of valid numbers as well as tell you if they're landlines or mobiles, disconnected, etc. It costs money.</source>
          <target state="translated">추가 분석을 위해 유효한 숫자의 데이터베이스에 액세스 할 수있을뿐만 아니라 유선 또는 이동 전화인지, 연결이 끊겼는지 등을 알려주는 많은 공급자 중 하나를 구독 할 수 있습니다. 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="af5aa2daf63a7d05f098b5b003ef31604f6b16f1" translate="yes" xml:space="preserve">
          <source>From my post on that site, I've created a quick guide to assist anyone with making their own regex for their own desired phone number format, which I will caveat (like I did on the other site) that if you are too restrictive, you may not get the desired results, and there is no &quot;one size fits all&quot; solution to accepting all possible phone numbers in the world - only what you decide to accept as your format of choice.  Use at your own risk.</source>
          <target state="translated">해당 사이트의 게시물을 통해 누구나 원하는 전화 번호 형식으로 자신의 정규식을 만드는 데 도움이되는 빠른 가이드를 만들었습니다. 다른 사이트에서와 같이 너무 제한적이라면 원하는 결과를 얻지 못할 수도 있으며 전 세계에서 가능한 모든 전화 번호를 받아들이는 &quot;하나의 크기에 모두 맞는&quot;솔루션은 없으며 선택한 형식으로 수락하기로 결정한 것만 있습니다. 자신의 책임하에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1ea80608bd0135d482e7ecafa7647192f008cb75" translate="yes" xml:space="preserve">
          <source>Google's version has code for Java and Javascript, but people have also implemented libraries for other languages that use the Google i18n phone number dataset:</source>
          <target state="translated">Google 버전에는 Java 및 Javascript 용 코드가 있지만 사람들은 Google i18n 전화 번호 데이터 세트를 사용하는 다른 언어 용 라이브러리도 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="44f085c8e03a6a858b882ee9431bad07c64c314e" translate="yes" xml:space="preserve">
          <source>Have you had a look over at &lt;a href=&quot;http://regexlib.com/&quot;&gt;RegExLib&lt;/a&gt;?</source>
          <target state="translated">&lt;a href=&quot;http://regexlib.com/&quot;&gt;RegExLib를&lt;/a&gt; 살펴 보셨습니까 ?</target>
        </trans-unit>
        <trans-unit id="ca525f2d9d8acdf38205777d144c84521f1a175d" translate="yes" xml:space="preserve">
          <source>Here's a perl script to test it.  When you match, $1 contains the area code, $2 and $3 contain the phone number, and $5 contains the extension.  My test script downloads a file from the internet and prints all the phone numbers in it.</source>
          <target state="translated">이를 테스트하기위한 펄 스크립트가있다. 일치하면 $ 1에 지역 번호가 포함되고 $ 2와 $ 3에 전화 번호가 포함되며 $ 5에 내선 번호가 포함됩니다. 내 테스트 스크립트는 인터넷에서 파일을 다운로드하고 그 안에있는 모든 전화 번호를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="22b476064f663edfa8252e9e9661ecf3d4ed6339" translate="yes" xml:space="preserve">
          <source>Here's a regex for a 7 or 10 digit number, with extensions allowed, delimiters are spaces, dashes, or periods:</source>
          <target state="translated">7 자리 또는 10 자리 숫자에 대한 정규식은 다음과 같습니다. 확장자는 허용되고 구분자는 공백, 대시 또는 마침표입니다.</target>
        </trans-unit>
        <trans-unit id="eacc65b2c702c38624f0c21b9e494415538871b2" translate="yes" xml:space="preserve">
          <source>Here's a wonderful pattern that most closely matched the validation that I needed to achieve. I'm not the original author, but I think it's well worth sharing as I found this problem to be very complex and without a concise or widely useful answer.</source>
          <target state="translated">여기에 내가 달성 해야하는 검증과 가장 일치하는 훌륭한 패턴이 있습니다. 나는 원래의 저자는 아니지만이 문제가 매우 복잡하고 간결하거나 유용한 답변이 없다는 것을 알았으므로 공유 할 가치가 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="87bb8df3e3750778782fc993b14771b25c1ae9e1" translate="yes" xml:space="preserve">
          <source>Here's my best try so far. It handles the formats above but I'm sure I'm missing some other possible formats.</source>
          <target state="translated">지금까지 최선을 다하겠습니다. 위의 형식을 처리하지만 다른 가능한 형식이 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="3d4c8ec063c8453425fd199339fa0dc71fd1084a" translate="yes" xml:space="preserve">
          <source>Here's one that works well in JavaScript. It's in a string because that's what the Dojo widget was expecting.</source>
          <target state="translated">JavaScript에서 잘 작동하는 것이 있습니다. Dojo 위젯이 기대했던 것이기 때문에 문자열에 있습니다.</target>
        </trans-unit>
        <trans-unit id="022980180be3a3d695520932cf3a4e6a1f9d42d8" translate="yes" xml:space="preserve">
          <source>Here's what I used for a client project recently, where we had to convert all phone numbers in any format to tel: links.</source>
          <target state="translated">다음은 최근에 클라이언트 프로젝트에 사용한 것으로 모든 형식의 전화 번호를 tel : 링크로 변환해야했습니다.</target>
        </trans-unit>
        <trans-unit id="f0ac0dbc5713c70f3f68911c8011ad8531f4bfc7" translate="yes" xml:space="preserve">
          <source>Honestly, I would recommend you don't try to validate phone numbers. Even if you could write a big, hairy validator that would allow all the different legitimate formats, it would end up allowing pretty much anything even remotely resembling a phone number in the first place.</source>
          <target state="translated">솔직히 전화 번호를 확인하지 않는 것이 좋습니다. 모든 다른 합법적 인 형식을 허용하는 크고 털이 많은 유효성 검사기를 작성할 수 있더라도 처음에는 전화 번호와 거의 닮은 거의 모든 것이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="63826e2f09a3eca5122612b589a84c33d0624c30" translate="yes" xml:space="preserve">
          <source>How to validate phone numbers using regex</source>
          <target state="translated">정규식을 사용하여 전화 번호를 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="5a7c6a46c8b444a39962acafbea226f89aa12a89" translate="yes" xml:space="preserve">
          <source>I answered this question on another SO question before deciding to also include my answer as an answer on this thread, because no one was addressing how to require/not require items, just handing out regexs:
&lt;a href=&quot;https://stackoverflow.com/questions/25184823/regex-working-wrong-matching-unexpected-things/25298604#25298604&quot;&gt;Regex working wrong, matching unexpected things&lt;/a&gt;</source>
          <target state="translated">아무도이 스레드에 대한 답변으로 내 답변을 포함 시키기로 결정하기 전에 다른 SO 질문에 대해이 질문에 대답했습니다.</target>
        </trans-unit>
        <trans-unit id="0bfbfe611624b3a8f88a726cb01f206cb9f27249" translate="yes" xml:space="preserve">
          <source>I believe the &lt;a href=&quot;http://search.cpan.org/~kennedyh/Number-Phone-US-1.5/&quot;&gt;Number::Phone::US&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/~abigail/Regexp-Common-2.122/&quot;&gt;Regexp::Common&lt;/a&gt;  (particularly the source of &lt;a href=&quot;http://search.cpan.org/~abigail/Regexp-Common-2.122/lib/Regexp/Common/URI/RFC2806.pm&quot;&gt;Regexp::Common::URI::RFC2806&lt;/a&gt;) Perl modules could help.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/~kennedyh/Number-Phone-US-1.5/&quot;&gt;Number :: Phone :: US&lt;/a&gt; 및 &lt;a href=&quot;http://search.cpan.org/~abigail/Regexp-Common-2.122/&quot;&gt;Regexp :: Common&lt;/a&gt; (특히 &lt;a href=&quot;http://search.cpan.org/~abigail/Regexp-Common-2.122/lib/Regexp/Common/URI/RFC2806.pm&quot;&gt;Regexp :: Common :: URI :: RFC2806&lt;/a&gt; ) Perl 모듈이 도움이 될 수 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ccc9e077f990fddb26d3b34eeba471be5b1cec42" translate="yes" xml:space="preserve">
          <source>I found this to be something interesting. I have not tested it but it looks as if it would work</source>
          <target state="translated">나는 이것이 흥미있는 것을 발견했다. 테스트하지는 않았지만 작동하는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="10e25061e0c6d708c7ba4765226d048f5fdd6132" translate="yes" xml:space="preserve">
          <source>I found this to work quite well:</source>
          <target state="translated">나는 이것이 잘 작동한다는 것을 알았다.</target>
        </trans-unit>
        <trans-unit id="b71f940c0579bff4446fcab0a0dcfce1cf7dc5fa" translate="yes" xml:space="preserve">
          <source>I interpret the question as looking for a broadly valid pattern, which may not be internally consistent - for example having a valid set of numbers, but not validating that the trunk-line, exchange, etc. to the valid pattern for the country code prefix.</source>
          <target state="translated">나는 질문이 광범위하게 유효한 패턴을 찾는 것으로 해석합니다. 예를 들어 유효한 숫자 세트를 가지고 있지만 간선, 교환 등이 국가 코드 접두사의 유효한 패턴으로 검증되지 않는 등 내부적으로 일관성이 없을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75d1417c12f58c1fc82eee361d8bf8f15542070f" translate="yes" xml:space="preserve">
          <source>I was struggling with the same issue, trying to make my application future proof, but these guys got me going in the right direction. I'm not actually checking the number itself to see if it works or not, I'm just trying to make sure that a series of numbers was entered that may or may not have an extension.</source>
          <target state="translated">나는 같은 문제로 고생하면서 내 응용 프로그램을 미래의 증거로 만들려고 노력했지만이 사람들은 올바른 방향으로 나아갔습니다. 실제로 숫자 자체를 검사하여 작동하는지 여부를 확인하는 것이 아니라 확장 프로그램이 있거나없는 일련의 숫자가 입력되었는지 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="fa0d64ff8c3a2270191366f37f0e3b07e104d40f" translate="yes" xml:space="preserve">
          <source>I work for a market research company and we have to filter these types of input alllll the time. You're complicating it too much. Just strip the non-alphanumeric chars, and see if there's an extension.</source>
          <target state="translated">저는 시장 조사 회사에서 일하고 있으며 이러한 유형의 입력을 시간별로 필터링해야합니다. 너무 복잡합니다. 영숫자가 아닌 문자를 제거하고 확장명이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="36f85d8b9ecf98746ea135d39fc26f6f094fc9c2" translate="yes" xml:space="preserve">
          <source>I would also consider any of the following as valid entries on a web site:</source>
          <target state="translated">또한 다음 중 하나를 웹 사이트의 유효한 항목으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="b240d6f282239cc116368553457e618099c93be0" translate="yes" xml:space="preserve">
          <source>I would also suggest looking at the &quot;&lt;a href=&quot;https://github.com/googlei18n/libphonenumber&quot;&gt;libphonenumber&lt;/a&gt;&quot; Google Library. I know it is not regex but it does exactly what you want.</source>
          <target state="translated">또한 &quot; &lt;a href=&quot;https://github.com/googlei18n/libphonenumber&quot;&gt;libphonenumber&lt;/a&gt; &quot;Google 라이브러리를 참조하십시오. 나는 그것이 정규 표현식이 아니라는 것을 알고 있지만 정확히 원하는 것을합니다.</target>
        </trans-unit>
        <trans-unit id="2980a1a622568116f14431287d2474d7ffb950a1" translate="yes" xml:space="preserve">
          <source>I would suggest skipping a simple regular expression to test your phone number against, and using a library such as Google's &lt;a href=&quot;https://github.com/googlei18n/libphonenumber&quot;&gt;&lt;code&gt;libphonenumber&lt;/code&gt; (link to GitHub project)&lt;/a&gt;.</source>
          <target state="translated">전화 번호를 테스트하기 위해 간단한 정규 표현식을 건너 뛰고 Google의 &lt;a href=&quot;https://github.com/googlei18n/libphonenumber&quot;&gt; &lt;code&gt;libphonenumber&lt;/code&gt; (GitHub 프로젝트 링크)&lt;/a&gt; 와 같은 라이브러리를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="66b66c47f3306e9d78e3a3bf13fb6788b912c88f" translate="yes" xml:space="preserve">
          <source>I wrote simpliest (although i didn't need dot in it).</source>
          <target state="translated">나는 가장 간단하게 썼다 (점은 필요하지 않지만).</target>
        </trans-unit>
        <trans-unit id="4c2424d48183efdb09767b99a30b1f0659f9ef5a" translate="yes" xml:space="preserve">
          <source>I'll answer with my current attempt, but I'm hoping somebody has something better and/or more elegant.</source>
          <target state="translated">나는 현재의 시도로 대답 할 것이지만, 누군가가 더 좋고 우아한 것을 기대하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c90880b06f56cf763af15f83349452b90003c599" translate="yes" xml:space="preserve">
          <source>I'm trying to put together a comprehensive regex to validate phone numbers. Ideally it would handle international formats, but it must handle US formats, including the following:</source>
          <target state="translated">전화 번호를 확인하기 위해 포괄적 인 정규식을 작성하려고합니다. 이상적으로는 국제 형식을 처리하지만 다음을 포함하여 미국 형식을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="8994625e0238ac85a4b3f559a90a21a2acde5fe4" translate="yes" xml:space="preserve">
          <source>If the users want to give you their phone numbers, then trust them to get it right.  If they do not want to give it to you then forcing them to enter a valid number will either send them to a competitor's site or make them enter a random string that fits your regex.  I might even be tempted to look up the number of a premium rate horoscope hotline and enter that instead.</source>
          <target state="translated">사용자가 전화 번호를 알려주려면 전화 번호를 올바르게 입력해야합니다. 그들이 당신에게 그것을주고 싶지 않다면 유효한 숫자를 입력하도록 강요하면 경쟁 업체의 사이트로 보내거나 정규식에 맞는 임의의 문자열을 입력하게됩니다. 나는 심지어 프리미엄 운세 운세 핫라인의 수를 찾아보고 대신 입력하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f091b9560d69c1ee36d37625cbaf5953d8340aa" translate="yes" xml:space="preserve">
          <source>If you are trying to validate user input, why not normalize the result and be done with it?  If the user puts in a number you can't recognize as a valid number, either save it as inputted or strip out undailable characters.  The &lt;a href=&quot;http://search.cpan.org/~cfaerber/Number-Phone-Normalize-0.20/lib/Number/Phone/Normalize.pm&quot;&gt;Number::Phone::Normalize&lt;/a&gt; Perl module could be a source of inspiration.</source>
          <target state="translated">사용자 입력의 유효성을 검사하려는 경우 결과를 정규화하여 수행하지 않는 이유는 무엇입니까? 사용자가 숫자를 입력하면 유효한 숫자로 인식 할 수 없으며 입력 한대로 저장하거나 실패 할 수없는 문자를 제거하십시오. &lt;a href=&quot;http://search.cpan.org/~cfaerber/Number-Phone-Normalize-0.20/lib/Number/Phone/Normalize.pm&quot;&gt;Number :: Phone :: Normalize&lt;/a&gt; Perl 모듈은 영감의 원천이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b02777a3e87266f7dd95c27f23a29f5651cc719f" translate="yes" xml:space="preserve">
          <source>If you just want to verify you don't have random garbage in the field (i.e., from form spammers) this regex should do nicely:</source>
          <target state="translated">필드에 임의 가비지가 없는지 (예 : 양식 스패머) 확인하려면이 정규식을 잘 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="15a209b828c8667e424aefd50e088a7ea554abc4" translate="yes" xml:space="preserve">
          <source>If you want a hyphen, just type &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;[-]&lt;/code&gt; . If you do not put it first or last in a series of other characters, though, you may need to escape it:  &lt;code&gt;\-&lt;/code&gt;</source>
          <target state="translated">하이픈을 원하면 &lt;code&gt;-&lt;/code&gt; 또는 &lt;code&gt;[-]&lt;/code&gt; 만 입력하십시오. 그러나 일련의 다른 문자를 맨 처음이나 마지막에 넣지 않으면 이스케이프해야 할 수도 있습니다. &lt;code&gt;\-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd3c2186bbca3a97b7824576c949f6ea54f4fa75" translate="yes" xml:space="preserve">
          <source>If you want anything to be optional, put a &lt;code&gt;?&lt;/code&gt; after it</source>
          <target state="translated">선택 사항 인 것을 원한다면 &lt;code&gt;?&lt;/code&gt; 그 후</target>
        </trans-unit>
        <trans-unit id="718e26645a3839ca2b0ddaaed52e50182e77cee4" translate="yes" xml:space="preserve">
          <source>If you want specific numbers to match a slot, enter them: &lt;code&gt;[246]&lt;/code&gt; will require a 2, 4, or 6.  &lt;code&gt;[77|78]&lt;/code&gt; will require 77 or 78.</source>
          <target state="translated">특정 숫자가 슬롯과 일치하도록하려면 해당 숫자를 입력하십시오. &lt;code&gt;[246]&lt;/code&gt; 은 2, 4 또는 6이 필요합니다. &lt;code&gt;[77|78]&lt;/code&gt; 은 77 또는 78이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2ac71d06ab1140a038c4a6d174e05d44ca01d64e" translate="yes" xml:space="preserve">
          <source>If you want to accept different choices in a slot, put brackets around the options: &lt;code&gt;[-.\s]&lt;/code&gt; will require a hyphen, period, or space.  A question mark after the last bracket will make all of those optional for that slot.</source>
          <target state="translated">슬롯에서 다른 항목을 선택하려면 옵션 주위에 대괄호를 넣으십시오. &lt;code&gt;[-.\s]&lt;/code&gt; 에는 하이픈, 마침표 또는 공백이 필요합니다. 마지막 대괄호 뒤의 물음표는 해당 슬롯에 대한 모든 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="4a7d10f24f70f4d0fedc28310dd1999c71ad4928" translate="yes" xml:space="preserve">
          <source>If you want to maintain per digit rules (such as in US Area Codes and Prefixes (exchange codes) must fall in the range of 200-999) well, good luck to you. Maintaining a complex rule-set which could be outdated at any point in the future by any country in the world does not sound fun.</source>
          <target state="translated">자릿수 별 규칙 (예 : 미국 지역 코드 및 접두사 (교환 코드) 등)을 유지하려면 200-999 범위 내에 있어야합니다. 세계 어느 나라에서나 미래에 구식이 될 수있는 복잡한 규칙 집합을 유지하는 것은 재미 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e90127b7b04fe9a92804e9a02c9e0cdda1e82db" translate="yes" xml:space="preserve">
          <source>If you want to require a space, use:  &lt;code&gt;[\s]&lt;/code&gt; or &lt;code&gt;\s&lt;/code&gt;</source>
          <target state="translated">공백이 필요하면 &lt;code&gt;[\s]&lt;/code&gt; 또는 &lt;code&gt;\s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5ed6e18f9c088af83ca192a802e402a6e7aacdc" translate="yes" xml:space="preserve">
          <source>If you want to require parenthesis, use:  &lt;code&gt;[(]&lt;/code&gt; and &lt;code&gt;[)]&lt;/code&gt; .  Using &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; is ugly and can make things confusing.</source>
          <target state="translated">괄호가 필요한 경우 &lt;code&gt;[(]&lt;/code&gt; 및 &lt;code&gt;[)]&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;\(&lt;/code&gt; 와 &lt;code&gt;\)&lt;/code&gt; 를 사용하는 것은 추악하고 혼란 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb2fb6da06f21696f5d1b2691d120c610e9009e5" translate="yes" xml:space="preserve">
          <source>If you're talking about form validation, the regexp to validate correct meaning as well as correct data is going to be extremely complex because of varying country and provider standards. It will also be hard to keep up to date.</source>
          <target state="translated">양식 유효성 검사에 대해 이야기하는 경우 국가 및 공급자 표준이 다르기 때문에 올바른 의미뿐만 아니라 올바른 데이터의 유효성을 검사하는 정규 표현식은 매우 복잡 할 것입니다. 최신 상태를 유지하는 것도 어려울 것입니다.</target>
        </trans-unit>
        <trans-unit id="87fcc4d677e51bf63d0ac99b2817edc349e9cb7a" translate="yes" xml:space="preserve">
          <source>In my opinion, the most elegant solution is to validate a minimum length, nothing more.</source>
          <target state="translated">제 생각에는 가장 우아한 해결책은 최소 길이를 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="43e79cfa9396bc345e5838e3f37973a6c38c5e5f" translate="yes" xml:space="preserve">
          <source>Introducing libphonenumber!</source>
          <target state="translated">libphonenumber를 소개합니다!</target>
        </trans-unit>
        <trans-unit id="a4b27df698d7725b55128784e85bbae9b949ab77" translate="yes" xml:space="preserve">
          <source>Is it a worry that there may need to be a pause and then more keys entered? Or something like 555-1212 (wait for the beep) 123?</source>
          <target state="translated">일시 중지 한 다음 더 많은 키를 입력해야 할까봐 걱정됩니까? 아니면 555-1212 (경고음 기다림) 123 같은 것입니까?</target>
        </trans-unit>
        <trans-unit id="3eb85813d690117d00ba8ce9afa7e769117ad047" translate="yes" xml:space="preserve">
          <source>It is up to you to sanitize it for display. After validating it &lt;em&gt;could&lt;/em&gt; be a number though.</source>
          <target state="translated">표시를 위해 소독하는 것은 귀하의 책임입니다. 유효성 검사 후에는 숫자 일 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="d819d73918d144bf36182bd54a80f94464fc719b" translate="yes" xml:space="preserve">
          <source>It matches a 10 digit North America NANP number with optional extension. Spaces, dashes and periods are accepted delimiters.</source>
          <target state="translated">선택적 확장명을 가진 10 자리 북미 NANP 번호와 일치합니다. 공백, 대시 및 마침표는 구분 기호로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f5bbec380484c3069324749e5a035edf5e474e6" translate="yes" xml:space="preserve">
          <source>It should be compatible with international numbers and localization formats. Do you foresee any need to allow square, curly, or angled brackets for some regions? (currently they aren't included).</source>
          <target state="translated">국제 번호 및 현지화 형식과 호환되어야합니다. 일부 지역에 대괄호, 중괄호 또는 꺾쇠 괄호를 사용해야 할 필요성이 있습니까? (현재는 포함되어 있지 않습니다).</target>
        </trans-unit>
        <trans-unit id="e5b6a04692150ee396c21b4a57672a87a7ab4f20" translate="yes" xml:space="preserve">
          <source>It turns out that there's something of a spec for this, at least for North America, called the &lt;a href=&quot;http://en.wikipedia.org/wiki/North_American_Numbering_Plan&quot;&gt;NANP&lt;/a&gt;.</source>
          <target state="translated">적어도 북미에 대해서는 &lt;a href=&quot;http://en.wikipedia.org/wiki/North_American_Numbering_Plan&quot;&gt;NANP&lt;/a&gt; 라는 사양이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6588a0770d9f9cf9c4f30b6c0b8040981a6dcb51" translate="yes" xml:space="preserve">
          <source>It works for these number formats:</source>
          <target state="translated">다음 숫자 형식에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9f40c848887d7e0847c7b4c6abe28ac113814717" translate="yes" xml:space="preserve">
          <source>Like validating email addresses, even if you have a valid result you can't know if it's assigned to someone until you try it.</source>
          <target state="translated">이메일 주소 확인과 마찬가지로, 유효한 결과가 있더라도 시도 할 때까지 누군가에게 할당되었는지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7057878a5e038957345085ab1b05d5b33c955fd7" translate="yes" xml:space="preserve">
          <source>Link:  &lt;a href=&quot;http://www.regexr.com/3bp4b&quot;&gt;http://www.regexr.com/3bp4b&lt;/a&gt;</source>
          <target state="translated">링크 : &lt;a href=&quot;http://www.regexr.com/3bp4b&quot;&gt;http://www.regexr.com/3bp4b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="71cb6484edba6b6c887668edf2ee21f03c120a6e" translate="yes" xml:space="preserve">
          <source>Make sure to use global AND multiline flags to make sure.</source>
          <target state="translated">전역 및 여러 줄 플래그를 사용하여 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="776c1c2a1fe04524e681fe8e5cc65db0cf1e92eb" translate="yes" xml:space="preserve">
          <source>Must end with a digit, can begin with ( or + or a digit, and may contain + - ( or )</source>
          <target state="translated">숫자로 끝나야하며 (또는 + 또는 숫자로 시작할 수 있으며 +-(또는)를 포함 할 수 있음</target>
        </trans-unit>
        <trans-unit id="0b11df816cc9038c4fd5a10dca5adfa322783d1f" translate="yes" xml:space="preserve">
          <source>My attempt at an unrestrictive regex:</source>
          <target state="translated">무제한 정규식에 대한 나의 시도 :</target>
        </trans-unit>
        <trans-unit id="67ec4a620ab433ec5e022254965558a542cb2a2b" translate="yes" xml:space="preserve">
          <source>My gut feeling is reinforced by the amount of replies to this topic - that there is a virtually infinite number of solutions to this problem, none of which are going to be elegant.</source>
          <target state="translated">내 문제는이 주제에 대한 답변의 양에 의해 강화됩니다.이 문제에 대한 해결책은 거의 무한하지만 그 어느 것도 우아하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a37dbb17a66518011d677e5e44077ec82b6b3da" translate="yes" xml:space="preserve">
          <source>My inclination is to agree that stripping non-digits and just accepting what's there is best. Maybe to ensure at least a couple digits are present, although that does prohibit something like an alphabetic phone number &quot;ASK-JAKE&quot; for example.</source>
          <target state="translated">내 성향은 숫자가 아닌 숫자를 제거하고 가장 좋은 것을 받아들이는 것에 동의하는 것입니다. 예를 들어 알파벳 전화 번호 &quot;ASK-JAKE&quot;와 같은 것을 금지하지만 적어도 두 자리 숫자가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dab2d18b0aca7dc5ec44365bf7d787cfa5b0bdce" translate="yes" xml:space="preserve">
          <source>Negative:</source>
          <target state="translated">Negative:</target>
        </trans-unit>
        <trans-unit id="95942b328963edd3d4351c3c56ba69c40d14e793" translate="yes" xml:space="preserve">
          <source>North America is straightforward, and for international I prefer to use an 'idiomatic' pattern which covers the ways in which people specify and remember their numbers:</source>
          <target state="translated">북미는 간단하며 국제적으로 사람들이 숫자를 지정하고 기억하는 방식을 다루는 '아이디 오 매틱'패턴을 사용하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="d51e891f1e5d2aee821d8fd4aa7ce56bb38b96a4" translate="yes" xml:space="preserve">
          <source>Note that it doesn't have any special rules for how many digits, or what numbers are valid in those digits, it just verifies that only digits, parenthesis, dashes, plus, space, pound,  asterisk, period, comma, or the letters &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt; are present.</source>
          <target state="translated">숫자의 수 또는 해당 숫자에서 유효한 숫자에 대한 특별한 규칙이 없으며 숫자, 괄호, 대시, 더하기, 공백, 파운드, 별표, 마침표, 쉼표 또는 문자 만 확인합니다. &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="adeacbad8873a5fd52f8f94e72b56b3d1471dbd6" translate="yes" xml:space="preserve">
          <source>Note that stripping &lt;code&gt;()&lt;/code&gt; characters does not work for a style of writing UK numbers that is common: &lt;code&gt;+44 (0) 1234 567890&lt;/code&gt; which means dial either the international number:</source>
          <target state="translated">일반적인 영국 번호를 쓰는 스타일에는 &lt;code&gt;()&lt;/code&gt; 문자를 제거 할 수 없습니다. &lt;code&gt;+44 (0) 1234 567890&lt;/code&gt; : 국제 번호로 전화하십시오.</target>
        </trans-unit>
        <trans-unit id="ca024c03255c776ed9cde0669572cfeef6b6693f" translate="yes" xml:space="preserve">
          <source>On $n, it saves:</source>
          <target state="translated">$ n이면 다음을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="57b3f19efda3db9541743ca20805fdc3cc6037b9" translate="yes" xml:space="preserve">
          <source>Original source: &lt;a href=&quot;http://www.regexr.com/38pvb&quot;&gt;http://www.regexr.com/38pvb&lt;/a&gt;</source>
          <target state="translated">원본 출처 : &lt;a href=&quot;http://www.regexr.com/38pvb&quot;&gt;http://www.regexr.com/38pvb&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7daf403c7589f4927632ed3b6af762a992f09b78" translate="yes" xml:space="preserve">
          <source>PHP</source>
          <target state="translated">PHP</target>
        </trans-unit>
        <trans-unit id="bb64f436897b16df14b3e811de773d2ebaf52e22" translate="yes" xml:space="preserve">
          <source>PHP function to replace all phone numbers with tel: links (in case anyone is curious):</source>
          <target state="translated">모든 전화 번호를 tel : 링크로 바꾸는 PHP 기능 (누군가 궁금한 경우) :</target>
        </trans-unit>
        <trans-unit id="0ea51c7a617654993771490ea9e81d30a03af872" translate="yes" xml:space="preserve">
          <source>Parsing/formatting/validating phone numbers for all countries/regions of the world.</source>
          <target state="translated">전 세계 모든 국가 / 지역의 전화 번호 구문 분석 / 포맷 / 확인</target>
        </trans-unit>
        <trans-unit id="8961d3bf56ef1c18ef5c831ba0838e8b1f85e5de" translate="yes" xml:space="preserve">
          <source>Phone number</source>
          <target state="translated">전화 번호</target>
        </trans-unit>
        <trans-unit id="78efb8bbd67c1896fb22b7034ecc0ee8da90f38c" translate="yes" xml:space="preserve">
          <source>Positive:</source>
          <target state="translated">Positive:</target>
        </trans-unit>
        <trans-unit id="8e54c9b1c2dfef11b55a9b78e13d7252f5ad62a5" translate="yes" xml:space="preserve">
          <source>Quick cheat sheet</source>
          <target state="translated">빠른 치트 시트</target>
        </trans-unit>
        <trans-unit id="a16b01bb4a0955a42f3184d251b7508ef3590ed5" translate="yes" xml:space="preserve">
          <source>Regex:</source>
          <target state="translated">Regex:</target>
        </trans-unit>
        <trans-unit id="0c7929be80317c9b5ed14c7e723d5b1c7863b671" translate="yes" xml:space="preserve">
          <source>Rejects:</source>
          <target state="translated">Rejects:</target>
        </trans-unit>
        <trans-unit id="5db41536d0a17a221c98fbfddb6fbfb0466e104f" translate="yes" xml:space="preserve">
          <source>So far, it's been working with everything they've thrown at it, but if errors come up, I'll update this answer.</source>
          <target state="translated">지금까지는 그들이 던진 모든 것에 대해 노력하고 있지만 오류가 발생하면이 답변을 업데이트 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0dd4fff1de550144cf86eec0812f147ee12d15f7" translate="yes" xml:space="preserve">
          <source>So not only do you learn if the phone number is valid (which it is), but you also get consistent phone number formatting in your locale.</source>
          <target state="translated">따라서 전화 번호가 유효한지 여부를 알 수있을뿐만 아니라 로캘에서 일관된 전화 번호 형식을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="4f665cfaf200a12ba9fa162f8ca4bf502423e54b" translate="yes" xml:space="preserve">
          <source>Start the expression:  &lt;code&gt;/^&lt;/code&gt;</source>
          <target state="translated">표현식을 시작하십시오. &lt;code&gt;/^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd1fbc9a4c8077728d7d41f50640c260a78a08c1" translate="yes" xml:space="preserve">
          <source>Test it here: &lt;a href=&quot;http://refiddle.com/1ox&quot;&gt;http://refiddle.com/1ox&lt;/a&gt;</source>
          <target state="translated">여기에서 테스트하십시오 : &lt;a href=&quot;http://refiddle.com/1ox&quot;&gt;http://refiddle.com/1ox&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3dd5ed2b006a2c4e4eda78dea03343c7eac1b057" translate="yes" xml:space="preserve">
          <source>The North American pattern makes sure that if one parenthesis is included both are.  The international accounts for an optional initial '+' and country code.  After that, you're in the idiom.  Valid matches would be:</source>
          <target state="translated">북미 패턴은 하나의 괄호가 포함되어 있으면 둘 다 포함되도록합니다. 국제은 선택적인 초기 '+'및 국가 코드를 설명합니다. 그 후, 당신은 관용구에 있습니다. 유효한 일치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7fd81a8aaf6a57b5ddc89278b1a6384f8deb0e42" translate="yes" xml:space="preserve">
          <source>The biggest problem with phone number validation is it is very culturally dependant.</source>
          <target state="translated">전화 번호 확인의 가장 큰 문제는 문화적으로 매우 다르다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cdbd51aa8cc8844a78771ccfa80d1d540ebac280" translate="yes" xml:space="preserve">
          <source>The first one will match ANY two digit country code, while the second one will match the Philippine country code exclusively.</source>
          <target state="translated">첫 번째는 두 자리 국가 코드와 일치하며 두 번째는 필리핀 국가 코드와 독점적으로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="62692686df1c5b3b8d5898482ac3d6f07ff6614f" translate="yes" xml:space="preserve">
          <source>The following regex will catch widely used number and character combinations in a variety of global phone number formats:</source>
          <target state="translated">다음 정규식은 다양한 전 세계 전화 번호 형식으로 널리 사용되는 숫자 및 문자 조합을 포착합니다.</target>
        </trans-unit>
        <trans-unit id="8f012cc502a1dd6af0cfc11025b7261b5cee93c2" translate="yes" xml:space="preserve">
          <source>The question should probably be specified in a bit more detail to explain the purpose of validating the numbers.  For instance, 911 is a valid number in the US, but 911x isn't for any value of x.  That's so that the phone company can calculate when you are done dialing.  There are several variations on this issue.  But your regex doesn't check the area code portion, so that doesn't seem to be a concern.</source>
          <target state="translated">질문은 숫자를 검증하는 목적을 설명하기 위해 조금 더 자세하게 지정해야합니다. 예를 들어 911은 미국에서 유효한 숫자이지만 911x는 x 값이 아닙니다. 전화 회사에서 전화 걸기 완료 시점을 계산할 수 있습니다. 이 문제에는 몇 가지 변형이 있습니다. 그러나 정규 표현식은 지역 코드 부분을 확인하지 않으므로 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f477bd6da6989ac5eedab1067bc8f2e905fa3fb" translate="yes" xml:space="preserve">
          <source>Then when you display, reformat to your hearts content. e.g.</source>
          <target state="translated">그런 다음 표시 할 때 하트 컨텐츠로 다시 포맷하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="ac2c585e0fd46195e564ef49c2fcf2718c0161e3" translate="yes" xml:space="preserve">
          <source>Then, you end up with values like:</source>
          <target state="translated">그런 다음 다음과 같은 값으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="4672a7b3fc8f3d7ccfae109d1c8e1a317b117d04" translate="yes" xml:space="preserve">
          <source>There is also a JQuery solution on that link.</source>
          <target state="translated">해당 링크에는 JQuery 솔루션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="15129efc19b445979961f54aa768b66bb0b78f10" translate="yes" xml:space="preserve">
          <source>They even go over how to mask phone number inputs in their tutorial.</source>
          <target state="translated">심지어 튜토리얼에서 전화 번호 입력을 숨기는 방법도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f75317c94b401f28a1651a9ef34023d46532b9a7" translate="yes" xml:space="preserve">
          <source>This is a simple Regular Expression pattern for Philippine Mobile Phone Numbers:</source>
          <target state="translated">다음은 필리핀 휴대 전화 번호의 간단한 정규식 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="a70496b978a05b65591b54c2cb906b99688e1181" translate="yes" xml:space="preserve">
          <source>This matches:</source>
          <target state="translated">이것은 다음과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="96de1b265278b3f71ca16feea1983e3c0ab2c655" translate="yes" xml:space="preserve">
          <source>This may be biased as my experience is limited to North America, Europe and a small bit of Asia.</source>
          <target state="translated">나의 경험이 북미, 유럽 및 작은 아시아 지역으로 제한되어 있기 때문에 이것은 편향 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5870bfaa0b34c1097aef11523676e1529cef19b" translate="yes" xml:space="preserve">
          <source>Unless you are certain that you are always going to be accepting numbers from one locale, and they are always going to be in one format, I would heavily suggest not writing your own code for this, and using libphonenumber for validating and displaying phone numbers.</source>
          <target state="translated">항상 한 로케일의 숫자를 받아들이고 항상 하나의 형식으로되어 있다고 확신하지 않는 한, 자신의 코드를 작성하지 말고 libphonenumber를 사용하여 전화 번호를 확인하고 표시하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dbce309ff66488b404ed28d71ac60ebe021bd617" translate="yes" xml:space="preserve">
          <source>Use the first one to keep the digit groups together, which may give formatting clues. Use the second one to trivially toss all non-digits.</source>
          <target state="translated">첫 번째 그룹을 사용하여 숫자 그룹을 함께 유지하면 서식 힌트를 얻을 수 있습니다. 두 번째 숫자를 사용하여 모든 비 숫자를 사소하게 던지십시오.</target>
        </trans-unit>
        <trans-unit id="cdfacd1928d4950d5111c4de6bc9d502c037b588" translate="yes" xml:space="preserve">
          <source>Using one of your more complex examples, &lt;code&gt;1-234-567-8901 x1234&lt;/code&gt;, you get &lt;a href=&quot;https://libphonenumber.appspot.com/phonenumberparser?number=234-567-8901+x123&amp;amp;country=US&amp;amp;geocodingLocale=en-US&quot;&gt;the following data out of &lt;code&gt;libphonenumber&lt;/code&gt; (link to online demo)&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;1-234-567-8901 x1234&lt;/code&gt; 보다 복잡한 예제 중 하나를 사용하여 &lt;a href=&quot;https://libphonenumber.appspot.com/phonenumberparser?number=234-567-8901+x123&amp;amp;country=US&amp;amp;geocodingLocale=en-US&quot;&gt; &lt;code&gt;libphonenumber&lt;/code&gt; (온라인 데모 링크)에서 다음 데이터&lt;/a&gt; 를 얻 습니다 .</target>
        </trans-unit>
        <trans-unit id="bfbdab4a2b4c45896d02b09374e7fedf55af54e2" translate="yes" xml:space="preserve">
          <source>Worst case scenario if the user had to pull an unformatted number from the XML file, they would still just type the numbers into the phone's numberpad &lt;code&gt;012345678x5&lt;/code&gt;, no real reason to keep it pretty. That kind of RegEx would come out something like this for me:</source>
          <target state="translated">사용자가 XML 파일에서 형식화되지 않은 숫자를 가져와야하는 최악의 시나리오는 여전히 숫자를 휴대 전화의 숫자 키패드 &lt;code&gt;012345678x5&lt;/code&gt; 에 입력 하면 아무 문제가 없습니다. 그런 종류의 RegEx는 다음과 같이 나옵니다.</target>
        </trans-unit>
        <trans-unit id="b47b766208f8ce2f500bfcf69a6ee1c98720e422" translate="yes" xml:space="preserve">
          <source>You can change \W* to \s*\W?\s* in the regex to tighten it up a bit.  I wasn't thinking of the regex in terms of, say, validating user input on a form when I wrote it, but this change makes it possible to use the regex for that purpose.</source>
          <target state="translated">정규식에서 \ W *를 \ s * \ W? \ s *로 변경하여 조금 강화할 수 있습니다. 예를 들어 양식을 작성할 때 사용자 입력의 유효성을 검사하는 것과 관련하여 정규 표현식을 생각하지 않았지만이 변경으로 인해 정규식을 해당 목적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4fc38b4c1497d7649b3704f8dddf5c49b098519" translate="yes" xml:space="preserve">
          <source>You can test it on &lt;a href=&quot;https://www.regexpal.com/?fam=99127&quot;&gt;https://www.regexpal.com/?fam=99127&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.regexpal.com/?fam=99127&quot;&gt;https://www.regexpal.com/?fam=99127에서&lt;/a&gt; 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77470b2cf4d80e511f5d0478505bf5f48f4b2324" translate="yes" xml:space="preserve">
          <source>You need to specify exactly what you want. What are legal delimiters? Spaces, dashes, and periods? No delimiter allowed? Can one mix delimiters (e.g., +0.111-222.3333)? How are extensions (e.g., 111-222-3333 x 44444) going to be handled? What about special numbers, like 911? Is the area code going to be optional or required?</source>
          <target state="translated">원하는 것을 정확하게 지정해야합니다. 법적 구분 기호 란 무엇입니까? 공백, 대시 및 마침표? 구분자가 허용되지 않습니까? 하나의 혼합 분리 문자를 사용할 수 있습니까 (예 : + 0.111-222.3333)? 확장 (예 : 111-222-3333 x 44444)은 어떻게 처리됩니까? 911과 같은 특수 숫자는 어떻습니까? 지역 번호는 선택 사항입니까, 아니면 필수입니까?</target>
        </trans-unit>
        <trans-unit id="c4bf0ac578f43f9354484a128538d7dfc54a322f" translate="yes" xml:space="preserve">
          <source>You would probably be better off using a Masked Input for this.  That way users can ONLY enter numbers and you can format however you see fit.  I'm not sure if this is for a web application, but if it is there is a very click jQuery plugin that offers some options for doing this.</source>
          <target state="translated">이를 위해 마스크 입력을 사용하는 것이 좋습니다. 이런 식으로 사용자는 숫자 만 입력 할 수 있으며 원하는대로 서식을 지정할 수 있습니다. 이것이 웹 응용 프로그램을위한 것인지 확실하지 않지만 그것이있는 경우이 작업을 수행하는 몇 가지 옵션을 제공하는 매우 클릭 jQuery 플러그인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1fada8e271fdb48c0538ce4a226f71b9335690d" translate="yes" xml:space="preserve">
          <source>You'll have a hard time dealing with international numbers with a single/simple regex, see &lt;a href=&quot;https://stackoverflow.com/questions/41925/is-there-a-standard-for-storing-normalized-phone-numbers-in-a-database#41982&quot;&gt;this post&lt;/a&gt; on the difficulties of international (and even north american) phone numbers.</source>
          <target state="translated">단일 / 간단한 정규식으로 국제 전화 번호를 다루는 데 어려움을 겪을 수 있습니다. 국제 전화 번호 및 심지어는 북미 전화 번호의 어려움에 대한 &lt;a href=&quot;https://stackoverflow.com/questions/41925/is-there-a-standard-for-storing-normalized-phone-numbers-in-a-database#41982&quot;&gt;이 게시물&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b012622b5cd106aa994e423a68f75df6af5f2f04" translate="yes" xml:space="preserve">
          <source>You'll want to parse the first few digits to determine what the country code is, then act differently based on the country.</source>
          <target state="translated">처음 몇 자리 숫자를 구문 분석하여 국가 코드가 무엇인지 확인한 다음 국가에 따라 다르게 행동해야합니다.</target>
        </trans-unit>
        <trans-unit id="91e2eeadb5278bcea65ca02c9fe718f3f9995981" translate="yes" xml:space="preserve">
          <source>You've correctly identified that it's a tricky problem...</source>
          <target state="translated">까다로운 문제임을 올바르게 확인했습니다 ...</target>
        </trans-unit>
        <trans-unit id="20bc79407d96acddb6ff91f963f31fb77dc39a56" translate="yes" xml:space="preserve">
          <source>is a possible number but not a valid number. It also supports countries outside the US.</source>
          <target state="translated">가능한 숫자이지만 유효한 숫자는 아닙니다. 또한 미국 이외의 국가를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1acef3661e617a169f69157393e675bf232166c7" translate="yes" xml:space="preserve">
          <source>jQuery solution:</source>
          <target state="translated">jQuery 솔루션 :</target>
        </trans-unit>
        <trans-unit id="957cf2f4562af79ff7be8afd4a8ffa463ee6d543" translate="yes" xml:space="preserve">
          <source>libphonenumber also gives you many additional benefits, such as grabbing the location that the phone number is detected as being, and also getting the time zone information from the phone number:</source>
          <target state="translated">libphonenumber는 또한 전화 번호가 감지 된 위치를 파악하고 전화 번호에서 시간대 정보를 얻는 것과 같은 많은 추가 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="41fa97204f85b1ee91db07e4b13713003b0d9880" translate="yes" xml:space="preserve">
          <source>or in the UK dial &lt;code&gt;01234567890&lt;/code&gt;</source>
          <target state="translated">또는 영국에서는 &lt;code&gt;01234567890&lt;/code&gt; 으로 전화하십시오 .</target>
        </trans-unit>
        <trans-unit id="48b9fa27e31ebdae0101f95cfe08e08db7b95200" translate="yes" xml:space="preserve">
          <source>will match these:</source>
          <target state="translated">다음과 일치합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
