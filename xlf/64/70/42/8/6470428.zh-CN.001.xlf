<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/6470428">
    <body>
      <group id="6470428">
        <trans-unit id="4c5bf79f3c7090acea7b512de0735d716d9b5855" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTES:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTES:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab51a5a95212edc93655cc24b28a5f914b05fe4b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;try&lt;/code&gt; statement may have more than one except clause, to specify
  handlers for different exceptions. At most one handler will be
  executed. Handlers only handle exceptions that occur in the
  corresponding try clause, not in other handlers of the same try
  statement. An except clause may name multiple exceptions as a
  parenthesized tuple, for example:</source>
          <target state="translated">一个 &lt;code&gt;try&lt;/code&gt; 语句可能具有多个except子句，以指定不同异常的处理程序。 最多将执行一个处理程序。 处理程序仅处理在相应的try子句中发生的异常，而不处理同一try语句的其他处理程序中的异常。 exclude子句可以将多个异常命名为带括号的元组，例如：</target>
        </trans-unit>
        <trans-unit id="b049d4d6cc89ce4c077b28174e43420d6a4bc2cc" translate="yes" xml:space="preserve">
          <source>An except clause may name multiple exceptions as a parenthesized tuple, for example</source>
          <target state="translated">一个except子句可以将多个异常作为一个括号元组来命名,例如</target>
        </trans-unit>
        <trans-unit id="d8cb09e158212bf209b199530d94686ab9de6f8c" translate="yes" xml:space="preserve">
          <source>Best Practice</source>
          <target state="translated">最佳做法</target>
        </trans-unit>
        <trans-unit id="817b3c16209f1354c4647f0853f13398696d0d2f" translate="yes" xml:space="preserve">
          <source>But if I want to do the same thing inside two different exceptions, the best I can think of right now is to do this:</source>
          <target state="translated">但如果我想在两个不同的特例里面做同样的事情,我现在能想到的最好的办法就是这样做。</target>
        </trans-unit>
        <trans-unit id="7b2b69a15733371ac46b79803f3cc36eaf3ee9be" translate="yes" xml:space="preserve">
          <source>Catch multiple exceptions in one line (except block)</source>
          <target state="translated">在一行中捕捉多个异常(除块外)。</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="a09d8fe71d819660f00ffa7e97f5581804bd696d" translate="yes" xml:space="preserve">
          <source>Do this:</source>
          <target state="translated">做到这一点。</target>
        </trans-unit>
        <trans-unit id="13affbde8a1ea802fe72700ad8c2898507c9259c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/2/tutorial/errors.html#handling-exceptions&quot;&gt;Python documentation -&amp;gt; 8.3 Handling Exceptions&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;https://docs.python.org/2/tutorial/errors.html#handling-exceptions&quot;&gt;Python文档-&amp;gt; 8.3处理异常&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="2c6825f23083c7c1e94708a167000ee7ab04e1cf" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/3/tutorial/errors.html#handling-exceptions&quot;&gt;Python Documentation&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;https://docs.python.org/3/tutorial/errors.html#handling-exceptions&quot;&gt;Python文档&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="ded2ede429f8a9ed8ea8ab4b5cf15fba93ff8c57" translate="yes" xml:space="preserve">
          <source>Here's an example of simple usage:</source>
          <target state="translated">下面是一个简单的用法的例子。</target>
        </trans-unit>
        <trans-unit id="25401e6d560f2365c3f86f0125c7ffa7a861662a" translate="yes" xml:space="preserve">
          <source>How do I catch multiple exceptions in one line (except block)</source>
          <target state="translated">如何在一行中捕捉多个异常(块除外)?</target>
        </trans-unit>
        <trans-unit id="41760b6f3ebb7baac4ad211d7c27b7499d6d4e88" translate="yes" xml:space="preserve">
          <source>I can also do this:</source>
          <target state="translated">我也可以这样做。</target>
        </trans-unit>
        <trans-unit id="0690b8cb888193df03438257609795252e5473af" translate="yes" xml:space="preserve">
          <source>I know that I can do:</source>
          <target state="translated">我知道我可以做到。</target>
        </trans-unit>
        <trans-unit id="e1483e7b14daed222d2c8aef506327181c1b3c4a" translate="yes" xml:space="preserve">
          <source>I know that second one is not the best way to do this, but i'm just showing number of ways to do this thing.</source>
          <target state="translated">我知道第二种方法并不是最好的方法,但我只是展示了一些做这件事的方法。</target>
        </trans-unit>
        <trans-unit id="b902bf544387ba5c38f871fc0f6304eab8182ec2" translate="yes" xml:space="preserve">
          <source>I'm specifying only these exceptions to avoid hiding bugs, which if I encounter I expect the full stack trace from.</source>
          <target state="translated">我只指定了这些异常,以避免隐藏bug,如果遇到这些异常,我希望能得到完整的栈跟踪。</target>
        </trans-unit>
        <trans-unit id="a3befa5d5bde2dd45b6cb9e5cfdd8e2e675fb897" translate="yes" xml:space="preserve">
          <source>If you frequently use a large number of exceptions, you can pre-define a tuple, so you don't have to re-type them many times.</source>
          <target state="translated">如果你经常使用大量的异常,你可以预先定义一个元组,这样你就不需要多次重复输入。</target>
        </trans-unit>
        <trans-unit id="b7a540cdc02a3c56ceec5c00c10a8ed90a3556b7" translate="yes" xml:space="preserve">
          <source>If you just cannot tolerate a global variable, define it in main()
and pass it around where needed...</source>
          <target state="translated">如果你不能容忍一个全局变量,可以在main()中定义它,然后在需要的地方传递它。</target>
        </trans-unit>
        <trans-unit id="a9fb9bd20ca250fed19a43594b2578230ac37e6b" translate="yes" xml:space="preserve">
          <source>If you see the comma name assignment in your codebase, and you're using Python 2.5 or higher, switch to the new way of doing it so your code remains compatible when you upgrade.</source>
          <target state="translated">如果您在代码库中看到逗号名称分配,而且您正在使用 Python 2.5 或更高版本的 Python,请切换到新的方式,这样您的代码在升级时仍能保持兼容。</target>
        </trans-unit>
        <trans-unit id="d53e02618e344d52ef01c720b0e4a1aeade3ace3" translate="yes" xml:space="preserve">
          <source>If you, also, need to catch other exceptions than those in the
pre-defined tuple, you will need to define another except block.</source>
          <target state="translated">如果你还需要捕捉预设的tuple以外的其他异常,你需要定义另一个except块。</target>
        </trans-unit>
        <trans-unit id="de1a6de2f465c2cd7ad7368000b40688a92f698b" translate="yes" xml:space="preserve">
          <source>Is there a way to do this?</source>
          <target state="translated">有什么办法可以这样做吗?</target>
        </trans-unit>
        <trans-unit id="c7465ca741faacdaacf8fc289a406e2b80c58c6f" translate="yes" xml:space="preserve">
          <source>Is there any way that I can do something like this (since the action to take in both exceptions is to &lt;code&gt;say please&lt;/code&gt;):</source>
          <target state="translated">我有什么办法可以做这样的事情（因为在两种情况下都要采取的行动是 &lt;code&gt;say please&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="0ddc7de3efedfca6bfa1df90007e94bbdec68263" translate="yes" xml:space="preserve">
          <source>Note that in Python 3, the &lt;code&gt;err&lt;/code&gt; object falls out of scope when the &lt;code&gt;except&lt;/code&gt; block is concluded.</source>
          <target state="translated">请注意，在Python 3中， &lt;code&gt;except&lt;/code&gt; 块结束时， &lt;code&gt;err&lt;/code&gt; 对象超出范围。</target>
        </trans-unit>
        <trans-unit id="bc004f867fab3134998b742d32b99375aa58bc59" translate="yes" xml:space="preserve">
          <source>Note that the parentheses around this tuple are required, because
  except &lt;code&gt;ValueError, e:&lt;/code&gt; was the syntax used for what is normally
  written as &lt;code&gt;except ValueError as e:&lt;/code&gt; in modern Python (described
  below). The old syntax is still supported for backwards compatibility.
  This means &lt;code&gt;except RuntimeError, TypeError&lt;/code&gt; is not equivalent to
  &lt;code&gt;except (RuntimeError, TypeError):&lt;/code&gt; but to &lt;code&gt;except RuntimeError as&lt;/code&gt;&lt;code&gt;TypeError:&lt;/code&gt; which is not what you want.</source>
          <target state="translated">请注意，必须在该元组周围加上括号，因为在现代Python中，除 &lt;code&gt;ValueError, e:&lt;/code&gt; 之外，e：是通常用作 &lt;code&gt;except ValueError as e:&lt;/code&gt; 之外的e：的语法（如下所述）。 为了向后兼容，仍支持旧语法。 这意味着， &lt;code&gt;except RuntimeError, TypeError&lt;/code&gt; 不等于 &lt;code&gt;except (RuntimeError, TypeError):&lt;/code&gt; &lt;code&gt;TypeError:&lt;/code&gt; 而不是 &lt;code&gt;except RuntimeError as&lt;/code&gt; TypeError：，这不是您想要的。</target>
        </trans-unit>
        <trans-unit id="d723b6ca1c9901f40ffa8c7cb73cf071dc6f9e0d" translate="yes" xml:space="preserve">
          <source>Now this really won't work, as it matches the syntax for:</source>
          <target state="translated">现在这个真的不行了,因为它的语法符合。</target>
        </trans-unit>
        <trans-unit id="79e92850cf7ab3458ee0c35ad48771f18d731aef" translate="yes" xml:space="preserve">
          <source>One of the way to do this is..</source>
          <target state="translated">其中一个方法是.....</target>
        </trans-unit>
        <trans-unit id="ab8be1efd6dc3c435478dd3a62ea08cc4d4c06e3" translate="yes" xml:space="preserve">
          <source>Or, for Python 2 only:</source>
          <target state="translated">或者,只针对Python 2。</target>
        </trans-unit>
        <trans-unit id="888126aced4a34b1e616dbdc24b23e92f8571666" translate="yes" xml:space="preserve">
          <source>Separating the exception from the variable with a comma will still work in Python 2.6 and 2.7, but is now deprecated and does not work in Python 3; now you should be using &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">用逗号将变量与变量分开仍然可以在Python 2.6和2.7中使用，但是现在已弃用，并且在Python 3中不起作用。 现在您应该使用 &lt;code&gt;as&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="530c6bc48355a2f0b526302e96aa22689f3a413c" translate="yes" xml:space="preserve">
          <source>So when you want to &lt;code&gt;pass&lt;/code&gt; on certain exceptions, use &lt;code&gt;suppress&lt;/code&gt;.</source>
          <target state="translated">因此，当您想 &lt;code&gt;pass&lt;/code&gt; 某些异常时，请使用 &lt;code&gt;suppress&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fd8ccd2dd96cfb9e086072e85ef976d09bafe09" translate="yes" xml:space="preserve">
          <source>So, my effort to catch the two distinct exceptions doesn't exactly come through.</source>
          <target state="translated">所以,我抓住这两个明显的特例的努力,并没有完全通过。</target>
        </trans-unit>
        <trans-unit id="e8d29ca877f0b675404f6ad99cc97ea5416ba17d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;suppress&lt;/code&gt; context manager</source>
          <target state="translated">&lt;code&gt;suppress&lt;/code&gt; 上下文管理器</target>
        </trans-unit>
        <trans-unit id="8f5ee26bfbcdad01c21831aaa32acdbdab6870f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;except&lt;/code&gt;, &lt;code&gt;pass&lt;/code&gt; lines can be handled in a single line with the &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;suppress context manager, available in Python 3.4&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; &lt;code&gt;except&lt;/code&gt; 行可以使用&lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;抑制上下文管理器（可在Python 3.4中使用）在&lt;/a&gt;一行中处理：</target>
        </trans-unit>
        <trans-unit id="bee6793736696d15c86e9418c392cb160b334c24" translate="yes" xml:space="preserve">
          <source>The accepted answer is really 4 lines of code, minimum:</source>
          <target state="translated">接受的答案真的是4行代码,最少也要4行。</target>
        </trans-unit>
        <trans-unit id="ded8725c303b5da6585a80fa99b9320cabc80649" translate="yes" xml:space="preserve">
          <source>The parentheses are required due to older syntax that used the commas to assign the error object to a name. The &lt;code&gt;as&lt;/code&gt; keyword is used for the assignment. You can use any name for the error object, I prefer &lt;code&gt;error&lt;/code&gt; personally.</source>
          <target state="translated">由于使用了逗号将错误对象分配给名称的较旧语法，因此需要使用括号。 &lt;code&gt;as&lt;/code&gt; 关键字用于分配。 您可以为错误对象使用任何名称，我个人更喜欢 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="256437836b7943e4e7fdd752b20caa8596495bbe" translate="yes" xml:space="preserve">
          <source>This is documented here: &lt;a href=&quot;https://docs.python.org/tutorial/errors.html&quot;&gt;https://docs.python.org/tutorial/errors.html&lt;/a&gt;</source>
          <target state="translated">在此处进行记录： &lt;a href=&quot;https://docs.python.org/tutorial/errors.html&quot;&gt;https&lt;/a&gt; : //docs.python.org/tutorial/errors.html</target>
        </trans-unit>
        <trans-unit id="7f29c057864f2263b1ab7362d208202bd2da70e6" translate="yes" xml:space="preserve">
          <source>To do this in a manner currently and forward compatible with Python, you need to separate the Exceptions with commas and wrap them with parentheses to differentiate from earlier syntax that assigned the exception instance to a variable name by following the Exception type to be caught with a comma.</source>
          <target state="translated">为了以目前和Python兼容的方式来做,你需要用逗号来分隔异常,并用括号将其包起来,以区别于早期的语法,即通过在Exception类型后面用逗号来抓取异常类型,将异常实例分配给变量名。</target>
        </trans-unit>
        <trans-unit id="6ba5618acc6b4058c1e35f3d6a2c3cef5ea10a96" translate="yes" xml:space="preserve">
          <source>You can assign the exception to a variable, (&lt;code&gt;e&lt;/code&gt; is common, but you might prefer a more verbose variable if you have long exception handling or your IDE only highlights selections larger than that, as mine does.) The instance has an args attribute. Here is an example:</source>
          <target state="translated">您可以将异常分配给变量（ &lt;code&gt;e&lt;/code&gt; 很常见，但是如果您具有较长的异常处理能力，或者您的IDE仅像我的那样突出显示大于此的选择，则您可能更喜欢使用更冗长的变量。）实例具有args属性。 这是一个例子：</target>
        </trans-unit>
        <trans-unit id="9e6e4be46f2b9460466e983a0c36c398eceb540a" translate="yes" xml:space="preserve">
          <source>You may see code that assigns the error with a comma. This usage, the only form available in Python 2.5 and earlier, is deprecated, and if you wish your code to be forward compatible in Python 3, you should update the syntax to use the new form:</source>
          <target state="translated">你可能会看到用逗号指定错误的代码。这种用法是Python 2.5 及更早的版本中唯一可用的形式,现在已经过时了,如果你希望你的代码在Python 3中能够兼容,你应该更新语法以使用新的形式。</target>
        </trans-unit>
        <trans-unit id="ab0ff4075328dcf9cd0d73abe51697d044af9e1c" translate="yes" xml:space="preserve">
          <source>and another way is to create method which performs task executed by &lt;code&gt;except&lt;/code&gt; block and call it through all of the &lt;code&gt;except&lt;/code&gt; block that you write..</source>
          <target state="translated">另一种方法是创建执行由 &lt;code&gt;except&lt;/code&gt; 块执行的任务的方法，并通过您编写的所有except块调用该方法。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
