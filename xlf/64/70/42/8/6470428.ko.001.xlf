<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/6470428">
    <body>
      <group id="6470428">
        <trans-unit id="4c5bf79f3c7090acea7b512de0735d716d9b5855" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTES:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTES:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab51a5a95212edc93655cc24b28a5f914b05fe4b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;try&lt;/code&gt; statement may have more than one except clause, to specify
  handlers for different exceptions. At most one handler will be
  executed. Handlers only handle exceptions that occur in the
  corresponding try clause, not in other handlers of the same try
  statement. An except clause may name multiple exceptions as a
  parenthesized tuple, for example:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 문은 다른 예외에 대한 핸들러를 지정하기 위해 하나 이상의 except 절을 가질 수 있습니다. 최대 하나의 핸들러가 실행됩니다. 핸들러는 동일한 try 문의 다른 핸들러가 아닌 해당 try 절에서 발생하는 예외 만 처리합니다. except 절은 여러 예외의 이름을 괄호로 묶은 튜플로 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b049d4d6cc89ce4c077b28174e43420d6a4bc2cc" translate="yes" xml:space="preserve">
          <source>An except clause may name multiple exceptions as a parenthesized tuple, for example</source>
          <target state="translated">except 절은 여러 예외를 괄호로 묶은 튜플로 명명 할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="d8cb09e158212bf209b199530d94686ab9de6f8c" translate="yes" xml:space="preserve">
          <source>Best Practice</source>
          <target state="translated">모범 사례</target>
        </trans-unit>
        <trans-unit id="817b3c16209f1354c4647f0853f13398696d0d2f" translate="yes" xml:space="preserve">
          <source>But if I want to do the same thing inside two different exceptions, the best I can think of right now is to do this:</source>
          <target state="translated">그러나 두 가지 다른 예외 내에서 동일한 작업을 수행하려면 지금 생각할 수있는 최선의 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b2b69a15733371ac46b79803f3cc36eaf3ee9be" translate="yes" xml:space="preserve">
          <source>Catch multiple exceptions in one line (except block)</source>
          <target state="translated">한 줄에 여러 예외를 잡아라 (블록 제외)</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="a09d8fe71d819660f00ffa7e97f5581804bd696d" translate="yes" xml:space="preserve">
          <source>Do this:</source>
          <target state="translated">이 작업을 수행:</target>
        </trans-unit>
        <trans-unit id="13affbde8a1ea802fe72700ad8c2898507c9259c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/2/tutorial/errors.html#handling-exceptions&quot;&gt;Python documentation -&amp;gt; 8.3 Handling Exceptions&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/tutorial/errors.html#handling-exceptions&quot;&gt;파이썬 문서에서-&amp;gt; 8.3 예외 처리&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2c6825f23083c7c1e94708a167000ee7ab04e1cf" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/3/tutorial/errors.html#handling-exceptions&quot;&gt;Python Documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/tutorial/errors.html#handling-exceptions&quot;&gt;파이썬 문서에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ded2ede429f8a9ed8ea8ab4b5cf15fba93ff8c57" translate="yes" xml:space="preserve">
          <source>Here's an example of simple usage:</source>
          <target state="translated">간단한 사용법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25401e6d560f2365c3f86f0125c7ffa7a861662a" translate="yes" xml:space="preserve">
          <source>How do I catch multiple exceptions in one line (except block)</source>
          <target state="translated">한 줄에 여러 예외를 잡는 방법 (블록 제외)</target>
        </trans-unit>
        <trans-unit id="41760b6f3ebb7baac4ad211d7c27b7499d6d4e88" translate="yes" xml:space="preserve">
          <source>I can also do this:</source>
          <target state="translated">나는 또한 이것을 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="0690b8cb888193df03438257609795252e5473af" translate="yes" xml:space="preserve">
          <source>I know that I can do:</source>
          <target state="translated">나는 내가 할 수 있다는 것을 안다.</target>
        </trans-unit>
        <trans-unit id="e1483e7b14daed222d2c8aef506327181c1b3c4a" translate="yes" xml:space="preserve">
          <source>I know that second one is not the best way to do this, but i'm just showing number of ways to do this thing.</source>
          <target state="translated">나는 두 번째 방법이 이것을하는 가장 좋은 방법은 아니라는 것을 알고 있지만,이 일을하는 많은 방법을 보여주고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b902bf544387ba5c38f871fc0f6304eab8182ec2" translate="yes" xml:space="preserve">
          <source>I'm specifying only these exceptions to avoid hiding bugs, which if I encounter I expect the full stack trace from.</source>
          <target state="translated">버그를 숨기지 않기 위해 이러한 예외 만 지정하고 있습니다. 버그가 발생하면 전체 스택 추적을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="a3befa5d5bde2dd45b6cb9e5cfdd8e2e675fb897" translate="yes" xml:space="preserve">
          <source>If you frequently use a large number of exceptions, you can pre-define a tuple, so you don't have to re-type them many times.</source>
          <target state="translated">많은 수의 예외를 자주 사용하는 경우 튜플을 미리 정의 할 수 있으므로 여러 번 다시 입력 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b7a540cdc02a3c56ceec5c00c10a8ed90a3556b7" translate="yes" xml:space="preserve">
          <source>If you just cannot tolerate a global variable, define it in main()
and pass it around where needed...</source>
          <target state="translated">전역 변수를 허용 할 수 없다면 main ()에서 변수를 정의하고 필요한 곳으로 전달하십시오 ...</target>
        </trans-unit>
        <trans-unit id="a9fb9bd20ca250fed19a43594b2578230ac37e6b" translate="yes" xml:space="preserve">
          <source>If you see the comma name assignment in your codebase, and you're using Python 2.5 or higher, switch to the new way of doing it so your code remains compatible when you upgrade.</source>
          <target state="translated">코드베이스에 쉼표 이름이 할당되어 있고 Python 2.5 이상을 사용하는 경우 새로운 방식으로 전환하여 업그레이드 할 때 코드가 호환되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="d53e02618e344d52ef01c720b0e4a1aeade3ace3" translate="yes" xml:space="preserve">
          <source>If you, also, need to catch other exceptions than those in the
pre-defined tuple, you will need to define another except block.</source>
          <target state="translated">또한 사전 정의 된 튜플의 예외 이외의 다른 예외를 포착해야하는 경우 다른 except 블록을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="de1a6de2f465c2cd7ad7368000b40688a92f698b" translate="yes" xml:space="preserve">
          <source>Is there a way to do this?</source>
          <target state="translated">이것을 할 수있는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="c7465ca741faacdaacf8fc289a406e2b80c58c6f" translate="yes" xml:space="preserve">
          <source>Is there any way that I can do something like this (since the action to take in both exceptions is to &lt;code&gt;say please&lt;/code&gt;):</source>
          <target state="translated">이 같은 작업을 수행 할 수있는 방법이 있습니까 (두 예외를 모두 취하는 조치는 &lt;code&gt;say please&lt;/code&gt; 이므로) :</target>
        </trans-unit>
        <trans-unit id="0ddc7de3efedfca6bfa1df90007e94bbdec68263" translate="yes" xml:space="preserve">
          <source>Note that in Python 3, the &lt;code&gt;err&lt;/code&gt; object falls out of scope when the &lt;code&gt;except&lt;/code&gt; block is concluded.</source>
          <target state="translated">Python 3에서 &lt;code&gt;except&lt;/code&gt; 블록이 끝나면 &lt;code&gt;err&lt;/code&gt; 객체가 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="bc004f867fab3134998b742d32b99375aa58bc59" translate="yes" xml:space="preserve">
          <source>Note that the parentheses around this tuple are required, because
  except &lt;code&gt;ValueError, e:&lt;/code&gt; was the syntax used for what is normally
  written as &lt;code&gt;except ValueError as e:&lt;/code&gt; in modern Python (described
  below). The old syntax is still supported for backwards compatibility.
  This means &lt;code&gt;except RuntimeError, TypeError&lt;/code&gt; is not equivalent to
  &lt;code&gt;except (RuntimeError, TypeError):&lt;/code&gt; but to &lt;code&gt;except RuntimeError as&lt;/code&gt;&lt;code&gt;TypeError:&lt;/code&gt; which is not what you want.</source>
          <target state="translated">이 튜플 주위의 괄호는 &lt;code&gt;ValueError, e:&lt;/code&gt; 제외하고는 필요합니다 . &lt;code&gt;except ValueError as e:&lt;/code&gt; 는 현대 Python에서 e : 를 ValueError로 제외 하는 데 일반적으로 사용되는 구문이었습니다 (아래 설명 참조). 이전 구문은 이전 버전과의 호환성을 위해 계속 지원됩니다. 이것은 &lt;code&gt;except RuntimeError, TypeError&lt;/code&gt; 를 &lt;code&gt;except (RuntimeError, TypeError):&lt;/code&gt; TypeError 는 (RuntimeError, TypeError) : 를 제외 하는 것과 같지 않지만 &lt;code&gt;except RuntimeError as&lt;/code&gt; &lt;code&gt;TypeError:&lt;/code&gt; 로 제외 하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d723b6ca1c9901f40ffa8c7cb73cf071dc6f9e0d" translate="yes" xml:space="preserve">
          <source>Now this really won't work, as it matches the syntax for:</source>
          <target state="translated">이제는 다음 구문과 일치하므로 실제로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79e92850cf7ab3458ee0c35ad48771f18d731aef" translate="yes" xml:space="preserve">
          <source>One of the way to do this is..</source>
          <target state="translated">이 작업을 수행하는 방법 중 하나는</target>
        </trans-unit>
        <trans-unit id="ab8be1efd6dc3c435478dd3a62ea08cc4d4c06e3" translate="yes" xml:space="preserve">
          <source>Or, for Python 2 only:</source>
          <target state="translated">또는 Python 2의 경우에만 :</target>
        </trans-unit>
        <trans-unit id="888126aced4a34b1e616dbdc24b23e92f8571666" translate="yes" xml:space="preserve">
          <source>Separating the exception from the variable with a comma will still work in Python 2.6 and 2.7, but is now deprecated and does not work in Python 3; now you should be using &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">변수에서 예외를 쉼표로 분리하면 Python 2.6 및 2.7에서는 계속 작동하지만 더 이상 사용되지 않으며 Python 3에서는 작동하지 않습니다. 이제는로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="530c6bc48355a2f0b526302e96aa22689f3a413c" translate="yes" xml:space="preserve">
          <source>So when you want to &lt;code&gt;pass&lt;/code&gt; on certain exceptions, use &lt;code&gt;suppress&lt;/code&gt;.</source>
          <target state="translated">따라서 특정 예외를 &lt;code&gt;pass&lt;/code&gt; 하려면 &lt;code&gt;suppress&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5fd8ccd2dd96cfb9e086072e85ef976d09bafe09" translate="yes" xml:space="preserve">
          <source>So, my effort to catch the two distinct exceptions doesn't exactly come through.</source>
          <target state="translated">따라서 두 가지 예외를 포착하려는 노력이 정확히 이루어지지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="e8d29ca877f0b675404f6ad99cc97ea5416ba17d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;suppress&lt;/code&gt; context manager</source>
          <target state="translated">컨텍스트 &lt;code&gt;suppress&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8f5ee26bfbcdad01c21831aaa32acdbdab6870f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;except&lt;/code&gt;, &lt;code&gt;pass&lt;/code&gt; lines can be handled in a single line with the &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;suppress context manager, available in Python 3.4&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 을 &lt;code&gt;except&lt;/code&gt; try 는 &lt;code&gt;pass&lt;/code&gt; &lt;a href=&quot;https://docs.python.org/3/library/contextlib.html#contextlib.suppress&quot;&gt;Context를&lt;/a&gt; 사용하여 단일 행 에서 파이썬 3.4에서 사용할 수있는 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="bee6793736696d15c86e9418c392cb160b334c24" translate="yes" xml:space="preserve">
          <source>The accepted answer is really 4 lines of code, minimum:</source>
          <target state="translated">허용되는 답변은 실제로 최소 4 줄의 코드입니다.</target>
        </trans-unit>
        <trans-unit id="ded8725c303b5da6585a80fa99b9320cabc80649" translate="yes" xml:space="preserve">
          <source>The parentheses are required due to older syntax that used the commas to assign the error object to a name. The &lt;code&gt;as&lt;/code&gt; keyword is used for the assignment. You can use any name for the error object, I prefer &lt;code&gt;error&lt;/code&gt; personally.</source>
          <target state="translated">쉼표를 사용하여 오류 객체를 이름에 할당 한 이전 구문으로 인해 괄호가 필요합니다. &lt;code&gt;as&lt;/code&gt; 키워드가 할당에 사용됩니다. 오류 개체의 모든 이름을 사용할 수 있습니다. 개인적으로 &lt;code&gt;error&lt;/code&gt; 선호 합니다 .</target>
        </trans-unit>
        <trans-unit id="256437836b7943e4e7fdd752b20caa8596495bbe" translate="yes" xml:space="preserve">
          <source>This is documented here: &lt;a href=&quot;https://docs.python.org/tutorial/errors.html&quot;&gt;https://docs.python.org/tutorial/errors.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/tutorial/errors.html&quot;&gt;https://docs.python.org/tutorial/errors.html에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f29c057864f2263b1ab7362d208202bd2da70e6" translate="yes" xml:space="preserve">
          <source>To do this in a manner currently and forward compatible with Python, you need to separate the Exceptions with commas and wrap them with parentheses to differentiate from earlier syntax that assigned the exception instance to a variable name by following the Exception type to be caught with a comma.</source>
          <target state="translated">현재 및 파이썬과 호환되는 방식 으로이 작업을 수행하려면 Exception을 쉼표로 구분하고 괄호로 묶어 예외 유형을 지정하여 예외 인스턴스를 변수 이름으로 할당 한 이전 구문과 구별해야합니다. 반점.</target>
        </trans-unit>
        <trans-unit id="6ba5618acc6b4058c1e35f3d6a2c3cef5ea10a96" translate="yes" xml:space="preserve">
          <source>You can assign the exception to a variable, (&lt;code&gt;e&lt;/code&gt; is common, but you might prefer a more verbose variable if you have long exception handling or your IDE only highlights selections larger than that, as mine does.) The instance has an args attribute. Here is an example:</source>
          <target state="translated">예외를 변수에 할당 할 수 있습니다 ( &lt;code&gt;e&lt;/code&gt; 는 일반적이지만 예외 처리가 길거나 IDE가 내 선택과 같이 더 큰 선택 만 강조 표시하는 경우 더 자세한 변수를 선호 할 수 있습니다). 인스턴스에는 args 속성이 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e6e4be46f2b9460466e983a0c36c398eceb540a" translate="yes" xml:space="preserve">
          <source>You may see code that assigns the error with a comma. This usage, the only form available in Python 2.5 and earlier, is deprecated, and if you wish your code to be forward compatible in Python 3, you should update the syntax to use the new form:</source>
          <target state="translated">쉼표로 오류를 지정하는 코드가 표시 될 수 있습니다. Python 2.5 및 이전 버전에서 사용할 수있는 유일한 형식 인이 사용법은 더 이상 사용되지 않으며 Python 3에서 코드가 이전 버전과 호환되도록하려면 구문을 업데이트하여 새 양식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab0ff4075328dcf9cd0d73abe51697d044af9e1c" translate="yes" xml:space="preserve">
          <source>and another way is to create method which performs task executed by &lt;code&gt;except&lt;/code&gt; block and call it through all of the &lt;code&gt;except&lt;/code&gt; block that you write..</source>
          <target state="translated">또 다른 방법은 &lt;code&gt;except&lt;/code&gt; 블록으로 실행 된 태스크를 수행하는 메소드를 작성하고 작성하는 모든 &lt;code&gt;except&lt;/code&gt; 블록을 통해 호출하는 방법입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
