<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/6470651">
    <body>
      <group id="6470651">
        <trans-unit id="ce551772d925b8244e0871a46c5c62edabde5ab0" translate="yes" xml:space="preserve">
          <source>&quot;A memory leak, in computer science (or leakage, in this context), occurs when a computer program consumes memory but is unable to release it back to the operating system.&quot; (Wikipedia)</source>
          <target state="translated">&quot;内存泄漏,在计算机科学中,当计算机程序消耗了内存,但无法将其释放回操作系统时,就会发生内存泄漏(在此情况下,或称泄漏)。&quot; &quot;(维基百科)</target>
        </trans-unit>
        <trans-unit id="5e57ac3aff18b19898d770571f33488ff49c0558" translate="yes" xml:space="preserve">
          <source>(*edited*)</source>
          <target state="translated">(*edited*)</target>
        </trans-unit>
        <trans-unit id="5bdafb56fc1b00b73f2a4f5cd91af94f858da2b7" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;ClassLoader&lt;/code&gt; doesn't really play a role in creating the leak, it just makes the leak worse because of this additional reference chain: example class &amp;rarr; &lt;code&gt;ClassLoader&lt;/code&gt; &amp;rarr; all the classes it has loaded. It was even worse in many JVM implementations, especially prior to Java 7, because classes and &lt;code&gt;ClassLoader&lt;/code&gt;s were allocated straight into permgen and were never garbage-collected at all.)</source>
          <target state="translated">（ &lt;code&gt;ClassLoader&lt;/code&gt; 在创建泄漏中并没有真正起作用，它只是由于以下附加参考链而使泄漏更糟：示例类&amp;rarr; &lt;code&gt;ClassLoader&lt;/code&gt; &amp;rarr;它已加载的所有类。在许多JVM实现中，甚至更糟。在Java 7之前，因为类和 &lt;code&gt;ClassLoader&lt;/code&gt; 是直接分配到permgen中的，所以根本不会进行垃圾回收。）</target>
        </trans-unit>
        <trans-unit id="8a2cb5badd06d28955e6dd5187697ae3899dae98" translate="yes" xml:space="preserve">
          <source>-Wes Tarle</source>
          <target state="translated">-Wes Tarle</target>
        </trans-unit>
        <trans-unit id="9f33ee22495c88b28752411615696d9e6cd9b883" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;File.deleteOnExit()&lt;/code&gt; - always leaks the string, &lt;del&gt;if the string is a substring, the leak is even worse (the underlying char[] is also leaked)&lt;/del&gt; - &lt;em&gt;in Java&amp;nbsp;7 substring also copies the &lt;code&gt;char[]&lt;/code&gt;, so the later doesn't apply&lt;/em&gt;; @Daniel, no needs for votes, though.</source>
          <target state="translated">&lt;code&gt;File.deleteOnExit()&lt;/code&gt; -始终泄漏字符串， &lt;del&gt; 如果字符串是子字符串，则泄漏会更加严重（底层的char []也被泄漏） &lt;/del&gt; - &lt;em&gt;在Java 7中，子字符串还复制了 &lt;code&gt;char[]&lt;/code&gt; ，因此后者不适用&lt;/em&gt; ； @Daniel，不过不需要投票。</target>
        </trans-unit>
        <trans-unit id="3b29da849034672fbeff563c8ca560e1f28825fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Runtime.addShutdownHook&lt;/code&gt; and not remove... and then even with removeShutdownHook due to a bug in ThreadGroup class regarding unstarted threads it may not get collected, effectively leak the ThreadGroup. JGroup has the leak in GossipRouter.</source>
          <target state="translated">&lt;code&gt;Runtime.addShutdownHook&lt;/code&gt; 而不是不删除...，即使由于ThreadGroup类中关于未启动的线程的错误（可能无法收集未启动的线程）导致的错误，即使使用removeShutdownHook也会有效地泄漏ThreadGroup。 JGroup在GossipRouter中泄漏。</target>
        </trans-unit>
        <trans-unit id="b5fe4e1a6cd0ea146ce3183821fd7ded9f7fddcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Thread&lt;/code&gt; object &amp;rarr; &lt;code&gt;threadLocals&lt;/code&gt; map &amp;rarr; instance of example class &amp;rarr; example class &amp;rarr; static &lt;code&gt;ThreadLocal&lt;/code&gt; field &amp;rarr; &lt;code&gt;ThreadLocal&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; 对象&amp;rarr; &lt;code&gt;threadLocals&lt;/code&gt; 映射&amp;rarr;示例类的实例&amp;rarr;示例类&amp;rarr;静态 &lt;code&gt;ThreadLocal&lt;/code&gt; 字段&amp;rarr; &lt;code&gt;ThreadLocal&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="a9416d962c9ac52f5046b355062720b3a6a912a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ThreadLocal&lt;/code&gt; caches; those are evil in many cases. I am sure everyone has seen quite a bit of simple caches based on ThreadLocal, well the bad news: if the thread keeps going more than expected the life the context ClassLoader, it is a pure nice little leak. Do not use ThreadLocal caches unless really needed.</source>
          <target state="translated">&lt;code&gt;ThreadLocal&lt;/code&gt; 缓存； 在许多情况下，这些都是邪恶的。 我敢肯定，每个人都已经看到了很多基于ThreadLocal的简单缓存，这是个坏消息：如果线程在类ClassLoader上下文中的寿命超过预期，那将是一个很好的泄漏。 除非确实需要，否则不要使用ThreadLocal缓存。</target>
        </trans-unit>
        <trans-unit id="1c6aba7a78f8385e0ba3e00b9761fe99aed8a72b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(I can add some more time wasters I have encountered upon request.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（我可以根据要求添加更多遇到的时间浪费者。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83c6a1eadabdd69897dc450376fab516908bf374" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Typical example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;典型示例：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8a4892207dc4108ead9ad94e3c06ab543f3489f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What often happens:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;经常发生的情况：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a9b98791a2ab9361faf8fde0f4c41f252b82e19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(Unclosed) open streams ( file , network etc... )&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;（未关闭）打开的流（文件，网络等...）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f79c87db599bf20aaa050617e73ebbe69aaa028b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Areas that are unreachable from JVM's garbage collector&lt;/strong&gt;, such as memory allocated through native methods</source>
          <target state="translated">&lt;strong&gt;JVM的垃圾收集器无法访问的区域&lt;/strong&gt; ，例如通过本机方法分配的内存</target>
        </trans-unit>
        <trans-unit id="4699b0f1f0227f0142005faa185d17f92b4d4515" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling &lt;a href=&quot;http://download.oracle.com/javase/6/docs/api/java/lang/String.html#intern%28%29&quot;&gt;&lt;code&gt;String.intern()&lt;/code&gt;&lt;/a&gt; on lengthy String&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在冗长的String上调用&lt;a href=&quot;http://download.oracle.com/javase/6/docs/api/java/lang/String.html#intern%28%29&quot;&gt; &lt;code&gt;String.intern()&lt;/code&gt; &lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3726fbd1251a5fadd54dc665b5e59b41e631b1b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incorrect or inappropriate JVM options&lt;/strong&gt;, such as the &lt;code&gt;noclassgc&lt;/code&gt; option on IBM JDK that prevents unused class garbage collection</source>
          <target state="translated">&lt;strong&gt;错误或不适当的JVM选项&lt;/strong&gt; ，例如防止未使用的类垃圾回收的IBM JDK上的 &lt;code&gt;noclassgc&lt;/code&gt; 选项</target>
        </trans-unit>
        <trans-unit id="9120e3e844c455e48acd2e25895a159800ab3a73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It gets worse over time.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;随着时间的流逝，情况变得越来越糟。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c5741c3dad69ebb3321e2c35668a7815931d415" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Real-life scenario:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;现实场景：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7bf99711d32dc7b8bc74ee8adecf080bd76fa985" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static field holding object reference [esp final field]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;静态字段保存对象参考[特别是最终字段]&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2815984d9739ac637be39c602500deddc0cd3d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The garbage collector cannot clean it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;垃圾收集器无法清理它。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8573fafe482d5317550f13754962a332336456f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The solution?&lt;/strong&gt; Just directly save the key / value (as you probably already do) rather than saving the &lt;code&gt;Map.Entry&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;解决方案？&lt;/strong&gt; 只需直接保存键/值（就像您可能已经做过的），而不是保存 &lt;code&gt;Map.Entry&lt;/code&gt; 即可 。</target>
        </trans-unit>
        <trans-unit id="d21ebb21d17f7c002c95a9430a5725826affb75d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unclosed connections&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;未封闭的连接&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ef7c13da50873fcd8c19bd2ad40c8d7de85846ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;: Since lots of people keep asking for it, &lt;a href=&quot;https://gist.github.com/dpryden/b2bb29ee2d146901b4ae&quot;&gt;here's some example code that shows this behavior in action&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;更新&lt;/strong&gt; ：由于很多人一直在要求它，因此以下&lt;a href=&quot;https://gist.github.com/dpryden/b2bb29ee2d146901b4ae&quot;&gt;示例代码展示了这种行为&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6b659a120e5d6112b5b7ab03de7d6b71d2f7026" translate="yes" xml:space="preserve">
          <source>A cache of objects is a good starting point to mess things up.</source>
          <target state="translated">对象的缓存是一个很好的起点,可以把事情搞得一团糟。</target>
        </trans-unit>
        <trans-unit id="bb7cb15522cb5a211052ea6472969db685b66046" translate="yes" xml:space="preserve">
          <source>A common example of this in GUI code is when creating a widget/component and adding a listener to some static/application scoped object and then not removing the listener when the widget is destroyed. Not only do you get a memory leak, but also a performance hit as when whatever you are listening to fires events, all your old listeners are called too.</source>
          <target state="translated">在GUI代码中,一个常见的例子是,当创建一个widgetcomponent,并向一些staticapplication scoped对象添加一个监听器,然后当widget被销毁时,不删除监听器。这不仅会造成内存泄漏,而且还会影响性能,因为当你所监听的事件发生时,所有旧的监听器也会被调用。</target>
        </trans-unit>
        <trans-unit id="9a0673a585c795ac28cf1e0c0cf4a751e109fd26" translate="yes" xml:space="preserve">
          <source>A memory leak is indeed truly possible and is perfectly predictable. No need for special language features or corner cases. Memory leaks are either an indicator that something is maybe missing or even of design problems.</source>
          <target state="translated">内存泄露确实是真的有可能的,而且是完全可以预测的。不需要特殊的语言特性或边角料。内存泄露,要么说明可能有什么东西遗漏,甚至说明设计上有问题。</target>
        </trans-unit>
        <trans-unit id="baefde2ecc16522348f8de06b13e699e98c478ed" translate="yes" xml:space="preserve">
          <source>A simple thing to do is to use a HashSet with an incorrect (or non-existent) &lt;code&gt;hashCode()&lt;/code&gt; or &lt;code&gt;equals()&lt;/code&gt;, and then keep adding &quot;duplicates&quot;.  Instead of ignoring duplicates as it should, the set will only ever grow and you won't be able to remove them.</source>
          <target state="translated">一个简单的事情是使用带有不正确（或不存在）的 &lt;code&gt;hashCode()&lt;/code&gt; 或 &lt;code&gt;equals()&lt;/code&gt; 的HashSet，然后继续添加&amp;ldquo;重复项&amp;rdquo;。 该集合只会不断增长，而您将无法删除它们，而不会忽略应有的重复项。</target>
        </trans-unit>
        <trans-unit id="a80d8e5173a3525de31e5ab2033ddb3b6ec29dd6" translate="yes" xml:space="preserve">
          <source>A variation on this pattern is why application containers (like Tomcat) can leak memory like a sieve if you frequently redeploy applications which happen to use &lt;code&gt;ThreadLocal&lt;/code&gt;s that in some way point back to themselves. This can happen for a number of subtle reasons and is often hard to debug and/or fix.</source>
          <target state="translated">这种模式的一个变种是，如果您频繁地重新部署恰巧使用 &lt;code&gt;ThreadLocal&lt;/code&gt; 的应用程序，而应用程序容器（例如Tomcat）却以某种方式指向自身，那么应用程序容器（例如Tomcat）会像筛子一样泄漏内存。 发生这种情况的原因很多，通常很难调试和/或修复。</target>
        </trans-unit>
        <trans-unit id="588772519dca67090e1685f2821715a70d9cedbd" translate="yes" xml:space="preserve">
          <source>After each &lt;code&gt;pseudoQueryDatabase()&lt;/code&gt; call, the &lt;code&gt;map&lt;/code&gt; instances should be ready for collection, but it won't happen, as at least one &lt;code&gt;Entry&lt;/code&gt; is stored somewhere else.</source>
          <target state="translated">在每个 &lt;code&gt;pseudoQueryDatabase()&lt;/code&gt; 调用之后，应该准备好收集 &lt;code&gt;map&lt;/code&gt; 实例，但是不会发生，因为至少有一个 &lt;code&gt;Entry&lt;/code&gt; 存储在其他位置。</target>
        </trans-unit>
        <trans-unit id="9b59729415ee481439bfee253d53a21559efa0a8" translate="yes" xml:space="preserve">
          <source>All the other answers so far are in my definition not really memory leaks. They all aim at filling the memory with pointless stuff real fast. But at any time you could still dereference the objects you created and thus freeing the memory --&amp;gt; NO LEAK. &lt;a href=&quot;https://stackoverflow.com/a/4948560/327301&quot;&gt;acconrad's answer&lt;/a&gt; comes pretty close though as I have to admit since his solution is effectively to just &quot;crash&quot; the garbage collector by forcing it in an endless loop).</source>
          <target state="translated">到目前为止，所有其他答案在我的定义中并不是真正的内存泄漏。 它们都旨在快速地用毫无意义的东西填充内存。 但是在任何时候，您仍然可以取消引用创建的对象，从而释放内存-&amp;gt;无泄漏。 &lt;a href=&quot;https://stackoverflow.com/a/4948560/327301&quot;&gt;acconrad的答案&lt;/a&gt;非常接近，但我不得不承认，因为他的解决方案实际上是通过迫使其无限循环来&amp;ldquo;崩溃&amp;rdquo;垃圾收集器）。</target>
        </trans-unit>
        <trans-unit id="d14d9c81cd606cffaec50cf1e4ba0a95ee66650b" translate="yes" xml:space="preserve">
          <source>All you need is a jar file with a file inside which will be referenced from Java code. The bigger the jar file, the quicker memory gets allocated.</source>
          <target state="translated">你需要的只是一个jar文件,里面有一个文件,这个文件会被Java代码引用。jar文件越大,内存分配得越快。</target>
        </trans-unit>
        <trans-unit id="92796050257ee31b4669322aedc4e14a1f4e1bac" translate="yes" xml:space="preserve">
          <source>Another way to create potentially huge memory leaks is to hold references to &lt;code&gt;Map.Entry&amp;lt;K,V&amp;gt;&lt;/code&gt; of a &lt;code&gt;TreeMap&lt;/code&gt;.</source>
          <target state="translated">创建潜在的巨大内存泄漏的另一种方法是保留对 &lt;code&gt;TreeMap&lt;/code&gt; 的 &lt;code&gt;Map.Entry&amp;lt;K,V&amp;gt;&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="15208722c8d9d35afacae07addaaa54d89ae1c80" translate="yes" xml:space="preserve">
          <source>Any time you keep references around to objects that you no longer need you have a memory leak.  See &lt;a href=&quot;http://www.ibm.com/developerworks/library/j-leaks/&quot;&gt;Handling memory leaks in Java programs&lt;/a&gt; for examples of how memory leaks manifest themselves in Java and what you can do about it.</source>
          <target state="translated">每当您保留对不再需要的对象的引用时，就会发生内存泄漏。 请参阅&lt;a href=&quot;http://www.ibm.com/developerworks/library/j-leaks/&quot;&gt;处理Java程序中的内存泄漏以&lt;/a&gt;获取有关内存泄漏如何在Java中表现出来以及如何执行的示例。</target>
        </trans-unit>
        <trans-unit id="3eb29554094059e5e094f60940cd4967c16b94c3" translate="yes" xml:space="preserve">
          <source>Application:</source>
          <target state="translated">Application:</target>
        </trans-unit>
        <trans-unit id="2160b097141acc1504e1eceb949c5dcc5858756e" translate="yes" xml:space="preserve">
          <source>As a lot of people have suggested, Resource Leaks are fairly easy to cause - like the JDBC examples. Actual Memory leaks are a bit harder - especially if you aren't relying on broken bits of the JVM to do it for you...</source>
          <target state="translated">正如很多人建议的那样,资源泄漏是相当容易造成的--就像JDBC的例子。实际的内存泄漏就比较难了--尤其是如果你不是依靠JVM的破损部分来解决的话......</target>
        </trans-unit>
        <trans-unit id="a4b08c6fe4ec7a0e9b4c24d40b76337ca881783d" translate="yes" xml:space="preserve">
          <source>As a toy example:</source>
          <target state="translated">作为一个玩具的例子。</target>
        </trans-unit>
        <trans-unit id="6ed7302d22555afde81c52261097b368f125c935" translate="yes" xml:space="preserve">
          <source>At the end of the day, with a modern JVM, you need to write some Java code that allocates a native resource outside the normal scope of the JVM's awareness.</source>
          <target state="translated">说到底,在现代JVM的情况下,你需要写一些Java代码,在JVM的正常感知范围之外分配一个原生资源。</target>
        </trans-unit>
        <trans-unit id="a4a0b6d34474218b90f7179c656bff731e8f4ed4" translate="yes" xml:space="preserve">
          <source>Because the substring refers to the internal representation of the original, much longer string, the original stays in memory. Thus, as long as you have a StringLeaker in play, you have the whole original string in memory, too, even though you might think you're just holding on to a single-character string.</source>
          <target state="translated">因为子字符串指的是原始的、更长的字符串的内部表示,所以原始的字符串保留在内存中。因此,只要你有一个StringLeaker,你的内存中就有整个原始字符串,尽管你可能认为你只是保留了一个单字符的字符串。</target>
        </trans-unit>
        <trans-unit id="ec66d55aea6163734b225b0eaee1f4aff2d21c20" translate="yes" xml:space="preserve">
          <source>Below there will be a non-obvious case where Java leaks, besides the standard case of forgotten listeners, static references, bogus/modifiable keys in hashmaps, or just threads stuck without any chance to end their life-cycle.</source>
          <target state="translated">下面会有一个非明显的Java泄露的情况,除了标准的被遗忘的监听器、静态引用、hashmaps中的可修改键,或者只是线程卡住了没有机会结束生命周期的线程外,还有一个非明显的案例。</target>
        </trans-unit>
        <trans-unit id="d6890f5c871bf813320eebb7769e31ce3e0862eb" translate="yes" xml:space="preserve">
          <source>But any long-lived application tend to have shared state. It can be anything, statics, singletons... Often non-trivial applications tend to make complex objects graphs. Just forgetting to set a reference to null or more often forgetting to remove one object from a collection is enough to make a memory leak.</source>
          <target state="translated">但是,任何长期的应用程序往往都有共享状态。它可以是任何东西,静态,单子......通常情况下,非琐碎的应用往往会倾向于做复杂的对象图。只是忘记把引用设置为null或者更多的时候忘记从集合中删除一个对象,就足以造成内存泄露。</target>
        </trans-unit>
        <trans-unit id="5d2e7eace75767ecc3750ad43683978a9ba57abb" translate="yes" xml:space="preserve">
          <source>But each &lt;em&gt;value&lt;/em&gt; is a strong reference, so when a value (directly or indirectly) points to the &lt;code&gt;ThreadLocal&lt;/code&gt; object that is its &lt;em&gt;key&lt;/em&gt;, that object will neither be garbage-collected nor removed from the map as long as the thread lives.</source>
          <target state="translated">但是每个&lt;em&gt;值&lt;/em&gt;都是一个强引用，因此，当一个值（直接或间接）指向作为其&lt;em&gt;键&lt;/em&gt;的 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象时，只要线程存在，该对象就不会被垃圾回收或从映射中删除。</target>
        </trans-unit>
        <trans-unit id="6dc882c31ef2333a4cb2ce12871d12e4568e39ef" translate="yes" xml:space="preserve">
          <source>But that is about a &quot;standard&quot; type of memory leak, when you cannot access the memory anymore, but it is still owned by the application. You can instead keep references to unused objects, or open streams without closing them afterwards.</source>
          <target state="translated">但那是关于 &quot;标准 &quot;类型的内存泄露,当你不能再访问内存时,但它仍然是由应用程序拥有的。相反,你可以保留对未使用的对象的引用,或者打开流而不在事后关闭它们。</target>
        </trans-unit>
        <trans-unit id="789320444cb7767260264a9cc9e9745ad7e7b191" translate="yes" xml:space="preserve">
          <source>But there are multiple meta-questions that may have been being asked?</source>
          <target state="translated">但是,可能有多个元问题被问到了?</target>
        </trans-unit>
        <trans-unit id="06b82e17900450ead4189c16a2dab375e08481ce" translate="yes" xml:space="preserve">
          <source>But there are really simpler cases for memory leaks. The garbage collector only frees what is no longer referenced. We as Java developers don't care about memory. We allocate it when needed and let it be freed automatically. Fine.</source>
          <target state="translated">但是内存泄露的情况真的有比较简单的情况。垃圾回收器只释放不再被引用的东西。我们作为Java开发者并不关心内存。我们在需要的时候分配它,让它自动释放。好吧,那就好。</target>
        </trans-unit>
        <trans-unit id="ce4161afe55f67a0294d9c668e44e8d09476c61c" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;System.gc()&lt;/code&gt; all you like, but the object passed to &lt;code&gt;leakMe&lt;/code&gt; will never die.</source>
          <target state="translated">&lt;code&gt;leakMe&lt;/code&gt; 调用 &lt;code&gt;System.gc()&lt;/code&gt; ，但传递给LeakMe的对象将永远不会消失。</target>
        </trans-unit>
        <trans-unit id="d152e2fcb524abf55287ceec73755ba1b51b9525" translate="yes" xml:space="preserve">
          <source>Call the native method.</source>
          <target state="translated">调用原生方法。</target>
        </trans-unit>
        <trans-unit id="32c8fac6d96245359d4955074230160abf920c47" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;ThreadGroup.destroy()&lt;/code&gt; when the ThreadGroup has no threads itself, but it still keeps child ThreadGroups. A bad leak that will prevent the ThreadGroup to remove from its parent, but all the children become un-enumerateable.</source>
          <target state="translated">当ThreadGroup本身没有线程，但仍保留子ThreadGroups时，调用 &lt;code&gt;ThreadGroup.destroy()&lt;/code&gt; 。 严重的泄漏将阻止ThreadGroup从其父级删除，但所有子级都变得无法枚举。</target>
        </trans-unit>
        <trans-unit id="96d2be15f0142d38fff9f1d0710b8a2950d9695e" translate="yes" xml:space="preserve">
          <source>Code doesn't compile in Eclipse IDE - compile it using command &lt;code&gt;javac&lt;/code&gt; (during compilation you'll get warnings)</source>
          <target state="translated">代码无法在Eclipse IDE中进行编译-使用命令 &lt;code&gt;javac&lt;/code&gt; 对其进行编译 （在编译过程中，您会收到警告）</target>
        </trans-unit>
        <trans-unit id="f90dd378d13e2f5f863d95c5043b9eb2f5314f2d" translate="yes" xml:space="preserve">
          <source>Consider the following wrapper class:</source>
          <target state="translated">考虑一下下面的包装类。</target>
        </trans-unit>
        <trans-unit id="58fab44360252f01998a02b0103a0562094b38f5" translate="yes" xml:space="preserve">
          <source>Consider: the basic pattern to terminate a worker thread is to set some condition variable seen by the thread. The thread can check the variable periodically and use that as a signal to terminate. If the variable is not declared &lt;code&gt;volatile&lt;/code&gt;, then the change to the variable might not be seen by the thread, so it won't know to terminate. Or imagine if some threads want to update a shared object, but deadlock while trying to lock on it.</source>
          <target state="translated">考虑：终止工作线程的基本模式是设置一些线程看到的条件变量。 线程可以定期检查变量并将其用作终止信号。 如果未将变量声明为 &lt;code&gt;volatile&lt;/code&gt; ，则线程可能看不到对变量的更改，因此它将不知道终止。 或者，假设某些线程是否要更新共享对象，但是在尝试锁定共享对象时却死锁。</target>
        </trans-unit>
        <trans-unit id="208d1932659651cdfcd8d8bc76e9e21d0d4d0246" translate="yes" xml:space="preserve">
          <source>Create a static Map and keep adding hard references to it.  Those will never be GC'd.</source>
          <target state="translated">创建一个静态地图,并不断添加硬引用。这些永远不会被GC'd。</target>
        </trans-unit>
        <trans-unit id="d1bddb5b37195d2b9cfc511e087351b8b37fc258" translate="yes" xml:space="preserve">
          <source>Creating a thread inherits the &lt;code&gt;ContextClassLoader&lt;/code&gt; and &lt;code&gt;AccessControlContext&lt;/code&gt;, plus the &lt;code&gt;ThreadGroup&lt;/code&gt; and any &lt;code&gt;InheritedThreadLocal&lt;/code&gt;, all those references are potential leaks, along with the entire classes loaded by the classloader and all static references, and ja-ja. The effect is especially visible with the entire j.u.c.Executor framework that features a super simple &lt;code&gt;ThreadFactory&lt;/code&gt; interface, yet most developers have no clue of the lurking danger. Also a lot of libraries do start threads upon request (way too many industry popular libraries).</source>
          <target state="translated">创建线程将继承 &lt;code&gt;ContextClassLoader&lt;/code&gt; 和 &lt;code&gt;AccessControlContext&lt;/code&gt; ，以及 &lt;code&gt;ThreadGroup&lt;/code&gt; 和任何 &lt;code&gt;InheritedThreadLocal&lt;/code&gt; ，所有这些引用都是潜在的泄漏，包括类加载器加载的整个类，所有静态引用以及ja-ja。 在具有超简单 &lt;code&gt;ThreadFactory&lt;/code&gt; 接口的整个jucExecutor框架中，效果尤其明显，但是大多数开发人员都不知道潜伏的危险。 另外，许多库确实根据请求启动线程（太多了业界流行的库）。</target>
        </trans-unit>
        <trans-unit id="2e6cf4701335cb5f59429515d569b0d29f77d768" translate="yes" xml:space="preserve">
          <source>Creating, but not starting, a &lt;code&gt;Thread&lt;/code&gt; goes into the same category as above.</source>
          <target state="translated">创建（而不是启动） &lt;code&gt;Thread&lt;/code&gt; 与上述类别相同。</target>
        </trans-unit>
        <trans-unit id="7294b77309edefafefe2bd3f45c66bab000f3d7c" translate="yes" xml:space="preserve">
          <source>Declare native method.</source>
          <target state="translated">申报本地方法。</target>
        </trans-unit>
        <trans-unit id="23728e6f1e8c32e9d0000075eebf66661982db5b" translate="yes" xml:space="preserve">
          <source>Depending on your &lt;code&gt;jvm&lt;/code&gt; settings, the application may crash in the early stage due to a &lt;code&gt;OutOfMemoryError&lt;/code&gt;.</source>
          <target state="translated">根据您的 &lt;code&gt;jvm&lt;/code&gt; 设置，应用程序可能会由于 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 而在早期崩溃。</target>
        </trans-unit>
        <trans-unit id="58816422485d099c26b663bf93adbe40a467f347" translate="yes" xml:space="preserve">
          <source>Do they know they can call other languages through native interfaces?</source>
          <target state="translated">他们知道自己可以通过原生接口调用其他语言吗?</target>
        </trans-unit>
        <trans-unit id="f5c9fcb2ac63bb6c6c32913f8fefe3bb71d7ed08" translate="yes" xml:space="preserve">
          <source>Do they know to leak memory in those other languages?</source>
          <target state="translated">他们知道用那些其他语言泄露内存吗?</target>
        </trans-unit>
        <trans-unit id="69aab9c5dfbb16547f4fc2c5abaf1344cf95a14c" translate="yes" xml:space="preserve">
          <source>Does the candidate even know what memory management is, and what is going on behind the scene in Java?</source>
          <target state="translated">考生甚至不知道什么是内存管理,在Java的幕后是什么情况?</target>
        </trans-unit>
        <trans-unit id="4dd2014adcd814735e78bd1371951597f5a3eea0" translate="yes" xml:space="preserve">
          <source>Does the candidate understand how garbage collection works?</source>
          <target state="translated">考生是否了解垃圾回收的工作原理?</target>
        </trans-unit>
        <trans-unit id="0bf3c2bfc81fd20031b3e9b9d609f7dd6aaaaf29" translate="yes" xml:space="preserve">
          <source>Does the candidate understand the difference between theory and reality?</source>
          <target state="translated">考生是否理解理论与现实的区别?</target>
        </trans-unit>
        <trans-unit id="f2811d869f66aa43f58c855c0b8b1856517b1f02" translate="yes" xml:space="preserve">
          <source>Doing so will keep both the original long string and the derived substring in memory even after the StringLeaker instance has been discarded.</source>
          <target state="translated">即使在StringLeaker实例被丢弃后,这样做将使原始长字符串和派生子串都保留在内存中。</target>
        </trans-unit>
        <trans-unit id="595b1741483d7d383832f58de31ab4ccfd5ae979" translate="yes" xml:space="preserve">
          <source>Due to the way &lt;code&gt;ThreadLocal&lt;/code&gt; is implemented in Oracle's JDK, this creates a memory leak:</source>
          <target state="translated">由于在Oracle的JDK中实现 &lt;code&gt;ThreadLocal&lt;/code&gt; 的方式，这会造成内存泄漏：</target>
        </trans-unit>
        <trans-unit id="6612e728c6376d049be0c52a45c0cafe2f871430" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;Thread&lt;/code&gt; has a private field &lt;code&gt;threadLocals&lt;/code&gt;, which actually stores the thread-local values.</source>
          <target state="translated">每个 &lt;code&gt;Thread&lt;/code&gt; 都有一个私有字段 &lt;code&gt;threadLocals&lt;/code&gt; ，它实际上存储线程本地值。</target>
        </trans-unit>
        <trans-unit id="651924eafe2e5c299685cb6d3c0296106ddc4229" translate="yes" xml:space="preserve">
          <source>Each &lt;em&gt;key&lt;/em&gt; in this map is a weak reference to a &lt;code&gt;ThreadLocal&lt;/code&gt; object, so after that &lt;code&gt;ThreadLocal&lt;/code&gt; object is garbage-collected, its entry is removed from the map.</source>
          <target state="translated">此映射中的每个&lt;em&gt;键&lt;/em&gt;都是对 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象的弱引用，因此在该 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象被垃圾回收之后，其条目将从映射中删除。</target>
        </trans-unit>
        <trans-unit id="2f85102b6f29d40dee4486317764bdc96c07bfac" translate="yes" xml:space="preserve">
          <source>Et voil&amp;agrave;: you find a jar archive in your current working directory with two files inside.</source>
          <target state="translated">等：您在当前工作目录中找到一个jar存档，其中包含两个文件。</target>
        </trans-unit>
        <trans-unit id="3fc97cb36795d349336e2937cf57eba4d88c6f85" translate="yes" xml:space="preserve">
          <source>Even if the JDBC driver were to implement &lt;code&gt;finalize&lt;/code&gt;, it is possible for exceptions to be thrown during finalization. The resulting behavior is that any memory associated with the now &quot;dormant&quot; object will not be reclaimed, as &lt;code&gt;finalize&lt;/code&gt; is guaranteed to be invoked only once.</source>
          <target state="translated">即使JDBC驱动程序要实现 &lt;code&gt;finalize&lt;/code&gt; ，也有可能在finalization期间引发异常。 最终的结果是，与finalt对象相关联的任何内存都不会被回收，因为 &lt;code&gt;finalize&lt;/code&gt; 只能被调用一次。</target>
        </trans-unit>
        <trans-unit id="16c7bc550059cf92961fbeac4004677360337532" translate="yes" xml:space="preserve">
          <source>Everyone always forgets the native code route.  Here's a simple formula for a leak:</source>
          <target state="translated">大家总是忘记了原生代码的路线。下面给大家介绍一个简单的漏网之鱼公式。</target>
        </trans-unit>
        <trans-unit id="85ba58bac97a3e55de6e391b4dcfef4a1a7a69b4" translate="yes" xml:space="preserve">
          <source>For added badness, you might also &lt;code&gt;.intern()&lt;/code&gt; the substring:</source>
          <target state="translated">为了增加 &lt;code&gt;.intern()&lt;/code&gt; ，您还可以.intern（）子字符串：</target>
        </trans-unit>
        <trans-unit id="3c74b0583eca451f3949e324127e22834986bacd" translate="yes" xml:space="preserve">
          <source>For instance, using ThreadLocal variables in Servlets to communicate with other web components, having the threads being created by the container and maintaining the idle ones in a pool. ThreadLocal variables, if not correctly cleaned up, will live there until, possibly, the same web component overwrites their values.</source>
          <target state="translated">例如,在Servlet中使用ThreadLocal变量与其他web组件进行通信,让容器创建的线程,并将闲置的线程维护在一个池中。ThreadLocal变量如果没有被正确清理,就会住在那里,直到有可能被同一个Web组件覆盖了它们的值。</target>
        </trans-unit>
        <trans-unit id="a550b50fecea603dd7d627a3a2a7718b13bdaa32" translate="yes" xml:space="preserve">
          <source>Good luck and stay safe; leaks are evil!</source>
          <target state="translated">祝大家好运,注意安全;漏网之鱼是邪恶的!</target>
        </trans-unit>
        <trans-unit id="d4becfb3fb0bc45134001f050666b7e0050d978e" translate="yes" xml:space="preserve">
          <source>Here's a good way to create a true memory leak (objects inaccessible by running code but still stored in memory) in pure Java:</source>
          <target state="translated">这里有一个好方法,可以在纯Java中创建一个真正的内存泄露(运行代码无法访问但仍存储在内存中的对象)。</target>
        </trans-unit>
        <trans-unit id="2f2b740f4900d7a6978f8315f2f1a8035106b9da" translate="yes" xml:space="preserve">
          <source>Here's a simple/sinister one via &lt;a href=&quot;http://wiki.eclipse.org/Performance_Bloopers#String.substring.28.29&quot;&gt;http://wiki.eclipse.org/Performance_Bloopers#String.substring.28.29&lt;/a&gt;.</source>
          <target state="translated">这是通过&lt;a href=&quot;http://wiki.eclipse.org/Performance_Bloopers#String.substring.28.29&quot;&gt;http://wiki.eclipse.org/Performance_Bloopers#String.substring.28.29&lt;/a&gt;进行的简单介绍。</target>
        </trans-unit>
        <trans-unit id="1b7f86efaf6f1be9a4631614110e3a1d163c3c9e" translate="yes" xml:space="preserve">
          <source>How to create a memory leak in Java</source>
          <target state="translated">如何在Java中创建内存泄漏</target>
        </trans-unit>
        <trans-unit id="01b6c42de1549d8f57e267f836caf27305ce373f" translate="yes" xml:space="preserve">
          <source>I came across a more subtle kind of resource leak recently.
We open resources via class loader's getResourceAsStream and it happened that the input stream handles were not closed.</source>
          <target state="translated">最近我遇到了一种比较微妙的资源泄露问题。我们通过类加载器的getResourceAsStream打开资源,结果刚好输入流句柄没有被关闭。</target>
        </trans-unit>
        <trans-unit id="e00a7aee2c9e1ea43ccd97f28e1044cddc2c12bb" translate="yes" xml:space="preserve">
          <source>I can copy my answer from here:
&lt;a href=&quot;https://stackoverflow.com/questions/4948529/easiest-way-to-cause-memory-leak-in-java/4948763&quot;&gt;Easiest way to cause memory leak in Java?&lt;/a&gt;</source>
          <target state="translated">我可以从这里复制答案： &lt;a href=&quot;https://stackoverflow.com/questions/4948529/easiest-way-to-cause-memory-leak-in-java/4948763&quot;&gt;导致Java内存泄漏的最简单方法？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c593eeadc2fb1717b13d6e06d4149bb1f7cea59" translate="yes" xml:space="preserve">
          <source>I don't think anyone has said this yet: you can resurrect an object by overriding the finalize() method such that finalize() stores a reference of this somewhere. The garbage collector will only be called once on the object so after that the object will never destroyed.</source>
          <target state="translated">我想还没有人说过:你可以通过重写finalize()方法来复活一个对象,让finalize()方法在某个地方存储一个引用。垃圾回收器只会在对象上被调用一次,所以在那之后,这个对象将永远不会被销毁。</target>
        </trans-unit>
        <trans-unit id="c6a50503d1ed9c1772a9fcbd93fa55757fa057ca" translate="yes" xml:space="preserve">
          <source>I have had a nice &quot;memory leak&quot; in relation to PermGen and XML parsing once.
The XML parser we used (I can't remember which one it was) did a String.intern() on tag names, to make comparison faster.
One of our customers had the great idea to store data values not in XML attributes or text, but as tagnames, so we had a document like:</source>
          <target state="translated">我曾经在PermGen和XML解析方面遇到过一次不错的 &quot;内存泄露&quot;。我们使用的XML解析器(我不记得是哪一个了)在标签名上做了一个String.inter(),以使比较更快。我们的一个客户有一个很好的想法,就是不以XML属性或文本的形式存储数据值,而是以tagnames的形式存储,所以我们有一个类似于这样的文档。</target>
        </trans-unit>
        <trans-unit id="21b20ac27c46030b96ee7a4c65ccb09c92ac0b95" translate="yes" xml:space="preserve">
          <source>I have written a more extensive benchmark &lt;a href=&quot;https://stackoverflow.com/a/49430255/8524301&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">我&lt;a href=&quot;https://stackoverflow.com/a/49430255/8524301&quot;&gt;在这里&lt;/a&gt;写了一个更广泛的基准。</target>
        </trans-unit>
        <trans-unit id="e6ecf084ad53032ca17349b056ec1fdcf8050143" translate="yes" xml:space="preserve">
          <source>I just had an interview, and I was asked to create a &lt;strong&gt;&lt;em&gt;memory leak&lt;/em&gt;&lt;/strong&gt; with Java.</source>
          <target state="translated">我刚刚接受采访，并被要求使用Java造成&lt;strong&gt;&lt;em&gt;内存泄漏&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="92126881424ebbbf07602882ed701925fe7eb526" translate="yes" xml:space="preserve">
          <source>I recently encountered a memory leak situation caused in a way by log4j.</source>
          <target state="translated">我最近遇到了一个由log4j造成的内存泄露的情况。</target>
        </trans-unit>
        <trans-unit id="7a504850de91ebafb452ca1440f20c4063b46f8a" translate="yes" xml:space="preserve">
          <source>I think that a valid example could be using ThreadLocal variables in an environment where threads are pooled.</source>
          <target state="translated">我认为一个有效的例子可以是在线程池环境中使用ThreadLocal变量。</target>
        </trans-unit>
        <trans-unit id="45f7a3d9f100654fd1c34bd75e3eb9d5a83eae86" translate="yes" xml:space="preserve">
          <source>I thought it was interesting that no one used the internal class examples.  If you have an internal class; it inherently maintains a reference to the containing class.  Of course it is not technically a memory leak because Java WILL eventually clean it up; but this can cause classes to hang around longer than anticipated.</source>
          <target state="translated">我以为很有意思的是,没有人用内部类的例子。如果你有一个内部类;它本质上会维护一个包含类的引用。当然,从技术上来说,这不是内存泄漏,因为Java最终会把它清理掉;但这可能会导致类比预期的时间更长。</target>
        </trans-unit>
        <trans-unit id="7d429b0485d7a2ac23d7e784ee85f99d6b65f029" translate="yes" xml:space="preserve">
          <source>I'll concentrate on threads to show the danger of unmanaged threads mostly, don't wish to even touch swing.</source>
          <target state="translated">我就集中线程来说明一下无人管理的线程的危害性,主要是不想连摆荡都不想碰。</target>
        </trans-unit>
        <trans-unit id="1fe18c2a2477f6295792e994a397c93f0806a8eb" translate="yes" xml:space="preserve">
          <source>I'm reading your meta-question as &quot;What's an answer I could have used in this interview situation&quot;. And hence, I'm going to focus on interview skills instead of Java. I believe you're more likely to repeat the situation of not knowing the answer to a question in an interview than you are to be in a place of needing to know how to make Java leak. So, hopefully, this will help.</source>
          <target state="translated">我把你的meta-question理解为 &quot;在这种面试的情况下,我可以用什么答案&quot;。因此,我要重点讲的是面试技巧,而不是Java。我相信你在面试的时候更容易重复出现不知道问题的答案的情况,而不是在需要知道如何让Java泄漏的地方。所以,希望能对你有所帮助。</target>
        </trans-unit>
        <trans-unit id="4b275ac46db4fdaa491bf5408c4f45e1255c8d27" translate="yes" xml:space="preserve">
          <source>I've also heard a rumor that if you have a variable that exists for longer than a specific amount of time; Java assumes that it will always exist and will actually never try to clean it up if cannot be reached in code anymore.  But that is completely unverified.</source>
          <target state="translated">我还听说过一个传言,说如果你有一个变量存在的时间超过了特定的时间,那么Java会假设它将永远存在,如果在代码中无法再达到,实际上永远不会尝试清理它。但这种说法是完全没有得到证实的。</target>
        </trans-unit>
        <trans-unit id="3fb2a5a45b0633c5ecfa4de6234eeb7c9b8db692" translate="yes" xml:space="preserve">
          <source>If the query was called lots of times and, for each query (so, for each &lt;code&gt;Map&lt;/code&gt; returned) you save an &lt;code&gt;Entry&lt;/code&gt; somewhere, the memory would constantly keep growing.</source>
          <target state="translated">如果查询被多次调用，并且对于每个查询（因此对于返回的每个 &lt;code&gt;Map&lt;/code&gt; ），您都将 &lt;code&gt;Entry&lt;/code&gt; 保存在某个地方，则内存将不断增长。</target>
        </trans-unit>
        <trans-unit id="e728ed31e7836138e4e1b214963390f9f9d63680" translate="yes" xml:space="preserve">
          <source>If there is just one reference surviving the undeployment of your web app, the corresponding classloader and by consequence all classes of your web app cannot be garbage collected.</source>
          <target state="translated">如果你的web应用程序只有一个引用没有被部署,那么相应的classloader以及你的web应用程序的所有类就不能被垃圾回收。</target>
        </trans-unit>
        <trans-unit id="a844f39481ac36271eb7582aa6ffdda4fd58a0aa" translate="yes" xml:space="preserve">
          <source>If this Info object has references to other objects, which again have references to other objects. In a way you could also consider this to be some kind of memory leak, (caused by bad design).</source>
          <target state="translated">如果这个Info对象有对其他对象的引用,而这些对象又有对其他对象的引用。在某种程度上,你也可以认为这是一种内存泄漏,(由于设计不当造成的)。</target>
        </trans-unit>
        <trans-unit id="3dec03b2417923a03f07454056bdbc6a069e20ca" translate="yes" xml:space="preserve">
          <source>If you only have a handful of threads these bugs will probably be obvious because your program will stop working properly. If you have a thread pool that creates more threads as needed, then the obsolete/stuck threads might not be noticed, and will accumulate indefinitely, causing a memory leak. Threads are likely to use other data in your application, so will also prevent anything they directly reference from ever being collected.</source>
          <target state="translated">如果你只有少数几个线程,这些bug可能会很明显,因为你的程序会停止正常工作。如果你有一个线程池,可以根据需要创建更多的线程,那么这些obsoletestuck线程可能不会被注意到,并且会无限期地积累,造成内存泄露。线程很可能会使用你的程序中的其他数据,所以也会阻止他们直接引用的任何东西被收集。</target>
        </trans-unit>
        <trans-unit id="07183207e77909e1bfc147b3897805b040b19554" translate="yes" xml:space="preserve">
          <source>If you want the application to play safe, close the input stream right where it's created:</source>
          <target state="translated">如果你想让应用程序安全地运行,就在创建的地方关闭输入流。</target>
        </trans-unit>
        <trans-unit id="b77776fc1bc27a6e9d7f17108863ff3131c7112a" translate="yes" xml:space="preserve">
          <source>If you want these bad keys/elements to hang around you can use a static field like</source>
          <target state="translated">如果你想让这些坏的关键元素挂在身边,你可以使用静态字段,如</target>
        </trans-unit>
        <trans-unit id="1f4a041a2b50b2a53250f8f05e6166af2d9e5d37" translate="yes" xml:space="preserve">
          <source>If you were implementing it yourself, would you have thought to clear the array element that is no longer used (&lt;code&gt;elementData[--size] = null&lt;/code&gt;)? That reference might keep a huge object alive ...</source>
          <target state="translated">如果您自己实现它，您是否会考虑清除不再使用的数组元素（ &lt;code&gt;elementData[--size] = null&lt;/code&gt; ）？ 该引用可能会使一个巨大的对象保持活动状态...</target>
        </trans-unit>
        <trans-unit id="fd37c731da6ece7675c58bbe7d98346fdbaa4cda" translate="yes" xml:space="preserve">
          <source>If you're doubtful, try to compile and start the class above, but make sure to chose a decent heap size (2 MB):</source>
          <target state="translated">如果你有疑问,可以试着编译一下,开始上面的类,但一定要选择一个像样的堆(2MB)。</target>
        </trans-unit>
        <trans-unit id="d47133a89c6ee68265054f24bec9f1e818d65900" translate="yes" xml:space="preserve">
          <source>Imagine having a db query that returns a big &lt;code&gt;TreeMap&lt;/code&gt; data structure. People usually use &lt;code&gt;TreeMap&lt;/code&gt;s as the element insertion order is retained.</source>
          <target state="translated">想象一下，有一个数据库查询返回一个大的 &lt;code&gt;TreeMap&lt;/code&gt; 数据结构。 人们通常使用 &lt;code&gt;TreeMap&lt;/code&gt; ,因为保留了元素插入顺序。</target>
        </trans-unit>
        <trans-unit id="616351eed8e13ed77018420d9f5f8f9e135a2f8b" translate="yes" xml:space="preserve">
          <source>In fact, they did not use numbers but longer textual IDs (around 20 characters), which were unique and came in at a rate of 10-15 million a day. That makes 200&amp;nbsp;MB of rubbish a day, which is never needed again, and never GCed (since it is in PermGen). We had permgen set to 512&amp;nbsp;MB, so it took around two days for the out-of-memory exception (OOME) to arrive...</source>
          <target state="translated">实际上，他们没有使用数字，而是使用更长的文本ID（大约20个字符），这些ID是唯一的，每天以10-15百万的速度出现。 每天将产生200 MB的垃圾，不再需要，也不再进行GC（因为它在PermGen中）。 我们将permgen设置为512 MB，因此大约需要两天的时间才能看到内存不足异常（OOME）。</target>
        </trans-unit>
        <trans-unit id="7d3a9486d4f2eefbc274d2aae1c983235c4f0060" translate="yes" xml:space="preserve">
          <source>In native method, call &lt;code&gt;malloc&lt;/code&gt;.  Don't call &lt;code&gt;free&lt;/code&gt;.</source>
          <target state="translated">在本机方法中，调用 &lt;code&gt;malloc&lt;/code&gt; 。 不要打 &lt;code&gt;free&lt;/code&gt; 电话。</target>
        </trans-unit>
        <trans-unit id="814f901888930bb38be0968e58de23b51f29ac3b" translate="yes" xml:space="preserve">
          <source>In order to store thread specific tags, log4j's NDC class uses a Hashtable which is keyed by the Thread object itself (as opposed to say the thread id), and thus till the NDC tag stays in memory all the objects that hang off of the thread object also stay in memory. In our web application we use NDC to tag logoutputs with a request id to distinguish logs from a single request separately. The container that associates the NDC tag with a thread, also removes it while returning the response from a request. The problem occurred when during the course of processing a request, a child thread was spawned, something like the following code:</source>
          <target state="translated">为了存储特定于线程的标签,log4j的NDC类使用了一个Hashtable,这个Hashtable是由线程对象本身(相对于线程id而言)来键入的,因此直到NDC标签留在内存中,所有挂在线程对象上的对象也都会留在内存中。在我们的Web应用中,我们使用NDC来标记日志输出的请求ID,以区分日志和单个请求。将NDC标记与线程关联的容器,在返回请求的响应时,也会将其删除。在处理一个请求的过程中,出现了这样的问题:在处理请求的过程中,产生了一个子线程,类似于下面的代码。</target>
        </trans-unit>
        <trans-unit id="1151b20bb174dcd65ae8dc89e7062e26b2f1ceff" translate="yes" xml:space="preserve">
          <source>In such an event where the &lt;code&gt;Connection&lt;/code&gt;'s &lt;code&gt;finalize&lt;/code&gt; method does not clean up everything, one might actually find that the physical connection to the database server will last several garbage collection cycles, until the database server eventually figures out that the connection is not alive (if it does), and should be closed.</source>
          <target state="translated">如果 &lt;code&gt;Connection&lt;/code&gt; 的 &lt;code&gt;finalize&lt;/code&gt; 方法无法清除所有内容，则实际上可能会发现与数据库服务器的物理连接将持续几个垃圾回收周期，直到数据库服务器最终确定该连接未激活为止（如果确实如此），则应将其关闭。</target>
        </trans-unit>
        <trans-unit id="a086d2d8fc03e322322053a853925ae19c3f6771" translate="yes" xml:space="preserve">
          <source>In this example, the chain of strong references looks like this:</source>
          <target state="translated">在这个例子中,强引用的链条看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="d62d178029de1efea2203c23a23efb70a4696661" translate="yes" xml:space="preserve">
          <source>In web applications, some objects are stored in application scope until the application is explicitly stopped or removed.</source>
          <target state="translated">在Web应用中,有些对象会被存储在应用范围内,直到应用程序被明确停止或删除。</target>
        </trans-unit>
        <trans-unit id="68aec4830681344f2b93563671f2dff71f1bbf04" translate="yes" xml:space="preserve">
          <source>Is a theoretically &quot;perfect&quot; Java implementation vulnerable to leaks?</source>
          <target state="translated">一个理论上 &quot;完美 &quot;的Java实现是否容易被泄露?</target>
        </trans-unit>
        <trans-unit id="05f78f8106fbe6329e286863d22b4d75d685d7ed" translate="yes" xml:space="preserve">
          <source>Is it possible in practice to make Java leak? Of course it is, and there are plenty of examples in the other answers.</source>
          <target state="translated">在实际操作中,是否有可能让Java泄露?当然可以,其他答案中也有很多例子。</target>
        </trans-unit>
        <trans-unit id="72344f67ba500872a5868aea32be6d2ec2ff0948" translate="yes" xml:space="preserve">
          <source>It is hard to asses why this applies only to &lt;code&gt;TreeMap&lt;/code&gt;s, but by looking at the implementation the reason might be that: a &lt;code&gt;TreeMap.Entry&lt;/code&gt; stores references to its siblings, therefore if a &lt;code&gt;TreeMap&lt;/code&gt; is ready to be collected, but some other class holds a reference to any of its &lt;code&gt;Map.Entry&lt;/code&gt;, then the &lt;strong&gt;entire&lt;/strong&gt; Map will be retained into memory.</source>
          <target state="translated">很难评估为什么这仅适用于 &lt;code&gt;TreeMap&lt;/code&gt; ，但是通过查看实现，原因可能是： &lt;code&gt;TreeMap.Entry&lt;/code&gt; 存储对其兄弟姐妹的引用，因此，是否准备好收集 &lt;code&gt;TreeMap&lt;/code&gt; ，但是其他一些类可以保存对其 &lt;code&gt;Map.Entry&lt;/code&gt; 的任何引用，则&lt;strong&gt;整个&lt;/strong&gt; Map将保留在内存中。</target>
        </trans-unit>
        <trans-unit id="561fe384bd30b46ac778a1ce06a62ef27c82a798" translate="yes" xml:space="preserve">
          <source>It's a waste of memory.</source>
          <target state="translated">这是在浪费记忆力。</target>
        </trans-unit>
        <trans-unit id="3214ee93295d6c88e9d4e29520c16ecb1e48337f" translate="yes" xml:space="preserve">
          <source>It's caused by a &lt;strong&gt;bug&lt;/strong&gt; or &lt;strong&gt;bad design.&lt;/strong&gt;</source>
          <target state="translated">这是由&lt;strong&gt;错误&lt;/strong&gt;或&lt;strong&gt;错误的设计&lt;/strong&gt;引起的&lt;strong&gt;。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="05faaf871b0d1119fafda19c7fdc687954cbd451" translate="yes" xml:space="preserve">
          <source>Just paste into a file named BigJarCreator.java, compile and run it from command line:</source>
          <target state="translated">只要粘贴到一个名为BigJarCreator.java的文件中,编译后在命令行中运行即可。</target>
        </trans-unit>
        <trans-unit id="f6a8033007fd6ec98535faec7a65097b14dd4f72" translate="yes" xml:space="preserve">
          <source>Let's create a second class:</source>
          <target state="translated">让我们创建第二类。</target>
        </trans-unit>
        <trans-unit id="d4bc67a5ed72fede9fcad90c9bb44a98798af683" translate="yes" xml:space="preserve">
          <source>Like we have to close SQL connections or files. We need to set proper references to null and remove elements from the collection. We shall have proper caching strategies (maximum memory size, number of elements, or timers). All objects that allow a listener to be notified must provide both a addListener and removeListener method. And when these notifiers are no longer used, they must clear their listener list.</source>
          <target state="translated">比如我们要关闭SQL连接或文件。我们需要将适当的引用设置为空,并从集合中删除元素。我们应该有适当的缓存策略(最大内存大小、元素数量或定时器)。所有允许监听器的对象必须同时提供一个addListener和removeListener方法。而且当这些通知器不再使用时,必须清除它们的监听器列表。</target>
        </trans-unit>
        <trans-unit id="3b458dced83c8ab074875078d1d91f33a9d27043" translate="yes" xml:space="preserve">
          <source>Log4j has this mechanism called &lt;a href=&quot;http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/NDC.html&quot;&gt;Nested Diagnostic Context(NDC)&lt;/a&gt;  which is an instrument to distinguish interleaved log output from different sources. The granularity at which NDC works is threads, so it distinguishes log outputs from different threads separately.</source>
          <target state="translated">Log4j具有称为&lt;a href=&quot;http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/NDC.html&quot;&gt;嵌套诊断上下文（NDC）的&lt;/a&gt;机制，该机制可以区分来自不同源的交错日志输出。 NDC工作的粒度是线程，因此它将日志输出与不同线程分开。</target>
        </trans-unit>
        <trans-unit id="a74d4d9b42b3c1615e4d56d4f582ad45b2655049" translate="yes" xml:space="preserve">
          <source>Managing a &lt;code&gt;List&lt;/code&gt; instance where you are only adding to the list and not deleting from it (although you should be getting rid of elements you no longer need), or</source>
          <target state="translated">管理仅添加到列表而不删除列表的 &lt;code&gt;List&lt;/code&gt; 实例（尽管您应该摆脱不再需要的元素），或者</target>
        </trans-unit>
        <trans-unit id="b465c99f288420225f974ac507b411ef070d8d63" translate="yes" xml:space="preserve">
          <source>Maybe by using external native code through JNI?</source>
          <target state="translated">也许通过JNI使用外部原生代码?</target>
        </trans-unit>
        <trans-unit id="8175a245c08fc481438f6815596d0da7c146e50e" translate="yes" xml:space="preserve">
          <source>Most examples here are &quot;too complex&quot;. They are edge cases. With these examples, the programmer made a mistake (like don't redefining equals/hashcode), or has been bitten by a corner case of the JVM/JAVA (load of class with static...). I think that's not the type of example an interviewer want or even the most common case.</source>
          <target state="translated">这里的例子大多是 &quot;太复杂&quot;。它们都是边缘案例。在这些例子中,程序员犯了一个错误(比如说不要重新定义 equalshashcode),或者是被JVMJAVA的一个角落案例咬住了(load of class with static...)。我认为这不是面试官想要的例子,甚至是最常见的例子。</target>
        </trans-unit>
        <trans-unit id="da0e531c2d2164c2c5e59501901aa030bdfe6f3b" translate="yes" xml:space="preserve">
          <source>Needless to say, I felt pretty dumb having no clue on how to even start creating one.</source>
          <target state="translated">不用说,我觉得自己很笨,根本不知道该如何开始创作。</target>
        </trans-unit>
        <trans-unit id="c19ee64f2381d0ee2609515e17669080e93f414f" translate="yes" xml:space="preserve">
          <source>Next you might explain creating an Object that has an underlying native resource, like this:</source>
          <target state="translated">接下来,你可能会解释一下创建一个有底层资源的对象,比如这样。</target>
        </trans-unit>
        <trans-unit id="6fd38b422389649a368e74b0ac97cd5537e46b9f" translate="yes" xml:space="preserve">
          <source>Not unloading Singletons when bringing down a Java EE application. Apparently, the Classloader that loaded the singleton class will retain a reference to the class, and hence the singleton instance will never be collected. When a new instance of the application is deployed, a new class loader is usually created, and the former class loader will continue to exist due to the singleton.</source>
          <target state="translated">带下Java EE应用程序时不卸载单体类。显然,加载了单体类的Classloader会保留对该类的引用,因此单体实例永远不会被收集。当部署一个新的应用程序实例时,通常会创建一个新的类加载器,而之前的类加载器会因为单体类而继续存在。</target>
        </trans-unit>
        <trans-unit id="9998b1000c5178e2b3e94d9693a3bf2b4281faec" translate="yes" xml:space="preserve">
          <source>Now if you call Example1 and get an Example2 discarding Example1, you will inherently still have a link to an Example1 object.</source>
          <target state="translated">现在,如果你调用实例1并得到一个丢弃了实例1的实例2,那么你本质上仍然会有一个链接到实例1对象。</target>
        </trans-unit>
        <trans-unit id="31d4698f19da02d2be9e8fdd5e63c35ecbb2df33" translate="yes" xml:space="preserve">
          <source>Of course all sort of listeners (like UI listeners), caches, or any long-lived shared state tend to produce memory leak if not properly handled. What shall be understood is that this is not a Java corner case, or a problem with the garbage collector. It is a design problem. We design that we add a listener to a long-lived object, but we don't remove the listener when no longer needed. We cache objects, but we have no strategy to remove them from the cache.</source>
          <target state="translated">当然,所有类型的监听器(如UI监听器)、缓存或任何长时间的共享状态,如果处理不当,往往会产生内存泄漏。应该理解的是,这不是Java的死角,也不是垃圾回收器的问题。它是一个设计问题。我们在设计中,我们会给一个长效对象添加一个监听器,但是当不再需要的时候,我们不会删除这个监听器。我们缓存对象,但我们没有策略将其从缓存中删除。</target>
        </trans-unit>
        <trans-unit id="f39c96ac84791daa94456083a1e63b12c3b34e64" translate="yes" xml:space="preserve">
          <source>Of course, once identified, the problem can be solved easily.</source>
          <target state="translated">当然,一旦发现问题,就可以轻松解决。</target>
        </trans-unit>
        <trans-unit id="359f9517116d8da7b1550c5bd1475ce1ff8ac81b" translate="yes" xml:space="preserve">
          <source>One of the most important skills you can develop for interviewing is learning to actively listen to the questions and working with the interviewer to extract their intent. Not only does this let you answer their question the way they want, but also shows that you have some vital communication skills. And when it comes down to a choice between many equally talented developers, I'll hire the one who listens, thinks, and understands before they respond every time.</source>
          <target state="translated">在面试中,你可以培养的最重要的技巧之一,就是学会主动倾听问题,并与面试官合作,提取他们的意图。这不仅能让你按照他们的方式回答他们的问题,还能说明你有一些重要的沟通技巧。而且,当在众多同样优秀的开发人员中做出选择的时候,我会选择在他们每次回答之前,先倾听,先思考,先理解的那个人。</target>
        </trans-unit>
        <trans-unit id="36a5e6b2c91adbb6a3e2aab7e879640729801965" translate="yes" xml:space="preserve">
          <source>One way that &lt;em&gt;used&lt;/em&gt; to work though - and I don't know if it still does - is to have a three-deep circular chain. As in Object A has a reference to Object B, Object B has a reference to Object C and Object C has a reference to Object A. The GC was clever enough to know that a two deep chain - as in A &amp;lt;--&amp;gt; B - can safely be collected if A and B aren't accessible by anything else, but couldn't handle the three-way chain...</source>
          <target state="translated">不过， &lt;em&gt;曾经&lt;/em&gt;起作用的一种方法-我不知道它是否仍然起作用-是拥有一个三层深的圆形链。 正如对象A中对对象B的引用，对象B中对对象C的引用，对象C对对象A的引用。GC非常聪明，足以知道两条深链-如A &amp;lt;-&amp;gt; B -如果A和B无法通过其他任何方式访问，但无法处理三通链，则可以安全地收集它...</target>
        </trans-unit>
        <trans-unit id="5b917237b7467dac31648fbc59206979ce55dfd9" translate="yes" xml:space="preserve">
          <source>Opening &lt;code&gt;Socket&lt;/code&gt;s or &lt;code&gt;File&lt;/code&gt;s, but not closing them when they are no longer needed (similar to the above example involving the &lt;code&gt;Connection&lt;/code&gt; class).</source>
          <target state="translated">打开 &lt;code&gt;Socket&lt;/code&gt; 或 &lt;code&gt;File&lt;/code&gt; ，但是在不再需要它们时不关闭它们（类似于上面涉及 &lt;code&gt;Connection&lt;/code&gt; 类的示例）。</target>
        </trans-unit>
        <trans-unit id="76869464027089f768f29feb0983c01df9f013f8" translate="yes" xml:space="preserve">
          <source>Or how garbage collection is supposed to work in an ideal case?</source>
          <target state="translated">或者说,在理想的情况下,垃圾回收应该如何进行?</target>
        </trans-unit>
        <trans-unit id="a6c25b025c686e8f9dc74431fd57522f3d862d94" translate="yes" xml:space="preserve">
          <source>Probably one of the simplest examples of a potential memory leak, and how to avoid it, is the implementation of ArrayList.remove(int):</source>
          <target state="translated">ArrayList.remove(int)的实现可能是一个最简单的例子,说明了一个潜在的内存泄漏,以及如何避免它。</target>
        </trans-unit>
        <trans-unit id="17fed754c98c700a1e917a4eff83b7503478c1c4" translate="yes" xml:space="preserve">
          <source>Quite simple and surprising.</source>
          <target state="translated">相当简单,也很让人惊讶。</target>
        </trans-unit>
        <trans-unit id="f8be3060c2f0cc0e7ea1d276209efffb79b9da26" translate="yes" xml:space="preserve">
          <source>Remember, memory allocations in native code come from the JVM heap.</source>
          <target state="translated">记住,本机代码中的内存分配来自于JVM堆。</target>
        </trans-unit>
        <trans-unit id="f93f18734a59d8cc05e84f1d83da3ae5a1b3c541" translate="yes" xml:space="preserve">
          <source>Repeat.</source>
          <target state="translated">Repeat.</target>
        </trans-unit>
        <trans-unit id="fa7a78b153a99b91ec29c754c3a203c8e71690c7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/wasinfo/v6r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/tprf_tunejvm.html&quot;&gt;IBM jdk settings&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;http://publib.boulder.ibm.com/infocenter/wasinfo/v6r0/index.jsp?topic=/com.ibm.websphere.express.doc/info/exp/ae/tprf_tunejvm.html&quot;&gt;IBM jdk设置&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="4342f1aa1b6f38f7d64ecef7db9d19d2d3e75a62" translate="yes" xml:space="preserve">
          <source>So an NDC context was associated with inline thread that was spawned. The thread object that was the key for this NDC context, is the inline thread which has the hugeList object hanging off of it. Hence even after the thread finished doing what it was doing, the reference to the hugeList was kept alive by the NDC context Hastable, thus causing a memory leak.</source>
          <target state="translated">因此,一个NDC上下文与内联线程相关联,而内联线程是被生出来的。作为这个NDC上下文的关键的线程对象,就是内联线程,而内联线程上挂着的是BigantList对象。因此,即使在线程完成了它正在做的事情之后,BigantList对象的引用也被NDC上下文Hastable保留了下来,从而造成了内存泄露。</target>
        </trans-unit>
        <trans-unit id="7d67985467b958c5652d6e83679a4c218ed1543a" translate="yes" xml:space="preserve">
          <source>Sure, you can make things a lot more complicated:</source>
          <target state="translated">当然,你可以把事情做得更复杂。</target>
        </trans-unit>
        <trans-unit id="cd8d76ac2082269dbea658a5d224bb45032f49e4" translate="yes" xml:space="preserve">
          <source>Take any web application running in any servlet container (Tomcat, Jetty, Glassfish, whatever...). Redeploy the app 10 or 20 times in a row (it may be enough to simply touch the WAR in the server's autodeploy directory.</source>
          <target state="translated">拿任何运行在任何servlet容器中的web应用(Tomcat、Jetty、Glassfish等)。连续重新部署该应用10到20次(可能只需在服务器的自动部署目录下触动WAR即可。</target>
        </trans-unit>
        <trans-unit id="3f0ddb50199ce6aa646038cf3549d10733a974bc" translate="yes" xml:space="preserve">
          <source>The above scenario of encountering exceptions during object finalization is related to another other scenario that could possibly lead to a memory leak - object resurrection. Object resurrection is often done intentionally by creating a strong reference to the object from being finalized, from another object. When object resurrection is misused it will lead to a memory leak in combination with other sources of memory leaks.</source>
          <target state="translated">上述在对象最终化过程中遇到异常的情况,与另一种可能导致内存泄露的情况有关--对象复活。对象复活通常是通过从被最终化的对象中,从另一个对象中创建一个强引用来有意地完成的。当对象复活被误用时,会与其他的内存泄漏源一起导致内存泄漏。</target>
        </trans-unit>
        <trans-unit id="2b9ff2a3549857707ad2be7dd1a55940374de5a7" translate="yes" xml:space="preserve">
          <source>The answer depends entirely on what the interviewer thought they were asking.</source>
          <target state="translated">答案完全取决于面试官认为自己问的是什么。</target>
        </trans-unit>
        <trans-unit id="e3695b3f538930610ef2063781d02d8ad60759f2" translate="yes" xml:space="preserve">
          <source>The application clears all references to the custom class or the &lt;code&gt;ClassLoader&lt;/code&gt; it was loaded from.</source>
          <target state="translated">应用程序清除对自定义类或从中 &lt;code&gt;ClassLoader&lt;/code&gt; 的自定义类的所有引用。</target>
        </trans-unit>
        <trans-unit id="eb7caa9734b5c2cfa40c6dd7a093614c5ac2b370" translate="yes" xml:space="preserve">
          <source>The application creates a long-running thread (or use a thread pool to leak even faster).</source>
          <target state="translated">应用程序会创建一个运行时间较长的线程(或者使用线程池来泄漏更快)。</target>
        </trans-unit>
        <trans-unit id="7f743f017b4a20fdb5c358a933b5c9d5b39a31e1" translate="yes" xml:space="preserve">
          <source>The class allocates a large chunk of memory (e.g. &lt;code&gt;new byte[1000000]&lt;/code&gt;), stores a strong reference to it in a static field, and then stores a reference to itself in a &lt;code&gt;ThreadLocal&lt;/code&gt;.  Allocating the extra memory is optional (leaking the class instance is enough), but it will make the leak work that much faster.</source>
          <target state="translated">该类分配大量内存（例如 &lt;code&gt;new byte[1000000]&lt;/code&gt; ），在静态字段中存储对它的强引用，然后在 &lt;code&gt;ThreadLocal&lt;/code&gt; 中存储对自身的引用。 分配额外的内存是可选的（泄漏类实例就足够了），但是它将使泄漏工作快得多。</target>
        </trans-unit>
        <trans-unit id="d1d4b11ad55598d70c016aed843e15846eb38a95" translate="yes" xml:space="preserve">
          <source>The easy answer is: You can't. Java does automatic memory management and will free resources that are not needed for you. You can't stop this from happening. It will ALWAYS be able to release the resources. In programs with manual memory management, this is different. You cann get some memory in C using malloc(). To free the memory, you need the pointer that malloc returned and call free() on it. But if you don't have the pointer anymore (overwritten, or lifetime exceeded), then you are unfortunately incapable of freeing this memory and thus you have a memory leak.</source>
          <target state="translated">简单的答案是:你不能。Java会自动进行内存管理,会释放出不需要的资源。你无法阻止这种情况的发生。它总是能够释放资源。在有手动内存管理的程序中,这就不同了。在C语言中,你可以使用malloc()获得一些内存。要释放内存,你需要malloc返回的指针,然后调用free()。但是,如果你不再有这个指针了(被覆盖了,或者寿命超过了),那么很不幸的是,你无法释放这个内存,从而出现了内存泄漏。</target>
        </trans-unit>
        <trans-unit id="b424fdf14efd0565b16910fc197e737854e5dbbb" translate="yes" xml:space="preserve">
          <source>The following is a pretty pointless example, if you do not understand &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_Database_Connectivity&quot;&gt;JDBC&lt;/a&gt;. Or at least how JDBC expects a developer to close &lt;code&gt;Connection&lt;/code&gt;, &lt;code&gt;Statement&lt;/code&gt; and &lt;code&gt;ResultSet&lt;/code&gt; instances before discarding them or losing references to them, instead of relying on the implementation of &lt;code&gt;finalize&lt;/code&gt;.</source>
          <target state="translated">如果您不了解&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_Database_Connectivity&quot;&gt;JDBC&lt;/a&gt; ，那么以下是一个毫无意义的示例。 或者至少JDBC希望开发人员在放弃它们，丢失对它们的引用之前关闭 &lt;code&gt;Connection&lt;/code&gt; ， &lt;code&gt;Statement&lt;/code&gt; 和 &lt;code&gt;ResultSet&lt;/code&gt; 实例，而不是依赖 &lt;code&gt;finalize&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="8b24917f88855c09f743fed66380957ea6ac7f32" translate="yes" xml:space="preserve">
          <source>The ideas of creating objects that have a very large footprint and then not being able to access them aren't real memory leaks either. If nothing can access it then it will be garbage collected, and if something can access it then it's not a leak...</source>
          <target state="translated">创建的对象有很大的占用空间,然后无法访问的想法也不是真正的内存泄露。如果没有东西可以访问它,那么它就会被垃圾回收,如果有东西可以访问它,那么它就不是泄漏......</target>
        </trans-unit>
        <trans-unit id="498384654cf1a60837b9c1e363e1194c26e66a19" translate="yes" xml:space="preserve">
          <source>The interviewer might have be looking for a circular reference solution:</source>
          <target state="translated">面试官可能正在寻找一个循环参考的解决方案。</target>
        </trans-unit>
        <trans-unit id="412ce2817e5c890b4523cb4a740d986a34dfcdb5" translate="yes" xml:space="preserve">
          <source>The interviewer was probably looking for a circular reference like the code below (which incidentally only leak memory in very old JVMs that used reference counting, which isn't the case any more).  But it's a pretty vague question, so it's a prime opportunity to show off your understanding of JVM memory management.</source>
          <target state="translated">面试官可能是在找一个像下面这段代码一样的循环引用(顺便说一下,在非常古老的JVM中,只有使用引用计数的JVM才会泄露内存,现在已经不是这样了)。但这是一个相当模糊的问题,所以这是一个展示你对JVM内存管理理解的黄金机会。</target>
        </trans-unit>
        <trans-unit id="8dc73d2ce0e83223aa03d41ab80d35a989d7f58c" translate="yes" xml:space="preserve">
          <source>The long answer is: You can get a memory leak by writing a library for Java using the JNI, which can have manual memory management and thus have memory leaks. If you call this library, your java process will leak memory. Or, you can have bugs in the JVM, so that the JVM looses memory. There are probably bugs in the JVM, there may even be some known ones since garbage collection is not that trivial, but then it's still a bug. By design this is not possible. You may be asking for some java code that is effected by such a bug. Sorry I don't know one and it might well not be a bug anymore in the next Java version anyway.</source>
          <target state="translated">长此以往的答案是:你可以通过使用JNI为Java编写一个库来获得内存泄漏,这个库可以有手动管理内存的功能,从而产生内存泄漏。如果你调用这个库,你的java进程就会出现内存泄漏。或者,你可以在JVM中存在BUG,这样JVM就会出现内存泄漏。JVM中可能有bug,甚至可能有一些已知的bug,因为垃圾回收并不是那么琐碎,但那样的话还是会有bug。从设计上看,这是不可能的。你可能会问一些受这样的bug影响的java代码。对不起,我不知道一个,而且很可能在下一个Java版本中不再是bug了。</target>
        </trans-unit>
        <trans-unit id="adea7071c985a58f8fd610cc024525873a3aa3a3" translate="yes" xml:space="preserve">
          <source>The problem is, the lifetime of the container is longer than the lifetime of your application. You have to make sure that all references the container might have to objects or classes of your application can be garbage collected.</source>
          <target state="translated">问题是,容器的生命周期比你的应用程序的生命周期要长。你必须确保容器可能对你的应用程序的对象或类的所有引用都能被垃圾回收。</target>
        </trans-unit>
        <trans-unit id="32354f8645f398ec02633b310f2fbfabd89963a0" translate="yes" xml:space="preserve">
          <source>The problem with the above is that the &lt;code&gt;Connection&lt;/code&gt; object is not closed, and hence the physical connection will remain open, until the garbage collector comes around and sees that it is unreachable. GC will invoke the &lt;code&gt;finalize&lt;/code&gt; method, but there are JDBC drivers that do not implement the &lt;code&gt;finalize&lt;/code&gt;, at least not in the same way that &lt;code&gt;Connection.close&lt;/code&gt; is implemented. The resulting behavior is that while memory will be reclaimed due to unreachable objects being collected, resources (including memory) associated with the &lt;code&gt;Connection&lt;/code&gt; object might simply not be reclaimed.</source>
          <target state="translated">上面的问题是 &lt;code&gt;Connection&lt;/code&gt; 对象没有关闭，因此物理连接将保持打开状态，直到垃圾回收器出现并且无法访问为止。 GC将调用 &lt;code&gt;finalize&lt;/code&gt; 方法，但是有些JDBC驱动程序没有实现 &lt;code&gt;finalize&lt;/code&gt; ，至少与实现 &lt;code&gt;Connection.close&lt;/code&gt; 的方式不同。 导致的行为是，由于将收集无法访问的对象而将回收内存，而与 &lt;code&gt;Connection&lt;/code&gt; 对象关联的资源（包括内存）可能根本不会回收。</target>
        </trans-unit>
        <trans-unit id="c0492784502ac7b023338bf1861aa0d6c1111248" translate="yes" xml:space="preserve">
          <source>The same case with &lt;code&gt;java.util.zip.Deflater&lt;/code&gt;. This one is far worse since Deflater is memory hungry in Java, i.e. always uses 15&amp;nbsp;bits (max) and 8&amp;nbsp;memory levels (9 is max) allocating several hundreds KB of native memory. Fortunately, &lt;code&gt;Deflater&lt;/code&gt; is not widely used and to my knowledge JDK contains no misuses. Always call &lt;code&gt;end()&lt;/code&gt; if you manually create a &lt;code&gt;Deflater&lt;/code&gt; or &lt;code&gt;Inflater&lt;/code&gt;. The best part of the last two: &lt;em&gt;you can't find them via normal profiling tools available.&lt;/em&gt;</source>
          <target state="translated">与 &lt;code&gt;java.util.zip.Deflater&lt;/code&gt; 相同。 由于Deflater在Java中占用大量内存，因此这一情况要糟得多，即，始终使用15位（最大）和8个内存级别（最大9个）分配数百KB的本机内存。 幸运的是， &lt;code&gt;Deflater&lt;/code&gt; 并未得到广泛使用，据我所知JDK不包含任何误用。 如果您手动创建 &lt;code&gt;Deflater&lt;/code&gt; 或 &lt;code&gt;Inflater&lt;/code&gt; ,请始终调用 &lt;code&gt;end()&lt;/code&gt; 。 最后两个最好的部分： &lt;em&gt;您无法通过可用的常规配置工具找到它们。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7730755a141a588beb950cf6c7f3e8017ee4066" translate="yes" xml:space="preserve">
          <source>The same does not happen with a hashed data-structure (&lt;code&gt;HashMap&lt;/code&gt;).</source>
          <target state="translated">哈希数据结构（ &lt;code&gt;HashMap&lt;/code&gt; ）不会发生相同的情况。</target>
        </trans-unit>
        <trans-unit id="0352f2341f5f449ba06bcda30149e5f08b413dbd" translate="yes" xml:space="preserve">
          <source>The thread loads a class via an (optionally custom) &lt;code&gt;ClassLoader&lt;/code&gt;.</source>
          <target state="translated">线程通过（可选地，自定义） &lt;code&gt;ClassLoader&lt;/code&gt; 加载类 。</target>
        </trans-unit>
        <trans-unit id="6fedeb1df7f6b88de765c27a7adbb0fdeb28d8aa" translate="yes" xml:space="preserve">
          <source>The way to avoid storing an unwanted reference to the original string is to do something like this:</source>
          <target state="translated">避免存储一个不需要的原始字符串引用的方法是这样做。</target>
        </trans-unit>
        <trans-unit id="45629db4e3dbdc5582d4bb13414ae467af08c8bb" translate="yes" xml:space="preserve">
          <source>Then you can explain that with reference counting, the above code would leak memory.  But most modern JVMs don't use reference counting any longer, most use a sweep garbage collector, which will in fact collect this memory.</source>
          <target state="translated">那么你可以解释一下,用引用计数,上面的代码会泄露内存。但大多数现代的JVM已经不使用引用计数了,大多数使用的是扫码垃圾收集器,实际上会收集这些内存。</target>
        </trans-unit>
        <trans-unit id="66d4e8703685eff6d732f6391330bb34727fe15c" translate="yes" xml:space="preserve">
          <source>Then you can explain this is technically a memory leak, but really the leak is caused by native code in the JVM allocating underlying native resources, which weren't freed by your Java code.</source>
          <target state="translated">那么你可以解释一下,这在技术上是内存泄露,但真正的泄露是由JVM中的原生代码分配底层原生资源造成的,而这些资源并没有被你的Java代码释放出来。</target>
        </trans-unit>
        <trans-unit id="ffc5e9bb3e214badc001c96e9c2a5a49f5a27f5e" translate="yes" xml:space="preserve">
          <source>There are plenty more examples that you can conjure up - like</source>
          <target state="translated">你能想到的例子还有很多,比如说</target>
        </trans-unit>
        <trans-unit id="904011d1f23e7492eaba27cbc41be9c7c5b6df7a" translate="yes" xml:space="preserve">
          <source>This class basically does nothing, but create unreferenced InputStream objects. Those objects will be garbage collected immediately and thus, do not contribute to heap size.
It is important for our example to load an existing resource from a jar file, and size does matter here!</source>
          <target state="translated">这个类基本上什么也不做,只是创建一些没有引用的 InputStream 对象。这些对象将立即被垃圾回收,因此不会增加堆的大小。对于我们的例子来说,从jar文件中加载一个现有的资源是很重要的,而在这里,大小确实很重要!</target>
        </trans-unit>
        <trans-unit id="aafd3bef6db7342b162f90ff472dde6af8ff6c40" translate="yes" xml:space="preserve">
          <source>This is a classic problem with reference counting garbage collectors.  You would then politely explain that JVMs use a much more sophisticated algorithm that doesn't have this limitation.</source>
          <target state="translated">这是引用计数垃圾回收器的一个典型问题。然后你会委婉地解释说,JVM使用的是一种更复杂的算法,没有这个限制。</target>
        </trans-unit>
        <trans-unit id="c4fe560b3789232951558a324f943b367a22a050" translate="yes" xml:space="preserve">
          <source>This is the graph when using a &lt;code&gt;HashMap&lt;/code&gt;.</source>
          <target state="translated">这是使用 &lt;code&gt;HashMap&lt;/code&gt; 时的图。</target>
        </trans-unit>
        <trans-unit id="b145c727efa517020a8f1c0a55c1c2da20a12547" translate="yes" xml:space="preserve">
          <source>Threads are not collected until they terminate. They serve as &lt;a href=&quot;https://stackoverflow.com/questions/6366211/what-are-the-roots&quot;&gt;roots&lt;/a&gt; of garbage collection. They are one of the few objects that won't be reclaimed simply by forgetting about them or clearing references to them.</source>
          <target state="translated">线程直到终止才被收集。 它们是垃圾收集的&lt;a href=&quot;https://stackoverflow.com/questions/6366211/what-are-the-roots&quot;&gt;根源&lt;/a&gt; 。 它们是为数不多的仅通过忘记它们或清除对它们的引用就不会对其进行回收的对象之一。</target>
        </trans-unit>
        <trans-unit id="a4085f8f26ad02cf20cca7df5130111f289a5f5a" translate="yes" xml:space="preserve">
          <source>Threads started by your application, ThreadLocal variables, logging appenders are some of the usual suspects to cause classloader leaks.</source>
          <target state="translated">你的应用程序启动的线程、ThreadLocal变量、日志加载器是导致classloader泄漏的一些常见嫌疑人。</target>
        </trans-unit>
        <trans-unit id="19e95f717de5b1ff354994ef88c03939a32c2c41" translate="yes" xml:space="preserve">
          <source>Uhm, you might say, what an idiot.</source>
          <target state="translated">呃,你可以说,真是个白痴。</target>
        </trans-unit>
        <trans-unit id="0008cf97a597cccd424ebf9a467479cf5807f825" translate="yes" xml:space="preserve">
          <source>Unless anybody has actually tested this, chances are high that you'll get an OutOfMemoryError after a couple of redeployments, because the application did not take care to clean up after itself. You may even find a bug in your server with this test.</source>
          <target state="translated">除非有人实际测试过,否则你在几次重新部署后很有可能会得到一个OutOfMemoryError,因为应用程序没有注意清理自己。你甚至可能会在这个测试中发现你的服务器上有一个bug。</target>
        </trans-unit>
        <trans-unit id="128a6307eefbc715ecb4699ab3da65a0639066f2" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;InflaterInputStream&lt;/code&gt; passing &lt;code&gt;new java.util.zip.Inflater()&lt;/code&gt; in the constructor (&lt;code&gt;PNGImageDecoder&lt;/code&gt; for instance) and not calling &lt;code&gt;end()&lt;/code&gt; of the inflater. Well, if you pass in the constructor with just &lt;code&gt;new&lt;/code&gt;, no chance... And yes, calling &lt;code&gt;close()&lt;/code&gt; on the stream does not close the inflater if it's manually passed as constructor parameter. This is not a true leak since it'd be released by the finalizer... when it deems it necessary. Till that moment it eats native memory so badly it can cause Linux oom_killer to kill the process with impunity. The main issue is that finalization in Java is very unreliable and G1 made it worse till 7.0.2. Moral of the story: release native resources as soon as you can; the finalizer is just too poor.</source>
          <target state="translated">使用 &lt;code&gt;PNGImageDecoder&lt;/code&gt; 在构造函数（例如PNGImageDecoder &lt;code&gt;new java.util.zip.Inflater()&lt;/code&gt; 中传递新的java.util.zip.Inflater（） ，而不调用充气器的 &lt;code&gt;end()&lt;/code&gt; 。 好吧，如果您传入 &lt;code&gt;new&lt;/code&gt; 的构造函数，就没有机会了&amp;hellip;&amp;hellip;是的，如果手动将其作为构造函数参数传递，则在流上调用 &lt;code&gt;close()&lt;/code&gt; 不会关闭充气机。 这不是真正的泄漏，因为它将由终结器释放&amp;hellip;&amp;hellip;在其认为必要时。 直到那一刻，它严重消耗了本机内存，可能导致Linux oom_killer毫无惩罚地终止进程。 主要问题是Java中的终结处理非常不可靠，G1恶化到7.0.2。 故事的寓意：尽快释放本机资源； 终结器太差了。</target>
        </trans-unit>
        <trans-unit id="db7f83d9c472fa43a63151a5e4c317b7c3bbf627" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;java.net.URL&lt;/code&gt; with the HTTP(S) protocol and loading the resource from(!). This one is special, the &lt;code&gt;KeepAliveCache&lt;/code&gt; creates a new thread in the system ThreadGroup which leaks the current thread's context classloader. The thread is created upon the first request when no alive thread exists, so either you may get lucky or just leak. &lt;em&gt;The leak is already fixed in Java&amp;nbsp;7 and the code that creates thread properly removes the context classloader.&lt;/em&gt; There are few more cases (&lt;del&gt;like ImageFetcher&lt;/del&gt;, &lt;em&gt;also fixed&lt;/em&gt;) of creating similar threads.</source>
          <target state="translated">使用具有HTTP（S）协议的 &lt;code&gt;java.net.URL&lt;/code&gt; 并从（！）加载资源。 这很特殊， &lt;code&gt;KeepAliveCache&lt;/code&gt; 在系统ThreadGroup中创建了一个新线程，该线程泄漏了当前线程的上下文类加载器。 当没有活动线程存在时，该线程是在第一个请求时创建的，因此您可能会很幸运或只是泄漏。 &lt;em&gt;Java 7中已经修复了该泄漏，并且正确创建线程的代码会删除上下文类加载器。&lt;/em&gt; 还有其他几种情况（ &lt;del&gt; 像ImageFetcher &lt;/del&gt; ， &lt;em&gt;也修复&lt;/em&gt;了创建类似线程的问题）。</target>
        </trans-unit>
        <trans-unit id="7e2bd08997e52249f29d0c756352856016775283" translate="yes" xml:space="preserve">
          <source>Using WeakHashMap and the value (in)directly references the key. This is a hard one to find without a heap dump. That applies to all extended &lt;code&gt;Weak/SoftReference&lt;/code&gt; that might keep a hard reference back to the guarded object.</source>
          <target state="translated">使用WeakHashMap和值（in）直接引用键。 如果没有堆转储，这是很难找到的。 这适用于所有扩展的 &lt;code&gt;Weak/SoftReference&lt;/code&gt; ，这些扩展可能会将硬引用保留回受保护的对象。</target>
        </trans-unit>
        <trans-unit id="5fa1d1f56ee0faa7d0cf56ebc24c98388dcc729f" translate="yes" xml:space="preserve">
          <source>We maybe have a complex graph that store the previous state that is needed by a computation. But the previous state is itself linked to the state before and so on.</source>
          <target state="translated">我们也许有一个复杂的图,它存储了一个计算所需要的前一个状态。但前一个状态本身是和前一个状态等联系在一起的。</target>
        </trans-unit>
        <trans-unit id="5fd7c424bc08d42aa85bcb6558d5264996a2b57a" translate="yes" xml:space="preserve">
          <source>Well, what makes this interesting is: this way, you can leak heap memory of the underlying process, rather than from JVM's heap.</source>
          <target state="translated">那么,让人感兴趣的是:这样一来,你可以泄露底层进程的堆内存,而不是从JVM的堆中泄露。</target>
        </trans-unit>
        <trans-unit id="1e8f1a2cab2a1e8c521b8499a326ad722ac22533" translate="yes" xml:space="preserve">
          <source>What would an example be?</source>
          <target state="translated">一个例子会是什么呢?</target>
        </trans-unit>
        <trans-unit id="2bcbc0f27e355df9586f60612ed6c419c0b76ba0" translate="yes" xml:space="preserve">
          <source>What's a memory leak:</source>
          <target state="translated">什么是内存泄露。</target>
        </trans-unit>
        <trans-unit id="8e57ea67c0d0d56590c6fc284fb243c6af72b231" translate="yes" xml:space="preserve">
          <source>With pure Java, it is almost impossible.</source>
          <target state="translated">用纯Java,这几乎是不可能的。</target>
        </trans-unit>
        <trans-unit id="e3503ae94b2d7d671b690c78d933fef4b9fd517a" translate="yes" xml:space="preserve">
          <source>You are able to make memory leak with &lt;strong&gt;sun.misc.Unsafe&lt;/strong&gt; class. In fact this service class is used in different standard classes (for example in &lt;strong&gt;java.nio&lt;/strong&gt; classes). &lt;strong&gt;You can't create instance of this class directly&lt;/strong&gt;, but you may &lt;strong&gt;use reflection to do that&lt;/strong&gt;.</source>
          <target state="translated">您可以使用&lt;strong&gt;sun.misc.Unsafe&lt;/strong&gt;类使内存泄漏。 实际上，此服务类在不同的标准类中使用（例如，在&lt;strong&gt;java.nio&lt;/strong&gt;类中）。 &lt;strong&gt;您不能直接创建此类的实例&lt;/strong&gt; ，但是您可以&lt;strong&gt;使用反射来实现&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="495db2d0ecb2b5d6486e34663aac96fb78fd63b3" translate="yes" xml:space="preserve">
          <source>You can create a moving memory leak by creating a new instance of a class in that class's finalize method. Bonus points if the finalizer creates multiple instances. Here's a simple program that leaks the entire heap in sometime between a few seconds and a few minutes depending on your heap size:</source>
          <target state="translated">你可以通过在类的finalize方法中创建一个新的类的实例来创建一个移动内存泄漏。如果finalize方法创建了多个实例,可以获得奖励。这里有一个简单的程序,可以在几秒钟到几分钟的时间内泄漏整个堆,这取决于你的堆大小。</target>
        </trans-unit>
        <trans-unit id="c72266e96293bbdf8f5fe332a36656dce96d27dc" translate="yes" xml:space="preserve">
          <source>You can easily create such a jar with the following class:</source>
          <target state="translated">你可以用下面的类轻松创建这样一个罐子。</target>
        </trans-unit>
        <trans-unit id="fefe0fe4e4d641d9025b925dd7404b2aa130fb61" translate="yes" xml:space="preserve">
          <source>You can see from this &lt;code&gt;visualvm&lt;/code&gt; graph how the memory keeps growing.</source>
          <target state="translated">您可以从此 &lt;code&gt;visualvm&lt;/code&gt; 图形中看到内存如何保持增长。</target>
        </trans-unit>
        <trans-unit id="d8c3ed8ac3489419651ba518cc481631d2dc3ca9" translate="yes" xml:space="preserve">
          <source>You will not encounter an OOM error here, as no references are kept, the application will keep running no matter how large you chose ITERATIONS in the above example.
The memory consumption of your process (visible in top (RES/RSS) or process explorer) grows unless the application gets to the wait command. In the setup above, it will allocate around 150 MB in memory.</source>
          <target state="translated">在这里你不会遇到OOM错误,因为没有保留任何引用,无论你在上面的例子中选择了ITERATIONS有多大,应用程序都会继续运行。你的进程(在顶部(RESRSS)或进程资源管理器中可见)的内存消耗会增长,除非应用程序到达等待命令。在上面的设置中,它将分配大约150MB的内存。</target>
        </trans-unit>
        <trans-unit id="86f8f434981fb71a8e76491c4a7a343cf03466a0" translate="yes" xml:space="preserve">
          <source>Your cache grows and grows. And pretty soon the entire database gets sucked into memory. A better design uses an LRUMap (Only keeps recently used objects in cache).</source>
          <target state="translated">你的缓存会越来越大,越来越多。而且很快整个数据库就会被吸进内存。一个更好的设计是使用LRUMap(只保留最近使用的对象在缓存中)。</target>
        </trans-unit>
        <trans-unit id="ad36d9e69cb6c7cf2acdd873fd137df990e16c0b" translate="yes" xml:space="preserve">
          <source>adding more &lt;strong&gt;complex reference trees&lt;/strong&gt;.</source>
          <target state="translated">添加更&lt;strong&gt;复杂的参考树&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="dff532b2bed649cb51e0055c618ee5a7df1d5e3b" translate="yes" xml:space="preserve">
          <source>and your process will not exceed 35 MB, independent of the iteration count.</source>
          <target state="translated">和你的进程不会超过35MB,与迭代次数无关。</target>
        </trans-unit>
        <trans-unit id="5d0578d4d75c5bea4841ed0d843dfa4511871bc3" translate="yes" xml:space="preserve">
          <source>or leaks caused by &lt;strong&gt;3rd party libraries&lt;/strong&gt;.</source>
          <target state="translated">或由&lt;strong&gt;第三方图书馆&lt;/strong&gt;引起的泄漏。</target>
        </trans-unit>
        <trans-unit id="6dc2a9f3e198de9ab5c44591f007d29eb6dce64c" translate="yes" xml:space="preserve">
          <source>using &lt;strong&gt;ThreadLocal&lt;/strong&gt; constructions.</source>
          <target state="translated">使用&lt;strong&gt;ThreadLocal&lt;/strong&gt;构造。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
