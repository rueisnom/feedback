<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/6441218">
    <body>
      <group id="6441218">
        <trans-unit id="f5f16923f0af049a9268d2bca9a807fbee68cdfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; might in fact genuinely be a valid address of a double, e.g. &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 는 실제로 double의 유효한 주소, 예를 들어 &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt; q = &amp;amp; p; .</target>
        </trans-unit>
        <trans-unit id="2323769261698fad3bf45ce9c6dead419d7ed3ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; might point somewhere inside allocated memory and I just overwrite 8 bytes in there.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 는 할당 된 메모리 내부를 가리킬 수 있으며 8 바이트를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="89dc785e6f5a1676a10c0b1098798eb7eb2480dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; points outside allocated memory and the operating system's memory manager sends a segmentation fault signal to my program, causing the runtime to terminate it.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 할당 된 메모리 외부의 포인트를 가리키고 운영 체제의 메모리 관리자가 세그먼트 오류 신호를 내 프로그램으로 보내 런타임이이를 종료시킵니다.</target>
        </trans-unit>
        <trans-unit id="199f80d5e26390e5ebf9e949c594dd75500aa2da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Let me take a real world example:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;실제 예를 들어 보겠습니다.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="092cbceb9ffa47ba2a3d0a48ececdefff70b083a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ is not a safe language&lt;/strong&gt;. It will cheerfully allow you to break the rules of the system. If you try to do something illegal and foolish like going back into a room you're not authorized to be in and rummaging through a desk that might not even be there anymore, C++ is not going to stop you. Safer languages than C++ solve this problem by restricting your power -- by having much stricter control over keys, for example.</source>
          <target state="translated">&lt;strong&gt;C ++는 안전한 언어가 아닙니다&lt;/strong&gt; . 유쾌하게 시스템의 규칙을 어길 수 있습니다. 당신이 방으로 돌아가는 것처럼 불법적이고 어리석은 짓을하려고한다면 더 이상 없을 수도있는 책상에 들어 와서 넘어 질 수있는 권한이 없습니다. C ++은 당신을 막을 수 없습니다. C ++보다 안전한 언어는 예를 들어 키를 훨씬 더 엄격하게 제어하여 전력을 제한함으로써이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="6c1c49fcc0bc7f787bb6de1ef0e235efab3bfc3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How can that be? Aren't the contents of a hotel room drawer inaccessible if you haven't rented the room?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어떻게 그렇게 될수 있니?&lt;/strong&gt; &lt;strong&gt;방을 임대하지 않은 경우 호텔 방 서랍의 내용에 액세스 할 수 없습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c802d8f0f438f6d01b82bd537e9909b51c503a35" translate="yes" xml:space="preserve">
          <source>A little addition to all the answers:</source>
          <target state="translated">모든 답변에 약간의 추가 :</target>
        </trans-unit>
        <trans-unit id="ee1cefbbc3f6ae87dd7e67ea9cfb80dac82e13c9" translate="yes" xml:space="preserve">
          <source>A week later, you return to the hotel, do not check in, sneak into your old room with your stolen key, and look in the drawer. Your book is still there. Astonishing!</source>
          <target state="translated">일주일 후, 당신은 호텔로 돌아와 체크인하지 않고, 열쇠를 훔쳐서 오래된 방으로 몰래 들어가서 서랍을 봅니다. 당신의 책은 여전히 ​​있습니다. 놀라운!</target>
        </trans-unit>
        <trans-unit id="9125bf2280239c3b164efc1df4e296b36f1c41f1" translate="yes" xml:space="preserve">
          <source>After returning from a function, all identifiers are destroyed instead of kept values in a memory location and we can not locate the values without having an identifier.But that location still contains the value stored by previous function.</source>
          <target state="translated">함수에서 돌아온 후 메모리 위치에 값을 유지하는 대신 모든 식별자가 소멸되며 식별자가 없으면 값을 찾을 수 없지만 해당 위치에는 여전히 이전 함수에 저장된 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="551408e0c19118edd84d52d381542cdcbdda834c" translate="yes" xml:space="preserve">
          <source>An implementation of C++ is not required to ensure that when the stack logically shrinks, the addresses that used to be valid are still mapped into memory. The implementation is allowed to tell the operating system &quot;we're done using this page of stack now. Until I say otherwise, issue an exception that destroys the process if anyone touches the previously-valid stack page&quot;.  Again, implementations do not actually do that because it is slow and unnecessary.</source>
          <target state="translated">스택이 논리적으로 축소 될 때 유효한 주소가 여전히 메모리에 매핑되도록 C ++을 구현할 필요는 없습니다. 구현은 운영 체제에 &quot;지금이 스택 페이지를 사용하여 완료되었습니다. 달리 말할 때까지 누군가가 이전에 유효한 스택 페이지를 건 드리면 프로세스를 파괴하는 예외를 발행합니다&quot;라고 말할 수 있습니다. 다시 말하지만 구현은 느리고 불필요하기 때문에 실제로는 그렇게하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e4a51f2c5d3df5cc305fe5241ee9f91c1862f4a" translate="yes" xml:space="preserve">
          <source>An implementation of C++ is not required to leave the garbage you left on the stack untouched so that you can come back for it later illegally; it is perfectly legal for the compiler to generate code that turns back to zero everything in the &quot;room&quot; that you just vacated. It doesn't because again, that would be expensive.</source>
          <target state="translated">C ++ 구현은 스택에 남겨둔 쓰레기를 건드리지 않고 나중에 불법으로 되돌릴 수 있도록 요구하지 않습니다. 방금 비운 &quot;방&quot;의 모든 것을 0으로 되 돌리는 코드를 컴파일러가 생성하는 것은 합법적입니다. 다시 비싸지 않기 때문에 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="107c7e3b89899d409b00af753e9116c3756b3bed" translate="yes" xml:space="preserve">
          <source>And the code is just running with no runtime exceptions!</source>
          <target state="translated">그리고 런타임 예외없이 코드가 실행 중입니다!</target>
        </trans-unit>
        <trans-unit id="2eef47beb4615f77d95310d433dca2a905f6afd0" translate="yes" xml:space="preserve">
          <source>Because the storage space wasn't stomped on just yet. Don't count on that behavior.</source>
          <target state="translated">저장 공간이 아직 스톰하지 않았기 때문입니다. 그 행동에 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4c294f2376bf1ce93f3fa4b96d3051ce6d617ff9" translate="yes" xml:space="preserve">
          <source>But I agree with Mark B that the resulting behavior is undefined.</source>
          <target state="translated">그러나 결과적인 동작이 정의되지 않았다는 마크 B에 동의합니다.</target>
        </trans-unit>
        <trans-unit id="b1cc5de4f5cc262455af25eee537c1fbe8ede183" translate="yes" xml:space="preserve">
          <source>Can a local variable's memory be accessed outside its scope</source>
          <target state="translated">범위 밖에서 지역 변수의 메모리에 접근 할 수 있습니까</target>
        </trans-unit>
        <trans-unit id="b2a932b65ee498810514c1bea0d35efc855a4f81" translate="yes" xml:space="preserve">
          <source>Compilers are in the business of generating code which manages the storage of the data manipulated by that program. There are lots of different ways of generating code to manage memory, but over time two basic techniques have become entrenched.</source>
          <target state="translated">컴파일러는 해당 프로그램에 의해 조작 된 데이터의 저장을 관리하는 코드를 생성하는 사업에 있습니다. 메모리를 관리하기 위해 코드를 생성하는 방법에는 여러 가지가 있지만 시간이 지남에 따라 두 가지 기본 기술이 확립되었습니다.</target>
        </trans-unit>
        <trans-unit id="c817be5dd088db601f9b4bede3267671d06ac959" translate="yes" xml:space="preserve">
          <source>Consider this example, instead, and test it:</source>
          <target state="translated">대신이 예제를 고려하여 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="c0f296eb7c38fa507531b7353e52a86837866c31" translate="yes" xml:space="preserve">
          <source>Did you compile your program with the optimiser enabled? The &lt;code&gt;foo()&lt;/code&gt; function is quite simple and might have been inlined or replaced in the resulting code.</source>
          <target state="translated">옵티 마이저를 사용하여 프로그램을 컴파일 했습니까? &lt;code&gt;foo()&lt;/code&gt; 함수는 매우 단순하며 결과 코드에서 인라인되거나 대체되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b807ff8ce557df22c0a2b48e1eb3c952a35d8a67" translate="yes" xml:space="preserve">
          <source>For an example of the kind of spooky behavior you are &lt;em&gt;likely&lt;/em&gt; to get, try this sample:</source>
          <target state="translated">얻을 수있는 짜증나는 행동의 예를 보려면 다음 샘플을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="5c70b26fb103aa28d932d18050cb856e801635d4" translate="yes" xml:space="preserve">
          <source>For further reading:</source>
          <target state="translated">더 읽을 거리 :</target>
        </trans-unit>
        <trans-unit id="1bf2110822fba72487dccdd77a2d40f6bd00662b" translate="yes" xml:space="preserve">
          <source>For this reason, local variables are usually generated as storage on a &quot;stack&quot; data structure, because a stack has the property that the first thing pushed on it is going to be the last thing popped off.</source>
          <target state="translated">이러한 이유로 로컬 변수는 일반적으로 &quot;스택&quot;데이터 구조의 저장소로 생성됩니다. 스택에는 가장 먼저 밀어 넣은 속성이 마지막으로 사라지는 속성이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5efbdcdc6578ea05130db18ac54a4c2a591f0648" translate="yes" xml:space="preserve">
          <source>GCC shows this Warning</source>
          <target state="translated">GCC는이 경고를 보여줍니다</target>
        </trans-unit>
        <trans-unit id="b10d57cc173a336784fa10ae3535545c463b017f" translate="yes" xml:space="preserve">
          <source>Here I am simply treating 123456 as the address of a double and write to it. Any number of things could happen:</source>
          <target state="translated">여기서는 단순히 123456을 double의 주소로 취급하여 작성합니다. 여러 가지 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cac5d1b4d781ba7ae7623777363b8748a7fffdc9" translate="yes" xml:space="preserve">
          <source>Holy goodness, this answer is getting a lot of attention. (I'm not sure why -- I considered it to be just a &quot;fun&quot; little analogy, but whatever.)</source>
          <target state="translated">신의 선하심,이 대답은 많은 주목을 받고 있습니다. (왜 그런지 잘 모르겠습니다. 나는 그것이 단지 &quot;재미있는&quot;작은 비유라고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="3fc5e06963f155f494425e90cc027ebe74ce7146" translate="yes" xml:space="preserve">
          <source>How can it be? Isn't the memory of a local variable inaccessible outside its function?</source>
          <target state="translated">어떻게 할 수 있습니까? 함수 외부에서 로컬 변수의 메모리에 액세스 할 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="3fb4e1bfa90528212a424b3831d731b3a5295bc1" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;undefined&lt;/em&gt; behaviour and you should not rely on it to work!</source>
          <target state="translated">그러나 이것은 &lt;em&gt;정의되지 않은&lt;/em&gt; 동작이므로 작동에 의존해서는 안됩니다!</target>
        </trans-unit>
        <trans-unit id="a7065978f6d14568e0e790c7484b61564f9f8483" translate="yes" xml:space="preserve">
          <source>I have the following code.</source>
          <target state="translated">다음 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9e4823ab18ab248ad0ae5098903f1270fb34501" translate="yes" xml:space="preserve">
          <source>I thought it might be germane to update this a bit with a few more technical thoughts.</source>
          <target state="translated">나는 약간의 기술적 인 생각으로 이것을 조금 업데이트하는 것이 독창적이라고 생각했다.</target>
        </trans-unit>
        <trans-unit id="e84b4bc2bc02c2ff515aa6c327f740c5f39d484a" translate="yes" xml:space="preserve">
          <source>In C++, you &lt;em&gt;can&lt;/em&gt; access any address, but it doesn't mean you &lt;em&gt;should&lt;/em&gt;. The address you are accessing is no longer valid. It &lt;em&gt;works&lt;/em&gt; because nothing else scrambled the memory after foo returned, but it could crash under many circumstances. Try analyzing your program with &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt;, or even just compiling it optimized, and see...</source>
          <target state="translated">C ++에서는 모든 주소에 액세스 할 &lt;em&gt;수&lt;/em&gt; 있지만 &lt;em&gt;반드시해야하는&lt;/em&gt; 것은 아닙니다. 액세스중인 주소가 더 이상 유효하지 않습니다. foo가 반환 된 후 메모리를 뒤섞은 것이 없기 때문에 &lt;em&gt;작동&lt;/em&gt; 하지만 많은 상황에서 충돌 할 수 있습니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind를 사용&lt;/a&gt; 하여 프로그램을 분석하거나 최적화 된 컴파일을 시도해보십시오.</target>
        </trans-unit>
        <trans-unit id="d0fe5db286c8dab66cb0d3b82b36a45e675f7834" translate="yes" xml:space="preserve">
          <source>In short: this won't usually work, but sometimes will by chance.</source>
          <target state="translated">요컨대 이것은 일반적으로 작동하지 않지만 때로는 우연히 발생합니다.</target>
        </trans-unit>
        <trans-unit id="884f6b5a0e405708c0d3da980d10be30e33501e7" translate="yes" xml:space="preserve">
          <source>In this situation &lt;strong&gt;anything can happen&lt;/strong&gt;. The book can be there -- you got lucky. Someone else's book can be there and yours could be in the hotel's furnace. Someone could be there right when you come in, tearing your book to pieces. The hotel could have removed the table and book entirely and replaced it with a wardrobe. The entire hotel could be just about to be torn down and replaced with a football stadium, and you are going to die in an explosion while you are sneaking around.</source>
          <target state="translated">이 상황에서는 &lt;strong&gt;어떤 일이든 일어날 수 있습니다&lt;/strong&gt; . 책은 거기있을 수 있습니다. 운이 좋았습니다. 다른 사람의 책이있을 수 있으며 호텔의 화로에있을 수도 있습니다. 당신이 들어 와서 책을 여러 조각으로 찢어 버릴 수 있습니다. 호텔에서 테이블을 제거하고 완전히 예약하여 옷장으로 교체했을 수 있습니다. 호텔 전체가 찢어지고 축구 경기장으로 교체 될 수 있으며, 몰래 숨을 쉴 때 폭발로 사망 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e771043fe216902e4ecf87e32bed904be6c6fe8" translate="yes" xml:space="preserve">
          <source>In typical compiler implementations, you can think of the code as &quot;print out the value of the memory block with adress that &lt;em&gt;used to be&lt;/em&gt; occupied by a&quot;. Also, if you add a new function invocation to a function that constains a local &lt;code&gt;int&lt;/code&gt; it's a good chance that the value of &lt;code&gt;a&lt;/code&gt; (or the memory address that &lt;code&gt;a&lt;/code&gt; used to point to) changes. This happens because the stack will be overwritten with a new frame containing different data.</source>
          <target state="translated">일반적인 컴파일러 구현에서는 코드를 &quot;a &lt;em&gt;가&lt;/em&gt; 차지했던 주소로 메모리 블록의 값을 인쇄합니다&quot;라고 생각할 수 있습니다. 또한 로컬 &lt;code&gt;int&lt;/code&gt; 를 구성하는 함수에 새 함수 호출을 추가하면 (또는 가리키는 데 사용 된 메모리 주소)의 값이 변경 될 가능성이 큽니다. 이는 다른 데이터를 포함하는 새 프레임으로 스택을 덮어 쓰기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e6431cf35a0648d9b667c3d460073ff4a639aace" translate="yes" xml:space="preserve">
          <source>Instead, implementations let you make mistakes and get away with it. Most of the time. Until one day something truly awful goes wrong and the process explodes.</source>
          <target state="translated">대신 구현을 통해 실수를 저지르고 벗어날 수 있습니다. 대부분의 경우 언젠가는 정말 끔찍한 일이 일어나고 그 과정이 폭발합니다.</target>
        </trans-unit>
        <trans-unit id="cf808b24485af68ad3c78cf040a3df8bd129cff2" translate="yes" xml:space="preserve">
          <source>It can, because &lt;code&gt;a&lt;/code&gt; is a variable allocated temporarily for the lifetime of its scope (&lt;code&gt;foo&lt;/code&gt; function). After you return from &lt;code&gt;foo&lt;/code&gt; the memory is free and can be overwritten.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 는 해당 범위의 수명 동안 일시적으로 할당되는 변수이기 때문에 가능 합니다 ( &lt;code&gt;foo&lt;/code&gt; 함수). &lt;code&gt;foo&lt;/code&gt; 에서 돌아온 후 메모리가 사용 가능하며 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a24c120f4ed8e1f85f91181732fc5d4f90b2dfce" translate="yes" xml:space="preserve">
          <source>It works because the stack has not been altered (yet) since a was put there. 
Call a few other functions (which are also calling other functions) before accessing &lt;code&gt;a&lt;/code&gt; again and you will probably not be so lucky anymore... ;-)</source>
          <target state="translated">스택을 넣은 이후 스택이 변경되지 않았기 때문에 작동합니다. 다시 액세스하기 전에 다른 함수를 호출하는 다른 함수를 호출하면 더 이상 운이 좋지 않을 것입니다 ... ;-)</target>
        </trans-unit>
        <trans-unit id="6d865b18ac08c0c3d8f413777a079cf33cf8b7d8" translate="yes" xml:space="preserve">
          <source>It's 'Dirty' way of using memory addresses. When you return an address (pointer) you don't know whether it belongs to local scope of a function. It's just an address. Now that you invoked the 'foo' function, that address (memory location) of 'a' was already allocated there in the (safely, for now at least) addressable memory of your application (process). After the 'foo' function returned, the address of 'a' can be considered 'dirty' but it's there, not cleaned up, nor disturbed/modified by expressions in other part of program (in this specific case at least). A C/C++ compiler doesn't stop you from such 'dirty' access (might warn you though, if you care). You can safely use (update) any memory location that is in the data segment of your program instance (process) unless you protect the address by some means.</source>
          <target state="translated">메모리 주소를 사용하는 '더러운'방법입니다. 주소 (포인터)를 반환하면 해당 주소가 함수의 로컬 범위에 속하는지 알 수 없습니다. 주소 일뿐입니다. 이제 'foo'함수를 호출 했으므로 'a'의 해당 주소 (메모리 위치)는 이미 애플리케이션 (프로세스)의 주소 지정 가능한 메모리에 안전하게 할당되어 있습니다. 'foo'함수가 리턴 된 후, 'a'의 주소는 '더러운'것으로 간주 될 수 있지만, 프로그램의 다른 부분 (적어도이 경우에는)의 표현식에 의해 정리되지 않거나 방해 받거나 수정되지 않습니다. AC / C ++ 컴파일러는 이러한 '더러운'액세스를 막지 않습니다 (주의를 기울이면 경고 할 수 있음). 어떤 방법으로 주소를 보호하지 않는 한 프로그램 인스턴스 (프로세스)의 데이터 세그먼트에있는 메모리 위치를 안전하게 사용 (업데이트) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="668ed96ef41788718678a8ce40aa14755a7a92c8" translate="yes" xml:space="preserve">
          <source>It's like the hotel decides to only rent out rooms sequentially, and you can't check out until everyone with a room number higher than you has checked out.</source>
          <target state="translated">호텔에서 순차적으로 객실을 임대하기로 결정한 것처럼 객실 번호가 높은 사람이 모두 체크 아웃 할 때까지 체크 아웃 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f3e2804ed3bd64f789e8ab14d3b38ca8f2c1f567" translate="yes" xml:space="preserve">
          <source>Local variables follow the latter pattern; when a method is entered, its local variables come alive. When that method calls another method, the new method's local variables come alive. They'll be dead before the first method's local variables are dead.  The relative order of the beginnings and endings of lifetimes of storages associated with local variables can be worked out ahead of time.</source>
          <target state="translated">지역 변수는 후자의 패턴을 따릅니다. 메소드가 입력되면 로컬 변수가 활성화됩니다. 해당 메소드가 다른 메소드를 호출하면 새 메소드의 로컬 변수가 활성화됩니다. 첫 번째 방법의 지역 변수가 죽기 전에 죽을 것입니다. 지역 변수와 관련된 스토리지 수명의 시작과 끝의 상대적 순서는 미리 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92b523458f46cae25f6e91180adcbb80c63ad661" translate="yes" xml:space="preserve">
          <source>More memory-safe languages solve this problem by restricting your power. In &quot;normal&quot; C# there simply is no way to take the address of a local and return it or store it for later. You can take the address of a local, but the language is cleverly designed so that it is impossible to use it after the lifetime of the local ends. In order to take the address of a local and pass it back, you have to put the compiler in a special &quot;unsafe&quot; mode, &lt;em&gt;and&lt;/em&gt; put the word &quot;unsafe&quot; in your program, to call attention to the fact that you are probably doing something dangerous that could be breaking the rules.</source>
          <target state="translated">메모리를 안전하게 사용하는 언어가 많을수록 전력을 제한하여이 문제를 해결합니다. &quot;정상&quot;C #에서는 단순히 로컬 주소를 가져 와서 반환하거나 나중에 저장할 수있는 방법이 없습니다. 당신은 지역의 주소를 취할 수 있지만, 언어는 지역 끝이 끝난 후에는 언어를 사용할 수 없도록 영리하게 설계되었습니다. 로컬 주소를 가져 와서 다시 전달하려면 컴파일러를 특수한 &quot;안전하지 않은&quot;모드로 설정 &lt;em&gt;하고&lt;/em&gt; 프로그램에 &quot;안전하지 않은&quot;이라는 단어를 넣어야 할 것입니다. 규칙을 어길 수있는 위험한 것.</target>
        </trans-unit>
        <trans-unit id="f7776b8ae70f653468c196298aea76866e611224" translate="yes" xml:space="preserve">
          <source>Nobody will automatically check the semantic validity of memory addresses like that for you during normal program execution. However, a memory debugger such as &lt;code&gt;valgrind&lt;/code&gt; will happily do this, so you should run your program through it and witness the errors.</source>
          <target state="translated">정상적인 프로그램 실행 중에는 메모리 주소의 의미 적 유효성이 자동으로 확인되지 않습니다. 그러나 &lt;code&gt;valgrind&lt;/code&gt; 와 같은 메모리 디버거는이 작업을 즐겁게 수행하므로 프로그램을 실행하고 오류를 관찰해야합니다.</target>
        </trans-unit>
        <trans-unit id="9cc0ce9cccdfa9247eba033a1e1a044665d8c5e6" translate="yes" xml:space="preserve">
          <source>Now if you're wondering why the compiler doesn't complain, it's probably because &lt;code&gt;foo&lt;/code&gt; got eliminated by optimization. It usually will warn you about this sort of thing. C assumes you know what you're doing though, and technically you haven't violated scope here (there's no reference to &lt;code&gt;a&lt;/code&gt; itself outside of &lt;code&gt;foo&lt;/code&gt;), only memory access rules, which only triggers a warning rather than an error.</source>
          <target state="translated">컴파일러가 왜 불평하지 않는지 궁금하다면, 아마도 최적화에 의해 &lt;code&gt;foo&lt;/code&gt; 가 제거 되었기 때문일 것입니다. 보통 이런 종류의 일에 대해 경고합니다. C는 당신이하고있는 일을 알고 있다고 가정하고 기술적으로 당신은 여기서 범위를 위반하지 않았고 ( &lt;code&gt;foo&lt;/code&gt; 이외의 자체에 대한 참조는 없음) 메모리 액세스 규칙 만 오류가 아닌 경고 만 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="64dfdee1fb88a04e52e453e6fea524374d6fce64" translate="yes" xml:space="preserve">
          <source>Pay attention to  all warnings . Do not only solve errors.</source>
          <target state="translated">모든 경고에주의하십시오. 오류 만 해결하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="dbd3aa8cb4b802de57285634bed996e92ef2c0e4" translate="yes" xml:space="preserve">
          <source>Returning the address of a temporary works, but as temporaries are destroyed at the end of a function the results of accessing them will be undefined.</source>
          <target state="translated">임시 작품의 주소를 반환하지만 함수의 끝에서 임시가 파괴되면 액세스 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a96582b612f775240973f5214e850faef3962ce" translate="yes" xml:space="preserve">
          <source>So let's think about the stack. In many operating systems you get one stack per thread and the stack is allocated to be a certain fixed size. When you call a method, stuff is pushed onto the stack. If you then pass a pointer to the stack back out of your method, as the original poster does here, that's just a pointer to the middle of some entirely valid million-byte memory block. In our analogy, you check out of the hotel; when you do, you just checked out of the highest-numbered occupied room.  If no one else checks in after you, and you go back to your room illegally, all your stuff is guaranteed to still be there &lt;em&gt;in this particular hotel&lt;/em&gt;.</source>
          <target state="translated">스택에 대해 생각해 봅시다. 많은 운영 체제에서 스레드 당 하나의 스택이 생성되고 스택은 특정 고정 크기로 할당됩니다. 메소드를 호출하면, 내용물이 스택으로 푸시됩니다. 그런 다음 원래 포스터에서와 같이 메소드에서 스택에 대한 포인터를 다시 전달하면 완전히 유효한 백만 바이트 메모리 블록의 중간에 대한 포인터입니다. 우리의 비유로, 당신은 호텔을 체크 아웃합니다; 당신이 할 때, 당신은 방금 가장 높은 자리를 체크 아웃했습니다. 다른 사람이 체크인 한 후 아무도 체크인하지 않고 불법적으로 방으로 돌아 가면 모든 물건 &lt;em&gt;이이 특정 호텔에&lt;/em&gt; 여전히 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="48e728fecb72b1215b61d3c3ac811f6b5f708706" translate="yes" xml:space="preserve">
          <source>So you did not modify &lt;code&gt;a&lt;/code&gt; but rather the memory location where &lt;code&gt;a&lt;/code&gt; once was. This difference is very similar to the difference between crashing and not crashing.</source>
          <target state="translated">따라서 한 번 있던 메모리 위치를 수정하지 않고 메모리 위치를 수정 &lt;code&gt;a&lt;/code&gt; . 이 차이는 충돌과 충돌하지 않는 차이와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="415f6940290f7adad86030b3b1e1a91474c25e52" translate="yes" xml:space="preserve">
          <source>So, here function &lt;code&gt;foo()&lt;/code&gt; is returning the address of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is destroyed after returning its address. And you can access the modified value through that returned address.</source>
          <target state="translated">따라서 여기서 함수 &lt;code&gt;foo()&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 의 주소를 반환하고 &lt;code&gt;a&lt;/code&gt; 는 주소를 반환 한 후 제거됩니다. 반환 된 주소를 통해 수정 된 값에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ca65421239872c85bc7cb4eab3534ea2b033ade" translate="yes" xml:space="preserve">
          <source>Suppose a man hides money at a location and tells you the location. After some time, the man who had told you the money location dies. But still you have the access of that hidden money.</source>
          <target state="translated">한 남자가 어떤 위치에서 돈을 숨기고 그 위치를 말해 준다고 가정 해 봅시다. 얼마 후, 돈의 위치를 ​​말한 사람은 죽습니다. 그러나 여전히 당신은 그 숨겨진 돈에 접근 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6637ee0ae3a2356e88607e4783fe52245560ba0b" translate="yes" xml:space="preserve">
          <source>That is because after returning from foo() the stack is freed and then reused by boo().
If you deassemble the executable you will see it clearly.</source>
          <target state="translated">foo ()에서 돌아온 후 스택이 해제 된 다음 boo ()에 의해 재사용되기 때문입니다. 실행 파일을 디스 어셈블하면 명확하게 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10653b9d4a1d031b54f7ad1b1a5976b3c3fe1950" translate="yes" xml:space="preserve">
          <source>That means the memory address could be valid or not, and your code will be vulnerable to possible memory address issues (for example segmentation fault).</source>
          <target state="translated">즉, 메모리 주소가 유효하거나 유효하지 않을 수 있으며 코드는 가능한 메모리 주소 문제 (예 : 분할 오류)에 취약합니다.</target>
        </trans-unit>
        <trans-unit id="55e66b98d49314348a56ec9d7b30dce4d53f468e" translate="yes" xml:space="preserve">
          <source>That's classic &lt;strong&gt;undefined behaviour&lt;/strong&gt; that's been discussed here not two days ago -- search around the site for a bit. In a nutshell, you were lucky, but anything could have happened and your code is making invalid access to memory.</source>
          <target state="translated">그것은 이틀 전에 논의 &lt;strong&gt;되지 않은&lt;/strong&gt; 고전적인 &lt;strong&gt;정의되지 않은 행동&lt;/strong&gt; 입니다. 사이트를 조금만 검색하십시오. 간단히 말해서 운이 좋았지 만 어떤 일이 있었을 수 있으며 코드가 메모리에 잘못 액세스하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d01e8b0fd46bdbf027d2c78b2cf77e0ad3eadb05" translate="yes" xml:space="preserve">
          <source>The first is to have some sort of &quot;long lived&quot; storage area where the &quot;lifetime&quot; of each byte in the storage -- that is, the period of time when it is validly associated with some program variable -- cannot be easily predicted ahead of time. The compiler generates calls into a &quot;heap manager&quot; that knows how to dynamically allocate storage when it is needed and reclaim it when it is no longer needed.</source>
          <target state="translated">첫 번째는 스토리지에있는 각 바이트의 &quot;수명&quot;즉, 일부 프로그램 변수와 유효하게 연관된 기간을 미리 쉽게 예측할 수없는 일종의 &quot;긴 수명&quot;스토리지 영역을 갖는 것입니다. 시간. 컴파일러는 필요할 때 스토리지를 동적으로 할당하고 더 이상 필요하지 않은 경우이를 회수하는 방법을 알고있는 &quot;힙 관리자&quot;에 대한 호출을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2a517045d055d1343ace682896452e5177bc4524" translate="yes" xml:space="preserve">
          <source>The hotel management is not &lt;em&gt;required&lt;/em&gt; to remove your book. You didn't make a contract with them that said that if you leave stuff behind, they'll shred it for you. If you illegally re-enter your room with a stolen key to get it back, the hotel security staff is not &lt;em&gt;required&lt;/em&gt; to catch you sneaking in. You didn't make a contract with them that said &quot;if I try to sneak back into my room later, you are required to stop me.&quot; Rather, you signed a contract with them that said &quot;I promise not to sneak back into my room later&quot;, a contract which &lt;em&gt;you broke&lt;/em&gt;.</source>
          <target state="translated">호텔 관리자는 책을 제거 할 &lt;em&gt;필요&lt;/em&gt; 가 없습니다. 당신은 당신이 물건을 남겨두면 그들은 당신을 위해 그것을 분쇄 할 것이라고 말했다 그들과 계약을하지 않았다. 열쇠를 훔쳐 열쇠를 가지고 방에 다시 들어 오면 호텔 보안 직원이 당신을 몰래 잡을 &lt;em&gt;필요&lt;/em&gt; 가 없습니다. &quot;내가 다시 몰래 들어 가려고한다면 나중에 방을 막아야합니다. &quot; 오히려, 당신은 그들과 계약을 맺었다. &quot;나는 나중에 내 방으로 몰래 들어 가지 않겠다&quot;는 계약을 맺었다.</target>
        </trans-unit>
        <trans-unit id="0393a71499e25d744a2e0cd1648098b160eca6d2" translate="yes" xml:space="preserve">
          <source>The output was &lt;code&gt;58&lt;/code&gt;</source>
          <target state="translated">출력은 &lt;code&gt;58&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c253d37c3711b668d6b9d942320ae2687acd295" translate="yes" xml:space="preserve">
          <source>The problem you are having is why the program doesn't signal an error when referencing illegal memory. This is because C++ standards does not specify a very clear boundary between illegal memory and legal memory. Referencing something in popped out stack sometimes causes error and sometimes not. It depends. Don't count on this behavior. Assume it will always result in error when you program, but assume it will never signal error when you debug.</source>
          <target state="translated">당신이 겪고있는 문제는 불법 메모리를 참조 할 때 프로그램이 오류를 알리지 않는 이유입니다. C ++ 표준은 불법 메모리와 법적 메모리 사이에 명확한 경계를 지정하지 않기 때문입니다. 튀어 나온 스택에서 무언가를 참조하면 때때로 오류가 발생하고 때로는 그렇지 않습니다. 때에 따라 다르지. 이 행동에 의존하지 마십시오. 프로그래밍 할 때 항상 오류가 발생한다고 가정하지만 디버그 할 때 오류가 발생하지 않는다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="890aeeea49faa2fa28d38ffb4d73ad962a14ab97" translate="yes" xml:space="preserve">
          <source>The second method is to have a &amp;ldquo;short-lived&amp;rdquo; storage area where the lifetime of each byte is well known. Here, the lifetimes follow a &amp;ldquo;nesting&amp;rdquo; pattern. The longest-lived of these short-lived variables will be allocated before any other short-lived variables, and will be freed last. Shorter-lived variables will be allocated after the longest-lived ones, and will be freed before them. The lifetime of these shorter-lived variables is &amp;ldquo;nested&amp;rdquo; within the lifetime of longer-lived ones.</source>
          <target state="translated">두 번째 방법은 각 바이트의 수명이 잘 알려진 &quot;짧은 수명&quot;저장 영역을 갖는 것입니다. 여기서 수명은 &quot;중첩&quot;패턴을 따릅니다. 이 수명이 짧은 변수 중 가장 긴 수명은 다른 수명이 짧은 변수보다 먼저 할당되고 마지막에 해제됩니다. 수명이 짧은 변수는 수명이 가장 긴 변수 다음에 할당되고 변수가 해제되기 전에 해제됩니다. 수명이 짧은 변수의 수명은 수명이 긴 변수의 수명 내에 &quot;중첩&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="35e6bd2b69222deaf1995ea9da0a68f6703d7ccb" translate="yes" xml:space="preserve">
          <source>The things with correct (?) console output can change dramatically if you use ::printf but not cout. 
You can play around with debugger within below code (tested on x86, 32-bit, MSVisual Studio):</source>
          <target state="translated">:: printf를 사용하지만 cout을 사용하지 않으면 올바른 (?) 콘솔 출력이있는 항목이 크게 변경 될 수 있습니다. 아래 코드 내에서 디버거로 놀 수 있습니다 (x86, 32 비트, MSVisual Studio에서 테스트 됨).</target>
        </trans-unit>
        <trans-unit id="f0ba7d3098b2635fa4805520c0d620eed935a473" translate="yes" xml:space="preserve">
          <source>The way you set it up it is a bit more reasonable that the returned address points into a valid area of memory, as it will probably just be a little further down the stack, but it is still an invalid location that you cannot access in a deterministic fashion.</source>
          <target state="translated">설정 방법은 반환 된 주소가 유효한 메모리 영역을 가리키는 것이 더 합리적입니다. 아마 스택에서 조금 더 떨어져 있기는하지만 여전히 액세스 할 수없는 잘못된 위치입니다 결정 론적 패션.</target>
        </trans-unit>
        <trans-unit id="c64bb54b249751cf9009a2a39ddde0cbec79cbdf" translate="yes" xml:space="preserve">
          <source>This behavior is undefined, as Alex pointed out--in fact, most compilers will warn against doing this, because it's an easy way to get crashes.</source>
          <target state="translated">Alex가 지적한 것처럼이 동작은 정의되어 있지 않습니다. 실제로 대부분의 컴파일러는 충돌을 일으키는 쉬운 방법이기 때문에이 작업을 수행하지 않도록 경고합니다.</target>
        </trans-unit>
        <trans-unit id="df8ae21359a7a9c1782b2fa5d716171e207fefde" translate="yes" xml:space="preserve">
          <source>This is  power of C++. You should care about memory. With the &lt;code&gt;-Werror&lt;/code&gt; flag, this warning becames an error and now you have to debug it.</source>
          <target state="translated">이것이 C ++의 힘입니다. 기억에주의해야합니다. &lt;code&gt;-Werror&lt;/code&gt; 플래그를 사용하면이 경고가 오류가되었으며 이제 디버그해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b0d1e6d4ef066a26535944c60c6026681ae3fe8" translate="yes" xml:space="preserve">
          <source>This is problematic. There are a lot of rules and it is very easy to break them accidentally. I certainly have many times. And worse, the problem often only surfaces when memory is detected to be corrupt billions of nanoseconds after the corruption happened, when it is very hard to figure out who messed it up.</source>
          <target state="translated">문제가 있습니다. 많은 규칙이 있으며 실수로 규칙을 어기는 것은 매우 쉽습니다. 나는 확실히 여러 번 있습니다. 더 나쁜 것은, 손상이 발생한 후 메모리가 수십억 나노초로 손상된 것으로 밝혀 졌을 때, 메모리를 누가 엉망으로 만들지 알아내는 것이 매우 어려운 경우에만 문제가 종종 드러납니다.</target>
        </trans-unit>
        <trans-unit id="0eaf8b53ad7d5c524b38b6a971be8dfad3b95b37" translate="yes" xml:space="preserve">
          <source>This means that you are doing a very bad thing, becouse you are passing a memory address to a pointer wich is not trustable at all.</source>
          <target state="translated">즉, 메모리 주소를 포인터로 전달하는 것은 전혀 신뢰할 수 없기 때문에 매우 나쁜 일을하고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6f697153226ae9e147e41d50dcd86d77b9a8ca6f" translate="yes" xml:space="preserve">
          <source>This prints out &quot;y=123&quot;, but your results may vary (really!). Your pointer is clobbering other, unrelated local variables.</source>
          <target state="translated">이렇게하면 &quot;y = 123&quot;이 인쇄되지만 결과는 실제와 다를 수 있습니다. 포인터가 관련없는 다른 지역 변수를 방해합니다.</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="398226ff0451b7e1c1c5e5a7a2cbe718625ea490" translate="yes" xml:space="preserve">
          <source>Unlike your example, with this example you are:</source>
          <target state="translated">예제와 달리이 예제를 사용하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf83ed6f06abc30e3c1ba88ba6233762dd35af5d" translate="yes" xml:space="preserve">
          <source>We use stacks for temporary stores because they are really cheap and easy. An implementation of C++ is not required to use a stack for storage of locals; it could use the heap. It doesn't, because that would make the program slower.</source>
          <target state="translated">스택은 실제로 저렴하고 쉬우므로 임시 저장소에 스택을 사용합니다. C ++ 구현은 로컬 저장을 위해 스택을 사용하지 않아도됩니다. 힙을 사용할 수 있습니다. 그것은 프로그램을 느리게 만들 것이기 ​​때문에 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e53fd215b0c495c0d89e0f96c8abbf2fb92be241" translate="yes" xml:space="preserve">
          <source>Well, obviously that scenario can happen in the real world no problem. There is no mysterious force that causes your book to disappear when you are no longer authorized to be in the room. Nor is there a mysterious force that prevents you from entering a room with a stolen key.</source>
          <target state="translated">분명히,이 시나리오는 현실 세계에서 아무 문제없이 일어날 수 있습니다. 더 이상 방에있을 권한이 없을 때 책이 사라지는 신비한 힘은 없습니다. 도난당한 열쇠로 방에 들어 가지 못하게하는 신비한 힘도 없습니다.</target>
        </trans-unit>
        <trans-unit id="a5d081b4250b3c6bf254dbe76846254422327e9b" translate="yes" xml:space="preserve">
          <source>What if C# did allow returning references? Coincidentally that is the subject of today's blog post:</source>
          <target state="translated">C #에서 참조 반환을 허용하면 어떻게됩니까? 우연히도 이것이 오늘 블로그 게시물의 주제입니다.</target>
        </trans-unit>
        <trans-unit id="4ba89d6203509c5bf6440005ba0577078a5e174f" translate="yes" xml:space="preserve">
          <source>What you're doing here is simply reading and writing to memory that</source>
          <target state="translated">당신이 여기서하는 일은 단순히 메모리에 읽고 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b0b04b262ca077c743d5bedec5d61192576329c1" translate="yes" xml:space="preserve">
          <source>What you're doing is described as &lt;em&gt;undefined behavior&lt;/em&gt;. The result cannot be predicted.</source>
          <target state="translated">당신이하고있는 것은 &lt;em&gt;정의되지 않은 행동으로&lt;/em&gt; 설명됩니다. 결과를 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a5b6bae245aa7990e2bf8f6d62a4b4fd1d7c04a8" translate="yes" xml:space="preserve">
          <source>When you return from &lt;code&gt;foo&lt;/code&gt;, you tell the OS that you're no longer using that memory and it can be reassigned to something else. If you're lucky and it never does get reassigned, and the OS doesn't catch you using it again, then you'll get away with the lie. Chances are though you'll end up writing over whatever else ends up with that address.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 에서 돌아 오면 OS에 더 이상 해당 메모리를 사용하지 않고 다른 것으로 재 할당 할 수 있다고 알려줍니다. 운이 좋고 다시 할당되지 않고 OS에서 다시 사용하지 않으면 거짓말을 피할 수 있습니다. 기회는 당신이 그 주소로 끝나는 모든 것을 작성하게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa1180633feda4933e750090ee9485e74f2fa520" translate="yes" xml:space="preserve">
          <source>Why do we use stacks to manage memory? Are value types in C# always stored on the stack? How does virtual memory work? And many more topics in how the C# memory manager works. Many of these articles are also germane to C++ programmers:</source>
          <target state="translated">왜 스택을 사용하여 메모리를 관리합니까? C #의 값 유형은 항상 스택에 저장됩니까? 가상 메모리는 어떻게 작동합니까? 그리고 C # 메모리 관리자의 작동 방식에 대한 더 많은 주제가 있습니다. 이 기사들 중 다수는 C ++ 프로그래머와도 밀접한 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="367a511c0bd23747bed54a801c60343a2911cb1f" translate="yes" xml:space="preserve">
          <source>Yes if you try to dereference that memory address you will have undefined behavior.</source>
          <target state="translated">해당 메모리 주소를 역 참조하려고하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f7b6efeb9999e8415e2256127bd801c374f407de" translate="yes" xml:space="preserve">
          <source>You actually invoked undefined behaviour.</source>
          <target state="translated">실제로 정의되지 않은 동작을 호출했습니다.</target>
        </trans-unit>
        <trans-unit id="0ab951d4546ea151e47a2697193d8f628bd98a9e" translate="yes" xml:space="preserve">
          <source>You are just returning a memory address, it's allowed but probably an error.</source>
          <target state="translated">메모리 주소를 반환하고 있습니다. 허용되지만 오류 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="632ab4b8b530f13855f715927a28aa2f5a4eb21e" translate="yes" xml:space="preserve">
          <source>You don't know what is going to happen; when you checked out of the hotel and stole a key to illegally use later, you gave up the right to live in a predictable, safe world because &lt;em&gt;you&lt;/em&gt; chose to break the rules of the system.</source>
          <target state="translated">당신은 무슨 일이 일어날 지 모른다. 호텔을 체크 아웃하고 나중에 불법적으로 사용할 열쇠를 훔 쳤을 때, 시스템 규칙을 어기도록 선택했기 때문에 예측 가능하고 안전한 세상에 살 권리를 포기했습니다.</target>
        </trans-unit>
        <trans-unit id="b6a838ff678f89b070003058718a712103126d6e" translate="yes" xml:space="preserve">
          <source>You never throw a C++ exception by accessing invalid memory. You are just giving an example of the general idea of referencing an arbitrary memory location. I could do the same like this:</source>
          <target state="translated">유효하지 않은 메모리에 액세스하여 C ++ 예외를 발생시키지 않습니다. 임의의 메모리 위치를 참조하는 일반적인 아이디어의 예를 제공합니다. 나는 이와 같이 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="851a700a375ff806c1dcbb41aa3d34c727d4e133" translate="yes" xml:space="preserve">
          <source>You rent a hotel room. You put a book in the top drawer of the bedside table and go to sleep.  You check out the next morning, but &quot;forget&quot; to give back your key. You steal the key!</source>
          <target state="translated">호텔 방을 임대하십시오. 침대 옆 테이블의 상단 서랍에 책을 넣고 자러갑니다. 다음날 아침에 체크 아웃하지만 열쇠를 돌려주는 것을 잊어 버렸습니다. 열쇠를 훔쳐!</target>
        </trans-unit>
        <trans-unit id="b6cedbdba81d1f1c5892a7412b1dd7929c578e4d" translate="yes" xml:space="preserve">
          <source>You win the lottery.</source>
          <target state="translated">당신은 복권에 당첨됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d5a5789511f170672864f52617e354f9acfe8c" translate="yes" xml:space="preserve">
          <source>Your code is very risky. You are creating a local variable (wich is considered destroyed after function ends) and you return the address of memory of that variable after it is destoyed.</source>
          <target state="translated">코드는 매우 위험합니다. 로컬 변수를 생성하고 (함수가 종료 된 후 파괴 된 것으로 간주 됨) 변수가 삭제 된 후 해당 변수의 메모리 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="27c02908661ef2d4af116e6eda229fd38a50ef3f" translate="yes" xml:space="preserve">
          <source>Your problem has nothing to do with &lt;em&gt;scope&lt;/em&gt;. In the code you show, the function &lt;code&gt;main&lt;/code&gt; does not see the names in the function &lt;code&gt;foo&lt;/code&gt;, so you can't access &lt;code&gt;a&lt;/code&gt; in foo directly with &lt;em&gt;this&lt;/em&gt; name outside &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">당신의 문제는 &lt;em&gt;범위&lt;/em&gt; 와 아무 관련이 없습니다. 표시하는 코드에서 &lt;code&gt;main&lt;/code&gt; 함수는 &lt;code&gt;foo&lt;/code&gt; 함수의 이름을 볼 수 없으므로 foo 외부 &lt;em&gt;에서이&lt;/em&gt; 이름 &lt;code&gt;a&lt;/code&gt; in foo에 직접 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4467dc3c2dfc773030d9d4d4ec6b6374a6ce09aa" translate="yes" xml:space="preserve">
          <source>allocating memory for int into a local function</source>
          <target state="translated">로컬 함수에 int를위한 메모리 할당</target>
        </trans-unit>
        <trans-unit id="25568658dcfbd886141b75f7a37ca9a44f6d7bfe" translate="yes" xml:space="preserve">
          <source>be the address of &lt;code&gt;a&lt;/code&gt;. Now that you're outside of &lt;code&gt;foo&lt;/code&gt;, it's just a pointer to some random memory area. It just so happens that in your example, that memory area does exist and nothing else is using it at the moment. You don't break anything by continuing to use it, and nothing else has overwritten it yet. Therefore, the &lt;code&gt;5&lt;/code&gt; is still there. In a real program, that memory would be re-used almost immediately and you'd break something by doing this (though the symptoms may not appear until much later!)</source>
          <target state="translated">의 주소 여야합니다. 이제 &lt;code&gt;foo&lt;/code&gt; 외부에 있으므로 임의의 메모리 영역에 대한 포인터 일뿐입니다. 귀하의 예에서 메모리 영역이 존재하고 현재 다른 것을 사용하지 않는 경우가 있습니다. 계속해서 사용해도 아무 것도 깨지 않으며, 아직 그것을 덮어 쓴 것은 없습니다. 따라서 &lt;code&gt;5&lt;/code&gt; 는 여전히 존재합니다. 실제 프로그램에서, 그 메모리는 거의 즉시 재사용 될 것이며, 이렇게함으로써 무언가를 깰 수 있습니다 (심지어 증상은 훨씬 나중에 나타나지 않을 수도 있습니다!)</target>
        </trans-unit>
        <trans-unit id="5b1b059e808759b8d1c5874ad49671b3b3d4813a" translate="yes" xml:space="preserve">
          <source>if you do something like that:</source>
          <target state="translated">그런 식으로하면 :</target>
        </trans-unit>
        <trans-unit id="3853ee4965d2fd6e74929bd4ae29cc0ed44947f9" translate="yes" xml:space="preserve">
          <source>that memory address is still valid also when function expires, (it is not deleted by anyone)</source>
          <target state="translated">해당 메모리 주소는 기능이 만료 된 경우에도 여전히 유효합니다 (아무도 삭제하지 않음)</target>
        </trans-unit>
        <trans-unit id="197d6cb5a85574406eca31e0a72c1a7b788a0490" translate="yes" xml:space="preserve">
          <source>the memory address is trustable (that memory block is not considered free, so it will be not overridden until it is deleted)</source>
          <target state="translated">메모리 주소를 신뢰할 수 있음 (메모리 블록은 사용 가능한 것으로 간주되지 않으므로 삭제 될 때까지 무시되지 않음)</target>
        </trans-unit>
        <trans-unit id="e0d69ca46fd46558106bbf5d93de1a37ad007fdb" translate="yes" xml:space="preserve">
          <source>the memory address should be deleted when not used. (see the delete at the end of the program)</source>
          <target state="translated">사용하지 않을 때는 메모리 주소를 삭제해야합니다. (프로그램 끝에서 삭제 참조)</target>
        </trans-unit>
        <trans-unit id="abe86398849a8e40d77bea83096ad74f206ef947" translate="yes" xml:space="preserve">
          <source>the output probably will be: 7</source>
          <target state="translated">결과는 다음과 같습니다. 7</target>
        </trans-unit>
        <trans-unit id="34790dc2e682800571cab44d1835a970e54f21a8" translate="yes" xml:space="preserve">
          <source>used to</source>
          <target state="translated">사용</target>
        </trans-unit>
        <trans-unit id="46dbdaa85bacc9d8c59df32ce3fb81070bc6523b" translate="yes" xml:space="preserve">
          <source>warning: address of local variable 'a' returned</source>
          <target state="translated">경고 : 로컬 변수 'a'의 주소가 반환되었습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
