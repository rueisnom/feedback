<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/6441218">
    <body>
      <group id="6441218">
        <trans-unit id="f5f16923f0af049a9268d2bca9a807fbee68cdfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; might in fact genuinely be a valid address of a double, e.g. &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; de hecho podr&amp;iacute;a ser una direcci&amp;oacute;n v&amp;aacute;lida de un doble, por ejemplo, &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt; q = &amp;amp; p; .</target>
        </trans-unit>
        <trans-unit id="2323769261698fad3bf45ce9c6dead419d7ed3ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; might point somewhere inside allocated memory and I just overwrite 8 bytes in there.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; podr&amp;iacute;a apuntar a alg&amp;uacute;n lugar dentro de la memoria asignada y simplemente sobrescribo 8 bytes all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="89dc785e6f5a1676a10c0b1098798eb7eb2480dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; points outside allocated memory and the operating system's memory manager sends a segmentation fault signal to my program, causing the runtime to terminate it.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; apunta fuera de la memoria asignada y el administrador de memoria del sistema operativo env&amp;iacute;a una se&amp;ntilde;al de falla de segmentaci&amp;oacute;n a mi programa, lo que hace que el tiempo de ejecuci&amp;oacute;n la finalice.</target>
        </trans-unit>
        <trans-unit id="199f80d5e26390e5ebf9e949c594dd75500aa2da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Let me take a real world example:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;D&amp;eacute;jame tomar un ejemplo del mundo real:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="092cbceb9ffa47ba2a3d0a48ececdefff70b083a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ is not a safe language&lt;/strong&gt;. It will cheerfully allow you to break the rules of the system. If you try to do something illegal and foolish like going back into a room you're not authorized to be in and rummaging through a desk that might not even be there anymore, C++ is not going to stop you. Safer languages than C++ solve this problem by restricting your power -- by having much stricter control over keys, for example.</source>
          <target state="translated">&lt;strong&gt;C ++ no es un lenguaje seguro&lt;/strong&gt; . Alegremente te permitir&amp;aacute; romper las reglas del sistema. Si intentas hacer algo ilegal y tonto como volver a una habitaci&amp;oacute;n en la que no est&amp;aacute;s autorizado a entrar y hurgar en un escritorio que tal vez ya no est&amp;eacute; all&amp;iacute;, C ++ no te detendr&amp;aacute;. Los lenguajes m&amp;aacute;s seguros que C ++ resuelven este problema al restringir su poder, al tener un control mucho m&amp;aacute;s estricto sobre las teclas, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="6c1c49fcc0bc7f787bb6de1ef0e235efab3bfc3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How can that be? Aren't the contents of a hotel room drawer inaccessible if you haven't rented the room?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Como puede ser?&lt;/strong&gt; &lt;strong&gt;&amp;iquest;No son inaccesibles los contenidos del caj&amp;oacute;n de una habitaci&amp;oacute;n de hotel si no ha alquilado la habitaci&amp;oacute;n?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c802d8f0f438f6d01b82bd537e9909b51c503a35" translate="yes" xml:space="preserve">
          <source>A little addition to all the answers:</source>
          <target state="translated">Una pequeña adición a todas las respuestas:</target>
        </trans-unit>
        <trans-unit id="ee1cefbbc3f6ae87dd7e67ea9cfb80dac82e13c9" translate="yes" xml:space="preserve">
          <source>A week later, you return to the hotel, do not check in, sneak into your old room with your stolen key, and look in the drawer. Your book is still there. Astonishing!</source>
          <target state="translated">Una semana después,regresas al hotel,no te registras,te escabulles en tu antigua habitación con la llave robada y miras en el cajón.Tu libro sigue ahí.¡Asombroso!</target>
        </trans-unit>
        <trans-unit id="9125bf2280239c3b164efc1df4e296b36f1c41f1" translate="yes" xml:space="preserve">
          <source>After returning from a function, all identifiers are destroyed instead of kept values in a memory location and we can not locate the values without having an identifier.But that location still contains the value stored by previous function.</source>
          <target state="translated">Después de regresar de una función,todos los identificadores son destruidos en lugar de los valores guardados en una ubicación de memoria y no podemos localizar los valores sin tener un identificador,pero esa ubicación sigue conteniendo el valor almacenado por la función anterior.</target>
        </trans-unit>
        <trans-unit id="551408e0c19118edd84d52d381542cdcbdda834c" translate="yes" xml:space="preserve">
          <source>An implementation of C++ is not required to ensure that when the stack logically shrinks, the addresses that used to be valid are still mapped into memory. The implementation is allowed to tell the operating system &quot;we're done using this page of stack now. Until I say otherwise, issue an exception that destroys the process if anyone touches the previously-valid stack page&quot;.  Again, implementations do not actually do that because it is slow and unnecessary.</source>
          <target state="translated">No se requiere una implementación de C++para asegurar que cuando la pila se encoge lógicamente,las direcciones que solían ser válidas siguen siendo mapeadas en la memoria.Se permite que la implementación le diga al sistema operativo &quot;hemos terminado de usar esta página de la pila ahora&quot;.Hasta que yo diga lo contrario,emitir una excepción que destruya el proceso si alguien toca la página de pila previamente válida&quot;.Una vez más,las implementaciones no hacen eso en realidad porque es lento e innecesario.</target>
        </trans-unit>
        <trans-unit id="9e4a51f2c5d3df5cc305fe5241ee9f91c1862f4a" translate="yes" xml:space="preserve">
          <source>An implementation of C++ is not required to leave the garbage you left on the stack untouched so that you can come back for it later illegally; it is perfectly legal for the compiler to generate code that turns back to zero everything in the &quot;room&quot; that you just vacated. It doesn't because again, that would be expensive.</source>
          <target state="translated">Una implementación de C++no es necesaria para dejar la basura que dejaste en la pila sin tocar para que puedas volver por ella después ilegalmente;es perfectamente legal que el compilador genere código que vuelva a poner a cero todo en la &quot;habitación&quot; que acabas de desocupar.No lo hace porque,de nuevo,eso sería caro.</target>
        </trans-unit>
        <trans-unit id="107c7e3b89899d409b00af753e9116c3756b3bed" translate="yes" xml:space="preserve">
          <source>And the code is just running with no runtime exceptions!</source>
          <target state="translated">¡Y el código funciona sin excepciones de tiempo de ejecución!</target>
        </trans-unit>
        <trans-unit id="2eef47beb4615f77d95310d433dca2a905f6afd0" translate="yes" xml:space="preserve">
          <source>Because the storage space wasn't stomped on just yet. Don't count on that behavior.</source>
          <target state="translated">Porque el espacio de almacenamiento no ha sido pisoteado todavía.No cuentes con ese comportamiento.</target>
        </trans-unit>
        <trans-unit id="4c294f2376bf1ce93f3fa4b96d3051ce6d617ff9" translate="yes" xml:space="preserve">
          <source>But I agree with Mark B that the resulting behavior is undefined.</source>
          <target state="translated">Pero estoy de acuerdo con Mark B en que el comportamiento resultante es indefinido.</target>
        </trans-unit>
        <trans-unit id="b1cc5de4f5cc262455af25eee537c1fbe8ede183" translate="yes" xml:space="preserve">
          <source>Can a local variable's memory be accessed outside its scope</source>
          <target state="translated">¿Se puede acceder a la memoria de una variable local fuera de su alcance</target>
        </trans-unit>
        <trans-unit id="b2a932b65ee498810514c1bea0d35efc855a4f81" translate="yes" xml:space="preserve">
          <source>Compilers are in the business of generating code which manages the storage of the data manipulated by that program. There are lots of different ways of generating code to manage memory, but over time two basic techniques have become entrenched.</source>
          <target state="translated">Los compiladores se dedican a generar código que gestiona el almacenamiento de los datos manipulados por ese programa.Hay muchas maneras diferentes de generar código para gestionar la memoria,pero con el tiempo dos técnicas básicas se han afianzado.</target>
        </trans-unit>
        <trans-unit id="c817be5dd088db601f9b4bede3267671d06ac959" translate="yes" xml:space="preserve">
          <source>Consider this example, instead, and test it:</source>
          <target state="translated">Considere este ejemplo,en cambio,y pruébelo:</target>
        </trans-unit>
        <trans-unit id="c0f296eb7c38fa507531b7353e52a86837866c31" translate="yes" xml:space="preserve">
          <source>Did you compile your program with the optimiser enabled? The &lt;code&gt;foo()&lt;/code&gt; function is quite simple and might have been inlined or replaced in the resulting code.</source>
          <target state="translated">&amp;iquest;Compil&amp;oacute; su programa con el optimizador habilitado? La funci&amp;oacute;n &lt;code&gt;foo()&lt;/code&gt; es bastante simple y podr&amp;iacute;a haber sido incorporada o reemplazada en el c&amp;oacute;digo resultante.</target>
        </trans-unit>
        <trans-unit id="b807ff8ce557df22c0a2b48e1eb3c952a35d8a67" translate="yes" xml:space="preserve">
          <source>For an example of the kind of spooky behavior you are &lt;em&gt;likely&lt;/em&gt; to get, try this sample:</source>
          <target state="translated">Para ver un ejemplo del tipo de comportamiento espeluznante que es &lt;em&gt;probable&lt;/em&gt; que tenga, pruebe este ejemplo:</target>
        </trans-unit>
        <trans-unit id="5c70b26fb103aa28d932d18050cb856e801635d4" translate="yes" xml:space="preserve">
          <source>For further reading:</source>
          <target state="translated">Para más información:</target>
        </trans-unit>
        <trans-unit id="1bf2110822fba72487dccdd77a2d40f6bd00662b" translate="yes" xml:space="preserve">
          <source>For this reason, local variables are usually generated as storage on a &quot;stack&quot; data structure, because a stack has the property that the first thing pushed on it is going to be the last thing popped off.</source>
          <target state="translated">Por esta razón,las variables locales suelen generarse como almacenamiento en una estructura de datos &quot;apilados&quot;,porque una pila tiene la propiedad de que lo primero que se le empuje será lo último que salga.</target>
        </trans-unit>
        <trans-unit id="5efbdcdc6578ea05130db18ac54a4c2a591f0648" translate="yes" xml:space="preserve">
          <source>GCC shows this Warning</source>
          <target state="translated">GCC muestra esta advertencia</target>
        </trans-unit>
        <trans-unit id="b10d57cc173a336784fa10ae3535545c463b017f" translate="yes" xml:space="preserve">
          <source>Here I am simply treating 123456 as the address of a double and write to it. Any number of things could happen:</source>
          <target state="translated">Aquí estoy simplemente tratando 123456 como la dirección de un doble y le escribo.Cualquier cantidad de cosas podrían suceder:</target>
        </trans-unit>
        <trans-unit id="cac5d1b4d781ba7ae7623777363b8748a7fffdc9" translate="yes" xml:space="preserve">
          <source>Holy goodness, this answer is getting a lot of attention. (I'm not sure why -- I considered it to be just a &quot;fun&quot; little analogy, but whatever.)</source>
          <target state="translated">Santo Dios,esta respuesta está recibiendo mucha atención.(No estoy seguro de por qué...lo consideré una pequeña analogía &quot;divertida&quot;,pero como sea.)</target>
        </trans-unit>
        <trans-unit id="3fc5e06963f155f494425e90cc027ebe74ce7146" translate="yes" xml:space="preserve">
          <source>How can it be? Isn't the memory of a local variable inaccessible outside its function?</source>
          <target state="translated">¿Cómo puede ser? ¿No es la memoria de una variable local inaccesible fuera de su función?</target>
        </trans-unit>
        <trans-unit id="3fb4e1bfa90528212a424b3831d731b3a5295bc1" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;undefined&lt;/em&gt; behaviour and you should not rely on it to work!</source>
          <target state="translated">Sin embargo, este es &lt;em&gt;un&lt;/em&gt; comportamiento &lt;em&gt;indefinido&lt;/em&gt; y no debe confiar en que funcione.</target>
        </trans-unit>
        <trans-unit id="a7065978f6d14568e0e790c7484b61564f9f8483" translate="yes" xml:space="preserve">
          <source>I have the following code.</source>
          <target state="translated">Tengo el siguiente código.</target>
        </trans-unit>
        <trans-unit id="d9e4823ab18ab248ad0ae5098903f1270fb34501" translate="yes" xml:space="preserve">
          <source>I thought it might be germane to update this a bit with a few more technical thoughts.</source>
          <target state="translated">Pensé que podría ser pertinente actualizar esto un poco con algunos pensamientos técnicos más.</target>
        </trans-unit>
        <trans-unit id="e84b4bc2bc02c2ff515aa6c327f740c5f39d484a" translate="yes" xml:space="preserve">
          <source>In C++, you &lt;em&gt;can&lt;/em&gt; access any address, but it doesn't mean you &lt;em&gt;should&lt;/em&gt;. The address you are accessing is no longer valid. It &lt;em&gt;works&lt;/em&gt; because nothing else scrambled the memory after foo returned, but it could crash under many circumstances. Try analyzing your program with &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt;, or even just compiling it optimized, and see...</source>
          <target state="translated">En C ++, &lt;em&gt;puede&lt;/em&gt; acceder a cualquier direcci&amp;oacute;n, pero eso no significa que &lt;em&gt;deba hacerlo&lt;/em&gt; . La direcci&amp;oacute;n a la que accede ya no es v&amp;aacute;lida. &lt;em&gt;Funciona&lt;/em&gt; porque nada m&amp;aacute;s revuelve la memoria despu&amp;eacute;s de que Foo regres&amp;oacute;, pero podr&amp;iacute;a fallar en muchas circunstancias. Intente analizar su programa con &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt; , o incluso compilarlo optimizado, y vea ...</target>
        </trans-unit>
        <trans-unit id="d0fe5db286c8dab66cb0d3b82b36a45e675f7834" translate="yes" xml:space="preserve">
          <source>In short: this won't usually work, but sometimes will by chance.</source>
          <target state="translated">En resumen:esto no suele funcionar,pero a veces lo hará por casualidad.</target>
        </trans-unit>
        <trans-unit id="884f6b5a0e405708c0d3da980d10be30e33501e7" translate="yes" xml:space="preserve">
          <source>In this situation &lt;strong&gt;anything can happen&lt;/strong&gt;. The book can be there -- you got lucky. Someone else's book can be there and yours could be in the hotel's furnace. Someone could be there right when you come in, tearing your book to pieces. The hotel could have removed the table and book entirely and replaced it with a wardrobe. The entire hotel could be just about to be torn down and replaced with a football stadium, and you are going to die in an explosion while you are sneaking around.</source>
          <target state="translated">En esta situaci&amp;oacute;n, &lt;strong&gt;cualquier cosa puede suceder&lt;/strong&gt; . El libro puede estar all&amp;iacute;, tienes suerte. El libro de otra persona puede estar all&amp;iacute; y el suyo puede estar en el horno del hotel. Alguien podr&amp;iacute;a estar all&amp;iacute; justo cuando entras, rompiendo tu libro en pedazos. El hotel podr&amp;iacute;a haber eliminado la mesa y el libro por completo y reemplazarlo con un armario. Todo el hotel podr&amp;iacute;a estar a punto de ser demolido y reemplazado por un estadio de f&amp;uacute;tbol, ​​y morir&amp;aacute;s en una explosi&amp;oacute;n mientras te escabulles.</target>
        </trans-unit>
        <trans-unit id="2e771043fe216902e4ecf87e32bed904be6c6fe8" translate="yes" xml:space="preserve">
          <source>In typical compiler implementations, you can think of the code as &quot;print out the value of the memory block with adress that &lt;em&gt;used to be&lt;/em&gt; occupied by a&quot;. Also, if you add a new function invocation to a function that constains a local &lt;code&gt;int&lt;/code&gt; it's a good chance that the value of &lt;code&gt;a&lt;/code&gt; (or the memory address that &lt;code&gt;a&lt;/code&gt; used to point to) changes. This happens because the stack will be overwritten with a new frame containing different data.</source>
          <target state="translated">En las implementaciones t&amp;iacute;picas del compilador, puede pensar en el c&amp;oacute;digo como &quot;imprimir el valor del bloque de memoria con la direcci&amp;oacute;n que &lt;em&gt;sol&amp;iacute;a estar&lt;/em&gt; ocupada por un&quot;. Adem&amp;aacute;s, si agrega una nueva invocaci&amp;oacute;n de funci&amp;oacute;n a una funci&amp;oacute;n que mantiene un &lt;code&gt;int&lt;/code&gt; local, es muy probable que cambie el valor de (o la direcci&amp;oacute;n de memoria a la que sol&amp;iacute;a se&amp;ntilde;alar). Esto sucede porque la pila se sobrescribir&amp;aacute; con un nuevo marco que contiene datos diferentes.</target>
        </trans-unit>
        <trans-unit id="e6431cf35a0648d9b667c3d460073ff4a639aace" translate="yes" xml:space="preserve">
          <source>Instead, implementations let you make mistakes and get away with it. Most of the time. Until one day something truly awful goes wrong and the process explodes.</source>
          <target state="translated">En cambio,las implementaciones permiten cometer errores y salirse con la suya.La mayoría de las veces.Hasta que un día algo verdaderamente horrible sale mal y el proceso explota.</target>
        </trans-unit>
        <trans-unit id="cf808b24485af68ad3c78cf040a3df8bd129cff2" translate="yes" xml:space="preserve">
          <source>It can, because &lt;code&gt;a&lt;/code&gt; is a variable allocated temporarily for the lifetime of its scope (&lt;code&gt;foo&lt;/code&gt; function). After you return from &lt;code&gt;foo&lt;/code&gt; the memory is free and can be overwritten.</source>
          <target state="translated">Puede, porque &lt;code&gt;a&lt;/code&gt; es una variable asignada temporalmente para la vida &amp;uacute;til de su alcance (funci&amp;oacute;n &lt;code&gt;foo&lt;/code&gt; ). Despu&amp;eacute;s de regresar de &lt;code&gt;foo&lt;/code&gt; , la memoria es libre y puede sobrescribirse.</target>
        </trans-unit>
        <trans-unit id="a24c120f4ed8e1f85f91181732fc5d4f90b2dfce" translate="yes" xml:space="preserve">
          <source>It works because the stack has not been altered (yet) since a was put there. 
Call a few other functions (which are also calling other functions) before accessing &lt;code&gt;a&lt;/code&gt; again and you will probably not be so lucky anymore... ;-)</source>
          <target state="translated">Funciona porque la pila no ha sido alterada (todav&amp;iacute;a) desde que se coloc&amp;oacute; all&amp;iacute;. Llame a algunas otras funciones (que tambi&amp;eacute;n est&amp;aacute;n llamando a otras funciones) antes de acceder &lt;code&gt;a&lt;/code&gt; otra vez y probablemente ya no tenga tanta suerte ... ;-)</target>
        </trans-unit>
        <trans-unit id="6d865b18ac08c0c3d8f413777a079cf33cf8b7d8" translate="yes" xml:space="preserve">
          <source>It's 'Dirty' way of using memory addresses. When you return an address (pointer) you don't know whether it belongs to local scope of a function. It's just an address. Now that you invoked the 'foo' function, that address (memory location) of 'a' was already allocated there in the (safely, for now at least) addressable memory of your application (process). After the 'foo' function returned, the address of 'a' can be considered 'dirty' but it's there, not cleaned up, nor disturbed/modified by expressions in other part of program (in this specific case at least). A C/C++ compiler doesn't stop you from such 'dirty' access (might warn you though, if you care). You can safely use (update) any memory location that is in the data segment of your program instance (process) unless you protect the address by some means.</source>
          <target state="translated">Es la forma 'sucia' de usar las direcciones de memoria.Cuando devuelves una dirección (puntero)no sabes si pertenece al ámbito local de una función.Es sólo una dirección.Ahora que has invocado la función 'foo',esa dirección (ubicación de memoria)de 'a' ya estaba asignada allí en la (segura,al menos por ahora)memoria direccionable de tu aplicación (proceso).Después de que la función 'foo' regresó,la dirección de 'a' puede ser considerada 'sucia' pero está allí,no se ha limpiado,ni se ha perturbado por expresiones en otra parte del programa (en este caso específico por lo menos).Un compilador CC++no te impide un acceso tan 'sucio' (aunque podría advertirte,si te importa).Puedes usar (actualizar)con seguridad cualquier ubicación de memoria que esté en el segmento de datos de tu instancia (proceso)de programa a menos que protejas la dirección por algún medio.</target>
        </trans-unit>
        <trans-unit id="668ed96ef41788718678a8ce40aa14755a7a92c8" translate="yes" xml:space="preserve">
          <source>It's like the hotel decides to only rent out rooms sequentially, and you can't check out until everyone with a room number higher than you has checked out.</source>
          <target state="translated">Es como si el hotel decidiera alquilar sólo habitaciones secuencialmente,y no se puede hacer el check out hasta que todos los que tengan un número de habitación superior al suyo lo hayan hecho.</target>
        </trans-unit>
        <trans-unit id="f3e2804ed3bd64f789e8ab14d3b38ca8f2c1f567" translate="yes" xml:space="preserve">
          <source>Local variables follow the latter pattern; when a method is entered, its local variables come alive. When that method calls another method, the new method's local variables come alive. They'll be dead before the first method's local variables are dead.  The relative order of the beginnings and endings of lifetimes of storages associated with local variables can be worked out ahead of time.</source>
          <target state="translated">Las variables locales siguen este último patrón;cuando se introduce un método,sus variables locales cobran vida.Cuando ese método llama a otro método,las variables locales del nuevo método cobran vida.Estarán muertas antes de que las variables locales del primer método estén muertas.El orden relativo de los comienzos y finales de la vida útil de los almacenamientos asociados a las variables locales puede calcularse con antelación.</target>
        </trans-unit>
        <trans-unit id="92b523458f46cae25f6e91180adcbb80c63ad661" translate="yes" xml:space="preserve">
          <source>More memory-safe languages solve this problem by restricting your power. In &quot;normal&quot; C# there simply is no way to take the address of a local and return it or store it for later. You can take the address of a local, but the language is cleverly designed so that it is impossible to use it after the lifetime of the local ends. In order to take the address of a local and pass it back, you have to put the compiler in a special &quot;unsafe&quot; mode, &lt;em&gt;and&lt;/em&gt; put the word &quot;unsafe&quot; in your program, to call attention to the fact that you are probably doing something dangerous that could be breaking the rules.</source>
          <target state="translated">M&amp;aacute;s idiomas seguros para la memoria resuelven este problema al restringir su potencia. En C # &quot;normal&quot; simplemente no hay forma de tomar la direcci&amp;oacute;n de un local y devolverla o almacenarla para m&amp;aacute;s adelante. Puede tomar la direcci&amp;oacute;n de un local, pero el idioma est&amp;aacute; inteligentemente dise&amp;ntilde;ado para que sea imposible usarlo despu&amp;eacute;s de la vida &amp;uacute;til de los fines locales. Para tomar la direcci&amp;oacute;n de un local y devolverla, debe poner el compilador en un modo especial &quot;inseguro&quot; &lt;em&gt;y&lt;/em&gt; poner la palabra &quot;inseguro&quot; en su programa, para llamar la atenci&amp;oacute;n sobre el hecho de que probablemente est&amp;eacute; haciendo algo peligroso que podr&amp;iacute;a estar rompiendo las reglas.</target>
        </trans-unit>
        <trans-unit id="f7776b8ae70f653468c196298aea76866e611224" translate="yes" xml:space="preserve">
          <source>Nobody will automatically check the semantic validity of memory addresses like that for you during normal program execution. However, a memory debugger such as &lt;code&gt;valgrind&lt;/code&gt; will happily do this, so you should run your program through it and witness the errors.</source>
          <target state="translated">Nadie verificar&amp;aacute; autom&amp;aacute;ticamente la validez sem&amp;aacute;ntica de las direcciones de memoria como esa durante la ejecuci&amp;oacute;n normal del programa. Sin embargo, un depurador de memoria como &lt;code&gt;valgrind&lt;/code&gt; lo har&amp;aacute; felizmente, por lo que debe ejecutar su programa a trav&amp;eacute;s de &amp;eacute;l y presenciar los errores.</target>
        </trans-unit>
        <trans-unit id="9cc0ce9cccdfa9247eba033a1e1a044665d8c5e6" translate="yes" xml:space="preserve">
          <source>Now if you're wondering why the compiler doesn't complain, it's probably because &lt;code&gt;foo&lt;/code&gt; got eliminated by optimization. It usually will warn you about this sort of thing. C assumes you know what you're doing though, and technically you haven't violated scope here (there's no reference to &lt;code&gt;a&lt;/code&gt; itself outside of &lt;code&gt;foo&lt;/code&gt;), only memory access rules, which only triggers a warning rather than an error.</source>
          <target state="translated">Ahora, si se pregunta por qu&amp;eacute; el compilador no se queja, probablemente sea porque la optimizaci&amp;oacute;n lo elimin&amp;oacute;. Por lo general, te advertir&amp;aacute; sobre este tipo de cosas. C asume que sabe lo que est&amp;aacute; haciendo, y t&amp;eacute;cnicamente no ha violado el alcance aqu&amp;iacute; (no hay referencia a &lt;code&gt;a&lt;/code&gt; s&amp;iacute; mismo fuera de &lt;code&gt;foo&lt;/code&gt; ), solo las reglas de acceso a la memoria, que solo activan una advertencia en lugar de un error.</target>
        </trans-unit>
        <trans-unit id="64dfdee1fb88a04e52e453e6fea524374d6fce64" translate="yes" xml:space="preserve">
          <source>Pay attention to  all warnings . Do not only solve errors.</source>
          <target state="translated">Preste atención a todas las advertencias.No sólo resuelva los errores.</target>
        </trans-unit>
        <trans-unit id="dbd3aa8cb4b802de57285634bed996e92ef2c0e4" translate="yes" xml:space="preserve">
          <source>Returning the address of a temporary works, but as temporaries are destroyed at the end of a function the results of accessing them will be undefined.</source>
          <target state="translated">Devolver la dirección de una obra temporal,pero como las obras temporales se destruyen al final de una función los resultados de acceder a ellas serán indefinidos.</target>
        </trans-unit>
        <trans-unit id="7a96582b612f775240973f5214e850faef3962ce" translate="yes" xml:space="preserve">
          <source>So let's think about the stack. In many operating systems you get one stack per thread and the stack is allocated to be a certain fixed size. When you call a method, stuff is pushed onto the stack. If you then pass a pointer to the stack back out of your method, as the original poster does here, that's just a pointer to the middle of some entirely valid million-byte memory block. In our analogy, you check out of the hotel; when you do, you just checked out of the highest-numbered occupied room.  If no one else checks in after you, and you go back to your room illegally, all your stuff is guaranteed to still be there &lt;em&gt;in this particular hotel&lt;/em&gt;.</source>
          <target state="translated">As&amp;iacute; que pensemos en la pila. En muchos sistemas operativos, obtienes una pila por subproceso y la pila se asigna a un cierto tama&amp;ntilde;o fijo. Cuando llamas a un m&amp;eacute;todo, las cosas se insertan en la pila. Si luego pasa un puntero a la pila fuera de su m&amp;eacute;todo, como lo hace el p&amp;oacute;ster original aqu&amp;iacute;, eso es solo un puntero al medio de un bloque de memoria de un mill&amp;oacute;n de bytes completamente v&amp;aacute;lido. En nuestra analog&amp;iacute;a, sales del hotel; cuando lo haces, acabas de salir de la habitaci&amp;oacute;n ocupada con el n&amp;uacute;mero m&amp;aacute;s alto. Si nadie m&amp;aacute;s se registra despu&amp;eacute;s de usted y regresa a su habitaci&amp;oacute;n ilegalmente, se garantiza que todas sus cosas seguir&amp;aacute;n all&amp;iacute; &lt;em&gt;en este hotel en particular&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="48e728fecb72b1215b61d3c3ac811f6b5f708706" translate="yes" xml:space="preserve">
          <source>So you did not modify &lt;code&gt;a&lt;/code&gt; but rather the memory location where &lt;code&gt;a&lt;/code&gt; once was. This difference is very similar to the difference between crashing and not crashing.</source>
          <target state="translated">Por lo tanto, no modific&amp;oacute; &lt;code&gt;a&lt;/code&gt; lugar, sino la ubicaci&amp;oacute;n de la memoria donde &lt;code&gt;a&lt;/code&gt; vez estuvo Esta diferencia es muy similar a la diferencia entre estrellarse y no estrellarse.</target>
        </trans-unit>
        <trans-unit id="415f6940290f7adad86030b3b1e1a91474c25e52" translate="yes" xml:space="preserve">
          <source>So, here function &lt;code&gt;foo()&lt;/code&gt; is returning the address of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is destroyed after returning its address. And you can access the modified value through that returned address.</source>
          <target state="translated">Entonces, aqu&amp;iacute; la funci&amp;oacute;n &lt;code&gt;foo()&lt;/code&gt; est&amp;aacute; devolviendo la direcci&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; se destruye despu&amp;eacute;s de devolver su direcci&amp;oacute;n. Y puede acceder al valor modificado a trav&amp;eacute;s de esa direcci&amp;oacute;n devuelta.</target>
        </trans-unit>
        <trans-unit id="4ca65421239872c85bc7cb4eab3534ea2b033ade" translate="yes" xml:space="preserve">
          <source>Suppose a man hides money at a location and tells you the location. After some time, the man who had told you the money location dies. But still you have the access of that hidden money.</source>
          <target state="translated">Supongamos que un hombre esconde dinero en un lugar y te dice el lugar.Después de un tiempo,el hombre que te dijo la ubicación del dinero muere.Pero aún así tienes el acceso a ese dinero escondido.</target>
        </trans-unit>
        <trans-unit id="6637ee0ae3a2356e88607e4783fe52245560ba0b" translate="yes" xml:space="preserve">
          <source>That is because after returning from foo() the stack is freed and then reused by boo().
If you deassemble the executable you will see it clearly.</source>
          <target state="translated">Eso es porque después de regresar de foo()la pila se libera y luego es reutilizada por boo().Si desmontas el ejecutable lo verás claramente.</target>
        </trans-unit>
        <trans-unit id="10653b9d4a1d031b54f7ad1b1a5976b3c3fe1950" translate="yes" xml:space="preserve">
          <source>That means the memory address could be valid or not, and your code will be vulnerable to possible memory address issues (for example segmentation fault).</source>
          <target state="translated">Eso significa que la dirección de memoria podría ser válida o no,y su código será vulnerable a posibles problemas de dirección de memoria (por ejemplo,fallo de segmentación).</target>
        </trans-unit>
        <trans-unit id="55e66b98d49314348a56ec9d7b30dce4d53f468e" translate="yes" xml:space="preserve">
          <source>That's classic &lt;strong&gt;undefined behaviour&lt;/strong&gt; that's been discussed here not two days ago -- search around the site for a bit. In a nutshell, you were lucky, but anything could have happened and your code is making invalid access to memory.</source>
          <target state="translated">Ese es &lt;strong&gt;un comportamiento indefinido&lt;/strong&gt; cl&amp;aacute;sico que se discuti&amp;oacute; aqu&amp;iacute; no hace dos d&amp;iacute;as: busque un poco en el sitio. En pocas palabras, tuvo suerte, pero cualquier cosa podr&amp;iacute;a haber sucedido y su c&amp;oacute;digo est&amp;aacute; haciendo un acceso no v&amp;aacute;lido a la memoria.</target>
        </trans-unit>
        <trans-unit id="d01e8b0fd46bdbf027d2c78b2cf77e0ad3eadb05" translate="yes" xml:space="preserve">
          <source>The first is to have some sort of &quot;long lived&quot; storage area where the &quot;lifetime&quot; of each byte in the storage -- that is, the period of time when it is validly associated with some program variable -- cannot be easily predicted ahead of time. The compiler generates calls into a &quot;heap manager&quot; that knows how to dynamically allocate storage when it is needed and reclaim it when it is no longer needed.</source>
          <target state="translated">La primera es tener algún tipo de área de almacenamiento de &quot;larga vida&quot; donde la &quot;vida&quot; de cada byte en el almacenamiento-es decir,el período de tiempo en que se asocia válidamente con alguna variable del programa-no se puede predecir fácilmente con antelación.El compilador genera llamadas a un &quot;gestor de escombros&quot; que sabe cómo asignar dinámicamente el almacenamiento cuando se necesita y reclamarlo cuando ya no se necesita.</target>
        </trans-unit>
        <trans-unit id="2a517045d055d1343ace682896452e5177bc4524" translate="yes" xml:space="preserve">
          <source>The hotel management is not &lt;em&gt;required&lt;/em&gt; to remove your book. You didn't make a contract with them that said that if you leave stuff behind, they'll shred it for you. If you illegally re-enter your room with a stolen key to get it back, the hotel security staff is not &lt;em&gt;required&lt;/em&gt; to catch you sneaking in. You didn't make a contract with them that said &quot;if I try to sneak back into my room later, you are required to stop me.&quot; Rather, you signed a contract with them that said &quot;I promise not to sneak back into my room later&quot;, a contract which &lt;em&gt;you broke&lt;/em&gt;.</source>
          <target state="translated">La administraci&amp;oacute;n del hotel no est&amp;aacute; &lt;em&gt;obligada&lt;/em&gt; a eliminar su libro. No hiciste un contrato con ellos que dijera que si dejas cosas atr&amp;aacute;s, te lo destrozar&amp;aacute;n. Si vuelve a ingresar ilegalmente a su habitaci&amp;oacute;n con una llave robada para recuperarla, no se &lt;em&gt;requiere&lt;/em&gt; que el personal de seguridad del hotel lo atrape a escondidas. No hizo un contrato con ellos que dijera &quot;si trato de colarse nuevamente en mi m&amp;aacute;s tarde, debes detenerme &quot;. Por el contrario, firm&amp;oacute; un contrato con ellos que dec&amp;iacute;a &quot;Prometo no volver a mi habitaci&amp;oacute;n m&amp;aacute;s tarde&quot;, un contrato que &lt;em&gt;rompi&amp;oacute;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0393a71499e25d744a2e0cd1648098b160eca6d2" translate="yes" xml:space="preserve">
          <source>The output was &lt;code&gt;58&lt;/code&gt;</source>
          <target state="translated">El resultado fue &lt;code&gt;58&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c253d37c3711b668d6b9d942320ae2687acd295" translate="yes" xml:space="preserve">
          <source>The problem you are having is why the program doesn't signal an error when referencing illegal memory. This is because C++ standards does not specify a very clear boundary between illegal memory and legal memory. Referencing something in popped out stack sometimes causes error and sometimes not. It depends. Don't count on this behavior. Assume it will always result in error when you program, but assume it will never signal error when you debug.</source>
          <target state="translated">El problema que tiene es por qué el programa no señala un error al referirse a la memoria ilegal.Esto se debe a que los estándares de C++no especifican una frontera muy clara entre la memoria ilegal y la memoria legal.Referenciar algo en la pila de pop-ups a veces causa un error y a veces no.Depende.No cuentes con este comportamiento.Asume que siempre resultará en un error cuando programes,pero asume que nunca señalará error cuando depures.</target>
        </trans-unit>
        <trans-unit id="890aeeea49faa2fa28d38ffb4d73ad962a14ab97" translate="yes" xml:space="preserve">
          <source>The second method is to have a &amp;ldquo;short-lived&amp;rdquo; storage area where the lifetime of each byte is well known. Here, the lifetimes follow a &amp;ldquo;nesting&amp;rdquo; pattern. The longest-lived of these short-lived variables will be allocated before any other short-lived variables, and will be freed last. Shorter-lived variables will be allocated after the longest-lived ones, and will be freed before them. The lifetime of these shorter-lived variables is &amp;ldquo;nested&amp;rdquo; within the lifetime of longer-lived ones.</source>
          <target state="translated">El segundo m&amp;eacute;todo es tener un &amp;aacute;rea de almacenamiento &quot;de corta duraci&amp;oacute;n&quot; donde la vida &amp;uacute;til de cada byte sea bien conocida. Aqu&amp;iacute;, las vidas siguen un patr&amp;oacute;n de &quot;anidaci&amp;oacute;n&quot;. La m&amp;aacute;s longeva de estas variables de corta duraci&amp;oacute;n se asignar&amp;aacute; antes que cualquier otra variable de corta duraci&amp;oacute;n, y se liberar&amp;aacute; al final. Las variables de vida m&amp;aacute;s corta se asignar&amp;aacute;n despu&amp;eacute;s de las de vida m&amp;aacute;s larga y se liberar&amp;aacute;n antes que ellas. La vida &amp;uacute;til de estas variables de vida m&amp;aacute;s corta est&amp;aacute; &quot;anidada&quot; dentro de la vida de las de vida m&amp;aacute;s larga.</target>
        </trans-unit>
        <trans-unit id="35e6bd2b69222deaf1995ea9da0a68f6703d7ccb" translate="yes" xml:space="preserve">
          <source>The things with correct (?) console output can change dramatically if you use ::printf but not cout. 
You can play around with debugger within below code (tested on x86, 32-bit, MSVisual Studio):</source>
          <target state="translated">Las cosas con salida de consola correcta (?)pueden cambiar dramáticamente si usas ::printf pero no cout.Puedes jugar con el depurador dentro del siguiente código (probado en x86,32-bit,MSVisual Studio):</target>
        </trans-unit>
        <trans-unit id="f0ba7d3098b2635fa4805520c0d620eed935a473" translate="yes" xml:space="preserve">
          <source>The way you set it up it is a bit more reasonable that the returned address points into a valid area of memory, as it will probably just be a little further down the stack, but it is still an invalid location that you cannot access in a deterministic fashion.</source>
          <target state="translated">La forma en que se configura es un poco más razonable que la dirección devuelta apunte a un área de memoria válida,ya que probablemente esté un poco más abajo en la pila,pero sigue siendo una ubicación inválida a la que no se puede acceder de forma determinista.</target>
        </trans-unit>
        <trans-unit id="c64bb54b249751cf9009a2a39ddde0cbec79cbdf" translate="yes" xml:space="preserve">
          <source>This behavior is undefined, as Alex pointed out--in fact, most compilers will warn against doing this, because it's an easy way to get crashes.</source>
          <target state="translated">Este comportamiento es indefinido,como señaló Alex...de hecho,la mayoría de los compiladores advertirán que no lo hagan,porque es una forma fácil de conseguir choques.</target>
        </trans-unit>
        <trans-unit id="df8ae21359a7a9c1782b2fa5d716171e207fefde" translate="yes" xml:space="preserve">
          <source>This is  power of C++. You should care about memory. With the &lt;code&gt;-Werror&lt;/code&gt; flag, this warning becames an error and now you have to debug it.</source>
          <target state="translated">Este es el poder de C ++. Deber&amp;iacute;as preocuparte por la memoria. Con el indicador &lt;code&gt;-Werror&lt;/code&gt; , esta advertencia se convierte en un error y ahora debe depurarlo.</target>
        </trans-unit>
        <trans-unit id="5b0d1e6d4ef066a26535944c60c6026681ae3fe8" translate="yes" xml:space="preserve">
          <source>This is problematic. There are a lot of rules and it is very easy to break them accidentally. I certainly have many times. And worse, the problem often only surfaces when memory is detected to be corrupt billions of nanoseconds after the corruption happened, when it is very hard to figure out who messed it up.</source>
          <target state="translated">Esto es problemático.Hay muchas reglas y es muy fácil romperlas accidentalmente.Ciertamente lo he hecho muchas veces.Y lo que es peor,el problema a menudo sólo aparece cuando se detecta que la memoria está corrupta miles de millones de nanosegundos después de que ocurriera la corrupción,cuando es muy difícil averiguar quién la estropeó.</target>
        </trans-unit>
        <trans-unit id="0eaf8b53ad7d5c524b38b6a971be8dfad3b95b37" translate="yes" xml:space="preserve">
          <source>This means that you are doing a very bad thing, becouse you are passing a memory address to a pointer wich is not trustable at all.</source>
          <target state="translated">Esto significa que estás haciendo algo muy malo,porque estás pasando una dirección de memoria a un puntero que no es nada fiable.</target>
        </trans-unit>
        <trans-unit id="6f697153226ae9e147e41d50dcd86d77b9a8ca6f" translate="yes" xml:space="preserve">
          <source>This prints out &quot;y=123&quot;, but your results may vary (really!). Your pointer is clobbering other, unrelated local variables.</source>
          <target state="translated">Esto imprime &quot;y=123&quot;,pero sus resultados pueden variar (¡de verdad!).Tu puntero está golpeando otras variables locales no relacionadas.</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="398226ff0451b7e1c1c5e5a7a2cbe718625ea490" translate="yes" xml:space="preserve">
          <source>Unlike your example, with this example you are:</source>
          <target state="translated">A diferencia de tu ejemplo,con este ejemplo lo eres:</target>
        </trans-unit>
        <trans-unit id="bf83ed6f06abc30e3c1ba88ba6233762dd35af5d" translate="yes" xml:space="preserve">
          <source>We use stacks for temporary stores because they are really cheap and easy. An implementation of C++ is not required to use a stack for storage of locals; it could use the heap. It doesn't, because that would make the program slower.</source>
          <target state="translated">Usamos pilas para las tiendas temporales porque son muy baratas y fáciles.No se requiere una implementación de C++para usar una pila para el almacenamiento de los locales;podría usar el montón.No lo hace,porque eso haría que el programa fuera más lento.</target>
        </trans-unit>
        <trans-unit id="e53fd215b0c495c0d89e0f96c8abbf2fb92be241" translate="yes" xml:space="preserve">
          <source>Well, obviously that scenario can happen in the real world no problem. There is no mysterious force that causes your book to disappear when you are no longer authorized to be in the room. Nor is there a mysterious force that prevents you from entering a room with a stolen key.</source>
          <target state="translated">Bueno,obviamente ese escenario puede ocurrir en el mundo real sin problemas.No hay ninguna fuerza misteriosa que haga que tu libro desaparezca cuando ya no estés autorizado a estar en la habitación.Tampoco hay una fuerza misteriosa que impida que entres en una habitación con una llave robada.</target>
        </trans-unit>
        <trans-unit id="a5d081b4250b3c6bf254dbe76846254422327e9b" translate="yes" xml:space="preserve">
          <source>What if C# did allow returning references? Coincidentally that is the subject of today's blog post:</source>
          <target state="translated">¿Y si C#permitió devolver las referencias? Coincidentemente ese es el tema de la entrada del blog de hoy:</target>
        </trans-unit>
        <trans-unit id="4ba89d6203509c5bf6440005ba0577078a5e174f" translate="yes" xml:space="preserve">
          <source>What you're doing here is simply reading and writing to memory that</source>
          <target state="translated">Lo que estás haciendo aquí es simplemente leer y escribir a la memoria que</target>
        </trans-unit>
        <trans-unit id="b0b04b262ca077c743d5bedec5d61192576329c1" translate="yes" xml:space="preserve">
          <source>What you're doing is described as &lt;em&gt;undefined behavior&lt;/em&gt;. The result cannot be predicted.</source>
          <target state="translated">Lo que est&amp;aacute;s haciendo se describe como &lt;em&gt;un comportamiento indefinido&lt;/em&gt; . El resultado no se puede predecir.</target>
        </trans-unit>
        <trans-unit id="a5b6bae245aa7990e2bf8f6d62a4b4fd1d7c04a8" translate="yes" xml:space="preserve">
          <source>When you return from &lt;code&gt;foo&lt;/code&gt;, you tell the OS that you're no longer using that memory and it can be reassigned to something else. If you're lucky and it never does get reassigned, and the OS doesn't catch you using it again, then you'll get away with the lie. Chances are though you'll end up writing over whatever else ends up with that address.</source>
          <target state="translated">Cuando regresas de &lt;code&gt;foo&lt;/code&gt; , le dices al sistema operativo que ya no est&amp;aacute;s usando esa memoria y que se puede reasignar a otra cosa. Si tienes suerte y nunca se reasigna, y el sistema operativo no te atrapa us&amp;aacute;ndolo nuevamente, entonces te saldr&amp;aacute;s con la mentira. Lo m&amp;aacute;s probable es que termines escribiendo sobre cualquier otra cosa que termine con esa direcci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fa1180633feda4933e750090ee9485e74f2fa520" translate="yes" xml:space="preserve">
          <source>Why do we use stacks to manage memory? Are value types in C# always stored on the stack? How does virtual memory work? And many more topics in how the C# memory manager works. Many of these articles are also germane to C++ programmers:</source>
          <target state="translated">¿Por qué usamos pilas para gestionar la memoria? ¿Los tipos de valores en C#se almacenan siempre en la pila? ¿Cómo funciona la memoria virtual? Y muchos más temas sobre cómo funciona el gestor de memoria en C#.Muchos de estos artículos también son relacionados con los programadores de C++:</target>
        </trans-unit>
        <trans-unit id="367a511c0bd23747bed54a801c60343a2911cb1f" translate="yes" xml:space="preserve">
          <source>Yes if you try to dereference that memory address you will have undefined behavior.</source>
          <target state="translated">Sí,si intentas derivar esa dirección de memoria tendrás un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="f7b6efeb9999e8415e2256127bd801c374f407de" translate="yes" xml:space="preserve">
          <source>You actually invoked undefined behaviour.</source>
          <target state="translated">En realidad invocaste un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="0ab951d4546ea151e47a2697193d8f628bd98a9e" translate="yes" xml:space="preserve">
          <source>You are just returning a memory address, it's allowed but probably an error.</source>
          <target state="translated">Sólo estás devolviendo una dirección de memoria,está permitido pero probablemente sea un error.</target>
        </trans-unit>
        <trans-unit id="632ab4b8b530f13855f715927a28aa2f5a4eb21e" translate="yes" xml:space="preserve">
          <source>You don't know what is going to happen; when you checked out of the hotel and stole a key to illegally use later, you gave up the right to live in a predictable, safe world because &lt;em&gt;you&lt;/em&gt; chose to break the rules of the system.</source>
          <target state="translated">No sabes lo que va a pasar; Cuando saliste del hotel y robaste una llave para usarla ilegalmente m&amp;aacute;s tarde, renunciaste al derecho a vivir en un mundo predecible y seguro porque elegiste romper las reglas del sistema.</target>
        </trans-unit>
        <trans-unit id="b6a838ff678f89b070003058718a712103126d6e" translate="yes" xml:space="preserve">
          <source>You never throw a C++ exception by accessing invalid memory. You are just giving an example of the general idea of referencing an arbitrary memory location. I could do the same like this:</source>
          <target state="translated">Nunca se lanza una excepción de C++por acceder a una memoria inválida.Sólo estás dando un ejemplo de la idea general de referirse a una ubicación de memoria arbitraria.Podría hacer lo mismo así:</target>
        </trans-unit>
        <trans-unit id="851a700a375ff806c1dcbb41aa3d34c727d4e133" translate="yes" xml:space="preserve">
          <source>You rent a hotel room. You put a book in the top drawer of the bedside table and go to sleep.  You check out the next morning, but &quot;forget&quot; to give back your key. You steal the key!</source>
          <target state="translated">Alquilas una habitación de hotel.Pones un libro en el cajón superior de la mesilla de noche y te vas a dormir.Te vas a la mañana siguiente,pero &quot;olvidas&quot; devolver la llave.¡Robas la llave!</target>
        </trans-unit>
        <trans-unit id="b6cedbdba81d1f1c5892a7412b1dd7929c578e4d" translate="yes" xml:space="preserve">
          <source>You win the lottery.</source>
          <target state="translated">Ganaste la lotería.</target>
        </trans-unit>
        <trans-unit id="a8d5a5789511f170672864f52617e354f9acfe8c" translate="yes" xml:space="preserve">
          <source>Your code is very risky. You are creating a local variable (wich is considered destroyed after function ends) and you return the address of memory of that variable after it is destoyed.</source>
          <target state="translated">Su código es muy arriesgado.Estás creando una variable local (que se considera destruida después de que la función termina)y devuelves la dirección de memoria de esa variable después de que es descrita.</target>
        </trans-unit>
        <trans-unit id="27c02908661ef2d4af116e6eda229fd38a50ef3f" translate="yes" xml:space="preserve">
          <source>Your problem has nothing to do with &lt;em&gt;scope&lt;/em&gt;. In the code you show, the function &lt;code&gt;main&lt;/code&gt; does not see the names in the function &lt;code&gt;foo&lt;/code&gt;, so you can't access &lt;code&gt;a&lt;/code&gt; in foo directly with &lt;em&gt;this&lt;/em&gt; name outside &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Su problema no tiene nada que ver con el &lt;em&gt;alcance&lt;/em&gt; . En el c&amp;oacute;digo que muestra, la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; no ve los nombres en la funci&amp;oacute;n &lt;code&gt;foo&lt;/code&gt; , por lo que no puede acceder &lt;code&gt;a&lt;/code&gt; in ino directamente con &lt;em&gt;este&lt;/em&gt; nombre fuera de &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4467dc3c2dfc773030d9d4d4ec6b6374a6ce09aa" translate="yes" xml:space="preserve">
          <source>allocating memory for int into a local function</source>
          <target state="translated">asignando memoria para int en una función local</target>
        </trans-unit>
        <trans-unit id="25568658dcfbd886141b75f7a37ca9a44f6d7bfe" translate="yes" xml:space="preserve">
          <source>be the address of &lt;code&gt;a&lt;/code&gt;. Now that you're outside of &lt;code&gt;foo&lt;/code&gt;, it's just a pointer to some random memory area. It just so happens that in your example, that memory area does exist and nothing else is using it at the moment. You don't break anything by continuing to use it, and nothing else has overwritten it yet. Therefore, the &lt;code&gt;5&lt;/code&gt; is still there. In a real program, that memory would be re-used almost immediately and you'd break something by doing this (though the symptoms may not appear until much later!)</source>
          <target state="translated">ser la direcci&amp;oacute;n de &lt;code&gt;a&lt;/code&gt; . Ahora que est&amp;aacute;s fuera de &lt;code&gt;foo&lt;/code&gt; , es solo un puntero a un &amp;aacute;rea de memoria aleatoria. Sucede que, en su ejemplo, esa &amp;aacute;rea de memoria existe y nada m&amp;aacute;s la est&amp;aacute; usando en este momento. No se rompe nada al continuar us&amp;aacute;ndolo, y nada m&amp;aacute;s lo ha sobrescrito todav&amp;iacute;a. Por lo tanto, el &lt;code&gt;5&lt;/code&gt; sigue ah&amp;iacute;. En un programa real, esa memoria se reutilizar&amp;iacute;a casi de inmediato y se romper&amp;iacute;a algo al hacer esto (&amp;iexcl;aunque los s&amp;iacute;ntomas pueden no aparecer hasta mucho m&amp;aacute;s tarde!)</target>
        </trans-unit>
        <trans-unit id="5b1b059e808759b8d1c5874ad49671b3b3d4813a" translate="yes" xml:space="preserve">
          <source>if you do something like that:</source>
          <target state="translated">si haces algo así:</target>
        </trans-unit>
        <trans-unit id="3853ee4965d2fd6e74929bd4ae29cc0ed44947f9" translate="yes" xml:space="preserve">
          <source>that memory address is still valid also when function expires, (it is not deleted by anyone)</source>
          <target state="translated">esa dirección de memoria sigue siendo válida también cuando la función expira,(no es borrada por nadie)</target>
        </trans-unit>
        <trans-unit id="197d6cb5a85574406eca31e0a72c1a7b788a0490" translate="yes" xml:space="preserve">
          <source>the memory address is trustable (that memory block is not considered free, so it will be not overridden until it is deleted)</source>
          <target state="translated">la dirección de memoria es confiable (ese bloque de memoria no se considera libre,por lo que no se anulará hasta que se elimine)</target>
        </trans-unit>
        <trans-unit id="e0d69ca46fd46558106bbf5d93de1a37ad007fdb" translate="yes" xml:space="preserve">
          <source>the memory address should be deleted when not used. (see the delete at the end of the program)</source>
          <target state="translated">la dirección de la memoria debe ser borrada cuando no se utiliza.(ver el borrado al final del programa)</target>
        </trans-unit>
        <trans-unit id="abe86398849a8e40d77bea83096ad74f206ef947" translate="yes" xml:space="preserve">
          <source>the output probably will be: 7</source>
          <target state="translated">la salida probablemente será:7</target>
        </trans-unit>
        <trans-unit id="34790dc2e682800571cab44d1835a970e54f21a8" translate="yes" xml:space="preserve">
          <source>used to</source>
          <target state="translated">solía</target>
        </trans-unit>
        <trans-unit id="46dbdaa85bacc9d8c59df32ce3fb81070bc6523b" translate="yes" xml:space="preserve">
          <source>warning: address of local variable 'a' returned</source>
          <target state="translated">advertencia:la dirección de la variable local &quot;a&quot; devuelta</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
