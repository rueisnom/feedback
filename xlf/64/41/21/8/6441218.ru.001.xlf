<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/6441218">
    <body>
      <group id="6441218">
        <trans-unit id="f5f16923f0af049a9268d2bca9a807fbee68cdfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; might in fact genuinely be a valid address of a double, e.g. &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; действительно может быть действительным адресом типа double, например &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt; q = &amp;amp; p; ,</target>
        </trans-unit>
        <trans-unit id="2323769261698fad3bf45ce9c6dead419d7ed3ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; might point somewhere inside allocated memory and I just overwrite 8 bytes in there.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; может указывать где-то внутри выделенной памяти, и я просто перезаписываю туда 8 байтов.</target>
        </trans-unit>
        <trans-unit id="89dc785e6f5a1676a10c0b1098798eb7eb2480dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; points outside allocated memory and the operating system's memory manager sends a segmentation fault signal to my program, causing the runtime to terminate it.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; указывает за пределы выделенной памяти, и диспетчер памяти операционной системы посылает сигнал сбоя сегментации в мою программу, заставляя время выполнения прекратить его.</target>
        </trans-unit>
        <trans-unit id="199f80d5e26390e5ebf9e949c594dd75500aa2da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Let me take a real world example:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Позвольте мне привести пример из реального мира:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="092cbceb9ffa47ba2a3d0a48ececdefff70b083a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ is not a safe language&lt;/strong&gt;. It will cheerfully allow you to break the rules of the system. If you try to do something illegal and foolish like going back into a room you're not authorized to be in and rummaging through a desk that might not even be there anymore, C++ is not going to stop you. Safer languages than C++ solve this problem by restricting your power -- by having much stricter control over keys, for example.</source>
          <target state="translated">&lt;strong&gt;C ++ не является безопасным языком&lt;/strong&gt; . Это позволит вам весело нарушить правила системы. Если вы попытаетесь сделать что-то незаконное и глупое, например, вернуться в комнату, в которой вам не разрешено находиться, и порыться в столе, которого там больше нет, C ++ вас не остановит. Более безопасные языки, чем C ++, решают эту проблему, ограничивая ваши возможности - например, благодаря более строгому контролю над ключами.</target>
        </trans-unit>
        <trans-unit id="6c1c49fcc0bc7f787bb6de1ef0e235efab3bfc3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How can that be? Aren't the contents of a hotel room drawer inaccessible if you haven't rented the room?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как это может быть?&lt;/strong&gt; &lt;strong&gt;Разве содержимое ящика гостиничного номера недоступно, если вы не арендовали номер?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c802d8f0f438f6d01b82bd537e9909b51c503a35" translate="yes" xml:space="preserve">
          <source>A little addition to all the answers:</source>
          <target state="translated">Небольшое дополнение ко всем ответам:</target>
        </trans-unit>
        <trans-unit id="ee1cefbbc3f6ae87dd7e67ea9cfb80dac82e13c9" translate="yes" xml:space="preserve">
          <source>A week later, you return to the hotel, do not check in, sneak into your old room with your stolen key, and look in the drawer. Your book is still there. Astonishing!</source>
          <target state="translated">Через неделю вы возвращаетесь в отель,не регистрируетесь,проникаете в свой старый номер с украденным ключом и заглядываете в ящик.Твоя книга все еще там.Удивительно!</target>
        </trans-unit>
        <trans-unit id="9125bf2280239c3b164efc1df4e296b36f1c41f1" translate="yes" xml:space="preserve">
          <source>After returning from a function, all identifiers are destroyed instead of kept values in a memory location and we can not locate the values without having an identifier.But that location still contains the value stored by previous function.</source>
          <target state="translated">После возвращения из функции все идентификаторы уничтожаются вместо сохраненных значений в ячейке памяти,и мы не можем найти значения без идентификатора,но в этой ячейке все равно находится значение,сохраненное предыдущей функцией.</target>
        </trans-unit>
        <trans-unit id="551408e0c19118edd84d52d381542cdcbdda834c" translate="yes" xml:space="preserve">
          <source>An implementation of C++ is not required to ensure that when the stack logically shrinks, the addresses that used to be valid are still mapped into memory. The implementation is allowed to tell the operating system &quot;we're done using this page of stack now. Until I say otherwise, issue an exception that destroys the process if anyone touches the previously-valid stack page&quot;.  Again, implementations do not actually do that because it is slow and unnecessary.</source>
          <target state="translated">Реализация C++не требуется для того,чтобы при логическом сокращении стека адреса,которые раньше были действительными,по-прежнему отображались в памяти.Реализация позволяет сказать операционной системе,что &quot;мы закончили использовать эту страницу стека&quot;.Пока я не скажу иначе,выпустите исключение,которое уничтожает процесс,если кто-нибудь прикоснется к странице стека,которая ранее была действительна&quot;.Опять же,реализации на самом деле не делают этого,потому что они медленные и ненужные.</target>
        </trans-unit>
        <trans-unit id="9e4a51f2c5d3df5cc305fe5241ee9f91c1862f4a" translate="yes" xml:space="preserve">
          <source>An implementation of C++ is not required to leave the garbage you left on the stack untouched so that you can come back for it later illegally; it is perfectly legal for the compiler to generate code that turns back to zero everything in the &quot;room&quot; that you just vacated. It doesn't because again, that would be expensive.</source>
          <target state="translated">Реализация Си++не требуется,чтобы оставить мусор,который вы оставили на стеке,нетронутым,чтобы вы могли вернуться за ним позже нелегально;компилятору совершенно легально генерировать код,который возвращает к нулю все в &quot;комнате&quot;,которую вы только что освободили.Это не так,потому что опять же,это было бы дорого.</target>
        </trans-unit>
        <trans-unit id="107c7e3b89899d409b00af753e9116c3756b3bed" translate="yes" xml:space="preserve">
          <source>And the code is just running with no runtime exceptions!</source>
          <target state="translated">И код работает без исключений во время выполнения!</target>
        </trans-unit>
        <trans-unit id="2eef47beb4615f77d95310d433dca2a905f6afd0" translate="yes" xml:space="preserve">
          <source>Because the storage space wasn't stomped on just yet. Don't count on that behavior.</source>
          <target state="translated">Потому что хранилище еще не топтали.Не рассчитывай на такое поведение.</target>
        </trans-unit>
        <trans-unit id="4c294f2376bf1ce93f3fa4b96d3051ce6d617ff9" translate="yes" xml:space="preserve">
          <source>But I agree with Mark B that the resulting behavior is undefined.</source>
          <target state="translated">Но я согласен с Марком Б,что результирующее поведение не определено.</target>
        </trans-unit>
        <trans-unit id="b1cc5de4f5cc262455af25eee537c1fbe8ede183" translate="yes" xml:space="preserve">
          <source>Can a local variable's memory be accessed outside its scope</source>
          <target state="translated">Может ли доступ к памяти локальной переменной за пределами ее границ</target>
        </trans-unit>
        <trans-unit id="b2a932b65ee498810514c1bea0d35efc855a4f81" translate="yes" xml:space="preserve">
          <source>Compilers are in the business of generating code which manages the storage of the data manipulated by that program. There are lots of different ways of generating code to manage memory, but over time two basic techniques have become entrenched.</source>
          <target state="translated">Компиляторы занимаются генерированием кода,который управляет хранением данных,манипулируемых этой программой.Существует множество различных способов генерации кода для управления памятью,но со временем укоренились два основных метода.</target>
        </trans-unit>
        <trans-unit id="c817be5dd088db601f9b4bede3267671d06ac959" translate="yes" xml:space="preserve">
          <source>Consider this example, instead, and test it:</source>
          <target state="translated">Вместо этого рассмотрим этот пример и протестируем его:</target>
        </trans-unit>
        <trans-unit id="c0f296eb7c38fa507531b7353e52a86837866c31" translate="yes" xml:space="preserve">
          <source>Did you compile your program with the optimiser enabled? The &lt;code&gt;foo()&lt;/code&gt; function is quite simple and might have been inlined or replaced in the resulting code.</source>
          <target state="translated">Скомпилировали ли вы свою программу с включенным оптимизатором? Функция &lt;code&gt;foo()&lt;/code&gt; довольно проста и может быть встроена или заменена в полученном коде.</target>
        </trans-unit>
        <trans-unit id="b807ff8ce557df22c0a2b48e1eb3c952a35d8a67" translate="yes" xml:space="preserve">
          <source>For an example of the kind of spooky behavior you are &lt;em&gt;likely&lt;/em&gt; to get, try this sample:</source>
          <target state="translated">Для примера того типа поведения, которое вы, &lt;em&gt;вероятно,&lt;/em&gt; получите, попробуйте этот пример:</target>
        </trans-unit>
        <trans-unit id="5c70b26fb103aa28d932d18050cb856e801635d4" translate="yes" xml:space="preserve">
          <source>For further reading:</source>
          <target state="translated">Для дальнейшего чтения:</target>
        </trans-unit>
        <trans-unit id="1bf2110822fba72487dccdd77a2d40f6bd00662b" translate="yes" xml:space="preserve">
          <source>For this reason, local variables are usually generated as storage on a &quot;stack&quot; data structure, because a stack has the property that the first thing pushed on it is going to be the last thing popped off.</source>
          <target state="translated">По этой причине локальные переменные обычно генерируются как хранилище в структуре данных &quot;стека&quot;,потому что стек имеет свойство,что первое,что на него нажимается,будет последним,что выскакивает.</target>
        </trans-unit>
        <trans-unit id="5efbdcdc6578ea05130db18ac54a4c2a591f0648" translate="yes" xml:space="preserve">
          <source>GCC shows this Warning</source>
          <target state="translated">GCC показывает это предупреждение</target>
        </trans-unit>
        <trans-unit id="b10d57cc173a336784fa10ae3535545c463b017f" translate="yes" xml:space="preserve">
          <source>Here I am simply treating 123456 as the address of a double and write to it. Any number of things could happen:</source>
          <target state="translated">Здесь я просто рассматриваю 123456 как адрес двойника и пишу ему.Может случиться что угодно:</target>
        </trans-unit>
        <trans-unit id="cac5d1b4d781ba7ae7623777363b8748a7fffdc9" translate="yes" xml:space="preserve">
          <source>Holy goodness, this answer is getting a lot of attention. (I'm not sure why -- I considered it to be just a &quot;fun&quot; little analogy, but whatever.)</source>
          <target state="translated">Святые небеса,этот ответ привлекает много внимания.(Я не уверен,почему...Я считал,что это просто &quot;веселая&quot; маленькая аналогия,но неважно.)</target>
        </trans-unit>
        <trans-unit id="3fc5e06963f155f494425e90cc027ebe74ce7146" translate="yes" xml:space="preserve">
          <source>How can it be? Isn't the memory of a local variable inaccessible outside its function?</source>
          <target state="translated">Как это может быть? Разве память локальной переменной не недоступна вне ее функции?</target>
        </trans-unit>
        <trans-unit id="3fb4e1bfa90528212a424b3831d731b3a5295bc1" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;undefined&lt;/em&gt; behaviour and you should not rely on it to work!</source>
          <target state="translated">Тем не менее, это &lt;em&gt;неопределенное&lt;/em&gt; поведение, и вы не должны полагаться на него, чтобы работать!</target>
        </trans-unit>
        <trans-unit id="a7065978f6d14568e0e790c7484b61564f9f8483" translate="yes" xml:space="preserve">
          <source>I have the following code.</source>
          <target state="translated">У меня есть следующий код.</target>
        </trans-unit>
        <trans-unit id="d9e4823ab18ab248ad0ae5098903f1270fb34501" translate="yes" xml:space="preserve">
          <source>I thought it might be germane to update this a bit with a few more technical thoughts.</source>
          <target state="translated">Я подумал,что было бы уместно обновить это немного более технически.</target>
        </trans-unit>
        <trans-unit id="e84b4bc2bc02c2ff515aa6c327f740c5f39d484a" translate="yes" xml:space="preserve">
          <source>In C++, you &lt;em&gt;can&lt;/em&gt; access any address, but it doesn't mean you &lt;em&gt;should&lt;/em&gt;. The address you are accessing is no longer valid. It &lt;em&gt;works&lt;/em&gt; because nothing else scrambled the memory after foo returned, but it could crash under many circumstances. Try analyzing your program with &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt;, or even just compiling it optimized, and see...</source>
          <target state="translated">В C ++ вы &lt;em&gt;можете&lt;/em&gt; получить доступ к любому адресу, но это не значит, что вы &lt;em&gt;должны&lt;/em&gt; . Адрес, к которому вы обращаетесь, больше не действителен. Это &lt;em&gt;работает,&lt;/em&gt; потому что после возврата foo больше ничего не зашифровывало память, но могло произойти сбой при многих обстоятельствах. Попробуйте проанализировать вашу программу с помощью &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt; или даже просто оптимизировать ее, и посмотрите ...</target>
        </trans-unit>
        <trans-unit id="d0fe5db286c8dab66cb0d3b82b36a45e675f7834" translate="yes" xml:space="preserve">
          <source>In short: this won't usually work, but sometimes will by chance.</source>
          <target state="translated">Короче говоря:обычно это не срабатывает,но иногда срабатывает случайно.</target>
        </trans-unit>
        <trans-unit id="884f6b5a0e405708c0d3da980d10be30e33501e7" translate="yes" xml:space="preserve">
          <source>In this situation &lt;strong&gt;anything can happen&lt;/strong&gt;. The book can be there -- you got lucky. Someone else's book can be there and yours could be in the hotel's furnace. Someone could be there right when you come in, tearing your book to pieces. The hotel could have removed the table and book entirely and replaced it with a wardrobe. The entire hotel could be just about to be torn down and replaced with a football stadium, and you are going to die in an explosion while you are sneaking around.</source>
          <target state="translated">В этой ситуации &lt;strong&gt;все может случиться&lt;/strong&gt; . Книга может быть там - вам повезло. Там может быть чужая книга, а ваша может быть в печи отеля. Кто-то может быть там, когда вы входите, разрывая вашу книгу на части. Отель мог бы убрать стол и забронировать полностью и заменить его гардеробом. Весь отель может быть снесен и заменен футбольным стадионом, и вы умрете во взрыве, когда будете красться.</target>
        </trans-unit>
        <trans-unit id="2e771043fe216902e4ecf87e32bed904be6c6fe8" translate="yes" xml:space="preserve">
          <source>In typical compiler implementations, you can think of the code as &quot;print out the value of the memory block with adress that &lt;em&gt;used to be&lt;/em&gt; occupied by a&quot;. Also, if you add a new function invocation to a function that constains a local &lt;code&gt;int&lt;/code&gt; it's a good chance that the value of &lt;code&gt;a&lt;/code&gt; (or the memory address that &lt;code&gt;a&lt;/code&gt; used to point to) changes. This happens because the stack will be overwritten with a new frame containing different data.</source>
          <target state="translated">В типичных реализациях компилятора вы можете думать о коде как о &amp;laquo;распечатке значения блока памяти с адресом, который &lt;em&gt;раньше был&lt;/em&gt; занят&amp;raquo;. Кроме того, если вы добавляете новый вызов функции в функцию, которая содержит локальный тип &lt;code&gt;int&lt;/code&gt; , есть большая вероятность того, что значение (или адрес памяти, &lt;code&gt;a&lt;/code&gt; используется указатель) изменится. Это происходит потому, что стек будет перезаписан новым фреймом, содержащим другие данные.</target>
        </trans-unit>
        <trans-unit id="e6431cf35a0648d9b667c3d460073ff4a639aace" translate="yes" xml:space="preserve">
          <source>Instead, implementations let you make mistakes and get away with it. Most of the time. Until one day something truly awful goes wrong and the process explodes.</source>
          <target state="translated">Вместо этого реализации позволяют совершать ошибки и уходить от них.Большую часть времени.Пока однажды что-то действительно ужасное не пойдет не так,и процесс не взорвется.</target>
        </trans-unit>
        <trans-unit id="cf808b24485af68ad3c78cf040a3df8bd129cff2" translate="yes" xml:space="preserve">
          <source>It can, because &lt;code&gt;a&lt;/code&gt; is a variable allocated temporarily for the lifetime of its scope (&lt;code&gt;foo&lt;/code&gt; function). After you return from &lt;code&gt;foo&lt;/code&gt; the memory is free and can be overwritten.</source>
          <target state="translated">Это возможно, потому &lt;code&gt;a&lt;/code&gt; переменная, временно выделенная на время существования ее области видимости (функция &lt;code&gt;foo&lt;/code&gt; ). После возврата из &lt;code&gt;foo&lt;/code&gt; память свободна и может быть перезаписана.</target>
        </trans-unit>
        <trans-unit id="a24c120f4ed8e1f85f91181732fc5d4f90b2dfce" translate="yes" xml:space="preserve">
          <source>It works because the stack has not been altered (yet) since a was put there. 
Call a few other functions (which are also calling other functions) before accessing &lt;code&gt;a&lt;/code&gt; again and you will probably not be so lucky anymore... ;-)</source>
          <target state="translated">Это работает, потому что стек не был изменен (пока) с тех пор, как был помещен туда. Вызовите несколько других функций (которые также вызывают другие функции), прежде чем снова получить доступ к &lt;code&gt;a&lt;/code&gt; , и вам, вероятно, больше не повезет ... ;-)</target>
        </trans-unit>
        <trans-unit id="6d865b18ac08c0c3d8f413777a079cf33cf8b7d8" translate="yes" xml:space="preserve">
          <source>It's 'Dirty' way of using memory addresses. When you return an address (pointer) you don't know whether it belongs to local scope of a function. It's just an address. Now that you invoked the 'foo' function, that address (memory location) of 'a' was already allocated there in the (safely, for now at least) addressable memory of your application (process). After the 'foo' function returned, the address of 'a' can be considered 'dirty' but it's there, not cleaned up, nor disturbed/modified by expressions in other part of program (in this specific case at least). A C/C++ compiler doesn't stop you from such 'dirty' access (might warn you though, if you care). You can safely use (update) any memory location that is in the data segment of your program instance (process) unless you protect the address by some means.</source>
          <target state="translated">Это &quot;Грязный&quot; способ использования адресов памяти.Когда вы возвращаете адрес (указатель),вы не знаете,принадлежит ли он к локальной области видимости функции.Это просто адрес.Теперь,когда вы вызвали функцию 'foo',этот адрес (область памяти)'a' уже был выделен в (по крайней мере,пока)адресной памяти вашего приложения (процесса).После возврата функции 'foo' адрес 'a' можно считать &quot;грязным&quot;,но он там,не очищен и не изменен выражениями в другой части программы (по крайней мере,в данном конкретном случае).Компилятор CC++не останавливает Вас от такого 'грязного' доступа (может предупредить,если Вас это волнует).Вы можете безопасно использовать (обновлять)любую область памяти,находящуюся в сегменте данных экземпляра (процесса)вашей программы,если только вы не защитите адрес каким-либо образом.</target>
        </trans-unit>
        <trans-unit id="668ed96ef41788718678a8ce40aa14755a7a92c8" translate="yes" xml:space="preserve">
          <source>It's like the hotel decides to only rent out rooms sequentially, and you can't check out until everyone with a room number higher than you has checked out.</source>
          <target state="translated">Это похоже на то,что отель решает снимать номера только последовательно,и вы не сможете выписаться,пока все,у кого номер комнаты выше,не выпишут.</target>
        </trans-unit>
        <trans-unit id="f3e2804ed3bd64f789e8ab14d3b38ca8f2c1f567" translate="yes" xml:space="preserve">
          <source>Local variables follow the latter pattern; when a method is entered, its local variables come alive. When that method calls another method, the new method's local variables come alive. They'll be dead before the first method's local variables are dead.  The relative order of the beginnings and endings of lifetimes of storages associated with local variables can be worked out ahead of time.</source>
          <target state="translated">Локальные переменные следуют последнему шаблону;при вводе метода оживают его локальные переменные.Когда этот метод вызывает другой метод,оживают локальные переменные нового метода.Они будут мертвы до того,как локальные переменные первого метода будут мертвы.Относительный порядок начала и окончания срока службы хранилищ,связанных с локальными переменными,можно вычислить заранее.</target>
        </trans-unit>
        <trans-unit id="92b523458f46cae25f6e91180adcbb80c63ad661" translate="yes" xml:space="preserve">
          <source>More memory-safe languages solve this problem by restricting your power. In &quot;normal&quot; C# there simply is no way to take the address of a local and return it or store it for later. You can take the address of a local, but the language is cleverly designed so that it is impossible to use it after the lifetime of the local ends. In order to take the address of a local and pass it back, you have to put the compiler in a special &quot;unsafe&quot; mode, &lt;em&gt;and&lt;/em&gt; put the word &quot;unsafe&quot; in your program, to call attention to the fact that you are probably doing something dangerous that could be breaking the rules.</source>
          <target state="translated">Более безопасные для памяти языки решают эту проблему, ограничивая ваши возможности. В &amp;laquo;нормальном&amp;raquo; C # просто нет возможности взять адрес локального и вернуть его или сохранить на потом. Вы можете взять адрес локального, но язык продуманно разработан так, что его невозможно использовать после окончания срока действия локального. Чтобы взять локальный адрес и передать его обратно, вы должны перевести компилятор в специальный &amp;laquo;небезопасный&amp;raquo; режим &lt;em&gt;и&lt;/em&gt; поместить слово &amp;laquo;небезопасный&amp;raquo; в вашу программу, чтобы обратить внимание на тот факт, что вы, вероятно, делаете что-то опасное, что может нарушать правила.</target>
        </trans-unit>
        <trans-unit id="f7776b8ae70f653468c196298aea76866e611224" translate="yes" xml:space="preserve">
          <source>Nobody will automatically check the semantic validity of memory addresses like that for you during normal program execution. However, a memory debugger such as &lt;code&gt;valgrind&lt;/code&gt; will happily do this, so you should run your program through it and witness the errors.</source>
          <target state="translated">Никто не будет автоматически проверять семантическую правильность адресов памяти для вас при обычном выполнении программы. Тем не менее, отладчик памяти, такой как &lt;code&gt;valgrind&lt;/code&gt; , с радостью сделает это, поэтому вы должны запустить свою программу через него и стать свидетелем ошибок.</target>
        </trans-unit>
        <trans-unit id="9cc0ce9cccdfa9247eba033a1e1a044665d8c5e6" translate="yes" xml:space="preserve">
          <source>Now if you're wondering why the compiler doesn't complain, it's probably because &lt;code&gt;foo&lt;/code&gt; got eliminated by optimization. It usually will warn you about this sort of thing. C assumes you know what you're doing though, and technically you haven't violated scope here (there's no reference to &lt;code&gt;a&lt;/code&gt; itself outside of &lt;code&gt;foo&lt;/code&gt;), only memory access rules, which only triggers a warning rather than an error.</source>
          <target state="translated">Теперь, если вам интересно, почему компилятор не жалуется, возможно, это связано с оптимизацией &lt;code&gt;foo&lt;/code&gt; . Обычно он предупредит вас об этом. C предполагает, что вы знаете, что делаете, и технически здесь вы не нарушили область действия (здесь нет ссылки на себя вне &lt;code&gt;foo&lt;/code&gt; ), только правила доступа к памяти, которые только вызывают предупреждение, а не ошибку.</target>
        </trans-unit>
        <trans-unit id="64dfdee1fb88a04e52e453e6fea524374d6fce64" translate="yes" xml:space="preserve">
          <source>Pay attention to  all warnings . Do not only solve errors.</source>
          <target state="translated">Обратите внимание на все предупреждения.Не только устраняйте ошибки.</target>
        </trans-unit>
        <trans-unit id="dbd3aa8cb4b802de57285634bed996e92ef2c0e4" translate="yes" xml:space="preserve">
          <source>Returning the address of a temporary works, but as temporaries are destroyed at the end of a function the results of accessing them will be undefined.</source>
          <target state="translated">Возврат адреса временных работ,но по мере того,как временные работы будут уничтожены в конце функции,результаты доступа к ним будут неопределенны.</target>
        </trans-unit>
        <trans-unit id="7a96582b612f775240973f5214e850faef3962ce" translate="yes" xml:space="preserve">
          <source>So let's think about the stack. In many operating systems you get one stack per thread and the stack is allocated to be a certain fixed size. When you call a method, stuff is pushed onto the stack. If you then pass a pointer to the stack back out of your method, as the original poster does here, that's just a pointer to the middle of some entirely valid million-byte memory block. In our analogy, you check out of the hotel; when you do, you just checked out of the highest-numbered occupied room.  If no one else checks in after you, and you go back to your room illegally, all your stuff is guaranteed to still be there &lt;em&gt;in this particular hotel&lt;/em&gt;.</source>
          <target state="translated">Итак, давайте подумаем о стеке. Во многих операционных системах вы получаете один стек на поток, и стек выделяется для определенного фиксированного размера. Когда вы вызываете метод, материал помещается в стек. Если вы затем передаете указатель на стек обратно из вашего метода, как это делает оригинальный постер, это просто указатель на середину какого-то полностью действительного блока памяти в миллион байт. По нашей аналогии вы выезжаете из отеля; когда вы это сделаете, вы только что вышли из занятой комнаты с наибольшим номером. Если никто не зарегистрируется после вас, и вы незаконно вернетесь в свою комнату, все ваши вещи гарантированно останутся &lt;em&gt;в этом конкретном отеле&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="48e728fecb72b1215b61d3c3ac811f6b5f708706" translate="yes" xml:space="preserve">
          <source>So you did not modify &lt;code&gt;a&lt;/code&gt; but rather the memory location where &lt;code&gt;a&lt;/code&gt; once was. This difference is very similar to the difference between crashing and not crashing.</source>
          <target state="translated">Таким образом, вы не изменили, а скорее место памяти, где когда-то был. Эта разница очень похожа на разницу между сбой и не сбой.</target>
        </trans-unit>
        <trans-unit id="415f6940290f7adad86030b3b1e1a91474c25e52" translate="yes" xml:space="preserve">
          <source>So, here function &lt;code&gt;foo()&lt;/code&gt; is returning the address of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is destroyed after returning its address. And you can access the modified value through that returned address.</source>
          <target state="translated">Итак, здесь функция &lt;code&gt;foo()&lt;/code&gt; возвращает адрес &lt;code&gt;a&lt;/code&gt; , а &lt;code&gt;a&lt;/code&gt; уничтожается после возврата его адреса. И вы можете получить доступ к измененному значению через этот возвращенный адрес.</target>
        </trans-unit>
        <trans-unit id="4ca65421239872c85bc7cb4eab3534ea2b033ade" translate="yes" xml:space="preserve">
          <source>Suppose a man hides money at a location and tells you the location. After some time, the man who had told you the money location dies. But still you have the access of that hidden money.</source>
          <target state="translated">Предположим,человек прячет деньги на месте и сообщает вам о месте.Спустя некоторое время,человек,который сказал вам местонахождение денег,умирает.Но все же у вас есть доступ к этим скрытым деньгам.</target>
        </trans-unit>
        <trans-unit id="6637ee0ae3a2356e88607e4783fe52245560ba0b" translate="yes" xml:space="preserve">
          <source>That is because after returning from foo() the stack is freed and then reused by boo().
If you deassemble the executable you will see it clearly.</source>
          <target state="translated">Это происходит потому,что после возвращения из функции foo()стек освобождается и затем повторно используется функцией boo().Если вы деассемблируете исполняемый файл,вы увидите его отчетливо.</target>
        </trans-unit>
        <trans-unit id="10653b9d4a1d031b54f7ad1b1a5976b3c3fe1950" translate="yes" xml:space="preserve">
          <source>That means the memory address could be valid or not, and your code will be vulnerable to possible memory address issues (for example segmentation fault).</source>
          <target state="translated">Это означает,что адрес памяти может быть действительным или нет,и ваш код будет уязвим для возможных проблем с адресом памяти (например,ошибка сегментации).</target>
        </trans-unit>
        <trans-unit id="55e66b98d49314348a56ec9d7b30dce4d53f468e" translate="yes" xml:space="preserve">
          <source>That's classic &lt;strong&gt;undefined behaviour&lt;/strong&gt; that's been discussed here not two days ago -- search around the site for a bit. In a nutshell, you were lucky, but anything could have happened and your code is making invalid access to memory.</source>
          <target state="translated">Это классическое &lt;strong&gt;неопределенное поведение,&lt;/strong&gt; которое обсуждалось здесь не два дня назад - поиск по сайту немного. Короче говоря, вам повезло, но все могло произойти, и ваш код делает недопустимый доступ к памяти.</target>
        </trans-unit>
        <trans-unit id="d01e8b0fd46bdbf027d2c78b2cf77e0ad3eadb05" translate="yes" xml:space="preserve">
          <source>The first is to have some sort of &quot;long lived&quot; storage area where the &quot;lifetime&quot; of each byte in the storage -- that is, the period of time when it is validly associated with some program variable -- cannot be easily predicted ahead of time. The compiler generates calls into a &quot;heap manager&quot; that knows how to dynamically allocate storage when it is needed and reclaim it when it is no longer needed.</source>
          <target state="translated">Первое-это некая &quot;долгоживущая&quot; область хранения,в которой &quot;время жизни&quot; каждого байта в хранилище-то есть период времени,когда он корректно связан с какой-то программной переменной-не может быть легко предсказано заранее.Компилятор генерирует вызовы в &quot;менеджер кучи&quot;,который знает,как динамически выделять хранилище,когда оно необходимо,и восстанавливать его,когда оно больше не нужно.</target>
        </trans-unit>
        <trans-unit id="2a517045d055d1343ace682896452e5177bc4524" translate="yes" xml:space="preserve">
          <source>The hotel management is not &lt;em&gt;required&lt;/em&gt; to remove your book. You didn't make a contract with them that said that if you leave stuff behind, they'll shred it for you. If you illegally re-enter your room with a stolen key to get it back, the hotel security staff is not &lt;em&gt;required&lt;/em&gt; to catch you sneaking in. You didn't make a contract with them that said &quot;if I try to sneak back into my room later, you are required to stop me.&quot; Rather, you signed a contract with them that said &quot;I promise not to sneak back into my room later&quot;, a contract which &lt;em&gt;you broke&lt;/em&gt;.</source>
          <target state="translated">Администрация отеля не &lt;em&gt;обязана&lt;/em&gt; удалять вашу книгу. Вы не заключили с ними контракт, в котором говорилось, что если вы оставите вещи позади, они уничтожат их для вас. Если вы незаконно вернетесь в свою комнату с украденным ключом, чтобы вернуть его, сотрудники службы безопасности отеля не &lt;em&gt;обязаны&lt;/em&gt; отлавливать вас подкрадываясь. Вы не заключили с ними контракт, в котором говорилось: &amp;laquo;Если я попытаюсь пробраться обратно в мой номер позже, вы обязаны остановить меня. &quot; Скорее, вы подписали с ними контракт, в котором говорилось: &amp;laquo;Я обещаю не возвращаться в мою комнату позже&amp;raquo;, контракт, который &lt;em&gt;вы нарушили&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0393a71499e25d744a2e0cd1648098b160eca6d2" translate="yes" xml:space="preserve">
          <source>The output was &lt;code&gt;58&lt;/code&gt;</source>
          <target state="translated">Выход был &lt;code&gt;58&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c253d37c3711b668d6b9d942320ae2687acd295" translate="yes" xml:space="preserve">
          <source>The problem you are having is why the program doesn't signal an error when referencing illegal memory. This is because C++ standards does not specify a very clear boundary between illegal memory and legal memory. Referencing something in popped out stack sometimes causes error and sometimes not. It depends. Don't count on this behavior. Assume it will always result in error when you program, but assume it will never signal error when you debug.</source>
          <target state="translated">Проблема в том,что программа не сигнализирует об ошибке при обращении к нелегальной памяти.Это связано с тем,что стандарты языка Си++не определяют очень четкую границу между нелегальной памятью и легальной памятью.Ссылка на что-то в выпавшем стеке иногда приводит к ошибке,а иногда нет.Это зависит.Не рассчитывайте на такое поведение.Допустим,оно всегда будет приводить к ошибке при программировании,но предположим,что оно никогда не будет сигнализировать об ошибке при отладке.</target>
        </trans-unit>
        <trans-unit id="890aeeea49faa2fa28d38ffb4d73ad962a14ab97" translate="yes" xml:space="preserve">
          <source>The second method is to have a &amp;ldquo;short-lived&amp;rdquo; storage area where the lifetime of each byte is well known. Here, the lifetimes follow a &amp;ldquo;nesting&amp;rdquo; pattern. The longest-lived of these short-lived variables will be allocated before any other short-lived variables, and will be freed last. Shorter-lived variables will be allocated after the longest-lived ones, and will be freed before them. The lifetime of these shorter-lived variables is &amp;ldquo;nested&amp;rdquo; within the lifetime of longer-lived ones.</source>
          <target state="translated">Второй способ заключается в том, чтобы иметь &amp;laquo;недолговечную&amp;raquo; область хранения, в которой время жизни каждого байта хорошо известно. Здесь время жизни соответствует шаблону &amp;laquo;вложения&amp;raquo;. Самая долгоживущая из этих кратковременных переменных будет размещена перед любыми другими недолговечными переменными и будет освобождена последней. Короткоживущие переменные будут размещены после самых долгоживущих и будут освобождены перед ними. Время жизни этих короткоживущих переменных &amp;laquo;вложено&amp;raquo; в время жизни долгоживущих.</target>
        </trans-unit>
        <trans-unit id="35e6bd2b69222deaf1995ea9da0a68f6703d7ccb" translate="yes" xml:space="preserve">
          <source>The things with correct (?) console output can change dramatically if you use ::printf but not cout. 
You can play around with debugger within below code (tested on x86, 32-bit, MSVisual Studio):</source>
          <target state="translated">Вещи с правильным (?)консольным выводом могут кардинально измениться,если вы используете ::printf,но не cout.Вы можете поиграть с отладчиком в нижеприведенном коде (тестировался на x86,32-bit,MSVisual Studio):</target>
        </trans-unit>
        <trans-unit id="f0ba7d3098b2635fa4805520c0d620eed935a473" translate="yes" xml:space="preserve">
          <source>The way you set it up it is a bit more reasonable that the returned address points into a valid area of memory, as it will probably just be a little further down the stack, but it is still an invalid location that you cannot access in a deterministic fashion.</source>
          <target state="translated">То,как вы его настроили,немного более разумно,что возвращаемый адрес указывает в действительную область памяти,так как он,вероятно,будет немного дальше по стеку,но это все равно недействительное место,к которому вы не можете получить доступ детерминированным образом.</target>
        </trans-unit>
        <trans-unit id="c64bb54b249751cf9009a2a39ddde0cbec79cbdf" translate="yes" xml:space="preserve">
          <source>This behavior is undefined, as Alex pointed out--in fact, most compilers will warn against doing this, because it's an easy way to get crashes.</source>
          <target state="translated">Это поведение не определено,как заметил Алекс-на самом деле,большинство компиляторов будут предупреждать об этом,потому что это простой способ получить сбои.</target>
        </trans-unit>
        <trans-unit id="df8ae21359a7a9c1782b2fa5d716171e207fefde" translate="yes" xml:space="preserve">
          <source>This is  power of C++. You should care about memory. With the &lt;code&gt;-Werror&lt;/code&gt; flag, this warning becames an error and now you have to debug it.</source>
          <target state="translated">Это сила C ++. Вы должны заботиться о памяти. С &lt;code&gt;-Werror&lt;/code&gt; это предупреждение становится ошибкой, и теперь вы должны его отладить.</target>
        </trans-unit>
        <trans-unit id="5b0d1e6d4ef066a26535944c60c6026681ae3fe8" translate="yes" xml:space="preserve">
          <source>This is problematic. There are a lot of rules and it is very easy to break them accidentally. I certainly have many times. And worse, the problem often only surfaces when memory is detected to be corrupt billions of nanoseconds after the corruption happened, when it is very hard to figure out who messed it up.</source>
          <target state="translated">Это проблематично.Есть много правил,и очень легко их случайно нарушить.У меня,конечно,много раз.И что еще хуже,проблема часто возникает только тогда,когда в памяти обнаруживаются поврежденные миллиарды наносекунд после того,как произошло повреждение,когда очень сложно выяснить,кто все испортил.</target>
        </trans-unit>
        <trans-unit id="0eaf8b53ad7d5c524b38b6a971be8dfad3b95b37" translate="yes" xml:space="preserve">
          <source>This means that you are doing a very bad thing, becouse you are passing a memory address to a pointer wich is not trustable at all.</source>
          <target state="translated">Это означает,что вы делаете очень плохую вещь,потому что вы передаете адрес памяти указателю,который совсем не доверяет.</target>
        </trans-unit>
        <trans-unit id="6f697153226ae9e147e41d50dcd86d77b9a8ca6f" translate="yes" xml:space="preserve">
          <source>This prints out &quot;y=123&quot;, but your results may vary (really!). Your pointer is clobbering other, unrelated local variables.</source>
          <target state="translated">Это печатает &quot;y=123&quot;,но ваши результаты могут варьироваться (на самом деле!).Ваш указатель засоряет другие,несвязанные локальные переменные.</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="398226ff0451b7e1c1c5e5a7a2cbe718625ea490" translate="yes" xml:space="preserve">
          <source>Unlike your example, with this example you are:</source>
          <target state="translated">В отличие от вашего примера:</target>
        </trans-unit>
        <trans-unit id="bf83ed6f06abc30e3c1ba88ba6233762dd35af5d" translate="yes" xml:space="preserve">
          <source>We use stacks for temporary stores because they are really cheap and easy. An implementation of C++ is not required to use a stack for storage of locals; it could use the heap. It doesn't, because that would make the program slower.</source>
          <target state="translated">Мы используем стеки для временных магазинов,потому что они действительно дешевые и простые.Реализация C++не требует использования стека для хранения местных жителей,она может использовать кучу.Это не так,потому что это сделает программу медленнее.</target>
        </trans-unit>
        <trans-unit id="e53fd215b0c495c0d89e0f96c8abbf2fb92be241" translate="yes" xml:space="preserve">
          <source>Well, obviously that scenario can happen in the real world no problem. There is no mysterious force that causes your book to disappear when you are no longer authorized to be in the room. Nor is there a mysterious force that prevents you from entering a room with a stolen key.</source>
          <target state="translated">Ну,очевидно,что этот сценарий может произойти в реальном мире без проблем.Нет никакой таинственной силы,которая заставляет вашу книгу исчезнуть,когда вы больше не имеете права находиться в комнате.Нет также таинственной силы,которая не позволяет вам войти в комнату с украденным ключом.</target>
        </trans-unit>
        <trans-unit id="a5d081b4250b3c6bf254dbe76846254422327e9b" translate="yes" xml:space="preserve">
          <source>What if C# did allow returning references? Coincidentally that is the subject of today's blog post:</source>
          <target state="translated">Что,если бы C#позволил вернуть ссылки? Кстати,это тема сегодняшней заметки в блоге:</target>
        </trans-unit>
        <trans-unit id="4ba89d6203509c5bf6440005ba0577078a5e174f" translate="yes" xml:space="preserve">
          <source>What you're doing here is simply reading and writing to memory that</source>
          <target state="translated">То,что ты здесь делаешь,это просто читаешь и записываешь в память то.</target>
        </trans-unit>
        <trans-unit id="b0b04b262ca077c743d5bedec5d61192576329c1" translate="yes" xml:space="preserve">
          <source>What you're doing is described as &lt;em&gt;undefined behavior&lt;/em&gt;. The result cannot be predicted.</source>
          <target state="translated">То, что вы делаете, описывается как &lt;em&gt;неопределенное поведение&lt;/em&gt; . Результат не может быть предсказан.</target>
        </trans-unit>
        <trans-unit id="a5b6bae245aa7990e2bf8f6d62a4b4fd1d7c04a8" translate="yes" xml:space="preserve">
          <source>When you return from &lt;code&gt;foo&lt;/code&gt;, you tell the OS that you're no longer using that memory and it can be reassigned to something else. If you're lucky and it never does get reassigned, and the OS doesn't catch you using it again, then you'll get away with the lie. Chances are though you'll end up writing over whatever else ends up with that address.</source>
          <target state="translated">Когда вы возвращаетесь из &lt;code&gt;foo&lt;/code&gt; , вы сообщаете ОС, что больше не используете эту память, и ее можно переназначить на что-то другое. Если вам повезло, и он никогда не будет переназначен, а ОС не поймает вас на том, что вы снова его используете, тогда вам сойдет с рук ложь. Скорее всего, вы в конечном итоге переписываете то, что еще заканчивается этим адресом.</target>
        </trans-unit>
        <trans-unit id="fa1180633feda4933e750090ee9485e74f2fa520" translate="yes" xml:space="preserve">
          <source>Why do we use stacks to manage memory? Are value types in C# always stored on the stack? How does virtual memory work? And many more topics in how the C# memory manager works. Many of these articles are also germane to C++ programmers:</source>
          <target state="translated">Почему мы используем стеки для управления памятью? Всегда ли типы значений в C#хранятся в стеке? Как работает виртуальная память? И еще много тем о том,как работает менеджер памяти на C#.Многие из этих статей также относятся к программистам на Си++:</target>
        </trans-unit>
        <trans-unit id="367a511c0bd23747bed54a801c60343a2911cb1f" translate="yes" xml:space="preserve">
          <source>Yes if you try to dereference that memory address you will have undefined behavior.</source>
          <target state="translated">Да,если вы попытаетесь разыменовать этот адрес памяти,у вас будет неопределенное поведение.</target>
        </trans-unit>
        <trans-unit id="f7b6efeb9999e8415e2256127bd801c374f407de" translate="yes" xml:space="preserve">
          <source>You actually invoked undefined behaviour.</source>
          <target state="translated">Ты на самом деле призвал к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="0ab951d4546ea151e47a2697193d8f628bd98a9e" translate="yes" xml:space="preserve">
          <source>You are just returning a memory address, it's allowed but probably an error.</source>
          <target state="translated">Вы просто возвращаете адрес памяти,это разрешено,но,возможно,ошибка.</target>
        </trans-unit>
        <trans-unit id="632ab4b8b530f13855f715927a28aa2f5a4eb21e" translate="yes" xml:space="preserve">
          <source>You don't know what is going to happen; when you checked out of the hotel and stole a key to illegally use later, you gave up the right to live in a predictable, safe world because &lt;em&gt;you&lt;/em&gt; chose to break the rules of the system.</source>
          <target state="translated">Вы не знаете, что произойдет; Когда вы выехали из отеля и позже украли ключ для незаконного использования, вы отказались от права жить в предсказуемом и безопасном мире, потому &lt;em&gt;что&lt;/em&gt; решили нарушить правила системы.</target>
        </trans-unit>
        <trans-unit id="b6a838ff678f89b070003058718a712103126d6e" translate="yes" xml:space="preserve">
          <source>You never throw a C++ exception by accessing invalid memory. You are just giving an example of the general idea of referencing an arbitrary memory location. I could do the same like this:</source>
          <target state="translated">Вы никогда не бросаете исключение C++,получив доступ к недействительной памяти.Вы просто приводите пример общей идеи обращения к произвольной памяти.Я мог бы сделать то же самое:</target>
        </trans-unit>
        <trans-unit id="851a700a375ff806c1dcbb41aa3d34c727d4e133" translate="yes" xml:space="preserve">
          <source>You rent a hotel room. You put a book in the top drawer of the bedside table and go to sleep.  You check out the next morning, but &quot;forget&quot; to give back your key. You steal the key!</source>
          <target state="translated">Ты снимаешь номер в отеле.Вы кладете книгу в верхний ящик прикроватной тумбочки и ложитесь спать.Вы выезжаете на следующее утро,но &quot;забываете&quot; вернуть ключ.Вы крадете ключ!</target>
        </trans-unit>
        <trans-unit id="b6cedbdba81d1f1c5892a7412b1dd7929c578e4d" translate="yes" xml:space="preserve">
          <source>You win the lottery.</source>
          <target state="translated">Ты выиграл в лотерею.</target>
        </trans-unit>
        <trans-unit id="a8d5a5789511f170672864f52617e354f9acfe8c" translate="yes" xml:space="preserve">
          <source>Your code is very risky. You are creating a local variable (wich is considered destroyed after function ends) and you return the address of memory of that variable after it is destoyed.</source>
          <target state="translated">Твой код очень опасен.Вы создаете локальную переменную (wich считается уничтоженной после завершения функции)и возвращаете адрес памяти этой переменной после того,как она будет уничтожена.</target>
        </trans-unit>
        <trans-unit id="27c02908661ef2d4af116e6eda229fd38a50ef3f" translate="yes" xml:space="preserve">
          <source>Your problem has nothing to do with &lt;em&gt;scope&lt;/em&gt;. In the code you show, the function &lt;code&gt;main&lt;/code&gt; does not see the names in the function &lt;code&gt;foo&lt;/code&gt;, so you can't access &lt;code&gt;a&lt;/code&gt; in foo directly with &lt;em&gt;this&lt;/em&gt; name outside &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Ваша проблема не имеет ничего общего с &lt;em&gt;областью применения&lt;/em&gt; . В показанном вами коде функция &lt;code&gt;main&lt;/code&gt; не видит имен в функции &lt;code&gt;foo&lt;/code&gt; , поэтому вы не можете получить доступ &lt;code&gt;a&lt;/code&gt; in foo напрямую с &lt;em&gt;этим&lt;/em&gt; именем вне &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4467dc3c2dfc773030d9d4d4ec6b6374a6ce09aa" translate="yes" xml:space="preserve">
          <source>allocating memory for int into a local function</source>
          <target state="translated">выделение памяти для int в локальную функцию</target>
        </trans-unit>
        <trans-unit id="25568658dcfbd886141b75f7a37ca9a44f6d7bfe" translate="yes" xml:space="preserve">
          <source>be the address of &lt;code&gt;a&lt;/code&gt;. Now that you're outside of &lt;code&gt;foo&lt;/code&gt;, it's just a pointer to some random memory area. It just so happens that in your example, that memory area does exist and nothing else is using it at the moment. You don't break anything by continuing to use it, and nothing else has overwritten it yet. Therefore, the &lt;code&gt;5&lt;/code&gt; is still there. In a real program, that memory would be re-used almost immediately and you'd break something by doing this (though the symptoms may not appear until much later!)</source>
          <target state="translated">быть адресом Теперь, когда вы вне &lt;code&gt;foo&lt;/code&gt; , это просто указатель на некоторую область произвольной памяти. Просто так получилось, что в вашем примере эта область памяти существует, и ничто другое не использует ее в данный момент. Вы ничего не нарушаете, продолжая использовать это, и ничто другое не перезаписало это еще. Таким образом, &lt;code&gt;5&lt;/code&gt; все еще там. В реальной программе эта память использовалась бы почти сразу, и вы могли бы что-то сломать, делая это (хотя симптомы могут появиться не намного позже!)</target>
        </trans-unit>
        <trans-unit id="5b1b059e808759b8d1c5874ad49671b3b3d4813a" translate="yes" xml:space="preserve">
          <source>if you do something like that:</source>
          <target state="translated">если ты сделаешь что-то подобное:</target>
        </trans-unit>
        <trans-unit id="3853ee4965d2fd6e74929bd4ae29cc0ed44947f9" translate="yes" xml:space="preserve">
          <source>that memory address is still valid also when function expires, (it is not deleted by anyone)</source>
          <target state="translated">что адрес памяти остается действительным и по истечении срока действия функции (он никем не удаляется).</target>
        </trans-unit>
        <trans-unit id="197d6cb5a85574406eca31e0a72c1a7b788a0490" translate="yes" xml:space="preserve">
          <source>the memory address is trustable (that memory block is not considered free, so it will be not overridden until it is deleted)</source>
          <target state="translated">адрес памяти надежный (этот блок памяти не считается свободным,поэтому он не будет переопределен до тех пор,пока не будет удален).</target>
        </trans-unit>
        <trans-unit id="e0d69ca46fd46558106bbf5d93de1a37ad007fdb" translate="yes" xml:space="preserve">
          <source>the memory address should be deleted when not used. (see the delete at the end of the program)</source>
          <target state="translated">адрес памяти следует удалять,если он не используется.(см.&quot;Удалить&quot; в конце программы).</target>
        </trans-unit>
        <trans-unit id="abe86398849a8e40d77bea83096ad74f206ef947" translate="yes" xml:space="preserve">
          <source>the output probably will be: 7</source>
          <target state="translated">результат,вероятно,будет:7</target>
        </trans-unit>
        <trans-unit id="34790dc2e682800571cab44d1835a970e54f21a8" translate="yes" xml:space="preserve">
          <source>used to</source>
          <target state="translated">привыкший</target>
        </trans-unit>
        <trans-unit id="46dbdaa85bacc9d8c59df32ce3fb81070bc6523b" translate="yes" xml:space="preserve">
          <source>warning: address of local variable 'a' returned</source>
          <target state="translated">warning:адрес возвращаемой локальной переменной 'a'</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
