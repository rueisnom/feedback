<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/6441218">
    <body>
      <group id="6441218">
        <trans-unit id="f5f16923f0af049a9268d2bca9a807fbee68cdfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; might in fact genuinely be a valid address of a double, e.g. &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; は実際にはdoubleの有効なアドレスである可能性があります（例： &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt; q =＆p; 。</target>
        </trans-unit>
        <trans-unit id="2323769261698fad3bf45ce9c6dead419d7ed3ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; might point somewhere inside allocated memory and I just overwrite 8 bytes in there.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 割り当てられたメモリ内のどこかを指している可能性があり、そこにある8バイトを上書きするだけです。</target>
        </trans-unit>
        <trans-unit id="89dc785e6f5a1676a10c0b1098798eb7eb2480dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; points outside allocated memory and the operating system's memory manager sends a segmentation fault signal to my program, causing the runtime to terminate it.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 割り当てられたメモリの外側を指し、オペレーティングシステムのメモリマネージャーがセグメンテーションフォールト信号をプログラムに送信し、ランタイムがそれを終了させます。</target>
        </trans-unit>
        <trans-unit id="199f80d5e26390e5ebf9e949c594dd75500aa2da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Let me take a real world example:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;実際の例を見てみましょう：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="092cbceb9ffa47ba2a3d0a48ececdefff70b083a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ is not a safe language&lt;/strong&gt;. It will cheerfully allow you to break the rules of the system. If you try to do something illegal and foolish like going back into a room you're not authorized to be in and rummaging through a desk that might not even be there anymore, C++ is not going to stop you. Safer languages than C++ solve this problem by restricting your power -- by having much stricter control over keys, for example.</source>
          <target state="translated">&lt;strong&gt;C ++は安全な言語ではありません&lt;/strong&gt; 。 それは陽気にあなたがシステムのルールを破ることを可能にします。 許可されていない部屋に戻って、もうそこにはないかもしれない机をくまなく探すなど、違法で愚かなことをしようとした場合、C ++はあなたを止めません。 C ++よりも安全な言語は、たとえばキーをはるかに厳密に制御することによって、能力を制限することでこの問題を解決します。</target>
        </trans-unit>
        <trans-unit id="6c1c49fcc0bc7f787bb6de1ef0e235efab3bfc3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How can that be? Aren't the contents of a hotel room drawer inaccessible if you haven't rented the room?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;それはどういうことですか？&lt;/strong&gt; &lt;strong&gt;部屋を借りていないと、ホテルの部屋の引き出しの内容にアクセスできませんか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c802d8f0f438f6d01b82bd537e9909b51c503a35" translate="yes" xml:space="preserve">
          <source>A little addition to all the answers:</source>
          <target state="translated">全回答に少しだけ追加。</target>
        </trans-unit>
        <trans-unit id="ee1cefbbc3f6ae87dd7e67ea9cfb80dac82e13c9" translate="yes" xml:space="preserve">
          <source>A week later, you return to the hotel, do not check in, sneak into your old room with your stolen key, and look in the drawer. Your book is still there. Astonishing!</source>
          <target state="translated">一週間後、ホテルに戻り、チェックインもせず、盗んだ鍵を持って昔の部屋に忍び込み、引き出しの中を覗く。君の本がまだそこにあった 驚いた!</target>
        </trans-unit>
        <trans-unit id="9125bf2280239c3b164efc1df4e296b36f1c41f1" translate="yes" xml:space="preserve">
          <source>After returning from a function, all identifiers are destroyed instead of kept values in a memory location and we can not locate the values without having an identifier.But that location still contains the value stored by previous function.</source>
          <target state="translated">関数から戻ってきた後、すべての識別子はメモリ上の値を保持する代わりに破棄され、識別子を持っていないと値を見つけることができません。</target>
        </trans-unit>
        <trans-unit id="551408e0c19118edd84d52d381542cdcbdda834c" translate="yes" xml:space="preserve">
          <source>An implementation of C++ is not required to ensure that when the stack logically shrinks, the addresses that used to be valid are still mapped into memory. The implementation is allowed to tell the operating system &quot;we're done using this page of stack now. Until I say otherwise, issue an exception that destroys the process if anyone touches the previously-valid stack page&quot;.  Again, implementations do not actually do that because it is slow and unnecessary.</source>
          <target state="translated">C++の実装は、スタックが論理的に縮小したときに、以前は有効だったアドレスがまだメモリにマップされていることを保証する必要はありません。実装はオペレーティングシステムに「スタックのこのページの使用を終了します」と伝えることが許されています。私が別のことを言うまで、誰かが以前に有効だったスタックページに触れた場合、プロセスを破壊する例外を発行してください」。繰り返しになりますが、実装では実際にはそのようなことはしていません。</target>
        </trans-unit>
        <trans-unit id="9e4a51f2c5d3df5cc305fe5241ee9f91c1862f4a" translate="yes" xml:space="preserve">
          <source>An implementation of C++ is not required to leave the garbage you left on the stack untouched so that you can come back for it later illegally; it is perfectly legal for the compiler to generate code that turns back to zero everything in the &quot;room&quot; that you just vacated. It doesn't because again, that would be expensive.</source>
          <target state="translated">C++の実装では、スタックに残したゴミをそのままにしておく必要はなく、後で違法に取りに来ることができます。そうではありません。</target>
        </trans-unit>
        <trans-unit id="107c7e3b89899d409b00af753e9116c3756b3bed" translate="yes" xml:space="preserve">
          <source>And the code is just running with no runtime exceptions!</source>
          <target state="translated">そして、コードは実行時の例外なしに実行されているだけです!</target>
        </trans-unit>
        <trans-unit id="2eef47beb4615f77d95310d433dca2a905f6afd0" translate="yes" xml:space="preserve">
          <source>Because the storage space wasn't stomped on just yet. Don't count on that behavior.</source>
          <target state="translated">収納スペースがまだ踏みつけられていなかったからだ。その行動に期待するな</target>
        </trans-unit>
        <trans-unit id="4c294f2376bf1ce93f3fa4b96d3051ce6d617ff9" translate="yes" xml:space="preserve">
          <source>But I agree with Mark B that the resulting behavior is undefined.</source>
          <target state="translated">しかし、結果としての動作が未定義であることはマークBに同意します。</target>
        </trans-unit>
        <trans-unit id="b1cc5de4f5cc262455af25eee537c1fbe8ede183" translate="yes" xml:space="preserve">
          <source>Can a local variable's memory be accessed outside its scope</source>
          <target state="translated">ローカル変数のメモリをスコープ外でアクセスできるようにする</target>
        </trans-unit>
        <trans-unit id="b2a932b65ee498810514c1bea0d35efc855a4f81" translate="yes" xml:space="preserve">
          <source>Compilers are in the business of generating code which manages the storage of the data manipulated by that program. There are lots of different ways of generating code to manage memory, but over time two basic techniques have become entrenched.</source>
          <target state="translated">コンパイラは、プログラムで操作されたデータの保存を管理するコードを生成する仕事をしています。メモリを管理するコードを生成する方法はいろいろありますが、長い間に2つの基本的な手法が定着してきました。</target>
        </trans-unit>
        <trans-unit id="c817be5dd088db601f9b4bede3267671d06ac959" translate="yes" xml:space="preserve">
          <source>Consider this example, instead, and test it:</source>
          <target state="translated">代わりにこの例を考えて、テストしてみてください。</target>
        </trans-unit>
        <trans-unit id="c0f296eb7c38fa507531b7353e52a86837866c31" translate="yes" xml:space="preserve">
          <source>Did you compile your program with the optimiser enabled? The &lt;code&gt;foo()&lt;/code&gt; function is quite simple and might have been inlined or replaced in the resulting code.</source>
          <target state="translated">オプティマイザを有効にしてプログラムをコンパイルしましたか？ &lt;code&gt;foo()&lt;/code&gt; 関数は非常に単純であり、結果のコードでインライン化または置き換えられた可能性があります。</target>
        </trans-unit>
        <trans-unit id="b807ff8ce557df22c0a2b48e1eb3c952a35d8a67" translate="yes" xml:space="preserve">
          <source>For an example of the kind of spooky behavior you are &lt;em&gt;likely&lt;/em&gt; to get, try this sample:</source>
          <target state="translated">発生する&lt;em&gt;可能性の&lt;/em&gt;ある不気味な動作の例については、次のサンプルを試してください。</target>
        </trans-unit>
        <trans-unit id="5c70b26fb103aa28d932d18050cb856e801635d4" translate="yes" xml:space="preserve">
          <source>For further reading:</source>
          <target state="translated">続きを読むには</target>
        </trans-unit>
        <trans-unit id="1bf2110822fba72487dccdd77a2d40f6bd00662b" translate="yes" xml:space="preserve">
          <source>For this reason, local variables are usually generated as storage on a &quot;stack&quot; data structure, because a stack has the property that the first thing pushed on it is going to be the last thing popped off.</source>
          <target state="translated">この理由から、ローカル変数は通常、&quot;スタック &quot;データ構造体上のストレージとして生成されます。</target>
        </trans-unit>
        <trans-unit id="5efbdcdc6578ea05130db18ac54a4c2a591f0648" translate="yes" xml:space="preserve">
          <source>GCC shows this Warning</source>
          <target state="translated">GCC はこの警告を表示します。</target>
        </trans-unit>
        <trans-unit id="b10d57cc173a336784fa10ae3535545c463b017f" translate="yes" xml:space="preserve">
          <source>Here I am simply treating 123456 as the address of a double and write to it. Any number of things could happen:</source>
          <target state="translated">ここでは単純に 123456 をダブルのアドレスとして扱い、そこに書き込んでいます。いろいろなことが起こりうる。</target>
        </trans-unit>
        <trans-unit id="cac5d1b4d781ba7ae7623777363b8748a7fffdc9" translate="yes" xml:space="preserve">
          <source>Holy goodness, this answer is getting a lot of attention. (I'm not sure why -- I considered it to be just a &quot;fun&quot; little analogy, but whatever.)</source>
          <target state="translated">何と、この答えが注目を集めている。(なぜかはわかりませんが、私はただの「楽しい」小さな例え話だと思っていました。)</target>
        </trans-unit>
        <trans-unit id="3fc5e06963f155f494425e90cc027ebe74ce7146" translate="yes" xml:space="preserve">
          <source>How can it be? Isn't the memory of a local variable inaccessible outside its function?</source>
          <target state="translated">どうしてそうなるのでしょうか?ローカル変数のメモリは、その関数以外ではアクセスできないのではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="3fb4e1bfa90528212a424b3831d731b3a5295bc1" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;undefined&lt;/em&gt; behaviour and you should not rely on it to work!</source>
          <target state="translated">ただし、これは&lt;em&gt;未定義の&lt;/em&gt;動作であり、動作に依存するべきではありません。</target>
        </trans-unit>
        <trans-unit id="a7065978f6d14568e0e790c7484b61564f9f8483" translate="yes" xml:space="preserve">
          <source>I have the following code.</source>
          <target state="translated">私は以下のようなコードを持っています。</target>
        </trans-unit>
        <trans-unit id="d9e4823ab18ab248ad0ae5098903f1270fb34501" translate="yes" xml:space="preserve">
          <source>I thought it might be germane to update this a bit with a few more technical thoughts.</source>
          <target state="translated">私はそれがもう少し技術的な考えを持ってこれを少し更新することが有益かもしれないと考えました。</target>
        </trans-unit>
        <trans-unit id="e84b4bc2bc02c2ff515aa6c327f740c5f39d484a" translate="yes" xml:space="preserve">
          <source>In C++, you &lt;em&gt;can&lt;/em&gt; access any address, but it doesn't mean you &lt;em&gt;should&lt;/em&gt;. The address you are accessing is no longer valid. It &lt;em&gt;works&lt;/em&gt; because nothing else scrambled the memory after foo returned, but it could crash under many circumstances. Try analyzing your program with &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt;, or even just compiling it optimized, and see...</source>
          <target state="translated">C ++では、任意のアドレスにアクセスできますが、そうする必要&lt;em&gt;はあり&lt;/em&gt;ません。 アクセスしているアドレスは無効になりました。 fooが戻った後、メモリをスクランブルするものは他にないため&lt;em&gt;機能し&lt;/em&gt;ますが、多くの状況でクラッシュする可能性があります。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrindを使用&lt;/a&gt;してプログラムを分析するか、最適化してコンパイルしてみてください...</target>
        </trans-unit>
        <trans-unit id="d0fe5db286c8dab66cb0d3b82b36a45e675f7834" translate="yes" xml:space="preserve">
          <source>In short: this won't usually work, but sometimes will by chance.</source>
          <target state="translated">要するに、これは通常はうまくいきませんが、偶然にもうまくいくことがあります。</target>
        </trans-unit>
        <trans-unit id="884f6b5a0e405708c0d3da980d10be30e33501e7" translate="yes" xml:space="preserve">
          <source>In this situation &lt;strong&gt;anything can happen&lt;/strong&gt;. The book can be there -- you got lucky. Someone else's book can be there and yours could be in the hotel's furnace. Someone could be there right when you come in, tearing your book to pieces. The hotel could have removed the table and book entirely and replaced it with a wardrobe. The entire hotel could be just about to be torn down and replaced with a football stadium, and you are going to die in an explosion while you are sneaking around.</source>
          <target state="translated">この状況では、 &lt;strong&gt;何かが起こる可能性があり&lt;/strong&gt;ます。 本はそこにあることができます-あなたは幸運になりました。 他の誰かの本がそこにあり、あなたの本がホテルのかまどにあるかもしれません。 あなたが本をばらばらに引き裂いて入ってくると、誰かがそこにいるのかもしれません。 ホテルはテーブルを削除して完全に予約し、ワードローブに交換することができます。 ホテル全体が取り壊され、サッカースタジアムに置き換えられようとしている可能性があります。こっそり潜んでいる間に爆発で死ぬことになります。</target>
        </trans-unit>
        <trans-unit id="2e771043fe216902e4ecf87e32bed904be6c6fe8" translate="yes" xml:space="preserve">
          <source>In typical compiler implementations, you can think of the code as &quot;print out the value of the memory block with adress that &lt;em&gt;used to be&lt;/em&gt; occupied by a&quot;. Also, if you add a new function invocation to a function that constains a local &lt;code&gt;int&lt;/code&gt; it's a good chance that the value of &lt;code&gt;a&lt;/code&gt; (or the memory address that &lt;code&gt;a&lt;/code&gt; used to point to) changes. This happens because the stack will be overwritten with a new frame containing different data.</source>
          <target state="translated">典型的なコンパイラの実装では、コードは「 &lt;em&gt;以前は&lt;/em&gt; a &lt;em&gt;で&lt;/em&gt;占められていたアドレスでメモリブロックの値を出力する」と考えることができます。 また、ローカルの &lt;code&gt;int&lt;/code&gt; を含む関数に新しい関数呼び出しを追加する場合、 &lt;code&gt;a&lt;/code&gt; の値（またはが使用してい &lt;code&gt;a&lt;/code&gt; メモリアドレス）が変更される可能性が高くなります。 これは、スタックが異なるデータを含む新しいフレームで上書きされるために発生します。</target>
        </trans-unit>
        <trans-unit id="e6431cf35a0648d9b667c3d460073ff4a639aace" translate="yes" xml:space="preserve">
          <source>Instead, implementations let you make mistakes and get away with it. Most of the time. Until one day something truly awful goes wrong and the process explodes.</source>
          <target state="translated">むしろ実装はミスをしても逃げられるようにしてくれます。ほとんどの場合は。ある日本当にひどいことが起きて プロセスが爆発するまではね</target>
        </trans-unit>
        <trans-unit id="cf808b24485af68ad3c78cf040a3df8bd129cff2" translate="yes" xml:space="preserve">
          <source>It can, because &lt;code&gt;a&lt;/code&gt; is a variable allocated temporarily for the lifetime of its scope (&lt;code&gt;foo&lt;/code&gt; function). After you return from &lt;code&gt;foo&lt;/code&gt; the memory is free and can be overwritten.</source>
          <target state="translated">これは、 &lt;code&gt;a&lt;/code&gt; がスコープ（ &lt;code&gt;foo&lt;/code&gt; 関数）の有効期間中に一時的に割り当てられる変数であるためです。 &lt;code&gt;foo&lt;/code&gt; から戻ると、メモリは解放され、上書きできます。</target>
        </trans-unit>
        <trans-unit id="a24c120f4ed8e1f85f91181732fc5d4f90b2dfce" translate="yes" xml:space="preserve">
          <source>It works because the stack has not been altered (yet) since a was put there. 
Call a few other functions (which are also calling other functions) before accessing &lt;code&gt;a&lt;/code&gt; again and you will probably not be so lucky anymore... ;-)</source>
          <target state="translated">スタックがそこに配置されてからスタックが（まだ）変更されていないため、機能します。 再度アクセス &lt;code&gt;a&lt;/code&gt; 前に、他のいくつかの関数（他の関数も呼び出す）を呼び出すと、おそらくそれほど幸運ではなくなります... ;-)</target>
        </trans-unit>
        <trans-unit id="6d865b18ac08c0c3d8f413777a079cf33cf8b7d8" translate="yes" xml:space="preserve">
          <source>It's 'Dirty' way of using memory addresses. When you return an address (pointer) you don't know whether it belongs to local scope of a function. It's just an address. Now that you invoked the 'foo' function, that address (memory location) of 'a' was already allocated there in the (safely, for now at least) addressable memory of your application (process). After the 'foo' function returned, the address of 'a' can be considered 'dirty' but it's there, not cleaned up, nor disturbed/modified by expressions in other part of program (in this specific case at least). A C/C++ compiler doesn't stop you from such 'dirty' access (might warn you though, if you care). You can safely use (update) any memory location that is in the data segment of your program instance (process) unless you protect the address by some means.</source>
          <target state="translated">これはメモリアドレスの「ダーティ」な使い方です。アドレス(ポインタ)を返すとき、それが関数のローカルスコープに属しているかどうかはわかりません。ただのアドレスです。今、'foo' 関数を呼び出したので、'a' のアドレス (メモリの場所)は、アプリケーション (プロセス)の (安全に、少なくとも今のところは)アドレス指定可能なメモリの中に既に確保されています。foo' 関数が戻ってきた後、'a' のアドレスは 'ダーティ' とみなされるかもしれませんが、プログラムの他の部分の式によって変更されたり、クリーンアップされたりすることはありません (少なくともこの特定のケースでは)。CC++コンパイラはこのような「ダーティな」アクセスを止めることはできません(気になる場合は警告するかもしれませんが)。プログラムのインスタンス(プロセス)のデータセグメント内にあるメモリ位置は、何らかの方法でアドレスを保護しない限り、安全に使用(更新)することができます。</target>
        </trans-unit>
        <trans-unit id="668ed96ef41788718678a8ce40aa14755a7a92c8" translate="yes" xml:space="preserve">
          <source>It's like the hotel decides to only rent out rooms sequentially, and you can't check out until everyone with a room number higher than you has checked out.</source>
          <target state="translated">ホテルが部屋だけを順次貸し出すと決めているようなもので、自分より部屋番号の高い人が全員チェックアウトしてからでないとチェックアウトできません。</target>
        </trans-unit>
        <trans-unit id="f3e2804ed3bd64f789e8ab14d3b38ca8f2c1f567" translate="yes" xml:space="preserve">
          <source>Local variables follow the latter pattern; when a method is entered, its local variables come alive. When that method calls another method, the new method's local variables come alive. They'll be dead before the first method's local variables are dead.  The relative order of the beginnings and endings of lifetimes of storages associated with local variables can be worked out ahead of time.</source>
          <target state="translated">ローカル変数は後者のパターンに従います。そのメソッドが別のメソッドを呼び出すと、新しいメソッドのローカル変数が生きてきます。最初のメソッドのローカル変数が死ぬ前に死んでしまいます。ローカル変数に関連付けられたストレージの寿命の開始と終了の相対的な順序は、事前に調べることができます。</target>
        </trans-unit>
        <trans-unit id="92b523458f46cae25f6e91180adcbb80c63ad661" translate="yes" xml:space="preserve">
          <source>More memory-safe languages solve this problem by restricting your power. In &quot;normal&quot; C# there simply is no way to take the address of a local and return it or store it for later. You can take the address of a local, but the language is cleverly designed so that it is impossible to use it after the lifetime of the local ends. In order to take the address of a local and pass it back, you have to put the compiler in a special &quot;unsafe&quot; mode, &lt;em&gt;and&lt;/em&gt; put the word &quot;unsafe&quot; in your program, to call attention to the fact that you are probably doing something dangerous that could be breaking the rules.</source>
          <target state="translated">より多くのメモリセーフ言語はあなたの力を制限することによってこの問題を解決します。 「通常の」C＃では、ローカルのアドレスを取得して返すか、後で使用するために保存する方法はありません。 ローカルのアドレスを取得できますが、言語は巧妙に設計されているため、ローカルの存続期間が終了すると使用できなくなります。 ローカルのアドレスを取得してそれを返すには、コンパイラを特別な「安全でない」モードにし、プログラムに「安全でない」という単語&lt;em&gt;を&lt;/em&gt;入れて、おそらく実行しているという事実に注意を向ける必要があります。ルールを破る危険な何か。</target>
        </trans-unit>
        <trans-unit id="f7776b8ae70f653468c196298aea76866e611224" translate="yes" xml:space="preserve">
          <source>Nobody will automatically check the semantic validity of memory addresses like that for you during normal program execution. However, a memory debugger such as &lt;code&gt;valgrind&lt;/code&gt; will happily do this, so you should run your program through it and witness the errors.</source>
          <target state="translated">通常のプログラム実行中に、そのようなメモリアドレスのセマンティックな妥当性を自動的にチェックする人は誰もいません。 ただし、 &lt;code&gt;valgrind&lt;/code&gt; などのメモリデバッガはこれをうまく行うので、プログラムを実行してエラーを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="9cc0ce9cccdfa9247eba033a1e1a044665d8c5e6" translate="yes" xml:space="preserve">
          <source>Now if you're wondering why the compiler doesn't complain, it's probably because &lt;code&gt;foo&lt;/code&gt; got eliminated by optimization. It usually will warn you about this sort of thing. C assumes you know what you're doing though, and technically you haven't violated scope here (there's no reference to &lt;code&gt;a&lt;/code&gt; itself outside of &lt;code&gt;foo&lt;/code&gt;), only memory access rules, which only triggers a warning rather than an error.</source>
          <target state="translated">コンパイラが文句を言わないのはなぜかと思っているのなら、それはおそらく &lt;code&gt;foo&lt;/code&gt; が最適化によって削除されたためです。 通常、このようなことについて警告します。 Cは、あなたが何をしているのかを知っていて、技術的にはここのスコープに違反していない（ &lt;code&gt;foo&lt;/code&gt; の外に &lt;code&gt;a&lt;/code&gt; それ自体への参照はない）ことを前提としており、メモリアクセスルールのみで、エラーではなく警告のみをトリガーします。</target>
        </trans-unit>
        <trans-unit id="64dfdee1fb88a04e52e453e6fea524374d6fce64" translate="yes" xml:space="preserve">
          <source>Pay attention to  all warnings . Do not only solve errors.</source>
          <target state="translated">すべての警告に注意してください。エラーだけを解決しないでください。</target>
        </trans-unit>
        <trans-unit id="dbd3aa8cb4b802de57285634bed996e92ef2c0e4" translate="yes" xml:space="preserve">
          <source>Returning the address of a temporary works, but as temporaries are destroyed at the end of a function the results of accessing them will be undefined.</source>
          <target state="translated">一時的な作品のアドレスを返しますが、一時的な作品は関数の終了時に破棄されるので、アクセスした結果は未定義になります。</target>
        </trans-unit>
        <trans-unit id="7a96582b612f775240973f5214e850faef3962ce" translate="yes" xml:space="preserve">
          <source>So let's think about the stack. In many operating systems you get one stack per thread and the stack is allocated to be a certain fixed size. When you call a method, stuff is pushed onto the stack. If you then pass a pointer to the stack back out of your method, as the original poster does here, that's just a pointer to the middle of some entirely valid million-byte memory block. In our analogy, you check out of the hotel; when you do, you just checked out of the highest-numbered occupied room.  If no one else checks in after you, and you go back to your room illegally, all your stuff is guaranteed to still be there &lt;em&gt;in this particular hotel&lt;/em&gt;.</source>
          <target state="translated">スタックについて考えてみましょう。 多くのオペレーティングシステムでは、スレッドごとに1つのスタックを取得し、スタックは特定の固定サイズになるように割り当てられます。 メソッドを呼び出すと、スタックにスタックされます。 次に、元の投稿者がここで行うように、スタックへのポインターをメソッドから戻す場合、それは完全に有効な100万バイトのメモリブロックの中央へのポインターにすぎません。 私たちの類推では、ホテルをチェックアウトします。 すると、あなたはちょうど最も大きい番号の占有された部屋からチェックアウトしました。 他の誰もあなたの後にチェックインせず、あなたが違法にあなたの部屋に戻った場合、あなたのすべてのものは&lt;em&gt;この特定のホテル&lt;/em&gt;にまだそこ&lt;em&gt;にある&lt;/em&gt;ことが保証されてい&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="48e728fecb72b1215b61d3c3ac811f6b5f708706" translate="yes" xml:space="preserve">
          <source>So you did not modify &lt;code&gt;a&lt;/code&gt; but rather the memory location where &lt;code&gt;a&lt;/code&gt; once was. This difference is very similar to the difference between crashing and not crashing.</source>
          <target state="translated">つまり &lt;code&gt;a&lt;/code&gt; 一度変更 &lt;code&gt;a&lt;/code&gt; たメモリの場所を変更するのではなく、変更しました。 この違いは、クラッシュする場合としない場合の違いによく似ています。</target>
        </trans-unit>
        <trans-unit id="415f6940290f7adad86030b3b1e1a91474c25e52" translate="yes" xml:space="preserve">
          <source>So, here function &lt;code&gt;foo()&lt;/code&gt; is returning the address of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is destroyed after returning its address. And you can access the modified value through that returned address.</source>
          <target state="translated">したがって、ここでは関数 &lt;code&gt;foo()&lt;/code&gt; が &lt;code&gt;a&lt;/code&gt; のアドレスを返し、 &lt;code&gt;a&lt;/code&gt; はそのアドレスを返した後に破棄されます。 そして、その返されたアドレスを通じて変更された値にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="4ca65421239872c85bc7cb4eab3534ea2b033ade" translate="yes" xml:space="preserve">
          <source>Suppose a man hides money at a location and tells you the location. After some time, the man who had told you the money location dies. But still you have the access of that hidden money.</source>
          <target state="translated">ある場所にお金を隠した男が、その場所を教えてくれたとします。しばらくして、お金の場所を教えてくれた男は死んでしまいます。しかし、それでもあなたはその隠したお金のアクセス権を持っています。</target>
        </trans-unit>
        <trans-unit id="6637ee0ae3a2356e88607e4783fe52245560ba0b" translate="yes" xml:space="preserve">
          <source>That is because after returning from foo() the stack is freed and then reused by boo().
If you deassemble the executable you will see it clearly.</source>
          <target state="translated">これは、foo()から戻った後にスタックが解放され、その後 boo()で再利用されるからです。実行ファイルをデアセンブルしてみるとよくわかると思います。</target>
        </trans-unit>
        <trans-unit id="10653b9d4a1d031b54f7ad1b1a5976b3c3fe1950" translate="yes" xml:space="preserve">
          <source>That means the memory address could be valid or not, and your code will be vulnerable to possible memory address issues (for example segmentation fault).</source>
          <target state="translated">これは、メモリアドレスが有効かどうかを意味し、あなたのコードはメモリアドレスの問題(例えばセグメンテーションフォルト)に対して脆弱になる可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="55e66b98d49314348a56ec9d7b30dce4d53f468e" translate="yes" xml:space="preserve">
          <source>That's classic &lt;strong&gt;undefined behaviour&lt;/strong&gt; that's been discussed here not two days ago -- search around the site for a bit. In a nutshell, you were lucky, but anything could have happened and your code is making invalid access to memory.</source>
          <target state="translated">これは、2日前ではなく、ここで説明されている古典的な&lt;strong&gt;未定義の動作&lt;/strong&gt;です。サイトを少し検索してみてください。 簡単に言えば、あなたは幸運でしたが、何かが起こった可能性があり、コードがメモリへの無効なアクセスを行っています。</target>
        </trans-unit>
        <trans-unit id="d01e8b0fd46bdbf027d2c78b2cf77e0ad3eadb05" translate="yes" xml:space="preserve">
          <source>The first is to have some sort of &quot;long lived&quot; storage area where the &quot;lifetime&quot; of each byte in the storage -- that is, the period of time when it is validly associated with some program variable -- cannot be easily predicted ahead of time. The compiler generates calls into a &quot;heap manager&quot; that knows how to dynamically allocate storage when it is needed and reclaim it when it is no longer needed.</source>
          <target state="translated">第一に、ストレージ内の各バイトの「寿命」、つまりプログラム変数に有効に関連付けられている期間を事前に容易に予測できないような、ある種の「長寿命」ストレージ領域を持つことです。コンパイラは、必要なときには動的にストレージを割り当て、不要になったときにはそれを再利用する方法を知っている「ヒープマネージャ」への呼び出しを生成します。</target>
        </trans-unit>
        <trans-unit id="2a517045d055d1343ace682896452e5177bc4524" translate="yes" xml:space="preserve">
          <source>The hotel management is not &lt;em&gt;required&lt;/em&gt; to remove your book. You didn't make a contract with them that said that if you leave stuff behind, they'll shred it for you. If you illegally re-enter your room with a stolen key to get it back, the hotel security staff is not &lt;em&gt;required&lt;/em&gt; to catch you sneaking in. You didn't make a contract with them that said &quot;if I try to sneak back into my room later, you are required to stop me.&quot; Rather, you signed a contract with them that said &quot;I promise not to sneak back into my room later&quot;, a contract which &lt;em&gt;you broke&lt;/em&gt;.</source>
          <target state="translated">ホテルの管理者があなたの本を削除する&lt;em&gt;必要&lt;/em&gt;はありません。 あなたは彼らと契約を結んでおらず、あなたが物を残した場合、彼らはあなたのためにそれを細断します。 盗まれたキーを使って違法に部屋に戻ってそれを取り戻す場合、ホテルのセキュリティスタッフはあなたをこっそりと捕まえる&lt;em&gt;必要&lt;/em&gt;はありません。部屋は後で、あなたは私を止める必要があります。」 むしろ、あなたは彼らと契約し、「私は後で私の部屋にこっそり侵入しないことを約束します」という契約に署名しました。</target>
        </trans-unit>
        <trans-unit id="0393a71499e25d744a2e0cd1648098b160eca6d2" translate="yes" xml:space="preserve">
          <source>The output was &lt;code&gt;58&lt;/code&gt;</source>
          <target state="translated">出力は &lt;code&gt;58&lt;/code&gt; でした</target>
        </trans-unit>
        <trans-unit id="5c253d37c3711b668d6b9d942320ae2687acd295" translate="yes" xml:space="preserve">
          <source>The problem you are having is why the program doesn't signal an error when referencing illegal memory. This is because C++ standards does not specify a very clear boundary between illegal memory and legal memory. Referencing something in popped out stack sometimes causes error and sometimes not. It depends. Don't count on this behavior. Assume it will always result in error when you program, but assume it will never signal error when you debug.</source>
          <target state="translated">あなたが抱えている問題は、なぜプログラムが不正なメモリを参照しているときにエラーを通知しないのかということです。これは、C++の標準では、不正なメモリと合法なメモリの間の境界を明確に指定していないからです。ポップアウトされたスタックで何かを参照するとエラーになることもあれば、そうでないこともあります。それは依存しています。この動作をあてにしてはいけません。プログラムを書いているときには必ずエラーになりますが、デバッグをしているときにはエラーになることはないと思ってください。</target>
        </trans-unit>
        <trans-unit id="890aeeea49faa2fa28d38ffb4d73ad962a14ab97" translate="yes" xml:space="preserve">
          <source>The second method is to have a &amp;ldquo;short-lived&amp;rdquo; storage area where the lifetime of each byte is well known. Here, the lifetimes follow a &amp;ldquo;nesting&amp;rdquo; pattern. The longest-lived of these short-lived variables will be allocated before any other short-lived variables, and will be freed last. Shorter-lived variables will be allocated after the longest-lived ones, and will be freed before them. The lifetime of these shorter-lived variables is &amp;ldquo;nested&amp;rdquo; within the lifetime of longer-lived ones.</source>
          <target state="translated">2番目の方法は、各バイトの存続期間がよく知られている「短命な」ストレージ領域を用意することです。 ここでは、寿命は「ネスト」パターンに従います。 これらの短命変数の中で最も長命の変数は、他の短命変数の前に割り当てられ、最後に解放されます。 寿命の短い変数は、寿命の最も長い変数の後に割り当てられ、それらの前に解放されます。 これらの寿命の短い変数の寿命は、寿命の長い変数の寿命内に「ネスト」されます。</target>
        </trans-unit>
        <trans-unit id="35e6bd2b69222deaf1995ea9da0a68f6703d7ccb" translate="yes" xml:space="preserve">
          <source>The things with correct (?) console output can change dramatically if you use ::printf but not cout. 
You can play around with debugger within below code (tested on x86, 32-bit, MSVisual Studio):</source>
          <target state="translated">正しい(?)コンソール出力を持つものは、:printf を使うのと使わないのとでは大きく変わってきます。以下のコードの中でデバッガを使って遊ぶことができます(x86,32ビット,MSVisual Studioでテスト済み)。</target>
        </trans-unit>
        <trans-unit id="f0ba7d3098b2635fa4805520c0d620eed935a473" translate="yes" xml:space="preserve">
          <source>The way you set it up it is a bit more reasonable that the returned address points into a valid area of memory, as it will probably just be a little further down the stack, but it is still an invalid location that you cannot access in a deterministic fashion.</source>
          <target state="translated">あなたが設定した方法では、返されたアドレスが有効なメモリ領域を指すというのは、おそらくスタックの少し下の方にあるので、もう少し合理的ですが、決定論的な方法ではアクセスできない無効な場所であることに変わりはありません。</target>
        </trans-unit>
        <trans-unit id="c64bb54b249751cf9009a2a39ddde0cbec79cbdf" translate="yes" xml:space="preserve">
          <source>This behavior is undefined, as Alex pointed out--in fact, most compilers will warn against doing this, because it's an easy way to get crashes.</source>
          <target state="translated">アレックスが指摘したように、この動作は未定義です。実際、ほとんどのコンパイラはこのような動作をしないように警告します。</target>
        </trans-unit>
        <trans-unit id="df8ae21359a7a9c1782b2fa5d716171e207fefde" translate="yes" xml:space="preserve">
          <source>This is  power of C++. You should care about memory. With the &lt;code&gt;-Werror&lt;/code&gt; flag, this warning becames an error and now you have to debug it.</source>
          <target state="translated">これがC ++の力です​​。 あなたはメモリを気にする必要があります。 &lt;code&gt;-Werror&lt;/code&gt; フラグを使用すると、この警告はエラーになり、デバッグする必要があります。</target>
        </trans-unit>
        <trans-unit id="5b0d1e6d4ef066a26535944c60c6026681ae3fe8" translate="yes" xml:space="preserve">
          <source>This is problematic. There are a lot of rules and it is very easy to break them accidentally. I certainly have many times. And worse, the problem often only surfaces when memory is detected to be corrupt billions of nanoseconds after the corruption happened, when it is very hard to figure out who messed it up.</source>
          <target state="translated">これは問題があります。ルールがたくさんあって、うっかり破ってしまうことはとても簡単です。私は確かに何度も破りました。さらに悪いことに、この問題が表面化するのは、メモリが破損していることが検出された数十億ナノ秒後で、誰がそれを台無しにしたのかを理解するのが非常に困難なときだけです。</target>
        </trans-unit>
        <trans-unit id="0eaf8b53ad7d5c524b38b6a971be8dfad3b95b37" translate="yes" xml:space="preserve">
          <source>This means that you are doing a very bad thing, becouse you are passing a memory address to a pointer wich is not trustable at all.</source>
          <target state="translated">これはあなたが非常に悪いことをしているということを意味します。</target>
        </trans-unit>
        <trans-unit id="6f697153226ae9e147e41d50dcd86d77b9a8ca6f" translate="yes" xml:space="preserve">
          <source>This prints out &quot;y=123&quot;, but your results may vary (really!). Your pointer is clobbering other, unrelated local variables.</source>
          <target state="translated">これは &quot;y=123&quot; と出力しますが、結果は異なるかもしれません(本当に!)。あなたのポインタは、他の無関係なローカル変数にぶつかっています。</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="398226ff0451b7e1c1c5e5a7a2cbe718625ea490" translate="yes" xml:space="preserve">
          <source>Unlike your example, with this example you are:</source>
          <target state="translated">あなたの例とは違い、この例ではあなたがそうです。</target>
        </trans-unit>
        <trans-unit id="bf83ed6f06abc30e3c1ba88ba6233762dd35af5d" translate="yes" xml:space="preserve">
          <source>We use stacks for temporary stores because they are really cheap and easy. An implementation of C++ is not required to use a stack for storage of locals; it could use the heap. It doesn't, because that would make the program slower.</source>
          <target state="translated">スタックを一時的なストアに使用しているのは、本当に安くて簡単だからです。C++の実装では、ローカルの格納にスタックを使用する必要はありません。ヒープを使うことはできますが、使わないようにしています。</target>
        </trans-unit>
        <trans-unit id="e53fd215b0c495c0d89e0f96c8abbf2fb92be241" translate="yes" xml:space="preserve">
          <source>Well, obviously that scenario can happen in the real world no problem. There is no mysterious force that causes your book to disappear when you are no longer authorized to be in the room. Nor is there a mysterious force that prevents you from entering a room with a stolen key.</source>
          <target state="translated">まあ、明らかにそのシナリオは現実世界でも問題なく起こり得る。あなたが部屋に入ることを許されなくなったときに、あなたの本が消えてしまうような不思議な力はありません。盗まれた鍵で部屋に入れないようにする不思議な力もありません。</target>
        </trans-unit>
        <trans-unit id="a5d081b4250b3c6bf254dbe76846254422327e9b" translate="yes" xml:space="preserve">
          <source>What if C# did allow returning references? Coincidentally that is the subject of today's blog post:</source>
          <target state="translated">C#で参照を返すことができるとしたらどうでしょうか?偶然にもそれが今日のブログ記事の主題です。</target>
        </trans-unit>
        <trans-unit id="4ba89d6203509c5bf6440005ba0577078a5e174f" translate="yes" xml:space="preserve">
          <source>What you're doing here is simply reading and writing to memory that</source>
          <target state="translated">あなたがここでやっていることは、単に読み書きして記憶に残しているだけです。</target>
        </trans-unit>
        <trans-unit id="b0b04b262ca077c743d5bedec5d61192576329c1" translate="yes" xml:space="preserve">
          <source>What you're doing is described as &lt;em&gt;undefined behavior&lt;/em&gt;. The result cannot be predicted.</source>
          <target state="translated">あなたがやっていることは、 &lt;em&gt;未定義の動作&lt;/em&gt;として説明されて&lt;em&gt;います&lt;/em&gt; 。 結果は予測できません。</target>
        </trans-unit>
        <trans-unit id="a5b6bae245aa7990e2bf8f6d62a4b4fd1d7c04a8" translate="yes" xml:space="preserve">
          <source>When you return from &lt;code&gt;foo&lt;/code&gt;, you tell the OS that you're no longer using that memory and it can be reassigned to something else. If you're lucky and it never does get reassigned, and the OS doesn't catch you using it again, then you'll get away with the lie. Chances are though you'll end up writing over whatever else ends up with that address.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; から戻ると、そのメモリをもう使用しておらず、別のメモリに再割り当てできることをOSに伝えます。 運が良ければ、再割り当てされることはなく、OSがそれを再び使用することに気付かない場合は、うそをついてしまいます。 たぶん、あなたはそのアドレスで終わる他のものを上書きしてしまうでしょう。</target>
        </trans-unit>
        <trans-unit id="fa1180633feda4933e750090ee9485e74f2fa520" translate="yes" xml:space="preserve">
          <source>Why do we use stacks to manage memory? Are value types in C# always stored on the stack? How does virtual memory work? And many more topics in how the C# memory manager works. Many of these articles are also germane to C++ programmers:</source>
          <target state="translated">なぜスタックを使ってメモリを管理するのか?C#の値の型は常にスタックに格納されているのか?仮想メモリはどのように動作するのか? その他にも、C#のメモリマネージャがどのように動作するかについてのトピックがたくさんあります。これらの記事の多くは、C++プログラマにとっても有益なものです。</target>
        </trans-unit>
        <trans-unit id="367a511c0bd23747bed54a801c60343a2911cb1f" translate="yes" xml:space="preserve">
          <source>Yes if you try to dereference that memory address you will have undefined behavior.</source>
          <target state="translated">はい、そのメモリアドレスを参照解除しようとすると、未定義の動作になります。</target>
        </trans-unit>
        <trans-unit id="f7b6efeb9999e8415e2256127bd801c374f407de" translate="yes" xml:space="preserve">
          <source>You actually invoked undefined behaviour.</source>
          <target state="translated">あなたは実際に未定義の振る舞いを発動しました。</target>
        </trans-unit>
        <trans-unit id="0ab951d4546ea151e47a2697193d8f628bd98a9e" translate="yes" xml:space="preserve">
          <source>You are just returning a memory address, it's allowed but probably an error.</source>
          <target state="translated">メモリアドレスを返しているだけで、許可されていますが、おそらくエラーです。</target>
        </trans-unit>
        <trans-unit id="632ab4b8b530f13855f715927a28aa2f5a4eb21e" translate="yes" xml:space="preserve">
          <source>You don't know what is going to happen; when you checked out of the hotel and stole a key to illegally use later, you gave up the right to live in a predictable, safe world because &lt;em&gt;you&lt;/em&gt; chose to break the rules of the system.</source>
          <target state="translated">何が起こるかわかりません。 ホテルをチェックアウトし、後で違法に使用するための鍵を盗んだとき、システムの規則を破ること&lt;em&gt;を&lt;/em&gt;選択したため、予測可能な安全な世界に住む権利を放棄しました。</target>
        </trans-unit>
        <trans-unit id="b6a838ff678f89b070003058718a712103126d6e" translate="yes" xml:space="preserve">
          <source>You never throw a C++ exception by accessing invalid memory. You are just giving an example of the general idea of referencing an arbitrary memory location. I could do the same like this:</source>
          <target state="translated">無効なメモリにアクセスしてC++の例外が発生することはありません。あなたは、任意のメモリ位置を参照するという一般的な考え方の例を示しているに過ぎません。こんな感じで同じようなことができます。</target>
        </trans-unit>
        <trans-unit id="851a700a375ff806c1dcbb41aa3d34c727d4e133" translate="yes" xml:space="preserve">
          <source>You rent a hotel room. You put a book in the top drawer of the bedside table and go to sleep.  You check out the next morning, but &quot;forget&quot; to give back your key. You steal the key!</source>
          <target state="translated">ホテルの部屋を借りる。ベッドサイドテーブルの一番上の引き出しに本を入れて寝る。翌朝チェックアウトしたが、鍵を返すのを「忘れた」。鍵を盗んでしまいました。</target>
        </trans-unit>
        <trans-unit id="b6cedbdba81d1f1c5892a7412b1dd7929c578e4d" translate="yes" xml:space="preserve">
          <source>You win the lottery.</source>
          <target state="translated">宝くじが当たる。</target>
        </trans-unit>
        <trans-unit id="a8d5a5789511f170672864f52617e354f9acfe8c" translate="yes" xml:space="preserve">
          <source>Your code is very risky. You are creating a local variable (wich is considered destroyed after function ends) and you return the address of memory of that variable after it is destoyed.</source>
          <target state="translated">あなたのコードは非常に危険です。あなたはローカル変数(関数終了後に破棄されると考えられる)を作成し、破棄された後にその変数のメモリのアドレスを返しています。</target>
        </trans-unit>
        <trans-unit id="27c02908661ef2d4af116e6eda229fd38a50ef3f" translate="yes" xml:space="preserve">
          <source>Your problem has nothing to do with &lt;em&gt;scope&lt;/em&gt;. In the code you show, the function &lt;code&gt;main&lt;/code&gt; does not see the names in the function &lt;code&gt;foo&lt;/code&gt;, so you can't access &lt;code&gt;a&lt;/code&gt; in foo directly with &lt;em&gt;this&lt;/em&gt; name outside &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">あなたの問題は&lt;em&gt;スコープ&lt;/em&gt;とは何の関係もありません。 表示するコードでは、関数 &lt;code&gt;main&lt;/code&gt; は関数 &lt;code&gt;foo&lt;/code&gt; の名前を認識しないため、fooの外で&lt;em&gt;この&lt;/em&gt;名前を使用し &lt;code&gt;a&lt;/code&gt; in fooに直接アクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="4467dc3c2dfc773030d9d4d4ec6b6374a6ce09aa" translate="yes" xml:space="preserve">
          <source>allocating memory for int into a local function</source>
          <target state="translated">ローカル関数への int メモリの割り当て</target>
        </trans-unit>
        <trans-unit id="25568658dcfbd886141b75f7a37ca9a44f6d7bfe" translate="yes" xml:space="preserve">
          <source>be the address of &lt;code&gt;a&lt;/code&gt;. Now that you're outside of &lt;code&gt;foo&lt;/code&gt;, it's just a pointer to some random memory area. It just so happens that in your example, that memory area does exist and nothing else is using it at the moment. You don't break anything by continuing to use it, and nothing else has overwritten it yet. Therefore, the &lt;code&gt;5&lt;/code&gt; is still there. In a real program, that memory would be re-used almost immediately and you'd break something by doing this (though the symptoms may not appear until much later!)</source>
          <target state="translated">のアドレスで &lt;code&gt;a&lt;/code&gt; 。 これで &lt;code&gt;foo&lt;/code&gt; の外に出たので、これはランダムなメモリ領域へのポインタにすぎません。 たまたまあなたの例では、そのメモリ領域が存在し、現時点では他に何も使用していません。 あなたはそれを使い続けることで何かを壊すことはありません、そして他にはまだそれを上書きしていません。 したがって、 &lt;code&gt;5&lt;/code&gt; はまだそこにあります。 実際のプログラムでは、そのメモリはほとんどすぐに再利用され、これを実行すると何かが壊れます（ただし、症状はかなり後になるまで現れないかもしれません！）</target>
        </trans-unit>
        <trans-unit id="5b1b059e808759b8d1c5874ad49671b3b3d4813a" translate="yes" xml:space="preserve">
          <source>if you do something like that:</source>
          <target state="translated">みたいなことをしたら</target>
        </trans-unit>
        <trans-unit id="3853ee4965d2fd6e74929bd4ae29cc0ed44947f9" translate="yes" xml:space="preserve">
          <source>that memory address is still valid also when function expires, (it is not deleted by anyone)</source>
          <target state="translated">関数が終了してもメモリアドレスは有効であることを示しています。</target>
        </trans-unit>
        <trans-unit id="197d6cb5a85574406eca31e0a72c1a7b788a0490" translate="yes" xml:space="preserve">
          <source>the memory address is trustable (that memory block is not considered free, so it will be not overridden until it is deleted)</source>
          <target state="translated">メモリアドレスが信頼できる (そのメモリブロックは空きメモリとはみなされないので、削除されるまでオーバーライドされません)</target>
        </trans-unit>
        <trans-unit id="e0d69ca46fd46558106bbf5d93de1a37ad007fdb" translate="yes" xml:space="preserve">
          <source>the memory address should be deleted when not used. (see the delete at the end of the program)</source>
          <target state="translated">を使用しない場合は、メモリアドレスを削除する必要があります。(プログラムの最後にある削除を参照)</target>
        </trans-unit>
        <trans-unit id="abe86398849a8e40d77bea83096ad74f206ef947" translate="yes" xml:space="preserve">
          <source>the output probably will be: 7</source>
          <target state="translated">の出力はおそらくそうなるでしょう。7</target>
        </trans-unit>
        <trans-unit id="34790dc2e682800571cab44d1835a970e54f21a8" translate="yes" xml:space="preserve">
          <source>used to</source>
          <target state="translated">馴れ馴れしい</target>
        </trans-unit>
        <trans-unit id="46dbdaa85bacc9d8c59df32ce3fb81070bc6523b" translate="yes" xml:space="preserve">
          <source>warning: address of local variable 'a' returned</source>
          <target state="translated">警告:ローカル変数 'a' のアドレスが返されました。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
