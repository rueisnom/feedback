<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/6441218">
    <body>
      <group id="6441218">
        <trans-unit id="f5f16923f0af049a9268d2bca9a807fbee68cdfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; might in fact genuinely be a valid address of a double, e.g. &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 实际上可能确实是双精度数（例如， &lt;code&gt;double p; q = &amp;amp;p;&lt;/code&gt; 的有效地址； q =＆p; 。</target>
        </trans-unit>
        <trans-unit id="2323769261698fad3bf45ce9c6dead419d7ed3ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; might point somewhere inside allocated memory and I just overwrite 8 bytes in there.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 可能指向分配的内存中的某个地方，而我只是覆盖了其中的8个字节。</target>
        </trans-unit>
        <trans-unit id="89dc785e6f5a1676a10c0b1098798eb7eb2480dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; points outside allocated memory and the operating system's memory manager sends a segmentation fault signal to my program, causing the runtime to terminate it.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 指向分配的内存之外，操作系统的内存管理器将分段错误信号发送到我的程序，从而导致运行时终止该程序。</target>
        </trans-unit>
        <trans-unit id="199f80d5e26390e5ebf9e949c594dd75500aa2da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Let me take a real world example:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;让我以现实世界为例：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="092cbceb9ffa47ba2a3d0a48ececdefff70b083a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ is not a safe language&lt;/strong&gt;. It will cheerfully allow you to break the rules of the system. If you try to do something illegal and foolish like going back into a room you're not authorized to be in and rummaging through a desk that might not even be there anymore, C++ is not going to stop you. Safer languages than C++ solve this problem by restricting your power -- by having much stricter control over keys, for example.</source>
          <target state="translated">&lt;strong&gt;C ++不是安全的语言&lt;/strong&gt; 。 它会很乐意让您打破系统规则。 如果您尝试做一些非法而愚蠢的事情，例如回到没有权限的房间，或者翻阅一张桌子甚至翻腾的桌子，那C ++不会阻止您。 比C ++更安全的语言通过限制您的力量来解决此问题-例如，通过对键进行更严格的控制。</target>
        </trans-unit>
        <trans-unit id="6c1c49fcc0bc7f787bb6de1ef0e235efab3bfc3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How can that be? Aren't the contents of a hotel room drawer inaccessible if you haven't rented the room?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这个怎么可能？&lt;/strong&gt; &lt;strong&gt;如果您没有租房，不是不是无法进入酒店房间抽屉的内容吗？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c802d8f0f438f6d01b82bd537e9909b51c503a35" translate="yes" xml:space="preserve">
          <source>A little addition to all the answers:</source>
          <target state="translated">补了一下所有的答案。</target>
        </trans-unit>
        <trans-unit id="ee1cefbbc3f6ae87dd7e67ea9cfb80dac82e13c9" translate="yes" xml:space="preserve">
          <source>A week later, you return to the hotel, do not check in, sneak into your old room with your stolen key, and look in the drawer. Your book is still there. Astonishing!</source>
          <target state="translated">一个星期后,你回到酒店,没有办理入住手续,拿着偷来的钥匙溜进原来的房间,在抽屉里翻找。你的书还在那里。惊呆了!</target>
        </trans-unit>
        <trans-unit id="9125bf2280239c3b164efc1df4e296b36f1c41f1" translate="yes" xml:space="preserve">
          <source>After returning from a function, all identifiers are destroyed instead of kept values in a memory location and we can not locate the values without having an identifier.But that location still contains the value stored by previous function.</source>
          <target state="translated">从一个函数返回后,所有的标识符都会被销毁,而不是保存在内存位置上的值,没有标识符我们就无法定位,但该位置仍然包含了之前函数存储的值。</target>
        </trans-unit>
        <trans-unit id="551408e0c19118edd84d52d381542cdcbdda834c" translate="yes" xml:space="preserve">
          <source>An implementation of C++ is not required to ensure that when the stack logically shrinks, the addresses that used to be valid are still mapped into memory. The implementation is allowed to tell the operating system &quot;we're done using this page of stack now. Until I say otherwise, issue an exception that destroys the process if anyone touches the previously-valid stack page&quot;.  Again, implementations do not actually do that because it is slow and unnecessary.</source>
          <target state="translated">C++的实现不需要确保当堆栈逻辑上收缩时,过去有效的地址仍然映射到内存中。实现可以告诉操作系统 &quot;我们现在已经用完这一页堆栈了&quot;。除非我说不这样做,否则就发出一个异常,如果有人触及以前有效的堆栈页,就破坏这个进程&quot;。还是那句话,实现实际上并没有这样做,因为这样做很慢,也没有必要。</target>
        </trans-unit>
        <trans-unit id="9e4a51f2c5d3df5cc305fe5241ee9f91c1862f4a" translate="yes" xml:space="preserve">
          <source>An implementation of C++ is not required to leave the garbage you left on the stack untouched so that you can come back for it later illegally; it is perfectly legal for the compiler to generate code that turns back to zero everything in the &quot;room&quot; that you just vacated. It doesn't because again, that would be expensive.</source>
          <target state="translated">一个C++的实现并不要求你把你留在堆栈上的垃圾不留,以便你以后可以非法地回来取回它;编译器生成的代码,把你刚刚腾出的 &quot;房间 &quot;里的一切都归零,是完全合法的。但它不会,因为那又会很贵。</target>
        </trans-unit>
        <trans-unit id="107c7e3b89899d409b00af753e9116c3756b3bed" translate="yes" xml:space="preserve">
          <source>And the code is just running with no runtime exceptions!</source>
          <target state="translated">而代码只是在运行时没有运行异常!</target>
        </trans-unit>
        <trans-unit id="2eef47beb4615f77d95310d433dca2a905f6afd0" translate="yes" xml:space="preserve">
          <source>Because the storage space wasn't stomped on just yet. Don't count on that behavior.</source>
          <target state="translated">因为刚才还没踩到储物空间。不要指望这种行为。</target>
        </trans-unit>
        <trans-unit id="4c294f2376bf1ce93f3fa4b96d3051ce6d617ff9" translate="yes" xml:space="preserve">
          <source>But I agree with Mark B that the resulting behavior is undefined.</source>
          <target state="translated">但我同意Mark B的观点,即由此产生的行为是无法定义的。</target>
        </trans-unit>
        <trans-unit id="b1cc5de4f5cc262455af25eee537c1fbe8ede183" translate="yes" xml:space="preserve">
          <source>Can a local variable's memory be accessed outside its scope</source>
          <target state="translated">本地变量的内存可以在其范围外访问吗?</target>
        </trans-unit>
        <trans-unit id="b2a932b65ee498810514c1bea0d35efc855a4f81" translate="yes" xml:space="preserve">
          <source>Compilers are in the business of generating code which manages the storage of the data manipulated by that program. There are lots of different ways of generating code to manage memory, but over time two basic techniques have become entrenched.</source>
          <target state="translated">编译器的工作是生成代码,而生成的代码就是管理该程序所操纵的数据的存储。生成代码管理内存的方法有很多,但随着时间的推移,有两种基本技术已经根深蒂固。</target>
        </trans-unit>
        <trans-unit id="c817be5dd088db601f9b4bede3267671d06ac959" translate="yes" xml:space="preserve">
          <source>Consider this example, instead, and test it:</source>
          <target state="translated">反之,考虑这个例子,再来测试一下。</target>
        </trans-unit>
        <trans-unit id="c0f296eb7c38fa507531b7353e52a86837866c31" translate="yes" xml:space="preserve">
          <source>Did you compile your program with the optimiser enabled? The &lt;code&gt;foo()&lt;/code&gt; function is quite simple and might have been inlined or replaced in the resulting code.</source>
          <target state="translated">您是否在启用优化程序的情况下编译了程序？ &lt;code&gt;foo()&lt;/code&gt; 函数非常简单，可能已内联或替换为结果代码。</target>
        </trans-unit>
        <trans-unit id="b807ff8ce557df22c0a2b48e1eb3c952a35d8a67" translate="yes" xml:space="preserve">
          <source>For an example of the kind of spooky behavior you are &lt;em&gt;likely&lt;/em&gt; to get, try this sample:</source>
          <target state="translated">有关您&lt;em&gt;可能&lt;/em&gt;会遇到的怪异行为的示例，请尝试以下示例：</target>
        </trans-unit>
        <trans-unit id="5c70b26fb103aa28d932d18050cb856e801635d4" translate="yes" xml:space="preserve">
          <source>For further reading:</source>
          <target state="translated">详见:</target>
        </trans-unit>
        <trans-unit id="1bf2110822fba72487dccdd77a2d40f6bd00662b" translate="yes" xml:space="preserve">
          <source>For this reason, local variables are usually generated as storage on a &quot;stack&quot; data structure, because a stack has the property that the first thing pushed on it is going to be the last thing popped off.</source>
          <target state="translated">由于这个原因,本地变量通常是作为存储在 &quot;堆栈 &quot;数据结构上的存储而产生的,因为堆栈具有这样的属性:第一个被推送到它上面的东西将是最后一个被弹出的东西。</target>
        </trans-unit>
        <trans-unit id="5efbdcdc6578ea05130db18ac54a4c2a591f0648" translate="yes" xml:space="preserve">
          <source>GCC shows this Warning</source>
          <target state="translated">GCC显示此警告</target>
        </trans-unit>
        <trans-unit id="b10d57cc173a336784fa10ae3535545c463b017f" translate="yes" xml:space="preserve">
          <source>Here I am simply treating 123456 as the address of a double and write to it. Any number of things could happen:</source>
          <target state="translated">在这里,我只是把123456作为一个双倍地址,并写到它。任何事情都可能发生。</target>
        </trans-unit>
        <trans-unit id="cac5d1b4d781ba7ae7623777363b8748a7fffdc9" translate="yes" xml:space="preserve">
          <source>Holy goodness, this answer is getting a lot of attention. (I'm not sure why -- I considered it to be just a &quot;fun&quot; little analogy, but whatever.)</source>
          <target state="translated">天啊,这个答案引起了很多人的关注。(我不知道为什么 ----我认为这只是一个 &quot;有趣 &quot;的小比喻,但不管怎么样。)</target>
        </trans-unit>
        <trans-unit id="3fc5e06963f155f494425e90cc027ebe74ce7146" translate="yes" xml:space="preserve">
          <source>How can it be? Isn't the memory of a local variable inaccessible outside its function?</source>
          <target state="translated">怎么会这样呢?本地变量的内存不是在其函数之外无法访问吗?</target>
        </trans-unit>
        <trans-unit id="3fb4e1bfa90528212a424b3831d731b3a5295bc1" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;undefined&lt;/em&gt; behaviour and you should not rely on it to work!</source>
          <target state="translated">但是，这是&lt;em&gt;未定义的&lt;/em&gt;行为，您不应依靠它来工作！</target>
        </trans-unit>
        <trans-unit id="a7065978f6d14568e0e790c7484b61564f9f8483" translate="yes" xml:space="preserve">
          <source>I have the following code.</source>
          <target state="translated">我有以下代码:</target>
        </trans-unit>
        <trans-unit id="d9e4823ab18ab248ad0ae5098903f1270fb34501" translate="yes" xml:space="preserve">
          <source>I thought it might be germane to update this a bit with a few more technical thoughts.</source>
          <target state="translated">我想可能会有必要再更新一下技术上的一些想法。</target>
        </trans-unit>
        <trans-unit id="e84b4bc2bc02c2ff515aa6c327f740c5f39d484a" translate="yes" xml:space="preserve">
          <source>In C++, you &lt;em&gt;can&lt;/em&gt; access any address, but it doesn't mean you &lt;em&gt;should&lt;/em&gt;. The address you are accessing is no longer valid. It &lt;em&gt;works&lt;/em&gt; because nothing else scrambled the memory after foo returned, but it could crash under many circumstances. Try analyzing your program with &lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt;, or even just compiling it optimized, and see...</source>
          <target state="translated">在C ++中，您&lt;em&gt;可以&lt;/em&gt;访问任何地址，但这并不意味着您&lt;em&gt;应该&lt;/em&gt; 。 您正在访问的地址不再有效。 之所以&lt;em&gt;起作用，&lt;/em&gt;是因为在foo返回之后，没有其他事情扰乱了内存，但是在许多情况下它可能崩溃。 尝试使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Valgrind&quot;&gt;Valgrind&lt;/a&gt;分析您的程序，甚至只是对其进行优化编译，然后查看...</target>
        </trans-unit>
        <trans-unit id="d0fe5db286c8dab66cb0d3b82b36a45e675f7834" translate="yes" xml:space="preserve">
          <source>In short: this won't usually work, but sometimes will by chance.</source>
          <target state="translated">简而言之:这通常不会有效果,但有时偶然会有效果。</target>
        </trans-unit>
        <trans-unit id="884f6b5a0e405708c0d3da980d10be30e33501e7" translate="yes" xml:space="preserve">
          <source>In this situation &lt;strong&gt;anything can happen&lt;/strong&gt;. The book can be there -- you got lucky. Someone else's book can be there and yours could be in the hotel's furnace. Someone could be there right when you come in, tearing your book to pieces. The hotel could have removed the table and book entirely and replaced it with a wardrobe. The entire hotel could be just about to be torn down and replaced with a football stadium, and you are going to die in an explosion while you are sneaking around.</source>
          <target state="translated">在这种情况下， &lt;strong&gt;任何事情都可能发生&lt;/strong&gt; 。 这本书可以在那里-您很幸运。 可能有人的书在那里，而您的书可能在酒店的炉子里。 当您进来时，有人可能会在那里，将您的书撕成碎片。 该酒店本可以删除桌子并完全预订，然后用衣柜代替。 整个酒店可能会被拆毁，取而代之的是一个足球场，而当您潜行时，您将在爆炸中丧生。</target>
        </trans-unit>
        <trans-unit id="2e771043fe216902e4ecf87e32bed904be6c6fe8" translate="yes" xml:space="preserve">
          <source>In typical compiler implementations, you can think of the code as &quot;print out the value of the memory block with adress that &lt;em&gt;used to be&lt;/em&gt; occupied by a&quot;. Also, if you add a new function invocation to a function that constains a local &lt;code&gt;int&lt;/code&gt; it's a good chance that the value of &lt;code&gt;a&lt;/code&gt; (or the memory address that &lt;code&gt;a&lt;/code&gt; used to point to) changes. This happens because the stack will be overwritten with a new frame containing different data.</source>
          <target state="translated">在典型的编译器实现中，您可以将代码视为&amp;ldquo; &lt;em&gt;用以前&lt;/em&gt;被a占用的地址打印出内存块的值&amp;rdquo;。 同样，如果您向包含局部 &lt;code&gt;int&lt;/code&gt; 的函数添加新的函数调用，则很有可能会更改 &lt;code&gt;a&lt;/code&gt; （或用于指向的内存地址）的值。 发生这种情况是因为堆栈将被包含不同数据的新帧覆盖。</target>
        </trans-unit>
        <trans-unit id="e6431cf35a0648d9b667c3d460073ff4a639aace" translate="yes" xml:space="preserve">
          <source>Instead, implementations let you make mistakes and get away with it. Most of the time. Until one day something truly awful goes wrong and the process explodes.</source>
          <target state="translated">相反,实现让你犯了错误就可以逍遥法外。大多数时候都是这样。直到有一天,真正可怕的事情出了错,过程爆发了。</target>
        </trans-unit>
        <trans-unit id="cf808b24485af68ad3c78cf040a3df8bd129cff2" translate="yes" xml:space="preserve">
          <source>It can, because &lt;code&gt;a&lt;/code&gt; is a variable allocated temporarily for the lifetime of its scope (&lt;code&gt;foo&lt;/code&gt; function). After you return from &lt;code&gt;foo&lt;/code&gt; the memory is free and can be overwritten.</source>
          <target state="translated">因为 &lt;code&gt;a&lt;/code&gt; 是在其作用域的生命周期内临时分配的变量（ &lt;code&gt;foo&lt;/code&gt; 函数），所以可以。 从 &lt;code&gt;foo&lt;/code&gt; 返回后，内存是可用的，可以被覆盖。</target>
        </trans-unit>
        <trans-unit id="a24c120f4ed8e1f85f91181732fc5d4f90b2dfce" translate="yes" xml:space="preserve">
          <source>It works because the stack has not been altered (yet) since a was put there. 
Call a few other functions (which are also calling other functions) before accessing &lt;code&gt;a&lt;/code&gt; again and you will probably not be so lucky anymore... ;-)</source>
          <target state="translated">之所以起作用，是因为自从将a放入堆栈以来，堆栈没有被更改。 在再次访问之前，请调用一些其他函数（也正在调用其他函数），您可能不会再那么幸运了&amp;hellip;&amp;hellip;;-)</target>
        </trans-unit>
        <trans-unit id="6d865b18ac08c0c3d8f413777a079cf33cf8b7d8" translate="yes" xml:space="preserve">
          <source>It's 'Dirty' way of using memory addresses. When you return an address (pointer) you don't know whether it belongs to local scope of a function. It's just an address. Now that you invoked the 'foo' function, that address (memory location) of 'a' was already allocated there in the (safely, for now at least) addressable memory of your application (process). After the 'foo' function returned, the address of 'a' can be considered 'dirty' but it's there, not cleaned up, nor disturbed/modified by expressions in other part of program (in this specific case at least). A C/C++ compiler doesn't stop you from such 'dirty' access (might warn you though, if you care). You can safely use (update) any memory location that is in the data segment of your program instance (process) unless you protect the address by some means.</source>
          <target state="translated">这是使用内存地址的 &quot;肮脏 &quot;方式。当你返回一个地址(指针)时,你不知道它是否属于函数的本地作用域。它只是一个地址。现在你调用了'foo'函数,'a'的那个地址(内存位置)已经在你的应用程序(进程)的可寻址内存中(至少现在是安全的)分配到了那里。在'foo'函数返回后,'a'的地址可以被认为是'脏的',但它还在那里,没有被清理,也没有被程序的其他部分的表达式干扰修改(至少在这个特定的情况下)。CC++编译器不会阻止你对这种 &quot;脏 &quot;的访问(如果你在乎的话,可能会警告你)。你可以安全地使用(更新)你的程序实例(进程)的数据段中的任何内存位置,除非你通过某种方式保护地址。</target>
        </trans-unit>
        <trans-unit id="668ed96ef41788718678a8ce40aa14755a7a92c8" translate="yes" xml:space="preserve">
          <source>It's like the hotel decides to only rent out rooms sequentially, and you can't check out until everyone with a room number higher than you has checked out.</source>
          <target state="translated">就好比酒店决定只能按顺序出租房间,等房号比你高的人都退房了,你才能退房。</target>
        </trans-unit>
        <trans-unit id="f3e2804ed3bd64f789e8ab14d3b38ca8f2c1f567" translate="yes" xml:space="preserve">
          <source>Local variables follow the latter pattern; when a method is entered, its local variables come alive. When that method calls another method, the new method's local variables come alive. They'll be dead before the first method's local variables are dead.  The relative order of the beginnings and endings of lifetimes of storages associated with local variables can be worked out ahead of time.</source>
          <target state="translated">局部变量遵循后一种模式;当一个方法被输入时,它的局部变量就会被激活。当该方法调用另一个方法时,新方法的局部变量就会活过来。在第一个方法的局部变量死之前,它们就已经死了。与局部变量相关联的存储器的生命开始和结束的相对顺序可以提前算出。</target>
        </trans-unit>
        <trans-unit id="92b523458f46cae25f6e91180adcbb80c63ad661" translate="yes" xml:space="preserve">
          <source>More memory-safe languages solve this problem by restricting your power. In &quot;normal&quot; C# there simply is no way to take the address of a local and return it or store it for later. You can take the address of a local, but the language is cleverly designed so that it is impossible to use it after the lifetime of the local ends. In order to take the address of a local and pass it back, you have to put the compiler in a special &quot;unsafe&quot; mode, &lt;em&gt;and&lt;/em&gt; put the word &quot;unsafe&quot; in your program, to call attention to the fact that you are probably doing something dangerous that could be breaking the rules.</source>
          <target state="translated">更多的内存安全语言通过限制您的能力来解决此问题。 在&amp;ldquo;普通&amp;rdquo; C＃中，根本没有办法获取本地地址并将其返回或存储以供以后使用。 您可以使用本地地址，但是语言设计巧妙，因此在本地生命周期结束后无法使用它。 为了获取本地地址并将其传递回去，您必须将编译器置于特殊的&amp;ldquo;不安全&amp;rdquo;模式， &lt;em&gt;并将&lt;/em&gt; &amp;ldquo;不安全&amp;rdquo;一词放入程序中，以引起注意以下事实：可能违反规则的危险。</target>
        </trans-unit>
        <trans-unit id="f7776b8ae70f653468c196298aea76866e611224" translate="yes" xml:space="preserve">
          <source>Nobody will automatically check the semantic validity of memory addresses like that for you during normal program execution. However, a memory debugger such as &lt;code&gt;valgrind&lt;/code&gt; will happily do this, so you should run your program through it and witness the errors.</source>
          <target state="translated">在正常程序执行期间，没有人会像您一样自动检查内存地址的语义有效性。 但是，内存调试器（例如 &lt;code&gt;valgrind&lt;/code&gt; )会很乐意这样做，因此您应该通过它运行程序并见证错误。</target>
        </trans-unit>
        <trans-unit id="9cc0ce9cccdfa9247eba033a1e1a044665d8c5e6" translate="yes" xml:space="preserve">
          <source>Now if you're wondering why the compiler doesn't complain, it's probably because &lt;code&gt;foo&lt;/code&gt; got eliminated by optimization. It usually will warn you about this sort of thing. C assumes you know what you're doing though, and technically you haven't violated scope here (there's no reference to &lt;code&gt;a&lt;/code&gt; itself outside of &lt;code&gt;foo&lt;/code&gt;), only memory access rules, which only triggers a warning rather than an error.</source>
          <target state="translated">现在，如果您想知道为什么编译器不会抱怨，那可能是因为 &lt;code&gt;foo&lt;/code&gt; 被优化消除了。 通常会警告您这种事情。 C假设您知道自己在做什么，并且从技术上讲，您在这里没有违反范围（在 &lt;code&gt;foo&lt;/code&gt; 之外没有引用自身），只有内存访问规则，它仅触发警告而不是错误。</target>
        </trans-unit>
        <trans-unit id="64dfdee1fb88a04e52e453e6fea524374d6fce64" translate="yes" xml:space="preserve">
          <source>Pay attention to  all warnings . Do not only solve errors.</source>
          <target state="translated">注意所有的警告。不要只解决错误。</target>
        </trans-unit>
        <trans-unit id="dbd3aa8cb4b802de57285634bed996e92ef2c0e4" translate="yes" xml:space="preserve">
          <source>Returning the address of a temporary works, but as temporaries are destroyed at the end of a function the results of accessing them will be undefined.</source>
          <target state="translated">返回一个临时工程的地址,但由于临时工程在函数结束时被销毁,所以访问临时工程的结果将无法定义。</target>
        </trans-unit>
        <trans-unit id="7a96582b612f775240973f5214e850faef3962ce" translate="yes" xml:space="preserve">
          <source>So let's think about the stack. In many operating systems you get one stack per thread and the stack is allocated to be a certain fixed size. When you call a method, stuff is pushed onto the stack. If you then pass a pointer to the stack back out of your method, as the original poster does here, that's just a pointer to the middle of some entirely valid million-byte memory block. In our analogy, you check out of the hotel; when you do, you just checked out of the highest-numbered occupied room.  If no one else checks in after you, and you go back to your room illegally, all your stuff is guaranteed to still be there &lt;em&gt;in this particular hotel&lt;/em&gt;.</source>
          <target state="translated">因此，让我们考虑一下堆栈。 在许多操作系统中，每个线程获得一个堆栈，并且该堆栈被分配为一定的固定大小。 调用方法时，东西被压入堆栈。 如果您随后将指针传递回方法之外的堆栈，就像原始海报在此处所做的那样，那仅是指向某些完全有效的百万字节内存块中间的指针。 打个比方，您从酒店退房； 当您这样做时，您只是从编号最高的占用房间中退出。 如果没有其他人在您之后&lt;em&gt;入住&lt;/em&gt; ，并且您非法返回您的房间，则可以保证所有物品仍在&lt;em&gt;该特定酒店中&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="48e728fecb72b1215b61d3c3ac811f6b5f708706" translate="yes" xml:space="preserve">
          <source>So you did not modify &lt;code&gt;a&lt;/code&gt; but rather the memory location where &lt;code&gt;a&lt;/code&gt; once was. This difference is very similar to the difference between crashing and not crashing.</source>
          <target state="translated">因此，您没有修改 &lt;code&gt;a&lt;/code&gt; 而是修改 &lt;code&gt;a&lt;/code&gt; 一次的存储位置。 这种差异与崩溃与不崩溃之间的差异非常相似。</target>
        </trans-unit>
        <trans-unit id="415f6940290f7adad86030b3b1e1a91474c25e52" translate="yes" xml:space="preserve">
          <source>So, here function &lt;code&gt;foo()&lt;/code&gt; is returning the address of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is destroyed after returning its address. And you can access the modified value through that returned address.</source>
          <target state="translated">因此，此处的函数 &lt;code&gt;foo()&lt;/code&gt; 返回a的地址，而 &lt;code&gt;a&lt;/code&gt; 在返回其地址后被销毁。 您可以通过该返回地址访问修改后的值。</target>
        </trans-unit>
        <trans-unit id="4ca65421239872c85bc7cb4eab3534ea2b033ade" translate="yes" xml:space="preserve">
          <source>Suppose a man hides money at a location and tells you the location. After some time, the man who had told you the money location dies. But still you have the access of that hidden money.</source>
          <target state="translated">假设一个人把钱藏在一个地方,并告诉你钱的位置。过了一段时间后,那个告诉你钱的位置的人死了。但你仍然可以获得那笔隐藏的钱的使用权。</target>
        </trans-unit>
        <trans-unit id="6637ee0ae3a2356e88607e4783fe52245560ba0b" translate="yes" xml:space="preserve">
          <source>That is because after returning from foo() the stack is freed and then reused by boo().
If you deassemble the executable you will see it clearly.</source>
          <target state="translated">这是因为从foo()返回后,栈被释放,然后被boo()重用。如果你解构可执行文件,你会清楚地看到它。</target>
        </trans-unit>
        <trans-unit id="10653b9d4a1d031b54f7ad1b1a5976b3c3fe1950" translate="yes" xml:space="preserve">
          <source>That means the memory address could be valid or not, and your code will be vulnerable to possible memory address issues (for example segmentation fault).</source>
          <target state="translated">这意味着内存地址可能是有效的,也可能是无效的,你的代码将很容易受到可能的内存地址问题的影响(例如分段故障)。</target>
        </trans-unit>
        <trans-unit id="55e66b98d49314348a56ec9d7b30dce4d53f468e" translate="yes" xml:space="preserve">
          <source>That's classic &lt;strong&gt;undefined behaviour&lt;/strong&gt; that's been discussed here not two days ago -- search around the site for a bit. In a nutshell, you were lucky, but anything could have happened and your code is making invalid access to memory.</source>
          <target state="translated">这是经典的&lt;strong&gt;未定义行为&lt;/strong&gt; ，前两天在这里进行了讨论-在站点周围进行搜索。 简而言之，您很幸运，但是任何事情都可能发生，并且您的代码使对内存的访问无效。</target>
        </trans-unit>
        <trans-unit id="d01e8b0fd46bdbf027d2c78b2cf77e0ad3eadb05" translate="yes" xml:space="preserve">
          <source>The first is to have some sort of &quot;long lived&quot; storage area where the &quot;lifetime&quot; of each byte in the storage -- that is, the period of time when it is validly associated with some program variable -- cannot be easily predicted ahead of time. The compiler generates calls into a &quot;heap manager&quot; that knows how to dynamically allocate storage when it is needed and reclaim it when it is no longer needed.</source>
          <target state="translated">首先是要有某种 &quot;长寿 &quot;的存储区,其中存储中的每个字节的 &quot;寿命&quot;--也就是说,它与某个程序变量有效关联的时间段--不容易提前预测。编译器会生成对 &quot;堆管理器 &quot;的调用,它知道如何在需要的时候动态分配存储区,并在不再需要的时候收回。</target>
        </trans-unit>
        <trans-unit id="2a517045d055d1343ace682896452e5177bc4524" translate="yes" xml:space="preserve">
          <source>The hotel management is not &lt;em&gt;required&lt;/em&gt; to remove your book. You didn't make a contract with them that said that if you leave stuff behind, they'll shred it for you. If you illegally re-enter your room with a stolen key to get it back, the hotel security staff is not &lt;em&gt;required&lt;/em&gt; to catch you sneaking in. You didn't make a contract with them that said &quot;if I try to sneak back into my room later, you are required to stop me.&quot; Rather, you signed a contract with them that said &quot;I promise not to sneak back into my room later&quot;, a contract which &lt;em&gt;you broke&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;不需要&lt;/em&gt;酒店管理人员删除您的书。 您没有与他们签订合同，说如果您留下东西，他们会为您切碎。 如果您用偷来的钥匙非法重新进入房间以将其取回，则&lt;em&gt;无需&lt;/em&gt;酒店安全人员抓住您潜行。您没有与他们订立合同，说&amp;ldquo;如果我尝试潜入我的房间，房间之后，您必须阻止我。&amp;rdquo; 相反，您与他们签订了一份合同，上面写着&amp;ldquo;我保证以后不会再潜入我的房间&amp;rdquo;，这是&lt;em&gt;您违反&lt;/em&gt;的合同。</target>
        </trans-unit>
        <trans-unit id="0393a71499e25d744a2e0cd1648098b160eca6d2" translate="yes" xml:space="preserve">
          <source>The output was &lt;code&gt;58&lt;/code&gt;</source>
          <target state="translated">输出为 &lt;code&gt;58&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c253d37c3711b668d6b9d942320ae2687acd295" translate="yes" xml:space="preserve">
          <source>The problem you are having is why the program doesn't signal an error when referencing illegal memory. This is because C++ standards does not specify a very clear boundary between illegal memory and legal memory. Referencing something in popped out stack sometimes causes error and sometimes not. It depends. Don't count on this behavior. Assume it will always result in error when you program, but assume it will never signal error when you debug.</source>
          <target state="translated">你所遇到的问题是,为什么程序在引用非法内存时没有发出错误信号。这是因为C++标准并没有明确规定非法内存和合法内存之间的界限。引用弹出栈中的东西有时会导致错误,有时不会。这要看情况而定。不要指望这种行为。假设它在你编程时总是会导致错误,但假设它在你调试时永远不会发出错误信号。</target>
        </trans-unit>
        <trans-unit id="890aeeea49faa2fa28d38ffb4d73ad962a14ab97" translate="yes" xml:space="preserve">
          <source>The second method is to have a &amp;ldquo;short-lived&amp;rdquo; storage area where the lifetime of each byte is well known. Here, the lifetimes follow a &amp;ldquo;nesting&amp;rdquo; pattern. The longest-lived of these short-lived variables will be allocated before any other short-lived variables, and will be freed last. Shorter-lived variables will be allocated after the longest-lived ones, and will be freed before them. The lifetime of these shorter-lived variables is &amp;ldquo;nested&amp;rdquo; within the lifetime of longer-lived ones.</source>
          <target state="translated">第二种方法是拥有一个&amp;ldquo;短暂的&amp;rdquo;存储区域，其中每个字节的生存期众所周知。 在此，生命周期遵循&amp;ldquo;嵌套&amp;rdquo;模式。 这些短期变量中寿命最长的变量将在任何其他短期变量之前分配，最后释放。 寿命较短的变量将在寿命最长的变量之后分配，并在它们之前被释放。 这些寿命较短的变量的寿命被&amp;ldquo;嵌套&amp;rdquo;在寿命较长的变量的寿命之内。</target>
        </trans-unit>
        <trans-unit id="35e6bd2b69222deaf1995ea9da0a68f6703d7ccb" translate="yes" xml:space="preserve">
          <source>The things with correct (?) console output can change dramatically if you use ::printf but not cout. 
You can play around with debugger within below code (tested on x86, 32-bit, MSVisual Studio):</source>
          <target state="translated">如果你使用:::printf而不是cout,那么控制台输出正确的东西会有很大的变化。你可以在下面的代码中使用调试器(在x86,32位,MSVisual Studio上测试)。</target>
        </trans-unit>
        <trans-unit id="f0ba7d3098b2635fa4805520c0d620eed935a473" translate="yes" xml:space="preserve">
          <source>The way you set it up it is a bit more reasonable that the returned address points into a valid area of memory, as it will probably just be a little further down the stack, but it is still an invalid location that you cannot access in a deterministic fashion.</source>
          <target state="translated">从你设置的方式来看,返回的地址指向有效的内存区域是比较合理的,因为它很可能只是在堆栈的下端稍远一点,但它仍然是一个无效的位置,不能以确定性的方式访问。</target>
        </trans-unit>
        <trans-unit id="c64bb54b249751cf9009a2a39ddde0cbec79cbdf" translate="yes" xml:space="preserve">
          <source>This behavior is undefined, as Alex pointed out--in fact, most compilers will warn against doing this, because it's an easy way to get crashes.</source>
          <target state="translated">这种行为是没有定义的,正如Alex指出的那样----事实上,大多数编译器都会警告不要这样做,因为这样做很容易导致崩溃。</target>
        </trans-unit>
        <trans-unit id="df8ae21359a7a9c1782b2fa5d716171e207fefde" translate="yes" xml:space="preserve">
          <source>This is  power of C++. You should care about memory. With the &lt;code&gt;-Werror&lt;/code&gt; flag, this warning becames an error and now you have to debug it.</source>
          <target state="translated">这是C ++的强大功能。 您应该关心内存。 使用 &lt;code&gt;-Werror&lt;/code&gt; 标志，此警告变为错误，现在您必须对其进行调试。</target>
        </trans-unit>
        <trans-unit id="5b0d1e6d4ef066a26535944c60c6026681ae3fe8" translate="yes" xml:space="preserve">
          <source>This is problematic. There are a lot of rules and it is very easy to break them accidentally. I certainly have many times. And worse, the problem often only surfaces when memory is detected to be corrupt billions of nanoseconds after the corruption happened, when it is very hard to figure out who messed it up.</source>
          <target state="translated">这是有问题的。规矩很多,一不小心就很容易违反。我当然也有过很多次。而且更糟糕的是,往往只有在腐败发生后几十亿纳秒后,当检测到内存被损坏时,问题才会浮出水面,这时就很难弄清楚是谁把它弄坏了。</target>
        </trans-unit>
        <trans-unit id="0eaf8b53ad7d5c524b38b6a971be8dfad3b95b37" translate="yes" xml:space="preserve">
          <source>This means that you are doing a very bad thing, becouse you are passing a memory address to a pointer wich is not trustable at all.</source>
          <target state="translated">这意味着你正在做一件非常糟糕的事情,因为你传递一个内存地址给一个指针,而这个指针根本不值得信任。</target>
        </trans-unit>
        <trans-unit id="6f697153226ae9e147e41d50dcd86d77b9a8ca6f" translate="yes" xml:space="preserve">
          <source>This prints out &quot;y=123&quot;, but your results may vary (really!). Your pointer is clobbering other, unrelated local variables.</source>
          <target state="translated">这打印出 &quot;y=123&quot;,但你的结果可能会有所不同(真的!)。你的指针会干扰其他不相关的本地变量。</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="398226ff0451b7e1c1c5e5a7a2cbe718625ea490" translate="yes" xml:space="preserve">
          <source>Unlike your example, with this example you are:</source>
          <target state="translated">和你的例子不同,有了这个例子你就。</target>
        </trans-unit>
        <trans-unit id="bf83ed6f06abc30e3c1ba88ba6233762dd35af5d" translate="yes" xml:space="preserve">
          <source>We use stacks for temporary stores because they are really cheap and easy. An implementation of C++ is not required to use a stack for storage of locals; it could use the heap. It doesn't, because that would make the program slower.</source>
          <target state="translated">我们用堆来做临时存储,因为它们确实很便宜,也很方便。C++的实现不需要使用堆栈来存储locals,它可以使用堆。它不需要,因为那样会使程序速度变慢。</target>
        </trans-unit>
        <trans-unit id="e53fd215b0c495c0d89e0f96c8abbf2fb92be241" translate="yes" xml:space="preserve">
          <source>Well, obviously that scenario can happen in the real world no problem. There is no mysterious force that causes your book to disappear when you are no longer authorized to be in the room. Nor is there a mysterious force that prevents you from entering a room with a stolen key.</source>
          <target state="translated">好吧,显然这种情况在现实世界中发生是没有问题的。没有什么神秘的力量会导致你的书消失,当你不再被授权进入房间时,你的书就会消失。也没有一种神秘的力量阻止你用被盗的钥匙进入房间。</target>
        </trans-unit>
        <trans-unit id="a5d081b4250b3c6bf254dbe76846254422327e9b" translate="yes" xml:space="preserve">
          <source>What if C# did allow returning references? Coincidentally that is the subject of today's blog post:</source>
          <target state="translated">如果C#真的允许返回引用呢?巧合的是,这就是今天博文的主题。</target>
        </trans-unit>
        <trans-unit id="4ba89d6203509c5bf6440005ba0577078a5e174f" translate="yes" xml:space="preserve">
          <source>What you're doing here is simply reading and writing to memory that</source>
          <target state="translated">你在这里做的是简单的阅读和写作记忆,即</target>
        </trans-unit>
        <trans-unit id="b0b04b262ca077c743d5bedec5d61192576329c1" translate="yes" xml:space="preserve">
          <source>What you're doing is described as &lt;em&gt;undefined behavior&lt;/em&gt;. The result cannot be predicted.</source>
          <target state="translated">您正在做什么被描述为&lt;em&gt;未定义的行为&lt;/em&gt; 。 结果无法预测。</target>
        </trans-unit>
        <trans-unit id="a5b6bae245aa7990e2bf8f6d62a4b4fd1d7c04a8" translate="yes" xml:space="preserve">
          <source>When you return from &lt;code&gt;foo&lt;/code&gt;, you tell the OS that you're no longer using that memory and it can be reassigned to something else. If you're lucky and it never does get reassigned, and the OS doesn't catch you using it again, then you'll get away with the lie. Chances are though you'll end up writing over whatever else ends up with that address.</source>
          <target state="translated">从 &lt;code&gt;foo&lt;/code&gt; 返回时，您告诉操作系统您不再使用该内存，可以将其重新分配给其他内存。 如果您很幸运，而且它从未被重新分配过，并且操作系统没有抓住您再次使用它的权利，那么您就可以摆脱谎言。 尽管您最终可能会写满以该地址结尾的其他内容，但这种机会还是有可能的。</target>
        </trans-unit>
        <trans-unit id="fa1180633feda4933e750090ee9485e74f2fa520" translate="yes" xml:space="preserve">
          <source>Why do we use stacks to manage memory? Are value types in C# always stored on the stack? How does virtual memory work? And many more topics in how the C# memory manager works. Many of these articles are also germane to C++ programmers:</source>
          <target state="translated">为什么我们要用堆栈来管理内存?C#中的值类型总是存储在堆栈中吗?虚拟内存是如何工作的?以及更多关于C#内存管理器如何工作的话题。这些文章中的许多内容对于C++程序员来说也是有意义的。</target>
        </trans-unit>
        <trans-unit id="367a511c0bd23747bed54a801c60343a2911cb1f" translate="yes" xml:space="preserve">
          <source>Yes if you try to dereference that memory address you will have undefined behavior.</source>
          <target state="translated">是的,如果你试图取消对该内存地址的引用,你将会出现未定义的行为。</target>
        </trans-unit>
        <trans-unit id="f7b6efeb9999e8415e2256127bd801c374f407de" translate="yes" xml:space="preserve">
          <source>You actually invoked undefined behaviour.</source>
          <target state="translated">你实际上调用了未定义的行为。</target>
        </trans-unit>
        <trans-unit id="0ab951d4546ea151e47a2697193d8f628bd98a9e" translate="yes" xml:space="preserve">
          <source>You are just returning a memory address, it's allowed but probably an error.</source>
          <target state="translated">你只是返回一个内存地址,这是允许的,但很可能是个错误。</target>
        </trans-unit>
        <trans-unit id="632ab4b8b530f13855f715927a28aa2f5a4eb21e" translate="yes" xml:space="preserve">
          <source>You don't know what is going to happen; when you checked out of the hotel and stole a key to illegally use later, you gave up the right to live in a predictable, safe world because &lt;em&gt;you&lt;/em&gt; chose to break the rules of the system.</source>
          <target state="translated">您不知道会发生什么； 当您退房并偷走了以后非法使用的钥匙时，您放弃了生活在可预测的安全世界中的权利，因为&lt;em&gt;您&lt;/em&gt;选择了违反系统规则。</target>
        </trans-unit>
        <trans-unit id="b6a838ff678f89b070003058718a712103126d6e" translate="yes" xml:space="preserve">
          <source>You never throw a C++ exception by accessing invalid memory. You are just giving an example of the general idea of referencing an arbitrary memory location. I could do the same like this:</source>
          <target state="translated">你永远不会通过访问无效内存抛出一个C++异常。你只是举了一个例子来说明引用任意内存位置的一般思路。我也可以这样做。</target>
        </trans-unit>
        <trans-unit id="851a700a375ff806c1dcbb41aa3d34c727d4e133" translate="yes" xml:space="preserve">
          <source>You rent a hotel room. You put a book in the top drawer of the bedside table and go to sleep.  You check out the next morning, but &quot;forget&quot; to give back your key. You steal the key!</source>
          <target state="translated">你租了一间酒店的房间。你把一本书放在床头柜最上面的抽屉里,然后睡觉。第二天早上你退房,却 &quot;忘了 &quot;把钥匙还给你。你把钥匙偷走了!</target>
        </trans-unit>
        <trans-unit id="b6cedbdba81d1f1c5892a7412b1dd7929c578e4d" translate="yes" xml:space="preserve">
          <source>You win the lottery.</source>
          <target state="translated">你中了彩票。</target>
        </trans-unit>
        <trans-unit id="a8d5a5789511f170672864f52617e354f9acfe8c" translate="yes" xml:space="preserve">
          <source>Your code is very risky. You are creating a local variable (wich is considered destroyed after function ends) and you return the address of memory of that variable after it is destoyed.</source>
          <target state="translated">你的代码是非常危险的。你在创建一个本地变量(在函数结束后被认为是被销毁的),而你返回的是该变量被销毁后的内存地址。</target>
        </trans-unit>
        <trans-unit id="27c02908661ef2d4af116e6eda229fd38a50ef3f" translate="yes" xml:space="preserve">
          <source>Your problem has nothing to do with &lt;em&gt;scope&lt;/em&gt;. In the code you show, the function &lt;code&gt;main&lt;/code&gt; does not see the names in the function &lt;code&gt;foo&lt;/code&gt;, so you can't access &lt;code&gt;a&lt;/code&gt; in foo directly with &lt;em&gt;this&lt;/em&gt; name outside &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">您的问题与&lt;em&gt;范围&lt;/em&gt;无关。 在显示的代码中， &lt;code&gt;main&lt;/code&gt; 函数在 &lt;code&gt;foo&lt;/code&gt; 函数中看不到名称，因此您不能直接在foo外使用&lt;em&gt;此&lt;/em&gt;名称访问in in &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4467dc3c2dfc773030d9d4d4ec6b6374a6ce09aa" translate="yes" xml:space="preserve">
          <source>allocating memory for int into a local function</source>
          <target state="translated">分配内存到本地函数</target>
        </trans-unit>
        <trans-unit id="25568658dcfbd886141b75f7a37ca9a44f6d7bfe" translate="yes" xml:space="preserve">
          <source>be the address of &lt;code&gt;a&lt;/code&gt;. Now that you're outside of &lt;code&gt;foo&lt;/code&gt;, it's just a pointer to some random memory area. It just so happens that in your example, that memory area does exist and nothing else is using it at the moment. You don't break anything by continuing to use it, and nothing else has overwritten it yet. Therefore, the &lt;code&gt;5&lt;/code&gt; is still there. In a real program, that memory would be re-used almost immediately and you'd break something by doing this (though the symptoms may not appear until much later!)</source>
          <target state="translated">是的地址。 现在您不在 &lt;code&gt;foo&lt;/code&gt; 之外，它只是指向某个随机内存区域的指针。 碰巧的是，在您的示例中，该内存区域确实存在，并且目前没有其他人在使用它。 您不会通过继续使用而破坏任何东西，并且还没有其他东西覆盖它。 因此， &lt;code&gt;5&lt;/code&gt; 仍然存在。 在实际的程序中，该内存将几乎立即被重新使用，并且这样做会破坏某些功能（尽管症状可能要等到很久以后才会出现！）</target>
        </trans-unit>
        <trans-unit id="5b1b059e808759b8d1c5874ad49671b3b3d4813a" translate="yes" xml:space="preserve">
          <source>if you do something like that:</source>
          <target state="translated">如果你做这样的事情。</target>
        </trans-unit>
        <trans-unit id="3853ee4965d2fd6e74929bd4ae29cc0ed44947f9" translate="yes" xml:space="preserve">
          <source>that memory address is still valid also when function expires, (it is not deleted by anyone)</source>
          <target state="translated">该内存地址在功能过期时仍然有效,(不会被任何人删除</target>
        </trans-unit>
        <trans-unit id="197d6cb5a85574406eca31e0a72c1a7b788a0490" translate="yes" xml:space="preserve">
          <source>the memory address is trustable (that memory block is not considered free, so it will be not overridden until it is deleted)</source>
          <target state="translated">内存地址是可信任的(该内存块不被认为是空闲的,所以在它被删除之前不会被重写</target>
        </trans-unit>
        <trans-unit id="e0d69ca46fd46558106bbf5d93de1a37ad007fdb" translate="yes" xml:space="preserve">
          <source>the memory address should be deleted when not used. (see the delete at the end of the program)</source>
          <target state="translated">内存地址不使用时应删除。(见程序末尾的删除)</target>
        </trans-unit>
        <trans-unit id="abe86398849a8e40d77bea83096ad74f206ef947" translate="yes" xml:space="preserve">
          <source>the output probably will be: 7</source>
          <target state="translated">输出可能会是。7</target>
        </trans-unit>
        <trans-unit id="34790dc2e682800571cab44d1835a970e54f21a8" translate="yes" xml:space="preserve">
          <source>used to</source>
          <target state="translated">惯于</target>
        </trans-unit>
        <trans-unit id="46dbdaa85bacc9d8c59df32ce3fb81070bc6523b" translate="yes" xml:space="preserve">
          <source>warning: address of local variable 'a' returned</source>
          <target state="translated">警告:返回本地变量'a'的地址</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
