<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/6430448">
    <body>
      <group id="6430448">
        <trans-unit id="4d250087c10e817bb864c62232c3ce88493f0870" translate="yes" xml:space="preserve">
          <source>... once you know what kind of programmer &lt;em&gt;you&lt;/em&gt; are, you can use the &quot;-ffast-math&quot; switch to tell GCC that &quot;Hey, GCC, I know what I am doing!&quot;. This will allow GCC to convert a*a*a*a*a*a into a different piece of text - it looks different from a*a*a*a*a*a - but still computes a number within the error interval of a*a*a*a*a*a. This is OK, since you already know you are working with intervals, not ideal numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... как только вы узнаете, какой &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вы&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; программист &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, вы можете использовать переключатель &quot;-ffast-math&quot;, чтобы сообщить GCC: &quot;Эй, GCC, я знаю, что я делаю!&quot; Это позволит GCC преобразовать a * a * a * a * a * a в другой фрагмент текста - он выглядит иначе, чем a * a * a * a * a * a - но все равно вычисляет число в интервале ошибок а * а * а * а * а * а. Это нормально, так как вы уже знаете, что работаете с интервалами, а не с идеальными числами.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e601cb9e293c7f55858b9c7c9a8e1f3cfbbcf80f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/6430525/463065&quot;&gt;&lt;strong&gt;Lambdageek&lt;/strong&gt;&lt;/a&gt; correctly points out that because associativity does not hold for floating-point numbers, the &quot;optimization&quot; of &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; may change the value.  This is why it is disallowed by C99 (unless specifically allowed by the user, via compiler flag or pragma).  Generally, the assumption is that the programmer wrote what she did for a reason, and the compiler should respect that.  If you want &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;, write that.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/6430525/463065&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lambdageek&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; правильно указывает, что поскольку ассоциативность не выполняется для чисел с плавающей запятой, &amp;laquo;оптимизация&amp;raquo;&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; до&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; может измениться Значение. Вот почему он запрещен C99 (если это явно не разрешено пользователем, с помощью флага компилятора или прагмы). Как правило, предполагается, что программист написал то, что она сделала по какой-то причине, и компилятор должен это учитывать. Если вы хотите&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , напишите это.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3554b22e1fc90a354131abcb9d80400bf1e1fd41" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;strong&gt;Clarification for the curious:&lt;/strong&gt; this does not find the optimal way to compute powers, but since &lt;a href=&quot;http://en.wikipedia.org/wiki/Addition-chain_exponentiation&quot;&gt;finding the optimal solution is an NP-complete problem&lt;/a&gt; and this is only worth doing for small powers anyway (as opposed to using &lt;code&gt;pow&lt;/code&gt;), there's no reason to fuss with the detail.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Разъяснение для любопытных:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; это не находит оптимального способа вычисления степеней, но поскольку &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Addition-chain_exponentiation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;поиск оптимального решения является NP-полной задачей,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и в любом случае это стоит делать только для малых держав (в отличие от использования &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), нет никаких причин для возиться с деталями.&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="8ec2ebf132faa836164fcc84f4c1f54c2408fce2" translate="yes" xml:space="preserve">
          <source>Another similar case: most compilers won't optimize &lt;code&gt;a + b + c + d&lt;/code&gt; to &lt;code&gt;(a + b) + (c + d)&lt;/code&gt; (this is an optimization since the second expression can be pipelined better) and evaluate it as given (i.e. as &lt;code&gt;(((a + b) + c) + d)&lt;/code&gt;). This too is because of corner cases:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Еще один похожий случай: большинство компиляторов не оптимизируют &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a + b + c + d&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; до &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a + b) + (c + d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (это оптимизация, поскольку второе выражение может быть лучше конвейеризовано) и оценивают его как заданное (т.е. как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(((a + b) + c) + d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это тоже из-за угловых случаев:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c9a86236232165a7908c885e6e3608d6ebaa349" translate="yes" xml:space="preserve">
          <source>As Lambdageek pointed out float multiplication is not associative and you can get less accuracy, but also when get better accuracy you can argue against optimisation, because you want a deterministic application. For example in game simulation client/server, where every client has to simulate the same world you want floating point calculations to be deterministic.</source>
          <target state="translated">Как отметил Lambdageek,умножение с плавающей точкой не является ассоциативным,и вы можете получить меньшую точность,но также,когда вы получите лучшую точность,вы можете возразить против оптимизации,потому что вам нужно детерминистическое приложение.Например,в клиентсервере игрового симулятора,где каждый клиент должен симулировать один и тот же мир,вычисления с плавающей точкой должны быть детерминированными.</target>
        </trans-unit>
        <trans-unit id="a878690db08938608264102fc103f5780dab6683" translate="yes" xml:space="preserve">
          <source>As a result, most compilers are very conservative about reordering floating point calculations unless they can be sure that the answer will stay the same, or unless you tell them you don't care about numerical accuracy.  For example: &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt;the &lt;code&gt;-fassociative-math&lt;/code&gt; option&lt;/a&gt; of gcc which allows gcc to reassociate floating point operations, or even the &lt;code&gt;-ffast-math&lt;/code&gt; option which allows even more aggressive tradeoffs of accuracy against speed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В результате большинство компиляторов очень консервативно изменяют порядок вычислений с плавающей запятой, если только они не могут быть уверены, что ответ останется прежним, или если вы не скажете им, что вам не важна числовая точность. Например: &lt;/font&gt;&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt; &lt;code&gt;-fassociative-math&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вариант&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; НКИ , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;который позволяет куб.сму до реассоциирует операции с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;плавающей точкой, или даже &lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; вариант , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;который позволяет еще более агрессивные компромиссы точности против скорости.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1f7025a0a8653e90ed33ccd59a524411194bee3" translate="yes" xml:space="preserve">
          <source>As other posters have noted, this option is not possible in floating point, because floating point arithmetic is not associative.</source>
          <target state="translated">Как отмечали другие плакаты,эта опция невозможна в арифметике с плавающей точкой,так как арифметика с плавающей точкой не является ассоциативной.</target>
        </trans-unit>
        <trans-unit id="5cab4fa1adf07c1f4fab622ca0e1c9a2bbadc951" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems&quot;&gt;Floating Point Math is not Associative&lt;/a&gt;.  The way you group the operands in floating point multiplication has an effect on the numerical accuracy of the answer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Потому что &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;математика с плавающей точкой не ассоциативна&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;То, как вы группируете операнды в умножении с плавающей запятой, влияет на числовую точность ответа.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac72a721d84b77b0b13d7bfd347c5a737d30b1ff" translate="yes" xml:space="preserve">
          <source>Because a 32-bit floating-point number - such as 1.024 - is not 1.024. In a computer, 1.024 is an interval: from (1.024-e) to (1.024+e), where &quot;e&quot; represents an error. Some people fail to realize this and also believe that * in a*a stands for multiplication of arbitrary-precision numbers without there being any errors attached to those numbers. The reason why some people fail to realize this is perhaps the math computations they exercised in elementary schools: working only with ideal numbers without errors attached, and believing that it is OK to simply ignore &quot;e&quot; while performing multiplication. They do not see the &quot;e&quot; implicit in &quot;float a=1.2&quot;, &quot;a*a*a&quot; and similar C codes.</source>
          <target state="translated">Потому что 32-битное число с плавающей точкой,например 1.024,не является 1.024.В компьютере 1.024-это интервал:от (1.024-e)до (1.024+e),где &quot;e&quot;-это ошибка.Некоторые люди этого не понимают,а также считают,что*в a*a означает умножение чисел произвольной точности без привязки ошибок к этим числам.Причина,по которой некоторые люди не понимают этого,возможно,в математических вычислениях,которые они выполняли в начальной школе:работая только с идеальными числами без прикрепленных ошибок,и веря,что это нормально просто игнорировать &quot;e&quot; во время выполнения умножения.Они не видят &quot;e&quot;,неявно выраженного в &quot;float a=1.2&quot;,&quot;a*a*a&quot; и подобных C-кодах.</target>
        </trans-unit>
        <trans-unit id="fc0b3ee381fd7de113933bbc502a60dac899d423" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b62e31b37189d012f547a0a066099b50cab9e5ae" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a*a*a*a*a*a&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac18e696c6c6f8d2010e80747b9e03f2cdd1dbfb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4c7cce855605e6a3df3d02aa3dd09fd1da9c306" translate="yes" xml:space="preserve">
          <source>Fortran (designed for scientific computing) has a built-in power operator, and as far as I know Fortran compilers will commonly optimize raising to integer powers in a similar fashion to what you describe.  C/C++ unfortunately don't have a power operator, only the library function &lt;code&gt;pow()&lt;/code&gt;.  This doesn't prevent smart compilers from treating &lt;code&gt;pow&lt;/code&gt; specially and computing it in a faster way for special cases, but it seems they do it less commonly ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Fortran (разработанный для научных вычислений) имеет встроенный оператор питания, и, насколько мне известно, компиляторы Fortran обычно оптимизируют повышение до целочисленных степеней аналогично тому, что вы описываете. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;К сожалению, в C / C ++ нет оператора power, только библиотечная функция &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это не мешает умным компиляторам &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;специально &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обрабатывать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и вычислять его быстрее для особых случаев, но кажется, что они делают это реже ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="28395c97c243c9dc54c1873c68dbaf715650cbaa" translate="yes" xml:space="preserve">
          <source>GCC does actually optimize &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; when a is an integer.  I tried with this command:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC действительно оптимизирует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; до &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; когда a является целым числом. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я попытался с этой командой:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5cff5d070250d7e8684c02968fdc4cf5608e1d1a" translate="yes" xml:space="preserve">
          <source>GCC doesn't support this pragma, but with the default options, it assumes it to be &lt;code&gt;ON&lt;/code&gt;; thus for targets with a hardware FMA, if one wants to prevent the transformation &lt;code&gt;a*b+c&lt;/code&gt; to fma(a,b,c), one needs to provide an option such as &lt;code&gt;-ffp-contract=off&lt;/code&gt; (to explicitly set the pragma to &lt;code&gt;OFF&lt;/code&gt;) or &lt;code&gt;-std=c99&lt;/code&gt; (to tell GCC to conform to some C standard version, here C99, thus follow the above paragraph). In the past, the latter option was not preventing the transformation, meaning that GCC was not conforming on this point: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&quot;&gt;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC не поддерживает эту прагму, но с параметрами по умолчанию он предполагает, что она &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; таким образом, для целей с аппаратным FMA, если кто-то хочет предотвратить преобразование &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*b+c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в fma (a, b, c), необходимо предоставить опцию, например &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffp-contract=off&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (чтобы явно установить прагму в положение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-std=c99&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (чтобы сообщить GCC о соответствии некоторой стандартной версии C, здесь C99, таким образом следуйте приведенному выше параграфу). В прошлом последний вариант не препятствовал преобразованию, а это означает, что GCC не соответствовал этому пункту: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="981522191a8758a2cf80c7f0915aa11eabaca13e" translate="yes" xml:space="preserve">
          <source>Here's the important part of the output.  I've annotated it with some comments indicating what's going on in the assembly language:</source>
          <target state="translated">Вот важная часть выхода.Я снабдил ее комментариями,указывающими на то,что происходит на языке ассемблера:</target>
        </trans-unit>
        <trans-unit id="1853745e32869f380edec4598bc3ef06f0430bde" translate="yes" xml:space="preserve">
          <source>Hope this can be useful.</source>
          <target state="translated">Надеюсь,это может пригодиться.</target>
        </trans-unit>
        <trans-unit id="85e39a3e78f49e60da31dbc9c4c7ab654a9d8ff7" translate="yes" xml:space="preserve">
          <source>I am doing some numerical optimization on a scientific application. One thing I noticed is that GCC will optimize the call &lt;code&gt;pow(a,2)&lt;/code&gt; by compiling it into &lt;code&gt;a*a&lt;/code&gt;, but the call &lt;code&gt;pow(a,6)&lt;/code&gt; is not optimized and will actually call the library function &lt;code&gt;pow&lt;/code&gt;, which greatly slows down the performance. (In contrast, &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_C++_Compiler&quot;&gt;Intel C++ Compiler&lt;/a&gt;, executable &lt;code&gt;icc&lt;/code&gt;, will eliminate the library call for &lt;code&gt;pow(a,6)&lt;/code&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я делаю некоторую числовую оптимизацию для научного приложения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Одна вещь, которую я заметил, заключается в том, что GCC оптимизирует вызов &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , скомпилировав его в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но вызов &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не оптимизируется и фактически вызовет библиотечную функцию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что значительно замедляет производительность. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Напротив, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_C++_Compiler&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;компилятор Intel C ++&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , исполняемый файл &lt;/font&gt;&lt;/font&gt; &lt;code&gt;icc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , исключит вызов библиотеки для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68e041c100d9c66ab0c3bcee649f2dba3fb13072" translate="yes" xml:space="preserve">
          <source>I was surprised to learn from the other answers that this expression could indeed be optimized with the proper compiler switches. Either the optimization is trivial, or it is an edge case of a much more common optimization, or the compiler writers were extremely thorough.</source>
          <target state="translated">Я с удивлением узнал из других ответов,что это выражение действительно можно оптимизировать с помощью соответствующих ключей компилятора.Либо оптимизация тривиальна,либо это крайний случай гораздо более распространенной оптимизации,либо писатели компилятора были предельно внимательны.</target>
        </trans-unit>
        <trans-unit id="8e52965681e9d8c31e55fa89df4f421c02c286ab" translate="yes" xml:space="preserve">
          <source>I would not have expected this case to be optimized at all. It can't be very often where an expression contains subexpressions that can be regrouped to remove entire operations. I would expect compiler writers to invest their time in areas which would be more likely to result in noticeable improvements, rather than covering a rarely encountered edge case.</source>
          <target state="translated">Я бы вообще не ожидал,что это дело будет оптимизировано.Не очень часто бывает так,что выражение содержит подвыражения,которые можно перегруппировать,чтобы удалить целые операции.Я бы ожидал,что писатели компилятора вложат свое время в те области,которые с большей вероятностью приведут к заметным улучшениям,а не к покрытию редко встречающегося краевого случая.</target>
        </trans-unit>
        <trans-unit id="03310089f35a8bb06c3934edfb960e33bebbf631" translate="yes" xml:space="preserve">
          <source>I'm using system GCC on Linux Mint 16 Petra, an Ubuntu derivative.  Here's the gcc version:</source>
          <target state="translated">Я использую систему GCC на Linux Mint 16 Petra,производную Ubuntu.Вот версия gcc:</target>
        </trans-unit>
        <trans-unit id="71a578b2882ad2932339e7108c7ed7c15ddeaa8e" translate="yes" xml:space="preserve">
          <source>If a compiler doesn't support this pragma, it must be conservative by avoiding any such optimization, in case the developer has chosen to set it to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если компилятор не поддерживает эту прагму, он должен быть консервативным, избегая любой такой оптимизации, в случае, если разработчик решил установить для нее значение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88c654fab2a03795d25bdf97b7e8f0998123d1d1" translate="yes" xml:space="preserve">
          <source>In general you know that for arbitrary floating point values &quot;pow&quot; has better accuracy than any function you could eventually write, but in some special cases multiple multiplications may have better accuracy and performance, it is up to the developer choosing what is more appropriate, eventually commenting the code so that noone else would &quot;optimize&quot; that code.</source>
          <target state="translated">В общем,вы знаете,что для произвольных значений с плавающей точкой &quot;pow&quot; имеет большую точность,чем любая функция,которую вы могли бы в конечном итоге написать,но в некоторых особых случаях множественные умножения могут иметь лучшую точность и производительность,именно разработчик выбирает то,что является более подходящим,в конечном итоге комментируя код так,чтобы никто другой не &quot;оптимизировал&quot; этот код.</target>
        </trans-unit>
        <trans-unit id="cc6d49616d403affbb828d1c957be55e63e50885" translate="yes" xml:space="preserve">
          <source>Library functions like &quot;pow&quot; are usually carefully crafted to yield the minimum possible error (in generic case). This is usually achieved approximating functions with splines (according to Pascal's comment the most common implementation seems to be using &lt;a href=&quot;https://en.wikipedia.org/wiki/Remez_algorithm&quot;&gt;Remez algorithm&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Библиотечные функции, такие как &amp;laquo;pow&amp;raquo;, обычно тщательно создаются для получения минимально возможной ошибки (в общем случае). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обычно это достигается аппроксимацией функций сплайнами (согласно комментарию Паскаля, наиболее распространенной реализацией является использование &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Remez_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;алгоритма Ремеза&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c6a32c2fef0ceb0b9c94cd7c9b0a92dc173bfc48" translate="yes" xml:space="preserve">
          <source>No posters have mentioned the contraction of floating expressions yet (ISO C standard, 6.5p8 and 7.12.2). If the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma is set to &lt;code&gt;ON&lt;/code&gt;, the compiler is allowed to regard an expression such as &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; as a single operation, as if evaluated exactly with a single rounding. For instance, a compiler may replace it by an internal power function that is both faster and more accurate. This is particularly interesting as the behavior is partly controlled by the programmer directly in the source code, while compiler options provided by the end user may sometimes be used incorrectly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ни один из авторов еще не упомянул о сокращении выражений с плавающей запятой (стандарт ISO C, 6.5p8 и 7.12.2). Если для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;FP_CONTRACT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; задано значение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , то компилятору разрешается рассматривать такое выражение, как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; как одну операцию, как если бы оно вычислялось точно с одним округлением. Например, компилятор может заменить его внутренней функцией power, которая является более быстрой и точной. Это особенно интересно, поскольку поведение частично контролируется программистом непосредственно в исходном коде, в то время как параметры компилятора, предоставляемые конечным пользователем, могут иногда использоваться неправильно.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95a717f5c6110339b6c63d4df7945ada42cd7db8" translate="yes" xml:space="preserve">
          <source>Note that GCC provides &lt;code&gt;__builtin_powi(x,n)&lt;/code&gt; as an alternative to &lt;code&gt;pow( )&lt;/code&gt;, which should generate an inline multiplication tree.  Use that if you want to trade off accuracy for performance, but do not want to enable fast-math.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что GCC предоставляет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;__builtin_powi(x,n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в качестве альтернативы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow( )&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , который должен генерировать встроенное дерево умножения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используйте это, если вы хотите поменять точность на производительность, но не хотите включать быструю математику.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94c760a7cba09a8bca02fa707bf827e1a8cc56ea" translate="yes" xml:space="preserve">
          <source>Should majority of programmers recognize (and be able to execute on) the idea that C expression a*a*a*a*a*a is not actually working with ideal numbers, the GCC compiler would then be FREE to optimize &quot;a*a*a*a*a*a&quot; into say &quot;t=(a*a); t*t*t&quot; which requires a smaller number of multiplications. But unfortunately, the GCC compiler does not know whether the programmer writing the code thinks that &quot;a&quot; is a number with or without an error. And so GCC will only do what the source code looks like - because that is what GCC sees with its &quot;naked eye&quot;.</source>
          <target state="translated">Если большинство программистов распознает (и сможет выполнить)идею,что выражение a*a*a*a*a*a на самом деле не работает с идеальными числами,то компилятор GCC будет БЕСПЛАТНО оптимизировать &quot;a*a*a*a*a&quot;,скажем,&quot;t=(a*a);t*t*t&quot;,что требует меньшего количества умножений.Но,к сожалению,компилятор GCC не знает,считает ли программист,пишущий код,что &quot;a&quot;-это число с ошибкой или без нее.И поэтому GCC будет делать только то,как выглядит исходный код-потому что GCC видит это &quot;невооруженным глазом&quot;.</target>
        </trans-unit>
        <trans-unit id="28ed3ac2704e149ae2dd87d11eccdff53fdf0451" translate="yes" xml:space="preserve">
          <source>Signed integers, as Peter Cordes pointed out in a comment, can do this optimization without &lt;code&gt;-funsafe-math-optimizations&lt;/code&gt; since it holds exactly when there is no overflow and if there is overflow you get undefined behavior. So you get</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Целые числа со &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-funsafe-math-optimizations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , как указал Питер Кордес в комментарии, могут выполнить эту оптимизацию без &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-funsafe-math-optimizations,&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поскольку она выполняется именно тогда, когда переполнения нет, а при переполнении вы получаете неопределенное поведение. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, вы получаете&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4dcee4d2845f68dd48259ec19ca5fa93c40dae90" translate="yes" xml:space="preserve">
          <source>Some years ago I was trying to make it more convenient to calculate integer powers in an optimal way, and came up with the following.  It's C++, not C though, and still depends on the compiler being somewhat smart about how to optimize/inline things. Anyway, hope you might find it useful in practice:</source>
          <target state="translated">Несколько лет назад я пытался сделать вычисление целочисленных степеней более удобным и придумал следующее.Это все-таки Си++,а не Си,и все равно зависит от умения компилятора оптимизировать в строке.В любом случае,надеюсь,что он окажется полезным на практике:</target>
        </trans-unit>
        <trans-unit id="f69c9a253137aba303e8ac403c17349ba850c078" translate="yes" xml:space="preserve">
          <source>That can be a pain to write, though; why can't the compiler just do [what you consider to be] the right thing when you use &lt;code&gt;pow(a,6)&lt;/code&gt;?  Because it would be the &lt;em&gt;wrong&lt;/em&gt; thing to do.  On a platform with a good math library, &lt;code&gt;pow(a,6)&lt;/code&gt; is significantly more accurate than either &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; or &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;.  Just to provide some data, I ran a small experiment on my Mac Pro, measuring the worst error in evaluating a^6 for all single-precision floating numbers between [1,2):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это может быть боль писать, хотя; почему компилятор не может просто [сделать то, что вы считаете] правильным, когда вы используете &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? Потому что это было бы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;неправильно&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . На платформе с хорошей математической библиотекой &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; значительно точнее, чем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Просто для того, чтобы предоставить некоторые данные, я провел небольшой эксперимент на своем Mac Pro, измеряя наихудшую ошибку при оценке ^ 6 для всех плавающих чисел одинарной точности между [1,2):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd79ee104a238b2bcbb0aefa26e43a29a96700ad" translate="yes" xml:space="preserve">
          <source>The compiler should be really carefull to the kind of optimization it is doing:</source>
          <target state="translated">Компилятор должен быть очень внимателен к выполняемой оптимизации:</target>
        </trans-unit>
        <trans-unit id="70f3ac8d17a4f4ef97f85ecb089f37ed70d7a2d4" translate="yes" xml:space="preserve">
          <source>The default state of the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma is implementation-defined, so that a compiler is allowed to do such optimizations by default. Thus portable code that needs to strictly follow the IEEE 754 rules should explicitly set it to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Состояние по умолчанию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;FP_CONTRACT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; определяется реализацией, поэтому компилятору разрешено выполнять такую ​​оптимизацию по умолчанию. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, переносимый код, который должен строго следовать правилам IEEE 754, должен явно установить для него значение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="032412492bf0d092f330b93773053935967db4a8" translate="yes" xml:space="preserve">
          <source>The only thing that make sense (personal opinion, and apparently a choice in GCC wichout any particular optimization or compiler flag) to optimize should be replacing &quot;pow(a,2)&quot; with &quot;a*a&quot;. That would be the only sane thing a compiler vendor should do.</source>
          <target state="translated">Единственное,что имеет смысл (личное мнение и,по-видимому,выбор в GCC в пользу какой-либо конкретной оптимизации или флага компилятора)для оптимизации,это замена &quot;pow(a,2)&quot; на &quot;a*a&quot;.Это было бы единственной разумной вещью,которую должен делать производитель компилятора.</target>
        </trans-unit>
        <trans-unit id="a622439a8bfbafc241f087dbbd072315176f64bb" translate="yes" xml:space="preserve">
          <source>Then just use it as &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тогда просто используйте это как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf492b55441273a0253418f344466dc73cd10073" translate="yes" xml:space="preserve">
          <source>There are a lot of gcc flags but nothing fancy.  They mean:  Read from stdin; use O2 optimization level; output assembly language listing instead of a binary; the listing should use Intel assembly language syntax; the input is in C language (usually language is inferred from input file extension, but there is no file extension when reading from stdin); and write to stdout.</source>
          <target state="translated">Есть много флагов Gcc,но ничего причудливого.Они имеют в виду:Чтение из stdin;использование уровня оптимизации O2;вывод листинга на ассемблере вместо бинарного;листинг должен использовать синтаксис языка ассемблера Intel;входной сигнал сделан на языке C (обычно язык выводится из расширения входного файла,но при чтении из stdin файл не имеет расширения);и запись в stdout.</target>
        </trans-unit>
        <trans-unit id="038c91abf47f7af8387f87881fe8c08dd6f3b995" translate="yes" xml:space="preserve">
          <source>There are already a few good answers to this question, but for the sake of completeness I wanted to point out that the applicable section of the C standard is 5.1.2.2.3/15 (which is the same as section 1.9/9 in the C++11 standard).  This section states that operators can only be regrouped if they are really associative or commutative.</source>
          <target state="translated">На этот вопрос уже есть несколько хороших ответов,но для полноты я хотел бы отметить,что применимым разделом стандарта С является 5.1.2.2.315 (что совпадает с разделом 1.99 в стандарте С++11).В этом разделе сказано,что операторы могут быть перегруппированы только в том случае,если они действительно ассоциативны или коммутативны.</target>
        </trans-unit>
        <trans-unit id="34a6090f4401ef36f9853e0c1580d3e4d38191d7" translate="yes" xml:space="preserve">
          <source>There's nothing wrong with providing hints to the compiler as you've done here. It's a normal and expected part of the micro-optimization process to rearrange statements and expressions to see what differences they will bring.</source>
          <target state="translated">Нет ничего плохого в том,чтобы дать подсказки компилятору,как вы сделали это здесь.Это нормальная и ожидаемая часть процесса микро-оптимизации-переставлять выражения и выражения,чтобы посмотреть,какие различия они принесут.</target>
        </trans-unit>
        <trans-unit id="f119f08c5c4dbeee8e65aa7456308d7e067dfe12" translate="yes" xml:space="preserve">
          <source>This is what I get from my compiler:</source>
          <target state="translated">Вот что я получаю от своего компилятора:</target>
        </trans-unit>
        <trans-unit id="f4fe0dbbf5143d55f866bd834ce8215252c70263" translate="yes" xml:space="preserve">
          <source>This makes it easy to type powers (no need to spell out 6 &lt;code&gt;a&lt;/code&gt;s with parens), and lets you have this kind of optimization without &lt;code&gt;-ffast-math&lt;/code&gt; in case you have something precision dependent such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation_algorithm&quot;&gt;compensated summation&lt;/a&gt; (an example where the order of operations is essential).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это позволяет легко набирать полномочия (не нужно прописывать 6 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; s с паренами) и позволяет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; этот вид оптимизации без &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-ffast-math&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в случае, если у вас есть что-то зависящее от точности, такое как &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;скомпенсированное суммирование&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (пример, где порядок операций имеет важное значение).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3a21c378f482fb7cba0b9dc669736cc20cdb3cd" translate="yes" xml:space="preserve">
          <source>This outputs &lt;code&gt;1.000000e-05 0.000000e+00&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это выводит &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1.000000e-05 0.000000e+00&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a954fcc81f3445fd1f1f16ee4798784fc70c5f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pow&lt;/code&gt; instead of a multiplication tree reduces the error bound by a &lt;em&gt;factor of 4&lt;/em&gt;.  Compilers should not (and generally do not) make &quot;optimizations&quot; that increase error unless licensed to do so by the user (e.g. via &lt;code&gt;-ffast-math&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Использование &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вместо дерева умножения уменьшает погрешность в &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4 раза&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Компиляторы не должны (и, как правило, не делают) делать &amp;laquo;оптимизации&amp;raquo;, которые увеличивают ошибку, если только у пользователя нет на это лицензии (например, через &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="02de4b219e179d76a6d96b22b18d1566e505141d" translate="yes" xml:space="preserve">
          <source>What I am curious about is that when I replaced &lt;code&gt;pow(a,6)&lt;/code&gt; with &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; using GCC 4.5.1 and options &quot;&lt;code&gt;-O3 -lm -funroll-loops -msse4&lt;/code&gt;&quot;, it uses 5 &lt;code&gt;mulsd&lt;/code&gt; instructions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что любопытно , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;о том , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;когда я заменил &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с помощью GCC 4.5.1 и опции &amp;laquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-O3 -lm -funroll-loops -msse4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;, он использует 5 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;инструкций &lt;/font&gt;&lt;/font&gt; &lt;code&gt;mulsd&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="019e7ae12d49514249ba5f50e9f30acbe61db21a" translate="yes" xml:space="preserve">
          <source>While the compiler may be justified in considering the two expressions to deliver inconsistent results (without the proper switches), there's no need for you to be bound by that restriction. The difference will be incredibly tiny - so much so that if the difference matters to you, you should not be using standard floating point arithmetic in the first place.</source>
          <target state="translated">Хотя компилятор может быть оправдан в рассмотрении двух выражений для получения несовместимых результатов (без соответствующих ключей),нет необходимости быть связанным этим ограничением.Разница будет невероятно маленькой-настолько,что если для вас важна разница,то не стоит использовать стандартную арифметику с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="cde544d42fbafa1f338764a2c2773d3ec5822639" translate="yes" xml:space="preserve">
          <source>While the following operation:</source>
          <target state="translated">Во время следующей операции:</target>
        </trans-unit>
        <trans-unit id="db94284baa6947e0b56737b3af7e707f25f8165c" translate="yes" xml:space="preserve">
          <source>Why do compilers not recognize this optimization trick?</source>
          <target state="translated">Почему компиляторы не распознают этот трюк оптимизации?</target>
        </trans-unit>
        <trans-unit id="b7d445e56ae3b3b51205e7428cddf177214a3a36" translate="yes" xml:space="preserve">
          <source>Why doesn't GCC optimize a*a*a*a*a*a to (a*a*a)*(a*a*a)</source>
          <target state="translated">Почему GCC не оптимизирует a*a*a*a*a*a до (a*a*a)*(a*a*a*a).</target>
        </trans-unit>
        <trans-unit id="5ed24af97064af0cd9ce60a3e5e0f869a731bf23" translate="yes" xml:space="preserve">
          <source>You can probably also forget that this is C++ and just use it in the C program (if it compiles with a C++ compiler).</source>
          <target state="translated">Наверное,также можно забыть,что это C++и просто использовать его в программе на Си (если он компилируется с помощью C++компилятора).</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="b700a3c7f4d2e0b51edf81e37c6548c3fcace4ed" translate="yes" xml:space="preserve">
          <source>fundamentally the following operation:</source>
          <target state="translated">в основном следующая операция:</target>
        </trans-unit>
        <trans-unit id="fb6edeecaf4ad3a1a421caf127f44a6e529f8f35" translate="yes" xml:space="preserve">
          <source>gcc actually can do this optimization, even for floating-point numbers. For example,</source>
          <target state="translated">gcc на самом деле может сделать эту оптимизацию,даже для чисел с плавающей точкой.Например,</target>
        </trans-unit>
        <trans-unit id="67297856c412ac15e2bf250ffaa0316856878b1f" translate="yes" xml:space="preserve">
          <source>has a inherent error of approximately the &lt;strong&gt;same magnitude as the error in any single multiplication or division&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;имеет присущую ошибку приблизительно такой &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;же величины, что и ошибка при любом одиночном умножении или делении&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75d90159c1ba5de1cab0baec48b5e1f3ec29a879" translate="yes" xml:space="preserve">
          <source>has a inherent error that is greater more than &lt;strong&gt;5 times the error of a single multiplication&lt;/strong&gt; or division (because you are combining 5 multiplications).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;имеет собственную ошибку, которая более чем в &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5 раз превышает ошибку одиночного умножения&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или деления (потому что вы комбинируете 5 умножений).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fda107f074252af4966e46b506713bd46dec57a" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;a*a*a*a*a*a&lt;/code&gt;  to &lt;code&gt;pow(a,6)&lt;/code&gt; it may actually reduce the accuracy because &quot;a&quot; was some special value that allows multiplication without error (a power of 2 or some small integer number)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;если оптимизировать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; к &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; это может фактически снизить точность, потому что &quot;a&quot; было некоторым специальным значением, которое позволяет умножение без ошибок (степень 2 или небольшое целое число)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf71e4ed346f57912a1e79b200383d8fa6c3fc01" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;pow(a,6)&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; or &lt;code&gt;(a*a)*(a*a)*(a*a)&lt;/code&gt; there still can be a loss of accuracy compared to &lt;code&gt;pow&lt;/code&gt; function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;если оптимизация &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a)*(a*a)*(a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; все еще может привести к потере точности по сравнению с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функцией &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cfec1f2de6ea415d4cf8ceedd8dcaca5c6ec2e8" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;pow(a,6)&lt;/code&gt; to &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; it &lt;strong&gt;may&lt;/strong&gt; improve performance, but drastically reduce the accuracy for floating point numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;если оптимизировать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; это &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;может&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; улучшить производительность, но значительно снизить точность для чисел с плавающей запятой.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fef10f56fa82200041ab99b1d4d2485b58462410" translate="yes" xml:space="preserve">
          <source>which reduces the number of multiply instructions to 3. &lt;code&gt;icc&lt;/code&gt; has similar behavior.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что уменьшает количество команд умножения до 3. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;icc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; имеет аналогичное поведение.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8cd4c1833209b82d692c0005ba1b92e7b7924368" translate="yes" xml:space="preserve">
          <source>while if I write &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;, it will produce</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в то время как если я напишу &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , он выдаст&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e99df94664796974ee5510f379629ed4b7b1e71" translate="yes" xml:space="preserve">
          <source>with &lt;code&gt;-O -funsafe-math-optimizations&lt;/code&gt;. This reordering violates IEEE-754, though, so it requires the flag.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-O -funsafe-math-optimizations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это переупорядочение нарушает IEEE-754, поэтому требует флаг.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a019b70a71456f8a761d32e12d9c417e7e1379b6" translate="yes" xml:space="preserve">
          <source>with just &lt;code&gt;-O&lt;/code&gt;. For unsigned integers, it's even easier since they work mod powers of 2 and so can be reordered freely even in the face of overflow.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;просто &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-O&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для целых чисел без знака это даже проще, так как они работают с модами степеней 2 и поэтому могут свободно переупорядочиваться даже при переполнении.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
