<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/6430448">
    <body>
      <group id="6430448">
        <trans-unit id="4d250087c10e817bb864c62232c3ce88493f0870" translate="yes" xml:space="preserve">
          <source>... once you know what kind of programmer &lt;em&gt;you&lt;/em&gt; are, you can use the &quot;-ffast-math&quot; switch to tell GCC that &quot;Hey, GCC, I know what I am doing!&quot;. This will allow GCC to convert a*a*a*a*a*a into a different piece of text - it looks different from a*a*a*a*a*a - but still computes a number within the error interval of a*a*a*a*a*a. This is OK, since you already know you are working with intervals, not ideal numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 어떤 프로그래머 알고 나면 ... &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신은&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 당신은 GCC를 말할 수있는 &quot;-ffast - 수학&quot;스위치를 사용할 수있다 &quot;이봐, GCC, 나는 내가 뭐하는 거지 알아!&quot;. 이를 통해 GCC는 a * a * a * a * a * a를 다른 텍스트 조각으로 변환 할 수 있습니다. a * a * a * a * a * a와는 다르게 보이지만 여전히 오류 간격 내에서 숫자를 계산합니다. a * a * a * a * a * a. 이상적인 숫자가 아닌 간격으로 작업하고 있다는 것을 이미 알고 있으므로 괜찮습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e601cb9e293c7f55858b9c7c9a8e1f3cfbbcf80f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/6430525/463065&quot;&gt;&lt;strong&gt;Lambdageek&lt;/strong&gt;&lt;/a&gt; correctly points out that because associativity does not hold for floating-point numbers, the &quot;optimization&quot; of &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; may change the value.  This is why it is disallowed by C99 (unless specifically allowed by the user, via compiler flag or pragma).  Generally, the assumption is that the programmer wrote what she did for a reason, and the compiler should respect that.  If you want &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;, write that.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/6430525/463065&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lambdageek은&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 제대로의 연관성은, 부동 소수점 숫자에 대해 &quot;최적화&quot;를 보유하지 않기 때문에 지적&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 변경 될 수 있습니다 가치. 이것이 C99에서 허용하지 않는 이유입니다 (컴파일러 플래그 또는 pragma를 통해 사용자가 특별히 허용하지 않는 한). 일반적으로 프로그래머는 자신이 한 이유로 자신이 한 일을 썼다는 것을 전제로하며, 컴파일러는이를 존중해야합니다. 당신이 원하는 경우&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 쓰기 것을.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3554b22e1fc90a354131abcb9d80400bf1e1fd41" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;strong&gt;Clarification for the curious:&lt;/strong&gt; this does not find the optimal way to compute powers, but since &lt;a href=&quot;http://en.wikipedia.org/wiki/Addition-chain_exponentiation&quot;&gt;finding the optimal solution is an NP-complete problem&lt;/a&gt; and this is only worth doing for small powers anyway (as opposed to using &lt;code&gt;pow&lt;/code&gt;), there's no reason to fuss with the detail.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;호기심에 대한 설명 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이것은 전력을 계산하는 최적의 방법을 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Addition-chain_exponentiation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;찾지&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 못하지만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최적의 솔루션을 찾는 것은 NP- 완전한 문제&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이므로 ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하는 것과는 달리) 작은 전력에 대해서만 가치가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있기 때문에 아무런 이유가 없습니다. 세부 사항으로 소란.&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="8ec2ebf132faa836164fcc84f4c1f54c2408fce2" translate="yes" xml:space="preserve">
          <source>Another similar case: most compilers won't optimize &lt;code&gt;a + b + c + d&lt;/code&gt; to &lt;code&gt;(a + b) + (c + d)&lt;/code&gt; (this is an optimization since the second expression can be pipelined better) and evaluate it as given (i.e. as &lt;code&gt;(((a + b) + c) + d)&lt;/code&gt;). This too is because of corner cases:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또 다른 유사한 경우 : 대부분의 컴파일러는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a + b + c + d&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a + b) + (c + d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 최적화하지 않으며 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 두 번째 표현식이 더 잘 파이프 라인 될 수 있기 때문에 최적화입니다) 주어진대로 평가합니다 (예 : 등 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(((a + b) + c) + d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 코너 케이스 때문입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c9a86236232165a7908c885e6e3608d6ebaa349" translate="yes" xml:space="preserve">
          <source>As Lambdageek pointed out float multiplication is not associative and you can get less accuracy, but also when get better accuracy you can argue against optimisation, because you want a deterministic application. For example in game simulation client/server, where every client has to simulate the same world you want floating point calculations to be deterministic.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lambdageek이 지적했듯이 float 곱셈은 연관성이 없으며 정확도는 떨어질 수 있지만 정확도가 높아지면 결정 론적 응용 프로그램을 원하기 때문에 최적화에 반대 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 게임 시뮬레이션 클라이언트 / 서버에서 모든 클라이언트는 부동 소수점 계산을 결정하기 원하는 동일한 세계를 시뮬레이션해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a878690db08938608264102fc103f5780dab6683" translate="yes" xml:space="preserve">
          <source>As a result, most compilers are very conservative about reordering floating point calculations unless they can be sure that the answer will stay the same, or unless you tell them you don't care about numerical accuracy.  For example: &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt;the &lt;code&gt;-fassociative-math&lt;/code&gt; option&lt;/a&gt; of gcc which allows gcc to reassociate floating point operations, or even the &lt;code&gt;-ffast-math&lt;/code&gt; option which allows even more aggressive tradeoffs of accuracy against speed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결과적으로, 대부분의 컴파일러는 응답이 동일하게 유지된다는 것을 확신 할 수 없거나 수치 정확도에 신경 쓰지 않는다고 말하지 않는 한 부동 소수점 계산을 재정렬하는 데 매우 보수적입니다. 예를 들어 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, gcc가 부동 소수점 연산을 재 &lt;/font&gt;&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt; &lt;code&gt;-fassociative-math&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 할 수있게하는 gcc &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-fassociative-math&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 옵션&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속도에 대한 정확성의 더욱 적극적인 절충을 허용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 옵션도 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1f7025a0a8653e90ed33ccd59a524411194bee3" translate="yes" xml:space="preserve">
          <source>As other posters have noted, this option is not possible in floating point, because floating point arithmetic is not associative.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 포스터에서 언급했듯이 부동 소수점 산술은 연관성이 없으므로 부동 소수점에서는이 옵션을 사용할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5cab4fa1adf07c1f4fab622ca0e1c9a2bbadc951" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems&quot;&gt;Floating Point Math is not Associative&lt;/a&gt;.  The way you group the operands in floating point multiplication has an effect on the numerical accuracy of the answer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;때문에 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부동 소수점 수학 연관되지 않습니다&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부동 소수점 곱셈에서 피연산자를 그룹화하는 방법은 답의 숫자 정확도에 영향을줍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac72a721d84b77b0b13d7bfd347c5a737d30b1ff" translate="yes" xml:space="preserve">
          <source>Because a 32-bit floating-point number - such as 1.024 - is not 1.024. In a computer, 1.024 is an interval: from (1.024-e) to (1.024+e), where &quot;e&quot; represents an error. Some people fail to realize this and also believe that * in a*a stands for multiplication of arbitrary-precision numbers without there being any errors attached to those numbers. The reason why some people fail to realize this is perhaps the math computations they exercised in elementary schools: working only with ideal numbers without errors attached, and believing that it is OK to simply ignore &quot;e&quot; while performing multiplication. They do not see the &quot;e&quot; implicit in &quot;float a=1.2&quot;, &quot;a*a*a&quot; and similar C codes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;32 비트 부동 소수점 숫자 (예 : 1.024)는 1.024가 아니기 때문입니다. 컴퓨터에서 1.024는 (1.024-e)에서 (1.024 + e)까지의 간격입니다. 여기서 &quot;e&quot;는 오류를 나타냅니다. 어떤 사람들은 이것을 깨닫지 못하고 또한 *에서 *는 임의의 정밀도 숫자의 곱셈을 의미하며 그 숫자에 오류가 없음을 믿습니다. 일부 사람들이 이것을 깨닫지 못하는 이유는 아마도 초등학교에서 연습 한 수학 계산 일 것입니다. 오류가없는 이상적인 숫자로만 작업하고 곱셈을 수행하는 동안 단순히 &quot;e&quot;를 무시해도된다고 믿기 때문입니다. &quot;float a = 1.2&quot;, &quot;a * a * a&quot;및 유사한 C 코드에 &quot;e&quot;가 암시되어 있지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fc0b3ee381fd7de113933bbc502a60dac899d423" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;옵션 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b62e31b37189d012f547a0a066099b50cab9e5ae" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a*a*a*a*a*a&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;들어 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac18e696c6c6f8d2010e80747b9e03f2cdd1dbfb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;용 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4c7cce855605e6a3df3d02aa3dd09fd1da9c306" translate="yes" xml:space="preserve">
          <source>Fortran (designed for scientific computing) has a built-in power operator, and as far as I know Fortran compilers will commonly optimize raising to integer powers in a similar fashion to what you describe.  C/C++ unfortunately don't have a power operator, only the library function &lt;code&gt;pow()&lt;/code&gt;.  This doesn't prevent smart compilers from treating &lt;code&gt;pow&lt;/code&gt; specially and computing it in a faster way for special cases, but it seems they do it less commonly ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Fortran (과학 컴퓨팅 용으로 설계됨)에는 전원 연산자가 내장되어 있으며, 내가 아는 한 Fortran 컴파일러는 일반적으로 설명하는 것과 비슷한 방식으로 정수 제곱을 올리는 것을 최적화합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;불행히도 C / C ++에는 거듭 제곱 연산자가없고 라이브러리 함수 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 똑똑한 컴파일러가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특수한 경우에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 특별하게 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;처리 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하고 더 빠른 방법으로 계산 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하는 것을 막지는 않지만 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, 덜 일반적으로하는 것처럼 보입니다 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="28395c97c243c9dc54c1873c68dbaf715650cbaa" translate="yes" xml:space="preserve">
          <source>GCC does actually optimize &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; when a is an integer.  I tried with this command:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a가 정수인 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 최적화 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는이 명령으로 시도했다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5cff5d070250d7e8684c02968fdc4cf5608e1d1a" translate="yes" xml:space="preserve">
          <source>GCC doesn't support this pragma, but with the default options, it assumes it to be &lt;code&gt;ON&lt;/code&gt;; thus for targets with a hardware FMA, if one wants to prevent the transformation &lt;code&gt;a*b+c&lt;/code&gt; to fma(a,b,c), one needs to provide an option such as &lt;code&gt;-ffp-contract=off&lt;/code&gt; (to explicitly set the pragma to &lt;code&gt;OFF&lt;/code&gt;) or &lt;code&gt;-std=c99&lt;/code&gt; (to tell GCC to conform to some C standard version, here C99, thus follow the above paragraph). In the past, the latter option was not preventing the transformation, meaning that GCC was not conforming on this point: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&quot;&gt;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC는이 pragma를 지원하지 않지만 기본 옵션에서는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ON&lt;/code&gt; 으로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가정합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 따라서 하드웨어 FMA가있는 대상의 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*b+c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 fma (a, b, c)로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffp-contract=off&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같은 옵션을 제공해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(프 래그 마를 명시 적으로 설정). 에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-std=c99&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (위의 단락을 수행하여, 여기에 몇 가지 C 표준 버전, C99을 준수하기 위해 GCC 말씀합니다). 과거에는 후자의 옵션이 변환을 방해하지 않았으므로 GCC 가이 시점에서 준수하지 않았 음을 의미합니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="981522191a8758a2cf80c7f0915aa11eabaca13e" translate="yes" xml:space="preserve">
          <source>Here's the important part of the output.  I've annotated it with some comments indicating what's going on in the assembly language:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;출력의 중요한 부분은 다음과 같습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어셈블리 언어로 무슨 일이 일어나고 있는지 나타내는 몇 가지 주석으로 주석을 달았습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1853745e32869f380edec4598bc3ef06f0430bde" translate="yes" xml:space="preserve">
          <source>Hope this can be useful.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 유용 할 수 있기를 바랍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85e39a3e78f49e60da31dbc9c4c7ab654a9d8ff7" translate="yes" xml:space="preserve">
          <source>I am doing some numerical optimization on a scientific application. One thing I noticed is that GCC will optimize the call &lt;code&gt;pow(a,2)&lt;/code&gt; by compiling it into &lt;code&gt;a*a&lt;/code&gt;, but the call &lt;code&gt;pow(a,6)&lt;/code&gt; is not optimized and will actually call the library function &lt;code&gt;pow&lt;/code&gt;, which greatly slows down the performance. (In contrast, &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_C++_Compiler&quot;&gt;Intel C++ Compiler&lt;/a&gt;, executable &lt;code&gt;icc&lt;/code&gt;, will eliminate the library call for &lt;code&gt;pow(a,6)&lt;/code&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;과학 응용 프로그램에서 수치 최적화를하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 주목 한 한 가지는 GCC가 호출 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 컴파일 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하여&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 최적화 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지만 호출 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 최적화되지 않았으며 실제로 라이브러리 함수 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 호출하여 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;크게 느려진다는 것입니다 성능. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반대로, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실행 가능한 &lt;/font&gt; &lt;code&gt;icc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 인 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_C++_Compiler&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Intel C ++ Compiler&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 라이브러리 호출을 제거합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68e041c100d9c66ab0c3bcee649f2dba3fb13072" translate="yes" xml:space="preserve">
          <source>I was surprised to learn from the other answers that this expression could indeed be optimized with the proper compiler switches. Either the optimization is trivial, or it is an edge case of a much more common optimization, or the compiler writers were extremely thorough.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 답변 에서이 표현이 실제로 적절한 컴파일러 스위치로 최적화 될 수 있다는 사실에 놀랐습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최적화가 사소한 것이거나 훨씬 일반적인 최적화의 경우이거나 컴파일러 작성자가 매우 철저했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8e52965681e9d8c31e55fa89df4f421c02c286ab" translate="yes" xml:space="preserve">
          <source>I would not have expected this case to be optimized at all. It can't be very often where an expression contains subexpressions that can be regrouped to remove entire operations. I would expect compiler writers to invest their time in areas which would be more likely to result in noticeable improvements, rather than covering a rarely encountered edge case.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 사례가 전혀 최적화되지 않았을 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;표현식에 전체 연산을 제거하기 위해 다시 그룹화 할 수있는 하위 표현식이 포함 된 경우가 종종 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;필자는 컴파일러 작성자가 거의 발생하지 않는 엣지 케이스를 다루지 않고 눈에 띄게 개선 될 수있는 영역에 시간을 투자 할 것으로 기대합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03310089f35a8bb06c3934edfb960e33bebbf631" translate="yes" xml:space="preserve">
          <source>I'm using system GCC on Linux Mint 16 Petra, an Ubuntu derivative.  Here's the gcc version:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우분투 파생물 인 Linux Mint 16 Petra에서 시스템 GCC를 사용하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;gcc 버전은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="71a578b2882ad2932339e7108c7ed7c15ddeaa8e" translate="yes" xml:space="preserve">
          <source>If a compiler doesn't support this pragma, it must be conservative by avoiding any such optimization, in case the developer has chosen to set it to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러가이 pragma를 지원하지 않으면 개발자가 해당 pragma를 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 설정하도록 선택한 경우 이러한 최적화를 피함으로써 보수적이어야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88c654fab2a03795d25bdf97b7e8f0998123d1d1" translate="yes" xml:space="preserve">
          <source>In general you know that for arbitrary floating point values &quot;pow&quot; has better accuracy than any function you could eventually write, but in some special cases multiple multiplications may have better accuracy and performance, it is up to the developer choosing what is more appropriate, eventually commenting the code so that noone else would &quot;optimize&quot; that code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 임의의 부동 소수점 값의 경우 &quot;pow&quot;는 궁극적으로 작성할 수있는 함수보다 정확도가 높지만 일부 특수한 경우 다중 곱셈의 정확도와 성능이 더 우수 할 수 있다는 것은 개발자의 결정에 달려 있습니다. 결국 아무도 코드를 &quot;최적화&quot;하지 않도록 코드에 주석을 답니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc6d49616d403affbb828d1c957be55e63e50885" translate="yes" xml:space="preserve">
          <source>Library functions like &quot;pow&quot; are usually carefully crafted to yield the minimum possible error (in generic case). This is usually achieved approximating functions with splines (according to Pascal's comment the most common implementation seems to be using &lt;a href=&quot;https://en.wikipedia.org/wiki/Remez_algorithm&quot;&gt;Remez algorithm&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;pow&quot;와 같은 라이브러리 함수는 일반적으로 가능한 최소 오류 (일반적인 경우)를 생성하기 위해 신중하게 작성됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 일반적으로 스플라인으로 함수를 근사화합니다 (Pascal의 의견에 따르면 가장 일반적인 구현은 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Remez_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Remez 알고리즘을&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하는 것 같습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c6a32c2fef0ceb0b9c94cd7c9b0a92dc173bfc48" translate="yes" xml:space="preserve">
          <source>No posters have mentioned the contraction of floating expressions yet (ISO C standard, 6.5p8 and 7.12.2). If the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma is set to &lt;code&gt;ON&lt;/code&gt;, the compiler is allowed to regard an expression such as &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; as a single operation, as if evaluated exactly with a single rounding. For instance, a compiler may replace it by an internal power function that is both faster and more accurate. This is particularly interesting as the behavior is partly controlled by the programmer directly in the source code, while compiler options provided by the end user may sometimes be used incorrectly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;플로팅 표현식의 수축에 대해서는 아직 언급 한 포스터가 없습니다 (ISO C 표준, 6.5p8 및 7.12.2). 경우] &lt;/font&gt;&lt;/font&gt; &lt;code&gt;FP_CONTRACT&lt;/code&gt; 의&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 프라그로 설정 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 컴파일러는 같은 식 간주시킨다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 번의 라운딩 정확하게 평가할 것과 같은 하나의 동작. 예를 들어, 컴파일러는 더 빠르고 정확한 내부 전력 함수로이를 대체 할 수 있습니다. 이는 최종 사용자가 제공 한 컴파일러 옵션이 때때로 잘못 사용될 수 있지만 동작은 소스 코드에서 프로그래머가 직접 동작을 부분적으로 제어하기 때문에 특히 흥미 롭습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95a717f5c6110339b6c63d4df7945ada42cd7db8" translate="yes" xml:space="preserve">
          <source>Note that GCC provides &lt;code&gt;__builtin_powi(x,n)&lt;/code&gt; as an alternative to &lt;code&gt;pow( )&lt;/code&gt;, which should generate an inline multiplication tree.  Use that if you want to trade off accuracy for performance, but do not want to enable fast-math.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;__builtin_powi(x,n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow( )&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대신 제공 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하며 인라인 곱셈 트리를 생성해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;성능의 정확성을 떨어 뜨리고 싶지만 빠른 계산을 사용하지 않으려는 경우에 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94c760a7cba09a8bca02fa707bf827e1a8cc56ea" translate="yes" xml:space="preserve">
          <source>Should majority of programmers recognize (and be able to execute on) the idea that C expression a*a*a*a*a*a is not actually working with ideal numbers, the GCC compiler would then be FREE to optimize &quot;a*a*a*a*a*a&quot; into say &quot;t=(a*a); t*t*t&quot; which requires a smaller number of multiplications. But unfortunately, the GCC compiler does not know whether the programmer writing the code thinks that &quot;a&quot; is a number with or without an error. And so GCC will only do what the source code looks like - because that is what GCC sees with its &quot;naked eye&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 프로그래머가 C 표현식 a * a * a * a * a * a가 실제로 이상적인 숫자와 함께 작동하지 않는다는 생각을 인식하고 실행할 수 있다면 GCC 컴파일러는 &quot;a * a를 최적화 할 수 있습니다. * a * a * a * a &quot;는&quot;t = (a * a); t * t * t &quot;로 말하면 더 적은 수의 곱셈이 필요합니다. 그러나 불행히도 GCC 컴파일러는 코드를 작성하는 프로그래머가 &quot;a&quot;가 오류가 있거나없는 숫자라고 생각하는지 여부를 알지 못합니다. 따라서 GCC는 소스 코드의 모양 만 수행합니다. GCC는 &quot;네이 키드 아이&quot;로 보는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="28ed3ac2704e149ae2dd87d11eccdff53fdf0451" translate="yes" xml:space="preserve">
          <source>Signed integers, as Peter Cordes pointed out in a comment, can do this optimization without &lt;code&gt;-funsafe-math-optimizations&lt;/code&gt; since it holds exactly when there is no overflow and if there is overflow you get undefined behavior. So you get</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Peter Cordes가 주석에서 지적했듯이 부호있는 정수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 오버플로가 없을 때 정확하게 보유하고 오버플로가있는 경우 정의되지 않은 동작을 얻으 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-funsafe-math-optimizations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 최적화를 수행 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서 당신은 얻을&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4dcee4d2845f68dd48259ec19ca5fa93c40dae90" translate="yes" xml:space="preserve">
          <source>Some years ago I was trying to make it more convenient to calculate integer powers in an optimal way, and came up with the following.  It's C++, not C though, and still depends on the compiler being somewhat smart about how to optimize/inline things. Anyway, hope you might find it useful in practice:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;몇 년 전에 나는 최적의 방법으로 정수 전력을 더 편리하게 계산하려고 노력했으며 다음을 생각해 냈습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 C가 아니라 C ++이며 여전히 최적화 / 인라인 방법에 대해 다소 똑똑한 컴파일러에 달려 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어쨌든, 실제로 유용하게 사용될 수 있기를 바랍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f69c9a253137aba303e8ac403c17349ba850c078" translate="yes" xml:space="preserve">
          <source>That can be a pain to write, though; why can't the compiler just do [what you consider to be] the right thing when you use &lt;code&gt;pow(a,6)&lt;/code&gt;?  Because it would be the &lt;em&gt;wrong&lt;/em&gt; thing to do.  On a platform with a good math library, &lt;code&gt;pow(a,6)&lt;/code&gt; is significantly more accurate than either &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; or &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;.  Just to provide some data, I ran a small experiment on my Mac Pro, measuring the worst error in evaluating a^6 for all single-precision floating numbers between [1,2):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지만 글을 쓰는 것은 고통 스러울 수 있습니다. 왜 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 사용할 때 컴파일러가 올바른 것으로 생각할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;없는가? 그렇게하는 것이 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;잘못&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 되기 때문입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 수학 라이브러리가 좋은 플랫폼에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 보다 훨씬 더 정확합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 일부 데이터를 제공하기 위해 Mac Pro에서 작은 실험을 수행하여 [1,2) 사이의 모든 단 정밀도 부동 숫자에 대해 a ^ 6을 평가할 때 최악의 오류를 측정했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd79ee104a238b2bcbb0aefa26e43a29a96700ad" translate="yes" xml:space="preserve">
          <source>The compiler should be really carefull to the kind of optimization it is doing:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러는 수행하는 최적화 종류에주의해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70f3ac8d17a4f4ef97f85ecb089f37ed70d7a2d4" translate="yes" xml:space="preserve">
          <source>The default state of the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma is implementation-defined, so that a compiler is allowed to do such optimizations by default. Thus portable code that needs to strictly follow the IEEE 754 rules should explicitly set it to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;FP_CONTRACT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; pragma &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 기본 상태 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 구현에 따라 정의되므로 컴파일러는 기본적으로 이러한 최적화를 수행 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 IEEE 754 규칙을 엄격하게 준수해야하는 이식 가능한 코드는 명시 적으로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 설정해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="032412492bf0d092f330b93773053935967db4a8" translate="yes" xml:space="preserve">
          <source>The only thing that make sense (personal opinion, and apparently a choice in GCC wichout any particular optimization or compiler flag) to optimize should be replacing &quot;pow(a,2)&quot; with &quot;a*a&quot;. That would be the only sane thing a compiler vendor should do.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최적화하기 위해 (개인의 의견, 그리고 특정 최적화 또는 컴파일러 플래그를 제외하고는 GCC에서 분명히 선택) 유일한 것은 &quot;pow (a, 2)&quot;를 &quot;a * a&quot;로 바꾸는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 컴파일러 벤더가해야 할 유일한 제정신 일입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a622439a8bfbafc241f087dbbd072315176f64bb" translate="yes" xml:space="preserve">
          <source>Then just use it as &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf492b55441273a0253418f344466dc73cd10073" translate="yes" xml:space="preserve">
          <source>There are a lot of gcc flags but nothing fancy.  They mean:  Read from stdin; use O2 optimization level; output assembly language listing instead of a binary; the listing should use Intel assembly language syntax; the input is in C language (usually language is inferred from input file extension, but there is no file extension when reading from stdin); and write to stdout.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;gcc 플래그는 많지만 멋진 것은 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그들은 의미한다 : stdin에서 읽는다; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O2 최적화 수준을 사용하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 대신 출력 어셈블리 언어 목록; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;리스팅은 인텔 어셈블리 언어 구문을 사용해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입력은 C 언어입니다 (일반적으로 언어는 입력 파일 확장자에서 유추되지만 stdin에서 읽을 때 파일 확장자는 없습니다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 stdout에 씁니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="038c91abf47f7af8387f87881fe8c08dd6f3b995" translate="yes" xml:space="preserve">
          <source>There are already a few good answers to this question, but for the sake of completeness I wanted to point out that the applicable section of the C standard is 5.1.2.2.3/15 (which is the same as section 1.9/9 in the C++11 standard).  This section states that operators can only be regrouped if they are really associative or commutative.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 질문에 대한 몇 가지 좋은 답변이 있지만 완전성을 기하기 위해 C 표준의 해당 섹션이 5.1.2.2.3 / 15 (1.9 / 9의 섹션 1.9 / 9와 동일 함)를 지적하고 싶었습니다. C ++ 11 표준). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 섹션에서는 연산자가 실제로 연관되거나 정식 인 경우에만 연산자를 다시 그룹화 할 수 있다고 설명합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="34a6090f4401ef36f9853e0c1580d3e4d38191d7" translate="yes" xml:space="preserve">
          <source>There's nothing wrong with providing hints to the compiler as you've done here. It's a normal and expected part of the micro-optimization process to rearrange statements and expressions to see what differences they will bring.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기에서 한 것처럼 컴파일러에 힌트를 제공하는 데 아무런 문제가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;명령문과 표현식을 재 배열하여 차이점이 무엇인지 확인하는 것이 마이크로 최적화 프로세스의 정상적이고 예상되는 부분입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f119f08c5c4dbeee8e65aa7456308d7e067dfe12" translate="yes" xml:space="preserve">
          <source>This is what I get from my compiler:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 내 컴파일러에서 얻는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4fe0dbbf5143d55f866bd834ce8215252c70263" translate="yes" xml:space="preserve">
          <source>This makes it easy to type powers (no need to spell out 6 &lt;code&gt;a&lt;/code&gt;s with parens), and lets you have this kind of optimization without &lt;code&gt;-ffast-math&lt;/code&gt; in case you have something precision dependent such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation_algorithm&quot;&gt;compensated summation&lt;/a&gt; (an example where the order of operations is essential).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 쉽게 (6 철자를 필요 권한을 입력하지 할 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;괄호로들), 그리고 당신이없이 최적화의이 종류가 있습니다 &lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 부양 등 뭔가 정밀도가 경우에 &lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보상 요약&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (예를 들어 순서를 작업이 필수적입니다).&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3a21c378f482fb7cba0b9dc669736cc20cdb3cd" translate="yes" xml:space="preserve">
          <source>This outputs &lt;code&gt;1.000000e-05 0.000000e+00&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 &lt;/font&gt; &lt;code&gt;1.000000e-05 0.000000e+00&lt;/code&gt; 을&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 출력합니다&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4a954fcc81f3445fd1f1f16ee4798784fc70c5f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pow&lt;/code&gt; instead of a multiplication tree reduces the error bound by a &lt;em&gt;factor of 4&lt;/em&gt;.  Compilers should not (and generally do not) make &quot;optimizations&quot; that increase error unless licensed to do so by the user (e.g. via &lt;code&gt;-ffast-math&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;곱셈 트리 대신 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면 오차 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 오차가 줄어 듭니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러는 사용자가 라이센스를 부여하지 않은 경우 (예 : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 통해) 오류를 증가시키는 &quot;최적화&quot;를 수행해서는 안됩니다 (일반적으로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="02de4b219e179d76a6d96b22b18d1566e505141d" translate="yes" xml:space="preserve">
          <source>What I am curious about is that when I replaced &lt;code&gt;pow(a,6)&lt;/code&gt; with &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; using GCC 4.5.1 and options &quot;&lt;code&gt;-O3 -lm -funroll-loops -msse4&lt;/code&gt;&quot;, it uses 5 &lt;code&gt;mulsd&lt;/code&gt; instructions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;궁금한 점은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC 4.5.1 및 옵션 &quot; &lt;/font&gt; &lt;code&gt;-O3 -lm -funroll-loops -msse4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하여 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대체&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하면 5 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;mulsd&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 지침 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="019e7ae12d49514249ba5f50e9f30acbe61db21a" translate="yes" xml:space="preserve">
          <source>While the compiler may be justified in considering the two expressions to deliver inconsistent results (without the proper switches), there's no need for you to be bound by that restriction. The difference will be incredibly tiny - so much so that if the difference matters to you, you should not be using standard floating point arithmetic in the first place.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일관된 결과없이 일관된 결과를 제공하기 위해 두 표현식을 고려할 때 컴파일러가 정당화 될 수 있지만, 그러한 제한에 구속 될 필요는 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 차이는 엄청나게 작을 것입니다. 그래서 그 차이가 당신에게 중요하다면, 표준 부동 소수점 산술을 사용해서는 안됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cde544d42fbafa1f338764a2c2773d3ec5822639" translate="yes" xml:space="preserve">
          <source>While the following operation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 작업 중 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db94284baa6947e0b56737b3af7e707f25f8165c" translate="yes" xml:space="preserve">
          <source>Why do compilers not recognize this optimization trick?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러가이 최적화 트릭을 인식하지 못하는 이유는 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b7d445e56ae3b3b51205e7428cddf177214a3a36" translate="yes" xml:space="preserve">
          <source>Why doesn't GCC optimize a*a*a*a*a*a to (a*a*a)*(a*a*a)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC가 a * a * a * a * a * a를 (a * a * a) * (a * a * a)로 최적화하지 않는 이유&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5ed24af97064af0cd9ce60a3e5e0f869a731bf23" translate="yes" xml:space="preserve">
          <source>You can probably also forget that this is C++ and just use it in the C program (if it compiles with a C++ compiler).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아마도 이것이 C ++임을 잊어 버릴 수 있으며 C 프로그램에서 사용하십시오 (C ++ 컴파일러로 컴파일하는 경우).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="b700a3c7f4d2e0b51edf81e37c6548c3fcace4ed" translate="yes" xml:space="preserve">
          <source>fundamentally the following operation:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 다음 작업 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb6edeecaf4ad3a1a421caf127f44a6e529f8f35" translate="yes" xml:space="preserve">
          <source>gcc actually can do this optimization, even for floating-point numbers. For example,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;gcc는 실제로 부동 소수점 숫자에도이 최적화를 수행 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67297856c412ac15e2bf250ffaa0316856878b1f" translate="yes" xml:space="preserve">
          <source>has a inherent error of approximately the &lt;strong&gt;same magnitude as the error in any single multiplication or division&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단일 곱셈 또는 나눗셈의 오차와&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대략 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;같은 크기&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 고유 오차가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75d90159c1ba5de1cab0baec48b5e1f3ec29a879" translate="yes" xml:space="preserve">
          <source>has a inherent error that is greater more than &lt;strong&gt;5 times the error of a single multiplication&lt;/strong&gt; or division (because you are combining 5 multiplications).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5 곱셈을 결합하기 때문에 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단일 곱셈&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 나눗셈 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오류의 5 배&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이상인 고유 오류가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fda107f074252af4966e46b506713bd46dec57a" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;a*a*a*a*a*a&lt;/code&gt;  to &lt;code&gt;pow(a,6)&lt;/code&gt; it may actually reduce the accuracy because &quot;a&quot; was some special value that allows multiplication without error (a power of 2 or some small integer number)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 최적화 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;a&quot;는 실수없이 곱셈을 허용하는 특별한 값 (2의 거듭 제곱 또는 작은 정수)이므로 실제로 정확도를 떨어 뜨릴 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf71e4ed346f57912a1e79b200383d8fa6c3fc01" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;pow(a,6)&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; or &lt;code&gt;(a*a)*(a*a)*(a*a)&lt;/code&gt; there still can be a loss of accuracy compared to &lt;code&gt;pow&lt;/code&gt; function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a)*(a*a)*(a*a)&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 최적화하면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여전히 정확도 손실이 발생할 수 있습니다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기능 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;과 비교 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cfec1f2de6ea415d4cf8ceedd8dcaca5c6ec2e8" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;pow(a,6)&lt;/code&gt; to &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; it &lt;strong&gt;may&lt;/strong&gt; improve performance, but drastically reduce the accuracy for floating point numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최적화하는 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 향상 성능,하지만 크게 부동 소수점 숫자의 정확성을 줄일 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fef10f56fa82200041ab99b1d4d2485b58462410" translate="yes" xml:space="preserve">
          <source>which reduces the number of multiply instructions to 3. &lt;code&gt;icc&lt;/code&gt; has similar behavior.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;곱하기 명령어의 수를 3으로 줄입니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;icc&lt;/code&gt; 의&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 동작은 비슷합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8cd4c1833209b82d692c0005ba1b92e7b7924368" translate="yes" xml:space="preserve">
          <source>while if I write &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;, it will produce</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 작성하는 경우 동안 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 그것은 생산합니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e99df94664796974ee5510f379629ed4b7b1e71" translate="yes" xml:space="preserve">
          <source>with &lt;code&gt;-O -funsafe-math-optimizations&lt;/code&gt;. This reordering violates IEEE-754, though, so it requires the flag.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-O -funsafe-math-optimizations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 재정렬은 IEEE-754를 위반하므로 플래그가 필요합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a019b70a71456f8a761d32e12d9c417e7e1379b6" translate="yes" xml:space="preserve">
          <source>with just &lt;code&gt;-O&lt;/code&gt;. For unsigned integers, it's even easier since they work mod powers of 2 and so can be reordered freely even in the face of overflow.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단지와 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-O&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부호없는 정수의 경우, 2의 거듭 제곱으로 작동하기 때문에 훨씬 쉬우므로 오버플로가 발생하더라도 자유롭게 재정렬 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
