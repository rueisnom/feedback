<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/6430448">
    <body>
      <group id="6430448">
        <trans-unit id="4d250087c10e817bb864c62232c3ce88493f0870" translate="yes" xml:space="preserve">
          <source>... once you know what kind of programmer &lt;em&gt;you&lt;/em&gt; are, you can use the &quot;-ffast-math&quot; switch to tell GCC that &quot;Hey, GCC, I know what I am doing!&quot;. This will allow GCC to convert a*a*a*a*a*a into a different piece of text - it looks different from a*a*a*a*a*a - but still computes a number within the error interval of a*a*a*a*a*a. This is OK, since you already know you are working with intervals, not ideal numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;......一旦你知道那种程序员的是什么&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，你&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是，你可以使用&amp;ldquo;-ffast -数学&amp;rdquo;开关告诉GCC说：&amp;ldquo;嘿，GCC，我知道我在做什么！&amp;rdquo;。这将允许GCC将a * a * a * a * a * a转换为不同的文本-它看起来与a * a * a * a * a * a * a不同-但仍会在的错误间隔内计算数字a * a * a * a * a * a。可以，因为您已经知道自己正在使用间隔而不是理想数字。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e601cb9e293c7f55858b9c7c9a8e1f3cfbbcf80f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/6430525/463065&quot;&gt;&lt;strong&gt;Lambdageek&lt;/strong&gt;&lt;/a&gt; correctly points out that because associativity does not hold for floating-point numbers, the &quot;optimization&quot; of &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; may change the value.  This is why it is disallowed by C99 (unless specifically allowed by the user, via compiler flag or pragma).  Generally, the assumption is that the programmer wrote what she did for a reason, and the compiler should respect that.  If you want &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;, write that.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/6430525/463065&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lambdageek&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正确指出，由于浮点数不具有关联性，因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&amp;ldquo;优化&amp;rdquo;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能会改变价值。这就是C99禁止使用它的原因（除非用户明确允许，通过编译器标志或编译指示）。通常，假定程序员是出于某种原因写了她所做的事情，而编译器应该尊重这一点。如果要&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，请写下。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3554b22e1fc90a354131abcb9d80400bf1e1fd41" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;strong&gt;Clarification for the curious:&lt;/strong&gt; this does not find the optimal way to compute powers, but since &lt;a href=&quot;http://en.wikipedia.org/wiki/Addition-chain_exponentiation&quot;&gt;finding the optimal solution is an NP-complete problem&lt;/a&gt; and this is only worth doing for small powers anyway (as opposed to using &lt;code&gt;pow&lt;/code&gt;), there's no reason to fuss with the detail.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为好奇而澄清：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这并没有找到计算幂的最佳方法，但是由于&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Addition-chain_exponentiation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;找到最佳解是一个NP完全问题，&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且无论如何，这仅适合于小幂（与使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相对&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），因此没有理由对细节大惊小怪。&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="8ec2ebf132faa836164fcc84f4c1f54c2408fce2" translate="yes" xml:space="preserve">
          <source>Another similar case: most compilers won't optimize &lt;code&gt;a + b + c + d&lt;/code&gt; to &lt;code&gt;(a + b) + (c + d)&lt;/code&gt; (this is an optimization since the second expression can be pipelined better) and evaluate it as given (i.e. as &lt;code&gt;(((a + b) + c) + d)&lt;/code&gt;). This too is because of corner cases:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一个类似的情况：大多数编译器不会将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a + b + c + d&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a + b) + (c + d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（这是一种优化，因为可以更好地对第二个表达式进行流水线处理）并按给定的方式对其求值（即如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(((a + b) + c) + d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这也是由于极端情况：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c9a86236232165a7908c885e6e3608d6ebaa349" translate="yes" xml:space="preserve">
          <source>As Lambdageek pointed out float multiplication is not associative and you can get less accuracy, but also when get better accuracy you can argue against optimisation, because you want a deterministic application. For example in game simulation client/server, where every client has to simulate the same world you want floating point calculations to be deterministic.</source>
          <target state="translated">正如Lambdageek所指出的,浮点乘法不是联想的,你可以获得较低的精度,但当获得较高的精度时,你也可以反驳优化,因为你想要一个确定性的应用。比如在游戏模拟客户端服务器中,每个客户端都要模拟同一个世界,你希望浮点计算是确定性的。</target>
        </trans-unit>
        <trans-unit id="a878690db08938608264102fc103f5780dab6683" translate="yes" xml:space="preserve">
          <source>As a result, most compilers are very conservative about reordering floating point calculations unless they can be sure that the answer will stay the same, or unless you tell them you don't care about numerical accuracy.  For example: &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt;the &lt;code&gt;-fassociative-math&lt;/code&gt; option&lt;/a&gt; of gcc which allows gcc to reassociate floating point operations, or even the &lt;code&gt;-ffast-math&lt;/code&gt; option which allows even more aggressive tradeoffs of accuracy against speed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;结果，大多数编译器在对浮点计算进行重新排序时非常保守，除非他们可以确保答案保持不变，或者除非您告诉他们您不关心数值精度。例如：&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;gcc &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-fassociative-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;选项&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;允许gcc重新关联浮点运算，甚至&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;选项允许更加精确地权衡速度。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1f7025a0a8653e90ed33ccd59a524411194bee3" translate="yes" xml:space="preserve">
          <source>As other posters have noted, this option is not possible in floating point, because floating point arithmetic is not associative.</source>
          <target state="translated">正如其他发帖者所指出的,这个选项在浮点运算中是不可能的,因为浮点运算不是联想的。</target>
        </trans-unit>
        <trans-unit id="5cab4fa1adf07c1f4fab622ca0e1c9a2bbadc951" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems&quot;&gt;Floating Point Math is not Associative&lt;/a&gt;.  The way you group the operands in floating point multiplication has an effect on the numerical accuracy of the answer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮点数学不是关联的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以浮点乘法对操作数进行分组的方式会影响答案的数值精度。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac72a721d84b77b0b13d7bfd347c5a737d30b1ff" translate="yes" xml:space="preserve">
          <source>Because a 32-bit floating-point number - such as 1.024 - is not 1.024. In a computer, 1.024 is an interval: from (1.024-e) to (1.024+e), where &quot;e&quot; represents an error. Some people fail to realize this and also believe that * in a*a stands for multiplication of arbitrary-precision numbers without there being any errors attached to those numbers. The reason why some people fail to realize this is perhaps the math computations they exercised in elementary schools: working only with ideal numbers without errors attached, and believing that it is OK to simply ignore &quot;e&quot; while performing multiplication. They do not see the &quot;e&quot; implicit in &quot;float a=1.2&quot;, &quot;a*a*a&quot; and similar C codes.</source>
          <target state="translated">因为一个32位的浮点数--比如1.024,并不是1.024。在计算机中,1.024是一个区间:从(1.024-e)到(1.024+e),其中 &quot;e &quot;代表错误。有些人没有意识到这一点,还认为a*a中的*代表任意精度的数字的乘法,而这些数字上并没有附加任何误差。有些人没有意识到这一点的原因,可能是他们在小学时练习的数学计算方法:只用理想数进行运算,不附加任何错误,认为在进行乘法运算时,只需忽略 &quot;e &quot;即可。他们没有看到 &quot;浮动a=1.2&quot;、&quot;a*a*a &quot;和类似的C代码中隐含的 &quot;e&quot;。</target>
        </trans-unit>
        <trans-unit id="fc0b3ee381fd7de113933bbc502a60dac899d423" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b62e31b37189d012f547a0a066099b50cab9e5ae" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a*a*a*a*a*a&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac18e696c6c6f8d2010e80747b9e03f2cdd1dbfb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4c7cce855605e6a3df3d02aa3dd09fd1da9c306" translate="yes" xml:space="preserve">
          <source>Fortran (designed for scientific computing) has a built-in power operator, and as far as I know Fortran compilers will commonly optimize raising to integer powers in a similar fashion to what you describe.  C/C++ unfortunately don't have a power operator, only the library function &lt;code&gt;pow()&lt;/code&gt;.  This doesn't prevent smart compilers from treating &lt;code&gt;pow&lt;/code&gt; specially and computing it in a faster way for special cases, but it seems they do it less commonly ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Fortran（专为科学计算而设计）具有内置的幂运算符，据我所知，Fortran编译器通常会以与您所描述的相似的方式来优化对整数幂的提升。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不幸的是，C / C ++没有幂运算符，只有库函数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这不会阻止智能编译器对&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; 进行&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特殊处理，并在特殊情况下以更快的方式对其进行计算，但是似乎它们不那么常用...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="28395c97c243c9dc54c1873c68dbaf715650cbaa" translate="yes" xml:space="preserve">
          <source>GCC does actually optimize &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; when a is an integer.  I tried with this command:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当a为整数时，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC实际上确实将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; 优化&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我尝试使用以下命令：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5cff5d070250d7e8684c02968fdc4cf5608e1d1a" translate="yes" xml:space="preserve">
          <source>GCC doesn't support this pragma, but with the default options, it assumes it to be &lt;code&gt;ON&lt;/code&gt;; thus for targets with a hardware FMA, if one wants to prevent the transformation &lt;code&gt;a*b+c&lt;/code&gt; to fma(a,b,c), one needs to provide an option such as &lt;code&gt;-ffp-contract=off&lt;/code&gt; (to explicitly set the pragma to &lt;code&gt;OFF&lt;/code&gt;) or &lt;code&gt;-std=c99&lt;/code&gt; (to tell GCC to conform to some C standard version, here C99, thus follow the above paragraph). In the past, the latter option was not preventing the transformation, meaning that GCC was not conforming on this point: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&quot;&gt;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC不支持此编译指示，但是使用默认选项时，它会假定它为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;；因此，对于具有硬件FMA的目标，如果要防止将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*b+c&lt;/code&gt; 转换&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为fma（a，b，c），则需要提供&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffp-contract=off&lt;/code&gt; 之&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类的选项&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（以明确设置编译指示到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-std=c99&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（以告知GCC符合某些C标准版本，此处为C99，因此遵循上一段）。过去，后一种选择不会阻止转换，这意味着GCC在这一点上不符合要求：&lt;/font&gt;&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//gcc.gnu.org/bugzilla/show_bug.cgi？id = 37845&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="981522191a8758a2cf80c7f0915aa11eabaca13e" translate="yes" xml:space="preserve">
          <source>Here's the important part of the output.  I've annotated it with some comments indicating what's going on in the assembly language:</source>
          <target state="translated">下面是输出的重要部分。我在上面标注了一些注释,指出了汇编语言中发生的事情。</target>
        </trans-unit>
        <trans-unit id="1853745e32869f380edec4598bc3ef06f0430bde" translate="yes" xml:space="preserve">
          <source>Hope this can be useful.</source>
          <target state="translated">希望能对你有所帮助。</target>
        </trans-unit>
        <trans-unit id="85e39a3e78f49e60da31dbc9c4c7ab654a9d8ff7" translate="yes" xml:space="preserve">
          <source>I am doing some numerical optimization on a scientific application. One thing I noticed is that GCC will optimize the call &lt;code&gt;pow(a,2)&lt;/code&gt; by compiling it into &lt;code&gt;a*a&lt;/code&gt;, but the call &lt;code&gt;pow(a,6)&lt;/code&gt; is not optimized and will actually call the library function &lt;code&gt;pow&lt;/code&gt;, which greatly slows down the performance. (In contrast, &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_C++_Compiler&quot;&gt;Intel C++ Compiler&lt;/a&gt;, executable &lt;code&gt;icc&lt;/code&gt;, will eliminate the library call for &lt;code&gt;pow(a,6)&lt;/code&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我正在对科学应用程序进行一些数值优化。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我注意到的一件事是，GCC将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过将其编译为&lt;/font&gt; &lt;code&gt;a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;来优化调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是调用&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;并未经过优化，实际上会调用库函数&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这大大降低了速度表演。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（相比之下，&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_C++_Compiler&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;英特尔C ++编译器&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（可执行文件&lt;/font&gt; &lt;code&gt;icc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;）将消除对&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的库调用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。）&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68e041c100d9c66ab0c3bcee649f2dba3fb13072" translate="yes" xml:space="preserve">
          <source>I was surprised to learn from the other answers that this expression could indeed be optimized with the proper compiler switches. Either the optimization is trivial, or it is an edge case of a much more common optimization, or the compiler writers were extremely thorough.</source>
          <target state="translated">我从其他答案中得知,这个表达式确实可以通过适当的编译器开关来优化,这让我很惊讶。要么是这个优化很琐碎,要么是一个更常见的优化的边缘案例,要么就是编译器编写者的优化非常彻底。</target>
        </trans-unit>
        <trans-unit id="8e52965681e9d8c31e55fa89df4f421c02c286ab" translate="yes" xml:space="preserve">
          <source>I would not have expected this case to be optimized at all. It can't be very often where an expression contains subexpressions that can be regrouped to remove entire operations. I would expect compiler writers to invest their time in areas which would be more likely to result in noticeable improvements, rather than covering a rarely encountered edge case.</source>
          <target state="translated">我完全没想到这种情况会被优化。一个表达式中包含子表达式的情况不可能经常出现,因为它不可能经常出现,因为一个表达式中包含的子表达式可以被重新组合起来,以去除整个操作。我希望编译器编写者将时间投入到更有可能带来明显改进的领域,而不是覆盖一个很少遇到的边缘案例。</target>
        </trans-unit>
        <trans-unit id="03310089f35a8bb06c3934edfb960e33bebbf631" translate="yes" xml:space="preserve">
          <source>I'm using system GCC on Linux Mint 16 Petra, an Ubuntu derivative.  Here's the gcc version:</source>
          <target state="translated">我在Linux Mint 16 Petra上使用系统GCC,这是Ubuntu的一个衍生版本。下面是gcc版本。</target>
        </trans-unit>
        <trans-unit id="71a578b2882ad2932339e7108c7ed7c15ddeaa8e" translate="yes" xml:space="preserve">
          <source>If a compiler doesn't support this pragma, it must be conservative by avoiding any such optimization, in case the developer has chosen to set it to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果编译器不支持此编译指示，则必须避免任何此类优化，以保持保守，以防开发人员选择将其设置为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88c654fab2a03795d25bdf97b7e8f0998123d1d1" translate="yes" xml:space="preserve">
          <source>In general you know that for arbitrary floating point values &quot;pow&quot; has better accuracy than any function you could eventually write, but in some special cases multiple multiplications may have better accuracy and performance, it is up to the developer choosing what is more appropriate, eventually commenting the code so that noone else would &quot;optimize&quot; that code.</source>
          <target state="translated">一般情况下,你知道对于任意的浮点值,&quot;pow &quot;的精度比你最终能写的任何函数都要好,但在一些特殊情况下,多次乘法可能会有更好的精度和性能,这就要看开发者选择哪种更合适了,最终在代码中注释,这样就不会有人再去 &quot;优化 &quot;那段代码了。</target>
        </trans-unit>
        <trans-unit id="cc6d49616d403affbb828d1c957be55e63e50885" translate="yes" xml:space="preserve">
          <source>Library functions like &quot;pow&quot; are usually carefully crafted to yield the minimum possible error (in generic case). This is usually achieved approximating functions with splines (according to Pascal's comment the most common implementation seems to be using &lt;a href=&quot;https://en.wikipedia.org/wiki/Remez_algorithm&quot;&gt;Remez algorithm&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常会精心设计库函数（例如&amp;ldquo; pow&amp;rdquo;）以产生最小的错误（在一般情况下）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这通常是通过样条&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Remez_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;曲线&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;逼近函数实现的（根据Pascal的评论，最常见的实现似乎是使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Remez算法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c6a32c2fef0ceb0b9c94cd7c9b0a92dc173bfc48" translate="yes" xml:space="preserve">
          <source>No posters have mentioned the contraction of floating expressions yet (ISO C standard, 6.5p8 and 7.12.2). If the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma is set to &lt;code&gt;ON&lt;/code&gt;, the compiler is allowed to regard an expression such as &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; as a single operation, as if evaluated exactly with a single rounding. For instance, a compiler may replace it by an internal power function that is both faster and more accurate. This is particularly interesting as the behavior is partly controlled by the programmer directly in the source code, while compiler options provided by the end user may sometimes be used incorrectly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尚无张贴者提到浮动表达式的收缩（ISO C标准，6.5p8和7.12.2）。如果将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;FP_CONTRACT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译指示设置为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则允许编译器将诸如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; 之&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类的表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;视为单个操作，就好象是通过一次舍入而精确地求值一样。例如，编译器可以用更快更准确的内部幂函数代替它。这一点特别有趣，因为行为的一部分由程序员直接在源代码中控制，而最终用户提供的编译器选项有时可能不正确地使用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95a717f5c6110339b6c63d4df7945ada42cd7db8" translate="yes" xml:space="preserve">
          <source>Note that GCC provides &lt;code&gt;__builtin_powi(x,n)&lt;/code&gt; as an alternative to &lt;code&gt;pow( )&lt;/code&gt;, which should generate an inline multiplication tree.  Use that if you want to trade off accuracy for performance, but do not want to enable fast-math.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，GCC提供了&lt;/font&gt;&lt;/font&gt; &lt;code&gt;__builtin_powi(x,n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow( )&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的替代，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;pow（）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该生成一个内联乘法树。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您要在准确性与性能之间进行权衡，但又不想启用快速计算，请使用该选项。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94c760a7cba09a8bca02fa707bf827e1a8cc56ea" translate="yes" xml:space="preserve">
          <source>Should majority of programmers recognize (and be able to execute on) the idea that C expression a*a*a*a*a*a is not actually working with ideal numbers, the GCC compiler would then be FREE to optimize &quot;a*a*a*a*a*a&quot; into say &quot;t=(a*a); t*t*t&quot; which requires a smaller number of multiplications. But unfortunately, the GCC compiler does not know whether the programmer writing the code thinks that &quot;a&quot; is a number with or without an error. And so GCC will only do what the source code looks like - because that is what GCC sees with its &quot;naked eye&quot;.</source>
          <target state="translated">如果大多数程序员认识到(并且能够执行)C语言表达式a*a*a*a*a*a*a的想法,那么GCC编译器就可以自由地将 &quot;a*a*a*a*a*a &quot;优化为 &quot;t=(a*a);t*t*t&quot;,这需要较少的乘法次数。但遗憾的是,GCC编译器不知道写代码的程序员是否认为 &quot;a &quot;是一个有或没有错误的数字。所以GCC只会按照源代码的样子去做--因为GCC用 &quot;肉眼 &quot;看到的就是这个样子。</target>
        </trans-unit>
        <trans-unit id="28ed3ac2704e149ae2dd87d11eccdff53fdf0451" translate="yes" xml:space="preserve">
          <source>Signed integers, as Peter Cordes pointed out in a comment, can do this optimization without &lt;code&gt;-funsafe-math-optimizations&lt;/code&gt; since it holds exactly when there is no overflow and if there is overflow you get undefined behavior. So you get</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正如彼得&amp;middot;科德斯（Peter Cordes）在评论中指出的那样，带符号整数可以在没有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-funsafe-math-optimizations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; optimizations的情况下进行此优化，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为它精确地保留了没有溢出的时间，如果存在溢出，您将获得不确定的行为。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所以你得到&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4dcee4d2845f68dd48259ec19ca5fa93c40dae90" translate="yes" xml:space="preserve">
          <source>Some years ago I was trying to make it more convenient to calculate integer powers in an optimal way, and came up with the following.  It's C++, not C though, and still depends on the compiler being somewhat smart about how to optimize/inline things. Anyway, hope you might find it useful in practice:</source>
          <target state="translated">几年前,我想用优化的方式让整数次幂的计算更方便,于是想出了下面这个方法。它是C++的,不是C语言,但仍然取决于编译器对优化内联的东西有一定的智慧。总之,希望大家在实践中能派上用场。</target>
        </trans-unit>
        <trans-unit id="f69c9a253137aba303e8ac403c17349ba850c078" translate="yes" xml:space="preserve">
          <source>That can be a pain to write, though; why can't the compiler just do [what you consider to be] the right thing when you use &lt;code&gt;pow(a,6)&lt;/code&gt;?  Because it would be the &lt;em&gt;wrong&lt;/em&gt; thing to do.  On a platform with a good math library, &lt;code&gt;pow(a,6)&lt;/code&gt; is significantly more accurate than either &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; or &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;.  Just to provide some data, I ran a small experiment on my Mac Pro, measuring the worst error in evaluating a^6 for all single-precision floating numbers between [1,2):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不过，写起来可能很痛苦。为什么在使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时编译器不能只是做[您认为是正确的事情] &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？因为这样做是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;错误&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的。在具有良好数学库的平台上，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;准确得多&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。为了提供一些数据，我在Mac Pro上进行了一个小实验，测量了在[1,2）之间的所有单精度浮点数的a ^ 6评估中的最差错误：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd79ee104a238b2bcbb0aefa26e43a29a96700ad" translate="yes" xml:space="preserve">
          <source>The compiler should be really carefull to the kind of optimization it is doing:</source>
          <target state="translated">编译器真的要注意自己的优化方式。</target>
        </trans-unit>
        <trans-unit id="70f3ac8d17a4f4ef97f85ecb089f37ed70d7a2d4" translate="yes" xml:space="preserve">
          <source>The default state of the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma is implementation-defined, so that a compiler is allowed to do such optimizations by default. Thus portable code that needs to strictly follow the IEEE 754 rules should explicitly set it to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;FP_CONTRACT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译指示&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的默认状态&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是实现定义的，因此默认情况下允许编译器执行此类优化。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，需要严格遵循IEEE 754规则的可移植代码应将其显式设置为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="032412492bf0d092f330b93773053935967db4a8" translate="yes" xml:space="preserve">
          <source>The only thing that make sense (personal opinion, and apparently a choice in GCC wichout any particular optimization or compiler flag) to optimize should be replacing &quot;pow(a,2)&quot; with &quot;a*a&quot;. That would be the only sane thing a compiler vendor should do.</source>
          <target state="translated">唯一有意义的事情(个人观点,显然是GCC中的选择,不考虑任何特定的优化或编译器标志)应该是用 &quot;a*a &quot;代替 &quot;pow(a,2)&quot;。这将是一个编译器厂商应该做的唯一理智的事情。</target>
        </trans-unit>
        <trans-unit id="a622439a8bfbafc241f087dbbd072315176f64bb" translate="yes" xml:space="preserve">
          <source>Then just use it as &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后将其用作&lt;/font&gt;&lt;/font&gt; &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf492b55441273a0253418f344466dc73cd10073" translate="yes" xml:space="preserve">
          <source>There are a lot of gcc flags but nothing fancy.  They mean:  Read from stdin; use O2 optimization level; output assembly language listing instead of a binary; the listing should use Intel assembly language syntax; the input is in C language (usually language is inferred from input file extension, but there is no file extension when reading from stdin); and write to stdout.</source>
          <target state="translated">有很多gcc标志,但没有什么花哨的东西。它们的意思是。从 stdin 读取;使用 O2 优化级别;输出汇编语言列表,而不是二进制的;列表应该使用 Intel 汇编语言语法;输入是 C 语言(通常从输入文件扩展名推断出语言,但从 stdin 读取时没有文件扩展名);写到 stdout。</target>
        </trans-unit>
        <trans-unit id="038c91abf47f7af8387f87881fe8c08dd6f3b995" translate="yes" xml:space="preserve">
          <source>There are already a few good answers to this question, but for the sake of completeness I wanted to point out that the applicable section of the C standard is 5.1.2.2.3/15 (which is the same as section 1.9/9 in the C++11 standard).  This section states that operators can only be regrouped if they are really associative or commutative.</source>
          <target state="translated">这个问题已经有几个很好的答案了,但为了完整起见,我想指出C标准中适用的章节是5.1.2.2.2.315(这与C++11标准中的1.99节相同)。这一节规定,只有当运算符真的是联想或换乘时,才可以重新组合。</target>
        </trans-unit>
        <trans-unit id="34a6090f4401ef36f9853e0c1580d3e4d38191d7" translate="yes" xml:space="preserve">
          <source>There's nothing wrong with providing hints to the compiler as you've done here. It's a normal and expected part of the micro-optimization process to rearrange statements and expressions to see what differences they will bring.</source>
          <target state="translated">向编译器提供提示并没有错,就像你在这里做的那样。在微观优化过程中,重新排列语句和表达式,看看它们会带来什么不同,这是正常的,也是预期的一部分。</target>
        </trans-unit>
        <trans-unit id="f119f08c5c4dbeee8e65aa7456308d7e067dfe12" translate="yes" xml:space="preserve">
          <source>This is what I get from my compiler:</source>
          <target state="translated">这就是我从编译器里得到的结果。</target>
        </trans-unit>
        <trans-unit id="f4fe0dbbf5143d55f866bd834ce8215252c70263" translate="yes" xml:space="preserve">
          <source>This makes it easy to type powers (no need to spell out 6 &lt;code&gt;a&lt;/code&gt;s with parens), and lets you have this kind of optimization without &lt;code&gt;-ffast-math&lt;/code&gt; in case you have something precision dependent such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation_algorithm&quot;&gt;compensated summation&lt;/a&gt; (an example where the order of operations is essential).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样可以很容易地输入幂（不需要&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用括号&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来拼写6 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; s），并且可以在不&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的情况下进行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这种优化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，以防万一您对精度有某些要求，例如&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;补偿求和&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（例如操作至关重要）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3a21c378f482fb7cba0b9dc669736cc20cdb3cd" translate="yes" xml:space="preserve">
          <source>This outputs &lt;code&gt;1.000000e-05 0.000000e+00&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;输出&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1.000000e-05 0.000000e+00&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a954fcc81f3445fd1f1f16ee4798784fc70c5f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pow&lt;/code&gt; instead of a multiplication tree reduces the error bound by a &lt;em&gt;factor of 4&lt;/em&gt;.  Compilers should not (and generally do not) make &quot;optimizations&quot; that increase error unless licensed to do so by the user (e.g. via &lt;code&gt;-ffast-math&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不是乘法树可以将错误范围限制&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为4&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除非用户许可（例如，通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;否则编译器不应（并且通常不会）进行&amp;ldquo;优化&amp;rdquo;以增加错误&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="02de4b219e179d76a6d96b22b18d1566e505141d" translate="yes" xml:space="preserve">
          <source>What I am curious about is that when I replaced &lt;code&gt;pow(a,6)&lt;/code&gt; with &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; using GCC 4.5.1 and options &quot;&lt;code&gt;-O3 -lm -funroll-loops -msse4&lt;/code&gt;&quot;, it uses 5 &lt;code&gt;mulsd&lt;/code&gt; instructions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我很好奇的是，当我&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用GCC 4.5.1和选项&amp;ldquo; &lt;/font&gt; &lt;code&gt;-O3 -lm -funroll-loops -msse4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;替换为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; 时&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它使用了5 &lt;/font&gt; &lt;code&gt;mulsd&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;说明：&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="019e7ae12d49514249ba5f50e9f30acbe61db21a" translate="yes" xml:space="preserve">
          <source>While the compiler may be justified in considering the two expressions to deliver inconsistent results (without the proper switches), there's no need for you to be bound by that restriction. The difference will be incredibly tiny - so much so that if the difference matters to you, you should not be using standard floating point arithmetic in the first place.</source>
          <target state="translated">虽然编译器可能有理由认为这两个表达式会提供不一致的结果(没有适当的开关),但你没有必要受此限制。这两个表达式之间的差异将是非常微小的,以至于如果差异对你来说很重要的话,你首先就不应该使用标准的浮点算术。</target>
        </trans-unit>
        <trans-unit id="cde544d42fbafa1f338764a2c2773d3ec5822639" translate="yes" xml:space="preserve">
          <source>While the following operation:</source>
          <target state="translated">虽然下面的操作:</target>
        </trans-unit>
        <trans-unit id="db94284baa6947e0b56737b3af7e707f25f8165c" translate="yes" xml:space="preserve">
          <source>Why do compilers not recognize this optimization trick?</source>
          <target state="translated">为什么编译器不承认这个优化技巧?</target>
        </trans-unit>
        <trans-unit id="b7d445e56ae3b3b51205e7428cddf177214a3a36" translate="yes" xml:space="preserve">
          <source>Why doesn't GCC optimize a*a*a*a*a*a to (a*a*a)*(a*a*a)</source>
          <target state="translated">为什么GCC不将a*a*a*a*a优化为(a*a*a)*(a*a*a)*(a*a*a)</target>
        </trans-unit>
        <trans-unit id="5ed24af97064af0cd9ce60a3e5e0f869a731bf23" translate="yes" xml:space="preserve">
          <source>You can probably also forget that this is C++ and just use it in the C program (if it compiles with a C++ compiler).</source>
          <target state="translated">你可能也可以忘记这是C++,只需在C程序中使用它(如果用C++编译器编译的话)。</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="b700a3c7f4d2e0b51edf81e37c6548c3fcace4ed" translate="yes" xml:space="preserve">
          <source>fundamentally the following operation:</source>
          <target state="translated">基本上是以下操作:</target>
        </trans-unit>
        <trans-unit id="fb6edeecaf4ad3a1a421caf127f44a6e529f8f35" translate="yes" xml:space="preserve">
          <source>gcc actually can do this optimization, even for floating-point numbers. For example,</source>
          <target state="translated">gcc实际上可以进行这样的优化,即使是对于浮点数也可以。比如说</target>
        </trans-unit>
        <trans-unit id="67297856c412ac15e2bf250ffaa0316856878b1f" translate="yes" xml:space="preserve">
          <source>has a inherent error of approximately the &lt;strong&gt;same magnitude as the error in any single multiplication or division&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;固有误差与&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何单个乘法或除法的误差&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大致&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相同&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75d90159c1ba5de1cab0baec48b5e1f3ec29a879" translate="yes" xml:space="preserve">
          <source>has a inherent error that is greater more than &lt;strong&gt;5 times the error of a single multiplication&lt;/strong&gt; or division (because you are combining 5 multiplications).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的固有误差大于&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;单个乘法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或除法&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;误差的5倍&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（因为您要组合5个乘法）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fda107f074252af4966e46b506713bd46dec57a" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;a*a*a*a*a*a&lt;/code&gt;  to &lt;code&gt;pow(a,6)&lt;/code&gt; it may actually reduce the accuracy because &quot;a&quot; was some special value that allows multiplication without error (a power of 2 or some small integer number)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; 优化&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则实际上可能会降低精度，因为&amp;ldquo; a&amp;rdquo;是一些允许无错误相乘的特殊值（2的幂或一些小整数）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf71e4ed346f57912a1e79b200383d8fa6c3fc01" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;pow(a,6)&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; or &lt;code&gt;(a*a)*(a*a)*(a*a)&lt;/code&gt; there still can be a loss of accuracy compared to &lt;code&gt;pow&lt;/code&gt; function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a)*(a*a)*(a*a)&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则仍然会损失精度与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;功能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相比&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cfec1f2de6ea415d4cf8ceedd8dcaca5c6ec2e8" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;pow(a,6)&lt;/code&gt; to &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; it &lt;strong&gt;may&lt;/strong&gt; improve performance, but drastically reduce the accuracy for floating point numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能会&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提高性能，但会大大降低浮点数的精度。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fef10f56fa82200041ab99b1d4d2485b58462410" translate="yes" xml:space="preserve">
          <source>which reduces the number of multiply instructions to 3. &lt;code&gt;icc&lt;/code&gt; has similar behavior.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将乘法指令的数量减少到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;icc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有相似的行为。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8cd4c1833209b82d692c0005ba1b92e7b7924368" translate="yes" xml:space="preserve">
          <source>while if I write &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;, it will produce</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而如果我写&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它将产生&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e99df94664796974ee5510f379629ed4b7b1e71" translate="yes" xml:space="preserve">
          <source>with &lt;code&gt;-O -funsafe-math-optimizations&lt;/code&gt;. This reordering violates IEEE-754, though, so it requires the flag.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-O -funsafe-math-optimizations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，此重新排序违反了IEEE-754，因此需要该标志。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a019b70a71456f8a761d32e12d9c417e7e1379b6" translate="yes" xml:space="preserve">
          <source>with just &lt;code&gt;-O&lt;/code&gt;. For unsigned integers, it's even easier since they work mod powers of 2 and so can be reordered freely even in the face of overflow.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-O&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于无符号整数，这更容易，因为它们的mod幂为2，因此即使面对溢出也可以自由地重新排序。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
