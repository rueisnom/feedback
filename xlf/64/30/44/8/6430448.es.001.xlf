<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/6430448">
    <body>
      <group id="6430448">
        <trans-unit id="4d250087c10e817bb864c62232c3ce88493f0870" translate="yes" xml:space="preserve">
          <source>... once you know what kind of programmer &lt;em&gt;you&lt;/em&gt; are, you can use the &quot;-ffast-math&quot; switch to tell GCC that &quot;Hey, GCC, I know what I am doing!&quot;. This will allow GCC to convert a*a*a*a*a*a into a different piece of text - it looks different from a*a*a*a*a*a - but still computes a number within the error interval of a*a*a*a*a*a. This is OK, since you already know you are working with intervals, not ideal numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... una vez que sepa qu&amp;eacute; tipo de programador es &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;usted&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , puede usar el interruptor &quot;-ffast-math&quot; para decirle a GCC que &quot;&amp;iexcl;Hola, GCC, s&amp;eacute; lo que estoy haciendo!&quot;. Esto permitir&amp;aacute; que GCC convierta a * a * a * a * a * a en un texto diferente; se ve diferente de a * a * a * a * a * a, pero a&amp;uacute;n calcula un n&amp;uacute;mero dentro del intervalo de error de a * a * a * a * a * a. Esto est&amp;aacute; bien, ya que ya sabe que est&amp;aacute; trabajando con intervalos, no con n&amp;uacute;meros ideales.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e601cb9e293c7f55858b9c7c9a8e1f3cfbbcf80f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/6430525/463065&quot;&gt;&lt;strong&gt;Lambdageek&lt;/strong&gt;&lt;/a&gt; correctly points out that because associativity does not hold for floating-point numbers, the &quot;optimization&quot; of &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; may change the value.  This is why it is disallowed by C99 (unless specifically allowed by the user, via compiler flag or pragma).  Generally, the assumption is that the programmer wrote what she did for a reason, and the compiler should respect that.  If you want &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;, write that.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/6430525/463065&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lambdageek&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se&amp;ntilde;ala correctamente que debido a que la asociatividad no se cumple para los n&amp;uacute;meros de coma flotante, la &quot;optimizaci&amp;oacute;n&quot; de&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; puede cambiar el valor. Esta es la raz&amp;oacute;n por la cual C99 no lo permite (a menos que el usuario lo permita espec&amp;iacute;ficamente, a trav&amp;eacute;s del indicador del compilador o pragma). En general, se supone que el programador escribi&amp;oacute; lo que hizo por una raz&amp;oacute;n, y el compilador debe respetar eso. Si quieres&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , escr&amp;iacute;belo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3554b22e1fc90a354131abcb9d80400bf1e1fd41" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;strong&gt;Clarification for the curious:&lt;/strong&gt; this does not find the optimal way to compute powers, but since &lt;a href=&quot;http://en.wikipedia.org/wiki/Addition-chain_exponentiation&quot;&gt;finding the optimal solution is an NP-complete problem&lt;/a&gt; and this is only worth doing for small powers anyway (as opposed to using &lt;code&gt;pow&lt;/code&gt;), there's no reason to fuss with the detail.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aclaraci&amp;oacute;n para los curiosos:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; esto no encuentra la forma &amp;oacute;ptima de calcular las potencias, pero dado que &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Addition-chain_exponentiation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;encontrar la soluci&amp;oacute;n &amp;oacute;ptima es un problema NP-completo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y esto solo vale la pena hacerlo para las potencias peque&amp;ntilde;as de todos modos (en lugar de usar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), no hay raz&amp;oacute;n para Alboroto con el detalle.&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="8ec2ebf132faa836164fcc84f4c1f54c2408fce2" translate="yes" xml:space="preserve">
          <source>Another similar case: most compilers won't optimize &lt;code&gt;a + b + c + d&lt;/code&gt; to &lt;code&gt;(a + b) + (c + d)&lt;/code&gt; (this is an optimization since the second expression can be pipelined better) and evaluate it as given (i.e. as &lt;code&gt;(((a + b) + c) + d)&lt;/code&gt;). This too is because of corner cases:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otro caso similar: la mayor&amp;iacute;a de los compiladores no optimizar&amp;aacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a + b + c + d&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a + b) + (c + d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (esta es una optimizaci&amp;oacute;n ya que la segunda expresi&amp;oacute;n se puede canalizar mejor) y la evaluar&amp;aacute;n como se da (es decir como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(((a + b) + c) + d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto tambi&amp;eacute;n se debe a casos de esquina:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c9a86236232165a7908c885e6e3608d6ebaa349" translate="yes" xml:space="preserve">
          <source>As Lambdageek pointed out float multiplication is not associative and you can get less accuracy, but also when get better accuracy you can argue against optimisation, because you want a deterministic application. For example in game simulation client/server, where every client has to simulate the same world you want floating point calculations to be deterministic.</source>
          <target state="translated">Como señaló Lambdageek,la multiplicación por flotación no es asociativa y se puede obtener menos precisión,pero también cuando se obtiene una mayor precisión se puede argumentar en contra de la optimización,porque se quiere una aplicación determinista.Por ejemplo,en la simulación de un juego cliente-servidor,en el que cada cliente tiene que simular el mismo mundo,se quiere que los cálculos en coma flotante sean deterministas.</target>
        </trans-unit>
        <trans-unit id="a878690db08938608264102fc103f5780dab6683" translate="yes" xml:space="preserve">
          <source>As a result, most compilers are very conservative about reordering floating point calculations unless they can be sure that the answer will stay the same, or unless you tell them you don't care about numerical accuracy.  For example: &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt;the &lt;code&gt;-fassociative-math&lt;/code&gt; option&lt;/a&gt; of gcc which allows gcc to reassociate floating point operations, or even the &lt;code&gt;-ffast-math&lt;/code&gt; option which allows even more aggressive tradeoffs of accuracy against speed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como resultado, la mayor&amp;iacute;a de los compiladores son muy conservadores al reordenar los c&amp;aacute;lculos de coma flotante a menos que puedan estar seguros de que la respuesta seguir&amp;aacute; siendo la misma, o a menos que les diga que no le importa la precisi&amp;oacute;n num&amp;eacute;rica. Por ejemplo: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;opci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-fassociative-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de gcc que le permite a gcc reasociar operaciones de coma flotante, o incluso la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;opci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que permite compensaciones a&amp;uacute;n m&amp;aacute;s agresivas de precisi&amp;oacute;n contra velocidad.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1f7025a0a8653e90ed33ccd59a524411194bee3" translate="yes" xml:space="preserve">
          <source>As other posters have noted, this option is not possible in floating point, because floating point arithmetic is not associative.</source>
          <target state="translated">Como se ha señalado en otros carteles,esta opción no es posible en coma flotante,porque la aritmética en coma flotante no es asociativa.</target>
        </trans-unit>
        <trans-unit id="5cab4fa1adf07c1f4fab622ca0e1c9a2bbadc951" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems&quot;&gt;Floating Point Math is not Associative&lt;/a&gt;.  The way you group the operands in floating point multiplication has an effect on the numerical accuracy of the answer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Porque &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Floating Point Math no es asociativo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La forma en que agrupa los operandos en la multiplicaci&amp;oacute;n de coma flotante tiene un efecto en la precisi&amp;oacute;n num&amp;eacute;rica de la respuesta.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac72a721d84b77b0b13d7bfd347c5a737d30b1ff" translate="yes" xml:space="preserve">
          <source>Because a 32-bit floating-point number - such as 1.024 - is not 1.024. In a computer, 1.024 is an interval: from (1.024-e) to (1.024+e), where &quot;e&quot; represents an error. Some people fail to realize this and also believe that * in a*a stands for multiplication of arbitrary-precision numbers without there being any errors attached to those numbers. The reason why some people fail to realize this is perhaps the math computations they exercised in elementary schools: working only with ideal numbers without errors attached, and believing that it is OK to simply ignore &quot;e&quot; while performing multiplication. They do not see the &quot;e&quot; implicit in &quot;float a=1.2&quot;, &quot;a*a*a&quot; and similar C codes.</source>
          <target state="translated">Porque un número de 32 bits de punto flotante,como 1.024,no es 1.024.En un ordenador,1.024 es un intervalo:de (1.024-e)a (1.024+e),donde &quot;e&quot; representa un error.Algunas personas no se dan cuenta de esto y también creen que*en a*a representa la multiplicación de números de precisión arbitraria sin que haya ningún error en esos números.La razón por la que algunas personas no se dan cuenta de esto es quizás los cálculos matemáticos que hacían en las escuelas primarias:trabajar sólo con números ideales sin errores,y creer que está bien simplemente ignorar la &quot;e&quot; mientras se realiza la multiplicación.No ven la &quot;e&quot; implícita en &quot;flotar a=1,2&quot;,&quot;a*a*a&quot; y códigos C similares.</target>
        </trans-unit>
        <trans-unit id="fc0b3ee381fd7de113933bbc502a60dac899d423" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b62e31b37189d012f547a0a066099b50cab9e5ae" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a*a*a*a*a*a&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac18e696c6c6f8d2010e80747b9e03f2cdd1dbfb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para la &lt;/font&gt;&lt;/font&gt; &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4c7cce855605e6a3df3d02aa3dd09fd1da9c306" translate="yes" xml:space="preserve">
          <source>Fortran (designed for scientific computing) has a built-in power operator, and as far as I know Fortran compilers will commonly optimize raising to integer powers in a similar fashion to what you describe.  C/C++ unfortunately don't have a power operator, only the library function &lt;code&gt;pow()&lt;/code&gt;.  This doesn't prevent smart compilers from treating &lt;code&gt;pow&lt;/code&gt; specially and computing it in a faster way for special cases, but it seems they do it less commonly ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Fortran (dise&amp;ntilde;ado para computaci&amp;oacute;n cient&amp;iacute;fica) tiene un operador de energ&amp;iacute;a incorporado, y que yo sepa, los compiladores de Fortran com&amp;uacute;nmente optimizar&amp;aacute;n la elevaci&amp;oacute;n a potencias enteras de manera similar a lo que usted describe. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desafortunadamente, C / C ++ no tiene un operador de energ&amp;iacute;a, solo la funci&amp;oacute;n de biblioteca &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto no impide que los compiladores inteligentes traten &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;especialmente a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y lo computen de una manera m&amp;aacute;s r&amp;aacute;pida para casos especiales, pero parece que lo hacen con menos frecuencia ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="28395c97c243c9dc54c1873c68dbaf715650cbaa" translate="yes" xml:space="preserve">
          <source>GCC does actually optimize &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; when a is an integer.  I tried with this command:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC realmente optimiza &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; to &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cuando a es un n&amp;uacute;mero entero. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Intent&amp;eacute; con este comando:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5cff5d070250d7e8684c02968fdc4cf5608e1d1a" translate="yes" xml:space="preserve">
          <source>GCC doesn't support this pragma, but with the default options, it assumes it to be &lt;code&gt;ON&lt;/code&gt;; thus for targets with a hardware FMA, if one wants to prevent the transformation &lt;code&gt;a*b+c&lt;/code&gt; to fma(a,b,c), one needs to provide an option such as &lt;code&gt;-ffp-contract=off&lt;/code&gt; (to explicitly set the pragma to &lt;code&gt;OFF&lt;/code&gt;) or &lt;code&gt;-std=c99&lt;/code&gt; (to tell GCC to conform to some C standard version, here C99, thus follow the above paragraph). In the past, the latter option was not preventing the transformation, meaning that GCC was not conforming on this point: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&quot;&gt;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC no admite este pragma, pero con las opciones predeterminadas, se supone que est&amp;aacute; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ; por lo tanto, para objetivos con un FMA de hardware, si se quiere evitar la transformaci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*b+c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a fma (a, b, c), se debe proporcionar una opci&amp;oacute;n como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffp-contract=off&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (para establecer expl&amp;iacute;citamente el pragma a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-std=c99&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (para indicarle a GCC que se ajuste a alguna versi&amp;oacute;n est&amp;aacute;ndar de C, aqu&amp;iacute; C99, por lo tanto, siga el p&amp;aacute;rrafo anterior). En el pasado, la &amp;uacute;ltima opci&amp;oacute;n no imped&amp;iacute;a la transformaci&amp;oacute;n, lo que significa que GCC no se ajustaba a este punto: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="981522191a8758a2cf80c7f0915aa11eabaca13e" translate="yes" xml:space="preserve">
          <source>Here's the important part of the output.  I've annotated it with some comments indicating what's going on in the assembly language:</source>
          <target state="translated">Aquí está la parte importante de la salida.Lo he anotado con algunos comentarios que indican lo que está pasando en el lenguaje ensamblador:</target>
        </trans-unit>
        <trans-unit id="1853745e32869f380edec4598bc3ef06f0430bde" translate="yes" xml:space="preserve">
          <source>Hope this can be useful.</source>
          <target state="translated">Espero que esto pueda ser útil.</target>
        </trans-unit>
        <trans-unit id="85e39a3e78f49e60da31dbc9c4c7ab654a9d8ff7" translate="yes" xml:space="preserve">
          <source>I am doing some numerical optimization on a scientific application. One thing I noticed is that GCC will optimize the call &lt;code&gt;pow(a,2)&lt;/code&gt; by compiling it into &lt;code&gt;a*a&lt;/code&gt;, but the call &lt;code&gt;pow(a,6)&lt;/code&gt; is not optimized and will actually call the library function &lt;code&gt;pow&lt;/code&gt;, which greatly slows down the performance. (In contrast, &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_C++_Compiler&quot;&gt;Intel C++ Compiler&lt;/a&gt;, executable &lt;code&gt;icc&lt;/code&gt;, will eliminate the library call for &lt;code&gt;pow(a,6)&lt;/code&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Estoy haciendo una optimizaci&amp;oacute;n num&amp;eacute;rica en una aplicaci&amp;oacute;n cient&amp;iacute;fica. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una cosa que not&amp;eacute; es que GCC optimizar&amp;aacute; la llamada &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; compil&amp;aacute;ndola en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero la llamada &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no est&amp;aacute; optimizada y en realidad llamar&amp;aacute; a la funci&amp;oacute;n de biblioteca &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , que se ralentiza enormemente el desempe&amp;ntilde;o. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(En contraste, el &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_C++_Compiler&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;compilador Intel C ++&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;icc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ejecutable &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, eliminar&amp;aacute; la llamada de la biblioteca para &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68e041c100d9c66ab0c3bcee649f2dba3fb13072" translate="yes" xml:space="preserve">
          <source>I was surprised to learn from the other answers that this expression could indeed be optimized with the proper compiler switches. Either the optimization is trivial, or it is an edge case of a much more common optimization, or the compiler writers were extremely thorough.</source>
          <target state="translated">Me sorprendió saber por las otras respuestas que esta expresión podía ser optimizada con los interruptores de compilación adecuados.O bien la optimización es trivial,o es un caso límite de una optimización mucho más común,o los escritores del compilador fueron extremadamente minuciosos.</target>
        </trans-unit>
        <trans-unit id="8e52965681e9d8c31e55fa89df4f421c02c286ab" translate="yes" xml:space="preserve">
          <source>I would not have expected this case to be optimized at all. It can't be very often where an expression contains subexpressions that can be regrouped to remove entire operations. I would expect compiler writers to invest their time in areas which would be more likely to result in noticeable improvements, rather than covering a rarely encountered edge case.</source>
          <target state="translated">No esperaba que este caso se optimizara en absoluto.No puede ser muy frecuente que una expresión contenga subexpresiones que puedan ser reagrupadas para eliminar operaciones enteras.Yo esperaría que los escritores compiladores invirtieran su tiempo en áreas en las que sería más probable que se produjeran mejoras notables,en lugar de cubrir un caso de borde raramente encontrado.</target>
        </trans-unit>
        <trans-unit id="03310089f35a8bb06c3934edfb960e33bebbf631" translate="yes" xml:space="preserve">
          <source>I'm using system GCC on Linux Mint 16 Petra, an Ubuntu derivative.  Here's the gcc version:</source>
          <target state="translated">Estoy usando el sistema GCC en Linux Mint 16 Petra,un derivado de Ubuntu.Aquí está la versión de GCC:</target>
        </trans-unit>
        <trans-unit id="71a578b2882ad2932339e7108c7ed7c15ddeaa8e" translate="yes" xml:space="preserve">
          <source>If a compiler doesn't support this pragma, it must be conservative by avoiding any such optimization, in case the developer has chosen to set it to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si un compilador no es compatible con este pragma, debe ser conservador evitando dicha optimizaci&amp;oacute;n, en caso de que el desarrollador haya elegido &lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88c654fab2a03795d25bdf97b7e8f0998123d1d1" translate="yes" xml:space="preserve">
          <source>In general you know that for arbitrary floating point values &quot;pow&quot; has better accuracy than any function you could eventually write, but in some special cases multiple multiplications may have better accuracy and performance, it is up to the developer choosing what is more appropriate, eventually commenting the code so that noone else would &quot;optimize&quot; that code.</source>
          <target state="translated">En general se sabe que para valores arbitrarios en coma flotante &quot;pow&quot; tiene una mayor exactitud que cualquier función que se pueda escribir eventualmente,pero en algunos casos especiales las multiplicaciones múltiples pueden tener una mayor exactitud y rendimiento,depende del desarrollador elegir lo que sea más apropiado,comentando eventualmente el código para que nadie más lo &quot;optimice&quot;.</target>
        </trans-unit>
        <trans-unit id="cc6d49616d403affbb828d1c957be55e63e50885" translate="yes" xml:space="preserve">
          <source>Library functions like &quot;pow&quot; are usually carefully crafted to yield the minimum possible error (in generic case). This is usually achieved approximating functions with splines (according to Pascal's comment the most common implementation seems to be using &lt;a href=&quot;https://en.wikipedia.org/wiki/Remez_algorithm&quot;&gt;Remez algorithm&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las funciones de la biblioteca como &quot;pow&quot; generalmente est&amp;aacute;n cuidadosamente dise&amp;ntilde;adas para producir el m&amp;iacute;nimo error posible (en caso gen&amp;eacute;rico). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto generalmente se logra aproximando funciones con splines (seg&amp;uacute;n el comentario de Pascal, la implementaci&amp;oacute;n m&amp;aacute;s com&amp;uacute;n parece estar usando el &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Remez_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;algoritmo Remez&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c6a32c2fef0ceb0b9c94cd7c9b0a92dc173bfc48" translate="yes" xml:space="preserve">
          <source>No posters have mentioned the contraction of floating expressions yet (ISO C standard, 6.5p8 and 7.12.2). If the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma is set to &lt;code&gt;ON&lt;/code&gt;, the compiler is allowed to regard an expression such as &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; as a single operation, as if evaluated exactly with a single rounding. For instance, a compiler may replace it by an internal power function that is both faster and more accurate. This is particularly interesting as the behavior is partly controlled by the programmer directly in the source code, while compiler options provided by the end user may sometimes be used incorrectly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ning&amp;uacute;n p&amp;oacute;ster ha mencionado todav&amp;iacute;a la contracci&amp;oacute;n de las expresiones flotantes (est&amp;aacute;ndar ISO C, 6.5p8 y 7.12.2). Si el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;pragma &lt;/font&gt;&lt;/font&gt; &lt;code&gt;FP_CONTRACT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; est&amp;aacute; establecido en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , el compilador puede considerar una expresi&amp;oacute;n como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como una operaci&amp;oacute;n &amp;uacute;nica, como si se evaluara exactamente con un solo redondeo. Por ejemplo, un compilador puede reemplazarlo por una funci&amp;oacute;n de potencia interna que es m&amp;aacute;s r&amp;aacute;pida y m&amp;aacute;s precisa. Esto es particularmente interesante ya que el comportamiento est&amp;aacute; parcialmente controlado por el programador directamente en el c&amp;oacute;digo fuente, mientras que las opciones del compilador proporcionadas por el usuario final a veces se pueden usar incorrectamente.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95a717f5c6110339b6c63d4df7945ada42cd7db8" translate="yes" xml:space="preserve">
          <source>Note that GCC provides &lt;code&gt;__builtin_powi(x,n)&lt;/code&gt; as an alternative to &lt;code&gt;pow( )&lt;/code&gt;, which should generate an inline multiplication tree.  Use that if you want to trade off accuracy for performance, but do not want to enable fast-math.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tenga en cuenta que GCC proporciona &lt;/font&gt;&lt;/font&gt; &lt;code&gt;__builtin_powi(x,n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como una alternativa a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow( )&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , que deber&amp;iacute;a generar un &amp;aacute;rbol de multiplicaci&amp;oacute;n en l&amp;iacute;nea. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;Uacute;selo si desea cambiar la precisi&amp;oacute;n por el rendimiento, pero no desea habilitar las matem&amp;aacute;ticas r&amp;aacute;pidas.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94c760a7cba09a8bca02fa707bf827e1a8cc56ea" translate="yes" xml:space="preserve">
          <source>Should majority of programmers recognize (and be able to execute on) the idea that C expression a*a*a*a*a*a is not actually working with ideal numbers, the GCC compiler would then be FREE to optimize &quot;a*a*a*a*a*a&quot; into say &quot;t=(a*a); t*t*t&quot; which requires a smaller number of multiplications. But unfortunately, the GCC compiler does not know whether the programmer writing the code thinks that &quot;a&quot; is a number with or without an error. And so GCC will only do what the source code looks like - because that is what GCC sees with its &quot;naked eye&quot;.</source>
          <target state="translated">Si la mayoría de los programadores reconocieran (y fueran capaces de ejecutar sobre)la idea de que la expresión C a*a*a*a*a*a no está funcionando realmente con los números ideales,el compilador GCC estaría entonces LIBRE para optimizar &quot;a*a*a*a*a*a&quot; en digamos &quot;t=(a*a);t*t*t&quot; que requiere un número menor de multiplicaciones.Pero desafortunadamente,el compilador GCC no sabe si el programador que escribe el código piensa que &quot;a&quot; es un número con o sin error.Así que GCC sólo hará lo que el código fuente parece,porque eso es lo que GCC ve a &quot;ojo desnudo&quot;.</target>
        </trans-unit>
        <trans-unit id="28ed3ac2704e149ae2dd87d11eccdff53fdf0451" translate="yes" xml:space="preserve">
          <source>Signed integers, as Peter Cordes pointed out in a comment, can do this optimization without &lt;code&gt;-funsafe-math-optimizations&lt;/code&gt; since it holds exactly when there is no overflow and if there is overflow you get undefined behavior. So you get</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los enteros firmados, como Peter Cordes se&amp;ntilde;al&amp;oacute; en un comentario, pueden hacer esta optimizaci&amp;oacute;n sin optimizaciones &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-funsafe-math-optimizations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ya que se mantiene exactamente cuando no hay desbordamiento y si hay desbordamiento, obtienes un comportamiento indefinido. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces obtienes&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4dcee4d2845f68dd48259ec19ca5fa93c40dae90" translate="yes" xml:space="preserve">
          <source>Some years ago I was trying to make it more convenient to calculate integer powers in an optimal way, and came up with the following.  It's C++, not C though, and still depends on the compiler being somewhat smart about how to optimize/inline things. Anyway, hope you might find it useful in practice:</source>
          <target state="translated">Hace algunos años estaba tratando de hacer más conveniente el cálculo de los poderes enteros de una manera óptima,y se me ocurrió lo siguiente.Es C++,no C,y aún depende de que el compilador sea algo inteligente sobre cómo optimizar las cosas en línea.De todas formas,espero que lo encuentres útil en la práctica:</target>
        </trans-unit>
        <trans-unit id="f69c9a253137aba303e8ac403c17349ba850c078" translate="yes" xml:space="preserve">
          <source>That can be a pain to write, though; why can't the compiler just do [what you consider to be] the right thing when you use &lt;code&gt;pow(a,6)&lt;/code&gt;?  Because it would be the &lt;em&gt;wrong&lt;/em&gt; thing to do.  On a platform with a good math library, &lt;code&gt;pow(a,6)&lt;/code&gt; is significantly more accurate than either &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; or &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;.  Just to provide some data, I ran a small experiment on my Mac Pro, measuring the worst error in evaluating a^6 for all single-precision floating numbers between [1,2):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, puede ser un dolor de escribir; &amp;iquest;por qu&amp;eacute; el compilador no puede hacer [lo que consideras que es] lo correcto cuando usas &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? Porque ser&amp;iacute;a lo &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;incorrecto&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; hacer. En una plataforma con una buena biblioteca matem&amp;aacute;tica, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es significativamente m&amp;aacute;s preciso que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Solo para proporcionar algunos datos, realic&amp;eacute; un peque&amp;ntilde;o experimento en mi Mac Pro, midiendo el peor error al evaluar un ^ 6 para todos los n&amp;uacute;meros flotantes de precisi&amp;oacute;n simple entre [1,2):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd79ee104a238b2bcbb0aefa26e43a29a96700ad" translate="yes" xml:space="preserve">
          <source>The compiler should be really carefull to the kind of optimization it is doing:</source>
          <target state="translated">El compilador debe ser muy cuidadoso con el tipo de optimización que está haciendo:</target>
        </trans-unit>
        <trans-unit id="70f3ac8d17a4f4ef97f85ecb089f37ed70d7a2d4" translate="yes" xml:space="preserve">
          <source>The default state of the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma is implementation-defined, so that a compiler is allowed to do such optimizations by default. Thus portable code that needs to strictly follow the IEEE 754 rules should explicitly set it to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El estado predeterminado del &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;pragma &lt;/font&gt;&lt;/font&gt; &lt;code&gt;FP_CONTRACT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; est&amp;aacute; definido por la implementaci&amp;oacute;n, de modo que un compilador puede realizar tales optimizaciones de forma predeterminada. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, el c&amp;oacute;digo port&amp;aacute;til que debe seguir estrictamente las reglas IEEE 754 debe establecerlo expl&amp;iacute;citamente en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="032412492bf0d092f330b93773053935967db4a8" translate="yes" xml:space="preserve">
          <source>The only thing that make sense (personal opinion, and apparently a choice in GCC wichout any particular optimization or compiler flag) to optimize should be replacing &quot;pow(a,2)&quot; with &quot;a*a&quot;. That would be the only sane thing a compiler vendor should do.</source>
          <target state="translated">Lo único que tiene sentido (opinión personal,y aparentemente una elección en el GCC sin ninguna optimización particular o bandera del compilador)para optimizar debería ser reemplazar &quot;pow(a,2)&quot; por &quot;a*a&quot;.Eso sería lo único sensato que un vendedor de compiladores debería hacer.</target>
        </trans-unit>
        <trans-unit id="a622439a8bfbafc241f087dbbd072315176f64bb" translate="yes" xml:space="preserve">
          <source>Then just use it as &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Luego, &amp;uacute;salo como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf492b55441273a0253418f344466dc73cd10073" translate="yes" xml:space="preserve">
          <source>There are a lot of gcc flags but nothing fancy.  They mean:  Read from stdin; use O2 optimization level; output assembly language listing instead of a binary; the listing should use Intel assembly language syntax; the input is in C language (usually language is inferred from input file extension, but there is no file extension when reading from stdin); and write to stdout.</source>
          <target state="translated">Hay muchas banderas de GCC pero nada elegante.Significan:Leer desde stdin;usar el nivel de optimización de O2;el listado del lenguaje ensamblador de salida en lugar de un binario;el listado debe usar la sintaxis del lenguaje ensamblador Intel;la entrada está en lenguaje C (normalmente el lenguaje se infiere a partir de la extensión del archivo de entrada,pero no hay extensión de archivo cuando se lee desde stdin);y escribir en stdout.</target>
        </trans-unit>
        <trans-unit id="038c91abf47f7af8387f87881fe8c08dd6f3b995" translate="yes" xml:space="preserve">
          <source>There are already a few good answers to this question, but for the sake of completeness I wanted to point out that the applicable section of the C standard is 5.1.2.2.3/15 (which is the same as section 1.9/9 in the C++11 standard).  This section states that operators can only be regrouped if they are really associative or commutative.</source>
          <target state="translated">Ya hay algunas buenas respuestas a esta pregunta,pero en aras de la exhaustividad quería señalar que la sección aplicable de la norma C es la 5.1.2.2.315 (que es la misma que la sección 1.99 de la norma C++11).Esta sección establece que los operadores sólo pueden reagruparse si son realmente asociativos o conmutativos.</target>
        </trans-unit>
        <trans-unit id="34a6090f4401ef36f9853e0c1580d3e4d38191d7" translate="yes" xml:space="preserve">
          <source>There's nothing wrong with providing hints to the compiler as you've done here. It's a normal and expected part of the micro-optimization process to rearrange statements and expressions to see what differences they will bring.</source>
          <target state="translated">No hay nada de malo en dar pistas al compilador como lo has hecho aquí.Es una parte normal y esperada del proceso de micro-optimización el reacomodar las declaraciones y expresiones para ver qué diferencias traerán.</target>
        </trans-unit>
        <trans-unit id="f119f08c5c4dbeee8e65aa7456308d7e067dfe12" translate="yes" xml:space="preserve">
          <source>This is what I get from my compiler:</source>
          <target state="translated">Esto es lo que obtengo de mi compilador:</target>
        </trans-unit>
        <trans-unit id="f4fe0dbbf5143d55f866bd834ce8215252c70263" translate="yes" xml:space="preserve">
          <source>This makes it easy to type powers (no need to spell out 6 &lt;code&gt;a&lt;/code&gt;s with parens), and lets you have this kind of optimization without &lt;code&gt;-ffast-math&lt;/code&gt; in case you have something precision dependent such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation_algorithm&quot;&gt;compensated summation&lt;/a&gt; (an example where the order of operations is essential).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto hace que sea f&amp;aacute;cil escribir poderes (no es necesario deletrear 6 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; s con parens), y le permite tener este tipo de optimizaci&amp;oacute;n sin &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en caso de que tenga algo dependiente de la precisi&amp;oacute;n, como la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;suma compensada&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (un ejemplo donde el orden de operaciones es esencial).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3a21c378f482fb7cba0b9dc669736cc20cdb3cd" translate="yes" xml:space="preserve">
          <source>This outputs &lt;code&gt;1.000000e-05 0.000000e+00&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto genera &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1.000000e-05 0.000000e+00&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a954fcc81f3445fd1f1f16ee4798784fc70c5f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pow&lt;/code&gt; instead of a multiplication tree reduces the error bound by a &lt;em&gt;factor of 4&lt;/em&gt;.  Compilers should not (and generally do not) make &quot;optimizations&quot; that increase error unless licensed to do so by the user (e.g. via &lt;code&gt;-ffast-math&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El uso de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; en&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lugar de un &amp;aacute;rbol de multiplicaci&amp;oacute;n reduce el error limitado por un &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;factor de 4&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los compiladores no deber&amp;iacute;an (y generalmente no lo hacen) &quot;optimizaciones&quot; que aumenten el error a menos que el usuario lo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (por ejemplo, a trav&amp;eacute;s de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-ffast-math&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="02de4b219e179d76a6d96b22b18d1566e505141d" translate="yes" xml:space="preserve">
          <source>What I am curious about is that when I replaced &lt;code&gt;pow(a,6)&lt;/code&gt; with &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; using GCC 4.5.1 and options &quot;&lt;code&gt;-O3 -lm -funroll-loops -msse4&lt;/code&gt;&quot;, it uses 5 &lt;code&gt;mulsd&lt;/code&gt; instructions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo que tengo curiosidad es que cuando reemplac&amp;eacute; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; usando GCC 4.5.1 y las opciones &quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-O3 -lm -funroll-loops -msse4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;, usa &lt;/font&gt;&lt;/font&gt; &lt;code&gt;mulsd&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 5 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mulsd&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="019e7ae12d49514249ba5f50e9f30acbe61db21a" translate="yes" xml:space="preserve">
          <source>While the compiler may be justified in considering the two expressions to deliver inconsistent results (without the proper switches), there's no need for you to be bound by that restriction. The difference will be incredibly tiny - so much so that if the difference matters to you, you should not be using standard floating point arithmetic in the first place.</source>
          <target state="translated">Si bien el compilador puede estar justificado al considerar que las dos expresiones dan resultados incoherentes (sin los cambios adecuados),no hay necesidad de que esté obligado por esa restricción.La diferencia será increíblemente pequeña,tanto que si la diferencia le importa,no debería utilizar la aritmética estándar de punto flotante en primer lugar.</target>
        </trans-unit>
        <trans-unit id="cde544d42fbafa1f338764a2c2773d3ec5822639" translate="yes" xml:space="preserve">
          <source>While the following operation:</source>
          <target state="translated">Mientras que la siguiente operación:</target>
        </trans-unit>
        <trans-unit id="db94284baa6947e0b56737b3af7e707f25f8165c" translate="yes" xml:space="preserve">
          <source>Why do compilers not recognize this optimization trick?</source>
          <target state="translated">¿Por qué los compiladores no reconocen este truco de optimización?</target>
        </trans-unit>
        <trans-unit id="b7d445e56ae3b3b51205e7428cddf177214a3a36" translate="yes" xml:space="preserve">
          <source>Why doesn't GCC optimize a*a*a*a*a*a to (a*a*a)*(a*a*a)</source>
          <target state="translated">¿Por qué el CCG no optimiza a*a*a*a*a*a para (a*a*a)*(a*a*a)</target>
        </trans-unit>
        <trans-unit id="5ed24af97064af0cd9ce60a3e5e0f869a731bf23" translate="yes" xml:space="preserve">
          <source>You can probably also forget that this is C++ and just use it in the C program (if it compiles with a C++ compiler).</source>
          <target state="translated">Probablemente también puedes olvidar que esto es C++y simplemente usarlo en el programa C (si compila con un compilador de C++).</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="b700a3c7f4d2e0b51edf81e37c6548c3fcace4ed" translate="yes" xml:space="preserve">
          <source>fundamentally the following operation:</source>
          <target state="translated">fundamentalmente la siguiente operación:</target>
        </trans-unit>
        <trans-unit id="fb6edeecaf4ad3a1a421caf127f44a6e529f8f35" translate="yes" xml:space="preserve">
          <source>gcc actually can do this optimization, even for floating-point numbers. For example,</source>
          <target state="translated">GCC puede hacer esta optimización,incluso para los números de punto flotante.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="67297856c412ac15e2bf250ffaa0316856878b1f" translate="yes" xml:space="preserve">
          <source>has a inherent error of approximately the &lt;strong&gt;same magnitude as the error in any single multiplication or division&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tiene un error inherente de aproximadamente la &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;misma magnitud que el error en cualquier multiplicaci&amp;oacute;n o divisi&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75d90159c1ba5de1cab0baec48b5e1f3ec29a879" translate="yes" xml:space="preserve">
          <source>has a inherent error that is greater more than &lt;strong&gt;5 times the error of a single multiplication&lt;/strong&gt; or division (because you are combining 5 multiplications).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tiene un error inherente que es mayor que &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5 veces el error de una sola multiplicaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o divisi&amp;oacute;n (porque est&amp;aacute; combinando 5 multiplicaciones).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fda107f074252af4966e46b506713bd46dec57a" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;a*a*a*a*a*a&lt;/code&gt;  to &lt;code&gt;pow(a,6)&lt;/code&gt; it may actually reduce the accuracy because &quot;a&quot; was some special value that allows multiplication without error (a power of 2 or some small integer number)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;si se optimiza &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; to &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en realidad puede reducir la precisi&amp;oacute;n porque &quot;a&quot; era un valor especial que permite la multiplicaci&amp;oacute;n sin error (una potencia de 2 o alg&amp;uacute;n n&amp;uacute;mero entero peque&amp;ntilde;o)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf71e4ed346f57912a1e79b200383d8fa6c3fc01" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;pow(a,6)&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; or &lt;code&gt;(a*a)*(a*a)*(a*a)&lt;/code&gt; there still can be a loss of accuracy compared to &lt;code&gt;pow&lt;/code&gt; function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;si optimiza &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a)*(a*a)*(a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; todav&amp;iacute;a puede haber una p&amp;eacute;rdida de precisi&amp;oacute;n en comparaci&amp;oacute;n con la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cfec1f2de6ea415d4cf8ceedd8dcaca5c6ec2e8" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;pow(a,6)&lt;/code&gt; to &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; it &lt;strong&gt;may&lt;/strong&gt; improve performance, but drastically reduce the accuracy for floating point numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;si optimiza &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;puede&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; mejorar el rendimiento, pero reducir dr&amp;aacute;sticamente la precisi&amp;oacute;n de los n&amp;uacute;meros de coma flotante.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fef10f56fa82200041ab99b1d4d2485b58462410" translate="yes" xml:space="preserve">
          <source>which reduces the number of multiply instructions to 3. &lt;code&gt;icc&lt;/code&gt; has similar behavior.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lo que reduce el n&amp;uacute;mero de instrucciones de multiplicaci&amp;oacute;n a 3. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;icc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiene un comportamiento similar.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8cd4c1833209b82d692c0005ba1b92e7b7924368" translate="yes" xml:space="preserve">
          <source>while if I write &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;, it will produce</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mientras que si escribo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , producir&amp;aacute;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e99df94664796974ee5510f379629ed4b7b1e71" translate="yes" xml:space="preserve">
          <source>with &lt;code&gt;-O -funsafe-math-optimizations&lt;/code&gt;. This reordering violates IEEE-754, though, so it requires the flag.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-O -funsafe-math-optimizations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, este reordenamiento viola IEEE-754, por lo que requiere la bandera.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a019b70a71456f8a761d32e12d9c417e7e1379b6" translate="yes" xml:space="preserve">
          <source>with just &lt;code&gt;-O&lt;/code&gt;. For unsigned integers, it's even easier since they work mod powers of 2 and so can be reordered freely even in the face of overflow.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;con solo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-O&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para enteros sin signo, es a&amp;uacute;n m&amp;aacute;s f&amp;aacute;cil ya que funcionan con potencias mod de 2 y, por lo tanto, se pueden reordenar libremente incluso ante el desbordamiento.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
