<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/6430448">
    <body>
      <group id="6430448">
        <trans-unit id="4d250087c10e817bb864c62232c3ce88493f0870" translate="yes" xml:space="preserve">
          <source>... once you know what kind of programmer &lt;em&gt;you&lt;/em&gt; are, you can use the &quot;-ffast-math&quot; switch to tell GCC that &quot;Hey, GCC, I know what I am doing!&quot;. This will allow GCC to convert a*a*a*a*a*a into a different piece of text - it looks different from a*a*a*a*a*a - but still computes a number within the error interval of a*a*a*a*a*a. This is OK, since you already know you are working with intervals, not ideal numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;...自分がどのようなプログラマである&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;か&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;わかったら&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、「-ffast-math」スイッチを使用して、GCCに「ねえ、GCC、私がやっていることを知っている！」と伝えます。これにより、GCCはa * a * a * a * a * aを別のテキストに変換できます-これはa * a * a * a * a * aとは異なって見えますが、それでもエラー間隔内の数値を計算しますa * a * a * a * a * a。これは、理想的な数値ではなく間隔で作業していることをすでに知っているので、問題ありません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e601cb9e293c7f55858b9c7c9a8e1f3cfbbcf80f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/6430525/463065&quot;&gt;&lt;strong&gt;Lambdageek&lt;/strong&gt;&lt;/a&gt; correctly points out that because associativity does not hold for floating-point numbers, the &quot;optimization&quot; of &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; may change the value.  This is why it is disallowed by C99 (unless specifically allowed by the user, via compiler flag or pragma).  Generally, the assumption is that the programmer wrote what she did for a reason, and the compiler should respect that.  If you want &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;, write that.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/6430525/463065&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lambdageek&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、連想性が浮動小数点数に対して保持されないため、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; へ&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の「最適化」&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が変わる可能性があることを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正しく指摘してい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます値。これがC99で許可されていない理由です（コンパイラフラグまたはプラグマを介して、ユーザーによって特に許可されていない限り）。一般的には、プログラマーが理由で書いたことをプログラマーが想定し、コンパイラーはそれを尊重する必要があります。あなたがしたい場合は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、書き込みいます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3554b22e1fc90a354131abcb9d80400bf1e1fd41" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;strong&gt;Clarification for the curious:&lt;/strong&gt; this does not find the optimal way to compute powers, but since &lt;a href=&quot;http://en.wikipedia.org/wiki/Addition-chain_exponentiation&quot;&gt;finding the optimal solution is an NP-complete problem&lt;/a&gt; and this is only worth doing for small powers anyway (as opposed to using &lt;code&gt;pow&lt;/code&gt;), there's no reason to fuss with the detail.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好奇心の明確化：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これはべき乗を計算するための最適な方法を見つけませんが&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Addition-chain_exponentiation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、最適解を見つけることはNP完全問題で&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あり、これはとにかく（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;するのではなく）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;小さな力に対してのみ行う価値&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;があるため、理由はありません細部にこだわる。&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="8ec2ebf132faa836164fcc84f4c1f54c2408fce2" translate="yes" xml:space="preserve">
          <source>Another similar case: most compilers won't optimize &lt;code&gt;a + b + c + d&lt;/code&gt; to &lt;code&gt;(a + b) + (c + d)&lt;/code&gt; (this is an optimization since the second expression can be pipelined better) and evaluate it as given (i.e. as &lt;code&gt;(((a + b) + c) + d)&lt;/code&gt;). This too is because of corner cases:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;別の同様のケース：ほとんどのコンパイラーは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a + b + c + d&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a + b) + (c + d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最適化せず（これは、2番目の式をより適切にパイプライン化できるため、最適化です）、与えられた&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とおりに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;評価します（つまり&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(((a + b) + c) + d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これもコーナーケースが原因です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c9a86236232165a7908c885e6e3608d6ebaa349" translate="yes" xml:space="preserve">
          <source>As Lambdageek pointed out float multiplication is not associative and you can get less accuracy, but also when get better accuracy you can argue against optimisation, because you want a deterministic application. For example in game simulation client/server, where every client has to simulate the same world you want floating point calculations to be deterministic.</source>
          <target state="translated">Lambdageekさんが指摘しているように、浮動小数点の乗算は連想的ではないので、精度が悪くなることがあります。例えば、ゲームシミュレーションのクライアントサーバでは、すべてのクライアントが同じ世界をシミュレートしなければならないので、浮動小数点演算は決定論的なものにしたいのです。</target>
        </trans-unit>
        <trans-unit id="a878690db08938608264102fc103f5780dab6683" translate="yes" xml:space="preserve">
          <source>As a result, most compilers are very conservative about reordering floating point calculations unless they can be sure that the answer will stay the same, or unless you tell them you don't care about numerical accuracy.  For example: &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt;the &lt;code&gt;-fassociative-math&lt;/code&gt; option&lt;/a&gt; of gcc which allows gcc to reassociate floating point operations, or even the &lt;code&gt;-ffast-math&lt;/code&gt; option which allows even more aggressive tradeoffs of accuracy against speed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;結果として、ほとんどのコンパイラーは、答えが変わらないと確信できない場合、または数値の精度を気にしないように指示しない限り、浮動小数点計算の並べ替えについて非常に保守的です。例えば：&lt;/font&gt;&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html&quot;&gt; &lt;code&gt;-fassociative-math&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オプション&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; GCCは浮動小数点演算、あるいは再結合することを可能にするGCCの&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;速度に対する精度の一層積極的なトレードオフを可能にするオプション。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1f7025a0a8653e90ed33ccd59a524411194bee3" translate="yes" xml:space="preserve">
          <source>As other posters have noted, this option is not possible in floating point, because floating point arithmetic is not associative.</source>
          <target state="translated">他の投稿者が指摘しているように、浮動小数点演算は連想的ではないため、このオプションは浮動小数点では使用できません。</target>
        </trans-unit>
        <trans-unit id="5cab4fa1adf07c1f4fab622ca0e1c9a2bbadc951" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems&quot;&gt;Floating Point Math is not Associative&lt;/a&gt;.  The way you group the operands in floating point multiplication has an effect on the numerical accuracy of the answer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのため&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮動小数点演算が連想ではありません&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮動小数点乗算でオペランドをグループ化する方法は、回答の数値精度に影響を与えます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac72a721d84b77b0b13d7bfd347c5a737d30b1ff" translate="yes" xml:space="preserve">
          <source>Because a 32-bit floating-point number - such as 1.024 - is not 1.024. In a computer, 1.024 is an interval: from (1.024-e) to (1.024+e), where &quot;e&quot; represents an error. Some people fail to realize this and also believe that * in a*a stands for multiplication of arbitrary-precision numbers without there being any errors attached to those numbers. The reason why some people fail to realize this is perhaps the math computations they exercised in elementary schools: working only with ideal numbers without errors attached, and believing that it is OK to simply ignore &quot;e&quot; while performing multiplication. They do not see the &quot;e&quot; implicit in &quot;float a=1.2&quot;, &quot;a*a*a&quot; and similar C codes.</source>
          <target state="translated">なぜなら、1.024 のような 32 ビット浮動小数点数は 1.024 ではないからです。コンピュータでは、1.024は(1.024-e)から(1.024+e)までの区間であり、&quot;e &quot;は誤差を表します。このことに気づかず、a*aの*は任意の精度の数字の掛け算であり、その数字には誤差がないと思っている人もいます。このことに気づかない人がいるのは、小学校で習った算数の計算で、誤差のない理想数だけを使って、掛け算をするときは「e」を無視してもいいと思っているからかもしれません。彼らは &quot;float a=1.2&quot; や &quot;a*a*a&quot; などの C 言語のコードに暗黙の &quot;e&quot; があることに気がついていません。</target>
        </trans-unit>
        <trans-unit id="fc0b3ee381fd7de113933bbc502a60dac899d423" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b62e31b37189d012f547a0a066099b50cab9e5ae" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a*a*a*a*a*a&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下のための&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac18e696c6c6f8d2010e80747b9e03f2cdd1dbfb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt;,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4c7cce855605e6a3df3d02aa3dd09fd1da9c306" translate="yes" xml:space="preserve">
          <source>Fortran (designed for scientific computing) has a built-in power operator, and as far as I know Fortran compilers will commonly optimize raising to integer powers in a similar fashion to what you describe.  C/C++ unfortunately don't have a power operator, only the library function &lt;code&gt;pow()&lt;/code&gt;.  This doesn't prevent smart compilers from treating &lt;code&gt;pow&lt;/code&gt; specially and computing it in a faster way for special cases, but it seems they do it less commonly ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Fortran（科学計算用に設計されています）にはべき乗演算子が組み込まれており、私が知る限り、Fortranコンパイラーは通常、整数のべき乗に最適化します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C / C ++には残念ながらパワー演算子がなく、ライブラリ関数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、スマートコンパイラが&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特別に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;扱い&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、特別な場合にそれをより高速に計算&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;することを妨げません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が、あまり一般的ではないようです...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="28395c97c243c9dc54c1873c68dbaf715650cbaa" translate="yes" xml:space="preserve">
          <source>GCC does actually optimize &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; when a is an integer.  I tried with this command:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aが整数の場合、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCCは実際に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に最適化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私はこのコマンドで試しました：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5cff5d070250d7e8684c02968fdc4cf5608e1d1a" translate="yes" xml:space="preserve">
          <source>GCC doesn't support this pragma, but with the default options, it assumes it to be &lt;code&gt;ON&lt;/code&gt;; thus for targets with a hardware FMA, if one wants to prevent the transformation &lt;code&gt;a*b+c&lt;/code&gt; to fma(a,b,c), one needs to provide an option such as &lt;code&gt;-ffp-contract=off&lt;/code&gt; (to explicitly set the pragma to &lt;code&gt;OFF&lt;/code&gt;) or &lt;code&gt;-std=c99&lt;/code&gt; (to tell GCC to conform to some C standard version, here C99, thus follow the above paragraph). In the past, the latter option was not preventing the transformation, meaning that GCC was not conforming on this point: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&quot;&gt;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCCはこのプラグマをサポートしていませんが、デフォルトのオプションでは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;であると想定しています&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。したがって、ハードウェアFMAを備えたターゲットの場合&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*b+c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;からfma（a、b、c）への&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;変換を防止したい場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffp-contract=off&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（プラグマを明示的に設定する）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などのオプションを提供する必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;to &lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）または&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-std=c99&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（GCCにC標準バージョン、ここではC99に準拠するように指示するため、上記の段落に従います）。以前は、後者のオプションは変換を妨げていませんでした。つまり、GCCはこの点に準拠していませんでした：&lt;/font&gt;&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//gcc.gnu.org/bugzilla/show_bug.cgi?id=37845&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="981522191a8758a2cf80c7f0915aa11eabaca13e" translate="yes" xml:space="preserve">
          <source>Here's the important part of the output.  I've annotated it with some comments indicating what's going on in the assembly language:</source>
          <target state="translated">ここに出力の重要な部分があります。アセンブリ言語で何が起こっているかを示すいくつかのコメントを付けました。</target>
        </trans-unit>
        <trans-unit id="1853745e32869f380edec4598bc3ef06f0430bde" translate="yes" xml:space="preserve">
          <source>Hope this can be useful.</source>
          <target state="translated">お役に立てれば幸いです。</target>
        </trans-unit>
        <trans-unit id="85e39a3e78f49e60da31dbc9c4c7ab654a9d8ff7" translate="yes" xml:space="preserve">
          <source>I am doing some numerical optimization on a scientific application. One thing I noticed is that GCC will optimize the call &lt;code&gt;pow(a,2)&lt;/code&gt; by compiling it into &lt;code&gt;a*a&lt;/code&gt;, but the call &lt;code&gt;pow(a,6)&lt;/code&gt; is not optimized and will actually call the library function &lt;code&gt;pow&lt;/code&gt;, which greatly slows down the performance. (In contrast, &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_C++_Compiler&quot;&gt;Intel C++ Compiler&lt;/a&gt;, executable &lt;code&gt;icc&lt;/code&gt;, will eliminate the library call for &lt;code&gt;pow(a,6)&lt;/code&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;科学的なアプリケーションで数値の最適化を行っています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私が気づいたことの一つは、GCCが通話最適化することである&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;にそれをコンパイルすることによって&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が、コールの&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最適化されておらず、実際には、ライブラリ関数呼び出します&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大幅に遅くなり、パフォーマンス。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（対照的に、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_C++_Compiler&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インテルC ++コンパイラー&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、実行可能&lt;/font&gt;&lt;/font&gt; &lt;code&gt;icc&lt;/code&gt; は&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のライブラリー呼び出しを排除します&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68e041c100d9c66ab0c3bcee649f2dba3fb13072" translate="yes" xml:space="preserve">
          <source>I was surprised to learn from the other answers that this expression could indeed be optimized with the proper compiler switches. Either the optimization is trivial, or it is an edge case of a much more common optimization, or the compiler writers were extremely thorough.</source>
          <target state="translated">他の回答から、この式は適切なコンパイラスイッチで確かに最適化できることを知って驚きました。最適化が些細なものなのか、それとももっと一般的な最適化のエッジケースなのか、あるいはコンパイラの執筆者が非常に徹底していたのか、どちらなのでしょうか。</target>
        </trans-unit>
        <trans-unit id="8e52965681e9d8c31e55fa89df4f421c02c286ab" translate="yes" xml:space="preserve">
          <source>I would not have expected this case to be optimized at all. It can't be very often where an expression contains subexpressions that can be regrouped to remove entire operations. I would expect compiler writers to invest their time in areas which would be more likely to result in noticeable improvements, rather than covering a rarely encountered edge case.</source>
          <target state="translated">このケースが最適化されるとは全く予想していませんでした。式に副式が含まれていて、それを再グループ化して操作全体を削除することができることはあまりありません。コンパイラライターは、めったに遭遇しないエッジケースをカバーするのではなく、顕著な改善をもたらす可能性の高い分野に時間を投資することを期待しています。</target>
        </trans-unit>
        <trans-unit id="03310089f35a8bb06c3934edfb960e33bebbf631" translate="yes" xml:space="preserve">
          <source>I'm using system GCC on Linux Mint 16 Petra, an Ubuntu derivative.  Here's the gcc version:</source>
          <target state="translated">Linux Mint 16 PetraというUbuntuの派生品でシステムGCCを使っています。ここにgccのバージョンがあります。</target>
        </trans-unit>
        <trans-unit id="71a578b2882ad2932339e7108c7ed7c15ddeaa8e" translate="yes" xml:space="preserve">
          <source>If a compiler doesn't support this pragma, it must be conservative by avoiding any such optimization, in case the developer has chosen to set it to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイラーがこのプラグマをサポートしていない場合、開発者が&lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に設定することを選択した場合に備えて、そのような最適化を回避することにより、保守的でなければなりません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88c654fab2a03795d25bdf97b7e8f0998123d1d1" translate="yes" xml:space="preserve">
          <source>In general you know that for arbitrary floating point values &quot;pow&quot; has better accuracy than any function you could eventually write, but in some special cases multiple multiplications may have better accuracy and performance, it is up to the developer choosing what is more appropriate, eventually commenting the code so that noone else would &quot;optimize&quot; that code.</source>
          <target state="translated">一般的には、任意の浮動小数点値については、&quot;pow &quot;が最終的にどの関数よりも精度が良いことを知っていると思いますが、いくつかの特別なケースでは、複数回の乗算の方が精度と性能が良い場合があります。</target>
        </trans-unit>
        <trans-unit id="cc6d49616d403affbb828d1c957be55e63e50885" translate="yes" xml:space="preserve">
          <source>Library functions like &quot;pow&quot; are usually carefully crafted to yield the minimum possible error (in generic case). This is usually achieved approximating functions with splines (according to Pascal's comment the most common implementation seems to be using &lt;a href=&quot;https://en.wikipedia.org/wiki/Remez_algorithm&quot;&gt;Remez algorithm&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「pow」のようなライブラリ関数は、通常、可能な限り最小限のエラーを生成するように注意深く作成されています（一般的な場合）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは通常、スプラインで関数を近似することで達成されます（Pascalのコメントによると、最も一般的な実装は&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Remez_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Remezアルゴリズム&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用している&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ようです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c6a32c2fef0ceb0b9c94cd7c9b0a92dc173bfc48" translate="yes" xml:space="preserve">
          <source>No posters have mentioned the contraction of floating expressions yet (ISO C standard, 6.5p8 and 7.12.2). If the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma is set to &lt;code&gt;ON&lt;/code&gt;, the compiler is allowed to regard an expression such as &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; as a single operation, as if evaluated exactly with a single rounding. For instance, a compiler may replace it by an internal power function that is both faster and more accurate. This is particularly interesting as the behavior is partly controlled by the programmer directly in the source code, while compiler options provided by the end user may sometimes be used incorrectly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浮動式の縮小について言及しているポスターはまだありません（ISO C標準、6.5p8および7.12.2）。場合&lt;/font&gt;&lt;/font&gt; &lt;code&gt;FP_CONTRACT&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プラグマに設定されて&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ON&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、コンパイラは、次のような表現見なすように許可されている&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;単一の操作として、単一の丸めと正確に評価されているかのように。たとえば、コンパイラは、より高速で正確な内部電源関数に置き換えます。エンドユーザーが提供するコンパイラオプションが誤って使用される場合がある一方で、動作は部分的にプログラマによってソースコードで直接制御されるため、これは特に興味深いものです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95a717f5c6110339b6c63d4df7945ada42cd7db8" translate="yes" xml:space="preserve">
          <source>Note that GCC provides &lt;code&gt;__builtin_powi(x,n)&lt;/code&gt; as an alternative to &lt;code&gt;pow( )&lt;/code&gt;, which should generate an inline multiplication tree.  Use that if you want to trade off accuracy for performance, but do not want to enable fast-math.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCCは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、インライン乗算ツリーを生成する必要がある&lt;/font&gt; &lt;code&gt;pow( )&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;代わりに&lt;/font&gt;&lt;/font&gt; &lt;code&gt;__builtin_powi(x,n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供することに注意してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;精度とパフォーマンスをトレードオフしたいが、高速演算を有効にしたくない場合に使用します。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="94c760a7cba09a8bca02fa707bf827e1a8cc56ea" translate="yes" xml:space="preserve">
          <source>Should majority of programmers recognize (and be able to execute on) the idea that C expression a*a*a*a*a*a is not actually working with ideal numbers, the GCC compiler would then be FREE to optimize &quot;a*a*a*a*a*a&quot; into say &quot;t=(a*a); t*t*t&quot; which requires a smaller number of multiplications. But unfortunately, the GCC compiler does not know whether the programmer writing the code thinks that &quot;a&quot; is a number with or without an error. And so GCC will only do what the source code looks like - because that is what GCC sees with its &quot;naked eye&quot;.</source>
          <target state="translated">大多数のプログラマが、C言語の式a*a*a*a*a*a*a*aが実際には理想的な数ではないことを認識し、実行できるようになれば、GCCコンパイラは &quot;a*a*a*a*a*a*a &quot;を、より少ない乗算数を必要とする &quot;t=(a*a);t*t*t &quot;に自由に最適化することができます。しかし、残念ながら、GCCコンパイラは、コードを書いているプログラマが、&quot;a &quot;がエラーのある数字であると思っているか、エラーのない数字であると思っているかを知りません。そのため、GCCはソースコードがどのように見えるかだけを実行します-なぜなら、それはGCCが「肉眼」で見ているものだからです。</target>
        </trans-unit>
        <trans-unit id="28ed3ac2704e149ae2dd87d11eccdff53fdf0451" translate="yes" xml:space="preserve">
          <source>Signed integers, as Peter Cordes pointed out in a comment, can do this optimization without &lt;code&gt;-funsafe-math-optimizations&lt;/code&gt; since it holds exactly when there is no overflow and if there is overflow you get undefined behavior. So you get</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;符号付き整数は、Peter Cordesがコメントで指摘したように、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;オーバーフローがない場合に正確に保持され、オーバーフローがある場合に未定義の動作が発生するため、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-funsafe-math-optimizations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なしでこの最適化を実行できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;だからあなたは得る&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4dcee4d2845f68dd48259ec19ca5fa93c40dae90" translate="yes" xml:space="preserve">
          <source>Some years ago I was trying to make it more convenient to calculate integer powers in an optimal way, and came up with the following.  It's C++, not C though, and still depends on the compiler being somewhat smart about how to optimize/inline things. Anyway, hope you might find it useful in practice:</source>
          <target state="translated">数年前、私は整数の累乗を最適な方法で計算するのをもっと便利にしようとしていて、次のようなものを思いつきました。これはC++であってCではないが、コンパイラがどのようにインラインで最適化するかについて多少賢いかどうかに依存している。いずれにしても、あなたが実際に役立つことを見つけるかもしれないことを願っています。</target>
        </trans-unit>
        <trans-unit id="f69c9a253137aba303e8ac403c17349ba850c078" translate="yes" xml:space="preserve">
          <source>That can be a pain to write, though; why can't the compiler just do [what you consider to be] the right thing when you use &lt;code&gt;pow(a,6)&lt;/code&gt;?  Because it would be the &lt;em&gt;wrong&lt;/em&gt; thing to do.  On a platform with a good math library, &lt;code&gt;pow(a,6)&lt;/code&gt; is significantly more accurate than either &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; or &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;.  Just to provide some data, I ran a small experiment on my Mac Pro, measuring the worst error in evaluating a^6 for all single-precision floating numbers between [1,2):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、これを書くのは面倒なことです。なぜ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用するときに、コンパイラーが正しいと見なすことができないの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ですか？なぜならそれを行うのは&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;間違って&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いるからです。優れた数学ライブラリを備えたプラットフォームでは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;よりもはるかに正確&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。データを提供するために、Mac Proで小さな実験を行い、[1,2）の間のすべての単精度浮動小数点数についてa ^ 6を評価する際の最悪のエラーを測定しました。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd79ee104a238b2bcbb0aefa26e43a29a96700ad" translate="yes" xml:space="preserve">
          <source>The compiler should be really carefull to the kind of optimization it is doing:</source>
          <target state="translated">コンパイラはどのような最適化を行っているのか、本当に気をつけてください。</target>
        </trans-unit>
        <trans-unit id="70f3ac8d17a4f4ef97f85ecb089f37ed70d7a2d4" translate="yes" xml:space="preserve">
          <source>The default state of the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma is implementation-defined, so that a compiler is allowed to do such optimizations by default. Thus portable code that needs to strictly follow the IEEE 754 rules should explicitly set it to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;FP_CONTRACT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プラグマ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のデフォルトの状態&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は実装定義なので、コンパイラーはデフォルトでそのような最適化を実行できます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、IEEE 754のルールに厳密に従う必要がある移植可能なコードでは、明示的に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;OFF&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;設定する必要があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="032412492bf0d092f330b93773053935967db4a8" translate="yes" xml:space="preserve">
          <source>The only thing that make sense (personal opinion, and apparently a choice in GCC wichout any particular optimization or compiler flag) to optimize should be replacing &quot;pow(a,2)&quot; with &quot;a*a&quot;. That would be the only sane thing a compiler vendor should do.</source>
          <target state="translated">最適化するために唯一意味のあることは(個人的な意見ですが、GCCでは特定の最適化やコンパイラフラグを使わずに選択できるようです)、&quot;pow(a,2)&quot;を &quot;a*a &quot;に置き換えることです。これはコンパイラベンダがすべき唯一のまともなことです。</target>
        </trans-unit>
        <trans-unit id="a622439a8bfbafc241f087dbbd072315176f64bb" translate="yes" xml:space="preserve">
          <source>Then just use it as &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次に、それを&lt;/font&gt;&lt;/font&gt; &lt;code&gt;power&amp;lt;6&amp;gt;(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;として使用し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf492b55441273a0253418f344466dc73cd10073" translate="yes" xml:space="preserve">
          <source>There are a lot of gcc flags but nothing fancy.  They mean:  Read from stdin; use O2 optimization level; output assembly language listing instead of a binary; the listing should use Intel assembly language syntax; the input is in C language (usually language is inferred from input file extension, but there is no file extension when reading from stdin); and write to stdout.</source>
          <target state="translated">たくさんの gcc フラグがありますが、特に派手なものはありません。これらのフラグの意味は以下の通りです。stdin から読み込む、O2 最適化レベルを使用する、バイナリではなくアセンブリ言語のリストを出力する、リストは Intel のアセンブリ言語の構文を使用する、入力は C 言語 (通常は入力ファイルの拡張子から言語を推測しますが、stdin から読み込む場合は拡張子はありません)、そして標準出力に書き込む、という意味です。</target>
        </trans-unit>
        <trans-unit id="038c91abf47f7af8387f87881fe8c08dd6f3b995" translate="yes" xml:space="preserve">
          <source>There are already a few good answers to this question, but for the sake of completeness I wanted to point out that the applicable section of the C standard is 5.1.2.2.3/15 (which is the same as section 1.9/9 in the C++11 standard).  This section states that operators can only be regrouped if they are really associative or commutative.</source>
          <target state="translated">この質問に対する良い回答はすでにいくつかありますが、完全性を保つために、C標準の該当するセクションは5.1.2.2.2.315(C++11標準の1.99と同じです)であることを指摘しておきたいと思います。このセクションでは、演算子は本当に連想的または可換的である場合にのみ再グループ化できると述べています。</target>
        </trans-unit>
        <trans-unit id="34a6090f4401ef36f9853e0c1580d3e4d38191d7" translate="yes" xml:space="preserve">
          <source>There's nothing wrong with providing hints to the compiler as you've done here. It's a normal and expected part of the micro-optimization process to rearrange statements and expressions to see what differences they will bring.</source>
          <target state="translated">あなたがここで行ったように、コンパイラにヒントを提供することには何の問題もありません。ステートメントや式を並べ替えて、どのような違いをもたらすかを確認するのは、マイクロ最適化プロセスの正常で期待される部分です。</target>
        </trans-unit>
        <trans-unit id="f119f08c5c4dbeee8e65aa7456308d7e067dfe12" translate="yes" xml:space="preserve">
          <source>This is what I get from my compiler:</source>
          <target state="translated">コンパイラからはこんな感じで出てきます。</target>
        </trans-unit>
        <trans-unit id="f4fe0dbbf5143d55f866bd834ce8215252c70263" translate="yes" xml:space="preserve">
          <source>This makes it easy to type powers (no need to spell out 6 &lt;code&gt;a&lt;/code&gt;s with parens), and lets you have this kind of optimization without &lt;code&gt;-ffast-math&lt;/code&gt; in case you have something precision dependent such as &lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation_algorithm&quot;&gt;compensated summation&lt;/a&gt; (an example where the order of operations is essential).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、タイプパワー（6を綴るする必要はありませんに簡単にそれを作る&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;括弧で複数可）を、そしてあなたがすることなく、最適化のこの種を持っていることができます&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;、次のような依存何か精度持つ場合には&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Kahan_summation_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、補償の総和&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（例えば、順番を操作の必須です）。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e3a21c378f482fb7cba0b9dc669736cc20cdb3cd" translate="yes" xml:space="preserve">
          <source>This outputs &lt;code&gt;1.000000e-05 0.000000e+00&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは&lt;/font&gt; &lt;code&gt;1.000000e-05 0.000000e+00&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出力します&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4a954fcc81f3445fd1f1f16ee4798784fc70c5f8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;pow&lt;/code&gt; instead of a multiplication tree reduces the error bound by a &lt;em&gt;factor of 4&lt;/em&gt;.  Compilers should not (and generally do not) make &quot;optimizations&quot; that increase error unless licensed to do so by the user (e.g. via &lt;code&gt;-ffast-math&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;乗算ツリーの代わりに&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すると、エラーバウンド&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が4倍になり&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイラーは、ユーザーが（例えば&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-ffast-math&lt;/code&gt; を使用して&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;許可を得ている場合を除き、エラーを増加させる「最適化」を行うべきではありません（通常は行いません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="02de4b219e179d76a6d96b22b18d1566e505141d" translate="yes" xml:space="preserve">
          <source>What I am curious about is that when I replaced &lt;code&gt;pow(a,6)&lt;/code&gt; with &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; using GCC 4.5.1 and options &quot;&lt;code&gt;-O3 -lm -funroll-loops -msse4&lt;/code&gt;&quot;, it uses 5 &lt;code&gt;mulsd&lt;/code&gt; instructions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私が気になるのは&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; GCC 4.5.1とオプション &quot; &lt;/font&gt; &lt;code&gt;-O3 -lm -funroll-loops -msse4&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;を使用して&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a * a * a * a * a * a&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に置き換えたときに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、 5 &lt;/font&gt; &lt;code&gt;mulsd&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;命令：&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="019e7ae12d49514249ba5f50e9f30acbe61db21a" translate="yes" xml:space="preserve">
          <source>While the compiler may be justified in considering the two expressions to deliver inconsistent results (without the proper switches), there's no need for you to be bound by that restriction. The difference will be incredibly tiny - so much so that if the difference matters to you, you should not be using standard floating point arithmetic in the first place.</source>
          <target state="translated">コンパイラは(適切なスイッチを使用せずに)2つの式が矛盾した結果をもたらすと考えることが正当化されるかもしれませんが、その制限に縛られる必要はありません。違いは信じられないほど小さなもので、その違いが気になるのであれば、そもそも標準的な浮動小数点演算を使うべきではありません。</target>
        </trans-unit>
        <trans-unit id="cde544d42fbafa1f338764a2c2773d3ec5822639" translate="yes" xml:space="preserve">
          <source>While the following operation:</source>
          <target state="translated">以下の操作をしながら。</target>
        </trans-unit>
        <trans-unit id="db94284baa6947e0b56737b3af7e707f25f8165c" translate="yes" xml:space="preserve">
          <source>Why do compilers not recognize this optimization trick?</source>
          <target state="translated">なぜコンパイラはこの最適化のトリックを認識しないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="b7d445e56ae3b3b51205e7428cddf177214a3a36" translate="yes" xml:space="preserve">
          <source>Why doesn't GCC optimize a*a*a*a*a*a to (a*a*a)*(a*a*a)</source>
          <target state="translated">なぜGCCはa*a*a*a*a*a*aを(a*a*a)*(a*a*a)に最適化しないのか?</target>
        </trans-unit>
        <trans-unit id="5ed24af97064af0cd9ce60a3e5e0f869a731bf23" translate="yes" xml:space="preserve">
          <source>You can probably also forget that this is C++ and just use it in the C program (if it compiles with a C++ compiler).</source>
          <target state="translated">また、これがC++であることを忘れて、Cプログラムの中で使うこともできるでしょう(C++コンパイラでコンパイルされている場合)。</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="b700a3c7f4d2e0b51edf81e37c6548c3fcace4ed" translate="yes" xml:space="preserve">
          <source>fundamentally the following operation:</source>
          <target state="translated">基本的には次のような操作をします。</target>
        </trans-unit>
        <trans-unit id="fb6edeecaf4ad3a1a421caf127f44a6e529f8f35" translate="yes" xml:space="preserve">
          <source>gcc actually can do this optimization, even for floating-point numbers. For example,</source>
          <target state="translated">gcc は実際に浮動小数点数でもこの最適化を行うことができます。例えば</target>
        </trans-unit>
        <trans-unit id="67297856c412ac15e2bf250ffaa0316856878b1f" translate="yes" xml:space="preserve">
          <source>has a inherent error of approximately the &lt;strong&gt;same magnitude as the error in any single multiplication or division&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;には、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;単一の乗算または除算の&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;エラーとほぼ&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同じ大きさの&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;固有エラーが&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あります&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75d90159c1ba5de1cab0baec48b5e1f3ec29a879" translate="yes" xml:space="preserve">
          <source>has a inherent error that is greater more than &lt;strong&gt;5 times the error of a single multiplication&lt;/strong&gt; or division (because you are combining 5 multiplications).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;には、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;単一の乗算&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または除算の&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;誤差の5倍を&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;超える固有の誤差があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（5つの乗算を組み合わせているため）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fda107f074252af4966e46b506713bd46dec57a" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;a*a*a*a*a*a&lt;/code&gt;  to &lt;code&gt;pow(a,6)&lt;/code&gt; it may actually reduce the accuracy because &quot;a&quot; was some special value that allows multiplication without error (a power of 2 or some small integer number)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; を&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最適化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すると、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「a」はエラーなしで乗算できる特別な値（2の累乗または小さな整数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;であるため、実際には精度が低下する可能性があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf71e4ed346f57912a1e79b200383d8fa6c3fc01" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;pow(a,6)&lt;/code&gt; to &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; or &lt;code&gt;(a*a)*(a*a)*(a*a)&lt;/code&gt; there still can be a loss of accuracy compared to &lt;code&gt;pow&lt;/code&gt; function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(a*a)*(a*a)*(a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最適化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すると、依然として精度が失われる可能性があります&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pow&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;機能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と比較して&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cfec1f2de6ea415d4cf8ceedd8dcaca5c6ec2e8" translate="yes" xml:space="preserve">
          <source>if optimizing &lt;code&gt;pow(a,6)&lt;/code&gt; to &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; it &lt;strong&gt;may&lt;/strong&gt; improve performance, but drastically reduce the accuracy for floating point numbers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;pow(a,6)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*a*a*a*a*a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最適化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すると、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パフォーマンス&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;向上しますが、浮動小数点数の精度が大幅に低下します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fef10f56fa82200041ab99b1d4d2485b58462410" translate="yes" xml:space="preserve">
          <source>which reduces the number of multiply instructions to 3. &lt;code&gt;icc&lt;/code&gt; has similar behavior.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これにより、乗算命令の数が3に&lt;/font&gt;&lt;/font&gt; &lt;code&gt;icc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。icc&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;も同様の動作をします。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8cd4c1833209b82d692c0005ba1b92e7b7924368" translate="yes" xml:space="preserve">
          <source>while if I write &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt;, it will produce</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;(a*a*a)*(a*a*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と書けば&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e99df94664796974ee5510f379629ed4b7b1e71" translate="yes" xml:space="preserve">
          <source>with &lt;code&gt;-O -funsafe-math-optimizations&lt;/code&gt;. This reordering violates IEEE-754, though, so it requires the flag.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;-O -funsafe-math-optimizations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、この並べ替えはIEEE-754に違反するため、フラグが必要です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a019b70a71456f8a761d32e12d9c417e7e1379b6" translate="yes" xml:space="preserve">
          <source>with just &lt;code&gt;-O&lt;/code&gt;. For unsigned integers, it's even easier since they work mod powers of 2 and so can be reordered freely even in the face of overflow.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;-O&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;だけで&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;符号なし整数の場合、2の累乗のmodが機能するため、オーバーフローが発生した場合でも自由に並べ替えることができるため、さらに簡単です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
