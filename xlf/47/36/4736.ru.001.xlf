<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/4736">
    <body>
      <group id="4736">
        <trans-unit id="8c342e8585fceeee466cfc575e45384b0da85bd4" translate="yes" xml:space="preserve">
          <source>&quot;Hello,&quot; she said, &quot;How are you?&quot;</source>
          <target state="translated">&quot;Привет&quot;,-сказала она,-&quot;Как дела?&quot;</target>
        </trans-unit>
        <trans-unit id="33005ca44ed78f77c7fadc5a196abf1256960301" translate="yes" xml:space="preserve">
          <source>(As to your confusion, I don't know of any regular-expression dialect where &lt;code&gt;((.+?))&lt;/code&gt; would do the same thing. I suspect something got lost in transmission somewhere along the way.)</source>
          <target state="translated">(Что касается вашей путаницы, я не знаю ни одного диалекта регулярного выражения, где &lt;code&gt;((.+?))&lt;/code&gt; Делал бы то же самое. Я подозреваю, что что-то потеряно при передаче где-то по пути.)</target>
        </trans-unit>
        <trans-unit id="4ef24db075ab7963455bfe3ea7654428474ef88d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://neverfear.org/blog/view/Regex_tutorial_for_people_who_should_know_Regex__but_do_not___Part_1&quot;&gt;Regular Expressions - Everything you should know&lt;/a&gt; (PDF Series)</source>
          <target state="translated">&lt;a href=&quot;http://neverfear.org/blog/view/Regex_tutorial_for_people_who_should_know_Regex__but_do_not___Part_1&quot;&gt;Регулярные выражения - все, что вы должны знать&lt;/a&gt; (серия PDF)</target>
        </trans-unit>
        <trans-unit id="4c618840a436ae1359f6b753fc7b297f01d3edc4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;Mastering Regular Expressions&lt;/a&gt;, the &lt;a href=&quot;http://oreilly.com/catalog/9780596002893&quot;&gt;2nd Edition&lt;/a&gt;, and the &lt;a href=&quot;http://shop.oreilly.com/product/9780596528126.do&quot;&gt;3rd edition&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;Освоение регулярных выражений&lt;/a&gt; , &lt;a href=&quot;http://oreilly.com/catalog/9780596002893&quot;&gt;2-е издание&lt;/a&gt; и &lt;a href=&quot;http://shop.oreilly.com/product/9780596528126.do&quot;&gt;3-е издание&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a78dcd68ae6f3277cb0e045417feb90a498d6dd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://regexlib.com/Default.aspx&quot;&gt;Regular Expression Library&lt;/a&gt; (Predefined Regexes for common scenarios)</source>
          <target state="translated">&lt;a href=&quot;http://regexlib.com/Default.aspx&quot;&gt;Библиотека регулярных выражений&lt;/a&gt; (предопределенные регулярные выражения для распространенных сценариев)</target>
        </trans-unit>
        <trans-unit id="52ba4e284aa4c3ef639e8a8eb43c76f0d2dd305d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://regexstorm.net/&quot;&gt;Regex Storm&lt;/a&gt; (for .NET)</source>
          <target state="translated">&lt;a href=&quot;http://regexstorm.net/&quot;&gt;Regex Storm&lt;/a&gt; (для .NET)</target>
        </trans-unit>
        <trans-unit id="c399644d59ada43490f6ffcfa767c8ffa88aaf34" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weitz.de/regex-coach/&quot;&gt;Regex Coach&lt;/a&gt; (engine backed by &lt;a href=&quot;https://edicl.github.io/cl-ppcre/&quot;&gt;CL-PPCRE&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://weitz.de/regex-coach/&quot;&gt;Regex Coach&lt;/a&gt; (двигатель поддерживается &lt;a href=&quot;https://edicl.github.io/cl-ppcre/&quot;&gt;CL-PPCRE&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="37fbb3c67041c88bb5fb2ee7d0ea73da5aca34b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;Expresso&lt;/a&gt; (for .NET)</source>
          <target state="translated">&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;Expresso&lt;/a&gt; (для .NET)</target>
        </trans-unit>
        <trans-unit id="5091e76616eb92b95cb38de4c129f9453eee45c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regex101.com/&quot;&gt;Regex 101&lt;/a&gt; (for PCRE, JavaScript, Python, Golang)</source>
          <target state="translated">&lt;a href=&quot;https://regex101.com/&quot;&gt;Regex 101&lt;/a&gt; (для PCRE, JavaScript, Python, Golang)</target>
        </trans-unit>
        <trans-unit id="0219e5502b55fbd56d948d75b0b9d635ece58d47" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regexr.com/&quot;&gt;RegExr&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://regexr.com/&quot;&gt;RegExr&lt;/a&gt; (для JavaScript)</target>
        </trans-unit>
        <trans-unit id="88542bbf29e8bb29a91e15cec896ae72f5da8770" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://rubular.com/&quot;&gt;Rubular&lt;/a&gt; (for Ruby)</source>
          <target state="translated">&lt;a href=&quot;https://rubular.com/&quot;&gt;Рубулярный&lt;/a&gt; (для Руби)</target>
        </trans-unit>
        <trans-unit id="2307de32b2e7372a804ec97e3ca567c35d03bd92" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.debuggex.com/&quot;&gt;Debuggex&lt;/a&gt; (visual regex tester and helper)</source>
          <target state="translated">&lt;a href=&quot;https://www.debuggex.com/&quot;&gt;Debuggex&lt;/a&gt; (визуальный тестер регулярных выражений и помощник)</target>
        </trans-unit>
        <trans-unit id="b671ff66076869497a948d0bf95f5fc2b9e40299" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.regexpal.com/&quot;&gt;RegexPal&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://www.regexpal.com/&quot;&gt;RegexPal&lt;/a&gt; (для JavaScript)</target>
        </trans-unit>
        <trans-unit id="9cb9a6ab932dceec9ffe65247bc3cccfda5da286" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.regextester.com/&quot;&gt;Regex Tester&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://www.regextester.com/&quot;&gt;Regex Tester&lt;/a&gt; (для JavaScript)</target>
        </trans-unit>
        <trans-unit id="eeb0890b8bae80c63e782001363779e5dd6a4cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; (zero or more times)</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; (ноль или более раз)</target>
        </trans-unit>
        <trans-unit id="68e7787028c0f8e5c7cb1974a6a29b105ad2afb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; (one or more times)</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; (один или несколько раз)</target>
        </trans-unit>
        <trans-unit id="4078b42459a3d9c1d9e1e9ea095ffdfc0773bc68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[0-9]+&lt;/code&gt; (and its equivalent &lt;code&gt;\d+&lt;/code&gt;) matches any non-negative integer</source>
          <target state="translated">&lt;code&gt;[0-9]+&lt;/code&gt; (и его эквивалент &lt;code&gt;\d+&lt;/code&gt; ) соответствует любому неотрицательному целому числу</target>
        </trans-unit>
        <trans-unit id="c29c5736875d33c09abed9a6b02279da10095e0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt; matches dates formatted like 2019-01-01</source>
          <target state="translated">&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt; соответствует датам в формате 2019-01-01</target>
        </trans-unit>
        <trans-unit id="b251d9b6ea61001d2d2aa44d156af068b0ca092e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,m}&lt;/code&gt; (at least &lt;em&gt;n&lt;/em&gt; times but no more than &lt;em&gt;m&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n,m}&lt;/code&gt; (не менее &lt;em&gt;n&lt;/em&gt; раз, но не более &lt;em&gt;m&lt;/em&gt; раз)</target>
        </trans-unit>
        <trans-unit id="ef799869d678028f74953d5c3755452d618be643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,}&lt;/code&gt; (at least &lt;em&gt;n&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n,}&lt;/code&gt; (не менее &lt;em&gt;n&lt;/em&gt; раз)</target>
        </trans-unit>
        <trans-unit id="8ea261c3e08a435014c07c930a9339279f834530" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n}&lt;/code&gt; (exactly &lt;em&gt;n&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n}&lt;/code&gt; (ровно &lt;em&gt;n&lt;/em&gt; раз)</target>
        </trans-unit>
        <trans-unit id="ebf2b2b20b1e034d96b759673425d9a2e451a754" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(and so on)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(и так далее)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dab55287a0c775bf4cd951c49b0ac8dfa0b7f22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;dagger;:&lt;/strong&gt; The statement above that &lt;code&gt;.&lt;/code&gt; matches any character is a simplification for pedagogical purposes that is not strictly true. Dot matches any character except newline, &lt;code&gt;&quot;\n&quot;&lt;/code&gt;, but in practice you rarely expect a pattern such as &lt;code&gt;.+&lt;/code&gt; to cross a newline boundary. Perl regexes have a &lt;a href=&quot;https://perldoc.perl.org/perlre.html#s&quot;&gt;&lt;code&gt;/s&lt;/code&gt; switch&lt;/a&gt; and Java &lt;a href=&quot;https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html#DOTALL&quot;&gt;&lt;code&gt;Pattern.DOTALL&lt;/code&gt;&lt;/a&gt;, for example, to make &lt;code&gt;.&lt;/code&gt; match any character at all. For languages that don't have such a feature, you can use something like &lt;code&gt;[\s\S]&lt;/code&gt; to match &quot;any whitespace or any non-whitespace&quot;, in other words anything.</source>
          <target state="translated">&lt;strong&gt;&amp;dagger;:&lt;/strong&gt; утверждение выше этого &lt;code&gt;.&lt;/code&gt; Соответствие любому символу является упрощением для педагогических целей, что не совсем верно. Точка соответствует любому символу, кроме новой строки, &lt;code&gt;&quot;\n&quot;&lt;/code&gt; , но на практике вы редко ожидаете, что шаблон, такой как &lt;code&gt;.+&lt;/code&gt; , Пересечет границу новой строки. В регулярных выражениях Perl, например, есть &lt;a href=&quot;https://perldoc.perl.org/perlre.html#s&quot;&gt;ключ &lt;code&gt;/s&lt;/code&gt; &lt;/a&gt; и Java &lt;a href=&quot;https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html#DOTALL&quot;&gt; &lt;code&gt;Pattern.DOTALL&lt;/code&gt; &lt;/a&gt; &lt;code&gt;.&lt;/code&gt; соответствовать любому персонажу вообще. Для языков, которые не имеют такой возможности, вы можете использовать что-то вроде &lt;code&gt;[\s\S]&lt;/code&gt; для соответствия &amp;laquo;любому пробелу или любому непробелу&amp;raquo;, другими словами, чему угодно.</target>
        </trans-unit>
        <trans-unit id="e4616c92589ed8e68a1ebbf03782fde32acb593f" translate="yes" xml:space="preserve">
          <source>A few other useful examples:</source>
          <target state="translated">Несколько других полезных примеров:</target>
        </trans-unit>
        <trans-unit id="9698c2a9402dd87d80e8df20e87b7752186b2fba" translate="yes" xml:space="preserve">
          <source>A quantifier modifies the pattern to its immediate left. You might expect &lt;code&gt;0abc+0&lt;/code&gt; to match '0abc0', '0abcabc0', and so forth, but the pattern &lt;em&gt;immediately&lt;/em&gt; to the left of the plus quantifier is &lt;code&gt;c&lt;/code&gt;. This means &lt;code&gt;0abc+0&lt;/code&gt; matches '0abc0', '0abcc0', '0abccc0', and so on.</source>
          <target state="translated">Квантификатор изменяет шаблон непосредственно слева. Вы можете ожидать, что &lt;code&gt;0abc+0&lt;/code&gt; будет соответствовать '0abc0', '0abcabc0' и т. Д., Но шаблон слева от квантификатора плюс - &lt;code&gt;c&lt;/code&gt; . Это означает, что &lt;code&gt;0abc+0&lt;/code&gt; соответствует '0abc0', '0abcc0', '0abccc0' и так далее.</target>
        </trans-unit>
        <trans-unit id="c2eec20b60545f98a44bd16ad8a4e0cd3a89a41a" translate="yes" xml:space="preserve">
          <source>Adding just a little complexity, you can match either 'Nick' or 'nick' with the pattern &lt;code&gt;[Nn]ick&lt;/code&gt;. The part in square brackets is a &lt;em&gt;character class&lt;/em&gt;, which means it matches exactly one of the enclosed characters. You can also use ranges in character classes, so &lt;code&gt;[a-c]&lt;/code&gt; matches either 'a' or 'b' or 'c'.</source>
          <target state="translated">Добавляя небольшую сложность, вы можете сопоставить 'Nick' или 'Nick' с шаблоном &lt;code&gt;[Nn]ick&lt;/code&gt; . Часть в квадратных скобках является &lt;em&gt;классом символов&lt;/em&gt; , что означает, что он соответствует точно одному из заключенных символов. Вы также можете использовать диапазоны в классах символов, поэтому &lt;code&gt;[a-c]&lt;/code&gt; соответствует 'a' или 'b' или 'c'.</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="83d719739c59379bf19d989792e9ec8998993c2d" translate="yes" xml:space="preserve">
          <source>Although some characters match themselves, others have special meanings. The pattern &lt;code&gt;\d+&lt;/code&gt; doesn't match backslash followed by lowercase D followed by a plus sign: to get that, we'd use &lt;code&gt;\\d\+&lt;/code&gt;. A backslash removes the special meaning from the following character.</source>
          <target state="translated">Хотя некоторые персонажи соответствуют друг другу, другие имеют особое значение. Шаблон &lt;code&gt;\d+&lt;/code&gt; не совпадает с обратной косой чертой, за которой следует строчная буква D с последующим знаком плюс: чтобы получить это, мы будем использовать &lt;code&gt;\\d\+&lt;/code&gt; . Обратная косая черта удаляет специальное значение из следующего символа.</target>
        </trans-unit>
        <trans-unit id="a307a637b89fe16e9922778e99bea2ed2e8e496b" translate="yes" xml:space="preserve">
          <source>Anchors</source>
          <target state="translated">Anchors</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="f20b35258323d6253263d376f19f1859ea7fa62f" translate="yes" xml:space="preserve">
          <source>Build your own</source>
          <target state="translated">Построй свой собственный</target>
        </trans-unit>
        <trans-unit id="1d333bcb58941bfd7a3fb8cda029220d5a88e47f" translate="yes" xml:space="preserve">
          <source>Conceptually, the simplest regular expressions are literal characters. The pattern &lt;code&gt;N&lt;/code&gt; matches the character 'N'.</source>
          <target state="translated">Концептуально, самые простые регулярные выражения - это буквальные символы. Шаблон &lt;code&gt;N&lt;/code&gt; соответствует символу &amp;laquo;N&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fabc21bb541d3248d6745e3a4b9e442f9a030f7d" translate="yes" xml:space="preserve">
          <source>Earlier, we saw one way to match either 'Nick' or 'nick'. Another is with alternation as in &lt;code&gt;Nick|nick&lt;/code&gt;. Remember that alternation includes everything to its left and everything to its right. Use grouping parentheses to limit the scope of &lt;code&gt;|&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;(Nick|nick)&lt;/code&gt;.</source>
          <target state="translated">Ранее мы видели один способ сопоставления &amp;laquo;Ника&amp;raquo; или &amp;laquo;Ника&amp;raquo;. Другой с чередованием, как у &lt;code&gt;Nick|nick&lt;/code&gt; . Помните, что чередование включает в себя все слева и все справа. Используйте круглые скобки для ограничения области действия &lt;code&gt;|&lt;/code&gt; &lt;em&gt;Например&lt;/em&gt; , &lt;code&gt;(Nick|nick)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2779ea444cb47200f1b0085d04662b33c09fc23f" translate="yes" xml:space="preserve">
          <source>Escaping</source>
          <target state="translated">Escaping</target>
        </trans-unit>
        <trans-unit id="40e31a210a1913fd0a8b28b892780996d154c70d" translate="yes" xml:space="preserve">
          <source>Footnote</source>
          <target state="translated">Footnote</target>
        </trans-unit>
        <trans-unit id="4cd395750596fc63879f88a287d8880fa0e85e60" translate="yes" xml:space="preserve">
          <source>For another example, you could equivalently write &lt;code&gt;[a-c]&lt;/code&gt; as &lt;code&gt;a|b|c&lt;/code&gt;, but this is likely to be suboptimal because many implementations assume alternatives will have lengths greater than 1.</source>
          <target state="translated">В другом примере вы могли бы эквивалентно написать &lt;code&gt;[a-c]&lt;/code&gt; как &lt;code&gt;a|b|c&lt;/code&gt; , но это, вероятно, будет неоптимальным, поскольку во многих реализациях предполагается, что альтернативы будут иметь длину больше 1.</target>
        </trans-unit>
        <trans-unit id="1afa4f2a09ae6c3e5a9c146d9e129073c4f2e82e" translate="yes" xml:space="preserve">
          <source>For example, say the input is</source>
          <target state="translated">Например,скажем,что вход</target>
        </trans-unit>
        <trans-unit id="8dd341228f5203334a2dbe18a099fd9cdb246553" translate="yes" xml:space="preserve">
          <source>Free resources</source>
          <target state="translated">Свободные ресурсы</target>
        </trans-unit>
        <trans-unit id="8b058c9ddbb5e235a3b17a4d130bb8609fba9734" translate="yes" xml:space="preserve">
          <source>From there, you can repeat parts of your pattern with &lt;em&gt;quantifiers&lt;/em&gt;. For example, the pattern &lt;code&gt;ab?c&lt;/code&gt; matches 'abc' or 'ac' because the &lt;code&gt;?&lt;/code&gt; quantifier makes the subpattern it modifies optional. Other quantifiers are</source>
          <target state="translated">Оттуда вы можете повторить части вашего шаблона с &lt;em&gt;квантификаторами&lt;/em&gt; . Например, шаблон &lt;code&gt;ab?c&lt;/code&gt; соответствует 'abc' или 'ac', потому что &lt;code&gt;?&lt;/code&gt; квантификатор делает подшаблон, который он изменяет, необязательным. Другие квантификаторы</target>
        </trans-unit>
        <trans-unit id="59985b76bfac61da62ef1b2c39db3443c181b381" translate="yes" xml:space="preserve">
          <source>Greediness</source>
          <target state="translated">Greediness</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="f646cf743adf4a08fb6e1b26f378b70f117af712" translate="yes" xml:space="preserve">
          <source>Helpful shortcuts</source>
          <target state="translated">Полезные горячие клавиши</target>
        </trans-unit>
        <trans-unit id="9356b9688cab55bd64e84c0c92cc854e57b999b4" translate="yes" xml:space="preserve">
          <source>How Regexes Work</source>
          <target state="translated">Как работают регексы</target>
        </trans-unit>
        <trans-unit id="a5370c7d8ba341173df1c3b84ffdbdf6a7833cfc" translate="yes" xml:space="preserve">
          <source>I don't really understand regular expressions.  Can you explain them to me in an easy-to-follow manner?  If there are any online tools or books, could you also link to them?</source>
          <target state="translated">Я не очень понимаю регулярные выражения.Ты можешь объяснить их мне простым языком? Если есть какие-нибудь онлайн-инструменты или книги,не могли бы вы также дать ссылку на них?</target>
        </trans-unit>
        <trans-unit id="530b1c010c952dc47e7ccad7a66d94ff2c275a0e" translate="yes" xml:space="preserve">
          <source>If you think of regular expressions as building blocks that you can mix and match as you please, it helps you learn how to write and debug your own patterns but also how to understand patterns written by others.</source>
          <target state="translated">Если вы думаете о регулярных выражениях как о строительных блоках,которые можно смешивать и сопоставлять по своему усмотрению,это поможет вам научиться не только писать и отлаживать свои собственные паттерны,но и понимать паттерны,написанные другими людьми.</target>
        </trans-unit>
        <trans-unit id="46b79bd52027013bd53543e10582ce6baeead7a2" translate="yes" xml:space="preserve">
          <source>If you've ever used &lt;code&gt;grep&lt;/code&gt; on Unix&amp;mdash;even if only to search for ordinary looking strings&amp;mdash;you've already been using regular expressions! (The &lt;code&gt;re&lt;/code&gt; in &lt;code&gt;grep&lt;/code&gt; refers to regular expressions.)</source>
          <target state="translated">Если вы когда-либо использовали &lt;code&gt;grep&lt;/code&gt; в Unix - даже если только для поиска обычных строк - вы уже использовали регулярные выражения! ( &lt;code&gt;re&lt;/code&gt; в &lt;code&gt;grep&lt;/code&gt; относится к регулярным выражениям.)</target>
        </trans-unit>
        <trans-unit id="3f48e3ea7a67593afc624d898633d8bcfd4d221e" translate="yes" xml:space="preserve">
          <source>If your input is '(123) (456)', then the first capture will be '123'. Non-greedy quantifiers want to allow the rest of the pattern to start matching as soon as possible.</source>
          <target state="translated">Если ваш вход '(123)(456)',то первый захват будет '123'.Не жадные квантификаторы хотят позволить остальным шаблонам начать выравнивание как можно быстрее.</target>
        </trans-unit>
        <trans-unit id="feecfcff81cdfac79c1169c68bcdf3298543a39e" translate="yes" xml:space="preserve">
          <source>Learning Regular Expressions</source>
          <target state="translated">Обучение регулярным экспрессиям</target>
        </trans-unit>
        <trans-unit id="54274c1b66e4db9103a52754b9f88c07567bd846" translate="yes" xml:space="preserve">
          <source>Nick</source>
          <target state="translated">Nick</target>
        </trans-unit>
        <trans-unit id="c659a1a4add3674e46b01f5c3aed16066f609fba" translate="yes" xml:space="preserve">
          <source>Nnick</source>
          <target state="translated">Nnick</target>
        </trans-unit>
        <trans-unit id="849e6a4431d3bc9b7fd03e9363f4f10c14117c82" translate="yes" xml:space="preserve">
          <source>Once is not enough</source>
          <target state="translated">Один раз недостаточно</target>
        </trans-unit>
        <trans-unit id="82eb240ece12cf01f54324b6e46ee819e866dd8b" translate="yes" xml:space="preserve">
          <source>Order from the menu</source>
          <target state="translated">Заказ из меню</target>
        </trans-unit>
        <trans-unit id="44a71879f76eef9a972c14aeb610df9bb2a2d7cd" translate="yes" xml:space="preserve">
          <source>Perl: &lt;a href=&quot;https://metacpan.org/release/YAPE-Regex-Explain&quot;&gt;YAPE: Regex Explain&lt;/a&gt;</source>
          <target state="translated">Perl: &lt;a href=&quot;https://metacpan.org/release/YAPE-Regex-Explain&quot;&gt;YAPE: Regex Объясните&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="947c6e8160e2686ffe1464043c63e0d649717e4f" translate="yes" xml:space="preserve">
          <source>Putting some of these blocks together, the pattern &lt;code&gt;[Nn]*ick&lt;/code&gt; matches all of</source>
          <target state="translated">Соединяя некоторые из этих блоков, шаблон &lt;code&gt;[Nn]*ick&lt;/code&gt; соответствует всем</target>
        </trans-unit>
        <trans-unit id="16dc60b323d79a2f6113da0cf72b1173c59702bf" translate="yes" xml:space="preserve">
          <source>Regex Buddy</source>
          <target state="translated">Регекс Бадди</target>
        </trans-unit>
        <trans-unit id="b9648927d75753351180b745bd9201dc142cf8bb" translate="yes" xml:space="preserve">
          <source>Regex Cookbook</source>
          <target state="translated">Регекс Кулинарная книга</target>
        </trans-unit>
        <trans-unit id="79fd14db3d8dce5771ed8d43cbac1e67ff353684" translate="yes" xml:space="preserve">
          <source>Regex Syntax Summary</source>
          <target state="translated">Резюме синтаксиса Регекса</target>
        </trans-unit>
        <trans-unit id="d8fee145772e06e3d12eea6ce0cb821cd8678167" translate="yes" xml:space="preserve">
          <source>RegexOne - Learn with simple, interactive exercises.</source>
          <target state="translated">RegexOne-Учитесь с помощью простых интерактивных упражнений.</target>
        </trans-unit>
        <trans-unit id="c8974ee3c3bc80517e839f83d10737faa707127b" translate="yes" xml:space="preserve">
          <source>Regular Expressions Cheat Sheet</source>
          <target state="translated">Регулярные экспрессии Шит-лист</target>
        </trans-unit>
        <trans-unit id="89c14d5368a465f10ef6a24a01a9a7b38da0fc57" translate="yes" xml:space="preserve">
          <source>Regular Expressions Online Tester</source>
          <target state="translated">Регулярные экспрессии онлайн-тестер</target>
        </trans-unit>
        <trans-unit id="5699d9c17f85d41638b57e6a204ea26e5d711b98" translate="yes" xml:space="preserve">
          <source>Regular expression quantifiers are greedy. This means they match as much text as they possibly can while allowing the entire pattern to match successfully.</source>
          <target state="translated">Квантователи регулярных выражений жадны.Это означает,что они соответствуют как можно большему количеству текста,позволяя при этом успешно сопоставлять весь шаблон.</target>
        </trans-unit>
        <trans-unit id="68e27e707d3e03f55d0c8a5732979a4ccc2d797c" translate="yes" xml:space="preserve">
          <source>Regular expressions are recursive, so now that you understand these basic rules, you can combine them however you like.</source>
          <target state="translated">Регулярные выражения являются рекурсивными,поэтому теперь,когда вы понимаете эти основные правила,вы можете комбинировать их как угодно.</target>
        </trans-unit>
        <trans-unit id="6c187c47e14e519d74321d9000d5afb95d07cfdc" translate="yes" xml:space="preserve">
          <source>Regular expressions next to each other match sequences. For example, the pattern &lt;code&gt;Nick&lt;/code&gt; matches the sequence 'N' followed by 'i' followed by 'c' followed by 'k'.</source>
          <target state="translated">Регулярные выражения рядом друг с другом соответствуют последовательностям. Например, шаблон &lt;code&gt;Nick&lt;/code&gt; соответствует последовательности &amp;laquo;N&amp;raquo;, за которой следует &amp;laquo;i&amp;raquo;, затем &amp;laquo;c&amp;raquo; и &amp;laquo;k&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3555c1a56411b43a7966c37d01ae16f4955f43f9" translate="yes" xml:space="preserve">
          <source>Say you want to match comments of the form</source>
          <target state="translated">Скажи,что ты хочешь сопоставить комментарии формы</target>
        </trans-unit>
        <trans-unit id="cb45b4e62bf666c532a02287bb4fb02a809b6fc5" translate="yes" xml:space="preserve">
          <source>Start simple</source>
          <target state="translated">Начать просто</target>
        </trans-unit>
        <trans-unit id="28aef8f69db620eb498820f0e319209292abdccd" translate="yes" xml:space="preserve">
          <source>Teach Yourself Regular Expressions</source>
          <target state="translated">Научите себя регулярным экспрессиям</target>
        </trans-unit>
        <trans-unit id="c845c6000fff99af437a9fc8c2e6f447122a611d" translate="yes" xml:space="preserve">
          <source>The first match demonstrates an important lesson: &lt;em&gt;&lt;code&gt;*&lt;/code&gt; always succeeds!&lt;/em&gt; Any pattern can match zero times.</source>
          <target state="translated">Первый матч демонстрирует важный урок: &lt;em&gt; &lt;code&gt;*&lt;/code&gt; всегда успешно!&lt;/em&gt; Любой шаблон может соответствовать нулю раз.</target>
        </trans-unit>
        <trans-unit id="b96fd7359131170ec3910a2c15c093b0604c1e9d" translate="yes" xml:space="preserve">
          <source>The most important part is the concepts. Once you understand how the building blocks work, differences in syntax amount to little more than mild dialects. A layer on top of your regular expression engine's syntax is the syntax of the programming language you're using. Languages such as Perl remove most of this complication, but you'll have to keep in mind other considerations if you're using regular expressions in a C program.</source>
          <target state="translated">Самая важная часть-это понятия.Как только вы понимаете,как работают строительные блоки,различия в синтаксисе составляют чуть больше,чем мягкие диалекты.Слой поверх синтаксиса вашего движка регулярных выражений-это синтаксис языка программирования,который вы используете.Языки,такие как Perl,устраняют большую часть этого усложнения,но вы должны помнить о других соображениях,если вы используете регулярные выражения в программе на Си.</target>
        </trans-unit>
        <trans-unit id="22715149bb9c6655ed248fa2ba77fe101f0f5ecb" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;.&lt;/code&gt; is special: rather than matching a literal dot only, it matches &lt;em&gt;any&lt;/em&gt; character&lt;sup&gt;&amp;dagger;&lt;/sup&gt;. It's the same conceptually as the really big character class &lt;code&gt;[-.?+%$A-Za-z0-9...]&lt;/code&gt;.</source>
          <target state="translated">Шаблон &lt;code&gt;.&lt;/code&gt; является особенным: вместо того, чтобы соответствовать только буквальной точке, он соответствует &lt;em&gt;любому&lt;/em&gt; символу &lt;sup&gt;&amp;dagger;&lt;/sup&gt; . Концептуально это то же самое, что и действительно большой класс персонажей &lt;code&gt;[-.?+%$A-Za-z0-9...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91a4d600b807bd4f09976a09959e06274f29ba2d" translate="yes" xml:space="preserve">
          <source>The uppercased variants are their complements, so &lt;code&gt;\S&lt;/code&gt; matches any &lt;em&gt;non&lt;/em&gt;-whitespace character, for example.</source>
          <target state="translated">Варианты в верхнем регистре являются их дополнениями, поэтому &lt;code&gt;\S&lt;/code&gt; соответствует любому символу, &lt;em&gt;не&lt;/em&gt; являющемуся пробелом, например.</target>
        </trans-unit>
        <trans-unit id="e293881e27590496ef91a61c6c25643e50a9e297" translate="yes" xml:space="preserve">
          <source>Think of character classes as menus: pick just one.</source>
          <target state="translated">Думайте о классах персонажей как о меню:выберите только одно.</target>
        </trans-unit>
        <trans-unit id="de4b0e2db7bd3c9c11ac9e377548480b18fc9bf9" translate="yes" xml:space="preserve">
          <source>To match one or more sequences of 'abc' with zeros on the ends, use &lt;code&gt;0(abc)+0&lt;/code&gt;. The parentheses denote a subpattern that can be quantified as a unit. It's also common for regular expression engines to save or &quot;capture&quot; the portion of the input text that matches a parenthesized group. Extracting bits this way is much more flexible and less error-prone than counting indices and &lt;code&gt;substr&lt;/code&gt;.</source>
          <target state="translated">Чтобы сопоставить одну или несколько последовательностей &amp;laquo;abc&amp;raquo; с нулями на концах, используйте &lt;code&gt;0(abc)+0&lt;/code&gt; . Скобки обозначают подшаблон, который может быть количественно определен как единое целое. Механизмам регулярных выражений также свойственно сохранять или &amp;laquo;захватывать&amp;raquo; часть входного текста, которая соответствует группе в скобках. Таким образом, извлечение битов гораздо более гибко и менее подвержено ошибкам, чем подсчет индексов и &lt;code&gt;substr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ddbc5d0277e3c16b73cf8e609473468f17b01c" translate="yes" xml:space="preserve">
          <source>To switch from greedy to what you might think of as cautious, add an extra &lt;code&gt;?&lt;/code&gt; to the quantifier. Now you understand how &lt;code&gt;\((.+?)\)&lt;/code&gt;, the example from your question works. It matches the sequence of a literal left-parenthesis, followed by one or more characters, and terminated by a right-parenthesis.</source>
          <target state="translated">Чтобы переключиться с жадного на то, что вы считаете осторожным, добавьте лишнее &lt;code&gt;?&lt;/code&gt; в квантификатор. Теперь вы понимаете, как работает &lt;code&gt;\((.+?)\)&lt;/code&gt; Пример из вашего вопроса. Он соответствует последовательности буквальной левой круглой скобки, за которой следуют один или несколько символов и оканчивающейся правой круглой скобкой.</target>
        </trans-unit>
        <trans-unit id="92935cc481013b79cd161911bb7bc552f1ba3812" translate="yes" xml:space="preserve">
          <source>Tools for writing and debugging regexes:</source>
          <target state="translated">Инструменты для написания и отладки регексов:</target>
        </trans-unit>
        <trans-unit id="a1fd9141e7da915eb8a8004fe9ab9111acd0635a" translate="yes" xml:space="preserve">
          <source>Txt2RE</source>
          <target state="translated">Txt2RE</target>
        </trans-unit>
        <trans-unit id="fe6d79779c9d27867ff69b0be6ad558feeaa20f7" translate="yes" xml:space="preserve">
          <source>Use the special pattern &lt;code&gt;^&lt;/code&gt; to match only at the beginning of your input and &lt;code&gt;$&lt;/code&gt; to match only at the end. Making &quot;bookends&quot; with your patterns where you say, &quot;I know what's at the front and back, but give me everything between&quot; is a useful technique.</source>
          <target state="translated">Используйте специальный шаблон &lt;code&gt;^&lt;/code&gt; для сопоставления только в начале ввода и &lt;code&gt;$&lt;/code&gt; для сопоставления только в конце. Создание &amp;laquo;форзацев&amp;raquo; с вашими шаблонами, когда вы говорите: &amp;laquo;Я знаю, что находится впереди и сзади, но дай мне все между&amp;raquo;, - полезная техника.</target>
        </trans-unit>
        <trans-unit id="37304d600ce0cd62463a50ccd70b1ebda871fa2f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.&lt;/code&gt; can save you lots of typing, and there are other shortcuts for common patterns. Say you want to match a digit: one way to write that is &lt;code&gt;[0-9]&lt;/code&gt;. Digits are a frequent match target, so you could instead use the shortcut &lt;code&gt;\d&lt;/code&gt;. Others are &lt;code&gt;\s&lt;/code&gt; (whitespace) and &lt;code&gt;\w&lt;/code&gt; (word characters: alphanumerics or underscore).</source>
          <target state="translated">Использование может сэкономить много печатать, и есть другие ярлыки для общих шаблонов. Скажем, вы хотите сопоставить цифру: один из способов написать это &lt;code&gt;[0-9]&lt;/code&gt; . Цифры часто встречаются, поэтому вместо них можно использовать ярлык &lt;code&gt;\d&lt;/code&gt; . Другими являются &lt;code&gt;\s&lt;/code&gt; (пробелы) и &lt;code&gt;\w&lt;/code&gt; (символы слова: буквенно-цифровые символы или подчеркивание).</target>
        </trans-unit>
        <trans-unit id="526f639bebd48d81d13a90a85f8fd1789e9df34d" translate="yes" xml:space="preserve">
          <source>Visual RegExp</source>
          <target state="translated">Visual RegExp</target>
        </trans-unit>
        <trans-unit id="75e9f880bd62145e1e31f2d7b936986d0605f73e" translate="yes" xml:space="preserve">
          <source>You might expect &lt;code&gt;&quot;.+&quot;&lt;/code&gt; to match only 'Hello,' and will then be surprised when you see that it matched from 'Hello' all the way through 'you?'.</source>
          <target state="translated">Вы можете ожидать, что &lt;code&gt;&quot;.+&quot;&lt;/code&gt; Будет соответствовать только &amp;laquo;Hello&amp;raquo;, и вы будете удивлены, когда увидите, что оно совпадает с &amp;laquo;Hello&amp;raquo; на всем протяжении &amp;laquo;you?&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a2b8abe4260aad959411d4203bb668f167991d6a" translate="yes" xml:space="preserve">
          <source>ick</source>
          <target state="translated">ick</target>
        </trans-unit>
        <trans-unit id="fc15a9dd34ddc23b9aff22adce8b09526d7b078c" translate="yes" xml:space="preserve">
          <source>nNick</source>
          <target state="translated">nNick</target>
        </trans-unit>
        <trans-unit id="75ef9faee755c70589550b513ad881e5a603182c" translate="yes" xml:space="preserve">
          <source>nick</source>
          <target state="translated">nick</target>
        </trans-unit>
        <trans-unit id="98cb5605f45e16baa3327dd0dd78f00ec9cc4b36" translate="yes" xml:space="preserve">
          <source>nnick</source>
          <target state="translated">nnick</target>
        </trans-unit>
        <trans-unit id="35b888ad74eacdebe041626f388c5c12bae6bfda" translate="yes" xml:space="preserve">
          <source>you'd write &lt;code&gt;^--\s+(.+)\s+--$&lt;/code&gt;.</source>
          <target state="translated">вы бы написали &lt;code&gt;^--\s+(.+)\s+--$&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
