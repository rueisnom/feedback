<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/4736">
    <body>
      <group id="4736">
        <trans-unit id="8c342e8585fceeee466cfc575e45384b0da85bd4" translate="yes" xml:space="preserve">
          <source>&quot;Hello,&quot; she said, &quot;How are you?&quot;</source>
          <target state="translated">&quot;Hola&quot;,dijo,&quot;¿Cómo estás?&quot;</target>
        </trans-unit>
        <trans-unit id="33005ca44ed78f77c7fadc5a196abf1256960301" translate="yes" xml:space="preserve">
          <source>(As to your confusion, I don't know of any regular-expression dialect where &lt;code&gt;((.+?))&lt;/code&gt; would do the same thing. I suspect something got lost in transmission somewhere along the way.)</source>
          <target state="translated">(En cuanto a su confusi&amp;oacute;n, no s&amp;eacute; de ning&amp;uacute;n dialecto de expresi&amp;oacute;n regular donde &lt;code&gt;((.+?))&lt;/code&gt; Har&amp;iacute;a lo mismo. Sospecho que algo se perdi&amp;oacute; en la transmisi&amp;oacute;n en alg&amp;uacute;n lugar del camino).</target>
        </trans-unit>
        <trans-unit id="4ef24db075ab7963455bfe3ea7654428474ef88d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://neverfear.org/blog/view/Regex_tutorial_for_people_who_should_know_Regex__but_do_not___Part_1&quot;&gt;Regular Expressions - Everything you should know&lt;/a&gt; (PDF Series)</source>
          <target state="translated">&lt;a href=&quot;http://neverfear.org/blog/view/Regex_tutorial_for_people_who_should_know_Regex__but_do_not___Part_1&quot;&gt;Expresiones regulares: todo lo que debe saber&lt;/a&gt; (Serie PDF)</target>
        </trans-unit>
        <trans-unit id="4c618840a436ae1359f6b753fc7b297f01d3edc4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;Mastering Regular Expressions&lt;/a&gt;, the &lt;a href=&quot;http://oreilly.com/catalog/9780596002893&quot;&gt;2nd Edition&lt;/a&gt;, and the &lt;a href=&quot;http://shop.oreilly.com/product/9780596528126.do&quot;&gt;3rd edition&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;Dominar las expresiones regulares&lt;/a&gt; , la &lt;a href=&quot;http://oreilly.com/catalog/9780596002893&quot;&gt;segunda edici&amp;oacute;n&lt;/a&gt; y la &lt;a href=&quot;http://shop.oreilly.com/product/9780596528126.do&quot;&gt;tercera edici&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a78dcd68ae6f3277cb0e045417feb90a498d6dd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://regexlib.com/Default.aspx&quot;&gt;Regular Expression Library&lt;/a&gt; (Predefined Regexes for common scenarios)</source>
          <target state="translated">&lt;a href=&quot;http://regexlib.com/Default.aspx&quot;&gt;Biblioteca de expresiones regulares (expresiones regulares&lt;/a&gt; predefinidas para escenarios comunes)</target>
        </trans-unit>
        <trans-unit id="52ba4e284aa4c3ef639e8a8eb43c76f0d2dd305d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://regexstorm.net/&quot;&gt;Regex Storm&lt;/a&gt; (for .NET)</source>
          <target state="translated">&lt;a href=&quot;http://regexstorm.net/&quot;&gt;Tormenta de expresiones regulares&lt;/a&gt; (para .NET)</target>
        </trans-unit>
        <trans-unit id="c399644d59ada43490f6ffcfa767c8ffa88aaf34" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weitz.de/regex-coach/&quot;&gt;Regex Coach&lt;/a&gt; (engine backed by &lt;a href=&quot;https://edicl.github.io/cl-ppcre/&quot;&gt;CL-PPCRE&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://weitz.de/regex-coach/&quot;&gt;Regex Coach&lt;/a&gt; (motor respaldado por &lt;a href=&quot;https://edicl.github.io/cl-ppcre/&quot;&gt;CL-PPCRE&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="37fbb3c67041c88bb5fb2ee7d0ea73da5aca34b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;Expresso&lt;/a&gt; (for .NET)</source>
          <target state="translated">&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;Expresso&lt;/a&gt; (para .NET)</target>
        </trans-unit>
        <trans-unit id="5091e76616eb92b95cb38de4c129f9453eee45c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regex101.com/&quot;&gt;Regex 101&lt;/a&gt; (for PCRE, JavaScript, Python, Golang)</source>
          <target state="translated">&lt;a href=&quot;https://regex101.com/&quot;&gt;Regex 101&lt;/a&gt; (para PCRE, JavaScript, Python, Golang)</target>
        </trans-unit>
        <trans-unit id="0219e5502b55fbd56d948d75b0b9d635ece58d47" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regexr.com/&quot;&gt;RegExr&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://regexr.com/&quot;&gt;RegExr&lt;/a&gt; (para JavaScript)</target>
        </trans-unit>
        <trans-unit id="88542bbf29e8bb29a91e15cec896ae72f5da8770" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://rubular.com/&quot;&gt;Rubular&lt;/a&gt; (for Ruby)</source>
          <target state="translated">&lt;a href=&quot;https://rubular.com/&quot;&gt;Rubular&lt;/a&gt; (para Ruby)</target>
        </trans-unit>
        <trans-unit id="2307de32b2e7372a804ec97e3ca567c35d03bd92" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.debuggex.com/&quot;&gt;Debuggex&lt;/a&gt; (visual regex tester and helper)</source>
          <target state="translated">&lt;a href=&quot;https://www.debuggex.com/&quot;&gt;Debuggex&lt;/a&gt; (probador visual de expresiones regulares y ayudante)</target>
        </trans-unit>
        <trans-unit id="b671ff66076869497a948d0bf95f5fc2b9e40299" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.regexpal.com/&quot;&gt;RegexPal&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://www.regexpal.com/&quot;&gt;RegexPal&lt;/a&gt; (para JavaScript)</target>
        </trans-unit>
        <trans-unit id="9cb9a6ab932dceec9ffe65247bc3cccfda5da286" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.regextester.com/&quot;&gt;Regex Tester&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://www.regextester.com/&quot;&gt;Probador de expresiones regulares&lt;/a&gt; (para JavaScript)</target>
        </trans-unit>
        <trans-unit id="eeb0890b8bae80c63e782001363779e5dd6a4cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; (zero or more times)</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; (cero o m&amp;aacute;s veces)</target>
        </trans-unit>
        <trans-unit id="68e7787028c0f8e5c7cb1974a6a29b105ad2afb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; (one or more times)</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; (una o m&amp;aacute;s veces)</target>
        </trans-unit>
        <trans-unit id="4078b42459a3d9c1d9e1e9ea095ffdfc0773bc68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[0-9]+&lt;/code&gt; (and its equivalent &lt;code&gt;\d+&lt;/code&gt;) matches any non-negative integer</source>
          <target state="translated">&lt;code&gt;[0-9]+&lt;/code&gt; (y su equivalente &lt;code&gt;\d+&lt;/code&gt; ) coincide con cualquier n&amp;uacute;mero entero no negativo</target>
        </trans-unit>
        <trans-unit id="c29c5736875d33c09abed9a6b02279da10095e0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt; matches dates formatted like 2019-01-01</source>
          <target state="translated">&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt; coincide con las fechas formateadas como 2019-01-01</target>
        </trans-unit>
        <trans-unit id="b251d9b6ea61001d2d2aa44d156af068b0ca092e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,m}&lt;/code&gt; (at least &lt;em&gt;n&lt;/em&gt; times but no more than &lt;em&gt;m&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n,m}&lt;/code&gt; (al menos &lt;em&gt;n&lt;/em&gt; veces pero no m&amp;aacute;s de &lt;em&gt;m&lt;/em&gt; veces)</target>
        </trans-unit>
        <trans-unit id="ef799869d678028f74953d5c3755452d618be643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,}&lt;/code&gt; (at least &lt;em&gt;n&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n,}&lt;/code&gt; (al menos &lt;em&gt;n&lt;/em&gt; veces)</target>
        </trans-unit>
        <trans-unit id="8ea261c3e08a435014c07c930a9339279f834530" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n}&lt;/code&gt; (exactly &lt;em&gt;n&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n}&lt;/code&gt; (exactamente &lt;em&gt;n&lt;/em&gt; veces)</target>
        </trans-unit>
        <trans-unit id="ebf2b2b20b1e034d96b759673425d9a2e451a754" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(and so on)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(y as&amp;iacute;)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dab55287a0c775bf4cd951c49b0ac8dfa0b7f22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;dagger;:&lt;/strong&gt; The statement above that &lt;code&gt;.&lt;/code&gt; matches any character is a simplification for pedagogical purposes that is not strictly true. Dot matches any character except newline, &lt;code&gt;&quot;\n&quot;&lt;/code&gt;, but in practice you rarely expect a pattern such as &lt;code&gt;.+&lt;/code&gt; to cross a newline boundary. Perl regexes have a &lt;a href=&quot;https://perldoc.perl.org/perlre.html#s&quot;&gt;&lt;code&gt;/s&lt;/code&gt; switch&lt;/a&gt; and Java &lt;a href=&quot;https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html#DOTALL&quot;&gt;&lt;code&gt;Pattern.DOTALL&lt;/code&gt;&lt;/a&gt;, for example, to make &lt;code&gt;.&lt;/code&gt; match any character at all. For languages that don't have such a feature, you can use something like &lt;code&gt;[\s\S]&lt;/code&gt; to match &quot;any whitespace or any non-whitespace&quot;, in other words anything.</source>
          <target state="translated">&lt;strong&gt;&amp;dagger;:&lt;/strong&gt; La declaraci&amp;oacute;n anterior a eso &lt;code&gt;.&lt;/code&gt; coincide con cualquier personaje es una simplificaci&amp;oacute;n para fines pedag&amp;oacute;gicos que no es estrictamente cierto. El punto coincide con cualquier car&amp;aacute;cter, excepto la nueva l&amp;iacute;nea, &lt;code&gt;&quot;\n&quot;&lt;/code&gt; , pero en la pr&amp;aacute;ctica rara vez se espera que un patr&amp;oacute;n como &lt;code&gt;.+&lt;/code&gt; Cruce un l&amp;iacute;mite de nueva l&amp;iacute;nea. Las expresiones regulares de Perl tienen un &lt;a href=&quot;https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html#DOTALL&quot;&gt; &lt;code&gt;Pattern.DOTALL&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;https://perldoc.perl.org/perlre.html#s&quot;&gt; &lt;code&gt;/s&lt;/code&gt; &lt;/a&gt; y Java Pattern.DOTALL , por ejemplo, para hacer &lt;code&gt;.&lt;/code&gt; coincide con cualquier personaje en absoluto. Para los idiomas que no tienen esa caracter&amp;iacute;stica, puede usar algo como &lt;code&gt;[\s\S]&lt;/code&gt; para que coincida con &quot;cualquier espacio en blanco o cualquier espacio en blanco&quot;, en otras palabras, cualquier cosa.</target>
        </trans-unit>
        <trans-unit id="e4616c92589ed8e68a1ebbf03782fde32acb593f" translate="yes" xml:space="preserve">
          <source>A few other useful examples:</source>
          <target state="translated">Algunos otros ejemplos útiles:</target>
        </trans-unit>
        <trans-unit id="9698c2a9402dd87d80e8df20e87b7752186b2fba" translate="yes" xml:space="preserve">
          <source>A quantifier modifies the pattern to its immediate left. You might expect &lt;code&gt;0abc+0&lt;/code&gt; to match '0abc0', '0abcabc0', and so forth, but the pattern &lt;em&gt;immediately&lt;/em&gt; to the left of the plus quantifier is &lt;code&gt;c&lt;/code&gt;. This means &lt;code&gt;0abc+0&lt;/code&gt; matches '0abc0', '0abcc0', '0abccc0', and so on.</source>
          <target state="translated">Un cuantificador modifica el patr&amp;oacute;n a su izquierda inmediata. Puede esperar que &lt;code&gt;0abc+0&lt;/code&gt; coincida con '0abc0', '0abcabc0', etc., pero el patr&amp;oacute;n &lt;em&gt;inmediatamente&lt;/em&gt; a la izquierda del cuantificador m&amp;aacute;s es &lt;code&gt;c&lt;/code&gt; . Esto significa que &lt;code&gt;0abc+0&lt;/code&gt; coincide con '0abc0', '0abcc0', '0abccc0', y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="c2eec20b60545f98a44bd16ad8a4e0cd3a89a41a" translate="yes" xml:space="preserve">
          <source>Adding just a little complexity, you can match either 'Nick' or 'nick' with the pattern &lt;code&gt;[Nn]ick&lt;/code&gt;. The part in square brackets is a &lt;em&gt;character class&lt;/em&gt;, which means it matches exactly one of the enclosed characters. You can also use ranges in character classes, so &lt;code&gt;[a-c]&lt;/code&gt; matches either 'a' or 'b' or 'c'.</source>
          <target state="translated">Agregando un poco de complejidad, puede hacer coincidir 'Nick' o 'nick' con el patr&amp;oacute;n &lt;code&gt;[Nn]ick&lt;/code&gt; . La parte entre corchetes es una &lt;em&gt;clase de caracteres&lt;/em&gt; , lo que significa que coincide exactamente con uno de los caracteres incluidos. Tambi&amp;eacute;n puede usar rangos en clases de caracteres, por lo que &lt;code&gt;[a-c]&lt;/code&gt; coincide con 'a' o 'b' o 'c'.</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="83d719739c59379bf19d989792e9ec8998993c2d" translate="yes" xml:space="preserve">
          <source>Although some characters match themselves, others have special meanings. The pattern &lt;code&gt;\d+&lt;/code&gt; doesn't match backslash followed by lowercase D followed by a plus sign: to get that, we'd use &lt;code&gt;\\d\+&lt;/code&gt;. A backslash removes the special meaning from the following character.</source>
          <target state="translated">Aunque algunos personajes coinciden, otros tienen significados especiales. El patr&amp;oacute;n &lt;code&gt;\d+&lt;/code&gt; no coincide con la barra invertida seguida de una D min&amp;uacute;scula seguida de un signo m&amp;aacute;s: para obtener eso, usar&amp;iacute;amos &lt;code&gt;\\d\+&lt;/code&gt; . Una barra invertida elimina el significado especial del siguiente car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="a307a637b89fe16e9922778e99bea2ed2e8e496b" translate="yes" xml:space="preserve">
          <source>Anchors</source>
          <target state="translated">Anchors</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="f20b35258323d6253263d376f19f1859ea7fa62f" translate="yes" xml:space="preserve">
          <source>Build your own</source>
          <target state="translated">Construye tu propio</target>
        </trans-unit>
        <trans-unit id="1d333bcb58941bfd7a3fb8cda029220d5a88e47f" translate="yes" xml:space="preserve">
          <source>Conceptually, the simplest regular expressions are literal characters. The pattern &lt;code&gt;N&lt;/code&gt; matches the character 'N'.</source>
          <target state="translated">Conceptualmente, las expresiones regulares m&amp;aacute;s simples son caracteres literales. El patr&amp;oacute;n &lt;code&gt;N&lt;/code&gt; coincide con el car&amp;aacute;cter 'N'.</target>
        </trans-unit>
        <trans-unit id="fabc21bb541d3248d6745e3a4b9e442f9a030f7d" translate="yes" xml:space="preserve">
          <source>Earlier, we saw one way to match either 'Nick' or 'nick'. Another is with alternation as in &lt;code&gt;Nick|nick&lt;/code&gt;. Remember that alternation includes everything to its left and everything to its right. Use grouping parentheses to limit the scope of &lt;code&gt;|&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;(Nick|nick)&lt;/code&gt;.</source>
          <target state="translated">Anteriormente, vimos una forma de hacer coincidir 'Nick' o 'nick'. Otro es con alternancia como en &lt;code&gt;Nick|nick&lt;/code&gt; . Recuerde que la alternancia incluye todo a su izquierda y todo a su derecha. Use par&amp;eacute;ntesis de agrupaci&amp;oacute;n para limitar el alcance de &lt;code&gt;|&lt;/code&gt; , &lt;em&gt;por ejemplo&lt;/em&gt; , &lt;code&gt;(Nick|nick)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2779ea444cb47200f1b0085d04662b33c09fc23f" translate="yes" xml:space="preserve">
          <source>Escaping</source>
          <target state="translated">Escaping</target>
        </trans-unit>
        <trans-unit id="40e31a210a1913fd0a8b28b892780996d154c70d" translate="yes" xml:space="preserve">
          <source>Footnote</source>
          <target state="translated">Footnote</target>
        </trans-unit>
        <trans-unit id="4cd395750596fc63879f88a287d8880fa0e85e60" translate="yes" xml:space="preserve">
          <source>For another example, you could equivalently write &lt;code&gt;[a-c]&lt;/code&gt; as &lt;code&gt;a|b|c&lt;/code&gt;, but this is likely to be suboptimal because many implementations assume alternatives will have lengths greater than 1.</source>
          <target state="translated">Para otro ejemplo, podr&amp;iacute;a escribir &lt;code&gt;[a-c]&lt;/code&gt; equivalente como &lt;code&gt;a|b|c&lt;/code&gt; , pero es probable que esto sea sub&amp;oacute;ptimo porque muchas implementaciones suponen que las alternativas tendr&amp;aacute;n longitudes mayores que 1.</target>
        </trans-unit>
        <trans-unit id="1afa4f2a09ae6c3e5a9c146d9e129073c4f2e82e" translate="yes" xml:space="preserve">
          <source>For example, say the input is</source>
          <target state="translated">Por ejemplo,digamos que la entrada es</target>
        </trans-unit>
        <trans-unit id="8dd341228f5203334a2dbe18a099fd9cdb246553" translate="yes" xml:space="preserve">
          <source>Free resources</source>
          <target state="translated">Recursos gratuitos</target>
        </trans-unit>
        <trans-unit id="8b058c9ddbb5e235a3b17a4d130bb8609fba9734" translate="yes" xml:space="preserve">
          <source>From there, you can repeat parts of your pattern with &lt;em&gt;quantifiers&lt;/em&gt;. For example, the pattern &lt;code&gt;ab?c&lt;/code&gt; matches 'abc' or 'ac' because the &lt;code&gt;?&lt;/code&gt; quantifier makes the subpattern it modifies optional. Other quantifiers are</source>
          <target state="translated">A partir de ah&amp;iacute;, puede repetir partes de su patr&amp;oacute;n con &lt;em&gt;cuantificadores&lt;/em&gt; . Por ejemplo, el patr&amp;oacute;n &lt;code&gt;ab?c&lt;/code&gt; coincide con 'abc' o 'ac' porque el &lt;code&gt;?&lt;/code&gt; cuantificador hace que el subpatr&amp;oacute;n que modifica sea opcional. Otros cuantificadores son</target>
        </trans-unit>
        <trans-unit id="59985b76bfac61da62ef1b2c39db3443c181b381" translate="yes" xml:space="preserve">
          <source>Greediness</source>
          <target state="translated">Greediness</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="f646cf743adf4a08fb6e1b26f378b70f117af712" translate="yes" xml:space="preserve">
          <source>Helpful shortcuts</source>
          <target state="translated">Atajos útiles</target>
        </trans-unit>
        <trans-unit id="9356b9688cab55bd64e84c0c92cc854e57b999b4" translate="yes" xml:space="preserve">
          <source>How Regexes Work</source>
          <target state="translated">Cómo funcionan los Regexes</target>
        </trans-unit>
        <trans-unit id="a5370c7d8ba341173df1c3b84ffdbdf6a7833cfc" translate="yes" xml:space="preserve">
          <source>I don't really understand regular expressions.  Can you explain them to me in an easy-to-follow manner?  If there are any online tools or books, could you also link to them?</source>
          <target state="translated">No entiendo las expresiones regulares.¿Puede explicármelas de una manera fácil de seguir? Si hay alguna herramienta o libro en línea,¿podría también enlazarlos?</target>
        </trans-unit>
        <trans-unit id="530b1c010c952dc47e7ccad7a66d94ff2c275a0e" translate="yes" xml:space="preserve">
          <source>If you think of regular expressions as building blocks that you can mix and match as you please, it helps you learn how to write and debug your own patterns but also how to understand patterns written by others.</source>
          <target state="translated">Si piensas en las expresiones regulares como bloques de construcción que puedes mezclar y combinar a tu gusto,te ayuda a aprender a escribir y depurar tus propios patrones,pero también a entender los patrones escritos por otros.</target>
        </trans-unit>
        <trans-unit id="46b79bd52027013bd53543e10582ce6baeead7a2" translate="yes" xml:space="preserve">
          <source>If you've ever used &lt;code&gt;grep&lt;/code&gt; on Unix&amp;mdash;even if only to search for ordinary looking strings&amp;mdash;you've already been using regular expressions! (The &lt;code&gt;re&lt;/code&gt; in &lt;code&gt;grep&lt;/code&gt; refers to regular expressions.)</source>
          <target state="translated">Si alguna vez ha usado &lt;code&gt;grep&lt;/code&gt; en Unix, incluso si solo busca cadenas de aspecto ordinario, &amp;iexcl;ya ha estado usando expresiones regulares! (La referencia en &lt;code&gt;grep&lt;/code&gt; se refiere a expresiones regulares).</target>
        </trans-unit>
        <trans-unit id="3f48e3ea7a67593afc624d898633d8bcfd4d221e" translate="yes" xml:space="preserve">
          <source>If your input is '(123) (456)', then the first capture will be '123'. Non-greedy quantifiers want to allow the rest of the pattern to start matching as soon as possible.</source>
          <target state="translated">Si su entrada es '(123)(456)',entonces la primera captura será '(123)'.Los cuantificadores no codiciosos quieren permitir que el resto del patrón empiece a coincidir lo antes posible.</target>
        </trans-unit>
        <trans-unit id="feecfcff81cdfac79c1169c68bcdf3298543a39e" translate="yes" xml:space="preserve">
          <source>Learning Regular Expressions</source>
          <target state="translated">Aprendiendo expresiones regulares</target>
        </trans-unit>
        <trans-unit id="54274c1b66e4db9103a52754b9f88c07567bd846" translate="yes" xml:space="preserve">
          <source>Nick</source>
          <target state="translated">Nick</target>
        </trans-unit>
        <trans-unit id="c659a1a4add3674e46b01f5c3aed16066f609fba" translate="yes" xml:space="preserve">
          <source>Nnick</source>
          <target state="translated">Nnick</target>
        </trans-unit>
        <trans-unit id="849e6a4431d3bc9b7fd03e9363f4f10c14117c82" translate="yes" xml:space="preserve">
          <source>Once is not enough</source>
          <target state="translated">Una vez no es suficiente</target>
        </trans-unit>
        <trans-unit id="82eb240ece12cf01f54324b6e46ee819e866dd8b" translate="yes" xml:space="preserve">
          <source>Order from the menu</source>
          <target state="translated">Ordene desde el menú</target>
        </trans-unit>
        <trans-unit id="44a71879f76eef9a972c14aeb610df9bb2a2d7cd" translate="yes" xml:space="preserve">
          <source>Perl: &lt;a href=&quot;https://metacpan.org/release/YAPE-Regex-Explain&quot;&gt;YAPE: Regex Explain&lt;/a&gt;</source>
          <target state="translated">Perl: &lt;a href=&quot;https://metacpan.org/release/YAPE-Regex-Explain&quot;&gt;YAPE: Regex Explain&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="947c6e8160e2686ffe1464043c63e0d649717e4f" translate="yes" xml:space="preserve">
          <source>Putting some of these blocks together, the pattern &lt;code&gt;[Nn]*ick&lt;/code&gt; matches all of</source>
          <target state="translated">Al juntar algunos de estos bloques, el patr&amp;oacute;n &lt;code&gt;[Nn]*ick&lt;/code&gt; coincide con todos</target>
        </trans-unit>
        <trans-unit id="16dc60b323d79a2f6113da0cf72b1173c59702bf" translate="yes" xml:space="preserve">
          <source>Regex Buddy</source>
          <target state="translated">Regex Buddy</target>
        </trans-unit>
        <trans-unit id="b9648927d75753351180b745bd9201dc142cf8bb" translate="yes" xml:space="preserve">
          <source>Regex Cookbook</source>
          <target state="translated">Regex Cookbook</target>
        </trans-unit>
        <trans-unit id="79fd14db3d8dce5771ed8d43cbac1e67ff353684" translate="yes" xml:space="preserve">
          <source>Regex Syntax Summary</source>
          <target state="translated">Resumen de la sintaxis de Regex</target>
        </trans-unit>
        <trans-unit id="d8fee145772e06e3d12eea6ce0cb821cd8678167" translate="yes" xml:space="preserve">
          <source>RegexOne - Learn with simple, interactive exercises.</source>
          <target state="translated">RegexOne-Aprenda con ejercicios simples e interactivos.</target>
        </trans-unit>
        <trans-unit id="c8974ee3c3bc80517e839f83d10737faa707127b" translate="yes" xml:space="preserve">
          <source>Regular Expressions Cheat Sheet</source>
          <target state="translated">Hoja de Trampas de Expresiones Regulares</target>
        </trans-unit>
        <trans-unit id="89c14d5368a465f10ef6a24a01a9a7b38da0fc57" translate="yes" xml:space="preserve">
          <source>Regular Expressions Online Tester</source>
          <target state="translated">Probador de expresiones regulares en línea</target>
        </trans-unit>
        <trans-unit id="5699d9c17f85d41638b57e6a204ea26e5d711b98" translate="yes" xml:space="preserve">
          <source>Regular expression quantifiers are greedy. This means they match as much text as they possibly can while allowing the entire pattern to match successfully.</source>
          <target state="translated">Los cuantificadores de expresión regular son codiciosos.Esto significa que coinciden con la mayor cantidad de texto posible mientras permiten que todo el patrón coincida con éxito.</target>
        </trans-unit>
        <trans-unit id="68e27e707d3e03f55d0c8a5732979a4ccc2d797c" translate="yes" xml:space="preserve">
          <source>Regular expressions are recursive, so now that you understand these basic rules, you can combine them however you like.</source>
          <target state="translated">Las expresiones regulares son recursivas,así que ahora que entiendes estas reglas básicas,puedes combinarlas como quieras.</target>
        </trans-unit>
        <trans-unit id="6c187c47e14e519d74321d9000d5afb95d07cfdc" translate="yes" xml:space="preserve">
          <source>Regular expressions next to each other match sequences. For example, the pattern &lt;code&gt;Nick&lt;/code&gt; matches the sequence 'N' followed by 'i' followed by 'c' followed by 'k'.</source>
          <target state="translated">Las expresiones regulares una al lado de la otra coinciden con las secuencias. Por ejemplo, el patr&amp;oacute;n &lt;code&gt;Nick&lt;/code&gt; coincide con la secuencia 'N' seguida de 'i' seguida de 'c' seguida de 'k'.</target>
        </trans-unit>
        <trans-unit id="3555c1a56411b43a7966c37d01ae16f4955f43f9" translate="yes" xml:space="preserve">
          <source>Say you want to match comments of the form</source>
          <target state="translated">Diga que quiere hacer coincidir los comentarios del formulario</target>
        </trans-unit>
        <trans-unit id="cb45b4e62bf666c532a02287bb4fb02a809b6fc5" translate="yes" xml:space="preserve">
          <source>Start simple</source>
          <target state="translated">Empieza simple</target>
        </trans-unit>
        <trans-unit id="28aef8f69db620eb498820f0e319209292abdccd" translate="yes" xml:space="preserve">
          <source>Teach Yourself Regular Expressions</source>
          <target state="translated">Enséñese expresiones regulares</target>
        </trans-unit>
        <trans-unit id="c845c6000fff99af437a9fc8c2e6f447122a611d" translate="yes" xml:space="preserve">
          <source>The first match demonstrates an important lesson: &lt;em&gt;&lt;code&gt;*&lt;/code&gt; always succeeds!&lt;/em&gt; Any pattern can match zero times.</source>
          <target state="translated">El primer partido demuestra una lecci&amp;oacute;n importante: &lt;em&gt; &lt;code&gt;*&lt;/code&gt; &amp;iexcl; siempre tiene &amp;eacute;xito!&lt;/em&gt; Cualquier patr&amp;oacute;n puede coincidir con cero veces.</target>
        </trans-unit>
        <trans-unit id="b96fd7359131170ec3910a2c15c093b0604c1e9d" translate="yes" xml:space="preserve">
          <source>The most important part is the concepts. Once you understand how the building blocks work, differences in syntax amount to little more than mild dialects. A layer on top of your regular expression engine's syntax is the syntax of the programming language you're using. Languages such as Perl remove most of this complication, but you'll have to keep in mind other considerations if you're using regular expressions in a C program.</source>
          <target state="translated">La parte más importante son los conceptos.Una vez que entiendes cómo funcionan los bloques de construcción,las diferencias en la sintaxis equivalen a poco más que los dialectos suaves.Una capa encima de la sintaxis de tu motor de expresión regular es la sintaxis del lenguaje de programación que estás usando.Lenguajes como el Perl eliminan la mayor parte de esta complicación,pero tendrás que tener en cuenta otras consideraciones si estás usando expresiones regulares en un programa C.</target>
        </trans-unit>
        <trans-unit id="22715149bb9c6655ed248fa2ba77fe101f0f5ecb" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;.&lt;/code&gt; is special: rather than matching a literal dot only, it matches &lt;em&gt;any&lt;/em&gt; character&lt;sup&gt;&amp;dagger;&lt;/sup&gt;. It's the same conceptually as the really big character class &lt;code&gt;[-.?+%$A-Za-z0-9...]&lt;/code&gt;.</source>
          <target state="translated">El patr&amp;oacute;n es especial: en lugar de hacer coincidir solo un punto literal, coincide con &lt;em&gt;cualquier&lt;/em&gt; car&amp;aacute;cter &lt;sup&gt;&amp;dagger;&lt;/sup&gt; . Es lo mismo conceptualmente que la clase de personaje realmente grande &lt;code&gt;[-.?+%$A-Za-z0-9...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91a4d600b807bd4f09976a09959e06274f29ba2d" translate="yes" xml:space="preserve">
          <source>The uppercased variants are their complements, so &lt;code&gt;\S&lt;/code&gt; matches any &lt;em&gt;non&lt;/em&gt;-whitespace character, for example.</source>
          <target state="translated">Las variantes en may&amp;uacute;sculas son sus complementos, por lo que &lt;code&gt;\S&lt;/code&gt; coincide con cualquier car&amp;aacute;cter que &lt;em&gt;no sea un&lt;/em&gt; espacio en blanco, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="e293881e27590496ef91a61c6c25643e50a9e297" translate="yes" xml:space="preserve">
          <source>Think of character classes as menus: pick just one.</source>
          <target state="translated">Piensa en las clases de personajes como menús:elige sólo uno.</target>
        </trans-unit>
        <trans-unit id="de4b0e2db7bd3c9c11ac9e377548480b18fc9bf9" translate="yes" xml:space="preserve">
          <source>To match one or more sequences of 'abc' with zeros on the ends, use &lt;code&gt;0(abc)+0&lt;/code&gt;. The parentheses denote a subpattern that can be quantified as a unit. It's also common for regular expression engines to save or &quot;capture&quot; the portion of the input text that matches a parenthesized group. Extracting bits this way is much more flexible and less error-prone than counting indices and &lt;code&gt;substr&lt;/code&gt;.</source>
          <target state="translated">Para hacer coincidir una o m&amp;aacute;s secuencias de 'abc' con ceros en los extremos, use &lt;code&gt;0(abc)+0&lt;/code&gt; . Los par&amp;eacute;ntesis denotan un subpatr&amp;oacute;n que se puede cuantificar como una unidad. Tambi&amp;eacute;n es com&amp;uacute;n que los motores de expresi&amp;oacute;n regular guarden o &quot;capturen&quot; la parte del texto de entrada que coincide con un grupo entre par&amp;eacute;ntesis. Extraer bits de esta manera es mucho m&amp;aacute;s flexible y menos propenso a errores que contar &amp;iacute;ndices y &lt;code&gt;substr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ddbc5d0277e3c16b73cf8e609473468f17b01c" translate="yes" xml:space="preserve">
          <source>To switch from greedy to what you might think of as cautious, add an extra &lt;code&gt;?&lt;/code&gt; to the quantifier. Now you understand how &lt;code&gt;\((.+?)\)&lt;/code&gt;, the example from your question works. It matches the sequence of a literal left-parenthesis, followed by one or more characters, and terminated by a right-parenthesis.</source>
          <target state="translated">Para cambiar de codicioso a lo que podr&amp;iacute;a considerar cauteloso, agregue un extra &lt;code&gt;?&lt;/code&gt; al cuantificador Ahora comprende c&amp;oacute;mo &lt;code&gt;\((.+?)\)&lt;/code&gt; , Funciona el ejemplo de su pregunta. Coincide con la secuencia de un par&amp;eacute;ntesis izquierdo literal, seguido de uno o m&amp;aacute;s caracteres, y termina con un par&amp;eacute;ntesis derecho.</target>
        </trans-unit>
        <trans-unit id="92935cc481013b79cd161911bb7bc552f1ba3812" translate="yes" xml:space="preserve">
          <source>Tools for writing and debugging regexes:</source>
          <target state="translated">Herramientas para escribir y depurar regexes:</target>
        </trans-unit>
        <trans-unit id="a1fd9141e7da915eb8a8004fe9ab9111acd0635a" translate="yes" xml:space="preserve">
          <source>Txt2RE</source>
          <target state="translated">Txt2RE</target>
        </trans-unit>
        <trans-unit id="fe6d79779c9d27867ff69b0be6ad558feeaa20f7" translate="yes" xml:space="preserve">
          <source>Use the special pattern &lt;code&gt;^&lt;/code&gt; to match only at the beginning of your input and &lt;code&gt;$&lt;/code&gt; to match only at the end. Making &quot;bookends&quot; with your patterns where you say, &quot;I know what's at the front and back, but give me everything between&quot; is a useful technique.</source>
          <target state="translated">Use el patr&amp;oacute;n especial &lt;code&gt;^&lt;/code&gt; para que coincida solo al comienzo de su entrada y &lt;code&gt;$&lt;/code&gt; para que coincida solo al final. Hacer &quot;sujetalibros&quot; con tus patrones donde dices: &quot;S&amp;eacute; lo que hay al frente y atr&amp;aacute;s, pero dame todo entre ellos&quot; es una t&amp;eacute;cnica &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="37304d600ce0cd62463a50ccd70b1ebda871fa2f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.&lt;/code&gt; can save you lots of typing, and there are other shortcuts for common patterns. Say you want to match a digit: one way to write that is &lt;code&gt;[0-9]&lt;/code&gt;. Digits are a frequent match target, so you could instead use the shortcut &lt;code&gt;\d&lt;/code&gt;. Others are &lt;code&gt;\s&lt;/code&gt; (whitespace) and &lt;code&gt;\w&lt;/code&gt; (word characters: alphanumerics or underscore).</source>
          <target state="translated">Utilizando &lt;code&gt;.&lt;/code&gt; puede ahorrarle mucho tipeo, y hay otros accesos directos para patrones comunes. Digamos que desea hacer coincidir un d&amp;iacute;gito: una forma de escribir que es &lt;code&gt;[0-9]&lt;/code&gt; . Los d&amp;iacute;gitos son un objetivo de coincidencia frecuente, por lo que podr&amp;iacute;a usar el acceso directo &lt;code&gt;\d&lt;/code&gt; . Otros son &lt;code&gt;\s&lt;/code&gt; (espacios en blanco) y &lt;code&gt;\w&lt;/code&gt; (caracteres de palabras: alfanum&amp;eacute;ricos o guiones bajos).</target>
        </trans-unit>
        <trans-unit id="526f639bebd48d81d13a90a85f8fd1789e9df34d" translate="yes" xml:space="preserve">
          <source>Visual RegExp</source>
          <target state="translated">Visual RegExp</target>
        </trans-unit>
        <trans-unit id="75e9f880bd62145e1e31f2d7b936986d0605f73e" translate="yes" xml:space="preserve">
          <source>You might expect &lt;code&gt;&quot;.+&quot;&lt;/code&gt; to match only 'Hello,' and will then be surprised when you see that it matched from 'Hello' all the way through 'you?'.</source>
          <target state="translated">Es posible que espere que &lt;code&gt;&quot;.+&quot;&lt;/code&gt; Coincida solo con 'Hola', y luego se sorprender&amp;aacute; cuando vea que coincide con 'Hola' a trav&amp;eacute;s de 'usted?'.</target>
        </trans-unit>
        <trans-unit id="a2b8abe4260aad959411d4203bb668f167991d6a" translate="yes" xml:space="preserve">
          <source>ick</source>
          <target state="translated">ick</target>
        </trans-unit>
        <trans-unit id="fc15a9dd34ddc23b9aff22adce8b09526d7b078c" translate="yes" xml:space="preserve">
          <source>nNick</source>
          <target state="translated">nNick</target>
        </trans-unit>
        <trans-unit id="75ef9faee755c70589550b513ad881e5a603182c" translate="yes" xml:space="preserve">
          <source>nick</source>
          <target state="translated">nick</target>
        </trans-unit>
        <trans-unit id="98cb5605f45e16baa3327dd0dd78f00ec9cc4b36" translate="yes" xml:space="preserve">
          <source>nnick</source>
          <target state="translated">nnick</target>
        </trans-unit>
        <trans-unit id="35b888ad74eacdebe041626f388c5c12bae6bfda" translate="yes" xml:space="preserve">
          <source>you'd write &lt;code&gt;^--\s+(.+)\s+--$&lt;/code&gt;.</source>
          <target state="translated">escribir&amp;iacute;as &lt;code&gt;^--\s+(.+)\s+--$&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
