<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/4736">
    <body>
      <group id="4736">
        <trans-unit id="8c342e8585fceeee466cfc575e45384b0da85bd4" translate="yes" xml:space="preserve">
          <source>&quot;Hello,&quot; she said, &quot;How are you?&quot;</source>
          <target state="translated">&quot;안녕하세요.&quot;그녀는 &quot;어떻게 지내?&quot;</target>
        </trans-unit>
        <trans-unit id="33005ca44ed78f77c7fadc5a196abf1256960301" translate="yes" xml:space="preserve">
          <source>(As to your confusion, I don't know of any regular-expression dialect where &lt;code&gt;((.+?))&lt;/code&gt; would do the same thing. I suspect something got lost in transmission somewhere along the way.)</source>
          <target state="translated">(혼동으로, 나는 &lt;code&gt;((.+?))&lt;/code&gt; 가 똑같은 일을 할 정규 표현 방언을 모른다. 나는 어딘가에서 전송에서 잃어버린 것으로 의심된다.)</target>
        </trans-unit>
        <trans-unit id="4ef24db075ab7963455bfe3ea7654428474ef88d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://neverfear.org/blog/view/Regex_tutorial_for_people_who_should_know_Regex__but_do_not___Part_1&quot;&gt;Regular Expressions - Everything you should know&lt;/a&gt; (PDF Series)</source>
          <target state="translated">&lt;a href=&quot;http://neverfear.org/blog/view/Regex_tutorial_for_people_who_should_know_Regex__but_do_not___Part_1&quot;&gt;정규식-알아야 할 모든 것&lt;/a&gt; (PDF 시리즈)</target>
        </trans-unit>
        <trans-unit id="4c618840a436ae1359f6b753fc7b297f01d3edc4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;Mastering Regular Expressions&lt;/a&gt;, the &lt;a href=&quot;http://oreilly.com/catalog/9780596002893&quot;&gt;2nd Edition&lt;/a&gt;, and the &lt;a href=&quot;http://shop.oreilly.com/product/9780596528126.do&quot;&gt;3rd edition&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;정규 표현식&lt;/a&gt; , &lt;a href=&quot;http://oreilly.com/catalog/9780596002893&quot;&gt;2 판&lt;/a&gt; 및 &lt;a href=&quot;http://shop.oreilly.com/product/9780596528126.do&quot;&gt;3 판 습득&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a78dcd68ae6f3277cb0e045417feb90a498d6dd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://regexlib.com/Default.aspx&quot;&gt;Regular Expression Library&lt;/a&gt; (Predefined Regexes for common scenarios)</source>
          <target state="translated">&lt;a href=&quot;http://regexlib.com/Default.aspx&quot;&gt;정규식 라이브러리&lt;/a&gt; (일반 시나리오에 대해 미리 정의 된 정규식 )</target>
        </trans-unit>
        <trans-unit id="52ba4e284aa4c3ef639e8a8eb43c76f0d2dd305d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://regexstorm.net/&quot;&gt;Regex Storm&lt;/a&gt; (for .NET)</source>
          <target state="translated">&lt;a href=&quot;http://regexstorm.net/&quot;&gt;정규식 폭풍&lt;/a&gt; (.NET 용)</target>
        </trans-unit>
        <trans-unit id="c399644d59ada43490f6ffcfa767c8ffa88aaf34" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weitz.de/regex-coach/&quot;&gt;Regex Coach&lt;/a&gt; (engine backed by &lt;a href=&quot;https://edicl.github.io/cl-ppcre/&quot;&gt;CL-PPCRE&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://weitz.de/regex-coach/&quot;&gt;정규식 코치&lt;/a&gt; ( &lt;a href=&quot;https://edicl.github.io/cl-ppcre/&quot;&gt;CL-PPCRE&lt;/a&gt; 지원 엔진)</target>
        </trans-unit>
        <trans-unit id="37fbb3c67041c88bb5fb2ee7d0ea73da5aca34b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;Expresso&lt;/a&gt; (for .NET)</source>
          <target state="translated">&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;Expresso&lt;/a&gt; (.NET 용)</target>
        </trans-unit>
        <trans-unit id="5091e76616eb92b95cb38de4c129f9453eee45c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regex101.com/&quot;&gt;Regex 101&lt;/a&gt; (for PCRE, JavaScript, Python, Golang)</source>
          <target state="translated">&lt;a href=&quot;https://regex101.com/&quot;&gt;정규식 101&lt;/a&gt; (PCRE, JavaScript, Python, Golang 용)</target>
        </trans-unit>
        <trans-unit id="0219e5502b55fbd56d948d75b0b9d635ece58d47" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regexr.com/&quot;&gt;RegExr&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://regexr.com/&quot;&gt;RegExr&lt;/a&gt; (JavaScript 용)</target>
        </trans-unit>
        <trans-unit id="88542bbf29e8bb29a91e15cec896ae72f5da8770" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://rubular.com/&quot;&gt;Rubular&lt;/a&gt; (for Ruby)</source>
          <target state="translated">&lt;a href=&quot;https://rubular.com/&quot;&gt;루블&lt;/a&gt; ( 루 비용 )</target>
        </trans-unit>
        <trans-unit id="2307de32b2e7372a804ec97e3ca567c35d03bd92" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.debuggex.com/&quot;&gt;Debuggex&lt;/a&gt; (visual regex tester and helper)</source>
          <target state="translated">&lt;a href=&quot;https://www.debuggex.com/&quot;&gt;Debuggex&lt;/a&gt; (시각 정규식 테스터 및 도우미)</target>
        </trans-unit>
        <trans-unit id="b671ff66076869497a948d0bf95f5fc2b9e40299" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.regexpal.com/&quot;&gt;RegexPal&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://www.regexpal.com/&quot;&gt;RegexPal&lt;/a&gt; (JavaScript 용)</target>
        </trans-unit>
        <trans-unit id="9cb9a6ab932dceec9ffe65247bc3cccfda5da286" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.regextester.com/&quot;&gt;Regex Tester&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://www.regextester.com/&quot;&gt;정규식 테스터&lt;/a&gt; (JavaScript 용)</target>
        </trans-unit>
        <trans-unit id="eeb0890b8bae80c63e782001363779e5dd6a4cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; (zero or more times)</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; (0 회 이상)</target>
        </trans-unit>
        <trans-unit id="68e7787028c0f8e5c7cb1974a6a29b105ad2afb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; (one or more times)</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; (하나 이상)</target>
        </trans-unit>
        <trans-unit id="4078b42459a3d9c1d9e1e9ea095ffdfc0773bc68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[0-9]+&lt;/code&gt; (and its equivalent &lt;code&gt;\d+&lt;/code&gt;) matches any non-negative integer</source>
          <target state="translated">&lt;code&gt;[0-9]+&lt;/code&gt; (및 동등한 &lt;code&gt;\d+&lt;/code&gt; )는 음이 아닌 정수와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c29c5736875d33c09abed9a6b02279da10095e0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt; matches dates formatted like 2019-01-01</source>
          <target state="translated">&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt; 는 2019-01-01과 같은 형식의 날짜와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b251d9b6ea61001d2d2aa44d156af068b0ca092e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,m}&lt;/code&gt; (at least &lt;em&gt;n&lt;/em&gt; times but no more than &lt;em&gt;m&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n,m}&lt;/code&gt; (최소 &lt;em&gt;n&lt;/em&gt; 회, &lt;em&gt;m&lt;/em&gt; 회 이하)</target>
        </trans-unit>
        <trans-unit id="ef799869d678028f74953d5c3755452d618be643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,}&lt;/code&gt; (at least &lt;em&gt;n&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n,}&lt;/code&gt; (최소 &lt;em&gt;n&lt;/em&gt; 회)</target>
        </trans-unit>
        <trans-unit id="8ea261c3e08a435014c07c930a9339279f834530" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n}&lt;/code&gt; (exactly &lt;em&gt;n&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n}&lt;/code&gt; (정확히 &lt;em&gt;n&lt;/em&gt; 번)</target>
        </trans-unit>
        <trans-unit id="ebf2b2b20b1e034d96b759673425d9a2e451a754" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(and so on)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(등등)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dab55287a0c775bf4cd951c49b0ac8dfa0b7f22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;dagger;:&lt;/strong&gt; The statement above that &lt;code&gt;.&lt;/code&gt; matches any character is a simplification for pedagogical purposes that is not strictly true. Dot matches any character except newline, &lt;code&gt;&quot;\n&quot;&lt;/code&gt;, but in practice you rarely expect a pattern such as &lt;code&gt;.+&lt;/code&gt; to cross a newline boundary. Perl regexes have a &lt;a href=&quot;https://perldoc.perl.org/perlre.html#s&quot;&gt;&lt;code&gt;/s&lt;/code&gt; switch&lt;/a&gt; and Java &lt;a href=&quot;https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html#DOTALL&quot;&gt;&lt;code&gt;Pattern.DOTALL&lt;/code&gt;&lt;/a&gt;, for example, to make &lt;code&gt;.&lt;/code&gt; match any character at all. For languages that don't have such a feature, you can use something like &lt;code&gt;[\s\S]&lt;/code&gt; to match &quot;any whitespace or any non-whitespace&quot;, in other words anything.</source>
          <target state="translated">&lt;strong&gt;&amp;dagger; :&lt;/strong&gt; 위의 진술 &lt;code&gt;.&lt;/code&gt; 모든 문자와 일치하는 것은 엄격하게 사실이 아닌 교육적 목적을 위해 단순화 된 것입니다. 점은 개행 문자 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 제외한 모든 문자와 일치하지만 실제로는 &lt;code&gt;.+&lt;/code&gt; 와 같은 패턴이 개행 경계를 넘을 것으로 예상하지 않습니다. Perl 정규 표현식에는 &lt;a href=&quot;https://perldoc.perl.org/perlre.html#s&quot;&gt; &lt;code&gt;/s&lt;/code&gt; 스위치&lt;/a&gt; 와 Java &lt;a href=&quot;https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html#DOTALL&quot;&gt; &lt;code&gt;Pattern.DOTALL&lt;/code&gt; &lt;/a&gt; 이 있습니다 (예 : make) &lt;code&gt;.&lt;/code&gt; 어떤 캐릭터와도 일치합니다. 이러한 기능이없는 언어의 경우 &lt;code&gt;[\s\S]&lt;/code&gt; 와 같은 것을 사용하여 &quot;임의의 공백 또는 공백이 아닌&quot;, 즉 다른 것과 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4616c92589ed8e68a1ebbf03782fde32acb593f" translate="yes" xml:space="preserve">
          <source>A few other useful examples:</source>
          <target state="translated">몇 가지 다른 유용한 예 :</target>
        </trans-unit>
        <trans-unit id="9698c2a9402dd87d80e8df20e87b7752186b2fba" translate="yes" xml:space="preserve">
          <source>A quantifier modifies the pattern to its immediate left. You might expect &lt;code&gt;0abc+0&lt;/code&gt; to match '0abc0', '0abcabc0', and so forth, but the pattern &lt;em&gt;immediately&lt;/em&gt; to the left of the plus quantifier is &lt;code&gt;c&lt;/code&gt;. This means &lt;code&gt;0abc+0&lt;/code&gt; matches '0abc0', '0abcc0', '0abccc0', and so on.</source>
          <target state="translated">수량자는 패턴을 바로 왼쪽으로 수정합니다. &lt;code&gt;0abc+0&lt;/code&gt; 이 '0abc0', '0abcabc0'등과 일치 할 것으로 예상 할 수 있지만 더하기 수량 자 &lt;em&gt;바로&lt;/em&gt; 왼쪽의 패턴은 &lt;code&gt;c&lt;/code&gt; 입니다. 이는 &lt;code&gt;0abc+0&lt;/code&gt; 이 '0abc0', '0abcc0', '0abccc0'등과 일치 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c2eec20b60545f98a44bd16ad8a4e0cd3a89a41a" translate="yes" xml:space="preserve">
          <source>Adding just a little complexity, you can match either 'Nick' or 'nick' with the pattern &lt;code&gt;[Nn]ick&lt;/code&gt;. The part in square brackets is a &lt;em&gt;character class&lt;/em&gt;, which means it matches exactly one of the enclosed characters. You can also use ranges in character classes, so &lt;code&gt;[a-c]&lt;/code&gt; matches either 'a' or 'b' or 'c'.</source>
          <target state="translated">약간의 복잡성을 추가하면 'Nick'또는 'nick'을 &lt;code&gt;[Nn]ick&lt;/code&gt; 패턴과 일치시킬 수 있습니다. 대괄호로 묶인 부분은 &lt;em&gt;문자 클래스&lt;/em&gt; 이므로 동봉 된 문자 중 하나와 정확히 일치합니다. 문자 클래스에서 범위를 사용할 수도 있으므로 &lt;code&gt;[a-c]&lt;/code&gt; 는 'a'또는 'b'또는 'c'와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="83d719739c59379bf19d989792e9ec8998993c2d" translate="yes" xml:space="preserve">
          <source>Although some characters match themselves, others have special meanings. The pattern &lt;code&gt;\d+&lt;/code&gt; doesn't match backslash followed by lowercase D followed by a plus sign: to get that, we'd use &lt;code&gt;\\d\+&lt;/code&gt;. A backslash removes the special meaning from the following character.</source>
          <target state="translated">일부 문자는 서로 일치하지만 다른 문자는 특별한 의미를 갖습니다. &lt;code&gt;\d+&lt;/code&gt; 패턴은 백 슬래시, 소문자 D, 더하기 부호와 일치하지 않습니다.이를 위해서는 &lt;code&gt;\\d\+&lt;/code&gt; 합니다. 백 슬래시는 다음 문자에서 특별한 의미를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a307a637b89fe16e9922778e99bea2ed2e8e496b" translate="yes" xml:space="preserve">
          <source>Anchors</source>
          <target state="translated">Anchors</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="f20b35258323d6253263d376f19f1859ea7fa62f" translate="yes" xml:space="preserve">
          <source>Build your own</source>
          <target state="translated">나만의 빌드</target>
        </trans-unit>
        <trans-unit id="1d333bcb58941bfd7a3fb8cda029220d5a88e47f" translate="yes" xml:space="preserve">
          <source>Conceptually, the simplest regular expressions are literal characters. The pattern &lt;code&gt;N&lt;/code&gt; matches the character 'N'.</source>
          <target state="translated">개념 상 가장 간단한 정규식은 리터럴 문자입니다. 패턴 &lt;code&gt;N&lt;/code&gt; 은 문자 'N'과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fabc21bb541d3248d6745e3a4b9e442f9a030f7d" translate="yes" xml:space="preserve">
          <source>Earlier, we saw one way to match either 'Nick' or 'nick'. Another is with alternation as in &lt;code&gt;Nick|nick&lt;/code&gt;. Remember that alternation includes everything to its left and everything to its right. Use grouping parentheses to limit the scope of &lt;code&gt;|&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;(Nick|nick)&lt;/code&gt;.</source>
          <target state="translated">이전에는 '닉'또는 '닉'과 일치하는 방법을 보았습니다. 다른 하나는 &lt;code&gt;Nick|nick&lt;/code&gt; 에서와 같이 교대로 있습니다. 교대에는 왼쪽의 모든 것과 오른쪽의 모든 것이 포함됩니다. 그룹화 괄호를 사용하여 &lt;code&gt;|&lt;/code&gt; &lt;em&gt;예를 들어&lt;/em&gt; , &lt;code&gt;(Nick|nick)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2779ea444cb47200f1b0085d04662b33c09fc23f" translate="yes" xml:space="preserve">
          <source>Escaping</source>
          <target state="translated">Escaping</target>
        </trans-unit>
        <trans-unit id="40e31a210a1913fd0a8b28b892780996d154c70d" translate="yes" xml:space="preserve">
          <source>Footnote</source>
          <target state="translated">Footnote</target>
        </trans-unit>
        <trans-unit id="4cd395750596fc63879f88a287d8880fa0e85e60" translate="yes" xml:space="preserve">
          <source>For another example, you could equivalently write &lt;code&gt;[a-c]&lt;/code&gt; as &lt;code&gt;a|b|c&lt;/code&gt;, but this is likely to be suboptimal because many implementations assume alternatives will have lengths greater than 1.</source>
          <target state="translated">다른 예를 들어, &lt;code&gt;[a-c]&lt;/code&gt; 를 &lt;code&gt;a|b|c&lt;/code&gt; 로 동등하게 쓸 수는 있지만, 많은 구현에서 대안의 길이가 1보다 길다고 가정하기 때문에이 방법은 차선책 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1afa4f2a09ae6c3e5a9c146d9e129073c4f2e82e" translate="yes" xml:space="preserve">
          <source>For example, say the input is</source>
          <target state="translated">예를 들어 입력이</target>
        </trans-unit>
        <trans-unit id="8dd341228f5203334a2dbe18a099fd9cdb246553" translate="yes" xml:space="preserve">
          <source>Free resources</source>
          <target state="translated">무료 자료</target>
        </trans-unit>
        <trans-unit id="8b058c9ddbb5e235a3b17a4d130bb8609fba9734" translate="yes" xml:space="preserve">
          <source>From there, you can repeat parts of your pattern with &lt;em&gt;quantifiers&lt;/em&gt;. For example, the pattern &lt;code&gt;ab?c&lt;/code&gt; matches 'abc' or 'ac' because the &lt;code&gt;?&lt;/code&gt; quantifier makes the subpattern it modifies optional. Other quantifiers are</source>
          <target state="translated">여기에서 &lt;em&gt;수량자를 사용&lt;/em&gt; 하여 패턴의 일부를 반복 할 수 있습니다. 예를 들어 패턴 &lt;code&gt;ab?c&lt;/code&gt; 는 'abc'또는 'ac'와 일치하므로 &lt;code&gt;?&lt;/code&gt; 수량화는 수정하는 하위 패턴을 선택적으로 만듭니다. 다른 정량자는</target>
        </trans-unit>
        <trans-unit id="59985b76bfac61da62ef1b2c39db3443c181b381" translate="yes" xml:space="preserve">
          <source>Greediness</source>
          <target state="translated">Greediness</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="f646cf743adf4a08fb6e1b26f378b70f117af712" translate="yes" xml:space="preserve">
          <source>Helpful shortcuts</source>
          <target state="translated">유용한 단축키</target>
        </trans-unit>
        <trans-unit id="9356b9688cab55bd64e84c0c92cc854e57b999b4" translate="yes" xml:space="preserve">
          <source>How Regexes Work</source>
          <target state="translated">정규식 작동 방식</target>
        </trans-unit>
        <trans-unit id="a5370c7d8ba341173df1c3b84ffdbdf6a7833cfc" translate="yes" xml:space="preserve">
          <source>I don't really understand regular expressions.  Can you explain them to me in an easy-to-follow manner?  If there are any online tools or books, could you also link to them?</source>
          <target state="translated">정규 표현식을 실제로 이해하지 못합니다. 따라하기 쉬운 방법으로 설명해 주시겠습니까? 온라인 도구 나 책이 있다면 그 도구들에도 연결할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="530b1c010c952dc47e7ccad7a66d94ff2c275a0e" translate="yes" xml:space="preserve">
          <source>If you think of regular expressions as building blocks that you can mix and match as you please, it helps you learn how to write and debug your own patterns but also how to understand patterns written by others.</source>
          <target state="translated">정규식을 원하는대로 혼합하고 일치시킬 수있는 빌딩 블록으로 생각하면 자신의 패턴을 작성하고 디버그하는 방법과 다른 사람이 작성한 패턴을 이해하는 방법을 배우는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="46b79bd52027013bd53543e10582ce6baeead7a2" translate="yes" xml:space="preserve">
          <source>If you've ever used &lt;code&gt;grep&lt;/code&gt; on Unix&amp;mdash;even if only to search for ordinary looking strings&amp;mdash;you've already been using regular expressions! (The &lt;code&gt;re&lt;/code&gt; in &lt;code&gt;grep&lt;/code&gt; refers to regular expressions.)</source>
          <target state="translated">유닉스에서 &lt;code&gt;grep&lt;/code&gt; 을 사용해 본 적이 있다면 (보통 일반 문자열 만 검색하더라도) 이미 정규 표현식을 사용하고 있습니다! &lt;code&gt;grep&lt;/code&gt; in &lt;code&gt;re&lt;/code&gt; 은 정규 표현식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f48e3ea7a67593afc624d898633d8bcfd4d221e" translate="yes" xml:space="preserve">
          <source>If your input is '(123) (456)', then the first capture will be '123'. Non-greedy quantifiers want to allow the rest of the pattern to start matching as soon as possible.</source>
          <target state="translated">입력이 '(123) (456)'이면 첫 번째 캡처는 '123'입니다. 욕심없는 정량자는 나머지 패턴이 가능한 빨리 일치하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="feecfcff81cdfac79c1169c68bcdf3298543a39e" translate="yes" xml:space="preserve">
          <source>Learning Regular Expressions</source>
          <target state="translated">정규식 학습</target>
        </trans-unit>
        <trans-unit id="54274c1b66e4db9103a52754b9f88c07567bd846" translate="yes" xml:space="preserve">
          <source>Nick</source>
          <target state="translated">Nick</target>
        </trans-unit>
        <trans-unit id="c659a1a4add3674e46b01f5c3aed16066f609fba" translate="yes" xml:space="preserve">
          <source>Nnick</source>
          <target state="translated">Nnick</target>
        </trans-unit>
        <trans-unit id="849e6a4431d3bc9b7fd03e9363f4f10c14117c82" translate="yes" xml:space="preserve">
          <source>Once is not enough</source>
          <target state="translated">한 번이면 충분하지 않습니다</target>
        </trans-unit>
        <trans-unit id="82eb240ece12cf01f54324b6e46ee819e866dd8b" translate="yes" xml:space="preserve">
          <source>Order from the menu</source>
          <target state="translated">메뉴에서 주문</target>
        </trans-unit>
        <trans-unit id="44a71879f76eef9a972c14aeb610df9bb2a2d7cd" translate="yes" xml:space="preserve">
          <source>Perl: &lt;a href=&quot;https://metacpan.org/release/YAPE-Regex-Explain&quot;&gt;YAPE: Regex Explain&lt;/a&gt;</source>
          <target state="translated">Perl : &lt;a href=&quot;https://metacpan.org/release/YAPE-Regex-Explain&quot;&gt;YAPE : 정규식 설명&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="947c6e8160e2686ffe1464043c63e0d649717e4f" translate="yes" xml:space="preserve">
          <source>Putting some of these blocks together, the pattern &lt;code&gt;[Nn]*ick&lt;/code&gt; matches all of</source>
          <target state="translated">이 블록들 중 일부를 합치면 패턴 &lt;code&gt;[Nn]*ick&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="16dc60b323d79a2f6113da0cf72b1173c59702bf" translate="yes" xml:space="preserve">
          <source>Regex Buddy</source>
          <target state="translated">정규식 버디</target>
        </trans-unit>
        <trans-unit id="b9648927d75753351180b745bd9201dc142cf8bb" translate="yes" xml:space="preserve">
          <source>Regex Cookbook</source>
          <target state="translated">정규식 요리 책</target>
        </trans-unit>
        <trans-unit id="79fd14db3d8dce5771ed8d43cbac1e67ff353684" translate="yes" xml:space="preserve">
          <source>Regex Syntax Summary</source>
          <target state="translated">정규식 구문 요약</target>
        </trans-unit>
        <trans-unit id="d8fee145772e06e3d12eea6ce0cb821cd8678167" translate="yes" xml:space="preserve">
          <source>RegexOne - Learn with simple, interactive exercises.</source>
          <target state="translated">RegexOne-간단한 대화식 연습으로 배우십시오.</target>
        </trans-unit>
        <trans-unit id="c8974ee3c3bc80517e839f83d10737faa707127b" translate="yes" xml:space="preserve">
          <source>Regular Expressions Cheat Sheet</source>
          <target state="translated">정규식 치트 시트</target>
        </trans-unit>
        <trans-unit id="89c14d5368a465f10ef6a24a01a9a7b38da0fc57" translate="yes" xml:space="preserve">
          <source>Regular Expressions Online Tester</source>
          <target state="translated">정규식 온라인 테스터</target>
        </trans-unit>
        <trans-unit id="5699d9c17f85d41638b57e6a204ea26e5d711b98" translate="yes" xml:space="preserve">
          <source>Regular expression quantifiers are greedy. This means they match as much text as they possibly can while allowing the entire pattern to match successfully.</source>
          <target state="translated">정규식 수량자는 탐욕 스럽습니다. 즉, 전체 패턴을 성공적으로 일치시키면서 가능한 한 많은 텍스트를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="68e27e707d3e03f55d0c8a5732979a4ccc2d797c" translate="yes" xml:space="preserve">
          <source>Regular expressions are recursive, so now that you understand these basic rules, you can combine them however you like.</source>
          <target state="translated">정규 표현식은 재귀 적이므로 이제 이러한 기본 규칙을 이해 했으므로 원하는대로 조합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c187c47e14e519d74321d9000d5afb95d07cfdc" translate="yes" xml:space="preserve">
          <source>Regular expressions next to each other match sequences. For example, the pattern &lt;code&gt;Nick&lt;/code&gt; matches the sequence 'N' followed by 'i' followed by 'c' followed by 'k'.</source>
          <target state="translated">서로 옆에있는 정규식은 시퀀스와 일치합니다. 예를 들어, 패턴 &lt;code&gt;Nick&lt;/code&gt; 은 시퀀스 'N'과 'i', 'c'와 'k'가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3555c1a56411b43a7966c37d01ae16f4955f43f9" translate="yes" xml:space="preserve">
          <source>Say you want to match comments of the form</source>
          <target state="translated">양식의 주석과 일치 시키려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="cb45b4e62bf666c532a02287bb4fb02a809b6fc5" translate="yes" xml:space="preserve">
          <source>Start simple</source>
          <target state="translated">간단하게 시작</target>
        </trans-unit>
        <trans-unit id="28aef8f69db620eb498820f0e319209292abdccd" translate="yes" xml:space="preserve">
          <source>Teach Yourself Regular Expressions</source>
          <target state="translated">정규식을 가르쳐라</target>
        </trans-unit>
        <trans-unit id="c845c6000fff99af437a9fc8c2e6f447122a611d" translate="yes" xml:space="preserve">
          <source>The first match demonstrates an important lesson: &lt;em&gt;&lt;code&gt;*&lt;/code&gt; always succeeds!&lt;/em&gt; Any pattern can match zero times.</source>
          <target state="translated">첫 번째 경기는 중요한 교훈을 보여줍니다 : &lt;em&gt; &lt;code&gt;*&lt;/code&gt; 항상 성공합니다!&lt;/em&gt; 모든 패턴은 0 번 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b96fd7359131170ec3910a2c15c093b0604c1e9d" translate="yes" xml:space="preserve">
          <source>The most important part is the concepts. Once you understand how the building blocks work, differences in syntax amount to little more than mild dialects. A layer on top of your regular expression engine's syntax is the syntax of the programming language you're using. Languages such as Perl remove most of this complication, but you'll have to keep in mind other considerations if you're using regular expressions in a C program.</source>
          <target state="translated">가장 중요한 부분은 개념입니다. 빌딩 블록의 작동 방식을 이해하면 구문의 차이는 가벼운 방언에 지나지 않습니다. 정규식 엔진의 구문 위에있는 레이어는 사용중인 프로그래밍 언어의 구문입니다. Perl과 같은 언어는 이러한 복잡한 문제를 대부분 제거하지만 C 프로그램에서 정규식을 사용하는 경우 다른 고려 사항을 명심해야합니다.</target>
        </trans-unit>
        <trans-unit id="22715149bb9c6655ed248fa2ba77fe101f0f5ecb" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;.&lt;/code&gt; is special: rather than matching a literal dot only, it matches &lt;em&gt;any&lt;/em&gt; character&lt;sup&gt;&amp;dagger;&lt;/sup&gt;. It's the same conceptually as the really big character class &lt;code&gt;[-.?+%$A-Za-z0-9...]&lt;/code&gt;.</source>
          <target state="translated">패턴 &lt;code&gt;.&lt;/code&gt; 리터럴 점과 만 일치하는 것이 아니라 &lt;em&gt;모든&lt;/em&gt; 문자 &lt;sup&gt;&amp;dagger;&lt;/sup&gt; 와 일치 &lt;em&gt;합니다&lt;/em&gt; . 실제로 큰 문자 클래스 &lt;code&gt;[-.?+%$A-Za-z0-9...]&lt;/code&gt; 와 개념적으로 같습니다.</target>
        </trans-unit>
        <trans-unit id="91a4d600b807bd4f09976a09959e06274f29ba2d" translate="yes" xml:space="preserve">
          <source>The uppercased variants are their complements, so &lt;code&gt;\S&lt;/code&gt; matches any &lt;em&gt;non&lt;/em&gt;-whitespace character, for example.</source>
          <target state="translated">대문자 변형은 보완이므로 예를 들어 &lt;code&gt;\S&lt;/code&gt; 는 공백이 &lt;em&gt;아닌&lt;/em&gt; 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e293881e27590496ef91a61c6c25643e50a9e297" translate="yes" xml:space="preserve">
          <source>Think of character classes as menus: pick just one.</source>
          <target state="translated">캐릭터 클래스를 메뉴로 생각하십시오. 하나만 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="de4b0e2db7bd3c9c11ac9e377548480b18fc9bf9" translate="yes" xml:space="preserve">
          <source>To match one or more sequences of 'abc' with zeros on the ends, use &lt;code&gt;0(abc)+0&lt;/code&gt;. The parentheses denote a subpattern that can be quantified as a unit. It's also common for regular expression engines to save or &quot;capture&quot; the portion of the input text that matches a parenthesized group. Extracting bits this way is much more flexible and less error-prone than counting indices and &lt;code&gt;substr&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 'abc'시퀀스를 끝에 0과 일치 시키려면 &lt;code&gt;0(abc)+0&lt;/code&gt; . 괄호는 단위로 수량화 할 수있는 하위 패턴을 나타냅니다. 정규식 엔진이 괄호로 묶은 그룹과 일치하는 입력 텍스트 부분을 저장하거나 &quot;캡처&quot;하는 것도 일반적입니다. 이 방법으로 비트를 추출하면 인덱스 및 &lt;code&gt;substr&lt;/code&gt; 을 계산하는 것보다 훨씬 유연하고 오류가 적습니다.</target>
        </trans-unit>
        <trans-unit id="50ddbc5d0277e3c16b73cf8e609473468f17b01c" translate="yes" xml:space="preserve">
          <source>To switch from greedy to what you might think of as cautious, add an extra &lt;code&gt;?&lt;/code&gt; to the quantifier. Now you understand how &lt;code&gt;\((.+?)\)&lt;/code&gt;, the example from your question works. It matches the sequence of a literal left-parenthesis, followed by one or more characters, and terminated by a right-parenthesis.</source>
          <target state="translated">욕심 많은 것에서 조심스럽게 생각할 수있는 것으로 바꾸려면 여분의 &lt;code&gt;?&lt;/code&gt; 수량 자에게. 이제 질문의 예인 &lt;code&gt;\((.+?)\)&lt;/code&gt; 작동하는지 이해했습니다. 리터럴 왼쪽 괄호, 하나 이상의 문자 순서 및 오른쪽 괄호로 끝나는 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="92935cc481013b79cd161911bb7bc552f1ba3812" translate="yes" xml:space="preserve">
          <source>Tools for writing and debugging regexes:</source>
          <target state="translated">정규식 작성 및 디버깅 도구 :</target>
        </trans-unit>
        <trans-unit id="a1fd9141e7da915eb8a8004fe9ab9111acd0635a" translate="yes" xml:space="preserve">
          <source>Txt2RE</source>
          <target state="translated">Txt2RE</target>
        </trans-unit>
        <trans-unit id="fe6d79779c9d27867ff69b0be6ad558feeaa20f7" translate="yes" xml:space="preserve">
          <source>Use the special pattern &lt;code&gt;^&lt;/code&gt; to match only at the beginning of your input and &lt;code&gt;$&lt;/code&gt; to match only at the end. Making &quot;bookends&quot; with your patterns where you say, &quot;I know what's at the front and back, but give me everything between&quot; is a useful technique.</source>
          <target state="translated">특수 패턴 &lt;code&gt;^&lt;/code&gt; 을 사용하여 입력의 시작 부분에만 일치하고 &lt;code&gt;$&lt;/code&gt; 를 사용하여 끝 부분에만 일치시킵니다. &quot;앞뒤에 무엇이 있는지 알고 있지만 그 사이에 모든 것을 알려주십시오.&quot;라고 말하는 패턴으로 &quot;북 엔드&quot;를 만드는 것은 유용한 기술입니다.</target>
        </trans-unit>
        <trans-unit id="37304d600ce0cd62463a50ccd70b1ebda871fa2f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.&lt;/code&gt; can save you lots of typing, and there are other shortcuts for common patterns. Say you want to match a digit: one way to write that is &lt;code&gt;[0-9]&lt;/code&gt;. Digits are a frequent match target, so you could instead use the shortcut &lt;code&gt;\d&lt;/code&gt;. Others are &lt;code&gt;\s&lt;/code&gt; (whitespace) and &lt;code&gt;\w&lt;/code&gt; (word characters: alphanumerics or underscore).</source>
          <target state="translated">사용 &lt;code&gt;.&lt;/code&gt; 타이핑을 많이 절약 할 수 있으며 일반적인 패턴에 대한 다른 바로 가기가 있습니다. 숫자를 맞추고 싶다고 가정 해 봅시다. 한 가지 방법은 &lt;code&gt;[0-9]&lt;/code&gt; 입니다. 숫자는 자주 일치하는 대상이므로 바로 가기 &lt;code&gt;\d&lt;/code&gt; 를 사용할 수 있습니다. 다른 문자는 &lt;code&gt;\s&lt;/code&gt; (공백) 및 &lt;code&gt;\w&lt;/code&gt; (단어 문자 : 영숫자 또는 밑줄)입니다.</target>
        </trans-unit>
        <trans-unit id="526f639bebd48d81d13a90a85f8fd1789e9df34d" translate="yes" xml:space="preserve">
          <source>Visual RegExp</source>
          <target state="translated">비주얼 정규식</target>
        </trans-unit>
        <trans-unit id="75e9f880bd62145e1e31f2d7b936986d0605f73e" translate="yes" xml:space="preserve">
          <source>You might expect &lt;code&gt;&quot;.+&quot;&lt;/code&gt; to match only 'Hello,' and will then be surprised when you see that it matched from 'Hello' all the way through 'you?'.</source>
          <target state="translated">&lt;code&gt;&quot;.+&quot;&lt;/code&gt; 가 'Hello'와만 일치 할 것으로 예상 할 수 있으며 'Hello'에서 'you?'까지 일치하는 것을 볼 때 놀라게됩니다.</target>
        </trans-unit>
        <trans-unit id="a2b8abe4260aad959411d4203bb668f167991d6a" translate="yes" xml:space="preserve">
          <source>ick</source>
          <target state="translated">ick</target>
        </trans-unit>
        <trans-unit id="fc15a9dd34ddc23b9aff22adce8b09526d7b078c" translate="yes" xml:space="preserve">
          <source>nNick</source>
          <target state="translated">nNick</target>
        </trans-unit>
        <trans-unit id="75ef9faee755c70589550b513ad881e5a603182c" translate="yes" xml:space="preserve">
          <source>nick</source>
          <target state="translated">nick</target>
        </trans-unit>
        <trans-unit id="98cb5605f45e16baa3327dd0dd78f00ec9cc4b36" translate="yes" xml:space="preserve">
          <source>nnick</source>
          <target state="translated">nnick</target>
        </trans-unit>
        <trans-unit id="35b888ad74eacdebe041626f388c5c12bae6bfda" translate="yes" xml:space="preserve">
          <source>you'd write &lt;code&gt;^--\s+(.+)\s+--$&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;^--\s+(.+)\s+--$&lt;/code&gt; 쓸 것입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
