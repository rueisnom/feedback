<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/4736">
    <body>
      <group id="4736">
        <trans-unit id="8c342e8585fceeee466cfc575e45384b0da85bd4" translate="yes" xml:space="preserve">
          <source>&quot;Hello,&quot; she said, &quot;How are you?&quot;</source>
          <target state="translated">&quot;こんにちは &quot;と言って、&quot;お元気ですか?&quot;と声をかけてくれました。</target>
        </trans-unit>
        <trans-unit id="33005ca44ed78f77c7fadc5a196abf1256960301" translate="yes" xml:space="preserve">
          <source>(As to your confusion, I don't know of any regular-expression dialect where &lt;code&gt;((.+?))&lt;/code&gt; would do the same thing. I suspect something got lost in transmission somewhere along the way.)</source>
          <target state="translated">（あなたの混乱に関して、 &lt;code&gt;((.+?))&lt;/code&gt; が同じことをする正規表現の方言は知りません。途中でどこかで送信で何かが失われたのではないかと思います。）</target>
        </trans-unit>
        <trans-unit id="4ef24db075ab7963455bfe3ea7654428474ef88d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://neverfear.org/blog/view/Regex_tutorial_for_people_who_should_know_Regex__but_do_not___Part_1&quot;&gt;Regular Expressions - Everything you should know&lt;/a&gt; (PDF Series)</source>
          <target state="translated">&lt;a href=&quot;http://neverfear.org/blog/view/Regex_tutorial_for_people_who_should_know_Regex__but_do_not___Part_1&quot;&gt;正規表現-知っておくべきことすべて&lt;/a&gt; （PDFシリーズ）</target>
        </trans-unit>
        <trans-unit id="4c618840a436ae1359f6b753fc7b297f01d3edc4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;Mastering Regular Expressions&lt;/a&gt;, the &lt;a href=&quot;http://oreilly.com/catalog/9780596002893&quot;&gt;2nd Edition&lt;/a&gt;, and the &lt;a href=&quot;http://shop.oreilly.com/product/9780596528126.do&quot;&gt;3rd edition&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;正規表現の習得&lt;/a&gt; 、 &lt;a href=&quot;http://oreilly.com/catalog/9780596002893&quot;&gt;第2版&lt;/a&gt; 、および第&lt;a href=&quot;http://shop.oreilly.com/product/9780596528126.do&quot;&gt;3版&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a78dcd68ae6f3277cb0e045417feb90a498d6dd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://regexlib.com/Default.aspx&quot;&gt;Regular Expression Library&lt;/a&gt; (Predefined Regexes for common scenarios)</source>
          <target state="translated">&lt;a href=&quot;http://regexlib.com/Default.aspx&quot;&gt;正規表現ライブラリ&lt;/a&gt; （一般的なシナリオの定義済み正規表現 ）</target>
        </trans-unit>
        <trans-unit id="52ba4e284aa4c3ef639e8a8eb43c76f0d2dd305d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://regexstorm.net/&quot;&gt;Regex Storm&lt;/a&gt; (for .NET)</source>
          <target state="translated">&lt;a href=&quot;http://regexstorm.net/&quot;&gt;正規表現ストーム&lt;/a&gt; （.NET用）</target>
        </trans-unit>
        <trans-unit id="c399644d59ada43490f6ffcfa767c8ffa88aaf34" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weitz.de/regex-coach/&quot;&gt;Regex Coach&lt;/a&gt; (engine backed by &lt;a href=&quot;https://edicl.github.io/cl-ppcre/&quot;&gt;CL-PPCRE&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://edicl.github.io/cl-ppcre/&quot;&gt;正規表現&lt;/a&gt; &lt;a href=&quot;http://weitz.de/regex-coach/&quot;&gt;コーチ&lt;/a&gt; （ CL-PPCREによってサポートされるエンジン）</target>
        </trans-unit>
        <trans-unit id="37fbb3c67041c88bb5fb2ee7d0ea73da5aca34b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;Expresso&lt;/a&gt; (for .NET)</source>
          <target state="translated">&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;Expresso&lt;/a&gt; （.NET用）</target>
        </trans-unit>
        <trans-unit id="5091e76616eb92b95cb38de4c129f9453eee45c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regex101.com/&quot;&gt;Regex 101&lt;/a&gt; (for PCRE, JavaScript, Python, Golang)</source>
          <target state="translated">&lt;a href=&quot;https://regex101.com/&quot;&gt;Regex 101&lt;/a&gt; （PCRE、JavaScript、Python、Golang用）</target>
        </trans-unit>
        <trans-unit id="0219e5502b55fbd56d948d75b0b9d635ece58d47" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regexr.com/&quot;&gt;RegExr&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://regexr.com/&quot;&gt;RegExr&lt;/a&gt; （JavaScript用）</target>
        </trans-unit>
        <trans-unit id="88542bbf29e8bb29a91e15cec896ae72f5da8770" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://rubular.com/&quot;&gt;Rubular&lt;/a&gt; (for Ruby)</source>
          <target state="translated">&lt;a href=&quot;https://rubular.com/&quot;&gt;Rubular&lt;/a&gt; （Ruby用）</target>
        </trans-unit>
        <trans-unit id="2307de32b2e7372a804ec97e3ca567c35d03bd92" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.debuggex.com/&quot;&gt;Debuggex&lt;/a&gt; (visual regex tester and helper)</source>
          <target state="translated">&lt;a href=&quot;https://www.debuggex.com/&quot;&gt;Debuggex&lt;/a&gt; （ビジュアル正規表現テスターおよびヘルパー）</target>
        </trans-unit>
        <trans-unit id="b671ff66076869497a948d0bf95f5fc2b9e40299" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.regexpal.com/&quot;&gt;RegexPal&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://www.regexpal.com/&quot;&gt;RegexPal&lt;/a&gt; （JavaScript用）</target>
        </trans-unit>
        <trans-unit id="9cb9a6ab932dceec9ffe65247bc3cccfda5da286" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.regextester.com/&quot;&gt;Regex Tester&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://www.regextester.com/&quot;&gt;正規表現テスター&lt;/a&gt; （JavaScript用）</target>
        </trans-unit>
        <trans-unit id="eeb0890b8bae80c63e782001363779e5dd6a4cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; (zero or more times)</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; （ゼロ回以上）</target>
        </trans-unit>
        <trans-unit id="68e7787028c0f8e5c7cb1974a6a29b105ad2afb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; (one or more times)</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; （1回以上）</target>
        </trans-unit>
        <trans-unit id="4078b42459a3d9c1d9e1e9ea095ffdfc0773bc68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[0-9]+&lt;/code&gt; (and its equivalent &lt;code&gt;\d+&lt;/code&gt;) matches any non-negative integer</source>
          <target state="translated">&lt;code&gt;[0-9]+&lt;/code&gt; （およびそれに相当する &lt;code&gt;\d+&lt;/code&gt; ）は、負でない整数に一致します</target>
        </trans-unit>
        <trans-unit id="c29c5736875d33c09abed9a6b02279da10095e0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt; matches dates formatted like 2019-01-01</source>
          <target state="translated">&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt; は、2019-01-01のような形式の日付に一致します</target>
        </trans-unit>
        <trans-unit id="b251d9b6ea61001d2d2aa44d156af068b0ca092e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,m}&lt;/code&gt; (at least &lt;em&gt;n&lt;/em&gt; times but no more than &lt;em&gt;m&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n,m}&lt;/code&gt; （少なくとも&lt;em&gt;n&lt;/em&gt;回、 &lt;em&gt;m&lt;/em&gt;回以下）</target>
        </trans-unit>
        <trans-unit id="ef799869d678028f74953d5c3755452d618be643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,}&lt;/code&gt; (at least &lt;em&gt;n&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n,}&lt;/code&gt; （少なくとも&lt;em&gt;n&lt;/em&gt;回）</target>
        </trans-unit>
        <trans-unit id="8ea261c3e08a435014c07c930a9339279f834530" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n}&lt;/code&gt; (exactly &lt;em&gt;n&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n}&lt;/code&gt; （正確に&lt;em&gt;n&lt;/em&gt;回）</target>
        </trans-unit>
        <trans-unit id="ebf2b2b20b1e034d96b759673425d9a2e451a754" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(and so on)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（等々）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dab55287a0c775bf4cd951c49b0ac8dfa0b7f22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;dagger;:&lt;/strong&gt; The statement above that &lt;code&gt;.&lt;/code&gt; matches any character is a simplification for pedagogical purposes that is not strictly true. Dot matches any character except newline, &lt;code&gt;&quot;\n&quot;&lt;/code&gt;, but in practice you rarely expect a pattern such as &lt;code&gt;.+&lt;/code&gt; to cross a newline boundary. Perl regexes have a &lt;a href=&quot;https://perldoc.perl.org/perlre.html#s&quot;&gt;&lt;code&gt;/s&lt;/code&gt; switch&lt;/a&gt; and Java &lt;a href=&quot;https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html#DOTALL&quot;&gt;&lt;code&gt;Pattern.DOTALL&lt;/code&gt;&lt;/a&gt;, for example, to make &lt;code&gt;.&lt;/code&gt; match any character at all. For languages that don't have such a feature, you can use something like &lt;code&gt;[\s\S]&lt;/code&gt; to match &quot;any whitespace or any non-whitespace&quot;, in other words anything.</source>
          <target state="translated">&lt;strong&gt;&amp;dagger;：&lt;/strong&gt;その上のステートメント &lt;code&gt;.&lt;/code&gt; 任意の文字に一致することは、厳密には真実ではない、教育目的のための単純化です。 ドットは改行 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 以外の任意の文字に一致しますが、実際には、 &lt;code&gt;.+&lt;/code&gt; などのパターンが改行の境界を越えることはほとんどありません。 Perl正規表現には、たとえば&lt;a href=&quot;https://perldoc.perl.org/perlre.html#s&quot;&gt; &lt;code&gt;/s&lt;/code&gt; スイッチ&lt;/a&gt;とJava &lt;a href=&quot;https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html#DOTALL&quot;&gt; &lt;code&gt;Pattern.DOTALL&lt;/code&gt; が&lt;/a&gt;あります &lt;code&gt;.&lt;/code&gt; すべての文字に一致します。 そのような機能を持たない言語の場合、 &lt;code&gt;[\s\S]&lt;/code&gt; ようなものを使用して、「任意の空白または非空白」、つまり何でも一致させることができます。</target>
        </trans-unit>
        <trans-unit id="e4616c92589ed8e68a1ebbf03782fde32acb593f" translate="yes" xml:space="preserve">
          <source>A few other useful examples:</source>
          <target state="translated">他にもいくつかの便利な例があります。</target>
        </trans-unit>
        <trans-unit id="9698c2a9402dd87d80e8df20e87b7752186b2fba" translate="yes" xml:space="preserve">
          <source>A quantifier modifies the pattern to its immediate left. You might expect &lt;code&gt;0abc+0&lt;/code&gt; to match '0abc0', '0abcabc0', and so forth, but the pattern &lt;em&gt;immediately&lt;/em&gt; to the left of the plus quantifier is &lt;code&gt;c&lt;/code&gt;. This means &lt;code&gt;0abc+0&lt;/code&gt; matches '0abc0', '0abcc0', '0abccc0', and so on.</source>
          <target state="translated">量指定子は、パターンをすぐ左に変更します。 &lt;code&gt;0abc+0&lt;/code&gt; が「0abc0」、「0abcabc0」などと一致すると予想される場合がありますが、プラスの量指定子の&lt;em&gt;すぐ&lt;/em&gt;左側のパターンは &lt;code&gt;c&lt;/code&gt; です。 つまり、 &lt;code&gt;0abc+0&lt;/code&gt; は 「0abc0」、「0abcc0」、「0abccc0」などと一致します。</target>
        </trans-unit>
        <trans-unit id="c2eec20b60545f98a44bd16ad8a4e0cd3a89a41a" translate="yes" xml:space="preserve">
          <source>Adding just a little complexity, you can match either 'Nick' or 'nick' with the pattern &lt;code&gt;[Nn]ick&lt;/code&gt;. The part in square brackets is a &lt;em&gt;character class&lt;/em&gt;, which means it matches exactly one of the enclosed characters. You can also use ranges in character classes, so &lt;code&gt;[a-c]&lt;/code&gt; matches either 'a' or 'b' or 'c'.</source>
          <target state="translated">少しだけ複雑さを追加して、「ニック」または「ニック」をパターン &lt;code&gt;[Nn]ick&lt;/code&gt; と一致させることができます。 角括弧で囲まれた部分は&lt;em&gt;文字クラス&lt;/em&gt;です。つまり、囲まれた文字の1つと完全に一致します。 文字クラスで範囲を使用することもできるため、 &lt;code&gt;[a-c]&lt;/code&gt; は「a」、「b」、または「c」のいずれかに一致します。</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="83d719739c59379bf19d989792e9ec8998993c2d" translate="yes" xml:space="preserve">
          <source>Although some characters match themselves, others have special meanings. The pattern &lt;code&gt;\d+&lt;/code&gt; doesn't match backslash followed by lowercase D followed by a plus sign: to get that, we'd use &lt;code&gt;\\d\+&lt;/code&gt;. A backslash removes the special meaning from the following character.</source>
          <target state="translated">一致する文字もあれば、特別な意味を持つ文字もあります。 パターン &lt;code&gt;\d+&lt;/code&gt; は、バックスラッシュの後に小文字のDの後に正符号が続くものと一致しません。これを取得するには、 &lt;code&gt;\\d\+&lt;/code&gt; 使用します。 バックスラッシュは、次の文字から特別な意味を取り除きます。</target>
        </trans-unit>
        <trans-unit id="a307a637b89fe16e9922778e99bea2ed2e8e496b" translate="yes" xml:space="preserve">
          <source>Anchors</source>
          <target state="translated">Anchors</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="f20b35258323d6253263d376f19f1859ea7fa62f" translate="yes" xml:space="preserve">
          <source>Build your own</source>
          <target state="translated">自分自身を構築する</target>
        </trans-unit>
        <trans-unit id="1d333bcb58941bfd7a3fb8cda029220d5a88e47f" translate="yes" xml:space="preserve">
          <source>Conceptually, the simplest regular expressions are literal characters. The pattern &lt;code&gt;N&lt;/code&gt; matches the character 'N'.</source>
          <target state="translated">概念的には、最も単純な正規表現はリテラル文字です。 パターン &lt;code&gt;N&lt;/code&gt; は文字「N」と一致します。</target>
        </trans-unit>
        <trans-unit id="fabc21bb541d3248d6745e3a4b9e442f9a030f7d" translate="yes" xml:space="preserve">
          <source>Earlier, we saw one way to match either 'Nick' or 'nick'. Another is with alternation as in &lt;code&gt;Nick|nick&lt;/code&gt;. Remember that alternation includes everything to its left and everything to its right. Use grouping parentheses to limit the scope of &lt;code&gt;|&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;(Nick|nick)&lt;/code&gt;.</source>
          <target state="translated">以前、「ニック」または「ニック」のいずれかと一致する1つの方法を見ました。 もう1つは &lt;code&gt;Nick|nick&lt;/code&gt; ように交互に使用する方法です。 交替には、左側のすべてと右側のすべてが含まれることを覚えておいてください。 &lt;code&gt;|&lt;/code&gt; の範囲を制限するには、グループ化括弧を使用します。 、 &lt;em&gt;たとえば&lt;/em&gt; &lt;code&gt;(Nick|nick)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2779ea444cb47200f1b0085d04662b33c09fc23f" translate="yes" xml:space="preserve">
          <source>Escaping</source>
          <target state="translated">Escaping</target>
        </trans-unit>
        <trans-unit id="40e31a210a1913fd0a8b28b892780996d154c70d" translate="yes" xml:space="preserve">
          <source>Footnote</source>
          <target state="translated">Footnote</target>
        </trans-unit>
        <trans-unit id="4cd395750596fc63879f88a287d8880fa0e85e60" translate="yes" xml:space="preserve">
          <source>For another example, you could equivalently write &lt;code&gt;[a-c]&lt;/code&gt; as &lt;code&gt;a|b|c&lt;/code&gt;, but this is likely to be suboptimal because many implementations assume alternatives will have lengths greater than 1.</source>
          <target state="translated">別の例として、 &lt;code&gt;[a-c]&lt;/code&gt; を &lt;code&gt;a|b|c&lt;/code&gt; と同等に書くこともできますが、多くの実装では代替が1より大きい長さであると想定しているため、これは最適ではない可能性があります。</target>
        </trans-unit>
        <trans-unit id="1afa4f2a09ae6c3e5a9c146d9e129073c4f2e82e" translate="yes" xml:space="preserve">
          <source>For example, say the input is</source>
          <target state="translated">例えば、入力が</target>
        </trans-unit>
        <trans-unit id="8dd341228f5203334a2dbe18a099fd9cdb246553" translate="yes" xml:space="preserve">
          <source>Free resources</source>
          <target state="translated">無料のリソース</target>
        </trans-unit>
        <trans-unit id="8b058c9ddbb5e235a3b17a4d130bb8609fba9734" translate="yes" xml:space="preserve">
          <source>From there, you can repeat parts of your pattern with &lt;em&gt;quantifiers&lt;/em&gt;. For example, the pattern &lt;code&gt;ab?c&lt;/code&gt; matches 'abc' or 'ac' because the &lt;code&gt;?&lt;/code&gt; quantifier makes the subpattern it modifies optional. Other quantifiers are</source>
          <target state="translated">そこから、 &lt;em&gt;数量詞&lt;/em&gt;を使用してパターンの一部を繰り返すことができます。 たとえば、パターン &lt;code&gt;ab?c&lt;/code&gt; は 「abc」または「ac」と一致し &lt;code&gt;?&lt;/code&gt; 量指定子は、変更するサブパターンをオプションにします。 他の数量詞は</target>
        </trans-unit>
        <trans-unit id="59985b76bfac61da62ef1b2c39db3443c181b381" translate="yes" xml:space="preserve">
          <source>Greediness</source>
          <target state="translated">Greediness</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="f646cf743adf4a08fb6e1b26f378b70f117af712" translate="yes" xml:space="preserve">
          <source>Helpful shortcuts</source>
          <target state="translated">便利なショートカット</target>
        </trans-unit>
        <trans-unit id="9356b9688cab55bd64e84c0c92cc854e57b999b4" translate="yes" xml:space="preserve">
          <source>How Regexes Work</source>
          <target state="translated">正規表現の仕組み</target>
        </trans-unit>
        <trans-unit id="a5370c7d8ba341173df1c3b84ffdbdf6a7833cfc" translate="yes" xml:space="preserve">
          <source>I don't really understand regular expressions.  Can you explain them to me in an easy-to-follow manner?  If there are any online tools or books, could you also link to them?</source>
          <target state="translated">正規表現がよくわかりません。わかりやすく説明してもらえますか?また、オンラインツールや書籍があれば、それらへのリンクもお願いします。</target>
        </trans-unit>
        <trans-unit id="530b1c010c952dc47e7ccad7a66d94ff2c275a0e" translate="yes" xml:space="preserve">
          <source>If you think of regular expressions as building blocks that you can mix and match as you please, it helps you learn how to write and debug your own patterns but also how to understand patterns written by others.</source>
          <target state="translated">正規表現を自分の好きなように混ぜ合わせて使えるビルディングブロックと考えれば、自分のパターンの書き方やデバッグの仕方だけでなく、他の人が書いたパターンを理解する方法を学ぶことができます。</target>
        </trans-unit>
        <trans-unit id="46b79bd52027013bd53543e10582ce6baeead7a2" translate="yes" xml:space="preserve">
          <source>If you've ever used &lt;code&gt;grep&lt;/code&gt; on Unix&amp;mdash;even if only to search for ordinary looking strings&amp;mdash;you've already been using regular expressions! (The &lt;code&gt;re&lt;/code&gt; in &lt;code&gt;grep&lt;/code&gt; refers to regular expressions.)</source>
          <target state="translated">Unixで &lt;code&gt;grep&lt;/code&gt; を使用したことがある場合-普通に見える文字列を検索するだけの場合でも-すでに正規表現を使用しています。 （ &lt;code&gt;grep&lt;/code&gt; の &lt;code&gt;re&lt;/code&gt; は正規表現を指します。）</target>
        </trans-unit>
        <trans-unit id="3f48e3ea7a67593afc624d898633d8bcfd4d221e" translate="yes" xml:space="preserve">
          <source>If your input is '(123) (456)', then the first capture will be '123'. Non-greedy quantifiers want to allow the rest of the pattern to start matching as soon as possible.</source>
          <target state="translated">入力が '(123)(456)' の場合、最初のキャプチャは '123' になります。非greedyな量詞は、パターンの残りの部分ができるだけ早くマッチングを開始できるようにしたいのです。</target>
        </trans-unit>
        <trans-unit id="feecfcff81cdfac79c1169c68bcdf3298543a39e" translate="yes" xml:space="preserve">
          <source>Learning Regular Expressions</source>
          <target state="translated">正規表現の学習</target>
        </trans-unit>
        <trans-unit id="54274c1b66e4db9103a52754b9f88c07567bd846" translate="yes" xml:space="preserve">
          <source>Nick</source>
          <target state="translated">Nick</target>
        </trans-unit>
        <trans-unit id="c659a1a4add3674e46b01f5c3aed16066f609fba" translate="yes" xml:space="preserve">
          <source>Nnick</source>
          <target state="translated">Nnick</target>
        </trans-unit>
        <trans-unit id="849e6a4431d3bc9b7fd03e9363f4f10c14117c82" translate="yes" xml:space="preserve">
          <source>Once is not enough</source>
          <target state="translated">一度では足りない</target>
        </trans-unit>
        <trans-unit id="82eb240ece12cf01f54324b6e46ee819e866dd8b" translate="yes" xml:space="preserve">
          <source>Order from the menu</source>
          <target state="translated">メニューからのご注文</target>
        </trans-unit>
        <trans-unit id="44a71879f76eef9a972c14aeb610df9bb2a2d7cd" translate="yes" xml:space="preserve">
          <source>Perl: &lt;a href=&quot;https://metacpan.org/release/YAPE-Regex-Explain&quot;&gt;YAPE: Regex Explain&lt;/a&gt;</source>
          <target state="translated">Perl： &lt;a href=&quot;https://metacpan.org/release/YAPE-Regex-Explain&quot;&gt;YAPE&lt;/a&gt; ： 正規表現の説明</target>
        </trans-unit>
        <trans-unit id="947c6e8160e2686ffe1464043c63e0d649717e4f" translate="yes" xml:space="preserve">
          <source>Putting some of these blocks together, the pattern &lt;code&gt;[Nn]*ick&lt;/code&gt; matches all of</source>
          <target state="translated">これらのブロックのいくつかを &lt;code&gt;[Nn]*ick&lt;/code&gt; と、パターン[Nn] * ickはすべてに一致します</target>
        </trans-unit>
        <trans-unit id="16dc60b323d79a2f6113da0cf72b1173c59702bf" translate="yes" xml:space="preserve">
          <source>Regex Buddy</source>
          <target state="translated">正規表現バディ</target>
        </trans-unit>
        <trans-unit id="b9648927d75753351180b745bd9201dc142cf8bb" translate="yes" xml:space="preserve">
          <source>Regex Cookbook</source>
          <target state="translated">正規表現クックブック</target>
        </trans-unit>
        <trans-unit id="79fd14db3d8dce5771ed8d43cbac1e67ff353684" translate="yes" xml:space="preserve">
          <source>Regex Syntax Summary</source>
          <target state="translated">正規表現構文の概要</target>
        </trans-unit>
        <trans-unit id="d8fee145772e06e3d12eea6ce0cb821cd8678167" translate="yes" xml:space="preserve">
          <source>RegexOne - Learn with simple, interactive exercises.</source>
          <target state="translated">RegexOne-シンプルでインタラクティブな演習で学ぶ。</target>
        </trans-unit>
        <trans-unit id="c8974ee3c3bc80517e839f83d10737faa707127b" translate="yes" xml:space="preserve">
          <source>Regular Expressions Cheat Sheet</source>
          <target state="translated">正規表現チートシート</target>
        </trans-unit>
        <trans-unit id="89c14d5368a465f10ef6a24a01a9a7b38da0fc57" translate="yes" xml:space="preserve">
          <source>Regular Expressions Online Tester</source>
          <target state="translated">正規表現オンラインテスター</target>
        </trans-unit>
        <trans-unit id="5699d9c17f85d41638b57e6a204ea26e5d711b98" translate="yes" xml:space="preserve">
          <source>Regular expression quantifiers are greedy. This means they match as much text as they possibly can while allowing the entire pattern to match successfully.</source>
          <target state="translated">正規表現の量詞は貪欲です。これは、可能な限り多くのテキストにマッチする一方で、パターン全体が正常にマッチするようにすることを意味します。</target>
        </trans-unit>
        <trans-unit id="68e27e707d3e03f55d0c8a5732979a4ccc2d797c" translate="yes" xml:space="preserve">
          <source>Regular expressions are recursive, so now that you understand these basic rules, you can combine them however you like.</source>
          <target state="translated">正規表現は再帰的なものなので、これらの基本的なルールを理解した上で、好きなように組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="6c187c47e14e519d74321d9000d5afb95d07cfdc" translate="yes" xml:space="preserve">
          <source>Regular expressions next to each other match sequences. For example, the pattern &lt;code&gt;Nick&lt;/code&gt; matches the sequence 'N' followed by 'i' followed by 'c' followed by 'k'.</source>
          <target state="translated">隣り合う正規表現はシーケンスを照合します。 たとえば、パターン &lt;code&gt;Nick&lt;/code&gt; は、シーケンス「N」、「i」、「c」、「k」の順に一致します。</target>
        </trans-unit>
        <trans-unit id="3555c1a56411b43a7966c37d01ae16f4955f43f9" translate="yes" xml:space="preserve">
          <source>Say you want to match comments of the form</source>
          <target state="translated">フォームのコメントを一致させたいとします。</target>
        </trans-unit>
        <trans-unit id="cb45b4e62bf666c532a02287bb4fb02a809b6fc5" translate="yes" xml:space="preserve">
          <source>Start simple</source>
          <target state="translated">シンプルなスタート</target>
        </trans-unit>
        <trans-unit id="28aef8f69db620eb498820f0e319209292abdccd" translate="yes" xml:space="preserve">
          <source>Teach Yourself Regular Expressions</source>
          <target state="translated">正規表現を自分に教える</target>
        </trans-unit>
        <trans-unit id="c845c6000fff99af437a9fc8c2e6f447122a611d" translate="yes" xml:space="preserve">
          <source>The first match demonstrates an important lesson: &lt;em&gt;&lt;code&gt;*&lt;/code&gt; always succeeds!&lt;/em&gt; Any pattern can match zero times.</source>
          <target state="translated">最初の試合は重要な教訓を示しています： &lt;em&gt; &lt;code&gt;*&lt;/code&gt; 常に成功します！&lt;/em&gt; どのパターンもゼロ回一致できます。</target>
        </trans-unit>
        <trans-unit id="b96fd7359131170ec3910a2c15c093b0604c1e9d" translate="yes" xml:space="preserve">
          <source>The most important part is the concepts. Once you understand how the building blocks work, differences in syntax amount to little more than mild dialects. A layer on top of your regular expression engine's syntax is the syntax of the programming language you're using. Languages such as Perl remove most of this complication, but you'll have to keep in mind other considerations if you're using regular expressions in a C program.</source>
          <target state="translated">最も重要なのは概念です。構成要素がどのように機能するかを理解してしまえば、構文の違いは軽度の方言に過ぎません。正規表現エンジンの構文の上には、使用しているプログラミング言語の構文があります。Perl のような言語はこの複雑さのほとんどを取り除きますが、C プログラムで正規表現を使用している場合は、他の考慮事項を念頭に置いておく必要があります。</target>
        </trans-unit>
        <trans-unit id="22715149bb9c6655ed248fa2ba77fe101f0f5ecb" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;.&lt;/code&gt; is special: rather than matching a literal dot only, it matches &lt;em&gt;any&lt;/em&gt; character&lt;sup&gt;&amp;dagger;&lt;/sup&gt;. It's the same conceptually as the really big character class &lt;code&gt;[-.?+%$A-Za-z0-9...]&lt;/code&gt;.</source>
          <target state="translated">パターン &lt;code&gt;.&lt;/code&gt; 特殊です。リテラルのドットのみではなく、 &lt;em&gt;任意の&lt;/em&gt;文字&lt;sup&gt;&amp;dagger;&lt;/sup&gt;に一致し&lt;em&gt;ます&lt;/em&gt; 。 概念的には、本当に大きな文字クラス &lt;code&gt;[-.?+%$A-Za-z0-9...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91a4d600b807bd4f09976a09959e06274f29ba2d" translate="yes" xml:space="preserve">
          <source>The uppercased variants are their complements, so &lt;code&gt;\S&lt;/code&gt; matches any &lt;em&gt;non&lt;/em&gt;-whitespace character, for example.</source>
          <target state="translated">大文字のバリアントはそれらの補数であるため、たとえば &lt;code&gt;\S&lt;/code&gt; 空白文字&lt;em&gt;以外の&lt;/em&gt;文字と一致します。</target>
        </trans-unit>
        <trans-unit id="e293881e27590496ef91a61c6c25643e50a9e297" translate="yes" xml:space="preserve">
          <source>Think of character classes as menus: pick just one.</source>
          <target state="translated">キャラクタークラスをメニューとして考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="de4b0e2db7bd3c9c11ac9e377548480b18fc9bf9" translate="yes" xml:space="preserve">
          <source>To match one or more sequences of 'abc' with zeros on the ends, use &lt;code&gt;0(abc)+0&lt;/code&gt;. The parentheses denote a subpattern that can be quantified as a unit. It's also common for regular expression engines to save or &quot;capture&quot; the portion of the input text that matches a parenthesized group. Extracting bits this way is much more flexible and less error-prone than counting indices and &lt;code&gt;substr&lt;/code&gt;.</source>
          <target state="translated">「abc」の1つ以上のシーケンスを両端のゼロと照合するには、 &lt;code&gt;0(abc)+0&lt;/code&gt; を使用します。 括弧は、単位として数量化できるサブパターンを示します。 正規表現エンジンでは、括弧で囲まれたグループに一致する入力テキストの部分を保存または「キャプチャ」することもよくあります。 この方法でビットを抽出すると、インデックスや &lt;code&gt;substr&lt;/code&gt; をカウントするよりもはるかに柔軟で、エラーが発生しにくくなります 。</target>
        </trans-unit>
        <trans-unit id="50ddbc5d0277e3c16b73cf8e609473468f17b01c" translate="yes" xml:space="preserve">
          <source>To switch from greedy to what you might think of as cautious, add an extra &lt;code&gt;?&lt;/code&gt; to the quantifier. Now you understand how &lt;code&gt;\((.+?)\)&lt;/code&gt;, the example from your question works. It matches the sequence of a literal left-parenthesis, followed by one or more characters, and terminated by a right-parenthesis.</source>
          <target state="translated">貪欲から慎重と思われるものに切り替えるには、追加し &lt;code&gt;?&lt;/code&gt; 数量詞に。 これで、質問の例である &lt;code&gt;\((.+?)\)&lt;/code&gt; どのように機能するかを理解できました。 これは、リテラルの左括弧の後に1つ以上の文字が続き、右括弧で終了するシーケンスと一致します。</target>
        </trans-unit>
        <trans-unit id="92935cc481013b79cd161911bb7bc552f1ba3812" translate="yes" xml:space="preserve">
          <source>Tools for writing and debugging regexes:</source>
          <target state="translated">正規表現を書いたりデバッグしたりするためのツール。</target>
        </trans-unit>
        <trans-unit id="a1fd9141e7da915eb8a8004fe9ab9111acd0635a" translate="yes" xml:space="preserve">
          <source>Txt2RE</source>
          <target state="translated">Txt2RE</target>
        </trans-unit>
        <trans-unit id="fe6d79779c9d27867ff69b0be6ad558feeaa20f7" translate="yes" xml:space="preserve">
          <source>Use the special pattern &lt;code&gt;^&lt;/code&gt; to match only at the beginning of your input and &lt;code&gt;$&lt;/code&gt; to match only at the end. Making &quot;bookends&quot; with your patterns where you say, &quot;I know what's at the front and back, but give me everything between&quot; is a useful technique.</source>
          <target state="translated">特別なパターン &lt;code&gt;^&lt;/code&gt; を使用して、入力の最初のみを照合し、 &lt;code&gt;$&lt;/code&gt; を最後のみを照合します。 「表と裏に何があるかわかっているが、その間にすべてがある」と言うパターンで「ブックエンド」を作成することは、便利なテクニックです。</target>
        </trans-unit>
        <trans-unit id="37304d600ce0cd62463a50ccd70b1ebda871fa2f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.&lt;/code&gt; can save you lots of typing, and there are other shortcuts for common patterns. Say you want to match a digit: one way to write that is &lt;code&gt;[0-9]&lt;/code&gt;. Digits are a frequent match target, so you could instead use the shortcut &lt;code&gt;\d&lt;/code&gt;. Others are &lt;code&gt;\s&lt;/code&gt; (whitespace) and &lt;code&gt;\w&lt;/code&gt; (word characters: alphanumerics or underscore).</source>
          <target state="translated">を使用し &lt;code&gt;.&lt;/code&gt; タイピングの手間を省くことができ、一般的なパターンには他にもショートカットがあります。 数字と一致させたいとしましょう。それを書く1つの方法は &lt;code&gt;[0-9]&lt;/code&gt; です。 数字は頻繁に一致するターゲットであるため、代わりにショートカット &lt;code&gt;\d&lt;/code&gt; 使用できます。 その他は、 &lt;code&gt;\s&lt;/code&gt; （空白）と &lt;code&gt;\w&lt;/code&gt; （単語文字：英数字またはアンダースコア）です。</target>
        </trans-unit>
        <trans-unit id="526f639bebd48d81d13a90a85f8fd1789e9df34d" translate="yes" xml:space="preserve">
          <source>Visual RegExp</source>
          <target state="translated">ビジュアルRegExp</target>
        </trans-unit>
        <trans-unit id="75e9f880bd62145e1e31f2d7b936986d0605f73e" translate="yes" xml:space="preserve">
          <source>You might expect &lt;code&gt;&quot;.+&quot;&lt;/code&gt; to match only 'Hello,' and will then be surprised when you see that it matched from 'Hello' all the way through 'you?'.</source>
          <target state="translated">&lt;code&gt;&quot;.+&quot;&lt;/code&gt; は「こんにちは」だけに一致することを期待するかもしれませんが、「こんにちは」から「あなた？」までずっと一致したことがわかると驚かれることでしょう。</target>
        </trans-unit>
        <trans-unit id="a2b8abe4260aad959411d4203bb668f167991d6a" translate="yes" xml:space="preserve">
          <source>ick</source>
          <target state="translated">ick</target>
        </trans-unit>
        <trans-unit id="fc15a9dd34ddc23b9aff22adce8b09526d7b078c" translate="yes" xml:space="preserve">
          <source>nNick</source>
          <target state="translated">nNick</target>
        </trans-unit>
        <trans-unit id="75ef9faee755c70589550b513ad881e5a603182c" translate="yes" xml:space="preserve">
          <source>nick</source>
          <target state="translated">nick</target>
        </trans-unit>
        <trans-unit id="98cb5605f45e16baa3327dd0dd78f00ec9cc4b36" translate="yes" xml:space="preserve">
          <source>nnick</source>
          <target state="translated">nnick</target>
        </trans-unit>
        <trans-unit id="35b888ad74eacdebe041626f388c5c12bae6bfda" translate="yes" xml:space="preserve">
          <source>you'd write &lt;code&gt;^--\s+(.+)\s+--$&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;^--\s+(.+)\s+--$&lt;/code&gt; と書きます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
