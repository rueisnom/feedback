<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4736">
    <body>
      <group id="4736">
        <trans-unit id="8c342e8585fceeee466cfc575e45384b0da85bd4" translate="yes" xml:space="preserve">
          <source>&quot;Hello,&quot; she said, &quot;How are you?&quot;</source>
          <target state="translated">&quot;你好,&quot;她说,&quot;你好吗?&quot;</target>
        </trans-unit>
        <trans-unit id="33005ca44ed78f77c7fadc5a196abf1256960301" translate="yes" xml:space="preserve">
          <source>(As to your confusion, I don't know of any regular-expression dialect where &lt;code&gt;((.+?))&lt;/code&gt; would do the same thing. I suspect something got lost in transmission somewhere along the way.)</source>
          <target state="translated">（关于您的困惑，我不知道任何 &lt;code&gt;((.+?))&lt;/code&gt; 会做同样事情的正则方言。我怀疑在传输过程中某些地方丢失了某些东西。）</target>
        </trans-unit>
        <trans-unit id="4ef24db075ab7963455bfe3ea7654428474ef88d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://neverfear.org/blog/view/Regex_tutorial_for_people_who_should_know_Regex__but_do_not___Part_1&quot;&gt;Regular Expressions - Everything you should know&lt;/a&gt; (PDF Series)</source>
          <target state="translated">&lt;a href=&quot;http://neverfear.org/blog/view/Regex_tutorial_for_people_who_should_know_Regex__but_do_not___Part_1&quot;&gt;正则表达式-您应该知道的一切&lt;/a&gt; （PDF系列）</target>
        </trans-unit>
        <trans-unit id="4c618840a436ae1359f6b753fc7b297f01d3edc4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;Mastering Regular Expressions&lt;/a&gt;, the &lt;a href=&quot;http://oreilly.com/catalog/9780596002893&quot;&gt;2nd Edition&lt;/a&gt;, and the &lt;a href=&quot;http://shop.oreilly.com/product/9780596528126.do&quot;&gt;3rd edition&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://oreilly.com/catalog/9780596528126/&quot;&gt;掌握正则表达式&lt;/a&gt; ， &lt;a href=&quot;http://oreilly.com/catalog/9780596002893&quot;&gt;第二版&lt;/a&gt;和&lt;a href=&quot;http://shop.oreilly.com/product/9780596528126.do&quot;&gt;第三版&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a78dcd68ae6f3277cb0e045417feb90a498d6dd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://regexlib.com/Default.aspx&quot;&gt;Regular Expression Library&lt;/a&gt; (Predefined Regexes for common scenarios)</source>
          <target state="translated">&lt;a href=&quot;http://regexlib.com/Default.aspx&quot;&gt;正则表达式库&lt;/a&gt; （常见方案的预定义正则表达式 ）</target>
        </trans-unit>
        <trans-unit id="52ba4e284aa4c3ef639e8a8eb43c76f0d2dd305d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://regexstorm.net/&quot;&gt;Regex Storm&lt;/a&gt; (for .NET)</source>
          <target state="translated">&lt;a href=&quot;http://regexstorm.net/&quot;&gt;正则表达式风暴&lt;/a&gt; （.NET）</target>
        </trans-unit>
        <trans-unit id="c399644d59ada43490f6ffcfa767c8ffa88aaf34" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://weitz.de/regex-coach/&quot;&gt;Regex Coach&lt;/a&gt; (engine backed by &lt;a href=&quot;https://edicl.github.io/cl-ppcre/&quot;&gt;CL-PPCRE&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://weitz.de/regex-coach/&quot;&gt;正则表达式教练&lt;/a&gt; （由&lt;a href=&quot;https://edicl.github.io/cl-ppcre/&quot;&gt;CL-PPCRE&lt;/a&gt;支持的引擎）</target>
        </trans-unit>
        <trans-unit id="37fbb3c67041c88bb5fb2ee7d0ea73da5aca34b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;Expresso&lt;/a&gt; (for .NET)</source>
          <target state="translated">&lt;a href=&quot;http://www.ultrapico.com/Expresso.htm&quot;&gt;Expresso&lt;/a&gt; （用于.NET）</target>
        </trans-unit>
        <trans-unit id="5091e76616eb92b95cb38de4c129f9453eee45c4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regex101.com/&quot;&gt;Regex 101&lt;/a&gt; (for PCRE, JavaScript, Python, Golang)</source>
          <target state="translated">&lt;a href=&quot;https://regex101.com/&quot;&gt;正则表达式101&lt;/a&gt; （用于PCRE，JavaScript，Python，Golang）</target>
        </trans-unit>
        <trans-unit id="0219e5502b55fbd56d948d75b0b9d635ece58d47" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regexr.com/&quot;&gt;RegExr&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://regexr.com/&quot;&gt;RegExr&lt;/a&gt; （用于JavaScript）</target>
        </trans-unit>
        <trans-unit id="88542bbf29e8bb29a91e15cec896ae72f5da8770" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://rubular.com/&quot;&gt;Rubular&lt;/a&gt; (for Ruby)</source>
          <target state="translated">&lt;a href=&quot;https://rubular.com/&quot;&gt;Rubular&lt;/a&gt; （对于Ruby）</target>
        </trans-unit>
        <trans-unit id="2307de32b2e7372a804ec97e3ca567c35d03bd92" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.debuggex.com/&quot;&gt;Debuggex&lt;/a&gt; (visual regex tester and helper)</source>
          <target state="translated">&lt;a href=&quot;https://www.debuggex.com/&quot;&gt;Debuggex&lt;/a&gt; （可视化正则表达式测试器和帮助器）</target>
        </trans-unit>
        <trans-unit id="b671ff66076869497a948d0bf95f5fc2b9e40299" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.regexpal.com/&quot;&gt;RegexPal&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://www.regexpal.com/&quot;&gt;RegexPal&lt;/a&gt; （适用于JavaScript）</target>
        </trans-unit>
        <trans-unit id="9cb9a6ab932dceec9ffe65247bc3cccfda5da286" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.regextester.com/&quot;&gt;Regex Tester&lt;/a&gt; (for JavaScript)</source>
          <target state="translated">&lt;a href=&quot;https://www.regextester.com/&quot;&gt;正则表达式测试器&lt;/a&gt; （用于JavaScript）</target>
        </trans-unit>
        <trans-unit id="eeb0890b8bae80c63e782001363779e5dd6a4cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; (zero or more times)</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; （零次或多次）</target>
        </trans-unit>
        <trans-unit id="68e7787028c0f8e5c7cb1974a6a29b105ad2afb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt; (one or more times)</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; （一次或多次）</target>
        </trans-unit>
        <trans-unit id="4078b42459a3d9c1d9e1e9ea095ffdfc0773bc68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[0-9]+&lt;/code&gt; (and its equivalent &lt;code&gt;\d+&lt;/code&gt;) matches any non-negative integer</source>
          <target state="translated">&lt;code&gt;[0-9]+&lt;/code&gt; （及其等价 &lt;code&gt;\d+&lt;/code&gt; ）与任何非负整数匹配</target>
        </trans-unit>
        <trans-unit id="c29c5736875d33c09abed9a6b02279da10095e0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt; matches dates formatted like 2019-01-01</source>
          <target state="translated">&lt;code&gt;\d{4}-\d{2}-\d{2}&lt;/code&gt; 匹配日期格式为2019-01-01的日期</target>
        </trans-unit>
        <trans-unit id="b251d9b6ea61001d2d2aa44d156af068b0ca092e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,m}&lt;/code&gt; (at least &lt;em&gt;n&lt;/em&gt; times but no more than &lt;em&gt;m&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n,m}&lt;/code&gt; （至少&lt;em&gt;n&lt;/em&gt;次但不超过&lt;em&gt;m&lt;/em&gt;次）</target>
        </trans-unit>
        <trans-unit id="ef799869d678028f74953d5c3755452d618be643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n,}&lt;/code&gt; (at least &lt;em&gt;n&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n,}&lt;/code&gt; （至少&lt;em&gt;n&lt;/em&gt;次）</target>
        </trans-unit>
        <trans-unit id="8ea261c3e08a435014c07c930a9339279f834530" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{n}&lt;/code&gt; (exactly &lt;em&gt;n&lt;/em&gt; times)</source>
          <target state="translated">&lt;code&gt;{n}&lt;/code&gt; （恰好&lt;em&gt;n&lt;/em&gt;次）</target>
        </trans-unit>
        <trans-unit id="ebf2b2b20b1e034d96b759673425d9a2e451a754" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(and so on)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（等等）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dab55287a0c775bf4cd951c49b0ac8dfa0b7f22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;dagger;:&lt;/strong&gt; The statement above that &lt;code&gt;.&lt;/code&gt; matches any character is a simplification for pedagogical purposes that is not strictly true. Dot matches any character except newline, &lt;code&gt;&quot;\n&quot;&lt;/code&gt;, but in practice you rarely expect a pattern such as &lt;code&gt;.+&lt;/code&gt; to cross a newline boundary. Perl regexes have a &lt;a href=&quot;https://perldoc.perl.org/perlre.html#s&quot;&gt;&lt;code&gt;/s&lt;/code&gt; switch&lt;/a&gt; and Java &lt;a href=&quot;https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html#DOTALL&quot;&gt;&lt;code&gt;Pattern.DOTALL&lt;/code&gt;&lt;/a&gt;, for example, to make &lt;code&gt;.&lt;/code&gt; match any character at all. For languages that don't have such a feature, you can use something like &lt;code&gt;[\s\S]&lt;/code&gt; to match &quot;any whitespace or any non-whitespace&quot;, in other words anything.</source>
          <target state="translated">&lt;strong&gt;&amp;dagger;：&lt;/strong&gt;上方的陈述 &lt;code&gt;.&lt;/code&gt; 匹配任何字符都是出于教学目的的简化，并非严格如此。 点与除换行符 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 之外的任何字符都匹配，但是实际上，您很少期望 &lt;code&gt;.+&lt;/code&gt; 这样的模式跨越换行符边界。 Perl正则表达式具有&lt;a href=&quot;https://perldoc.perl.org/perlre.html#s&quot;&gt; &lt;code&gt;/s&lt;/code&gt; 开关&lt;/a&gt;和Java &lt;a href=&quot;https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html#DOTALL&quot;&gt; &lt;code&gt;Pattern.DOTALL&lt;/code&gt; &lt;/a&gt; ，例如make &lt;code&gt;.&lt;/code&gt; 完全匹配任何字符。 对于没有这种功能的语言，可以使用 &lt;code&gt;[\s\S]&lt;/code&gt; 来匹配&amp;ldquo;任何空白或任何非空白&amp;rdquo;，换句话说，就是任何东西。</target>
        </trans-unit>
        <trans-unit id="e4616c92589ed8e68a1ebbf03782fde32acb593f" translate="yes" xml:space="preserve">
          <source>A few other useful examples:</source>
          <target state="translated">其他几个有用的例子。</target>
        </trans-unit>
        <trans-unit id="9698c2a9402dd87d80e8df20e87b7752186b2fba" translate="yes" xml:space="preserve">
          <source>A quantifier modifies the pattern to its immediate left. You might expect &lt;code&gt;0abc+0&lt;/code&gt; to match '0abc0', '0abcabc0', and so forth, but the pattern &lt;em&gt;immediately&lt;/em&gt; to the left of the plus quantifier is &lt;code&gt;c&lt;/code&gt;. This means &lt;code&gt;0abc+0&lt;/code&gt; matches '0abc0', '0abcc0', '0abccc0', and so on.</source>
          <target state="translated">量词将模式修改到其紧邻的左侧。 您可能希望 &lt;code&gt;0abc+0&lt;/code&gt; 匹配'0abc0'，'0abcabc0'等，但是加号修饰符左侧的模式是 &lt;code&gt;c&lt;/code&gt; 。 这意味着 &lt;code&gt;0abc+0&lt;/code&gt; 与'0abc0'，'0abcc0'，'0abccc0'等匹配。</target>
        </trans-unit>
        <trans-unit id="c2eec20b60545f98a44bd16ad8a4e0cd3a89a41a" translate="yes" xml:space="preserve">
          <source>Adding just a little complexity, you can match either 'Nick' or 'nick' with the pattern &lt;code&gt;[Nn]ick&lt;/code&gt;. The part in square brackets is a &lt;em&gt;character class&lt;/em&gt;, which means it matches exactly one of the enclosed characters. You can also use ranges in character classes, so &lt;code&gt;[a-c]&lt;/code&gt; matches either 'a' or 'b' or 'c'.</source>
          <target state="translated">稍微增加一点复杂性，您就可以将[Nick]或'nick'与模式 &lt;code&gt;[Nn]ick&lt;/code&gt; 匹配。 方括号中的部分是一个&lt;em&gt;字符类&lt;/em&gt; ，这意味着它与所包含的字符之一完全匹配。 您还可以在字符类中使用范围，因此 &lt;code&gt;[a-c]&lt;/code&gt; 匹配&amp;ldquo; a&amp;rdquo;或&amp;ldquo; b&amp;rdquo;或&amp;ldquo; c&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="83d719739c59379bf19d989792e9ec8998993c2d" translate="yes" xml:space="preserve">
          <source>Although some characters match themselves, others have special meanings. The pattern &lt;code&gt;\d+&lt;/code&gt; doesn't match backslash followed by lowercase D followed by a plus sign: to get that, we'd use &lt;code&gt;\\d\+&lt;/code&gt;. A backslash removes the special meaning from the following character.</source>
          <target state="translated">尽管某些字符匹配，但其他字符具有特殊含义。 模式 &lt;code&gt;\d+&lt;/code&gt; 与反斜杠，小写字母D和加号不匹配：要实现此目的，我们将使用 &lt;code&gt;\\d\+&lt;/code&gt; 。 反斜杠从后面的字符中删除特殊含义。</target>
        </trans-unit>
        <trans-unit id="a307a637b89fe16e9922778e99bea2ed2e8e496b" translate="yes" xml:space="preserve">
          <source>Anchors</source>
          <target state="translated">Anchors</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="f20b35258323d6253263d376f19f1859ea7fa62f" translate="yes" xml:space="preserve">
          <source>Build your own</source>
          <target state="translated">建立你自己的</target>
        </trans-unit>
        <trans-unit id="1d333bcb58941bfd7a3fb8cda029220d5a88e47f" translate="yes" xml:space="preserve">
          <source>Conceptually, the simplest regular expressions are literal characters. The pattern &lt;code&gt;N&lt;/code&gt; matches the character 'N'.</source>
          <target state="translated">从概念上讲，最简单的正则表达式是文字字符。 模式 &lt;code&gt;N&lt;/code&gt; 与字符&amp;ldquo; N&amp;rdquo;匹配。</target>
        </trans-unit>
        <trans-unit id="fabc21bb541d3248d6745e3a4b9e442f9a030f7d" translate="yes" xml:space="preserve">
          <source>Earlier, we saw one way to match either 'Nick' or 'nick'. Another is with alternation as in &lt;code&gt;Nick|nick&lt;/code&gt;. Remember that alternation includes everything to its left and everything to its right. Use grouping parentheses to limit the scope of &lt;code&gt;|&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;, &lt;code&gt;(Nick|nick)&lt;/code&gt;.</source>
          <target state="translated">之前，我们看到了一种匹配&amp;ldquo; Nick&amp;rdquo;或&amp;ldquo; nick&amp;rdquo;的方法。 另一个如 &lt;code&gt;Nick|nick&lt;/code&gt; 。 请记住，交替包括其左侧的所有内容和右侧的所有内容。 使用分组括号来限制 &lt;code&gt;|&lt;/code&gt; 的范围。 ， &lt;em&gt;例如&lt;/em&gt; &lt;code&gt;(Nick|nick)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2779ea444cb47200f1b0085d04662b33c09fc23f" translate="yes" xml:space="preserve">
          <source>Escaping</source>
          <target state="translated">Escaping</target>
        </trans-unit>
        <trans-unit id="40e31a210a1913fd0a8b28b892780996d154c70d" translate="yes" xml:space="preserve">
          <source>Footnote</source>
          <target state="translated">Footnote</target>
        </trans-unit>
        <trans-unit id="4cd395750596fc63879f88a287d8880fa0e85e60" translate="yes" xml:space="preserve">
          <source>For another example, you could equivalently write &lt;code&gt;[a-c]&lt;/code&gt; as &lt;code&gt;a|b|c&lt;/code&gt;, but this is likely to be suboptimal because many implementations assume alternatives will have lengths greater than 1.</source>
          <target state="translated">再举一个例子，您可以将 &lt;code&gt;[a-c]&lt;/code&gt; 等价地写为 &lt;code&gt;a|b|c&lt;/code&gt; ，但这可能不是最优的，因为许多实现都假定替代项的长度大于1。</target>
        </trans-unit>
        <trans-unit id="1afa4f2a09ae6c3e5a9c146d9e129073c4f2e82e" translate="yes" xml:space="preserve">
          <source>For example, say the input is</source>
          <target state="translated">例如,假设输入是</target>
        </trans-unit>
        <trans-unit id="8dd341228f5203334a2dbe18a099fd9cdb246553" translate="yes" xml:space="preserve">
          <source>Free resources</source>
          <target state="translated">免费资源</target>
        </trans-unit>
        <trans-unit id="8b058c9ddbb5e235a3b17a4d130bb8609fba9734" translate="yes" xml:space="preserve">
          <source>From there, you can repeat parts of your pattern with &lt;em&gt;quantifiers&lt;/em&gt;. For example, the pattern &lt;code&gt;ab?c&lt;/code&gt; matches 'abc' or 'ac' because the &lt;code&gt;?&lt;/code&gt; quantifier makes the subpattern it modifies optional. Other quantifiers are</source>
          <target state="translated">从那里，您可以使用&lt;em&gt;量词&lt;/em&gt;重复模式的某些部分。 例如，模式 &lt;code&gt;ab?c&lt;/code&gt; 与'abc'或'ac'相匹配，因为 &lt;code&gt;?&lt;/code&gt; 量词使它修改的子图案成为可选的。 其他量词是</target>
        </trans-unit>
        <trans-unit id="59985b76bfac61da62ef1b2c39db3443c181b381" translate="yes" xml:space="preserve">
          <source>Greediness</source>
          <target state="translated">Greediness</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="f646cf743adf4a08fb6e1b26f378b70f117af712" translate="yes" xml:space="preserve">
          <source>Helpful shortcuts</source>
          <target state="translated">有用的捷径</target>
        </trans-unit>
        <trans-unit id="9356b9688cab55bd64e84c0c92cc854e57b999b4" translate="yes" xml:space="preserve">
          <source>How Regexes Work</source>
          <target state="translated">编码编码是如何工作的</target>
        </trans-unit>
        <trans-unit id="a5370c7d8ba341173df1c3b84ffdbdf6a7833cfc" translate="yes" xml:space="preserve">
          <source>I don't really understand regular expressions.  Can you explain them to me in an easy-to-follow manner?  If there are any online tools or books, could you also link to them?</source>
          <target state="translated">我不太懂正则表达式。你能不能通俗易懂地给我解释一下?如果有什么在线工具或书籍,你能不能也链接一下?</target>
        </trans-unit>
        <trans-unit id="530b1c010c952dc47e7ccad7a66d94ff2c275a0e" translate="yes" xml:space="preserve">
          <source>If you think of regular expressions as building blocks that you can mix and match as you please, it helps you learn how to write and debug your own patterns but also how to understand patterns written by others.</source>
          <target state="translated">如果你把正则表达式看作是你可以随意搭配的积木,它不仅可以帮助你学习如何编写和调试自己的模式,还可以帮助你理解别人写的模式。</target>
        </trans-unit>
        <trans-unit id="46b79bd52027013bd53543e10582ce6baeead7a2" translate="yes" xml:space="preserve">
          <source>If you've ever used &lt;code&gt;grep&lt;/code&gt; on Unix&amp;mdash;even if only to search for ordinary looking strings&amp;mdash;you've already been using regular expressions! (The &lt;code&gt;re&lt;/code&gt; in &lt;code&gt;grep&lt;/code&gt; refers to regular expressions.)</source>
          <target state="translated">如果您曾经在Unix上使用过 &lt;code&gt;grep&lt;/code&gt; （即使只是为了搜索普通的字符串），那么您已经在使用正则表达式！ （ &lt;code&gt;grep&lt;/code&gt; 中的 &lt;code&gt;re&lt;/code&gt; 是指正则表达式。）</target>
        </trans-unit>
        <trans-unit id="3f48e3ea7a67593afc624d898633d8bcfd4d221e" translate="yes" xml:space="preserve">
          <source>If your input is '(123) (456)', then the first capture will be '123'. Non-greedy quantifiers want to allow the rest of the pattern to start matching as soon as possible.</source>
          <target state="translated">如果你的输入是'(123)(456)',那么第一次捕获的是'123'。非greedy量化器希望让其余的模式尽快开始匹配。</target>
        </trans-unit>
        <trans-unit id="feecfcff81cdfac79c1169c68bcdf3298543a39e" translate="yes" xml:space="preserve">
          <source>Learning Regular Expressions</source>
          <target state="translated">学习正则表达式</target>
        </trans-unit>
        <trans-unit id="54274c1b66e4db9103a52754b9f88c07567bd846" translate="yes" xml:space="preserve">
          <source>Nick</source>
          <target state="translated">Nick</target>
        </trans-unit>
        <trans-unit id="c659a1a4add3674e46b01f5c3aed16066f609fba" translate="yes" xml:space="preserve">
          <source>Nnick</source>
          <target state="translated">Nnick</target>
        </trans-unit>
        <trans-unit id="849e6a4431d3bc9b7fd03e9363f4f10c14117c82" translate="yes" xml:space="preserve">
          <source>Once is not enough</source>
          <target state="translated">仅此一次是不够的</target>
        </trans-unit>
        <trans-unit id="82eb240ece12cf01f54324b6e46ee819e866dd8b" translate="yes" xml:space="preserve">
          <source>Order from the menu</source>
          <target state="translated">从菜单上订购</target>
        </trans-unit>
        <trans-unit id="44a71879f76eef9a972c14aeb610df9bb2a2d7cd" translate="yes" xml:space="preserve">
          <source>Perl: &lt;a href=&quot;https://metacpan.org/release/YAPE-Regex-Explain&quot;&gt;YAPE: Regex Explain&lt;/a&gt;</source>
          <target state="translated">Perl： &lt;a href=&quot;https://metacpan.org/release/YAPE-Regex-Explain&quot;&gt;YAPE：正则表达式解释&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="947c6e8160e2686ffe1464043c63e0d649717e4f" translate="yes" xml:space="preserve">
          <source>Putting some of these blocks together, the pattern &lt;code&gt;[Nn]*ick&lt;/code&gt; matches all of</source>
          <target state="translated">将其中一些块放在一起，模式 &lt;code&gt;[Nn]*ick&lt;/code&gt; 匹配所有</target>
        </trans-unit>
        <trans-unit id="16dc60b323d79a2f6113da0cf72b1173c59702bf" translate="yes" xml:space="preserve">
          <source>Regex Buddy</source>
          <target state="translated">Regex Buddy</target>
        </trans-unit>
        <trans-unit id="b9648927d75753351180b745bd9201dc142cf8bb" translate="yes" xml:space="preserve">
          <source>Regex Cookbook</source>
          <target state="translated">编码库</target>
        </trans-unit>
        <trans-unit id="79fd14db3d8dce5771ed8d43cbac1e67ff353684" translate="yes" xml:space="preserve">
          <source>Regex Syntax Summary</source>
          <target state="translated">语法摘要</target>
        </trans-unit>
        <trans-unit id="d8fee145772e06e3d12eea6ce0cb821cd8678167" translate="yes" xml:space="preserve">
          <source>RegexOne - Learn with simple, interactive exercises.</source>
          <target state="translated">RegexOne-通过简单的互动练习来学习。</target>
        </trans-unit>
        <trans-unit id="c8974ee3c3bc80517e839f83d10737faa707127b" translate="yes" xml:space="preserve">
          <source>Regular Expressions Cheat Sheet</source>
          <target state="translated">正则表达式练习册</target>
        </trans-unit>
        <trans-unit id="89c14d5368a465f10ef6a24a01a9a7b38da0fc57" translate="yes" xml:space="preserve">
          <source>Regular Expressions Online Tester</source>
          <target state="translated">正则表达式在线测试仪</target>
        </trans-unit>
        <trans-unit id="5699d9c17f85d41638b57e6a204ea26e5d711b98" translate="yes" xml:space="preserve">
          <source>Regular expression quantifiers are greedy. This means they match as much text as they possibly can while allowing the entire pattern to match successfully.</source>
          <target state="translated">正则表达式量化器是贪婪的。这意味着它们尽可能多地匹配文本,同时让整个模式成功匹配。</target>
        </trans-unit>
        <trans-unit id="68e27e707d3e03f55d0c8a5732979a4ccc2d797c" translate="yes" xml:space="preserve">
          <source>Regular expressions are recursive, so now that you understand these basic rules, you can combine them however you like.</source>
          <target state="translated">正则表达式是递归的,所以现在你了解了这些基本规则,你就可以随心所欲地组合它们了。</target>
        </trans-unit>
        <trans-unit id="6c187c47e14e519d74321d9000d5afb95d07cfdc" translate="yes" xml:space="preserve">
          <source>Regular expressions next to each other match sequences. For example, the pattern &lt;code&gt;Nick&lt;/code&gt; matches the sequence 'N' followed by 'i' followed by 'c' followed by 'k'.</source>
          <target state="translated">正则表达式彼此相邻，匹配序列。 例如，模式 &lt;code&gt;Nick&lt;/code&gt; 匹配序列&amp;ldquo; N&amp;rdquo;，&amp;ldquo; i&amp;rdquo;，&amp;ldquo; c&amp;rdquo;和&amp;ldquo; k&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3555c1a56411b43a7966c37d01ae16f4955f43f9" translate="yes" xml:space="preserve">
          <source>Say you want to match comments of the form</source>
          <target state="translated">说你想匹配表格的评论</target>
        </trans-unit>
        <trans-unit id="cb45b4e62bf666c532a02287bb4fb02a809b6fc5" translate="yes" xml:space="preserve">
          <source>Start simple</source>
          <target state="translated">简单的开始</target>
        </trans-unit>
        <trans-unit id="28aef8f69db620eb498820f0e319209292abdccd" translate="yes" xml:space="preserve">
          <source>Teach Yourself Regular Expressions</source>
          <target state="translated">自学正则表达式</target>
        </trans-unit>
        <trans-unit id="c845c6000fff99af437a9fc8c2e6f447122a611d" translate="yes" xml:space="preserve">
          <source>The first match demonstrates an important lesson: &lt;em&gt;&lt;code&gt;*&lt;/code&gt; always succeeds!&lt;/em&gt; Any pattern can match zero times.</source>
          <target state="translated">第一场比赛展示了一个重要的教训： &lt;em&gt; &lt;code&gt;*&lt;/code&gt; 总是成功！&lt;/em&gt; 任何模式都可以匹配零次。</target>
        </trans-unit>
        <trans-unit id="b96fd7359131170ec3910a2c15c093b0604c1e9d" translate="yes" xml:space="preserve">
          <source>The most important part is the concepts. Once you understand how the building blocks work, differences in syntax amount to little more than mild dialects. A layer on top of your regular expression engine's syntax is the syntax of the programming language you're using. Languages such as Perl remove most of this complication, but you'll have to keep in mind other considerations if you're using regular expressions in a C program.</source>
          <target state="translated">最重要的是概念。一旦你了解了这些构件是如何工作的,语法上的差异只相当于轻微的方言。在正则表达式引擎的语法之上,还有一层是你所使用的编程语言的语法。像 Perl 这样的语言可以消除大部分的复杂性,但如果你在 C 程序中使用正则表达式,你必须记住其他的注意事项。</target>
        </trans-unit>
        <trans-unit id="22715149bb9c6655ed248fa2ba77fe101f0f5ecb" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;.&lt;/code&gt; is special: rather than matching a literal dot only, it matches &lt;em&gt;any&lt;/em&gt; character&lt;sup&gt;&amp;dagger;&lt;/sup&gt;. It's the same conceptually as the really big character class &lt;code&gt;[-.?+%$A-Za-z0-9...]&lt;/code&gt;.</source>
          <target state="translated">图案 &lt;code&gt;.&lt;/code&gt; 是特殊的：它不仅匹配文字点，还匹配&lt;em&gt;任何&lt;/em&gt;字符&lt;sup&gt;&amp;dagger;&lt;/sup&gt; 。 从概念上讲，它与真正的大型角色类 &lt;code&gt;[-.?+%$A-Za-z0-9...]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91a4d600b807bd4f09976a09959e06274f29ba2d" translate="yes" xml:space="preserve">
          <source>The uppercased variants are their complements, so &lt;code&gt;\S&lt;/code&gt; matches any &lt;em&gt;non&lt;/em&gt;-whitespace character, for example.</source>
          <target state="translated">大写的变体是它们的补语，因此 &lt;code&gt;\S&lt;/code&gt; 匹配任何&lt;em&gt;非&lt;/em&gt;空白字符。</target>
        </trans-unit>
        <trans-unit id="e293881e27590496ef91a61c6c25643e50a9e297" translate="yes" xml:space="preserve">
          <source>Think of character classes as menus: pick just one.</source>
          <target state="translated">把角色类想成菜单:只选一个。</target>
        </trans-unit>
        <trans-unit id="de4b0e2db7bd3c9c11ac9e377548480b18fc9bf9" translate="yes" xml:space="preserve">
          <source>To match one or more sequences of 'abc' with zeros on the ends, use &lt;code&gt;0(abc)+0&lt;/code&gt;. The parentheses denote a subpattern that can be quantified as a unit. It's also common for regular expression engines to save or &quot;capture&quot; the portion of the input text that matches a parenthesized group. Extracting bits this way is much more flexible and less error-prone than counting indices and &lt;code&gt;substr&lt;/code&gt;.</source>
          <target state="translated">要匹配一个或多个'abc'序列的末端为零，请使用 &lt;code&gt;0(abc)+0&lt;/code&gt; 。 括号表示可以量化为一个单位的子模式。 正则表达式引擎通常会保存或&amp;ldquo;捕获&amp;rdquo;与括号组匹配的输入文本部分。 与对索引和 &lt;code&gt;substr&lt;/code&gt; 进行计数相比，以这种方式提取位更加灵活且不易出错。</target>
        </trans-unit>
        <trans-unit id="50ddbc5d0277e3c16b73cf8e609473468f17b01c" translate="yes" xml:space="preserve">
          <source>To switch from greedy to what you might think of as cautious, add an extra &lt;code&gt;?&lt;/code&gt; to the quantifier. Now you understand how &lt;code&gt;\((.+?)\)&lt;/code&gt;, the example from your question works. It matches the sequence of a literal left-parenthesis, followed by one or more characters, and terminated by a right-parenthesis.</source>
          <target state="translated">要从贪婪切换到您可能认为谨慎的地方，请添加一个额外的 &lt;code&gt;?&lt;/code&gt; 到量词。 现在您了解了问题中的示例 &lt;code&gt;\((.+?)\)&lt;/code&gt; 的工作原理。 它与文字左括号的顺序匹配，后接一个或多个字符，并以右括号终止。</target>
        </trans-unit>
        <trans-unit id="92935cc481013b79cd161911bb7bc552f1ba3812" translate="yes" xml:space="preserve">
          <source>Tools for writing and debugging regexes:</source>
          <target state="translated">编写和调试重构符的工具。</target>
        </trans-unit>
        <trans-unit id="a1fd9141e7da915eb8a8004fe9ab9111acd0635a" translate="yes" xml:space="preserve">
          <source>Txt2RE</source>
          <target state="translated">Txt2RE</target>
        </trans-unit>
        <trans-unit id="fe6d79779c9d27867ff69b0be6ad558feeaa20f7" translate="yes" xml:space="preserve">
          <source>Use the special pattern &lt;code&gt;^&lt;/code&gt; to match only at the beginning of your input and &lt;code&gt;$&lt;/code&gt; to match only at the end. Making &quot;bookends&quot; with your patterns where you say, &quot;I know what's at the front and back, but give me everything between&quot; is a useful technique.</source>
          <target state="translated">使用特殊模式 &lt;code&gt;^&lt;/code&gt; 仅在输入的开头进行匹配，而 &lt;code&gt;$&lt;/code&gt; 仅在输入的末尾进行匹配。 用您的模式制作&amp;ldquo;书挡&amp;rdquo;，您说：&amp;ldquo;我知道正面和背面是什么，但是请给我之间的一切&amp;rdquo;是一种有用的技术。</target>
        </trans-unit>
        <trans-unit id="37304d600ce0cd62463a50ccd70b1ebda871fa2f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;.&lt;/code&gt; can save you lots of typing, and there are other shortcuts for common patterns. Say you want to match a digit: one way to write that is &lt;code&gt;[0-9]&lt;/code&gt;. Digits are a frequent match target, so you could instead use the shortcut &lt;code&gt;\d&lt;/code&gt;. Others are &lt;code&gt;\s&lt;/code&gt; (whitespace) and &lt;code&gt;\w&lt;/code&gt; (word characters: alphanumerics or underscore).</source>
          <target state="translated">使用 &lt;code&gt;.&lt;/code&gt; 可以节省大量的输入时间，还有其他常见模式的捷径。 假设您要匹配一个数字：一种写方法是 &lt;code&gt;[0-9]&lt;/code&gt; 。 数字是经常匹配的目标，因此您可以改用 &lt;code&gt;\d&lt;/code&gt; 快捷方式。 其他是 &lt;code&gt;\s&lt;/code&gt; （空格）和 &lt;code&gt;\w&lt;/code&gt; （单词字符：字母数字或下划线）。</target>
        </trans-unit>
        <trans-unit id="526f639bebd48d81d13a90a85f8fd1789e9df34d" translate="yes" xml:space="preserve">
          <source>Visual RegExp</source>
          <target state="translated">可视化正则</target>
        </trans-unit>
        <trans-unit id="75e9f880bd62145e1e31f2d7b936986d0605f73e" translate="yes" xml:space="preserve">
          <source>You might expect &lt;code&gt;&quot;.+&quot;&lt;/code&gt; to match only 'Hello,' and will then be surprised when you see that it matched from 'Hello' all the way through 'you?'.</source>
          <target state="translated">您可能希望 &lt;code&gt;&quot;.+&quot;&lt;/code&gt; 仅匹配&amp;ldquo; Hello&amp;rdquo;，然后当您看到它与&amp;ldquo; Hello&amp;rdquo;一直匹配到&amp;ldquo; you？&amp;rdquo;时，您会感到惊讶。</target>
        </trans-unit>
        <trans-unit id="a2b8abe4260aad959411d4203bb668f167991d6a" translate="yes" xml:space="preserve">
          <source>ick</source>
          <target state="translated">ick</target>
        </trans-unit>
        <trans-unit id="fc15a9dd34ddc23b9aff22adce8b09526d7b078c" translate="yes" xml:space="preserve">
          <source>nNick</source>
          <target state="translated">nNick</target>
        </trans-unit>
        <trans-unit id="75ef9faee755c70589550b513ad881e5a603182c" translate="yes" xml:space="preserve">
          <source>nick</source>
          <target state="translated">nick</target>
        </trans-unit>
        <trans-unit id="98cb5605f45e16baa3327dd0dd78f00ec9cc4b36" translate="yes" xml:space="preserve">
          <source>nnick</source>
          <target state="translated">nnick</target>
        </trans-unit>
        <trans-unit id="35b888ad74eacdebe041626f388c5c12bae6bfda" translate="yes" xml:space="preserve">
          <source>you'd write &lt;code&gt;^--\s+(.+)\s+--$&lt;/code&gt;.</source>
          <target state="translated">你会写 &lt;code&gt;^--\s+(.+)\s+--$&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
