<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/472906">
    <body>
      <group id="472906">
        <trans-unit id="12d92f20fd5e751242d08c35e9ec6ef2bc1ed3ed" translate="yes" xml:space="preserve">
          <source>(And, of course, to be able to re-construct the string from the bytes.)</source>
          <target state="translated">(当然,还要能够从字节中重新构造字符串)。</target>
        </trans-unit>
        <trans-unit id="1b083175a7952dbca89143ec8ab5b10ff3e5b645" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/20321003/369792&quot;&gt;Tom Blodget's answer&lt;/a&gt; is 20-30% faster than Mehrdad since it skips the intermediate step of allocating a char array and copying the bytes to it, but it requires you compile with the &lt;code&gt;/unsafe&lt;/code&gt; option.  If you absolutely do not want to use encoding, I think this is the way to go.  If you put your encryption login inside the &lt;code&gt;fixed&lt;/code&gt; block, you don't even need to allocate a separate byte array and copy the bytes to it.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/20321003/369792&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tom Blodget的答案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比Mehrdad快20-30％，因为它跳过了分配char数组并将字节复制到其中的中间步骤，但是它要求您使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;/unsafe&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;选项进行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您绝对不想使用编码，我认为这是要走的路。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果将加密登录名放在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fixed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;块内，则甚至不需要分配单独的字节数组并将字节复制到其中。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc41837abd0e977716c8c397fb8912ecd3dad4a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Everybody else answered this incorrect question incorrectly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其他人都错误地回答了这个错误的问题。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6e34be17e25bca5212b6d3a4de133c044184b5e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that working with &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; requires installing the &lt;a href=&quot;https://www.nuget.org/packages/System.Memory&quot;&gt;System.Memory NuGet package&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;需要安装&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.nuget.org/packages/System.Memory&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Memory NuGet软件包&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0561660ea53366c3d45e5997c890a23d70363f33" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;That's it for most usages. If that's what you need, stop reading here.&lt;/em&gt; See the fun &lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;Joel Spolsky article&lt;/a&gt; if you don't understand what an encoding is.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多数情况就是这样。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果那是您的需要，请在这里停止阅读。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您不了解编码是什么，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参阅有趣的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Joel Spolsky文章&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b2c442146e3794ea28fbd8e2c26d8286d526de31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This is based off of OP's comment on his own question, and is the correct question if I understand OP's hints at the use-case.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是基于OP对他自己的问题的评论，如果我理解OP关于用例的提示，这是正确的问题。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d94e738be3d4d982dfcf523fa657196119f8016f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;EDIT&lt;/em&gt;&lt;/strong&gt;
as Makotosan commented this is now the best way:</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编辑&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 诚诚评论这是最好的方法：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d72a3384d26ca8c8484068b64b00feb648fab1b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fastest way&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最快的方法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dbce4e34dabf0c0683865f641afdcbbb63a8240" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In other words, you can't satisfy your requirement for &lt;em&gt;consistency&lt;/em&gt; without specifying an encoding.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;换句话说，如果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不指定编码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，就无法满足&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一致性&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要求&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65a2d2a3d5e39c98144e466619dc430e70beec66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mehrdad's Answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;梅尔达德的答案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65c958e6dee00219a13d85ae2be8a1b4e028fd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tom Blodget's Answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;汤姆&amp;middot;布洛杰特的答案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b434a03504320706540f9b87e55a1ef2cf97770" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.string(v=vs.110).aspx&quot;&gt;string&lt;/a&gt; in .NET represents text as a sequence of UTF-16 code units, so the bytes are encoded in memory in UTF-16 already.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.string(v=vs.110).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字符串将&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文本表示为UTF-16代码单元的序列，因此字节已经在UTF-16的内存中进行了编码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8289079a63027bc7e05ffb27f563cbf920241334" translate="yes" xml:space="preserve">
          <source>A small sample why encoding matters:</source>
          <target state="translated">一个小样本,为什么编码很重要。</target>
        </trans-unit>
        <trans-unit id="11e8fd694a3cbe8d859770b79eb647edd463766b" translate="yes" xml:space="preserve">
          <source>A string (or more generically, a text) is composed of characters: letters, digits, and other symbols. That's all. Computers, however, do not know anything about characters; they can only handle bytes. Therefore, if you want to store or transmit text by using a computer, you need to transform the characters to bytes. How do you do that? Here's where encodings come to the scene.</source>
          <target state="translated">一个字符串(或更通俗的说,是由字母、数字和其他符号组成的字符串(或更通俗的说,是一个文本)。仅此而已。然而,计算机对字符一无所知;它们只能处理字节。因此,如果你想用计算机来存储或传输文本,你需要将字符转化为字节。如何做到这一点呢?这时,编码就出现了。</target>
        </trans-unit>
        <trans-unit id="2fcf684bd3c5c93b2ec38730ad5c4cd5645524d5" translate="yes" xml:space="preserve">
          <source>ASCII simply isn't equipped to deal with special characters.</source>
          <target state="translated">ASCII根本不具备处理特殊字符的能力。</target>
        </trans-unit>
        <trans-unit id="e7f8396deba19ebd2f572fa25ad2f5b3de56be39" translate="yes" xml:space="preserve">
          <source>Additional benefit to this approach:</source>
          <target state="translated">这种方法的额外好处是:</target>
        </trans-unit>
        <trans-unit id="b566b8a5021ad88e51d3e4b7d5d612f040ec6ef2" translate="yes" xml:space="preserve">
          <source>Also please explain why encoding should be taken into consideration. 
  Can't I simply get what bytes the string has been stored in?
  Why this dependency on encoding?!!!</source>
          <target state="translated">另外请解释一下为什么要考虑到编码的问题。难道我不能简单地得到字符串存储在什么字节里吗?为什么对编码有这种依赖性?</target>
        </trans-unit>
        <trans-unit id="6760299d10ce0a958a61d6a1e2965454ce0a8fe8" translate="yes" xml:space="preserve">
          <source>Also, .NET supports non-Unicode encodings, but they are not valid in general case (will be valid only if a limited sub-set of Unicode code point is used in an actual string, such as ASCII). Internally, .NET supports UTF-16, but for stream representation, UTF-8 is usually used. It is also a standard-de-facto for Internet.</source>
          <target state="translated">另外,.NET支持非Unicode编码,但它们在一般情况下是无效的(只有在实际的字符串中使用有限的Unicode码点子集时才会有效,比如ASCII)。在内部,.NET支持UTF-16,但对于流的表示,通常使用UTF-8。它也是Internet的一个事实标准。</target>
        </trans-unit>
        <trans-unit id="cc5e9f1684f7a373c58a842445dc80d4e34ca6a5" translate="yes" xml:space="preserve">
          <source>Also, why should encoding be taken into consideration? Can't I simply get what bytes the string has been stored in? Why is there a dependency on character encodings?</source>
          <target state="translated">另外,为什么要考虑到编码?难道我不能简单地得到字符串存储在什么字节里吗?为什么对字符编码有依赖性?</target>
        </trans-unit>
        <trans-unit id="8d4da4f1fc049fae3a7cdccededfeee113ee8961" translate="yes" xml:space="preserve">
          <source>Also, why should encoding even be taken into consideration? Can't I simply get what bytes the string has been stored in? Why is there a dependency on character encodings?</source>
          <target state="translated">另外,为什么要考虑到编码呢?难道我不能简单地得到字符串被存储在什么字节中吗?为什么会对字符编码有依赖性?</target>
        </trans-unit>
        <trans-unit id="7a7c26363aae04ff8b9358b236c2b8be81b4306c" translate="yes" xml:space="preserve">
          <source>An encoding is nothing but a convention to translate logical characters to physical bytes. The simplest and best known encoding is ASCII, and it is all you need if you write in English. For other languages you will need more complete encodings, being any of the Unicode flavours the safest choice nowadays.</source>
          <target state="translated">编码只是一种将逻辑字符转换为物理字节的约定。最简单也是最著名的编码是ASCII,如果你用英语写作,就只需要它。对于其他语言,你需要更完整的编码,现在最安全的选择是Unicode的任何一种编码。</target>
        </trans-unit>
        <trans-unit id="b199b85ba17f5afaf2627e750d478f49c4a52d52" translate="yes" xml:space="preserve">
          <source>And,</source>
          <target state="translated">And,</target>
        </trans-unit>
        <trans-unit id="213c6ee30ec5ff4710dd1ea02173a295d5b16230" translate="yes" xml:space="preserve">
          <source>As @CodesInChaos pointed out, the result depends on the endianness of the machine. But the question author is not concerned with that.</source>
          <target state="translated">正如@CodesInChaos指出的那样,结果取决于机器的ENDIANNESS。但问题作者并不关心这个问题。</target>
        </trans-unit>
        <trans-unit id="6b35f831e0e676d7d7012d1fef6810df7de7eb5e" translate="yes" xml:space="preserve">
          <source>As long as your program (or other programs) don't try to &lt;em&gt;interpret&lt;/em&gt; the bytes somehow, which you obviously didn't mention you intend to do, then there is &lt;strong&gt;nothing&lt;/strong&gt; wrong with this approach! Worrying about encodings just makes your life more complicated for no real reason.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只要您的程序（或其他程序）不尝试以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;某种方式&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解释&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字节（您显然没有提到您打算这样做），那么&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这种方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;就&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;错！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无须担心编码，这会使您的生活更加复杂。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e5453acc43479c51c2639631effba130305463cf" translate="yes" xml:space="preserve">
          <source>As you can see, it's also actually less code to just use the built in encoding objects than to implement your own reader/writer methods.</source>
          <target state="translated">正如你所看到的那样,仅仅使用内置的编码对象实际上也比实现自己的readwriter方法要少很多代码。</target>
        </trans-unit>
        <trans-unit id="a2a9418ccf48ccffff57c0ec370bed125059d005" translate="yes" xml:space="preserve">
          <source>Assuming that you have binary data (rather than text) stored in a string</source>
          <target state="translated">假设你有二进制数据(而不是文本)存储在一个字符串中。</target>
        </trans-unit>
        <trans-unit id="e2888f72c3a469703d179f475e8ff340617f003a" translate="yes" xml:space="preserve">
          <source>Because that is the proper way to do it.  &lt;code&gt;string&lt;/code&gt; is an abstraction.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为那是正确的方法。 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个抽象。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76878448f83add9a0896a7c9661deaf0db7e1012" translate="yes" xml:space="preserve">
          <source>Because there is no such thing as &quot;the bytes of the string&quot;.</source>
          <target state="translated">因为没有 &quot;字符串的字节 &quot;这种东西。</target>
        </trans-unit>
        <trans-unit id="764bdc9aac628b1989ecedd0ebe6bd5fc9fd62d5" translate="yes" xml:space="preserve">
          <source>But a conversion was used -- each character was placed into a fixed size box (c#'s character type).  However what that representation is does not matter, which is technically the answer to the OP.  So -- if you are going to convert anyway...  Why not 'encode'?</source>
          <target state="translated">但是使用了一个转换----每个字符都被放入一个固定大小的框中(c#的字符类型)。然而,这个表示方式是什么并不重要,这在技术上是对OP的答案。所以,如果你要转换的话......为什么不进行 &quot;编码&quot;?</target>
        </trans-unit>
        <trans-unit id="371c1ce2a6b5b66ba3cd7c90aa8ba5f29768c55f" translate="yes" xml:space="preserve">
          <source>But to avoid the mention of encodings, we must do it another way. If an intermediate data type is acceptable, there is a conceptual shortcut for this:</source>
          <target state="translated">但为了避免提到编码,我们必须用另一种方式来做。如果中间的数据类型是可以接受的,那就有一个概念上的捷径。</target>
        </trans-unit>
        <trans-unit id="a327eb37907ef9ea4fff97d2b6b447e5cd25a852" translate="yes" xml:space="preserve">
          <source>But why leave the 'encoding' up to magic?  Why not specify the encoding so that you know what bytes you are gonna get?</source>
          <target state="translated">但是,为什么要把 &quot;编码 &quot;留给魔法呢?为什么不指定编码,让你知道你会得到什么字节?</target>
        </trans-unit>
        <trans-unit id="cc32ca8b2565c116d2b88180835165c1407fb460" translate="yes" xml:space="preserve">
          <source>By the way, I strongly recommend you (and anyone, for that matter) to read this small piece of wisdom: &lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;顺便说一句，我强烈建议您（和任何其他人）阅读这一小知识：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个软件开发人员绝对绝对要完全了解Unicode和字符集（没有任何借口！）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1fc320f3254958f8d464eb376c3c1270c1e166c" translate="yes" xml:space="preserve">
          <source>C# to convert a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;byte&lt;/code&gt; array:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C＃将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;byte&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e23fe8562b81064741b61938288b46879494182" translate="yes" xml:space="preserve">
          <source>Character and string processing in C# uses Unicode encoding. The char
  type represents a UTF-16 code unit, and the string type represents a
  sequence of UTF-16 code units.</source>
          <target state="translated">C#中的字符和字符串处理采用Unicode编码。char类型代表一个UTF-16编码单位,字符串类型代表一串UTF-16编码单位。</target>
        </trans-unit>
        <trans-unit id="e0ef3a4505bcbc6160c552b1ae785584813523bf" translate="yes" xml:space="preserve">
          <source>Clearly, conversions are not necessarily lossless!</source>
          <target state="translated">显然,转换不一定是无损的!</target>
        </trans-unit>
        <trans-unit id="9cdff2e5bb172553c918c78b7b587dce154716c8" translate="yes" xml:space="preserve">
          <source>Common Need</source>
          <target state="translated">共同需要</target>
        </trans-unit>
        <trans-unit id="881db208cce3965e094f2bbcd67f87ac22ac59dd" translate="yes" xml:space="preserve">
          <source>Contrary to the answers here, you DON'T need to worry about encoding &lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt; the bytes don't need to be interpreted!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与这里的答案相反，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不需要解释字节，则无需&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;担心编码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acaaab22b5cc002ed8b04f6496989a4e4704ec21" translate="yes" xml:space="preserve">
          <source>Converting it back should be a non-starter because that means you are in fact interpreting the data somehow, but for the sake of completeness:</source>
          <target state="translated">将其转换回来应该是一个不可能的事情,因为这意味着你实际上是在以某种方式解释数据,但为了完整性的原因。</target>
        </trans-unit>
        <trans-unit id="f4d849313ccc4b84cee6efad70e46cb183c4e23c" translate="yes" xml:space="preserve">
          <source>Darn, Microsoft should have just used &lt;code&gt;System.Buffer.BlockCopy&lt;/code&gt; in its &lt;code&gt;BinaryFormatter&lt;/code&gt; ツ</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;织补，微软应该刚使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Buffer.BlockCopy&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在它&lt;/font&gt;&lt;/font&gt; &lt;code&gt;BinaryFormatter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ツ&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b971e5d4bc6947d5c932095238f4bde4965ccf6f" translate="yes" xml:space="preserve">
          <source>Don't reinvent the wheel if you don't have to...</source>
          <target state="translated">如果你不需要的话,就不要重塑车轮......</target>
        </trans-unit>
        <trans-unit id="c973c91a278235b6dafdf98e8329894c72798190" translate="yes" xml:space="preserve">
          <source>Encoding (in this context) simply means the bytes that represent your string.  Not the bytes of the string object.  You wanted the bytes the string has been stored in -- this is where the question was asked naively.  You wanted the bytes of string in a contiguous array that represent the string, and not all of the other binary data that a string object may contain.</source>
          <target state="translated">编码(在这里的上下文中)只是指代表你的字符串的字节。而不是字符串对象的字节。你想要的是字符串被存储的字节----这就是问题被天真地问到的地方。你想要的是字符串的字节,而不是字符串对象可能包含的所有其他二进制数据。</target>
        </trans-unit>
        <trans-unit id="bec7c4514fe118c47315563dd5f6221c9508127e" translate="yes" xml:space="preserve">
          <source>Every string has a character set and encoding. When you convert a &lt;code&gt;System.String&lt;/code&gt; object to an array of &lt;code&gt;System.Byte&lt;/code&gt; you still have a character set and encoding. &lt;strong&gt;For most usages, you'd know which character set and encoding you need and .NET makes it simple to &quot;copy with conversion.&quot;&lt;/strong&gt; Just choose the appropriate &lt;code&gt;Encoding&lt;/code&gt; class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个字符串都有一个字符集和编码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Byte&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的数组时，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您仍然具有字符集和编码。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于大多数用法，您会知道需要哪种字符集和编码，.NET使&amp;ldquo;转换转换复制&amp;rdquo;变得简单。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只需选择适当的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Encoding&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ded830ec260ed22e3e81c4beb3d65d91f62df969" translate="yes" xml:space="preserve">
          <source>Every time there's a movement in this question, I'm still thinking of a serializer(be it from Microsoft or from 3rd party component) that can persist strings even it contains unpaired surrogate characters; I google this every now and then: &lt;strong&gt;serialization unpaired surrogate character .NET&lt;/strong&gt;. This doesn't make me lose any sleep, but it's kind of annoying when every  now and then there's somebody commenting on my answer that it's flawed, yet their answers are equally flawed when it comes to unpaired surrogate characters.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每当这个问题出现动静时，我仍在思考一个序列化程序（无论是来自Microsoft还是来自第三方的组件），即使其中包含不成对的替代字符，该序列化程序也可以保留字符串；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我不时在Google上搜索：&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;序列化未配对的代理字符.NET&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这不会让我失去任何睡眠，但是时不时有人在烦恼我，我的回答是有缺陷的，但是对于不成对的代理角色，他们的回答同样是有缺陷的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2cdfd3bc6caf4ac53a8acb2c2eaccd76c9103d74" translate="yes" xml:space="preserve">
          <source>First of all, the bytes used internally by the string class &lt;em&gt;don't matter&lt;/em&gt;, and whenever you assume they do you're likely introducing a bug.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先，字符串类内部使用的字节&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无关紧要&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且每当您假设它们出现时，就很可能引入错误。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="53209f5e88f2cc4248bddf0e08037f0f42a3d105" translate="yes" xml:space="preserve">
          <source>For communicating (either with a completely disparate process or with the same program in the future), you need to define your protocol &lt;strong&gt;strictly&lt;/strong&gt; to minimize the difficulty of working with it or accidentally creating bugs. Depending on .NET's internal representation is not a strict, clear, or even guaranteed to be consistent definition. A standard encoding &lt;em&gt;is&lt;/em&gt; a strict definition that will not fail you in the future.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了进行通信（使用完全不同的过程或将来使用同一程序进行通信），您需要&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;严格&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定义协议，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以最大程度地减少使用它或意外创建错误的难度。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;依赖于.NET的内部表示形式不是严格，清晰的，甚至不能保证是一致的定义。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;标准编码&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;严格的定义，将来不会令您失望。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="2b90b113f177529b6709a0949dd9936fdea84ac2" translate="yes" xml:space="preserve">
          <source>For serialization to an array of bytes using &lt;code&gt;System.Text.Encoding.GetBytes&lt;/code&gt;. For the inverse operation use &lt;code&gt;System.Text.Encoding.GetChars&lt;/code&gt;. This function returns an array of characters, so to get a string, use a string constructor &lt;code&gt;System.String(char[])&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.GetBytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;序列化为字节数组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于逆运算，请使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.GetChars&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此函数返回一个字符数组，因此要获取字符串，请使用字符串构造函数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.String(char[])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c720f9d5f4a088fed167ead31f5163d521731ff" translate="yes" xml:space="preserve">
          <source>For those goals, I honestly do &lt;em&gt;not&lt;/em&gt; understand why people keep telling you that you need the encodings. You certainly do NOT need to worry about encodings for this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于这些目标，老实说，我&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;明白为什么人们&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总是&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;告诉您您需要编码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您当然不必为此担心编码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a799f5d20469b87cb2c5e22e877f21e629fcf803" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.microsoft.com/en-us/download/confirmation.aspx?id=7029&quot;&gt;C# spec&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.microsoft.com/en-us/download/confirmation.aspx?id=7029&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C＃规范&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="62e3e6ef5278c69c7f272b982a159c71a9219c05" translate="yes" xml:space="preserve">
          <source>He doesn't want any conversion.</source>
          <target state="translated">他不希望有任何转换。</target>
        </trans-unit>
        <trans-unit id="74068d3f7ddc60086e084ec9ff97f9d04d593254" translate="yes" xml:space="preserve">
          <source>Here is my unsafe implementation of &lt;code&gt;String&lt;/code&gt; to &lt;code&gt;Byte[]&lt;/code&gt; conversion:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是我不安全的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;String&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Byte[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换的实现：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79a31c95b719d1c0a03c21994345a7067dcbc970" translate="yes" xml:space="preserve">
          <source>How do I convert a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;byte[]&lt;/code&gt; in .NET (C#) without manually specifying a specific encoding?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如何将转换&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;byte[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在.NET（C＃），而无需手动指定一个特定的编码？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="250f9b487de8b4346798124d6f0272cb174fa03e" translate="yes" xml:space="preserve">
          <source>How do I convert a string to a byte[] in .NET (C#) without manually specifying a specific encoding?</source>
          <target state="translated">如何在.NET(C#)中将字符串转换为字节[],而无需手动指定特定的编码?</target>
        </trans-unit>
        <trans-unit id="8301aff1e0b7b5e543cf294e6d8e4a152d09b4e6" translate="yes" xml:space="preserve">
          <source>How do I get a consistent byte representation of strings in C# without manually specifying an encoding</source>
          <target state="translated">如何在C#中获得一致的字节表示的字符串,而不需要手动指定编码?</target>
        </trans-unit>
        <trans-unit id="308d05f72a533a6f046867579a0fd5bff9c1fc21" translate="yes" xml:space="preserve">
          <source>I like Tom Bloget's answer because he took you towards the 'bytes of the string object' direction.  It's implementation dependent though, and because he's peeking at internals it might be difficult to reconstitute a copy of the string.</source>
          <target state="translated">我喜欢Tom Bloget的回答,因为他把你带到了 &quot;字符串对象的字节 &quot;的方向。不过这取决于实现,而且因为他在偷看内部,所以可能很难重构一个字符串的副本。</target>
        </trans-unit>
        <trans-unit id="11e1812469f5e52b2b356ac02b49b92bf948ca15" translate="yes" xml:space="preserve">
          <source>I tend to use the bottom one more often than the top, haven't benchmarked them for speed.</source>
          <target state="translated">我倾向于用下边的那个比上边的多,还没有对它们的速度做过标杆。</target>
        </trans-unit>
        <trans-unit id="8b2de312e872be935e0a0767a85a7bcfb8861e8d" translate="yes" xml:space="preserve">
          <source>I think the question isn't why you want to worry about the encoding, but why you want to ignore it and use something else.  Encoding is meant to represent the abstraction of a string in a sequence of bytes.  &lt;code&gt;System.Text.Encoding.Unicode&lt;/code&gt; will give you a little endian byte order encoding and will perform the same on every system, now and in the future.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我认为问题不是您为什么要担心编码，而是为什么要忽略它并使用其他东西。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编码旨在表示字节序列中字符串的抽象。 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将为您提供一点字节序的字节编码，并且无论现在还是将来，在每个系统上都将执行相同的操作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d5ba1f23cbb7de00b3499a5d3c1fa2891c35976c" translate="yes" xml:space="preserve">
          <source>I understand that in this case you might prefer to use the actual bytes stored by the string variable in memory where possible, with the idea that it might save some work creating your byte stream. However, I put it to you it's just not important compared to making sure that your output is understood at the other end, and to guarantee that you &lt;em&gt;must&lt;/em&gt; be explicit with your encoding. Additionally, if you really want to match your internal bytes, you can already just choose the &lt;code&gt;Unicode&lt;/code&gt; encoding, and get that performance savings.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我了解在这种情况下，您可能更愿意在可能的情况下使用字符串变量存储在内存中的实际字节，这样可能会节省创建字节流的工作。但是，我告诉您，与确保另一端可以理解您的输出并确保&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您的编码&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是明确的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相比，这并不重要&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。此外，如果您确实要匹配内部字节，则只需选择&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编码即可，从而节省了性能。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0a68547f8105b8c321a012db5592c9dfa6f86747" translate="yes" xml:space="preserve">
          <source>I will address your follow-up question: why do you need to pick an encoding?  Why can't you get that from the string class itself?</source>
          <target state="translated">我再来回答你的后续问题:为什么要选一个编码?为什么你不能从字符串类本身就能得到?</target>
        </trans-unit>
        <trans-unit id="7ada9517ee500634d2ed6a36e13993710ad8ab90" translate="yes" xml:space="preserve">
          <source>I'm going to encrypt it. I can encrypt it without converting but I'd still like to know why encoding comes to play here. Just give me the bytes is what I say.</source>
          <target state="translated">我要把它加密。我可以不用转换就能加密,但我还是想知道为什么要在这里加密。我是这么说的,只要把字节数给我就可以了。</target>
        </trans-unit>
        <trans-unit id="23328b8b90fc8391e6977f267afdb4987dce99f3" translate="yes" xml:space="preserve">
          <source>I'm going to encrypt the string. I can encrypt it without converting, but I'd still like to know why encoding comes to play here.</source>
          <target state="translated">我要对这个字符串进行加密。我可以不用转换就能加密,但我还是想知道为什么编码会在这里发挥作用。</target>
        </trans-unit>
        <trans-unit id="73edba52ee6a28a24523945beee302c70085419a" translate="yes" xml:space="preserve">
          <source>I'm not sure, but I think the string stores its info as an array of Chars, which is inefficient with bytes.  Specifically, the definition of a Char is &quot;Represents a Unicode character&quot;.</source>
          <target state="translated">我不太清楚,但我认为字符串的信息是以数组Chars的形式存储的,用字节来存储,效率很低。具体来说,Char的定义是 &quot;代表一个Unicode字符&quot;。</target>
        </trans-unit>
        <trans-unit id="c4312324dd22deb5211f29d42de3f21cb51b940c" translate="yes" xml:space="preserve">
          <source>I've changed my mind about this (Mehrdad's solution) -- this isn't getting the bytes of the string; rather it is getting the bytes of the character array that was created from the string.  Regardless of encoding, the char datatype in c# is a fixed size.  This allows a consistent length byte array to be produced, and it allows the character array to be reproduced based on the size of the byte array.  So if the encoding were UTF-8, but each char was 6 bytes to accommodate the largest utf8 value, it would still work.  So indeed -- encoding of the character does not matter.</source>
          <target state="translated">我改变了我对这个问题的看法(Mehrdad的解决方案)----这不是获取字符串的字节数,而是获取从字符串中创建的字符数组的字节数。无论编码如何,c#中的char数据类型都是固定大小的。这样就可以产生一个长度一致的字节数组,它可以根据字节数组的大小来重现字符数组。因此,如果编码是UTF-8,但每个char是6个字节,以容纳最大的utf8值,它仍然可以工作。所以确实是这样,字符的编码并不重要。</target>
        </trans-unit>
        <trans-unit id="8f987a9391d67ecbc6f5e57e1eba7f6b2a903207" translate="yes" xml:space="preserve">
          <source>If the string looks good as-is, just pick an encoding (preferably one starting with UTF), use the corresponding &lt;code&gt;System.Text.Encoding.???.GetBytes()&lt;/code&gt; function, and tell whoever you give the bytes to which encoding you picked.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果字符串按原样看起来不错，则只需选择一种编码（最好是一种以UTF开头的编码），然后使用相应的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.???.GetBytes()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数，并告诉将字节提供给谁的人即可采摘。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8014e7bced1ca056331e4021f470ccb6ec78153c" translate="yes" xml:space="preserve">
          <source>If you have a text string with an unknown encoding</source>
          <target state="translated">如果你有一个未知编码的文本字符串</target>
        </trans-unit>
        <trans-unit id="cdf6921da828ca4a35976570bed2c1d0683ef413" translate="yes" xml:space="preserve">
          <source>If you really want a copy of the underlying bytes of a string, you can use a function like the one that follows. &lt;strong&gt;However, you shouldn't&lt;/strong&gt; please read on to find out why.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您确实想要一个字符串的基础字节的副本，则可以使用下面的函数。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，您不应该继续&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;阅读以找出原因。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fe3e3532bc4f8d47ac6709111f975fd91357eeb0" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;System.Text.Encoding.Unicode&lt;/code&gt;, your code will be more resilient.  You don't have to worry about the &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;endianness&lt;/a&gt; of the system your code will be running on.  You don't need to worry if the next version of the CLR will use a different internal character encoding.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则代码将更具弹性。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您不必担心&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代码将在其上运行的系统&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字节顺序&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您无需担心下一版本的CLR是否使用其他内部字符编码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a7842bf159130826080a10125e8894356cfd6a7" translate="yes" xml:space="preserve">
          <source>If you used a specific encoding, though, it would've given you trouble with encoding/decoding invalid characters.</source>
          <target state="translated">不过,如果你使用的是特定的编码,那就会给你的无效字符编码带来麻烦。</target>
        </trans-unit>
        <trans-unit id="33b0321053b92b4fa0428632fbfc0415818cf893" translate="yes" xml:space="preserve">
          <source>If your program is entirely within the .Net world then you don't need to worry about getting byte arrays for strings at all, even if you're sending data across a network. Instead, use .Net Serialization to worry about transmitting the data.  You don't worry about the actual bytes any more: the Serialization formatter does it for you.</source>
          <target state="translated">如果你的程序完全在.Net世界中,那么你根本不需要担心获取字节数组的字符串,即使你要跨网络发送数据,也不用担心。相反,使用.Net Serialization来担心数据的传输问题。你再也不用担心实际的字节了:Serialization格式化器为你做了。</target>
        </trans-unit>
        <trans-unit id="b55572a251031f38f43e0ce27cb2550dfd157131" translate="yes" xml:space="preserve">
          <source>In all likelihood this will give the same result, is easier to type, and the bytes will always round-trip with a call to</source>
          <target state="translated">在所有的可能性中,这将得到同样的结果,更容易打字,而且字节总是会通过调用</target>
        </trans-unit>
        <trans-unit id="54278cf74b906f55d3e2e4e2f5f2899e105de098" translate="yes" xml:space="preserve">
          <source>In order to use it, you have to tick &quot;Allow Unsafe Code&quot; in your project build properties.
As per .NET Framework 3.5, this method can also be used as String extension:</source>
          <target state="translated">为了使用它,你必须在项目构建属性中勾选 &quot;允许不安全代码&quot;。根据.NET Framework 3.5,这个方法也可以作为String扩展。</target>
        </trans-unit>
        <trans-unit id="e315a35ab8b323b6f1b71f706b5abe5be3682bdb" translate="yes" xml:space="preserve">
          <source>Internally, the .NET framework uses &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-16&quot;&gt;UTF-16&lt;/a&gt; to represent strings, so if you simply want to get the exact bytes that .NET uses, use &lt;code&gt;System.Text.Encoding.Unicode.GetBytes (...)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在内部，.NET框架使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-16&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;UTF-16&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示字符串，因此，如果您只想获取.NET使用的确切字节，请使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.Unicode.GetBytes (...)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="253d98cd0ff94b324089dd103360170318602987" translate="yes" xml:space="preserve">
          <source>It depends on the encoding of your string (&lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;, ...).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它取决于字符串的编码（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ASCII&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;UTF-8&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，...）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb8673fc3c3b53f57ce77c997e1a1de179fe1ace" translate="yes" xml:space="preserve">
          <source>It depends on what you want the bytes FOR</source>
          <target state="translated">这要看你想要的字节是什么了</target>
        </trans-unit>
        <trans-unit id="fafdca4a7238f02b1bcabb06d745312e84100bb3" translate="yes" xml:space="preserve">
          <source>It doesn't matter if the string contains invalid characters, because you can still get the data and reconstruct the original string anyway!</source>
          <target state="translated">如果字符串中包含无效字符也没有关系,因为你仍然可以获得数据并重构原始字符串!</target>
        </trans-unit>
        <trans-unit id="3743f646e71bbbf4f2fa8d2a8a992c94db7d0419" translate="yes" xml:space="preserve">
          <source>It will be encoded and decoded just the same, because you are &lt;em&gt;just looking at the bytes&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为您&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是在看bytes&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，所以它的编码和解码都&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一样&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50ef6f8b46c2a72a4edd3727490c28fa9ad5b914" translate="yes" xml:space="preserve">
          <source>It would be &lt;strong&gt;safer, simpler and more reliable&lt;/strong&gt; to just call,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;拨打电话&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;会&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更安全，更简单，更可靠&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="09a9d3269261d67410064802503de606e111f4eb" translate="yes" xml:space="preserve">
          <source>It's also important to understand your string has to be re-written to wire, and that involves at least some translation of the bit-pattern &lt;em&gt;even when you use a matching encoding&lt;/em&gt;. The computer needs to account for things like Big vs Little Endian, network byte order, packetization, session information, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同样重要的是要了解您的字符串必须重写为wire，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即使使用匹配的编码&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这也至少涉及位模式的一些翻译&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;计算机需要考虑诸如Big vs Little Endian，网络字节顺序，打包，会话信息等问题。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18a23e217bf26b95123358b0c912f11ad4a34af7" translate="yes" xml:space="preserve">
          <source>It's bad when the string, for example, comes from &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt; where it was built from a byte array storing, for example, a password hash. If we drop anything from it, it'll store an invalid hash, and if we want to store it in XML, we want to leave it intact (because the XML writer drops an exception on any unpaired surrogate it finds).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，当字符串来自&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server时&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这是很不&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好的，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是从存储例如密码哈希的字节数组构建的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我们从其中删除任何内容，它将存储一个无效的哈希，并且如果我们希望将其存储在XML中，我们希望将其保持不变（因为XML编写器会在发现的任何未配对代理中删除异常）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0239ce0f340ef86dd3fc996e2af2070445e8cde7" translate="yes" xml:space="preserve">
          <source>It's way faster than the accepted anwser's one, even if not as elegant as it is.
Here are my Stopwatch benchmarks over 10000000 iterations:</source>
          <target state="translated">它比公认的Anwser的那个快得多,即使没有那么优雅。以下是我的Stopwatch基准,经过10000000次迭代后,我的Stopwatch基准。</target>
        </trans-unit>
        <trans-unit id="b45885d736c4aeff1a446b8c7294826b2f0d7bd9" translate="yes" xml:space="preserve">
          <source>Joel has a posting on this:</source>
          <target state="translated">乔尔有一个关于这个的帖子。</target>
        </trans-unit>
        <trans-unit id="d8c62c907006f766a6556ba8b07bf4c5573e8c16" translate="yes" xml:space="preserve">
          <source>Just do this instead:</source>
          <target state="translated">就这样做吧。</target>
        </trans-unit>
        <trans-unit id="be726ed35a3333ee7f9a2e2916e7384715f4e1e9" translate="yes" xml:space="preserve">
          <source>Just to demonstrate that Mehrdrad's sound &lt;a href=&quot;https://stackoverflow.com/a/10380166&quot;&gt;answer&lt;/a&gt; works, his approach can even persist the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter%28v=VS.100%29.aspx&quot;&gt;unpaired surrogate characters&lt;/a&gt;(of which many had leveled against my answer, but of which everyone are equally guilty of, e.g. &lt;code&gt;System.Text.Encoding.UTF8.GetBytes&lt;/code&gt;, &lt;code&gt;System.Text.Encoding.Unicode.GetBytes&lt;/code&gt;; those encoding methods can't persist the high surrogate characters &lt;code&gt;d800&lt;/code&gt; for example, and those just merely replace high surrogate characters with value &lt;code&gt;fffd&lt;/code&gt; ) :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是为了证明Mehrdrad的声音&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/10380166&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;答案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有效，他的方法甚至可以保留&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter%28v=VS.100%29.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;未配对的代理字符&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（其中许多&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;已与我的答案&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相提并论&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但每个人都同样有罪，例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.UTF8.GetBytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.Unicode.GetBytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那些编码方法不能保留高替代字符&lt;/font&gt;&lt;/font&gt; &lt;code&gt;d800&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，而只是将高替代字符替换为值&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fffd&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2ef24e2af226a4311be29d5b5c4456ee7bfbcc3d" translate="yes" xml:space="preserve">
          <source>Like you mentioned, your goal is, simply, to &lt;em&gt;&quot;get what bytes the string has been stored in&quot;&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;就像您提到的那样，您的目标很简单，就是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;获取字符串存储在哪个字节中&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="62dc42908d3fb01c4805c4e57a1a0b5db12b9b8c" translate="yes" xml:space="preserve">
          <source>Mehrdad's response is wrong because it is misleading at the conceptual level.  You still have a list of bytes, encoded.  His particular solution allows for unpaired surrogates to be preserved -- this is implementation dependent.  His particular solution would not produce the string's bytes accurately if &lt;code&gt;GetBytes&lt;/code&gt; returned the string in UTF-8 by default.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mehrdad的回答是错误的，因为它在概念层面上具有误导性。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您仍然有一个已编码的字节列表。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他的特定解决方案允许保留未配对的代理-这取决于实现。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetBytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;默认情况下以UTF-8返回字符串，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则他的特定解决方案将无法准确产生字符串的字节&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="47a99c1d5eff545ce3518be595bcbc8cb9d65801" translate="yes" xml:space="preserve">
          <source>Not surprisingly, serialization of string into an array of byte and deserialization is supported by the class &lt;code&gt;System.Text.Encoding&lt;/code&gt;, which is an abstract class; its derived classes support concrete encodings: &lt;code&gt;ASCIIEncoding&lt;/code&gt; and four UTFs (&lt;code&gt;System.Text.UnicodeEncoding&lt;/code&gt; supports UTF-16)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;毫不奇怪，类&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;支持将字符串序列化为字节数组并反序列化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其派生类支持具体的编码：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ASCIIEncoding&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和四个UTF（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.UnicodeEncoding&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;支持UTF-16）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb2eccf7017a0105eeeb7f202ea5e630dc101c72" translate="yes" xml:space="preserve">
          <source>Note: For &lt;code&gt;System.String&lt;/code&gt; the source character set is Unicode.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意：对于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，源字符集为Unicode。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d7effc002b8ac571412ec3d546c04ee79313d1c8" translate="yes" xml:space="preserve">
          <source>Now, the question author asks, &quot;Every string is stored as an array of bytes, right? Why can't I simply have those bytes?&quot;</source>
          <target state="translated">现在,问题作者问道:&quot;每个字符串都是以字节数组的形式存储的吧?为什么我不能简单的拥有这些字节呢?&quot;</target>
        </trans-unit>
        <trans-unit id="255b8f55679083ebaad714d1ab2eec76c35e7fad" translate="yes" xml:space="preserve">
          <source>On the other hand, what if you are sending these bytes somewhere that you can't guarantee will pull in data from a .Net serialized stream? In this case you definitely do need to worry about encoding, because obviously this external system cares. So again, the internal bytes used by the string don't matter: you need to pick an encoding so you can be explicit about this encoding on the receiving end, even if it's the same encoding used internally by .Net.</source>
          <target state="translated">另一方面,如果你把这些字节发送到你不能保证能从.Net序列化流中拉入数据的地方呢?在这种情况下,你肯定需要担心编码问题,因为很明显,这个外部系统很在意。所以,同样,字符串使用的内部字节并不重要:你需要选择一个编码,这样你就可以在接收端明确这个编码,即使它是.Net内部使用的相同编码。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="02f510b0a4e3557ce2149e475e6e82014f8ef252" translate="yes" xml:space="preserve">
          <source>Ref &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx&quot;&gt;this link.&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此链接。&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="363506df10662d63102d4ce4295ee324d6a6c259" translate="yes" xml:space="preserve">
          <source>Ref this page.</source>
          <target state="translated">参考本页。</target>
        </trans-unit>
        <trans-unit id="9b1479ef7d39111457b3930a7066c6d6b6370503" translate="yes" xml:space="preserve">
          <source>Regardless of whether you intend to send this encrypted data over the network, load it back into memory later, or steam it to another process, you are clearly intending to &lt;em&gt;decrypt&lt;/em&gt; it at some point. In that case, the answer is that you're defining a communication protocol. A communication protocol should not be &lt;strong&gt;defined&lt;/strong&gt; in terms of implementation details of your programming language and its associated runtime. There are several reasons for this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无论您打算通过网络发送此加密数据，稍后再将其加载回内存还是将其蒸腾到另一个进程，您显然都打算&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在某个时候对其&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解密&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，答案是您正在定义通信协议。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不应&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据您的编程语言及其关联的运行时的实现细节&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定义&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通信协议&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有几个原因：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c036f48a13443ce781fbbab689cd7f571a952014" translate="yes" xml:space="preserve">
          <source>Regardless, the &lt;em&gt;actual&lt;/em&gt; original question and follow-up comments imply that the underlying memory is not being &quot;interpreted&quot; (which I assume means is not modified or read beyond the need to write it as-is), indicating that some implementation of the &lt;code&gt;Stream&lt;/code&gt; class should be used instead of reasoning about the data as strings at all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无论如何，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原始问题和后续评论都暗示未对&amp;ldquo;底层内存&amp;rdquo;进行&amp;ldquo;解释&amp;rdquo;（我认为这意味着未对它们进行修改或超出了按原样编写它的需要），这表明该&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Stream&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;某些实现&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该使用class而不是完全将数据作为字符串进行推理。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4546e7c2b857f3ab3a6eb87dffcf458ab7496382" translate="yes" xml:space="preserve">
          <source>See &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms404377.aspx&quot;&gt;Character Encoding in the .NET Framework&lt;/a&gt;&lt;/em&gt; (MSDN) for more information.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更多信息，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参见&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms404377.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET Framework&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（MSDN）&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的字符编码&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9dc63bb2af5cd1e369af72f5dacfe14b82975a3c" translate="yes" xml:space="preserve">
          <source>Simply use this:</source>
          <target state="translated">只需使用这个就可以了。</target>
        </trans-unit>
        <trans-unit id="6398f1a61d94c7b892f9d1ef44bbd28dcd1bc9e1" translate="yes" xml:space="preserve">
          <source>So I use &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64&quot;&gt;Base64&lt;/a&gt; encoding of byte arrays in such cases, but hey, on the Internet there is only one solution to this in C#, and it has bug in it and is only one way, so I've fixed the bug and written back procedure. Here you are, future googlers:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，在这种情况下，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字节数组的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Base64&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Base64&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编码，但是嘿，在Internet上，C＃仅对此提供一种解决方案，并且其中包含错误，并且只是一种方法，因此，我已修复了该错误并写回程序。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;未来的Google员工，您好！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16fff7be164e3bccb0802acb8c0d4081298aa180" translate="yes" xml:space="preserve">
          <source>So choose an encoding and use it:</source>
          <target state="translated">所以选择一个编码并使用它。</target>
        </trans-unit>
        <trans-unit id="09ef2b0fdbe15cea061bf191e6b890a4d195162a" translate="yes" xml:space="preserve">
          <source>So if you just want the bytes used by the string, simply use &lt;code&gt;Encoding.Unicode&lt;/code&gt;, but it will be inefficient with storage space.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，如果只想使用字符串使用的字节，则只需使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Encoding.Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是它在存储空间方面效率低下。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="11d1d1615bd28a9785dd7a854fb672407bfb0899" translate="yes" xml:space="preserve">
          <source>So, in short, trying to &quot;get the bytes of a string without using encodings&quot; is as impossible as &quot;writing a text without using any language&quot;.</source>
          <target state="translated">所以,简而言之,想要 &quot;不使用编码就能得到字符串的字节数&quot;,就像 &quot;不使用任何语言就能写出一段文字 &quot;一样不可能。</target>
        </trans-unit>
        <trans-unit id="0536e7418ee1a23db7d0d7a3f544577523ad1d88" translate="yes" xml:space="preserve">
          <source>So, we know that if we ask for the null conversion (i.e., from UTF-16 to UTF-16), we'll get the desired result:</source>
          <target state="translated">所以,我们知道,如果我们要求进行空转换(即从UTF-16转换为UTF-16),就会得到想要的结果。</target>
        </trans-unit>
        <trans-unit id="baf3176971ea9ba7658a410ad325a9b5e5b59932" translate="yes" xml:space="preserve">
          <source>Specific Need</source>
          <target state="translated">具体需求</target>
        </trans-unit>
        <trans-unit id="d9851fedd08659ff8d8e4a81bd30b71762cdf523" translate="yes" xml:space="preserve">
          <source>Storing binary data in strings is probably the wrong approach because of the assumed encoding mentioned above! Whatever program or library stored that binary data in a &lt;code&gt;string&lt;/code&gt; (instead of a &lt;code&gt;byte[]&lt;/code&gt; array which would have been more appropriate) has already lost the battle before it has begun. If they are sending the bytes to you in a REST request/response or anything that &lt;em&gt;must&lt;/em&gt; transmit strings, &lt;a href=&quot;https://stackoverflow.com/q/201479/1739000&quot;&gt;Base64&lt;/a&gt; would be the right approach.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于上述假定的编码，将二进制数据存储在字符串中可能是错误的方法！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无论哪种程序或库将二进制数据存储在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（而不是将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;byte[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组更合适）存储在开始之前，都已经失去了战斗。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果他们以REST请求/响应或&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;传输字符串的形式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;向您发送字节&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/q/201479/1739000&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Base64&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是正确的方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f536b71e266ca742599e9e431ae560474b99326f" translate="yes" xml:space="preserve">
          <source>Sure, but that's where the fundamental error in the question arises.  The String is an object which could have an interesting data structure.  We already know it does, because it allows unpaired surrogates to be stored.  It might store the length.  It might keep a pointer to each of the 'paired' surrogates allowing quick counting.  Etc.  All of these extra bytes are not part of the character data.</source>
          <target state="translated">当然,但这就是问题的根本错误所在。String是一个对象,它可以有一个有趣的数据结构。我们已经知道它有,因为它允许存储未配对的代数。它可能会存储长度。它可能会保存一个指向每一个 &quot;配对的 &quot;代用品的指针,允许快速计数。等等。所有这些额外的字节都不是字符数据的一部分。</target>
        </trans-unit>
        <trans-unit id="5dbed11d9742fd76bd5a609ed5392a7eb7b65fac" translate="yes" xml:space="preserve">
          <source>Take note that the Unicode answer is 14 bytes in both instances, whereas the UTF-8 answer is only 9 bytes for the first, and only 7 for the second.</source>
          <target state="translated">请注意,在这两种情况下,Unicode的答案都是14个字节,而UTF-8的答案前者只有9个字节,后者只有7个字节。</target>
        </trans-unit>
        <trans-unit id="b3d1691b90f3f3216a25d44b87d676d4186487c4" translate="yes" xml:space="preserve">
          <source>That doesn't get us the desired datatype but &lt;a href=&quot;https://stackoverflow.com/a/10380166/2226988&quot;&gt;Mehrdad's answer&lt;/a&gt; shows how to convert this Char array to a Byte array using &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.buffer.blockcopy%28v=vs.110%29.aspx&quot;&gt;BlockCopy&lt;/a&gt;. However, this copies the string twice! And, it too explicitly uses encoding-specific code: the datatype &lt;code&gt;System.Char&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这并不能为我们提供所需的数据类型，但是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/10380166/2226988&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mehrdad的答案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;显示了如何使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.buffer.blockcopy%28v=vs.110%29.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BlockCopy&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将此Char数组转换为Byte数组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，这会将字符串复制两次！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且，它也明确使用编码特定的代码：数据类型&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Char&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54f180522aa90faa6b00e1d77c13baec981d8974" translate="yes" xml:space="preserve">
          <source>The .NET implementation might change the internal representation of strings. You may think this sounds farfetched, but this &lt;a href=&quot;https://www.vojtechruzicka.com/java-9-compact-strings/&quot;&gt;actually happened in Java 9&lt;/a&gt; to reduce memory usage. There's no reason .NET couldn't follow suit. &lt;a href=&quot;https://stackoverflow.com/a/14942142/1394393&quot;&gt;Skeet suggests&lt;/a&gt; that UTF-16 probably isn't optimal today give the rise of the emoji and other blocks of Unicode needing more than 2 bytes to represent as well, increasing the likelihood that the internal representation could change in the future.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NET实现可能会更改字符串的内部表示。您可能认为这听起来有些牵强，但这&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.vojtechruzicka.com/java-9-compact-strings/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上是在Java 9中发生的，&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以减少内存使用。 .NET没有理由不能效仿。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/14942142/1394393&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Skeet建议&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，UTF-16可能在今天并不是最佳选择，这也增加了表情符号和其他需要2个以上字节表示的Unicode其他块的出现，从而增加了内部表示将来可能更改的可能性。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac99e747a72258da36ac97be7a7d101d33946faf" translate="yes" xml:space="preserve">
          <source>The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</source>
          <target state="translated">每个软件开发人员绝对、肯定地必须知道的关于Unicode和字符集的绝对最低限度的知识(没有任何借口!)。</target>
        </trans-unit>
        <trans-unit id="efd69fe7ce3c17569af8c335e4a585e33812e409" translate="yes" xml:space="preserve">
          <source>The accepted answer is very, very complicated. Use the included .NET classes for this:</source>
          <target state="translated">接受的答案是非常、非常复杂。为此,请使用包含的.NET类。</target>
        </trans-unit>
        <trans-unit id="e6447751f9c76dc2e9beb74a23a15045eb7a43a4" translate="yes" xml:space="preserve">
          <source>The answer is in two parts.</source>
          <target state="translated">答案是分两部分。</target>
        </trans-unit>
        <trans-unit id="269e8cc0b61186d659e16fbf5f0486750f2105c8" translate="yes" xml:space="preserve">
          <source>The closest approach to the OP's question is Tom Blodget's, which actually goes into the object and extracts the bytes.  I say closest because it depends on implementation of the String Object.</source>
          <target state="translated">与OP的问题最接近的方法是Tom Blodget的,它实际上是进入对象并提取字节。我之所以说最接近,是因为这取决于String对象的实现。</target>
        </trans-unit>
        <trans-unit id="73514cd23fc4d868ca20e8a713f1a79185a82b12" translate="yes" xml:space="preserve">
          <source>The conversion may need to handle cases where the target character set or encoding doesn't support a character that's in the source. You have some choices: exception, substitution or skipping. The default policy is to substitute a '?'.</source>
          <target state="translated">转换可能需要处理目标字符集或编码不支持源中的字符的情况。你有一些选择:例外、替换或跳过。默认策略是替换'?&quot;。</target>
        </trans-unit>
        <trans-unit id="3d56114e252ccdf8c1990a643ceb4bcb8856f666" translate="yes" xml:space="preserve">
          <source>The first part of your question (how to get the bytes) was already answered by others: look in the &lt;code&gt;System.Text.Encoding&lt;/code&gt; namespace.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其他人已经回答了问题的第一部分（如何获取字节）：在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;命名空间中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;查找&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="730a097f3e85ebdd613402d589b73704722141bb" translate="yes" xml:space="preserve">
          <source>The key issue is that a glyph in a string takes 32 bits (16 bits for a character code) but a byte only has 8 bits to spare.  A one-to-one mapping doesn't exist unless you restrict yourself to strings that only contain ASCII characters.  System.Text.Encoding has lots of ways to map a string to byte[], you need to pick one that avoids loss of information and that is easy to use by your client when she needs to map the byte[] back to a string.</source>
          <target state="translated">问题的关键是,字符串中的字形需要32位(字符代码需要16位),而字节只有8位。一对一的映射是不存在的,除非你把自己限制在只包含ASCII字符的字符串中。System.Text.Encoding有很多将字符串映射到字节[]的方法,你需要选择一种可以避免信息丢失的方法,而且当你的客户需要将字节[]映射回字符串时,你需要选择一种便于客户使用的方法。</target>
        </trans-unit>
        <trans-unit id="a40a9ea14dae7563f50e320804e82a672b940687" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;NonPortableCast&lt;/code&gt; and &lt;code&gt;DangerousGetPinnableReference&lt;/code&gt; should further the argument that you probably shouldn't be doing this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;名称&lt;/font&gt;&lt;/font&gt; &lt;code&gt;NonPortableCast&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;DangerousGetPinnableReference&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该进一步说明您可能不应该这样做。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dda539ce82b20525f557ab49a5c6264cab553f17" translate="yes" xml:space="preserve">
          <source>The only confusing thing is that .NET uses the name of a character set for the name of one particular encoding of that character set. &lt;code&gt;Encoding.Unicode&lt;/code&gt; should be called &lt;code&gt;Encoding.UTF16&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;唯一令人困惑的是，.NET使用字符集的名称作为该字符集的一种特定编码的名称。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Encoding.Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该称为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Encoding.UTF16&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d87180cf4983e0ecdadae876f5161ab8b72c51c" translate="yes" xml:space="preserve">
          <source>The only way to get to the actual bytes the String is stored in is to use a pointer. The &lt;code&gt;fixed&lt;/code&gt; statement allows taking the address of values. From the C# spec:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;获取字符串存储在其中的实际字节的唯一方法是使用指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fixed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语句允许取值的地址。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据C＃规范：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50c45a3db03e83c198d132a47dbec8da83013c3b" translate="yes" xml:space="preserve">
          <source>The program may be re-implemented in a different language or runtime in the future.</source>
          <target state="translated">该程序将来可能会用不同的语言或运行时重新实现。</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">其结果是:</target>
        </trans-unit>
        <trans-unit id="69f6a043be4a0ce901b3fde8264cd0887c3552fc" translate="yes" xml:space="preserve">
          <source>The string can be converted to byte array in few different ways, due to the following fact: .NET supports Unicode, and Unicode standardizes several difference encodings called UTFs. They have different lengths of byte representation but are equivalent in that sense that when a string is encoded, it can be coded back to the string, but if the string is encoded with one UTF and decoded in the assumption of different UTF if can be screwed up.</source>
          <target state="translated">字符串可以用几种不同的方式转换为字节数组,这是由于以下事实:.NET支持Unicode,而Unicode标准化了几种不同的编码方式,称为UTF。它们有不同长度的字节表示,但在这个意义上是相等的,当一个字符串被编码时,它可以被编码回字符串,但如果字符串用一种UTF编码,并在不同的UTF的假设下解码,如果可以拧成一个UTF的话,就会被拧成一个字节数组。</target>
        </trans-unit>
        <trans-unit id="8c74ce348a5dbb8a79201c3a0b78651da595424f" translate="yes" xml:space="preserve">
          <source>This function will get you a copy of the bytes underlying your string, pretty quickly. You'll get those bytes in whatever way they are encoding on your system. This encoding is almost certainly UTF-16LE but that is an implementation detail you shouldn't have to care about.</source>
          <target state="translated">这个函数可以很快得到你的字符串底层字节的副本。你会以你的系统上的任何编码方式得到这些字节。这个编码几乎肯定是UTF-16LE,但这是一个你不需要关心的实现细节。</target>
        </trans-unit>
        <trans-unit id="5ea82f427c53e42188bc1a0b6b4f0e4e4450be8c" translate="yes" xml:space="preserve">
          <source>This is a popular question. It is important to understand what the question author is asking, and that it is different from what is likely the most common need. To discourage misuse of the code where it is not needed, I've answered the later first.</source>
          <target state="translated">这是一个热门的问题。一定要弄清楚这个问题的作者问的是什么,和可能是最常见的需求不同。为了避免在不需要的地方误用,我先回答了后面的问题。</target>
        </trans-unit>
        <trans-unit id="4d255839cccd5531ecdc7b87cc97e8633d588bb1" translate="yes" xml:space="preserve">
          <source>This is because, as Tyler so aptly &lt;a href=&quot;https://chat.stackoverflow.com/transcript/message/39942929#39942929&quot;&gt;said&lt;/a&gt;, &quot;Strings aren't pure data. They also have &lt;a href=&quot;http://www.diffen.com/difference/Data_vs_Information&quot;&gt;information&lt;/a&gt;.&quot; In this case, the information is an encoding that was assumed when the string was created.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正如Tyler恰当地&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://chat.stackoverflow.com/transcript/message/39942929#39942929&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;说的那样&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是因为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;字符串不是纯数据。它们还具有&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.diffen.com/difference/Data_vs_Information&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;信息&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，该信息是创建字符串时假定的编码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1337785d661cc653a07caf296384461bb676e002" translate="yes" xml:space="preserve">
          <source>To do so, the compiler writes code skip over the other parts of the string object with &lt;code&gt;RuntimeHelpers.OffsetToStringData&lt;/code&gt;. So, to get the raw bytes, just create a pointer to the string and copy the number of bytes needed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为此，编译器使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;RuntimeHelpers.OffsetToStringData&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编写代码跳过字符串对象的其他部分&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，要获取原始字节，只需创建一个指向字符串的指针并复制所需的字节数即可。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c07a189f95468b3a4f60c069a1ab01d5692eb38" translate="yes" xml:space="preserve">
          <source>Try that with &lt;strong&gt;System.Text.Encoding.UTF8.GetBytes&lt;/strong&gt; or &lt;strong&gt;System.Text.Encoding.Unicode.GetBytes&lt;/strong&gt;, they will merely replace high surrogate characters with value &lt;strong&gt;fffd&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试使用&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Text.Encoding.UTF8.GetBytes&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Text.Encoding.Unicode.GetBytes&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它们只会将高替代字符替换为值&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;fffd&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82808995e973592a5d7502f8e8a62ff736880d72" translate="yes" xml:space="preserve">
          <source>Try this, a lot less code:</source>
          <target state="translated">试试这个,少了很多代码。</target>
        </trans-unit>
        <trans-unit id="2dbfa18abdc4b7e6d736fb2be782c7623df34609" translate="yes" xml:space="preserve">
          <source>Two ways:</source>
          <target state="translated">两种方式。</target>
        </trans-unit>
        <trans-unit id="588b58a71870cebadf8938b04931b4163a3550c5" translate="yes" xml:space="preserve">
          <source>Upon being asked what you intend to do with the bytes, you &lt;a href=&quot;https://stackoverflow.com/questions/472906/how-do-i-get-a-consistent-byte-representation-of-strings-in-c-sharp-without-manu?rq=1#comment290510_472906&quot;&gt;responded&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当被问及您打算如何处理这些字节时，您&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/472906/how-do-i-get-a-consistent-byte-representation-of-strings-in-c-sharp-without-manu?rq=1#comment290510_472906&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;回答&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="8b07402f794ee7869e95ec64ac9ed4c8891a44d9" translate="yes" xml:space="preserve">
          <source>Using an encoding could give you trouble if you have 'strings' with invalid characters, but that shouldn't happen.  If you are getting data into your string with invalid characters you are doing it wrong.  You should probably be using a byte array or a Base64 encoding to start with.</source>
          <target state="translated">如果你的 &quot;字符串 &quot;中含有无效字符,使用编码可能会给你带来麻烦,但这不应该发生。如果你的字符串中的数据是无效字符,那么你的做法是错误的。你可能应该使用字节数组或Base64编码来开始。</target>
        </trans-unit>
        <trans-unit id="df3c7f56193a6836b84188f6c0a85cf34be8d7fa" translate="yes" xml:space="preserve">
          <source>Utf8 is a popular encoding, it is compact and not lossy.</source>
          <target state="translated">Utf8是一种流行的编码,它结构紧凑,无损耗。</target>
        </trans-unit>
        <trans-unit id="64fb9099f037694f04e41f89d909bdd2f91661fe" translate="yes" xml:space="preserve">
          <source>Well, I've read all answers and they were about using encoding or one about serialization that drops unpaired surrogates.</source>
          <target state="translated">好吧,我看了所有的答案,他们都是关于使用编码的,或者说一个是关于序列化的,丢掉未配对的代用品。</target>
        </trans-unit>
        <trans-unit id="f5bcb3383297f0cc19ad735baf6986d6c50a4f49" translate="yes" xml:space="preserve">
          <source>What you want is each character's bytes in an array.  And that is where 'encoding' comes in.  By default you will get UTF-16LE.  If you don't care about the bytes themselves except for the round trip then you can choose any encoding including the 'default', and convert it back later (assuming the same parameters such as what the default encoding was, code points, bug fixes, things allowed such as unpaired surrogates, etc.</source>
          <target state="translated">你想要的是每个字符的字节在一个数组中。这就是 &quot;编码 &quot;的意义所在。默认情况下,你会得到UTF-16LE。如果你不关心字节本身,除了往返,你可以选择包括 &quot;默认 &quot;在内的任何编码,然后再将其转换回来(假设参数相同,如默认编码是什么,代码点,bug修复,允许的东西,如未配对的代名词等)。</target>
        </trans-unit>
        <trans-unit id="e128d2a9a6c10ff324ef1df3d88b4a6e7fcaf4be" translate="yes" xml:space="preserve">
          <source>Which brings me to the second part... picking the &lt;code&gt;Unicode&lt;/code&gt; encoding &lt;em&gt;&lt;strong&gt;is&lt;/strong&gt;&lt;/em&gt; telling .Net to use the underlying bytes. You do need to pick this encoding, because when some new-fangled Unicode-Plus comes out the .Net runtime needs to be free to use this newer, better encoding model without breaking your program. But, for the moment (and forseeable future), just choosing the Unicode encoding gives you what you want.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这使我进入第二部分...选择&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编码&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;告诉.Net使用基础字节。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您确实需要选择这种编码，因为当某些新型的Unicode-Plus出现时，.Net运行时需要自由使用此更新的，更好的编码模型而不会破坏程序。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，就目前而言（以及可预见的未来），仅选择Unicode编码即可满足您的需求。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e57c91c65751984e438caf6215b56c4aac63d4a2" translate="yes" xml:space="preserve">
          <source>Which means how a string is stored is irrelevant.  You want a string &quot;Encoded&quot; into bytes in a byte array.</source>
          <target state="translated">这意味着如何存储一个字符串是无关紧要的。你想把一个字符串 &quot;编码 &quot;成字节数组中的字节。</target>
        </trans-unit>
        <trans-unit id="5633e0314b2479ba38f1d9b3bdc10f132ecabdb7" translate="yes" xml:space="preserve">
          <source>With the advent of &lt;a href=&quot;https://github.com/dotnet/corefxlab/blob/master/docs/specs/span.md&quot;&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; released with C# 7.2, the canonical technique to capture the underlying memory representation of a string into a managed byte array is:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;随着&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C＃7.2发行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefxlab/blob/master/docs/specs/span.md&quot;&gt; &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的出现，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将字符串的基础内存表示捕获到托管字节数组中的规范技术是：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dea489a74815f747f40610f8c1ea45fb4f1113f4" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://stackoverflow.com/a/10380166/369792&quot;&gt;Mehrdad's answer&lt;/a&gt;, but it does actually use an encoding because chars are UTF-16.  It calls ToCharArray which looking at &lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/string.cs,d78d4544220d96be&quot;&gt;the source&lt;/a&gt; creates a &lt;code&gt;char[]&lt;/code&gt; and copies the memory to it directly.  Then it copies the data to a byte array that is also allocated.  So under the hood it is copying the underlying bytes &lt;em&gt;twice&lt;/em&gt; and allocating a char array that is not used after the call.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/10380166/369792&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mehrdad的answer&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但实际上使用的是编码，因为chars是UTF-16。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它调用ToCharArray，后者查看&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/string.cs,d78d4544220d96be&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;源代码&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;char[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并将内存直接复制到它。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后它将数据复制到也分配的字节数组中。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，在幕后它将复制基础字节&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两次，&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并分配一个在调用后未使用的char数组。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8bc23768b511b70873e76a6a0ac6639f7c5b9bfd" translate="yes" xml:space="preserve">
          <source>You can use following code to convert a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;byte array&lt;/code&gt; in .NET</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用以下代码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在.NET中将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;byte array&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ddb52534c12174eb56c30fd283e29b52e1f810e2" translate="yes" xml:space="preserve">
          <source>You can use the following code for conversion between string and byte array.</source>
          <target state="translated">你可以使用以下代码进行字符串和字节数组之间的转换。</target>
        </trans-unit>
        <trans-unit id="c0fb9dbcf124da24e60d780c2987c4af0aa8c923" translate="yes" xml:space="preserve">
          <source>You may &lt;em&gt;certainly&lt;/em&gt; choose to use UTF-16 directly if you find that your process performs significantly better since .NET uses it internally or for any other reason, but you need to choose that encoding explicitly and perform those conversions explicitly in your code rather than depending on .NET's internal implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果发现由于.NET内部使用它或出于任何其他原因而使该过程的性能明显好转，则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;肯定&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;选择直接使用UTF-16，但是您需要显式选择该编码并在代码中显式执行这些转换，而不是依赖于在.NET的内部实现中。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="045aa4e470db14da85abf8b4becab0c68d6e6753" translate="yes" xml:space="preserve">
          <source>You may need to communicate with a process implemented in a different language or runtime. (This might include a server running on another machine or sending the string to a JavaScript browser client, for example.)</source>
          <target state="translated">您可能需要与不同语言或运行时实现的进程进行通信。这可能包括在另一台机器上运行的服务器或将字符串发送到JavaScript浏览器客户端等)。</target>
        </trans-unit>
        <trans-unit id="4605a05b00cc5f119e23424e593675ac7ef459d2" translate="yes" xml:space="preserve">
          <source>You need to take the encoding into account, because 1 character could be represented by 1 &lt;strong&gt;or more&lt;/strong&gt; bytes (up to about 6), and different encodings will treat these bytes differently.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您需要考虑编码，因为1个字符可以由1个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或多个&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字节（最多约6个）表示，并且不同的编码将对这些字节进行不同的处理。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8080d01b7f4ec171f7f5a4fdb095a0253015283e" translate="yes" xml:space="preserve">
          <source>[For] an expression of type string, ... the initializer computes the
  address of the first character in the string.</source>
          <target state="translated">对于]字符串类型的表达式,.初始化器计算字符串中第一个字符的地址。</target>
        </trans-unit>
        <trans-unit id="5abad554f427cc892658b8d6a97b4d1dd5d837a3" translate="yes" xml:space="preserve">
          <source>take this example sample:</source>
          <target state="translated">以此为例。</target>
        </trans-unit>
        <trans-unit id="a940fdbe080bf3b406fffafd133dc5497c184ece" translate="yes" xml:space="preserve">
          <source>谢谢！</source>
          <target state="translated">谢谢！</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
