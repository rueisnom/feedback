<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/472906">
    <body>
      <group id="472906">
        <trans-unit id="12d92f20fd5e751242d08c35e9ec6ef2bc1ed3ed" translate="yes" xml:space="preserve">
          <source>(And, of course, to be able to re-construct the string from the bytes.)</source>
          <target state="translated">(И,конечно же,чтобы иметь возможность перестроить строку из байтов).</target>
        </trans-unit>
        <trans-unit id="1b083175a7952dbca89143ec8ab5b10ff3e5b645" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/20321003/369792&quot;&gt;Tom Blodget's answer&lt;/a&gt; is 20-30% faster than Mehrdad since it skips the intermediate step of allocating a char array and copying the bytes to it, but it requires you compile with the &lt;code&gt;/unsafe&lt;/code&gt; option.  If you absolutely do not want to use encoding, I think this is the way to go.  If you put your encryption login inside the &lt;code&gt;fixed&lt;/code&gt; block, you don't even need to allocate a separate byte array and copy the bytes to it.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/20321003/369792&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ответ Tom Blodget на&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 20-30% быстрее, чем Mehrdad, поскольку он пропускает промежуточный этап выделения массива char и копирования в него байтов, но требует компиляции с параметром &lt;/font&gt;&lt;/font&gt; &lt;code&gt;/unsafe&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы абсолютно не хотите использовать кодирование, я думаю, что это путь. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы поместите свой логин шифрования в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fixed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; блок, вам даже не нужно выделять отдельный байтовый массив и копировать в него байты.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cc41837abd0e977716c8c397fb8912ecd3dad4a2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Everybody else answered this incorrect question incorrectly.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Все остальные ответили на этот неправильный вопрос неправильно.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6e34be17e25bca5212b6d3a4de133c044184b5e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that working with &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; requires installing the &lt;a href=&quot;https://www.nuget.org/packages/System.Memory&quot;&gt;System.Memory NuGet package&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что для работы с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; требуется установить &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.nuget.org/packages/System.Memory&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;пакет System.Memory NuGet&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0561660ea53366c3d45e5997c890a23d70363f33" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;That's it for most usages. If that's what you need, stop reading here.&lt;/em&gt; See the fun &lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;Joel Spolsky article&lt;/a&gt; if you don't understand what an encoding is.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот и все для большинства случаев. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если это то, что вам нужно, перестаньте читать здесь. &lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Посмотрите забавную &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;статью Джоэла Спольски,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; если вы не понимаете, что такое кодировка.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b2c442146e3794ea28fbd8e2c26d8286d526de31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This is based off of OP's comment on his own question, and is the correct question if I understand OP's hints at the use-case.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это основано на комментариях ОП к его собственному вопросу, и это правильный вопрос, если я понимаю подсказки ОП на случай использования.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d94e738be3d4d982dfcf523fa657196119f8016f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;EDIT&lt;/em&gt;&lt;/strong&gt;
as Makotosan commented this is now the best way:</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;РЕДАКТИРОВАТЬ,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; как прокомментировал Макотосан, теперь это лучший способ:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d72a3384d26ca8c8484068b64b00feb648fab1b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fastest way&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Самый быстрый способ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dbce4e34dabf0c0683865f641afdcbbb63a8240" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In other words, you can't satisfy your requirement for &lt;em&gt;consistency&lt;/em&gt; without specifying an encoding.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другими словами, вы не можете удовлетворить свое требование &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;согласованности&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; без указания кодировки.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65a2d2a3d5e39c98144e466619dc430e70beec66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mehrdad's Answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ответ Мердада&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65c958e6dee00219a13d85ae2be8a1b4e028fd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tom Blodget's Answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ответ Тома Блоджетта&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3b434a03504320706540f9b87e55a1ef2cf97770" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.string(v=vs.110).aspx&quot;&gt;string&lt;/a&gt; in .NET represents text as a sequence of UTF-16 code units, so the bytes are encoded in memory in UTF-16 already.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.string(v=vs.110).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Строка&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в .NET представляет текст в виде последовательности UTF-16 единиц коды, так что &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;байты кодируются в памяти в UTF-16 уже.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8289079a63027bc7e05ffb27f563cbf920241334" translate="yes" xml:space="preserve">
          <source>A small sample why encoding matters:</source>
          <target state="translated">Небольшой пример того,почему кодировка имеет значение:</target>
        </trans-unit>
        <trans-unit id="11e8fd694a3cbe8d859770b79eb647edd463766b" translate="yes" xml:space="preserve">
          <source>A string (or more generically, a text) is composed of characters: letters, digits, and other symbols. That's all. Computers, however, do not know anything about characters; they can only handle bytes. Therefore, if you want to store or transmit text by using a computer, you need to transform the characters to bytes. How do you do that? Here's where encodings come to the scene.</source>
          <target state="translated">Строка (или,точнее,текст)состоит из символов:букв,цифр и других символов.Вот и все.Компьютеры,однако,ничего не знают о символах,они могут обрабатывать только байты.Поэтому,если вы хотите хранить или передавать текст с помощью компьютера,вам нужно преобразовывать символы в байты.Как это сделать? Вот где кодировки появляются на сцене.</target>
        </trans-unit>
        <trans-unit id="2fcf684bd3c5c93b2ec38730ad5c4cd5645524d5" translate="yes" xml:space="preserve">
          <source>ASCII simply isn't equipped to deal with special characters.</source>
          <target state="translated">ASCII просто не приспособлен для работы со специальными символами.</target>
        </trans-unit>
        <trans-unit id="e7f8396deba19ebd2f572fa25ad2f5b3de56be39" translate="yes" xml:space="preserve">
          <source>Additional benefit to this approach:</source>
          <target state="translated">Дополнительная польза от такого подхода:</target>
        </trans-unit>
        <trans-unit id="b566b8a5021ad88e51d3e4b7d5d612f040ec6ef2" translate="yes" xml:space="preserve">
          <source>Also please explain why encoding should be taken into consideration. 
  Can't I simply get what bytes the string has been stored in?
  Why this dependency on encoding?!!!</source>
          <target state="translated">Также,пожалуйста,объясните,почему кодировка должна быть принята во внимание.Неужели я не могу просто получить,в каких байтах хранилась строка? Почему эта зависимость от кодировки?!!!</target>
        </trans-unit>
        <trans-unit id="6760299d10ce0a958a61d6a1e2965454ce0a8fe8" translate="yes" xml:space="preserve">
          <source>Also, .NET supports non-Unicode encodings, but they are not valid in general case (will be valid only if a limited sub-set of Unicode code point is used in an actual string, such as ASCII). Internally, .NET supports UTF-16, but for stream representation, UTF-8 is usually used. It is also a standard-de-facto for Internet.</source>
          <target state="translated">Кроме того,.NET поддерживает неюникодные кодировки,но они не действительны в общем случае (будут действительны только в том случае,если в реальной строке,например,в ASCII,используется ограниченный поднабор точки кода Юникода).Внутренне .NET поддерживает UTF-16,но для потокового представления обычно используется UTF-8.Это также стандартный де-факто для Интернета.</target>
        </trans-unit>
        <trans-unit id="cc5e9f1684f7a373c58a842445dc80d4e34ca6a5" translate="yes" xml:space="preserve">
          <source>Also, why should encoding be taken into consideration? Can't I simply get what bytes the string has been stored in? Why is there a dependency on character encodings?</source>
          <target state="translated">Также,почему кодирование должно быть принято во внимание? Неужели я не могу просто получить,в каких байтах хранилась строка? Почему существует зависимость от кодировок символов?</target>
        </trans-unit>
        <trans-unit id="8d4da4f1fc049fae3a7cdccededfeee113ee8961" translate="yes" xml:space="preserve">
          <source>Also, why should encoding even be taken into consideration? Can't I simply get what bytes the string has been stored in? Why is there a dependency on character encodings?</source>
          <target state="translated">Кроме того,почему кодирование вообще должно приниматься во внимание? Неужели я не могу просто получить,в каких байтах хранилась строка? Почему существует зависимость от кодировок символов?</target>
        </trans-unit>
        <trans-unit id="7a7c26363aae04ff8b9358b236c2b8be81b4306c" translate="yes" xml:space="preserve">
          <source>An encoding is nothing but a convention to translate logical characters to physical bytes. The simplest and best known encoding is ASCII, and it is all you need if you write in English. For other languages you will need more complete encodings, being any of the Unicode flavours the safest choice nowadays.</source>
          <target state="translated">Кодирование-это не что иное,как соглашение о переводе логических символов в физические байты.Самая простая и известная кодировка-это ASCII,и это все,что вам нужно,если вы пишете на английском языке.Для других языков Вам понадобятся более полные кодировки,так как любой из кодировок Unicode в настоящее время является самым безопасным выбором.</target>
        </trans-unit>
        <trans-unit id="b199b85ba17f5afaf2627e750d478f49c4a52d52" translate="yes" xml:space="preserve">
          <source>And,</source>
          <target state="translated">And,</target>
        </trans-unit>
        <trans-unit id="213c6ee30ec5ff4710dd1ea02173a295d5b16230" translate="yes" xml:space="preserve">
          <source>As @CodesInChaos pointed out, the result depends on the endianness of the machine. But the question author is not concerned with that.</source>
          <target state="translated">Как отметил @CodesInChaos,результат зависит от эндианности машины.Но автора вопроса это не касается.</target>
        </trans-unit>
        <trans-unit id="6b35f831e0e676d7d7012d1fef6810df7de7eb5e" translate="yes" xml:space="preserve">
          <source>As long as your program (or other programs) don't try to &lt;em&gt;interpret&lt;/em&gt; the bytes somehow, which you obviously didn't mention you intend to do, then there is &lt;strong&gt;nothing&lt;/strong&gt; wrong with this approach! Worrying about encodings just makes your life more complicated for no real reason.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;До тех пор, пока ваша программа (или другие программы) не пытаются как-то &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;интерпретировать&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; байты, что вы явно не упомянули, что собираетесь делать, в этом нет &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ничего&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; плохого! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Беспокойство по поводу кодировок просто усложняет вашу жизнь без реальной причины.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e5453acc43479c51c2639631effba130305463cf" translate="yes" xml:space="preserve">
          <source>As you can see, it's also actually less code to just use the built in encoding objects than to implement your own reader/writer methods.</source>
          <target state="translated">Как видите,на самом деле просто использовать встроенные объекты кодирования-это еще и меньше кода,чем реализовывать собственные методы читателя.</target>
        </trans-unit>
        <trans-unit id="a2a9418ccf48ccffff57c0ec370bed125059d005" translate="yes" xml:space="preserve">
          <source>Assuming that you have binary data (rather than text) stored in a string</source>
          <target state="translated">Предположим,что у вас есть двоичные данные (а не текст),хранящиеся в строке</target>
        </trans-unit>
        <trans-unit id="e2888f72c3a469703d179f475e8ff340617f003a" translate="yes" xml:space="preserve">
          <source>Because that is the proper way to do it.  &lt;code&gt;string&lt;/code&gt; is an abstraction.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Потому что это правильный способ сделать это. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; это абстракция.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="76878448f83add9a0896a7c9661deaf0db7e1012" translate="yes" xml:space="preserve">
          <source>Because there is no such thing as &quot;the bytes of the string&quot;.</source>
          <target state="translated">Потому что нет такой вещи,как &quot;байты строки&quot;.</target>
        </trans-unit>
        <trans-unit id="764bdc9aac628b1989ecedd0ebe6bd5fc9fd62d5" translate="yes" xml:space="preserve">
          <source>But a conversion was used -- each character was placed into a fixed size box (c#'s character type).  However what that representation is does not matter, which is technically the answer to the OP.  So -- if you are going to convert anyway...  Why not 'encode'?</source>
          <target state="translated">Но использовалось преобразование-каждый символ помещался в поле фиксированного размера (тип символов c#).Однако,что это представление не имеет значения,что технически является ответом на ОП.Так что...если вы все равно собираетесь конвертировать...Почему бы не 'кодировать'?</target>
        </trans-unit>
        <trans-unit id="371c1ce2a6b5b66ba3cd7c90aa8ba5f29768c55f" translate="yes" xml:space="preserve">
          <source>But to avoid the mention of encodings, we must do it another way. If an intermediate data type is acceptable, there is a conceptual shortcut for this:</source>
          <target state="translated">Но чтобы избежать упоминания о кодировках,мы должны сделать это по-другому.Если промежуточный тип данных приемлем,то для этого существует концептуальный ярлык:</target>
        </trans-unit>
        <trans-unit id="a327eb37907ef9ea4fff97d2b6b447e5cd25a852" translate="yes" xml:space="preserve">
          <source>But why leave the 'encoding' up to magic?  Why not specify the encoding so that you know what bytes you are gonna get?</source>
          <target state="translated">Но зачем оставлять &quot;кодировку&quot; магии? Почему бы не указать кодировку,чтобы вы знали,какие байты вы получите?</target>
        </trans-unit>
        <trans-unit id="cc32ca8b2565c116d2b88180835165c1407fb460" translate="yes" xml:space="preserve">
          <source>By the way, I strongly recommend you (and anyone, for that matter) to read this small piece of wisdom: &lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кстати, я настоятельно рекомендую вам (и любому, в этом отношении) прочитать эту маленькую мудрость: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Абсолютный минимум, который должен быть у каждого разработчика программного обеспечения.&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1fc320f3254958f8d464eb376c3c1270c1e166c" translate="yes" xml:space="preserve">
          <source>C# to convert a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;byte&lt;/code&gt; array:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C # для преобразования &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;byte&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; массив:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e23fe8562b81064741b61938288b46879494182" translate="yes" xml:space="preserve">
          <source>Character and string processing in C# uses Unicode encoding. The char
  type represents a UTF-16 code unit, and the string type represents a
  sequence of UTF-16 code units.</source>
          <target state="translated">Обработка символов и строк в C#использует кодировку Unicode.Тип char представляет собой единицу кода UTF-16,а строковый тип-последовательность единиц кода UTF-16.</target>
        </trans-unit>
        <trans-unit id="e0ef3a4505bcbc6160c552b1ae785584813523bf" translate="yes" xml:space="preserve">
          <source>Clearly, conversions are not necessarily lossless!</source>
          <target state="translated">Очевидно,что преобразования не обязательно безубыточны!</target>
        </trans-unit>
        <trans-unit id="9cdff2e5bb172553c918c78b7b587dce154716c8" translate="yes" xml:space="preserve">
          <source>Common Need</source>
          <target state="translated">Общая потребность</target>
        </trans-unit>
        <trans-unit id="881db208cce3965e094f2bbcd67f87ac22ac59dd" translate="yes" xml:space="preserve">
          <source>Contrary to the answers here, you DON'T need to worry about encoding &lt;strong&gt;&lt;em&gt;if&lt;/em&gt;&lt;/strong&gt; the bytes don't need to be interpreted!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вопреки ответам здесь, вам не нужно беспокоиться о кодировании, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;если&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; байты не нужно интерпретировать!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="acaaab22b5cc002ed8b04f6496989a4e4704ec21" translate="yes" xml:space="preserve">
          <source>Converting it back should be a non-starter because that means you are in fact interpreting the data somehow, but for the sake of completeness:</source>
          <target state="translated">Преобразование его обратно должно быть не начинающимся,потому что это означает,что вы на самом деле интерпретируете данные каким-то образом,но ради полноты:</target>
        </trans-unit>
        <trans-unit id="f4d849313ccc4b84cee6efad70e46cb183c4e23c" translate="yes" xml:space="preserve">
          <source>Darn, Microsoft should have just used &lt;code&gt;System.Buffer.BlockCopy&lt;/code&gt; in its &lt;code&gt;BinaryFormatter&lt;/code&gt; ツ</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Черт, Microsoft должна была просто использовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Buffer.BlockCopy&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в своем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;BinaryFormatter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ツ&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b971e5d4bc6947d5c932095238f4bde4965ccf6f" translate="yes" xml:space="preserve">
          <source>Don't reinvent the wheel if you don't have to...</source>
          <target state="translated">Не изобретай колесо заново,если тебе не нужно...</target>
        </trans-unit>
        <trans-unit id="c973c91a278235b6dafdf98e8329894c72798190" translate="yes" xml:space="preserve">
          <source>Encoding (in this context) simply means the bytes that represent your string.  Not the bytes of the string object.  You wanted the bytes the string has been stored in -- this is where the question was asked naively.  You wanted the bytes of string in a contiguous array that represent the string, and not all of the other binary data that a string object may contain.</source>
          <target state="translated">Кодирование (в данном контексте)просто означает байты,которые представляют вашу строку.А не байты объекта строки.Вы хотели,чтобы байты,в которых хранится строка,--здесь вопрос задается наивно.Вы хотели,чтобы байты строки находились в смежном массиве,представляющем строку,а не все остальные двоичные данные,которые могут содержаться в строковом объекте.</target>
        </trans-unit>
        <trans-unit id="bec7c4514fe118c47315563dd5f6221c9508127e" translate="yes" xml:space="preserve">
          <source>Every string has a character set and encoding. When you convert a &lt;code&gt;System.String&lt;/code&gt; object to an array of &lt;code&gt;System.Byte&lt;/code&gt; you still have a character set and encoding. &lt;strong&gt;For most usages, you'd know which character set and encoding you need and .NET makes it simple to &quot;copy with conversion.&quot;&lt;/strong&gt; Just choose the appropriate &lt;code&gt;Encoding&lt;/code&gt; class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Каждая строка имеет набор символов и кодировку. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда вы конвертируете &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;объект &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в массив &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Byte&lt;/code&gt; ,у&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вас все еще есть набор символов и кодировка. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В большинстве случаев вы будете знать, какой набор символов и кодировки вам нужны, а .NET упрощает &amp;laquo;копирование с преобразованием&amp;raquo;. &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Просто выберите подходящий &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;класс &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Encoding&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ded830ec260ed22e3e81c4beb3d65d91f62df969" translate="yes" xml:space="preserve">
          <source>Every time there's a movement in this question, I'm still thinking of a serializer(be it from Microsoft or from 3rd party component) that can persist strings even it contains unpaired surrogate characters; I google this every now and then: &lt;strong&gt;serialization unpaired surrogate character .NET&lt;/strong&gt;. This doesn't make me lose any sleep, but it's kind of annoying when every  now and then there's somebody commenting on my answer that it's flawed, yet their answers are equally flawed when it comes to unpaired surrogate characters.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Каждый раз, когда в этом вопросе есть движение, я все еще думаю о сериализаторе (будь то от Microsoft или от стороннего компонента), который может сохранять строки, даже если он содержит непарные суррогатные символы; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я гуглю это время от времени: &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сериализация непарного суррогатного персонажа .NET&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это не заставляет меня терять сон, но это немного раздражает, когда время от времени кто-то комментирует мой ответ, что он некорректен, но его ответы одинаково несовершенны, когда речь идет о непарных суррогатных персонажах.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2cdfd3bc6caf4ac53a8acb2c2eaccd76c9103d74" translate="yes" xml:space="preserve">
          <source>First of all, the bytes used internally by the string class &lt;em&gt;don't matter&lt;/em&gt;, and whenever you assume they do you're likely introducing a bug.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Прежде всего, байты, используемые внутренне классом string, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не имеют значения&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , и всякий раз, когда вы предполагаете, что они это делают, вы, вероятно, вносите ошибку.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="53209f5e88f2cc4248bddf0e08037f0f42a3d105" translate="yes" xml:space="preserve">
          <source>For communicating (either with a completely disparate process or with the same program in the future), you need to define your protocol &lt;strong&gt;strictly&lt;/strong&gt; to minimize the difficulty of working with it or accidentally creating bugs. Depending on .NET's internal representation is not a strict, clear, or even guaranteed to be consistent definition. A standard encoding &lt;em&gt;is&lt;/em&gt; a strict definition that will not fail you in the future.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для связи (либо с совершенно разнородным процессом, либо с той же самой программой в будущем) вам необходимо &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;строго&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; определить свой протокол, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чтобы минимизировать сложность работы с ним или случайного создания ошибок. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В зависимости от внутреннего представления .NET не является строгим, четким или даже гарантированно согласованным определением. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Стандартная кодировка &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; это строгое определение, которое не подведет вас в будущем.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="2b90b113f177529b6709a0949dd9936fdea84ac2" translate="yes" xml:space="preserve">
          <source>For serialization to an array of bytes using &lt;code&gt;System.Text.Encoding.GetBytes&lt;/code&gt;. For the inverse operation use &lt;code&gt;System.Text.Encoding.GetChars&lt;/code&gt;. This function returns an array of characters, so to get a string, use a string constructor &lt;code&gt;System.String(char[])&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для сериализации в массив байтов используется &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.GetBytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для обратной операции используйте &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.GetChars&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эта функция возвращает массив символов, поэтому для получения строки используйте строковый конструктор &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.String(char[])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c720f9d5f4a088fed167ead31f5163d521731ff" translate="yes" xml:space="preserve">
          <source>For those goals, I honestly do &lt;em&gt;not&lt;/em&gt; understand why people keep telling you that you need the encodings. You certainly do NOT need to worry about encodings for this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для этих целей я, честно говоря, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; понимаю, почему люди продолжают говорить вам, что вам нужны кодировки. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вам, конечно, не нужно беспокоиться о кодировках для этого.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a799f5d20469b87cb2c5e22e877f21e629fcf803" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://www.microsoft.com/en-us/download/confirmation.aspx?id=7029&quot;&gt;C# spec&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Из &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.microsoft.com/en-us/download/confirmation.aspx?id=7029&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;спецификации C #&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="62e3e6ef5278c69c7f272b982a159c71a9219c05" translate="yes" xml:space="preserve">
          <source>He doesn't want any conversion.</source>
          <target state="translated">Он не хочет никаких превращений.</target>
        </trans-unit>
        <trans-unit id="74068d3f7ddc60086e084ec9ff97f9d04d593254" translate="yes" xml:space="preserve">
          <source>Here is my unsafe implementation of &lt;code&gt;String&lt;/code&gt; to &lt;code&gt;Byte[]&lt;/code&gt; conversion:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот моя небезопасная реализация &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;преобразования &lt;/font&gt;&lt;/font&gt; &lt;code&gt;String&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Byte[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79a31c95b719d1c0a03c21994345a7067dcbc970" translate="yes" xml:space="preserve">
          <source>How do I convert a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;byte[]&lt;/code&gt; in .NET (C#) without manually specifying a specific encoding?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как преобразовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;byte[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в .NET (C #) без указания конкретной кодировки вручную?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="250f9b487de8b4346798124d6f0272cb174fa03e" translate="yes" xml:space="preserve">
          <source>How do I convert a string to a byte[] in .NET (C#) without manually specifying a specific encoding?</source>
          <target state="translated">Как преобразовать строку в байт[]в .NET (C#)без ручного указания конкретной кодировки?</target>
        </trans-unit>
        <trans-unit id="8301aff1e0b7b5e543cf294e6d8e4a152d09b4e6" translate="yes" xml:space="preserve">
          <source>How do I get a consistent byte representation of strings in C# without manually specifying an encoding</source>
          <target state="translated">Как получить последовательное байтовое представление строк на C#без ручного указания кодировки</target>
        </trans-unit>
        <trans-unit id="308d05f72a533a6f046867579a0fd5bff9c1fc21" translate="yes" xml:space="preserve">
          <source>I like Tom Bloget's answer because he took you towards the 'bytes of the string object' direction.  It's implementation dependent though, and because he's peeking at internals it might be difficult to reconstitute a copy of the string.</source>
          <target state="translated">Мне нравится ответ Тома Блогета,потому что он направил вас в направлении &quot;байт строкового объекта&quot;.Однако,это зависит от реализации,и поскольку он подглядывает за внутренностями,может быть сложно воссоздать копию строки.</target>
        </trans-unit>
        <trans-unit id="11e1812469f5e52b2b356ac02b49b92bf948ca15" translate="yes" xml:space="preserve">
          <source>I tend to use the bottom one more often than the top, haven't benchmarked them for speed.</source>
          <target state="translated">Я склонен использовать нижнее чаще,чем верхнее,не проверил их на скорость.</target>
        </trans-unit>
        <trans-unit id="8b2de312e872be935e0a0767a85a7bcfb8861e8d" translate="yes" xml:space="preserve">
          <source>I think the question isn't why you want to worry about the encoding, but why you want to ignore it and use something else.  Encoding is meant to represent the abstraction of a string in a sequence of bytes.  &lt;code&gt;System.Text.Encoding.Unicode&lt;/code&gt; will give you a little endian byte order encoding and will perform the same on every system, now and in the future.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я думаю, вопрос не в том, почему вы хотите беспокоиться о кодировке, а в том, почему вы хотите игнорировать ее и использовать что-то еще. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кодирование предназначено для представления абстракции строки в последовательности байтов. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; предоставит вам немного порядковый порядок байтов и будет выполнять то же самое в каждой системе, сейчас и в будущем.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d5ba1f23cbb7de00b3499a5d3c1fa2891c35976c" translate="yes" xml:space="preserve">
          <source>I understand that in this case you might prefer to use the actual bytes stored by the string variable in memory where possible, with the idea that it might save some work creating your byte stream. However, I put it to you it's just not important compared to making sure that your output is understood at the other end, and to guarantee that you &lt;em&gt;must&lt;/em&gt; be explicit with your encoding. Additionally, if you really want to match your internal bytes, you can already just choose the &lt;code&gt;Unicode&lt;/code&gt; encoding, and get that performance savings.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я понимаю, что в этом случае вы могли бы предпочесть использовать фактические байты, сохраненные строковой переменной в памяти, где это возможно, с идеей, что это может сэкономить некоторую работу, создавая ваш поток байтов. Тем не менее, я говорю вам, что это просто не важно по сравнению с тем, чтобы убедиться, что ваш вывод понят на другом конце, и чтобы гарантировать, что вы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;должны&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; четко указывать свою кодировку. Кроме того, если вы действительно хотите сопоставить свои внутренние байты, вы уже можете просто выбрать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;кодировку &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и получить это снижение производительности.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0a68547f8105b8c321a012db5592c9dfa6f86747" translate="yes" xml:space="preserve">
          <source>I will address your follow-up question: why do you need to pick an encoding?  Why can't you get that from the string class itself?</source>
          <target state="translated">Я отвечу на ваш последующий вопрос:зачем вам нужно выбирать кодировку? Почему вы не можете получить это из самого класса строк?</target>
        </trans-unit>
        <trans-unit id="7ada9517ee500634d2ed6a36e13993710ad8ab90" translate="yes" xml:space="preserve">
          <source>I'm going to encrypt it. I can encrypt it without converting but I'd still like to know why encoding comes to play here. Just give me the bytes is what I say.</source>
          <target state="translated">Я собираюсь зашифровать его.Я могу зашифровать его,не конвертируя,но мне все равно хотелось бы знать,почему кодирование приходит сюда.Просто дайте мне байты,вот что я скажу.</target>
        </trans-unit>
        <trans-unit id="23328b8b90fc8391e6977f267afdb4987dce99f3" translate="yes" xml:space="preserve">
          <source>I'm going to encrypt the string. I can encrypt it without converting, but I'd still like to know why encoding comes to play here.</source>
          <target state="translated">Я собираюсь зашифровать строку.Я могу зашифровать ее,не конвертируя,но мне все равно хотелось бы знать,почему кодирование приходит сюда.</target>
        </trans-unit>
        <trans-unit id="73edba52ee6a28a24523945beee302c70085419a" translate="yes" xml:space="preserve">
          <source>I'm not sure, but I think the string stores its info as an array of Chars, which is inefficient with bytes.  Specifically, the definition of a Char is &quot;Represents a Unicode character&quot;.</source>
          <target state="translated">Я не уверен,но думаю,что строка хранит свою информацию в виде массива Chars,который неэффективен с байтами.В частности,определение Char-&quot;Представляет символ Юникода&quot;.</target>
        </trans-unit>
        <trans-unit id="c4312324dd22deb5211f29d42de3f21cb51b940c" translate="yes" xml:space="preserve">
          <source>I've changed my mind about this (Mehrdad's solution) -- this isn't getting the bytes of the string; rather it is getting the bytes of the character array that was created from the string.  Regardless of encoding, the char datatype in c# is a fixed size.  This allows a consistent length byte array to be produced, and it allows the character array to be reproduced based on the size of the byte array.  So if the encoding were UTF-8, but each char was 6 bytes to accommodate the largest utf8 value, it would still work.  So indeed -- encoding of the character does not matter.</source>
          <target state="translated">Я передумал (решение Мехрдада)-это не получение байтов строки,а получение байтов символьного массива,который был создан из строки.Независимо от кодировки,тип данных char в c#имеет фиксированный размер.Это позволяет создавать массив байтов постоянной длины,а также воспроизводить символьный массив в зависимости от размера массива байтов.Таким образом,если бы кодировка была UTF-8,но каждый символ char имел бы 6 байт для наибольшего значения utf8,то это все равно работало бы.Так что на самом деле --кодировка символа не имеет значения.</target>
        </trans-unit>
        <trans-unit id="8f987a9391d67ecbc6f5e57e1eba7f6b2a903207" translate="yes" xml:space="preserve">
          <source>If the string looks good as-is, just pick an encoding (preferably one starting with UTF), use the corresponding &lt;code&gt;System.Text.Encoding.???.GetBytes()&lt;/code&gt; function, and tell whoever you give the bytes to which encoding you picked.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если строка выглядит хорошо, как есть, просто выберите кодировку (желательно, начинающуюся с UTF), используйте соответствующую &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функцию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.???.GetBytes()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и скажите, кому бы вы ни дали байты, для которой вы кодируете выбрал.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8014e7bced1ca056331e4021f470ccb6ec78153c" translate="yes" xml:space="preserve">
          <source>If you have a text string with an unknown encoding</source>
          <target state="translated">Если у вас есть текстовая строка с неизвестной кодировкой</target>
        </trans-unit>
        <trans-unit id="cdf6921da828ca4a35976570bed2c1d0683ef413" translate="yes" xml:space="preserve">
          <source>If you really want a copy of the underlying bytes of a string, you can use a function like the one that follows. &lt;strong&gt;However, you shouldn't&lt;/strong&gt; please read on to find out why.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вам действительно нужна копия нижележащих байтов строки, вы можете использовать функцию, подобную следующей. &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тем не менее, вы не должны&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; читать дальше, чтобы узнать, почему.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fe3e3532bc4f8d47ac6709111f975fd91357eeb0" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;System.Text.Encoding.Unicode&lt;/code&gt;, your code will be more resilient.  You don't have to worry about the &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;endianness&lt;/a&gt; of the system your code will be running on.  You don't need to worry if the next version of the CLR will use a different internal character encoding.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы используете &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , ваш код будет более устойчивым. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вам не нужно беспокоиться о &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;порядке&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; работы системы, в которой будет выполняться ваш код. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вам не нужно беспокоиться, если в следующей версии CLR будет использоваться другая внутренняя кодировка символов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a7842bf159130826080a10125e8894356cfd6a7" translate="yes" xml:space="preserve">
          <source>If you used a specific encoding, though, it would've given you trouble with encoding/decoding invalid characters.</source>
          <target state="translated">Однако,если бы вы использовали определенную кодировку,это привело бы к проблемам с кодировкой недействительных символов.</target>
        </trans-unit>
        <trans-unit id="33b0321053b92b4fa0428632fbfc0415818cf893" translate="yes" xml:space="preserve">
          <source>If your program is entirely within the .Net world then you don't need to worry about getting byte arrays for strings at all, even if you're sending data across a network. Instead, use .Net Serialization to worry about transmitting the data.  You don't worry about the actual bytes any more: the Serialization formatter does it for you.</source>
          <target state="translated">Если ваша программа полностью находится в мире .Net,то вам вообще не нужно беспокоиться о получении массивов байт для строк,даже если вы посылаете данные по сети.Вместо этого используйте сериализацию .Net,чтобы беспокоиться о передаче данных.Вы больше не беспокоитесь о действительных байтах:форматер сериализации делает это за вас.</target>
        </trans-unit>
        <trans-unit id="b55572a251031f38f43e0ce27cb2550dfd157131" translate="yes" xml:space="preserve">
          <source>In all likelihood this will give the same result, is easier to type, and the bytes will always round-trip with a call to</source>
          <target state="translated">По всей вероятности,это даст один и тот же результат,проще набирать,а байты всегда будут обходить с вызовом на</target>
        </trans-unit>
        <trans-unit id="54278cf74b906f55d3e2e4e2f5f2899e105de098" translate="yes" xml:space="preserve">
          <source>In order to use it, you have to tick &quot;Allow Unsafe Code&quot; in your project build properties.
As per .NET Framework 3.5, this method can also be used as String extension:</source>
          <target state="translated">Для того,чтобы использовать его,необходимо отметить галочкой &quot;Allow Unsafe Code&quot; в свойствах сборки вашего проекта.Согласно .NET Framework 3.5,этот метод также может быть использован в качестве расширения String:</target>
        </trans-unit>
        <trans-unit id="e315a35ab8b323b6f1b71f706b5abe5be3682bdb" translate="yes" xml:space="preserve">
          <source>Internally, the .NET framework uses &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-16&quot;&gt;UTF-16&lt;/a&gt; to represent strings, so if you simply want to get the exact bytes that .NET uses, use &lt;code&gt;System.Text.Encoding.Unicode.GetBytes (...)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Внутри .NET Framework использует &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-16&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;UTF-16&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для представления строк, поэтому, если вы просто хотите получить точные байты, которые использует .NET, используйте &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.Unicode.GetBytes (...)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="253d98cd0ff94b324089dd103360170318602987" translate="yes" xml:space="preserve">
          <source>It depends on the encoding of your string (&lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;, ...).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это зависит от кодировки вашей строки ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ASCII&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-8&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;UTF-8&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , ...).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb8673fc3c3b53f57ce77c997e1a1de179fe1ace" translate="yes" xml:space="preserve">
          <source>It depends on what you want the bytes FOR</source>
          <target state="translated">Зависит от того,какие байты вы хотите получить.</target>
        </trans-unit>
        <trans-unit id="fafdca4a7238f02b1bcabb06d745312e84100bb3" translate="yes" xml:space="preserve">
          <source>It doesn't matter if the string contains invalid characters, because you can still get the data and reconstruct the original string anyway!</source>
          <target state="translated">Не имеет значения,содержит ли строка недопустимые символы,потому что вы все равно можете получить данные и восстановить исходную строку в любом случае!</target>
        </trans-unit>
        <trans-unit id="3743f646e71bbbf4f2fa8d2a8a992c94db7d0419" translate="yes" xml:space="preserve">
          <source>It will be encoded and decoded just the same, because you are &lt;em&gt;just looking at the bytes&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он будет закодирован и декодирован точно так же, потому что вы &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;просто смотрите на байты&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50ef6f8b46c2a72a4edd3727490c28fa9ad5b914" translate="yes" xml:space="preserve">
          <source>It would be &lt;strong&gt;safer, simpler and more reliable&lt;/strong&gt; to just call,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Было бы &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;безопаснее, проще и надежнее&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; просто позвонить,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="09a9d3269261d67410064802503de606e111f4eb" translate="yes" xml:space="preserve">
          <source>It's also important to understand your string has to be re-written to wire, and that involves at least some translation of the bit-pattern &lt;em&gt;even when you use a matching encoding&lt;/em&gt;. The computer needs to account for things like Big vs Little Endian, network byte order, packetization, session information, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Также важно понимать, что ваша строка должна быть перезаписана на провод, и это предполагает, по крайней мере, некоторый перевод битового шаблона, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;даже если вы используете соответствующую кодировку&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Компьютер должен учитывать такие вещи, как Big против Little Endian, порядок байтов в сети, пакетирование, информация о сеансе и т. Д.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18a23e217bf26b95123358b0c912f11ad4a34af7" translate="yes" xml:space="preserve">
          <source>It's bad when the string, for example, comes from &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;SQL Server&lt;/a&gt; where it was built from a byte array storing, for example, a password hash. If we drop anything from it, it'll store an invalid hash, and if we want to store it in XML, we want to leave it intact (because the XML writer drops an exception on any unpaired surrogate it finds).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Плохо, когда строка, например, исходит от &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; где она была построена из байтового массива, например, хэша пароля. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если мы отбросим что-либо из него, он сохранит недопустимый хеш, а если мы хотим сохранить его в XML, мы хотим оставить его нетронутым (поскольку средство записи XML удаляет исключение для любого найденного непарного суррогата).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0239ce0f340ef86dd3fc996e2af2070445e8cde7" translate="yes" xml:space="preserve">
          <source>It's way faster than the accepted anwser's one, even if not as elegant as it is.
Here are my Stopwatch benchmarks over 10000000 iterations:</source>
          <target state="translated">Это намного быстрее,чем общепринятый эпосер,пусть даже и не такой элегантный,как он есть.Вот мои секундомеры с более чем 10000000 итерациями:</target>
        </trans-unit>
        <trans-unit id="b45885d736c4aeff1a446b8c7294826b2f0d7bd9" translate="yes" xml:space="preserve">
          <source>Joel has a posting on this:</source>
          <target state="translated">У Джоэла есть объявление об этом:</target>
        </trans-unit>
        <trans-unit id="d8c62c907006f766a6556ba8b07bf4c5573e8c16" translate="yes" xml:space="preserve">
          <source>Just do this instead:</source>
          <target state="translated">Просто сделай это вместо этого:</target>
        </trans-unit>
        <trans-unit id="be726ed35a3333ee7f9a2e2916e7384715f4e1e9" translate="yes" xml:space="preserve">
          <source>Just to demonstrate that Mehrdrad's sound &lt;a href=&quot;https://stackoverflow.com/a/10380166&quot;&gt;answer&lt;/a&gt; works, his approach can even persist the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter%28v=VS.100%29.aspx&quot;&gt;unpaired surrogate characters&lt;/a&gt;(of which many had leveled against my answer, but of which everyone are equally guilty of, e.g. &lt;code&gt;System.Text.Encoding.UTF8.GetBytes&lt;/code&gt;, &lt;code&gt;System.Text.Encoding.Unicode.GetBytes&lt;/code&gt;; those encoding methods can't persist the high surrogate characters &lt;code&gt;d800&lt;/code&gt; for example, and those just merely replace high surrogate characters with value &lt;code&gt;fffd&lt;/code&gt; ) :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Просто чтобы продемонстрировать, что звуковой &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/10380166&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ответ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Мердрада &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;работает, его подход может даже сохранить &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter%28v=VS.100%29.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;непарные суррогатные символы&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (из которых многие выровнялись против моего ответа, но в которых все одинаково виновны, например, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.UTF8.GetBytes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding.Unicode.GetBytes&lt;/code&gt; ,например&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , эти методы кодирования не могут сохранять старшие суррогатные символы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;d800&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , а просто заменяют старшие суррогатные символы значением &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fffd&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2ef24e2af226a4311be29d5b5c4456ee7bfbcc3d" translate="yes" xml:space="preserve">
          <source>Like you mentioned, your goal is, simply, to &lt;em&gt;&quot;get what bytes the string has been stored in&quot;&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как вы упомянули, ваша цель - просто &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;получить, в каких байтах хранится строка&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="62dc42908d3fb01c4805c4e57a1a0b5db12b9b8c" translate="yes" xml:space="preserve">
          <source>Mehrdad's response is wrong because it is misleading at the conceptual level.  You still have a list of bytes, encoded.  His particular solution allows for unpaired surrogates to be preserved -- this is implementation dependent.  His particular solution would not produce the string's bytes accurately if &lt;code&gt;GetBytes&lt;/code&gt; returned the string in UTF-8 by default.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Реакция Мердада неверна, потому что вводит в заблуждение на концептуальном уровне. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;У вас все еще есть список байтов, закодированный. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Его конкретное решение позволяет сохранить непарные суррогаты - это зависит от реализации. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Его конкретное решение не будет точно генерировать байты строки, если &lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetBytes&lt;/code&gt; вернет&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; строку в UTF-8 по умолчанию.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="47a99c1d5eff545ce3518be595bcbc8cb9d65801" translate="yes" xml:space="preserve">
          <source>Not surprisingly, serialization of string into an array of byte and deserialization is supported by the class &lt;code&gt;System.Text.Encoding&lt;/code&gt;, which is an abstract class; its derived classes support concrete encodings: &lt;code&gt;ASCIIEncoding&lt;/code&gt; and four UTFs (&lt;code&gt;System.Text.UnicodeEncoding&lt;/code&gt; supports UTF-16)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Неудивительно, что сериализация строки в массив байтов и десериализация поддерживается классом &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , который является абстрактным классом; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;его производные классы поддерживают конкретные кодировки: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ASCIIEncoding&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и четыре UTF ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.UnicodeEncoding&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; поддерживает UTF-16)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb2eccf7017a0105eeeb7f202ea5e630dc101c72" translate="yes" xml:space="preserve">
          <source>Note: For &lt;code&gt;System.String&lt;/code&gt; the source character set is Unicode.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примечание. Для &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.String&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; исходным набором символов является Unicode.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d7effc002b8ac571412ec3d546c04ee79313d1c8" translate="yes" xml:space="preserve">
          <source>Now, the question author asks, &quot;Every string is stored as an array of bytes, right? Why can't I simply have those bytes?&quot;</source>
          <target state="translated">Теперь автор вопроса задает вопрос:&quot;Каждая строка хранится в виде массива байт,верно? Почему я не могу просто иметь эти байты?&quot;</target>
        </trans-unit>
        <trans-unit id="255b8f55679083ebaad714d1ab2eec76c35e7fad" translate="yes" xml:space="preserve">
          <source>On the other hand, what if you are sending these bytes somewhere that you can't guarantee will pull in data from a .Net serialized stream? In this case you definitely do need to worry about encoding, because obviously this external system cares. So again, the internal bytes used by the string don't matter: you need to pick an encoding so you can be explicit about this encoding on the receiving end, even if it's the same encoding used internally by .Net.</source>
          <target state="translated">С другой стороны,что если вы посылаете эти байты куда-нибудь,где вы не можете гарантировать,что они будут втягивать данные из сериализованного потока .Net? В этом случае вам определенно нужно беспокоиться о кодировке,потому что очевидно,что эта внешняя система заботится об этом.Так что опять же,внутренние байты,используемые строкой,не имеют значения:вам нужно выбрать кодировку,чтобы вы могли ясно выразить эту кодировку на принимающей стороне,даже если это та же самая кодировка,которая используется внутри .Net.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="02f510b0a4e3557ce2149e475e6e82014f8ef252" translate="yes" xml:space="preserve">
          <source>Ref &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx&quot;&gt;this link.&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ссылка на &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;эту ссылку&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="363506df10662d63102d4ce4295ee324d6a6c259" translate="yes" xml:space="preserve">
          <source>Ref this page.</source>
          <target state="translated">Ссылка на эту страницу.</target>
        </trans-unit>
        <trans-unit id="9b1479ef7d39111457b3930a7066c6d6b6370503" translate="yes" xml:space="preserve">
          <source>Regardless of whether you intend to send this encrypted data over the network, load it back into memory later, or steam it to another process, you are clearly intending to &lt;em&gt;decrypt&lt;/em&gt; it at some point. In that case, the answer is that you're defining a communication protocol. A communication protocol should not be &lt;strong&gt;defined&lt;/strong&gt; in terms of implementation details of your programming language and its associated runtime. There are several reasons for this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Независимо от того, намереваетесь ли вы отправить эти зашифрованные данные по сети, позже загрузить их обратно в память или передать их другому процессу, вы явно собираетесь &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в какой-то момент &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;расшифровать&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; их. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этом случае ответ таков: вы определяете протокол связи. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Протокол связи не должен быть &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;определен&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с точки зрения деталей реализации вашего языка программирования и связанных с ним времени выполнения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На это есть несколько причин:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c036f48a13443ce781fbbab689cd7f571a952014" translate="yes" xml:space="preserve">
          <source>Regardless, the &lt;em&gt;actual&lt;/em&gt; original question and follow-up comments imply that the underlying memory is not being &quot;interpreted&quot; (which I assume means is not modified or read beyond the need to write it as-is), indicating that some implementation of the &lt;code&gt;Stream&lt;/code&gt; class should be used instead of reasoning about the data as strings at all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Несмотря на это, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;фактический&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; исходный вопрос и последующие комментарии подразумевают, что базовая память не &amp;laquo;интерпретируется&amp;raquo; (что, как я полагаю, означает, что она не изменена и не считана за исключением необходимости записывать ее как есть), что указывает на некоторую реализацию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Stream&lt;/code&gt; .&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; класс должен использоваться вместо рассуждения о данных как о строках вообще.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4546e7c2b857f3ab3a6eb87dffcf458ab7496382" translate="yes" xml:space="preserve">
          <source>See &lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms404377.aspx&quot;&gt;Character Encoding in the .NET Framework&lt;/a&gt;&lt;/em&gt; (MSDN) for more information.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;См. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms404377.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кодировка символов в .NET Framework&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (MSDN) для получения дополнительной информации.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9dc63bb2af5cd1e369af72f5dacfe14b82975a3c" translate="yes" xml:space="preserve">
          <source>Simply use this:</source>
          <target state="translated">Просто используй это:</target>
        </trans-unit>
        <trans-unit id="6398f1a61d94c7b892f9d1ef44bbd28dcd1bc9e1" translate="yes" xml:space="preserve">
          <source>So I use &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64&quot;&gt;Base64&lt;/a&gt; encoding of byte arrays in such cases, but hey, on the Internet there is only one solution to this in C#, and it has bug in it and is only one way, so I've fixed the bug and written back procedure. Here you are, future googlers:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в таких случаях &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;я использую &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;кодирование байтовых массивов &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Base64&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Base64&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но, эй, в Интернете есть только одно решение этой проблемы в C #, в котором есть ошибка и есть только один способ, поэтому я исправил ошибку и переписал процедура. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот вы, будущие гуглеры:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16fff7be164e3bccb0802acb8c0d4081298aa180" translate="yes" xml:space="preserve">
          <source>So choose an encoding and use it:</source>
          <target state="translated">Так что выбирайте кодировку и используйте ее:</target>
        </trans-unit>
        <trans-unit id="09ef2b0fdbe15cea061bf191e6b890a4d195162a" translate="yes" xml:space="preserve">
          <source>So if you just want the bytes used by the string, simply use &lt;code&gt;Encoding.Unicode&lt;/code&gt;, but it will be inefficient with storage space.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому, если вы просто хотите, чтобы байты использовались строкой, просто используйте &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Encoding.Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но это будет неэффективно с пространством хранения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="11d1d1615bd28a9785dd7a854fb672407bfb0899" translate="yes" xml:space="preserve">
          <source>So, in short, trying to &quot;get the bytes of a string without using encodings&quot; is as impossible as &quot;writing a text without using any language&quot;.</source>
          <target state="translated">Короче говоря,попытка &quot;получить байты строки без использования кодировок&quot; так же невозможна,как и &quot;написание текста без использования какого-либо языка&quot;.</target>
        </trans-unit>
        <trans-unit id="0536e7418ee1a23db7d0d7a3f544577523ad1d88" translate="yes" xml:space="preserve">
          <source>So, we know that if we ask for the null conversion (i.e., from UTF-16 to UTF-16), we'll get the desired result:</source>
          <target state="translated">Итак,мы знаем,что если попросить нулевое преобразование (т.е.из UTF-16 в UTF-16),то получим желаемый результат:</target>
        </trans-unit>
        <trans-unit id="baf3176971ea9ba7658a410ad325a9b5e5b59932" translate="yes" xml:space="preserve">
          <source>Specific Need</source>
          <target state="translated">Особая потребность</target>
        </trans-unit>
        <trans-unit id="d9851fedd08659ff8d8e4a81bd30b71762cdf523" translate="yes" xml:space="preserve">
          <source>Storing binary data in strings is probably the wrong approach because of the assumed encoding mentioned above! Whatever program or library stored that binary data in a &lt;code&gt;string&lt;/code&gt; (instead of a &lt;code&gt;byte[]&lt;/code&gt; array which would have been more appropriate) has already lost the battle before it has begun. If they are sending the bytes to you in a REST request/response or anything that &lt;em&gt;must&lt;/em&gt; transmit strings, &lt;a href=&quot;https://stackoverflow.com/q/201479/1739000&quot;&gt;Base64&lt;/a&gt; would be the right approach.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хранение двоичных данных в строках, вероятно, является неправильным подходом из-за предполагаемой кодировки, упомянутой выше! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Какая бы программа или библиотека не хранила эти двоичные данные в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (вместо &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;массива &lt;/font&gt;&lt;/font&gt; &lt;code&gt;byte[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; который был бы более подходящим), уже проиграл битву до ее начала. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если они отправляют вам байты в виде запроса / ответа REST или чего-либо, что &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;должно&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; передавать строки, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/q/201479/1739000&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Base64&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет правильным подходом.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f536b71e266ca742599e9e431ae560474b99326f" translate="yes" xml:space="preserve">
          <source>Sure, but that's where the fundamental error in the question arises.  The String is an object which could have an interesting data structure.  We already know it does, because it allows unpaired surrogates to be stored.  It might store the length.  It might keep a pointer to each of the 'paired' surrogates allowing quick counting.  Etc.  All of these extra bytes are not part of the character data.</source>
          <target state="translated">Конечно,но именно здесь возникает фундаментальная ошибка в вопросе.Строка-это объект,который может иметь интересную структуру данных.Мы уже знаем,что она есть,потому что позволяет хранить непарные суррогаты.В ней может храниться длина.Он может хранить указатель на каждый из &quot;парных&quot; суррогатов,позволяя быстро считать.И т.д.Все эти дополнительные байты не являются частью символьных данных.</target>
        </trans-unit>
        <trans-unit id="5dbed11d9742fd76bd5a609ed5392a7eb7b65fac" translate="yes" xml:space="preserve">
          <source>Take note that the Unicode answer is 14 bytes in both instances, whereas the UTF-8 answer is only 9 bytes for the first, and only 7 for the second.</source>
          <target state="translated">Обратите внимание,что в обоих случаях ответ в кодировке Unicode равен 14 байтам,в то время как ответ в кодировке UTF-8-только 9 байтам для первого и только 7-для второго.</target>
        </trans-unit>
        <trans-unit id="b3d1691b90f3f3216a25d44b87d676d4186487c4" translate="yes" xml:space="preserve">
          <source>That doesn't get us the desired datatype but &lt;a href=&quot;https://stackoverflow.com/a/10380166/2226988&quot;&gt;Mehrdad's answer&lt;/a&gt; shows how to convert this Char array to a Byte array using &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.buffer.blockcopy%28v=vs.110%29.aspx&quot;&gt;BlockCopy&lt;/a&gt;. However, this copies the string twice! And, it too explicitly uses encoding-specific code: the datatype &lt;code&gt;System.Char&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это не дает нам желаемый тип данных, но &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/10380166/2226988&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ответ &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.buffer.blockcopy%28v=vs.110%29.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мердада&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; показывает, как преобразовать этот массив Char в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;байтовый&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; массив с помощью &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BlockCopy&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тем не менее, это копирует строку дважды! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И он слишком явно использует специфичный для кодирования код: тип данных &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Char&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54f180522aa90faa6b00e1d77c13baec981d8974" translate="yes" xml:space="preserve">
          <source>The .NET implementation might change the internal representation of strings. You may think this sounds farfetched, but this &lt;a href=&quot;https://www.vojtechruzicka.com/java-9-compact-strings/&quot;&gt;actually happened in Java 9&lt;/a&gt; to reduce memory usage. There's no reason .NET couldn't follow suit. &lt;a href=&quot;https://stackoverflow.com/a/14942142/1394393&quot;&gt;Skeet suggests&lt;/a&gt; that UTF-16 probably isn't optimal today give the rise of the emoji and other blocks of Unicode needing more than 2 bytes to represent as well, increasing the likelihood that the internal representation could change in the future.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Реализация .NET может изменить внутреннее представление строк. Вы можете подумать, что это звучит неправдоподобно, но на &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.vojtechruzicka.com/java-9-compact-strings/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;самом деле это произошло в Java 9,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чтобы уменьшить использование памяти. Нет причин .NET не может последовать их примеру. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/14942142/1394393&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Скит полагает,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; что UTF-16 сегодня, вероятно, не оптимален, что приводит к появлению эмодзи и других блоков Юникода, для представления которых требуется более 2 байтов, что увеличивает вероятность того, что внутреннее представление может измениться в будущем.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac99e747a72258da36ac97be7a7d101d33946faf" translate="yes" xml:space="preserve">
          <source>The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</source>
          <target state="translated">Абсолютный минимум Каждый разработчик программного обеспечения должен знать о юникоде и наборах символов (без оправданий!).</target>
        </trans-unit>
        <trans-unit id="efd69fe7ce3c17569af8c335e4a585e33812e409" translate="yes" xml:space="preserve">
          <source>The accepted answer is very, very complicated. Use the included .NET classes for this:</source>
          <target state="translated">Принятый ответ очень,очень сложный.Для этого используйте включенные .NET классы:</target>
        </trans-unit>
        <trans-unit id="e6447751f9c76dc2e9beb74a23a15045eb7a43a4" translate="yes" xml:space="preserve">
          <source>The answer is in two parts.</source>
          <target state="translated">Ответ состоит из двух частей.</target>
        </trans-unit>
        <trans-unit id="269e8cc0b61186d659e16fbf5f0486750f2105c8" translate="yes" xml:space="preserve">
          <source>The closest approach to the OP's question is Tom Blodget's, which actually goes into the object and extracts the bytes.  I say closest because it depends on implementation of the String Object.</source>
          <target state="translated">Наиболее близкий подход к вопросу ОП-это вопрос Тома Блоджета (Tom Blodget),который на самом деле входит в объект и извлекает байты.Я говорю &quot;ближайший&quot;,потому что это зависит от реализации строкового объекта.</target>
        </trans-unit>
        <trans-unit id="73514cd23fc4d868ca20e8a713f1a79185a82b12" translate="yes" xml:space="preserve">
          <source>The conversion may need to handle cases where the target character set or encoding doesn't support a character that's in the source. You have some choices: exception, substitution or skipping. The default policy is to substitute a '?'.</source>
          <target state="translated">Преобразование может потребоваться для обработки случаев,когда целевой набор символов или кодировка не поддерживает символ,который находится в исходном коде.У вас есть несколько вариантов:исключение,подстановка или пропуск.Политикой по умолчанию является подстановка символа '?'.</target>
        </trans-unit>
        <trans-unit id="3d56114e252ccdf8c1990a643ceb4bcb8856f666" translate="yes" xml:space="preserve">
          <source>The first part of your question (how to get the bytes) was already answered by others: look in the &lt;code&gt;System.Text.Encoding&lt;/code&gt; namespace.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На первую часть вашего вопроса (как получить байты) уже отвечали другие: посмотрите в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;пространство имен &lt;/font&gt;&lt;/font&gt; &lt;code&gt;System.Text.Encoding&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="730a097f3e85ebdd613402d589b73704722141bb" translate="yes" xml:space="preserve">
          <source>The key issue is that a glyph in a string takes 32 bits (16 bits for a character code) but a byte only has 8 bits to spare.  A one-to-one mapping doesn't exist unless you restrict yourself to strings that only contain ASCII characters.  System.Text.Encoding has lots of ways to map a string to byte[], you need to pick one that avoids loss of information and that is easy to use by your client when she needs to map the byte[] back to a string.</source>
          <target state="translated">Ключевая проблема в том,что глиф в строке занимает 32 бита (16 бит для символьного кода),а байт имеет только 8 бит.Отображение один к одному не существует,если только вы не ограничиваете себя строками,которые содержат только ASCII-символы.System.Text.Encoding имеет множество способов отображения строки к байту[],вам нужно выбрать такой способ,который позволит избежать потери информации,и который прост в использовании вашим клиентом,когда ему нужно отобразить байт[]обратно к строке.</target>
        </trans-unit>
        <trans-unit id="a40a9ea14dae7563f50e320804e82a672b940687" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;NonPortableCast&lt;/code&gt; and &lt;code&gt;DangerousGetPinnableReference&lt;/code&gt; should further the argument that you probably shouldn't be doing this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Имена &lt;/font&gt;&lt;/font&gt; &lt;code&gt;NonPortableCast&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;DangerousGetPinnableReference&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; должны &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;дополнять&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; аргумент, что вы, вероятно, не должны этого делать.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dda539ce82b20525f557ab49a5c6264cab553f17" translate="yes" xml:space="preserve">
          <source>The only confusing thing is that .NET uses the name of a character set for the name of one particular encoding of that character set. &lt;code&gt;Encoding.Unicode&lt;/code&gt; should be called &lt;code&gt;Encoding.UTF16&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Единственное, что сбивает с толку, - это то, что .NET использует имя набора символов для имени одной конкретной кодировки этого набора символов. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Encoding.Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; должен называться &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Encoding.UTF16&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d87180cf4983e0ecdadae876f5161ab8b72c51c" translate="yes" xml:space="preserve">
          <source>The only way to get to the actual bytes the String is stored in is to use a pointer. The &lt;code&gt;fixed&lt;/code&gt; statement allows taking the address of values. From the C# spec:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Единственный способ получить фактические байты, в которых хранится строка - это использовать указатель. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Оператор &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fixed&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; позволяет получить адрес значений. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Из спецификации C #:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50c45a3db03e83c198d132a47dbec8da83013c3b" translate="yes" xml:space="preserve">
          <source>The program may be re-implemented in a different language or runtime in the future.</source>
          <target state="translated">В будущем программа может быть реализована на другом языке или во время выполнения.</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">В результате:</target>
        </trans-unit>
        <trans-unit id="69f6a043be4a0ce901b3fde8264cd0887c3552fc" translate="yes" xml:space="preserve">
          <source>The string can be converted to byte array in few different ways, due to the following fact: .NET supports Unicode, and Unicode standardizes several difference encodings called UTFs. They have different lengths of byte representation but are equivalent in that sense that when a string is encoded, it can be coded back to the string, but if the string is encoded with one UTF and decoded in the assumption of different UTF if can be screwed up.</source>
          <target state="translated">Строка может быть преобразована в байтовый массив несколькими различными способами,благодаря следующему факту:.NET поддерживает Юникод,а Юникод стандартизирует несколько разностных кодировок,называемых UTF.Они имеют разную длину представления байтов,но эквивалентны в том смысле,что когда строка закодирована,она может быть закодирована обратно в строку,но если строка закодирована с одной кодировкой UTF и декодирована в предположении разной кодировки,если она может быть испорчена.</target>
        </trans-unit>
        <trans-unit id="8c74ce348a5dbb8a79201c3a0b78651da595424f" translate="yes" xml:space="preserve">
          <source>This function will get you a copy of the bytes underlying your string, pretty quickly. You'll get those bytes in whatever way they are encoding on your system. This encoding is almost certainly UTF-16LE but that is an implementation detail you shouldn't have to care about.</source>
          <target state="translated">Эта функция позволит вам довольно быстро получить копию байтов,лежащих в основе вашей строки.Вы получите эти байты любым способом,каким они кодируются в вашей системе.Эта кодировка почти наверняка UTF-16LE,но это деталь реализации,о которой вам не стоит беспокоиться.</target>
        </trans-unit>
        <trans-unit id="5ea82f427c53e42188bc1a0b6b4f0e4e4450be8c" translate="yes" xml:space="preserve">
          <source>This is a popular question. It is important to understand what the question author is asking, and that it is different from what is likely the most common need. To discourage misuse of the code where it is not needed, I've answered the later first.</source>
          <target state="translated">Это популярный вопрос.Важно понять,что задает автор вопроса,и что он отличается от того,что,скорее всего,является наиболее распространенной потребностью.Чтобы предотвратить злоупотребление кодом там,где он не нужен,я сначала ответил на более поздний вопрос.</target>
        </trans-unit>
        <trans-unit id="4d255839cccd5531ecdc7b87cc97e8633d588bb1" translate="yes" xml:space="preserve">
          <source>This is because, as Tyler so aptly &lt;a href=&quot;https://chat.stackoverflow.com/transcript/message/39942929#39942929&quot;&gt;said&lt;/a&gt;, &quot;Strings aren't pure data. They also have &lt;a href=&quot;http://www.diffen.com/difference/Data_vs_Information&quot;&gt;information&lt;/a&gt;.&quot; In this case, the information is an encoding that was assumed when the string was created.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это потому, что, как метко &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://chat.stackoverflow.com/transcript/message/39942929#39942929&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сказал&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Тайлер &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;laquo;Строки не являются чистыми данными. У них также есть &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.diffen.com/difference/Data_vs_Information&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;информация&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этом случае информация представляет собой кодировку, которая была принята при создании строки.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1337785d661cc653a07caf296384461bb676e002" translate="yes" xml:space="preserve">
          <source>To do so, the compiler writes code skip over the other parts of the string object with &lt;code&gt;RuntimeHelpers.OffsetToStringData&lt;/code&gt;. So, to get the raw bytes, just create a pointer to the string and copy the number of bytes needed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для этого компилятор пишет код, пропускающий другие части строкового объекта с помощью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;RuntimeHelpers.OffsetToStringData&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, чтобы получить необработанные байты, просто создайте указатель на строку и скопируйте необходимое количество байтов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c07a189f95468b3a4f60c069a1ab01d5692eb38" translate="yes" xml:space="preserve">
          <source>Try that with &lt;strong&gt;System.Text.Encoding.UTF8.GetBytes&lt;/strong&gt; or &lt;strong&gt;System.Text.Encoding.Unicode.GetBytes&lt;/strong&gt;, they will merely replace high surrogate characters with value &lt;strong&gt;fffd&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Попробуйте это с &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Text.Encoding.UTF8.GetBytes&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;System.Text.Encoding.Unicode.GetBytes&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , они просто заменят старшие суррогатные символы значением &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;fffd&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82808995e973592a5d7502f8e8a62ff736880d72" translate="yes" xml:space="preserve">
          <source>Try this, a lot less code:</source>
          <target state="translated">Попробуй это,намного меньше кода:</target>
        </trans-unit>
        <trans-unit id="2dbfa18abdc4b7e6d736fb2be782c7623df34609" translate="yes" xml:space="preserve">
          <source>Two ways:</source>
          <target state="translated">Два способа:</target>
        </trans-unit>
        <trans-unit id="588b58a71870cebadf8938b04931b4163a3550c5" translate="yes" xml:space="preserve">
          <source>Upon being asked what you intend to do with the bytes, you &lt;a href=&quot;https://stackoverflow.com/questions/472906/how-do-i-get-a-consistent-byte-representation-of-strings-in-c-sharp-without-manu?rq=1#comment290510_472906&quot;&gt;responded&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда вас спросили, что вы собираетесь делать с байтами, вы &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/472906/how-do-i-get-a-consistent-byte-representation-of-strings-in-c-sharp-without-manu?rq=1#comment290510_472906&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ответили&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="8b07402f794ee7869e95ec64ac9ed4c8891a44d9" translate="yes" xml:space="preserve">
          <source>Using an encoding could give you trouble if you have 'strings' with invalid characters, but that shouldn't happen.  If you are getting data into your string with invalid characters you are doing it wrong.  You should probably be using a byte array or a Base64 encoding to start with.</source>
          <target state="translated">Использование кодировки может создать проблемы,если у вас есть 'строки' с недопустимыми символами,но этого не должно происходить.Если вы получаете данные в строку с недопустимыми символами,вы делаете это неправильно.Скорее всего,для начала следует использовать массив байт или кодировку Base64.</target>
        </trans-unit>
        <trans-unit id="df3c7f56193a6836b84188f6c0a85cf34be8d7fa" translate="yes" xml:space="preserve">
          <source>Utf8 is a popular encoding, it is compact and not lossy.</source>
          <target state="translated">Utf8-популярная кодировка,она компактна и не имеет потерь.</target>
        </trans-unit>
        <trans-unit id="64fb9099f037694f04e41f89d909bdd2f91661fe" translate="yes" xml:space="preserve">
          <source>Well, I've read all answers and they were about using encoding or one about serialization that drops unpaired surrogates.</source>
          <target state="translated">Ну,я прочитал все ответы,и они были об использовании кодирования или о сериализации,которая сбрасывает непарные суррогаты.</target>
        </trans-unit>
        <trans-unit id="f5bcb3383297f0cc19ad735baf6986d6c50a4f49" translate="yes" xml:space="preserve">
          <source>What you want is each character's bytes in an array.  And that is where 'encoding' comes in.  By default you will get UTF-16LE.  If you don't care about the bytes themselves except for the round trip then you can choose any encoding including the 'default', and convert it back later (assuming the same parameters such as what the default encoding was, code points, bug fixes, things allowed such as unpaired surrogates, etc.</source>
          <target state="translated">Вам нужен каждый байт символа в массиве.И именно здесь приходит &quot;кодировка&quot;.По умолчанию вы получите UTF-16LE.Если вас не волнуют сами байты,кроме поездки туда и обратно,то вы можете выбрать любую кодировку,включая 'default',и конвертировать ее обратно позже (предполагая те же самые параметры,такие как кодировка по умолчанию,точки кода,исправления ошибок,разрешенные вещи,такие как непарные суррогаты,и т.д.).</target>
        </trans-unit>
        <trans-unit id="e128d2a9a6c10ff324ef1df3d88b4a6e7fcaf4be" translate="yes" xml:space="preserve">
          <source>Which brings me to the second part... picking the &lt;code&gt;Unicode&lt;/code&gt; encoding &lt;em&gt;&lt;strong&gt;is&lt;/strong&gt;&lt;/em&gt; telling .Net to use the underlying bytes. You do need to pick this encoding, because when some new-fangled Unicode-Plus comes out the .Net runtime needs to be free to use this newer, better encoding model without breaking your program. But, for the moment (and forseeable future), just choosing the Unicode encoding gives you what you want.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это подводит меня ко второй части ... выбирая &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Unicode&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; кодировки &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;будет&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; говорить .Net , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чтобы использовать основные байты. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вам нужно выбрать эту кодировку, потому что, когда выходит какой-то новый Unicode-Plus, среда выполнения .Net должна быть свободна, чтобы использовать эту более новую, лучшую модель кодирования, не ломая вашу программу. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но на данный момент (и в обозримом будущем) простой выбор кодировки Unicode даст вам то, что вы хотите.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e57c91c65751984e438caf6215b56c4aac63d4a2" translate="yes" xml:space="preserve">
          <source>Which means how a string is stored is irrelevant.  You want a string &quot;Encoded&quot; into bytes in a byte array.</source>
          <target state="translated">Это означает,что то,как строка хранится,не имеет значения.Вы хотите,чтобы строка &quot;Кодировалась&quot; в байты в массиве байтов.</target>
        </trans-unit>
        <trans-unit id="5633e0314b2479ba38f1d9b3bdc10f132ecabdb7" translate="yes" xml:space="preserve">
          <source>With the advent of &lt;a href=&quot;https://github.com/dotnet/corefxlab/blob/master/docs/specs/span.md&quot;&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; released with C# 7.2, the canonical technique to capture the underlying memory representation of a string into a managed byte array is:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С появлением &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/dotnet/corefxlab/blob/master/docs/specs/span.md&quot;&gt; &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; выпущенного в C # 7.2, канонический метод для захвата основного представления памяти строки в массив управляемых байтов:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dea489a74815f747f40610f8c1ea45fb4f1113f4" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://stackoverflow.com/a/10380166/369792&quot;&gt;Mehrdad's answer&lt;/a&gt;, but it does actually use an encoding because chars are UTF-16.  It calls ToCharArray which looking at &lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/string.cs,d78d4544220d96be&quot;&gt;the source&lt;/a&gt; creates a &lt;code&gt;char[]&lt;/code&gt; and copies the memory to it directly.  Then it copies the data to a byte array that is also allocated.  So under the hood it is copying the underlying bytes &lt;em&gt;twice&lt;/em&gt; and allocating a char array that is not used after the call.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете использовать &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/10380166/369792&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ответ Mehrdad&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но он на самом деле использует кодировку, потому что символы UTF-16. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он вызывает ToCharArray, который, глядя на &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/string.cs,d78d4544220d96be&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;источник,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; создает &lt;/font&gt;&lt;/font&gt; &lt;code&gt;char[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и напрямую копирует в него память. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем он копирует данные в байтовый массив, который также выделяется. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, он скрывает &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;два&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; байта &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и выделяет массив символов, который не используется после вызова.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8bc23768b511b70873e76a6a0ac6639f7c5b9bfd" translate="yes" xml:space="preserve">
          <source>You can use following code to convert a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;byte array&lt;/code&gt; in .NET</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете использовать следующий код для преобразования &lt;/font&gt;&lt;/font&gt; &lt;code&gt;string&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;byte array&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в .NET&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ddb52534c12174eb56c30fd283e29b52e1f810e2" translate="yes" xml:space="preserve">
          <source>You can use the following code for conversion between string and byte array.</source>
          <target state="translated">Для преобразования между строковым и байтовым массивами можно использовать следующий код.</target>
        </trans-unit>
        <trans-unit id="c0fb9dbcf124da24e60d780c2987c4af0aa8c923" translate="yes" xml:space="preserve">
          <source>You may &lt;em&gt;certainly&lt;/em&gt; choose to use UTF-16 directly if you find that your process performs significantly better since .NET uses it internally or for any other reason, but you need to choose that encoding explicitly and perform those conversions explicitly in your code rather than depending on .NET's internal implementation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;конечно,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; можете использовать UTF-16 напрямую, если обнаружите, что ваш процесс работает значительно лучше, поскольку .NET использует его внутри или по любой другой причине, но вам нужно выбрать эту кодировку явно и выполнять эти преобразования явно в своем коде, а не в зависимости на внутренней реализации .NET.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="045aa4e470db14da85abf8b4becab0c68d6e6753" translate="yes" xml:space="preserve">
          <source>You may need to communicate with a process implemented in a different language or runtime. (This might include a server running on another machine or sending the string to a JavaScript browser client, for example.)</source>
          <target state="translated">Возможно,вам понадобится общаться с процессом,реализованным на другом языке или во время выполнения.(Это может быть,например,сервер,работающий на другой машине или посылающий строку клиенту браузера JavaScript).</target>
        </trans-unit>
        <trans-unit id="4605a05b00cc5f119e23424e593675ac7ef459d2" translate="yes" xml:space="preserve">
          <source>You need to take the encoding into account, because 1 character could be represented by 1 &lt;strong&gt;or more&lt;/strong&gt; bytes (up to about 6), and different encodings will treat these bytes differently.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Необходимо принять во внимание кодировку, потому что 1 символ может быть представлен 1 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;или более&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; байтами (до 6), и разные кодировки будут обрабатывать эти байты по-разному.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8080d01b7f4ec171f7f5a4fdb095a0253015283e" translate="yes" xml:space="preserve">
          <source>[For] an expression of type string, ... the initializer computes the
  address of the first character in the string.</source>
          <target state="translated">[Для]выражения типа строки,...инициализатор вычисляет адрес первого символа в строке.</target>
        </trans-unit>
        <trans-unit id="5abad554f427cc892658b8d6a97b4d1dd5d837a3" translate="yes" xml:space="preserve">
          <source>take this example sample:</source>
          <target state="translated">возьмите этот пример:</target>
        </trans-unit>
        <trans-unit id="a940fdbe080bf3b406fffafd133dc5497c184ece" translate="yes" xml:space="preserve">
          <source>谢谢！</source>
          <target state="translated">谢谢！</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
