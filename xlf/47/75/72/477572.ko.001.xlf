<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/477572">
    <body>
      <group id="477572">
        <trans-unit id="e38d004047cde5eb417d48832f1998c8472bba00" translate="yes" xml:space="preserve">
          <source>1) Every time you do &lt;code&gt;BitmapFactory.decodeXYZ()&lt;/code&gt;, make sure to pass in a &lt;code&gt;BitmapFactory.Options&lt;/code&gt; with &lt;code&gt;inPurgeable&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; (and preferably with &lt;code&gt;inInputShareable&lt;/code&gt; also set to &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">1) &lt;code&gt;BitmapFactory.decodeXYZ()&lt;/code&gt; 를 수행 할 때마다 &lt;code&gt;inPurgeable&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있고 inInputShareable 이 true로 설정되어있는 &lt;code&gt;BitmapFactory.Options&lt;/code&gt; 를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="8782c067eeb1c1f90f926f8b5ee08512104fefc2" translate="yes" xml:space="preserve">
          <source>2) NEVER use &lt;code&gt;Bitmap.createBitmap(width, height, Config.ARGB_8888)&lt;/code&gt;. I mean NEVER! I've never had that thing not raise memory error after few passes. No amount of &lt;code&gt;recycle()&lt;/code&gt;, &lt;code&gt;System.gc()&lt;/code&gt;, whatever helped. It always raised exception. The one other way that actually works is to have a dummy image in your drawables (or another Bitmap that you decoded using step 1 above), rescale that to whatever you want, then manipulate the resulting Bitmap (such as passing it on to a Canvas for more fun). So, what you should use instead is: &lt;code&gt;Bitmap.createScaledBitmap(srcBitmap, width, height, false)&lt;/code&gt;. If for whatever reason you MUST use the brute force create method, then at least pass &lt;code&gt;Config.ARGB_4444&lt;/code&gt;.</source>
          <target state="translated">2) 절대 &lt;code&gt;Bitmap.createBitmap(width, height, Config.ARGB_8888)&lt;/code&gt; 사용하지 마십시오. 나는 절대 의미하지 않는다! 몇 번의 통과 후에도 메모리 오류가 발생하지 않는 것은 없었습니다. 도움이 된 모든 &lt;code&gt;recycle()&lt;/code&gt; , &lt;code&gt;System.gc()&lt;/code&gt; . 항상 예외가 발생했습니다. 실제로 작동하는 또 다른 방법은 드로어 블에 더미 이미지 (또는 위의 1 단계를 사용하여 디코딩 한 다른 비트 맵)를 가지고 원하는 크기로 조정 한 다음 결과 비트 맵을 조작하는 것입니다 (예 : 캔버스에 전달하는 것) 더 재미있게). 따라서 대신 사용해야하는 것은 &lt;code&gt;Bitmap.createScaledBitmap(srcBitmap, width, height, false)&lt;/code&gt; 입니다. 어떤 이유로 든 무차별 강제 작성 메소드를 사용해야하는 경우 최소한 &lt;code&gt;Config.ARGB_4444&lt;/code&gt; 를 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="562263b1466294b7de472ca74c4560bbeb477dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decodeFileDescriptor&lt;/code&gt; looks like it calls different native methods than the decodeStream/decodeFile.</source>
          <target state="translated">&lt;code&gt;decodeFileDescriptor&lt;/code&gt; 는 decodeStream / decodeFile과 다른 고유 메소드를 호출하는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="c0119b41f35b7e464151bc4394e0148b6c7c4fa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getView()&lt;/code&gt; gets called very often. It's normally not a good idea to download images there if we haven't implemented a check that ensure us that we won't start an infinite amount of threads per row. Cache.java checks whether the &lt;code&gt;rowObject.mBitmapUrl&lt;/code&gt; already is in a task and if it is, it won't start another. Therefore, we are most likely not exceeding the work queue restriction from the &lt;code&gt;AsyncTask&lt;/code&gt; pool.</source>
          <target state="translated">&lt;code&gt;getView()&lt;/code&gt; 는 매우 자주 호출됩니다. 행당 무한한 수의 스레드를 시작하지 않도록 확인을 구현하지 않은 경우 일반적으로 이미지를 다운로드하는 것은 좋지 않습니다. Cache.java는 &lt;code&gt;rowObject.mBitmapUrl&lt;/code&gt; 이 이미 작업에 있는지 확인하고, 이미 있으면 다른 것을 시작하지 않습니다. 따라서 &lt;code&gt;AsyncTask&lt;/code&gt; 풀의 작업 큐 제한을 초과하지 않을 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="5a2a7862a6c547b2e092e4cf80ae9639f368585c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Retains the cache if there is an orientation change&lt;/em&gt;, using a singleton</source>
          <target state="translated">싱글 톤을 사용하여 &lt;em&gt;방향 변경이있는 경우 캐시를 유지합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7baa5dc9710205332e50f61e26eb82dfa968082b" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;By referring to the &lt;a href=&quot;http://techpalle.com/blog/wp-content/uploads/2012/03/activity_lifecycle.png&quot;&gt;Activity Life Cycle&lt;/a&gt;&lt;/strike&gt;</source>
          <target state="translated">&lt;strike&gt;&lt;a href=&quot;http://techpalle.com/blog/wp-content/uploads/2012/03/activity_lifecycle.png&quot;&gt;활동 수명주기&lt;/a&gt; 를 참조하여&lt;/strike&gt;</target>
        </trans-unit>
        <trans-unit id="738f489e8fcc88ac9846e9e94707b826be87e80a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A power of two value is calculated because the decoder uses a
  final value by rounding down to the nearest power of two, as per the
  &lt;code&gt;inSampleSize&lt;/code&gt; documentation.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;inSampleSize&lt;/code&gt; 설명서에 따라 디코더가 가장 가까운 2의 거듭 제곱으로 내림차순 으로 최종 값을 사용하므로 2의 거듭 제곱이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3f154f989c2982b44c304392cc3fc4749629e582" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution&lt;/strong&gt;:
Move the images to &quot;assets&quot; folder and use the following function to get BitmapDrawable:</source>
          <target state="translated">&lt;strong&gt;해결책&lt;/strong&gt; : 이미지를 &quot;자산&quot;폴더로 이동하고 다음 기능을 사용하여 BitmapDrawable을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="27301bb33e9a932b41cd4ef280ed71c4ba67d620" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unfortunately&lt;/strong&gt; if None of the Above works, then Add this to your &lt;strong&gt;Manifest&lt;/strong&gt; file. Inside &lt;em&gt;application&lt;/em&gt; tag</source>
          <target state="translated">&lt;strong&gt;불행히도&lt;/strong&gt; 위의 어느 것도 작동하지 않으면 &lt;strong&gt;매니페스트&lt;/strong&gt; 파일에 추가하십시오. 내부 &lt;em&gt;애플리케이션&lt;/em&gt; 태그</target>
        </trans-unit>
        <trans-unit id="0ec8b07a0031298ce5bcdcf2e906e88cf818b728" translate="yes" xml:space="preserve">
          <source>After I've done a lot of experiments with this App, I've got the following conclusions:</source>
          <target state="translated">이 앱으로 많은 실험을 한 후 다음과 같은 결론을 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="5d9f33ceb54e285b1f0f546fa5ae5441f81cf547" translate="yes" xml:space="preserve">
          <source>All the solutions here require setting a IMAGE_MAX_SIZE. This limits devices with more powerful hardware and if the image size is too low it looks ugly on the HD screen.</source>
          <target state="translated">여기의 모든 솔루션은 IMAGE_MAX_SIZE를 설정해야합니다. 이것은 더 강력한 하드웨어를 가진 장치를 제한하고 이미지 크기가 너무 작 으면 HD 화면에서보기 흉하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="1884733a3c481df7c2074ade429f3a9f9686109c" translate="yes" xml:space="preserve">
          <source>Android API 2.1 or higher (I simply could not manage to get the available memory for an application in API 1.6 - that is the only piece of code that doesn't work in API 1.6)</source>
          <target state="translated">Android API 2.1 이상 (단순히 API 1.6에서 응용 프로그램에 사용 가능한 메모리를 가져올 수 없었습니다-API 1.6에서 작동하지 않는 유일한 코드입니다)</target>
        </trans-unit>
        <trans-unit id="c852378f8fd87cb6e98eea9753b7acf9191bc79d" translate="yes" xml:space="preserve">
          <source>Android support package</source>
          <target state="translated">안드로이드 지원 패키지</target>
        </trans-unit>
        <trans-unit id="15f9db5a119d042a2a0dbcd8e7a20a243027d043" translate="yes" xml:space="preserve">
          <source>Anyways, what worked was this (note that I added some options as some had above, but that's not what made the difference. What is critical is the call to &lt;strong&gt;BitmapFactory.decodeFileDescriptor&lt;/strong&gt; instead of &lt;strong&gt;decodeStream&lt;/strong&gt; or &lt;strong&gt;decodeFile&lt;/strong&gt;):</source>
          <target state="translated">어쨌든, 효과가 있었던 것은 이것입니다 (위의 일부 옵션을 추가했지만 차이점은 아닙니다. 중요한 것은 &lt;strong&gt;decodeStream&lt;/strong&gt; 또는 &lt;strong&gt;decodeFile&lt;/strong&gt; 대신 &lt;strong&gt;BitmapFactory.decodeFileDescriptor에&lt;/strong&gt; 대한 호출입니다).</target>
        </trans-unit>
        <trans-unit id="2a639f00f36e3a3df1f8a5ce44c1eba66c427656" translate="yes" xml:space="preserve">
          <source>As soon as I disabled the image on the list view it worked fine again.</source>
          <target state="translated">목록보기에서 이미지를 비활성화하자마자 다시 정상적으로 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="e04f7f19db81d0bbf4b2eaf9335fc544b05da2a3" translate="yes" xml:space="preserve">
          <source>Because of this I wrote an example application that demonstrates caching in an Android environment. This implementation has not yet gotten an OOM.</source>
          <target state="translated">이 때문에 안드로이드 환경에서 캐싱을 보여주는 예제 애플리케이션을 작성했습니다. 이 구현은 아직 OOM을 얻지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="ee849ef8bc77f61c239846c451384637a9839373" translate="yes" xml:space="preserve">
          <source>Bitmap is stored in VM heap, Native memory is not counted for OOM.</source>
          <target state="translated">비트 맵은 VM 힙에 저장되며 기본 메모리는 OOM에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88672ca86836327b9dde502c2e5829f39cc85ff3" translate="yes" xml:space="preserve">
          <source>Bitmap is stored in native heap, but it will get garbage collected automatically, calling recycle() is needless.</source>
          <target state="translated">비트 맵은 기본 힙에 저장되지만 recycle ()을 불필요하게 호출하면 가비지가 자동으로 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="205a822cd5bbafed369318fc3a950d9a83784750" translate="yes" xml:space="preserve">
          <source>Bitmap memory isn't in the VM heap but rather in the native heap - see &lt;a href=&quot;https://stackoverflow.com/questions/1955410/bitmapfactory-oom-driving-me-nuts/5493182#5493182&quot;&gt;BitmapFactory OOM driving me nuts&lt;/a&gt;</source>
          <target state="translated">비트 맵 메모리는 VM 힙이 아니라 기본 힙에 있습니다. &lt;a href=&quot;https://stackoverflow.com/questions/1955410/bitmapfactory-oom-driving-me-nuts/5493182#5493182&quot;&gt;BitmapFactory OOM을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2850c6f9080f7ab7710c811fdf37a52b2390e539" translate="yes" xml:space="preserve">
          <source>Cache.java's critical stuff (the &lt;code&gt;loadBitmap()&lt;/code&gt; method is the most important):</source>
          <target state="translated">Cache.java의 중요한 것들 ( &lt;code&gt;loadBitmap()&lt;/code&gt; 메소드가 가장 중요합니다) :</target>
        </trans-unit>
        <trans-unit id="9c7abf0da6a58cae788ad7565b643389edaee688" translate="yes" xml:space="preserve">
          <source>Callbacks are anonymous inner classes too, so if a static instance in your project holds them and do not release them, memory would be leaked.</source>
          <target state="translated">콜백은 익명의 내부 클래스이기도하므로 프로젝트의 정적 인스턴스가 보유하고 해제하지 않으면 메모리가 누출됩니다.</target>
        </trans-unit>
        <trans-unit id="5328b687344df73f23830a73eb9346cab386ef68" translate="yes" xml:space="preserve">
          <source>Calling AsyncTask.cancel(true) will not stop the execution if the task is blocked in an IO operation in background thread.</source>
          <target state="translated">백그라운드 스레드의 IO 작업에서 작업이 차단 된 경우 AsyncTask.cancel (true)을 호출하면 실행이 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="671599bc1a399d2611080b182c6ec309dceb993f" translate="yes" xml:space="preserve">
          <source>Controls &lt;em&gt;that there is an internet connection available&lt;/em&gt; before downloading the bitmaps</source>
          <target state="translated">비트 맵을 다운로드하기 전에 &lt;em&gt;인터넷에 연결되어 있는지&lt;/em&gt; 제어</target>
        </trans-unit>
        <trans-unit id="db6569c7a3ae973546f496a86ab5b9b206ec95a5" translate="yes" xml:space="preserve">
          <source>Dimensions of the target ImageView or UI component that the image is to be loaded into.</source>
          <target state="translated">이미지를로드 할 대상 ImageView 또는 UI 구성 요소의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f5a62978708306f9ae8db3e77eb70b18a55e42a7" translate="yes" xml:space="preserve">
          <source>Disk caching. This should be easy to implement anyway - just point to a different task that grabs the bitmaps from the disk</source>
          <target state="translated">디스크 캐싱. 어쨌든 구현하기 쉬워야합니다. 디스크에서 비트 맵을 가져 오는 다른 작업을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="d41afcdf06f873159a02f2c71ff9d4ff63760f01" translate="yes" xml:space="preserve">
          <source>Download:</source>
          <target state="translated">Download:</target>
        </trans-unit>
        <trans-unit id="53a6f94106746c28ba76a2b35fa9813bee528f13" translate="yes" xml:space="preserve">
          <source>Estimated memory usage of loading the full image in memory.</source>
          <target state="translated">메모리에 전체 이미지를로드하는 예상 메모리 사용량입니다.</target>
        </trans-unit>
        <trans-unit id="b09f2105d1275959687cbd96020e7a8cd8eed874" translate="yes" xml:space="preserve">
          <source>FYI: This is how I was doing it:</source>
          <target state="translated">참고 : 이것이 내가 한 일입니다 :</target>
        </trans-unit>
        <trans-unit id="5df81ffa82179b458e1d55e350db9d88805a69b2" translate="yes" xml:space="preserve">
          <source>Features:</source>
          <target state="translated">Features:</target>
        </trans-unit>
        <trans-unit id="50966d4fa4bd11157f2c78c84f8e32c94e4dc8a1" translate="yes" xml:space="preserve">
          <source>For example, it&amp;rsquo;s not worth loading a 1024x768 pixel image into memory if it will eventually be displayed in a 128x96 pixel thumbnail in an &lt;code&gt;ImageView&lt;/code&gt;.</source>
          <target state="translated">예를 들어 1024x768 픽셀 이미지를 &lt;code&gt;ImageView&lt;/code&gt; 의 128x96 픽셀 썸네일로 표시 할 경우 메모리에 1024x768 픽셀 이미지를로드 할 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="08ffb9f14d4f90d0318cfb08c98680be308359bf" translate="yes" xml:space="preserve">
          <source>Garbage collection for the native heap is lazier than the VM heap - so you need to be quite aggressive about doing bitmap.recycle and bitmap =null every time you go through an Activity's onPause or onDestroy</source>
          <target state="translated">기본 힙에 대한 가비지 콜렉션은 VM 힙보다 느리므로 활동의 onPause 또는 onDestroy를 수행 할 때마다 bitmap.recycle 및 bitmap = null 수행에 대해 매우 적극적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="72d5be6ec911bd80fb8bae74de3673d72fff4bcd" translate="yes" xml:space="preserve">
          <source>Generally android device heap size is only 16MB (varies from device/OS see post &lt;a href=&quot;https://stackoverflow.com/a/9940415/1053097&quot;&gt;Heap Sizes&lt;/a&gt;), if you are loading the images and it crosses the size of 16MB , it will throw out of memory exception, instead of using the Bitmap for , loading images from SD card or from resources or even from network try to using &lt;strong&gt;getImageUri&lt;/strong&gt; , loading bitmap require more memory , or you can set bitmap to null if your work done with that bitmap.</source>
          <target state="translated">일반적으로 안드로이드 장치 힙 크기는 16MB에 불과합니다 (장치 / OS에 따라 다름 &lt;a href=&quot;https://stackoverflow.com/a/9940415/1053097&quot;&gt;힙 크기&lt;/a&gt; 참조). 이미지를로드하고 크기가 16MB를 넘으면에 대한 비트 맵을 사용하는 대신 메모리 예외가 발생합니다. SD 카드 또는 리소스 또는 네트워크의 이미지에서 &lt;strong&gt;getImageUri&lt;/strong&gt; 를 사용하려고 시도하면 비트 맵을로드하는 데 더 많은 메모리가 필요하거나 해당 비트 맵으로 작업이 완료된 경우 비트 맵을 null로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a06d0f015483587699b8a176995e7382555aa09" translate="yes" xml:space="preserve">
          <source>Great answers here, but I wanted a &lt;strong&gt;fully usable class&lt;/strong&gt; to address this problem.. so I did one.</source>
          <target state="translated">여기에 큰 답변이 있지만이 문제를 해결하기 위해 &lt;strong&gt;완전히 사용할 수있는 수업&lt;/strong&gt; 을 원했습니다.</target>
        </trans-unit>
        <trans-unit id="3ac2685d8968e5ce7bf1f958f25f0955c33e1786" translate="yes" xml:space="preserve">
          <source>Here is my &lt;strong&gt;BitmapHelper class&lt;/strong&gt; that is OutOfMemoryError proof :-)</source>
          <target state="translated">다음은 OutOfMemoryError 증거 인 &lt;strong&gt;BitmapHelper 클래스&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="19cb376555018e8823eaa695a9df2f1af042d562" translate="yes" xml:space="preserve">
          <source>Here is my LogCat:</source>
          <target state="translated">내 LogCat은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cffa2bc53f11363125136f8a2ab820dca37158cd" translate="yes" xml:space="preserve">
          <source>Here is some of my observations about Garbage Collection and Memory Leak.</source>
          <target state="translated">가비지 수집 및 메모리 누수에 대한 관찰 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a02f56ef5eb139e6928484a85c5a047ddea1327" translate="yes" xml:space="preserve">
          <source>Here's a complete method. First it reads image size without decoding the content itself. Then it finds the best &lt;code&gt;inSampleSize&lt;/code&gt; value, it should be a power of 2, and finally the image is decoded.</source>
          <target state="translated">다음은 완전한 방법입니다. 먼저 내용 자체를 디코딩하지 않고 이미지 크기를 읽습니다. 그런 다음 최상의 &lt;code&gt;inSampleSize&lt;/code&gt; 값을 찾고 2의 거듭 제곱이어야하며 마지막으로 이미지가 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="808a8de8725ef3f0318a54ee708ab3155fc4418f" translate="yes" xml:space="preserve">
          <source>Hope this helps someone out there..</source>
          <target state="translated">이것이 누군가를 도울 수 있기를 바랍니다 ..</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">도움이 되었기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="68dbf58b4d75dc4e6d3fcbae5f5cb30a0e0c723d" translate="yes" xml:space="preserve">
          <source>I also have a new error when displaying an image:</source>
          <target state="translated">이미지를 표시 할 때 새로운 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d707934563266af24417ef00ad34c82d947bec0e" translate="yes" xml:space="preserve">
          <source>I came out with a solution that works with my Samsung Galaxy S3 and several other devices including less powerful ones, with better image quality when a more powerful device is used.</source>
          <target state="translated">더 강력한 장치를 사용할 때 이미지 품질이 더 좋은 삼성 Galaxy S3 및 덜 강력한 장치를 포함한 여러 다른 장치와 함께 작동하는 솔루션을 개발했습니다.</target>
        </trans-unit>
        <trans-unit id="ac38569581f05208050b75097c3c346aaabe9718" translate="yes" xml:space="preserve">
          <source>I come from iOS experience and I was frustrated to discover an issue with something so basic as loading and showing an image. After all, everyone that is having this issue is trying to display reasonably sized images. Anyway, here are the two changes that fixed my problem (and made my app very responsive).</source>
          <target state="translated">나는 iOS 경험에서 왔으며 이미지를로드하고 표시하는 것과 같은 기본적인 문제를 발견하는 데 좌절했습니다. 결국,이 문제가있는 모든 사람들은 합리적인 크기의 이미지를 표시하려고합니다. 어쨌든, 여기 내 문제를 해결하고 내 앱을 매우 반응 적으로 만든 두 가지 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="41042d10893fe7f9878c2ee20b4903eaec26fdc6" translate="yes" xml:space="preserve">
          <source>I did the following to take the image and resize it on the fly. Hope this helps</source>
          <target state="translated">나는 이미지를 가져 와서 즉시 크기를 조정하기 위해 다음을 수행했습니다. 도움이 되었기를 바랍니다</target>
        </trans-unit>
        <trans-unit id="70963af00b7f5a5eee53277c66e3856a91f2891c" translate="yes" xml:space="preserve">
          <source>I had this same issue and solved it by avoiding the BitmapFactory.decodeStream or decodeFile functions and instead used &lt;code&gt;BitmapFactory.decodeFileDescriptor&lt;/code&gt;</source>
          <target state="translated">나는이 같은 문제가 있었고 BitmapFactory.decodeStream 또는 decodeFile 함수를 피하고 대신 &lt;code&gt;BitmapFactory.decodeFileDescriptor&lt;/code&gt; 를 사용하여 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="dcefbefe16ed45ee1a19ad421413e07c13b85e21" translate="yes" xml:space="preserve">
          <source>I have a list view with a couple of image buttons on each row. When you click the list row, it launches a new activity. I have had to build my own tabs because of an issue with the camera layout. The activity that gets launched for the result is a map. If I click on my button to launch the image preview (load an image off the SD card) the application returns from the activity back to the &lt;code&gt;listview&lt;/code&gt; activity to the result handler to relaunch my new activity which is nothing more than an image widget.</source>
          <target state="translated">각 행에 몇 개의 이미지 버튼이있는 목록보기가 있습니다. 목록 행을 클릭하면 새 활동이 시작됩니다. 카메라 레이아웃에 문제가있어 탭을 직접 만들어야했습니다. 결과에 대해 시작된 활동은 맵입니다. 내 버튼을 클릭하여 이미지 미리보기를 시작하면 (이미지를 SD 카드에로드) 애플리케이션이 액티비티에서 목록보기 액티비티로 돌아가 결과 핸들러로 돌아와 이미지 위젯에 지나지 않는 새로운 액티비티를 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3f3b7b996420d046d3c3706a4043539fc317ca2b" translate="yes" xml:space="preserve">
          <source>I have a much more effective solution which does not need scaling of any sort. Simply decode your bitmap only once and then cache it in a map against its name. Then simply retrieve the bitmap against the name and set it in the ImageView. There is nothing more that needs to be done.</source>
          <target state="translated">나는 어떤 종류의 확장이 필요없는 훨씬 효과적인 솔루션을 가지고 있습니다. 비트 맵을 한 번만 디코딩 한 다음 이름과 비교하여 맵에 캐시하면됩니다. 그런 다음 이름에서 비트 맵을 검색하여 ImageView에서 설정하십시오. 더 이상 할 일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="80c98ac37ad76002dab413e284d77bc9b5b987a9" translate="yes" xml:space="preserve">
          <source>I have resolved the same issue in the following manner.</source>
          <target state="translated">다음과 같은 방법으로 동일한 문제를 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="90e8def22b8526c77f4a89a6e67c5c7f7892ca05" translate="yes" xml:space="preserve">
          <source>I have seen a lot of questions about OOM exceptions and caching lately. The developer guide has &lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/cache-bitmap.html&quot;&gt;a really good article&lt;/a&gt; on this, but some tends to fail on implementing it in a suitable way.</source>
          <target state="translated">최근 OOM 예외 및 캐싱에 대한 많은 질문이 있습니다. 개발자 안내서에는 이것에 &lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/cache-bitmap.html&quot;&gt;대한 좋은 기사&lt;/a&gt; 가 있지만 일부는 적절한 방법으로 구현하지 못하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a92ba1c9a91a190d24c060f9480a125fd5d7a703" translate="yes" xml:space="preserve">
          <source>I have tested this for a few weeks now, I haven't gotten a single OOM exception yet. I have tested this on the emulator, on my Nexus One and on my Nexus S. I have tested image urls that contain images that were in HD quality. The only bottleneck is that it takes more time to download.</source>
          <target state="translated">나는 이것을 몇 주 동안 테스트했지만 아직 단일 OOM 예외를 얻지 못했습니다. 에뮬레이터, Nexus One 및 Nexus S에서 이것을 테스트했습니다. HD 품질의 이미지가 포함 된 이미지 URL을 테스트했습니다. 유일한 병목 현상은 다운로드하는 데 시간이 더 걸린다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd3a2038e0a415d454b2b7282e042b09784ff570" translate="yes" xml:space="preserve">
          <source>I hope this will help the buddies facing the same problem!</source>
          <target state="translated">나는 이것이 같은 문제에 직면하는 친구를 도울 수 있기를 바랍니다!</target>
        </trans-unit>
        <trans-unit id="ef445c286efa75adce24bdec51eab0b63f0b80ee" translate="yes" xml:space="preserve">
          <source>I just ran into this issue a couple minutes ago. I solved it by doing a better job at managing my listview adapter. I thought it was an issue with the hundreds of 50x50px images I was using, turns out I was trying to inflate my custom view each time the row was being shown. Simply by testing to see if the row had been inflated I eliminated this error, and I am using hundreds of bitmaps. This is actually for a Spinner, but the base adapter works all the same for a ListView. This simple fix also greatly improved the performance of the adapter.</source>
          <target state="translated">방금 몇 분 전에이 문제가 발생했습니다. 내 listview 어댑터 관리에서 더 나은 작업을 수행하여 문제를 해결했습니다. 나는 그것이 사용하고있는 수백 개의 50x50px 이미지에 문제가 있다고 생각했는데 행이 표시 될 때마다 사용자 정의보기를 부풀 리려고 노력하고있는 것으로 나타났습니다. 단순히 행이 팽창되었는지 확인하기 위해 테스트 하여이 오류를 제거했으며 수백 개의 비트 맵을 사용하고 있습니다. 이것은 실제로 스피너 용이지만 기본 어댑터는 ListView에서 모두 동일하게 작동합니다. 이 간단한 수정 사항은 또한 어댑터의 성능을 크게 향상 시켰습니다.</target>
        </trans-unit>
        <trans-unit id="cc69206e5815e05d21981036e91bc0bb1b830920" translate="yes" xml:space="preserve">
          <source>I know I can do an out of band resize and save of my image, but that is not really what I want to do, but some sample code for that would be nice.</source>
          <target state="translated">대역 외 크기를 조정하고 이미지를 저장할 수 있다는 것을 알고 있지만 실제로 원하는 것은 아니지만 샘플 코드가 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f1a21cccc75a4df422b282e20e780ffcfefd2ba8" translate="yes" xml:space="preserve">
          <source>I made an &lt;a href=&quot;https://play.google.com/store/apps/details?id=net.coocood.oomresearch&quot;&gt;app&lt;/a&gt; to intentionally cause &lt;code&gt;OutOfMemoryError&lt;/code&gt;, and monitor memory usage.</source>
          <target state="translated">의도적으로 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 를 발생시키고 메모리 사용량을 모니터링하는 &lt;a href=&quot;https://play.google.com/store/apps/details?id=net.coocood.oomresearch&quot;&gt;앱&lt;/a&gt; 을 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="cfd9d3246806c0d0544d387ca159b2f1de0c5464" translate="yes" xml:space="preserve">
          <source>I set the maximum memory used by this bitmap to be 25% of maximum allocated memory, you may need to adjust this to your needs and make sure this bitmap is cleaned up and don't stay in memory when you've finished using it. Typically I use this code to perform image rotation (source and destination bitmap) so my app needs to load 2 bitmaps in memory at the same time, and 25% gives me a good buffer without running out of memory when performing image rotation.</source>
          <target state="translated">이 비트 맵에서 사용하는 최대 메모리를 할당 된 최대 메모리의 25 %로 설정했습니다. 필요에 따라이 비트 맵을 정리하고이 비트 맵을 정리하고 사용이 완료되면 메모리에 남아 있지 않아야합니다. 일반적 으로이 코드를 사용하여 이미지 회전 (소스 및 대상 비트 맵)을 수행하므로 앱에서 동시에 2 비트 맵을 메모리에로드해야하며 25 %는 이미지 회전을 수행 할 때 메모리가 부족하지 않은 상태에서 좋은 버퍼를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="be1ebee6d533ac5f91df22838053b293abd1093c" translate="yes" xml:space="preserve">
          <source>I think best way to avoid the &lt;code&gt;OutOfMemoryError&lt;/code&gt; is to face it and understand it.</source>
          <target state="translated">&lt;code&gt;OutOfMemoryError&lt;/code&gt; 를 피하는 가장 좋은 방법은 그것을 직면하고 이해하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb7fdde6f7588fa4661d28589535e5ae66450cc5" translate="yes" xml:space="preserve">
          <source>I think there is a problem with the native function used in decodeStream/decodeFile. I have confirmed that a different native method is called when using decodeFileDescriptor.  Also what I've read is &quot;that Images (Bitmaps) are not allocated in a standard Java way but via native calls; the allocations are done outside of the virtual heap, but are
&lt;strong&gt;&lt;em&gt;counted against it!&lt;/em&gt;&lt;/strong&gt;&quot;</source>
          <target state="translated">decodeStream / decodeFile에 사용 된 기본 함수에 문제가 있다고 생각합니다. decodeFileDescriptor를 사용할 때 다른 기본 메소드가 호출되는 것을 확인했습니다. 또한 내가 읽은 것은 &quot;이미지 (비트 맵)는 표준 Java 방식으로 할당되지 않고 네이티브 호출을 통해 할당됩니다. 할당은 가상 힙 외부에서 이루어 지지만 이에 대해 &lt;strong&gt;&lt;em&gt;계산됩니다!&lt;/em&gt;&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="89d03da63fffe99b55265fa19e6085ce6f7c68b9" translate="yes" xml:space="preserve">
          <source>I'm gonna talk about SDK versions before Honey Comb first.</source>
          <target state="translated">허니 콤 전에 SDK 버전에 대해 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="949b7e396b503afc7e60ed24080a292eb274cd8c" translate="yes" xml:space="preserve">
          <source>I've made a small improvement to Fedor's code. It basically does the same, but without the (in my opinion) ugly while loop and it always results in a power of two. Kudos to Fedor for making the original solution, I was stuck until I found his, and then I was able to make this one :)</source>
          <target state="translated">Fedor의 코드를 약간 개선했습니다. 기본적으로는 동일하지만 (제 생각에는) 추악한 while 루프가 없으면 항상 2의 거듭 제곱이됩니다. 독창적 인 솔루션을 만들기 위해 Fedor에게 Kudos를, 나는 그의 발견 할 때까지 붙어 있었고, 나는 이것을 만들 수있었습니다 :)</target>
        </trans-unit>
        <trans-unit id="f572a323e69f42f2995af8376e6833205e919d12" translate="yes" xml:space="preserve">
          <source>I've spent the entire day testing these solutions and the only thing that worked for me is the above approaches for getting the image and manually calling the GC, which I know is not supposed to be necessary, but it is the only thing that worked when I put my app under heavy load testing switching between activities.  My app has a list of thumbnail images in a listview in (lets say activity A) and when you click on one of those images it takes you to another activity (lets say activity B) that shows a main image for that item.  When I would switch back and forth between the two activities, I would eventually get the OOM error and the app would force close.</source>
          <target state="translated">나는 하루 종일 이러한 솔루션을 테스트했으며 나를 위해 일한 유일한 것은 이미지를 가져 와서 수동으로 GC를 호출하는 위의 접근 방식입니다. 필요하지는 않지만 알 수는 없었습니다. 액티비티간에 전환하는 중부 하 테스트를 수행 할 때 내 응용 프로그램에는 목록보기에 축소판 이미지 목록이 있습니다 (활동 A라고 말하십시오).이 이미지 중 하나를 클릭하면 해당 항목의 기본 이미지를 보여주는 다른 활동 (활동 B라고 함)으로 이동합니다. 두 활동 사이를 전환 할 때 결국 OOM 오류가 발생하고 앱이 강제로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="6d49a2855b498c0fef974a894bdc320dc6145acf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;you are flinging&lt;/em&gt; the &lt;code&gt;ListView&lt;/code&gt; away, it simply won't download the bitmaps between</source>
          <target state="translated">&lt;code&gt;ListView&lt;/code&gt; 를 멀리 떨어 &lt;em&gt;뜨리면&lt;/em&gt; 단순히 비트 맵을 다운로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aae26a8106e5c91b33735bff022f3cde761adb3a" translate="yes" xml:space="preserve">
          <source>If you scheduled a repeating or delayed task, for example a Timer, and you do not call cancel() and purge() in onPause(), memory would be leaked.</source>
          <target state="translated">타이머와 같이 반복되거나 지연된 작업을 예약하고 onPause ()에서 cancel () 및 purge ()를 호출하지 않으면 메모리가 누출됩니다.</target>
        </trans-unit>
        <trans-unit id="8b45d3552db7a9f1666671b53d59f302a103fcd8" translate="yes" xml:space="preserve">
          <source>If {VM heap size} + {allocated native heap memory} &amp;gt;= {VM heap size limit for the device}, and you are trying to create bitmap, OOM will be thrown.</source>
          <target state="translated">{VM 힙 크기} + {할당 된 기본 힙 메모리}&amp;gt; = {장치의 VM 힙 크기 제한}이고 비트 맵을 작성하려고하면 OOM이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="49e7f074b8cc99d872d2d1216825c26fffff2a73" translate="yes" xml:space="preserve">
          <source>In one of my application i need to take picture either from &lt;code&gt;Camera/Gallery&lt;/code&gt;. If user click image from Camera(may be 2MP, 5MP or 8MP), image size varies from &lt;code&gt;kB&lt;/code&gt;s to &lt;code&gt;MB&lt;/code&gt;s. If image size is less(or up to 1-2MB) above code working fine but if i have image of size above 4MB or 5MB then &lt;code&gt;OOM&lt;/code&gt; comes in frame :(</source>
          <target state="translated">내 응용 프로그램 중 하나에서 &lt;code&gt;Camera/Gallery&lt;/code&gt; 에서 사진을 찍어야합니다. 사용자가 카메라에서 이미지를 클릭하면 (2MP, 5MP 또는 8MP 일 수 있음) 이미지 크기는 &lt;code&gt;kB&lt;/code&gt; s에서 &lt;code&gt;MB&lt;/code&gt; s까지 다양합니다. 이미지 크기가 위의 코드보다 작거나 최대 1-2MB이면 정상적으로 작동하지만 4MB 또는 5MB보다 큰 이미지의 이미지가 있으면 &lt;code&gt;OOM&lt;/code&gt; 이 프레임에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="dd98994863f2d2fdf584dc5c4b2152d193280740" translate="yes" xml:space="preserve">
          <source>Is there a way I can build the list adapter easily row by row, where I can resize on the fly (&lt;em&gt;bit wise&lt;/em&gt;)?</source>
          <target state="translated">목록 어댑터를 한 줄씩 쉽게 만들 수있는 방법이 있습니까? 여기서 &lt;em&gt;비트&lt;/em&gt; 크기를 조정할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c3345639637ff08fe7c9ede8ee3564a6b1257d50" translate="yes" xml:space="preserve">
          <source>It seems that this is a very long running problem, with a lot of differing explanations.  I took the advice of the two most common presented answers here, but neither one of these solved my problems of the VM claiming it couldn't afford the bytes to perform the &lt;strong&gt;decoding&lt;/strong&gt; part of the process.  After some digging I learned that the real problem here is the decoding process taking away from the &lt;strong&gt;NATIVE&lt;/strong&gt; heap.</source>
          <target state="translated">이것은 많은 다른 설명과 함께 매우 오래 실행되는 문제인 것 같습니다. 나는 여기에 가장 일반적인 두 가지 답변에 대한 조언을 얻었지만이 중 어느 것도 VM이 프로세스의 &lt;strong&gt;디코딩&lt;/strong&gt; 부분을 ​​수행 할 바이트를 감당할 수 없다고 주장하는 VM의 문제를 해결하지 못했습니다. 약간의 파기 후에 나는 여기서 실제 문제가 &lt;strong&gt;NATIVE&lt;/strong&gt; 힙에서 제거하는 디코딩 프로세스라는 것을 알게되었습니다.</target>
        </trans-unit>
        <trans-unit id="212e829919910956b61b83294caa292f0c725558" translate="yes" xml:space="preserve">
          <source>It's a &lt;a href=&quot;http://code.google.com/p/android/issues/detail?id=8488&quot;&gt;known bug&lt;/a&gt;, it's not because of large files. Since Android Caches the Drawables, it's going out of memory after using few images. But I've found an alternate way for it, by skipping the android default cache system.</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/android/issues/detail?id=8488&quot;&gt;알려진 버그&lt;/a&gt; 이며 큰 파일 때문이 아닙니다. Android는 Drawables를 캐시하므로 이미지를 거의 사용하지 않으면 메모리가 부족합니다. 그러나 안드로이드 기본 캐시 시스템을 건너 뛰어 대체 방법을 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="87c40bac9ed5b0407f1d8f530751ca38621a14df" translate="yes" xml:space="preserve">
          <source>Large bitmaps &lt;em&gt;gets scaled&lt;/em&gt; (you can define the maximum pixels that you want to allow)</source>
          <target state="translated">큰 비트 맵의 &lt;em&gt;크기가 조정됩니다&lt;/em&gt; (허용하려는 최대 픽셀을 정의 할 수 있음)</target>
        </trans-unit>
        <trans-unit id="8678809351d8e9e866f9fb346e60b5b2ea5382df" translate="yes" xml:space="preserve">
          <source>Last words:</source>
          <target state="translated">마지막 말:</target>
        </trans-unit>
        <trans-unit id="32aee2a63bf12b3e42d6f178b7670e25eb19b3af" translate="yes" xml:space="preserve">
          <source>Load a scaled down version into Memory</source>
          <target state="translated">축소 된 버전을 메모리에로드</target>
        </trans-unit>
        <trans-unit id="59d71b903d7086e09cd387175e346c3f8a597a02" translate="yes" xml:space="preserve">
          <source>Look at the end of this answer for a link to the source code.</source>
          <target state="translated">소스 코드에 대한 링크는이 답변의 끝 부분을보십시오.</target>
        </trans-unit>
        <trans-unit id="0c2bdc40e8343d1d94d6a69dc85aeca934ae99de" translate="yes" xml:space="preserve">
          <source>MainActivity.java's critical stuff:</source>
          <target state="translated">MainActivity.java의 중요한 것들 :</target>
        </trans-unit>
        <trans-unit id="83a207a33592bbc545cc207ae6453335028a666e" translate="yes" xml:space="preserve">
          <source>Makes sure that you are only instantiating &lt;em&gt;one task&lt;/em&gt; per row</source>
          <target state="translated">행당 &lt;em&gt;하나의 작업&lt;/em&gt; 만 인스턴스화해야합니다.</target>
        </trans-unit>
        <trans-unit id="95b33b353acf294ef83e9aa5fea20dcd94f0383c" translate="yes" xml:space="preserve">
          <source>Manually call System.gc() is meaningless, the system will call it first before trying to grow the heap size.</source>
          <target state="translated">System.gc ()를 수동으로 호출하는 것은 의미가 없습니다. 힙 크기를 늘리기 전에 시스템에서 먼저 호출합니다.</target>
        </trans-unit>
        <trans-unit id="fad3a84456f058bb312145ad5ce97cf5778734fb" translate="yes" xml:space="preserve">
          <source>More on that topic here: &lt;a href=&quot;http://groups.google.com/group/android-developers/browse_thread/thread/146a3a354ce3e8e3/61e113036089d696&quot;&gt;Is the limit of memory heap only 6M? &lt;/a&gt;</source>
          <target state="translated">이 주제에 대한 자세한 내용은 다음과 같습니다. &lt;a href=&quot;http://groups.google.com/group/android-developers/browse_thread/thread/146a3a354ce3e8e3/61e113036089d696&quot;&gt;메모리 힙 제한이 6M입니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a9f9d53cd957a664f586e1fac925b35dac68f30" translate="yes" xml:space="preserve">
          <source>My 2 cents: i solved my OOM errors with bitmaps by:</source>
          <target state="translated">내 2 센트 : 비트 맵으로 OOM 오류를 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="b3a39586148364aa68cde4adff75f273148bbe39" translate="yes" xml:space="preserve">
          <source>NOTICE: VM HEAP SIZE is counted rather than VM ALLOCATED MEMORY.</source>
          <target state="translated">주의 사항 : VM ALLOCATED MEMORY가 아닌 VM HEAP SIZE가 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d9a2f4e5272d151e35ec41d7fe1283ecec32b9fb" translate="yes" xml:space="preserve">
          <source>Native Heap Size will never shrink too, but it's not counted for OOM, so no need to worry about it.</source>
          <target state="translated">기본 힙 크기도 축소되지 않지만 OOM에는 포함되지 않으므로 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="54879c96b74bbe786d1bd7159a8b0599d4c321f0" translate="yes" xml:space="preserve">
          <source>None of the answers above worked for me, but I did come up with a horribly ugly workaround that solved the problem. I added a very small, 1x1 pixel image to my project as a resource, and loaded it into my ImageView before calling into garbage collection. I think it might be that the ImageView was not releasing the Bitmap, so GC never picked it up. It's ugly, but it seems to be working for now.</source>
          <target state="translated">위의 답변 중 어느 것도 나를 위해 효과가 없었지만 문제를 해결하는 끔찍한 추악한 해결 방법을 생각해 냈습니다. 매우 작은 1x1 픽셀 이미지를 프로젝트에 리소스로 추가하고 가비지 수집을 호출하기 전에 ImageView에로드했습니다. ImageView가 비트 맵을 발표하지 않았을 가능성이 있으므로 GC는 그것을 선택하지 않았습니다. 추악하지만 지금은 효과가있는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f8894f2abf440bb9aeea96c883d859a08c12297" translate="yes" xml:space="preserve">
          <source>Now since your image is in a file somewhere (or may even be coming from an external server), it is YOUR responsibility to cache the decoded bitmap instance to be reused any where it is needed.</source>
          <target state="translated">이제 이미지가 파일 어딘가에 있거나 외부 서버에서 온 것일 수도 있으므로, 디코딩 된 비트 맵 인스턴스를 캐시하여 필요한 곳에서 재사용 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad220e4cd6cb224186c1ca16f667ece57dba20f3" translate="yes" xml:space="preserve">
          <source>Now that the image dimensions are known, they can be used to decide if the full image should be loaded into memory or if a subsampled version should be loaded instead. Here are some factors to consider:</source>
          <target state="translated">이제 이미지 크기를 알았으므로 전체 이미지를 메모리에로드해야하는지 또는 서브 샘플링 된 버전을로드해야하는지 결정하는 데 사용할 수 있습니다. 고려해야 할 몇 가지 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2a795044eb263e6638bc4149db07fd71cd76aac" translate="yes" xml:space="preserve">
          <source>Now when I implement the following in activity B, I can go through the entire listview with no issue and keep going and going and going...and its plenty fast.</source>
          <target state="translated">이제 활동 B에서 다음을 구현하면 문제없이 전체 목록보기를 진행하고 계속 진행하고 계속 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="902e1f686c28630c2a04528f7d145b6094c53aba" translate="yes" xml:space="preserve">
          <source>Now, having said all of this, I am a complete dunce with Java and Android too.  So if you think this is a terrible way to solve this problem, you are probably right.  ;-)  But this has worked wonders for me, and I have found it impossible to run the VM out of heap cache now.  The only drawback I can find is that you are trashing your cached drawn image.  Which means if you go RIGHT back to that image, you are redrawing it each and every time.  In the case of how my application works, that is not really a problem.  Your mileage may vary.</source>
          <target state="translated">이제,이 모든 것을 말했듯이, 나는 Java와 Android도 완벽하게 다루고 있습니다. 따라서 이것이이 문제를 해결하는 끔찍한 방법이라고 생각한다면 아마도 옳을 것입니다. ;-) 그러나 이것은 나를 위해 놀라운 일이었고 지금은 힙 캐시에서 VM을 실행하는 것이 불가능하다는 것을 알았습니다. 내가 찾을 수있는 유일한 단점은 캐시 된 그려진 이미지를 휴지통에 버리는 것입니다. 즉, 해당 이미지로 다시 돌아 가면 매번 다시 그립니다. 내 응용 프로그램이 작동하는 방식은 실제로 문제가되지 않습니다. 귀하의 마일리지가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="035dbf096a64f11fe2822c4a18f107046d3f5703" translate="yes" xml:space="preserve">
          <source>Read Bitmap Dimensions and Type</source>
          <target state="translated">비트 맵 치수 및 유형 읽기</target>
        </trans-unit>
        <trans-unit id="ab9146b1673102ddbc5c7115d7b318805bd47098" translate="yes" xml:space="preserve">
          <source>Report errors in the comments! :-)</source>
          <target state="translated">의견에 오류를 신고하십시오! :-)</target>
        </trans-unit>
        <trans-unit id="475ffa14014bb463965306813410e4afd01a7039" translate="yes" xml:space="preserve">
          <source>Requirements:</source>
          <target state="translated">Requirements:</target>
        </trans-unit>
        <trans-unit id="bbd19d7653cc08e0948d447b0d060fac147cb4d7" translate="yes" xml:space="preserve">
          <source>Sample code:</source>
          <target state="translated">샘플 코드 :</target>
        </trans-unit>
        <trans-unit id="ce7e680b40c93d87fca537a049ec0c6773e8cc78" translate="yes" xml:space="preserve">
          <source>Screen size and density of the current device.</source>
          <target state="translated">현재 장치의 화면 크기 및 밀도</target>
        </trans-unit>
        <trans-unit id="202c0c493954cb7331141e65ff5574bc316f7006" translate="yes" xml:space="preserve">
          <source>See here: &lt;a href=&quot;https://stackoverflow.com/questions/1955410/bitmapfactory-oom-driving-me-nuts/5493182#5493182&quot;&gt;BitmapFactory OOM driving me nuts&lt;/a&gt;</source>
          <target state="translated">여기를 참조하십시오 : &lt;a href=&quot;https://stackoverflow.com/questions/1955410/bitmapfactory-oom-driving-me-nuts/5493182#5493182&quot;&gt;BitmapFactory OOM이 나를 미치게&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="34f1933bc01cc5bf7557f841a052257210fb860e" translate="yes" xml:space="preserve">
          <source>So please check in a device. It may be run in device.</source>
          <target state="translated">장치를 확인하십시오. 장치에서 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1664354fdd92ce3acf492010afdff1a0f35d11b7" translate="yes" xml:space="preserve">
          <source>So you have more available memory to create bitmap with the same heap size limit,  OOM is less likely to be thrown.</source>
          <target state="translated">따라서 동일한 힙 크기 제한으로 비트 맵을 만들 수있는 사용 가능한 메모리가 더 많으므로 OOM 발생 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="8e003454e74d8952ecfc04329daac1b2362fc26b" translate="yes" xml:space="preserve">
          <source>So you have to keep the peak VM memory as low as possible to keep VM Heap Size from growing too big to save available memory for Bitmaps.</source>
          <target state="translated">따라서 비트 맵에 사용 가능한 메모리를 절약하기 위해 VM 힙 크기가 너무 커지지 않도록 피크 VM 메모리를 최대한 낮게 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b66c6e8db0c80867e9069f6c30289a860680ca4" translate="yes" xml:space="preserve">
          <source>Strange out of memory issue while loading an image to a Bitmap object</source>
          <target state="translated">비트 맵 객체에 이미지를로드하는 동안 메모리 부족 문제</target>
        </trans-unit>
        <trans-unit id="72f1f2daff69d0af1a894aec65d8485be42e1160" translate="yes" xml:space="preserve">
          <source>Such &lt;code&gt;OutofMemoryException&lt;/code&gt; cannot be totally resolved by calling the &lt;code&gt;System.gc()&lt;/code&gt; and so on .</source>
          <target state="translated">이러한 &lt;code&gt;OutofMemoryException&lt;/code&gt; 은 &lt;code&gt;System.gc()&lt;/code&gt; 등을 호출하여 완전히 해결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="37a396c052474568e5e78e72fcb66454313d2c6e" translate="yes" xml:space="preserve">
          <source>That lead me to another discussion thread where I found a couple more solutions to this problem.  One is to call&lt;code&gt;System.gc();&lt;/code&gt; manually after your image is displayed.  But that actually makes your app use MORE memory, in an effort to reduce the native heap.  The better solution as of the release of 2.0 (Donut) is to use the BitmapFactory option &quot;inPurgeable&quot;.  So I simply added &lt;code&gt;o2.inPurgeable=true;&lt;/code&gt; just after &lt;code&gt;o2.inSampleSize=scale;&lt;/code&gt;.</source>
          <target state="translated">이 문제에 대한 몇 가지 해결책을 찾은 또 다른 토론 스레드로 연결되었습니다. 하나는 &lt;code&gt;System.gc();&lt;/code&gt; 를 호출하는 것입니다 . 이미지가 표시된 후 수동으로. 그러나 실제로 기본 힙을 줄이기 위해 앱에서 더 많은 메모리를 사용합니다. 2.0 (Donut) 릴리스에서 더 나은 솔루션은 BitmapFactory 옵션 &quot;inPurgeable&quot;을 사용하는 것입니다. 그래서 간단히 &lt;code&gt;o2.inPurgeable=true;&lt;/code&gt; 를 추가 했습니다. &lt;code&gt;o2.inSampleSize=scale;&lt;/code&gt; 직후 ; .</target>
        </trans-unit>
        <trans-unit id="9ff6aebc5a428a3373320888b302b859e74ecd31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://developer.android.com/reference/android/util/LruCache.html&quot;&gt;&lt;code&gt;LruCache&lt;/code&gt;&lt;/a&gt; has a good way to deal with bitmaps. However, in this application I put an instance of an &lt;code&gt;LruCache&lt;/code&gt; inside another cache class that I created in order to get the application more feasible.</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/reference/android/util/LruCache.html&quot;&gt; &lt;code&gt;LruCache&lt;/code&gt; &lt;/a&gt; 는 비트 맵을 다루는 좋은 방법이 있습니다. 그러나이 응용 프로그램에서 &lt;code&gt;LruCache&lt;/code&gt; 인스턴스를 응용 프로그램을 더 실현하기 위해 만든 다른 캐시 클래스에 넣었 습니다.</target>
        </trans-unit>
        <trans-unit id="64f673a944a2cbfbb517a096df3685f58f381856" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://developer.android.com/training/index.html&quot;&gt;Android Training&lt;/a&gt; class, &quot;&lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/index.html&quot;&gt;Displaying Bitmaps Efficiently&lt;/a&gt;&quot;, offers some great information for understanding and dealing with the exception &lt;code&gt;java.lang.OutOfMemoryError: bitmap size exceeds VM budget&lt;/code&gt; when loading Bitmaps.</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/index.html&quot;&gt;비트 맵을 효율적으로 표시&lt;/a&gt; 하는 &lt;a href=&quot;http://developer.android.com/training/index.html&quot;&gt;Android Training&lt;/a&gt; 클래스는 예외 &lt;code&gt;java.lang.OutOfMemoryError: bitmap size exceeds VM budget&lt;/code&gt; 를 이해하고 처리하는 데 유용한 정보를 제공합니다 . 비트 맵을 로드 할 때 비트 맵 크기가 VM 예산을 초과 합니다.</target>
        </trans-unit>
        <trans-unit id="6e661b93c0459b86a470bf78ee4b300cf5c24057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BitmapFactory&lt;/code&gt; class provides several decoding methods (&lt;code&gt;decodeByteArray()&lt;/code&gt;, &lt;code&gt;decodeFile()&lt;/code&gt;, &lt;code&gt;decodeResource()&lt;/code&gt;, etc.) for creating a &lt;code&gt;Bitmap&lt;/code&gt; from various sources. Choose the most appropriate decode method based on your image data source. These methods attempt to allocate memory for the constructed bitmap and therefore can easily result in an &lt;code&gt;OutOfMemory&lt;/code&gt; exception. Each type of decode method has additional signatures that let you specify decoding options via the &lt;code&gt;BitmapFactory.Options&lt;/code&gt; class. Setting the &lt;code&gt;inJustDecodeBounds&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; while decoding avoids memory allocation, returning &lt;code&gt;null&lt;/code&gt; for the bitmap object but setting &lt;code&gt;outWidth&lt;/code&gt;, &lt;code&gt;outHeight&lt;/code&gt; and &lt;code&gt;outMimeType&lt;/code&gt;. This technique allows you to read the dimensions and type of the image data prior to construction (and memory allocation) of the bitmap.</source>
          <target state="translated">&lt;code&gt;BitmapFactory&lt;/code&gt; 클래스는 다양한 소스에서 &lt;code&gt;Bitmap&lt;/code&gt; 을 작성하기위한 몇 가지 디코딩 메소드 ( &lt;code&gt;decodeByteArray()&lt;/code&gt; , &lt;code&gt;decodeFile()&lt;/code&gt; , &lt;code&gt;decodeResource()&lt;/code&gt; 등)를 제공합니다. 이미지 데이터 소스에 따라 가장 적합한 디코딩 방법을 선택하십시오. 이러한 메소드는 구성된 비트 맵에 메모리를 할당하려고 시도하므로 &lt;code&gt;OutOfMemory&lt;/code&gt; 예외가 쉽게 발생할 수 있습니다. 각 유형의 디코딩 방법에는 &lt;code&gt;BitmapFactory.Options&lt;/code&gt; 클래스를 통해 디코딩 옵션을 지정할 수있는 추가 서명이 있습니다. 디코딩하는 동안 &lt;code&gt;inJustDecodeBounds&lt;/code&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 메모리 할당을 피하여 비트 맵 객체에 대해 &lt;code&gt;null&lt;/code&gt; 을 반환하지만 &lt;code&gt;outWidth&lt;/code&gt; , &lt;code&gt;outHeight&lt;/code&gt; 및 &lt;code&gt;outMimeType&lt;/code&gt; 을 설정합니다. 이 기술을 사용하면 비트 맵을 구성 (및 메모리 할당)하기 전에 이미지 데이터의 크기와 유형을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="617f4327d13a0a613a5190e16101142d1b68a40b" translate="yes" xml:space="preserve">
          <source>The Activity States are determined by the OS itself subject to the memory usage for each process and the priority of each process.</source>
          <target state="translated">활동 상태는 각 프로세스의 메모리 사용량과 각 프로세스의 우선 순위에 따라 OS 자체에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="417869f28c90577e509bcf77a07d44d70fbf0454" translate="yes" xml:space="preserve">
          <source>The amount of memory you are willing to commit to loading this image given any other memory requirements of your application.</source>
          <target state="translated">응용 프로그램의 다른 메모리 요구 사항이 주어지면이 이미지를로드하려고 할 메모리 양입니다.</target>
        </trans-unit>
        <trans-unit id="1a9e27d3055bbb1d01dcb44e5f8b8bb80b139083" translate="yes" xml:space="preserve">
          <source>The condition for OOM is much simpler: {VM heap size} &amp;gt;= {VM heap size limit for the device}.</source>
          <target state="translated">OOM의 조건은 {VM 힙 크기}&amp;gt; = {장치의 VM 힙 크기 제한}보다 훨씬 간단합니다.</target>
        </trans-unit>
        <trans-unit id="5c046e88d1a921489d9dffe41d8908c149e21116" translate="yes" xml:space="preserve">
          <source>The gist of it is to calculate the maximum memory allocated for the app on a particular device, then set the scale to be lowest possible without exceeding this memory. Here's the code:</source>
          <target state="translated">요점은 특정 장치에서 앱에 할당 된 최대 메모리를 계산 한 다음이 메모리를 초과하지 않고 스케일을 가능한 가장 낮게 설정하는 것입니다. 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7906221e833c9985371afb28753819159d2d104" translate="yes" xml:space="preserve">
          <source>The image preview on the list view is being done with the cursor and &lt;code&gt;ListAdapter&lt;/code&gt;. This makes it pretty simple, but I am not sure how I can put a resized image (I.e. Smaller bit size not pixel as the &lt;code&gt;src&lt;/code&gt; for the image button on the fly. So I just resized the image that came off the phone camera.</source>
          <target state="translated">커서와 &lt;code&gt;ListAdapter&lt;/code&gt; 로 목록보기의 이미지 미리보기가 수행됩니다. 이것은 매우 간단하지만 크기가 조정 된 이미지를 넣을 수있는 방법을 잘 모르겠습니다 (즉, 이미지 버튼의 &lt;code&gt;src&lt;/code&gt; 로 픽셀이 아닌 작은 비트 크기) 즉석 전화 카메라에서 나온 이미지의 크기를 조정했습니다.</target>
        </trans-unit>
        <trans-unit id="881de785d39773ca03137cf7aaf2b8fb8fbc92b5" translate="yes" xml:space="preserve">
          <source>The images that are being downloaded are images (75x75) from Flickr. However, put whatever image urls you want to be processed, and the application will scale it down if it exceeds the maximum. In this application the urls are simply in a &lt;code&gt;String&lt;/code&gt; array.</source>
          <target state="translated">다운로드중인 이미지는 Flickr의 이미지 (75x75)입니다. 그러나 처리하려는 이미지 URL을 입력하고 최대 값을 초과하면 응용 프로그램에서 이미지 크기를 줄입니다. 이 응용 프로그램에서 URL은 단순히 &lt;code&gt;String&lt;/code&gt; 배열에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f9a96a13ca2ff8309b627254b404a92c7ccfb45" translate="yes" xml:space="preserve">
          <source>The issue is that I get an out of memory error when it tries to go back and re-launch the 2nd activity.</source>
          <target state="translated">문제는 돌아가서 두 번째 활동을 다시 시작하려고 할 때 메모리 부족 오류가 발생한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1b3fe0b14ae50ce78dc0f11e36bb1bbae4dceb35" translate="yes" xml:space="preserve">
          <source>Then, let's talk about SDK Starts from Honey Comb.</source>
          <target state="translated">그런 다음 Honey Comb의 SDK 시작에 대해 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="7eb770ec595c754acc60ae25455a0c3d685c99f7" translate="yes" xml:space="preserve">
          <source>There are two issues here....</source>
          <target state="translated">여기에 두 가지 문제가 있습니다 ....</target>
        </trans-unit>
        <trans-unit id="92a822662c6a874d0c9af95dec02a3a2fec8f74d" translate="yes" xml:space="preserve">
          <source>There is only one possible scenario where I can imagine that the OOM will appear, and that is if we download many, really big images, and before they get scaled and put into cache, will simultaneously take up more memory and cause an OOM. But that isn't even an ideal situation anyway and it most likely won't be possible to solve in a more feasible way.</source>
          <target state="translated">OOM이 나타날 것이라고 상상할 수있는 시나리오는 하나뿐입니다. 실제로 많은 큰 이미지를 다운로드하고 크기를 조정하고 캐시에 넣기 전에 동시에 더 많은 메모리를 차지하고 OOM을 유발할 수 있습니다. 그러나 그것은 어쨌든 이상적인 상황은 아니며 더 실현 가능한 방법으로는 해결할 수 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="00d9ad0894bf0c0ece2432d8d50bce27ee712197" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;inSampleSize&lt;/code&gt; option reduces memory consumption.</source>
          <target state="translated">이 &lt;code&gt;inSampleSize&lt;/code&gt; 옵션은 메모리 소비를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="68151546c4f61ab7739aaa7c622046933070f857" translate="yes" xml:space="preserve">
          <source>This code will help to load large bitmap from drawable</source>
          <target state="translated">이 코드는 드로어 블에서 큰 비트 맵을로드하는 데 도움이됩니다</target>
        </trans-unit>
        <trans-unit id="fc774592f32c7c998ede5a84451cdc61ee17210b" translate="yes" xml:space="preserve">
          <source>This does not include:</source>
          <target state="translated">여기에는 다음이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49741fc52da958e447dcb1d70d7f5bc8545bbfc3" translate="yes" xml:space="preserve">
          <source>This is almost guaranteed to save you hours if not days. All that talk about scaling the image, etc. does not really work (unless you consider getting wrong size or degraded image a solution).</source>
          <target state="translated">며칠이 아니라면 시간을 절약 할 수 있습니다. 이미지 크기 조정 등에 대한 모든 이야기는 실제로 작동하지 않습니다 (잘못된 크기를 얻거나 이미지의 해상도가 떨어지는 것을 고려하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="1adf5fc889e0ac6a44110a0c1935d18af31dbcd2" translate="yes" xml:space="preserve">
          <source>This is because AsyncTask is an instance of an anonymous inner class, it holds a reference of the Activity.</source>
          <target state="translated">AsyncTask는 익명의 내부 클래스의 인스턴스이므로 Activity에 대한 참조를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="31c9695f6e300ed35b6c8a9e69cc4b8ae89fc837" translate="yes" xml:space="preserve">
          <source>This issue only happens in Android emulators. I also faced this issue in an emulator but when I checked in a device then it worked fine.</source>
          <target state="translated">이 문제는 Android 에뮬레이터에서만 발생합니다. 또한 에뮬레이터 에서이 문제에 직면했지만 장치를 체크인하면 정상적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="25fa0ce83b96a1bf53c72341f7de9287e367373c" translate="yes" xml:space="preserve">
          <source>This method makes it easy to load a bitmap of arbitrarily large size into an &lt;code&gt;ImageView&lt;/code&gt; that displays a 100x100 pixel thumbnail, as shown in the following example code:</source>
          <target state="translated">이 방법을 사용하면 다음 예제 코드와 같이 100x100 픽셀 축소판을 표시하는 &lt;code&gt;ImageView&lt;/code&gt; 에 임의로 큰 크기의 비트 맵을 쉽게로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b412b9ffc3f40429c9fd4b3c3a6e26c29f0579ef" translate="yes" xml:space="preserve">
          <source>This seems like the appropriate place to share my utility class for loading and processing images with the community, you are welcome to use it and modify it freely.</source>
          <target state="translated">이것은 이미지를로드하고 처리하기 위해 유틸리티 클래스를 커뮤니티와 공유 할 수있는 적절한 장소 인 것 같습니다. 자유롭게 사용하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c22f297ce30d1437a3a031b9295e728495fda9d" translate="yes" xml:space="preserve">
          <source>This will work because the actual binary data of the decoded bitmap is not stored within the dalvik VM heap. It is stored externally. So every time you decode a bitmap, it allocates memory outside of VM heap which is never reclaimed by GC</source>
          <target state="translated">이것은 디코딩 된 비트 맵의 ​​실제 이진 데이터가 dalvik VM 힙 내에 저장되지 않기 때문에 작동합니다. 외부에 저장됩니다. 따라서 비트 맵을 디코딩 할 때마다 GC에서 회수하지 않는 VM 힙 외부의 메모리를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="083571b73e7037527d98deb441337ef37561d9e3" translate="yes" xml:space="preserve">
          <source>This worked for me!</source>
          <target state="translated">이것은 나를 위해 일했다!</target>
        </trans-unit>
        <trans-unit id="ff3cc37ab695a425aff6adea4152c406e697b6ca" translate="yes" xml:space="preserve">
          <source>This works for me.</source>
          <target state="translated">이것은 나를 위해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b83a9cea18feba16553b9bcfb40c0d66a03ef1d7" translate="yes" xml:space="preserve">
          <source>This would be preferable as I also need to make some changes to the properties of the widgets/elements in each row as I am unable to select a row with the touch screen because of the focus issue. (&lt;em&gt;I can use roller ball.&lt;/em&gt;)</source>
          <target state="translated">포커스 문제로 인해 터치 스크린으로 행을 선택할 수 없으므로 각 행의 위젯 / 요소 속성을 일부 변경해야하기 때문에 바람직합니다. ( &lt;em&gt;롤러 볼을 사용할 수 있습니다.&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="d1c0eb4e84c2af1b6622c8a4e7d4606247637ac5" translate="yes" xml:space="preserve">
          <source>To avoid &lt;code&gt;java.lang.OutOfMemory&lt;/code&gt; exceptions, check the dimensions of a bitmap before decoding it, unless you absolutely trust the source to provide you with predictably sized image data that comfortably fits within the available memory.</source>
          <target state="translated">&lt;code&gt;java.lang.OutOfMemory&lt;/code&gt; 예외를 피하려면 사용 가능한 메모리에 편안하게 맞는 예측 가능한 크기의 이미지 데이터를 제공하도록 소스를 절대 신뢰하지 않는 한 비트 맵의 ​​크기를 디코딩 한 후 디코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="48d70a72fc4b6b1e69ce7fd5a7aec59543dba56c" translate="yes" xml:space="preserve">
          <source>To fix the OutOfMemory error, you should do something like this:</source>
          <target state="translated">OutOfMemory 오류를 해결하려면 다음과 같이해야합니다.</target>
        </trans-unit>
        <trans-unit id="65b13cbd1e14b5560d947288d163d6c54a93a42b" translate="yes" xml:space="preserve">
          <source>To help you better appreciate this, imagine you have kept ur image in the drawable folder. You just get the image by doing a getResources().getDrwable(R.drawable.). This will NOT decode your image everytime but re-use an already decoded instance everytime you call it. So in essence it is cached.</source>
          <target state="translated">이것을 더 잘 이해하려면 drawable 폴더에 ur 이미지를 보관했다고 가정하십시오. getResources (). getDrwable (R.drawable.)을 수행하여 이미지를 가져옵니다. 매번 이미지를 디코딩하지는 않지만 호출 할 때마다 이미 디코딩 된 인스턴스를 재사용합니다. 본질적으로 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="71eb65994b8a42ceb4636801be75eb60cea6fbf4" translate="yes" xml:space="preserve">
          <source>To tell the decoder to subsample the image, loading a smaller version into memory, set &lt;code&gt;inSampleSize&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in your &lt;code&gt;BitmapFactory.Options&lt;/code&gt; object. For example, an image with resolution 2048x1536 that is decoded with an &lt;code&gt;inSampleSize&lt;/code&gt; of 4 produces a bitmap of approximately 512x384. Loading this into memory uses 0.75MB rather than 12MB for the full image (assuming a bitmap configuration of &lt;code&gt;ARGB_8888&lt;/code&gt;). Here&amp;rsquo;s a method to calculate a sample size value that is a power of two based on a target width and height:</source>
          <target state="translated">디코더가 이미지를 서브 샘플링하고 더 작은 버전을 메모리에로드하도록하려면 &lt;code&gt;BitmapFactory.Options&lt;/code&gt; 객체에서 &lt;code&gt;inSampleSize&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오. 예를 들어, &lt;code&gt;inSampleSize&lt;/code&gt; 4로 디코딩 된 해상도 2048x1536의 이미지는 약 512x384의 비트 맵을 생성합니다. 이것을 메모리에로드하면 전체 이미지에 12MB가 아닌 0.75MB가 사용됩니다 (ARGB_8888의 비트 맵 구성 가정). 목표 너비와 높이에 따라 2의 거듭 제곱 인 표본 크기 값을 계산하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df352c8e2d07bd2d7dbdef1797f9c0346e5ecc46" translate="yes" xml:space="preserve">
          <source>To use this method, first decode with &lt;code&gt;inJustDecodeBounds&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, pass the options through and then decode again using the new &lt;code&gt;inSampleSize&lt;/code&gt; value and &lt;code&gt;inJustDecodeBounds&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">이 메소드를 사용하려면 먼저 &lt;code&gt;inJustDecodeBounds&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하고 디코딩 한 다음 옵션을 통과 한 다음 새 &lt;code&gt;inSampleSize&lt;/code&gt; 값과 &lt;code&gt;inJustDecodeBounds&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하여 다시 디코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="9749e1bdd9779ff26905faf23b25fa0ee6ff24a1" translate="yes" xml:space="preserve">
          <source>Use &lt;em&gt;one eighth&lt;/em&gt; of the assigned application memory to the cache (modify if you want)</source>
          <target state="translated">할당 된 응용 프로그램 메모리 &lt;em&gt;중 8 분&lt;/em&gt; 의 &lt;em&gt;1을&lt;/em&gt; 캐시에 사용합니다 (원하는 경우 수정).</target>
        </trans-unit>
        <trans-unit id="086b109c2c71c8a21f0af357fec8c21ffee53f19" translate="yes" xml:space="preserve">
          <source>Use this &lt;code&gt;bitmap.recycle();&lt;/code&gt; This helps without any image quality issue.</source>
          <target state="translated">이 &lt;code&gt;bitmap.recycle();&lt;/code&gt; 사용하십시오 . 이것은 이미지 품질 문제없이 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="9b4efae91171efc758e907e192f453bd7adb8a6a" translate="yes" xml:space="preserve">
          <source>VM Heap size will never shrink after grown, even if the allocated VM memory is shrinked.</source>
          <target state="translated">할당 된 VM 메모리가 축소 되더라도 VM 힙 크기는 커진 후에 축소되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e5a09a5ae7dbdb06951a426b6cf158547b19325" translate="yes" xml:space="preserve">
          <source>When I would get half way down the listview it would crash.</source>
          <target state="translated">내가 목록보기의 절반을 내리면 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c945a308d354091e2330620c81c8a0b0221e3e9f" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;R.id.imagefilename&lt;/code&gt; is a &lt;code&gt;ButtonImage&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;R.id.imagefilename&lt;/code&gt; 은 &lt;code&gt;ButtonImage&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="684e0710b7cc05acc8e388e5c53bb6116373051f" translate="yes" xml:space="preserve">
          <source>You can download the source code from &lt;a href=&quot;https://www.dropbox.com/s/pvr9zyl811tfeem/ListViewImageCache.zip&quot;&gt;https://www.dropbox.com/s/pvr9zyl811tfeem/ListViewImageCache.zip&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.dropbox.com/s/pvr9zyl811tfeem/ListViewImageCache.zip&quot;&gt;https://www.dropbox.com/s/pvr9zyl811tfeem/ListViewImageCache.zip&lt;/a&gt; 에서 소스 코드를 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73628b41fb9b25c155a21421306fbcce58da58cd" translate="yes" xml:space="preserve">
          <source>You can follow a similar process to decode bitmaps from other sources, by substituting the appropriate &lt;code&gt;BitmapFactory.decode*&lt;/code&gt; method as needed.</source>
          <target state="translated">필요에 따라 적절한 &lt;code&gt;BitmapFactory.decode*&lt;/code&gt; 메서드를 대체하여 유사한 프로세스에 따라 다른 소스에서 비트 맵을 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d794139a87d2b32089b831dc7c4fa49a35269032" translate="yes" xml:space="preserve">
          <source>You can see it yourself in the App. If an Activity executed an AsyncTask that was still running after the Activity was destroyed, the Activity will not get garbage collected until the AsyncTask finish.</source>
          <target state="translated">앱에서 직접 볼 수 있습니다. 활동이 활동이 종료 된 후에도 여전히 실행중인 AsyncTask를 실행 한 경우 AsyncTask가 완료 될 때까지 활동이 가비지 수집되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="356ca3448e5ea9eaa98cc0e959d7e34c0f22fa35" translate="yes" xml:space="preserve">
          <source>You may consider the size and the resolution for each of the bitmap pictures used. I recommend to reduce the size ,resample to lower resolution , refer to the design of galleries (one small picture PNG , and one original picture.)</source>
          <target state="translated">사용 된 각 비트 맵 그림의 크기와 해상도를 고려할 수 있습니다. 크기를 줄이고 해상도를 낮추려면 다시 샘플링하는 것이 좋습니다. 갤러리 디자인 (작은 그림 PNG 하나와 원본 그림 하나)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc28a9e5ebe1b3b73a20e45e1b52656870567674" translate="yes" xml:space="preserve">
          <source>You shouldn't need to edit anything in the Cache.java file unless you want to implement disk caching.</source>
          <target state="translated">디스크 캐싱을 구현하지 않는 한 Cache.java 파일에서 아무것도 편집하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="0dd213f54445d617f4d98ac140097719d49229b9" translate="yes" xml:space="preserve">
          <source>a) scaling my images by a factor of 2</source>
          <target state="translated">a) 2 배로 이미지 크기 조정</target>
        </trans-unit>
        <trans-unit id="72edad72ee3b57cafab52ff580d94c36c4e6e792" translate="yes" xml:space="preserve">
          <source>and this is on C# monodroid.
you can easily change the path of the image. what important here is the options to be set.</source>
          <target state="translated">그리고 이것은 C # monodroid에 있습니다. 이미지의 경로를 쉽게 변경할 수 있습니다. 여기서 중요한 것은 설정할 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="06449e6b2554561f87ea44d1680df513c4824509" translate="yes" xml:space="preserve">
          <source>b) using &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;Picasso&lt;/a&gt; library in my custom Adapter for a ListView, with a one-call in getView like this: &lt;code&gt;Picasso.with(context).load(R.id.myImage).into(R.id.myImageView);&lt;/code&gt;</source>
          <target state="translated">b) getView에서 한 번의 호출로 ListView에 대한 사용자 정의 어댑터에서 &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;Picasso&lt;/a&gt; 라이브러리를 다음과 같이 사용합니다. &lt;code&gt;Picasso.with(context).load(R.id.myImage).into(R.id.myImageView);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="960910ee56ce1c0c3410dd1ea2d9f24f2b9318b6" translate="yes" xml:space="preserve">
          <source>for more please refer &lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/load-bitmap.html&quot;&gt;&lt;em&gt;this&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/load-bitmap.html&quot;&gt;&lt;em&gt;이것을&lt;/em&gt;&lt;/a&gt; 참조 &lt;em&gt;하십시오&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe3747eb4c904bbf243426b3a4782c70145ee206" translate="yes" xml:space="preserve">
          <source>then i have worked to solve this issue &amp;amp; finally i've made the below improvement to Fedor's(All Credit to Fedor for making such a nice solution) code :)</source>
          <target state="translated">그런 다음이 문제를 해결하기 위해 노력했으며 마침내 Fedor의 (아래와 같은 훌륭한 솔루션을 만들기위한 모든 크레딧) 코드를 개선했습니다 :)</target>
        </trans-unit>
        <trans-unit id="5f200676e9d06c0a40c448510bed16ff1a13ccc7" translate="yes" xml:space="preserve">
          <source>use these code for every image in select from SdCard or drewable to convert bitmap object.</source>
          <target state="translated">SdCard에서 선택하거나 비트 맵 객체를 변환하기 위해 그릴 수있는 모든 이미지에이 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="beaddbd6b6bb9f62d2328be436e8d976a5b4fe6e" translate="yes" xml:space="preserve">
          <source>use your image path instend of &lt;strong&gt;ImageData_Path.get(img_pos).getPath()&lt;/strong&gt; .</source>
          <target state="translated">&lt;strong&gt;ImageData_Path.get (img_pos) .getPath ()&lt;/strong&gt; 의 이미지 경로를 사용하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
