<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/477572">
    <body>
      <group id="477572">
        <trans-unit id="e38d004047cde5eb417d48832f1998c8472bba00" translate="yes" xml:space="preserve">
          <source>1) Every time you do &lt;code&gt;BitmapFactory.decodeXYZ()&lt;/code&gt;, make sure to pass in a &lt;code&gt;BitmapFactory.Options&lt;/code&gt; with &lt;code&gt;inPurgeable&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; (and preferably with &lt;code&gt;inInputShareable&lt;/code&gt; also set to &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">1) Каждый раз, когда вы выполняете &lt;code&gt;BitmapFactory.decodeXYZ()&lt;/code&gt; , обязательно передайте &lt;code&gt;BitmapFactory.Options&lt;/code&gt; с &lt;code&gt;inPurgeable&lt;/code&gt; , установленным в значение &lt;code&gt;true&lt;/code&gt; (и, предпочтительно, с &lt;code&gt;inInputShareable&lt;/code&gt; , также установленным в значение &lt;code&gt;true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8782c067eeb1c1f90f926f8b5ee08512104fefc2" translate="yes" xml:space="preserve">
          <source>2) NEVER use &lt;code&gt;Bitmap.createBitmap(width, height, Config.ARGB_8888)&lt;/code&gt;. I mean NEVER! I've never had that thing not raise memory error after few passes. No amount of &lt;code&gt;recycle()&lt;/code&gt;, &lt;code&gt;System.gc()&lt;/code&gt;, whatever helped. It always raised exception. The one other way that actually works is to have a dummy image in your drawables (or another Bitmap that you decoded using step 1 above), rescale that to whatever you want, then manipulate the resulting Bitmap (such as passing it on to a Canvas for more fun). So, what you should use instead is: &lt;code&gt;Bitmap.createScaledBitmap(srcBitmap, width, height, false)&lt;/code&gt;. If for whatever reason you MUST use the brute force create method, then at least pass &lt;code&gt;Config.ARGB_4444&lt;/code&gt;.</source>
          <target state="translated">2) НИКОГДА не используйте &lt;code&gt;Bitmap.createBitmap(width, height, Config.ARGB_8888)&lt;/code&gt; . Я имею в виду НИКОГДА! У меня никогда не было, чтобы это не вызывало ошибку памяти после нескольких проходов. Никакое количество &lt;code&gt;recycle()&lt;/code&gt; , &lt;code&gt;System.gc()&lt;/code&gt; , что бы ни помогло. Это всегда вызывало исключение. Еще один способ, который действительно работает, заключается в том, чтобы иметь фиктивное изображение в ваших чертежах (или другое растровое изображение, которое вы декодировали с помощью шага 1, описанного выше), измените его масштаб на любое значение, а затем манипулируйте полученным растровым изображением (например, передавая его на холст). для большего удовольствия). Итак, что вы должны использовать вместо этого: &lt;code&gt;Bitmap.createScaledBitmap(srcBitmap, width, height, false)&lt;/code&gt; . Если по какой-либо причине вы ДОЛЖНЫ использовать метод создания грубой силы, то хотя бы передайте &lt;code&gt;Config.ARGB_4444&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="562263b1466294b7de472ca74c4560bbeb477dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decodeFileDescriptor&lt;/code&gt; looks like it calls different native methods than the decodeStream/decodeFile.</source>
          <target state="translated">&lt;code&gt;decodeFileDescriptor&lt;/code&gt; выглядит так, как будто он вызывает другие собственные методы, чем decodeStream / decodeFile.</target>
        </trans-unit>
        <trans-unit id="c0119b41f35b7e464151bc4394e0148b6c7c4fa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getView()&lt;/code&gt; gets called very often. It's normally not a good idea to download images there if we haven't implemented a check that ensure us that we won't start an infinite amount of threads per row. Cache.java checks whether the &lt;code&gt;rowObject.mBitmapUrl&lt;/code&gt; already is in a task and if it is, it won't start another. Therefore, we are most likely not exceeding the work queue restriction from the &lt;code&gt;AsyncTask&lt;/code&gt; pool.</source>
          <target state="translated">&lt;code&gt;getView()&lt;/code&gt; очень часто. Обычно не стоит загружать изображения туда, если мы не внедрили проверку, которая гарантирует, что мы не будем запускать бесконечное количество потоков в строке. Cache.java проверяет, есть ли &lt;code&gt;rowObject.mBitmapUrl&lt;/code&gt; в задаче, и если это так, она не запускает другую. Поэтому, скорее всего, мы не превышаем ограничение рабочей очереди из пула &lt;code&gt;AsyncTask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a2a7862a6c547b2e092e4cf80ae9639f368585c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Retains the cache if there is an orientation change&lt;/em&gt;, using a singleton</source>
          <target state="translated">&lt;em&gt;Сохраняет кеш при изменении ориентации&lt;/em&gt; , используя синглтон</target>
        </trans-unit>
        <trans-unit id="7baa5dc9710205332e50f61e26eb82dfa968082b" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;By referring to the &lt;a href=&quot;http://techpalle.com/blog/wp-content/uploads/2012/03/activity_lifecycle.png&quot;&gt;Activity Life Cycle&lt;/a&gt;&lt;/strike&gt;</source>
          <target state="translated">&lt;strike&gt;Ссылаясь на &lt;a href=&quot;http://techpalle.com/blog/wp-content/uploads/2012/03/activity_lifecycle.png&quot;&gt;жизненный цикл деятельности&lt;/a&gt;&lt;/strike&gt;</target>
        </trans-unit>
        <trans-unit id="738f489e8fcc88ac9846e9e94707b826be87e80a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: A power of two value is calculated because the decoder uses a
  final value by rounding down to the nearest power of two, as per the
  &lt;code&gt;inSampleSize&lt;/code&gt; documentation.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Значение степени два вычисляется, поскольку декодер использует конечное значение путем округления до ближайшего значения степени два, как &lt;code&gt;inSampleSize&lt;/code&gt; документации inSampleSize .</target>
        </trans-unit>
        <trans-unit id="3f154f989c2982b44c304392cc3fc4749629e582" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution&lt;/strong&gt;:
Move the images to &quot;assets&quot; folder and use the following function to get BitmapDrawable:</source>
          <target state="translated">&lt;strong&gt;Решение&lt;/strong&gt; . Переместите изображения в папку &amp;laquo;assets&amp;raquo; и используйте следующую функцию для получения BitmapDrawable:</target>
        </trans-unit>
        <trans-unit id="27301bb33e9a932b41cd4ef280ed71c4ba67d620" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unfortunately&lt;/strong&gt; if None of the Above works, then Add this to your &lt;strong&gt;Manifest&lt;/strong&gt; file. Inside &lt;em&gt;application&lt;/em&gt; tag</source>
          <target state="translated">&lt;strong&gt;к сожалению,&lt;/strong&gt; если ничего из вышеперечисленного не работает, добавьте это в свой файл &lt;strong&gt;манифеста&lt;/strong&gt; . Тег внутри &lt;em&gt;приложения&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ec8b07a0031298ce5bcdcf2e906e88cf818b728" translate="yes" xml:space="preserve">
          <source>After I've done a lot of experiments with this App, I've got the following conclusions:</source>
          <target state="translated">После того,как я провел много экспериментов с этим приложением,я пришел к следующим выводам:</target>
        </trans-unit>
        <trans-unit id="5d9f33ceb54e285b1f0f546fa5ae5441f81cf547" translate="yes" xml:space="preserve">
          <source>All the solutions here require setting a IMAGE_MAX_SIZE. This limits devices with more powerful hardware and if the image size is too low it looks ugly on the HD screen.</source>
          <target state="translated">Все решения здесь требуют установки IMAGE_MAX_SIZE.Это ограничивает возможности устройств с более мощным оборудованием,и если размер изображения слишком мал,оно будет выглядеть некрасиво на HD экране.</target>
        </trans-unit>
        <trans-unit id="1884733a3c481df7c2074ade429f3a9f9686109c" translate="yes" xml:space="preserve">
          <source>Android API 2.1 or higher (I simply could not manage to get the available memory for an application in API 1.6 - that is the only piece of code that doesn't work in API 1.6)</source>
          <target state="translated">Android API 2.1 или выше (я просто не смог получить доступную память для приложения в API 1.6-это единственный кусок кода,который не работает в API 1.6).</target>
        </trans-unit>
        <trans-unit id="c852378f8fd87cb6e98eea9753b7acf9191bc79d" translate="yes" xml:space="preserve">
          <source>Android support package</source>
          <target state="translated">пакет поддержки Android</target>
        </trans-unit>
        <trans-unit id="15f9db5a119d042a2a0dbcd8e7a20a243027d043" translate="yes" xml:space="preserve">
          <source>Anyways, what worked was this (note that I added some options as some had above, but that's not what made the difference. What is critical is the call to &lt;strong&gt;BitmapFactory.decodeFileDescriptor&lt;/strong&gt; instead of &lt;strong&gt;decodeStream&lt;/strong&gt; or &lt;strong&gt;decodeFile&lt;/strong&gt;):</source>
          <target state="translated">В любом случае, сработало следующее (обратите внимание, что я добавил несколько опций, как некоторые из них были выше, но это не то, что имело значение. Что важно, так это вызов &lt;strong&gt;BitmapFactory.decodeFileDescriptor&lt;/strong&gt; вместо &lt;strong&gt;decodeStream&lt;/strong&gt; или &lt;strong&gt;decodeFile&lt;/strong&gt; ):</target>
        </trans-unit>
        <trans-unit id="2a639f00f36e3a3df1f8a5ce44c1eba66c427656" translate="yes" xml:space="preserve">
          <source>As soon as I disabled the image on the list view it worked fine again.</source>
          <target state="translated">Как только я отключил изображение в просмотре списка,оно снова работало нормально.</target>
        </trans-unit>
        <trans-unit id="e04f7f19db81d0bbf4b2eaf9335fc544b05da2a3" translate="yes" xml:space="preserve">
          <source>Because of this I wrote an example application that demonstrates caching in an Android environment. This implementation has not yet gotten an OOM.</source>
          <target state="translated">Из-за этого я написал пример приложения,демонстрирующего кэширование в среде Android.Эта реализация еще не получила OOM.</target>
        </trans-unit>
        <trans-unit id="ee849ef8bc77f61c239846c451384637a9839373" translate="yes" xml:space="preserve">
          <source>Bitmap is stored in VM heap, Native memory is not counted for OOM.</source>
          <target state="translated">Битовая карта хранится в куче VM,для OOM не учитывается родная память.</target>
        </trans-unit>
        <trans-unit id="88672ca86836327b9dde502c2e5829f39cc85ff3" translate="yes" xml:space="preserve">
          <source>Bitmap is stored in native heap, but it will get garbage collected automatically, calling recycle() is needless.</source>
          <target state="translated">Битовая карта хранится в нативной куче,но при этом мусор будет собираться автоматически,вызов функции recycle()не нужен.</target>
        </trans-unit>
        <trans-unit id="205a822cd5bbafed369318fc3a950d9a83784750" translate="yes" xml:space="preserve">
          <source>Bitmap memory isn't in the VM heap but rather in the native heap - see &lt;a href=&quot;https://stackoverflow.com/questions/1955410/bitmapfactory-oom-driving-me-nuts/5493182#5493182&quot;&gt;BitmapFactory OOM driving me nuts&lt;/a&gt;</source>
          <target state="translated">Память растрового изображения находится не в куче виртуальной машины, а в собственной куче - см. &lt;a href=&quot;https://stackoverflow.com/questions/1955410/bitmapfactory-oom-driving-me-nuts/5493182#5493182&quot;&gt;BitmapFactory OOM сводит меня с ума&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2850c6f9080f7ab7710c811fdf37a52b2390e539" translate="yes" xml:space="preserve">
          <source>Cache.java's critical stuff (the &lt;code&gt;loadBitmap()&lt;/code&gt; method is the most important):</source>
          <target state="translated">Критические вещи &lt;code&gt;loadBitmap()&lt;/code&gt; наиболее важен метод loadBitmap () ):</target>
        </trans-unit>
        <trans-unit id="9c7abf0da6a58cae788ad7565b643389edaee688" translate="yes" xml:space="preserve">
          <source>Callbacks are anonymous inner classes too, so if a static instance in your project holds them and do not release them, memory would be leaked.</source>
          <target state="translated">Обратные вызовы также являются анонимными внутренними классами,поэтому если статический экземпляр в вашем проекте их держит и не освобождает,то память будет утечка.</target>
        </trans-unit>
        <trans-unit id="5328b687344df73f23830a73eb9346cab386ef68" translate="yes" xml:space="preserve">
          <source>Calling AsyncTask.cancel(true) will not stop the execution if the task is blocked in an IO operation in background thread.</source>
          <target state="translated">Вызов AsyncTask.cancel(true)не остановит выполнение,если задача заблокирована в операции ввода-вывода в фоновом потоке.</target>
        </trans-unit>
        <trans-unit id="671599bc1a399d2611080b182c6ec309dceb993f" translate="yes" xml:space="preserve">
          <source>Controls &lt;em&gt;that there is an internet connection available&lt;/em&gt; before downloading the bitmaps</source>
          <target state="translated">Контролирует &lt;em&gt;наличие доступного интернет-соединения&lt;/em&gt; перед загрузкой растровых изображений</target>
        </trans-unit>
        <trans-unit id="db6569c7a3ae973546f496a86ab5b9b206ec95a5" translate="yes" xml:space="preserve">
          <source>Dimensions of the target ImageView or UI component that the image is to be loaded into.</source>
          <target state="translated">Размеры целевого ImageView или компонента пользовательского интерфейса,в который будет загружено изображение.</target>
        </trans-unit>
        <trans-unit id="f5a62978708306f9ae8db3e77eb70b18a55e42a7" translate="yes" xml:space="preserve">
          <source>Disk caching. This should be easy to implement anyway - just point to a different task that grabs the bitmaps from the disk</source>
          <target state="translated">Кэширование дисков.Это должно быть легко реализовано в любом случае-просто укажите на другую задачу,которая захватывает растровые изображения с диска</target>
        </trans-unit>
        <trans-unit id="d41afcdf06f873159a02f2c71ff9d4ff63760f01" translate="yes" xml:space="preserve">
          <source>Download:</source>
          <target state="translated">Download:</target>
        </trans-unit>
        <trans-unit id="53a6f94106746c28ba76a2b35fa9813bee528f13" translate="yes" xml:space="preserve">
          <source>Estimated memory usage of loading the full image in memory.</source>
          <target state="translated">Расчетное использование памяти при загрузке полного образа в память.</target>
        </trans-unit>
        <trans-unit id="b09f2105d1275959687cbd96020e7a8cd8eed874" translate="yes" xml:space="preserve">
          <source>FYI: This is how I was doing it:</source>
          <target state="translated">Вот как я это делал:</target>
        </trans-unit>
        <trans-unit id="5df81ffa82179b458e1d55e350db9d88805a69b2" translate="yes" xml:space="preserve">
          <source>Features:</source>
          <target state="translated">Features:</target>
        </trans-unit>
        <trans-unit id="50966d4fa4bd11157f2c78c84f8e32c94e4dc8a1" translate="yes" xml:space="preserve">
          <source>For example, it&amp;rsquo;s not worth loading a 1024x768 pixel image into memory if it will eventually be displayed in a 128x96 pixel thumbnail in an &lt;code&gt;ImageView&lt;/code&gt;.</source>
          <target state="translated">Например, не стоит загружать изображение 1024x768 пикселей в память, если оно в конечном итоге будет отображаться в виде эскиза 128x96 пикселей в &lt;code&gt;ImageView&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08ffb9f14d4f90d0318cfb08c98680be308359bf" translate="yes" xml:space="preserve">
          <source>Garbage collection for the native heap is lazier than the VM heap - so you need to be quite aggressive about doing bitmap.recycle and bitmap =null every time you go through an Activity's onPause or onDestroy</source>
          <target state="translated">Сбор мусора для родной кучи ленивее,чем для VM кучи-так что вам нужно быть достаточно агрессивным,чтобы делать bitmap.recycle и bitmap =null каждый раз,когда вы проходите через Activity's onPause или onDestroy.</target>
        </trans-unit>
        <trans-unit id="72d5be6ec911bd80fb8bae74de3673d72fff4bcd" translate="yes" xml:space="preserve">
          <source>Generally android device heap size is only 16MB (varies from device/OS see post &lt;a href=&quot;https://stackoverflow.com/a/9940415/1053097&quot;&gt;Heap Sizes&lt;/a&gt;), if you are loading the images and it crosses the size of 16MB , it will throw out of memory exception, instead of using the Bitmap for , loading images from SD card or from resources or even from network try to using &lt;strong&gt;getImageUri&lt;/strong&gt; , loading bitmap require more memory , or you can set bitmap to null if your work done with that bitmap.</source>
          <target state="translated">Как правило, размер кучи устройства Android составляет всего 16 МБ (зависит от устройства / ОС, см. &lt;a href=&quot;https://stackoverflow.com/a/9940415/1053097&quot;&gt;Размеры кучи&lt;/a&gt; после публикации), если вы загружаете изображения и размер их превышает 16 МБ, из-за исключения из памяти будет выброшено исключение, вместо использования битовой карты для загрузки. изображения с SD-карты или из ресурсов или даже из сети пытаются использовать &lt;strong&gt;getImageUri&lt;/strong&gt; , загрузка растрового изображения требует больше памяти, или вы можете установить для растрового изображения значение null, если ваша работа выполняется с этим растровым изображением.</target>
        </trans-unit>
        <trans-unit id="1a06d0f015483587699b8a176995e7382555aa09" translate="yes" xml:space="preserve">
          <source>Great answers here, but I wanted a &lt;strong&gt;fully usable class&lt;/strong&gt; to address this problem.. so I did one.</source>
          <target state="translated">Хорошие ответы здесь, но я хотел, чтобы &lt;strong&gt;класс полностью пригодился&lt;/strong&gt; для решения этой проблемы .. поэтому я сделал один.</target>
        </trans-unit>
        <trans-unit id="3ac2685d8968e5ce7bf1f958f25f0955c33e1786" translate="yes" xml:space="preserve">
          <source>Here is my &lt;strong&gt;BitmapHelper class&lt;/strong&gt; that is OutOfMemoryError proof :-)</source>
          <target state="translated">Вот мой &lt;strong&gt;класс BitmapHelper,&lt;/strong&gt; который является доказательством OutOfMemoryError :-)</target>
        </trans-unit>
        <trans-unit id="19cb376555018e8823eaa695a9df2f1af042d562" translate="yes" xml:space="preserve">
          <source>Here is my LogCat:</source>
          <target state="translated">Вот мой ЛогКэт:</target>
        </trans-unit>
        <trans-unit id="cffa2bc53f11363125136f8a2ab820dca37158cd" translate="yes" xml:space="preserve">
          <source>Here is some of my observations about Garbage Collection and Memory Leak.</source>
          <target state="translated">Вот некоторые из моих наблюдений о сборе мусора и утечке памяти.</target>
        </trans-unit>
        <trans-unit id="0a02f56ef5eb139e6928484a85c5a047ddea1327" translate="yes" xml:space="preserve">
          <source>Here's a complete method. First it reads image size without decoding the content itself. Then it finds the best &lt;code&gt;inSampleSize&lt;/code&gt; value, it should be a power of 2, and finally the image is decoded.</source>
          <target state="translated">Вот полный метод. Сначала он читает размер изображения без декодирования самого содержимого. Затем он находит лучшее значение &lt;code&gt;inSampleSize&lt;/code&gt; , оно должно быть степенью 2, и, наконец, изображение декодируется.</target>
        </trans-unit>
        <trans-unit id="808a8de8725ef3f0318a54ee708ab3155fc4418f" translate="yes" xml:space="preserve">
          <source>Hope this helps someone out there..</source>
          <target state="translated">Надеюсь,это поможет кому-нибудь там...</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">Надеюсь,это поможет.</target>
        </trans-unit>
        <trans-unit id="68dbf58b4d75dc4e6d3fcbae5f5cb30a0e0c723d" translate="yes" xml:space="preserve">
          <source>I also have a new error when displaying an image:</source>
          <target state="translated">У меня также появилась новая ошибка при отображении изображения:</target>
        </trans-unit>
        <trans-unit id="d707934563266af24417ef00ad34c82d947bec0e" translate="yes" xml:space="preserve">
          <source>I came out with a solution that works with my Samsung Galaxy S3 and several other devices including less powerful ones, with better image quality when a more powerful device is used.</source>
          <target state="translated">Я вышел с решением,которое работает с моим Samsung Galaxy S3 и несколькими другими устройствами,включая менее мощные,с лучшим качеством изображения,когда используется более мощное устройство.</target>
        </trans-unit>
        <trans-unit id="ac38569581f05208050b75097c3c346aaabe9718" translate="yes" xml:space="preserve">
          <source>I come from iOS experience and I was frustrated to discover an issue with something so basic as loading and showing an image. After all, everyone that is having this issue is trying to display reasonably sized images. Anyway, here are the two changes that fixed my problem (and made my app very responsive).</source>
          <target state="translated">Я пришел из опыта работы на iOS и был разочарован тем,что обнаружил проблему с чем-то настолько простым,как загрузка и показ изображения.В конце концов,все,у кого есть эта проблема,пытаются отображать изображения разумного размера.В любом случае,вот два изменения,которые исправили мою проблему (и сделали мое приложение очень отзывчивым).</target>
        </trans-unit>
        <trans-unit id="41042d10893fe7f9878c2ee20b4903eaec26fdc6" translate="yes" xml:space="preserve">
          <source>I did the following to take the image and resize it on the fly. Hope this helps</source>
          <target state="translated">Я сделал следующее,чтобы взять изображение и изменить его размер на лету.Надеюсь,это поможет</target>
        </trans-unit>
        <trans-unit id="70963af00b7f5a5eee53277c66e3856a91f2891c" translate="yes" xml:space="preserve">
          <source>I had this same issue and solved it by avoiding the BitmapFactory.decodeStream or decodeFile functions and instead used &lt;code&gt;BitmapFactory.decodeFileDescriptor&lt;/code&gt;</source>
          <target state="translated">У меня была та же проблема, и я решил ее, избегая функций BitmapFactory.decodeStream или decodeFile, и вместо этого использовал &lt;code&gt;BitmapFactory.decodeFileDescriptor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcefbefe16ed45ee1a19ad421413e07c13b85e21" translate="yes" xml:space="preserve">
          <source>I have a list view with a couple of image buttons on each row. When you click the list row, it launches a new activity. I have had to build my own tabs because of an issue with the camera layout. The activity that gets launched for the result is a map. If I click on my button to launch the image preview (load an image off the SD card) the application returns from the activity back to the &lt;code&gt;listview&lt;/code&gt; activity to the result handler to relaunch my new activity which is nothing more than an image widget.</source>
          <target state="translated">У меня есть представление списка с парой кнопок изображений в каждой строке. Когда вы щелкаете по строке списка, запускается новое действие. Мне пришлось создавать свои собственные вкладки из-за проблемы с макетом камеры. Действие, которое запускается для результата, является картой. Если я нажму на кнопку, чтобы запустить предварительный просмотр изображения (загрузить изображение с SD-карты), приложение вернется из действия обратно в действие просмотра &lt;code&gt;listview&lt;/code&gt; в обработчик результатов, чтобы повторно запустить мое новое действие, которое является не чем иным, как виджетом изображения.</target>
        </trans-unit>
        <trans-unit id="3f3b7b996420d046d3c3706a4043539fc317ca2b" translate="yes" xml:space="preserve">
          <source>I have a much more effective solution which does not need scaling of any sort. Simply decode your bitmap only once and then cache it in a map against its name. Then simply retrieve the bitmap against the name and set it in the ImageView. There is nothing more that needs to be done.</source>
          <target state="translated">У меня есть гораздо более эффективное решение,не требующее никакого масштабирования.Просто декодируйте растровую карту всего один раз,а затем кэшируйте ее на карте под своим именем.Затем просто возьмите растровую карту против ее имени и установите ее в ImageView.Больше ничего не нужно делать.</target>
        </trans-unit>
        <trans-unit id="80c98ac37ad76002dab413e284d77bc9b5b987a9" translate="yes" xml:space="preserve">
          <source>I have resolved the same issue in the following manner.</source>
          <target state="translated">Я решил этот вопрос следующим образом.</target>
        </trans-unit>
        <trans-unit id="90e8def22b8526c77f4a89a6e67c5c7f7892ca05" translate="yes" xml:space="preserve">
          <source>I have seen a lot of questions about OOM exceptions and caching lately. The developer guide has &lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/cache-bitmap.html&quot;&gt;a really good article&lt;/a&gt; on this, but some tends to fail on implementing it in a suitable way.</source>
          <target state="translated">В последнее время я видел много вопросов об исключениях OOM и кэшировании. В руководстве для разработчиков есть &lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/cache-bitmap.html&quot;&gt;действительно хорошая статья&lt;/a&gt; по этому вопросу, но некоторые, как правило, терпят неудачу при реализации этого подходящим способом.</target>
        </trans-unit>
        <trans-unit id="a92ba1c9a91a190d24c060f9480a125fd5d7a703" translate="yes" xml:space="preserve">
          <source>I have tested this for a few weeks now, I haven't gotten a single OOM exception yet. I have tested this on the emulator, on my Nexus One and on my Nexus S. I have tested image urls that contain images that were in HD quality. The only bottleneck is that it takes more time to download.</source>
          <target state="translated">Я тестировал это уже несколько недель,я еще не получил ни одного OOM исключения.Я протестировал это на эмуляторе,на Nexus One и на Nexus S.Я протестировал urls изображений,которые содержат изображения в HD качестве.Единственным узким местом является то,что это занимает больше времени,чтобы загрузить.</target>
        </trans-unit>
        <trans-unit id="bd3a2038e0a415d454b2b7282e042b09784ff570" translate="yes" xml:space="preserve">
          <source>I hope this will help the buddies facing the same problem!</source>
          <target state="translated">Надеюсь,это поможет приятелям,столкнувшимся с той же проблемой!</target>
        </trans-unit>
        <trans-unit id="ef445c286efa75adce24bdec51eab0b63f0b80ee" translate="yes" xml:space="preserve">
          <source>I just ran into this issue a couple minutes ago. I solved it by doing a better job at managing my listview adapter. I thought it was an issue with the hundreds of 50x50px images I was using, turns out I was trying to inflate my custom view each time the row was being shown. Simply by testing to see if the row had been inflated I eliminated this error, and I am using hundreds of bitmaps. This is actually for a Spinner, but the base adapter works all the same for a ListView. This simple fix also greatly improved the performance of the adapter.</source>
          <target state="translated">Я столкнулся с этим вопросом пару минут назад.Я решил его,сделав более эффективную работу по управлению моим адаптером для просмотра списков.Я подумал,что это проблема с сотнями изображений 50х50px,которые я использовал,оказалось,что я пытался надуть свой пользовательский вид каждый раз,когда показывался ряд.Просто проверяя,был ли раздут ряд,я устранил эту ошибку,и я использую сотни растровых изображений.На самом деле это для Spinner,но базовый адаптер все равно работает для ListView.Это простое исправление также значительно улучшило производительность адаптера.</target>
        </trans-unit>
        <trans-unit id="cc69206e5815e05d21981036e91bc0bb1b830920" translate="yes" xml:space="preserve">
          <source>I know I can do an out of band resize and save of my image, but that is not really what I want to do, but some sample code for that would be nice.</source>
          <target state="translated">Я знаю,что могу изменить размер группы и сохранить свой имидж,но это не совсем то,что я хочу делать,но некоторые примеры кода для этого были бы неплохи.</target>
        </trans-unit>
        <trans-unit id="f1a21cccc75a4df422b282e20e780ffcfefd2ba8" translate="yes" xml:space="preserve">
          <source>I made an &lt;a href=&quot;https://play.google.com/store/apps/details?id=net.coocood.oomresearch&quot;&gt;app&lt;/a&gt; to intentionally cause &lt;code&gt;OutOfMemoryError&lt;/code&gt;, and monitor memory usage.</source>
          <target state="translated">Я сделал &lt;a href=&quot;https://play.google.com/store/apps/details?id=net.coocood.oomresearch&quot;&gt;приложение,&lt;/a&gt; чтобы преднамеренно вызывать &lt;code&gt;OutOfMemoryError&lt;/code&gt; и отслеживать использование памяти.</target>
        </trans-unit>
        <trans-unit id="cfd9d3246806c0d0544d387ca159b2f1de0c5464" translate="yes" xml:space="preserve">
          <source>I set the maximum memory used by this bitmap to be 25% of maximum allocated memory, you may need to adjust this to your needs and make sure this bitmap is cleaned up and don't stay in memory when you've finished using it. Typically I use this code to perform image rotation (source and destination bitmap) so my app needs to load 2 bitmaps in memory at the same time, and 25% gives me a good buffer without running out of memory when performing image rotation.</source>
          <target state="translated">Я установил максимальное количество памяти,используемой этой растровой картой,в 25% от максимального количества выделенной памяти,вам может понадобиться настроить это в соответствии с вашими потребностями и убедиться,что эта растровая карта очищена и не останется в памяти,когда вы ее закончите использовать.Обычно я использую этот код для выполнения ротации образа (исходного и целевого bitmap),поэтому моему приложению нужно загружать 2 bitmaps в память одновременно,и 25% дает мне хороший буфер,не истощая память при выполнении ротации образа.</target>
        </trans-unit>
        <trans-unit id="be1ebee6d533ac5f91df22838053b293abd1093c" translate="yes" xml:space="preserve">
          <source>I think best way to avoid the &lt;code&gt;OutOfMemoryError&lt;/code&gt; is to face it and understand it.</source>
          <target state="translated">Я думаю, что лучший способ избежать &lt;code&gt;OutOfMemoryError&lt;/code&gt; - это смириться с этим и понять его.</target>
        </trans-unit>
        <trans-unit id="fb7fdde6f7588fa4661d28589535e5ae66450cc5" translate="yes" xml:space="preserve">
          <source>I think there is a problem with the native function used in decodeStream/decodeFile. I have confirmed that a different native method is called when using decodeFileDescriptor.  Also what I've read is &quot;that Images (Bitmaps) are not allocated in a standard Java way but via native calls; the allocations are done outside of the virtual heap, but are
&lt;strong&gt;&lt;em&gt;counted against it!&lt;/em&gt;&lt;/strong&gt;&quot;</source>
          <target state="translated">Я думаю, что есть проблема с нативной функцией, используемой в decodeStream / decodeFile. Я подтвердил, что при использовании decodeFileDescriptor вызывается другой нативный метод. Также я прочитал, что &amp;laquo;изображения (растровые изображения) распределяются не стандартным способом Java, а с помощью собственных вызовов; выделения выполняются вне виртуальной кучи, но &lt;strong&gt;&lt;em&gt;учитываются!&lt;/em&gt;&lt;/strong&gt; &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="89d03da63fffe99b55265fa19e6085ce6f7c68b9" translate="yes" xml:space="preserve">
          <source>I'm gonna talk about SDK versions before Honey Comb first.</source>
          <target state="translated">Я собираюсь поговорить о версиях SDK до того,как Хани Комб начнет.</target>
        </trans-unit>
        <trans-unit id="949b7e396b503afc7e60ed24080a292eb274cd8c" translate="yes" xml:space="preserve">
          <source>I've made a small improvement to Fedor's code. It basically does the same, but without the (in my opinion) ugly while loop and it always results in a power of two. Kudos to Fedor for making the original solution, I was stuck until I found his, and then I was able to make this one :)</source>
          <target state="translated">Я внесла небольшое улучшение в код Федора.В основном оно делает то же самое,но без (на мой взгляд)уродливого цикла и всегда приводит к власти двоих.Слава Федору за оригинальное решение,я застрял,пока не нашел его,а потом смог сделать вот это :).</target>
        </trans-unit>
        <trans-unit id="f572a323e69f42f2995af8376e6833205e919d12" translate="yes" xml:space="preserve">
          <source>I've spent the entire day testing these solutions and the only thing that worked for me is the above approaches for getting the image and manually calling the GC, which I know is not supposed to be necessary, but it is the only thing that worked when I put my app under heavy load testing switching between activities.  My app has a list of thumbnail images in a listview in (lets say activity A) and when you click on one of those images it takes you to another activity (lets say activity B) that shows a main image for that item.  When I would switch back and forth between the two activities, I would eventually get the OOM error and the app would force close.</source>
          <target state="translated">Я потратил весь день на тестирование этих решений,и единственное,что сработало для меня,это вышеописанные подходы к получению образа и ручному вызову GC,который,как я знаю,не должен быть необходимым,но это единственное,что сработало,когда я поставил свое приложение под тяжелым нагрузочным тестированием,переключаясь между видами деятельности.В моем приложении есть список эскизов изображений в просмотре списка (скажем,активность A),и когда вы нажимаете на одно из этих изображений,оно переносит вас на другую активность (скажем,активность B),которая показывает основное изображение для этого элемента.Когда я переключаюсь между этими двумя действиями,я в конце концов получаю ошибку OOM и приложение принудительно закрывается.</target>
        </trans-unit>
        <trans-unit id="6d49a2855b498c0fef974a894bdc320dc6145acf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;you are flinging&lt;/em&gt; the &lt;code&gt;ListView&lt;/code&gt; away, it simply won't download the bitmaps between</source>
          <target state="translated">Если &lt;em&gt;вы отбрасываете&lt;/em&gt; &lt;code&gt;ListView&lt;/code&gt; , он просто не будет загружать растровые изображения между</target>
        </trans-unit>
        <trans-unit id="aae26a8106e5c91b33735bff022f3cde761adb3a" translate="yes" xml:space="preserve">
          <source>If you scheduled a repeating or delayed task, for example a Timer, and you do not call cancel() and purge() in onPause(), memory would be leaked.</source>
          <target state="translated">Если вы запланировали повторяющуюся или задержанную задачу,например,таймер,и не вызываете функции cancel()и cleange()в onPause(),память будет утечка.</target>
        </trans-unit>
        <trans-unit id="8b45d3552db7a9f1666671b53d59f302a103fcd8" translate="yes" xml:space="preserve">
          <source>If {VM heap size} + {allocated native heap memory} &amp;gt;= {VM heap size limit for the device}, and you are trying to create bitmap, OOM will be thrown.</source>
          <target state="translated">Если {Размер кучи виртуальной машины} + {выделенная собственная память кучи}&amp;gt; = {Ограничение размера кучи виртуальной машины для устройства}, и вы пытаетесь создать растровое изображение, OOM будет выброшено.</target>
        </trans-unit>
        <trans-unit id="49e7f074b8cc99d872d2d1216825c26fffff2a73" translate="yes" xml:space="preserve">
          <source>In one of my application i need to take picture either from &lt;code&gt;Camera/Gallery&lt;/code&gt;. If user click image from Camera(may be 2MP, 5MP or 8MP), image size varies from &lt;code&gt;kB&lt;/code&gt;s to &lt;code&gt;MB&lt;/code&gt;s. If image size is less(or up to 1-2MB) above code working fine but if i have image of size above 4MB or 5MB then &lt;code&gt;OOM&lt;/code&gt; comes in frame :(</source>
          <target state="translated">В одном из моих приложений мне нужно сделать снимок либо из &lt;code&gt;Camera/Gallery&lt;/code&gt; . Если пользователь щелкает изображение с камеры (может быть 2MP, 5MP или 8MP), размер изображения варьируется от &lt;code&gt;kB&lt;/code&gt; с до &lt;code&gt;MB&lt;/code&gt; с. Если размер изображения меньше (или до 1-2 МБ) выше, код работает нормально, но если у меня изображение размером более 4 МБ или 5 МБ, то &lt;code&gt;OOM&lt;/code&gt; входит в кадр :(</target>
        </trans-unit>
        <trans-unit id="dd98994863f2d2fdf584dc5c4b2152d193280740" translate="yes" xml:space="preserve">
          <source>Is there a way I can build the list adapter easily row by row, where I can resize on the fly (&lt;em&gt;bit wise&lt;/em&gt;)?</source>
          <target state="translated">Есть ли способ, которым я могу легко построить список адаптер за строкой, где я могу изменить размер на лету ( &lt;em&gt;немного мудрее&lt;/em&gt; )?</target>
        </trans-unit>
        <trans-unit id="c3345639637ff08fe7c9ede8ee3564a6b1257d50" translate="yes" xml:space="preserve">
          <source>It seems that this is a very long running problem, with a lot of differing explanations.  I took the advice of the two most common presented answers here, but neither one of these solved my problems of the VM claiming it couldn't afford the bytes to perform the &lt;strong&gt;decoding&lt;/strong&gt; part of the process.  After some digging I learned that the real problem here is the decoding process taking away from the &lt;strong&gt;NATIVE&lt;/strong&gt; heap.</source>
          <target state="translated">Кажется, что это очень длительная проблема, с множеством разных объяснений. Я воспользовался советом двух наиболее распространенных представленных здесь ответов, но ни один из них не решил мои проблемы с виртуальной машиной, утверждая, что она не может позволить байтам выполнить часть процесса &lt;strong&gt;декодирования&lt;/strong&gt; . После некоторого копания я узнал, что настоящая проблема здесь - процесс декодирования, &lt;strong&gt;убирающий из&lt;/strong&gt; кучи &lt;strong&gt;NATIVE&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="212e829919910956b61b83294caa292f0c725558" translate="yes" xml:space="preserve">
          <source>It's a &lt;a href=&quot;http://code.google.com/p/android/issues/detail?id=8488&quot;&gt;known bug&lt;/a&gt;, it's not because of large files. Since Android Caches the Drawables, it's going out of memory after using few images. But I've found an alternate way for it, by skipping the android default cache system.</source>
          <target state="translated">Это &lt;a href=&quot;http://code.google.com/p/android/issues/detail?id=8488&quot;&gt;известная ошибка&lt;/a&gt; , это не из-за больших файлов. Так как Android кэширует Drawables, он исчерпывает память после использования нескольких изображений. Но я нашел альтернативный способ, пропустив систему кеширования Android по умолчанию.</target>
        </trans-unit>
        <trans-unit id="87c40bac9ed5b0407f1d8f530751ca38621a14df" translate="yes" xml:space="preserve">
          <source>Large bitmaps &lt;em&gt;gets scaled&lt;/em&gt; (you can define the maximum pixels that you want to allow)</source>
          <target state="translated">Большие растровые изображения &lt;em&gt;масштабируются&lt;/em&gt; (вы можете определить максимальное количество пикселей, которое вы хотите разрешить)</target>
        </trans-unit>
        <trans-unit id="8678809351d8e9e866f9fb346e60b5b2ea5382df" translate="yes" xml:space="preserve">
          <source>Last words:</source>
          <target state="translated">Последние слова:</target>
        </trans-unit>
        <trans-unit id="32aee2a63bf12b3e42d6f178b7670e25eb19b3af" translate="yes" xml:space="preserve">
          <source>Load a scaled down version into Memory</source>
          <target state="translated">Загрузить уменьшенную версию в память.</target>
        </trans-unit>
        <trans-unit id="59d71b903d7086e09cd387175e346c3f8a597a02" translate="yes" xml:space="preserve">
          <source>Look at the end of this answer for a link to the source code.</source>
          <target state="translated">Посмотрите в конце этого ответа ссылку на исходный код.</target>
        </trans-unit>
        <trans-unit id="0c2bdc40e8343d1d94d6a69dc85aeca934ae99de" translate="yes" xml:space="preserve">
          <source>MainActivity.java's critical stuff:</source>
          <target state="translated">MainActivity.java критические вещи:</target>
        </trans-unit>
        <trans-unit id="83a207a33592bbc545cc207ae6453335028a666e" translate="yes" xml:space="preserve">
          <source>Makes sure that you are only instantiating &lt;em&gt;one task&lt;/em&gt; per row</source>
          <target state="translated">Уверен, что вы создаете только &lt;em&gt;одну задачу&lt;/em&gt; на строку</target>
        </trans-unit>
        <trans-unit id="95b33b353acf294ef83e9aa5fea20dcd94f0383c" translate="yes" xml:space="preserve">
          <source>Manually call System.gc() is meaningless, the system will call it first before trying to grow the heap size.</source>
          <target state="translated">Ручной вызов System.gc()бессмысленен,система вызовет его первой перед тем,как попытаться увеличить размер кучи.</target>
        </trans-unit>
        <trans-unit id="fad3a84456f058bb312145ad5ce97cf5778734fb" translate="yes" xml:space="preserve">
          <source>More on that topic here: &lt;a href=&quot;http://groups.google.com/group/android-developers/browse_thread/thread/146a3a354ce3e8e3/61e113036089d696&quot;&gt;Is the limit of memory heap only 6M? &lt;/a&gt;</source>
          <target state="translated">Подробнее об этом здесь: &lt;a href=&quot;http://groups.google.com/group/android-developers/browse_thread/thread/146a3a354ce3e8e3/61e113036089d696&quot;&gt;лимит кучи памяти только 6M?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a9f9d53cd957a664f586e1fac925b35dac68f30" translate="yes" xml:space="preserve">
          <source>My 2 cents: i solved my OOM errors with bitmaps by:</source>
          <target state="translated">Мои 2 цента:я решил свои OOM-ошибки битовыми картами:</target>
        </trans-unit>
        <trans-unit id="b3a39586148364aa68cde4adff75f273148bbe39" translate="yes" xml:space="preserve">
          <source>NOTICE: VM HEAP SIZE is counted rather than VM ALLOCATED MEMORY.</source>
          <target state="translated">ПРИМЕЧАНИЕ:ВМ ЗДОРОВЬЕ подсчитывается,а не ВМ АЛЛОКТРИРОВАННАЯ ПАМЯТЬ.</target>
        </trans-unit>
        <trans-unit id="d9a2f4e5272d151e35ec41d7fe1283ecec32b9fb" translate="yes" xml:space="preserve">
          <source>Native Heap Size will never shrink too, but it's not counted for OOM, so no need to worry about it.</source>
          <target state="translated">Размер кучи туземцев никогда не уменьшится,но это не считается для ООМ,так что не стоит беспокоиться об этом.</target>
        </trans-unit>
        <trans-unit id="54879c96b74bbe786d1bd7159a8b0599d4c321f0" translate="yes" xml:space="preserve">
          <source>None of the answers above worked for me, but I did come up with a horribly ugly workaround that solved the problem. I added a very small, 1x1 pixel image to my project as a resource, and loaded it into my ImageView before calling into garbage collection. I think it might be that the ImageView was not releasing the Bitmap, so GC never picked it up. It's ugly, but it seems to be working for now.</source>
          <target state="translated">Ни один из вышеперечисленных ответов не сработал для меня,но я придумал ужасно уродливый обходной путь,который решил проблему.Я добавил в свой проект в качестве ресурса очень маленькое изображение размером 1x1 пиксель и загрузил его в ImageView перед тем,как позвонить в мусорную коллекцию.Я думаю,что ImageView не выпускал Bitmap,поэтому GC так и не взял его.Это уродливо,но,похоже,пока работает.</target>
        </trans-unit>
        <trans-unit id="6f8894f2abf440bb9aeea96c883d859a08c12297" translate="yes" xml:space="preserve">
          <source>Now since your image is in a file somewhere (or may even be coming from an external server), it is YOUR responsibility to cache the decoded bitmap instance to be reused any where it is needed.</source>
          <target state="translated">Теперь,когда ваше изображение находится где-то в файле (или даже может исходить от внешнего сервера),ВАША ответственность за кэширование расшифрованного растрового экземпляра для повторного использования в любом месте,где это необходимо.</target>
        </trans-unit>
        <trans-unit id="ad220e4cd6cb224186c1ca16f667ece57dba20f3" translate="yes" xml:space="preserve">
          <source>Now that the image dimensions are known, they can be used to decide if the full image should be loaded into memory or if a subsampled version should be loaded instead. Here are some factors to consider:</source>
          <target state="translated">Теперь,когда размеры образа известны,их можно использовать,чтобы решить,загружать ли полный образ в память или загружать вместо него субдискретированную версию.Вот некоторые факторы,которые следует учитывать:</target>
        </trans-unit>
        <trans-unit id="c2a795044eb263e6638bc4149db07fd71cd76aac" translate="yes" xml:space="preserve">
          <source>Now when I implement the following in activity B, I can go through the entire listview with no issue and keep going and going and going...and its plenty fast.</source>
          <target state="translated">Теперь,когда я реализую следующее в деятельности B,я могу просматривать весь список безо всяких проблем и продолжать идти и идти...и довольно быстро.</target>
        </trans-unit>
        <trans-unit id="902e1f686c28630c2a04528f7d145b6094c53aba" translate="yes" xml:space="preserve">
          <source>Now, having said all of this, I am a complete dunce with Java and Android too.  So if you think this is a terrible way to solve this problem, you are probably right.  ;-)  But this has worked wonders for me, and I have found it impossible to run the VM out of heap cache now.  The only drawback I can find is that you are trashing your cached drawn image.  Which means if you go RIGHT back to that image, you are redrawing it each and every time.  In the case of how my application works, that is not really a problem.  Your mileage may vary.</source>
          <target state="translated">Теперь,сказав все это,я полный дурак с Java и Android тоже.Так что если вы думаете,что это ужасный способ решить эту проблему,вы,наверное,правы.;-)Но это сработало чудеса для меня,и я нашел невозможным запустить VM из кэша кучи сейчас.Единственным недостатком,который я могу найти,является то,что вы мусорные ваши кэшированные нарисованные изображения.Что означает,что если вы вернетесь к этому изображению ПРАВИЛЬНО,вы будете перерисовывать его каждый раз.В случае,если мое приложение работает,это не является проблемой.Ваш пробег может варьироваться.</target>
        </trans-unit>
        <trans-unit id="035dbf096a64f11fe2822c4a18f107046d3f5703" translate="yes" xml:space="preserve">
          <source>Read Bitmap Dimensions and Type</source>
          <target state="translated">Прочитать битовое изображение Размеры и тип</target>
        </trans-unit>
        <trans-unit id="ab9146b1673102ddbc5c7115d7b318805bd47098" translate="yes" xml:space="preserve">
          <source>Report errors in the comments! :-)</source>
          <target state="translated">Сообщайте об ошибках в комментариях! :-)</target>
        </trans-unit>
        <trans-unit id="475ffa14014bb463965306813410e4afd01a7039" translate="yes" xml:space="preserve">
          <source>Requirements:</source>
          <target state="translated">Requirements:</target>
        </trans-unit>
        <trans-unit id="bbd19d7653cc08e0948d447b0d060fac147cb4d7" translate="yes" xml:space="preserve">
          <source>Sample code:</source>
          <target state="translated">Образец кода:</target>
        </trans-unit>
        <trans-unit id="ce7e680b40c93d87fca537a049ec0c6773e8cc78" translate="yes" xml:space="preserve">
          <source>Screen size and density of the current device.</source>
          <target state="translated">Размер экрана и плотность экрана текущего устройства.</target>
        </trans-unit>
        <trans-unit id="202c0c493954cb7331141e65ff5574bc316f7006" translate="yes" xml:space="preserve">
          <source>See here: &lt;a href=&quot;https://stackoverflow.com/questions/1955410/bitmapfactory-oom-driving-me-nuts/5493182#5493182&quot;&gt;BitmapFactory OOM driving me nuts&lt;/a&gt;</source>
          <target state="translated">Смотрите здесь: &lt;a href=&quot;https://stackoverflow.com/questions/1955410/bitmapfactory-oom-driving-me-nuts/5493182#5493182&quot;&gt;BitmapFactory OOM сводит меня с ума&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="34f1933bc01cc5bf7557f841a052257210fb860e" translate="yes" xml:space="preserve">
          <source>So please check in a device. It may be run in device.</source>
          <target state="translated">Так что,пожалуйста,проверьте устройство.Оно может быть запущено в устройстве.</target>
        </trans-unit>
        <trans-unit id="1664354fdd92ce3acf492010afdff1a0f35d11b7" translate="yes" xml:space="preserve">
          <source>So you have more available memory to create bitmap with the same heap size limit,  OOM is less likely to be thrown.</source>
          <target state="translated">Таким образом,у вас есть больше доступной памяти для создания растровых карт с тем же пределом размера кучи,OOM с меньшей вероятностью будет брошен.</target>
        </trans-unit>
        <trans-unit id="8e003454e74d8952ecfc04329daac1b2362fc26b" translate="yes" xml:space="preserve">
          <source>So you have to keep the peak VM memory as low as possible to keep VM Heap Size from growing too big to save available memory for Bitmaps.</source>
          <target state="translated">Таким образом,вы должны держать пик памяти ВМ как можно меньше,чтобы держать VM Heap Размер от роста слишком большим,чтобы сохранить доступную память для битовых карт.</target>
        </trans-unit>
        <trans-unit id="0b66c6e8db0c80867e9069f6c30289a860680ca4" translate="yes" xml:space="preserve">
          <source>Strange out of memory issue while loading an image to a Bitmap object</source>
          <target state="translated">Странная проблема с памятью при загрузке изображения в объект Bitmap</target>
        </trans-unit>
        <trans-unit id="72f1f2daff69d0af1a894aec65d8485be42e1160" translate="yes" xml:space="preserve">
          <source>Such &lt;code&gt;OutofMemoryException&lt;/code&gt; cannot be totally resolved by calling the &lt;code&gt;System.gc()&lt;/code&gt; and so on .</source>
          <target state="translated">Такое &lt;code&gt;OutofMemoryException&lt;/code&gt; не может быть полностью разрешено путем вызова &lt;code&gt;System.gc()&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="37a396c052474568e5e78e72fcb66454313d2c6e" translate="yes" xml:space="preserve">
          <source>That lead me to another discussion thread where I found a couple more solutions to this problem.  One is to call&lt;code&gt;System.gc();&lt;/code&gt; manually after your image is displayed.  But that actually makes your app use MORE memory, in an effort to reduce the native heap.  The better solution as of the release of 2.0 (Donut) is to use the BitmapFactory option &quot;inPurgeable&quot;.  So I simply added &lt;code&gt;o2.inPurgeable=true;&lt;/code&gt; just after &lt;code&gt;o2.inSampleSize=scale;&lt;/code&gt;.</source>
          <target state="translated">Это привело меня к другой ветке обсуждения, где я нашел еще пару решений этой проблемы. Одним из них является вызов &lt;code&gt;System.gc();&lt;/code&gt; вручную после отображения вашего изображения. Но это на самом деле заставляет ваше приложение использовать БОЛЬШЕ памяти, чтобы уменьшить собственную кучу. Наилучшим решением с версии 2.0 (Donut) является использование опции BitmapFactory &amp;laquo;inPurgeable&amp;raquo;. Поэтому я просто добавил &lt;code&gt;o2.inPurgeable=true;&lt;/code&gt; сразу после &lt;code&gt;o2.inSampleSize=scale;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="9ff6aebc5a428a3373320888b302b859e74ecd31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://developer.android.com/reference/android/util/LruCache.html&quot;&gt;&lt;code&gt;LruCache&lt;/code&gt;&lt;/a&gt; has a good way to deal with bitmaps. However, in this application I put an instance of an &lt;code&gt;LruCache&lt;/code&gt; inside another cache class that I created in order to get the application more feasible.</source>
          <target state="translated">У &lt;a href=&quot;http://developer.android.com/reference/android/util/LruCache.html&quot;&gt; &lt;code&gt;LruCache&lt;/code&gt; &lt;/a&gt; есть хороший способ работы с растровыми изображениями. Однако в этом приложении я поместил экземпляр &lt;code&gt;LruCache&lt;/code&gt; в другой класс кэша, который я создал, чтобы сделать приложение более выполнимым.</target>
        </trans-unit>
        <trans-unit id="64f673a944a2cbfbb517a096df3685f58f381856" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://developer.android.com/training/index.html&quot;&gt;Android Training&lt;/a&gt; class, &quot;&lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/index.html&quot;&gt;Displaying Bitmaps Efficiently&lt;/a&gt;&quot;, offers some great information for understanding and dealing with the exception &lt;code&gt;java.lang.OutOfMemoryError: bitmap size exceeds VM budget&lt;/code&gt; when loading Bitmaps.</source>
          <target state="translated">&lt;a href=&quot;http://developer.android.com/training/index.html&quot;&gt;Учебный&lt;/a&gt; класс Android &amp;laquo; &lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/index.html&quot;&gt;Эффективное отображение растровых изображений&lt;/a&gt; &amp;raquo; предоставляет полезную информацию для понимания и устранения исключительной &lt;code&gt;java.lang.OutOfMemoryError: bitmap size exceeds VM budget&lt;/code&gt; при загрузке растровых изображений.</target>
        </trans-unit>
        <trans-unit id="6e661b93c0459b86a470bf78ee4b300cf5c24057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BitmapFactory&lt;/code&gt; class provides several decoding methods (&lt;code&gt;decodeByteArray()&lt;/code&gt;, &lt;code&gt;decodeFile()&lt;/code&gt;, &lt;code&gt;decodeResource()&lt;/code&gt;, etc.) for creating a &lt;code&gt;Bitmap&lt;/code&gt; from various sources. Choose the most appropriate decode method based on your image data source. These methods attempt to allocate memory for the constructed bitmap and therefore can easily result in an &lt;code&gt;OutOfMemory&lt;/code&gt; exception. Each type of decode method has additional signatures that let you specify decoding options via the &lt;code&gt;BitmapFactory.Options&lt;/code&gt; class. Setting the &lt;code&gt;inJustDecodeBounds&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt; while decoding avoids memory allocation, returning &lt;code&gt;null&lt;/code&gt; for the bitmap object but setting &lt;code&gt;outWidth&lt;/code&gt;, &lt;code&gt;outHeight&lt;/code&gt; and &lt;code&gt;outMimeType&lt;/code&gt;. This technique allows you to read the dimensions and type of the image data prior to construction (and memory allocation) of the bitmap.</source>
          <target state="translated">Класс &lt;code&gt;BitmapFactory&lt;/code&gt; предоставляет несколько методов декодирования ( &lt;code&gt;decodeByteArray()&lt;/code&gt; , &lt;code&gt;decodeFile()&lt;/code&gt; , &lt;code&gt;decodeResource()&lt;/code&gt; и т. Д.) Для создания &lt;code&gt;Bitmap&lt;/code&gt; из различных источников. Выберите наиболее подходящий метод декодирования на основе вашего источника данных изображения. Эти методы пытаются выделить память для &lt;code&gt;OutOfMemory&lt;/code&gt; растрового изображения и поэтому могут легко привести к исключению OutOfMemory . Каждый тип метода декодирования имеет дополнительные подписи, которые позволяют указывать параметры декодирования через класс &lt;code&gt;BitmapFactory.Options&lt;/code&gt; . Установка для свойства &lt;code&gt;inJustDecodeBounds&lt;/code&gt; значения &lt;code&gt;true&lt;/code&gt; ,в то время как декодирование позволяет избежать выделения памяти, возвращая значение &lt;code&gt;null&lt;/code&gt; для объекта растрового изображения, но устанавливая &lt;code&gt;outWidth&lt;/code&gt; , &lt;code&gt;outHeight&lt;/code&gt; и &lt;code&gt;outMimeType&lt;/code&gt; . Этот метод позволяет считывать размеры и тип данных изображения до создания (и выделения памяти) растрового изображения.</target>
        </trans-unit>
        <trans-unit id="617f4327d13a0a613a5190e16101142d1b68a40b" translate="yes" xml:space="preserve">
          <source>The Activity States are determined by the OS itself subject to the memory usage for each process and the priority of each process.</source>
          <target state="translated">Состояния активности определяются самой ОС в зависимости от использования памяти для каждого процесса и приоритета каждого процесса.</target>
        </trans-unit>
        <trans-unit id="417869f28c90577e509bcf77a07d44d70fbf0454" translate="yes" xml:space="preserve">
          <source>The amount of memory you are willing to commit to loading this image given any other memory requirements of your application.</source>
          <target state="translated">Количество памяти,которое вы готовы выделить для загрузки этого образа с учетом любых других требований к памяти вашего приложения.</target>
        </trans-unit>
        <trans-unit id="1a9e27d3055bbb1d01dcb44e5f8b8bb80b139083" translate="yes" xml:space="preserve">
          <source>The condition for OOM is much simpler: {VM heap size} &amp;gt;= {VM heap size limit for the device}.</source>
          <target state="translated">Условие для OOM намного проще: {размер кучи виртуальной машины}&amp;gt; = {ограничение размера кучи виртуальной машины для устройства}.</target>
        </trans-unit>
        <trans-unit id="5c046e88d1a921489d9dffe41d8908c149e21116" translate="yes" xml:space="preserve">
          <source>The gist of it is to calculate the maximum memory allocated for the app on a particular device, then set the scale to be lowest possible without exceeding this memory. Here's the code:</source>
          <target state="translated">Суть в том,чтобы вычислить максимальный объем памяти,выделяемый для приложения на конкретном устройстве,а затем установить шкалу наименьшим возможным значением,не превышая эту память.Вот код:</target>
        </trans-unit>
        <trans-unit id="c7906221e833c9985371afb28753819159d2d104" translate="yes" xml:space="preserve">
          <source>The image preview on the list view is being done with the cursor and &lt;code&gt;ListAdapter&lt;/code&gt;. This makes it pretty simple, but I am not sure how I can put a resized image (I.e. Smaller bit size not pixel as the &lt;code&gt;src&lt;/code&gt; for the image button on the fly. So I just resized the image that came off the phone camera.</source>
          <target state="translated">Предварительный просмотр изображения в виде списка выполняется с помощью курсора и &lt;code&gt;ListAdapter&lt;/code&gt; . Это делает это довольно просто, но я не уверен, как я могу поместить изображение с измененным размером (т.е. меньший размер бит, а не пиксель, как &lt;code&gt;src&lt;/code&gt; для кнопки изображения на лету. Поэтому я просто изменил размер изображения, полученного с камеры телефона.</target>
        </trans-unit>
        <trans-unit id="881de785d39773ca03137cf7aaf2b8fb8fbc92b5" translate="yes" xml:space="preserve">
          <source>The images that are being downloaded are images (75x75) from Flickr. However, put whatever image urls you want to be processed, and the application will scale it down if it exceeds the maximum. In this application the urls are simply in a &lt;code&gt;String&lt;/code&gt; array.</source>
          <target state="translated">Загружаемые изображения - это изображения (75x75) с Flickr. Однако поместите любые URL-адреса изображений, которые вы хотите обработать, и приложение уменьшит их, если они превысят максимум. В этом приложении URL-адреса просто находятся в массиве &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f9a96a13ca2ff8309b627254b404a92c7ccfb45" translate="yes" xml:space="preserve">
          <source>The issue is that I get an out of memory error when it tries to go back and re-launch the 2nd activity.</source>
          <target state="translated">Проблема в том,что я получаю ошибку в памяти,когда он пытается вернуться назад и перезапустить 2-ю активность.</target>
        </trans-unit>
        <trans-unit id="1b3fe0b14ae50ce78dc0f11e36bb1bbae4dceb35" translate="yes" xml:space="preserve">
          <source>Then, let's talk about SDK Starts from Honey Comb.</source>
          <target state="translated">Тогда давайте поговорим о SDK,который начинается с медового комбината.</target>
        </trans-unit>
        <trans-unit id="7eb770ec595c754acc60ae25455a0c3d685c99f7" translate="yes" xml:space="preserve">
          <source>There are two issues here....</source>
          <target state="translated">Здесь два вопроса...</target>
        </trans-unit>
        <trans-unit id="92a822662c6a874d0c9af95dec02a3a2fec8f74d" translate="yes" xml:space="preserve">
          <source>There is only one possible scenario where I can imagine that the OOM will appear, and that is if we download many, really big images, and before they get scaled and put into cache, will simultaneously take up more memory and cause an OOM. But that isn't even an ideal situation anyway and it most likely won't be possible to solve in a more feasible way.</source>
          <target state="translated">Есть только один возможный сценарий,при котором я могу представить,что OOM появится,а именно,если мы загрузим много,действительно больших образов,и до того,как они будут масштабированы и помещены в кэш,одновременно займут больше памяти и вызовут OOM.Но это даже не идеальная ситуация в любом случае,и,скорее всего,не удастся решить ее более осуществимым способом.</target>
        </trans-unit>
        <trans-unit id="00d9ad0894bf0c0ece2432d8d50bce27ee712197" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;inSampleSize&lt;/code&gt; option reduces memory consumption.</source>
          <target state="translated">Эта опция &lt;code&gt;inSampleSize&lt;/code&gt; уменьшает потребление памяти.</target>
        </trans-unit>
        <trans-unit id="68151546c4f61ab7739aaa7c622046933070f857" translate="yes" xml:space="preserve">
          <source>This code will help to load large bitmap from drawable</source>
          <target state="translated">Данный код поможет загрузить большую растровую карту из отрисовываемого</target>
        </trans-unit>
        <trans-unit id="fc774592f32c7c998ede5a84451cdc61ee17210b" translate="yes" xml:space="preserve">
          <source>This does not include:</source>
          <target state="translated">Это не включает в себя:</target>
        </trans-unit>
        <trans-unit id="49741fc52da958e447dcb1d70d7f5bc8545bbfc3" translate="yes" xml:space="preserve">
          <source>This is almost guaranteed to save you hours if not days. All that talk about scaling the image, etc. does not really work (unless you consider getting wrong size or degraded image a solution).</source>
          <target state="translated">Это почти гарантированно сэкономит вам часы,если не дни.Все эти разговоры о масштабировании изображения и т.д.на самом деле не работают (если только вы не считаете правильным решением проблему неправильного размера или ухудшения качества изображения).</target>
        </trans-unit>
        <trans-unit id="1adf5fc889e0ac6a44110a0c1935d18af31dbcd2" translate="yes" xml:space="preserve">
          <source>This is because AsyncTask is an instance of an anonymous inner class, it holds a reference of the Activity.</source>
          <target state="translated">Это связано с тем,что AsyncTask является экземпляром анонимного внутреннего класса,в нем содержится ссылка на Активность.</target>
        </trans-unit>
        <trans-unit id="31c9695f6e300ed35b6c8a9e69cc4b8ae89fc837" translate="yes" xml:space="preserve">
          <source>This issue only happens in Android emulators. I also faced this issue in an emulator but when I checked in a device then it worked fine.</source>
          <target state="translated">Эта проблема возникает только в эмуляторах Android.Я также столкнулся с этой проблемой в эмуляторе,но когда я проверил в устройстве,то он работал нормально.</target>
        </trans-unit>
        <trans-unit id="25fa0ce83b96a1bf53c72341f7de9287e367373c" translate="yes" xml:space="preserve">
          <source>This method makes it easy to load a bitmap of arbitrarily large size into an &lt;code&gt;ImageView&lt;/code&gt; that displays a 100x100 pixel thumbnail, as shown in the following example code:</source>
          <target state="translated">Этот метод позволяет легко загружать растровое изображение произвольно большого размера в &lt;code&gt;ImageView&lt;/code&gt; , который отображает миниатюру 100x100 пикселей, как показано в следующем примере кода:</target>
        </trans-unit>
        <trans-unit id="b412b9ffc3f40429c9fd4b3c3a6e26c29f0579ef" translate="yes" xml:space="preserve">
          <source>This seems like the appropriate place to share my utility class for loading and processing images with the community, you are welcome to use it and modify it freely.</source>
          <target state="translated">Это кажется подходящим местом для того,чтобы поделиться с сообществом своим классом утилиты для загрузки и обработки изображений,вы можете использовать его и свободно изменять.</target>
        </trans-unit>
        <trans-unit id="3c22f297ce30d1437a3a031b9295e728495fda9d" translate="yes" xml:space="preserve">
          <source>This will work because the actual binary data of the decoded bitmap is not stored within the dalvik VM heap. It is stored externally. So every time you decode a bitmap, it allocates memory outside of VM heap which is never reclaimed by GC</source>
          <target state="translated">Это сработает,так как фактические двоичные данные декодированной растровой карты не хранятся в куче ВМ dalvik.Они хранятся извне.Поэтому каждый раз,когда вы декодируете растровое изображение,оно выделяет память за пределами кучи ВМ,которая никогда не восстанавливается ГК</target>
        </trans-unit>
        <trans-unit id="083571b73e7037527d98deb441337ef37561d9e3" translate="yes" xml:space="preserve">
          <source>This worked for me!</source>
          <target state="translated">Это сработало со мной!</target>
        </trans-unit>
        <trans-unit id="ff3cc37ab695a425aff6adea4152c406e697b6ca" translate="yes" xml:space="preserve">
          <source>This works for me.</source>
          <target state="translated">Это работает на меня.</target>
        </trans-unit>
        <trans-unit id="b83a9cea18feba16553b9bcfb40c0d66a03ef1d7" translate="yes" xml:space="preserve">
          <source>This would be preferable as I also need to make some changes to the properties of the widgets/elements in each row as I am unable to select a row with the touch screen because of the focus issue. (&lt;em&gt;I can use roller ball.&lt;/em&gt;)</source>
          <target state="translated">Это было бы предпочтительным, так как мне также необходимо внести некоторые изменения в свойства виджетов / элементов в каждой строке, поскольку я не могу выбрать строку с сенсорным экраном из-за проблемы с фокусировкой. ( &lt;em&gt;Я могу использовать роллер мяч.&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="d1c0eb4e84c2af1b6622c8a4e7d4606247637ac5" translate="yes" xml:space="preserve">
          <source>To avoid &lt;code&gt;java.lang.OutOfMemory&lt;/code&gt; exceptions, check the dimensions of a bitmap before decoding it, unless you absolutely trust the source to provide you with predictably sized image data that comfortably fits within the available memory.</source>
          <target state="translated">Чтобы избежать исключений &lt;code&gt;java.lang.OutOfMemory&lt;/code&gt; , проверьте размеры растрового изображения перед его декодированием, если только вы не доверяете источнику, предоставляя вам данные изображения предсказуемого размера, которые удобно помещаются в доступную память.</target>
        </trans-unit>
        <trans-unit id="48d70a72fc4b6b1e69ce7fd5a7aec59543dba56c" translate="yes" xml:space="preserve">
          <source>To fix the OutOfMemory error, you should do something like this:</source>
          <target state="translated">Чтобы исправить ошибку OutOfMemory,нужно сделать что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="65b13cbd1e14b5560d947288d163d6c54a93a42b" translate="yes" xml:space="preserve">
          <source>To help you better appreciate this, imagine you have kept ur image in the drawable folder. You just get the image by doing a getResources().getDrwable(R.drawable.). This will NOT decode your image everytime but re-use an already decoded instance everytime you call it. So in essence it is cached.</source>
          <target state="translated">Чтобы помочь вам лучше оценить это,представьте,что вы сохранили изображение в папке для рисования.Вы просто получаете изображение,делая getResources().getDrwable(R.drawable.).Это НЕ будет декодировать ваше изображение каждый раз,а повторно использовать уже декодированный экземпляр каждый раз,когда вы его вызываете.Так что по сути оно кэшируется.</target>
        </trans-unit>
        <trans-unit id="71eb65994b8a42ceb4636801be75eb60cea6fbf4" translate="yes" xml:space="preserve">
          <source>To tell the decoder to subsample the image, loading a smaller version into memory, set &lt;code&gt;inSampleSize&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in your &lt;code&gt;BitmapFactory.Options&lt;/code&gt; object. For example, an image with resolution 2048x1536 that is decoded with an &lt;code&gt;inSampleSize&lt;/code&gt; of 4 produces a bitmap of approximately 512x384. Loading this into memory uses 0.75MB rather than 12MB for the full image (assuming a bitmap configuration of &lt;code&gt;ARGB_8888&lt;/code&gt;). Here&amp;rsquo;s a method to calculate a sample size value that is a power of two based on a target width and height:</source>
          <target state="translated">Чтобы дать декодеру &lt;code&gt;inSampleSize&lt;/code&gt; произвести выборку изображения, загружая уменьшенную версию в память, установите для inSampleSize значение &lt;code&gt;true&lt;/code&gt; в объекте &lt;code&gt;BitmapFactory.Options&lt;/code&gt; . Например, изображение с разрешением 2048x1536, которое декодируется с &lt;code&gt;inSampleSize&lt;/code&gt; 4, создает растровое изображение приблизительно 512x384. Загрузка этого в память использует 0,75 МБ, а не 12 МБ для полного изображения (при условии конфигурации растрового изображения &lt;code&gt;ARGB_8888&lt;/code&gt; ). Вот метод для вычисления значения размера выборки, которое является степенью двойки, на основе целевой ширины и высоты:</target>
        </trans-unit>
        <trans-unit id="df352c8e2d07bd2d7dbdef1797f9c0346e5ecc46" translate="yes" xml:space="preserve">
          <source>To use this method, first decode with &lt;code&gt;inJustDecodeBounds&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, pass the options through and then decode again using the new &lt;code&gt;inSampleSize&lt;/code&gt; value and &lt;code&gt;inJustDecodeBounds&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">Чтобы использовать этот метод, сначала &lt;code&gt;inJustDecodeBounds&lt;/code&gt; декодирование с inJustDecodeBounds, установленным в значение &lt;code&gt;true&lt;/code&gt; , передайте параметры, а затем снова декодируйте, используя новое значение &lt;code&gt;inJustDecodeBounds&lt;/code&gt; и inJustDecodeBounds, установленное в значение &lt;code&gt;false&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9749e1bdd9779ff26905faf23b25fa0ee6ff24a1" translate="yes" xml:space="preserve">
          <source>Use &lt;em&gt;one eighth&lt;/em&gt; of the assigned application memory to the cache (modify if you want)</source>
          <target state="translated">Используйте &lt;em&gt;одну восьмую&lt;/em&gt; назначенной памяти приложения для кэша (измените, если хотите)</target>
        </trans-unit>
        <trans-unit id="086b109c2c71c8a21f0af357fec8c21ffee53f19" translate="yes" xml:space="preserve">
          <source>Use this &lt;code&gt;bitmap.recycle();&lt;/code&gt; This helps without any image quality issue.</source>
          <target state="translated">Используйте этот &lt;code&gt;bitmap.recycle();&lt;/code&gt; Это помогает без каких-либо проблем с качеством изображения.</target>
        </trans-unit>
        <trans-unit id="9b4efae91171efc758e907e192f453bd7adb8a6a" translate="yes" xml:space="preserve">
          <source>VM Heap size will never shrink after grown, even if the allocated VM memory is shrinked.</source>
          <target state="translated">Размер кучи ВМ никогда не уменьшится после роста,даже если выделенная память ВМ сократится.</target>
        </trans-unit>
        <trans-unit id="5e5a09a5ae7dbdb06951a426b6cf158547b19325" translate="yes" xml:space="preserve">
          <source>When I would get half way down the listview it would crash.</source>
          <target state="translated">Когда я пройду полпути вниз по списку,он разобьется.</target>
        </trans-unit>
        <trans-unit id="c945a308d354091e2330620c81c8a0b0221e3e9f" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;R.id.imagefilename&lt;/code&gt; is a &lt;code&gt;ButtonImage&lt;/code&gt;.</source>
          <target state="translated">Где &lt;code&gt;R.id.imagefilename&lt;/code&gt; - это &lt;code&gt;ButtonImage&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="684e0710b7cc05acc8e388e5c53bb6116373051f" translate="yes" xml:space="preserve">
          <source>You can download the source code from &lt;a href=&quot;https://www.dropbox.com/s/pvr9zyl811tfeem/ListViewImageCache.zip&quot;&gt;https://www.dropbox.com/s/pvr9zyl811tfeem/ListViewImageCache.zip&lt;/a&gt;.</source>
          <target state="translated">Вы можете скачать исходный код с &lt;a href=&quot;https://www.dropbox.com/s/pvr9zyl811tfeem/ListViewImageCache.zip&quot;&gt;https://www.dropbox.com/s/pvr9zyl811tfeem/ListViewImageCache.zip&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73628b41fb9b25c155a21421306fbcce58da58cd" translate="yes" xml:space="preserve">
          <source>You can follow a similar process to decode bitmaps from other sources, by substituting the appropriate &lt;code&gt;BitmapFactory.decode*&lt;/code&gt; method as needed.</source>
          <target state="translated">Вы можете выполнить аналогичный процесс для декодирования растровых изображений из других источников, заменив соответствующий метод &lt;code&gt;BitmapFactory.decode*&lt;/code&gt; при необходимости.</target>
        </trans-unit>
        <trans-unit id="d794139a87d2b32089b831dc7c4fa49a35269032" translate="yes" xml:space="preserve">
          <source>You can see it yourself in the App. If an Activity executed an AsyncTask that was still running after the Activity was destroyed, the Activity will not get garbage collected until the AsyncTask finish.</source>
          <target state="translated">Ты можешь увидеть это сам в App.Если Действия выполняли AsyncTask,которая все еще выполнялась после того,как Действия были уничтожены,то Действия не будут собирать мусор до тех пор,пока AsyncTask не завершится.</target>
        </trans-unit>
        <trans-unit id="356ca3448e5ea9eaa98cc0e959d7e34c0f22fa35" translate="yes" xml:space="preserve">
          <source>You may consider the size and the resolution for each of the bitmap pictures used. I recommend to reduce the size ,resample to lower resolution , refer to the design of galleries (one small picture PNG , and one original picture.)</source>
          <target state="translated">Вы можете рассмотреть размер и разрешение для каждого используемого растрового изображения.Я рекомендую уменьшить размер,передискретизировать до более низкого разрешения,обратитесь к дизайну галерей (одна маленькая картинка PNG,и одна оригинальная картинка).</target>
        </trans-unit>
        <trans-unit id="bc28a9e5ebe1b3b73a20e45e1b52656870567674" translate="yes" xml:space="preserve">
          <source>You shouldn't need to edit anything in the Cache.java file unless you want to implement disk caching.</source>
          <target state="translated">Вам не нужно ничего редактировать в Cache.java файле,если только вы не хотите реализовать дисковое кэширование.</target>
        </trans-unit>
        <trans-unit id="0dd213f54445d617f4d98ac140097719d49229b9" translate="yes" xml:space="preserve">
          <source>a) scaling my images by a factor of 2</source>
          <target state="translated">а)масштабирование моих изображений в 2 раза.</target>
        </trans-unit>
        <trans-unit id="72edad72ee3b57cafab52ff580d94c36c4e6e792" translate="yes" xml:space="preserve">
          <source>and this is on C# monodroid.
you can easily change the path of the image. what important here is the options to be set.</source>
          <target state="translated">и это на C#monodroid.вы можете легко изменить путь к изображению.что здесь важно-это установить опции.</target>
        </trans-unit>
        <trans-unit id="06449e6b2554561f87ea44d1680df513c4824509" translate="yes" xml:space="preserve">
          <source>b) using &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;Picasso&lt;/a&gt; library in my custom Adapter for a ListView, with a one-call in getView like this: &lt;code&gt;Picasso.with(context).load(R.id.myImage).into(R.id.myImageView);&lt;/code&gt;</source>
          <target state="translated">б) использование библиотеки &lt;a href=&quot;http://square.github.io/picasso/&quot;&gt;Picasso&lt;/a&gt; в моем настраиваемом адаптере для ListView с помощью одного вызова в getView, например: &lt;code&gt;Picasso.with(context).load(R.id.myImage).into(R.id.myImageView);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="960910ee56ce1c0c3410dd1ea2d9f24f2b9318b6" translate="yes" xml:space="preserve">
          <source>for more please refer &lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/load-bitmap.html&quot;&gt;&lt;em&gt;this&lt;/em&gt;&lt;/a&gt;</source>
          <target state="translated">для более подробной информации, пожалуйста, обратитесь к &lt;a href=&quot;http://developer.android.com/training/displaying-bitmaps/load-bitmap.html&quot;&gt;&lt;em&gt;этому&lt;/em&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fe3747eb4c904bbf243426b3a4782c70145ee206" translate="yes" xml:space="preserve">
          <source>then i have worked to solve this issue &amp;amp; finally i've made the below improvement to Fedor's(All Credit to Fedor for making such a nice solution) code :)</source>
          <target state="translated">затем я работал над решением этой проблемы и, наконец, я сделал приведенное ниже усовершенствование кода Федора (Весь кредит Федору за создание такого замечательного решения) :)</target>
        </trans-unit>
        <trans-unit id="5f200676e9d06c0a40c448510bed16ff1a13ccc7" translate="yes" xml:space="preserve">
          <source>use these code for every image in select from SdCard or drewable to convert bitmap object.</source>
          <target state="translated">используйте этот код для каждого изображения в выделенной из SdCard или отрисованной для преобразования растрового объекта.</target>
        </trans-unit>
        <trans-unit id="beaddbd6b6bb9f62d2328be436e8d976a5b4fe6e" translate="yes" xml:space="preserve">
          <source>use your image path instend of &lt;strong&gt;ImageData_Path.get(img_pos).getPath()&lt;/strong&gt; .</source>
          <target state="translated">используйте путь к изображению в &lt;strong&gt;ImageData_Path.get (img_pos) .getPath ()&lt;/strong&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
