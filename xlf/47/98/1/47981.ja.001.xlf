<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/47981">
    <body>
      <group id="47981">
        <trans-unit id="667b1c8089bc12eca14d4d550e23e87738e4ee0c" translate="yes" xml:space="preserve">
          <source>----[ TEST.C ]----------------------------------------------------------------</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82622d08753d1de6f9f3382a0f1ea825f47b86c1" translate="yes" xml:space="preserve">
          <source>----[ TEST.OUT (disassembled) ]-----------------------------------------------</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28179a8129ad47c185aeefd2ab324dfd531a98ed" translate="yes" xml:space="preserve">
          <source>----[ finis ]-----------------------------------------------------------------</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d19acaa2879cd1a9c40d2ce2d4d557352b4f059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(number &amp;amp; ~(1UL &amp;lt;&amp;lt; n))&lt;/code&gt; will clear the &lt;code&gt;n&lt;/code&gt;th bit and &lt;code&gt;(x &amp;lt;&amp;lt; n)&lt;/code&gt; will set the &lt;code&gt;n&lt;/code&gt;th bit to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(number &amp;amp; ~(1UL &amp;lt;&amp;lt; n))&lt;/code&gt; は &lt;code&gt;n&lt;/code&gt; 番目のビットをクリアし、 &lt;code&gt;(x &amp;lt;&amp;lt; n)&lt;/code&gt; は &lt;code&gt;n&lt;/code&gt; 番目のビットを &lt;code&gt;x&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="88bab2da74a1a1522a542d4c0d7cf84f716233af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n = 4&lt;/code&gt; 0 based bit position to perform bitwise operations.</source>
          <target state="translated">&lt;code&gt;n = 4&lt;/code&gt; 0ベースのビット位置。ビットごとの演算を実行します。</target>
        </trans-unit>
        <trans-unit id="7f9771c7e84c816a1c96a6550df0b6ef37bdaed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num = 55&lt;/code&gt; Integer to perform bitwise operations (set, get, clear, toggle).</source>
          <target state="translated">&lt;code&gt;num = 55&lt;/code&gt; ビット単位の操作（設定、取得、クリア、トグル）を実行するための整数。</target>
        </trans-unit>
        <trans-unit id="848e31d285f7c9e89da0e7c2d41f36526f8b7106" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; may be too great for the shift &lt;code&gt;1 &amp;lt;&amp;lt; x&lt;/code&gt; leading to &lt;em&gt;undefined behavior&lt;/em&gt; (UB).  Even if &lt;code&gt;x&lt;/code&gt; is not too great, &lt;code&gt;~&lt;/code&gt; may not flip enough most-significant-bits.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; は、シフト &lt;code&gt;1 &amp;lt;&amp;lt; x&lt;/code&gt; に対して大きすぎて、 &lt;em&gt;未定義の動作&lt;/em&gt; （UB）につながる可能性があります。 &lt;code&gt;x&lt;/code&gt; が大きすぎない場合でも、 &lt;code&gt;~&lt;/code&gt; は十分な最上位ビットを反転できない場合があります。</target>
        </trans-unit>
        <trans-unit id="382fd1a3e6786b545b23d712868c309637e86796" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; operator: set the bit</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 演算子：ビットを設定する</target>
        </trans-unit>
        <trans-unit id="0359414adb9597ed96d4e6d0bc16391e5df70a66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;1&lt;/code&gt; is not always wide enough&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;1&lt;/code&gt; は必ずしも十分な幅ではありません&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7c79a8c50f27d048849355f137c942afdd1661f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clear a bit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;少しクリア：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c543101c73c1a296c14039d59bf0a9635793189f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How it works?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使い方？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61554349ab10dd3c0bd562fee6415e569b069485" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let suppose few things first&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最初にいくつかのものを想定しましょう&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7317348d5454e5ccfda6a26b4cd2b3fa9166fc7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;
This is designed to be fast (given its flexibility) and non-branchy.  It results in efficient SPARC machine code when compiled Sun Studio 8; I've also tested it using MSVC++ 2008 on amd64.  It's possible to make similar macros for setting and clearing bits.  The key difference of this solution compared with many others here is that it works for any location in pretty much any type of variable.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;これは高速で（その柔軟性を考慮して）分岐しないように設計されています。 Sun Studio 8をコンパイルすると、効率的なSPARCマシンコードが生成されます。 また、amd64でMSVC ++ 2008を使用してテストしました。 ビットを設定およびクリアするための同様のマクロを作成することが可能です。 このソリューションと他の多くのソリューションとの主な違いは、ほとんどすべてのタイプの変数の任意の場所で機能することです。</target>
        </trans-unit>
        <trans-unit id="1cb021c737f247e65e724f7eb367810088853454" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sample usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85768827ef5f80c7e352f5fa2d539548b98c629d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Set a bit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ビットを設定します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42da513f420af644829d9bb366f65fa08d4eb836" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To insure 1 is wide enough:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1の幅が十分であることを保証するには：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f9e296a49ce2bc809c273d109dc52cec704e934" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Toggle a bit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;少し切り替えます：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76484daaa9503e8ade8d19978cb56f30df1b0e1f" translate="yes" xml:space="preserve">
          <source>A C++11 templated version (put in a header):</source>
          <target state="translated">C++11でテンプレート化されたもの(ヘッダーに入れる)。</target>
        </trans-unit>
        <trans-unit id="dd0efbc1af335ddf7596de68563a756f24d2af13" translate="yes" xml:space="preserve">
          <source>As this is tagged &quot;embedded&quot; I'll assume you're using a microcontroller. All of the above suggestions are valid &amp;amp; work (read-modify-write, unions, structs, etc.).</source>
          <target state="translated">これには「組み込み」というタグが付いているので、マイクロコントローラーを使用していると想定します。 上記の提案はすべて有効であり、機能します（読み取り、変更、書き込み、共用体、構造体など）。</target>
        </trans-unit>
        <trans-unit id="ca3f48378eac716e70a5d35da0190c3f867ecea1" translate="yes" xml:space="preserve">
          <source>As with most bit manipulations, best to work with &lt;em&gt;unsigned&lt;/em&gt; types rather than &lt;em&gt;signed&lt;/em&gt; ones</source>
          <target state="translated">ほとんどのビット操作と同様に、 &lt;em&gt;符号付きの&lt;/em&gt;型ではなく&lt;em&gt;符号なしの&lt;/em&gt;型を使用するのが最善です</target>
        </trans-unit>
        <trans-unit id="c15f6ad62fcb1c5adbc33a14883c9aec53fb6629" translate="yes" xml:space="preserve">
          <source>Bit &lt;code&gt;n&lt;/code&gt; will be set if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, and cleared if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.  If &lt;code&gt;x&lt;/code&gt; has some other value, you get garbage.  &lt;code&gt;x = !!x&lt;/code&gt; will booleanize it to 0 or 1.</source>
          <target state="translated">ビット &lt;code&gt;n&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;1&lt;/code&gt; の場合に設定され、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;0&lt;/code&gt; の場合にクリアされます 。 &lt;code&gt;x&lt;/code&gt; に他の値がある場合、ゴミが発生します。 &lt;code&gt;x = !!x&lt;/code&gt; は0または1にブール値化します。</target>
        </trans-unit>
        <trans-unit id="c0dc3a25a7b2a779b187625efeb875cf8c20f29d" translate="yes" xml:space="preserve">
          <source>Changing the &lt;em&gt;n&lt;/em&gt;th bit to &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt;番目のビットを&lt;em&gt;xに&lt;/em&gt;変更する</target>
        </trans-unit>
        <trans-unit id="1270985c4d41de2a73fbc1aacfe693c2c765689c" translate="yes" xml:space="preserve">
          <source>Check a bit at an arbitrary location in a variable of arbitrary type:</source>
          <target state="translated">任意の型の変数の任意の位置のビットをチェックします。</target>
        </trans-unit>
        <trans-unit id="0046e71f379a6dd39fb25966cd1653a420ea2c0c" translate="yes" xml:space="preserve">
          <source>Checking a bit</source>
          <target state="translated">ちょっとしたチェック</target>
        </trans-unit>
        <trans-unit id="57acd198ff9087d7520a01146414b47b3a14b3f1" translate="yes" xml:space="preserve">
          <source>Checking a bit:</source>
          <target state="translated">ビットをチェックしています。</target>
        </trans-unit>
        <trans-unit id="4a6dd3b47c599cf59a114edea596417b09ee3985" translate="yes" xml:space="preserve">
          <source>Clearing a bit</source>
          <target state="translated">少しクリア</target>
        </trans-unit>
        <trans-unit id="6a8683eeffabe79feb1a889dc0f34644ae375aa3" translate="yes" xml:space="preserve">
          <source>Code could use &lt;code&gt;1ull&lt;/code&gt; or pedantically &lt;code&gt;(uintmax_t)1&lt;/code&gt; and let the compiler optimize.</source>
          <target state="translated">コードは &lt;code&gt;1ull&lt;/code&gt; またはpedantically &lt;code&gt;(uintmax_t)1&lt;/code&gt; を使用して、コンパイラーを最適化できます。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="a63c8c2a3c3b016fccf07ab1ac2d82cb938be8f1" translate="yes" xml:space="preserve">
          <source>Expanding on the &lt;code&gt;bitset&lt;/code&gt; answer:</source>
          <target state="translated">&lt;code&gt;bitset&lt;/code&gt; 答えを拡張する：</target>
        </trans-unit>
        <trans-unit id="39eb92508ee5df2b84015b6338bf22397753fcda" translate="yes" xml:space="preserve">
          <source>Finally, perform bitwise AND &lt;code&gt;&amp;amp;&lt;/code&gt; operation with the above result and &lt;code&gt;num&lt;/code&gt;. The above three steps together can be written as &lt;code&gt;num &amp;amp; (~ (1 &amp;lt;&amp;lt; n))&lt;/code&gt;;</source>
          <target state="translated">最後に、上記の結果と &lt;code&gt;num&lt;/code&gt; でビットごとのAND &lt;code&gt;&amp;amp;&lt;/code&gt; 演算を実行します。 上記の3つのステップをまとめると、 &lt;code&gt;num &amp;amp; (~ (1 &amp;lt;&amp;lt; n))&lt;/code&gt; として記述できます。</target>
        </trans-unit>
        <trans-unit id="acb53377ab75dda9fb22160fbaab3a8c655b90ac" translate="yes" xml:space="preserve">
          <source>For the beginner I would like to explain a bit more with an example:</source>
          <target state="translated">初心者の方には、もう少し例を挙げて説明したいと思います。</target>
        </trans-unit>
        <trans-unit id="5901a13434d6c93a77c96dc821923c76bcdb001e" translate="yes" xml:space="preserve">
          <source>For those unfamiliar: In my example, the micro has a general pin-state register PORTn which reflects the output pins, so doing PORTn |= BIT_TO_SET results in a read-modify-write to that register. However, the PORTnSET / PORTnCLEAR registers take a '1' to mean &quot;please make this bit 1&quot; (SET) or &quot;please make this bit zero&quot; (CLEAR) and a '0' to mean &quot;leave the pin alone&quot;. so, you end up with two port addresses depending whether you're setting or clearing the bit (not always convenient) but a &lt;em&gt;much&lt;/em&gt; faster reaction and smaller assembled code.</source>
          <target state="translated">なじみのない人のために：私の例では、マイクロには出力ピンを反映する一般的なピン状態レジスタPORTnがあるため、PORTn | = BIT_TO_SETを実行すると、そのレジスタへの読み取り-変更-書き込みが行われます。 ただし、PORTnSET / PORTnCLEARレジスタは、「このビットを1にしてください」（SET）または「このビットをゼロにしてください」（CLEAR）を意味する「1」と「ピンをそのままにする」ことを意味する「0」を取ります。 したがって、ビットを設定またはクリアするかどうかに応じて2つのポートアドレスが得られます（常に便利ではありません）が、反応は&lt;em&gt;はるかに&lt;/em&gt;速く、アセンブルされたコードは小さくなります。</target>
        </trans-unit>
        <trans-unit id="6bf3ec6d6ad3785ab0fb41e4f4217bd944ff4d87" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://snippets.org/code/temp/snip-c.zip&quot;&gt;snip-c.zip&lt;/a&gt;'s bitops.h:</source>
          <target state="translated">&lt;a href=&quot;http://snippets.org/code/temp/snip-c.zip&quot;&gt;snip-c.zip&lt;/a&gt;のbitops.hから：</target>
        </trans-unit>
        <trans-unit id="2acb84d0306fd7eb7601bbea16014daa02abef8a" translate="yes" xml:space="preserve">
          <source>Here are some macros I use:</source>
          <target state="translated">私が使っているマクロを紹介します。</target>
        </trans-unit>
        <trans-unit id="4b9390e3e32e0b8afea1e32f1f1feefc845945fe" translate="yes" xml:space="preserve">
          <source>Here's my favorite bit arithmetic macro, which works for any type of unsigned integer array from &lt;code&gt;unsigned char&lt;/code&gt; up to &lt;code&gt;size_t&lt;/code&gt; (which is the biggest type that should be efficient to work with):</source>
          <target state="translated">これが私のお気に入りのビット算術マクロです。これは、 &lt;code&gt;unsigned char&lt;/code&gt; から &lt;code&gt;size_t&lt;/code&gt; までのあらゆるタイプの符号なし整数配列で機能します（これは、効率的に動作する最大のタイプです）。</target>
        </trans-unit>
        <trans-unit id="dab754019cefc4bba49daa09c429495b77c8d0c3" translate="yes" xml:space="preserve">
          <source>How do you set, clear, and toggle a bit?</source>
          <target state="translated">セット、クリア、トグルを少しだけするにはどうしたらいいですか?</target>
        </trans-unit>
        <trans-unit id="f9c977f6f7383a9196447d907de3d0bb28b2af49" translate="yes" xml:space="preserve">
          <source>How do you set, clear, and toggle a single bit</source>
          <target state="translated">1ビットの設定、クリア、トグルはどのように行いますか?</target>
        </trans-unit>
        <trans-unit id="a5ce3b216f3bac3897b9e763d3183b410d7f332d" translate="yes" xml:space="preserve">
          <source>How do you set, clear, and toggle a single bit?</source>
          <target state="translated">1ビットの設定、クリア、トグルの方法は?</target>
        </trans-unit>
        <trans-unit id="99810e7c0f49901c9c73d5857a396a39cb6a6d07" translate="yes" xml:space="preserve">
          <source>How to clear a bit?</source>
          <target state="translated">ビットをクリアするには?</target>
        </trans-unit>
        <trans-unit id="0ef616e8fabd6b1f05a5d3ef01a0cf8320d9920c" translate="yes" xml:space="preserve">
          <source>How to get a bit?</source>
          <target state="translated">どうやってビットを手に入れるのか?</target>
        </trans-unit>
        <trans-unit id="676f6ee71c4069850ae2a5fa4f9c733b92d7f213" translate="yes" xml:space="preserve">
          <source>How to set a bit?</source>
          <target state="translated">ビットの設定方法は?</target>
        </trans-unit>
        <trans-unit id="7978c9b6c8953d08339eb06c78aa2fb897e8e58b" translate="yes" xml:space="preserve">
          <source>How to toggle a bit?</source>
          <target state="translated">ちょっとしたトグルの仕方を教えてください。</target>
        </trans-unit>
        <trans-unit id="a2fa6ff8c5a509f7affb45b5f46e1b50f9d21608" translate="yes" xml:space="preserve">
          <source>However, during a bout of oscilloscope-based debugging I was amazed to find that these methods have a considerable overhead in CPU cycles compared to writing a value directly to the micro's PORTnSET / PORTnCLEAR registers which makes a real difference where there are tight loops / high-frequency ISR's toggling pins.</source>
          <target state="translated">しかし、オシロスコープベースのデバッグでは、マイクロの PORTnSET PORTnCLEAR レジスタに直接値を書き込むのに比べて、これらの方法は CPU サイクルでかなりのオーバーヘッドがあることがわかり、これはタイトループの高周波 ISR のトグルピンがある場所では大きな違いとなります。</target>
        </trans-unit>
        <trans-unit id="f9ff9f9c33b6614a39d7e8d0f6b8c3c83b05a88f" translate="yes" xml:space="preserve">
          <source>I once used this approach to find duplicate loan records, where loan_number was the ISAM key, using the 6-digit loan number as an index into the bit array. Savagely fast, and after 8 months, proved that the mainframe system we were getting the data from was in fact malfunctioning. The simplicity of bit arrays makes confidence in their correctness very high - vs a searching approach for example.</source>
          <target state="translated">私は以前、この方法を使って、ローンレコードの重複を見つけるために使用したことがあります。ローン番号が6桁のローン番号をビット配列のインデックスとして使用して、ローン番号がISAMキーになっていました。非常に高速で、8ヶ月後には、データを取得していたメインフレーム・システムが実際には故障していたことが判明しました。ビット配列のシンプルさは、その正しさに対する信頼性を非常に高くしています。</target>
        </trans-unit>
        <trans-unit id="abb2634e4ade2a28866d25c8f2bdb63000cd6ff8" translate="yes" xml:space="preserve">
          <source>I use macros defined in a header file to handle bit set and clear:</source>
          <target state="translated">私はヘッダファイルで定義されたマクロを使ってビットセットとクリアを処理しています。</target>
        </trans-unit>
        <trans-unit id="7c4ffb4ea2a2439cee5a2c80ae16bef112cee616" translate="yes" xml:space="preserve">
          <source>I used &lt;code&gt;XXXb&lt;/code&gt; for clarity.  You'll probably be working with HEX representation, depending on the data structure in which you're packing bits.</source>
          <target state="translated">わかりやすくするために &lt;code&gt;XXXb&lt;/code&gt; を使用しました。 ビットをパックするデータ構造に応じて、おそらくHEX表現で作業します。</target>
        </trans-unit>
        <trans-unit id="53333655be5b4db7377f60710f9b0ca634975fe0" translate="yes" xml:space="preserve">
          <source>If posn==8, it will evaluate to:</source>
          <target state="translated">posn==8ならば評価されます。</target>
        </trans-unit>
        <trans-unit id="ab57d68adecc6b6e118572053a3f69dd754eef04" translate="yes" xml:space="preserve">
          <source>If the bit to toggle is 0 then, &lt;code&gt;0 ^ 1 =&amp;gt; 1&lt;/code&gt;.</source>
          <target state="translated">トグルするビットが0の場合、 &lt;code&gt;0 ^ 1 =&amp;gt; 1&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="709903b975187f0c348b45214e90d052b9e93fa0" translate="yes" xml:space="preserve">
          <source>If the bit to toggle is 1 then, &lt;code&gt;1 ^ 1 =&amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">トグルするビットが1の場合、 &lt;code&gt;1 ^ 1 =&amp;gt; 0&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b5b6e652bc09f0ac15f015a6d4bb22acd19945ba" translate="yes" xml:space="preserve">
          <source>If you want to perform this all operation with C programming in the &lt;strong&gt;Linux kernel&lt;/strong&gt; then I suggest to use standard APIs of the Linux kernel.</source>
          <target state="translated">&lt;strong&gt;Linuxカーネル&lt;/strong&gt;でCプログラミングを使用してこのすべての操作を実行する場合は、 &lt;strong&gt;Linuxカーネルの&lt;/strong&gt;標準APIを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="61899a46cc7eb4e290f78ad5e2725eed57bd4439" translate="yes" xml:space="preserve">
          <source>If you're doing a lot of bit twiddling you might want to use masks which will make the whole thing quicker. The following functions are very fast and are still flexible (they allow bit twiddling in bit maps of any size).</source>
          <target state="translated">たくさんのビットをいじっている場合は、マスクを使った方が全体の処理が速くなるかもしれません。以下の関数は非常に高速でありながら柔軟性があります (これらの関数は任意のサイズのビットマップでビットツイディリングを行うことができます)。</target>
        </trans-unit>
        <trans-unit id="e075322fcf0586e896160b581843d5cafec9bee4" translate="yes" xml:space="preserve">
          <source>In other words, it simply creates a field of 0's with a 1 at the specified
position. The only tricky part is in the BitClr() macro where we need to set
a single 0 bit in a field of 1's. This is accomplished by using the 1's
complement of the same expression as denoted by the tilde (~) operator.</source>
          <target state="translated">言い換えれば、指定した位置に 1 を持つ 0 のフィールドを単純に作成します。唯一のトリッキーな部分は BitClr()マクロで、1 のフィールドに 0 ビットを 1 つ設定する必要があります。これは、チルダ(~)演算子で表される同じ式の1の補数を使用することで実現します。</target>
        </trans-unit>
        <trans-unit id="5aa47be261e161951f1f0bafd740a16b32aa8b1c" translate="yes" xml:space="preserve">
          <source>It is sometimes worth using an &lt;code&gt;enum&lt;/code&gt; to &lt;em&gt;name&lt;/em&gt; the bits:</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; を使用してビットに&lt;em&gt;名前&lt;/em&gt;を&lt;em&gt;付ける&lt;/em&gt;ことは価値があります。</target>
        </trans-unit>
        <trans-unit id="0b473b87effc8c47c29548c29028f4de82eafa38" translate="yes" xml:space="preserve">
          <source>It's also generally a good idea to not to copy/paste code in general and so many people use preprocessor macros (like &lt;a href=&quot;https://stackoverflow.com/a/263738/52074&quot;&gt;the community wiki answer further down&lt;/a&gt;) or some sort of encapsulation.</source>
          <target state="translated">また、一般的にコードをコピー/貼り付けしないことは一般的に良い考えであり、多くの人々はプリプロセッサマクロ（ &lt;a href=&quot;https://stackoverflow.com/a/263738/52074&quot;&gt;コミュニティのwikiの回答など&lt;/a&gt; ）やある種のカプセル化を使用します。</target>
        </trans-unit>
        <trans-unit id="ed20494581b901298a0d7477a63131dc2432faf0" translate="yes" xml:space="preserve">
          <source>It's generally a good idea to use unsigned types for portable bit manipulation.</source>
          <target state="translated">一般的には、ポータブルなビット操作には符号なし型を使用するのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="f25048a05cb0bb71ed1211931fa89d7ef6b05ffc" translate="yes" xml:space="preserve">
          <source>It's up to you to ensure that the bit number is within the range of the bit map that you pass. Note that for little endian processors that bytes, words, dwords, qwords, etc., map correctly to each other in memory (main reason that little endian processors are 'better' than big-endian processors, ah, I feel a flame war coming on...).</source>
          <target state="translated">ビット番号が、渡すビットマップの範囲内にあるかどうかは、あなた次第です。リトルエンディアンプロセッサでは、バイト、ワード、dワード、qワードなどがメモリ上で正しくマップされていることに注意してください (リトルエンディアンプロセッサの方がビッグエンディアンプロセッサよりも「優れている」という主な理由があります。)</target>
        </trans-unit>
        <trans-unit id="9127fb2258eb06efbfee1748ca9d04c76290852f" translate="yes" xml:space="preserve">
          <source>Left shift 1, &lt;code&gt;n&lt;/code&gt; times i.e. &lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;.</source>
          <target state="translated">左シフト1、 &lt;code&gt;n&lt;/code&gt; 回、つまり &lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73ef110f80c735334a2164f4ced66ec711a00839" translate="yes" xml:space="preserve">
          <source>More general, for arbitrary sized bitmaps:</source>
          <target state="translated">より一般的には、任意のサイズのビットマップのために。</target>
        </trans-unit>
        <trans-unit id="c85d279b39b892fb0988e34530a22460f26dde21" translate="yes" xml:space="preserve">
          <source>Note there is nothing &quot;special&quot; about this code. It treats a bit like an integer - which technically, it is. A 1 bit integer that can hold 2 values, and 2 values only.</source>
          <target state="translated">このコードには何も「特別な」ことはないことに注意してください。これはビットを整数のように扱います。2 つの値を保持できる 1 ビットの整数で、2 つの値のみを保持します。</target>
        </trans-unit>
        <trans-unit id="43c1f0ee9dffa874878e37109448c03df6055fa1" translate="yes" xml:space="preserve">
          <source>Note, to set bit 'n' in a 16 bit integer you do the following:</source>
          <target state="translated">注意:16 ビット整数にビット 'n' を設定するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="c222bbbaefaedb63d5ffc3a5327c69e30a7a8475" translate="yes" xml:space="preserve">
          <source>Note: Here the whole operation happens in a single step. So these all are  guaranteed to be &lt;strong&gt;atomic&lt;/strong&gt; even on SMP computers and are useful
to keep coherence across processors.</source>
          <target state="translated">注：ここでは、操作全体が1つのステップで行われます。 したがって、これらはすべてSMPコンピューター上でも&lt;strong&gt;アトミック&lt;/strong&gt;であることが保証されており、プロセッサー間で一貫性を保つのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="5e87a0baab99790ee774b3f16e2f02538b65f612" translate="yes" xml:space="preserve">
          <source>OK, let's analyze things...</source>
          <target state="translated">よし、物事を分析してみよう...。</target>
        </trans-unit>
        <trans-unit id="c9dff73a77556f8f89fef17ebdd7a3587ab11da9" translate="yes" xml:space="preserve">
          <source>Once the mask is created it's applied to the argument just as you suggest,
by use of the bitwise and (&amp;amp;), or (|), and xor (^) operators. Since the mask
is of type long, the macros will work just as well on char's, short's, int's,
or long's.</source>
          <target state="translated">マスクが作成されると、ビットごとの（＆）、または（|）、およびxor（^）演算子を使用して、提案したとおりに引数に適用されます。 マスクはlong型なので、マクロはchar、short、int、longでも同様に機能します。</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="a72e2de1fad09c6b77cac7a842b1146a5d7550b7" translate="yes" xml:space="preserve">
          <source>Or cast - which makes for coding/review/maintenance issues keeping the cast correct and up-to-date.</source>
          <target state="translated">またはキャスト-キャストを正しく、最新の状態に保つcodingreviewmaintenanceの問題になります。</target>
        </trans-unit>
        <trans-unit id="f4d6bde5a9d5b3d020e725f997fcf3b65b6d6418" translate="yes" xml:space="preserve">
          <source>Or gently promote the &lt;code&gt;1&lt;/code&gt; by forcing a math operation that is as least as wide as the type of &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">または、少なくとも数値のタイプと同じ幅の数学演算を強制して、 &lt;code&gt;1&lt;/code&gt; を穏やかに昇格させます。</target>
        </trans-unit>
        <trans-unit id="125721cc78969f3a2d79b9b18521bcc882ed9fac" translate="yes" xml:space="preserve">
          <source>Or the &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; version: &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;&lt;code&gt;boost::dynamic_bitset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">または、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt;バージョン： &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt; &lt;code&gt;boost::dynamic_bitset&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2e9f4a4d6cdb522a496493f27b424fb5d782fa3" translate="yes" xml:space="preserve">
          <source>Other than that I endorse Jeremy's solution.</source>
          <target state="translated">それ以外はジェレミーの解決策を支持します。</target>
        </trans-unit>
        <trans-unit id="bc375646114e7205fd7164e5b46611889f795982" translate="yes" xml:space="preserve">
          <source>Perform bitwise complement with the above result. So that the nth bit becomes unset and rest of bit becomes set i.e. &lt;code&gt;~ (1 &amp;lt;&amp;lt; n)&lt;/code&gt;.</source>
          <target state="translated">上記の結果でビット単位の補数を実行します。 したがって、n番目のビットは設定されず、残りのビットは設定されます &lt;code&gt;~ (1 &amp;lt;&amp;lt; n)&lt;/code&gt; つまり、 〜（1 &amp;lt;&amp;lt; n）） 。</target>
        </trans-unit>
        <trans-unit id="53ecbc4d6e26d20b1988671948ec51f0ce92790a" translate="yes" xml:space="preserve">
          <source>Recommended reading - &lt;a href=&quot;https://codeforwin.org/2016/01/bitwise-operator-programming-exercises-and-solutions-in-c.html&quot;&gt;Bitwise operator exercises&lt;/a&gt;</source>
          <target state="translated">推奨読書- &lt;a href=&quot;https://codeforwin.org/2016/01/bitwise-operator-programming-exercises-and-solutions-in-c.html&quot;&gt;ビットごとのオペレーター演習&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9994ff248f68711d40d581bcf6caee98f87d856" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html&quot;&gt;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html&quot;&gt;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.htmlを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="61fa48f5afd4c97e0a87d8996b205d9f8d767a5a" translate="yes" xml:space="preserve">
          <source>Setting a bit</source>
          <target state="translated">ちょっとした設定</target>
        </trans-unit>
        <trans-unit id="4dd48a6020a0c4db5765caa2eb0ab4c448f79743" translate="yes" xml:space="preserve">
          <source>Setting the &lt;code&gt;n&lt;/code&gt;th bit to either &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; can be achieved with the following on a 2's complement C++ implementation:</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 番目のビットを &lt;code&gt;1&lt;/code&gt; または &lt;code&gt;0&lt;/code&gt; に設定するには、2の補数のC ++実装で以下を実行します。</target>
        </trans-unit>
        <trans-unit id="5f820945537e9519e37cab115773e594cbfde9df" translate="yes" xml:space="preserve">
          <source>So, to your question, &lt;code&gt;IsGph[i] =1&lt;/code&gt;, or &lt;code&gt;IsGph[i] =0&lt;/code&gt; make setting and clearing bools easy.</source>
          <target state="translated">したがって、あなたの質問に対して、 &lt;code&gt;IsGph[i] =1&lt;/code&gt; または &lt;code&gt;IsGph[i] =0&lt;/code&gt; を設定すると、ブール値の設定とクリアが簡単になります。</target>
        </trans-unit>
        <trans-unit id="c0d66a3a0b4acef20f48d55cb3db57fc9e015602" translate="yes" xml:space="preserve">
          <source>That will clear the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt;. You must invert the bit string with the bitwise NOT operator (&lt;code&gt;~&lt;/code&gt;), then AND it.</source>
          <target state="translated">これにより、 &lt;code&gt;number&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 番目のビットがクリアされます。 ビット列のNOT演算子（ &lt;code&gt;~&lt;/code&gt; ）を使用してビット文字列を反転してから、それをANDする必要があります。</target>
        </trans-unit>
        <trans-unit id="b7f8ce9f568420f97192ac7365e1a1d1e57b8cb9" translate="yes" xml:space="preserve">
          <source>That will put the value of the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt; into the variable &lt;code&gt;bit&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;number&lt;/code&gt; の &lt;code&gt;n&lt;/code&gt; 番目のビットの値が変数 &lt;code&gt;bit&lt;/code&gt; に入れられます 。</target>
        </trans-unit>
        <trans-unit id="8e2b5c6a2b73e16c3c1c0419d83c252dff2bf6b9" translate="yes" xml:space="preserve">
          <source>That will set the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; should be zero, if you want to set the &lt;code&gt;1&lt;/code&gt;st bit and so on upto &lt;code&gt;n-1&lt;/code&gt;, if you want to set the &lt;code&gt;n&lt;/code&gt;th bit.</source>
          <target state="translated">これにより、 &lt;code&gt;number&lt;/code&gt; の &lt;code&gt;n&lt;/code&gt; 番目のビットが設定されます。 最初のビットを設定する場合は &lt;code&gt;n&lt;/code&gt; をゼロに、 &lt;code&gt;n&lt;/code&gt; 番目のビットを設定する場合は &lt;code&gt;n-1&lt;/code&gt; までとします。</target>
        </trans-unit>
        <trans-unit id="e3792762dc53c61df78323ce8b14abd5d5c2d7fd" translate="yes" xml:space="preserve">
          <source>That will toggle the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">これにより、 &lt;code&gt;number&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 番目のビットが切り替わります。</target>
        </trans-unit>
        <trans-unit id="a6d75b05680564f82160755d4f06a5406f4c8d1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; operator is used check the bit:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 演算子を使用してビットを確認します。</target>
        </trans-unit>
        <trans-unit id="4720899f11a5ca9616a00586a34c7d0e1d6719c8" translate="yes" xml:space="preserve">
          <source>The Boost version allows a runtime sized bitset compared with a &lt;a href=&quot;https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library&quot;&gt;standard library&lt;/a&gt; compile-time sized bitset.</source>
          <target state="translated">Boostバージョンでは、 &lt;a href=&quot;https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library&quot;&gt;標準ライブラリの&lt;/a&gt;コンパイル時サイズのビットセットと比較して、ランタイムサイズのビットセットを使用できます。</target>
        </trans-unit>
        <trans-unit id="765d09f1c16860f29a69134a7f599e35e0b8267a" translate="yes" xml:space="preserve">
          <source>The XOR operator (&lt;code&gt;^&lt;/code&gt;) can be used to toggle a bit.</source>
          <target state="translated">XOR演算子（ &lt;code&gt;^&lt;/code&gt; ）を使用して、ビットを切り替えることができます。</target>
        </trans-unit>
        <trans-unit id="4cf704c5ff515de591788d3a37ab972dbffe1384" translate="yes" xml:space="preserve">
          <source>The bitfield approach has other advantages in the embedded arena. You can define a struct that maps directly onto the bits in a particular hardware register.</source>
          <target state="translated">ビットフィールドのアプローチは、組み込み分野では他にも利点があります。特定のハードウェア・レジスタのビットに直接マップする構造体を定義することができます。</target>
        </trans-unit>
        <trans-unit id="839a26b96b5f54ea008530fd6494a3e0722cd1da" translate="yes" xml:space="preserve">
          <source>The bottom line is that this is a general solution to an entire class of
problems. It is, of course, possible and even appropriate to rewrite the
equivalent of any of these macros with explicit mask values every time you
need one, but why do it? Remember, the macro substitution occurs in the
preprocessor and so the generated code will reflect the fact that the values
are considered constant by the compiler - i.e. it's just as efficient to use
the generalized macros as to &quot;reinvent the wheel&quot; every time you need to do
bit manipulation.</source>
          <target state="translated">要するに、これは問題のクラス全体に対する一般的な解決策であるということです。もちろん、これらのマクロの等価なものを、必要に応じてマスク値を明示的に書き換えることは可能ですし、適切でさえあります。マクロの置換はプリプロセッサで行われるため、生成されるコードはコンパイラによって値が一定とみなされていることが反映されることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="22807ae60fb3a3ea091315d57264831db77c47c8" translate="yes" xml:space="preserve">
          <source>The common expression that you seem to be having problems with in all of these is &quot;(1L &amp;lt;&amp;lt; (posn))&quot;. All this does is create a mask with a single bit on
and which will work with any integer type. The &quot;posn&quot; argument specifies the
position where you want the bit. If posn==0, then this expression will
evaluate to:</source>
          <target state="translated">これらすべてに問題があると思われる一般的な表現は「（1L &amp;lt;&amp;lt;（posn））」です。 これが行うことは、シングルビットがオンのマスクを作成することだけで、どの整数型でも機能します。 「posn」引数は、ビットが必要な位置を指定します。 posn == 0の場合、この式は次のように評価されます。</target>
        </trans-unit>
        <trans-unit id="2cf1df7ab406c6d7796051b70b9c6b54ded8be0f" translate="yes" xml:space="preserve">
          <source>The other option is to use bit fields:</source>
          <target state="translated">もう一つの選択肢は、ビットフィールドを使用することです。</target>
        </trans-unit>
        <trans-unit id="6d5a256e0a435b0dd162d8da2c0e4951fd0c09a6" translate="yes" xml:space="preserve">
          <source>Then use the &lt;em&gt;names&lt;/em&gt; later on. I.e. write</source>
          <target state="translated">その後、 &lt;em&gt;名前を&lt;/em&gt;使用し&lt;em&gt;ます&lt;/em&gt; 。 すなわち書く</target>
        </trans-unit>
        <trans-unit id="96f43706cb75f2ae9bded1dfc259d0010e530cea" translate="yes" xml:space="preserve">
          <source>There is no need to roll your own:</source>
          <target state="translated">自分で巻く必要はありません。</target>
        </trans-unit>
        <trans-unit id="4908454acc4ef10e75093e07cef612a928ed415e" translate="yes" xml:space="preserve">
          <source>This only works with fixed-size bit fields. Otherwise you have to resort to the bit-twiddling techniques described in previous posts.</source>
          <target state="translated">これは固定サイズのビットフィールドでのみ動作します。それ以外の場合は、以前の記事で説明したビットねじれのテクニックに頼らなければなりません。</target>
        </trans-unit>
        <trans-unit id="49ebcc18810c044e945316762b2409ebabeec5a3" translate="yes" xml:space="preserve">
          <source>This program is to change any data bit from 0 to 1 or 1 to 0:</source>
          <target state="translated">このプログラムは、任意のデータビットを0から1または1から0に変更するプログラムです。</target>
        </trans-unit>
        <trans-unit id="94dea5b7b912974a57bf942f92f6fcbceb094ddb" translate="yes" xml:space="preserve">
          <source>To address a common coding pitfall when attempting to form the mask:</source>
          <target state="translated">マスクを形成しようとするときによくあるコーディングの落とし穴に対処する。</target>
        </trans-unit>
        <trans-unit id="8bd00cd24171b73299a75c544c100d7ee8e8f976" translate="yes" xml:space="preserve">
          <source>To check a bit, shift the number n to the right, then bitwise AND it:</source>
          <target state="translated">ビットをチェックするには、n個の数字を右にシフトし、ビット単位でANDします。</target>
        </trans-unit>
        <trans-unit id="f55448bd37502c20589b8abddd4ff82c93fb71ca" translate="yes" xml:space="preserve">
          <source>To check last bit in &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; の最後のビットをチェックするには：</target>
        </trans-unit>
        <trans-unit id="b54a27b34b231f7dfbe4ac8c31019c52ca6554d2" translate="yes" xml:space="preserve">
          <source>To clear a bit:</source>
          <target state="translated">少しでもクリアするために。</target>
        </trans-unit>
        <trans-unit id="cd4df75a60322ba893bf854ca414bc756b509949" translate="yes" xml:space="preserve">
          <source>To clear last bit in &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; の最後のビットをクリアするには：</target>
        </trans-unit>
        <trans-unit id="83aa0df6b04e727ccad6ed04ce3e94028c5b988b" translate="yes" xml:space="preserve">
          <source>To find unprintable characters:</source>
          <target state="translated">印刷できない文字を見つけるために</target>
        </trans-unit>
        <trans-unit id="43b735ba3d04a81e8870ac8a77c98b4f54990879" translate="yes" xml:space="preserve">
          <source>To get the &lt;code&gt;nth&lt;/code&gt; bit of num right shift &lt;code&gt;num&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; times. Then perform bitwise AND &lt;code&gt;&amp;amp;&lt;/code&gt; with 1.</source>
          <target state="translated">numの &lt;code&gt;nth&lt;/code&gt; ビットを取得するには、 &lt;code&gt;num&lt;/code&gt; を &lt;code&gt;n&lt;/code&gt; 回右シフトします。 次に、ビットごとのAND &lt;code&gt;&amp;amp;&lt;/code&gt; 1を実行します。</target>
        </trans-unit>
        <trans-unit id="8980b85f79053d6948fc7141289370782531a289" translate="yes" xml:space="preserve">
          <source>To make this independent of 2's complement negation behaviour (where &lt;code&gt;-1&lt;/code&gt; has all bits set, unlike on a 1's complement or sign/magnitude C++ implementation), use unsigned negation.</source>
          <target state="translated">これを2の補数の否定動作から独立させるには（1の補数や符号/大きさのC ++実装とは異なり、 &lt;code&gt;-1&lt;/code&gt; ではすべてのビットが設定されています）、符号なし否定を使用します。</target>
        </trans-unit>
        <trans-unit id="4eb50e3328856c70c1dca6c48069360040ef97f7" translate="yes" xml:space="preserve">
          <source>To set a bit, used &lt;code&gt;int x = x | 0x?;&lt;/code&gt; where &lt;code&gt;?&lt;/code&gt; is the bit position in binary form.</source>
          <target state="translated">ビットを設定するには、 &lt;code&gt;int x = x | 0x?;&lt;/code&gt; 使用します。 0x ?; どこ &lt;code&gt;?&lt;/code&gt; バイナリ形式のビット位置です。</target>
        </trans-unit>
        <trans-unit id="6b53c97c6ee9a3d0d723e702f07943f5c9216677" translate="yes" xml:space="preserve">
          <source>To set a bit:</source>
          <target state="translated">ビットを設定すること。</target>
        </trans-unit>
        <trans-unit id="f9a2b2fb3a1c748d3527c65eef445ab67ab9dcde" translate="yes" xml:space="preserve">
          <source>To set a particular bit of number. Left shift 1 &lt;code&gt;n&lt;/code&gt; times. Then perform bitwise OR &lt;code&gt;|&lt;/code&gt; operation with &lt;code&gt;num&lt;/code&gt;.</source>
          <target state="translated">数値の特定のビットを設定します。 左シフト1 &lt;code&gt;n&lt;/code&gt; 回。 次に、ビットごとのOR &lt;code&gt;|&lt;/code&gt; &lt;code&gt;num&lt;/code&gt; による操作。</target>
        </trans-unit>
        <trans-unit id="10ccea6e8ef43829ca947e5c40c7f06cea47b440" translate="yes" xml:space="preserve">
          <source>To set last bit in &lt;code&gt;000b&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;000b&lt;/code&gt; の最後のビットを設定するには：</target>
        </trans-unit>
        <trans-unit id="e76ce493d90541c9b6b2be6f9c5d3d116427a803" translate="yes" xml:space="preserve">
          <source>To set or clear a bit:</source>
          <target state="translated">ビットを設定したり、クリアしたりすること。</target>
        </trans-unit>
        <trans-unit id="7abc415f2ccd44198e64e7a06b7544cdcf261192" translate="yes" xml:space="preserve">
          <source>To test a bit:</source>
          <target state="translated">ちょっとしたテストのために。</target>
        </trans-unit>
        <trans-unit id="ad468829fc4c0b8c79a1a6e04e882eb31a677d32" translate="yes" xml:space="preserve">
          <source>To toggle a bit we use bitwise XOR &lt;code&gt;^&lt;/code&gt; operator. Bitwise XOR operator evaluates to 1 if corresponding bit of both operands are different, otherwise evaluates to 0.</source>
          <target state="translated">ビットを切り替えるには、ビットごとのXOR &lt;code&gt;^&lt;/code&gt; 演算子を使用します。 ビットごとのXOR演算子は、両方のオペランドの対応するビットが異なる場合は1と評価され、それ以外の場合は0と評価されます。</target>
        </trans-unit>
        <trans-unit id="30f8e6fd1f568c58652958a8cbd971492dd62a90" translate="yes" xml:space="preserve">
          <source>To toggle a bit:</source>
          <target state="translated">ちょっとしたトグルに。</target>
        </trans-unit>
        <trans-unit id="0bd9784c0a74db4482ebf43f0a721806f5b58c6d" translate="yes" xml:space="preserve">
          <source>Toggle or Flip:</source>
          <target state="translated">トグルまたはフリップ。</target>
        </trans-unit>
        <trans-unit id="1b00b054a368563296b1a5a7e8e2be16e927b009" translate="yes" xml:space="preserve">
          <source>Toggling a bit</source>
          <target state="translated">ちょっとしたトグル</target>
        </trans-unit>
        <trans-unit id="d8ff662b08e88c27fe251936b1a4dbf6ca9db7af" translate="yes" xml:space="preserve">
          <source>Try one of these functions in the C language to change n bit:</source>
          <target state="translated">C言語でnビットを変更するには、これらの関数のいずれかを試してみてください。</target>
        </trans-unit>
        <trans-unit id="e33fd3e89b9ceffcb431cb638d3fe473f841d813" translate="yes" xml:space="preserve">
          <source>Unconvinced? Here's some test code - I used Watcom C with full optimization
and without using _cdecl so the resulting disassembly would be as clean as
possible:</source>
          <target state="translated">納得できませんか?Watcom C を完全に最適化して _cdecl を使用せずに使用しています。</target>
        </trans-unit>
        <trans-unit id="a133f4d724536d565a412a2bc18a60f9e028ff9a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;1ULL&lt;/code&gt; if &lt;code&gt;number&lt;/code&gt; is wider than &lt;code&gt;unsigned long&lt;/code&gt;; promotion of &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; doesn't happen until after evaluating &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; where it's undefined behaviour to shift by more than the width of a &lt;code&gt;long&lt;/code&gt;.  The same applies to all the rest of the examples.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; が &lt;code&gt;unsigned long&lt;/code&gt; より広い場合は &lt;code&gt;1ULL&lt;/code&gt; を使用します。 &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; 昇格は、 1UL &amp;lt;&amp;lt; nを評価するまで発生しません &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; は、 &lt;code&gt;long&lt;/code&gt; の幅を超えてシフトすることが未定義の動作です。 残りのすべての例にも同じことが当てはまります。</target>
        </trans-unit>
        <trans-unit id="3116a9203958e2fb47b3c9b0568831002b7f60d6" translate="yes" xml:space="preserve">
          <source>Use one of the operators as defined &lt;a href=&quot;http://www.vantasyworld.com/articles/articles/36/article36_programming_bits.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.vantasyworld.com/articles/articles/36/article36_programming_bits.html&quot;&gt;ここで&lt;/a&gt;定義されている演算子のいずれかを使用します 。</target>
        </trans-unit>
        <trans-unit id="ae11cffafff825583beb30d38a053dbcaf524806" translate="yes" xml:space="preserve">
          <source>Use the bitwise AND operator (&lt;code&gt;&amp;amp;&lt;/code&gt;) to clear a bit.</source>
          <target state="translated">ビット単位のAND演算子（ &lt;code&gt;&amp;amp;&lt;/code&gt; ）を使用して、ビットをクリアします。</target>
        </trans-unit>
        <trans-unit id="cfc0e11cd54b9e7a382a506d5c87343ec19762ac" translate="yes" xml:space="preserve">
          <source>Use the bitwise OR operator (&lt;code&gt;|&lt;/code&gt;) to set a bit.</source>
          <target state="translated">ビット単位のOR演算子（ &lt;code&gt;|&lt;/code&gt; ）を使用してビットを設定します。</target>
        </trans-unit>
        <trans-unit id="384b3daf63a6e18211f6b86fb2b43ebe6b8a0dbe" translate="yes" xml:space="preserve">
          <source>Use the bitwise operators: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;</source>
          <target state="translated">ビット演算子を使用します： &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">これを使って</target>
        </trans-unit>
        <trans-unit id="d680b05bc76ec8664f8f3ce8a41aeb3420399d4c" translate="yes" xml:space="preserve">
          <source>Using the Standard C++ Library: &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/bitset&quot;&gt;&lt;code&gt;std::bitset&amp;lt;N&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">標準C ++ライブラリの使用： &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/bitset&quot;&gt; &lt;code&gt;std::bitset&amp;lt;N&amp;gt;&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="51b111bd60430d71673d27f3e1f35f2a3ef469ef" translate="yes" xml:space="preserve">
          <source>Variable used</source>
          <target state="translated">使用変数</target>
        </trans-unit>
        <trans-unit id="759b6502d2072d601e3238211fe3053e9b2558a8" translate="yes" xml:space="preserve">
          <source>Visual C 2010, and perhaps many other compilers, have direct support for boolean operations built in. A bit has two possible values, just like a boolean, so we can use booleans instead - even if they take up more space than a single bit in memory in this representation. This works, even the &lt;code&gt;sizeof()&lt;/code&gt; operator works properly.</source>
          <target state="translated">Visual C 2010、およびおそらく他の多くのコンパイラーは、組み込みのブール演算を直接サポートしています。ビットにはブール値と同じように2つの値があり、ブール値を使用できます。この表現のメモリ。 これは機能し、 &lt;code&gt;sizeof()&lt;/code&gt; 演算子も正しく機能します。</target>
        </trans-unit>
        <trans-unit id="f9cf49e77f03430ebd5f25bc522c153cf1178625" translate="yes" xml:space="preserve">
          <source>What problems happen when &lt;code&gt;number&lt;/code&gt; is a wider type than &lt;code&gt;1&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; が1より広いタイプである場合、どのような問題が発生しますか？</target>
        </trans-unit>
        <trans-unit id="e4b095a3c1e4e7de61d2386a5c1c85ccaef3c5bf" translate="yes" xml:space="preserve">
          <source>Which means to toggle a bit, we need to perform XOR operation with the bit you want to toggle and 1.</source>
          <target state="translated">つまり、ビットをトグルするには、トグルしたいビットと1でXOR演算を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="13283e05a2e6100d0b5a95ed8d1a08dbfce494f8" translate="yes" xml:space="preserve">
          <source>You can then read, write, test the individual values as before.</source>
          <target state="translated">あとは、以前のように個々の値を読み書きしたり、テストしたりすることができます。</target>
        </trans-unit>
        <trans-unit id="a9a82378920a8af59723a93e1aefb067f39fc80d" translate="yes" xml:space="preserve">
          <source>You didn't ask for this, but I might as well add it.</source>
          <target state="translated">聞かれてないけど、追加してもいいかも。</target>
        </trans-unit>
        <trans-unit id="271ba18b7db73f6cb5c1287e8c31e53799100ded" translate="yes" xml:space="preserve">
          <source>You need to be aware of the bit packing order - I think it's MSB first, but this may be implementation-dependent. Also, verify how your compiler handlers fields crossing byte boundaries.</source>
          <target state="translated">ビットのパッキング順序に注意する必要があります-最初はMSBだと思いますが、これは実装に依存している可能性があります。また、コンパイラのハンドラがどのようにバイト境界を越えるかを確認してください。</target>
        </trans-unit>
        <trans-unit id="c56a85cee06a9cbc75b6a43727c8741125980bfe" translate="yes" xml:space="preserve">
          <source>defines a 3-bit field (actually, it's three 1-bit felds). Bit operations now become a bit (haha) simpler:</source>
          <target state="translated">は3ビットのフィールドを定義しています(実際には3つの1ビットのフィールドです)。ビット演算が少し(はぁ)シンプルになりました。</target>
        </trans-unit>
        <trans-unit id="fb7f7c94028fe09a6d2d9b3bf0b8501eb7095619" translate="yes" xml:space="preserve">
          <source>etc.</source>
          <target state="translated">etc.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="0c4add5f2b8e203f7f9a3a5902a4b7fbe3c3367f" translate="yes" xml:space="preserve">
          <source>pos - position of the bit that we're interested to set, clear or toggle.</source>
          <target state="translated">pos-設定、クリア、トグルするビットの位置.</target>
        </trans-unit>
        <trans-unit id="d183c0deb14cb48b70d54a4509f56c94c7466e99" translate="yes" xml:space="preserve">
          <source>to set, clear and test. This way you hide the magic numbers from the rest of your code.</source>
          <target state="translated">を使って設定、クリア、テストを行います。このようにして、マジックナンバーを他のコードから隠すことができます。</target>
        </trans-unit>
        <trans-unit id="110686b5a36529717043f97083920f834fb221cc" translate="yes" xml:space="preserve">
          <source>value - Data</source>
          <target state="translated">値-データ</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
