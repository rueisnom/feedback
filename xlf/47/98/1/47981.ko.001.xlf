<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/47981">
    <body>
      <group id="47981">
        <trans-unit id="667b1c8089bc12eca14d4d550e23e87738e4ee0c" translate="yes" xml:space="preserve">
          <source>----[ TEST.C ]----------------------------------------------------------------</source>
          <target state="translated">---- [TEST.C] ----------------------------------------- -----------------------</target>
        </trans-unit>
        <trans-unit id="82622d08753d1de6f9f3382a0f1ea825f47b86c1" translate="yes" xml:space="preserve">
          <source>----[ TEST.OUT (disassembled) ]-----------------------------------------------</source>
          <target state="translated">---- [TEST.OUT (분해)] -------------------------------------- ---------</target>
        </trans-unit>
        <trans-unit id="28179a8129ad47c185aeefd2ab324dfd531a98ed" translate="yes" xml:space="preserve">
          <source>----[ finis ]-----------------------------------------------------------------</source>
          <target state="translated">---- [finis] ------------------------------------------- ----------------------</target>
        </trans-unit>
        <trans-unit id="6d19acaa2879cd1a9c40d2ce2d4d557352b4f059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(number &amp;amp; ~(1UL &amp;lt;&amp;lt; n))&lt;/code&gt; will clear the &lt;code&gt;n&lt;/code&gt;th bit and &lt;code&gt;(x &amp;lt;&amp;lt; n)&lt;/code&gt; will set the &lt;code&gt;n&lt;/code&gt;th bit to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(number &amp;amp; ~(1UL &amp;lt;&amp;lt; n))&lt;/code&gt; 은 &lt;code&gt;n&lt;/code&gt; 번째 비트를 지우고 &lt;code&gt;(x &amp;lt;&amp;lt; n)&lt;/code&gt; 은 &lt;code&gt;n&lt;/code&gt; 번째 비트를 &lt;code&gt;x&lt;/code&gt; 로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="88bab2da74a1a1522a542d4c0d7cf84f716233af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n = 4&lt;/code&gt; 0 based bit position to perform bitwise operations.</source>
          <target state="translated">비트 단위 연산을 수행하기위한 &lt;code&gt;n = 4&lt;/code&gt; 0 기반 비트 위치.</target>
        </trans-unit>
        <trans-unit id="7f9771c7e84c816a1c96a6550df0b6ef37bdaed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num = 55&lt;/code&gt; Integer to perform bitwise operations (set, get, clear, toggle).</source>
          <target state="translated">&lt;code&gt;num = 55&lt;/code&gt; 비트 단위 연산을 수행하는 정수입니다 (설정, 가져 오기, 지우기, 전환).</target>
        </trans-unit>
        <trans-unit id="848e31d285f7c9e89da0e7c2d41f36526f8b7106" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; may be too great for the shift &lt;code&gt;1 &amp;lt;&amp;lt; x&lt;/code&gt; leading to &lt;em&gt;undefined behavior&lt;/em&gt; (UB).  Even if &lt;code&gt;x&lt;/code&gt; is not too great, &lt;code&gt;~&lt;/code&gt; may not flip enough most-significant-bits.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 시프트 &lt;code&gt;1 &amp;lt;&amp;lt; x&lt;/code&gt; 대해 너무 커서 &lt;em&gt;정의되지 않은 동작&lt;/em&gt; (UB)을 초래할 수 있습니다. &lt;code&gt;x&lt;/code&gt; 가 너무 크지 않더라도 &lt;code&gt;~&lt;/code&gt; 는 가장 중요한 비트를 충분히 뒤집지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="382fd1a3e6786b545b23d712868c309637e86796" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; operator: set the bit</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 연산자 : 비트 설정</target>
        </trans-unit>
        <trans-unit id="0359414adb9597ed96d4e6d0bc16391e5df70a66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;1&lt;/code&gt; is not always wide enough&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;1&lt;/code&gt; 은 항상 충분히 넓지는 않습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7c79a8c50f27d048849355f137c942afdd1661f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clear a bit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;조금만 지우십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c543101c73c1a296c14039d59bf0a9635793189f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How it works?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어떻게 작동합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61554349ab10dd3c0bd562fee6415e569b069485" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let suppose few things first&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;먼저 몇 가지를 가정하자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7317348d5454e5ccfda6a26b4cd2b3fa9166fc7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;
This is designed to be fast (given its flexibility) and non-branchy.  It results in efficient SPARC machine code when compiled Sun Studio 8; I've also tested it using MSVC++ 2008 on amd64.  It's possible to make similar macros for setting and clearing bits.  The key difference of this solution compared with many others here is that it works for any location in pretty much any type of variable.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 빠르고 (유연성 제공) 비점 도성으로 설계되었습니다. Sun Studio 8을 컴파일 할 때 효율적인 SPARC 시스템 코드가 생성됩니다. 또한 amd64에서 MSVC ++ 2008을 사용하여 테스트했습니다. 비트를 설정하고 지우는 비슷한 매크로를 만들 수 있습니다. 이 솔루션과 다른 많은 솔루션의 주요 차이점은 거의 모든 유형의 변수에서 모든 위치에서 작동한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1cb021c737f247e65e724f7eb367810088853454" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sample usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;샘플 사용법 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85768827ef5f80c7e352f5fa2d539548b98c629d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Set a bit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;조금 설정하십시오 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42da513f420af644829d9bb366f65fa08d4eb836" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To insure 1 is wide enough:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1이 충분히 넓게하려면 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f9e296a49ce2bc809c273d109dc52cec704e934" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Toggle a bit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;조금 토글 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76484daaa9503e8ade8d19978cb56f30df1b0e1f" translate="yes" xml:space="preserve">
          <source>A C++11 templated version (put in a header):</source>
          <target state="translated">C ++ 11 템플릿 버전 (헤더에 넣음) :</target>
        </trans-unit>
        <trans-unit id="dd0efbc1af335ddf7596de68563a756f24d2af13" translate="yes" xml:space="preserve">
          <source>As this is tagged &quot;embedded&quot; I'll assume you're using a microcontroller. All of the above suggestions are valid &amp;amp; work (read-modify-write, unions, structs, etc.).</source>
          <target state="translated">&quot;embedded&quot;태그가 붙어 있으므로 마이크로 컨트롤러를 사용한다고 가정하겠습니다. 위의 모든 제안은 유효하며 작동합니다 (읽기-수정-쓰기, 공용체, 구조체 등).</target>
        </trans-unit>
        <trans-unit id="ca3f48378eac716e70a5d35da0190c3f867ecea1" translate="yes" xml:space="preserve">
          <source>As with most bit manipulations, best to work with &lt;em&gt;unsigned&lt;/em&gt; types rather than &lt;em&gt;signed&lt;/em&gt; ones</source>
          <target state="translated">대부분의 비트 조작과 마찬가지로 &lt;em&gt;부호있는&lt;/em&gt; 유형이 아닌 &lt;em&gt;부호없는&lt;/em&gt; 유형으로 작업하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c15f6ad62fcb1c5adbc33a14883c9aec53fb6629" translate="yes" xml:space="preserve">
          <source>Bit &lt;code&gt;n&lt;/code&gt; will be set if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, and cleared if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.  If &lt;code&gt;x&lt;/code&gt; has some other value, you get garbage.  &lt;code&gt;x = !!x&lt;/code&gt; will booleanize it to 0 or 1.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 이면 비트 &lt;code&gt;n&lt;/code&gt; 이 설정되고 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 이면 지워집니다. &lt;code&gt;x&lt;/code&gt; 에 다른 값이 있으면 쓰레기가 생깁니다. &lt;code&gt;x = !!x&lt;/code&gt; 는 0 또는 1로 부울 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c0dc3a25a7b2a779b187625efeb875cf8c20f29d" translate="yes" xml:space="preserve">
          <source>Changing the &lt;em&gt;n&lt;/em&gt;th bit to &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 번째 비트를 &lt;em&gt;x로&lt;/em&gt; 변경</target>
        </trans-unit>
        <trans-unit id="1270985c4d41de2a73fbc1aacfe693c2c765689c" translate="yes" xml:space="preserve">
          <source>Check a bit at an arbitrary location in a variable of arbitrary type:</source>
          <target state="translated">임의 유형의 변수에서 임의의 위치에서 비트를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0046e71f379a6dd39fb25966cd1653a420ea2c0c" translate="yes" xml:space="preserve">
          <source>Checking a bit</source>
          <target state="translated">조금 확인</target>
        </trans-unit>
        <trans-unit id="57acd198ff9087d7520a01146414b47b3a14b3f1" translate="yes" xml:space="preserve">
          <source>Checking a bit:</source>
          <target state="translated">조금 확인 :</target>
        </trans-unit>
        <trans-unit id="4a6dd3b47c599cf59a114edea596417b09ee3985" translate="yes" xml:space="preserve">
          <source>Clearing a bit</source>
          <target state="translated">조금 지우기</target>
        </trans-unit>
        <trans-unit id="6a8683eeffabe79feb1a889dc0f34644ae375aa3" translate="yes" xml:space="preserve">
          <source>Code could use &lt;code&gt;1ull&lt;/code&gt; or pedantically &lt;code&gt;(uintmax_t)1&lt;/code&gt; and let the compiler optimize.</source>
          <target state="translated">코드는 &lt;code&gt;1ull&lt;/code&gt; 또는 pedantically &lt;code&gt;(uintmax_t)1&lt;/code&gt; 을 사용하여 컴파일러를 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="a63c8c2a3c3b016fccf07ab1ac2d82cb938be8f1" translate="yes" xml:space="preserve">
          <source>Expanding on the &lt;code&gt;bitset&lt;/code&gt; answer:</source>
          <target state="translated">&lt;code&gt;bitset&lt;/code&gt; 답변 확장 :</target>
        </trans-unit>
        <trans-unit id="39eb92508ee5df2b84015b6338bf22397753fcda" translate="yes" xml:space="preserve">
          <source>Finally, perform bitwise AND &lt;code&gt;&amp;amp;&lt;/code&gt; operation with the above result and &lt;code&gt;num&lt;/code&gt;. The above three steps together can be written as &lt;code&gt;num &amp;amp; (~ (1 &amp;lt;&amp;lt; n))&lt;/code&gt;;</source>
          <target state="translated">마지막으로 위의 결과 및 &lt;code&gt;num&lt;/code&gt; 으로 비트 AND &lt;code&gt;&amp;amp;&lt;/code&gt; 연산을 수행하십시오. 위의 세 단계를 함께 &lt;code&gt;num &amp;amp; (~ (1 &amp;lt;&amp;lt; n))&lt;/code&gt; 으로 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb53377ab75dda9fb22160fbaab3a8c655b90ac" translate="yes" xml:space="preserve">
          <source>For the beginner I would like to explain a bit more with an example:</source>
          <target state="translated">초보자에게는 예를 들어 조금 더 설명하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="5901a13434d6c93a77c96dc821923c76bcdb001e" translate="yes" xml:space="preserve">
          <source>For those unfamiliar: In my example, the micro has a general pin-state register PORTn which reflects the output pins, so doing PORTn |= BIT_TO_SET results in a read-modify-write to that register. However, the PORTnSET / PORTnCLEAR registers take a '1' to mean &quot;please make this bit 1&quot; (SET) or &quot;please make this bit zero&quot; (CLEAR) and a '0' to mean &quot;leave the pin alone&quot;. so, you end up with two port addresses depending whether you're setting or clearing the bit (not always convenient) but a &lt;em&gt;much&lt;/em&gt; faster reaction and smaller assembled code.</source>
          <target state="translated">익숙하지 않은 사람들을 위해 : 나의 예에서, 마이크로는 출력 핀을 반영하는 일반적인 핀 상태 레지스터 PORTn을 가지고 있으므로, PORTn | = BIT_TO_SET을 수행하면 해당 레지스터에 대한 읽기-수정-쓰기가 발생합니다. 그러나 PORTnSET / PORTnCLEAR 레지스터는 &quot;1을 사용하여&quot;이 비트를 1로 설정하십시오 &quot;(SET) 또는&quot;이 비트를 0으로 설정하십시오 &quot;(CLEAR)를 의미하고&quot;0 &quot;은&quot;핀을 그대로 두십시오 &quot;를 의미합니다. 따라서 비트를 설정하거나 지우는 지 (항상 편리하지는 않지만) &lt;em&gt;훨씬&lt;/em&gt; 빠른 반응과 작은 조립 코드에 따라 두 개의 포트 주소가 생깁니다.</target>
        </trans-unit>
        <trans-unit id="6bf3ec6d6ad3785ab0fb41e4f4217bd944ff4d87" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://snippets.org/code/temp/snip-c.zip&quot;&gt;snip-c.zip&lt;/a&gt;'s bitops.h:</source>
          <target state="translated">&lt;a href=&quot;http://snippets.org/code/temp/snip-c.zip&quot;&gt;snip-c.zip&lt;/a&gt; 의 bitops.h에서 :</target>
        </trans-unit>
        <trans-unit id="2acb84d0306fd7eb7601bbea16014daa02abef8a" translate="yes" xml:space="preserve">
          <source>Here are some macros I use:</source>
          <target state="translated">내가 사용하는 매크로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b9390e3e32e0b8afea1e32f1f1feefc845945fe" translate="yes" xml:space="preserve">
          <source>Here's my favorite bit arithmetic macro, which works for any type of unsigned integer array from &lt;code&gt;unsigned char&lt;/code&gt; up to &lt;code&gt;size_t&lt;/code&gt; (which is the biggest type that should be efficient to work with):</source>
          <target state="translated">여기에 내가 좋아하는 비트 산술 매크로가 있습니다. 이는 &lt;code&gt;unsigned char&lt;/code&gt; 에서 &lt;code&gt;size_t&lt;/code&gt; 까지의 모든 유형의 부호없는 정수 배열에서 작동합니다 (작업하기에 가장 효율적인 유형).</target>
        </trans-unit>
        <trans-unit id="dab754019cefc4bba49daa09c429495b77c8d0c3" translate="yes" xml:space="preserve">
          <source>How do you set, clear, and toggle a bit?</source>
          <target state="translated">비트를 어떻게 설정하고 지우고 토글합니까?</target>
        </trans-unit>
        <trans-unit id="f9c977f6f7383a9196447d907de3d0bb28b2af49" translate="yes" xml:space="preserve">
          <source>How do you set, clear, and toggle a single bit</source>
          <target state="translated">단일 비트를 설정, 지우기 및 전환하는 방법</target>
        </trans-unit>
        <trans-unit id="a5ce3b216f3bac3897b9e763d3183b410d7f332d" translate="yes" xml:space="preserve">
          <source>How do you set, clear, and toggle a single bit?</source>
          <target state="translated">단일 비트를 어떻게 설정하고 지우고 토글합니까?</target>
        </trans-unit>
        <trans-unit id="99810e7c0f49901c9c73d5857a396a39cb6a6d07" translate="yes" xml:space="preserve">
          <source>How to clear a bit?</source>
          <target state="translated">비트를 지우는 방법?</target>
        </trans-unit>
        <trans-unit id="0ef616e8fabd6b1f05a5d3ef01a0cf8320d9920c" translate="yes" xml:space="preserve">
          <source>How to get a bit?</source>
          <target state="translated">조금 얻는 방법?</target>
        </trans-unit>
        <trans-unit id="676f6ee71c4069850ae2a5fa4f9c733b92d7f213" translate="yes" xml:space="preserve">
          <source>How to set a bit?</source>
          <target state="translated">비트를 설정하는 방법?</target>
        </trans-unit>
        <trans-unit id="7978c9b6c8953d08339eb06c78aa2fb897e8e58b" translate="yes" xml:space="preserve">
          <source>How to toggle a bit?</source>
          <target state="translated">비트를 토글하는 방법?</target>
        </trans-unit>
        <trans-unit id="a2fa6ff8c5a509f7affb45b5f46e1b50f9d21608" translate="yes" xml:space="preserve">
          <source>However, during a bout of oscilloscope-based debugging I was amazed to find that these methods have a considerable overhead in CPU cycles compared to writing a value directly to the micro's PORTnSET / PORTnCLEAR registers which makes a real difference where there are tight loops / high-frequency ISR's toggling pins.</source>
          <target state="translated">그러나 오실로스코프 기반 디버깅이 진행되는 동안 이러한 방법이 마이크로의 PORTnSET / PORTnCLEAR 레지스터에 직접 값을 쓰는 것과 비교할 때 CPU 사이클에서 상당한 오버 헤드가 있다는 사실에 놀랐습니다. 주파수 ISR의 토글 핀.</target>
        </trans-unit>
        <trans-unit id="f9ff9f9c33b6614a39d7e8d0f6b8c3c83b05a88f" translate="yes" xml:space="preserve">
          <source>I once used this approach to find duplicate loan records, where loan_number was the ISAM key, using the 6-digit loan number as an index into the bit array. Savagely fast, and after 8 months, proved that the mainframe system we were getting the data from was in fact malfunctioning. The simplicity of bit arrays makes confidence in their correctness very high - vs a searching approach for example.</source>
          <target state="translated">한 번은이 접근 방식을 사용하여 6 자리 대출 번호를 비트 배열의 인덱스로 사용하여 loan_number가 ISAM 키인 중복 대출 레코드를 찾았습니다. 엄청나게 빠르며 8 개월 후 데이터를 가져 오는 메인 프레임 시스템이 실제로 오작동하고 있음을 증명했습니다. 비트 배열의 단순성으로 인해 검색 접근 방식과 비교하여 정확성이 매우 높습니다.</target>
        </trans-unit>
        <trans-unit id="abb2634e4ade2a28866d25c8f2bdb63000cd6ff8" translate="yes" xml:space="preserve">
          <source>I use macros defined in a header file to handle bit set and clear:</source>
          <target state="translated">비트 파일을 처리하고 지우기 위해 헤더 파일에 정의 된 매크로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7c4ffb4ea2a2439cee5a2c80ae16bef112cee616" translate="yes" xml:space="preserve">
          <source>I used &lt;code&gt;XXXb&lt;/code&gt; for clarity.  You'll probably be working with HEX representation, depending on the data structure in which you're packing bits.</source>
          <target state="translated">명확성을 위해 &lt;code&gt;XXXb&lt;/code&gt; 를 사용 했습니다 . 비트를 패킹하는 데이터 구조에 따라 HEX 표현으로 작업하고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="53333655be5b4db7377f60710f9b0ca634975fe0" translate="yes" xml:space="preserve">
          <source>If posn==8, it will evaluate to:</source>
          <target state="translated">posn == 8이면 다음과 같이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ab57d68adecc6b6e118572053a3f69dd754eef04" translate="yes" xml:space="preserve">
          <source>If the bit to toggle is 0 then, &lt;code&gt;0 ^ 1 =&amp;gt; 1&lt;/code&gt;.</source>
          <target state="translated">토글 할 비트가 0이면 &lt;code&gt;0 ^ 1 =&amp;gt; 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="709903b975187f0c348b45214e90d052b9e93fa0" translate="yes" xml:space="preserve">
          <source>If the bit to toggle is 1 then, &lt;code&gt;1 ^ 1 =&amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">토글 할 비트가 1이면 &lt;code&gt;1 ^ 1 =&amp;gt; 0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5b6e652bc09f0ac15f015a6d4bb22acd19945ba" translate="yes" xml:space="preserve">
          <source>If you want to perform this all operation with C programming in the &lt;strong&gt;Linux kernel&lt;/strong&gt; then I suggest to use standard APIs of the Linux kernel.</source>
          <target state="translated">&lt;strong&gt;Linux 커널&lt;/strong&gt; 에서 C 프로그래밍 으로이 모든 작업을 수행하려면 &lt;strong&gt;Linux 커널의&lt;/strong&gt; 표준 API를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="61899a46cc7eb4e290f78ad5e2725eed57bd4439" translate="yes" xml:space="preserve">
          <source>If you're doing a lot of bit twiddling you might want to use masks which will make the whole thing quicker. The following functions are very fast and are still flexible (they allow bit twiddling in bit maps of any size).</source>
          <target state="translated">많은 비트를 돌리고 있다면 마스크를 사용하여 모든 것을 빠르게 할 수 있습니다. 다음 기능은 매우 빠르고 유연합니다 (모든 크기의 비트 맵에서 비트 트위들 링 허용).</target>
        </trans-unit>
        <trans-unit id="e075322fcf0586e896160b581843d5cafec9bee4" translate="yes" xml:space="preserve">
          <source>In other words, it simply creates a field of 0's with a 1 at the specified
position. The only tricky part is in the BitClr() macro where we need to set
a single 0 bit in a field of 1's. This is accomplished by using the 1's
complement of the same expression as denoted by the tilde (~) operator.</source>
          <target state="translated">즉, 단순히 지정된 위치에 1을 가진 0의 필드를 만듭니다. 까다로운 부분은 BitClr () 매크로에 있으며 1의 필드에서 단일 0 비트를 설정해야합니다. 이는 물결표 (~) 연산자로 표시된 것과 동일한 식의 1의 보수를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5aa47be261e161951f1f0bafd740a16b32aa8b1c" translate="yes" xml:space="preserve">
          <source>It is sometimes worth using an &lt;code&gt;enum&lt;/code&gt; to &lt;em&gt;name&lt;/em&gt; the bits:</source>
          <target state="translated">때때로 &lt;code&gt;enum&lt;/code&gt; 을 &lt;em&gt;사용&lt;/em&gt; 하여 비트 &lt;em&gt;이름을&lt;/em&gt; 지정할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b473b87effc8c47c29548c29028f4de82eafa38" translate="yes" xml:space="preserve">
          <source>It's also generally a good idea to not to copy/paste code in general and so many people use preprocessor macros (like &lt;a href=&quot;https://stackoverflow.com/a/263738/52074&quot;&gt;the community wiki answer further down&lt;/a&gt;) or some sort of encapsulation.</source>
          <target state="translated">일반적으로 코드를 복사 / 붙여 넣기하지 않는 것이 좋으며, 많은 사람들이 프리 프로세서 매크로 ( &lt;a href=&quot;https://stackoverflow.com/a/263738/52074&quot;&gt;커뮤니티 위키의 답변 아래로 내려 가기 등&lt;/a&gt; ) 나 캡슐화를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ed20494581b901298a0d7477a63131dc2432faf0" translate="yes" xml:space="preserve">
          <source>It's generally a good idea to use unsigned types for portable bit manipulation.</source>
          <target state="translated">휴대용 비트 조작에 부호없는 유형을 사용하는 것이 일반적으로 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f25048a05cb0bb71ed1211931fa89d7ef6b05ffc" translate="yes" xml:space="preserve">
          <source>It's up to you to ensure that the bit number is within the range of the bit map that you pass. Note that for little endian processors that bytes, words, dwords, qwords, etc., map correctly to each other in memory (main reason that little endian processors are 'better' than big-endian processors, ah, I feel a flame war coming on...).</source>
          <target state="translated">비트 번호가 전달한 비트 맵 범위 내에 있는지 확인하는 것은 사용자의 책임입니다. 바이트, 단어, dwords, qwords 등이 리틀 엔디안 프로세서의 경우 메모리에서 서로 올바르게 매핑됩니다 (작은 엔디안 프로세서가 빅 엔디안 프로세서보다 '더 나은'주된 이유입니다. 의 위에...).</target>
        </trans-unit>
        <trans-unit id="9127fb2258eb06efbfee1748ca9d04c76290852f" translate="yes" xml:space="preserve">
          <source>Left shift 1, &lt;code&gt;n&lt;/code&gt; times i.e. &lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;.</source>
          <target state="translated">왼쪽 시프트 1, &lt;code&gt;n&lt;/code&gt; 배, 즉 &lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73ef110f80c735334a2164f4ced66ec711a00839" translate="yes" xml:space="preserve">
          <source>More general, for arbitrary sized bitmaps:</source>
          <target state="translated">임의 크기의 비트 맵의 ​​경우 더 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="c85d279b39b892fb0988e34530a22460f26dde21" translate="yes" xml:space="preserve">
          <source>Note there is nothing &quot;special&quot; about this code. It treats a bit like an integer - which technically, it is. A 1 bit integer that can hold 2 values, and 2 values only.</source>
          <target state="translated">이 코드에 대해 &quot;특별한&quot;것은 없습니다. 그것은 약간 정수처럼 취급합니다-기술적으로는 그렇습니다. 2 개의 값과 2 개의 값만 보유 할 수있는 1 비트 정수</target>
        </trans-unit>
        <trans-unit id="43c1f0ee9dffa874878e37109448c03df6055fa1" translate="yes" xml:space="preserve">
          <source>Note, to set bit 'n' in a 16 bit integer you do the following:</source>
          <target state="translated">16 비트 정수로 비트 'n'을 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c222bbbaefaedb63d5ffc3a5327c69e30a7a8475" translate="yes" xml:space="preserve">
          <source>Note: Here the whole operation happens in a single step. So these all are  guaranteed to be &lt;strong&gt;atomic&lt;/strong&gt; even on SMP computers and are useful
to keep coherence across processors.</source>
          <target state="translated">참고 : 여기서 전체 작업은 단일 단계로 수행됩니다. 따라서이 모든 것이 SMP 컴퓨터에서도 &lt;strong&gt;원 자성&lt;/strong&gt; 으로 보장되며 프로세서간에 일관성을 유지하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5e87a0baab99790ee774b3f16e2f02538b65f612" translate="yes" xml:space="preserve">
          <source>OK, let's analyze things...</source>
          <target state="translated">좋아, 물건을 분석하자 ...</target>
        </trans-unit>
        <trans-unit id="c9dff73a77556f8f89fef17ebdd7a3587ab11da9" translate="yes" xml:space="preserve">
          <source>Once the mask is created it's applied to the argument just as you suggest,
by use of the bitwise and (&amp;amp;), or (|), and xor (^) operators. Since the mask
is of type long, the macros will work just as well on char's, short's, int's,
or long's.</source>
          <target state="translated">마스크가 만들어지면 비트 단위 및 (&amp;amp;) 또는 (|) 및 xor (^) 연산자를 사용하여 제안한대로 인수에 적용됩니다. 마스크는 long 유형이므로 매크로는 char, short, int 또는 long에서도 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="a72e2de1fad09c6b77cac7a842b1146a5d7550b7" translate="yes" xml:space="preserve">
          <source>Or cast - which makes for coding/review/maintenance issues keeping the cast correct and up-to-date.</source>
          <target state="translated">또는 캐스트-캐스트를 정확하고 최신 상태로 유지하는 코딩 / 검토 / 유지 보수 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f4d6bde5a9d5b3d020e725f997fcf3b65b6d6418" translate="yes" xml:space="preserve">
          <source>Or gently promote the &lt;code&gt;1&lt;/code&gt; by forcing a math operation that is as least as wide as the type of &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">또는 &lt;code&gt;number&lt;/code&gt; 유형만큼 폭이 넓은 수학 연산을 수행하여 &lt;code&gt;1&lt;/code&gt; 을 부드럽게 올립니다.</target>
        </trans-unit>
        <trans-unit id="125721cc78969f3a2d79b9b18521bcc882ed9fac" translate="yes" xml:space="preserve">
          <source>Or the &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; version: &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;&lt;code&gt;boost::dynamic_bitset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; 버전 : &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt; &lt;code&gt;boost::dynamic_bitset&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2e9f4a4d6cdb522a496493f27b424fb5d782fa3" translate="yes" xml:space="preserve">
          <source>Other than that I endorse Jeremy's solution.</source>
          <target state="translated">그 외에는 Jeremy의 솔루션을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="bc375646114e7205fd7164e5b46611889f795982" translate="yes" xml:space="preserve">
          <source>Perform bitwise complement with the above result. So that the nth bit becomes unset and rest of bit becomes set i.e. &lt;code&gt;~ (1 &amp;lt;&amp;lt; n)&lt;/code&gt;.</source>
          <target state="translated">위 결과로 비트 단위 보수를 수행하십시오. 따라서 n 번째 비트가 설정되지 않고 나머지 비트가 설정됩니다. 즉 &lt;code&gt;~ (1 &amp;lt;&amp;lt; n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53ecbc4d6e26d20b1988671948ec51f0ce92790a" translate="yes" xml:space="preserve">
          <source>Recommended reading - &lt;a href=&quot;https://codeforwin.org/2016/01/bitwise-operator-programming-exercises-and-solutions-in-c.html&quot;&gt;Bitwise operator exercises&lt;/a&gt;</source>
          <target state="translated">권장 자료- &lt;a href=&quot;https://codeforwin.org/2016/01/bitwise-operator-programming-exercises-and-solutions-in-c.html&quot;&gt;비트 단위 연산자 연습&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9994ff248f68711d40d581bcf6caee98f87d856" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html&quot;&gt;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html&quot;&gt;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html 참조&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61fa48f5afd4c97e0a87d8996b205d9f8d767a5a" translate="yes" xml:space="preserve">
          <source>Setting a bit</source>
          <target state="translated">비트 설정</target>
        </trans-unit>
        <trans-unit id="4dd48a6020a0c4db5765caa2eb0ab4c448f79743" translate="yes" xml:space="preserve">
          <source>Setting the &lt;code&gt;n&lt;/code&gt;th bit to either &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; can be achieved with the following on a 2's complement C++ implementation:</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 의 비트를 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; 으로 설정하는 것은 2의 보수 C ++ 구현에서 다음을 통해 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f820945537e9519e37cab115773e594cbfde9df" translate="yes" xml:space="preserve">
          <source>So, to your question, &lt;code&gt;IsGph[i] =1&lt;/code&gt;, or &lt;code&gt;IsGph[i] =0&lt;/code&gt; make setting and clearing bools easy.</source>
          <target state="translated">따라서 귀하의 질문에 따라 &lt;code&gt;IsGph[i] =1&lt;/code&gt; 또는 &lt;code&gt;IsGph[i] =0&lt;/code&gt; 은 부울 설정 및 지우기를 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c0d66a3a0b4acef20f48d55cb3db57fc9e015602" translate="yes" xml:space="preserve">
          <source>That will clear the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt;. You must invert the bit string with the bitwise NOT operator (&lt;code&gt;~&lt;/code&gt;), then AND it.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 의 &lt;code&gt;n&lt;/code&gt; 번째 비트가 지워 집니다. 비트 NOT 연산자 ( &lt;code&gt;~&lt;/code&gt; )로 비트 문자열을 반전시킨 다음 AND해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7f8ce9f568420f97192ac7365e1a1d1e57b8cb9" translate="yes" xml:space="preserve">
          <source>That will put the value of the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt; into the variable &lt;code&gt;bit&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;n&lt;/code&gt; 번째 비트 &lt;code&gt;number&lt;/code&gt; 의 값이 변수 &lt;code&gt;bit&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8e2b5c6a2b73e16c3c1c0419d83c252dff2bf6b9" translate="yes" xml:space="preserve">
          <source>That will set the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; should be zero, if you want to set the &lt;code&gt;1&lt;/code&gt;st bit and so on upto &lt;code&gt;n-1&lt;/code&gt;, if you want to set the &lt;code&gt;n&lt;/code&gt;th bit.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 의 &lt;code&gt;n&lt;/code&gt; 번째 비트가 설정됩니다. &lt;code&gt;n&lt;/code&gt; 번째 비트를 설정하려면 &lt;code&gt;n&lt;/code&gt; 번째 비트를 &lt;code&gt;n-1&lt;/code&gt; 까지 설정하려면 n 은 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e3792762dc53c61df78323ce8b14abd5d5c2d7fd" translate="yes" xml:space="preserve">
          <source>That will toggle the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 의 &lt;code&gt;n&lt;/code&gt; 번째 비트를 토글합니다.</target>
        </trans-unit>
        <trans-unit id="a6d75b05680564f82160755d4f06a5406f4c8d1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; operator is used check the bit:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 연산자는 비트를 확인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4720899f11a5ca9616a00586a34c7d0e1d6719c8" translate="yes" xml:space="preserve">
          <source>The Boost version allows a runtime sized bitset compared with a &lt;a href=&quot;https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library&quot;&gt;standard library&lt;/a&gt; compile-time sized bitset.</source>
          <target state="translated">Boost 버전은 &lt;a href=&quot;https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library&quot;&gt;표준 라이브러리&lt;/a&gt; 컴파일 타임 크기 비트 세트와 비교하여 런타임 크기 비트 세트를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="765d09f1c16860f29a69134a7f599e35e0b8267a" translate="yes" xml:space="preserve">
          <source>The XOR operator (&lt;code&gt;^&lt;/code&gt;) can be used to toggle a bit.</source>
          <target state="translated">XOR 연산자 ( &lt;code&gt;^&lt;/code&gt; )를 사용하여 비트를 토글 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cf704c5ff515de591788d3a37ab972dbffe1384" translate="yes" xml:space="preserve">
          <source>The bitfield approach has other advantages in the embedded arena. You can define a struct that maps directly onto the bits in a particular hardware register.</source>
          <target state="translated">비트 필드 방식은 임베디드 분야에서 다른 이점을 제공합니다. 특정 하드웨어 레지스터의 비트에 직접 매핑되는 구조체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="839a26b96b5f54ea008530fd6494a3e0722cd1da" translate="yes" xml:space="preserve">
          <source>The bottom line is that this is a general solution to an entire class of
problems. It is, of course, possible and even appropriate to rewrite the
equivalent of any of these macros with explicit mask values every time you
need one, but why do it? Remember, the macro substitution occurs in the
preprocessor and so the generated code will reflect the fact that the values
are considered constant by the compiler - i.e. it's just as efficient to use
the generalized macros as to &quot;reinvent the wheel&quot; every time you need to do
bit manipulation.</source>
          <target state="translated">결론은 이것이 모든 종류의 문제에 대한 일반적인 해결책이라는 것입니다. 물론 필요할 때마다 명시 적 마스크 값을 사용하여 이러한 매크로에 해당하는 내용을 다시 작성하는 것이 가능하고 적절합니다. 왜 그런가요? 매크로 대체는 전 처리기에서 발생하므로 생성 된 코드는 컴파일러가 값을 일정하게 간주한다는 사실을 반영합니다. 즉, 일반화 된 매크로를 사용하여 필요할 때마다 &quot;바퀴를 재창조&quot;하는 것만 큼 효율적입니다. 비트 조작을하십시오.</target>
        </trans-unit>
        <trans-unit id="22807ae60fb3a3ea091315d57264831db77c47c8" translate="yes" xml:space="preserve">
          <source>The common expression that you seem to be having problems with in all of these is &quot;(1L &amp;lt;&amp;lt; (posn))&quot;. All this does is create a mask with a single bit on
and which will work with any integer type. The &quot;posn&quot; argument specifies the
position where you want the bit. If posn==0, then this expression will
evaluate to:</source>
          <target state="translated">이들 모두에서 문제가있는 것으로 보이는 일반적인 표현은 &quot;(1L &amp;lt;&amp;lt; (posn))&quot;입니다. 이 모든 작업은 단일 비트를 사용하는 마스크를 만들고 모든 정수 유형에서 작동합니다. &quot;posn&quot;인수는 비트를 원하는 위치를 지정합니다. posn == 0이면이 표현식은 다음과 같이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="2cf1df7ab406c6d7796051b70b9c6b54ded8be0f" translate="yes" xml:space="preserve">
          <source>The other option is to use bit fields:</source>
          <target state="translated">다른 옵션은 비트 필드를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d5a256e0a435b0dd162d8da2c0e4951fd0c09a6" translate="yes" xml:space="preserve">
          <source>Then use the &lt;em&gt;names&lt;/em&gt; later on. I.e. write</source>
          <target state="translated">그런 다음 나중에 &lt;em&gt;이름을&lt;/em&gt; 사용하십시오. 즉 쓰기</target>
        </trans-unit>
        <trans-unit id="96f43706cb75f2ae9bded1dfc259d0010e530cea" translate="yes" xml:space="preserve">
          <source>There is no need to roll your own:</source>
          <target state="translated">자신의 것을 굴릴 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4908454acc4ef10e75093e07cef612a928ed415e" translate="yes" xml:space="preserve">
          <source>This only works with fixed-size bit fields. Otherwise you have to resort to the bit-twiddling techniques described in previous posts.</source>
          <target state="translated">이것은 고정 크기 비트 필드에서만 작동합니다. 그렇지 않으면 이전 게시물에서 설명한 비트 트위들 링 기술에 의존해야합니다.</target>
        </trans-unit>
        <trans-unit id="49ebcc18810c044e945316762b2409ebabeec5a3" translate="yes" xml:space="preserve">
          <source>This program is to change any data bit from 0 to 1 or 1 to 0:</source>
          <target state="translated">이 프로그램은 데이터 비트를 0에서 1 또는 1에서 0으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="94dea5b7b912974a57bf942f92f6fcbceb094ddb" translate="yes" xml:space="preserve">
          <source>To address a common coding pitfall when attempting to form the mask:</source>
          <target state="translated">마스크를 형성하려고 할 때 일반적인 코딩 함정을 해결하려면 :</target>
        </trans-unit>
        <trans-unit id="8bd00cd24171b73299a75c544c100d7ee8e8f976" translate="yes" xml:space="preserve">
          <source>To check a bit, shift the number n to the right, then bitwise AND it:</source>
          <target state="translated">비트를 확인하려면 숫자 n을 오른쪽으로 이동 한 다음 비트 AND로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f55448bd37502c20589b8abddd4ff82c93fb71ca" translate="yes" xml:space="preserve">
          <source>To check last bit in &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 에서 마지막 비트를 확인하려면</target>
        </trans-unit>
        <trans-unit id="b54a27b34b231f7dfbe4ac8c31019c52ca6554d2" translate="yes" xml:space="preserve">
          <source>To clear a bit:</source>
          <target state="translated">비트를 지우려면 :</target>
        </trans-unit>
        <trans-unit id="cd4df75a60322ba893bf854ca414bc756b509949" translate="yes" xml:space="preserve">
          <source>To clear last bit in &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 에서 마지막 비트를 지우려면 :</target>
        </trans-unit>
        <trans-unit id="83aa0df6b04e727ccad6ed04ce3e94028c5b988b" translate="yes" xml:space="preserve">
          <source>To find unprintable characters:</source>
          <target state="translated">인쇄 할 수없는 문자를 찾으려면</target>
        </trans-unit>
        <trans-unit id="43b735ba3d04a81e8870ac8a77c98b4f54990879" translate="yes" xml:space="preserve">
          <source>To get the &lt;code&gt;nth&lt;/code&gt; bit of num right shift &lt;code&gt;num&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; times. Then perform bitwise AND &lt;code&gt;&amp;amp;&lt;/code&gt; with 1.</source>
          <target state="translated">오른쪽 시프트 &lt;code&gt;num&lt;/code&gt; 의 &lt;code&gt;nth&lt;/code&gt; 비트를 &lt;code&gt;n&lt;/code&gt; 번 얻으려면 n 번. 그런 다음 1로 비트 AND &lt;code&gt;&amp;amp;&lt;/code&gt; 를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8980b85f79053d6948fc7141289370782531a289" translate="yes" xml:space="preserve">
          <source>To make this independent of 2's complement negation behaviour (where &lt;code&gt;-1&lt;/code&gt; has all bits set, unlike on a 1's complement or sign/magnitude C++ implementation), use unsigned negation.</source>
          <target state="translated">이것을 2의 보수 부정 행위와 독립적으로 만들려면 ( &lt;code&gt;-1&lt;/code&gt; 의 보수 또는 부호 / 크기 C ++ 구현과 달리 -1 에 모든 비트가 설정되어 있음) 부호없는 부정을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4eb50e3328856c70c1dca6c48069360040ef97f7" translate="yes" xml:space="preserve">
          <source>To set a bit, used &lt;code&gt;int x = x | 0x?;&lt;/code&gt; where &lt;code&gt;?&lt;/code&gt; is the bit position in binary form.</source>
          <target state="translated">비트를 설정하려면 &lt;code&gt;int x = x | 0x?;&lt;/code&gt; 0x ?; 어디 &lt;code&gt;?&lt;/code&gt; 이진 형식의 비트 위치입니다.</target>
        </trans-unit>
        <trans-unit id="6b53c97c6ee9a3d0d723e702f07943f5c9216677" translate="yes" xml:space="preserve">
          <source>To set a bit:</source>
          <target state="translated">비트를 설정하려면</target>
        </trans-unit>
        <trans-unit id="f9a2b2fb3a1c748d3527c65eef445ab67ab9dcde" translate="yes" xml:space="preserve">
          <source>To set a particular bit of number. Left shift 1 &lt;code&gt;n&lt;/code&gt; times. Then perform bitwise OR &lt;code&gt;|&lt;/code&gt; operation with &lt;code&gt;num&lt;/code&gt;.</source>
          <target state="translated">특정 숫자 비트를 설정합니다. 왼쪽으로 1 번씩 이동합니다. 그런 다음 비트 OR &lt;code&gt;|&lt;/code&gt; &lt;code&gt;num&lt;/code&gt; 을 사용한 연산.</target>
        </trans-unit>
        <trans-unit id="10ccea6e8ef43829ca947e5c40c7f06cea47b440" translate="yes" xml:space="preserve">
          <source>To set last bit in &lt;code&gt;000b&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;000b&lt;/code&gt; 에서 마지막 비트를 설정하려면</target>
        </trans-unit>
        <trans-unit id="e76ce493d90541c9b6b2be6f9c5d3d116427a803" translate="yes" xml:space="preserve">
          <source>To set or clear a bit:</source>
          <target state="translated">비트를 설정하거나 지우려면 :</target>
        </trans-unit>
        <trans-unit id="7abc415f2ccd44198e64e7a06b7544cdcf261192" translate="yes" xml:space="preserve">
          <source>To test a bit:</source>
          <target state="translated">비트를 테스트하려면</target>
        </trans-unit>
        <trans-unit id="ad468829fc4c0b8c79a1a6e04e882eb31a677d32" translate="yes" xml:space="preserve">
          <source>To toggle a bit we use bitwise XOR &lt;code&gt;^&lt;/code&gt; operator. Bitwise XOR operator evaluates to 1 if corresponding bit of both operands are different, otherwise evaluates to 0.</source>
          <target state="translated">비트를 토글하기 위해 비트 XOR &lt;code&gt;^&lt;/code&gt; 연산자를 사용합니다. 비트 XOR 연산자는 두 피연산자의 해당 비트가 다른 경우 1로 평가되고, 그렇지 않으면 0으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="30f8e6fd1f568c58652958a8cbd971492dd62a90" translate="yes" xml:space="preserve">
          <source>To toggle a bit:</source>
          <target state="translated">비트를 토글하려면 :</target>
        </trans-unit>
        <trans-unit id="0bd9784c0a74db4482ebf43f0a721806f5b58c6d" translate="yes" xml:space="preserve">
          <source>Toggle or Flip:</source>
          <target state="translated">토글 또는 뒤집기 :</target>
        </trans-unit>
        <trans-unit id="1b00b054a368563296b1a5a7e8e2be16e927b009" translate="yes" xml:space="preserve">
          <source>Toggling a bit</source>
          <target state="translated">조금 토글</target>
        </trans-unit>
        <trans-unit id="d8ff662b08e88c27fe251936b1a4dbf6ca9db7af" translate="yes" xml:space="preserve">
          <source>Try one of these functions in the C language to change n bit:</source>
          <target state="translated">C 언어에서 다음 함수 중 하나를 시도하여 n 비트를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e33fd3e89b9ceffcb431cb638d3fe473f841d813" translate="yes" xml:space="preserve">
          <source>Unconvinced? Here's some test code - I used Watcom C with full optimization
and without using _cdecl so the resulting disassembly would be as clean as
possible:</source>
          <target state="translated">확신이 없습니까? 테스트 코드는 다음과 같습니다. Watcom C를 완전히 최적화하고 _cdecl을 사용하지 않고 결과 분해가 가능한 한 깨끗해졌습니다.</target>
        </trans-unit>
        <trans-unit id="a133f4d724536d565a412a2bc18a60f9e028ff9a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;1ULL&lt;/code&gt; if &lt;code&gt;number&lt;/code&gt; is wider than &lt;code&gt;unsigned long&lt;/code&gt;; promotion of &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; doesn't happen until after evaluating &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; where it's undefined behaviour to shift by more than the width of a &lt;code&gt;long&lt;/code&gt;.  The same applies to all the rest of the examples.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 가 &lt;code&gt;unsigned long&lt;/code&gt; 보다 넓은 경우 &lt;code&gt;1ULL&lt;/code&gt; 을 사용하십시오. &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; 승격은 정의되지 않은 동작이 &lt;code&gt;long&lt;/code&gt; 너비 이상으로 이동하는 &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; 을 평가할 때까지 발생하지 않습니다. 나머지 모든 예제에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3116a9203958e2fb47b3c9b0568831002b7f60d6" translate="yes" xml:space="preserve">
          <source>Use one of the operators as defined &lt;a href=&quot;http://www.vantasyworld.com/articles/articles/36/article36_programming_bits.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.vantasyworld.com/articles/articles/36/article36_programming_bits.html&quot;&gt;여기에&lt;/a&gt; 정의 된 연산자 중 하나를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae11cffafff825583beb30d38a053dbcaf524806" translate="yes" xml:space="preserve">
          <source>Use the bitwise AND operator (&lt;code&gt;&amp;amp;&lt;/code&gt;) to clear a bit.</source>
          <target state="translated">비트 AND 연산자 ( &lt;code&gt;&amp;amp;&lt;/code&gt; )를 사용하여 비트를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="cfc0e11cd54b9e7a382a506d5c87343ec19762ac" translate="yes" xml:space="preserve">
          <source>Use the bitwise OR operator (&lt;code&gt;|&lt;/code&gt;) to set a bit.</source>
          <target state="translated">비트 OR 연산자 ( &lt;code&gt;|&lt;/code&gt; )를 사용하여 비트를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="384b3daf63a6e18211f6b86fb2b43ebe6b8a0dbe" translate="yes" xml:space="preserve">
          <source>Use the bitwise operators: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;</source>
          <target state="translated">비트 연산자를 사용하십시오. &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">이것을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="d680b05bc76ec8664f8f3ce8a41aeb3420399d4c" translate="yes" xml:space="preserve">
          <source>Using the Standard C++ Library: &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/bitset&quot;&gt;&lt;code&gt;std::bitset&amp;lt;N&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표준 C ++ 라이브러리 사용 : &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/bitset&quot;&gt; &lt;code&gt;std::bitset&amp;lt;N&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51b111bd60430d71673d27f3e1f35f2a3ef469ef" translate="yes" xml:space="preserve">
          <source>Variable used</source>
          <target state="translated">사용 된 변수</target>
        </trans-unit>
        <trans-unit id="759b6502d2072d601e3238211fe3053e9b2558a8" translate="yes" xml:space="preserve">
          <source>Visual C 2010, and perhaps many other compilers, have direct support for boolean operations built in. A bit has two possible values, just like a boolean, so we can use booleans instead - even if they take up more space than a single bit in memory in this representation. This works, even the &lt;code&gt;sizeof()&lt;/code&gt; operator works properly.</source>
          <target state="translated">Visual C 2010 및 다른 많은 컴파일러는 내장 된 부울 연산을 직접 지원합니다. 비트는 부울과 같이 두 가지 가능한 값을 가지므로 단일 비트보다 많은 공간을 차지하더라도 대신 부울을 사용할 수 있습니다. 이 표현에서 메모리. &lt;code&gt;sizeof()&lt;/code&gt; 연산자조차도 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f9cf49e77f03430ebd5f25bc522c153cf1178625" translate="yes" xml:space="preserve">
          <source>What problems happen when &lt;code&gt;number&lt;/code&gt; is a wider type than &lt;code&gt;1&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 가 1보다 넓은 유형일 때 어떤 문제가 발생합니까?</target>
        </trans-unit>
        <trans-unit id="e4b095a3c1e4e7de61d2386a5c1c85ccaef3c5bf" translate="yes" xml:space="preserve">
          <source>Which means to toggle a bit, we need to perform XOR operation with the bit you want to toggle and 1.</source>
          <target state="translated">즉, 비트를 토글하려면 토글하려는 비트와 1로 XOR 연산을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="13283e05a2e6100d0b5a95ed8d1a08dbfce494f8" translate="yes" xml:space="preserve">
          <source>You can then read, write, test the individual values as before.</source>
          <target state="translated">그런 다음 이전과 같이 개별 값을 읽고 쓰고 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9a82378920a8af59723a93e1aefb067f39fc80d" translate="yes" xml:space="preserve">
          <source>You didn't ask for this, but I might as well add it.</source>
          <target state="translated">당신은 이것을 요구하지 않았지만 나는 그것을 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="271ba18b7db73f6cb5c1287e8c31e53799100ded" translate="yes" xml:space="preserve">
          <source>You need to be aware of the bit packing order - I think it's MSB first, but this may be implementation-dependent. Also, verify how your compiler handlers fields crossing byte boundaries.</source>
          <target state="translated">비트 패킹 순서를 알고 있어야합니다. 먼저 MSB라고 생각하지만 구현에 따라 다를 수 있습니다. 또한 컴파일러가 바이트 경계를 넘어 필드를 처리하는 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c56a85cee06a9cbc75b6a43727c8741125980bfe" translate="yes" xml:space="preserve">
          <source>defines a 3-bit field (actually, it's three 1-bit felds). Bit operations now become a bit (haha) simpler:</source>
          <target state="translated">3 비트 필드를 정의합니다 (실제로 3 비트의 1 비트 필드). 비트 작업이 이제 조금 더 간단 해졌습니다 (haha).</target>
        </trans-unit>
        <trans-unit id="fb7f7c94028fe09a6d2d9b3bf0b8501eb7095619" translate="yes" xml:space="preserve">
          <source>etc.</source>
          <target state="translated">etc.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="0c4add5f2b8e203f7f9a3a5902a4b7fbe3c3367f" translate="yes" xml:space="preserve">
          <source>pos - position of the bit that we're interested to set, clear or toggle.</source>
          <target state="translated">pos-설정, 클리어 또는 토글하고자하는 비트의 위치.</target>
        </trans-unit>
        <trans-unit id="d183c0deb14cb48b70d54a4509f56c94c7466e99" translate="yes" xml:space="preserve">
          <source>to set, clear and test. This way you hide the magic numbers from the rest of your code.</source>
          <target state="translated">설정하고 지우고 테스트합니다. 이 방법으로 나머지 코드에서 마법의 숫자를 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="110686b5a36529717043f97083920f834fb221cc" translate="yes" xml:space="preserve">
          <source>value - Data</source>
          <target state="translated">가치-데이터</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
