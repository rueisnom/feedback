<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/47981">
    <body>
      <group id="47981">
        <trans-unit id="667b1c8089bc12eca14d4d550e23e87738e4ee0c" translate="yes" xml:space="preserve">
          <source>----[ TEST.C ]----------------------------------------------------------------</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82622d08753d1de6f9f3382a0f1ea825f47b86c1" translate="yes" xml:space="preserve">
          <source>----[ TEST.OUT (disassembled) ]-----------------------------------------------</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28179a8129ad47c185aeefd2ab324dfd531a98ed" translate="yes" xml:space="preserve">
          <source>----[ finis ]-----------------------------------------------------------------</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d19acaa2879cd1a9c40d2ce2d4d557352b4f059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(number &amp;amp; ~(1UL &amp;lt;&amp;lt; n))&lt;/code&gt; will clear the &lt;code&gt;n&lt;/code&gt;th bit and &lt;code&gt;(x &amp;lt;&amp;lt; n)&lt;/code&gt; will set the &lt;code&gt;n&lt;/code&gt;th bit to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(number &amp;amp; ~(1UL &amp;lt;&amp;lt; n))&lt;/code&gt; 将清除第 &lt;code&gt;n&lt;/code&gt; 位，而 &lt;code&gt;(x &amp;lt;&amp;lt; n)&lt;/code&gt; 将第 &lt;code&gt;n&lt;/code&gt; 位设置为 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88bab2da74a1a1522a542d4c0d7cf84f716233af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n = 4&lt;/code&gt; 0 based bit position to perform bitwise operations.</source>
          <target state="translated">基于 &lt;code&gt;n = 4&lt;/code&gt; 0的位位置以执行按位运算。</target>
        </trans-unit>
        <trans-unit id="7f9771c7e84c816a1c96a6550df0b6ef37bdaed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num = 55&lt;/code&gt; Integer to perform bitwise operations (set, get, clear, toggle).</source>
          <target state="translated">&lt;code&gt;num = 55&lt;/code&gt; 执行整数操作（设置，获取，清除，切换）的整数。</target>
        </trans-unit>
        <trans-unit id="848e31d285f7c9e89da0e7c2d41f36526f8b7106" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; may be too great for the shift &lt;code&gt;1 &amp;lt;&amp;lt; x&lt;/code&gt; leading to &lt;em&gt;undefined behavior&lt;/em&gt; (UB).  Even if &lt;code&gt;x&lt;/code&gt; is not too great, &lt;code&gt;~&lt;/code&gt; may not flip enough most-significant-bits.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 对于移位 &lt;code&gt;1 &amp;lt;&amp;lt; x&lt;/code&gt; x可能太大，导致&lt;em&gt;未定义行为&lt;/em&gt; （UB）。 即使 &lt;code&gt;x&lt;/code&gt; 不太大， &lt;code&gt;~&lt;/code&gt; 也可能不会翻转足够的最高有效位。</target>
        </trans-unit>
        <trans-unit id="382fd1a3e6786b545b23d712868c309637e86796" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; operator: set the bit</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 操作员：设置位</target>
        </trans-unit>
        <trans-unit id="0359414adb9597ed96d4e6d0bc16391e5df70a66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;1&lt;/code&gt; is not always wide enough&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;1&lt;/code&gt; 并不总是足够宽&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7c79a8c50f27d048849355f137c942afdd1661f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Clear a bit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;清除一点：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c543101c73c1a296c14039d59bf0a9635793189f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How it works?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这个怎么运作？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="61554349ab10dd3c0bd562fee6415e569b069485" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let suppose few things first&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;让我们先假设几件事&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7317348d5454e5ccfda6a26b4cd2b3fa9166fc7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;
This is designed to be fast (given its flexibility) and non-branchy.  It results in efficient SPARC machine code when compiled Sun Studio 8; I've also tested it using MSVC++ 2008 on amd64.  It's possible to make similar macros for setting and clearing bits.  The key difference of this solution compared with many others here is that it works for any location in pretty much any type of variable.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这样做是为了快速（赋予其灵活性）和不分枝。 编译Sun Studio 8时，可以产生有效的SPARC机器代码； 我还在amd64上使用MSVC ++ 2008测试了它。 可以制作相似的宏来设置和清除位。 与许多其他解决方案相比，此解决方案的主要区别在于，它几乎可以在任何类型的变量中的任何位置使用。</target>
        </trans-unit>
        <trans-unit id="1cb021c737f247e65e724f7eb367810088853454" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sample usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;用法示例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85768827ef5f80c7e352f5fa2d539548b98c629d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Set a bit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;设置一点：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42da513f420af644829d9bb366f65fa08d4eb836" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To insure 1 is wide enough:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;确保1足够宽：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f9e296a49ce2bc809c273d109dc52cec704e934" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Toggle a bit:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;切换一下：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76484daaa9503e8ade8d19978cb56f30df1b0e1f" translate="yes" xml:space="preserve">
          <source>A C++11 templated version (put in a header):</source>
          <target state="translated">一个C++11的模板化版本(放在头条里)。</target>
        </trans-unit>
        <trans-unit id="dd0efbc1af335ddf7596de68563a756f24d2af13" translate="yes" xml:space="preserve">
          <source>As this is tagged &quot;embedded&quot; I'll assume you're using a microcontroller. All of the above suggestions are valid &amp;amp; work (read-modify-write, unions, structs, etc.).</source>
          <target state="translated">因为这被标记为&amp;ldquo;嵌入式&amp;rdquo;，所以我假设您正在使用微控制器。 以上所有建议均有效且可行（读-修改-写，并集，结构等）。</target>
        </trans-unit>
        <trans-unit id="ca3f48378eac716e70a5d35da0190c3f867ecea1" translate="yes" xml:space="preserve">
          <source>As with most bit manipulations, best to work with &lt;em&gt;unsigned&lt;/em&gt; types rather than &lt;em&gt;signed&lt;/em&gt; ones</source>
          <target state="translated">与大多数位操作一样，最好使用&lt;em&gt;无符号&lt;/em&gt;类型而不是带&lt;em&gt;符号&lt;/em&gt;类型</target>
        </trans-unit>
        <trans-unit id="c15f6ad62fcb1c5adbc33a14883c9aec53fb6629" translate="yes" xml:space="preserve">
          <source>Bit &lt;code&gt;n&lt;/code&gt; will be set if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, and cleared if &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.  If &lt;code&gt;x&lt;/code&gt; has some other value, you get garbage.  &lt;code&gt;x = !!x&lt;/code&gt; will booleanize it to 0 or 1.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ，则将设置 &lt;code&gt;n&lt;/code&gt; 位；如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; ，则将其清除。 如果 &lt;code&gt;x&lt;/code&gt; 具有其他值，则会产生垃圾。 &lt;code&gt;x = !!x&lt;/code&gt; 会将其布尔值设为0或1。</target>
        </trans-unit>
        <trans-unit id="c0dc3a25a7b2a779b187625efeb875cf8c20f29d" translate="yes" xml:space="preserve">
          <source>Changing the &lt;em&gt;n&lt;/em&gt;th bit to &lt;em&gt;x&lt;/em&gt;</source>
          <target state="translated">将第&lt;em&gt;n&lt;/em&gt;位更改为&lt;em&gt;x&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1270985c4d41de2a73fbc1aacfe693c2c765689c" translate="yes" xml:space="preserve">
          <source>Check a bit at an arbitrary location in a variable of arbitrary type:</source>
          <target state="translated">在任意类型的变量中的任意位置检查一个位。</target>
        </trans-unit>
        <trans-unit id="0046e71f379a6dd39fb25966cd1653a420ea2c0c" translate="yes" xml:space="preserve">
          <source>Checking a bit</source>
          <target state="translated">检查一下</target>
        </trans-unit>
        <trans-unit id="57acd198ff9087d7520a01146414b47b3a14b3f1" translate="yes" xml:space="preserve">
          <source>Checking a bit:</source>
          <target state="translated">检查了一下。</target>
        </trans-unit>
        <trans-unit id="4a6dd3b47c599cf59a114edea596417b09ee3985" translate="yes" xml:space="preserve">
          <source>Clearing a bit</source>
          <target state="translated">清理一下</target>
        </trans-unit>
        <trans-unit id="6a8683eeffabe79feb1a889dc0f34644ae375aa3" translate="yes" xml:space="preserve">
          <source>Code could use &lt;code&gt;1ull&lt;/code&gt; or pedantically &lt;code&gt;(uintmax_t)1&lt;/code&gt; and let the compiler optimize.</source>
          <target state="translated">代码可以使用 &lt;code&gt;1ull&lt;/code&gt; 或pedantically &lt;code&gt;(uintmax_t)1&lt;/code&gt; ,并让编译器进行优化。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="a63c8c2a3c3b016fccf07ab1ac2d82cb938be8f1" translate="yes" xml:space="preserve">
          <source>Expanding on the &lt;code&gt;bitset&lt;/code&gt; answer:</source>
          <target state="translated">扩展 &lt;code&gt;bitset&lt;/code&gt; 答案：</target>
        </trans-unit>
        <trans-unit id="39eb92508ee5df2b84015b6338bf22397753fcda" translate="yes" xml:space="preserve">
          <source>Finally, perform bitwise AND &lt;code&gt;&amp;amp;&lt;/code&gt; operation with the above result and &lt;code&gt;num&lt;/code&gt;. The above three steps together can be written as &lt;code&gt;num &amp;amp; (~ (1 &amp;lt;&amp;lt; n))&lt;/code&gt;;</source>
          <target state="translated">最后，对上述结果和 &lt;code&gt;num&lt;/code&gt; 执行按位AND &lt;code&gt;&amp;amp;&lt;/code&gt; 运算。 以上三个步骤可以写成 &lt;code&gt;num &amp;amp; (~ (1 &amp;lt;&amp;lt; n))&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="acb53377ab75dda9fb22160fbaab3a8c655b90ac" translate="yes" xml:space="preserve">
          <source>For the beginner I would like to explain a bit more with an example:</source>
          <target state="translated">对于初学者,我想用一个例子来说明一下。</target>
        </trans-unit>
        <trans-unit id="5901a13434d6c93a77c96dc821923c76bcdb001e" translate="yes" xml:space="preserve">
          <source>For those unfamiliar: In my example, the micro has a general pin-state register PORTn which reflects the output pins, so doing PORTn |= BIT_TO_SET results in a read-modify-write to that register. However, the PORTnSET / PORTnCLEAR registers take a '1' to mean &quot;please make this bit 1&quot; (SET) or &quot;please make this bit zero&quot; (CLEAR) and a '0' to mean &quot;leave the pin alone&quot;. so, you end up with two port addresses depending whether you're setting or clearing the bit (not always convenient) but a &lt;em&gt;much&lt;/em&gt; faster reaction and smaller assembled code.</source>
          <target state="translated">对于那些不熟悉的人：在我的示例中，微控制器具有反映输出引脚的通用引脚状态寄存器PORTn，因此执行PORTn | = BIT_TO_SET会导致对该寄存器进行读-修改-写操作。 但是，PORTnSET / PORTnCLEAR寄存器为1表示&amp;ldquo;请将该位设为1&amp;rdquo;（SET）或&amp;ldquo;请将该位设为0&amp;rdquo;（CLEAR），为0则表示&amp;ldquo;将该引脚保留&amp;rdquo;。 因此，最终会得到两个端口地址，具体取决于您是在设置还是清除该位（并不总是很方便），但是响应速度更快且汇编代码更小。</target>
        </trans-unit>
        <trans-unit id="6bf3ec6d6ad3785ab0fb41e4f4217bd944ff4d87" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://snippets.org/code/temp/snip-c.zip&quot;&gt;snip-c.zip&lt;/a&gt;'s bitops.h:</source>
          <target state="translated">从&lt;a href=&quot;http://snippets.org/code/temp/snip-c.zip&quot;&gt;snip-c.zip&lt;/a&gt;的bitops.h：</target>
        </trans-unit>
        <trans-unit id="2acb84d0306fd7eb7601bbea16014daa02abef8a" translate="yes" xml:space="preserve">
          <source>Here are some macros I use:</source>
          <target state="translated">以下是我使用的一些宏。</target>
        </trans-unit>
        <trans-unit id="4b9390e3e32e0b8afea1e32f1f1feefc845945fe" translate="yes" xml:space="preserve">
          <source>Here's my favorite bit arithmetic macro, which works for any type of unsigned integer array from &lt;code&gt;unsigned char&lt;/code&gt; up to &lt;code&gt;size_t&lt;/code&gt; (which is the biggest type that should be efficient to work with):</source>
          <target state="translated">这是我最喜欢的位算术宏，它适用于 &lt;code&gt;size_t&lt;/code&gt; &lt;code&gt;unsigned char&lt;/code&gt; 到size_t （这是应该有效使用的最大类型）的任何类型的无符号整数数组：</target>
        </trans-unit>
        <trans-unit id="dab754019cefc4bba49daa09c429495b77c8d0c3" translate="yes" xml:space="preserve">
          <source>How do you set, clear, and toggle a bit?</source>
          <target state="translated">如何设定、清晰、清晰、拨动一下?</target>
        </trans-unit>
        <trans-unit id="f9c977f6f7383a9196447d907de3d0bb28b2af49" translate="yes" xml:space="preserve">
          <source>How do you set, clear, and toggle a single bit</source>
          <target state="translated">如何设置、清除和切换一个个位子</target>
        </trans-unit>
        <trans-unit id="a5ce3b216f3bac3897b9e763d3183b410d7f332d" translate="yes" xml:space="preserve">
          <source>How do you set, clear, and toggle a single bit?</source>
          <target state="translated">如何设定、清晰、清晰、切换一个个位子?</target>
        </trans-unit>
        <trans-unit id="99810e7c0f49901c9c73d5857a396a39cb6a6d07" translate="yes" xml:space="preserve">
          <source>How to clear a bit?</source>
          <target state="translated">如何清点?</target>
        </trans-unit>
        <trans-unit id="0ef616e8fabd6b1f05a5d3ef01a0cf8320d9920c" translate="yes" xml:space="preserve">
          <source>How to get a bit?</source>
          <target state="translated">如何获得位?</target>
        </trans-unit>
        <trans-unit id="676f6ee71c4069850ae2a5fa4f9c733b92d7f213" translate="yes" xml:space="preserve">
          <source>How to set a bit?</source>
          <target state="translated">如何设置一个位子?</target>
        </trans-unit>
        <trans-unit id="7978c9b6c8953d08339eb06c78aa2fb897e8e58b" translate="yes" xml:space="preserve">
          <source>How to toggle a bit?</source>
          <target state="translated">如何切换一下?</target>
        </trans-unit>
        <trans-unit id="a2fa6ff8c5a509f7affb45b5f46e1b50f9d21608" translate="yes" xml:space="preserve">
          <source>However, during a bout of oscilloscope-based debugging I was amazed to find that these methods have a considerable overhead in CPU cycles compared to writing a value directly to the micro's PORTnSET / PORTnCLEAR registers which makes a real difference where there are tight loops / high-frequency ISR's toggling pins.</source>
          <target state="translated">然而,在一次基于示波器的调试过程中,我惊奇地发现,与直接向微机的PORTnSET PORTnCLEAR寄存器写值相比,这些方法在CPU周期上有相当大的开销,这在有紧环高频ISR的拨动引脚的地方,就有了真正的区别。</target>
        </trans-unit>
        <trans-unit id="f9ff9f9c33b6614a39d7e8d0f6b8c3c83b05a88f" translate="yes" xml:space="preserve">
          <source>I once used this approach to find duplicate loan records, where loan_number was the ISAM key, using the 6-digit loan number as an index into the bit array. Savagely fast, and after 8 months, proved that the mainframe system we were getting the data from was in fact malfunctioning. The simplicity of bit arrays makes confidence in their correctness very high - vs a searching approach for example.</source>
          <target state="translated">我曾经用这种方法来查找重复的贷款记录,其中loan_number是ISAM键,用6位数组中的贷款号作为索引。速度非常快,8个月后,证明了我们从主机上获取数据的系统实际上出了问题。位数组的简单性使我们对其正确性有很高的信心--比起搜索方法来说。</target>
        </trans-unit>
        <trans-unit id="abb2634e4ade2a28866d25c8f2bdb63000cd6ff8" translate="yes" xml:space="preserve">
          <source>I use macros defined in a header file to handle bit set and clear:</source>
          <target state="translated">我使用头文件中定义的宏来处理位设置和清除。</target>
        </trans-unit>
        <trans-unit id="7c4ffb4ea2a2439cee5a2c80ae16bef112cee616" translate="yes" xml:space="preserve">
          <source>I used &lt;code&gt;XXXb&lt;/code&gt; for clarity.  You'll probably be working with HEX representation, depending on the data structure in which you're packing bits.</source>
          <target state="translated">为了清楚起见，我使用了 &lt;code&gt;XXXb&lt;/code&gt; 。 您可能将使用HEX表示形式，具体取决于要打包位的数据结构。</target>
        </trans-unit>
        <trans-unit id="53333655be5b4db7377f60710f9b0ca634975fe0" translate="yes" xml:space="preserve">
          <source>If posn==8, it will evaluate to:</source>
          <target state="translated">如果posn===8,它将评估为:</target>
        </trans-unit>
        <trans-unit id="ab57d68adecc6b6e118572053a3f69dd754eef04" translate="yes" xml:space="preserve">
          <source>If the bit to toggle is 0 then, &lt;code&gt;0 ^ 1 =&amp;gt; 1&lt;/code&gt;.</source>
          <target state="translated">如果要切换的位为0，则 &lt;code&gt;0 ^ 1 =&amp;gt; 1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="709903b975187f0c348b45214e90d052b9e93fa0" translate="yes" xml:space="preserve">
          <source>If the bit to toggle is 1 then, &lt;code&gt;1 ^ 1 =&amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">如果要切换的位为1，则 &lt;code&gt;1 ^ 1 =&amp;gt; 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5b6e652bc09f0ac15f015a6d4bb22acd19945ba" translate="yes" xml:space="preserve">
          <source>If you want to perform this all operation with C programming in the &lt;strong&gt;Linux kernel&lt;/strong&gt; then I suggest to use standard APIs of the Linux kernel.</source>
          <target state="translated">如果要在&lt;strong&gt;Linux内核中&lt;/strong&gt;使用C编程执行所有这些操作，则建议使用Linux内核的标准API。</target>
        </trans-unit>
        <trans-unit id="61899a46cc7eb4e290f78ad5e2725eed57bd4439" translate="yes" xml:space="preserve">
          <source>If you're doing a lot of bit twiddling you might want to use masks which will make the whole thing quicker. The following functions are very fast and are still flexible (they allow bit twiddling in bit maps of any size).</source>
          <target state="translated">如果你要做大量的位扭动,你可能会想使用蒙版,这将使整个过程更快。下面的功能非常快,而且还很灵活(它们允许在任何大小的位图中进行位扭动)。</target>
        </trans-unit>
        <trans-unit id="e075322fcf0586e896160b581843d5cafec9bee4" translate="yes" xml:space="preserve">
          <source>In other words, it simply creates a field of 0's with a 1 at the specified
position. The only tricky part is in the BitClr() macro where we need to set
a single 0 bit in a field of 1's. This is accomplished by using the 1's
complement of the same expression as denoted by the tilde (~) operator.</source>
          <target state="translated">换句话说,它只需在指定的位置创建一个0的字段,并在指定的位置设置1。唯一棘手的部分是在BitClr()宏中,我们需要在1的字段中设置一个0位。这可以通过使用相同表达式的1的补数来实现,正如斜线(~)运算符所表示的那样。</target>
        </trans-unit>
        <trans-unit id="5aa47be261e161951f1f0bafd740a16b32aa8b1c" translate="yes" xml:space="preserve">
          <source>It is sometimes worth using an &lt;code&gt;enum&lt;/code&gt; to &lt;em&gt;name&lt;/em&gt; the bits:</source>
          <target state="translated">有时值得使用 &lt;code&gt;enum&lt;/code&gt; 来&lt;em&gt;命名&lt;/em&gt;位：</target>
        </trans-unit>
        <trans-unit id="0b473b87effc8c47c29548c29028f4de82eafa38" translate="yes" xml:space="preserve">
          <source>It's also generally a good idea to not to copy/paste code in general and so many people use preprocessor macros (like &lt;a href=&quot;https://stackoverflow.com/a/263738/52074&quot;&gt;the community wiki answer further down&lt;/a&gt;) or some sort of encapsulation.</source>
          <target state="translated">通常也不要复制/粘贴代码，这也是一个好主意，因此许多人使用预处理器宏（例如&lt;a href=&quot;https://stackoverflow.com/a/263738/52074&quot;&gt;社区Wiki进一步回答&lt;/a&gt; ）或某种封装。</target>
        </trans-unit>
        <trans-unit id="ed20494581b901298a0d7477a63131dc2432faf0" translate="yes" xml:space="preserve">
          <source>It's generally a good idea to use unsigned types for portable bit manipulation.</source>
          <target state="translated">一般情况下,使用无符号类型进行便携位操作是个好主意。</target>
        </trans-unit>
        <trans-unit id="f25048a05cb0bb71ed1211931fa89d7ef6b05ffc" translate="yes" xml:space="preserve">
          <source>It's up to you to ensure that the bit number is within the range of the bit map that you pass. Note that for little endian processors that bytes, words, dwords, qwords, etc., map correctly to each other in memory (main reason that little endian processors are 'better' than big-endian processors, ah, I feel a flame war coming on...).</source>
          <target state="translated">这要看你是否在你所传递的位数映射范围内。需要注意的是,对于小endian处理器来说,字节、字、词、dwords、qwords等在内存中的映射是正确的(小endian处理器比大endian处理器 &quot;好 &quot;的主要原因,啊,我感觉到火焰战要来了)。</target>
        </trans-unit>
        <trans-unit id="9127fb2258eb06efbfee1748ca9d04c76290852f" translate="yes" xml:space="preserve">
          <source>Left shift 1, &lt;code&gt;n&lt;/code&gt; times i.e. &lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt;.</source>
          <target state="translated">左移1次， &lt;code&gt;n&lt;/code&gt; 次，即 &lt;code&gt;1 &amp;lt;&amp;lt; n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73ef110f80c735334a2164f4ced66ec711a00839" translate="yes" xml:space="preserve">
          <source>More general, for arbitrary sized bitmaps:</source>
          <target state="translated">更普遍的是,对于任意大小的位图。</target>
        </trans-unit>
        <trans-unit id="c85d279b39b892fb0988e34530a22460f26dde21" translate="yes" xml:space="preserve">
          <source>Note there is nothing &quot;special&quot; about this code. It treats a bit like an integer - which technically, it is. A 1 bit integer that can hold 2 values, and 2 values only.</source>
          <target state="translated">注意,这段代码没有什么 &quot;特殊 &quot;的地方。它的处理方式有点像整数--技术上来说,它就是这样。一个1位的整数,可以容纳2个值,而且只能容纳2个值。</target>
        </trans-unit>
        <trans-unit id="43c1f0ee9dffa874878e37109448c03df6055fa1" translate="yes" xml:space="preserve">
          <source>Note, to set bit 'n' in a 16 bit integer you do the following:</source>
          <target state="translated">注意,要在16位整数中设置位'n',你可以执行以下操作。</target>
        </trans-unit>
        <trans-unit id="c222bbbaefaedb63d5ffc3a5327c69e30a7a8475" translate="yes" xml:space="preserve">
          <source>Note: Here the whole operation happens in a single step. So these all are  guaranteed to be &lt;strong&gt;atomic&lt;/strong&gt; even on SMP computers and are useful
to keep coherence across processors.</source>
          <target state="translated">注意：此处整个操作只需一步即可完成。 因此，即使在SMP计算机上，也保证了所有这些&lt;strong&gt;原子性&lt;/strong&gt; ，并且对于保持处理器之间的一致性很有用。</target>
        </trans-unit>
        <trans-unit id="5e87a0baab99790ee774b3f16e2f02538b65f612" translate="yes" xml:space="preserve">
          <source>OK, let's analyze things...</source>
          <target state="translated">好,我们来分析一下.....</target>
        </trans-unit>
        <trans-unit id="c9dff73a77556f8f89fef17ebdd7a3587ab11da9" translate="yes" xml:space="preserve">
          <source>Once the mask is created it's applied to the argument just as you suggest,
by use of the bitwise and (&amp;amp;), or (|), and xor (^) operators. Since the mask
is of type long, the macros will work just as well on char's, short's, int's,
or long's.</source>
          <target state="translated">一旦创建了掩码，就可以使用按位运算符（＆）或（|）和xor（^）运算符，按照您的建议将其应用于自变量。 由于掩码的类型为long，因此宏在char，short，int或long上也可以使用。</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="a72e2de1fad09c6b77cac7a842b1146a5d7550b7" translate="yes" xml:space="preserve">
          <source>Or cast - which makes for coding/review/maintenance issues keeping the cast correct and up-to-date.</source>
          <target state="translated">or cast----这就使得codingreviewmaintenance的问题成为了保持codingreviewmaintenance的正确性和最新的问题。</target>
        </trans-unit>
        <trans-unit id="f4d6bde5a9d5b3d020e725f997fcf3b65b6d6418" translate="yes" xml:space="preserve">
          <source>Or gently promote the &lt;code&gt;1&lt;/code&gt; by forcing a math operation that is as least as wide as the type of &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">或通过强制进行至少与 &lt;code&gt;number&lt;/code&gt; 类型一样宽的数学运算来轻轻地升 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="125721cc78969f3a2d79b9b18521bcc882ed9fac" translate="yes" xml:space="preserve">
          <source>Or the &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt; version: &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;&lt;code&gt;boost::dynamic_bitset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">或&lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29&quot;&gt;Boost&lt;/a&gt;版本： &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt; &lt;code&gt;boost::dynamic_bitset&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2e9f4a4d6cdb522a496493f27b424fb5d782fa3" translate="yes" xml:space="preserve">
          <source>Other than that I endorse Jeremy's solution.</source>
          <target state="translated">除此之外,我赞同杰里米的解决方案。</target>
        </trans-unit>
        <trans-unit id="bc375646114e7205fd7164e5b46611889f795982" translate="yes" xml:space="preserve">
          <source>Perform bitwise complement with the above result. So that the nth bit becomes unset and rest of bit becomes set i.e. &lt;code&gt;~ (1 &amp;lt;&amp;lt; n)&lt;/code&gt;.</source>
          <target state="translated">用上述结果执行按位补码。 这样第n位变为未置位，其余位变为置位，即 &lt;code&gt;~ (1 &amp;lt;&amp;lt; n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53ecbc4d6e26d20b1988671948ec51f0ce92790a" translate="yes" xml:space="preserve">
          <source>Recommended reading - &lt;a href=&quot;https://codeforwin.org/2016/01/bitwise-operator-programming-exercises-and-solutions-in-c.html&quot;&gt;Bitwise operator exercises&lt;/a&gt;</source>
          <target state="translated">推荐阅读- &lt;a href=&quot;https://codeforwin.org/2016/01/bitwise-operator-programming-exercises-and-solutions-in-c.html&quot;&gt;按位操作员练习&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9994ff248f68711d40d581bcf6caee98f87d856" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html&quot;&gt;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html&lt;/a&gt;</source>
          <target state="translated">参见&lt;a href=&quot;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html&quot;&gt;https://www.kernel.org/doc/htmldocs/kernel-api/ch02s03.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61fa48f5afd4c97e0a87d8996b205d9f8d767a5a" translate="yes" xml:space="preserve">
          <source>Setting a bit</source>
          <target state="translated">设定一点</target>
        </trans-unit>
        <trans-unit id="4dd48a6020a0c4db5765caa2eb0ab4c448f79743" translate="yes" xml:space="preserve">
          <source>Setting the &lt;code&gt;n&lt;/code&gt;th bit to either &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; can be achieved with the following on a 2's complement C++ implementation:</source>
          <target state="translated">在2的补码C ++实现中，可以通过以下操作将第 &lt;code&gt;n&lt;/code&gt; 位设置为 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;0&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5f820945537e9519e37cab115773e594cbfde9df" translate="yes" xml:space="preserve">
          <source>So, to your question, &lt;code&gt;IsGph[i] =1&lt;/code&gt;, or &lt;code&gt;IsGph[i] =0&lt;/code&gt; make setting and clearing bools easy.</source>
          <target state="translated">因此，对于您的问题， &lt;code&gt;IsGph[i] =1&lt;/code&gt; 或 &lt;code&gt;IsGph[i] =0&lt;/code&gt; 使设置和清除布尔值变得容易。</target>
        </trans-unit>
        <trans-unit id="c0d66a3a0b4acef20f48d55cb3db57fc9e015602" translate="yes" xml:space="preserve">
          <source>That will clear the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt;. You must invert the bit string with the bitwise NOT operator (&lt;code&gt;~&lt;/code&gt;), then AND it.</source>
          <target state="translated">这将清除数字的第 &lt;code&gt;n&lt;/code&gt; 位。 您必须使用按位NOT运算符（ &lt;code&gt;~&lt;/code&gt; ）反转位字符串，然后将其取反。</target>
        </trans-unit>
        <trans-unit id="b7f8ce9f568420f97192ac7365e1a1d1e57b8cb9" translate="yes" xml:space="preserve">
          <source>That will put the value of the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt; into the variable &lt;code&gt;bit&lt;/code&gt;.</source>
          <target state="translated">这将把数字的第 &lt;code&gt;n&lt;/code&gt; 位的 &lt;code&gt;number&lt;/code&gt; 放入可变 &lt;code&gt;bit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e2b5c6a2b73e16c3c1c0419d83c252dff2bf6b9" translate="yes" xml:space="preserve">
          <source>That will set the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; should be zero, if you want to set the &lt;code&gt;1&lt;/code&gt;st bit and so on upto &lt;code&gt;n-1&lt;/code&gt;, if you want to set the &lt;code&gt;n&lt;/code&gt;th bit.</source>
          <target state="translated">那将设置 &lt;code&gt;number&lt;/code&gt; 的第 &lt;code&gt;n&lt;/code&gt; 位。 如果要设置第 &lt;code&gt;1&lt;/code&gt; 位，则 &lt;code&gt;n&lt;/code&gt; 应为零；如果要设置第 &lt;code&gt;n-1&lt;/code&gt; 位，则n应为n-1 。</target>
        </trans-unit>
        <trans-unit id="e3792762dc53c61df78323ce8b14abd5d5c2d7fd" translate="yes" xml:space="preserve">
          <source>That will toggle the &lt;code&gt;n&lt;/code&gt;th bit of &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">那将切换数字的第 &lt;code&gt;n&lt;/code&gt; 位。</target>
        </trans-unit>
        <trans-unit id="a6d75b05680564f82160755d4f06a5406f4c8d1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; operator is used check the bit:</source>
          <target state="translated">使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算符检查该位：</target>
        </trans-unit>
        <trans-unit id="4720899f11a5ca9616a00586a34c7d0e1d6719c8" translate="yes" xml:space="preserve">
          <source>The Boost version allows a runtime sized bitset compared with a &lt;a href=&quot;https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library&quot;&gt;standard library&lt;/a&gt; compile-time sized bitset.</source>
          <target state="translated">与&lt;a href=&quot;https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library&quot;&gt;标准库&lt;/a&gt;编译时大小的位组相比，Boost版本允许运行时大小的位组。</target>
        </trans-unit>
        <trans-unit id="765d09f1c16860f29a69134a7f599e35e0b8267a" translate="yes" xml:space="preserve">
          <source>The XOR operator (&lt;code&gt;^&lt;/code&gt;) can be used to toggle a bit.</source>
          <target state="translated">XOR运算符（ &lt;code&gt;^&lt;/code&gt; ）可用于切换一位。</target>
        </trans-unit>
        <trans-unit id="4cf704c5ff515de591788d3a37ab972dbffe1384" translate="yes" xml:space="preserve">
          <source>The bitfield approach has other advantages in the embedded arena. You can define a struct that maps directly onto the bits in a particular hardware register.</source>
          <target state="translated">在嵌入式领域,位场方法还有其他优势。你可以定义一个结构,直接映射到特定硬件寄存器中的位上。</target>
        </trans-unit>
        <trans-unit id="839a26b96b5f54ea008530fd6494a3e0722cd1da" translate="yes" xml:space="preserve">
          <source>The bottom line is that this is a general solution to an entire class of
problems. It is, of course, possible and even appropriate to rewrite the
equivalent of any of these macros with explicit mask values every time you
need one, but why do it? Remember, the macro substitution occurs in the
preprocessor and so the generated code will reflect the fact that the values
are considered constant by the compiler - i.e. it's just as efficient to use
the generalized macros as to &quot;reinvent the wheel&quot; every time you need to do
bit manipulation.</source>
          <target state="translated">底线是,这是对一整类问题的一般解决方案。当然,每次需要的时候,重写这些宏的等效值是可能的,甚至是合适的,但为什么要这样做呢?请记住,宏替换是在预处理程序中发生的,因此生成的代码将反映出编译器认为值是常数的事实--也就是说,每次需要进行位操作的时候,使用泛化的宏和每次需要 &quot;重塑轮子 &quot;一样有效。</target>
        </trans-unit>
        <trans-unit id="22807ae60fb3a3ea091315d57264831db77c47c8" translate="yes" xml:space="preserve">
          <source>The common expression that you seem to be having problems with in all of these is &quot;(1L &amp;lt;&amp;lt; (posn))&quot;. All this does is create a mask with a single bit on
and which will work with any integer type. The &quot;posn&quot; argument specifies the
position where you want the bit. If posn==0, then this expression will
evaluate to:</source>
          <target state="translated">您似乎在所有这些方面都遇到问题的常见表达方式是&amp;ldquo;（1L &amp;lt;&amp;lt;（posn））&amp;rdquo;。 所有这些操作就是创建一个具有单个位的掩码，该掩码将适用于任何整数类型。 &amp;ldquo; posn&amp;rdquo;参数指定您想要该位的位置。 如果posn == 0，则此表达式的计算结果为：</target>
        </trans-unit>
        <trans-unit id="2cf1df7ab406c6d7796051b70b9c6b54ded8be0f" translate="yes" xml:space="preserve">
          <source>The other option is to use bit fields:</source>
          <target state="translated">另一种选择是使用位字段。</target>
        </trans-unit>
        <trans-unit id="6d5a256e0a435b0dd162d8da2c0e4951fd0c09a6" translate="yes" xml:space="preserve">
          <source>Then use the &lt;em&gt;names&lt;/em&gt; later on. I.e. write</source>
          <target state="translated">然后使用这些&lt;em&gt;名称&lt;/em&gt; 。 即写</target>
        </trans-unit>
        <trans-unit id="96f43706cb75f2ae9bded1dfc259d0010e530cea" translate="yes" xml:space="preserve">
          <source>There is no need to roll your own:</source>
          <target state="translated">没必要自己滚。</target>
        </trans-unit>
        <trans-unit id="4908454acc4ef10e75093e07cef612a928ed415e" translate="yes" xml:space="preserve">
          <source>This only works with fixed-size bit fields. Otherwise you have to resort to the bit-twiddling techniques described in previous posts.</source>
          <target state="translated">这只适用于固定大小的位域。否则,你必须使用之前的帖子中描述的位调换技术。</target>
        </trans-unit>
        <trans-unit id="49ebcc18810c044e945316762b2409ebabeec5a3" translate="yes" xml:space="preserve">
          <source>This program is to change any data bit from 0 to 1 or 1 to 0:</source>
          <target state="translated">该程序是将任意数据位从0变为1或1变为0。</target>
        </trans-unit>
        <trans-unit id="94dea5b7b912974a57bf942f92f6fcbceb094ddb" translate="yes" xml:space="preserve">
          <source>To address a common coding pitfall when attempting to form the mask:</source>
          <target state="translated">为了解决在试图形成掩码时常见的编码陷阱。</target>
        </trans-unit>
        <trans-unit id="8bd00cd24171b73299a75c544c100d7ee8e8f976" translate="yes" xml:space="preserve">
          <source>To check a bit, shift the number n to the right, then bitwise AND it:</source>
          <target state="translated">要检查一个位,请将数字n向右移位,然后用位和它。</target>
        </trans-unit>
        <trans-unit id="f55448bd37502c20589b8abddd4ff82c93fb71ca" translate="yes" xml:space="preserve">
          <source>To check last bit in &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">要检查 &lt;code&gt;foo&lt;/code&gt; 的最后一位：</target>
        </trans-unit>
        <trans-unit id="b54a27b34b231f7dfbe4ac8c31019c52ca6554d2" translate="yes" xml:space="preserve">
          <source>To clear a bit:</source>
          <target state="translated">要清除一点。</target>
        </trans-unit>
        <trans-unit id="cd4df75a60322ba893bf854ca414bc756b509949" translate="yes" xml:space="preserve">
          <source>To clear last bit in &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">要清除 &lt;code&gt;foo&lt;/code&gt; 中的最后一位：</target>
        </trans-unit>
        <trans-unit id="83aa0df6b04e727ccad6ed04ce3e94028c5b988b" translate="yes" xml:space="preserve">
          <source>To find unprintable characters:</source>
          <target state="translated">要找到无法打印的字符。</target>
        </trans-unit>
        <trans-unit id="43b735ba3d04a81e8870ac8a77c98b4f54990879" translate="yes" xml:space="preserve">
          <source>To get the &lt;code&gt;nth&lt;/code&gt; bit of num right shift &lt;code&gt;num&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; times. Then perform bitwise AND &lt;code&gt;&amp;amp;&lt;/code&gt; with 1.</source>
          <target state="translated">要获得num的 &lt;code&gt;nth&lt;/code&gt; 位，将num右移 &lt;code&gt;n&lt;/code&gt; 次。 然后用1执行按位AND &lt;code&gt;&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8980b85f79053d6948fc7141289370782531a289" translate="yes" xml:space="preserve">
          <source>To make this independent of 2's complement negation behaviour (where &lt;code&gt;-1&lt;/code&gt; has all bits set, unlike on a 1's complement or sign/magnitude C++ implementation), use unsigned negation.</source>
          <target state="translated">为了使它独立于2的补码取反行为（其中 &lt;code&gt;-1&lt;/code&gt; 设置了所有位，与1的补码或符号/幅度C ++实现不同），请使用无符号取反。</target>
        </trans-unit>
        <trans-unit id="4eb50e3328856c70c1dca6c48069360040ef97f7" translate="yes" xml:space="preserve">
          <source>To set a bit, used &lt;code&gt;int x = x | 0x?;&lt;/code&gt; where &lt;code&gt;?&lt;/code&gt; is the bit position in binary form.</source>
          <target state="translated">要设置一点，请使用 &lt;code&gt;int x = x | 0x?;&lt;/code&gt; 0x ?; 在 &lt;code&gt;?&lt;/code&gt; 是二进制形式的位位置。</target>
        </trans-unit>
        <trans-unit id="6b53c97c6ee9a3d0d723e702f07943f5c9216677" translate="yes" xml:space="preserve">
          <source>To set a bit:</source>
          <target state="translated">要设定一下。</target>
        </trans-unit>
        <trans-unit id="f9a2b2fb3a1c748d3527c65eef445ab67ab9dcde" translate="yes" xml:space="preserve">
          <source>To set a particular bit of number. Left shift 1 &lt;code&gt;n&lt;/code&gt; times. Then perform bitwise OR &lt;code&gt;|&lt;/code&gt; operation with &lt;code&gt;num&lt;/code&gt;.</source>
          <target state="translated">设置数字的特定位。 左移1 &lt;code&gt;n&lt;/code&gt; 次。 然后执行按位OR &lt;code&gt;|&lt;/code&gt; 用 &lt;code&gt;num&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="10ccea6e8ef43829ca947e5c40c7f06cea47b440" translate="yes" xml:space="preserve">
          <source>To set last bit in &lt;code&gt;000b&lt;/code&gt;:</source>
          <target state="translated">设置 &lt;code&gt;000b&lt;/code&gt; 的最后一位：</target>
        </trans-unit>
        <trans-unit id="e76ce493d90541c9b6b2be6f9c5d3d116427a803" translate="yes" xml:space="preserve">
          <source>To set or clear a bit:</source>
          <target state="translated">要设置或清除一点。</target>
        </trans-unit>
        <trans-unit id="7abc415f2ccd44198e64e7a06b7544cdcf261192" translate="yes" xml:space="preserve">
          <source>To test a bit:</source>
          <target state="translated">为了测试一下。</target>
        </trans-unit>
        <trans-unit id="ad468829fc4c0b8c79a1a6e04e882eb31a677d32" translate="yes" xml:space="preserve">
          <source>To toggle a bit we use bitwise XOR &lt;code&gt;^&lt;/code&gt; operator. Bitwise XOR operator evaluates to 1 if corresponding bit of both operands are different, otherwise evaluates to 0.</source>
          <target state="translated">为了切换一点，我们使用按位XOR &lt;code&gt;^&lt;/code&gt; 运算符。 如果两个操作数的对应位不同，则按位XOR运算符的计算结果为1，否则为0。</target>
        </trans-unit>
        <trans-unit id="30f8e6fd1f568c58652958a8cbd971492dd62a90" translate="yes" xml:space="preserve">
          <source>To toggle a bit:</source>
          <target state="translated">要切换一下。</target>
        </trans-unit>
        <trans-unit id="0bd9784c0a74db4482ebf43f0a721806f5b58c6d" translate="yes" xml:space="preserve">
          <source>Toggle or Flip:</source>
          <target state="translated">拨动或翻转。</target>
        </trans-unit>
        <trans-unit id="1b00b054a368563296b1a5a7e8e2be16e927b009" translate="yes" xml:space="preserve">
          <source>Toggling a bit</source>
          <target state="translated">切换一下</target>
        </trans-unit>
        <trans-unit id="d8ff662b08e88c27fe251936b1a4dbf6ca9db7af" translate="yes" xml:space="preserve">
          <source>Try one of these functions in the C language to change n bit:</source>
          <target state="translated">试着用C语言中的这些函数之一来改变n位。</target>
        </trans-unit>
        <trans-unit id="e33fd3e89b9ceffcb431cb638d3fe473f841d813" translate="yes" xml:space="preserve">
          <source>Unconvinced? Here's some test code - I used Watcom C with full optimization
and without using _cdecl so the resulting disassembly would be as clean as
possible:</source>
          <target state="translated">不信?下面是一些测试代码-我使用了Watcom C,进行了充分的优化,没有使用_cdecl,所以最后的反汇编会尽可能的干净。</target>
        </trans-unit>
        <trans-unit id="a133f4d724536d565a412a2bc18a60f9e028ff9a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;1ULL&lt;/code&gt; if &lt;code&gt;number&lt;/code&gt; is wider than &lt;code&gt;unsigned long&lt;/code&gt;; promotion of &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; doesn't happen until after evaluating &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; where it's undefined behaviour to shift by more than the width of a &lt;code&gt;long&lt;/code&gt;.  The same applies to all the rest of the examples.</source>
          <target state="translated">如果 &lt;code&gt;number&lt;/code&gt; 大于 &lt;code&gt;unsigned long&lt;/code&gt; 则使用 &lt;code&gt;1ULL&lt;/code&gt; ; 直到对 &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; 进行评估之后，才发生 &lt;code&gt;1UL &amp;lt;&amp;lt; n&lt;/code&gt; 提升，在这种情况下，未定义的行为要移动超过 &lt;code&gt;long&lt;/code&gt; 的宽度。 其他所有示例也是如此。</target>
        </trans-unit>
        <trans-unit id="3116a9203958e2fb47b3c9b0568831002b7f60d6" translate="yes" xml:space="preserve">
          <source>Use one of the operators as defined &lt;a href=&quot;http://www.vantasyworld.com/articles/articles/36/article36_programming_bits.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;http://www.vantasyworld.com/articles/articles/36/article36_programming_bits.html&quot;&gt;此处&lt;/a&gt;定义的运算符之一。</target>
        </trans-unit>
        <trans-unit id="ae11cffafff825583beb30d38a053dbcaf524806" translate="yes" xml:space="preserve">
          <source>Use the bitwise AND operator (&lt;code&gt;&amp;amp;&lt;/code&gt;) to clear a bit.</source>
          <target state="translated">使用按位AND运算符（ &lt;code&gt;&amp;amp;&lt;/code&gt; ）清除一位。</target>
        </trans-unit>
        <trans-unit id="cfc0e11cd54b9e7a382a506d5c87343ec19762ac" translate="yes" xml:space="preserve">
          <source>Use the bitwise OR operator (&lt;code&gt;|&lt;/code&gt;) to set a bit.</source>
          <target state="translated">使用按位或运算符（ &lt;code&gt;|&lt;/code&gt; ）进行设置。</target>
        </trans-unit>
        <trans-unit id="384b3daf63a6e18211f6b86fb2b43ebe6b8a0dbe" translate="yes" xml:space="preserve">
          <source>Use the bitwise operators: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;</source>
          <target state="translated">使用按位运算符： &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">用这个。</target>
        </trans-unit>
        <trans-unit id="d680b05bc76ec8664f8f3ce8a41aeb3420399d4c" translate="yes" xml:space="preserve">
          <source>Using the Standard C++ Library: &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/bitset&quot;&gt;&lt;code&gt;std::bitset&amp;lt;N&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用标准C ++库： &lt;a href=&quot;http://en.cppreference.com/w/cpp/utility/bitset&quot;&gt; &lt;code&gt;std::bitset&amp;lt;N&amp;gt;&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="51b111bd60430d71673d27f3e1f35f2a3ef469ef" translate="yes" xml:space="preserve">
          <source>Variable used</source>
          <target state="translated">使用的变量</target>
        </trans-unit>
        <trans-unit id="759b6502d2072d601e3238211fe3053e9b2558a8" translate="yes" xml:space="preserve">
          <source>Visual C 2010, and perhaps many other compilers, have direct support for boolean operations built in. A bit has two possible values, just like a boolean, so we can use booleans instead - even if they take up more space than a single bit in memory in this representation. This works, even the &lt;code&gt;sizeof()&lt;/code&gt; operator works properly.</source>
          <target state="translated">Visual C 2010，也许还有许多其他编译器，都直接支持内置的布尔操作。一个位具有两个可能的值，就像布尔值一样，因此我们可以改用布尔值-即使它们占用的空间大于单个位。以这种形式记忆。 这可以正常工作，即使 &lt;code&gt;sizeof()&lt;/code&gt; 运算符也可以正常工作。</target>
        </trans-unit>
        <trans-unit id="f9cf49e77f03430ebd5f25bc522c153cf1178625" translate="yes" xml:space="preserve">
          <source>What problems happen when &lt;code&gt;number&lt;/code&gt; is a wider type than &lt;code&gt;1&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 大于 &lt;code&gt;1&lt;/code&gt; 时会发生什么问题？</target>
        </trans-unit>
        <trans-unit id="e4b095a3c1e4e7de61d2386a5c1c85ccaef3c5bf" translate="yes" xml:space="preserve">
          <source>Which means to toggle a bit, we need to perform XOR operation with the bit you want to toggle and 1.</source>
          <target state="translated">这意味着要切换位,我们需要用你要切换的位和1进行XOR操作。</target>
        </trans-unit>
        <trans-unit id="13283e05a2e6100d0b5a95ed8d1a08dbfce494f8" translate="yes" xml:space="preserve">
          <source>You can then read, write, test the individual values as before.</source>
          <target state="translated">然后,你可以像以前一样读取、写入、测试各个值。</target>
        </trans-unit>
        <trans-unit id="a9a82378920a8af59723a93e1aefb067f39fc80d" translate="yes" xml:space="preserve">
          <source>You didn't ask for this, but I might as well add it.</source>
          <target state="translated">这不是你要求的,但我不妨补充一下。</target>
        </trans-unit>
        <trans-unit id="271ba18b7db73f6cb5c1287e8c31e53799100ded" translate="yes" xml:space="preserve">
          <source>You need to be aware of the bit packing order - I think it's MSB first, but this may be implementation-dependent. Also, verify how your compiler handlers fields crossing byte boundaries.</source>
          <target state="translated">你需要注意位打包顺序--我认为是MSB优先,但这可能与实现有关。另外,验证你的编译器处理程序字段是如何跨越字节边界的。</target>
        </trans-unit>
        <trans-unit id="c56a85cee06a9cbc75b6a43727c8741125980bfe" translate="yes" xml:space="preserve">
          <source>defines a 3-bit field (actually, it's three 1-bit felds). Bit operations now become a bit (haha) simpler:</source>
          <target state="translated">定义了一个3位字段(实际上是三个1位的felds)。位操作现在变得简单了一点(哈哈)。</target>
        </trans-unit>
        <trans-unit id="fb7f7c94028fe09a6d2d9b3bf0b8501eb7095619" translate="yes" xml:space="preserve">
          <source>etc.</source>
          <target state="translated">etc.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="0c4add5f2b8e203f7f9a3a5902a4b7fbe3c3367f" translate="yes" xml:space="preserve">
          <source>pos - position of the bit that we're interested to set, clear or toggle.</source>
          <target state="translated">pos-我们要设置、清除或切换的位的位置。</target>
        </trans-unit>
        <trans-unit id="d183c0deb14cb48b70d54a4509f56c94c7466e99" translate="yes" xml:space="preserve">
          <source>to set, clear and test. This way you hide the magic numbers from the rest of your code.</source>
          <target state="translated">来设置、清除和测试。这样,你就可以把神奇的数字隐藏起来,不被其他的代码所影响。</target>
        </trans-unit>
        <trans-unit id="110686b5a36529717043f97083920f834fb221cc" translate="yes" xml:space="preserve">
          <source>value - Data</source>
          <target state="translated">值-数据</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
