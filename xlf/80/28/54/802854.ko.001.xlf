<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/802854">
    <body>
      <group id="802854">
        <trans-unit id="826b9014c63c93a46483ed104dc39e50d839cb61" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developers.google.com/web/updates/2016/08/removing-document-write&quot;&gt;This article on developers.google.com&lt;/a&gt; goes into more detail.</source>
          <target state="translated">&lt;a href=&quot;https://developers.google.com/web/updates/2016/08/removing-document-write&quot;&gt;developers.google.com에 대한이 기사&lt;/a&gt; 는 더 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cfd8a330e13190ac0686e8f88167aa081d213b1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.write&lt;/code&gt; is considered a browser violation as it halts the parser from rendering the page. The parser receives the message that the document is being modified; hence, it gets blocked until JS has completed its process. Only at this time will the parser resume.</source>
          <target state="translated">&lt;code&gt;.write&lt;/code&gt; 는 파서가 페이지를 렌더링하지 못하도록 브라우저 위반으로 간주됩니다. 파서는 문서가 수정되고 있다는 메시지를받습니다. 따라서 JS가 프로세스를 완료 할 때까지 차단됩니다. 이때에만 파서가 재개됩니다.</target>
        </trans-unit>
        <trans-unit id="5d9a0a7ad32136ed8f1dfe8859a22013d795fd8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;document.write&lt;/code&gt; needs to be used in the page load or body load.  So if you want to use the script in any other time to update your page content document.write is pretty much useless.</source>
          <target state="translated">페이지로드 또는 본문로드에 &lt;code&gt;document.write&lt;/code&gt; 를 사용해야합니다. 따라서 다른 시간에 스크립트를 사용하여 페이지 내용을 업데이트하려는 경우 document.write는 거의 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="010cfb34d5e9aae971a419887f69356c7358300b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;document.write&lt;/code&gt; only works while the page is loading; If you call it after the page is done loading, it will overwrite the whole page.</source>
          <target state="translated">&lt;code&gt;document.write&lt;/code&gt; 는 페이지가로드되는 동안에 만 작동합니다. 페이지로드가 완료된 후 호출하면 전체 페이지를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="f5df3def5b65f811fb647181ffb06045115a7d1d" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;DW does not directly modify the DOM, preventing further manipulation&lt;/strike&gt;&lt;em&gt;(trying to find evidence of this, but it's at best situational)&lt;/em&gt;</source>
          <target state="translated">&lt;strike&gt;DW는 DOM을 직접 수정하지 않으므로 추가 조작을 방지&lt;/strike&gt; &lt;em&gt;할 수 있습니다 (증거를 찾으려고하지만 상황이 가장 좋습니다).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3592c4dcfefcbb51a806e1b2043f2dc833adaaa2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best&lt;/strong&gt;: some browser switch back to HTML rendering and everything works fine.</source>
          <target state="translated">&lt;strong&gt;최고&lt;/strong&gt; : 일부 브라우저는 HTML 렌더링으로 다시 전환되며 모든 것이 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b69465cc04cb840744cdc85367c3a6f0b52eec9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Con:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Con:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89fbb411004c913eb35991f02ce0e7a7eb62dcf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It can block your page&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;페이지를 차단할 수 있습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ebef2da58606aacbf7ac36789ad62b2206c8a51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pro:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pro:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ac1b1206df01a33d3746bfdfd5abf8fa0737ae0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Probable&lt;/strong&gt;: some browser disable the document.write() function in XML rendering mode.</source>
          <target state="translated">&lt;strong&gt;가능성&lt;/strong&gt; : 일부 브라우저는 XML 렌더링 모드에서 document.write () 함수를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="bfa333f1fe7ba6071039ae76ab877a0ae757f087" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst&lt;/strong&gt;: some browser will fire an XML error whenever using the document.write() function.</source>
          <target state="translated">&lt;strong&gt;최악&lt;/strong&gt; : 일부 브라우저는 document.write () 함수를 사용할 때마다 XML 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6f4349c380a63f838be88c370cef604f0922a8f0" translate="yes" xml:space="preserve">
          <source>A Parser-blocking, cross-origin script, ..., is invoked via
  document.write. This may be blocked by the browser if the device has
  poor network connectivity.</source>
          <target state="translated">파서 차단, 출처 간 스크립트 ...는 document.write를 통해 호출됩니다. 장치의 네트워크 연결 상태가 좋지 않으면 브라우저에 의해 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e213051c87e0c8695bfb38d61579650d93ea3ce5" translate="yes" xml:space="preserve">
          <source>A few of the more serious problems:</source>
          <target state="translated">더 심각한 문제 중 몇 가지 :</target>
        </trans-unit>
        <trans-unit id="6cf75588ce1d62c934410431b4c2d9f35e7e6b9a" translate="yes" xml:space="preserve">
          <source>A simple reason why &lt;code&gt;document.write&lt;/code&gt; is a bad practice is that you cannot come up with a scenario where you cannot find a better alternative.</source>
          <target state="translated">&lt;code&gt;document.write&lt;/code&gt; 가 나쁜 습관 인 간단한 이유는 더 나은 대안을 찾을 수없는 시나리오를 만들 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="586da593715c792d36b865e66a83957efa66c526" translate="yes" xml:space="preserve">
          <source>All in all, it's best to steer clear of this method if you can help it.</source>
          <target state="translated">도움이 될 수 있다면이 방법을 피하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="98a110c76dedb15e5d09cf5cf415d3b2d1c56018" translate="yes" xml:space="preserve">
          <source>And document.write() would be like evaluating a string, e.g. create a list by evaluating a source code string like this:</source>
          <target state="translated">그리고 document.write ()는 문자열을 평가하는 것과 같습니다. 예를 들어 다음과 같이 소스 코드 문자열을 평가하여 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="32a04b489cbeed3421a2b8f3a71e0044893aa7e1" translate="yes" xml:space="preserve">
          <source>Another legitimate use of &lt;code&gt;document.write&lt;/code&gt; comes from the HTML5 Boilerplate &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/master/src/index.html&quot;&gt;index.html&lt;/a&gt; example.</source>
          <target state="translated">&lt;code&gt;document.write&lt;/code&gt; 의 다른 합법적 인 사용은 HTML5 Boilerplate &lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/master/src/index.html&quot;&gt;index.html&lt;/a&gt; 예제에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f474738dcbd7760cf8863a85580615a2fe1ba6" translate="yes" xml:space="preserve">
          <source>Another reason is that you are dealing with strings instead of objects (it is very primitive).</source>
          <target state="translated">또 다른 이유는 객체 대신 문자열을 다루기 때문입니다 (매우 원시적입니다).</target>
        </trans-unit>
        <trans-unit id="ca31ae4dc28769755ba50b0821c0afe616261ac2" translate="yes" xml:space="preserve">
          <source>As long as you don't try to use it after the document has loaded, &lt;code&gt;document.write&lt;/code&gt; is not inherently evil, in my humble opinion.</source>
          <target state="translated">문서가로드 된 후 문서를 사용하려고 시도하지 않는 한 &lt;code&gt;document.write&lt;/code&gt; 는 본질적으로 악의가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b6c0d29bdc2419de1520c4227d4eccd10fcefc17" translate="yes" xml:space="preserve">
          <source>Based on analysis done by Google-Chrome Dev Tools' &lt;a href=&quot;https://developers.google.com/web/tools/lighthouse/&quot;&gt;Lighthouse Audit&lt;/a&gt;,</source>
          <target state="translated">Google-Chrome Dev Tools의 &lt;a href=&quot;https://developers.google.com/web/tools/lighthouse/&quot;&gt;Lighthouse Audit&lt;/a&gt; 에서 수행 한 분석을 기반으로,</target>
        </trans-unit>
        <trans-unit id="8dc2c268fbf1e34e5f2f11524efa1c819848ad1b" translate="yes" xml:space="preserve">
          <source>Browser Violation</source>
          <target state="translated">브라우저 위반</target>
        </trans-unit>
        <trans-unit id="ba5210cb9b1a663880ab56accba5bb7ebc5570cc" translate="yes" xml:space="preserve">
          <source>Chrome may block &lt;code&gt;document.write&lt;/code&gt; that inserts a script in certain cases. When this happens, it will display this warning in the console:</source>
          <target state="translated">Chrome은 경우에 따라 스크립트를 삽입하는 &lt;code&gt;document.write&lt;/code&gt; 를 차단할 수 있습니다. 이 경우 콘솔에 다음 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f0f55494b2cc804af7ba0550eb372d75167c5b39" translate="yes" xml:space="preserve">
          <source>DW executed after the page has finished loading will overwrite the page, or write a new page, or not work</source>
          <target state="translated">페이지로드가 완료된 후 실행 된 DW는 페이지를 덮어 쓰거나 새 페이지를 쓰거나 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c80ffc717cc2c0ee8ce8930d0c60d96a5a82a91" translate="yes" xml:space="preserve">
          <source>DW executes where encountered: it cannot inject at a given node point</source>
          <target state="translated">DW는 마주 친 곳에서 실행됩니다. 주어진 노드 포인트에 주입 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="cbb0aff8034c59a6fd0c41daa00c5dc9741b385a" translate="yes" xml:space="preserve">
          <source>DW is effectively writing serialised text which is not the way the DOM works conceptually, and is an easy way to create bugs (.innerHTML has the same problem)</source>
          <target state="translated">DW는 직렬화 된 텍스트를 효과적으로 작성합니다. 이는 DOM이 개념적으로 작동하는 방식이 아니며 버그를 만드는 쉬운 방법입니다 (.innerHTML도 같은 문제가 있습니다)</target>
        </trans-unit>
        <trans-unit id="83fb34631ce45b4b283b6f59d5cbae8fcc72f2f3" translate="yes" xml:space="preserve">
          <source>Even so, you aren't really leveraging the DOM when you use document.write--you are just dumping a blob of text into the document so I'd say it's bad form.</source>
          <target state="translated">그럼에도 불구하고 document.write를 사용할 때 DOM을 실제로 활용하지는 않습니다. 문서에 텍스트 덩어리를 덤핑하여 잘못된 형식이라고 말하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="38551b22eeca8f0a499aee32c2f294bbbc20028a" translate="yes" xml:space="preserve">
          <source>Far better to use the safe and DOM friendly &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document&quot;&gt;DOM manipulation methods&lt;/a&gt;</source>
          <target state="translated">안전하고 DOM 친화적 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document&quot;&gt;DOM 조작 방법&lt;/a&gt; 을 사용하는 것이 훨씬 좋습니다</target>
        </trans-unit>
        <trans-unit id="df9bf1ae98dc45f25c4d64a24409f663af5e4193" translate="yes" xml:space="preserve">
          <source>For more info see &lt;a href=&quot;https://developers.google.com/web/updates/2016/08/removing-document-write&quot;&gt;Intervening against document.write()&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://developers.google.com/web/updates/2016/08/removing-document-write&quot;&gt;document.write ()에&lt;/a&gt; 대한 개입을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d38a06e33046e7c7ebeaf9f839d52ef7ddc821f6" translate="yes" xml:space="preserve">
          <source>For users on slow connections, external scripts dynamically injected via &lt;code&gt;document.write()&lt;/code&gt; can delay page load by tens of seconds.</source>
          <target state="translated">연결 속도가 느린 사용자의 경우 &lt;code&gt;document.write()&lt;/code&gt; 를 통해 동적으로 삽입 된 외부 스크립트는 페이지로드를 수십 초 지연시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bf8b07b668fa428786cd90106cd901d16cc136e" translate="yes" xml:space="preserve">
          <source>Here's my twopence worth, in general you shouldn't use &lt;code&gt;document.write&lt;/code&gt; for heavy lifting, but there is one instance where it is definitely useful:</source>
          <target state="translated">여기에 두 가지 가치가 있습니다. 일반적으로 무거운 리프팅에는 &lt;code&gt;document.write&lt;/code&gt; 를 사용해서는 안되지만 확실히 유용한 경우가 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="328fea04589a8b96650b7cfd712cc75147cbe0f3" translate="yes" xml:space="preserve">
          <source>I discovered this recently trying to create an AJAX slider gallery. I created two nested divs, and applied &lt;code&gt;width&lt;/code&gt;/&lt;code&gt;height&lt;/code&gt; and &lt;code&gt;overflow: hidden&lt;/code&gt; to the outer &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; with JS. This was so that in the event that the browser had JS disabled, the div would float to accommodate the images in the gallery - some nice graceful degradation.</source>
          <target state="translated">최근에 AJAX 슬라이더 갤러리를 만들려는 것을 발견했습니다. 두 개의 중첩 된 div를 만들고 &lt;code&gt;width&lt;/code&gt; / &lt;code&gt;height&lt;/code&gt; 와 &lt;code&gt;overflow: hidden&lt;/code&gt; 적용했습니다 .JS를 사용하여 외부 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 숨겨져 있습니다. 브라우저가 JS를 사용하지 않도록 설정 한 경우 div가 갤러리의 이미지를 수용하기 위해 떠 다니는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4cc2016d66e51cfc989ebf136e4efc7d6d740778" translate="yes" xml:space="preserve">
          <source>I don't think using document.write is a bad practice at all. In simple words it is like a high voltage for inexperienced people. If you use it the wrong way, you get cooked. There are many developers who have used this and other dangerous methods at least once, and they never really dig into their failures. Instead, when something goes wrong, they just bail out, and use something safer. Those are the ones who make such statements about what is considered a &quot;Bad Practice&quot;.</source>
          <target state="translated">나는 document.write를 사용하는 것이 나쁜 습관이라고 생각하지 않습니다. 간단히 말해서 그것은 경험이없는 사람들에게는 고전압과 같습니다. 잘못 사용하면 요리됩니다. 이 방법과 다른 위험한 방법을 한 번 이상 사용한 많은 개발자가 있으며 실제로는 절대 실패하지 않습니다. 대신, 무언가 잘못되면, 그들은 구제되고 더 안전한 것을 사용합니다. 그것들은 &quot;나쁜 습관&quot;으로 간주되는 것에 대해 그러한 진술을하는 사람들입니다.</target>
        </trans-unit>
        <trans-unit id="c74cdb29b366e3a6755058cada71ff6212a65be2" translate="yes" xml:space="preserve">
          <source>I know &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/document.write&quot;&gt;&lt;code&gt;document.write&lt;/code&gt;&lt;/a&gt; is considered bad practice; and I'm hoping to compile a list of reasons to submit to a 3rd party vendor as to why they shouldn't use &lt;code&gt;document.write&lt;/code&gt; in implementations of their analytics code.</source>
          <target state="translated">나는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/document.write&quot;&gt; &lt;code&gt;document.write&lt;/code&gt; &lt;/a&gt; 가 나쁜 습관으로 간주된다는 것을 안다. 그리고 분석 코드 구현에서 &lt;code&gt;document.write&lt;/code&gt; 를 사용하지 않아야하는 이유에 대해 타사 공급 업체에 제출 해야하는 이유 목록을 컴파일하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="fab27ea335ae2aedd86eeacde1be3b1ec3376803" translate="yes" xml:space="preserve">
          <source>I think the biggest problem is that any elements written via document.write are added to the end of the page's elements. That's rarely the desired effect with modern page layouts and AJAX. (you have to keep in mind that the elements in the DOM are temporal, and when the script runs may affect its behavior).</source>
          <target state="translated">가장 큰 문제는 document.write를 통해 작성된 요소가 페이지 요소 끝에 추가된다는 것입니다. 현대적인 페이지 레이아웃과 AJAX에서 원하는 효과는 거의 없습니다. (DOM의 요소는 일시적이며 스크립트가 실행될 때 동작에 영향을 줄 수 있음을 명심해야합니다.)</target>
        </trans-unit>
        <trans-unit id="64c5e244a3d1310fd45ecd093638709510a70aa2" translate="yes" xml:space="preserve">
          <source>I've also seen the same technique for using the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js&quot;&gt;json2.js&lt;/a&gt; JSON parse/stringify polyfill (&lt;a href=&quot;http://caniuse.com/#search=JSON&quot;&gt;needed by IE7 and below&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;a href=&quot;https://github.com/douglascrockford/JSON-js&quot;&gt;json2.js&lt;/a&gt; JSON 구문 분석 / stringify polyfill ( &lt;a href=&quot;http://caniuse.com/#search=JSON&quot;&gt;IE7 이하에서 필요)&lt;/a&gt; 을 사용하는 것과 동일한 기술을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="7eec71562329793b9ab4fb06d8a13c15253feeb4" translate="yes" xml:space="preserve">
          <source>If you implement coding tools, like simple live editors, it is very handy to have the ability to quickly evaluate a string, for example using document.write() or .innerHTML. Lisp is ideal in this sense, but you can do very cool stuff also in JS, and many people are doing that, like &lt;a href=&quot;http://jsbin.com/&quot;&gt;http://jsbin.com/&lt;/a&gt;</source>
          <target state="translated">간단한 라이브 편집기와 같은 코딩 도구를 구현하는 경우 예를 들어 document.write () 또는 .innerHTML을 사용하여 문자열을 빠르게 평가할 수 있습니다. Lisp는 이러한 의미에서 이상적이지만 JS에서도 매우 멋진 작업을 수행 할 수 있으며 &lt;a href=&quot;http://jsbin.com/&quot;&gt;http://jsbin.com/&lt;/a&gt; 과 같이 많은 사람들이 그렇게하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbbb6e7716ce2de67a98d1d17d3a0cc173474da8" translate="yes" xml:space="preserve">
          <source>In terms of vendors supplying analytics code (like Google Analytics) it's actually the easiest way for them to distribute such snippets</source>
          <target state="translated">Google 애널리틱스와 같은 애널리틱스 코드를 제공하는 벤더 측면에서 실제로 이러한 스 니펫을 배포하는 가장 쉬운 방법입니다</target>
        </trans-unit>
        <trans-unit id="f05cfd43335dbedd7583840248aa0855d6b64c43" translate="yes" xml:space="preserve">
          <source>In the context of Lisp, DOM manipulation would be like manipulating a list structure, e.g. create the list (orange) by doing:</source>
          <target state="translated">Lisp와 관련하여 DOM 조작은 목록 구조를 조작하는 것과 같습니다 (예 : 다음을 수행하여 목록 (주황색) 작성).</target>
        </trans-unit>
        <trans-unit id="8675b2a73e6a1a25f1321e6faf20af9051787b3b" translate="yes" xml:space="preserve">
          <source>It breaks pages using XML rendering (like XHTML pages).</source>
          <target state="translated">XHTML 페이지와 같은 XML 렌더링을 사용하여 페이지를 분할합니다.</target>
        </trans-unit>
        <trans-unit id="2e959c99ff4ef573029bc59e4446ef47f9c227f3" translate="yes" xml:space="preserve">
          <source>It does only append to documents.</source>
          <target state="translated">문서에만 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c42952e44196436174e98bac19b77a2b2b74c708" translate="yes" xml:space="preserve">
          <source>It has nothing of the beauty of for instance the &lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC (Model-View-Controller)&lt;/a&gt; pattern.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC (Model-View-Controller)&lt;/a&gt; 패턴의 아름다움은 없습니다.</target>
        </trans-unit>
        <trans-unit id="08e33dc8264325fbaa4397164404c0a649dc0bf3" translate="yes" xml:space="preserve">
          <source>It is a lot more powerful to present dynamic content with &lt;a href=&quot;https://jquery.com/&quot;&gt;ajax+jQuery&lt;/a&gt; or &lt;a href=&quot;https://angularjs.org/&quot;&gt;angularJS&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jquery.com/&quot;&gt;ajax + jQuery&lt;/a&gt; 또는 &lt;a href=&quot;https://angularjs.org/&quot;&gt;angularJS로&lt;/a&gt; 동적 컨텐츠를 표시하는 것이 훨씬 강력합니다.</target>
        </trans-unit>
        <trans-unit id="44e2ddb5bb3b4c77e868bbf3cf0b7df8d150fc93" translate="yes" xml:space="preserve">
          <source>It is usually used in such a way that the script is placed within the content, which is considered bad-form.</source>
          <target state="translated">일반적으로 스크립트가 내용 내에 배치되는 방식으로 사용되며 이는 잘못된 형식으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="175abf4ef26925b6b362a56441ce762fead9b45c" translate="yes" xml:space="preserve">
          <source>It just doesn't have much use unless you're creating an entire document using JavaScript in which case you may start with document.write.</source>
          <target state="translated">JavaScript를 사용하여 전체 문서를 작성하지 않으면 document.write로 시작할 수 없다면 많이 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2c5fd47fa308d44afeb9997ca588e7b39b82c8b" translate="yes" xml:space="preserve">
          <source>It keeps the scripts small</source>
          <target state="translated">스크립트를 작게 유지합니다</target>
        </trans-unit>
        <trans-unit id="8a4d6da8f57c73c606ea29c6591b6369ca864e81" translate="yes" xml:space="preserve">
          <source>It overwrites content on the page which is the most obvious reason but I wouldn't call it &quot;bad&quot;.</source>
          <target state="translated">가장 명백한 이유 인 페이지의 내용을 덮어 쓰지만 &quot;나쁜&quot;것으로 부르지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef9ac0de84ae80dd062971857646c676c5a958b1" translate="yes" xml:space="preserve">
          <source>It serializes the rendering engine to pause until said external script is loaded, which could take much longer than an internal script.</source>
          <target state="translated">외부 스크립트가로드 될 때까지 렌더링 엔진을 직렬화하여 내부 스크립트보다 훨씬 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c88c041efc93bc804df3a7a648b060c3a5f7700" translate="yes" xml:space="preserve">
          <source>It's extremely compatible</source>
          <target state="translated">매우 호환됩니다</target>
        </trans-unit>
        <trans-unit id="2ace14076f8a9b5a7d406a6573b87f58ed3cab5b" translate="yes" xml:space="preserve">
          <source>It's like formatting a hard drive, when you need to delete only a few files and then saying &quot;formatting drive is a bad practice&quot;.</source>
          <target state="translated">파일을 몇 개만 삭제 한 다음 &quot;드라이브 포맷팅은 좋지 않습니다&quot;라고 말하면 하드 드라이브를 포맷하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c78d00d58c2fad38bf09178b081d71cc6a21b082" translate="yes" xml:space="preserve">
          <source>It's much better to set a placeholder element on the page, and then manipulate it's innerHTML.</source>
          <target state="translated">페이지에 자리 표시 자 요소를 설정 한 다음 innerHTML을 조작하는 것이 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f92572ecb296fa05fd25685e35e572aadc130367" translate="yes" xml:space="preserve">
          <source>It's the easiest way to embed inline content from an external (to your host/domain) script.</source>
          <target state="translated">외부 (호스트 / 도메인) 스크립트에서 인라인 컨텐츠를 포함하는 가장 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6107c7b458f7063e7d8034d97a4b6b3d895e601c" translate="yes" xml:space="preserve">
          <source>Lisp also has the very useful ability to create code using list manipulation (like using the &quot;DOM style&quot; to create a JS parse tree). This means you can build up a list structure using the &quot;DOM style&quot;, rather than the &quot;string style&quot;, and then run that code, e.g. like this:</source>
          <target state="translated">또한 Lisp에는 목록 조작을 사용하여 코드를 작성하는 데 매우 유용한 기능이 있습니다 (예 : &quot;DOM 스타일&quot;을 사용하여 JS 구문 분석 트리 작성). 즉, &quot;문자열 스타일&quot;대신 &quot;DOM 스타일&quot;을 사용하여 목록 구조를 작성한 다음 해당 코드를 실행할 수 있습니다 (예 : 다음과 같이).</target>
        </trans-unit>
        <trans-unit id="a3b94c601fb014b232428ef1810d35004bef8e6c" translate="yes" xml:space="preserve">
          <source>Obviously, this won't work in XHTML, but since XHTML appears to be something of a dead duck (and renders as tag soup in IE) it might be worth re-evaluating your choice of DOCTYPE...</source>
          <target state="translated">분명히 이것은 XHTML에서는 작동하지 않지만 XHTML은 죽은 오리의 것으로 보이므로 IE에서 태그 수프로 렌더링되므로 DOCTYPE 선택을 다시 평가할 가치가 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="714da2bdccc4a025fb61616dc3c7f5c953ff47b9" translate="yes" xml:space="preserve">
          <source>Off the top of my head:</source>
          <target state="translated">내 머리 꼭대기에서 :</target>
        </trans-unit>
        <trans-unit id="489705bd36c6abd21d164b21c02250fa21809212" translate="yes" xml:space="preserve">
          <source>Once it's written it's done and over with. We cannot go back to manipulate it without tapping into the DOM.</source>
          <target state="translated">일단 작성되면 끝났습니다. DOM을 두드리지 않고는 다시 조작 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3699d68a46c5054148562848233d367e2c070ff0" translate="yes" xml:space="preserve">
          <source>One can think of document.write() (and .innerHTML) as evaluating a source code string. This can be very handy for many applications. For example if you get HTML code as a string from some source, it is handy to just &quot;evaluate&quot; it.</source>
          <target state="translated">document.write () (및 .innerHTML)를 소스 코드 문자열을 평가하는 것으로 생각할 수 있습니다. 많은 응용 프로그램에 매우 유용 할 수 있습니다. 예를 들어 어떤 소스에서 HTML 코드를 문자열로 가져 오면 &quot;평가&quot;하는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="68bb5152ed597d87fb4619774fa38ca8e6d67911" translate="yes" xml:space="preserve">
          <source>Please include your reason for claiming &lt;code&gt;document.write&lt;/code&gt; as a bad practice below.</source>
          <target state="translated">아래의 나쁜 관행으로 &lt;code&gt;document.write&lt;/code&gt; 를 청구 한 이유를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="8d64579596b16b629cff3e95d263924c8177b0b1" translate="yes" xml:space="preserve">
          <source>Technically &lt;code&gt;document.write&lt;/code&gt; will only update HTML pages not XHTML/XML.  IE seems to be pretty forgiving of this fact but other browsers will not be.</source>
          <target state="translated">기술적으로 &lt;code&gt;document.write&lt;/code&gt; 는 XHTML / XML이 아닌 HTML 페이지 만 업데이트합니다. IE는이 사실을 꽤 용서하는 것처럼 보이지만 다른 브라우저는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce508ea0e8b07947932b7c25973a83033a926789" translate="yes" xml:space="preserve">
          <source>The biggest consequence of employing such a method is lowered performance. The browser will take longer to load page content. The adverse reaction on load time depends on what is being written to the document. You won't see much of a difference if you are adding a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tag to the DOM as opposed to passing an array of 50-some references to JavaScript libraries (something which I have seen in working code and resulted in an 11 second delay - of course, this also depends on your hardware).</source>
          <target state="translated">이러한 방법을 사용하면 가장 큰 결과는 성능이 저하됩니다. 브라우저는 페이지 내용을로드하는 데 시간이 더 걸립니다. 로드 시간에 대한 부작용은 문서에 기록되는 내용에 따라 다릅니다. JavaScript 라이브러리에 50-some 참조 배열을 전달하는 것과는 달리 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 태그를 DOM에 추가하면 큰 차이가 없습니다. 지연-물론 하드웨어에 따라 다릅니다).</target>
        </trans-unit>
        <trans-unit id="1bad4975a3288af8b0b1d4a8fd6a1d4292945a3b" translate="yes" xml:space="preserve">
          <source>The disadvantages of document.write mainly depends on these 3 factors:</source>
          <target state="translated">document.write의 단점은 주로 다음 세 가지 요소에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="21d307495a4832f897836ffd7f37a51a6c06551f" translate="yes" xml:space="preserve">
          <source>The document.write() is mostly used to write content to the screen as soon as that content is needed. This means it happens anywhere, either in a JavaScript file or inside a script tag within an HTML file. With the script tag being placed anywhere within such an HTML file, it is a bad idea to have document.write() statements inside script blocks that are intertwined with HTML inside a web page.</source>
          <target state="translated">document.write ()는 내용이 필요한 즉시 내용을 화면에 쓰는 데 주로 사용됩니다. 이는 JavaScript 파일 또는 HTML 파일 내의 스크립트 태그 내에서 발생합니다. 이러한 HTML 파일 내에서 스크립트 태그를 배치 할 경우 웹 페이지 내에서 HTML과 얽힌 스크립트 블록 내에 document.write () 문을 사용하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39ba256a68109911affc155798aab13473b6c90a" translate="yes" xml:space="preserve">
          <source>There's actually nothing wrong with &lt;code&gt;document.write&lt;/code&gt;, per se.  The problem is that it's really easy to misuse it.  Grossly, even.</source>
          <target state="translated">&lt;code&gt;document.write&lt;/code&gt; 자체에는 실제로 아무런 문제가 없습니다. 문제는 오용하기가 정말 쉽다는 것입니다. 심하게도.</target>
        </trans-unit>
        <trans-unit id="d3e76044d59cba50727568df74cdabf8784acfcd" translate="yes" xml:space="preserve">
          <source>They don't have to worry about overriding already established onload events or including the necessary abstraction to add onload events safely</source>
          <target state="translated">이미 설정된 onload 이벤트를 재정의하거나 onload 이벤트를 안전하게 추가하기 위해 필요한 추상화를 포함 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7855c95d2894d6ddde6e0082a1de86fd43d21857" translate="yes" xml:space="preserve">
          <source>Thing is, as with the article above, this JS hijacking of the CSS didn't kick in until the page had loaded, causing a momentary flash as the div was loaded. So I needed to write a CSS rule, or include a sheet, as the page loaded.</source>
          <target state="translated">위의 기사와 마찬가지로 CSS의 JS 하이재킹은 페이지가로드 될 때까지 시작되지 않아 div 가로 드 될 때 순간적으로 플래시가 발생했습니다. 따라서 페이지가로드 될 때 CSS 규칙을 작성하거나 시트를 포함해야했습니다.</target>
        </trans-unit>
        <trans-unit id="33808169775e6aaadd8aecbeb5d2b6d36098891c" translate="yes" xml:space="preserve">
          <source>This effectively means you have to call it from an inline script block - And that will prevent the browser from processing parts of the page that follow. Scripts and Images will not be downloaded until the writing block is finished.</source>
          <target state="translated">즉, 인라인 스크립트 블록에서 호출해야합니다. 그러면 브라우저가 다음 페이지의 일부를 처리하지 못하게됩니다. 쓰기 블록이 완료 될 때까지 스크립트와 이미지는 다운로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9c9f1a966019dcbce39961edc9ac9c1d57bdb78" translate="yes" xml:space="preserve">
          <source>Well designed code in general will take any dynamically generated content, store it in memory, keep manipulating it as it passes through the code before it finally gets spit out to the screen. So to reiterate the last point in the preceding section, rendering content in-place may render faster than other content that may be relied upon, but it may not be available to the other code that in turn requires the content to be rendered for processing. To solve this dilemma we need to get rid of the document.write() and implement it the right way.</source>
          <target state="translated">잘 설계된 코드는 일반적으로 동적으로 생성 된 컨텐츠를 가져 와서 메모리에 저장하며, 코드가 화면에 튀어 나오기 전에 코드를 통과하면서 조작합니다. 따라서 이전 섹션의 마지막 요점을 반복하기 위해, 적절한 위치에 컨텐츠를 렌더링하면 신뢰할 수있는 다른 컨텐츠보다 더 빠르게 렌더링 할 수 있지만 처리를 위해 컨텐츠를 렌더링해야하는 다른 코드에서는 사용할 수 없습니다. 이 딜레마를 해결하려면 document.write ()를 제거하고 올바른 방법으로 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="129c8b0eed788dd7325f0eacd5b5b5c92843d45b" translate="yes" xml:space="preserve">
          <source>Why is document.write considered a “bad practice”</source>
          <target state="translated">document.write가&amp;ldquo;나쁜 습관&amp;rdquo;으로 간주되는 이유</target>
        </trans-unit>
        <trans-unit id="ce707735b6bb21a581708a5a0645226e0fc70b02" translate="yes" xml:space="preserve">
          <source>You can overwrite the entire content in a frame/iframe.  I used to use this technique a lot for menu/navigation pieces before more modern Ajax techniques were widely available (1998-2002).</source>
          <target state="translated">프레임 / iframe에서 전체 내용을 덮어 쓸 수 있습니다. 더 현대적인 Ajax 기술이 널리 사용되기 전에 (1998-2002) 메뉴 / 탐색 조각에이 기술을 많이 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="f452a6fd96c9dac3749b8e54dfee97633000b3be" translate="yes" xml:space="preserve">
          <source>a) Implementation</source>
          <target state="translated">a) 구현</target>
        </trans-unit>
        <trans-unit id="b93aa289742c254955b9d232ad84cfd151b8c8d7" translate="yes" xml:space="preserve">
          <source>b) Rendering</source>
          <target state="translated">b) 렌더링</target>
        </trans-unit>
        <trans-unit id="b11df25841b632cbb871076973305085341aabb5" translate="yes" xml:space="preserve">
          <source>c) Impossible Manipulation</source>
          <target state="translated">c) 불가능한 조작</target>
        </trans-unit>
        <trans-unit id="f34d65f205f80fd1724a7e7821c49ec3a2d2e139" translate="yes" xml:space="preserve">
          <source>document.write (henceforth DW) does not work in XHTML</source>
          <target state="translated">XHTML에서는 document.write (이후 DW)가 작동하지 않습니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
