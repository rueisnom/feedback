<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/4366730">
    <body>
      <group id="4366730">
        <trans-unit id="536930aa45c4f9ebe04ec4eee9fe774d8b05ff5b" translate="yes" xml:space="preserve">
          <source>1- stristr()</source>
          <target state="translated">1-stristr()</target>
        </trans-unit>
        <trans-unit id="9c04eee059ec9710c163e4d720492795c8a32060" translate="yes" xml:space="preserve">
          <source>2- strpos()</source>
          <target state="translated">2-strpos()</target>
        </trans-unit>
        <trans-unit id="ae4b45ccf79b06e3929e1a3633b7a35b68e5cbbf" translate="yes" xml:space="preserve">
          <source>3- preg_match()</source>
          <target state="translated">3-preg_match()</target>
        </trans-unit>
        <trans-unit id="8d1a614572a1ef0c19a362e30bcd32eef314aab4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos&lt;/code&gt;&lt;/a&gt; finds the position of the first occurrence of a case-insensitive substring in a string.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos&lt;/code&gt; &lt;/a&gt;は、文字列内で大文字と小文字を区別しない部分文字列が最初に出現する位置を見つけます。</target>
        </trans-unit>
        <trans-unit id="d7edf7695232ace28ffa32c8559ecb9b1e5ea944" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos&lt;/code&gt;&lt;/a&gt; finds the position of the first occurrence of a case-sensitive substring in a string.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos&lt;/code&gt; &lt;/a&gt;は、文字列内で大文字と小文字を区別する部分文字列が最初に出現する位置を見つけます。</target>
        </trans-unit>
        <trans-unit id="65db47ef4129dadb5b064de72e4a9344d03d186d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;Look at &lt;code&gt;strpos()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos()&lt;/code&gt; を見てください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="161a91404619d6734e80cd0778e5e2eb37c87d8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$caseSensitive ? A : B&lt;/code&gt; selects either &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos&lt;/code&gt;&lt;/a&gt; to do the work, depending on the value of &lt;code&gt;$caseSensitive&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$caseSensitive ? A : B&lt;/code&gt; A：Bは、 &lt;code&gt;$caseSensitive&lt;/code&gt; 値に応じて、 &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos&lt;/code&gt; &lt;/a&gt;を選択して作業を行います。</target>
        </trans-unit>
        <trans-unit id="8e43f3e39917183f03b6c7d8df65a3d6caaca77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myFunction($haystack, $needle) === FALSE ? FALSE : TRUE&lt;/code&gt; ensures that &lt;code&gt;myFunction&lt;/code&gt; always returns a boolean and fixes unexpected behavior when the index of the substring is 0.</source>
          <target state="translated">&lt;code&gt;myFunction($haystack, $needle) === FALSE ? FALSE : TRUE&lt;/code&gt; FALSE：TRUEは、部分文字列のインデックスが0の場合、 &lt;code&gt;myFunction&lt;/code&gt; が常にブール値を返し、予期しない動作を修正することを保証します。</target>
        </trans-unit>
        <trans-unit id="a38601451a7271300a3862930f2409a619504b87" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Optionally eliminating redundancy prior to search the words&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;必要に応じて、単語を検索する前に冗長性を排除します&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b239b39dd3ea5d3bc28ab5e6594623814ae44575" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Normalisation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.正規化&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c2da9093478005107c83bcb253a85f687fcb20e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Stopword elimination&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.ストップワードの削除&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15f70347f13635fdde48efd621a04e1cd494add" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Dictionary substitution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.辞書の置換&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d4d8c048007e19655046e44f48cfa683d97aa7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ケース1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b17fa346bb4f567be4a05b73d079ef9eeb1da6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ケース2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d2e913dec4051855fb256e532411a9b529ea94d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ケース3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4219c5f6fe25ad668c412bff701696037aef1b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAUTION:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CAUTION:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcde4902afc8a02e4348242ab9385feb6c8fa9c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issues with the other boolean search methods such as &lt;code&gt;strpos()&lt;/code&gt;, &lt;code&gt;preg_match()&lt;/code&gt;, &lt;code&gt;strstr()&lt;/code&gt; or &lt;code&gt;stristr()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;strpos()&lt;/code&gt; 、 &lt;code&gt;preg_match()&lt;/code&gt; 、 &lt;code&gt;stristr()&lt;/code&gt; またはstristr（）などの他のブール検索メソッドの問題&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7666b304a8fca7faed968cac02ec2f4fede0f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTA BENE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTA BENE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00c6ca567e32596c84c50e0fb28233adda888901" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Here we do not mean word for every sequence of symbols.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;ここでは、記号のすべてのシーケンスの単語を意味するわけではありません。</target>
        </trans-unit>
        <trans-unit id="0464dc38e1fc7e588f4c179f040c57144d419a6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP method based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_space_model&quot;&gt;Vector Space Model&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf (term frequency&amp;ndash;inverse document frequency):&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_space_model&quot;&gt;Vector Space Model&lt;/a&gt;と&lt;a href=&quot;http://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf（term frequency&amp;ndash;inverse document frequency）に&lt;/a&gt;基づくPHPメソッド：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="450025855baecd41e523dc05eafa16f85db4098f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHPCode Sample with output&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;出力付きのPHPCodeサンプル&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b7fe3ad4bb795df9d41e53255576530192a9be9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESOURCES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESOURCES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3d9b2805e24d71fd7dbe60ed49798186b321048" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESULT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESULT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e8719c6c93a3d522fb7415c04094d2b50b9a4f84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESULTS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESULTS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d03f4a89fe7c2757c20c5c42a24c135ce9e8e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Without using an inbuilt function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;組み込み関数を使用しない場合：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa1853953b71f4c41b3cc95fb3cca78efdd9c424" translate="yes" xml:space="preserve">
          <source>A &quot;word&quot; character is any letter or digit or the underscore character,
  that is, any character which can be part of a Perl &quot; word &quot;. The
  definition of letters and digits is controlled by PCRE's character
  tables, and may vary if locale-specific matching is taking place (..)</source>
          <target state="translated">単語」文字とは、Perl の「単語」の一部となりうる文字や数字、アンダースコア文字のことです。文字と数字の定義は PCRE の文字テーブルによって管理されており、ローカリゼーション固有のマッチングが行われている場合は異なる場合があります (...)</target>
        </trans-unit>
        <trans-unit id="f8f3f2943f82691039b22b2ebdeff76dd86282d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;==&lt;/code&gt; sign is a comparison and tests whether the variable / expression / constant to the left has the same value as the variable / expression / constant to the right.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 記号は比較であり、左側の変数/式/定数が右側の変数/式/定数と同じ値かどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="b7e4f92de169b796d2edbe690758dfdf768e8e70" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;===&lt;/code&gt; sign is a comparison to see whether two variables / expresions / constants are equal &lt;code&gt;AND&lt;/code&gt; have the same type - i.e. both are strings or both are integers.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 記号は、2つの変数/式/定数が等しく、 &lt;code&gt;AND&lt;/code&gt; 同じ型であるかどうかを比較する比較です。つまり、両方が文字列であるか、両方が整数であるかを示します。</target>
        </trans-unit>
        <trans-unit id="e4920abb4f3b8892883bf5a41623c4aab2b1f548" translate="yes" xml:space="preserve">
          <source>A good article to understand why is &lt;em&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a&gt;&lt;/em&gt; by &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Joel_Spolsky&quot;&gt;Joel Spolsky&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Joel_Spolsky&quot;&gt;Joel Spolskyに&lt;/a&gt;&lt;/em&gt;よる、 &lt;em&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;Unicodeと文字セット（絶対に言い訳なし！）について、絶対にすべてのソフトウェア開発者が絶対に知っている必要&lt;/a&gt;&lt;/em&gt;がある理由を理解するのに適した記事です。</target>
        </trans-unit>
        <trans-unit id="f4dca82ce7301d5a56f3ffda9ea5d842b28eb7ec" translate="yes" xml:space="preserve">
          <source>A practical definition of word is in the sense the PCRE regular expression engine, where words are substrings consisting of word characters only, being separated by non-word characters.</source>
          <target state="translated">単語の実用的な定義は、PCRE正規表現エンジンの意味であり、単語は単語文字のみで構成される部分文字列であり、非単語文字で区切られている。</target>
        </trans-unit>
        <trans-unit id="5ec194c4603c00b67980b557f9d17564cb709fe7" translate="yes" xml:space="preserve">
          <source>A run gives</source>
          <target state="translated">走れば</target>
        </trans-unit>
        <trans-unit id="41a9b657064aaec58c7a71735974461119393ee2" translate="yes" xml:space="preserve">
          <source>A simple match for are could look something like this:</source>
          <target state="translated">シンプルにマッチするとこんな感じになります。</target>
        </trans-unit>
        <trans-unit id="5005dc287716aef5b1fa0a49374df254f53b0a13" translate="yes" xml:space="preserve">
          <source>Also, here's a great tool for testing and seeing explanations of various regular expressions &lt;a href=&quot;https://regex101.com/&quot;&gt;Regex101&lt;/a&gt;</source>
          <target state="translated">また、 &lt;a href=&quot;https://regex101.com/&quot;&gt;Regex101&lt;/a&gt;のさまざまな正規表現のテストと説明を表示するための優れたツールもここにあります</target>
        </trans-unit>
        <trans-unit id="154f98e219ba2d530ab470fcb920ed2cf84456ee" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;strstr()&lt;/a&gt; function. Something like:</source>
          <target state="translated">別のオプションは、 &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;strstr（）&lt;/a&gt;関数を使用することです。 何かのようなもの：</target>
        </trans-unit>
        <trans-unit id="30eb8eef8b6e9b1c537d3b8ca07b74300cc86462" translate="yes" xml:space="preserve">
          <source>Another option to finding the occurrence of a word from a string using &lt;a href=&quot;http://www.php.net/manual/en/function.strstr.php&quot;&gt;strstr()&lt;/a&gt; and &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr()&lt;/a&gt; is like the following:</source>
          <target state="translated">&lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;strstr（）&lt;/a&gt;とstristr（）を使用して文字列から単語の出現を見つける別のオプションは、次のようなものです。</target>
        </trans-unit>
        <trans-unit id="1c001274549b8d9c38352b77098a207b33210a25" translate="yes" xml:space="preserve">
          <source>Another solution for a specific string:</source>
          <target state="translated">特定の文字列に対する別の解決策。</target>
        </trans-unit>
        <trans-unit id="059fd4a17ec8f277845903f637b570f56ea31b4d" translate="yes" xml:space="preserve">
          <source>Basically, if you're &lt;strong&gt;having trouble finding words with characters specific to some languages&lt;/strong&gt;, such as German, French, Portuguese, Spanish, etc. (e.g.: &lt;em&gt;&amp;auml;&lt;/em&gt;, &lt;em&gt;&amp;eacute;&lt;/em&gt;, &lt;em&gt;&amp;ocirc;&lt;/em&gt;, &lt;em&gt;&amp;ccedil;&lt;/em&gt;, &lt;em&gt;&amp;ordm;&lt;/em&gt;, &lt;em&gt;&amp;ntilde;&lt;/em&gt;), you may want to precede the functions with &lt;code&gt;mb_&lt;/code&gt;. Therefore, the accepted answer would use &lt;a href=&quot;http://php.net/manual/en/function.mb-strpos.php&quot;&gt;&lt;code&gt;mb_strpos&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.mb-stripos.php&quot;&gt;&lt;code&gt;mb_stripos&lt;/code&gt;&lt;/a&gt; (for case-insensitive matching) instead:</source>
          <target state="translated">基本的に、ドイツ語、フランス語、ポルトガル語、スペイン語など、 &lt;strong&gt;一部の言語&lt;/strong&gt;に&lt;strong&gt;固有の文字&lt;/strong&gt; （例： &lt;em&gt;&amp;auml;&lt;/em&gt; 、 &lt;em&gt;&amp;eacute;&lt;/em&gt; 、 &lt;em&gt;&amp;ocirc;&lt;/em&gt; 、 &lt;em&gt;&amp;ccedil;&lt;/em&gt; 、 &lt;em&gt;&amp;ordm;&lt;/em&gt; 、 &lt;em&gt;&amp;ntilde;&lt;/em&gt; ） &lt;strong&gt;を含む単語を見つけるのに問題&lt;/strong&gt;がある場合は、前に進むことをお勧めします。 &lt;code&gt;mb_&lt;/code&gt; を使用する関数。 したがって、受け入れられた回答は、 &lt;a href=&quot;http://php.net/manual/en/function.mb-strpos.php&quot;&gt; &lt;code&gt;mb_strpos&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;http://php.net/manual/en/function.mb-stripos.php&quot;&gt; &lt;code&gt;mb_stripos&lt;/code&gt; &lt;/a&gt; （大文字と小文字を区別しないマッチングのため）を使用します。</target>
        </trans-unit>
        <trans-unit id="c6ac2ebe3d53f92da9f6857d844261f13d940aaa" translate="yes" xml:space="preserve">
          <source>Check if string contains specific words?</source>
          <target state="translated">文字列に特定の単語が含まれているかどうかをチェックしますか?</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="995f64f15a13f374697065535435ba94d26464e7" translate="yes" xml:space="preserve">
          <source>Convert all text to lower case</source>
          <target state="translated">すべてのテキストを小文字に変換</target>
        </trans-unit>
        <trans-unit id="112d1f61745b16ccc0356f918f7a7be16bdd57d2" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;preg_match()&lt;/code&gt; if you only want to check if one string is contained in another string. Use &lt;code&gt;strpos()&lt;/code&gt; or &lt;code&gt;strstr()&lt;/code&gt; instead as they will be faster. (&lt;a href=&quot;http://in2.php.net/preg_match&quot;&gt;http://in2.php.net/preg_match&lt;/a&gt;)</source>
          <target state="translated">ある文字列が別の文字列に含まれているかどうかを確認するだけの場合は、 &lt;code&gt;preg_match()&lt;/code&gt; を使用しないでください。 より高速になるため、代わりに &lt;code&gt;strpos()&lt;/code&gt; またはstrstr（）を使用してください。 （ &lt;a href=&quot;http://in2.php.net/preg_match&quot;&gt;http://in2.php.net/preg_match&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="771ca06d7bb1df15a66af37bb337725931a04e2f" translate="yes" xml:space="preserve">
          <source>Edit:
In order to search any part of the string, not just word by word, I would recommend using a regular expression like</source>
          <target state="translated">編集:一語一句だけでなく、文字列の任意の部分を検索するには、次のような正規表現を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a175d3309aa70f6eadc8fd006df92ee87672c066" translate="yes" xml:space="preserve">
          <source>Eliminate words from the text which carry no real meaning (like 'and', 'or', 'the', 'for', etc.)</source>
          <target state="translated">テキストから本当の意味を持たない単語を削除します('and'、'or'、'the'、'for'など)。</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="f8838d8c3e8de7ea1720befe670b6ddecdfca0fa" translate="yes" xml:space="preserve">
          <source>Find the position of the first occurrence of a case-insensitive substring in a string.</source>
          <target state="translated">大文字小文字を区別しない部分文字列の最初の出現位置を求めます。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="8e347c4e5e5f169d1f544caeabe3acbdeb0a1fd6" translate="yes" xml:space="preserve">
          <source>Further algorithmic measures (snowball) may be performed to further reduce words to their essential meaning.</source>
          <target state="translated">単語をさらに本質的な意味に還元するために、さらにアルゴリズム的な手段(スノーボール)が実行されてもよい。</target>
        </trans-unit>
        <trans-unit id="868013052501a3915b42071b147883eee03a3899" translate="yes" xml:space="preserve">
          <source>Here is a little utility function that is useful in situations like this</source>
          <target state="translated">このような場合に便利な、ちょっとした効用関数があります。</target>
        </trans-unit>
        <trans-unit id="640ccdb37a48eedfabd85e115efe42bf0f97e2b4" translate="yes" xml:space="preserve">
          <source>Here stripos finds needle in heystack &lt;strong&gt;without&lt;/strong&gt; considering case (small/caps).</source>
          <target state="translated">ここで、striposは大文字と小文字を区別&lt;strong&gt;せずに&lt;/strong&gt; 、heystackで針を見つけます。</target>
        </trans-unit>
        <trans-unit id="828d73986d577dc553333bd6f21ac565c1fb423c" translate="yes" xml:space="preserve">
          <source>How do I check if a string contains a specific word</source>
          <target state="translated">文字列に特定の単語が含まれているかどうかを確認するには</target>
        </trans-unit>
        <trans-unit id="224b8efc0b9ac26641de6ae359e96fd868125065" translate="yes" xml:space="preserve">
          <source>I had some trouble with this, and finally I chose to create my own solution. Without using &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; engine:</source>
          <target state="translated">私はこれでいくつかの問題を抱えていましたが、最後に自分のソリューションを作成することにしました。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;正規表現&lt;/a&gt;エンジンを使用しない場合：</target>
        </trans-unit>
        <trans-unit id="a42d6e1c43dd12b71ad626eaa7d6b3ea6944040b" translate="yes" xml:space="preserve">
          <source>I'm a bit impressed that none of the answers here that used &lt;code&gt;strpos&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt; and similar functions mentioned &lt;a href=&quot;http://php.net/manual/en/ref.mbstring.php&quot;&gt;Multibyte String Functions&lt;/a&gt; yet (2015-05-08).</source>
          <target state="translated">&lt;code&gt;strpos&lt;/code&gt; 、 strstr 、および同様の関数を使用したここでの回答のいずれも、まだ&lt;a href=&quot;http://php.net/manual/en/ref.mbstring.php&quot;&gt;マルチバイト文字列&lt;/a&gt;関数について言及していないことに少し感銘を受けました（2015-05-08）。</target>
        </trans-unit>
        <trans-unit id="fa8035d683dec343995234343194912e2e44077e" translate="yes" xml:space="preserve">
          <source>If the needle you are searching for is at the beginning of the haystack it will return position 0, if you do a &lt;code&gt;==&lt;/code&gt; compare that will not work, you will need to do a &lt;code&gt;===&lt;/code&gt;</source>
          <target state="translated">あなたが探している針が干し草の山の始めにある場合、それは位置0を返します、もし &lt;code&gt;==&lt;/code&gt; 比較が機能しないなら、あなたは &lt;code&gt;===&lt;/code&gt; を行う必要があります</target>
        </trans-unit>
        <trans-unit id="914d8946f736f2babcc727a583d93362c1a80a2b" translate="yes" xml:space="preserve">
          <source>If the word doesn't exist in the string then it will return false else it will return the position of the word.</source>
          <target state="translated">文字列の中にその単語が存在しない場合はfalseを返し、そうでない場合はその単語の位置を返します。</target>
        </trans-unit>
        <trans-unit id="0ca72b4ba6418cfdc9d8f0766d5bbbaed69c8c46" translate="yes" xml:space="preserve">
          <source>If we could weight the terms in a string based on how representative they are of the string as a whole, 
we could order our results by the ones that best match the query.</source>
          <target state="translated">文字列の中の用語が、文字列全体の中でどれだけ代表的なものであるかに基づいて重み付けをすることができれば、クエリに最もマッチするものから結果を順番に並べることができます。</target>
        </trans-unit>
        <trans-unit id="f22ff471b11f2348e549c1430ff4e7c026fa09ca" translate="yes" xml:space="preserve">
          <source>If we want to search for multiple words in a string the core problem is how we assign a weight to each one of them?</source>
          <target state="translated">文字列の中の複数の単語を検索したい場合の核心的な問題は、それぞれの単語にどのように重みを割り当てるかということです。</target>
        </trans-unit>
        <trans-unit id="7301e6fd4a01ccad442ed786a4bba0c369969b9f" translate="yes" xml:space="preserve">
          <source>If you are looking for a PHP algorithm to &lt;strong&gt;rank search results based on proximity/relevance&lt;/strong&gt; of multiple words
here comes a quick and easy way of generating search results with PHP only:</source>
          <target state="translated">複数の単語の&lt;strong&gt;近接性/関連性&lt;/strong&gt;に&lt;strong&gt;基づいて検索結果&lt;/strong&gt;を&lt;strong&gt;ランク付け&lt;/strong&gt;するPHPアルゴリズムを探している場合は、PHPのみで検索結果を生成する迅速かつ簡単な方法がここにあります。</target>
        </trans-unit>
        <trans-unit id="177529202720249ead729bcdcae74deef04b45b8" translate="yes" xml:space="preserve">
          <source>If you cannot guarantee that &lt;a href=&quot;https://stackoverflow.com/a/1744518/1326147&quot;&gt;&lt;em&gt;all your data is 100% in UTF-8&lt;/em&gt;&lt;/a&gt;, you may want to use the &lt;code&gt;mb_&lt;/code&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/1744518/1326147&quot;&gt;&lt;em&gt;すべてのデータが100％UTF-8&lt;/em&gt;&lt;/a&gt;であることを保証できない場合&lt;em&gt;は&lt;/em&gt; 、 &lt;code&gt;mb_&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="b09fd6a82cef6361ad80b45ebbcfda266a96e009" translate="yes" xml:space="preserve">
          <source>If you want anything more accurate than this, you'll have to start doing English language syntax parsing, and that's a pretty big can of worms (and assumes proper use of syntax, anyway, which isn't always a given).</source>
          <target state="translated">これ以上の正確さを求めるのであれば、英語の構文解析を始めなければなりませんが、これはかなり大きな問題です(構文の適切な使用を前提としていますが、これは常に与えられたものではありません)。</target>
        </trans-unit>
        <trans-unit id="e8f50c16e936b75ab4e2005421136e0198edf974" translate="yes" xml:space="preserve">
          <source>If you want to avoid the &quot;falsey&quot; and &quot;truthy&quot; problem, you can use substr_count:</source>
          <target state="translated">&quot;falsey &quot;と &quot;truthy &quot;の問題を避けたい場合は、substr_countを使用することができます。</target>
        </trans-unit>
        <trans-unit id="068ce11b70ff847aa349c2e01c1c982a84e0bfdd" translate="yes" xml:space="preserve">
          <source>If you want to check if the string contains several specifics words, you can do:</source>
          <target state="translated">文字列に複数の特定語が含まれているかどうかを確認したい場合は、このようにします。</target>
        </trans-unit>
        <trans-unit id="8c9649b02c5520357914939e07ddb195baefdc95" translate="yes" xml:space="preserve">
          <source>In PHP, the best way to verify if a string contains a certain substring, is to use a simple helper function like this:</source>
          <target state="translated">PHPでは、文字列に特定の部分文字列が含まれているかどうかを確認する最良の方法は、 以下のような単純なヘルパー関数を使用することです。</target>
        </trans-unit>
        <trans-unit id="0944f82b5ffe8e68399c6e203bfeb6491b34006e" translate="yes" xml:space="preserve">
          <source>In order to find a 'word', rather than the occurrence of a series of letters that could in fact be a part of another word, the following would be a good solution.</source>
          <target state="translated">単語」を見つけるためには、実際には別の単語の一部である可能性のある文字が連続して発生するのではなく、次のようにすると良い解決策になります。</target>
        </trans-unit>
        <trans-unit id="32cdcd308cc39dd176a93ce07644fddfb6a72f8d" translate="yes" xml:space="preserve">
          <source>It can be done in three different ways:</source>
          <target state="translated">それは3つの方法で行うことができます。</target>
        </trans-unit>
        <trans-unit id="471b011a086e49e68c14b691be41feb79ca9ef15" translate="yes" xml:space="preserve">
          <source>It sounds difficult but is surprisingly easy.</source>
          <target state="translated">難しそうですが、意外と簡単です。</target>
        </trans-unit>
        <trans-unit id="0a69fd82c05b687cc1c6fc980796c044246e1001" translate="yes" xml:space="preserve">
          <source>It's a bit slower than strpos but it avoids the comparison problems.</source>
          <target state="translated">ストポよりは少し遅いですが、比較問題を回避できます。</target>
        </trans-unit>
        <trans-unit id="8fefbf5fa8ffae8b83fd2f9f21c6c5bcc031055d" translate="yes" xml:space="preserve">
          <source>Lot of answers that use &lt;a href=&quot;http://php.net/manual/en/function.substr-count.php&quot;&gt;&lt;code&gt;substr_count&lt;/code&gt;&lt;/a&gt; checks if the result is &lt;code&gt;&amp;gt;0&lt;/code&gt;. But since the &lt;code&gt;if&lt;/code&gt; statement considers zero the &lt;a href=&quot;http://php.net/manual/en/types.comparisons.php&quot;&gt;same as false&lt;/a&gt;, you can avoid that check and write directly:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.substr-count.php&quot;&gt; &lt;code&gt;substr_count&lt;/code&gt; &lt;/a&gt;を使用する多くの回答は、結果が &lt;code&gt;&amp;gt;0&lt;/code&gt; かどうかをチェックします。 しかし、 &lt;code&gt;if&lt;/code&gt; ステートメントはゼロ&lt;a href=&quot;http://php.net/manual/en/types.comparisons.php&quot;&gt;をfalseと同じ&lt;/a&gt;と見なすため、そのチェックを回避して直接書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="a003609987c3e7e1f11c9f4ce341edc37355c80b" translate="yes" xml:space="preserve">
          <source>Make use of &lt;strong&gt;case-insensitve matching&lt;/strong&gt; using &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos()&lt;/code&gt; &lt;/a&gt;を使用して、 &lt;strong&gt;大文字と小文字を区別しないマッチング&lt;/strong&gt;を利用します 。</target>
        </trans-unit>
        <trans-unit id="45dc916072b135e579c2ee41d82c2f641b8922e7" translate="yes" xml:space="preserve">
          <source>Maybe you could use something like this:</source>
          <target state="translated">こんな感じのものを使ってもいいかもしれませんね。</target>
        </trans-unit>
        <trans-unit id="1dac38c99792d6c78db01b0498112d26dbe98bc4" translate="yes" xml:space="preserve">
          <source>MySQL Fulltext Search Score Explained</source>
          <target state="translated">MySQL フルテキスト検索スコアの解説</target>
        </trans-unit>
        <trans-unit id="a264d1851ace7e5dfc514edbe47e27ca1df83f6d" translate="yes" xml:space="preserve">
          <source>Note that the use of &lt;code&gt;!== false&lt;/code&gt; is deliberate (neither &lt;code&gt;!= false&lt;/code&gt; nor &lt;code&gt;=== true&lt;/code&gt; will return the desired result); &lt;code&gt;strpos()&lt;/code&gt; returns either the offset at which the needle string begins in the haystack string, or the boolean &lt;code&gt;false&lt;/code&gt; if the needle isn't found. Since 0 is a valid offset and 0 is &quot;falsey&quot;, we can't use simpler constructs like &lt;code&gt;!strpos($a, 'are')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!== false&lt;/code&gt; 使用は意図的なものであることに注意してください（ &lt;code&gt;!= false&lt;/code&gt; も &lt;code&gt;=== true&lt;/code&gt; も目的の結果を返しません）。 &lt;code&gt;strpos()&lt;/code&gt; は、 haystack文字列で針の文字列が始まるオフセットを返すか、針が見つからない場合はブール値の &lt;code&gt;false&lt;/code&gt; を返します。 0は有効なオフセットであり、0は「偽」であるため、 &lt;code&gt;!strpos($a, 'are')&lt;/code&gt; ような単純な構成を使用することはできません。</target>
        </trans-unit>
        <trans-unit id="cb3314fdcfc00e6c1e40e9271e52bb518e86f0b6" translate="yes" xml:space="preserve">
          <source>Now, this can be quite problematic in some cases as the $search string isn't sanitized in any way, I mean, it might not pass the check in some cases as if &lt;code&gt;$search&lt;/code&gt; is a user input they can add some string that might behave like some different regular expression...</source>
          <target state="translated">$ search文字列がどのようにもサニタイズされていないため、これは場合によってはかなり問題になる可能性があります。つまり、 &lt;code&gt;$search&lt;/code&gt; がユーザー入力であるかのように、チェックにパスしない場合があります。いくつかの異なる正規表現のように動作します...</target>
        </trans-unit>
        <trans-unit id="9b517bf2bb3a82c47f3f403dd4bbcdb4056e9a30" translate="yes" xml:space="preserve">
          <source>On the performance side, &lt;code&gt;strpos&lt;/code&gt; is about three times faster and have in mind, when I did one million compares at once, it took &lt;a href=&quot;https://secure.php.net/manual/en/function.preg-match.php&quot;&gt;&lt;code&gt;preg_match&lt;/code&gt;&lt;/a&gt; 1.5 seconds to finish and for &lt;code&gt;strpos&lt;/code&gt; it took 0.5 seconds.</source>
          <target state="translated">パフォーマンスの面では、 &lt;code&gt;strpos&lt;/code&gt; の方が約3倍高速であり、100万回の比較を一度に行った場合、 &lt;a href=&quot;https://secure.php.net/manual/en/function.preg-match.php&quot;&gt; &lt;code&gt;preg_match&lt;/code&gt; &lt;/a&gt;が完了するまでに1.5秒かかり、 &lt;code&gt;strpos&lt;/code&gt; の場合は0.5秒かかりました。</target>
        </trans-unit>
        <trans-unit id="b8dd4ac4674e94b729896ef5113fca86f853ef58" translate="yes" xml:space="preserve">
          <source>One way to do this and to specify the separators is using &lt;code&gt;preg_split&lt;/code&gt; (&lt;a href=&quot;http://php.net/manual/en/function.preg-split.php&quot;&gt;doc&lt;/a&gt;):</source>
          <target state="translated">これを行い、区切り文字を指定する1つの方法は、 &lt;code&gt;preg_split&lt;/code&gt; （ &lt;a href=&quot;http://php.net/manual/en/function.preg-split.php&quot;&gt;doc&lt;/a&gt; ）を使用することです 。</target>
        </trans-unit>
        <trans-unit id="f21f13bdb437a884fb06e17b0896b9b0d7f10759" translate="yes" xml:space="preserve">
          <source>One way to mitigate this would be to use a regular expression coupled with &lt;a href=&quot;http://www.regular-expressions.info/wordboundaries.html&quot;&gt;word boundaries&lt;/a&gt; (&lt;code&gt;\b&lt;/code&gt;):</source>
          <target state="translated">これを軽減する1つの方法は、 &lt;a href=&quot;http://www.regular-expressions.info/wordboundaries.html&quot;&gt;単語の境界&lt;/a&gt; （ &lt;code&gt;\b&lt;/code&gt; ）と組み合わせた正規表現を使用することです。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="2f2dc7f1d5c30b526851de85106e46920df9b647" translate="yes" xml:space="preserve">
          <source>Peer to SamGoody and Lego Stormtroopr comments.</source>
          <target state="translated">Peer to SamGoodyとLego Stormtrooprのコメント。</target>
        </trans-unit>
        <trans-unit id="edc3a262e579e4f18107ab1571c94ef9e25076ad" translate="yes" xml:space="preserve">
          <source>Point to note: The strstr() function is case-sensitive. For a case-insensitive search, use the &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr()&lt;/a&gt; function.</source>
          <target state="translated">注意点：strstr（）関数は大文字と小文字を区別します。 大文字と小文字を区別しない検索の場合は、 &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr（）&lt;/a&gt;関数を使用します。</target>
        </trans-unit>
        <trans-unit id="991a6a91ca7eeccb09411cc8f7609f2065f9d754" translate="yes" xml:space="preserve">
          <source>Replace words with others which have an identical or similar meaning. 
(ex:replace instances of 'hungrily' and 'hungry' with 'hunger')</source>
          <target state="translated">単語を、同一または類似の意味を持つ他の単語に置き換える。(例:'hungrily' と 'hungry' のインスタンスを 'hunger' に置き換える)</target>
        </trans-unit>
        <trans-unit id="c61ea5e0f58b3846041d08ca013157e2727368bf" translate="yes" xml:space="preserve">
          <source>Suppose I have the code above, what is the correct way to write the statement &lt;code&gt;if ($a contains 'are')&lt;/code&gt;?</source>
          <target state="translated">上記のコードがあるとすると &lt;code&gt;if ($a contains 'are')&lt;/code&gt; のステートメントの正しい記述方法は何ですか？</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="fba0c98c0a3e78e3d12ddcb4cfcf74e9fa3dd5eb" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; at the beginning of &quot;area&quot;</source>
          <target state="translated">&quot;area &quot;の頭にある &quot;are &quot;は</target>
        </trans-unit>
        <trans-unit id="65750dec72e69bd6ff39a4cd067052598124521b" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; at the end of &quot;hare&quot;</source>
          <target state="translated">&quot;うさぎ &quot;の語尾にある &quot;are &quot;は</target>
        </trans-unit>
        <trans-unit id="f9f8a2f0a59aac465b7b2e5829132ebadacd4d79" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in &quot;What _are_ you thinking?&quot;</source>
          <target state="translated">&quot;What _are_you think? &quot;の &quot;are &quot;は、&quot;What _are_you think? &quot;の &quot;are &quot;です。</target>
        </trans-unit>
        <trans-unit id="ff1600ce3aceaa25995ea3bed5fa16ea9e7f9d0f" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in &quot;lol u dunno wut those are4?&quot;</source>
          <target state="translated">&quot;Lol u dunno wut those are4? &quot;の &quot;are &quot;は、&quot;Lol u dunno wut those are4? &quot;の &quot;are &quot;です。</target>
        </trans-unit>
        <trans-unit id="6e73ec58021d66e8d244453eb8eecab178cd95e3" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in the middle of &quot;fares&quot;</source>
          <target state="translated">&quot;運賃 &quot;の途中の &quot;である &quot;は</target>
        </trans-unit>
        <trans-unit id="af141695ab878d911b750be60dedc56b44a1366b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; at the end of regular expression changes regular expression to be case-insensitive, if you do not want that, you can leave it out.</source>
          <target state="translated">正規表現の最後にある &lt;code&gt;i&lt;/code&gt; は、正規表現の大文字と小文字を区別しないように変更します。これを望まない場合は、省略できます。</target>
        </trans-unit>
        <trans-unit id="a58a61579fa10e87cfbc17dea3a1e7d4dee7a592" translate="yes" xml:space="preserve">
          <source>The function below also works and does not depend on any other function; it uses only native PHP string manipulation. Personally, I do not recommend this, but you can see how it works:</source>
          <target state="translated">以下の関数も動作し、他の関数に依存することなく、ネイティブのPHPの文字列操作のみを使用しています。個人的にはあまりお勧めできませんが、どのように動作するかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="f06677169500917274915f9ad5cfaf385a03d220" translate="yes" xml:space="preserve">
          <source>The reduction of numeric values by reducing precision are other ways of normalising the text.</source>
          <target state="translated">精度を落として数値を小さくすることも、テキストを正規化するための他の方法です。</target>
        </trans-unit>
        <trans-unit id="8acbf1d45a648165adc6a6e8fdf2236bcdcc9869" translate="yes" xml:space="preserve">
          <source>The replacement of colour names with their hexadecimal equivalents</source>
          <target state="translated">色名を16進数で置き換える</target>
        </trans-unit>
        <trans-unit id="7bdbb776fba5a8dc6853756dead688035a67cceb" translate="yes" xml:space="preserve">
          <source>The short-hand version</source>
          <target state="translated">ショートハンド版</target>
        </trans-unit>
        <trans-unit id="074eb46fa2eab2604e12769117a414a5c815cc4b" translate="yes" xml:space="preserve">
          <source>The strpos function works fine, but if you want to do &lt;code&gt;case-insensitive&lt;/code&gt; checking for a word in a paragraph then you can make use of the &lt;code&gt;stripos&lt;/code&gt; function of &lt;code&gt;PHP&lt;/code&gt;.</source>
          <target state="translated">strpos関数は問題なく機能しますが、段落内の単語の &lt;code&gt;case-insensitive&lt;/code&gt; チェックを行う場合は、 &lt;code&gt;PHP&lt;/code&gt; の &lt;code&gt;stripos&lt;/code&gt; 関数を使用できます 。</target>
        </trans-unit>
        <trans-unit id="fe39f4f56248c0ed3b837778f579013127d494e1" translate="yes" xml:space="preserve">
          <source>There are plenty of improvements to be made
but the model provides a way of getting good results from natural queries, 
which don't have boolean operators such as &lt;code&gt;strpos()&lt;/code&gt;, &lt;code&gt;preg_match()&lt;/code&gt;, &lt;code&gt;strstr()&lt;/code&gt; or &lt;code&gt;stristr()&lt;/code&gt;.</source>
          <target state="translated">行うべき改善点はたくさんありますが、モデルは、 &lt;code&gt;strpos()&lt;/code&gt; 、 &lt;code&gt;preg_match()&lt;/code&gt; 、 strstr（） 、 stristr（）などのブール演算子を持たない自然なクエリから良い結果を得る方法を提供します。</target>
        </trans-unit>
        <trans-unit id="d219fd4683f024b1b46ac4b7362bae7eb53df97b" translate="yes" xml:space="preserve">
          <source>This is the idea of the vector space model, &lt;strong&gt;not far from how SQL full-text search works:&lt;/strong&gt;</source>
          <target state="translated">これはベクトル空間モデルの考え方であり、 &lt;strong&gt;SQLの全文検索が機能する方法&lt;/strong&gt;に&lt;strong&gt;はほど遠くないものです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="281072b73957e4edbd3e2582a1cfa67bfbc65be8" translate="yes" xml:space="preserve">
          <source>This is useful to avoid spam when sending emails for example.</source>
          <target state="translated">例えばメールを送信する際にスパムを回避するのに便利です。</target>
        </trans-unit>
        <trans-unit id="8654cbc27d2dd80342d3a1c9c6aed7df2c779cab" translate="yes" xml:space="preserve">
          <source>This means the string has to be resolved into words (see note below).</source>
          <target state="translated">これは、文字列を単語に分解しなければならないことを意味します(以下の注を参照してください)。</target>
        </trans-unit>
        <trans-unit id="51a160776c2c7b3eab04ee3c79f29c6483cb965a" translate="yes" xml:space="preserve">
          <source>This method doesn't have the same false positives noted above, but it does have some edge cases of its own.  Word boundaries match on non-word characters (&lt;code&gt;\W&lt;/code&gt;), which are going to be anything that isn't &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;, or &lt;code&gt;_&lt;/code&gt;.  That means digits and underscores are going to be counted as word characters and scenarios like this will fail:</source>
          <target state="translated">このメソッドには、上記と同じ誤検知はありませんが、独自のエッジケースがいくつかあります。 単語の境界は、 &lt;code&gt;a-z&lt;/code&gt; 、 &lt;code&gt;A-Z&lt;/code&gt; 、 &lt;code&gt;0-9&lt;/code&gt; 、または &lt;code&gt;_&lt;/code&gt; 以外の任意の文字になる非単語文字（ &lt;code&gt;\W&lt;/code&gt; ）に一致します。 つまり、数字とアンダースコアは単語文字としてカウントされ、次のようなシナリオは失敗します。</target>
        </trans-unit>
        <trans-unit id="814d677a8f676b10f82ac5b818657779e061b6f0" translate="yes" xml:space="preserve">
          <source>To check if &lt;em&gt;not&lt;/em&gt; present, add the &lt;code&gt;!&lt;/code&gt; operator:</source>
          <target state="translated">存在し&lt;em&gt;ない&lt;/em&gt;かどうかを確認するには、 &lt;code&gt;!&lt;/code&gt; オペレーター：</target>
        </trans-unit>
        <trans-unit id="65c66e28ac6f1c0e38ec5e9659847cadea78cb2d" translate="yes" xml:space="preserve">
          <source>To combine both sets of functionality into a single multi-purpose function (including with selectable case sensitivity), you could use something like this:</source>
          <target state="translated">両方の機能を1つの多目的関数にまとめるには(大文字小文字の区別を選択できるようにするなど)、次のようにします。</target>
        </trans-unit>
        <trans-unit id="10edf5fed7899dea96bf80a0ad1840566ed6e1a4" translate="yes" xml:space="preserve">
          <source>To determine whether a string contains another string you can use the PHP function &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;strpos()&lt;/a&gt;.</source>
          <target state="translated">文字列に別の文字列が含まれているかどうかを確認するには、PHP関数&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;strpos（）を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="16f2e11c8284a6bf0ac0d263cb869b551c3cca3e" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;&lt;code&gt;strstr()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.stristr.php&quot;&gt;&lt;code&gt;stristr()&lt;/code&gt;&lt;/a&gt; if your search should be case insensitive would be another option.</source>
          <target state="translated">検索で大文字と小文字を区別しない場合は、 &lt;a href=&quot;http://php.net/manual/en/function.stristr.php&quot;&gt; &lt;code&gt;stristr()&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt; &lt;code&gt;strstr()&lt;/code&gt; &lt;/a&gt;またはstristr（）を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="efdcb8e898f459b234a8181ba616ea969d0119ad" translate="yes" xml:space="preserve">
          <source>What's the difference?  Substrings can appear within other words:</source>
          <target state="translated">違いは何ですか?基語は他の単語の中に現れることがあります。</target>
        </trans-unit>
        <trans-unit id="aa590c482271336764621e55078baf0c591d5536" translate="yes" xml:space="preserve">
          <source>While most of these answers will tell you if a substring appears in your string, that's usually not what you want if you're looking for a particular &lt;em&gt;word&lt;/em&gt;, and not a &lt;em&gt;substring&lt;/em&gt;.</source>
          <target state="translated">これらの回答のほとんどは、部分文字列が文字列に出現するかどうかを示しますが、通常、特定の&lt;em&gt;単語&lt;/em&gt;ではなく部分文字列を検索する場合は、これは望ましくありません。</target>
        </trans-unit>
        <trans-unit id="258937995fc341d4744a414cf73e47fe8f6bacc7" translate="yes" xml:space="preserve">
          <source>With the samples above, both &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; contains &lt;code&gt;$c&lt;/code&gt;, but you may want your function to tell you that only &lt;code&gt;$a&lt;/code&gt; contains &lt;code&gt;$c&lt;/code&gt;.</source>
          <target state="translated">上記のサンプルで &lt;code&gt;$a&lt;/code&gt; 、 &lt;code&gt;$b&lt;/code&gt; と$ bの両方に &lt;code&gt;$c&lt;/code&gt; が含まれていますが、関数で &lt;code&gt;$a&lt;/code&gt; だけに &lt;code&gt;$c&lt;/code&gt; が含まれていることを通知する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="fa883bf0d02de1e50fb3029d25f98235c9f50d88" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;strpos()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;strpos()&lt;/code&gt; 関数を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="048e7d27353c157dc1b5bc47ecb679187e0f6ed6" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos()&lt;/code&gt;&lt;/a&gt; function which is used to find the occurrence of one string inside another one:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos()&lt;/code&gt; &lt;/a&gt;関数を使用して、別の文字列内の1つの文字列の出現を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="54493c19dbfc90ba47d4dd06b13bebcfabf9e240" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;strstr&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;strstr&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="a6ce4df6c8750da05b0d98658e1056a1f84f5f17" translate="yes" xml:space="preserve">
          <source>You could use regular expressions, it's better for word matching compared to &lt;code&gt;strpos&lt;/code&gt; as mentioned by other users it will also return true for strings such as fare, care, stare, etc. This can simply be avoided in regular expression by using word boundaries.</source>
          <target state="translated">正規表現を使用することもできます。他のユーザーが言及しているように、 &lt;code&gt;strpos&lt;/code&gt; に比べて単語照合の方が優れています。運賃、世話、凝視などの文字列に対してもtrueを返します。これは、単語の境界を使用することで、正規表現で簡単に回避できます。</target>
        </trans-unit>
        <trans-unit id="a0bec4b988172a1d14d0a06bdba132b97b07f5c8" translate="yes" xml:space="preserve">
          <source>You may notice that the previous solutions are not an answer for the word being used as a prefix for another. In order to use your example:</source>
          <target state="translated">前の解答は、別の単語の接頭語として使用されている単語の答えではないことに気づくかもしれません。あなたの例を使うために</target>
        </trans-unit>
        <trans-unit id="a932d9c5bd36cc1e640ddd6ae01856aa33464c06" translate="yes" xml:space="preserve">
          <source>You need to use identical/not identical operators because strpos can return 0 as it's index value. If you like ternary operators, consider using the following (seems a little backwards I'll admit):</source>
          <target state="translated">strpos はインデックス値として 0 を返すことができるので、同一ではなく同一の演算子を使う必要があります。もし三項演算子が好きなら、以下のように使うことを検討してみてください(少し後ろ向きな感じがしますが、認めます)。</target>
        </trans-unit>
        <trans-unit id="17a4eaa70e6fca11cd3a0594e0e6ae22bcf5f5dd" translate="yes" xml:space="preserve">
          <source>You should use case Insensitive format,so if the entered value is in &lt;code&gt;small&lt;/code&gt; or &lt;code&gt;caps&lt;/code&gt; it wont matter.</source>
          <target state="translated">大文字と小文字を区別しない形式を使用する必要があるため、入力した値が &lt;code&gt;small&lt;/code&gt; 場合や &lt;code&gt;caps&lt;/code&gt; 場合は問題になりません。</target>
        </trans-unit>
        <trans-unit id="9411b3f7d38c850e9e0ce1838744755ad62458f6" translate="yes" xml:space="preserve">
          <source>can't search for multiple words</source>
          <target state="translated">複数の単語を検索できない</target>
        </trans-unit>
        <trans-unit id="15bf9afce4ffa3fbf44c7e834d049e617054404b" translate="yes" xml:space="preserve">
          <source>faster indexing and a consequently faster search.</source>
          <target state="translated">より高速なインデックス作成と、その結果としてより高速な検索が可能になります。</target>
        </trans-unit>
        <trans-unit id="37ab7e92198730c935587e8eab4e183e80b042a6" translate="yes" xml:space="preserve">
          <source>less disk I/O</source>
          <target state="translated">少ないディスクIO</target>
        </trans-unit>
        <trans-unit id="f262c494e86d759eb3e2029edccdeaf071231d09" translate="yes" xml:space="preserve">
          <source>results are unranked</source>
          <target state="translated">成績不振</target>
        </trans-unit>
        <trans-unit id="274e89ab94a3541c57aa9a85d106d78e5be3f50e" translate="yes" xml:space="preserve">
          <source>thereby reducing index size and resulting in less storage requirement</source>
          <target state="translated">これにより、インデックスサイズが小さくなり、ストレージ要件が少なくなります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
