<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4366730">
    <body>
      <group id="4366730">
        <trans-unit id="536930aa45c4f9ebe04ec4eee9fe774d8b05ff5b" translate="yes" xml:space="preserve">
          <source>1- stristr()</source>
          <target state="translated">1-stristr()</target>
        </trans-unit>
        <trans-unit id="9c04eee059ec9710c163e4d720492795c8a32060" translate="yes" xml:space="preserve">
          <source>2- strpos()</source>
          <target state="translated">2-strpos()</target>
        </trans-unit>
        <trans-unit id="ae4b45ccf79b06e3929e1a3633b7a35b68e5cbbf" translate="yes" xml:space="preserve">
          <source>3- preg_match()</source>
          <target state="translated">3-preg_match()</target>
        </trans-unit>
        <trans-unit id="8d1a614572a1ef0c19a362e30bcd32eef314aab4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos&lt;/code&gt;&lt;/a&gt; finds the position of the first occurrence of a case-insensitive substring in a string.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos&lt;/code&gt; &lt;/a&gt;查找不区分大小写的子字符串在字符串中首次出现的位置。</target>
        </trans-unit>
        <trans-unit id="d7edf7695232ace28ffa32c8559ecb9b1e5ea944" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos&lt;/code&gt;&lt;/a&gt; finds the position of the first occurrence of a case-sensitive substring in a string.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos&lt;/code&gt; &lt;/a&gt;查找字符串中首次出现的区分大小写的子字符串的位置。</target>
        </trans-unit>
        <trans-unit id="65db47ef4129dadb5b064de72e4a9344d03d186d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;Look at &lt;code&gt;strpos()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;看一下 &lt;code&gt;strpos()&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="161a91404619d6734e80cd0778e5e2eb37c87d8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$caseSensitive ? A : B&lt;/code&gt; selects either &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos&lt;/code&gt;&lt;/a&gt; to do the work, depending on the value of &lt;code&gt;$caseSensitive&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$caseSensitive ? A : B&lt;/code&gt; A：B根据 &lt;code&gt;$caseSensitive&lt;/code&gt; 的值选择&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos&lt;/code&gt; &lt;/a&gt;进行工作。</target>
        </trans-unit>
        <trans-unit id="8e43f3e39917183f03b6c7d8df65a3d6caaca77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myFunction($haystack, $needle) === FALSE ? FALSE : TRUE&lt;/code&gt; ensures that &lt;code&gt;myFunction&lt;/code&gt; always returns a boolean and fixes unexpected behavior when the index of the substring is 0.</source>
          <target state="translated">&lt;code&gt;myFunction($haystack, $needle) === FALSE ? FALSE : TRUE&lt;/code&gt; FALSE：TRUE确保 &lt;code&gt;myFunction&lt;/code&gt; 始终返回布尔值，并在子字符串的索引为0时修复意外行为。</target>
        </trans-unit>
        <trans-unit id="a38601451a7271300a3862930f2409a619504b87" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Optionally eliminating redundancy prior to search the words&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（可选）在搜索单词之前消除冗余&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b239b39dd3ea5d3bc28ab5e6594623814ae44575" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Normalisation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.归一化&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c2da9093478005107c83bcb253a85f687fcb20e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Stopword elimination&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.消除停用词&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15f70347f13635fdde48efd621a04e1cd494add" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Dictionary substitution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.字典替换&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d4d8c048007e19655046e44f48cfa683d97aa7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;情况1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b17fa346bb4f567be4a05b73d079ef9eeb1da6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;案例2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d2e913dec4051855fb256e532411a9b529ea94d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;案例3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4219c5f6fe25ad668c412bff701696037aef1b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAUTION:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CAUTION:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcde4902afc8a02e4348242ab9385feb6c8fa9c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issues with the other boolean search methods such as &lt;code&gt;strpos()&lt;/code&gt;, &lt;code&gt;preg_match()&lt;/code&gt;, &lt;code&gt;strstr()&lt;/code&gt; or &lt;code&gt;stristr()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;其他布尔搜索方法（例如 &lt;code&gt;strpos()&lt;/code&gt; ， &lt;code&gt;preg_match()&lt;/code&gt; ， &lt;code&gt;strstr()&lt;/code&gt; 或 &lt;code&gt;stristr()&lt;/code&gt; 的问题&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7666b304a8fca7faed968cac02ec2f4fede0f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTA BENE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;诺塔&amp;middot;贝内&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00c6ca567e32596c84c50e0fb28233adda888901" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Here we do not mean word for every sequence of symbols.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这里我们并不是指每个符号序列的单词。</target>
        </trans-unit>
        <trans-unit id="0464dc38e1fc7e588f4c179f040c57144d419a6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP method based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_space_model&quot;&gt;Vector Space Model&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf (term frequency&amp;ndash;inverse document frequency):&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;基于&lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_space_model&quot;&gt;向量空间模型&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf（项频率-逆文档频率）的&lt;/a&gt; PHP方法：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="450025855baecd41e523dc05eafa16f85db4098f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHPCode Sample with output&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PHPCode示例与输出&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b7fe3ad4bb795df9d41e53255576530192a9be9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESOURCES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESOURCES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3d9b2805e24d71fd7dbe60ed49798186b321048" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESULT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESULT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e8719c6c93a3d522fb7415c04094d2b50b9a4f84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESULTS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESULTS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d03f4a89fe7c2757c20c5c42a24c135ce9e8e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Without using an inbuilt function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不使用内置函数：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa1853953b71f4c41b3cc95fb3cca78efdd9c424" translate="yes" xml:space="preserve">
          <source>A &quot;word&quot; character is any letter or digit or the underscore character,
  that is, any character which can be part of a Perl &quot; word &quot;. The
  definition of letters and digits is controlled by PCRE's character
  tables, and may vary if locale-specific matching is taking place (..)</source>
          <target state="translated">字母 &quot;字符是指任何字母或数字或下划线字符,也就是说,任何可以成为Perl &quot;字 &quot;的一部分的字符。字母和数字的定义是由 PCRE 的字符表控制的,如果在进行特定的本地匹配,则可能会有不同的定义(...)</target>
        </trans-unit>
        <trans-unit id="f8f3f2943f82691039b22b2ebdeff76dd86282d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;==&lt;/code&gt; sign is a comparison and tests whether the variable / expression / constant to the left has the same value as the variable / expression / constant to the right.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 符号是一个比较，用于测试左侧的变量/表达式/常量是否与右侧的变量/表达式/常量具有相同的值。</target>
        </trans-unit>
        <trans-unit id="b7e4f92de169b796d2edbe690758dfdf768e8e70" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;===&lt;/code&gt; sign is a comparison to see whether two variables / expresions / constants are equal &lt;code&gt;AND&lt;/code&gt; have the same type - i.e. both are strings or both are integers.</source>
          <target state="translated">一个 &lt;code&gt;===&lt;/code&gt; 符号是一个比较，以查看两个变量/表达式/常量是否相等 &lt;code&gt;AND&lt;/code&gt; 具有相同的类型-即，它们都是字符串还是都是整数。</target>
        </trans-unit>
        <trans-unit id="e4920abb4f3b8892883bf5a41623c4aab2b1f548" translate="yes" xml:space="preserve">
          <source>A good article to understand why is &lt;em&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a&gt;&lt;/em&gt; by &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Joel_Spolsky&quot;&gt;Joel Spolsky&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">很好的一篇文章，为什么&lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Joel_Spolsky&quot;&gt;Joel Spolsky&lt;/a&gt;&lt;/em&gt;解释了为什么&lt;em&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;绝对&lt;/a&gt;&lt;/em&gt;是&lt;em&gt;每个软件开发人员绝对绝对肯定要了解的Unicode和字符集（无借口！）&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4dca82ce7301d5a56f3ffda9ea5d842b28eb7ec" translate="yes" xml:space="preserve">
          <source>A practical definition of word is in the sense the PCRE regular expression engine, where words are substrings consisting of word characters only, being separated by non-word characters.</source>
          <target state="translated">在PCRE正则表达式引擎的意义上,词的实际定义是指PCRE正则表达式引擎,其中词是仅由单词字符组成的子串,被非单词字符隔开。</target>
        </trans-unit>
        <trans-unit id="5ec194c4603c00b67980b557f9d17564cb709fe7" translate="yes" xml:space="preserve">
          <source>A run gives</source>
          <target state="translated">奔跑给</target>
        </trans-unit>
        <trans-unit id="41a9b657064aaec58c7a71735974461119393ee2" translate="yes" xml:space="preserve">
          <source>A simple match for are could look something like this:</source>
          <target state="translated">一个简单的匹配可以是这样的。</target>
        </trans-unit>
        <trans-unit id="5005dc287716aef5b1fa0a49374df254f53b0a13" translate="yes" xml:space="preserve">
          <source>Also, here's a great tool for testing and seeing explanations of various regular expressions &lt;a href=&quot;https://regex101.com/&quot;&gt;Regex101&lt;/a&gt;</source>
          <target state="translated">另外，这是一个测试和查看各种正则表达式&lt;a href=&quot;https://regex101.com/&quot;&gt;Regex101的&lt;/a&gt;解释的好工具</target>
        </trans-unit>
        <trans-unit id="154f98e219ba2d530ab470fcb920ed2cf84456ee" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;strstr()&lt;/a&gt; function. Something like:</source>
          <target state="translated">另一种选择是使用&lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;strstr（）&lt;/a&gt;函数。 就像是：</target>
        </trans-unit>
        <trans-unit id="30eb8eef8b6e9b1c537d3b8ca07b74300cc86462" translate="yes" xml:space="preserve">
          <source>Another option to finding the occurrence of a word from a string using &lt;a href=&quot;http://www.php.net/manual/en/function.strstr.php&quot;&gt;strstr()&lt;/a&gt; and &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr()&lt;/a&gt; is like the following:</source>
          <target state="translated">使用&lt;a href=&quot;http://www.php.net/manual/en/function.strstr.php&quot;&gt;strstr（）&lt;/a&gt;和&lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr（）&lt;/a&gt;从字符串中查找单词出现的另一种选择如下：</target>
        </trans-unit>
        <trans-unit id="1c001274549b8d9c38352b77098a207b33210a25" translate="yes" xml:space="preserve">
          <source>Another solution for a specific string:</source>
          <target state="translated">另一种是针对特定字符串的解决方案。</target>
        </trans-unit>
        <trans-unit id="059fd4a17ec8f277845903f637b570f56ea31b4d" translate="yes" xml:space="preserve">
          <source>Basically, if you're &lt;strong&gt;having trouble finding words with characters specific to some languages&lt;/strong&gt;, such as German, French, Portuguese, Spanish, etc. (e.g.: &lt;em&gt;&amp;auml;&lt;/em&gt;, &lt;em&gt;&amp;eacute;&lt;/em&gt;, &lt;em&gt;&amp;ocirc;&lt;/em&gt;, &lt;em&gt;&amp;ccedil;&lt;/em&gt;, &lt;em&gt;&amp;ordm;&lt;/em&gt;, &lt;em&gt;&amp;ntilde;&lt;/em&gt;), you may want to precede the functions with &lt;code&gt;mb_&lt;/code&gt;. Therefore, the accepted answer would use &lt;a href=&quot;http://php.net/manual/en/function.mb-strpos.php&quot;&gt;&lt;code&gt;mb_strpos&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.mb-stripos.php&quot;&gt;&lt;code&gt;mb_stripos&lt;/code&gt;&lt;/a&gt; (for case-insensitive matching) instead:</source>
          <target state="translated">基本上，如果您在&lt;strong&gt;查找带有某些语言特定字符的单词时遇到麻烦&lt;/strong&gt; ，例如德语，法语，葡萄牙语，西班牙语等（例如&lt;em&gt;&amp;auml;&lt;/em&gt; ， &lt;em&gt;&amp;eacute;&lt;/em&gt; ， &lt;em&gt;&amp;ocirc;&lt;/em&gt; ， &lt;em&gt;&amp;ccedil;&lt;/em&gt; ， &lt;em&gt;&amp;ordm;&lt;/em&gt; ， &lt;em&gt;&amp;ntilde;&lt;/em&gt; ），则可能需要先 &lt;code&gt;mb_&lt;/code&gt; 的功能。 因此，可接受的答案将使用&lt;a href=&quot;http://php.net/manual/en/function.mb-strpos.php&quot;&gt; &lt;code&gt;mb_strpos&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;http://php.net/manual/en/function.mb-stripos.php&quot;&gt; &lt;code&gt;mb_stripos&lt;/code&gt; &lt;/a&gt; （用于不区分大小写的匹配）：</target>
        </trans-unit>
        <trans-unit id="c6ac2ebe3d53f92da9f6857d844261f13d940aaa" translate="yes" xml:space="preserve">
          <source>Check if string contains specific words?</source>
          <target state="translated">检查字符串是否包含特定的单词?</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="995f64f15a13f374697065535435ba94d26464e7" translate="yes" xml:space="preserve">
          <source>Convert all text to lower case</source>
          <target state="translated">将所有文本转换为小写</target>
        </trans-unit>
        <trans-unit id="112d1f61745b16ccc0356f918f7a7be16bdd57d2" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;preg_match()&lt;/code&gt; if you only want to check if one string is contained in another string. Use &lt;code&gt;strpos()&lt;/code&gt; or &lt;code&gt;strstr()&lt;/code&gt; instead as they will be faster. (&lt;a href=&quot;http://in2.php.net/preg_match&quot;&gt;http://in2.php.net/preg_match&lt;/a&gt;)</source>
          <target state="translated">如果只想检查一个字符串是否包含在另一个字符串中，请不要使用 &lt;code&gt;preg_match()&lt;/code&gt; 。 请改用 &lt;code&gt;strpos()&lt;/code&gt; 或 &lt;code&gt;strstr()&lt;/code&gt; ,因为它们会更快。 （ &lt;a href=&quot;http://in2.php.net/preg_match&quot;&gt;http://in2.php.net/preg_match&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="771ca06d7bb1df15a66af37bb337725931a04e2f" translate="yes" xml:space="preserve">
          <source>Edit:
In order to search any part of the string, not just word by word, I would recommend using a regular expression like</source>
          <target state="translated">编辑:为了搜索字符串中的任何部分,而不仅仅是逐字搜索,我建议使用一个正则表达式,如</target>
        </trans-unit>
        <trans-unit id="a175d3309aa70f6eadc8fd006df92ee87672c066" translate="yes" xml:space="preserve">
          <source>Eliminate words from the text which carry no real meaning (like 'and', 'or', 'the', 'for', etc.)</source>
          <target state="translated">删除文中没有实际意义的词(如'和'、'或'、'的'、'的'、'的'、'的'等)。</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="f8838d8c3e8de7ea1720befe670b6ddecdfca0fa" translate="yes" xml:space="preserve">
          <source>Find the position of the first occurrence of a case-insensitive substring in a string.</source>
          <target state="translated">查找字符串中不区分大小写的子字符串的首次出现的位置。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="8e347c4e5e5f169d1f544caeabe3acbdeb0a1fd6" translate="yes" xml:space="preserve">
          <source>Further algorithmic measures (snowball) may be performed to further reduce words to their essential meaning.</source>
          <target state="translated">进一步的算法措施(滚雪球),可以将单词进一步缩小到其本质意义。</target>
        </trans-unit>
        <trans-unit id="868013052501a3915b42071b147883eee03a3899" translate="yes" xml:space="preserve">
          <source>Here is a little utility function that is useful in situations like this</source>
          <target state="translated">这里有一个小效用函数,在这种情况下很有用</target>
        </trans-unit>
        <trans-unit id="640ccdb37a48eedfabd85e115efe42bf0f97e2b4" translate="yes" xml:space="preserve">
          <source>Here stripos finds needle in heystack &lt;strong&gt;without&lt;/strong&gt; considering case (small/caps).</source>
          <target state="translated">在这里，stripos在&lt;strong&gt;不&lt;/strong&gt;考虑大小写（小/大写）的情况下，在heystack中发现了针。</target>
        </trans-unit>
        <trans-unit id="828d73986d577dc553333bd6f21ac565c1fb423c" translate="yes" xml:space="preserve">
          <source>How do I check if a string contains a specific word</source>
          <target state="translated">如何检查一个字符串是否包含一个特定的单词?</target>
        </trans-unit>
        <trans-unit id="224b8efc0b9ac26641de6ae359e96fd868125065" translate="yes" xml:space="preserve">
          <source>I had some trouble with this, and finally I chose to create my own solution. Without using &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; engine:</source>
          <target state="translated">我对此有些麻烦，最后我选择创建自己的解决方案。 不使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;正则表达式&lt;/a&gt;引擎：</target>
        </trans-unit>
        <trans-unit id="a42d6e1c43dd12b71ad626eaa7d6b3ea6944040b" translate="yes" xml:space="preserve">
          <source>I'm a bit impressed that none of the answers here that used &lt;code&gt;strpos&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt; and similar functions mentioned &lt;a href=&quot;http://php.net/manual/en/ref.mbstring.php&quot;&gt;Multibyte String Functions&lt;/a&gt; yet (2015-05-08).</source>
          <target state="translated">令我印象深刻的是，这里没有使用 &lt;code&gt;strpos&lt;/code&gt; ， &lt;code&gt;strstr&lt;/code&gt; 和类似函数的答案提到&lt;a href=&quot;http://php.net/manual/en/ref.mbstring.php&quot;&gt;多字节字符串函数&lt;/a&gt; （2015-05-08）。</target>
        </trans-unit>
        <trans-unit id="fa8035d683dec343995234343194912e2e44077e" translate="yes" xml:space="preserve">
          <source>If the needle you are searching for is at the beginning of the haystack it will return position 0, if you do a &lt;code&gt;==&lt;/code&gt; compare that will not work, you will need to do a &lt;code&gt;===&lt;/code&gt;</source>
          <target state="translated">如果您要搜索的针头位于干草堆的开头，它将返回位置0，如果执行 &lt;code&gt;==&lt;/code&gt; 比较不起作用，则需要执行 &lt;code&gt;===&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="914d8946f736f2babcc727a583d93362c1a80a2b" translate="yes" xml:space="preserve">
          <source>If the word doesn't exist in the string then it will return false else it will return the position of the word.</source>
          <target state="translated">如果该词在字符串中不存在,那么它将返回false,否则将返回该词的位置。</target>
        </trans-unit>
        <trans-unit id="0ca72b4ba6418cfdc9d8f0766d5bbbaed69c8c46" translate="yes" xml:space="preserve">
          <source>If we could weight the terms in a string based on how representative they are of the string as a whole, 
we could order our results by the ones that best match the query.</source>
          <target state="translated">如果我们可以根据一个字符串中的术语在整个字符串中的代表性,对其进行加权,那么我们就可以根据最符合查询结果的术语进行排序。</target>
        </trans-unit>
        <trans-unit id="f22ff471b11f2348e549c1430ff4e7c026fa09ca" translate="yes" xml:space="preserve">
          <source>If we want to search for multiple words in a string the core problem is how we assign a weight to each one of them?</source>
          <target state="translated">如果我们想在一个字符串中搜索多个单词,核心问题是如何给每个单词分配一个权重?</target>
        </trans-unit>
        <trans-unit id="7301e6fd4a01ccad442ed786a4bba0c369969b9f" translate="yes" xml:space="preserve">
          <source>If you are looking for a PHP algorithm to &lt;strong&gt;rank search results based on proximity/relevance&lt;/strong&gt; of multiple words
here comes a quick and easy way of generating search results with PHP only:</source>
          <target state="translated">如果您正在寻找一种PHP算法来&lt;strong&gt;根据&lt;/strong&gt;多个单词的&lt;strong&gt;接近度/相关性&lt;/strong&gt;对&lt;strong&gt;搜索结果&lt;/strong&gt;进行&lt;strong&gt;排名&lt;/strong&gt; ，那么这里提供了一种仅使用PHP即可生成搜索结果的快捷方法：</target>
        </trans-unit>
        <trans-unit id="177529202720249ead729bcdcae74deef04b45b8" translate="yes" xml:space="preserve">
          <source>If you cannot guarantee that &lt;a href=&quot;https://stackoverflow.com/a/1744518/1326147&quot;&gt;&lt;em&gt;all your data is 100% in UTF-8&lt;/em&gt;&lt;/a&gt;, you may want to use the &lt;code&gt;mb_&lt;/code&gt; functions.</source>
          <target state="translated">如果您不能保证&lt;a href=&quot;https://stackoverflow.com/a/1744518/1326147&quot;&gt;&lt;em&gt;所有数据都是UTF-8中的100％&lt;/em&gt;&lt;/a&gt; ，则可能要使用 &lt;code&gt;mb_&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="b09fd6a82cef6361ad80b45ebbcfda266a96e009" translate="yes" xml:space="preserve">
          <source>If you want anything more accurate than this, you'll have to start doing English language syntax parsing, and that's a pretty big can of worms (and assumes proper use of syntax, anyway, which isn't always a given).</source>
          <target state="translated">如果你想得到比这更准确的东西,你必须开始做英语语法解析,这是个相当大的问题(而且假定语法使用得当,无论如何,这并不总是必然的)。</target>
        </trans-unit>
        <trans-unit id="e8f50c16e936b75ab4e2005421136e0198edf974" translate="yes" xml:space="preserve">
          <source>If you want to avoid the &quot;falsey&quot; and &quot;truthy&quot; problem, you can use substr_count:</source>
          <target state="translated">如果你想避免 &quot;falsey &quot;和 &quot;truthy &quot;问题,可以使用substr_count。</target>
        </trans-unit>
        <trans-unit id="068ce11b70ff847aa349c2e01c1c982a84e0bfdd" translate="yes" xml:space="preserve">
          <source>If you want to check if the string contains several specifics words, you can do:</source>
          <target state="translated">如果你想检查字符串中是否包含几个具体的单词,可以这样做。</target>
        </trans-unit>
        <trans-unit id="8c9649b02c5520357914939e07ddb195baefdc95" translate="yes" xml:space="preserve">
          <source>In PHP, the best way to verify if a string contains a certain substring, is to use a simple helper function like this:</source>
          <target state="translated">在PHP中,验证一个字符串是否包含某个子字符串的最好方法是使用一个简单的帮助函数,就像这样。</target>
        </trans-unit>
        <trans-unit id="0944f82b5ffe8e68399c6e203bfeb6491b34006e" translate="yes" xml:space="preserve">
          <source>In order to find a 'word', rather than the occurrence of a series of letters that could in fact be a part of another word, the following would be a good solution.</source>
          <target state="translated">为了找到一个 &quot;词&quot;,而不是一连串字母的出现,实际上可能是另一个词的一部分,下面是一个很好的解决办法。</target>
        </trans-unit>
        <trans-unit id="32cdcd308cc39dd176a93ce07644fddfb6a72f8d" translate="yes" xml:space="preserve">
          <source>It can be done in three different ways:</source>
          <target state="translated">它可以通过三种不同的方式来实现。</target>
        </trans-unit>
        <trans-unit id="471b011a086e49e68c14b691be41feb79ca9ef15" translate="yes" xml:space="preserve">
          <source>It sounds difficult but is surprisingly easy.</source>
          <target state="translated">这听起来很难,但出乎意料的容易。</target>
        </trans-unit>
        <trans-unit id="0a69fd82c05b687cc1c6fc980796c044246e1001" translate="yes" xml:space="preserve">
          <source>It's a bit slower than strpos but it avoids the comparison problems.</source>
          <target state="translated">它比strpos慢了一点,但避免了对比的问题。</target>
        </trans-unit>
        <trans-unit id="8fefbf5fa8ffae8b83fd2f9f21c6c5bcc031055d" translate="yes" xml:space="preserve">
          <source>Lot of answers that use &lt;a href=&quot;http://php.net/manual/en/function.substr-count.php&quot;&gt;&lt;code&gt;substr_count&lt;/code&gt;&lt;/a&gt; checks if the result is &lt;code&gt;&amp;gt;0&lt;/code&gt;. But since the &lt;code&gt;if&lt;/code&gt; statement considers zero the &lt;a href=&quot;http://php.net/manual/en/types.comparisons.php&quot;&gt;same as false&lt;/a&gt;, you can avoid that check and write directly:</source>
          <target state="translated">许多使用&lt;a href=&quot;http://php.net/manual/en/function.substr-count.php&quot;&gt; &lt;code&gt;substr_count&lt;/code&gt; &lt;/a&gt;的答案检查结果是否为 &lt;code&gt;&amp;gt;0&lt;/code&gt; 。 但是由于 &lt;code&gt;if&lt;/code&gt; 语句认为零&lt;a href=&quot;http://php.net/manual/en/types.comparisons.php&quot;&gt;与false相同&lt;/a&gt; ，因此您可以避免执行该检查并直接编写：</target>
        </trans-unit>
        <trans-unit id="a003609987c3e7e1f11c9f4ce341edc37355c80b" translate="yes" xml:space="preserve">
          <source>Make use of &lt;strong&gt;case-insensitve matching&lt;/strong&gt; using &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">通过&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos()&lt;/code&gt; &lt;/a&gt;使用&lt;strong&gt;不区分大小写的匹配&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="45dc916072b135e579c2ee41d82c2f641b8922e7" translate="yes" xml:space="preserve">
          <source>Maybe you could use something like this:</source>
          <target state="translated">也许你可以用这样的东西</target>
        </trans-unit>
        <trans-unit id="1dac38c99792d6c78db01b0498112d26dbe98bc4" translate="yes" xml:space="preserve">
          <source>MySQL Fulltext Search Score Explained</source>
          <target state="translated">MySQL全文搜索得分解释</target>
        </trans-unit>
        <trans-unit id="a264d1851ace7e5dfc514edbe47e27ca1df83f6d" translate="yes" xml:space="preserve">
          <source>Note that the use of &lt;code&gt;!== false&lt;/code&gt; is deliberate (neither &lt;code&gt;!= false&lt;/code&gt; nor &lt;code&gt;=== true&lt;/code&gt; will return the desired result); &lt;code&gt;strpos()&lt;/code&gt; returns either the offset at which the needle string begins in the haystack string, or the boolean &lt;code&gt;false&lt;/code&gt; if the needle isn't found. Since 0 is a valid offset and 0 is &quot;falsey&quot;, we can't use simpler constructs like &lt;code&gt;!strpos($a, 'are')&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;!== false&lt;/code&gt; 的使用是有意的（ &lt;code&gt;!= false&lt;/code&gt; 或 &lt;code&gt;=== true&lt;/code&gt; 都不会返回期望的结果）。 &lt;code&gt;strpos()&lt;/code&gt; 返回大海捞针字符串中针串开始的偏移量，或者如果找不到针，则返回布尔值 &lt;code&gt;false&lt;/code&gt; 。 由于0是一个有效的偏移量，而0是&amp;ldquo; falsey&amp;rdquo;，我们不能使用更简单的结构，如 &lt;code&gt;!strpos($a, 'are')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb3314fdcfc00e6c1e40e9271e52bb518e86f0b6" translate="yes" xml:space="preserve">
          <source>Now, this can be quite problematic in some cases as the $search string isn't sanitized in any way, I mean, it might not pass the check in some cases as if &lt;code&gt;$search&lt;/code&gt; is a user input they can add some string that might behave like some different regular expression...</source>
          <target state="translated">现在，在某些情况下这可能会很成问题，因为$ search字符串没有以任何方式进行消毒，我的意思是，在某些情况下，它可能无法通过检查，就像 &lt;code&gt;$search&lt;/code&gt; 是用户输入一样，他们可以添加一些可能表现得像一些不同的正则表达式...</target>
        </trans-unit>
        <trans-unit id="9b517bf2bb3a82c47f3f403dd4bbcdb4056e9a30" translate="yes" xml:space="preserve">
          <source>On the performance side, &lt;code&gt;strpos&lt;/code&gt; is about three times faster and have in mind, when I did one million compares at once, it took &lt;a href=&quot;https://secure.php.net/manual/en/function.preg-match.php&quot;&gt;&lt;code&gt;preg_match&lt;/code&gt;&lt;/a&gt; 1.5 seconds to finish and for &lt;code&gt;strpos&lt;/code&gt; it took 0.5 seconds.</source>
          <target state="translated">在性能方面， &lt;code&gt;strpos&lt;/code&gt; 大约快三倍，并且要记住，当我一次进行一百万次比较时， &lt;a href=&quot;https://secure.php.net/manual/en/function.preg-match.php&quot;&gt; &lt;code&gt;preg_match&lt;/code&gt; 用了&lt;/a&gt; 1.5秒完成，而 &lt;code&gt;strpos&lt;/code&gt; 用了0.5秒。</target>
        </trans-unit>
        <trans-unit id="b8dd4ac4674e94b729896ef5113fca86f853ef58" translate="yes" xml:space="preserve">
          <source>One way to do this and to specify the separators is using &lt;code&gt;preg_split&lt;/code&gt; (&lt;a href=&quot;http://php.net/manual/en/function.preg-split.php&quot;&gt;doc&lt;/a&gt;):</source>
          <target state="translated">一种执行此操作并指定分隔符的方法是使用 &lt;code&gt;preg_split&lt;/code&gt; （ &lt;a href=&quot;http://php.net/manual/en/function.preg-split.php&quot;&gt;doc&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="f21f13bdb437a884fb06e17b0896b9b0d7f10759" translate="yes" xml:space="preserve">
          <source>One way to mitigate this would be to use a regular expression coupled with &lt;a href=&quot;http://www.regular-expressions.info/wordboundaries.html&quot;&gt;word boundaries&lt;/a&gt; (&lt;code&gt;\b&lt;/code&gt;):</source>
          <target state="translated">减轻这种情况的一种方法是使用带有&lt;a href=&quot;http://www.regular-expressions.info/wordboundaries.html&quot;&gt;单词边界&lt;/a&gt; （ &lt;code&gt;\b&lt;/code&gt; ）的正则表达式：</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="2f2dc7f1d5c30b526851de85106e46920df9b647" translate="yes" xml:space="preserve">
          <source>Peer to SamGoody and Lego Stormtroopr comments.</source>
          <target state="translated">同行对SamGoody和Lego Stormtroopr评论。</target>
        </trans-unit>
        <trans-unit id="edc3a262e579e4f18107ab1571c94ef9e25076ad" translate="yes" xml:space="preserve">
          <source>Point to note: The strstr() function is case-sensitive. For a case-insensitive search, use the &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr()&lt;/a&gt; function.</source>
          <target state="translated">注意点：strstr（）函数区分大小写。 对于不区分大小写的搜索，请使用&lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr（）&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="991a6a91ca7eeccb09411cc8f7609f2065f9d754" translate="yes" xml:space="preserve">
          <source>Replace words with others which have an identical or similar meaning. 
(ex:replace instances of 'hungrily' and 'hungry' with 'hunger')</source>
          <target state="translated">用其他意思相同或相似的词代替。(如:将'hungrily'和'hunger'替换为'饥饿')</target>
        </trans-unit>
        <trans-unit id="c61ea5e0f58b3846041d08ca013157e2727368bf" translate="yes" xml:space="preserve">
          <source>Suppose I have the code above, what is the correct way to write the statement &lt;code&gt;if ($a contains 'are')&lt;/code&gt;?</source>
          <target state="translated">假设我有上面的代码， &lt;code&gt;if ($a contains 'are')&lt;/code&gt; ，写语句的正确方法是什么？</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="fba0c98c0a3e78e3d12ddcb4cfcf74e9fa3dd5eb" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; at the beginning of &quot;area&quot;</source>
          <target state="translated">&quot;地区 &quot;开头的 &quot;是 &quot;字样的 &quot;是&quot;</target>
        </trans-unit>
        <trans-unit id="65750dec72e69bd6ff39a4cd067052598124521b" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; at the end of &quot;hare&quot;</source>
          <target state="translated">&quot;野兔 &quot;末尾的 &quot;是&quot;,&quot;是 &quot;的 &quot;是&quot;</target>
        </trans-unit>
        <trans-unit id="f9f8a2f0a59aac465b7b2e5829132ebadacd4d79" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in &quot;What _are_ you thinking?&quot;</source>
          <target state="translated">&quot;你在想什么?&quot;中的 &quot;是&quot;,&quot;你在想什么?&quot;</target>
        </trans-unit>
        <trans-unit id="ff1600ce3aceaa25995ea3bed5fa16ea9e7f9d0f" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in &quot;lol u dunno wut those are4?&quot;</source>
          <target state="translated">&quot;lol u dunno wut those are4? &quot;中的 &quot;是&quot;</target>
        </trans-unit>
        <trans-unit id="6e73ec58021d66e8d244453eb8eecab178cd95e3" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in the middle of &quot;fares&quot;</source>
          <target state="translated">票价 &quot;中间的 &quot;是 &quot;是 &quot;的 &quot;是&quot;</target>
        </trans-unit>
        <trans-unit id="af141695ab878d911b750be60dedc56b44a1366b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; at the end of regular expression changes regular expression to be case-insensitive, if you do not want that, you can leave it out.</source>
          <target state="translated">正则表达式末尾的 &lt;code&gt;i&lt;/code&gt; 会将正则表达式更改为不区分大小写，如果不希望这样，可以将其省略。</target>
        </trans-unit>
        <trans-unit id="a58a61579fa10e87cfbc17dea3a1e7d4dee7a592" translate="yes" xml:space="preserve">
          <source>The function below also works and does not depend on any other function; it uses only native PHP string manipulation. Personally, I do not recommend this, but you can see how it works:</source>
          <target state="translated">下面这个函数也是可以的,不依赖任何其他函数,它只使用原生的PHP字符串操作。我个人不推荐使用这个,但你可以看看它的工作原理。</target>
        </trans-unit>
        <trans-unit id="f06677169500917274915f9ad5cfaf385a03d220" translate="yes" xml:space="preserve">
          <source>The reduction of numeric values by reducing precision are other ways of normalising the text.</source>
          <target state="translated">通过降低精度来减少数值,是文本规范化的其他方式。</target>
        </trans-unit>
        <trans-unit id="8acbf1d45a648165adc6a6e8fdf2236bcdcc9869" translate="yes" xml:space="preserve">
          <source>The replacement of colour names with their hexadecimal equivalents</source>
          <target state="translated">用十六进制等价物替换颜色名称。</target>
        </trans-unit>
        <trans-unit id="7bdbb776fba5a8dc6853756dead688035a67cceb" translate="yes" xml:space="preserve">
          <source>The short-hand version</source>
          <target state="translated">简易版</target>
        </trans-unit>
        <trans-unit id="074eb46fa2eab2604e12769117a414a5c815cc4b" translate="yes" xml:space="preserve">
          <source>The strpos function works fine, but if you want to do &lt;code&gt;case-insensitive&lt;/code&gt; checking for a word in a paragraph then you can make use of the &lt;code&gt;stripos&lt;/code&gt; function of &lt;code&gt;PHP&lt;/code&gt;.</source>
          <target state="translated">strpos函数可以正常工作，但是如果您要对段落中的单词进行 &lt;code&gt;case-insensitive&lt;/code&gt; 检查，则可以使用 &lt;code&gt;PHP&lt;/code&gt; 的 &lt;code&gt;stripos&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="fe39f4f56248c0ed3b837778f579013127d494e1" translate="yes" xml:space="preserve">
          <source>There are plenty of improvements to be made
but the model provides a way of getting good results from natural queries, 
which don't have boolean operators such as &lt;code&gt;strpos()&lt;/code&gt;, &lt;code&gt;preg_match()&lt;/code&gt;, &lt;code&gt;strstr()&lt;/code&gt; or &lt;code&gt;stristr()&lt;/code&gt;.</source>
          <target state="translated">尚有许多改进之处，但是该模型提供了一种从自然查询中获得良好结果的方法，这些自然查询没有布尔运算符，例如 &lt;code&gt;strpos()&lt;/code&gt; ， &lt;code&gt;preg_match()&lt;/code&gt; ， &lt;code&gt;strstr()&lt;/code&gt; 或 &lt;code&gt;stristr()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d219fd4683f024b1b46ac4b7362bae7eb53df97b" translate="yes" xml:space="preserve">
          <source>This is the idea of the vector space model, &lt;strong&gt;not far from how SQL full-text search works:&lt;/strong&gt;</source>
          <target state="translated">这是向量空间模型的思想，与&lt;strong&gt;SQL全文搜索的工作原理相距不远：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="281072b73957e4edbd3e2582a1cfa67bfbc65be8" translate="yes" xml:space="preserve">
          <source>This is useful to avoid spam when sending emails for example.</source>
          <target state="translated">这对于避免发送垃圾邮件是很有用的,比如说,在发送邮件时。</target>
        </trans-unit>
        <trans-unit id="8654cbc27d2dd80342d3a1c9c6aed7df2c779cab" translate="yes" xml:space="preserve">
          <source>This means the string has to be resolved into words (see note below).</source>
          <target state="translated">这意味着必须将字符串解析成文字(见下文注释)。</target>
        </trans-unit>
        <trans-unit id="51a160776c2c7b3eab04ee3c79f29c6483cb965a" translate="yes" xml:space="preserve">
          <source>This method doesn't have the same false positives noted above, but it does have some edge cases of its own.  Word boundaries match on non-word characters (&lt;code&gt;\W&lt;/code&gt;), which are going to be anything that isn't &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;, or &lt;code&gt;_&lt;/code&gt;.  That means digits and underscores are going to be counted as word characters and scenarios like this will fail:</source>
          <target state="translated">该方法没有上面提到的相同的误报，但确实有一些边缘情况。 单词边界与非单词字符（ &lt;code&gt;\W&lt;/code&gt; ）匹配，这些字符将不是 &lt;code&gt;a-z&lt;/code&gt; ， &lt;code&gt;A-Z&lt;/code&gt; ， &lt;code&gt;0-9&lt;/code&gt; 或 &lt;code&gt;_&lt;/code&gt; 。 这意味着数字和下划线将被视为单词字符，这样的情况将失败：</target>
        </trans-unit>
        <trans-unit id="814d677a8f676b10f82ac5b818657779e061b6f0" translate="yes" xml:space="preserve">
          <source>To check if &lt;em&gt;not&lt;/em&gt; present, add the &lt;code&gt;!&lt;/code&gt; operator:</source>
          <target state="translated">要检查是否&lt;em&gt;不&lt;/em&gt;存在，请添加 &lt;code&gt;!&lt;/code&gt; 操作员：</target>
        </trans-unit>
        <trans-unit id="65c66e28ac6f1c0e38ec5e9659847cadea78cb2d" translate="yes" xml:space="preserve">
          <source>To combine both sets of functionality into a single multi-purpose function (including with selectable case sensitivity), you could use something like this:</source>
          <target state="translated">要将这两组功能组合成一个单一的多用途功能(包括可选择的案件敏感度),你可以使用类似这样的功能。</target>
        </trans-unit>
        <trans-unit id="10edf5fed7899dea96bf80a0ad1840566ed6e1a4" translate="yes" xml:space="preserve">
          <source>To determine whether a string contains another string you can use the PHP function &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;strpos()&lt;/a&gt;.</source>
          <target state="translated">要确定一个字符串是否包含另一个字符串，可以使用PHP函数&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;strpos（）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="16f2e11c8284a6bf0ac0d263cb869b551c3cca3e" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;&lt;code&gt;strstr()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.stristr.php&quot;&gt;&lt;code&gt;stristr()&lt;/code&gt;&lt;/a&gt; if your search should be case insensitive would be another option.</source>
          <target state="translated">如果您的搜索不区分大小写，则使用&lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt; &lt;code&gt;strstr()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;http://php.net/manual/en/function.stristr.php&quot;&gt; &lt;code&gt;stristr()&lt;/code&gt; &lt;/a&gt;是另一种选择。</target>
        </trans-unit>
        <trans-unit id="efdcb8e898f459b234a8181ba616ea969d0119ad" translate="yes" xml:space="preserve">
          <source>What's the difference?  Substrings can appear within other words:</source>
          <target state="translated">有什么区别?子句可以出现在其他字里行间。</target>
        </trans-unit>
        <trans-unit id="aa590c482271336764621e55078baf0c591d5536" translate="yes" xml:space="preserve">
          <source>While most of these answers will tell you if a substring appears in your string, that's usually not what you want if you're looking for a particular &lt;em&gt;word&lt;/em&gt;, and not a &lt;em&gt;substring&lt;/em&gt;.</source>
          <target state="translated">尽管大多数答案都会告诉您字符串中是否出现了子字符串，但是如果您正在寻找一个特定的&lt;em&gt;单词&lt;/em&gt; ，通常就不是您想要的，而不是&lt;em&gt;substring&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="258937995fc341d4744a414cf73e47fe8f6bacc7" translate="yes" xml:space="preserve">
          <source>With the samples above, both &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; contains &lt;code&gt;$c&lt;/code&gt;, but you may want your function to tell you that only &lt;code&gt;$a&lt;/code&gt; contains &lt;code&gt;$c&lt;/code&gt;.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 包含 &lt;code&gt;$c&lt;/code&gt; ，但是您可能希望函数告诉您只有 &lt;code&gt;$a&lt;/code&gt; 包含 &lt;code&gt;$c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa883bf0d02de1e50fb3029d25f98235c9f50d88" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;strpos()&lt;/code&gt; function.</source>
          <target state="translated">您也可以使用 &lt;code&gt;strpos()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="048e7d27353c157dc1b5bc47ecb679187e0f6ed6" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos()&lt;/code&gt;&lt;/a&gt; function which is used to find the occurrence of one string inside another one:</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos()&lt;/code&gt; &lt;/a&gt;函数来查找另一个字符串中另一个字符串的出现：</target>
        </trans-unit>
        <trans-unit id="54493c19dbfc90ba47d4dd06b13bebcfabf9e240" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;strstr&lt;/code&gt; function:</source>
          <target state="translated">您可以使用 &lt;code&gt;strstr&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="a6ce4df6c8750da05b0d98658e1056a1f84f5f17" translate="yes" xml:space="preserve">
          <source>You could use regular expressions, it's better for word matching compared to &lt;code&gt;strpos&lt;/code&gt; as mentioned by other users it will also return true for strings such as fare, care, stare, etc. This can simply be avoided in regular expression by using word boundaries.</source>
          <target state="translated">您可以使用正则表达式，与其他用户提到的 &lt;code&gt;strpos&lt;/code&gt; 相比，它在单词匹配方面更好，并且对于诸如票价，护理，凝视等字符串也将返回true。这可以通过使用单词边界在正则表达式中简单地避免。</target>
        </trans-unit>
        <trans-unit id="a0bec4b988172a1d14d0a06bdba132b97b07f5c8" translate="yes" xml:space="preserve">
          <source>You may notice that the previous solutions are not an answer for the word being used as a prefix for another. In order to use your example:</source>
          <target state="translated">你可能会注意到,前面的解题思路不是用这个词作为另一个词的前缀的答案。为了用你的例子。</target>
        </trans-unit>
        <trans-unit id="a932d9c5bd36cc1e640ddd6ae01856aa33464c06" translate="yes" xml:space="preserve">
          <source>You need to use identical/not identical operators because strpos can return 0 as it's index value. If you like ternary operators, consider using the following (seems a little backwards I'll admit):</source>
          <target state="translated">你需要使用相同而不是相同的运算符,因为strpos可以返回0作为它的索引值。如果你喜欢三元运算符,可以考虑使用下面的运算符(我承认似乎有点落后)。</target>
        </trans-unit>
        <trans-unit id="17a4eaa70e6fca11cd3a0594e0e6ae22bcf5f5dd" translate="yes" xml:space="preserve">
          <source>You should use case Insensitive format,so if the entered value is in &lt;code&gt;small&lt;/code&gt; or &lt;code&gt;caps&lt;/code&gt; it wont matter.</source>
          <target state="translated">您应该使用不区分大小写的格式，因此，如果输入的值 &lt;code&gt;small&lt;/code&gt; 或 &lt;code&gt;caps&lt;/code&gt; 则无所谓。</target>
        </trans-unit>
        <trans-unit id="9411b3f7d38c850e9e0ce1838744755ad62458f6" translate="yes" xml:space="preserve">
          <source>can't search for multiple words</source>
          <target state="translated">多词搜索不到</target>
        </trans-unit>
        <trans-unit id="15bf9afce4ffa3fbf44c7e834d049e617054404b" translate="yes" xml:space="preserve">
          <source>faster indexing and a consequently faster search.</source>
          <target state="translated">更快的索引,从而加快了搜索速度。</target>
        </trans-unit>
        <trans-unit id="37ab7e92198730c935587e8eab4e183e80b042a6" translate="yes" xml:space="preserve">
          <source>less disk I/O</source>
          <target state="translated">减少磁盘IO</target>
        </trans-unit>
        <trans-unit id="f262c494e86d759eb3e2029edccdeaf071231d09" translate="yes" xml:space="preserve">
          <source>results are unranked</source>
          <target state="translated">排名不分先后</target>
        </trans-unit>
        <trans-unit id="274e89ab94a3541c57aa9a85d106d78e5be3f50e" translate="yes" xml:space="preserve">
          <source>thereby reducing index size and resulting in less storage requirement</source>
          <target state="translated">从而减少了索引的大小,减少了存储需求</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
