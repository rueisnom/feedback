<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/4366730">
    <body>
      <group id="4366730">
        <trans-unit id="536930aa45c4f9ebe04ec4eee9fe774d8b05ff5b" translate="yes" xml:space="preserve">
          <source>1- stristr()</source>
          <target state="translated">1-stristr()</target>
        </trans-unit>
        <trans-unit id="9c04eee059ec9710c163e4d720492795c8a32060" translate="yes" xml:space="preserve">
          <source>2- strpos()</source>
          <target state="translated">2-strpos()</target>
        </trans-unit>
        <trans-unit id="ae4b45ccf79b06e3929e1a3633b7a35b68e5cbbf" translate="yes" xml:space="preserve">
          <source>3- preg_match()</source>
          <target state="translated">3-preg_match()</target>
        </trans-unit>
        <trans-unit id="8d1a614572a1ef0c19a362e30bcd32eef314aab4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos&lt;/code&gt;&lt;/a&gt; finds the position of the first occurrence of a case-insensitive substring in a string.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos&lt;/code&gt; &lt;/a&gt; encuentra la posici&amp;oacute;n de la primera aparici&amp;oacute;n de una subcadena insensible a may&amp;uacute;sculas y min&amp;uacute;sculas en una cadena.</target>
        </trans-unit>
        <trans-unit id="d7edf7695232ace28ffa32c8559ecb9b1e5ea944" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos&lt;/code&gt;&lt;/a&gt; finds the position of the first occurrence of a case-sensitive substring in a string.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos&lt;/code&gt; &lt;/a&gt; encuentra la posici&amp;oacute;n de la primera aparici&amp;oacute;n de una subcadena sensible a may&amp;uacute;sculas y min&amp;uacute;sculas en una cadena.</target>
        </trans-unit>
        <trans-unit id="65db47ef4129dadb5b064de72e4a9344d03d186d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;Look at &lt;code&gt;strpos()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;Mira &lt;code&gt;strpos()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="161a91404619d6734e80cd0778e5e2eb37c87d8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$caseSensitive ? A : B&lt;/code&gt; selects either &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos&lt;/code&gt;&lt;/a&gt; to do the work, depending on the value of &lt;code&gt;$caseSensitive&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$caseSensitive ? A : B&lt;/code&gt; A: B selecciona &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos&lt;/code&gt; &lt;/a&gt; para hacer el trabajo, dependiendo del valor de &lt;code&gt;$caseSensitive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e43f3e39917183f03b6c7d8df65a3d6caaca77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myFunction($haystack, $needle) === FALSE ? FALSE : TRUE&lt;/code&gt; ensures that &lt;code&gt;myFunction&lt;/code&gt; always returns a boolean and fixes unexpected behavior when the index of the substring is 0.</source>
          <target state="translated">&lt;code&gt;myFunction($haystack, $needle) === FALSE ? FALSE : TRUE&lt;/code&gt; FALSO: VERDADERO asegura que &lt;code&gt;myFunction&lt;/code&gt; siempre devuelve un valor booleano y corrige un comportamiento inesperado cuando el &amp;iacute;ndice de la subcadena es 0.</target>
        </trans-unit>
        <trans-unit id="a38601451a7271300a3862930f2409a619504b87" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Optionally eliminating redundancy prior to search the words&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Opcionalmente eliminando la redundancia antes de buscar las palabras&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b239b39dd3ea5d3bc28ab5e6594623814ae44575" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Normalisation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. Normalizaci&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c2da9093478005107c83bcb253a85f687fcb20e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Stopword elimination&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Eliminaci&amp;oacute;n de palabras vac&amp;iacute;as&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15f70347f13635fdde48efd621a04e1cd494add" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Dictionary substitution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. Sustituci&amp;oacute;n de diccionario&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d4d8c048007e19655046e44f48cfa683d97aa7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CASO 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b17fa346bb4f567be4a05b73d079ef9eeb1da6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CASO 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d2e913dec4051855fb256e532411a9b529ea94d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CASO 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4219c5f6fe25ad668c412bff701696037aef1b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAUTION:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CAUTION:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcde4902afc8a02e4348242ab9385feb6c8fa9c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issues with the other boolean search methods such as &lt;code&gt;strpos()&lt;/code&gt;, &lt;code&gt;preg_match()&lt;/code&gt;, &lt;code&gt;strstr()&lt;/code&gt; or &lt;code&gt;stristr()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Problemas con los otros m&amp;eacute;todos de b&amp;uacute;squeda booleanos como &lt;code&gt;strpos()&lt;/code&gt; , &lt;code&gt;preg_match()&lt;/code&gt; , &lt;code&gt;strstr()&lt;/code&gt; o &lt;code&gt;stristr()&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7666b304a8fca7faed968cac02ec2f4fede0f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTA BENE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTA BENE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00c6ca567e32596c84c50e0fb28233adda888901" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Here we do not mean word for every sequence of symbols.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Aqu&amp;iacute; no queremos decir palabra para cada secuencia de s&amp;iacute;mbolos.</target>
        </trans-unit>
        <trans-unit id="0464dc38e1fc7e588f4c179f040c57144d419a6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP method based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_space_model&quot;&gt;Vector Space Model&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf (term frequency&amp;ndash;inverse document frequency):&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo PHP basado en &lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_space_model&quot;&gt;el modelo de espacio vectorial&lt;/a&gt; y &lt;a href=&quot;http://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf (t&amp;eacute;rmino frecuencia-frecuencia de documento inversa):&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="450025855baecd41e523dc05eafa16f85db4098f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHPCode Sample with output&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PHPCode Muestra con salida&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b7fe3ad4bb795df9d41e53255576530192a9be9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESOURCES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESOURCES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3d9b2805e24d71fd7dbe60ed49798186b321048" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESULT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESULT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e8719c6c93a3d522fb7415c04094d2b50b9a4f84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESULTS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESULTS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d03f4a89fe7c2757c20c5c42a24c135ce9e8e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Without using an inbuilt function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sin usar una funci&amp;oacute;n incorporada:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa1853953b71f4c41b3cc95fb3cca78efdd9c424" translate="yes" xml:space="preserve">
          <source>A &quot;word&quot; character is any letter or digit or the underscore character,
  that is, any character which can be part of a Perl &quot; word &quot;. The
  definition of letters and digits is controlled by PCRE's character
  tables, and may vary if locale-specific matching is taking place (..)</source>
          <target state="translated">Un carácter de &quot;palabra&quot; es cualquier letra o dígito o el carácter de subrayado,es decir,cualquier carácter que pueda formar parte de una &quot;palabra&quot; de Perl.La definición de letras y dígitos se controla mediante las tablas de caracteres de PCRE,y puede variar si se está realizando una coincidencia específica de la localidad (..)</target>
        </trans-unit>
        <trans-unit id="f8f3f2943f82691039b22b2ebdeff76dd86282d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;==&lt;/code&gt; sign is a comparison and tests whether the variable / expression / constant to the left has the same value as the variable / expression / constant to the right.</source>
          <target state="translated">Un signo &lt;code&gt;==&lt;/code&gt; es una comparaci&amp;oacute;n y prueba si la variable / expresi&amp;oacute;n / constante a la izquierda tiene el mismo valor que la variable / expresi&amp;oacute;n / constante a la derecha.</target>
        </trans-unit>
        <trans-unit id="b7e4f92de169b796d2edbe690758dfdf768e8e70" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;===&lt;/code&gt; sign is a comparison to see whether two variables / expresions / constants are equal &lt;code&gt;AND&lt;/code&gt; have the same type - i.e. both are strings or both are integers.</source>
          <target state="translated">Un signo &lt;code&gt;===&lt;/code&gt; es una comparaci&amp;oacute;n para ver si dos variables / expresiones / constantes son iguales &lt;code&gt;AND&lt;/code&gt; tienen el mismo tipo, es decir, ambas son cadenas o ambas son n&amp;uacute;meros enteros.</target>
        </trans-unit>
        <trans-unit id="e4920abb4f3b8892883bf5a41623c4aab2b1f548" translate="yes" xml:space="preserve">
          <source>A good article to understand why is &lt;em&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a&gt;&lt;/em&gt; by &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Joel_Spolsky&quot;&gt;Joel Spolsky&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Un buen art&amp;iacute;culo para entender por qu&amp;eacute; es &lt;em&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;El m&amp;iacute;nimo absoluto que todo desarrollador de software debe saber absolutamente, positivamente sobre Unicode y los conjuntos de caracteres (&amp;iexcl;Sin excusas!)&lt;/a&gt;&lt;/em&gt; Por &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Joel_Spolsky&quot;&gt;Joel Spolsky&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f4dca82ce7301d5a56f3ffda9ea5d842b28eb7ec" translate="yes" xml:space="preserve">
          <source>A practical definition of word is in the sense the PCRE regular expression engine, where words are substrings consisting of word characters only, being separated by non-word characters.</source>
          <target state="translated">Una definición práctica de palabra es en el sentido del motor de expresión regular de la PCRE,en el que las palabras son subcadenas compuestas únicamente por caracteres de palabras,estando separadas por caracteres no denominativos.</target>
        </trans-unit>
        <trans-unit id="5ec194c4603c00b67980b557f9d17564cb709fe7" translate="yes" xml:space="preserve">
          <source>A run gives</source>
          <target state="translated">Una carrera da</target>
        </trans-unit>
        <trans-unit id="41a9b657064aaec58c7a71735974461119393ee2" translate="yes" xml:space="preserve">
          <source>A simple match for are could look something like this:</source>
          <target state="translated">Una simple coincidencia para son podría parecerse a algo como esto:</target>
        </trans-unit>
        <trans-unit id="5005dc287716aef5b1fa0a49374df254f53b0a13" translate="yes" xml:space="preserve">
          <source>Also, here's a great tool for testing and seeing explanations of various regular expressions &lt;a href=&quot;https://regex101.com/&quot;&gt;Regex101&lt;/a&gt;</source>
          <target state="translated">Adem&amp;aacute;s, aqu&amp;iacute; hay una gran herramienta para probar y ver explicaciones de varias expresiones regulares &lt;a href=&quot;https://regex101.com/&quot;&gt;Regex101&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="154f98e219ba2d530ab470fcb920ed2cf84456ee" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;strstr()&lt;/a&gt; function. Something like:</source>
          <target state="translated">Otra opci&amp;oacute;n es usar la funci&amp;oacute;n &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;strstr ()&lt;/a&gt; . Algo como:</target>
        </trans-unit>
        <trans-unit id="30eb8eef8b6e9b1c537d3b8ca07b74300cc86462" translate="yes" xml:space="preserve">
          <source>Another option to finding the occurrence of a word from a string using &lt;a href=&quot;http://www.php.net/manual/en/function.strstr.php&quot;&gt;strstr()&lt;/a&gt; and &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr()&lt;/a&gt; is like the following:</source>
          <target state="translated">Otra opci&amp;oacute;n para encontrar la aparici&amp;oacute;n de una palabra de una cadena usando &lt;a href=&quot;http://www.php.net/manual/en/function.strstr.php&quot;&gt;strstr ()&lt;/a&gt; y &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr ()&lt;/a&gt; es la siguiente:</target>
        </trans-unit>
        <trans-unit id="1c001274549b8d9c38352b77098a207b33210a25" translate="yes" xml:space="preserve">
          <source>Another solution for a specific string:</source>
          <target state="translated">Otra solución para una cadena específica:</target>
        </trans-unit>
        <trans-unit id="059fd4a17ec8f277845903f637b570f56ea31b4d" translate="yes" xml:space="preserve">
          <source>Basically, if you're &lt;strong&gt;having trouble finding words with characters specific to some languages&lt;/strong&gt;, such as German, French, Portuguese, Spanish, etc. (e.g.: &lt;em&gt;&amp;auml;&lt;/em&gt;, &lt;em&gt;&amp;eacute;&lt;/em&gt;, &lt;em&gt;&amp;ocirc;&lt;/em&gt;, &lt;em&gt;&amp;ccedil;&lt;/em&gt;, &lt;em&gt;&amp;ordm;&lt;/em&gt;, &lt;em&gt;&amp;ntilde;&lt;/em&gt;), you may want to precede the functions with &lt;code&gt;mb_&lt;/code&gt;. Therefore, the accepted answer would use &lt;a href=&quot;http://php.net/manual/en/function.mb-strpos.php&quot;&gt;&lt;code&gt;mb_strpos&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.mb-stripos.php&quot;&gt;&lt;code&gt;mb_stripos&lt;/code&gt;&lt;/a&gt; (for case-insensitive matching) instead:</source>
          <target state="translated">B&amp;aacute;sicamente, si &lt;strong&gt;tiene problemas para encontrar palabras con caracteres espec&amp;iacute;ficos de algunos idiomas&lt;/strong&gt; , como alem&amp;aacute;n, franc&amp;eacute;s, portugu&amp;eacute;s, espa&amp;ntilde;ol, etc. (por ejemplo: &lt;em&gt;&amp;auml;&lt;/em&gt; , &lt;em&gt;&amp;eacute;&lt;/em&gt; , &lt;em&gt;&amp;ocirc;&lt;/em&gt; , &lt;em&gt;&amp;ccedil;&lt;/em&gt; , &lt;em&gt;&amp;ordm;&lt;/em&gt; , &lt;em&gt;&amp;ntilde;&lt;/em&gt; ), es posible que desee preceder las funciones con &lt;code&gt;mb_&lt;/code&gt; . Por lo tanto, la respuesta aceptada usar&amp;iacute;a &lt;a href=&quot;http://php.net/manual/en/function.mb-strpos.php&quot;&gt; &lt;code&gt;mb_strpos&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;http://php.net/manual/en/function.mb-stripos.php&quot;&gt; &lt;code&gt;mb_stripos&lt;/code&gt; &lt;/a&gt; (para la coincidencia entre may&amp;uacute;sculas y min&amp;uacute;sculas) en su lugar:</target>
        </trans-unit>
        <trans-unit id="c6ac2ebe3d53f92da9f6857d844261f13d940aaa" translate="yes" xml:space="preserve">
          <source>Check if string contains specific words?</source>
          <target state="translated">¿Comprobar si la cadena contiene palabras específicas?</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="995f64f15a13f374697065535435ba94d26464e7" translate="yes" xml:space="preserve">
          <source>Convert all text to lower case</source>
          <target state="translated">Convertir todo el texto a minúsculas</target>
        </trans-unit>
        <trans-unit id="112d1f61745b16ccc0356f918f7a7be16bdd57d2" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;preg_match()&lt;/code&gt; if you only want to check if one string is contained in another string. Use &lt;code&gt;strpos()&lt;/code&gt; or &lt;code&gt;strstr()&lt;/code&gt; instead as they will be faster. (&lt;a href=&quot;http://in2.php.net/preg_match&quot;&gt;http://in2.php.net/preg_match&lt;/a&gt;)</source>
          <target state="translated">No use &lt;code&gt;preg_match()&lt;/code&gt; si solo desea verificar si una cadena est&amp;aacute; contenida en otra cadena. Use &lt;code&gt;strpos()&lt;/code&gt; o &lt;code&gt;strstr()&lt;/code&gt; lugar, ya que ser&amp;aacute;n m&amp;aacute;s r&amp;aacute;pidos. ( &lt;a href=&quot;http://in2.php.net/preg_match&quot;&gt;http://in2.php.net/preg_match&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="771ca06d7bb1df15a66af37bb337725931a04e2f" translate="yes" xml:space="preserve">
          <source>Edit:
In order to search any part of the string, not just word by word, I would recommend using a regular expression like</source>
          <target state="translated">Editar:Para buscar en cualquier parte de la cadena,no sólo palabra por palabra,recomendaría usar una expresión regular como</target>
        </trans-unit>
        <trans-unit id="a175d3309aa70f6eadc8fd006df92ee87672c066" translate="yes" xml:space="preserve">
          <source>Eliminate words from the text which carry no real meaning (like 'and', 'or', 'the', 'for', etc.)</source>
          <target state="translated">Eliminar las palabras del texto que no tienen un significado real (como &quot;y&quot;,&quot;o&quot;,&quot;el&quot;,&quot;para&quot;,etc.)</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="f8838d8c3e8de7ea1720befe670b6ddecdfca0fa" translate="yes" xml:space="preserve">
          <source>Find the position of the first occurrence of a case-insensitive substring in a string.</source>
          <target state="translated">Encuentra la posición de la primera ocurrencia de una subcadena insensible a las mayúsculas y minúsculas en una cadena.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="8e347c4e5e5f169d1f544caeabe3acbdeb0a1fd6" translate="yes" xml:space="preserve">
          <source>Further algorithmic measures (snowball) may be performed to further reduce words to their essential meaning.</source>
          <target state="translated">Se pueden realizar más medidas algorítmicas (bola de nieve)para reducir aún más las palabras a su significado esencial.</target>
        </trans-unit>
        <trans-unit id="868013052501a3915b42071b147883eee03a3899" translate="yes" xml:space="preserve">
          <source>Here is a little utility function that is useful in situations like this</source>
          <target state="translated">Aquí hay una pequeña función de utilidad que es útil en situaciones como esta</target>
        </trans-unit>
        <trans-unit id="640ccdb37a48eedfabd85e115efe42bf0f97e2b4" translate="yes" xml:space="preserve">
          <source>Here stripos finds needle in heystack &lt;strong&gt;without&lt;/strong&gt; considering case (small/caps).</source>
          <target state="translated">Aqu&amp;iacute; stripos encuentra la aguja en el heystack &lt;strong&gt;sin&lt;/strong&gt; considerar el caso (peque&amp;ntilde;o / tapas).</target>
        </trans-unit>
        <trans-unit id="828d73986d577dc553333bd6f21ac565c1fb423c" translate="yes" xml:space="preserve">
          <source>How do I check if a string contains a specific word</source>
          <target state="translated">¿Cómo puedo comprobar si una cadena contiene una palabra específica</target>
        </trans-unit>
        <trans-unit id="224b8efc0b9ac26641de6ae359e96fd868125065" translate="yes" xml:space="preserve">
          <source>I had some trouble with this, and finally I chose to create my own solution. Without using &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; engine:</source>
          <target state="translated">Tuve algunos problemas con esto y finalmente decid&amp;iacute; crear mi propia soluci&amp;oacute;n. Sin usar &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;el&lt;/a&gt; motor de expresi&amp;oacute;n regular :</target>
        </trans-unit>
        <trans-unit id="a42d6e1c43dd12b71ad626eaa7d6b3ea6944040b" translate="yes" xml:space="preserve">
          <source>I'm a bit impressed that none of the answers here that used &lt;code&gt;strpos&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt; and similar functions mentioned &lt;a href=&quot;http://php.net/manual/en/ref.mbstring.php&quot;&gt;Multibyte String Functions&lt;/a&gt; yet (2015-05-08).</source>
          <target state="translated">Estoy un poco impresionado de que ninguna de las respuestas aqu&amp;iacute; que usaban &lt;code&gt;strpos&lt;/code&gt; , &lt;code&gt;strstr&lt;/code&gt; y funciones similares mencionaran las &lt;a href=&quot;http://php.net/manual/en/ref.mbstring.php&quot;&gt;funciones de cadena multibyte&lt;/a&gt; todav&amp;iacute;a (2015-05-08).</target>
        </trans-unit>
        <trans-unit id="fa8035d683dec343995234343194912e2e44077e" translate="yes" xml:space="preserve">
          <source>If the needle you are searching for is at the beginning of the haystack it will return position 0, if you do a &lt;code&gt;==&lt;/code&gt; compare that will not work, you will need to do a &lt;code&gt;===&lt;/code&gt;</source>
          <target state="translated">Si la aguja que est&amp;aacute; buscando est&amp;aacute; al comienzo del pajar, volver&amp;aacute; a la posici&amp;oacute;n 0, si hace una comparaci&amp;oacute;n &lt;code&gt;==&lt;/code&gt; que no funcionar&amp;aacute;, deber&amp;aacute; hacer una &lt;code&gt;===&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="914d8946f736f2babcc727a583d93362c1a80a2b" translate="yes" xml:space="preserve">
          <source>If the word doesn't exist in the string then it will return false else it will return the position of the word.</source>
          <target state="translated">Si la palabra no existe en la cadena,entonces devolverá false,si no,devolverá la posición de la palabra.</target>
        </trans-unit>
        <trans-unit id="0ca72b4ba6418cfdc9d8f0766d5bbbaed69c8c46" translate="yes" xml:space="preserve">
          <source>If we could weight the terms in a string based on how representative they are of the string as a whole, 
we could order our results by the ones that best match the query.</source>
          <target state="translated">Si pudiéramos ponderar los términos de una cadena en función de su representatividad en el conjunto de la misma,podríamos ordenar los resultados por los que mejor se ajusten a la consulta.</target>
        </trans-unit>
        <trans-unit id="f22ff471b11f2348e549c1430ff4e7c026fa09ca" translate="yes" xml:space="preserve">
          <source>If we want to search for multiple words in a string the core problem is how we assign a weight to each one of them?</source>
          <target state="translated">Si queremos buscar varias palabras en una cadena,el problema principal es cómo asignar un peso a cada una de ellas...</target>
        </trans-unit>
        <trans-unit id="7301e6fd4a01ccad442ed786a4bba0c369969b9f" translate="yes" xml:space="preserve">
          <source>If you are looking for a PHP algorithm to &lt;strong&gt;rank search results based on proximity/relevance&lt;/strong&gt; of multiple words
here comes a quick and easy way of generating search results with PHP only:</source>
          <target state="translated">Si est&amp;aacute; buscando un algoritmo PHP para &lt;strong&gt;clasificar los resultados de b&amp;uacute;squeda en funci&amp;oacute;n de la proximidad / relevancia&lt;/strong&gt; de varias palabras, aqu&amp;iacute; viene una manera r&amp;aacute;pida y f&amp;aacute;cil de generar resultados de b&amp;uacute;squeda solo con PHP:</target>
        </trans-unit>
        <trans-unit id="177529202720249ead729bcdcae74deef04b45b8" translate="yes" xml:space="preserve">
          <source>If you cannot guarantee that &lt;a href=&quot;https://stackoverflow.com/a/1744518/1326147&quot;&gt;&lt;em&gt;all your data is 100% in UTF-8&lt;/em&gt;&lt;/a&gt;, you may want to use the &lt;code&gt;mb_&lt;/code&gt; functions.</source>
          <target state="translated">Si no puede garantizar que &lt;a href=&quot;https://stackoverflow.com/a/1744518/1326147&quot;&gt;&lt;em&gt;todos sus datos&lt;/em&gt;&lt;/a&gt; &lt;code&gt;mb_&lt;/code&gt; &lt;em&gt;100% en UTF-8&lt;/em&gt; , puede utilizar las funciones mb_ .</target>
        </trans-unit>
        <trans-unit id="b09fd6a82cef6361ad80b45ebbcfda266a96e009" translate="yes" xml:space="preserve">
          <source>If you want anything more accurate than this, you'll have to start doing English language syntax parsing, and that's a pretty big can of worms (and assumes proper use of syntax, anyway, which isn't always a given).</source>
          <target state="translated">Si quieres algo más preciso que esto,tendrás que empezar a hacer un análisis sintáctico del idioma inglés,y eso es una gran lata de gusanos (y asume el uso apropiado de la sintaxis,de todos modos,lo cual no siempre es un hecho).</target>
        </trans-unit>
        <trans-unit id="e8f50c16e936b75ab4e2005421136e0198edf974" translate="yes" xml:space="preserve">
          <source>If you want to avoid the &quot;falsey&quot; and &quot;truthy&quot; problem, you can use substr_count:</source>
          <target state="translated">Si quieres evitar el problema de la &quot;falsedad&quot; y la &quot;verdad&quot;,puedes usar substr_count:</target>
        </trans-unit>
        <trans-unit id="068ce11b70ff847aa349c2e01c1c982a84e0bfdd" translate="yes" xml:space="preserve">
          <source>If you want to check if the string contains several specifics words, you can do:</source>
          <target state="translated">Si quieres comprobar si la cadena contiene varias palabras específicas,puedes hacerlo:</target>
        </trans-unit>
        <trans-unit id="8c9649b02c5520357914939e07ddb195baefdc95" translate="yes" xml:space="preserve">
          <source>In PHP, the best way to verify if a string contains a certain substring, is to use a simple helper function like this:</source>
          <target state="translated">En PHP,la mejor manera de verificar si una cadena contiene una cierta subcadena,es usar una simple función de ayuda como esta:</target>
        </trans-unit>
        <trans-unit id="0944f82b5ffe8e68399c6e203bfeb6491b34006e" translate="yes" xml:space="preserve">
          <source>In order to find a 'word', rather than the occurrence of a series of letters that could in fact be a part of another word, the following would be a good solution.</source>
          <target state="translated">Para encontrar una &quot;palabra&quot;,en lugar de la aparición de una serie de letras que podrían,de hecho,formar parte de otra palabra,la siguiente sería una buena solución.</target>
        </trans-unit>
        <trans-unit id="32cdcd308cc39dd176a93ce07644fddfb6a72f8d" translate="yes" xml:space="preserve">
          <source>It can be done in three different ways:</source>
          <target state="translated">Se puede hacer de tres maneras diferentes:</target>
        </trans-unit>
        <trans-unit id="471b011a086e49e68c14b691be41feb79ca9ef15" translate="yes" xml:space="preserve">
          <source>It sounds difficult but is surprisingly easy.</source>
          <target state="translated">Suena difícil pero es sorprendentemente fácil.</target>
        </trans-unit>
        <trans-unit id="0a69fd82c05b687cc1c6fc980796c044246e1001" translate="yes" xml:space="preserve">
          <source>It's a bit slower than strpos but it avoids the comparison problems.</source>
          <target state="translated">Es un poco más lento que el strpos pero evita los problemas de comparación.</target>
        </trans-unit>
        <trans-unit id="8fefbf5fa8ffae8b83fd2f9f21c6c5bcc031055d" translate="yes" xml:space="preserve">
          <source>Lot of answers that use &lt;a href=&quot;http://php.net/manual/en/function.substr-count.php&quot;&gt;&lt;code&gt;substr_count&lt;/code&gt;&lt;/a&gt; checks if the result is &lt;code&gt;&amp;gt;0&lt;/code&gt;. But since the &lt;code&gt;if&lt;/code&gt; statement considers zero the &lt;a href=&quot;http://php.net/manual/en/types.comparisons.php&quot;&gt;same as false&lt;/a&gt;, you can avoid that check and write directly:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.substr-count.php&quot;&gt; &lt;code&gt;substr_count&lt;/code&gt; &lt;/a&gt; respuestas que usan verificaciones de substr_count si el resultado es &lt;code&gt;&amp;gt;0&lt;/code&gt; . Pero como la declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; considera cero &lt;a href=&quot;http://php.net/manual/en/types.comparisons.php&quot;&gt;igual que falso&lt;/a&gt; , puede evitar esa verificaci&amp;oacute;n y escribir directamente:</target>
        </trans-unit>
        <trans-unit id="a003609987c3e7e1f11c9f4ce341edc37355c80b" translate="yes" xml:space="preserve">
          <source>Make use of &lt;strong&gt;case-insensitve matching&lt;/strong&gt; using &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Utilice la &lt;strong&gt;combinaci&amp;oacute;n de may&amp;uacute;sculas y min&amp;uacute;sculas&lt;/strong&gt; con &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="45dc916072b135e579c2ee41d82c2f641b8922e7" translate="yes" xml:space="preserve">
          <source>Maybe you could use something like this:</source>
          <target state="translated">Tal vez podrías usar algo como esto:</target>
        </trans-unit>
        <trans-unit id="1dac38c99792d6c78db01b0498112d26dbe98bc4" translate="yes" xml:space="preserve">
          <source>MySQL Fulltext Search Score Explained</source>
          <target state="translated">Explicación de la puntuación de la búsqueda de texto completo en MySQL</target>
        </trans-unit>
        <trans-unit id="a264d1851ace7e5dfc514edbe47e27ca1df83f6d" translate="yes" xml:space="preserve">
          <source>Note that the use of &lt;code&gt;!== false&lt;/code&gt; is deliberate (neither &lt;code&gt;!= false&lt;/code&gt; nor &lt;code&gt;=== true&lt;/code&gt; will return the desired result); &lt;code&gt;strpos()&lt;/code&gt; returns either the offset at which the needle string begins in the haystack string, or the boolean &lt;code&gt;false&lt;/code&gt; if the needle isn't found. Since 0 is a valid offset and 0 is &quot;falsey&quot;, we can't use simpler constructs like &lt;code&gt;!strpos($a, 'are')&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que el uso de &lt;code&gt;!== false&lt;/code&gt; es deliberado (ni &lt;code&gt;!= false&lt;/code&gt; ni &lt;code&gt;=== true&lt;/code&gt; devolver&amp;aacute; el resultado deseado); &lt;code&gt;strpos()&lt;/code&gt; devuelve el desplazamiento en el que comienza la cadena de agujas en la cadena de pajar o el booleano &lt;code&gt;false&lt;/code&gt; si no se encuentra la aguja. Como 0 es un desplazamiento v&amp;aacute;lido y 0 es &quot;falsey&quot;, no podemos usar construcciones m&amp;aacute;s simples como &lt;code&gt;!strpos($a, 'are')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb3314fdcfc00e6c1e40e9271e52bb518e86f0b6" translate="yes" xml:space="preserve">
          <source>Now, this can be quite problematic in some cases as the $search string isn't sanitized in any way, I mean, it might not pass the check in some cases as if &lt;code&gt;$search&lt;/code&gt; is a user input they can add some string that might behave like some different regular expression...</source>
          <target state="translated">Ahora, esto puede ser bastante problem&amp;aacute;tico en algunos casos, ya que la cadena de b&amp;uacute;squeda $ no est&amp;aacute; desinfectada de ninguna manera, es decir, podr&amp;iacute;a no pasar la verificaci&amp;oacute;n en algunos casos, ya que si &lt;code&gt;$search&lt;/code&gt; es una entrada del usuario, pueden agregar alguna cadena que podr&amp;iacute;a comportarse como una expresi&amp;oacute;n regular diferente ...</target>
        </trans-unit>
        <trans-unit id="9b517bf2bb3a82c47f3f403dd4bbcdb4056e9a30" translate="yes" xml:space="preserve">
          <source>On the performance side, &lt;code&gt;strpos&lt;/code&gt; is about three times faster and have in mind, when I did one million compares at once, it took &lt;a href=&quot;https://secure.php.net/manual/en/function.preg-match.php&quot;&gt;&lt;code&gt;preg_match&lt;/code&gt;&lt;/a&gt; 1.5 seconds to finish and for &lt;code&gt;strpos&lt;/code&gt; it took 0.5 seconds.</source>
          <target state="translated">Por el lado del rendimiento, &lt;code&gt;strpos&lt;/code&gt; es aproximadamente tres veces m&amp;aacute;s r&amp;aacute;pido y tenga en cuenta que cuando hice un mill&amp;oacute;n de comparaciones a la vez, &lt;a href=&quot;https://secure.php.net/manual/en/function.preg-match.php&quot;&gt; &lt;code&gt;preg_match&lt;/code&gt; &lt;/a&gt; 1.5 segundos en preg_match y para &lt;code&gt;strpos&lt;/code&gt; tard&amp;oacute; 0.5 segundos.</target>
        </trans-unit>
        <trans-unit id="b8dd4ac4674e94b729896ef5113fca86f853ef58" translate="yes" xml:space="preserve">
          <source>One way to do this and to specify the separators is using &lt;code&gt;preg_split&lt;/code&gt; (&lt;a href=&quot;http://php.net/manual/en/function.preg-split.php&quot;&gt;doc&lt;/a&gt;):</source>
          <target state="translated">Una forma de hacer esto y especificar los separadores es usar &lt;code&gt;preg_split&lt;/code&gt; ( &lt;a href=&quot;http://php.net/manual/en/function.preg-split.php&quot;&gt;doc&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="f21f13bdb437a884fb06e17b0896b9b0d7f10759" translate="yes" xml:space="preserve">
          <source>One way to mitigate this would be to use a regular expression coupled with &lt;a href=&quot;http://www.regular-expressions.info/wordboundaries.html&quot;&gt;word boundaries&lt;/a&gt; (&lt;code&gt;\b&lt;/code&gt;):</source>
          <target state="translated">Una forma de mitigar esto ser&amp;iacute;a utilizar una expresi&amp;oacute;n regular junto con &lt;a href=&quot;http://www.regular-expressions.info/wordboundaries.html&quot;&gt;l&amp;iacute;mites de palabras&lt;/a&gt; ( &lt;code&gt;\b&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="2f2dc7f1d5c30b526851de85106e46920df9b647" translate="yes" xml:space="preserve">
          <source>Peer to SamGoody and Lego Stormtroopr comments.</source>
          <target state="translated">Comentarios de Peer a SamGoody y Lego Stormtroopr.</target>
        </trans-unit>
        <trans-unit id="edc3a262e579e4f18107ab1571c94ef9e25076ad" translate="yes" xml:space="preserve">
          <source>Point to note: The strstr() function is case-sensitive. For a case-insensitive search, use the &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr()&lt;/a&gt; function.</source>
          <target state="translated">Punto a tener en cuenta: la funci&amp;oacute;n strstr () distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas. Para una b&amp;uacute;squeda que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas, use la funci&amp;oacute;n &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="991a6a91ca7eeccb09411cc8f7609f2065f9d754" translate="yes" xml:space="preserve">
          <source>Replace words with others which have an identical or similar meaning. 
(ex:replace instances of 'hungrily' and 'hungry' with 'hunger')</source>
          <target state="translated">Reemplazar las palabras con otras que tengan un significado idéntico o similar.(ex:reemplazar los casos de &quot;hambriento&quot; y &quot;hambriento&quot; por &quot;hambre&quot;)</target>
        </trans-unit>
        <trans-unit id="c61ea5e0f58b3846041d08ca013157e2727368bf" translate="yes" xml:space="preserve">
          <source>Suppose I have the code above, what is the correct way to write the statement &lt;code&gt;if ($a contains 'are')&lt;/code&gt;?</source>
          <target state="translated">Supongamos que tengo el c&amp;oacute;digo anterior, &amp;iquest;cu&amp;aacute;l es la forma correcta de escribir la declaraci&amp;oacute;n &lt;code&gt;if ($a contains 'are')&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="fba0c98c0a3e78e3d12ddcb4cfcf74e9fa3dd5eb" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; at the beginning of &quot;area&quot;</source>
          <target state="translated">El &quot;son&quot; al principio de &quot;área&quot;</target>
        </trans-unit>
        <trans-unit id="65750dec72e69bd6ff39a4cd067052598124521b" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; at the end of &quot;hare&quot;</source>
          <target state="translated">El &quot;son&quot; al final de &quot;liebre&quot;</target>
        </trans-unit>
        <trans-unit id="f9f8a2f0a59aac465b7b2e5829132ebadacd4d79" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in &quot;What _are_ you thinking?&quot;</source>
          <target state="translated">El &quot;son&quot; en &quot;¿Qué estás pensando?&quot;</target>
        </trans-unit>
        <trans-unit id="ff1600ce3aceaa25995ea3bed5fa16ea9e7f9d0f" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in &quot;lol u dunno wut those are4?&quot;</source>
          <target state="translated">El &quot;son&quot; en &quot;lol u dunno wut esos son4?&quot;</target>
        </trans-unit>
        <trans-unit id="6e73ec58021d66e8d244453eb8eecab178cd95e3" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in the middle of &quot;fares&quot;</source>
          <target state="translated">Los &quot;son&quot; en medio de &quot;tarifas&quot;</target>
        </trans-unit>
        <trans-unit id="af141695ab878d911b750be60dedc56b44a1366b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; at the end of regular expression changes regular expression to be case-insensitive, if you do not want that, you can leave it out.</source>
          <target state="translated">La &lt;code&gt;i&lt;/code&gt; al final de la expresi&amp;oacute;n regular cambia la expresi&amp;oacute;n regular para que no distinga entre may&amp;uacute;sculas y min&amp;uacute;sculas, si no lo desea, puede omitirlo.</target>
        </trans-unit>
        <trans-unit id="a58a61579fa10e87cfbc17dea3a1e7d4dee7a592" translate="yes" xml:space="preserve">
          <source>The function below also works and does not depend on any other function; it uses only native PHP string manipulation. Personally, I do not recommend this, but you can see how it works:</source>
          <target state="translated">La función que figura a continuación también funciona y no depende de ninguna otra función;sólo utiliza la manipulación nativa de cadenas de PHP.Personalmente,no recomiendo esto,pero puedes ver cómo funciona:</target>
        </trans-unit>
        <trans-unit id="f06677169500917274915f9ad5cfaf385a03d220" translate="yes" xml:space="preserve">
          <source>The reduction of numeric values by reducing precision are other ways of normalising the text.</source>
          <target state="translated">La reducción de los valores numéricos mediante la reducción de la precisión son otras formas de normalizar el texto.</target>
        </trans-unit>
        <trans-unit id="8acbf1d45a648165adc6a6e8fdf2236bcdcc9869" translate="yes" xml:space="preserve">
          <source>The replacement of colour names with their hexadecimal equivalents</source>
          <target state="translated">La sustitución de los nombres de los colores por sus equivalentes hexadecimales</target>
        </trans-unit>
        <trans-unit id="7bdbb776fba5a8dc6853756dead688035a67cceb" translate="yes" xml:space="preserve">
          <source>The short-hand version</source>
          <target state="translated">La versión corta</target>
        </trans-unit>
        <trans-unit id="074eb46fa2eab2604e12769117a414a5c815cc4b" translate="yes" xml:space="preserve">
          <source>The strpos function works fine, but if you want to do &lt;code&gt;case-insensitive&lt;/code&gt; checking for a word in a paragraph then you can make use of the &lt;code&gt;stripos&lt;/code&gt; function of &lt;code&gt;PHP&lt;/code&gt;.</source>
          <target state="translated">La funci&amp;oacute;n strpos funciona bien, pero si desea hacer &lt;code&gt;case-insensitive&lt;/code&gt; comprobaci&amp;oacute;n de may&amp;uacute;sculas y min&amp;uacute;sculas para una palabra en un p&amp;aacute;rrafo, puede utilizar la funci&amp;oacute;n &lt;code&gt;stripos&lt;/code&gt; de &lt;code&gt;PHP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe39f4f56248c0ed3b837778f579013127d494e1" translate="yes" xml:space="preserve">
          <source>There are plenty of improvements to be made
but the model provides a way of getting good results from natural queries, 
which don't have boolean operators such as &lt;code&gt;strpos()&lt;/code&gt;, &lt;code&gt;preg_match()&lt;/code&gt;, &lt;code&gt;strstr()&lt;/code&gt; or &lt;code&gt;stristr()&lt;/code&gt;.</source>
          <target state="translated">Hay muchas mejoras por hacer, pero el modelo proporciona una forma de obtener buenos resultados de las consultas naturales, que no tienen operadores booleanos como &lt;code&gt;strpos()&lt;/code&gt; , &lt;code&gt;preg_match()&lt;/code&gt; , &lt;code&gt;strstr()&lt;/code&gt; o &lt;code&gt;stristr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d219fd4683f024b1b46ac4b7362bae7eb53df97b" translate="yes" xml:space="preserve">
          <source>This is the idea of the vector space model, &lt;strong&gt;not far from how SQL full-text search works:&lt;/strong&gt;</source>
          <target state="translated">Esta es la idea del modelo de espacio vectorial, &lt;strong&gt;no muy lejos de c&amp;oacute;mo funciona la b&amp;uacute;squeda de texto completo de SQL:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="281072b73957e4edbd3e2582a1cfa67bfbc65be8" translate="yes" xml:space="preserve">
          <source>This is useful to avoid spam when sending emails for example.</source>
          <target state="translated">Esto es útil para evitar el spam en el envío de correos electrónicos,por ejemplo.</target>
        </trans-unit>
        <trans-unit id="8654cbc27d2dd80342d3a1c9c6aed7df2c779cab" translate="yes" xml:space="preserve">
          <source>This means the string has to be resolved into words (see note below).</source>
          <target state="translated">Esto significa que la cuerda tiene que ser resuelta en palabras (ver nota abajo).</target>
        </trans-unit>
        <trans-unit id="51a160776c2c7b3eab04ee3c79f29c6483cb965a" translate="yes" xml:space="preserve">
          <source>This method doesn't have the same false positives noted above, but it does have some edge cases of its own.  Word boundaries match on non-word characters (&lt;code&gt;\W&lt;/code&gt;), which are going to be anything that isn't &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;, or &lt;code&gt;_&lt;/code&gt;.  That means digits and underscores are going to be counted as word characters and scenarios like this will fail:</source>
          <target state="translated">Este m&amp;eacute;todo no tiene los mismos falsos positivos mencionados anteriormente, pero s&amp;iacute; tiene algunos casos extremos. Los l&amp;iacute;mites de palabras coinciden en caracteres que no son palabras ( &lt;code&gt;\W&lt;/code&gt; ), que ser&amp;aacute;n cualquier cosa que no sea &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; o &lt;code&gt;_&lt;/code&gt; . Eso significa que los d&amp;iacute;gitos y los guiones bajos se contar&amp;aacute;n como caracteres de palabras y escenarios como este fallar&amp;aacute;n:</target>
        </trans-unit>
        <trans-unit id="814d677a8f676b10f82ac5b818657779e061b6f0" translate="yes" xml:space="preserve">
          <source>To check if &lt;em&gt;not&lt;/em&gt; present, add the &lt;code&gt;!&lt;/code&gt; operator:</source>
          <target state="translated">Para verificar si &lt;em&gt;no est&amp;aacute;&lt;/em&gt; presente, agregue el &lt;code&gt;!&lt;/code&gt; operador:</target>
        </trans-unit>
        <trans-unit id="65c66e28ac6f1c0e38ec5e9659847cadea78cb2d" translate="yes" xml:space="preserve">
          <source>To combine both sets of functionality into a single multi-purpose function (including with selectable case sensitivity), you could use something like this:</source>
          <target state="translated">Para combinar ambos conjuntos de funciones en una única función multiuso (incluso con sensibilidad a las mayúsculas y minúsculas seleccionables),se podría utilizar algo así:</target>
        </trans-unit>
        <trans-unit id="10edf5fed7899dea96bf80a0ad1840566ed6e1a4" translate="yes" xml:space="preserve">
          <source>To determine whether a string contains another string you can use the PHP function &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;strpos()&lt;/a&gt;.</source>
          <target state="translated">Para determinar si una cadena contiene otra cadena, puede usar la funci&amp;oacute;n PHP &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;strpos ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16f2e11c8284a6bf0ac0d263cb869b551c3cca3e" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;&lt;code&gt;strstr()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.stristr.php&quot;&gt;&lt;code&gt;stristr()&lt;/code&gt;&lt;/a&gt; if your search should be case insensitive would be another option.</source>
          <target state="translated">Usar &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt; &lt;code&gt;strstr()&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;http://php.net/manual/en/function.stristr.php&quot;&gt; &lt;code&gt;stristr()&lt;/code&gt; &lt;/a&gt; si su b&amp;uacute;squeda no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas ser&amp;iacute;a otra opci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="efdcb8e898f459b234a8181ba616ea969d0119ad" translate="yes" xml:space="preserve">
          <source>What's the difference?  Substrings can appear within other words:</source>
          <target state="translated">¿Cuál es la diferencia? Los sustratos pueden aparecer dentro de otras palabras:</target>
        </trans-unit>
        <trans-unit id="aa590c482271336764621e55078baf0c591d5536" translate="yes" xml:space="preserve">
          <source>While most of these answers will tell you if a substring appears in your string, that's usually not what you want if you're looking for a particular &lt;em&gt;word&lt;/em&gt;, and not a &lt;em&gt;substring&lt;/em&gt;.</source>
          <target state="translated">Si bien la mayor&amp;iacute;a de estas respuestas le dir&amp;aacute;n si aparece una subcadena en su cadena, eso generalmente no es lo que desea si est&amp;aacute; buscando una &lt;em&gt;palabra en&lt;/em&gt; particular, y no una &lt;em&gt;subcadena&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="258937995fc341d4744a414cf73e47fe8f6bacc7" translate="yes" xml:space="preserve">
          <source>With the samples above, both &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; contains &lt;code&gt;$c&lt;/code&gt;, but you may want your function to tell you that only &lt;code&gt;$a&lt;/code&gt; contains &lt;code&gt;$c&lt;/code&gt;.</source>
          <target state="translated">Con los ejemplos anteriores, &lt;code&gt;$a&lt;/code&gt; y &lt;code&gt;$b&lt;/code&gt; contienen &lt;code&gt;$c&lt;/code&gt; , pero es posible que desee que su funci&amp;oacute;n le diga que solo &lt;code&gt;$a&lt;/code&gt; contiene &lt;code&gt;$c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa883bf0d02de1e50fb3029d25f98235c9f50d88" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;strpos()&lt;/code&gt; function.</source>
          <target state="translated">Tambi&amp;eacute;n puede usar la funci&amp;oacute;n &lt;code&gt;strpos()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="048e7d27353c157dc1b5bc47ecb679187e0f6ed6" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos()&lt;/code&gt;&lt;/a&gt; function which is used to find the occurrence of one string inside another one:</source>
          <target state="translated">Puede usar la funci&amp;oacute;n &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos()&lt;/code&gt; &lt;/a&gt; que se usa para encontrar la aparici&amp;oacute;n de una cadena dentro de otra:</target>
        </trans-unit>
        <trans-unit id="54493c19dbfc90ba47d4dd06b13bebcfabf9e240" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;strstr&lt;/code&gt; function:</source>
          <target state="translated">Puede usar la funci&amp;oacute;n &lt;code&gt;strstr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a6ce4df6c8750da05b0d98658e1056a1f84f5f17" translate="yes" xml:space="preserve">
          <source>You could use regular expressions, it's better for word matching compared to &lt;code&gt;strpos&lt;/code&gt; as mentioned by other users it will also return true for strings such as fare, care, stare, etc. This can simply be avoided in regular expression by using word boundaries.</source>
          <target state="translated">Puede usar expresiones regulares, es mejor para la coincidencia de palabras en comparaci&amp;oacute;n con los &lt;code&gt;strpos&lt;/code&gt; mencionados por otros usuarios, tambi&amp;eacute;n devolver&amp;aacute; verdadero para cadenas como fare, care, stare, etc. Esto simplemente se puede evitar en la expresi&amp;oacute;n regular mediante el uso de l&amp;iacute;mites de palabras.</target>
        </trans-unit>
        <trans-unit id="a0bec4b988172a1d14d0a06bdba132b97b07f5c8" translate="yes" xml:space="preserve">
          <source>You may notice that the previous solutions are not an answer for the word being used as a prefix for another. In order to use your example:</source>
          <target state="translated">Puede notar que las soluciones anteriores no son una respuesta para la palabra que se está usando como prefijo para otra.Para usar su ejemplo:</target>
        </trans-unit>
        <trans-unit id="a932d9c5bd36cc1e640ddd6ae01856aa33464c06" translate="yes" xml:space="preserve">
          <source>You need to use identical/not identical operators because strpos can return 0 as it's index value. If you like ternary operators, consider using the following (seems a little backwards I'll admit):</source>
          <target state="translated">Necesitas usar operadores idénticos-no idénticos porque los strpos pueden devolver 0 como su valor índice.Si te gustan los operadores ternarios,considera usar los siguientes (parece un poco atrasado,lo admito):</target>
        </trans-unit>
        <trans-unit id="17a4eaa70e6fca11cd3a0594e0e6ae22bcf5f5dd" translate="yes" xml:space="preserve">
          <source>You should use case Insensitive format,so if the entered value is in &lt;code&gt;small&lt;/code&gt; or &lt;code&gt;caps&lt;/code&gt; it wont matter.</source>
          <target state="translated">Debe usar el formato de may&amp;uacute;sculas y min&amp;uacute;sculas, por lo que si el valor ingresado es &lt;code&gt;small&lt;/code&gt; o con &lt;code&gt;caps&lt;/code&gt; , no importar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="9411b3f7d38c850e9e0ce1838744755ad62458f6" translate="yes" xml:space="preserve">
          <source>can't search for multiple words</source>
          <target state="translated">no puede buscar varias palabras</target>
        </trans-unit>
        <trans-unit id="15bf9afce4ffa3fbf44c7e834d049e617054404b" translate="yes" xml:space="preserve">
          <source>faster indexing and a consequently faster search.</source>
          <target state="translated">una indexación más rápida y una búsqueda consecuentemente más rápida.</target>
        </trans-unit>
        <trans-unit id="37ab7e92198730c935587e8eab4e183e80b042a6" translate="yes" xml:space="preserve">
          <source>less disk I/O</source>
          <target state="translated">menos disco IO</target>
        </trans-unit>
        <trans-unit id="f262c494e86d759eb3e2029edccdeaf071231d09" translate="yes" xml:space="preserve">
          <source>results are unranked</source>
          <target state="translated">los resultados no están ordenados</target>
        </trans-unit>
        <trans-unit id="274e89ab94a3541c57aa9a85d106d78e5be3f50e" translate="yes" xml:space="preserve">
          <source>thereby reducing index size and resulting in less storage requirement</source>
          <target state="translated">reduciendo así el tamaño del índice y dando lugar a una menor necesidad de almacenamiento</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
