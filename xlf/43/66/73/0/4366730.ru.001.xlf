<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/4366730">
    <body>
      <group id="4366730">
        <trans-unit id="536930aa45c4f9ebe04ec4eee9fe774d8b05ff5b" translate="yes" xml:space="preserve">
          <source>1- stristr()</source>
          <target state="translated">1-stristr()</target>
        </trans-unit>
        <trans-unit id="9c04eee059ec9710c163e4d720492795c8a32060" translate="yes" xml:space="preserve">
          <source>2- strpos()</source>
          <target state="translated">2-strpos()</target>
        </trans-unit>
        <trans-unit id="ae4b45ccf79b06e3929e1a3633b7a35b68e5cbbf" translate="yes" xml:space="preserve">
          <source>3- preg_match()</source>
          <target state="translated">3-preg_match()</target>
        </trans-unit>
        <trans-unit id="8d1a614572a1ef0c19a362e30bcd32eef314aab4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos&lt;/code&gt;&lt;/a&gt; finds the position of the first occurrence of a case-insensitive substring in a string.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos&lt;/code&gt; &lt;/a&gt; находит позицию первого вхождения нечувствительной к регистру подстроки в строке.</target>
        </trans-unit>
        <trans-unit id="d7edf7695232ace28ffa32c8559ecb9b1e5ea944" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos&lt;/code&gt;&lt;/a&gt; finds the position of the first occurrence of a case-sensitive substring in a string.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos&lt;/code&gt; &lt;/a&gt; находит позицию первого вхождения чувствительной к регистру подстроки в строке.</target>
        </trans-unit>
        <trans-unit id="65db47ef4129dadb5b064de72e4a9344d03d186d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;Look at &lt;code&gt;strpos()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;Посмотрите на &lt;code&gt;strpos()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="161a91404619d6734e80cd0778e5e2eb37c87d8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$caseSensitive ? A : B&lt;/code&gt; selects either &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos&lt;/code&gt;&lt;/a&gt; to do the work, depending on the value of &lt;code&gt;$caseSensitive&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$caseSensitive ? A : B&lt;/code&gt; A: B выбирает &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos&lt;/code&gt; &lt;/a&gt; для выполнения работы, в зависимости от значения &lt;code&gt;$caseSensitive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e43f3e39917183f03b6c7d8df65a3d6caaca77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myFunction($haystack, $needle) === FALSE ? FALSE : TRUE&lt;/code&gt; ensures that &lt;code&gt;myFunction&lt;/code&gt; always returns a boolean and fixes unexpected behavior when the index of the substring is 0.</source>
          <target state="translated">&lt;code&gt;myFunction($haystack, $needle) === FALSE ? FALSE : TRUE&lt;/code&gt; FALSE: TRUE гарантирует, что &lt;code&gt;myFunction&lt;/code&gt; всегда возвращает логическое значение и исправляет непредвиденное поведение, когда индекс подстроки равен 0.</target>
        </trans-unit>
        <trans-unit id="a38601451a7271300a3862930f2409a619504b87" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Optionally eliminating redundancy prior to search the words&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Опционально устранение избыточности перед поиском по словам&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b239b39dd3ea5d3bc28ab5e6594623814ae44575" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Normalisation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. Нормализация&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c2da9093478005107c83bcb253a85f687fcb20e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Stopword elimination&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Стоп-лосс&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15f70347f13635fdde48efd621a04e1cd494add" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Dictionary substitution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. Подстановка словаря&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d4d8c048007e19655046e44f48cfa683d97aa7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ДЕЛО 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b17fa346bb4f567be4a05b73d079ef9eeb1da6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ДЕЛО 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d2e913dec4051855fb256e532411a9b529ea94d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ДЕЛО 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4219c5f6fe25ad668c412bff701696037aef1b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAUTION:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CAUTION:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcde4902afc8a02e4348242ab9385feb6c8fa9c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issues with the other boolean search methods such as &lt;code&gt;strpos()&lt;/code&gt;, &lt;code&gt;preg_match()&lt;/code&gt;, &lt;code&gt;strstr()&lt;/code&gt; or &lt;code&gt;stristr()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Проблемы с другими булевыми методами поиска, такими как &lt;code&gt;strpos()&lt;/code&gt; , &lt;code&gt;preg_match()&lt;/code&gt; , &lt;code&gt;strstr()&lt;/code&gt; или &lt;code&gt;stristr()&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7666b304a8fca7faed968cac02ec2f4fede0f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTA BENE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;НОТА БЕНЕ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00c6ca567e32596c84c50e0fb28233adda888901" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Here we do not mean word for every sequence of symbols.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; здесь мы не подразумеваем слово для каждой последовательности символов.</target>
        </trans-unit>
        <trans-unit id="0464dc38e1fc7e588f4c179f040c57144d419a6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP method based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_space_model&quot;&gt;Vector Space Model&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf (term frequency&amp;ndash;inverse document frequency):&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Метод PHP, основанный на &lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_space_model&quot;&gt;модели векторного пространства&lt;/a&gt; и &lt;a href=&quot;http://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf (термин &amp;laquo;частота - обратная частота документа&amp;raquo;):&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="450025855baecd41e523dc05eafa16f85db4098f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHPCode Sample with output&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример PHPCode с выводом&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b7fe3ad4bb795df9d41e53255576530192a9be9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESOURCES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESOURCES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3d9b2805e24d71fd7dbe60ed49798186b321048" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESULT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESULT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e8719c6c93a3d522fb7415c04094d2b50b9a4f84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESULTS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESULTS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d03f4a89fe7c2757c20c5c42a24c135ce9e8e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Without using an inbuilt function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Без использования встроенной функции:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa1853953b71f4c41b3cc95fb3cca78efdd9c424" translate="yes" xml:space="preserve">
          <source>A &quot;word&quot; character is any letter or digit or the underscore character,
  that is, any character which can be part of a Perl &quot; word &quot;. The
  definition of letters and digits is controlled by PCRE's character
  tables, and may vary if locale-specific matching is taking place (..)</source>
          <target state="translated">Символ &quot;слово&quot;-это любая буква или цифра или символ подчеркивания,то есть любой символ,который может быть частью Perl &quot; слова &quot;.Определение букв и цифр контролируется таблицами символов PCRE и может меняться,если происходит локальное совпадение (...).</target>
        </trans-unit>
        <trans-unit id="f8f3f2943f82691039b22b2ebdeff76dd86282d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;==&lt;/code&gt; sign is a comparison and tests whether the variable / expression / constant to the left has the same value as the variable / expression / constant to the right.</source>
          <target state="translated">Знак &lt;code&gt;==&lt;/code&gt; является сравнением и проверяет, имеет ли переменная / выражение / константа слева то же значение, что и переменная / выражение / константа справа.</target>
        </trans-unit>
        <trans-unit id="b7e4f92de169b796d2edbe690758dfdf768e8e70" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;===&lt;/code&gt; sign is a comparison to see whether two variables / expresions / constants are equal &lt;code&gt;AND&lt;/code&gt; have the same type - i.e. both are strings or both are integers.</source>
          <target state="translated">Знак &lt;code&gt;===&lt;/code&gt; - это сравнение, чтобы увидеть, равны ли две переменные / выражения / константы &lt;code&gt;AND&lt;/code&gt; имеют ли они один и тот же тип - т.е. оба являются строками или оба являются целыми числами.</target>
        </trans-unit>
        <trans-unit id="e4920abb4f3b8892883bf5a41623c4aab2b1f548" translate="yes" xml:space="preserve">
          <source>A good article to understand why is &lt;em&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a&gt;&lt;/em&gt; by &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Joel_Spolsky&quot;&gt;Joel Spolsky&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Хорошая статья, чтобы понять, почему &lt;em&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;Абсолютный Минимум, Каждый Разработчик Программного Обеспечения Абсолютно, Положительно Должен Знать О Юникоде и Наборах Символов (Никаких Оправданий!)&lt;/a&gt;&lt;/em&gt; &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Joel_Spolsky&quot;&gt;От Джоэла Спольски&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f4dca82ce7301d5a56f3ffda9ea5d842b28eb7ec" translate="yes" xml:space="preserve">
          <source>A practical definition of word is in the sense the PCRE regular expression engine, where words are substrings consisting of word characters only, being separated by non-word characters.</source>
          <target state="translated">Практическое определение слова-в том смысле,в каком оно используется в движке регулярных выражений PCRE,где слова представляют собой подстроки,состоящие только из словесных символов,разделенных несловесными символами.</target>
        </trans-unit>
        <trans-unit id="5ec194c4603c00b67980b557f9d17564cb709fe7" translate="yes" xml:space="preserve">
          <source>A run gives</source>
          <target state="translated">Забег дает</target>
        </trans-unit>
        <trans-unit id="41a9b657064aaec58c7a71735974461119393ee2" translate="yes" xml:space="preserve">
          <source>A simple match for are could look something like this:</source>
          <target state="translated">Простое совпадение может выглядеть вот так:</target>
        </trans-unit>
        <trans-unit id="5005dc287716aef5b1fa0a49374df254f53b0a13" translate="yes" xml:space="preserve">
          <source>Also, here's a great tool for testing and seeing explanations of various regular expressions &lt;a href=&quot;https://regex101.com/&quot;&gt;Regex101&lt;/a&gt;</source>
          <target state="translated">Также, вот отличный инструмент для тестирования и просмотра объяснений различных регулярных выражений &lt;a href=&quot;https://regex101.com/&quot;&gt;Regex101.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="154f98e219ba2d530ab470fcb920ed2cf84456ee" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;strstr()&lt;/a&gt; function. Something like:</source>
          <target state="translated">Другой вариант - использовать &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;функцию strstr ()&lt;/a&gt; . Что-то типа:</target>
        </trans-unit>
        <trans-unit id="30eb8eef8b6e9b1c537d3b8ca07b74300cc86462" translate="yes" xml:space="preserve">
          <source>Another option to finding the occurrence of a word from a string using &lt;a href=&quot;http://www.php.net/manual/en/function.strstr.php&quot;&gt;strstr()&lt;/a&gt; and &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr()&lt;/a&gt; is like the following:</source>
          <target state="translated">Другой вариант поиска вхождения слова из строки с использованием &lt;a href=&quot;http://www.php.net/manual/en/function.strstr.php&quot;&gt;strstr ()&lt;/a&gt; и &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr ()&lt;/a&gt; выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="1c001274549b8d9c38352b77098a207b33210a25" translate="yes" xml:space="preserve">
          <source>Another solution for a specific string:</source>
          <target state="translated">Другое решение для конкретной строки:</target>
        </trans-unit>
        <trans-unit id="059fd4a17ec8f277845903f637b570f56ea31b4d" translate="yes" xml:space="preserve">
          <source>Basically, if you're &lt;strong&gt;having trouble finding words with characters specific to some languages&lt;/strong&gt;, such as German, French, Portuguese, Spanish, etc. (e.g.: &lt;em&gt;&amp;auml;&lt;/em&gt;, &lt;em&gt;&amp;eacute;&lt;/em&gt;, &lt;em&gt;&amp;ocirc;&lt;/em&gt;, &lt;em&gt;&amp;ccedil;&lt;/em&gt;, &lt;em&gt;&amp;ordm;&lt;/em&gt;, &lt;em&gt;&amp;ntilde;&lt;/em&gt;), you may want to precede the functions with &lt;code&gt;mb_&lt;/code&gt;. Therefore, the accepted answer would use &lt;a href=&quot;http://php.net/manual/en/function.mb-strpos.php&quot;&gt;&lt;code&gt;mb_strpos&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.mb-stripos.php&quot;&gt;&lt;code&gt;mb_stripos&lt;/code&gt;&lt;/a&gt; (for case-insensitive matching) instead:</source>
          <target state="translated">В основном, если у вас &lt;strong&gt;возникают проблемы с поиском слов с символами, характерными для некоторых языков&lt;/strong&gt; , например, немецкого, французского, португальского, испанского и т. Д. (Например, &lt;em&gt;&amp;auml;&lt;/em&gt; , &lt;em&gt;&amp;eacute;&lt;/em&gt; , &lt;em&gt;&amp;ocirc;&lt;/em&gt; , &lt;em&gt;&amp;ccedil;&lt;/em&gt; , &lt;em&gt;&amp;ordm;&lt;/em&gt; , &lt;em&gt;&amp;ntilde;&lt;/em&gt; ), вам может потребоваться предшествовать функции с &lt;code&gt;mb_&lt;/code&gt; . Следовательно, принятый ответ будет использовать &lt;a href=&quot;http://php.net/manual/en/function.mb-strpos.php&quot;&gt; &lt;code&gt;mb_strpos&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;http://php.net/manual/en/function.mb-stripos.php&quot;&gt; &lt;code&gt;mb_stripos&lt;/code&gt; &lt;/a&gt; (для сопоставления без учета регистра):</target>
        </trans-unit>
        <trans-unit id="c6ac2ebe3d53f92da9f6857d844261f13d940aaa" translate="yes" xml:space="preserve">
          <source>Check if string contains specific words?</source>
          <target state="translated">Проверьте,содержит ли строка конкретные слова?</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="995f64f15a13f374697065535435ba94d26464e7" translate="yes" xml:space="preserve">
          <source>Convert all text to lower case</source>
          <target state="translated">Конвертировать весь текст в нижний регистр</target>
        </trans-unit>
        <trans-unit id="112d1f61745b16ccc0356f918f7a7be16bdd57d2" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;preg_match()&lt;/code&gt; if you only want to check if one string is contained in another string. Use &lt;code&gt;strpos()&lt;/code&gt; or &lt;code&gt;strstr()&lt;/code&gt; instead as they will be faster. (&lt;a href=&quot;http://in2.php.net/preg_match&quot;&gt;http://in2.php.net/preg_match&lt;/a&gt;)</source>
          <target state="translated">Не используйте &lt;code&gt;preg_match()&lt;/code&gt; если вы хотите проверить, содержится ли одна строка в другой. &lt;code&gt;strstr()&lt;/code&gt; этого используйте &lt;code&gt;strpos()&lt;/code&gt; или strstr (), так как они будут быстрее. ( &lt;a href=&quot;http://in2.php.net/preg_match&quot;&gt;http://in2.php.net/preg_match&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="771ca06d7bb1df15a66af37bb337725931a04e2f" translate="yes" xml:space="preserve">
          <source>Edit:
In order to search any part of the string, not just word by word, I would recommend using a regular expression like</source>
          <target state="translated">Правка:Для поиска по любой части строки,а не только по слову,я бы порекомендовал использовать регулярное выражение вида</target>
        </trans-unit>
        <trans-unit id="a175d3309aa70f6eadc8fd006df92ee87672c066" translate="yes" xml:space="preserve">
          <source>Eliminate words from the text which carry no real meaning (like 'and', 'or', 'the', 'for', etc.)</source>
          <target state="translated">Исключить из текста слова,не имеющие реального значения (например,&quot;и&quot;,&quot;или&quot;,&quot;или&quot;,&quot;для&quot; и т.д.).</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="f8838d8c3e8de7ea1720befe670b6ddecdfca0fa" translate="yes" xml:space="preserve">
          <source>Find the position of the first occurrence of a case-insensitive substring in a string.</source>
          <target state="translated">Найдите позицию первого появления подстроки,не чувствительной к регистру,в строке.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="8e347c4e5e5f169d1f544caeabe3acbdeb0a1fd6" translate="yes" xml:space="preserve">
          <source>Further algorithmic measures (snowball) may be performed to further reduce words to their essential meaning.</source>
          <target state="translated">Дополнительные алгоритмические меры (снежный ком)могут быть выполнены для дальнейшего сокращения слов до их существенного значения.</target>
        </trans-unit>
        <trans-unit id="868013052501a3915b42071b147883eee03a3899" translate="yes" xml:space="preserve">
          <source>Here is a little utility function that is useful in situations like this</source>
          <target state="translated">Вот небольшая полезная функция,которая полезна в таких ситуациях,как эта</target>
        </trans-unit>
        <trans-unit id="640ccdb37a48eedfabd85e115efe42bf0f97e2b4" translate="yes" xml:space="preserve">
          <source>Here stripos finds needle in heystack &lt;strong&gt;without&lt;/strong&gt; considering case (small/caps).</source>
          <target state="translated">Здесь стрипос находит иголку в стоге сена &lt;strong&gt;без&lt;/strong&gt; учета случая (маленький / заглушки)</target>
        </trans-unit>
        <trans-unit id="828d73986d577dc553333bd6f21ac565c1fb423c" translate="yes" xml:space="preserve">
          <source>How do I check if a string contains a specific word</source>
          <target state="translated">Как проверить,содержит ли строка конкретное слово</target>
        </trans-unit>
        <trans-unit id="224b8efc0b9ac26641de6ae359e96fd868125065" translate="yes" xml:space="preserve">
          <source>I had some trouble with this, and finally I chose to create my own solution. Without using &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; engine:</source>
          <target state="translated">У меня были некоторые проблемы с этим, и, наконец, я решил создать свое собственное решение. Без использования механизма &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;регулярных выражений&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="a42d6e1c43dd12b71ad626eaa7d6b3ea6944040b" translate="yes" xml:space="preserve">
          <source>I'm a bit impressed that none of the answers here that used &lt;code&gt;strpos&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt; and similar functions mentioned &lt;a href=&quot;http://php.net/manual/en/ref.mbstring.php&quot;&gt;Multibyte String Functions&lt;/a&gt; yet (2015-05-08).</source>
          <target state="translated">Я немного впечатлен тем, что ни один из ответов, в которых использовались &lt;code&gt;strpos&lt;/code&gt; , &lt;code&gt;strstr&lt;/code&gt; и подобные функции, не упоминал о &lt;a href=&quot;http://php.net/manual/en/ref.mbstring.php&quot;&gt;многобайтовых строковых функциях&lt;/a&gt; (2015-05-08)</target>
        </trans-unit>
        <trans-unit id="fa8035d683dec343995234343194912e2e44077e" translate="yes" xml:space="preserve">
          <source>If the needle you are searching for is at the beginning of the haystack it will return position 0, if you do a &lt;code&gt;==&lt;/code&gt; compare that will not work, you will need to do a &lt;code&gt;===&lt;/code&gt;</source>
          <target state="translated">Если искомая игла находится в начале стога сена, она вернет позицию 0, если вы выполните сравнение &lt;code&gt;==&lt;/code&gt; , которое не будет работать, вам нужно будет выполнить &lt;code&gt;===&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="914d8946f736f2babcc727a583d93362c1a80a2b" translate="yes" xml:space="preserve">
          <source>If the word doesn't exist in the string then it will return false else it will return the position of the word.</source>
          <target state="translated">Если слова нет в строке,то оно вернет false,иначе вернется положение слова.</target>
        </trans-unit>
        <trans-unit id="0ca72b4ba6418cfdc9d8f0766d5bbbaed69c8c46" translate="yes" xml:space="preserve">
          <source>If we could weight the terms in a string based on how representative they are of the string as a whole, 
we could order our results by the ones that best match the query.</source>
          <target state="translated">Если бы мы могли взвешивать термины в строке,основываясь на том,насколько они репрезентативны для строки в целом,мы могли бы упорядочить наши результаты по тем,которые наилучшим образом соответствуют запросу.</target>
        </trans-unit>
        <trans-unit id="f22ff471b11f2348e549c1430ff4e7c026fa09ca" translate="yes" xml:space="preserve">
          <source>If we want to search for multiple words in a string the core problem is how we assign a weight to each one of them?</source>
          <target state="translated">Если мы хотим найти несколько слов в строке,то основная проблема заключается в том,как мы присваиваем вес каждому из них?</target>
        </trans-unit>
        <trans-unit id="7301e6fd4a01ccad442ed786a4bba0c369969b9f" translate="yes" xml:space="preserve">
          <source>If you are looking for a PHP algorithm to &lt;strong&gt;rank search results based on proximity/relevance&lt;/strong&gt; of multiple words
here comes a quick and easy way of generating search results with PHP only:</source>
          <target state="translated">Если вы ищете PHP-алгоритм для &lt;strong&gt;ранжирования результатов поиска на основе близости / релевантности&lt;/strong&gt; нескольких слов, вот быстрый и простой способ получения результатов поиска только с помощью PHP:</target>
        </trans-unit>
        <trans-unit id="177529202720249ead729bcdcae74deef04b45b8" translate="yes" xml:space="preserve">
          <source>If you cannot guarantee that &lt;a href=&quot;https://stackoverflow.com/a/1744518/1326147&quot;&gt;&lt;em&gt;all your data is 100% in UTF-8&lt;/em&gt;&lt;/a&gt;, you may want to use the &lt;code&gt;mb_&lt;/code&gt; functions.</source>
          <target state="translated">Если вы не можете гарантировать, что &lt;a href=&quot;https://stackoverflow.com/a/1744518/1326147&quot;&gt;&lt;em&gt;все ваши данные на 100% в UTF-8&lt;/em&gt;&lt;/a&gt; , вы можете использовать функции &lt;code&gt;mb_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b09fd6a82cef6361ad80b45ebbcfda266a96e009" translate="yes" xml:space="preserve">
          <source>If you want anything more accurate than this, you'll have to start doing English language syntax parsing, and that's a pretty big can of worms (and assumes proper use of syntax, anyway, which isn't always a given).</source>
          <target state="translated">Если вы хотите что-то более точное,чем это,вам придется начать делать синтаксический разбор английского языка,и это довольно большая банка червей (и предполагает правильное использование синтаксиса,в любом случае,что не всегда является данностью).</target>
        </trans-unit>
        <trans-unit id="e8f50c16e936b75ab4e2005421136e0198edf974" translate="yes" xml:space="preserve">
          <source>If you want to avoid the &quot;falsey&quot; and &quot;truthy&quot; problem, you can use substr_count:</source>
          <target state="translated">Если вы хотите избежать проблемы &quot;falsey&quot; и &quot;truthy&quot;,вы можете использовать substr_count:</target>
        </trans-unit>
        <trans-unit id="068ce11b70ff847aa349c2e01c1c982a84e0bfdd" translate="yes" xml:space="preserve">
          <source>If you want to check if the string contains several specifics words, you can do:</source>
          <target state="translated">Если вы хотите проверить,содержит ли строка несколько специфических слов,вы можете это сделать:</target>
        </trans-unit>
        <trans-unit id="8c9649b02c5520357914939e07ddb195baefdc95" translate="yes" xml:space="preserve">
          <source>In PHP, the best way to verify if a string contains a certain substring, is to use a simple helper function like this:</source>
          <target state="translated">В PHP лучший способ проверить,содержит ли строка определенную подстроку,-это использовать простую вспомогательную функцию,подобную этой:</target>
        </trans-unit>
        <trans-unit id="0944f82b5ffe8e68399c6e203bfeb6491b34006e" translate="yes" xml:space="preserve">
          <source>In order to find a 'word', rather than the occurrence of a series of letters that could in fact be a part of another word, the following would be a good solution.</source>
          <target state="translated">Для того чтобы найти &quot;слово&quot;,а не серию букв,которые на самом деле могут быть частью другого слова,хорошим решением было бы следующее.</target>
        </trans-unit>
        <trans-unit id="32cdcd308cc39dd176a93ce07644fddfb6a72f8d" translate="yes" xml:space="preserve">
          <source>It can be done in three different ways:</source>
          <target state="translated">Это можно сделать тремя разными способами:</target>
        </trans-unit>
        <trans-unit id="471b011a086e49e68c14b691be41feb79ca9ef15" translate="yes" xml:space="preserve">
          <source>It sounds difficult but is surprisingly easy.</source>
          <target state="translated">Звучит сложно,но на удивление просто.</target>
        </trans-unit>
        <trans-unit id="0a69fd82c05b687cc1c6fc980796c044246e1001" translate="yes" xml:space="preserve">
          <source>It's a bit slower than strpos but it avoids the comparison problems.</source>
          <target state="translated">Это немного медленнее,чем strpos,но позволяет избежать проблем со сравнением.</target>
        </trans-unit>
        <trans-unit id="8fefbf5fa8ffae8b83fd2f9f21c6c5bcc031055d" translate="yes" xml:space="preserve">
          <source>Lot of answers that use &lt;a href=&quot;http://php.net/manual/en/function.substr-count.php&quot;&gt;&lt;code&gt;substr_count&lt;/code&gt;&lt;/a&gt; checks if the result is &lt;code&gt;&amp;gt;0&lt;/code&gt;. But since the &lt;code&gt;if&lt;/code&gt; statement considers zero the &lt;a href=&quot;http://php.net/manual/en/types.comparisons.php&quot;&gt;same as false&lt;/a&gt;, you can avoid that check and write directly:</source>
          <target state="translated">Много ответов, использующих &lt;a href=&quot;http://php.net/manual/en/function.substr-count.php&quot;&gt; &lt;code&gt;substr_count&lt;/code&gt; ,&lt;/a&gt; проверяет, равен ли результат &lt;code&gt;&amp;gt;0&lt;/code&gt; . Но поскольку оператор &lt;code&gt;if&lt;/code&gt; считает ноль тем &lt;a href=&quot;http://php.net/manual/en/types.comparisons.php&quot;&gt;же, что и ложь&lt;/a&gt; , вы можете избежать этой проверки и написать напрямую:</target>
        </trans-unit>
        <trans-unit id="a003609987c3e7e1f11c9f4ce341edc37355c80b" translate="yes" xml:space="preserve">
          <source>Make use of &lt;strong&gt;case-insensitve matching&lt;/strong&gt; using &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Используйте &lt;strong&gt;сопоставление без&lt;/strong&gt; &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos()&lt;/code&gt; &lt;/a&gt; &lt;strong&gt;регистра,&lt;/strong&gt; используя stripos () :</target>
        </trans-unit>
        <trans-unit id="45dc916072b135e579c2ee41d82c2f641b8922e7" translate="yes" xml:space="preserve">
          <source>Maybe you could use something like this:</source>
          <target state="translated">Может,тебе пригодится что-нибудь вроде этого:</target>
        </trans-unit>
        <trans-unit id="1dac38c99792d6c78db01b0498112d26dbe98bc4" translate="yes" xml:space="preserve">
          <source>MySQL Fulltext Search Score Explained</source>
          <target state="translated">Объясненная оценка полнотекстового поиска MySQL</target>
        </trans-unit>
        <trans-unit id="a264d1851ace7e5dfc514edbe47e27ca1df83f6d" translate="yes" xml:space="preserve">
          <source>Note that the use of &lt;code&gt;!== false&lt;/code&gt; is deliberate (neither &lt;code&gt;!= false&lt;/code&gt; nor &lt;code&gt;=== true&lt;/code&gt; will return the desired result); &lt;code&gt;strpos()&lt;/code&gt; returns either the offset at which the needle string begins in the haystack string, or the boolean &lt;code&gt;false&lt;/code&gt; if the needle isn't found. Since 0 is a valid offset and 0 is &quot;falsey&quot;, we can't use simpler constructs like &lt;code&gt;!strpos($a, 'are')&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что использование &lt;code&gt;!== false&lt;/code&gt; является преднамеренным (ни &lt;code&gt;!= false&lt;/code&gt; ни &lt;code&gt;=== true&lt;/code&gt; не вернут желаемый результат); &lt;code&gt;strpos()&lt;/code&gt; возвращает либо смещение, с которого начинается строка иглы в строке сена, либо логическое значение &lt;code&gt;false&lt;/code&gt; , если игла не найдена. Поскольку 0 является допустимым смещением, а 0 - &quot;ложным&quot;, мы не можем использовать более простые конструкции, такие как &lt;code&gt;!strpos($a, 'are')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb3314fdcfc00e6c1e40e9271e52bb518e86f0b6" translate="yes" xml:space="preserve">
          <source>Now, this can be quite problematic in some cases as the $search string isn't sanitized in any way, I mean, it might not pass the check in some cases as if &lt;code&gt;$search&lt;/code&gt; is a user input they can add some string that might behave like some different regular expression...</source>
          <target state="translated">Теперь, это может быть довольно проблематично в некоторых случаях, так как строка $ search не очищается каким-либо образом, я имею в виду, что в некоторых случаях она может не пройти проверку, так как если &lt;code&gt;$search&lt;/code&gt; является пользовательским вводом, они могут добавить некоторую строку, которая может вести себя как какое-то другое регулярное выражение ...</target>
        </trans-unit>
        <trans-unit id="9b517bf2bb3a82c47f3f403dd4bbcdb4056e9a30" translate="yes" xml:space="preserve">
          <source>On the performance side, &lt;code&gt;strpos&lt;/code&gt; is about three times faster and have in mind, when I did one million compares at once, it took &lt;a href=&quot;https://secure.php.net/manual/en/function.preg-match.php&quot;&gt;&lt;code&gt;preg_match&lt;/code&gt;&lt;/a&gt; 1.5 seconds to finish and for &lt;code&gt;strpos&lt;/code&gt; it took 0.5 seconds.</source>
          <target state="translated">Что касается производительности, &lt;code&gt;strpos&lt;/code&gt; работает примерно в три раза быстрее и имеет в виду, что когда я сделал миллион сравнений одновременно, &lt;a href=&quot;https://secure.php.net/manual/en/function.preg-match.php&quot;&gt; &lt;code&gt;preg_match&lt;/code&gt; &lt;/a&gt; потребовалось 1,5 секунды, чтобы завершиться, а для &lt;code&gt;strpos&lt;/code&gt; потребовалось 0,5 секунды.</target>
        </trans-unit>
        <trans-unit id="b8dd4ac4674e94b729896ef5113fca86f853ef58" translate="yes" xml:space="preserve">
          <source>One way to do this and to specify the separators is using &lt;code&gt;preg_split&lt;/code&gt; (&lt;a href=&quot;http://php.net/manual/en/function.preg-split.php&quot;&gt;doc&lt;/a&gt;):</source>
          <target state="translated">Один из способов сделать это и указать разделители - использовать &lt;code&gt;preg_split&lt;/code&gt; ( &lt;a href=&quot;http://php.net/manual/en/function.preg-split.php&quot;&gt;doc&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="f21f13bdb437a884fb06e17b0896b9b0d7f10759" translate="yes" xml:space="preserve">
          <source>One way to mitigate this would be to use a regular expression coupled with &lt;a href=&quot;http://www.regular-expressions.info/wordboundaries.html&quot;&gt;word boundaries&lt;/a&gt; (&lt;code&gt;\b&lt;/code&gt;):</source>
          <target state="translated">Одним из способов смягчения этого было бы использование регулярного выражения в сочетании с &lt;a href=&quot;http://www.regular-expressions.info/wordboundaries.html&quot;&gt;границами слова&lt;/a&gt; ( &lt;code&gt;\b&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="2f2dc7f1d5c30b526851de85106e46920df9b647" translate="yes" xml:space="preserve">
          <source>Peer to SamGoody and Lego Stormtroopr comments.</source>
          <target state="translated">Пирите комментарии SamGoody и Lego Stormtroopr.</target>
        </trans-unit>
        <trans-unit id="edc3a262e579e4f18107ab1571c94ef9e25076ad" translate="yes" xml:space="preserve">
          <source>Point to note: The strstr() function is case-sensitive. For a case-insensitive search, use the &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr()&lt;/a&gt; function.</source>
          <target state="translated">Обратите внимание: функция strstr () чувствительна к регистру. Для поиска без &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;учета&lt;/a&gt; регистра используйте функцию stristr () .</target>
        </trans-unit>
        <trans-unit id="991a6a91ca7eeccb09411cc8f7609f2065f9d754" translate="yes" xml:space="preserve">
          <source>Replace words with others which have an identical or similar meaning. 
(ex:replace instances of 'hungrily' and 'hungry' with 'hunger')</source>
          <target state="translated">Замените слова на другие,которые имеют идентичное или похожее значение.(Например,заменить слова &quot;голодный&quot; и &quot;голодный&quot; словом &quot;голодный&quot;).</target>
        </trans-unit>
        <trans-unit id="c61ea5e0f58b3846041d08ca013157e2727368bf" translate="yes" xml:space="preserve">
          <source>Suppose I have the code above, what is the correct way to write the statement &lt;code&gt;if ($a contains 'are')&lt;/code&gt;?</source>
          <target state="translated">Предположим, у меня есть код выше, как правильно написать оператор, &lt;code&gt;if ($a contains 'are')&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="fba0c98c0a3e78e3d12ddcb4cfcf74e9fa3dd5eb" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; at the beginning of &quot;area&quot;</source>
          <target state="translated">&quot;есть&quot; в начале &quot;области&quot;.</target>
        </trans-unit>
        <trans-unit id="65750dec72e69bd6ff39a4cd067052598124521b" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; at the end of &quot;hare&quot;</source>
          <target state="translated">&quot;есть&quot; в конце &quot;заяц&quot;...</target>
        </trans-unit>
        <trans-unit id="f9f8a2f0a59aac465b7b2e5829132ebadacd4d79" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in &quot;What _are_ you thinking?&quot;</source>
          <target state="translated">&quot;Есть&quot; в &quot;О чем ты думаешь?&quot;</target>
        </trans-unit>
        <trans-unit id="ff1600ce3aceaa25995ea3bed5fa16ea9e7f9d0f" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in &quot;lol u dunno wut those are4?&quot;</source>
          <target state="translated">&quot;are&quot; в &quot;lol u dunno wut those are4&quot;?</target>
        </trans-unit>
        <trans-unit id="6e73ec58021d66e8d244453eb8eecab178cd95e3" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in the middle of &quot;fares&quot;</source>
          <target state="translated">В середине &quot;тарифов&quot;...</target>
        </trans-unit>
        <trans-unit id="af141695ab878d911b750be60dedc56b44a1366b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; at the end of regular expression changes regular expression to be case-insensitive, if you do not want that, you can leave it out.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; в конце регулярного выражения меняет регулярное выражение, чтобы оно не учитывало регистр, если вы этого не хотите, вы можете его пропустить.</target>
        </trans-unit>
        <trans-unit id="a58a61579fa10e87cfbc17dea3a1e7d4dee7a592" translate="yes" xml:space="preserve">
          <source>The function below also works and does not depend on any other function; it uses only native PHP string manipulation. Personally, I do not recommend this, but you can see how it works:</source>
          <target state="translated">Функция,приведенная ниже,также работает и не зависит от любой другой функции;она использует только нативную манипуляцию со строками PHP.Лично я не рекомендую этого,но вы можете посмотреть,как она работает:</target>
        </trans-unit>
        <trans-unit id="f06677169500917274915f9ad5cfaf385a03d220" translate="yes" xml:space="preserve">
          <source>The reduction of numeric values by reducing precision are other ways of normalising the text.</source>
          <target state="translated">Уменьшение числовых значений за счет снижения точности-это другие способы нормализации текста.</target>
        </trans-unit>
        <trans-unit id="8acbf1d45a648165adc6a6e8fdf2236bcdcc9869" translate="yes" xml:space="preserve">
          <source>The replacement of colour names with their hexadecimal equivalents</source>
          <target state="translated">Замена названий цветов на их шестнадцатеричные эквиваленты.</target>
        </trans-unit>
        <trans-unit id="7bdbb776fba5a8dc6853756dead688035a67cceb" translate="yes" xml:space="preserve">
          <source>The short-hand version</source>
          <target state="translated">Короткая версия</target>
        </trans-unit>
        <trans-unit id="074eb46fa2eab2604e12769117a414a5c815cc4b" translate="yes" xml:space="preserve">
          <source>The strpos function works fine, but if you want to do &lt;code&gt;case-insensitive&lt;/code&gt; checking for a word in a paragraph then you can make use of the &lt;code&gt;stripos&lt;/code&gt; function of &lt;code&gt;PHP&lt;/code&gt;.</source>
          <target state="translated">Функция strpos работает нормально, но если вы хотите выполнить проверку слова в абзаце без &lt;code&gt;stripos&lt;/code&gt; то вы можете использовать функцию stripos в &lt;code&gt;PHP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe39f4f56248c0ed3b837778f579013127d494e1" translate="yes" xml:space="preserve">
          <source>There are plenty of improvements to be made
but the model provides a way of getting good results from natural queries, 
which don't have boolean operators such as &lt;code&gt;strpos()&lt;/code&gt;, &lt;code&gt;preg_match()&lt;/code&gt;, &lt;code&gt;strstr()&lt;/code&gt; or &lt;code&gt;stristr()&lt;/code&gt;.</source>
          <target state="translated">Есть много улучшений, которые необходимо внести, но модель предоставляет способ получения хороших результатов от естественных запросов, которые не имеют логических операторов, таких как &lt;code&gt;strpos()&lt;/code&gt; , &lt;code&gt;preg_match()&lt;/code&gt; , &lt;code&gt;strstr()&lt;/code&gt; или &lt;code&gt;stristr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d219fd4683f024b1b46ac4b7362bae7eb53df97b" translate="yes" xml:space="preserve">
          <source>This is the idea of the vector space model, &lt;strong&gt;not far from how SQL full-text search works:&lt;/strong&gt;</source>
          <target state="translated">Это идея модели векторного пространства, &lt;strong&gt;не очень похожая на то, как работает полнотекстовый поиск SQL:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="281072b73957e4edbd3e2582a1cfa67bfbc65be8" translate="yes" xml:space="preserve">
          <source>This is useful to avoid spam when sending emails for example.</source>
          <target state="translated">Это полезно для того,чтобы избежать спама,например,при отправке писем.</target>
        </trans-unit>
        <trans-unit id="8654cbc27d2dd80342d3a1c9c6aed7df2c779cab" translate="yes" xml:space="preserve">
          <source>This means the string has to be resolved into words (see note below).</source>
          <target state="translated">Это означает,что строка должна быть разрешена в слова (см.примечание ниже).</target>
        </trans-unit>
        <trans-unit id="51a160776c2c7b3eab04ee3c79f29c6483cb965a" translate="yes" xml:space="preserve">
          <source>This method doesn't have the same false positives noted above, but it does have some edge cases of its own.  Word boundaries match on non-word characters (&lt;code&gt;\W&lt;/code&gt;), which are going to be anything that isn't &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;, or &lt;code&gt;_&lt;/code&gt;.  That means digits and underscores are going to be counted as word characters and scenarios like this will fail:</source>
          <target state="translated">Этот метод не имеет таких же ложных срабатываний, отмеченных выше, но у него есть некоторые собственные крайние случаи. Границы слов совпадают с несловесными символами ( &lt;code&gt;\W&lt;/code&gt; ), которые могут быть чем угодно, кроме &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; или &lt;code&gt;_&lt;/code&gt; . Это означает, что цифры и подчеркивания будут учитываться как символы слова, и сценарии, подобные этому, потерпят неудачу:</target>
        </trans-unit>
        <trans-unit id="814d677a8f676b10f82ac5b818657779e061b6f0" translate="yes" xml:space="preserve">
          <source>To check if &lt;em&gt;not&lt;/em&gt; present, add the &lt;code&gt;!&lt;/code&gt; operator:</source>
          <target state="translated">Чтобы проверить, если &lt;em&gt;нет&lt;/em&gt; , добавьте &lt;code&gt;!&lt;/code&gt; оператор:</target>
        </trans-unit>
        <trans-unit id="65c66e28ac6f1c0e38ec5e9659847cadea78cb2d" translate="yes" xml:space="preserve">
          <source>To combine both sets of functionality into a single multi-purpose function (including with selectable case sensitivity), you could use something like this:</source>
          <target state="translated">Для объединения обоих наборов функций в одну многофункциональную функцию (в том числе с возможностью выбора чувствительности к регистру)можно использовать нечто подобное:</target>
        </trans-unit>
        <trans-unit id="10edf5fed7899dea96bf80a0ad1840566ed6e1a4" translate="yes" xml:space="preserve">
          <source>To determine whether a string contains another string you can use the PHP function &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;strpos()&lt;/a&gt;.</source>
          <target state="translated">Чтобы определить, содержит ли строка другую строку, вы можете использовать функцию PHP &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;strpos ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16f2e11c8284a6bf0ac0d263cb869b551c3cca3e" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;&lt;code&gt;strstr()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.stristr.php&quot;&gt;&lt;code&gt;stristr()&lt;/code&gt;&lt;/a&gt; if your search should be case insensitive would be another option.</source>
          <target state="translated">Использование &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt; &lt;code&gt;strstr()&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;http://php.net/manual/en/function.stristr.php&quot;&gt; &lt;code&gt;stristr()&lt;/code&gt; &lt;/a&gt; если ваш поиск должен быть без учета регистра, было бы другим вариантом.</target>
        </trans-unit>
        <trans-unit id="efdcb8e898f459b234a8181ba616ea969d0119ad" translate="yes" xml:space="preserve">
          <source>What's the difference?  Substrings can appear within other words:</source>
          <target state="translated">Какая разница? Подстроки могут появляться внутри других слов:</target>
        </trans-unit>
        <trans-unit id="aa590c482271336764621e55078baf0c591d5536" translate="yes" xml:space="preserve">
          <source>While most of these answers will tell you if a substring appears in your string, that's usually not what you want if you're looking for a particular &lt;em&gt;word&lt;/em&gt;, and not a &lt;em&gt;substring&lt;/em&gt;.</source>
          <target state="translated">Хотя большинство из этих ответов скажут вам, появляется ли в вашей строке подстрока, обычно это не то, что вам нужно, если вы ищете определенное &lt;em&gt;слово&lt;/em&gt; , а не &lt;em&gt;подстроку&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="258937995fc341d4744a414cf73e47fe8f6bacc7" translate="yes" xml:space="preserve">
          <source>With the samples above, both &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; contains &lt;code&gt;$c&lt;/code&gt;, but you may want your function to tell you that only &lt;code&gt;$a&lt;/code&gt; contains &lt;code&gt;$c&lt;/code&gt;.</source>
          <target state="translated">В приведенных выше примерах и &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; содержат &lt;code&gt;$c&lt;/code&gt; , но вы можете захотеть, чтобы ваша функция сообщала вам, что только &lt;code&gt;$a&lt;/code&gt; содержит &lt;code&gt;$c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa883bf0d02de1e50fb3029d25f98235c9f50d88" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;strpos()&lt;/code&gt; function.</source>
          <target state="translated">Вы также можете использовать функцию &lt;code&gt;strpos()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="048e7d27353c157dc1b5bc47ecb679187e0f6ed6" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos()&lt;/code&gt;&lt;/a&gt; function which is used to find the occurrence of one string inside another one:</source>
          <target state="translated">Вы можете использовать функцию &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos()&lt;/code&gt; &lt;/a&gt; которая используется для поиска вхождения одной строки в другую:</target>
        </trans-unit>
        <trans-unit id="54493c19dbfc90ba47d4dd06b13bebcfabf9e240" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;strstr&lt;/code&gt; function:</source>
          <target state="translated">Вы можете использовать функцию &lt;code&gt;strstr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a6ce4df6c8750da05b0d98658e1056a1f84f5f17" translate="yes" xml:space="preserve">
          <source>You could use regular expressions, it's better for word matching compared to &lt;code&gt;strpos&lt;/code&gt; as mentioned by other users it will also return true for strings such as fare, care, stare, etc. This can simply be avoided in regular expression by using word boundaries.</source>
          <target state="translated">Вы можете использовать регулярные выражения, лучше для сопоставления слов по сравнению с &lt;code&gt;strpos&lt;/code&gt; , как уже упоминалось другими пользователями, он также будет возвращать true для таких строк, как стоимость, уход, взгляд и т. Д. Этого можно просто избежать в регулярном выражении, используя границы слов.</target>
        </trans-unit>
        <trans-unit id="a0bec4b988172a1d14d0a06bdba132b97b07f5c8" translate="yes" xml:space="preserve">
          <source>You may notice that the previous solutions are not an answer for the word being used as a prefix for another. In order to use your example:</source>
          <target state="translated">Вы можете заметить,что предыдущие решения не являются ответом на слово,используемое в качестве префикса для другого.Для того,чтобы использовать ваш пример:</target>
        </trans-unit>
        <trans-unit id="a932d9c5bd36cc1e640ddd6ae01856aa33464c06" translate="yes" xml:space="preserve">
          <source>You need to use identical/not identical operators because strpos can return 0 as it's index value. If you like ternary operators, consider using the following (seems a little backwards I'll admit):</source>
          <target state="translated">Нужно использовать не идентичные операторы,потому что strpos может вернуть 0 в качестве значения индекса.Если Вам нравятся тернарные операторы,то подумайте об использовании следующих (кажется,немного задом наперёд,признаюсь):</target>
        </trans-unit>
        <trans-unit id="17a4eaa70e6fca11cd3a0594e0e6ae22bcf5f5dd" translate="yes" xml:space="preserve">
          <source>You should use case Insensitive format,so if the entered value is in &lt;code&gt;small&lt;/code&gt; or &lt;code&gt;caps&lt;/code&gt; it wont matter.</source>
          <target state="translated">Вы должны использовать регистр без учета регистра, поэтому, если введенное значение &lt;code&gt;small&lt;/code&gt; или &lt;code&gt;caps&lt;/code&gt; это не имеет значения.</target>
        </trans-unit>
        <trans-unit id="9411b3f7d38c850e9e0ce1838744755ad62458f6" translate="yes" xml:space="preserve">
          <source>can't search for multiple words</source>
          <target state="translated">не может найти несколько слов</target>
        </trans-unit>
        <trans-unit id="15bf9afce4ffa3fbf44c7e834d049e617054404b" translate="yes" xml:space="preserve">
          <source>faster indexing and a consequently faster search.</source>
          <target state="translated">ускорение индексирования и,следовательно,более быстрый поиск.</target>
        </trans-unit>
        <trans-unit id="37ab7e92198730c935587e8eab4e183e80b042a6" translate="yes" xml:space="preserve">
          <source>less disk I/O</source>
          <target state="translated">минус дисковый ввод данных</target>
        </trans-unit>
        <trans-unit id="f262c494e86d759eb3e2029edccdeaf071231d09" translate="yes" xml:space="preserve">
          <source>results are unranked</source>
          <target state="translated">результаты не оценены</target>
        </trans-unit>
        <trans-unit id="274e89ab94a3541c57aa9a85d106d78e5be3f50e" translate="yes" xml:space="preserve">
          <source>thereby reducing index size and resulting in less storage requirement</source>
          <target state="translated">тем самым уменьшая размер индекса и,как следствие,снижая потребность в хранении.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
