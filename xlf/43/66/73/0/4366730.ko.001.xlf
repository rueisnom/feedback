<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/4366730">
    <body>
      <group id="4366730">
        <trans-unit id="536930aa45c4f9ebe04ec4eee9fe774d8b05ff5b" translate="yes" xml:space="preserve">
          <source>1- stristr()</source>
          <target state="translated">1- 스트리스트 ()</target>
        </trans-unit>
        <trans-unit id="9c04eee059ec9710c163e4d720492795c8a32060" translate="yes" xml:space="preserve">
          <source>2- strpos()</source>
          <target state="translated">2- 스트랩 ()</target>
        </trans-unit>
        <trans-unit id="ae4b45ccf79b06e3929e1a3633b7a35b68e5cbbf" translate="yes" xml:space="preserve">
          <source>3- preg_match()</source>
          <target state="translated">3- preg_match ()</target>
        </trans-unit>
        <trans-unit id="8d1a614572a1ef0c19a362e30bcd32eef314aab4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos&lt;/code&gt;&lt;/a&gt; finds the position of the first occurrence of a case-insensitive substring in a string.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos&lt;/code&gt; &lt;/a&gt; 는 문자열에서 대소 문자를 구분하지 않는 부분 문자열이 처음 나타나는 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d7edf7695232ace28ffa32c8559ecb9b1e5ea944" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos&lt;/code&gt;&lt;/a&gt; finds the position of the first occurrence of a case-sensitive substring in a string.</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos&lt;/code&gt; &lt;/a&gt; 는 문자열에서 대소 문자 구분 서브 스트링이 처음 나타나는 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="65db47ef4129dadb5b064de72e4a9344d03d186d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;Look at &lt;code&gt;strpos()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="161a91404619d6734e80cd0778e5e2eb37c87d8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$caseSensitive ? A : B&lt;/code&gt; selects either &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos&lt;/code&gt;&lt;/a&gt; to do the work, depending on the value of &lt;code&gt;$caseSensitive&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$caseSensitive ? A : B&lt;/code&gt; A : B 는 &lt;code&gt;$caseSensitive&lt;/code&gt; 값에 따라 작업을 수행 할 &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos&lt;/code&gt; &lt;/a&gt; 를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="8e43f3e39917183f03b6c7d8df65a3d6caaca77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myFunction($haystack, $needle) === FALSE ? FALSE : TRUE&lt;/code&gt; ensures that &lt;code&gt;myFunction&lt;/code&gt; always returns a boolean and fixes unexpected behavior when the index of the substring is 0.</source>
          <target state="translated">&lt;code&gt;myFunction($haystack, $needle) === FALSE ? FALSE : TRUE&lt;/code&gt; FALSE : TRUE 는 &lt;code&gt;myFunction&lt;/code&gt; 이 항상 부울을 반환하고 부분 문자열의 인덱스가 0 일 때 예기치 않은 동작을 수정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a38601451a7271300a3862930f2409a619504b87" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Optionally eliminating redundancy prior to search the words&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;선택적으로 단어를 검색하기 전에 중복성을 제거&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b239b39dd3ea5d3bc28ab5e6594623814ae44575" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Normalisation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. 정규화&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c2da9093478005107c83bcb253a85f687fcb20e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Stopword elimination&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. 스톱 워드 제거&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15f70347f13635fdde48efd621a04e1cd494add" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Dictionary substitution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. 사전 대체&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d4d8c048007e19655046e44f48cfa683d97aa7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사례 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b17fa346bb4f567be4a05b73d079ef9eeb1da6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사례 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d2e913dec4051855fb256e532411a9b529ea94d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CASE 3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사례 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4219c5f6fe25ad668c412bff701696037aef1b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CAUTION:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;CAUTION:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcde4902afc8a02e4348242ab9385feb6c8fa9c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issues with the other boolean search methods such as &lt;code&gt;strpos()&lt;/code&gt;, &lt;code&gt;preg_match()&lt;/code&gt;, &lt;code&gt;strstr()&lt;/code&gt; or &lt;code&gt;stristr()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;strpos()&lt;/code&gt; , &lt;code&gt;preg_match()&lt;/code&gt; , &lt;code&gt;strstr()&lt;/code&gt; 또는 &lt;code&gt;stristr()&lt;/code&gt; 와 같은 다른 부울 검색 방법 관련 문제&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7666b304a8fca7faed968cac02ec2f4fede0f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTA BENE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTA BENE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00c6ca567e32596c84c50e0fb28233adda888901" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Here we do not mean word for every sequence of symbols.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 여기서는 모든 기호 시퀀스에 대한 단어를 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="0464dc38e1fc7e588f4c179f040c57144d419a6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP method based on &lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_space_model&quot;&gt;Vector Space Model&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf (term frequency&amp;ndash;inverse document frequency):&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Vector_space_model&quot;&gt;Vector Space Model&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf (term frequency-inverse document frequency)&lt;/a&gt; 기반 PHP 방법 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="450025855baecd41e523dc05eafa16f85db4098f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHPCode Sample with output&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;출력이있는 PHPCode 샘플&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b7fe3ad4bb795df9d41e53255576530192a9be9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESOURCES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESOURCES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3d9b2805e24d71fd7dbe60ed49798186b321048" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESULT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESULT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e8719c6c93a3d522fb7415c04094d2b50b9a4f84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESULTS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;RESULTS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6d03f4a89fe7c2757c20c5c42a24c135ce9e8e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Without using an inbuilt function:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;내장 함수를 사용하지 않고 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa1853953b71f4c41b3cc95fb3cca78efdd9c424" translate="yes" xml:space="preserve">
          <source>A &quot;word&quot; character is any letter or digit or the underscore character,
  that is, any character which can be part of a Perl &quot; word &quot;. The
  definition of letters and digits is controlled by PCRE's character
  tables, and may vary if locale-specific matching is taking place (..)</source>
          <target state="translated">&quot;단어&quot;문자는 문자 또는 숫자 또는 밑줄 문자, 즉 Perl &quot;단어&quot;의 일부가 될 수있는 문자입니다. 문자 및 숫자의 정의는 PCRE의 문자표에 의해 제어되며 로케일 별 일치가 발생하는 경우 달라질 수 있습니다 (..)</target>
        </trans-unit>
        <trans-unit id="f8f3f2943f82691039b22b2ebdeff76dd86282d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;==&lt;/code&gt; sign is a comparison and tests whether the variable / expression / constant to the left has the same value as the variable / expression / constant to the right.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 부호는 비교이며 왼쪽의 변수 / 표현식 / 상수가 오른쪽의 변수 / 표현식 / 상수와 같은 값인지 여부를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="b7e4f92de169b796d2edbe690758dfdf768e8e70" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;===&lt;/code&gt; sign is a comparison to see whether two variables / expresions / constants are equal &lt;code&gt;AND&lt;/code&gt; have the same type - i.e. both are strings or both are integers.</source>
          <target state="translated">&lt;code&gt;===&lt;/code&gt; 부호는 두 변수 / expresions / 상수가 같고 유형이 같은지 여부를 비교하는 것입니다. 즉 둘 다 문자열이거나 둘 다 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e4920abb4f3b8892883bf5a41623c4aab2b1f548" translate="yes" xml:space="preserve">
          <source>A good article to understand why is &lt;em&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&lt;/a&gt;&lt;/em&gt; by &lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Joel_Spolsky&quot;&gt;Joel Spolsky&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Joel_Spolsky&quot;&gt;Joel Spolsky의&lt;/a&gt;&lt;/em&gt; &lt;em&gt;&lt;a href=&quot;http://www.joelonsoftware.com/articles/Unicode.html&quot;&gt;유니 코드 및 문자 집합 (변명 없음)&lt;/a&gt;&lt;/em&gt; 에 &lt;em&gt;대해 절대적으로 모든 소프트웨어 개발자가 절대적&lt;/em&gt; 으로 알아야하는 이유를 이해하는 좋은 기사입니다.</target>
        </trans-unit>
        <trans-unit id="f4dca82ce7301d5a56f3ffda9ea5d842b28eb7ec" translate="yes" xml:space="preserve">
          <source>A practical definition of word is in the sense the PCRE regular expression engine, where words are substrings consisting of word characters only, being separated by non-word characters.</source>
          <target state="translated">단어의 실제 정의는 PCRE 정규식 엔진의 의미에서 단어는 단어 문자만으로 구성되고 단어가 아닌 문자로 구분되는 하위 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5ec194c4603c00b67980b557f9d17564cb709fe7" translate="yes" xml:space="preserve">
          <source>A run gives</source>
          <target state="translated">실행은 제공</target>
        </trans-unit>
        <trans-unit id="41a9b657064aaec58c7a71735974461119393ee2" translate="yes" xml:space="preserve">
          <source>A simple match for are could look something like this:</source>
          <target state="translated">에 대한 간단한 일치는 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5005dc287716aef5b1fa0a49374df254f53b0a13" translate="yes" xml:space="preserve">
          <source>Also, here's a great tool for testing and seeing explanations of various regular expressions &lt;a href=&quot;https://regex101.com/&quot;&gt;Regex101&lt;/a&gt;</source>
          <target state="translated">또한 다양한 정규식 &lt;a href=&quot;https://regex101.com/&quot;&gt;Regex101에&lt;/a&gt; 대한 설명을 테스트하고 설명하는 훌륭한 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="154f98e219ba2d530ab470fcb920ed2cf84456ee" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;strstr()&lt;/a&gt; function. Something like:</source>
          <target state="translated">또 다른 옵션은 &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;strstr ()&lt;/a&gt; 함수를 사용하는 것입니다. 다음과 같은 것 :</target>
        </trans-unit>
        <trans-unit id="30eb8eef8b6e9b1c537d3b8ca07b74300cc86462" translate="yes" xml:space="preserve">
          <source>Another option to finding the occurrence of a word from a string using &lt;a href=&quot;http://www.php.net/manual/en/function.strstr.php&quot;&gt;strstr()&lt;/a&gt; and &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr()&lt;/a&gt; is like the following:</source>
          <target state="translated">&lt;a href=&quot;http://www.php.net/manual/en/function.strstr.php&quot;&gt;strstr ()&lt;/a&gt; 및 &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr ()를&lt;/a&gt; 사용하여 문자열에서 단어의 발생을 찾는 다른 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c001274549b8d9c38352b77098a207b33210a25" translate="yes" xml:space="preserve">
          <source>Another solution for a specific string:</source>
          <target state="translated">특정 문자열에 대한 또 다른 솔루션 :</target>
        </trans-unit>
        <trans-unit id="059fd4a17ec8f277845903f637b570f56ea31b4d" translate="yes" xml:space="preserve">
          <source>Basically, if you're &lt;strong&gt;having trouble finding words with characters specific to some languages&lt;/strong&gt;, such as German, French, Portuguese, Spanish, etc. (e.g.: &lt;em&gt;&amp;auml;&lt;/em&gt;, &lt;em&gt;&amp;eacute;&lt;/em&gt;, &lt;em&gt;&amp;ocirc;&lt;/em&gt;, &lt;em&gt;&amp;ccedil;&lt;/em&gt;, &lt;em&gt;&amp;ordm;&lt;/em&gt;, &lt;em&gt;&amp;ntilde;&lt;/em&gt;), you may want to precede the functions with &lt;code&gt;mb_&lt;/code&gt;. Therefore, the accepted answer would use &lt;a href=&quot;http://php.net/manual/en/function.mb-strpos.php&quot;&gt;&lt;code&gt;mb_strpos&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.mb-stripos.php&quot;&gt;&lt;code&gt;mb_stripos&lt;/code&gt;&lt;/a&gt; (for case-insensitive matching) instead:</source>
          <target state="translated">기본적으로 독일어, 프랑스어, 포르투갈어, 스페인어 등과 같은 &lt;strong&gt;일부 언어에 특정한 문자가있는 단어를 찾는 데 어려움&lt;/strong&gt; 이있는 경우 (예 : &lt;em&gt;&amp;auml;&lt;/em&gt; , &lt;em&gt;&amp;eacute;&lt;/em&gt; , &lt;em&gt;&amp;ocirc;&lt;/em&gt; , &lt;em&gt;&amp;ccedil;&lt;/em&gt; , &lt;em&gt;&amp;ordm;&lt;/em&gt; , &lt;em&gt;&amp;ntilde;&lt;/em&gt; ) &lt;code&gt;mb_&lt;/code&gt; 함수 따라서 허용되는 답변은 &lt;a href=&quot;http://php.net/manual/en/function.mb-strpos.php&quot;&gt; &lt;code&gt;mb_strpos&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://php.net/manual/en/function.mb-stripos.php&quot;&gt; &lt;code&gt;mb_stripos&lt;/code&gt; &lt;/a&gt; (대소 문자를 구분하지 않는 일치)를 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c6ac2ebe3d53f92da9f6857d844261f13d940aaa" translate="yes" xml:space="preserve">
          <source>Check if string contains specific words?</source>
          <target state="translated">문자열에 특정 단어가 포함되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="995f64f15a13f374697065535435ba94d26464e7" translate="yes" xml:space="preserve">
          <source>Convert all text to lower case</source>
          <target state="translated">모든 텍스트를 소문자로 변환</target>
        </trans-unit>
        <trans-unit id="112d1f61745b16ccc0356f918f7a7be16bdd57d2" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;preg_match()&lt;/code&gt; if you only want to check if one string is contained in another string. Use &lt;code&gt;strpos()&lt;/code&gt; or &lt;code&gt;strstr()&lt;/code&gt; instead as they will be faster. (&lt;a href=&quot;http://in2.php.net/preg_match&quot;&gt;http://in2.php.net/preg_match&lt;/a&gt;)</source>
          <target state="translated">한 문자열이 다른 문자열에 포함되어 있는지 확인하려는 경우 &lt;code&gt;preg_match()&lt;/code&gt; 사용하지 마십시오. 대신 &lt;code&gt;strpos()&lt;/code&gt; 또는 &lt;code&gt;strstr()&lt;/code&gt; 사용 하십시오 . ( &lt;a href=&quot;http://in2.php.net/preg_match&quot;&gt;http://in2.php.net/preg_match&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="771ca06d7bb1df15a66af37bb337725931a04e2f" translate="yes" xml:space="preserve">
          <source>Edit:
In order to search any part of the string, not just word by word, I would recommend using a regular expression like</source>
          <target state="translated">편집 : 단어별로뿐만 아니라 문자열의 일부를 검색하려면 다음과 같은 정규 표현식을 사용하는 것이 좋습니다</target>
        </trans-unit>
        <trans-unit id="a175d3309aa70f6eadc8fd006df92ee87672c066" translate="yes" xml:space="preserve">
          <source>Eliminate words from the text which carry no real meaning (like 'and', 'or', 'the', 'for', etc.)</source>
          <target state="translated">실제 의미가없는 텍스트에서 단어를 제거하십시오 (예 : 'and', 'or', 'the', 'for'등)</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="f8838d8c3e8de7ea1720befe670b6ddecdfca0fa" translate="yes" xml:space="preserve">
          <source>Find the position of the first occurrence of a case-insensitive substring in a string.</source>
          <target state="translated">문자열에서 대소 문자를 구분하지 않는 하위 문자열이 처음 나타나는 위치를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="8e347c4e5e5f169d1f544caeabe3acbdeb0a1fd6" translate="yes" xml:space="preserve">
          <source>Further algorithmic measures (snowball) may be performed to further reduce words to their essential meaning.</source>
          <target state="translated">단어를 필수 의미로 추가로 줄이기 위해 추가 알고리즘 측정 (스노우 볼)이 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="868013052501a3915b42071b147883eee03a3899" translate="yes" xml:space="preserve">
          <source>Here is a little utility function that is useful in situations like this</source>
          <target state="translated">다음과 같은 상황에서 유용한 작은 유틸리티 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="640ccdb37a48eedfabd85e115efe42bf0f97e2b4" translate="yes" xml:space="preserve">
          <source>Here stripos finds needle in heystack &lt;strong&gt;without&lt;/strong&gt; considering case (small/caps).</source>
          <target state="translated">여기서 stripos는 대소 문자 &lt;strong&gt;를&lt;/strong&gt; 고려 &lt;strong&gt;하지 않고&lt;/strong&gt; heystack에서 needle을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="828d73986d577dc553333bd6f21ac565c1fb423c" translate="yes" xml:space="preserve">
          <source>How do I check if a string contains a specific word</source>
          <target state="translated">문자열에 특정 단어가 포함되어 있는지 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="224b8efc0b9ac26641de6ae359e96fd868125065" translate="yes" xml:space="preserve">
          <source>I had some trouble with this, and finally I chose to create my own solution. Without using &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; engine:</source>
          <target state="translated">나는 이것에 약간의 문제가 있었고 마침내 나는 내 자신의 솔루션을 만들기로 결정했다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_expression&quot;&gt;정규식&lt;/a&gt; 엔진을 사용하지 않는 경우 :</target>
        </trans-unit>
        <trans-unit id="a42d6e1c43dd12b71ad626eaa7d6b3ea6944040b" translate="yes" xml:space="preserve">
          <source>I'm a bit impressed that none of the answers here that used &lt;code&gt;strpos&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt; and similar functions mentioned &lt;a href=&quot;http://php.net/manual/en/ref.mbstring.php&quot;&gt;Multibyte String Functions&lt;/a&gt; yet (2015-05-08).</source>
          <target state="translated">&lt;code&gt;strpos&lt;/code&gt; , &lt;code&gt;strstr&lt;/code&gt; 및 이와 유사한 함수를 사용한 응답이 아직 &lt;a href=&quot;http://php.net/manual/en/ref.mbstring.php&quot;&gt;멀티 바이트 문자열 함수&lt;/a&gt; (2015-05-08)를 언급하지 않았다는 것에 약간 감명 받았습니다.</target>
        </trans-unit>
        <trans-unit id="fa8035d683dec343995234343194912e2e44077e" translate="yes" xml:space="preserve">
          <source>If the needle you are searching for is at the beginning of the haystack it will return position 0, if you do a &lt;code&gt;==&lt;/code&gt; compare that will not work, you will need to do a &lt;code&gt;===&lt;/code&gt;</source>
          <target state="translated">검색중인 바늘이 건초 더미의 시작 부분에 있으면 위치 0을 반환합니다. &lt;code&gt;==&lt;/code&gt; 비교하지 않으면 작동하지 않습니다 &lt;code&gt;===&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="914d8946f736f2babcc727a583d93362c1a80a2b" translate="yes" xml:space="preserve">
          <source>If the word doesn't exist in the string then it will return false else it will return the position of the word.</source>
          <target state="translated">단어가 문자열에 존재하지 않으면 false를 반환하고 그렇지 않으면 단어의 위치를 ​​반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ca72b4ba6418cfdc9d8f0766d5bbbaed69c8c46" translate="yes" xml:space="preserve">
          <source>If we could weight the terms in a string based on how representative they are of the string as a whole, 
we could order our results by the ones that best match the query.</source>
          <target state="translated">문자열 전체의 대표성을 기준으로 문자열에 용어의 가중치를 부여 할 수 있으면 쿼리와 가장 일치하는 결과로 결과를 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f22ff471b11f2348e549c1430ff4e7c026fa09ca" translate="yes" xml:space="preserve">
          <source>If we want to search for multiple words in a string the core problem is how we assign a weight to each one of them?</source>
          <target state="translated">문자열에서 여러 단어를 검색하려면 핵심 문제는 각 단어에 가중치를 할당하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7301e6fd4a01ccad442ed786a4bba0c369969b9f" translate="yes" xml:space="preserve">
          <source>If you are looking for a PHP algorithm to &lt;strong&gt;rank search results based on proximity/relevance&lt;/strong&gt; of multiple words
here comes a quick and easy way of generating search results with PHP only:</source>
          <target state="translated">여러 단어의 &lt;strong&gt;근접성 / 관련성&lt;/strong&gt; 에 &lt;strong&gt;따라 검색 결과의 순위&lt;/strong&gt; 를 &lt;strong&gt;매기&lt;/strong&gt; 는 PHP 알고리즘을 찾고 있다면 PHP로만 검색 결과를 생성하는 빠르고 쉬운 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="177529202720249ead729bcdcae74deef04b45b8" translate="yes" xml:space="preserve">
          <source>If you cannot guarantee that &lt;a href=&quot;https://stackoverflow.com/a/1744518/1326147&quot;&gt;&lt;em&gt;all your data is 100% in UTF-8&lt;/em&gt;&lt;/a&gt;, you may want to use the &lt;code&gt;mb_&lt;/code&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/1744518/1326147&quot;&gt;&lt;em&gt;모든 데이터가 UTF-8로 100 %&lt;/em&gt;&lt;/a&gt; 임을 보장 할 수없는 경우 &lt;code&gt;mb_&lt;/code&gt; 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b09fd6a82cef6361ad80b45ebbcfda266a96e009" translate="yes" xml:space="preserve">
          <source>If you want anything more accurate than this, you'll have to start doing English language syntax parsing, and that's a pretty big can of worms (and assumes proper use of syntax, anyway, which isn't always a given).</source>
          <target state="translated">이보다 더 정확한 것을 원한다면 영어 구문 구문 분석을 시작해야합니다. 그리고 그것은 꽤 큰 웜 캔입니다 (어쨌든 항상 주어진 것은 아니지만 구문을 올바르게 사용한다고 가정합니다).</target>
        </trans-unit>
        <trans-unit id="e8f50c16e936b75ab4e2005421136e0198edf974" translate="yes" xml:space="preserve">
          <source>If you want to avoid the &quot;falsey&quot; and &quot;truthy&quot; problem, you can use substr_count:</source>
          <target state="translated">&quot;falsey&quot;및 &quot;truthy&quot;문제를 피하려면 substr_count를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="068ce11b70ff847aa349c2e01c1c982a84e0bfdd" translate="yes" xml:space="preserve">
          <source>If you want to check if the string contains several specifics words, you can do:</source>
          <target state="translated">문자열에 몇 가지 구체적인 단어가 포함되어 있는지 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8c9649b02c5520357914939e07ddb195baefdc95" translate="yes" xml:space="preserve">
          <source>In PHP, the best way to verify if a string contains a certain substring, is to use a simple helper function like this:</source>
          <target state="translated">PHP에서 문자열에 특정 하위 문자열이 포함되어 있는지 확인하는 가장 좋은 방법은 다음과 같은 간단한 도우미 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0944f82b5ffe8e68399c6e203bfeb6491b34006e" translate="yes" xml:space="preserve">
          <source>In order to find a 'word', rather than the occurrence of a series of letters that could in fact be a part of another word, the following would be a good solution.</source>
          <target state="translated">실제로 다른 단어의 일부가 될 수있는 일련의 문자가 아닌 '단어'를 찾으려면 다음과 같은 방법이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="32cdcd308cc39dd176a93ce07644fddfb6a72f8d" translate="yes" xml:space="preserve">
          <source>It can be done in three different ways:</source>
          <target state="translated">세 가지 방법으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="471b011a086e49e68c14b691be41feb79ca9ef15" translate="yes" xml:space="preserve">
          <source>It sounds difficult but is surprisingly easy.</source>
          <target state="translated">어렵게 들리지만 놀라 울 정도로 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="0a69fd82c05b687cc1c6fc980796c044246e1001" translate="yes" xml:space="preserve">
          <source>It's a bit slower than strpos but it avoids the comparison problems.</source>
          <target state="translated">strpos보다 약간 느리지 만 비교 문제를 피합니다.</target>
        </trans-unit>
        <trans-unit id="8fefbf5fa8ffae8b83fd2f9f21c6c5bcc031055d" translate="yes" xml:space="preserve">
          <source>Lot of answers that use &lt;a href=&quot;http://php.net/manual/en/function.substr-count.php&quot;&gt;&lt;code&gt;substr_count&lt;/code&gt;&lt;/a&gt; checks if the result is &lt;code&gt;&amp;gt;0&lt;/code&gt;. But since the &lt;code&gt;if&lt;/code&gt; statement considers zero the &lt;a href=&quot;http://php.net/manual/en/types.comparisons.php&quot;&gt;same as false&lt;/a&gt;, you can avoid that check and write directly:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.substr-count.php&quot;&gt; &lt;code&gt;substr_count&lt;/code&gt; &lt;/a&gt; 를 사용하는 많은 답변은 결과가 &lt;code&gt;&amp;gt;0&lt;/code&gt; 인지 확인합니다. 그러나 &lt;code&gt;if&lt;/code&gt; 문은 0 &lt;a href=&quot;http://php.net/manual/en/types.comparisons.php&quot;&gt;을 false와 동일하게&lt;/a&gt; 간주하므로 검사를 피하고 직접 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a003609987c3e7e1f11c9f4ce341edc37355c80b" translate="yes" xml:space="preserve">
          <source>Make use of &lt;strong&gt;case-insensitve matching&lt;/strong&gt; using &lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt;&lt;code&gt;stripos()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.stripos.php&quot;&gt; &lt;code&gt;stripos()&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;strong&gt;대소 문자를 구분하지 않는 일치를&lt;/strong&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="45dc916072b135e579c2ee41d82c2f641b8922e7" translate="yes" xml:space="preserve">
          <source>Maybe you could use something like this:</source>
          <target state="translated">아마도 당신은 다음과 같은 것을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1dac38c99792d6c78db01b0498112d26dbe98bc4" translate="yes" xml:space="preserve">
          <source>MySQL Fulltext Search Score Explained</source>
          <target state="translated">MySQL 전문 검색 점수 설명</target>
        </trans-unit>
        <trans-unit id="a264d1851ace7e5dfc514edbe47e27ca1df83f6d" translate="yes" xml:space="preserve">
          <source>Note that the use of &lt;code&gt;!== false&lt;/code&gt; is deliberate (neither &lt;code&gt;!= false&lt;/code&gt; nor &lt;code&gt;=== true&lt;/code&gt; will return the desired result); &lt;code&gt;strpos()&lt;/code&gt; returns either the offset at which the needle string begins in the haystack string, or the boolean &lt;code&gt;false&lt;/code&gt; if the needle isn't found. Since 0 is a valid offset and 0 is &quot;falsey&quot;, we can't use simpler constructs like &lt;code&gt;!strpos($a, 'are')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!== false&lt;/code&gt; 사용하는 것은 의도적입니다 ( &lt;code&gt;!= false&lt;/code&gt; 또는 &lt;code&gt;=== true&lt;/code&gt; 는 원하는 결과를 반환하지 않습니다). &lt;code&gt;strpos()&lt;/code&gt; 는 haystack 문자열에서 바늘 문자열이 시작되는 오프셋을 반환하거나 바늘을 찾을 수 없으면 부울 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. 0은 유효한 오프셋이고 0은 &quot;falsey&quot;이므로 &lt;code&gt;!strpos($a, 'are')&lt;/code&gt; 와 같은 더 간단한 구문을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb3314fdcfc00e6c1e40e9271e52bb518e86f0b6" translate="yes" xml:space="preserve">
          <source>Now, this can be quite problematic in some cases as the $search string isn't sanitized in any way, I mean, it might not pass the check in some cases as if &lt;code&gt;$search&lt;/code&gt; is a user input they can add some string that might behave like some different regular expression...</source>
          <target state="translated">이제 $ search 문자열이 어떤 식 으로든 위생 처리되지 않기 때문에 일부 경우에 상당히 문제가 될 수 있습니다. 즉, &lt;code&gt;$search&lt;/code&gt; 가 사용자 입력 인 것처럼 확인을 통과하지 못할 수도 있습니다. 다른 정규 표현식처럼 행동하십시오 ...</target>
        </trans-unit>
        <trans-unit id="9b517bf2bb3a82c47f3f403dd4bbcdb4056e9a30" translate="yes" xml:space="preserve">
          <source>On the performance side, &lt;code&gt;strpos&lt;/code&gt; is about three times faster and have in mind, when I did one million compares at once, it took &lt;a href=&quot;https://secure.php.net/manual/en/function.preg-match.php&quot;&gt;&lt;code&gt;preg_match&lt;/code&gt;&lt;/a&gt; 1.5 seconds to finish and for &lt;code&gt;strpos&lt;/code&gt; it took 0.5 seconds.</source>
          <target state="translated">성능 측면에서 &lt;code&gt;strpos&lt;/code&gt; 는 약 3 배 빠르며 한 번에 백만 번 비교를 할 때 &lt;a href=&quot;https://secure.php.net/manual/en/function.preg-match.php&quot;&gt; &lt;code&gt;preg_match&lt;/code&gt; 가&lt;/a&gt; 1.5 초 &lt;code&gt;strpos&lt;/code&gt; 는 0.5 초가 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="b8dd4ac4674e94b729896ef5113fca86f853ef58" translate="yes" xml:space="preserve">
          <source>One way to do this and to specify the separators is using &lt;code&gt;preg_split&lt;/code&gt; (&lt;a href=&quot;http://php.net/manual/en/function.preg-split.php&quot;&gt;doc&lt;/a&gt;):</source>
          <target state="translated">이를 수행하고 구분 기호를 지정하는 한 가지 방법은 &lt;code&gt;preg_split&lt;/code&gt; ( &lt;a href=&quot;http://php.net/manual/en/function.preg-split.php&quot;&gt;doc&lt;/a&gt; )을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f21f13bdb437a884fb06e17b0896b9b0d7f10759" translate="yes" xml:space="preserve">
          <source>One way to mitigate this would be to use a regular expression coupled with &lt;a href=&quot;http://www.regular-expressions.info/wordboundaries.html&quot;&gt;word boundaries&lt;/a&gt; (&lt;code&gt;\b&lt;/code&gt;):</source>
          <target state="translated">이를 완화하는 한 가지 방법은 &lt;a href=&quot;http://www.regular-expressions.info/wordboundaries.html&quot;&gt;단어 경계&lt;/a&gt; ( &lt;code&gt;\b&lt;/code&gt; )와 결합 된 정규식을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="2f2dc7f1d5c30b526851de85106e46920df9b647" translate="yes" xml:space="preserve">
          <source>Peer to SamGoody and Lego Stormtroopr comments.</source>
          <target state="translated">SamGoody와 Lego Stormtroopr의 의견을 인용하십시오.</target>
        </trans-unit>
        <trans-unit id="edc3a262e579e4f18107ab1571c94ef9e25076ad" translate="yes" xml:space="preserve">
          <source>Point to note: The strstr() function is case-sensitive. For a case-insensitive search, use the &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;stristr()&lt;/a&gt; function.</source>
          <target state="translated">참고 사항 : strstr () 함수는 대소 문자를 구분합니다. 대소 문자를 구분하지 &lt;a href=&quot;http://www.php.net/manual/en/function.stristr.php&quot;&gt;않으려면 stristr ()&lt;/a&gt; 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="991a6a91ca7eeccb09411cc8f7609f2065f9d754" translate="yes" xml:space="preserve">
          <source>Replace words with others which have an identical or similar meaning. 
(ex:replace instances of 'hungrily' and 'hungry' with 'hunger')</source>
          <target state="translated">동일하거나 유사한 의미를 가진 다른 단어로 바꾸십시오. (예 : '배고픈'및 '배고픈'인스턴스를 '배고픔'으로 대체)</target>
        </trans-unit>
        <trans-unit id="c61ea5e0f58b3846041d08ca013157e2727368bf" translate="yes" xml:space="preserve">
          <source>Suppose I have the code above, what is the correct way to write the statement &lt;code&gt;if ($a contains 'are')&lt;/code&gt;?</source>
          <target state="translated">위의 코드가 있다고 가정 &lt;code&gt;if ($a contains 'are')&lt;/code&gt; 문을 작성하는 올바른 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5d3e2372695f63ce0c53a4f4135db20d5ae16db5" translate="yes" xml:space="preserve">
          <source>Test:</source>
          <target state="translated">Test:</target>
        </trans-unit>
        <trans-unit id="fba0c98c0a3e78e3d12ddcb4cfcf74e9fa3dd5eb" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; at the beginning of &quot;area&quot;</source>
          <target state="translated">&quot;지역&quot;의 시작 부분에있는 &quot;지역&quot;</target>
        </trans-unit>
        <trans-unit id="65750dec72e69bd6ff39a4cd067052598124521b" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; at the end of &quot;hare&quot;</source>
          <target state="translated">&quot;거기&quot;의 끝에 &quot;있다&quot;</target>
        </trans-unit>
        <trans-unit id="f9f8a2f0a59aac465b7b2e5829132ebadacd4d79" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in &quot;What _are_ you thinking?&quot;</source>
          <target state="translated">&quot;당신은 무엇을 생각하고 있습니까?&quot;</target>
        </trans-unit>
        <trans-unit id="ff1600ce3aceaa25995ea3bed5fa16ea9e7f9d0f" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in &quot;lol u dunno wut those are4?&quot;</source>
          <target state="translated">&quot;lol u dunno wut that are are4&quot;의 &quot;are&quot;는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6e73ec58021d66e8d244453eb8eecab178cd95e3" translate="yes" xml:space="preserve">
          <source>The &quot;are&quot; in the middle of &quot;fares&quot;</source>
          <target state="translated">&quot;운임&quot;의 중간에 &quot;있다&quot;</target>
        </trans-unit>
        <trans-unit id="af141695ab878d911b750be60dedc56b44a1366b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; at the end of regular expression changes regular expression to be case-insensitive, if you do not want that, you can leave it out.</source>
          <target state="translated">정규 표현식의 끝에있는 &lt;code&gt;i&lt;/code&gt; 는 정규 표현식을 대소 문자를 구분하지 않도록 변경합니다. 원하지 않으면 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a58a61579fa10e87cfbc17dea3a1e7d4dee7a592" translate="yes" xml:space="preserve">
          <source>The function below also works and does not depend on any other function; it uses only native PHP string manipulation. Personally, I do not recommend this, but you can see how it works:</source>
          <target state="translated">아래 기능도 작동하며 다른 기능에 의존하지 않습니다. 네이티브 PHP 문자열 조작 만 사용합니다. 개인적으로 나는 이것을 권장하지 않지만 작동 방식을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f06677169500917274915f9ad5cfaf385a03d220" translate="yes" xml:space="preserve">
          <source>The reduction of numeric values by reducing precision are other ways of normalising the text.</source>
          <target state="translated">정밀도를 줄임으로써 숫자 값을 줄이는 것은 텍스트를 정규화하는 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8acbf1d45a648165adc6a6e8fdf2236bcdcc9869" translate="yes" xml:space="preserve">
          <source>The replacement of colour names with their hexadecimal equivalents</source>
          <target state="translated">색상 이름을 16 진수로 대체</target>
        </trans-unit>
        <trans-unit id="7bdbb776fba5a8dc6853756dead688035a67cceb" translate="yes" xml:space="preserve">
          <source>The short-hand version</source>
          <target state="translated">속기 버전</target>
        </trans-unit>
        <trans-unit id="074eb46fa2eab2604e12769117a414a5c815cc4b" translate="yes" xml:space="preserve">
          <source>The strpos function works fine, but if you want to do &lt;code&gt;case-insensitive&lt;/code&gt; checking for a word in a paragraph then you can make use of the &lt;code&gt;stripos&lt;/code&gt; function of &lt;code&gt;PHP&lt;/code&gt;.</source>
          <target state="translated">strpos 함수는 정상적으로 작동하지만 단락에서 단어를 &lt;code&gt;case-insensitive&lt;/code&gt; 검사하려면 &lt;code&gt;PHP&lt;/code&gt; 의 &lt;code&gt;stripos&lt;/code&gt; 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe39f4f56248c0ed3b837778f579013127d494e1" translate="yes" xml:space="preserve">
          <source>There are plenty of improvements to be made
but the model provides a way of getting good results from natural queries, 
which don't have boolean operators such as &lt;code&gt;strpos()&lt;/code&gt;, &lt;code&gt;preg_match()&lt;/code&gt;, &lt;code&gt;strstr()&lt;/code&gt; or &lt;code&gt;stristr()&lt;/code&gt;.</source>
          <target state="translated">개선해야 할 부분이 많이 있지만 모델은 &lt;code&gt;strpos()&lt;/code&gt; , &lt;code&gt;preg_match()&lt;/code&gt; , &lt;code&gt;strstr()&lt;/code&gt; 또는 &lt;code&gt;stristr()&lt;/code&gt; 과 같은 부울 연산자가없는 자연 쿼리에서 좋은 결과를 얻는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d219fd4683f024b1b46ac4b7362bae7eb53df97b" translate="yes" xml:space="preserve">
          <source>This is the idea of the vector space model, &lt;strong&gt;not far from how SQL full-text search works:&lt;/strong&gt;</source>
          <target state="translated">이것은 &lt;strong&gt;SQL 전체 텍스트 검색의 작동 방식과 멀지 않은&lt;/strong&gt; 벡터 공간 모델에 대한 아이디어입니다 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="281072b73957e4edbd3e2582a1cfa67bfbc65be8" translate="yes" xml:space="preserve">
          <source>This is useful to avoid spam when sending emails for example.</source>
          <target state="translated">예를 들어 이메일을 보낼 때 스팸을 피하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8654cbc27d2dd80342d3a1c9c6aed7df2c779cab" translate="yes" xml:space="preserve">
          <source>This means the string has to be resolved into words (see note below).</source>
          <target state="translated">이는 문자열을 단어로 해석해야 함을 의미합니다 (아래 참고 참조).</target>
        </trans-unit>
        <trans-unit id="51a160776c2c7b3eab04ee3c79f29c6483cb965a" translate="yes" xml:space="preserve">
          <source>This method doesn't have the same false positives noted above, but it does have some edge cases of its own.  Word boundaries match on non-word characters (&lt;code&gt;\W&lt;/code&gt;), which are going to be anything that isn't &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;, or &lt;code&gt;_&lt;/code&gt;.  That means digits and underscores are going to be counted as word characters and scenarios like this will fail:</source>
          <target state="translated">이 방법에는 위에서 언급 한 것과 같은 오 탐지가 없지만 고유 한 경우가 있습니다. 단어 경계는 단어가 아닌 문자 ( &lt;code&gt;\W&lt;/code&gt; )와 일치하며, &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt; 또는 &lt;code&gt;_&lt;/code&gt; 가 아닌 문자가됩니다. 즉, 숫자와 밑줄은 단어 문자로 계산되며 이러한 시나리오는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="814d677a8f676b10f82ac5b818657779e061b6f0" translate="yes" xml:space="preserve">
          <source>To check if &lt;em&gt;not&lt;/em&gt; present, add the &lt;code&gt;!&lt;/code&gt; operator:</source>
          <target state="translated">존재 &lt;em&gt;하지 않는지&lt;/em&gt; 확인하려면 &lt;code&gt;!&lt;/code&gt; 운영자:</target>
        </trans-unit>
        <trans-unit id="65c66e28ac6f1c0e38ec5e9659847cadea78cb2d" translate="yes" xml:space="preserve">
          <source>To combine both sets of functionality into a single multi-purpose function (including with selectable case sensitivity), you could use something like this:</source>
          <target state="translated">두 기능 세트를 단일 다목적 기능 (선택 가능한 대소 문자 구분 포함)으로 결합하려면 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10edf5fed7899dea96bf80a0ad1840566ed6e1a4" translate="yes" xml:space="preserve">
          <source>To determine whether a string contains another string you can use the PHP function &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;strpos()&lt;/a&gt;.</source>
          <target state="translated">문자열에 다른 문자열이 포함되어 있는지 확인하려면 PHP 함수 &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;strpos ()를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f2e11c8284a6bf0ac0d263cb869b551c3cca3e" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt;&lt;code&gt;strstr()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://php.net/manual/en/function.stristr.php&quot;&gt;&lt;code&gt;stristr()&lt;/code&gt;&lt;/a&gt; if your search should be case insensitive would be another option.</source>
          <target state="translated">검색시 대소 문자를 구분하지 않으면 &lt;a href=&quot;http://php.net/manual/en/function.strstr.php&quot;&gt; &lt;code&gt;strstr()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;http://php.net/manual/en/function.stristr.php&quot;&gt; &lt;code&gt;stristr()&lt;/code&gt; &lt;/a&gt; 하는 것이 또 다른 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="efdcb8e898f459b234a8181ba616ea969d0119ad" translate="yes" xml:space="preserve">
          <source>What's the difference?  Substrings can appear within other words:</source>
          <target state="translated">차이점이 뭐야? 하위 문자열은 다른 말로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa590c482271336764621e55078baf0c591d5536" translate="yes" xml:space="preserve">
          <source>While most of these answers will tell you if a substring appears in your string, that's usually not what you want if you're looking for a particular &lt;em&gt;word&lt;/em&gt;, and not a &lt;em&gt;substring&lt;/em&gt;.</source>
          <target state="translated">이러한 답변의 대부분은 문자열에 하위 문자열이 나타나는지 알려주지 만 하위 문자열이 아닌 특정 &lt;em&gt;단어를&lt;/em&gt; 찾고 있다면 일반적으로 원하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="258937995fc341d4744a414cf73e47fe8f6bacc7" translate="yes" xml:space="preserve">
          <source>With the samples above, both &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; contains &lt;code&gt;$c&lt;/code&gt;, but you may want your function to tell you that only &lt;code&gt;$a&lt;/code&gt; contains &lt;code&gt;$c&lt;/code&gt;.</source>
          <target state="translated">위의 샘플에서 &lt;code&gt;$a&lt;/code&gt; 와 &lt;code&gt;$b&lt;/code&gt; 에는 &lt;code&gt;$c&lt;/code&gt; 가 포함되어 있지만 $ a 만 $ c를 포함하고 있음을 함수가 알려줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa883bf0d02de1e50fb3029d25f98235c9f50d88" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;strpos()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;strpos()&lt;/code&gt; 함수를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="048e7d27353c157dc1b5bc47ecb679187e0f6ed6" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt;&lt;code&gt;strpos()&lt;/code&gt;&lt;/a&gt; function which is used to find the occurrence of one string inside another one:</source>
          <target state="translated">&lt;a href=&quot;http://php.net/manual/en/function.strpos.php&quot;&gt; &lt;code&gt;strpos()&lt;/code&gt; &lt;/a&gt; 함수를 사용하면 다른 문자열 안에서 하나의 문자열을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54493c19dbfc90ba47d4dd06b13bebcfabf9e240" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;strstr&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;strstr&lt;/code&gt; 함수를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a6ce4df6c8750da05b0d98658e1056a1f84f5f17" translate="yes" xml:space="preserve">
          <source>You could use regular expressions, it's better for word matching compared to &lt;code&gt;strpos&lt;/code&gt; as mentioned by other users it will also return true for strings such as fare, care, stare, etc. This can simply be avoided in regular expression by using word boundaries.</source>
          <target state="translated">정규 표현식을 사용할 수 있습니다. 다른 사용자가 언급 한 것처럼 &lt;code&gt;strpos&lt;/code&gt; 와 비교하여 단어 일치에 더 좋습니다. 운임, 관리, 응시 등과 같은 문자열에 대해서도 true를 반환합니다. 단어 경계를 사용하여 정규 표현식에서 간단히 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0bec4b988172a1d14d0a06bdba132b97b07f5c8" translate="yes" xml:space="preserve">
          <source>You may notice that the previous solutions are not an answer for the word being used as a prefix for another. In order to use your example:</source>
          <target state="translated">이전 솔루션이 다른 솔루션의 접두사로 사용되는 단어에 대한 답변이 아님을 알 수 있습니다. 예제를 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="a932d9c5bd36cc1e640ddd6ae01856aa33464c06" translate="yes" xml:space="preserve">
          <source>You need to use identical/not identical operators because strpos can return 0 as it's index value. If you like ternary operators, consider using the following (seems a little backwards I'll admit):</source>
          <target state="translated">strpos가 인덱스 값으로 0을 리턴 할 수 있으므로 동일하거나 동일하지 않은 연산자를 사용해야합니다. 삼항 연산자를 좋아한다면 다음을 사용하는 것이 좋습니다 (약간 거꾸로 본 것입니다).</target>
        </trans-unit>
        <trans-unit id="17a4eaa70e6fca11cd3a0594e0e6ae22bcf5f5dd" translate="yes" xml:space="preserve">
          <source>You should use case Insensitive format,so if the entered value is in &lt;code&gt;small&lt;/code&gt; or &lt;code&gt;caps&lt;/code&gt; it wont matter.</source>
          <target state="translated">대소 문자를 구분하지 않는 형식을 사용해야하므로 입력 한 값이 &lt;code&gt;small&lt;/code&gt; 거나 &lt;code&gt;caps&lt;/code&gt; 경우에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9411b3f7d38c850e9e0ce1838744755ad62458f6" translate="yes" xml:space="preserve">
          <source>can't search for multiple words</source>
          <target state="translated">여러 단어를 검색 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="15bf9afce4ffa3fbf44c7e834d049e617054404b" translate="yes" xml:space="preserve">
          <source>faster indexing and a consequently faster search.</source>
          <target state="translated">더 빠른 색인 생성 및 결과적으로 더 빠른 검색.</target>
        </trans-unit>
        <trans-unit id="37ab7e92198730c935587e8eab4e183e80b042a6" translate="yes" xml:space="preserve">
          <source>less disk I/O</source>
          <target state="translated">적은 디스크 I / O</target>
        </trans-unit>
        <trans-unit id="f262c494e86d759eb3e2029edccdeaf071231d09" translate="yes" xml:space="preserve">
          <source>results are unranked</source>
          <target state="translated">결과는 순위가 없습니다</target>
        </trans-unit>
        <trans-unit id="274e89ab94a3541c57aa9a85d106d78e5be3f50e" translate="yes" xml:space="preserve">
          <source>thereby reducing index size and resulting in less storage requirement</source>
          <target state="translated">따라서 인덱스 크기를 줄이고 스토리지 요구 사항을 줄입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
