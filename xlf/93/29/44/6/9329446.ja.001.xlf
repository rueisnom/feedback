<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/9329446">
    <body>
      <group id="9329446">
        <trans-unit id="407418523e4b6661ebd3d7c0977b4358422a77b7" translate="yes" xml:space="preserve">
          <source>&quot;Just do this to every item in the list, I don't care about the order!&quot;</source>
          <target state="translated">&quot;リストの全ての項目にこれをしてくれ 順番は気にしない!&quot;</target>
        </trans-unit>
        <trans-unit id="828290fcafc33530b24d3d5dd4a9ad6ca15d4e08" translate="yes" xml:space="preserve">
          <source>(I couldn't find the equivalent verbiage in the ES2015 spec, but it's bound to still be the case.) Again, as of this writing the common host-provided array-like objects in modern browsers [&lt;code&gt;NodeList&lt;/code&gt; instances, for instance] &lt;strong&gt;do&lt;/strong&gt; handle &lt;code&gt;[[HasProperty]]&lt;/code&gt; correctly, but it's important to test.)</source>
          <target state="translated">（私はES2015仕様で同等の言い回しを見つけることができませんでしたが、それはまだ事実であるに違いありません。）再び、これを書いている時点で、最近のブラウザー[ &lt;code&gt;NodeList&lt;/code&gt; インスタンスなど]で一般的なホスト提供の配列のようなオブジェクトを書き&lt;strong&gt;ます&lt;/strong&gt; &lt;code&gt;[[HasProperty]]&lt;/code&gt; を正しく処理しますが、テストすることが重要です。）</target>
        </trans-unit>
        <trans-unit id="6b45776c77fb3cd134163e2ba508745f2d7fa17d" translate="yes" xml:space="preserve">
          <source>(If the discussion of intent makes no sense to you, then you and your code may benefit from watching Crockford's lecture on &lt;a href=&quot;https://www.youtube.com/watch?v=taaEzHI9xyY&amp;amp;t=480&quot;&gt;Programming Style &amp;amp; Your Brain&lt;/a&gt;.)</source>
          <target state="translated">（意図の議論があなたにとって意味をなさない場合、あなたとあなたのコードは&lt;a href=&quot;https://www.youtube.com/watch?v=taaEzHI9xyY&amp;amp;t=480&quot;&gt;プログラミングスタイルとあなたの脳&lt;/a&gt;に関するクロックフォードの講義を見ることから利益を得るかもしれません。）</target>
        </trans-unit>
        <trans-unit id="4123820b5846a3f7526a13d056cd330d08a55f64" translate="yes" xml:space="preserve">
          <source>1. Use &lt;code&gt;forEach&lt;/code&gt; and related</source>
          <target state="translated">1. &lt;code&gt;forEach&lt;/code&gt; および関連の使用</target>
        </trans-unit>
        <trans-unit id="5a308f239da9f276808356c1264e14c4f42dba7f" translate="yes" xml:space="preserve">
          <source>2. Use a simple &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">2.単純な &lt;code&gt;for&lt;/code&gt; ループを使用する</target>
        </trans-unit>
        <trans-unit id="5547e5e05c2ee31034d6e9a26818f942561707ff" translate="yes" xml:space="preserve">
          <source>3. Use &lt;code&gt;for-in&lt;/code&gt;&lt;em&gt;correctly&lt;/em&gt;</source>
          <target state="translated">3. &lt;code&gt;for-in&lt;/code&gt; を &lt;em&gt;正しく&lt;/em&gt;使用する</target>
        </trans-unit>
        <trans-unit id="799ce3e6b5064abe821148b3f183753446d2f3dc" translate="yes" xml:space="preserve">
          <source>4. Use &lt;code&gt;for-of&lt;/code&gt; (use an iterator implicitly) (ES2015+)</source>
          <target state="translated">4. &lt;code&gt;for-of&lt;/code&gt; を使用（暗黙的にイテレータを使用）（ES2015 +）</target>
        </trans-unit>
        <trans-unit id="219586416c25d4118e0031c2b8c71aae94dda23d" translate="yes" xml:space="preserve">
          <source>5. Use an iterator explicitly (ES2015+)</source>
          <target state="translated">5.明示的にイテレータを使用する(ES2015+)</target>
        </trans-unit>
        <trans-unit id="f808743c064b9869ab9f6547f7f8581b28fea109" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://codepen.io/Micka33/pen/nbyxf&quot;&gt;A CodePen example&lt;/a&gt; of how it works is:</source>
          <target state="translated">それがどのように機能するかの&lt;a href=&quot;http://codepen.io/Micka33/pen/nbyxf&quot;&gt;CodePenの例&lt;/a&gt;は次のとおりです：</target>
        </trans-unit>
        <trans-unit id="fedd9eb5c4d04a7948778748c41299d24255d66b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Documentation for native &lt;code&gt;Array.prototype.forEach()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;ネイティブ &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; のドキュメント&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="33c4d33aaa1f39715e196efdb5603883d817169a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for...of&lt;/a&gt; (MDN) describes the next way of iterating using &lt;code&gt;for (variable of object)&lt;/code&gt; as the part of the Harmony (ECMAScript&amp;nbsp;6) proposal.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for ... of&lt;/a&gt; （MDN）は、 &lt;code&gt;for (variable of object)&lt;/code&gt; をHarmony（ECMAScript 6）提案の一部として使用して反復する次の方法を説明します 。</target>
        </trans-unit>
        <trans-unit id="dd98744e853daba8a03a51ff44a45ab285ef96ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.every&quot;&gt;&lt;code&gt;every&lt;/code&gt;&lt;/a&gt; (stops looping the first time the callback returns &lt;code&gt;false&lt;/code&gt; or something falsey)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.every&quot;&gt; &lt;code&gt;every&lt;/code&gt; &lt;/a&gt; （コールバックが &lt;code&gt;false&lt;/code&gt; または何か誤ったものを初めて返したときにループを停止します）</target>
        </trans-unit>
        <trans-unit id="1fe98b98ac1a303b3e5d9fe919c4bf1d837d054e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; (creates a new array including elements where the filter function returns &lt;code&gt;true&lt;/code&gt; and omitting the ones where it returns &lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; （filter関数が &lt;code&gt;true&lt;/code&gt; を返す要素を含む新しい配列を作成し、 &lt;code&gt;false&lt;/code&gt; を返す要素は省略します ）</target>
        </trans-unit>
        <trans-unit id="dd4ceb819717bc057bb5f5be12b2dcaa00cc6d46" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; (creates a new array from the values returned by the callback)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; （コールバックによって返された値から新しい配列を作成します）</target>
        </trans-unit>
        <trans-unit id="967df601fa043b4383889e2892717dd399d122d6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; (builds up a value by repeatedly calling the callback, passing in previous values; see the spec for the details; useful for summing the contents of an array and many other things)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; （コールバックを繰り返し呼び出して値を作成し、前の値を渡します。詳細については仕様を参照してください。配列の内容やその他多くの内容を合計するのに役立ちます）</target>
        </trans-unit>
        <trans-unit id="cc8c405cc76a381935725e183d15ed035da147b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduceright&quot;&gt;&lt;code&gt;reduceRight&lt;/code&gt;&lt;/a&gt; (like &lt;code&gt;reduce&lt;/code&gt;, but works in descending rather than ascending order)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduceright&quot;&gt; &lt;code&gt;reduceRight&lt;/code&gt; &lt;/a&gt; （ &lt;code&gt;reduce&lt;/code&gt; と同様ですが、昇順ではなく降順で機能します）</target>
        </trans-unit>
        <trans-unit id="adfd7ff17249a9d39816111c7afab18302df88c6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.some&quot;&gt;&lt;code&gt;some&lt;/code&gt;&lt;/a&gt; (stops looping the first time the callback returns &lt;code&gt;true&lt;/code&gt; or something truthy)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.some&quot;&gt; &lt;code&gt;some&lt;/code&gt; &lt;/a&gt; （コールバックが &lt;code&gt;true&lt;/code&gt; または何か真実を返したときにループを停止します）</target>
        </trans-unit>
        <trans-unit id="377286bac8d6282390dfb096683ce2f568297474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array#forEach&lt;/code&gt; (&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt;&lt;code&gt;spec&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;MDN&lt;/code&gt;&lt;/a&gt;) (or its relatives &lt;code&gt;some&lt;/code&gt; and such) (ES5+ only),</source>
          <target state="translated">&lt;code&gt;Array#forEach&lt;/code&gt; （ &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt; &lt;code&gt;spec&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;MDN&lt;/code&gt; &lt;/a&gt; ）（またはその親戚など）（ES5 +のみ）、</target>
        </trans-unit>
        <trans-unit id="d7e42662fabd1b4650592db96d131acd3a1e156b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array.from&lt;/code&gt; (ES2015+, but easily polyfilled) creates an array from an array-like object, optionally passing the entries through a mapping function first. So:</source>
          <target state="translated">&lt;code&gt;Array.from&lt;/code&gt; （ES2015 +、ただし簡単にポリフィルされます）は、配列のようなオブジェクトから配列を作成し、オプションで最初にマッピング関数を介してエントリを渡します。 そう：</target>
        </trans-unit>
        <trans-unit id="b0e8f140b1faf7f02335c4444e052df5049591e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;angular.forEach&lt;/code&gt; takes 2 arguments and an optional third argument. The first argument is the object (array) to iterate over, the second argument is the iterator function, and the optional third argument is the object context (basically referred to inside the loop as 'this'.</source>
          <target state="translated">&lt;code&gt;angular.forEach&lt;/code&gt; は2つの引数とオプションの3番目の引数を取ります。 最初の引数は反復するオブジェクト（配列）、2番目の引数は反復関数、オプションの3番目の引数はオブジェクトコンテキストです（基本的にループ内では「this」と呼ばれます）。</target>
        </trans-unit>
        <trans-unit id="9a8d763ba59a05f954f7c48ce76ecba0f7d62607" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;entries()&lt;/code&gt;: Returns an iterator where each &lt;code&gt;value&lt;/code&gt; is an array in the form &lt;code&gt;[key, value]&lt;/code&gt; for that iteration.</source>
          <target state="translated">&lt;code&gt;entries()&lt;/code&gt; ：各 &lt;code&gt;value&lt;/code&gt; がその反復の &lt;code&gt;[key, value]&lt;/code&gt; 形式の配列である反復子を返します。</target>
        </trans-unit>
        <trans-unit id="b4cbd4974267f738d1be9503fdb7ebf5943cbd34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for-in&lt;/code&gt; with the same safeguards as with an array should work with array-like objects as well; the caveat for host-provided objects on #1 above may apply.</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; は、配列と同じセーフガードを使用して、配列のようなオブジェクトでも機能するはずです。 上記の＃1でホストが提供するオブジェクトに関する警告が適用される場合があります。</target>
        </trans-unit>
        <trans-unit id="9b9fa350aa7ed228cd4b3e93d0298f289edbbed8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for-of&lt;/code&gt; will use the iterator provided by the object (if any); we'll have to see how this plays with the various array-like objects, particularly host-provided ones. For instance, the specification for the &lt;code&gt;NodeList&lt;/code&gt; from &lt;code&gt;querySelectorAll&lt;/code&gt; was updated to support iteration. The spec for the &lt;code&gt;HTMLCollection&lt;/code&gt; from &lt;code&gt;getElementsByTagName&lt;/code&gt; was not.</source>
          <target state="translated">&lt;code&gt;for-of&lt;/code&gt; は、オブジェクトが提供するイテレータ（存在する場合）を使用します。 これがさまざまな配列のようなオブジェクト、特にホストが提供するオブジェクトでどのように機能するかを確認する必要があります。 たとえば、 &lt;code&gt;querySelectorAll&lt;/code&gt; からの &lt;code&gt;NodeList&lt;/code&gt; の仕様は、反復をサポートするように更新されました。 &lt;code&gt;getElementsByTagName&lt;/code&gt; からの &lt;code&gt;HTMLCollection&lt;/code&gt; の仕様はそうではありませんでした。</target>
        </trans-unit>
        <trans-unit id="04cdb28da8f19e68125e4596f8a56b848aec15ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forEach&lt;/code&gt; accepts a callback function and, optionally, a value to use as &lt;code&gt;this&lt;/code&gt; when calling that callback (not used above). The callback is called for each entry in the array, in order, skipping non-existent entries in sparse arrays. Although I only used one argument above, the callback is called with three: The value of each entry, the index of that entry, and a reference to the array you're iterating over (in case your function doesn't already have it handy).</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; は、コールバック関数と、オプションで、そのコールバックを呼び出すときに &lt;code&gt;this&lt;/code&gt; として使用する値を受け入れます（上記では使用されません）。 コールバックは、配列の各エントリに対して順番に呼び出され、疎な配列に存在しないエントリをスキップします。 上記の引数は1つしか使用していませんが、コールバックは次の3つで呼び出されます。各エントリの値、そのエントリのインデックス、繰り返し処理する配列への参照（関数にまだ使用できない場合） ）。</target>
        </trans-unit>
        <trans-unit id="10cc3315d863ec1f2a75337ba363aaa39af9ff7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forEach&lt;/code&gt; has the benefit that you don't have to declare indexing and value variables in the containing scope, as they're supplied as arguments to the iteration function, and so nicely scoped to just that iteration.</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; には、反復関数への引数として指定されているため、包含変数のスコープでインデックス変数と値変数を宣言する必要がないという利点があります。</target>
        </trans-unit>
        <trans-unit id="d31603bd232d66e37b18d7476c0486024b09c2d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forEach&lt;/code&gt; will iterate over the array you provide and for each iteration it will have &lt;code&gt;element&lt;/code&gt; which holds the value of that iteration. If you need index you can get the current index by passing the &lt;code&gt;i&lt;/code&gt; as the second parameter in the callback function for forEach.</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; は指定された配列を反復処理し、反復ごとに、その反復の値を保持する &lt;code&gt;element&lt;/code&gt; を持ちます。 インデックスが必要な場合、 &lt;code&gt;i&lt;/code&gt; をforEachのコールバック関数の2番目のパラメーターとして渡すことにより、現在のインデックスを取得できます。</target>
        </trans-unit>
        <trans-unit id="a637b50b32f61aa2eb966f27cbab468a25797cfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keys()&lt;/code&gt;: Returns an iterator where each &lt;code&gt;value&lt;/code&gt; is the key for that iteration (so for our &lt;code&gt;a&lt;/code&gt; above, that would be &lt;code&gt;&quot;0&quot;&lt;/code&gt;, then &lt;code&gt;&quot;1&quot;&lt;/code&gt;, then &lt;code&gt;&quot;2&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;keys()&lt;/code&gt; ：各 &lt;code&gt;value&lt;/code&gt; がその反復のキーであるイテレータを返します（上記の &lt;code&gt;a&lt;/code&gt; の場合、 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;2&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e09aa066919616abd8401c1b7f350a3988032555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;values()&lt;/code&gt;: This is the one I used above. It returns an iterator where each &lt;code&gt;value&lt;/code&gt; is the array entry for that iteration (&lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;b&quot;&lt;/code&gt;, and &lt;code&gt;&quot;c&quot;&lt;/code&gt; in the example earlier).</source>
          <target state="translated">&lt;code&gt;values()&lt;/code&gt; ：これは上記で使用したものです。 各 &lt;code&gt;value&lt;/code&gt; がその反復の配列エントリであるイテレータを返します（前の例では &lt;code&gt;&quot;b&quot;&lt;/code&gt; 、 &quot;b&quot; 、および &lt;code&gt;&quot;c&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b95a3bad9c3b12555c2a9ef69ef39152f687a5c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; will contain the last value of &lt;code&gt;y&lt;/code&gt; and it will be removed from the array. You can also use &lt;code&gt;shift()&lt;/code&gt; which will give and remove the first item from &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; には &lt;code&gt;y&lt;/code&gt; の最後の値が含まれ、配列から削除されます。 &lt;code&gt;y&lt;/code&gt; から最初の項目を取得および削除する &lt;code&gt;shift()&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="94d62988ff95e5983c9bb7336fe74b54beb70d31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Credits go to WYL for showing me the benefits and horrors of the reverse for loop.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;クレジットは、リバースforループの利点と恐怖を見せてくれたWYLに送られます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ebe32016513b7b36eecf84f088911eaffc1e16a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A&lt;/strong&gt; - &lt;code&gt;for&lt;/code&gt; tests</source>
          <target state="translated">&lt;strong&gt;A-&lt;/strong&gt;テスト用</target>
        </trans-unit>
        <trans-unit id="9e681feccaa2f651d3f5e876dbe2e319c1d67118" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array with 1,000,000 elements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1,000,000要素の配列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3255bc6f4f9492d8559a38233f24c1a81f7a3679" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array with 10 elements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;10要素の配列&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1730cb94cc2840238efe2ab02609e1acbb5d7877" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array.forEach()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Array.forEach()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f9864972c7c592b5676161c6e60aa0f51041edc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of ECMAScript&amp;nbsp;6:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ECMAScript 6以降：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="366729cb2dd9643a7a37c411a6350e8f3239e9fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B&lt;/strong&gt; - &lt;code&gt;while&lt;/code&gt; tests</source>
          <target state="translated">&lt;strong&gt;B-&lt;/strong&gt;テスト中</target>
        </trans-unit>
        <trans-unit id="330f92001b0c02491afac466730ba9e45d684ab4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C&lt;/strong&gt; - other/alternative methods</source>
          <target state="translated">&lt;strong&gt;C-&lt;/strong&gt;その他/別の方法</target>
        </trans-unit>
        <trans-unit id="1a68ce6032c3740fd013d6c9b66b882246d9cf06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caf1f7a722c982dbd57c57da6fb19a30c4de09b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66201f31a06924bccc5252ec818cb13549b146b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cross browser results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;クロスブラウザーの結果&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="750c1a011ed83068ce4b750427dca4f8195eb051" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;編集：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40f5fee30dbaa97b495918cfcda19fd49d758e20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="184138f36fc9d5f1b134435fd6400d89d5dd3ef7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fbf2341d370757e8b1e3d68104c67efff5070bbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc261b2aaea005d1254afb5ea26e11f1deea56b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="076cc797a53b7cb38c7bf05c97b94635f200c2e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1:&lt;/strong&gt; Normal &lt;code&gt;for...of&lt;/code&gt; loop - no tricks here.</source>
          <target state="translated">&lt;strong&gt;例1：&lt;/strong&gt;通常の &lt;code&gt;for...of&lt;/code&gt; ループ-ここではトリックはありません。</target>
        </trans-unit>
        <trans-unit id="49d9fa2400580995d7bae707d928b0d3821aa741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2:&lt;/strong&gt; Split words to characters</source>
          <target state="translated">&lt;strong&gt;例2：&lt;/strong&gt;単語を文字に分割する</target>
        </trans-unit>
        <trans-unit id="bdc1592f5ce50edf5193207a1607a8801ea11f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3:&lt;/strong&gt; Looping with a &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;例3：&lt;/strong&gt; &lt;code&gt;key&lt;/code&gt; と &lt;code&gt;value&lt;/code&gt; したループ</target>
        </trans-unit>
        <trans-unit id="78871da32ac6a0f7f115cb0b01a332656d6a8904" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4:&lt;/strong&gt; Get object properties inline</source>
          <target state="translated">&lt;strong&gt;例4：&lt;/strong&gt;オブジェクトのプロパティをインラインで取得する</target>
        </trans-unit>
        <trans-unit id="e558c5c128ffa4a0403278ee644502849ef174b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 5:&lt;/strong&gt; Get deep object properties of what you need</source>
          <target state="translated">&lt;strong&gt;例5：&lt;/strong&gt;必要なオブジェクトのディープオブジェクトプロパティを取得する</target>
        </trans-unit>
        <trans-unit id="0a55d796f49ed376bbdc8b840ed3ffef75a362c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 6:&lt;/strong&gt; Is &lt;strong&gt;Example 3&lt;/strong&gt; used with &lt;code&gt;.forEach&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;例6：&lt;/strong&gt; &lt;strong&gt;例3&lt;/strong&gt;が &lt;code&gt;.forEach&lt;/code&gt; で使用されていますか</target>
        </trans-unit>
        <trans-unit id="1c576ad032b24d44f329a8bbbc699e346dfa84e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 7:&lt;/strong&gt; Is &lt;strong&gt;Example 4&lt;/strong&gt; used with &lt;code&gt;.forEach&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;例7：&lt;/strong&gt; &lt;strong&gt;例4&lt;/strong&gt;は &lt;code&gt;.forEach&lt;/code&gt; で使用されていますか</target>
        </trans-unit>
        <trans-unit id="28f415a0afa402f72563bd9599b6360f208f4e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 8:&lt;/strong&gt; Is &lt;strong&gt;Example 5&lt;/strong&gt; used with &lt;code&gt;.forEach&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;例8：&lt;/strong&gt; &lt;strong&gt;例5&lt;/strong&gt;は &lt;code&gt;.forEach&lt;/code&gt; で使用されていますか</target>
        </trans-unit>
        <trans-unit id="4ce5e7fbb73dac5a612d22d4d58fd1306ab12eaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples 6, 7, and 8&lt;/strong&gt; can be used with any functional loops like &lt;code&gt;.map&lt;/code&gt;, &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.reduce&lt;/code&gt;, &lt;code&gt;.sort&lt;/code&gt;, &lt;code&gt;.every&lt;/code&gt;, &lt;code&gt;.some&lt;/code&gt;. For more information about these methods, check out the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;Array Object&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;例6、7、および8&lt;/strong&gt;は、 &lt;code&gt;.map&lt;/code&gt; 、 &lt;code&gt;.filter&lt;/code&gt; 、 &lt;code&gt;.reduce&lt;/code&gt; 、 &lt;code&gt;.sort&lt;/code&gt; 、 &lt;code&gt;.every&lt;/code&gt; 、 &lt;code&gt;.some&lt;/code&gt; などの関数ループで使用できます。 これらのメソッドの詳細については、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;配列オブジェクトを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="ea72b87b0bf2ace83cf5109381e93aeb066f2f76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples of usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b7b6fbb391b39121d3090835b1a7d329182a66c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional loops&lt;/strong&gt; - &lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, also &lt;code&gt;reduce&lt;/code&gt; (they loop through the function, but they are used if you need to do something with your array, etc.</source>
          <target state="translated">&lt;strong&gt;関数ループ&lt;/strong&gt; &lt;code&gt;forEach&lt;/code&gt; 、 &lt;code&gt;map&lt;/code&gt; 、 &lt;code&gt;filter&lt;/code&gt; 、 &lt;code&gt;reduce&lt;/code&gt; （関数をループしますが、配列で何かを行う必要がある場合などに使用されます）</target>
        </trans-unit>
        <trans-unit id="32fac35272abae62a061520fb1a2f945a7607806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How can it start at &lt;code&gt;array.length&lt;/code&gt; without exploding?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;爆発せずに &lt;code&gt;array.length&lt;/code&gt; から開始するにはどうすればよいですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b91663c8ee6622d139ccbcbdd48f45d5a5186122" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;NOTE&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="9df17e3bf34872a611d0e519ed5573d79bc888bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This answer is hopelessly out-of-date. For a more modern approach, look at &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;the methods available on an array&lt;/a&gt;. Methods of interest might be:</source>
          <target state="translated">&lt;strong&gt;注&lt;/strong&gt; ：この答えは絶望的に時代遅れです。 より現代的なアプローチについては&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;、アレイで利用可能なメソッドを&lt;/a&gt;見てください。 関心のある方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7e3161fd669d07159e3a7475c999f77628c85246" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="364d4fdee3e0bca52971cff9ce11bfd5c1cd8d29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0012595d3c17367fbb2f7b33de7378b0b6ab7340" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Removing siblings&lt;/strong&gt; from the DOM in reverse order is usually &lt;strong&gt;more efficient&lt;/strong&gt;.  (The browser needs to do less shifting of elements in its internal arrays.)</source>
          <target state="translated">DOMから&lt;strong&gt;兄弟&lt;/strong&gt;を逆の順序で&lt;strong&gt;削除&lt;/strong&gt;する方が、通常は&lt;strong&gt;より効率的&lt;/strong&gt;です。 （ブラウザは内部配列の要素のシフトを少なくする必要があります。）</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07ae7a0c45d54d2ebb1dc0cd4ec4001979bca9ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread syntax (&lt;code&gt;...&lt;/code&gt;)&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;スプレッド構文を&lt;/a&gt;使用（ &lt;code&gt;...&lt;/code&gt; ）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4022df37529f9de6389e8b44f78656816e01d469" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;Array.from&lt;/code&gt;&lt;/strong&gt;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.from&quot;&gt;(spec)&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from&quot;&gt;(MDN)&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Array.from&lt;/code&gt; &lt;/strong&gt; &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.from&quot;&gt;（spec）を&lt;/a&gt; &lt;strong&gt;使用する&lt;/strong&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from&quot;&gt;（MDN）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46eac7e8f751f6f37b8572993152b573d2db8084" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;for-in&lt;/code&gt; &lt;em&gt;correctly&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;for-in&lt;/code&gt; を &lt;em&gt;正しく&lt;/em&gt;使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d283294cac8da6d79925867e0ba6a307ede498df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;for-of&lt;/code&gt; (use an iterator implicitly) (ES2015+)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;for-of&lt;/code&gt; を使用（暗黙的にイテレーターを使用）（ES2015 +）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bd126a72acb2ecb3b1451e2659a42fd39e32809" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;forEach&lt;/code&gt; and related (ES5+)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;forEach&lt;/code&gt; および関連（ES5 +）を使用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb2d92cc11b7a9d0aca33182e1bebdf4c726208b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use a simple &lt;code&gt;for&lt;/code&gt; loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;単純な &lt;code&gt;for&lt;/code&gt; ループを使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f71bc706ab4a26bf9a13464f7b39c3aeaed0e52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use an iterator explicitly (ES2015+)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;イテレータを明示的に使用する（ES2015 +）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c4b03a035270e1b8f7dd2084f9df26df262debc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; method of arrays&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;配列の&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt;メソッドを使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8aa2a7263e5c604aa1227ef93fc167e49c67b84c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using loops with ECMAScript&amp;nbsp;6  &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;destructuring&lt;/a&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread operator&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ECMAScript 6の構造化&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;解除&lt;/a&gt;と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;スプレッド演算子で&lt;/a&gt;ループを使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="43d6f90660b9cfa169cfb55c0d5f5781ab586f65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why doesn't it stop iterating before index 0?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;なぜインデックス0の前に反復を停止しないのですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c7882bff3bd32e131ca75ee9b3310dc89ce137d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;do...while loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;する... whileループ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="292b6043564aae6314fc4949f7b4dc07ffca89f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;do/while&lt;/strong&gt; - also loop through a block of code while the condition is true, will run at least one time</source>
          <target state="translated">&lt;strong&gt;do / while-&lt;/strong&gt;条件がtrueである間もコードのブロックをループし、少なくとも1回は実行します</target>
        </trans-unit>
        <trans-unit id="59c2e1f4757834d90e32b8228c2ca6efbcc623e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;every&lt;/strong&gt; - Returns true or false if all the elements in the array pass the test in the callback function.</source>
          <target state="translated">&lt;strong&gt;every-&lt;/strong&gt;配列内のすべての要素がコールバック関数のテストに合格した場合、trueまたはfalseを返します。</target>
        </trans-unit>
        <trans-unit id="733d7f1b168a00ba327543b1d4fe7a84e1c306f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;filter&lt;/strong&gt; - Very similar to every except that filter returns an array with the elements that return true to the given function.</source>
          <target state="translated">&lt;strong&gt;filter-フィルター&lt;/strong&gt;が、指定された関数にtrueを返す要素を含む配列を返すことを除いて、すべてに非常に似ています。</target>
        </trans-unit>
        <trans-unit id="271fc1eae66abadd19acb62d4033231ca149cfff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;forループ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6730b771cabf57b04de93a3724c66df24b945a65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for...in loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;for ... inループ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41a75d50cd0e008efc00bd22fdc7462386f2f0fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for...of loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;for ... ofループ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2573e11cf7374a0bd5806f17739331b98d97a3d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for&lt;/strong&gt; - it's &lt;strong&gt;the most common one&lt;/strong&gt;. Full block of code for looping</source>
          <target state="translated">&lt;strong&gt;for-&lt;/strong&gt;それ&lt;strong&gt;は最も一般的なもの&lt;/strong&gt;です。 ループするコードの完全なブロック</target>
        </trans-unit>
        <trans-unit id="bf96d036e4a3af64d225f756d7cdb14e19eaa0d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;forEach&lt;/strong&gt; - Iterates through every item in the array and do whatever you need with each item.</source>
          <target state="translated">&lt;strong&gt;forEach-&lt;/strong&gt;配列内のすべての項目を反復処理し、各項目で必要なことをすべて実行します。</target>
        </trans-unit>
        <trans-unit id="ea31da07d585b6c78298f66e4e1cab0b4bf164cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;map&lt;/strong&gt; - It creates a new array with the result of the callback function. This method is good to be used when you need to format the elements of your array.</source>
          <target state="translated">map-コールバック関数の結果で新しい配列を作成します。 このメソッドは、配列の要素をフォーマットする必要がある場合に使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="1d2abe3d817566b9ac069c513ac4125616984176" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;reduce&lt;/strong&gt; - As the name says, it reduces the array to a single value by calling the given function passing in the current element and the result of the previous execution.</source>
          <target state="translated">&lt;strong&gt;reduce-&lt;/strong&gt;名前が示すように、現在の要素と前回の実行結果を渡して指定された関数を呼び出すことにより、配列を単一の値に減らします。</target>
        </trans-unit>
        <trans-unit id="bc7cb0747f251ea37bf8ac12f021c5f51bc464ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;while loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;whileループ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d59bd2da691ba295b8e0f0e005203a04e318b82d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;while&lt;/strong&gt; - loop while a condition is through. It seems to be the fastest loop</source>
          <target state="translated">while-条件が終了するまでループします。 最速のループのようです</target>
        </trans-unit>
        <trans-unit id="98ac7d9be42d78332ce549839259a6fa839e83f9" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;forEach&lt;/strong&gt; implementation (&lt;a href=&quot;http://jsfiddle.net/nmoliveira/zNsyB/&quot;&gt;see in jsFiddle&lt;/a&gt;):</source>
          <target state="translated">&lt;strong&gt;forEach&lt;/strong&gt;実装（ &lt;a href=&quot;http://jsfiddle.net/nmoliveira/zNsyB/&quot;&gt;jsFiddleを参照&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="1593b174e119f27794747b6ca100ac5339012c07" translate="yes" xml:space="preserve">
          <source>A way closest to your idea would be to use &lt;code&gt;Array.forEach()&lt;/code&gt; which accepts a closure function which will be executed for each element of the array.</source>
          <target state="translated">アイデアに最も近い方法は、配列の各要素に対して実行されるクロージャー関数を受け入れる &lt;code&gt;Array.forEach()&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="461621dddb84f5684403289120de177b2681c313" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt; has added a &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;forEach&lt;/code&gt;&lt;/a&gt; method to &lt;code&gt;Array.prototype&lt;/code&gt; which can be used to enumerate over an array using a calback (the polyfill is in the docs so you can still use it for older browsers):</source>
          <target state="translated">さらに、 &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt;は、 &lt;code&gt;Array.prototype&lt;/code&gt; に &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;forEach&lt;/code&gt; &lt;/a&gt;メソッドを追加しました。これは、 コールバックを使用して配列を列挙するために使用できます（ポリフィルはドキュメントにあるため、古いブラウザーでも使用できます）。</target>
        </trans-unit>
        <trans-unit id="636fc2fec13e68630984c3473aa5d7f358f03d69" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;forEach&lt;/code&gt; is the &quot;loop through them all&quot; function, but ES5 defined several other useful &quot;work your way through the array and do things&quot; functions, including:</source>
          <target state="translated">さらに、 &lt;code&gt;forEach&lt;/code&gt; は「loop through them all」関数ですが、ES5は以下を含む、他のいくつかの便利な「配列を操作して実行する」関数を定義しました。</target>
        </trans-unit>
        <trans-unit id="c9f143cb14712f08a4e4970f0a574a82e563a424" translate="yes" xml:space="preserve">
          <source>Advantages:</source>
          <target state="translated">Advantages:</target>
        </trans-unit>
        <trans-unit id="de209c6ef85b78db6e703d44fe0a792cf0cf2d79" translate="yes" xml:space="preserve">
          <source>Although the performance gains are usually insignificant, it sort of screams:</source>
          <target state="translated">パフォーマンスの向上は通常、取るに足らないものですが、それは一種の悲鳴のようなものです。</target>
        </trans-unit>
        <trans-unit id="41e3fc9478f9b0602ab804e2073a64ab781383e9" translate="yes" xml:space="preserve">
          <source>An easy solution now would be to use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;underscore.js library&lt;/a&gt;. It's providing many useful tools, such as &lt;code&gt;each&lt;/code&gt; and will automatically delegate the job to the native &lt;code&gt;forEach&lt;/code&gt; if available.</source>
          <target state="translated">今の簡単な解決策は、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;underscore.jsライブラリ&lt;/a&gt;を使用することです 。 &lt;code&gt;each&lt;/code&gt; ツールなど、多くの便利なツールを提供しており、可能な場合はジョブをネイティブの &lt;code&gt;forEach&lt;/code&gt; に自動的に委任します。</target>
        </trans-unit>
        <trans-unit id="76134101719fc71647c5e2d29cf268ee6974b9a0" translate="yes" xml:space="preserve">
          <source>And finally the first 20 blue p tags are changed to green</source>
          <target state="translated">そして最後に最初の20個の青Pタグを緑に変更します。</target>
        </trans-unit>
        <trans-unit id="286bb782ad24f006d5ef3df1b25f01bf4ccf96dd" translate="yes" xml:space="preserve">
          <source>And furthermore &lt;code&gt;await&lt;/code&gt;&lt;a href=&quot;https://gist.github.com/joeytwiddle/37d2085425c049629b80956d3c618971&quot;&gt;does not work&lt;/a&gt; inside &lt;code&gt;forEach()&lt;/code&gt;.  Using &lt;code&gt;for..of&lt;/code&gt; is &lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-259876436&quot;&gt;the clearest pattern&lt;/a&gt; in this case.</source>
          <target state="translated">さらに、 &lt;code&gt;await&lt;/code&gt; &lt;a href=&quot;https://gist.github.com/joeytwiddle/37d2085425c049629b80956d3c618971&quot;&gt;は&lt;/a&gt; &lt;code&gt;forEach()&lt;/code&gt; 内では機能しません 。 この場合&lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-259876436&quot;&gt;、&lt;/a&gt; &lt;code&gt;for..of&lt;/code&gt; の使用が最も明確なパターンです。</target>
        </trans-unit>
        <trans-unit id="e2635b275be0c2dfc38d57182a9f17df25ac0fd4" translate="yes" xml:space="preserve">
          <source>And if you want it to be a function, you can do this:</source>
          <target state="translated">そして、機能を持たせたいのであれば、こうすればいいのです。</target>
        </trans-unit>
        <trans-unit id="aa47cb48e650e1ab26dbe126a4f7ec3d29c4aae4" translate="yes" xml:space="preserve">
          <source>And there are many others for iteration.</source>
          <target state="translated">他にもイテレーションのためのものはたくさんあります。</target>
        </trans-unit>
        <trans-unit id="cd8096180abe912c76cb829baeb8776e4097989f" translate="yes" xml:space="preserve">
          <source>And when you do that, not just &lt;code&gt;value&lt;/code&gt; but also &lt;code&gt;index&lt;/code&gt; is recreated for each loop iteration, meaning closures created in the loop body keep a reference to the &lt;code&gt;index&lt;/code&gt; (and &lt;code&gt;value&lt;/code&gt;) created for that specific iteration:</source>
          <target state="translated">これを行うと、 &lt;code&gt;value&lt;/code&gt; だけでなく &lt;code&gt;index&lt;/code&gt; もループの反復ごとに再作成されます。つまり、ループ本体で作成されたクロージャーは、その特定の反復で作成された &lt;code&gt;index&lt;/code&gt; （および &lt;code&gt;value&lt;/code&gt; ）への参照を保持します。</target>
        </trans-unit>
        <trans-unit id="c5d23f01f61bcd35bfab142a15fd44885c61c3be" translate="yes" xml:space="preserve">
          <source>And/or counting backward:</source>
          <target state="translated">アンドールは逆算している。</target>
        </trans-unit>
        <trans-unit id="c4dfb973c48c6519cc7b7dc31550d6b63562a6b8" translate="yes" xml:space="preserve">
          <source>Another viable way would be to use &lt;code&gt;Array.map()&lt;/code&gt; which works in the same way, but it also takes all values that you return and returns them in a new array (essentially mapping each element to a new one), like this:</source>
          <target state="translated">別の実行可能な方法は、同じように機能する &lt;code&gt;Array.map()&lt;/code&gt; を使用することですが、次のように、返されるすべての値を取り、それらを新しい配列に返します（各要素を新しいものに本質的にマッピングします）。</target>
        </trans-unit>
        <trans-unit id="e3e988d8ceb27456dc97896d4220b5940816a6af" translate="yes" xml:space="preserve">
          <source>Another way that is useful for copying items from one array to another is</source>
          <target state="translated">配列から別の配列にアイテムをコピーするのに便利なもう一つの方法は</target>
        </trans-unit>
        <trans-unit id="8d554cc4170a849cf2e0aa16b801259f0efd7018" translate="yes" xml:space="preserve">
          <source>As per question, user want code in javascript instead of jquery so the edit is</source>
          <target state="translated">質問のように、ユーザーはjqueryの代わりにjavascriptのコードを望んでいるので、編集は</target>
        </trans-unit>
        <trans-unit id="bdc7e9a236af726f7038fbcebf901bc5de8a0e8f" translate="yes" xml:space="preserve">
          <source>As per the new updated feature ECMAScript 6 (ES6) and ECMAScript 2015, you can use the following options with loops:</source>
          <target state="translated">ECMAScript 6(ES6)およびECMAScript 2015の新機能アップデートに伴い、ループを使って以下のオプションを使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="47e50940d71eac09fa64f7e1d6bcb6c40b08529b" translate="yes" xml:space="preserve">
          <source>Aside from true arrays, there are also &lt;em&gt;array-like&lt;/em&gt; objects that have a &lt;code&gt;length&lt;/code&gt; property and properties with numeric names: &lt;code&gt;NodeList&lt;/code&gt; instances, the &lt;code&gt;arguments&lt;/code&gt; object, etc. How do we loop through their contents?</source>
          <target state="translated">真の配列の他に、 &lt;code&gt;length&lt;/code&gt; プロパティと数値名のプロパティを持つ&lt;em&gt;配列のような&lt;/em&gt;オブジェクトもあります &lt;code&gt;NodeList&lt;/code&gt; インスタンス、 &lt;code&gt;arguments&lt;/code&gt; オブジェクトなどです。どのようにしてコンテンツをループしますか？</target>
        </trans-unit>
        <trans-unit id="eab486bae96770e7bd766cc0cc4ada63033b8966" translate="yes" xml:space="preserve">
          <source>At least some, and possibly most or even all, of the array approaches above frequently apply equally well to array-like objects:</source>
          <target state="translated">上記の配列アプローチのうち,少なくともいくつか,そしておそらくほとんど,あるいはすべてのアプローチが,配列のようなオブジェクトにも同様に適用されることがよくあります.</target>
        </trans-unit>
        <trans-unit id="70a2b96e30c86a111cdae7a47c5956d3a9d28e3e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;i--&lt;/code&gt; runs &lt;em&gt;before&lt;/em&gt; each iteration, on the first iteration we will actually be accessing the item at &lt;code&gt;array.length - 1&lt;/code&gt; which avoids any issues with &lt;strike&gt;Array-out-of-bounds&lt;/strike&gt;&lt;code&gt;undefined&lt;/code&gt; items.</source>
          <target state="translated">&lt;code&gt;i--&lt;/code&gt; は各反復の&lt;em&gt;前に&lt;/em&gt;実行さ&lt;em&gt;れる&lt;/em&gt;ため、最初の反復では実際に &lt;code&gt;array.length - 1&lt;/code&gt; 項目にアクセスし、 &lt;strike&gt;配列の範囲外の&lt;/strike&gt; &lt;code&gt;undefined&lt;/code&gt; 項目の問題を回避します。</target>
        </trans-unit>
        <trans-unit id="7e75fbda4fe70f4af05ef437f23c8019a6e0a056" translate="yes" xml:space="preserve">
          <source>But the above concerns is not applicable to Node.js applications, where &lt;code&gt;for..of&lt;/code&gt; is now well supported.</source>
          <target state="translated">しかし、上記の懸念事項は、 &lt;code&gt;for..of&lt;/code&gt; がサポートされているNode.jsアプリケーションには当てはまりません。</target>
        </trans-unit>
        <trans-unit id="877397eda4030d185b7ccf9f7ce92ef4e0c61e68" translate="yes" xml:space="preserve">
          <source>But there's &lt;strong&gt;lots&lt;/strong&gt; more to explore, read on...</source>
          <target state="translated">しかし、さらに&lt;strong&gt;多くの&lt;/strong&gt;ことを探求し、読み進めてください...</target>
        </trans-unit>
        <trans-unit id="ee106f8a0a3a9dae96b0d69d742bcd97b39bd261" translate="yes" xml:space="preserve">
          <source>But with modern JavaScript engines, it's rare you need to eke out that last bit of juice.</source>
          <target state="translated">しかし、最新の JavaScript エンジンでは、最後の一滴を取り出す必要があることはめったにありません。</target>
        </trans-unit>
        <trans-unit id="3e709fabb3cf8ffb27a522d70327597b3b8cc4d2" translate="yes" xml:space="preserve">
          <source>Caution when using string as function: the function is created out-of-context and ought to be used only where you are certain of variable scoping.  Otherwise, better to pass functions where scoping is more intuitive.</source>
          <target state="translated">文字列を関数として使用する際の注意:この関数はコンテキスト外で作成されるため、変数のスコープが確実な場合にのみ使用するようにしてください。それ以外の場合は、スコーピングがより直感的に行えるような関数を渡す方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="ebdda461e7af469834840795faba24136d9d0951" translate="yes" xml:space="preserve">
          <source>Caveat for host-provided objects</source>
          <target state="translated">ホストが提供するオブジェクトに関する注意事項</target>
        </trans-unit>
        <trans-unit id="5c0fa40086336662397974cdbd5ffa0407908978" translate="yes" xml:space="preserve">
          <source>Consider the following 2 nested loops, which do exactly the same thing. Let's say that we have 2 arrays of objects and each object contains an array of results, each of which has a Value property that's a string (or whatever). And let's say we need to iterate over each of the results and if they're equal then perform some action:</source>
          <target state="translated">以下の2つの入れ子になったループを考えてみましょう。2つのオブジェクトの配列があり、それぞれのオブジェクトには結果の配列が含まれています。そして、それぞれの結果を繰り返し処理して、それらが等しい場合に何らかのアクションを実行する必要があるとしましょう。</target>
        </trans-unit>
        <trans-unit id="dc657383123e3b34e3dc9324b5bc94793d6b0ec9" translate="yes" xml:space="preserve">
          <source>Create a true array</source>
          <target state="translated">真の配列を作成する</target>
        </trans-unit>
        <trans-unit id="6ebbbdefb07c190cb50e696dfd8fd8b8232a9dd9" translate="yes" xml:space="preserve">
          <source>Destructuring and using of the spread operator have proven quite useful for newcomers to ECMAScript&amp;nbsp;6 as being more human-readable/aesthetic, although some JavaScript veterans might consider it messy. Juniors or some other people might find it useful.</source>
          <target state="translated">一部のJavaScriptのベテランは厄介だと考えるかもしれませんが、spreadオペレーターの解体と使用は、ECMAScript 6の初心者にとって非常に読みやすく/美的であることが非常に有用であることが証明されています。 ジュニアや他の人はそれが便利だと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="1daaad0084c2604185e45c5a29dc6efeff0b7fce" translate="yes" xml:space="preserve">
          <source>Details:</source>
          <target state="translated">Details:</target>
        </trans-unit>
        <trans-unit id="c472a51872469dd7221cdb8ed81b476216096187" translate="yes" xml:space="preserve">
          <source>Disadvantages:</source>
          <target state="translated">Disadvantages:</target>
        </trans-unit>
        <trans-unit id="6c93fe8028eb2c06aa7aad788adaf00386420ed1" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;for-in&lt;/code&gt; unless you use it with safeguards or are at least aware of why it might bite you.</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; は、安全策を講じて使用する場合や、少なくとも自分に噛まれる可能性があることを認識していない限り、使用しないでください。</target>
        </trans-unit>
        <trans-unit id="d08ac59c6f776a259666b38bd6f6b67c6ac20550" translate="yes" xml:space="preserve">
          <source>ECMAScript&amp;nbsp;5 (the version on JavaScript) to work with Arrays:</source>
          <target state="translated">配列で動作するECMAScript 5（JavaScriptのバージョン）：</target>
        </trans-unit>
        <trans-unit id="d365e59cfe702f0dc8ea35a70c741654a39fed8f" translate="yes" xml:space="preserve">
          <source>ES2015 adds &lt;em&gt;iterators&lt;/em&gt; to JavaScript. The easiest way to use iterators is the new &lt;code&gt;for-of&lt;/code&gt; statement. It looks like this:</source>
          <target state="translated">ES2015はJavaScriptに&lt;em&gt;イテレータ&lt;/em&gt;を追加します。 イテレータを使用する最も簡単な方法は、新しい &lt;code&gt;for-of&lt;/code&gt; ステートメントです。 次のようになります。</target>
        </trans-unit>
        <trans-unit id="89cce593f5131e64c65adfb3e7a2a8a99ecd6047" translate="yes" xml:space="preserve">
          <source>Each p tag gets &lt;code&gt;class=&quot;blue&quot;&lt;/code&gt;</source>
          <target state="translated">各pタグは &lt;code&gt;class=&quot;blue&quot;&lt;/code&gt; を取得します</target>
        </trans-unit>
        <trans-unit id="a03f898632fc9e1da60588b88699c530174fddff" translate="yes" xml:space="preserve">
          <source>Easy readability</source>
          <target state="translated">読みやすさ</target>
        </trans-unit>
        <trans-unit id="a1360cfea2542d434b165c5be72693e776eefce5" translate="yes" xml:space="preserve">
          <source>Easy writability</source>
          <target state="translated">書きやすさ</target>
        </trans-unit>
        <trans-unit id="5c260a8d97db3363bbeeb8cd4f1afd6ee2424cdf" translate="yes" xml:space="preserve">
          <source>Efficiency. &lt;code&gt;angular.forEach&lt;/code&gt;, and the native &lt;code&gt;forEach&lt;/code&gt;, for that matter, are both &lt;em&gt;so much&lt;/em&gt; slower than the normal &lt;code&gt;for&lt;/code&gt; loop....about &lt;a href=&quot;http://jsperf.com/angular-foreach-vs-native-for-loop/3&quot;&gt;90% slower&lt;/a&gt;. So for large data sets, best to stick to the native &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">効率。 &lt;code&gt;angular.forEach&lt;/code&gt; とネイティブの &lt;code&gt;forEach&lt;/code&gt; は 、どちらの場合も、通常の &lt;code&gt;for&lt;/code&gt; ループよりも&lt;em&gt;はるかに&lt;/em&gt;遅くなります....約&lt;a href=&quot;http://jsperf.com/angular-foreach-vs-native-for-loop/3&quot;&gt;90％遅くなります&lt;/a&gt; 。 したがって、大規模なデータセットの場合は、ネイティブの &lt;code&gt;for&lt;/code&gt; ループを使用するのが最適です。</target>
        </trans-unit>
        <trans-unit id="9bbc4aeb0980cee945b58ff2f771d473c92abbcf" translate="yes" xml:space="preserve">
          <source>Every other p tag gets &lt;code&gt;class=&quot;red&quot;&lt;/code&gt;&amp;gt;</source>
          <target state="translated">他のすべてのpタグは &lt;code&gt;class=&quot;red&quot;&lt;/code&gt; を取得します&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="31d46401beeeb139181157a391e38208292ff52c" translate="yes" xml:space="preserve">
          <source>For Actual Arrays</source>
          <target state="translated">実際の配列について</target>
        </trans-unit>
        <trans-unit id="574d2bfcf687ca1c9e5ae449855c6a7b3be2b282" translate="yes" xml:space="preserve">
          <source>For Array-Like Objects</source>
          <target state="translated">配列類似オブジェクトの場合</target>
        </trans-unit>
        <trans-unit id="4c9f1e7b36c7b85949136c05d06c3d1376f6fb79" translate="yes" xml:space="preserve">
          <source>For maximum browser support, &lt;code&gt;for..of&lt;/code&gt;&lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-471169142&quot;&gt;requires a polyfill&lt;/a&gt; for iterators, making your app slightly slower to execute and slightly larger to download.</source>
          <target state="translated">ブラウザのサポートを最大化するに&lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-471169142&quot;&gt;は、for..of&lt;/a&gt;でイテレータの &lt;code&gt;for..of&lt;/code&gt; が必要になるため、アプリの実行速度がわずかに遅くなり、ダウンロードがわずかに大きくなります。</target>
        </trans-unit>
        <trans-unit id="07dab6b0cba0aafb7fb630f2e41c7bbe0d2fa27e" translate="yes" xml:space="preserve">
          <source>For more information and examples about functional programming on arrays, look at the blog post &lt;em&gt;&lt;a href=&quot;http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/&quot;&gt;Functional programming in JavaScript: map, filter and reduce&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">配列の関数型プログラミングの詳細と例については、ブログ投稿&lt;em&gt;&lt;a href=&quot;http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/&quot;&gt;「JavaScriptでの関数型プログラミング：map、filter、reduce」を&lt;/a&gt;&lt;/em&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="e5b5226b5b2f9ba8ea80f8e646bec60d9ae27902" translate="yes" xml:space="preserve">
          <source>For that reason (and to encourage use of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt;), &lt;a href=&quot;https://github.com/airbnb/javascript#iterators-and-generators&quot;&gt;some front-end style guides&lt;/a&gt; ban &lt;code&gt;for..of&lt;/code&gt; completely!</source>
          <target state="translated">そのため（そして &lt;code&gt;map&lt;/code&gt; と &lt;code&gt;filter&lt;/code&gt; の使用を奨励するため）、 &lt;a href=&quot;https://github.com/airbnb/javascript#iterators-and-generators&quot;&gt;一部のフロントエンドスタイルガイドは&lt;/a&gt;完全に禁止されています。</target>
        </trans-unit>
        <trans-unit id="740b5208eb855ba5fe663f7061e6d63db399e3ab" translate="yes" xml:space="preserve">
          <source>For-each over an array in JavaScript</source>
          <target state="translated">JavaScriptで配列の上をFor-eachする</target>
        </trans-unit>
        <trans-unit id="4b1bffa7198cab670a61e9e726dc8034ad855ba9" translate="yes" xml:space="preserve">
          <source>ForEach</source>
          <target state="translated">ForEach</target>
        </trans-unit>
        <trans-unit id="0b863337ad80c0e087cc5bb5e2ee2b6648e7963d" translate="yes" xml:space="preserve">
          <source>Foreach is basically a High Order Function, Which takes another function as its parameter.</source>
          <target state="translated">Foreachは基本的には高次関数であり、別の関数をパラメータとしています。</target>
        </trans-unit>
        <trans-unit id="8a78ff713dd92b2ecbc101771445889515332055" translate="yes" xml:space="preserve">
          <source>Granted this is a very simple hypothetical example, but I've written triple embedded for loops using the second approach and it was &lt;em&gt;very&lt;/em&gt; hard to read, and write for that matter.</source>
          <target state="translated">これは非常に単純な架空の例ですが、2番目のアプローチを使用して、3つの埋め込みforループを記述したので、そのために読み書きするのは&lt;em&gt;非常に&lt;/em&gt;困難でした。</target>
        </trans-unit>
        <trans-unit id="4007b162af20ada18ae8a52aec1f5ada3364061d" translate="yes" xml:space="preserve">
          <source>Host objects may implement these internal methods in any manner unless specified otherwise; for example, one possibility is that &lt;code&gt;[[Get]]&lt;/code&gt; and &lt;code&gt;[[Put]]&lt;/code&gt; for a particular host object indeed fetch and store property values but &lt;code&gt;[[HasProperty]]&lt;/code&gt; always generates &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">ホストオブジェクトは、特に指定されていない限り、これらの内部メソッドを任意の方法で実装できます。 たとえば、1つの可能性として、特定のホストオブジェクトの &lt;code&gt;[[Get]]&lt;/code&gt; および &lt;code&gt;[[Put]]&lt;/code&gt; が実際にプロパティ値をフェッチして保存するが、 &lt;code&gt;[[HasProperty]]&lt;/code&gt; は常に&lt;strong&gt;falseを&lt;/strong&gt;生成する可能性があり&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="19813696848672a3c1fd16a6dcede994e8b0ea3c" translate="yes" xml:space="preserve">
          <source>How can I loop through all the entries in an array using JavaScript?</source>
          <target state="translated">JavaScriptを使って配列内のすべてのエントリをループさせるにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">どうやって使うのか?</target>
        </trans-unit>
        <trans-unit id="ca7b3040f56acb6407fc724b0d2fd827a45691bf" translate="yes" xml:space="preserve">
          <source>However in practice that is &lt;strong&gt;not&lt;/strong&gt; actually a reliable indication of intent, since it is indistinguishable from those occasions when you &lt;strong&gt;&lt;em&gt;do&lt;/em&gt;&lt;/strong&gt; care about the order, and really do &lt;strong&gt;&lt;em&gt;need&lt;/em&gt;&lt;/strong&gt; to loop in reverse.  So in fact another construct would be needed to accurately express the &quot;don't care&quot; intent, something currently unavailable in most languages, including ECMAScript, but which could be called, for example, &lt;code&gt;forEachUnordered()&lt;/code&gt;.</source>
          <target state="translated">ただし、実際には意図を信頼できる形で示している&lt;strong&gt;わけ&lt;/strong&gt;ではあり&lt;strong&gt;ません。&lt;/strong&gt;順序を気にしていて、逆にループ&lt;strong&gt;&lt;em&gt;する必要がある&lt;/em&gt;&lt;/strong&gt;場合と区別がつかないためです。 そのため、実際には、「ドントケア」の意図を正確に表現するために別の構成が必要になります。これは、現在ECMAScriptを含むほとんどの言語では利用できませんが、たとえば &lt;code&gt;forEachUnordered()&lt;/code&gt; と呼ぶことができます。</target>
        </trans-unit>
        <trans-unit id="61f75f3469a29e1942e3c3329af27ea060513a5e" translate="yes" xml:space="preserve">
          <source>However, note that there may be reasons to use an even simpler &lt;code&gt;for&lt;/code&gt; loop (see Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504&quot;&gt;Why is using &amp;ldquo;for&amp;hellip;in&amp;rdquo; with array iteration such a bad idea?&lt;/a&gt;&lt;/em&gt;)</source>
          <target state="translated">ただし、さらに単純な &lt;code&gt;for&lt;/code&gt; ループを使用する理由がある場合があることに注意してください（「スタックオーバーフローの質問&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504&quot;&gt;」を&lt;/a&gt;&lt;/em&gt;参照してください&lt;em&gt;。配列反復で「for ... in」を使用するのはなぜ悪い考えですか？&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="a6aed835f2d563c4c3320a911d587d82dbda800c" translate="yes" xml:space="preserve">
          <source>I also would like to add this as a composition of a reverse loop and an answer above for someone that would like this syntax too.</source>
          <target state="translated">私もこの構文が好きな人のために、逆ループと上の回答の構成として追加したいと思います。</target>
        </trans-unit>
        <trans-unit id="8477c992b5ade4df47cd7654aa1828b412e4a489" translate="yes" xml:space="preserve">
          <source>I know this is an old post, and there are so many great answers already. For a little more completeness I figured I'd throw in another one using &lt;a href=&quot;https://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;. Of course, this only applies if you're using Angular, obviously, nonetheless I'd like to put it anyway.</source>
          <target state="translated">私はこれが古い投稿であることを知っており、すでに非常に多くの素晴らしい答えがあります。 もう少し完全にするために、 &lt;a href=&quot;https://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;を使用して別のものを投入すると思いました。 もちろん、これは、Angularを使用している場合にのみ当てはまります。</target>
        </trans-unit>
        <trans-unit id="1c59ff4d9355404cf9a4b93a2e4792e99f5c4e05" translate="yes" xml:space="preserve">
          <source>I think the &lt;em&gt;reverse&lt;/em&gt; for loop deserves a mention here:</source>
          <target state="translated">ここでは、forループの&lt;em&gt;逆&lt;/em&gt;に言及する価値があると思います。</target>
        </trans-unit>
        <trans-unit id="f6502d93534ccbe12812234fb241d45f4ba61f26" translate="yes" xml:space="preserve">
          <source>I thought it was something like this:</source>
          <target state="translated">こんな感じかと思っていました。</target>
        </trans-unit>
        <trans-unit id="3603f48e92361f2a2fc432d1e620a715ff3fe622" translate="yes" xml:space="preserve">
          <source>I usually use the</source>
          <target state="translated">私が普段使っているのは</target>
        </trans-unit>
        <trans-unit id="12bc6fc52aa07da9df836fd7799f22941f498dc1" translate="yes" xml:space="preserve">
          <source>I'll quickly note that you can use the ES2015 options &lt;em&gt;now&lt;/em&gt;, even on ES5 engines, by &lt;em&gt;transpiling&lt;/em&gt; ES2015 to ES5. Search for &quot;ES2015 transpiling&quot; / &quot;ES6 transpiling&quot; for more...</source>
          <target state="translated">ES2015をES5に&lt;em&gt;トランス&lt;/em&gt;パイルすることにより、ES5エンジンでもES2015オプションを&lt;em&gt;すぐに&lt;/em&gt;使用できることにすぐに気づきます。 詳細については、「ES2015トランスパイル」/「ES6トランスパイル」を検索してください...</target>
        </trans-unit>
        <trans-unit id="18c6f30a69467c4462f7d6abc615a72db576f06d" translate="yes" xml:space="preserve">
          <source>I'm sure there's various other pros and cons as well, and please feel free to add any that you see fit. I feel that, bottom line, if you need efficiency, stick with just the native &lt;code&gt;for&lt;/code&gt; loop for your looping needs. But, if your datasets are smaller and a some efficiency is okay to give up in exchange for readability and writability, then by all means throw an &lt;code&gt;angular.forEach&lt;/code&gt; in that bad boy.</source>
          <target state="translated">他にもさまざまな長所と短所があると思います。必要に応じて自由に追加してください。 結論として、効率が必要な場合は、ループのニーズに合わせてネイティブの &lt;code&gt;for&lt;/code&gt; ループのみを使用するようにしてください。 しかし、データセットが小さく、読みやすさと &lt;code&gt;angular.forEach&lt;/code&gt; 性と引き換えにある程度の効率をあきらめても大丈夫な場合は、 必ずその悪党にangular.forEachをスローしてください 。</target>
        </trans-unit>
        <trans-unit id="06ac5670940bbfb285c1ba0308b4821c84d5e171" translate="yes" xml:space="preserve">
          <source>If available, &lt;code&gt;angular.forEach&lt;/code&gt; will use the ES5 forEach loop. Now, I will get to efficientcy in the cons section, as the forEach loops are &lt;em&gt;much&lt;/em&gt; slower than the for loops. I mention this as a pro because it's nice to be consistent and standardized.</source>
          <target state="translated">使用可能な場合、 &lt;code&gt;angular.forEach&lt;/code&gt; はES5 forEachループを使用します。 forEachループはforループよりも&lt;em&gt;はるかに&lt;/em&gt;遅いため、今度はconsセクションで効率性を確認します。 一貫性があり、標準化されていることは素晴らしいので、私はこれをプロと呼んでいます。</target>
        </trans-unit>
        <trans-unit id="e8907402896b09c17431fc05797665a93d1d2ebc" translate="yes" xml:space="preserve">
          <source>If order doesn't matter, and &lt;strong&gt;efficiency&lt;/strong&gt; is a concern (in the innermost loop of a game or animation engine), then it may be acceptable to use the reverse for loop as your go-to pattern.  Just remember that seeing a reverse for loop in existing code &lt;strong&gt;does not necessarily mean&lt;/strong&gt; that the order irrelevant!</source>
          <target state="translated">順序が問題ではなく、 &lt;strong&gt;効率&lt;/strong&gt;が問題である場合（ゲームまたはアニメーションエンジンの最も内側のループ）、逆パターンのforループを目的のパターンとして使用することもできます。 既存のコードで逆forループが表示され&lt;strong&gt;ても、必ずしも&lt;/strong&gt;順序が無関係であると&lt;strong&gt;は限らないことに注意&lt;/strong&gt;してください。</target>
        </trans-unit>
        <trans-unit id="b80d2d2ba2c3b20f6e937c93c538d0e0be32e646" translate="yes" xml:space="preserve">
          <source>If the length of the array won't change during the loop, and it's in performance-sensitive code (unlikely), a slightly more complicated version grabbing the length up front might be a &lt;strong&gt;&lt;em&gt;tiny&lt;/em&gt;&lt;/strong&gt; bit faster:</source>
          <target state="translated">ループ中に配列の長さが変化せず、パフォーマンスに敏感なコードの場合（そうではない）、長さを前もって取得する少し複雑なバージョンの方が少し高速かもしれません。</target>
        </trans-unit>
        <trans-unit id="b92dceb455d82f7bd9cef350ebca0d33e590aa5b" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;modify the array&lt;/strong&gt; while looping, at or after index &lt;em&gt;i&lt;/em&gt; (for example you remove or insert an item at &lt;code&gt;array[i]&lt;/code&gt;), then a forward loop would skip the item that shifted left into position &lt;em&gt;i&lt;/em&gt;, or re-process the &lt;em&gt;i&lt;/em&gt;th item that was shifted right.  In a traditional for loop, you &lt;em&gt;could&lt;/em&gt; update &lt;em&gt;i&lt;/em&gt; to point to the next item that needs processing - 1, but simply reversing the direction of iteration is often a &lt;strong&gt;simpler&lt;/strong&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/23186254/javascript-splice-changing-earlier-values-in-an-array/23186450#23186450&quot;&gt;more elegant solution&lt;/a&gt;.</source>
          <target state="translated">ループ中、インデックス&lt;em&gt;i&lt;/em&gt;以降で&lt;strong&gt;配列&lt;/strong&gt;を&lt;strong&gt;変更した&lt;/strong&gt;場合（たとえば、 &lt;code&gt;array[i]&lt;/code&gt; でアイテムを削除または挿入した場合）、フォワードループは、左にシフトしたアイテムを位置&lt;em&gt;i&lt;/em&gt;にスキップするか、 &lt;em&gt;iを&lt;/em&gt;再処理します。右にシフトされたアイテム。 従来のforループでは、処理を必要とする次の項目を指すように&lt;em&gt;i&lt;/em&gt;を更新すること&lt;em&gt;ができ&lt;/em&gt;ます-1が、反復の方向を単に逆にすることは、多くの場合、 &lt;strong&gt;よりシンプル&lt;/strong&gt;で&lt;a href=&quot;https://stackoverflow.com/questions/23186254/javascript-splice-changing-earlier-values-in-an-array/23186450#23186450&quot;&gt;エレガントなソリューション&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="2e64946b63608dcfc94ea160317714137b7354db" translate="yes" xml:space="preserve">
          <source>If you are a jQuery &lt;em&gt;fan&lt;/em&gt; and already have a jQuery file running, you should reverse the positions of the index and value parameters</source>
          <target state="translated">jQuery &lt;em&gt;ファンで&lt;/em&gt;あり、すでにjQueryファイルを実行している場合は、インデックスと値のパラメーターの位置を逆にする必要があります</target>
        </trans-unit>
        <trans-unit id="13ddd4cb90755914bc68cb46a5dcb9579aa341e2" translate="yes" xml:space="preserve">
          <source>If you don't mind emptying the array:</source>
          <target state="translated">配列を空にしても構わないのであれば</target>
        </trans-unit>
        <trans-unit id="ae87d418a37aaf3cda30fae440c63ffde95ff67b" translate="yes" xml:space="preserve">
          <source>If you had five divs, you'd get &quot;Index is: 0&quot; if you clicked the first and &quot;Index is: 4&quot; if you clicked the last. This does &lt;strong&gt;not&lt;/strong&gt; work if you use &lt;code&gt;var&lt;/code&gt; instead of &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">5つのdivがある場合、最初をクリックした場合は「Index is：0」、最後をクリックした場合は「Index is：4」になります。 &lt;code&gt;let&lt;/code&gt; の代わりに &lt;code&gt;var&lt;/code&gt; を使用すると、これは機能しませ&lt;strong&gt;ん&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d8e10b19a52f515f5ce1b1b685c8f30f79143a6" translate="yes" xml:space="preserve">
          <source>If you have a massive array you should use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt;&lt;strong&gt;&lt;code&gt;iterators&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; to gain some efficiency. Iterators are a property of certain JavaScript collections (like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;). Even, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt;&lt;code&gt;for..of&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; uses &lt;strong&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/strong&gt; under-the-hood.</source>
          <target state="translated">大規模な配列がある場合は、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt;&lt;strong&gt; &lt;code&gt;iterators&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;を使用して効率を上げる必要があり&lt;strong&gt;ます&lt;/strong&gt; 。 イテレータは、特定のJavaScriptコレクション（ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; など&lt;/a&gt; ）のプロパティです。 でも、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt; &lt;code&gt;for..of&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;は&lt;strong&gt;内部で&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/strong&gt;を使用し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="937ed980f598e6ed46ab0a45f6808c763154dc2c" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;Array.prototype&lt;/code&gt; functions with &lt;em&gt;host-provided&lt;/em&gt; array-like objects (DOM lists and other things provided by the browser rather than the JavaScript engine), you need to be sure to test in your target environments to make sure the host-provided object behaves properly. &lt;strong&gt;Most do behave properly&lt;/strong&gt; (now), but it's important to test. The reason is that most of the &lt;code&gt;Array.prototype&lt;/code&gt; methods you're likely to want to use rely on the host-provided object giving an honest answer to the abstract &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p&quot;&gt;&lt;code&gt;[[HasProperty]]&lt;/code&gt;&lt;/a&gt; operation. As of this writing, browsers do a very good job of this, but the 5.1 spec did allow for the possibility a host-provided object may not be honest. It's in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2&quot;&gt;&amp;sect;8.6.2&lt;/a&gt;, several paragraphs below the big table near the beginning of that section), where it says:</source>
          <target state="translated">&lt;em&gt;ホストが提供する&lt;/em&gt;配列のようなオブジェクト（JavaScriptエンジンではなくブラウザーが提供するDOMリストなど）で &lt;code&gt;Array.prototype&lt;/code&gt; 関数を使用する場合は、ターゲット環境でテストして、ホストが提供することを確認する必要があります。オブジェクトは適切に動作します。 &lt;strong&gt;ほとんどは適切に動作しますが&lt;/strong&gt; （現在）、テストすることが重要です。 その理由は、使用する可能性が高い &lt;code&gt;Array.prototype&lt;/code&gt; メソッドのほとんどが、ホストが提供するオブジェクトに依存して、抽象&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p&quot;&gt; &lt;code&gt;[[HasProperty]]&lt;/code&gt; &lt;/a&gt;操作に正直な回答を提供するためです。 これを書いている時点では、ブラウザーはこれを非常にうまく行っていますが、5.1仕様では、ホスト提供のオブジェクトが正直ではない可能性を考慮に入れていました。 それは&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2&quot;&gt;&amp;sect;8.6.2にあり&lt;/a&gt; 、そのセクションの冒頭近くの大きなテーブルの下のいくつかの段落）に、それは次のように述べています：</target>
        </trans-unit>
        <trans-unit id="1cf65717377f5a0ffbf4016aa7b65a5777d9b6bb" translate="yes" xml:space="preserve">
          <source>If you want to break, a little more logic:</source>
          <target state="translated">壊すならもう少し論理的に。</target>
        </trans-unit>
        <trans-unit id="1aae02233e247aceba4786eb942d19b76a8c3c1d" translate="yes" xml:space="preserve">
          <source>If you want to loop over an array, use the standard three-part &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">配列をループする場合は、標準の3部構成の &lt;code&gt;for&lt;/code&gt; ループを使用します。</target>
        </trans-unit>
        <trans-unit id="11105b5c63e872bf555853378e76dfee57d8fded" translate="yes" xml:space="preserve">
          <source>If you want to loop through an array of objects with the arrow function:</source>
          <target state="translated">矢印関数を使ってオブジェクトの配列をループさせたい場合。</target>
        </trans-unit>
        <trans-unit id="986435ae4b5acc19dfcae749d8f1c3e4994226d8" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;for()&lt;/code&gt;, it will look like -</source>
          <target state="translated">&lt;code&gt;for()&lt;/code&gt; を使用する場合、次のようになります-</target>
        </trans-unit>
        <trans-unit id="4acb3d06d2c92261570911bf5c1b6824ec6805ec" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;forEach()&lt;/code&gt;, it will look like -</source>
          <target state="translated">&lt;code&gt;forEach()&lt;/code&gt; を使用する場合、次のようになります-</target>
        </trans-unit>
        <trans-unit id="5fc44f65228be3d46253870a654fc920e523f6cf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the &lt;a href=&quot;http://jquery.com/&quot;&gt;&lt;strong&gt;jQuery&lt;/strong&gt;&lt;/a&gt; library, you can use &lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;&lt;strong&gt;jQuery.each&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com/&quot;&gt;&lt;strong&gt;jQuery&lt;/strong&gt;&lt;/a&gt;ライブラリを使用している場合は、 &lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;&lt;strong&gt;jQuery.each&lt;/strong&gt;&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="6a9d6ebddd744df1593bd5988193105784652f8b" translate="yes" xml:space="preserve">
          <source>If you're going to do that a lot, you might want to grab a copy of the function reference into a variable for reuse, e.g.:</source>
          <target state="translated">もし何度もやるのであれば、再利用のために関数参照のコピーを変数に取り込んでおきたいかもしれません。</target>
        </trans-unit>
        <trans-unit id="dd131ceaa21a63af287b484051a159dfdece2176" translate="yes" xml:space="preserve">
          <source>If you're worried about the runtime cost of making a function call for each array entry, don't be; &lt;a href=&quot;http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html&quot;&gt;details&lt;/a&gt;.</source>
          <target state="translated">各配列エントリに対して関数呼び出しを行う際の実行時のコストが心配な場合は、心配しないでください。 &lt;a href=&quot;http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html&quot;&gt;詳細&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40638a60a037cede5301ef987dee8d1ace1a9b0f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt; there will be a forEach method on the array prototype, but it is not supported in legacy browsers. So to be able to use it consistently you must either have an environment that supports it (for example, &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; for server side JavaScript), or use a &quot;Polyfill&quot;. The Polyfill for this functionality is, however, trivial and since it makes the code easier to read, it is a good polyfill to include.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt;では、配列プロトタイプにforEachメソッドがありますが、レガシーブラウザーではサポートされていません。 したがって、これを一貫して使用できるようにするには、それをサポートする環境（たとえば、サーバー側JavaScriptの&lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; ）を用意するか、「Polyfill」を使用する必要があります。 ただし、この機能のポリフィルは簡単なものであり、コードを読みやすくするため、含めるのに適したポリフィルです。</target>
        </trans-unit>
        <trans-unit id="1280ba4c719753e18ee74f317b64294340b96082" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in&quot;&gt;for_each...in&lt;/a&gt;&lt;/em&gt; (MDN) it is explained that &lt;code&gt;for each (variable in object)&lt;/code&gt; is deprecated as the part of ECMA-357 (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/E4X&quot;&gt;EAX&lt;/a&gt;) standard.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in&quot;&gt;for_each ... in&lt;/a&gt;&lt;/em&gt; （MDN）では &lt;code&gt;for each (variable in object)&lt;/code&gt; がECMA-357（ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/E4X&quot;&gt;EAX&lt;/a&gt; ）標準の一部として廃止されていると説明されています。</target>
        </trans-unit>
        <trans-unit id="9beb0c3410927f822bce0dcb01f44ccc46812376" translate="yes" xml:space="preserve">
          <source>In ES2015 and higher, you can make your index and value variables local to the &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">ES2015以降では、インデックス変数と値変数を &lt;code&gt;for&lt;/code&gt; ループに対してローカルにすることができます。</target>
        </trans-unit>
        <trans-unit id="2cd3e11ca52c117696a761c0998ed90bfcd20a96" translate="yes" xml:space="preserve">
          <source>In any vaguely-modern environment (so, not IE8) where you have access to the &lt;code&gt;Array&lt;/code&gt; features added by ES5 (directly or using polyfills), you can use &lt;code&gt;forEach&lt;/code&gt; (&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt;&lt;code&gt;spec&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;MDN&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">ES5によって追加された &lt;code&gt;Array&lt;/code&gt; 機能に（直接またはポリフィルを使用して）アクセスできる、漠然としたモダンな環境（IE8ではない）では、 &lt;code&gt;forEach&lt;/code&gt; （ &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt; &lt;code&gt;spec&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;MDN&lt;/code&gt; &lt;/a&gt; ）を使用できます。</target>
        </trans-unit>
        <trans-unit id="b3516d7a0d41bd0df93ef14853544e18b99e2cde" translate="yes" xml:space="preserve">
          <source>In case, more interested on operation on array using some inbuilt feature.</source>
          <target state="translated">もしもの時のために、組み込みの機能を使った配列の操作にも興味があります。</target>
        </trans-unit>
        <trans-unit id="99006d079057d1e0af6e98a54c83d22f0c6ba073" translate="yes" xml:space="preserve">
          <source>In general for higher level code where &lt;strong&gt;clarity and safety&lt;/strong&gt; are greater concerns, I previously recommended using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array::forEach&lt;/code&gt;&lt;/a&gt; as your default pattern for looping (although these days I prefer to use &lt;code&gt;for..of&lt;/code&gt;).  Reasons to prefer &lt;code&gt;forEach&lt;/code&gt; over a reverse loop are:</source>
          <target state="translated">一般的に、 &lt;strong&gt;明快さと安全性&lt;/strong&gt;が&lt;strong&gt;重視さ&lt;/strong&gt;れる高レベルのコードの場合、以前はループのデフォルトパターンとして&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array::forEach&lt;/code&gt; &lt;/a&gt;を使用することをお勧めしました（ただし、最近では &lt;code&gt;for..of&lt;/code&gt; を使用することを好みます）。 リバースループよりも &lt;code&gt;forEach&lt;/code&gt; を選ぶ理由は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="268bee6cf2ad84db04fb8978e3c41ceecff7fc38" translate="yes" xml:space="preserve">
          <source>In tests we calculate the sum of array elements. I perform a test for small arrays (10 elements) and big arrays (1M elements) and divide them into three groups:</source>
          <target state="translated">テストでは配列の要素の和を計算します。小さな配列(10要素)と大きな配列(1M要素)のテストを行い、3つのグループに分けます。</target>
        </trans-unit>
        <trans-unit id="3fb2676f32b14c1a1bbfd3126c8971f3d39c2fe6" translate="yes" xml:space="preserve">
          <source>In the traditional forwards for loop, &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; are interchangeable (as Douglas Crockford points out).  However in the reverse for loop, because our decrement is also our condition expression, we must stick with &lt;code&gt;i--&lt;/code&gt; if we want to process the item at index 0.</source>
          <target state="translated">従来のforward forループでは、 &lt;code&gt;i++&lt;/code&gt; と &lt;code&gt;++i&lt;/code&gt; は交換可能です（Douglas Crockfordが指摘しているように）。 ただし、逆のforループでは、デクリメントも条件式なので、インデックス0でアイテムを処理する場合は、 &lt;code&gt;i--&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="9f2a940ef1876e18b0a2d2adbbb0054401c1e001" translate="yes" xml:space="preserve">
          <source>It gives you a free scope for closures.</source>
          <target state="translated">閉鎖のための自由な範囲を与えてくれます。</target>
        </trans-unit>
        <trans-unit id="a26206100bd26a40a1a52fbba4254be28b14f1b7" translate="yes" xml:space="preserve">
          <source>It indicates that &lt;em&gt;i&lt;/em&gt; is not going to be shifted within the block (which is always a possible surprise hiding in long &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; loops).</source>
          <target state="translated">これは、 &lt;em&gt;i&lt;/em&gt;がブロック内でシフトされないことを示しています（これは、常に &lt;code&gt;for&lt;/code&gt; ループと &lt;code&gt;while&lt;/code&gt; ループで突然の非表示になる可能性があります）。</target>
        </trans-unit>
        <trans-unit id="9c1e136ecc6d6ff5b0bb24c065a47cca352d2f77" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;shorter&lt;/strong&gt; to type, and &lt;strong&gt;read&lt;/strong&gt;, than some of the other options available.  Although it loses to &lt;code&gt;forEach()&lt;/code&gt; and to ES6's &lt;code&gt;for ... of&lt;/code&gt;.</source>
          <target state="translated">利用可能な他のオプションのいくつかよりも、タイプして&lt;strong&gt;読む&lt;/strong&gt; &lt;strong&gt;方&lt;/strong&gt;が&lt;strong&gt;短い&lt;/strong&gt;です。 &lt;code&gt;forEach()&lt;/code&gt; とES6の &lt;code&gt;for ... of&lt;/code&gt; 負けますが 。</target>
        </trans-unit>
        <trans-unit id="e1592309e0411fe23d697624a6b081cb0ad5da05" translate="yes" xml:space="preserve">
          <source>It is clearer to read.</source>
          <target state="translated">読みやすくなっています。</target>
        </trans-unit>
        <trans-unit id="6fa8793a5b9a126bead6bc588548bf65c1d59eff" translate="yes" xml:space="preserve">
          <source>It is now even better to use for..of!</source>
          <target state="translated">のために使用することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="4c654c5e846023844a47e14f6c000b121f5ea18b" translate="yes" xml:space="preserve">
          <source>It looks like the traditional &lt;code&gt;for i&lt;/code&gt; (&lt;strong&gt;Aa&lt;/strong&gt;) is a good choice to write fast code on all browsers.</source>
          <target state="translated">従来の &lt;code&gt;for i&lt;/code&gt; （ &lt;strong&gt;Aa&lt;/strong&gt; ）は、すべてのブラウザーで高速コードを作成するのに適した選択のようです。</target>
        </trans-unit>
        <trans-unit id="b05ec9bd35f4ee8f34e03d2c14bb2cf3574009f2" translate="yes" xml:space="preserve">
          <source>It processes the items in reverse order.  If you were building a new array from the results, or printing things on screen, naturally &lt;strong&gt;the output will be reversed&lt;/strong&gt; with respect to the original order.</source>
          <target state="translated">逆の順序でアイテムを処理します。 結果から新しい配列を作成したり、画面に印刷したりする場合、当然&lt;strong&gt;、出力は&lt;/strong&gt;元の順序に対して&lt;strong&gt;逆になります&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="92650d012635dc87fe3676b746f2df0b221ba0a1" translate="yes" xml:space="preserve">
          <source>It reduces leakage of local variables and accidental collision with (and mutation of) outer variables.</source>
          <target state="translated">局所変数の漏れや、外部変数との偶発的な衝突(および突然変異)を軽減します。</target>
        </trans-unit>
        <trans-unit id="c027793c4fcbf7f7be6aed911c23cf2d476fffe0" translate="yes" xml:space="preserve">
          <source>It returns:</source>
          <target state="translated">返ってきます。</target>
        </trans-unit>
        <trans-unit id="5a66b905f75247eeead429833c89c54b6d523c59" translate="yes" xml:space="preserve">
          <source>It was better to use forEach()</source>
          <target state="translated">forEach()を使った方が良かったです。</target>
        </trans-unit>
        <trans-unit id="970da87efbe446de6ff12d27fb12ff80a89bc4c8" translate="yes" xml:space="preserve">
          <source>It's a &lt;a href=&quot;http://en.wikipedia.org/wiki/Sparse_array&quot;&gt;&lt;em&gt;sparse&lt;/em&gt; arrays&lt;/a&gt; with &lt;strong&gt;massive&lt;/strong&gt; gaps in it, or</source>
          <target state="translated">非常に&lt;strong&gt;大きな&lt;/strong&gt;ギャップがある&lt;a href=&quot;http://en.wikipedia.org/wiki/Sparse_array&quot;&gt;&lt;em&gt;疎な&lt;/em&gt;配列&lt;/a&gt; 、または</target>
        </trans-unit>
        <trans-unit id="76bb57f065042a04a16fd907fcb40021f5d1d715" translate="yes" xml:space="preserve">
          <source>It's also possible to use ES2015's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread syntax&lt;/a&gt; with JavaScript engines that support this feature:</source>
          <target state="translated">この機能をサポートするJavaScriptエンジンでES2015の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;スプレッド構文&lt;/a&gt;を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="cf3b30579b92065eb7bc495af1fbdb1ca47efb2e" translate="yes" xml:space="preserve">
          <source>It's important to note that &lt;code&gt;Array.prototype.forEach&lt;/code&gt; doesn't break when the callback returns &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; provide their own variations on &lt;code&gt;each&lt;/code&gt; to provide loops that can be short-circuited.</source>
          <target state="translated">コールバックが &lt;code&gt;false&lt;/code&gt; を返しても &lt;code&gt;Array.prototype.forEach&lt;/code&gt; は中断しないことに注意することが重要です。 &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt;と&lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt;は、それぞれに独自のバリエーションを提供し、短絡可能なループを提供します。</target>
        </trans-unit>
        <trans-unit id="8422ffb83ff856b5915a4e7e4e65862872e7a17c" translate="yes" xml:space="preserve">
          <source>Iterators are exhaustible in nature.</source>
          <target state="translated">イテレータは元来、消耗するものです。</target>
        </trans-unit>
        <trans-unit id="dd908ea29f0174193357642014bde7f4f593cc70" translate="yes" xml:space="preserve">
          <source>Iterators improve efficiency by letting you consume the items in a list one at a time as if they were a stream. What makes an iterator special is how it traverses a collection. Other loops need to load the entire collection up front in order to iterate over it, whereas an iterator only needs to know the current position in the collection.</source>
          <target state="translated">イテレータは、リスト内のアイテムをストリームのように一度に一つずつ消費できるようにすることで、効率を向上させます。イテレータが特別なのは、コレクションを横断する方法です。他のループでは、コレクションを反復処理するためにコレクション全体を前もってロードする必要がありますが、イテレータはコレクション内の現在位置を知る必要があるだけです。</target>
        </trans-unit>
        <trans-unit id="b4cec08cd006bef91b92cd98b872c068dfc6d47a" translate="yes" xml:space="preserve">
          <source>JavaScript has powerful semantics for looping through arrays and array-like objects. I've split the answer into two parts: Options for genuine arrays, and options for things that are just array-&lt;em&gt;like&lt;/em&gt;, such as the &lt;code&gt;arguments&lt;/code&gt; object, other iterable objects (ES2015+), DOM collections, and so on.</source>
          <target state="translated">JavaScriptには、配列や配列のようなオブジェクトをループするための強力なセマンティクスがあります。 正解の配列のオプションと、 &lt;code&gt;arguments&lt;/code&gt; オブジェクト、他の反復可能オブジェクト（ES2015 +）、DOMコレクションなど、配列に&lt;em&gt;似た&lt;/em&gt;もののオプションの2つの部分に答えを分けました。</target>
        </trans-unit>
        <trans-unit id="45b89ea7174719fe9456dfc7830bcd1c7b08f842" translate="yes" xml:space="preserve">
          <source>Looking only at that first example: You can use &lt;code&gt;for-in&lt;/code&gt; to visit those sparse array elements if you use appropriate safeguards:</source>
          <target state="translated">最初の例のみを見る：適切な保護手段を使用すれば &lt;code&gt;for-in&lt;/code&gt; を使用して、これらの疎配列要素にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="4839c1708da783319e9fbcbf7bb1edf7ed55c460" translate="yes" xml:space="preserve">
          <source>Loop backwards</source>
          <target state="translated">ループバック</target>
        </trans-unit>
        <trans-unit id="116eba95b7902da0b19b136ed240ca0e56d035ae" translate="yes" xml:space="preserve">
          <source>No break, continue, or return support. &lt;code&gt;continue&lt;/code&gt; is actually supported by &quot;&lt;a href=&quot;https://github.com/angular/angular.js/issues/263&quot;&gt;accident&lt;/a&gt;&quot;, to continue in an &lt;code&gt;angular.forEach&lt;/code&gt; you simple put a &lt;code&gt;return;&lt;/code&gt; statement in the function like &lt;code&gt;angular.forEach(array, function(item) { if (someConditionIsTrue) return; });&lt;/code&gt; which will cause it to continue out of the function for that iteration. This is also due to the fact that the native &lt;code&gt;forEach&lt;/code&gt; does not support break or continue either.</source>
          <target state="translated">中断、継続、または返品のサポートはありません。 &lt;code&gt;continue&lt;/code&gt; は、実際には「 &lt;a href=&quot;https://github.com/angular/angular.js/issues/263&quot;&gt;事故&lt;/a&gt; 」によってサポートされ、 &lt;code&gt;angular.forEach&lt;/code&gt; を付けて続行します &lt;code&gt;return;&lt;/code&gt; &lt;code&gt;angular.forEach(array, function(item) { if (someConditionIsTrue) return; });&lt;/code&gt; などの関数内のステートメント{if（someConditionIsTrue）return;}）; これにより、その反復の関数の外で続行します。 これは、ネイティブの &lt;code&gt;forEach&lt;/code&gt; が中断または継続もサポートしていないためです。</target>
        </trans-unit>
        <trans-unit id="b8c4d2fd6737ec63b08a652d9add0b5b76e57401" translate="yes" xml:space="preserve">
          <source>Note the three checks:</source>
          <target state="translated">3つのチェックに注意してください。</target>
        </trans-unit>
        <trans-unit id="98d5f549991350bbddfb1b3e02a8c7d43a397e2d" translate="yes" xml:space="preserve">
          <source>Note, however, that this approach is only good if you have a dense array, and each index is occupied by an element. If the array is sparse, then you can run into performance problems with this approach, since you will iterate over a lot of indices that do not &lt;em&gt;really&lt;/em&gt; exist in the array. In this case, a &lt;code&gt;for .. in&lt;/code&gt;-loop might be a better idea. &lt;strong&gt;However&lt;/strong&gt;, you must use the appropriate safeguards to ensure that only the desired properties of the array (that is, the array elements) are acted upon, since the &lt;code&gt;for..in&lt;/code&gt;-loop will also be enumerated in legacy browsers, or if the additional properties are defined as &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">ただし、この方法が適切なのは、配列が密で、各インデックスが要素で占められている場合のみです。 配列がスパースである場合、 &lt;em&gt;実際&lt;/em&gt;には配列に存在しない多くのインデックスを反復処理するため、このアプローチではパフォーマンスの問題が発生する可能性があります。 この場合、 &lt;code&gt;for .. in&lt;/code&gt; -loopの方が適しています。 &lt;strong&gt;ただし&lt;/strong&gt; 、 &lt;code&gt;for..in&lt;/code&gt; -loopはレガシーブラウザでも列挙されるため、または追加の場合は、適切な保護手段を使用して、配列の目的のプロパティ（つまり、配列要素）のみが機能するようにする必要があります。プロパティは &lt;code&gt;enumerable&lt;/code&gt; として定義されています。</target>
        </trans-unit>
        <trans-unit id="cdb386055d71d4e57655448305f3f266ba898acc" translate="yes" xml:space="preserve">
          <source>Now there are pros and cons of using the &lt;code&gt;angular.forEach&lt;/code&gt; function as opposed to the built in vanilla-flavored &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">現在、組み込みのバニラ風味の &lt;code&gt;for&lt;/code&gt; ループとは対照的に、 &lt;code&gt;angular.forEach&lt;/code&gt; 関数を使用することには長所と短所があります。</target>
        </trans-unit>
        <trans-unit id="ca0defbc542adca7eb89b7d006ccdd58542fae1e" translate="yes" xml:space="preserve">
          <source>Objects are not &lt;code&gt;iterable&lt;/code&gt; by default. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for..in&lt;/code&gt;&lt;/a&gt; in that case because instead of values it works with keys.</source>
          <target state="translated">オブジェクトはデフォルトでは &lt;code&gt;iterable&lt;/code&gt; はありません。 その場合は、値の代わりにキーで機能するため、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for..in&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="dac14b18ddbcf811caa6f41435770bfcac91def3" translate="yes" xml:space="preserve">
          <source>Obviously, a simple &lt;code&gt;for&lt;/code&gt; loop applies to array-like objects.</source>
          <target state="translated">明らかに、単純な &lt;code&gt;for&lt;/code&gt; ループは配列のようなオブジェクトに適用されます。</target>
        </trans-unit>
        <trans-unit id="0b2eddf2aee3155f4ce4917a2380a892eac5b90f" translate="yes" xml:space="preserve">
          <source>Okay, let's look at our options:</source>
          <target state="translated">さて、選択肢を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="a72c2c53fbdfb2727533feb058f51addfd63ad98" translate="yes" xml:space="preserve">
          <source>Or if you wanted to get an array of the tag names of the elements with a given class, you'd use the mapping function:</source>
          <target state="translated">あるいは、指定されたクラスの要素のタグ名の配列を取得したい場合は、マッピング関数を使用します。</target>
        </trans-unit>
        <trans-unit id="073b8d82f68c2fdbe0506bde968834e71b06dd49" translate="yes" xml:space="preserve">
          <source>Other times, you may want to convert an array-like object into a true array. Doing that is surprisingly easy:</source>
          <target state="translated">また、配列のようなオブジェクトを真の配列に変換したい場合もあるでしょう。これは驚くほど簡単です。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="aab5f282758bebdcb0646ab510ae5cc532d051d9" translate="yes" xml:space="preserve">
          <source>Personally, I tend to use whatever looks easiest to read, unless performance or minification has become a major concern.  So these days I prefer to use &lt;code&gt;for..of&lt;/code&gt; instead of &lt;code&gt;forEach()&lt;/code&gt;, but I will always use &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;&lt;code&gt;some&lt;/code&gt;&lt;/a&gt; when applicable. 
 (For the sake of my colleagues, I rarely use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">個人的には、パフォーマンスやミニファイが大きな問題にならない限り、私は読みやすいものを何でも使う傾向があります。 したがって、最近では、 &lt;code&gt;forEach()&lt;/code&gt; ではなく &lt;code&gt;for..of&lt;/code&gt; を使用することを好みますが、常に &lt;code&gt;map&lt;/code&gt; または &lt;code&gt;filter&lt;/code&gt; 使用する&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt; &lt;code&gt;some&lt;/code&gt; &lt;/a&gt; 、該当する場合は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;または検索を使用します 。 （同僚のために、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; を&lt;/a&gt;使用することはめったにありません。）</target>
        </trans-unit>
        <trans-unit id="d3e73cee41706cbf172168c939a770206031ae4a" translate="yes" xml:space="preserve">
          <source>Probably the &lt;code&gt;for(i = 0; i &amp;lt; array.length; i++)&lt;/code&gt; loop is not the best choice. Why? If you have this:</source>
          <target state="translated">おそらく &lt;code&gt;for(i = 0; i &amp;lt; array.length; i++)&lt;/code&gt; ループは最良の選択ではありません。 どうして？ これがあれば：</target>
        </trans-unit>
        <trans-unit id="5ca16fb6579631abba9ef29095127fc1724ade2e" translate="yes" xml:space="preserve">
          <source>Repeatedly inserting siblings into the DOM as a first child in order to retain their order is &lt;strong&gt;less efficient&lt;/strong&gt;.  (The browser would keep having to shift things right.)  To create DOM nodes efficiently and in order, just loop forwards and append as normal (and also use a &quot;document fragment&quot;).</source>
          <target state="translated">兄弟を最初の子としてDOMに繰り返し挿入して順序を維持するのは&lt;strong&gt;効率がよく&lt;/strong&gt;あり&lt;strong&gt;ません&lt;/strong&gt; 。 （ブラウザーは、物事を正しくシフトし続ける必要があります。）DOMノードを効率的かつ順番に作成するには、順方向にループし、通常どおりに追加します（「ドキュメントフラグメント」も使用します）。</target>
        </trans-unit>
        <trans-unit id="c3c204bcc11d0ba16e5b10935b855c9231c60df7" translate="yes" xml:space="preserve">
          <source>Results for Chrome. You can perform the test on your machine &lt;a href=&quot;https://jsbench.me/9uk4bj4svg&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">Chromeの結果。 &lt;a href=&quot;https://jsbench.me/9uk4bj4svg&quot;&gt;ここで&lt;/a&gt;マシンのテストを実行できます</target>
        </trans-unit>
        <trans-unit id="2632a58b332b7d1089e6d3db9b89fa34f55982ee" translate="yes" xml:space="preserve">
          <source>Results for Chrome. You can perform the test on your machine &lt;a href=&quot;https://jsbench.me/pxk4bicjru&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Chromeの結果。 &lt;a href=&quot;https://jsbench.me/pxk4bicjru&quot;&gt;ここで&lt;/a&gt;マシンのテストを実行できます 。</target>
        </trans-unit>
        <trans-unit id="2941ce8fc00301085c9d7ce71d82ff621ce0e501" translate="yes" xml:space="preserve">
          <source>Results for all tested browsers</source>
          <target state="translated">テストしたすべてのブラウザの結果</target>
        </trans-unit>
        <trans-unit id="3ab8b51db1affd18d3dd969199d9006feae51589" translate="yes" xml:space="preserve">
          <source>See #4, we'll have to see how iterators play out.</source>
          <target state="translated">4番を見て、イテレータがどのように再生されるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">参照</target>
        </trans-unit>
        <trans-unit id="b492c5ea4eeb39652fee30d40510ca39a54045aa" translate="yes" xml:space="preserve">
          <source>See the &lt;em&gt;Caveat for host-provided objects&lt;/em&gt; below. In particular, note that this will fail in IE8 and earlier, which don't let you use host-provided objects as &lt;code&gt;this&lt;/code&gt; like that.</source>
          <target state="translated">以下の&lt;em&gt;ホスト提供オブジェクトの警告を&lt;/em&gt;参照してください。 特に、これはIE8以前では失敗し、ホストが提供するオブジェクトを &lt;code&gt;this&lt;/code&gt; ように使用できないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="919b9d8e3baf041ad3035d3f106002059a32c5a7" translate="yes" xml:space="preserve">
          <source>Should I always use it?</source>
          <target state="translated">いつも使っていた方がいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">コードスニペットを表示</target>
        </trans-unit>
        <trans-unit id="90d4fe421bc14a9a7cd0cfb17b98bb87c323df29" translate="yes" xml:space="preserve">
          <source>Similarly, when modifying or removing &lt;strong&gt;nested&lt;/strong&gt; DOM elements, processing in reverse can &lt;strong&gt;circumvent errors&lt;/strong&gt;. For example, consider modifying the innerHTML of a parent node before handling its children.  By the time the child node is reached it will be detached from the DOM, having been replaced by a newly created child when the parent's innerHTML was written.</source>
          <target state="translated">同様に、 &lt;strong&gt;ネストされた&lt;/strong&gt; DOM要素を変更または削除&lt;strong&gt;する場合&lt;/strong&gt; 、逆の処理で&lt;strong&gt;エラー&lt;/strong&gt;を&lt;strong&gt;回避でき&lt;/strong&gt;ます。 たとえば、子を処理する前に、親ノードのinnerHTMLを変更することを検討してください。 子ノードに到達すると、子ノードはDOMから切り離され、親のinnerHTMLが書き込まれたときに新しく作成された子に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="9042b86e2d8972b544eebed08f73160765222f7f" translate="yes" xml:space="preserve">
          <source>So for instance, if we want to convert a &lt;code&gt;NodeList&lt;/code&gt; into a true array, we could do this:</source>
          <target state="translated">たとえば、 &lt;code&gt;NodeList&lt;/code&gt; を真の配列に変換する場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="1271c2d1e2ea0178abb1749d433619d8ba114b52" translate="yes" xml:space="preserve">
          <source>So for instance, if we want to convert a &lt;code&gt;NodeList&lt;/code&gt; into a true array, with spread syntax this becomes quite succinct:</source>
          <target state="translated">したがって、たとえば、 &lt;code&gt;NodeList&lt;/code&gt; を真の配列に変換する場合、spread構文を使用すると、これは非常に簡潔になります。</target>
        </trans-unit>
        <trans-unit id="d778f77d45108db7a7e4ef37756d652130403fa5" translate="yes" xml:space="preserve">
          <source>So on the final iteration, &lt;em&gt;i&lt;/em&gt; was previously &lt;strong&gt;1&lt;/strong&gt; and the &lt;code&gt;i--&lt;/code&gt; expression changes it to &lt;strong&gt;0&lt;/strong&gt; but actually yields &lt;strong&gt;1&lt;/strong&gt; (truthy), and so the condition passes.  On the next iteration &lt;code&gt;i--&lt;/code&gt; changes &lt;em&gt;i&lt;/em&gt; to &lt;strong&gt;-1&lt;/strong&gt; but yields &lt;strong&gt;0&lt;/strong&gt; (falsey), causing execution to immediately drop out of the bottom of the loop.</source>
          <target state="translated">したがって、最後の反復では、 &lt;em&gt;i&lt;/em&gt;は以前は&lt;strong&gt;1&lt;/strong&gt;でしたが、 &lt;code&gt;i--&lt;/code&gt; 式はそれを&lt;strong&gt;0に&lt;/strong&gt;変更し&lt;strong&gt;ます&lt;/strong&gt;が、実際には&lt;strong&gt;1&lt;/strong&gt; （truthy）を生成するため、条件は合格です。 次の反復で、 &lt;code&gt;i--&lt;/code&gt; は&lt;em&gt;i&lt;/em&gt;を&lt;strong&gt;-1に&lt;/strong&gt;変更しますが、結果は&lt;strong&gt;0&lt;/strong&gt; （偽）になるため、実行はすぐにループの最後から抜け出します。</target>
        </trans-unit>
        <trans-unit id="ec2c077f94e3ef98852872b7d08256a523f61745" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt;-style languages use &lt;code&gt;foreach&lt;/code&gt; to loop through enumerations. In JavaScript this is done with the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for..in&lt;/code&gt; loop structure&lt;/a&gt;:</source>
          <target state="translated">一部の&lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt;スタイル言語は &lt;code&gt;foreach&lt;/code&gt; を使用して列挙をループします。 JavaScriptでは、これは&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for..in&lt;/code&gt; ループ構造で&lt;/a&gt;行われます 。</target>
        </trans-unit>
        <trans-unit id="941bae0ecab27ddc205e29dd3a6d3b3bc8f9e89d" translate="yes" xml:space="preserve">
          <source>Some developers use the reverse for loop &lt;em&gt;by default&lt;/em&gt;, unless there is a good reason to loop forwards.</source>
          <target state="translated">一部の開発者は、順方向にループする正当な理由がない限り&lt;em&gt;、デフォルト&lt;/em&gt;で逆forループを使用&lt;em&gt;します&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="3163e5ac5c4f789da55694f27cb9f6c55a337dd5" translate="yes" xml:space="preserve">
          <source>Some people like to draw a little arrow in the reverse &lt;code&gt;for&lt;/code&gt; loop, and end with a wink:</source>
          <target state="translated">一部の人々は、逆の &lt;code&gt;for&lt;/code&gt; ループに小さな矢印を描き、ウィンクで終了することを好みます。</target>
        </trans-unit>
        <trans-unit id="b119d6cd5c4dc707a6167c6c075b24e4d7be734d" translate="yes" xml:space="preserve">
          <source>Sometimes the old ways are the best:</source>
          <target state="translated">昔のやり方が一番いいこともあります。</target>
        </trans-unit>
        <trans-unit id="59f86f5e3b9995bc329f5d4bc79c9d16c81b5fba" translate="yes" xml:space="preserve">
          <source>Sometimes, you might want to use an iterator &lt;em&gt;explicitly&lt;/em&gt;. You can do that, too, although it's a lot clunkier than &lt;code&gt;for-of&lt;/code&gt;. It looks like this:</source>
          <target state="translated">イテレータを&lt;em&gt;明示的&lt;/em&gt;に使用したい場合があります。 &lt;code&gt;for-of&lt;/code&gt; よりもはるかに不格好ですが、あなたもそれを行うことができます。 次のようになります。</target>
        </trans-unit>
        <trans-unit id="c7657c048f2c02f83c5e4cef8d5cbd16b976ff8a" translate="yes" xml:space="preserve">
          <source>Suppose you wanted to use &lt;code&gt;forEach&lt;/code&gt; on a &lt;code&gt;Node&lt;/code&gt;'s &lt;code&gt;childNodes&lt;/code&gt; property. You'd do this:</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; の &lt;code&gt;childNodes&lt;/code&gt; プロパティで &lt;code&gt;forEach&lt;/code&gt; を使用したいとします。 あなたはこれをするでしょう：</target>
        </trans-unit>
        <trans-unit id="2870c360b6a5c3b4d815964ddecea3817c257c4c" translate="yes" xml:space="preserve">
          <source>That the key is all decimal digits (e.g., normal string form, not scientific notation), and</source>
          <target state="translated">キーがすべて10進数であること(例えば、通常の文字列形式で、科学的表記ではないこと)と</target>
        </trans-unit>
        <trans-unit id="dce363e4d7896cca416fa7202976d0faa93b7cb7" translate="yes" xml:space="preserve">
          <source>That the key's value when coerced to a number is &amp;lt;= 2^32 - 2 (which is 4,294,967,294). Where does that number come from? It's part of the definition of an array index &lt;a href=&quot;https://tc39.github.io/ecma262/#array-index&quot;&gt;in the specification&lt;/a&gt;. Other numbers (non-integers, negative numbers, numbers greater than 2^32 - 2) are not array indexes. The reason it's 2^32 - &lt;strong&gt;2&lt;/strong&gt; is that that makes the greatest index value one lower than 2^32 - &lt;strong&gt;1&lt;/strong&gt;, which is the maximum value an array's &lt;code&gt;length&lt;/code&gt; can have. (E.g., an array's length fits in a 32-bit unsigned integer.) &lt;em&gt;(Props to RobG for pointing out in a comment &lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;on my blog post&lt;/a&gt; that my previous test wasn't quite right.)&lt;/em&gt;</source>
          <target state="translated">数値に強制変換された場合のキーの値は、&amp;lt;= 2 ^ 32-2（4,294,967,294）です。 その数はどこから来たのですか？ これ&lt;a href=&quot;https://tc39.github.io/ecma262/#array-index&quot;&gt;は、仕様の&lt;/a&gt;配列インデックスの定義の一部です。 他の数値（非整数、負の数値、2 ^ 32-2より大きい数値）は配列インデックスではありません。 2 ^ 32-2である理由は、最大のインデックス値が2 ^ 32-1よりも1つ低くなるためです。これは、配列の &lt;code&gt;length&lt;/code&gt; が取り得る最大値です。 （たとえば、配列の長さが32ビットの符号なし整数に収まります。） &lt;em&gt;（ &lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;私のブログ投稿の&lt;/a&gt;コメントで、前回のテストが正しくなかったことを指摘したRobGへの賛成です。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a83ef01e292828af9f95ea6fd3cb1ad1a7e9b181" translate="yes" xml:space="preserve">
          <source>That the object has its &lt;em&gt;own&lt;/em&gt; property by that name (not one it inherits from its prototype), and</source>
          <target state="translated">オブジェクトがその名前で&lt;em&gt;独自の&lt;/em&gt;プロパティを持って&lt;em&gt;いる&lt;/em&gt; （プロトタイプから継承したものではない）。</target>
        </trans-unit>
        <trans-unit id="410be7b6d8de783ae1460eb1fb1c418447a833c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i--&lt;/code&gt; like solutions where the loop starts from the last array element (&lt;strong&gt;Ac, Bc&lt;/strong&gt;) are usually ~30% slower than forward solutions - probably the reason is the way of &lt;a href=&quot;https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus&quot;&gt;CPU memory cache working&lt;/a&gt; - forward memory reading is more optimal for CPU caching). &lt;strong&gt;Is recommended to NOT USE such solutions.&lt;/strong&gt;</source>
          <target state="translated">ループが最後の配列要素（ &lt;strong&gt;Ac、Bc&lt;/strong&gt; ）から始まる &lt;code&gt;i--&lt;/code&gt; ようなソリューションは、通常、フォワードソリューションよりも約30％遅くなります-おそらくその理由は、 &lt;a href=&quot;https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus&quot;&gt;CPUメモリキャッシュ&lt;/a&gt;が機能する方法にあります -フォワードメモリの読み取りは、CPUにとってより最適ですキャッシング）。 &lt;strong&gt;このようなソリューションを使用しないことをお勧めします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50fab3bc0666321dff613699d5e26402e68c7f7f" translate="yes" xml:space="preserve">
          <source>The benefit for this: You have the reference already in the first like that won't need to be declared later with another line. It is handy when looping trough the object array.</source>
          <target state="translated">このための利点。最初のように既に参照を持っているので、後で別の行で宣言する必要はありません。これは、オブジェクトの配列をループするときに便利です。</target>
        </trans-unit>
        <trans-unit id="8e2dba3330af35406fa3d1420af1173d75e136d6" translate="yes" xml:space="preserve">
          <source>The braces (&lt;code&gt;{}&lt;/code&gt;) can be omitted when there is only one command (e.g. in the example above).</source>
          <target state="translated">中括弧（ &lt;code&gt;{}&lt;/code&gt; ）は、コマンドが1つしかない場合は省略できます（上記の例など）。</target>
        </trans-unit>
        <trans-unit id="c098c9f1a959378486a97457d4178958264ad2ec" translate="yes" xml:space="preserve">
          <source>The following examples will use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/a&gt; statement and the &lt;a href=&quot;https://developer.mozilla.org/ro/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;.forEach&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">次の例では、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/a&gt;ステートメントと&lt;a href=&quot;https://developer.mozilla.org/ro/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;.forEach&lt;/code&gt; &lt;/a&gt;メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="3a00e7fa39a3bdf93692adc3a257b29ca0ee5020" translate="yes" xml:space="preserve">
          <source>The iterator is an object matching the Iterator definition in the specification. Its &lt;code&gt;next&lt;/code&gt; method returns a new &lt;em&gt;result object&lt;/em&gt; each time you call it. The result object has a property, &lt;code&gt;done&lt;/code&gt;, telling us whether it's done, and a property &lt;code&gt;value&lt;/code&gt; with the value for that iteration. (&lt;code&gt;done&lt;/code&gt; is optional if it would be &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is optional if it would be &lt;code&gt;undefined&lt;/code&gt;.)</source>
          <target state="translated">イテレータは、仕様のイテレータ定義に一致するオブジェクトです。 その &lt;code&gt;next&lt;/code&gt; メソッドは、呼び出すたびに新しい&lt;em&gt;結果オブジェクトを&lt;/em&gt;返します。 結果オブジェクトには、 &lt;code&gt;done&lt;/code&gt; かどうかを示すプロパティdoneと、その反復の &lt;code&gt;value&lt;/code&gt; を含むプロパティ値があります。 （ &lt;code&gt;false&lt;/code&gt; の場合、 &lt;code&gt;done&lt;/code&gt; はオプションです。 &lt;code&gt;undefined&lt;/code&gt; 場合、 &lt;code&gt;value&lt;/code&gt; はオプションです。）</target>
        </trans-unit>
        <trans-unit id="fb536e6fcbd5fa797f6c5702a97e23e4c75f5773" translate="yes" xml:space="preserve">
          <source>The lambda syntax doesn't usually work in Internet&amp;nbsp;Explorer&amp;nbsp;10  or below.</source>
          <target state="translated">ラムダ構文は、通常、Internet Explorer 10以前では機能しません。</target>
        </trans-unit>
        <trans-unit id="866f22286c83f5903a913086e3b75aeeb2603c3c" translate="yes" xml:space="preserve">
          <source>The loop will stop iterating when the condition &lt;code&gt;i--&lt;/code&gt; evaluates to a falsey value (when it yields 0).</source>
          <target state="translated">ループは、条件 &lt;code&gt;i--&lt;/code&gt; が誤った値に評価されると（反復が0になると）、反復を停止します。</target>
        </trans-unit>
        <trans-unit id="80992ad230888519239affffa93744a318eb6afc" translate="yes" xml:space="preserve">
          <source>The loops with array length cached in &lt;code&gt;n&lt;/code&gt; (&lt;strong&gt;Ab, Bb, Be&lt;/strong&gt;) are sometimes faster, sometimes not. Probably compilers automatically detect this situation and introduce caching. The speed differences between the cached and no-cached versions (&lt;strong&gt;Aa, Ba, Bd&lt;/strong&gt;) are about ~1%, so it looks like introduce &lt;code&gt;n&lt;/code&gt; is a &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;micro-optimisation&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">配列長が &lt;code&gt;n&lt;/code&gt; にキャッシュされたループ（ &lt;strong&gt;Ab、Bb、Be&lt;/strong&gt; ）は、高速な場合とそうでない場合があります。 おそらくコンパイラはこの状況を自動的に検出し、キャッシングを導入します。 キャッシュされたバージョンとキャッシュされていないバージョン（ &lt;strong&gt;Aa、Ba、Bd&lt;/strong&gt; ）の速度の差は約1％であるため、introduce &lt;code&gt;n&lt;/code&gt; は&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;マイクロ最適化のよう&lt;/a&gt;&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="8e52b46122ec0efd9e5bc3d7eec0fac027826ce2" translate="yes" xml:space="preserve">
          <source>The meaning of &lt;code&gt;value&lt;/code&gt; varies depending on the iterator; arrays support (at least) three functions that return iterators:</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; の意味はイテレータによって異なります。 配列は、反復子を返す（少なくとも）3つの関数をサポートします。</target>
        </trans-unit>
        <trans-unit id="6f4344e9b0061937311866ba4501ba441df9956f" translate="yes" xml:space="preserve">
          <source>The method will call from &lt;code&gt;array[0]&lt;/code&gt; to &lt;code&gt;array[2]&lt;/code&gt;. First, this will first reference variables you don't even have, second you would not have the variables in the array, and third this will make the code bolder. Look here, it's what I use:</source>
          <target state="translated">このメソッドは &lt;code&gt;array[0]&lt;/code&gt; から &lt;code&gt;array[2]&lt;/code&gt; を呼び出します。 最初に、これは最初にあなたも持っていない変数を参照し、次に配列に変数を持たないでしょう、そして3番目にこれはコードを太字にします。 ここを見てください、それは私が使用するものです：</target>
        </trans-unit>
        <trans-unit id="74aa97507801ce4d05b427601775a33b918e48b3" translate="yes" xml:space="preserve">
          <source>The only real use cases for &lt;code&gt;for-in&lt;/code&gt; on an array are:</source>
          <target state="translated">配列の &lt;code&gt;for-in&lt;/code&gt; の実際の使用例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="752c45d9e3f0bb5c04149934ef14e0e9e95a2014" translate="yes" xml:space="preserve">
          <source>The other solutions, like &lt;code&gt;for-of&lt;/code&gt; (&lt;strong&gt;Ad&lt;/strong&gt;), all in group &lt;strong&gt;C.&lt;/strong&gt;... are usually 2 - 10 (and more) times slower than &lt;strong&gt;Aa&lt;/strong&gt;, but for small arrays it is ok to use it - for the sake of increase code clarity.</source>
          <target state="translated">グループ&lt;strong&gt;Cの&lt;/strong&gt; &lt;code&gt;for-of&lt;/code&gt; （ &lt;strong&gt;Ad&lt;/strong&gt; ）のような他のソリューションは、通常、 &lt;strong&gt;Aa&lt;/strong&gt;よりも2〜10（およびそれ以上）遅くなりますが、小さな配列の場合、それを使用しても問題ありません&lt;strong&gt;。&lt;/strong&gt;コードの明快さ。</target>
        </trans-unit>
        <trans-unit id="e6e6a03f8cd96d0cc668913bda563a8e9ba99a69" translate="yes" xml:space="preserve">
          <source>The reverse loop is &lt;strong&gt;confusing&lt;/strong&gt; to junior developers.  (You may consider that an advantage, depending on your outlook.)</source>
          <target state="translated">リバースループは、ジュニア開発者を&lt;strong&gt;混乱&lt;/strong&gt;させます。 （あなたの見通し次第では、それが有利だと考えるかもしれません。）</target>
        </trans-unit>
        <trans-unit id="f1e91d86c7df92b8dd9b5472ca55e71a9d8cd69a" translate="yes" xml:space="preserve">
          <source>The standard way to iterate an array in &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; is a vanilla &lt;code&gt;for&lt;/code&gt;-loop:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;で配列を反復する標準的な方法は、単純な &lt;code&gt;for&lt;/code&gt; ループです。</target>
        </trans-unit>
        <trans-unit id="f83ea1369d58b6fdc00c70cea4bb0aa9a818aa64" translate="yes" xml:space="preserve">
          <source>The trick is that unlike &lt;code&gt;--i&lt;/code&gt;, the trailing &lt;code&gt;i--&lt;/code&gt; operator decrements &lt;code&gt;i&lt;/code&gt; but yields the value &lt;strong&gt;&lt;em&gt;before&lt;/em&gt;&lt;/strong&gt; the decrement.  Your console can demonstrate this:</source>
          <target state="translated">トリックは、-- &lt;code&gt;i&lt;/code&gt; とは異なり、末尾の &lt;code&gt;i--&lt;/code&gt; 演算子はiをデクリメントしますが、デクリメントの&lt;strong&gt;&lt;em&gt;前&lt;/em&gt;&lt;/strong&gt;に値を生成します。 コンソールはこれを示すことができます：</target>
        </trans-unit>
        <trans-unit id="608bdf441fc2978c8b5bcb888401c074fd430bc1" translate="yes" xml:space="preserve">
          <source>The various functions on &lt;code&gt;Array.prototype&lt;/code&gt; are &quot;intentionally generic&quot; and can usually be used on array-like objects via &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.call&quot;&gt;&lt;code&gt;Function#call&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.apply&quot;&gt;&lt;code&gt;Function#apply&lt;/code&gt;&lt;/a&gt;. (See the &lt;em&gt;Caveat for host-provided objects&lt;/em&gt; at the end of this answer, but it's a rare issue.)</source>
          <target state="translated">&lt;code&gt;Array.prototype&lt;/code&gt; のさまざまな関数は「意図的に汎用的」であり、通常は&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.call&quot;&gt; &lt;code&gt;Function#call&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.apply&quot;&gt; &lt;code&gt;Function#apply&lt;/code&gt; を&lt;/a&gt;介して配列のようなオブジェクトで使用できます 。 （この回答の最後にある&lt;em&gt;ホスト提供オブジェクトの警告を&lt;/em&gt;参照してください。ただし、これはまれな問題です。）</target>
        </trans-unit>
        <trans-unit id="5b74a123ca6113288c61c01f944435ca7d90b342" translate="yes" xml:space="preserve">
          <source>Then when you do see the reverse for loop in your code, that is a hint that it is reversed for a good reason (perhaps one of the reasons described above).  And seeing a traditional forward for loop may indicate that shifting can take place.</source>
          <target state="translated">そして、あなたのコードで逆のforループを見たとき、それはそれなりの理由(おそらく上記の理由の1つ)で逆になっていることを示唆しています。そして、伝統的な順方向のforループを見ることは、シフトが行われる可能性があることを示しているかもしれません。</target>
        </trans-unit>
        <trans-unit id="d150400a4ca68f73e954c6ea93f05e7de141942b" translate="yes" xml:space="preserve">
          <source>There are &lt;strong&gt;a few ways&lt;/strong&gt; to loop through an array in JavaScript, as below:</source>
          <target state="translated">JavaScriptで配列をループするには、以下のように&lt;strong&gt;いくつかの方法&lt;/strong&gt;があります。</target>
        </trans-unit>
        <trans-unit id="0b51f25dbb23a6ed31b4ccfd1a12b3fdb1871919" translate="yes" xml:space="preserve">
          <source>There are different ways to use the forEach loop of angular. The simplest and probably most used is</source>
          <target state="translated">angularのforEachループを使う方法はいろいろあります。最もシンプルで、おそらく最も使われているのは</target>
        </trans-unit>
        <trans-unit id="43e3466064c6ca5060bfe7c0d8fe1a2296506e5e" translate="yes" xml:space="preserve">
          <source>There are three implementations of &lt;code&gt;foreach&lt;/code&gt; in &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; as follows.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQueryには&lt;/a&gt; 、次の3つの &lt;code&gt;foreach&lt;/code&gt; の実装があります。</target>
        </trans-unit>
        <trans-unit id="d54c80c3143769b1187df474f58937273f32b476" translate="yes" xml:space="preserve">
          <source>There is a catch. &lt;code&gt;for..in&lt;/code&gt; will loop through each of the object's enumerable members, and the members on its prototype. To avoid reading values that are inherited through the object's prototype, simply check if the property belongs to the object:</source>
          <target state="translated">落とし穴があります。 &lt;code&gt;for..in&lt;/code&gt; は、オブジェクトの列挙可能な各メンバーと、そのプロトタイプのメンバーをループします。 オブジェクトのプロトタイプを通じて継承される値を読み取らないようにするには、プロパティがオブジェクトに属しているかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="93b99dbbcfcfef18eac3c5a89b5362f4491b1f4f" translate="yes" xml:space="preserve">
          <source>There is a debate about whether &lt;code&gt;for..of&lt;/code&gt; or &lt;code&gt;forEach()&lt;/code&gt; are preferable:</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; または &lt;code&gt;forEach()&lt;/code&gt; のどちらが望ましいかについては議論があります：</target>
        </trans-unit>
        <trans-unit id="5162299771e3535e699131f35c2cf628ce13a63a" translate="yes" xml:space="preserve">
          <source>There isn't any &lt;code&gt;for each&lt;/code&gt; loop in native &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;. You can either use libraries to get this functionality (I recommend &lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt;), use a simple &lt;code&gt;for&lt;/code&gt; in loop.</source>
          <target state="translated">ネイティブ&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScriptに&lt;/a&gt;は &lt;code&gt;for each&lt;/code&gt; ループはありません。 ライブラリを使用してこの機能を取得するか（私は&lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt;をお勧めします）、単純な &lt;code&gt;for&lt;/code&gt; ループを使用できます。</target>
        </trans-unit>
        <trans-unit id="55d52a0b513a03e6f341ec331ed111d51c87156a" translate="yes" xml:space="preserve">
          <source>There's no inbuilt ability to break in &lt;code&gt;forEach&lt;/code&gt;. To interrupt execution use the &lt;code&gt;Array#some&lt;/code&gt; like below:</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; に割り込む組み込みの機能はありません。 実行を中断するには、以下のような &lt;code&gt;Array#some&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="24112cc482e8cc4c078f7faf03d3a6612e321185" translate="yes" xml:space="preserve">
          <source>This is an iterator for NON-sparse list where the index starts at 0, which is the typical scenario when dealing with document.getElementsByTagName or document.querySelectorAll)</source>
          <target state="translated">これは、document.getElementsByTagNameやdocument.querySelectorAllを扱う際の典型的なシナリオである、インデックスが0から始まるNON-sparseリストのためのイテレータです。)</target>
        </trans-unit>
        <trans-unit id="b109618ad05adb05d3d283e04dadad94a3074a14" translate="yes" xml:space="preserve">
          <source>This will break whenever the reference is false - falsey (undefined, etc.). It can be used as an advantage though. However, it would make it a little bit harder to read. And also depending on the browser it can be &quot;not&quot; optimized to work faster than the original one.</source>
          <target state="translated">これは、参照が false-falsey (未定義など)である場合にブレークします。でもメリットとしては使えます。ただし、少し読みづらくなります。また、ブラウザによっては、元のものよりも高速に動作するように最適化されていないこともあります。</target>
        </trans-unit>
        <trans-unit id="cb8a12948118a05c21c4646e9b69844b0d2ce858" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;some&lt;/code&gt; returns true as soon as any of the callbacks, executed in array order, returns true, short-circuiting the execution of the rest. 
&lt;a href=&quot;https://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break&quot;&gt;Original Answer&lt;/a&gt;
see Array prototype for &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.17&quot;&gt;some&lt;/a&gt;</source>
          <target state="translated">これは、配列順に実行されたコールバックのいずれ &lt;code&gt;some&lt;/code&gt; がtrueを返し、残りの実行を短絡するとすぐにtrueを返すため、機能します。 &lt;a href=&quot;https://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break&quot;&gt;元の回答&lt;/a&gt;は、 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.17&quot;&gt;一部の&lt;/a&gt;配列プロトタイプを参照してください</target>
        </trans-unit>
        <trans-unit id="4c334db464368d273947e54cf77b80331da64b0f" translate="yes" xml:space="preserve">
          <source>Though, you don't have to do that, you can simply do the following and it's equivalent to the previous example:</source>
          <target state="translated">とはいえ、そんなことをしなくても、以下のようにすればいいだけで、先ほどの例と同じです。</target>
        </trans-unit>
        <trans-unit id="257fcf65e941aa6ba5c5e06169df94cf19c12a87" translate="yes" xml:space="preserve">
          <source>Today (2019-12-18) I perform test on my &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra), on Chrome v 79.0, Safari v13.0.4 and Firefox v71.0 (64 bit) - conclusions about optimisation (and &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;micro-optimisation&lt;/a&gt;&lt;/em&gt; which usually is not worth to introduce it to code because the benefit is small, but code complexity grows).</source>
          <target state="translated">今日（2019-12-18） &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; （High Sierra）、Chrome v 79.0、Safari v13.0.4およびFirefox v71.0（64ビット）でテストを実行しました-最適化（および&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;マイクロ&lt;/a&gt;&lt;/em&gt;最適化）に関する結論メリットは小さいため、通常はコードに導入する価値はありませんが、コードは複雑になります）。</target>
        </trans-unit>
        <trans-unit id="54b58f77bdc50c962ebcb489df02102329ea9473" translate="yes" xml:space="preserve">
          <source>Transform your regular array to iterator using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values&quot;&gt;&lt;code&gt;values()&lt;/code&gt;&lt;/a&gt; method like this:</source>
          <target state="translated">次のように&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values&quot;&gt; &lt;code&gt;values()&lt;/code&gt; &lt;/a&gt;メソッドを使用して、通常の配列をイテレータに変換します。</target>
        </trans-unit>
        <trans-unit id="286e721a1890a58c29a5c4014f7f586f56cc077f" translate="yes" xml:space="preserve">
          <source>Trivia</source>
          <target state="translated">Trivia</target>
        </trans-unit>
        <trans-unit id="f2407f77f30d5cce56de1bb34c4429f7541eb397" translate="yes" xml:space="preserve">
          <source>Under the covers, that gets an &lt;em&gt;iterator&lt;/em&gt; from the array and loops through it, getting the values from it. This doesn't have the issue that using &lt;code&gt;for-in&lt;/code&gt; has, because it uses an iterator defined by the object (the array), and arrays define that their iterators iterate through their &lt;em&gt;entries&lt;/em&gt; (not their properties). Unlike &lt;code&gt;for-in&lt;/code&gt; in ES5, the order in which the entries are visited is the numeric order of their indexes.</source>
          <target state="translated">カバーの下で、配列から&lt;em&gt;イテレータ&lt;/em&gt;を取得してループし、そこから値を取得します。 これは、オブジェクト（配列）で定義されたイテレーターを使用し、配列はイテレーターが（プロパティではなく） &lt;em&gt;エントリーを&lt;/em&gt;反復することを定義しているため、 &lt;code&gt;for-in&lt;/code&gt; を使用する場合の問題はありません。 ES5の &lt;code&gt;for-in&lt;/code&gt; とは異なり、エントリにアクセスする順序は、インデックスの番号順です。</target>
        </trans-unit>
        <trans-unit id="51d0fcbbedb44b967fe1846371188cf04d2c2452" translate="yes" xml:space="preserve">
          <source>Unless you're supporting obsolete browsers like IE8 (which NetApps shows at just over 4% market share as of this writing in September&amp;nbsp;2016), you can happily use &lt;code&gt;forEach&lt;/code&gt; in a general-purpose web page without a shim. If you do need to support obsolete browsers, shimming/polyfilling &lt;code&gt;forEach&lt;/code&gt; is easily done (search for &quot;es5 shim&quot; for several options).</source>
          <target state="translated">IE8などの旧式のブラウザー（2016年9月の執筆時点ではNetAppsが4％を超える市場シェアを示している）をサポートしているのでない限り、shimなしで汎用のWebページで &lt;code&gt;forEach&lt;/code&gt; を喜んで使用できます。 廃止されたブラウザをサポートする必要がある場合、 &lt;code&gt;forEach&lt;/code&gt; のシミング/ポリフィリングは簡単に実行できます（いくつかのオプションについては、「es5 shim」を検索してください）。</target>
        </trans-unit>
        <trans-unit id="431a3b9a552efc88858519dfb72bdcfb495d5966" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for-in&lt;/code&gt;&lt;em&gt;correctly&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; を &lt;em&gt;正しく&lt;/em&gt;使用する</target>
        </trans-unit>
        <trans-unit id="9e0c11cbf7ef3c72db6fc4b3fe5d45b56bc12d21" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for-of&lt;/code&gt; (use an iterator implicitly) (ES2015+)</source>
          <target state="translated">&lt;code&gt;for-of&lt;/code&gt; を使用（暗黙的にイテレーターを使用）（ES2015 +）</target>
        </trans-unit>
        <trans-unit id="734ae2379fe23a7a3bc38483ac1b653b9d9051b3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;forEach&lt;/code&gt; and related (ES5+)</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; および関連（ES5 +）を使用</target>
        </trans-unit>
        <trans-unit id="2c08b442b76b66cca66b71d3f1ff947bdd36a587" translate="yes" xml:space="preserve">
          <source>Use a simple &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">単純な &lt;code&gt;for&lt;/code&gt; ループを使用する</target>
        </trans-unit>
        <trans-unit id="1ea53b376965f0df377f080711210f0ab1972b82" translate="yes" xml:space="preserve">
          <source>Use an iterator explicitly (ES2015+)</source>
          <target state="translated">イテレータを明示的に使用する(ES2015+)</target>
        </trans-unit>
        <trans-unit id="34c4927f746ab01e6fc5a9bc93966e26f8b7d962" translate="yes" xml:space="preserve">
          <source>Use any of the options above for arrays</source>
          <target state="translated">配列には上記のオプションのいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="e906c3cdb43d16bd2a2f35eccf263373e93c2a7f" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;slice&lt;/code&gt; method of arrays, which like the other methods mentioned above is &quot;intentionally generic&quot; and so can be used with array-like objects, like this:</source>
          <target state="translated">配列の &lt;code&gt;slice&lt;/code&gt; メソッドを使用できます。これは、上記の他のメソッドと同様に「意図的にジェネリック」であるため、次のように配列のようなオブジェクトで使用できます。</target>
        </trans-unit>
        <trans-unit id="ef4d47774a48af8c2dc4198f272524f303720ef0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;of&lt;/code&gt; avoids the oddities associated with &lt;code&gt;in&lt;/code&gt; and makes it work like the &lt;code&gt;for&lt;/code&gt; loop of any other language, and &lt;code&gt;let&lt;/code&gt; binds &lt;code&gt;i&lt;/code&gt; within the loop as opposed to within the function.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; に関連する奇妙な点 &lt;code&gt;of&lt;/code&gt; 避け、他の言語の &lt;code&gt;for&lt;/code&gt; ループのように機能させ、関数内ではなくループ内で &lt;code&gt;i&lt;/code&gt; をバインド &lt;code&gt;let&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="941d4e5eb1ee2fa812450abac2b4faed7e49a69d" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;theArray&lt;/code&gt; is my array, but this seems to be incorrect.</source>
          <target state="translated">&lt;code&gt;theArray&lt;/code&gt; は私の配列ですが、これは正しくないようです。</target>
        </trans-unit>
        <trans-unit id="08b975222d1b83cf89b60a81d765397d2dc1159f" translate="yes" xml:space="preserve">
          <source>You access the current item by calling the iterator&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; method. The next method will return the &lt;strong&gt;&lt;code&gt;value&lt;/code&gt;&lt;/strong&gt; of the current item and a &lt;strong&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/strong&gt; to indicate when you have reached the end of the collection. The following is an example of creating an iterator from an array.</source>
          <target state="translated">イテレータの &lt;code&gt;next&lt;/code&gt; メソッドを呼び出すことにより、現在のアイテムにアクセスします。 次のメソッドは、現在のアイテムの&lt;strong&gt; &lt;code&gt;value&lt;/code&gt; &lt;/strong&gt;と、コレクションの最後に達したことを示す&lt;strong&gt; &lt;code&gt;boolean&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;値&lt;/strong&gt;を返します。 以下は、配列からイテレータを作成する例です。</target>
        </trans-unit>
        <trans-unit id="faf0a839383e9ca040f86c77bb8d78628ddab12a" translate="yes" xml:space="preserve">
          <source>You can also iterate over an array like this:</source>
          <target state="translated">このように配列を反復処理することもできます。</target>
        </trans-unit>
        <trans-unit id="a99d0a423bd91c6ab11d1bbc2ecccf23c5be4af8" translate="yes" xml:space="preserve">
          <source>You can also transform your regular &lt;code&gt;array&lt;/code&gt; to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">次のように、通常の &lt;code&gt;array&lt;/code&gt; を&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/a&gt;変換することもできます。</target>
        </trans-unit>
        <trans-unit id="08ceb3749d20fa27c455e7e1a7300f32a149c3c7" translate="yes" xml:space="preserve">
          <source>You can also transform your regular array to iterator using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt; &lt;code&gt;Symbol.iterator&lt;/code&gt; &lt;/a&gt;ようにSymbol.iteratorを使用して、通常の配列をイテレータに変換することもできます。</target>
        </trans-unit>
        <trans-unit id="7f6f076641450693589f578d046aeeeb04ad8c10" translate="yes" xml:space="preserve">
          <source>You can call forEach like this:</source>
          <target state="translated">このようにforEachを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="8704a38dea0e6f3deb1af2a2e5fcf2aa68370fc9" translate="yes" xml:space="preserve">
          <source>You can get some performance optimisations by caching &lt;code&gt;myArray.length&lt;/code&gt; or iterating over it backwards.</source>
          <target state="translated">&lt;code&gt;myArray.length&lt;/code&gt; をキャッシュするか、逆方向に反復することにより、パフォーマンスを最適化できます。</target>
        </trans-unit>
        <trans-unit id="7623d5152acc3867d2222ce3eedc5c77ffbac5a8" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;iteration protocol&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iteration protocol&lt;/code&gt; 詳細については、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;こちらをご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">使えます。</target>
        </trans-unit>
        <trans-unit id="7d5badb0562b87f2a9430ec38445cdf3e13d52c2" translate="yes" xml:space="preserve">
          <source>You do not need to declare a temporary &lt;code&gt;len&lt;/code&gt; variable, or compare against &lt;code&gt;array.length&lt;/code&gt; on each iteration, either of which might be a minute optimisation.</source>
          <target state="translated">一時的な &lt;code&gt;len&lt;/code&gt; 変数を宣言し &lt;code&gt;array.length&lt;/code&gt; 、各反復でarray.lengthと比較したりする必要はありません。どちらも1分間の最適化です。</target>
        </trans-unit>
        <trans-unit id="021884629c616bb0e00f4dedc9401d5eeaae6b37" translate="yes" xml:space="preserve">
          <source>You have three options in &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript&amp;nbsp;5&lt;/a&gt; (&quot;ES5&quot;), the version most broadly supported at the moment, and two more added in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript&amp;nbsp;2015&lt;/a&gt; (&quot;ES2015&quot;, &quot;ES6&quot;):</source>
          <target state="translated">現在最も広くサポートされているバージョンである&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript 5&lt;/a&gt; （ &quot;ES5&quot;）には3つのオプションがあり、 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015&lt;/a&gt; （ &quot;ES2015&quot;、 &quot;ES6&quot;）にはさらに2つのオプションが追加されています。</target>
        </trans-unit>
        <trans-unit id="5baba5e2792c7b4a97eeca7d33b55e99ec8dd7bb" translate="yes" xml:space="preserve">
          <source>You will notice that &lt;code&gt;i--&lt;/code&gt; is the middle clause (where we usually see a comparison) and the last clause is empty (where we usually see &lt;code&gt;i++&lt;/code&gt;).  That means that &lt;code&gt;i--&lt;/code&gt; is also used as the &lt;em&gt;condition&lt;/em&gt; for continuation.  Crucially, it is executed and checked &lt;em&gt;before&lt;/em&gt; each iteration.</source>
          <target state="translated">&lt;code&gt;i--&lt;/code&gt; が中央の句（通常は比較が表示される）であり、最後の句が空（通常は &lt;code&gt;i++&lt;/code&gt; ）であることがわかります。 つまり、継続の&lt;em&gt;条件&lt;/em&gt;として &lt;code&gt;i--&lt;/code&gt; も使用されます。 重要なのは、各反復の&lt;em&gt;前に&lt;/em&gt;実行およびチェックされることです。</target>
        </trans-unit>
        <trans-unit id="1b92ca772f4a547ebbe1cecec130f971e1c7c39f" translate="yes" xml:space="preserve">
          <source>You wouldn't do that in inline code, of course. You'd write a utility function. Perhaps:</source>
          <target state="translated">もちろん、インラインコードではできません。あなたはユーティリティ関数を書くでしょう。そうかもしれません。</target>
        </trans-unit>
        <trans-unit id="5b72435b1a6e0292938c5e939f2b0c7c3502eb4e" translate="yes" xml:space="preserve">
          <source>You'll get people telling you to use &lt;code&gt;for-in&lt;/code&gt;, but &lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;that's not what &lt;code&gt;for-in&lt;/code&gt; is for&lt;/a&gt;. &lt;code&gt;for-in&lt;/code&gt; loops through the &lt;em&gt;enumerable properties of an object&lt;/em&gt;, not the indexes of an array. &lt;strong&gt;The order is not guaranteed&lt;/strong&gt;, not even in ES2015 (ES6). ES2015+ does define an order to object properties (via &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys&quot;&gt;&lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-enumerate&quot;&gt;&lt;code&gt;[[Enumerate]]&lt;/code&gt;&lt;/a&gt;, and things that use them like &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getownpropertynames&quot;&gt;&lt;code&gt;Object.getOwnPropertyKeys&lt;/code&gt;&lt;/a&gt;), but it &lt;strong&gt;does not&lt;/strong&gt; define that &lt;code&gt;for-in&lt;/code&gt; will follow that order. (Details in &lt;a href=&quot;https://stackoverflow.com/a/30919039/157247&quot;&gt;this other answer&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; を使うように言われるでしょうが、それが&lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt; &lt;code&gt;for-in&lt;/code&gt; の目的ではありません&lt;/a&gt; 。 &lt;code&gt;for-in&lt;/code&gt; は、配列のインデックスではなく、 &lt;em&gt;オブジェクトの列挙可能なプロパティを&lt;/em&gt;ループします。 ES2015（ES6）であっても、 &lt;strong&gt;順序は保証され&lt;/strong&gt;ません。 ES2015 +は（ &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys&quot;&gt; &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-enumerate&quot;&gt; &lt;code&gt;[[Enumerate]]&lt;/code&gt; &lt;/a&gt; 、および&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getownpropertynames&quot;&gt; &lt;code&gt;Object.getOwnPropertyKeys&lt;/code&gt; の&lt;/a&gt;ようにそれらを使用するものを介して）オブジェクトプロパティの順序を定義しますが、 &lt;code&gt;for-in&lt;/code&gt; がその順序に従うこと&lt;strong&gt;は&lt;/strong&gt;定義して&lt;strong&gt;いません&lt;/strong&gt; 。 （ &lt;a href=&quot;https://stackoverflow.com/a/30919039/157247&quot;&gt;この他の回答の&lt;/a&gt;詳細。）</target>
        </trans-unit>
        <trans-unit id="589b6a96f50575d676fcf038d8105e7b1699be4a" translate="yes" xml:space="preserve">
          <source>You're using non-element properties and you want to include them in the loop</source>
          <target state="translated">要素ではないプロパティを使用していて、それをループに含めたい場合</target>
        </trans-unit>
        <trans-unit id="10d7cc4a29eba4f6a5a3ca2db2a762f5a236cc71" translate="yes" xml:space="preserve">
          <source>Your best bets are usually</source>
          <target state="translated">あなたのベストベットは通常</target>
        </trans-unit>
        <trans-unit id="617846806ec9245ca6b1c7aac0723989e8f9ebee" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;for-of&lt;/code&gt; loop (ES2015+ only),</source>
          <target state="translated">&lt;code&gt;for-of&lt;/code&gt; ループ（ES2015 +のみ）、</target>
        </trans-unit>
        <trans-unit id="6b50530706e59258d411002d89ae4b283301aabf" translate="yes" xml:space="preserve">
          <source>a simple old-fashioned &lt;code&gt;for&lt;/code&gt; loop,</source>
          <target state="translated">単純な昔ながらの &lt;code&gt;for&lt;/code&gt; ループ</target>
        </trans-unit>
        <trans-unit id="6f15cde32ab6efb43a1b5c9033caf63a6feb7401" translate="yes" xml:space="preserve">
          <source>browsers**</source>
          <target state="translated">browsers**</target>
        </trans-unit>
        <trans-unit id="5873f666d03fb3fb39d0db9c71b5e1f769334088" translate="yes" xml:space="preserve">
          <source>every</source>
          <target state="translated">every</target>
        </trans-unit>
        <trans-unit id="4bb4ca75941b7bbc5bc6a12be44b22fc9c8d234e" translate="yes" xml:space="preserve">
          <source>filter</source>
          <target state="translated">filter</target>
        </trans-unit>
        <trans-unit id="43eef9a62abb8b1e1654f8a890aae054abffa82b" translate="yes" xml:space="preserve">
          <source>for</source>
          <target state="translated">for</target>
        </trans-unit>
        <trans-unit id="edc5ee22beb2b82f4da41914d8d41cca9c53020f" translate="yes" xml:space="preserve">
          <source>forEach</source>
          <target state="translated">forEach</target>
        </trans-unit>
        <trans-unit id="dc06788092621528ed3f0618bc0b6f3c356aa9e7" translate="yes" xml:space="preserve">
          <source>jQuery way using &lt;code&gt;$.map&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$.map&lt;/code&gt; を使用したjQueryの方法：</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="263cce6e93f37573f1e7fe24662cad3400cc887c" translate="yes" xml:space="preserve">
          <source>or &lt;code&gt;for-in&lt;/code&gt; with safeguards.</source>
          <target state="translated">またはセーフガード付きの &lt;code&gt;for-in&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48c3689f6dd5e9e952f925b7ebebf64d7c43fc56" translate="yes" xml:space="preserve">
          <source>reduce</source>
          <target state="translated">reduce</target>
        </trans-unit>
        <trans-unit id="eb875812858d27b22cb2b75f992dffadc1b05c66" translate="yes" xml:space="preserve">
          <source>some</source>
          <target state="translated">some</target>
        </trans-unit>
        <trans-unit id="f13e27693c85aed522df8c3fcb0bb0110ca54e14" translate="yes" xml:space="preserve">
          <source>zip</source>
          <target state="translated">zip</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
