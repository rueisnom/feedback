<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/9329446">
    <body>
      <group id="9329446">
        <trans-unit id="407418523e4b6661ebd3d7c0977b4358422a77b7" translate="yes" xml:space="preserve">
          <source>&quot;Just do this to every item in the list, I don't care about the order!&quot;</source>
          <target state="translated">&quot;只要把清单上的每一个项目都这样做就可以了,我不在乎顺序!&quot;</target>
        </trans-unit>
        <trans-unit id="828290fcafc33530b24d3d5dd4a9ad6ca15d4e08" translate="yes" xml:space="preserve">
          <source>(I couldn't find the equivalent verbiage in the ES2015 spec, but it's bound to still be the case.) Again, as of this writing the common host-provided array-like objects in modern browsers [&lt;code&gt;NodeList&lt;/code&gt; instances, for instance] &lt;strong&gt;do&lt;/strong&gt; handle &lt;code&gt;[[HasProperty]]&lt;/code&gt; correctly, but it's important to test.)</source>
          <target state="translated">（我在ES2015规范中找不到等效的用法，但情况肯定仍然如此。）同样，在撰写本文时，在现代浏览器中，常见的由主机提供的类似数组的对象[例如 &lt;code&gt;NodeList&lt;/code&gt; 实例] &lt;strong&gt;可以&lt;/strong&gt;正确处理 &lt;code&gt;[[HasProperty]]&lt;/code&gt; ，但进行测试很重要。）</target>
        </trans-unit>
        <trans-unit id="6b45776c77fb3cd134163e2ba508745f2d7fa17d" translate="yes" xml:space="preserve">
          <source>(If the discussion of intent makes no sense to you, then you and your code may benefit from watching Crockford's lecture on &lt;a href=&quot;https://www.youtube.com/watch?v=taaEzHI9xyY&amp;amp;t=480&quot;&gt;Programming Style &amp;amp; Your Brain&lt;/a&gt;.)</source>
          <target state="translated">（如果对意图的讨论对您没有意义，那么您和您的代码可能会受益于观看Crockford关于&amp;ldquo; &lt;a href=&quot;https://www.youtube.com/watch?v=taaEzHI9xyY&amp;amp;t=480&quot;&gt;编程风格和大脑&amp;rdquo;&lt;/a&gt;的讲座。）</target>
        </trans-unit>
        <trans-unit id="4123820b5846a3f7526a13d056cd330d08a55f64" translate="yes" xml:space="preserve">
          <source>1. Use &lt;code&gt;forEach&lt;/code&gt; and related</source>
          <target state="translated">1.使用 &lt;code&gt;forEach&lt;/code&gt; 及相关</target>
        </trans-unit>
        <trans-unit id="5a308f239da9f276808356c1264e14c4f42dba7f" translate="yes" xml:space="preserve">
          <source>2. Use a simple &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">2.使用简单的 &lt;code&gt;for&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="5547e5e05c2ee31034d6e9a26818f942561707ff" translate="yes" xml:space="preserve">
          <source>3. Use &lt;code&gt;for-in&lt;/code&gt;&lt;em&gt;correctly&lt;/em&gt;</source>
          <target state="translated">3. &lt;em&gt;正确&lt;/em&gt;使用 &lt;code&gt;for-in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="799ce3e6b5064abe821148b3f183753446d2f3dc" translate="yes" xml:space="preserve">
          <source>4. Use &lt;code&gt;for-of&lt;/code&gt; (use an iterator implicitly) (ES2015+)</source>
          <target state="translated">4.使用 &lt;code&gt;for-of&lt;/code&gt; （隐式使用迭代器）（ES2015 +）</target>
        </trans-unit>
        <trans-unit id="219586416c25d4118e0031c2b8c71aae94dda23d" translate="yes" xml:space="preserve">
          <source>5. Use an iterator explicitly (ES2015+)</source>
          <target state="translated">5.明确使用迭代器(ES2015+)</target>
        </trans-unit>
        <trans-unit id="f808743c064b9869ab9f6547f7f8581b28fea109" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://codepen.io/Micka33/pen/nbyxf&quot;&gt;A CodePen example&lt;/a&gt; of how it works is:</source>
          <target state="translated">&lt;a href=&quot;http://codepen.io/Micka33/pen/nbyxf&quot;&gt;CodePen&lt;/a&gt;如何工作的示例是：</target>
        </trans-unit>
        <trans-unit id="fedd9eb5c4d04a7948778748c41299d24255d66b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Documentation for native &lt;code&gt;Array.prototype.forEach()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;本机 &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; 的文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="33c4d33aaa1f39715e196efdb5603883d817169a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for...of&lt;/a&gt; (MDN) describes the next way of iterating using &lt;code&gt;for (variable of object)&lt;/code&gt; as the part of the Harmony (ECMAScript&amp;nbsp;6) proposal.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for ... of&lt;/a&gt; （MDN）描述了使用 &lt;code&gt;for (variable of object)&lt;/code&gt; 作为Harmony（ECMAScript 6）提议的一部分进行迭代的另一种方法。</target>
        </trans-unit>
        <trans-unit id="dd98744e853daba8a03a51ff44a45ab285ef96ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.every&quot;&gt;&lt;code&gt;every&lt;/code&gt;&lt;/a&gt; (stops looping the first time the callback returns &lt;code&gt;false&lt;/code&gt; or something falsey)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.every&quot;&gt; &lt;code&gt;every&lt;/code&gt; &lt;/a&gt; （在回调第一次返回 &lt;code&gt;false&lt;/code&gt; 或false时停止循环）</target>
        </trans-unit>
        <trans-unit id="1fe98b98ac1a303b3e5d9fe919c4bf1d837d054e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; (creates a new array including elements where the filter function returns &lt;code&gt;true&lt;/code&gt; and omitting the ones where it returns &lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; （创建一个新数组，其中包含filter函数返回 &lt;code&gt;true&lt;/code&gt; 的元素，并忽略其中返回 &lt;code&gt;false&lt;/code&gt; 的元素）</target>
        </trans-unit>
        <trans-unit id="dd4ceb819717bc057bb5f5be12b2dcaa00cc6d46" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; (creates a new array from the values returned by the callback)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; （根据回调返回的值创建一个新数组）</target>
        </trans-unit>
        <trans-unit id="967df601fa043b4383889e2892717dd399d122d6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; (builds up a value by repeatedly calling the callback, passing in previous values; see the spec for the details; useful for summing the contents of an array and many other things)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; （通过重复调用回调，传入先前的值来建立一个值；有关详细信息，请参见规范；对汇总数组内容和许多其他内容很有用）</target>
        </trans-unit>
        <trans-unit id="cc8c405cc76a381935725e183d15ed035da147b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduceright&quot;&gt;&lt;code&gt;reduceRight&lt;/code&gt;&lt;/a&gt; (like &lt;code&gt;reduce&lt;/code&gt;, but works in descending rather than ascending order)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduceright&quot;&gt; &lt;code&gt;reduceRight&lt;/code&gt; &lt;/a&gt; （类似于 &lt;code&gt;reduce&lt;/code&gt; ，但是以降序而不是升序工作）</target>
        </trans-unit>
        <trans-unit id="adfd7ff17249a9d39816111c7afab18302df88c6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.some&quot;&gt;&lt;code&gt;some&lt;/code&gt;&lt;/a&gt; (stops looping the first time the callback returns &lt;code&gt;true&lt;/code&gt; or something truthy)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.some&quot;&gt; &lt;code&gt;some&lt;/code&gt; &lt;/a&gt; （在回调第一次返回 &lt;code&gt;true&lt;/code&gt; 或true时停止循环）</target>
        </trans-unit>
        <trans-unit id="377286bac8d6282390dfb096683ce2f568297474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array#forEach&lt;/code&gt; (&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt;&lt;code&gt;spec&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;MDN&lt;/code&gt;&lt;/a&gt;) (or its relatives &lt;code&gt;some&lt;/code&gt; and such) (ES5+ only),</source>
          <target state="translated">&lt;code&gt;Array#forEach&lt;/code&gt; （ &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt; &lt;code&gt;spec&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;MDN&lt;/code&gt; &lt;/a&gt; ）（或其类似的亲戚）（仅适用于ES5 +），</target>
        </trans-unit>
        <trans-unit id="d7e42662fabd1b4650592db96d131acd3a1e156b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array.from&lt;/code&gt; (ES2015+, but easily polyfilled) creates an array from an array-like object, optionally passing the entries through a mapping function first. So:</source>
          <target state="translated">&lt;code&gt;Array.from&lt;/code&gt; （ES2015 +，但很容易填充）从类似数组的对象创建一个数组，可以选择先将条目通过映射函数传递。 所以：</target>
        </trans-unit>
        <trans-unit id="b0e8f140b1faf7f02335c4444e052df5049591e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;angular.forEach&lt;/code&gt; takes 2 arguments and an optional third argument. The first argument is the object (array) to iterate over, the second argument is the iterator function, and the optional third argument is the object context (basically referred to inside the loop as 'this'.</source>
          <target state="translated">&lt;code&gt;angular.forEach&lt;/code&gt; 接受2个参数和一个可选的第三个参数。 第一个参数是要迭代的对象（数组），第二个参数是迭代器函数，可选的第三个参数是对象上下文（在循环内部基本称为&amp;ldquo; this&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="9a8d763ba59a05f954f7c48ce76ecba0f7d62607" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;entries()&lt;/code&gt;: Returns an iterator where each &lt;code&gt;value&lt;/code&gt; is an array in the form &lt;code&gt;[key, value]&lt;/code&gt; for that iteration.</source>
          <target state="translated">&lt;code&gt;entries()&lt;/code&gt; ：返回一个迭代器，其中每个 &lt;code&gt;value&lt;/code&gt; 都是该迭代形式为 &lt;code&gt;[key, value]&lt;/code&gt; 形式的数组。</target>
        </trans-unit>
        <trans-unit id="b4cbd4974267f738d1be9503fdb7ebf5943cbd34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for-in&lt;/code&gt; with the same safeguards as with an array should work with array-like objects as well; the caveat for host-provided objects on #1 above may apply.</source>
          <target state="translated">具有与数组相同的保护措施的 &lt;code&gt;for-in&lt;/code&gt; 也应适用于类似数组的对象； 上面＃1中由主机提供的对象的警告可能适用。</target>
        </trans-unit>
        <trans-unit id="9b9fa350aa7ed228cd4b3e93d0298f289edbbed8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for-of&lt;/code&gt; will use the iterator provided by the object (if any); we'll have to see how this plays with the various array-like objects, particularly host-provided ones. For instance, the specification for the &lt;code&gt;NodeList&lt;/code&gt; from &lt;code&gt;querySelectorAll&lt;/code&gt; was updated to support iteration. The spec for the &lt;code&gt;HTMLCollection&lt;/code&gt; from &lt;code&gt;getElementsByTagName&lt;/code&gt; was not.</source>
          <target state="translated">&lt;code&gt;for-of&lt;/code&gt; 将使用对象提供的迭代器（如果有）； 我们将不得不看到它如何与各种数组状对象（尤其是主机提供的对象）一起使用。 例如，来自 &lt;code&gt;querySelectorAll&lt;/code&gt; 的 &lt;code&gt;NodeList&lt;/code&gt; 规范已更新为支持迭代。 来自 &lt;code&gt;getElementsByTagName&lt;/code&gt; 的 &lt;code&gt;HTMLCollection&lt;/code&gt; 规范不是。</target>
        </trans-unit>
        <trans-unit id="04cdb28da8f19e68125e4596f8a56b848aec15ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forEach&lt;/code&gt; accepts a callback function and, optionally, a value to use as &lt;code&gt;this&lt;/code&gt; when calling that callback (not used above). The callback is called for each entry in the array, in order, skipping non-existent entries in sparse arrays. Although I only used one argument above, the callback is called with three: The value of each entry, the index of that entry, and a reference to the array you're iterating over (in case your function doesn't already have it handy).</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; 接受一个回调函数，以及（可选）一个在调用该回调时用作 &lt;code&gt;this&lt;/code&gt; 函数的值（上面未使用）。 依次为数组中的每个条目调用回调，从而跳过稀疏数组中不存在的条目。 尽管上面我只使用了一个参数，但回调函数使用以下三个参数调用：每个条目的值，该条目的索引以及对要迭代的数组的引用（以防您的函数尚未使用它） ）。</target>
        </trans-unit>
        <trans-unit id="10cc3315d863ec1f2a75337ba363aaa39af9ff7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forEach&lt;/code&gt; has the benefit that you don't have to declare indexing and value variables in the containing scope, as they're supplied as arguments to the iteration function, and so nicely scoped to just that iteration.</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; 的好处是您不必在包含范围中声明索引和值变量，因为它们是作为迭代函数的参数提供的，因此很好地范围仅限于该迭代。</target>
        </trans-unit>
        <trans-unit id="d31603bd232d66e37b18d7476c0486024b09c2d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forEach&lt;/code&gt; will iterate over the array you provide and for each iteration it will have &lt;code&gt;element&lt;/code&gt; which holds the value of that iteration. If you need index you can get the current index by passing the &lt;code&gt;i&lt;/code&gt; as the second parameter in the callback function for forEach.</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; 将遍历您提供的数组，并且对于每次迭代，它将具有保存该迭代值的 &lt;code&gt;element&lt;/code&gt; 。 如果需要索引，可以通过将 &lt;code&gt;i&lt;/code&gt; 作为forEach的回调函数中的第二个参数传递来获取当前索引。</target>
        </trans-unit>
        <trans-unit id="a637b50b32f61aa2eb966f27cbab468a25797cfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keys()&lt;/code&gt;: Returns an iterator where each &lt;code&gt;value&lt;/code&gt; is the key for that iteration (so for our &lt;code&gt;a&lt;/code&gt; above, that would be &lt;code&gt;&quot;0&quot;&lt;/code&gt;, then &lt;code&gt;&quot;1&quot;&lt;/code&gt;, then &lt;code&gt;&quot;2&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;keys()&lt;/code&gt; ：返回一个迭代器，其中每个 &lt;code&gt;value&lt;/code&gt; 都是该迭代的键（因此，对于我们上面的 &lt;code&gt;a&lt;/code&gt; ，它将是 &lt;code&gt;&quot;0&quot;&lt;/code&gt; ，然后是 &lt;code&gt;&quot;1&quot;&lt;/code&gt; ，然后是 &lt;code&gt;&quot;2&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e09aa066919616abd8401c1b7f350a3988032555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;values()&lt;/code&gt;: This is the one I used above. It returns an iterator where each &lt;code&gt;value&lt;/code&gt; is the array entry for that iteration (&lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;b&quot;&lt;/code&gt;, and &lt;code&gt;&quot;c&quot;&lt;/code&gt; in the example earlier).</source>
          <target state="translated">&lt;code&gt;values()&lt;/code&gt; ：这是我上面使用的那个。 它返回一个迭代器，其中每个 &lt;code&gt;value&lt;/code&gt; 都是该迭代的数组条目（在前面的示例中为 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ， &lt;code&gt;&quot;b&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;c&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b95a3bad9c3b12555c2a9ef69ef39152f687a5c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; will contain the last value of &lt;code&gt;y&lt;/code&gt; and it will be removed from the array. You can also use &lt;code&gt;shift()&lt;/code&gt; which will give and remove the first item from &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 将包含 &lt;code&gt;y&lt;/code&gt; 的最后一个值，并将其从数组中删除。 您也可以使用 &lt;code&gt;shift()&lt;/code&gt; 来从 &lt;code&gt;y&lt;/code&gt; 中删除第一项。</target>
        </trans-unit>
        <trans-unit id="94d62988ff95e5983c9bb7336fe74b54beb70d31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Credits go to WYL for showing me the benefits and horrors of the reverse for loop.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;感谢WYL向我展示反向for循环的好处和恐惧。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ebe32016513b7b36eecf84f088911eaffc1e16a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A&lt;/strong&gt; - &lt;code&gt;for&lt;/code&gt; tests</source>
          <target state="translated">&lt;strong&gt;A-&lt;/strong&gt; &lt;code&gt;for&lt;/code&gt; 测试</target>
        </trans-unit>
        <trans-unit id="9e681feccaa2f651d3f5e876dbe2e319c1d67118" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array with 1,000,000 elements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;具有1,000,000个元素的数组&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3255bc6f4f9492d8559a38233f24c1a81f7a3679" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array with 10 elements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;包含10个元素的数组&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1730cb94cc2840238efe2ab02609e1acbb5d7877" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array.forEach()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Array.forEach()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f9864972c7c592b5676161c6e60aa0f51041edc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of ECMAScript&amp;nbsp;6:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;从ECMAScript 6开始：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="366729cb2dd9643a7a37c411a6350e8f3239e9fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B&lt;/strong&gt; - &lt;code&gt;while&lt;/code&gt; tests</source>
          <target state="translated">&lt;strong&gt;B-边&lt;/strong&gt;测</target>
        </trans-unit>
        <trans-unit id="330f92001b0c02491afac466730ba9e45d684ab4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C&lt;/strong&gt; - other/alternative methods</source>
          <target state="translated">&lt;strong&gt;C-&lt;/strong&gt;其他/替代方法</target>
        </trans-unit>
        <trans-unit id="1a68ce6032c3740fd013d6c9b66b882246d9cf06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caf1f7a722c982dbd57c57da6fb19a30c4de09b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66201f31a06924bccc5252ec818cb13549b146b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cross browser results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;跨浏览器结果&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="750c1a011ed83068ce4b750427dca4f8195eb051" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40f5fee30dbaa97b495918cfcda19fd49d758e20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="184138f36fc9d5f1b134435fd6400d89d5dd3ef7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;范例＃2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fbf2341d370757e8b1e3d68104c67efff5070bbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子＃3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc261b2aaea005d1254afb5ea26e11f1deea56b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例子＃4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="076cc797a53b7cb38c7bf05c97b94635f200c2e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1:&lt;/strong&gt; Normal &lt;code&gt;for...of&lt;/code&gt; loop - no tricks here.</source>
          <target state="translated">&lt;strong&gt;示例1：&lt;/strong&gt; &lt;code&gt;for...of&lt;/code&gt; 循环的正常-这里没有技巧。</target>
        </trans-unit>
        <trans-unit id="49d9fa2400580995d7bae707d928b0d3821aa741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2:&lt;/strong&gt; Split words to characters</source>
          <target state="translated">&lt;strong&gt;示例2：将&lt;/strong&gt;单词拆分为字符</target>
        </trans-unit>
        <trans-unit id="bdc1592f5ce50edf5193207a1607a8801ea11f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3:&lt;/strong&gt; Looping with a &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;示例3：&lt;/strong&gt;使用 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="78871da32ac6a0f7f115cb0b01a332656d6a8904" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4:&lt;/strong&gt; Get object properties inline</source>
          <target state="translated">&lt;strong&gt;示例4：&lt;/strong&gt;内联获取对象属性</target>
        </trans-unit>
        <trans-unit id="e558c5c128ffa4a0403278ee644502849ef174b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 5:&lt;/strong&gt; Get deep object properties of what you need</source>
          <target state="translated">&lt;strong&gt;示例5：&lt;/strong&gt;获得所需的深层对象属性</target>
        </trans-unit>
        <trans-unit id="0a55d796f49ed376bbdc8b840ed3ffef75a362c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 6:&lt;/strong&gt; Is &lt;strong&gt;Example 3&lt;/strong&gt; used with &lt;code&gt;.forEach&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;示例6：&lt;/strong&gt; &lt;strong&gt;示例3&lt;/strong&gt;是否与 &lt;code&gt;.forEach&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="1c576ad032b24d44f329a8bbbc699e346dfa84e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 7:&lt;/strong&gt; Is &lt;strong&gt;Example 4&lt;/strong&gt; used with &lt;code&gt;.forEach&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;示例7：&lt;/strong&gt;是&lt;strong&gt;示例4&lt;/strong&gt;与 &lt;code&gt;.forEach&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="28f415a0afa402f72563bd9599b6360f208f4e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 8:&lt;/strong&gt; Is &lt;strong&gt;Example 5&lt;/strong&gt; used with &lt;code&gt;.forEach&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;示例8：&lt;/strong&gt; &lt;strong&gt;示例5&lt;/strong&gt;是否与 &lt;code&gt;.forEach&lt;/code&gt; 一起使用</target>
        </trans-unit>
        <trans-unit id="4ce5e7fbb73dac5a612d22d4d58fd1306ab12eaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples 6, 7, and 8&lt;/strong&gt; can be used with any functional loops like &lt;code&gt;.map&lt;/code&gt;, &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.reduce&lt;/code&gt;, &lt;code&gt;.sort&lt;/code&gt;, &lt;code&gt;.every&lt;/code&gt;, &lt;code&gt;.some&lt;/code&gt;. For more information about these methods, check out the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;Array Object&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;示例6、7和8&lt;/strong&gt;可以与任何功能循环（例如 &lt;code&gt;.map&lt;/code&gt; ， &lt;code&gt;.filter&lt;/code&gt; ， .reduce ， &lt;code&gt;.sort&lt;/code&gt; ， &lt;code&gt;.every&lt;/code&gt; 和 &lt;code&gt;.some&lt;/code&gt; )一起使用 。 有关这些方法的更多信息，请查看&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;Array Object&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea72b87b0bf2ace83cf5109381e93aeb066f2f76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples of usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;用法示例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b7b6fbb391b39121d3090835b1a7d329182a66c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional loops&lt;/strong&gt; - &lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, also &lt;code&gt;reduce&lt;/code&gt; (they loop through the function, but they are used if you need to do something with your array, etc.</source>
          <target state="translated">&lt;strong&gt;功能循环&lt;/strong&gt; &lt;code&gt;forEach&lt;/code&gt; ， &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;filter&lt;/code&gt; ，也可以 &lt;code&gt;reduce&lt;/code&gt; （它们循环遍历函数，但是如果您需要对数组做一些操作，则可以使用它们。</target>
        </trans-unit>
        <trans-unit id="32fac35272abae62a061520fb1a2f945a7607806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How can it start at &lt;code&gt;array.length&lt;/code&gt; without exploding?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;它如何从 &lt;code&gt;array.length&lt;/code&gt; 开始而不爆炸？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b91663c8ee6622d139ccbcbdd48f45d5a5186122" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;NOTE&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="9df17e3bf34872a611d0e519ed5573d79bc888bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This answer is hopelessly out-of-date. For a more modern approach, look at &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;the methods available on an array&lt;/a&gt;. Methods of interest might be:</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：此答案已过时。 对于更现代的方法，请查看&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;array上可用的方法&lt;/a&gt; 。 感兴趣的方法可能是：</target>
        </trans-unit>
        <trans-unit id="7e3161fd669d07159e3a7475c999f77628c85246" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="364d4fdee3e0bca52971cff9ce11bfd5c1cd8d29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0012595d3c17367fbb2f7b33de7378b0b6ab7340" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Removing siblings&lt;/strong&gt; from the DOM in reverse order is usually &lt;strong&gt;more efficient&lt;/strong&gt;.  (The browser needs to do less shifting of elements in its internal arrays.)</source>
          <target state="translated">以相反的顺序从DOM中&lt;strong&gt;删除兄弟姐妹&lt;/strong&gt;通常&lt;strong&gt;更为有效&lt;/strong&gt; 。 （浏览器需要减少其内部数组中元素的移动。）</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07ae7a0c45d54d2ebb1dc0cd4ec4001979bca9ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread syntax (&lt;code&gt;...&lt;/code&gt;)&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;扩展语法（ &lt;code&gt;...&lt;/code&gt; ）&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4022df37529f9de6389e8b44f78656816e01d469" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;Array.from&lt;/code&gt;&lt;/strong&gt;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.from&quot;&gt;(spec)&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from&quot;&gt;(MDN)&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;使用 &lt;code&gt;Array.from&lt;/code&gt; &lt;/strong&gt; &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.from&quot;&gt;（spec）&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from&quot;&gt;（MDN）&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46eac7e8f751f6f37b8572993152b573d2db8084" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;for-in&lt;/code&gt; &lt;em&gt;correctly&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;正确&lt;/em&gt;使用&lt;em&gt;转售&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d283294cac8da6d79925867e0ba6a307ede498df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;for-of&lt;/code&gt; (use an iterator implicitly) (ES2015+)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用 &lt;code&gt;for-of&lt;/code&gt; （隐式使用迭代器）（ES2015 +）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bd126a72acb2ecb3b1451e2659a42fd39e32809" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;forEach&lt;/code&gt; and related (ES5+)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;适用于 &lt;code&gt;forEach&lt;/code&gt; 及相关（ES5 +）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb2d92cc11b7a9d0aca33182e1bebdf4c726208b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use a simple &lt;code&gt;for&lt;/code&gt; loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用简单的 &lt;code&gt;for&lt;/code&gt; 循环&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f71bc706ab4a26bf9a13464f7b39c3aeaed0e52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use an iterator explicitly (ES2015+)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;明确使用迭代器（ES2015 +）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c4b03a035270e1b8f7dd2084f9df26df262debc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; method of arrays&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用数组的&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt;方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8aa2a7263e5c604aa1227ef93fc167e49c67b84c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using loops with ECMAScript&amp;nbsp;6  &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;destructuring&lt;/a&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread operator&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;在ECMAScript 6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;解构&lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;散布运算符中&lt;/a&gt;使用循环&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="43d6f90660b9cfa169cfb55c0d5f5781ab586f65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why doesn't it stop iterating before index 0?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为什么它在索引0之前不停止迭代？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c7882bff3bd32e131ca75ee9b3310dc89ce137d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;do...while loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;做... while循环&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="292b6043564aae6314fc4949f7b4dc07ffca89f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;do/while&lt;/strong&gt; - also loop through a block of code while the condition is true, will run at least one time</source>
          <target state="translated">&lt;strong&gt;do / while-&lt;/strong&gt;在条件为true的情况下也循环遍历代码块，至少运行一次</target>
        </trans-unit>
        <trans-unit id="59c2e1f4757834d90e32b8228c2ca6efbcc623e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;every&lt;/strong&gt; - Returns true or false if all the elements in the array pass the test in the callback function.</source>
          <target state="translated">every-如果数组中的所有元素都通过了回调函数中的测试，则返回true或false。</target>
        </trans-unit>
        <trans-unit id="733d7f1b168a00ba327543b1d4fe7a84e1c306f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;filter&lt;/strong&gt; - Very similar to every except that filter returns an array with the elements that return true to the given function.</source>
          <target state="translated">filter-与每个&lt;strong&gt;过滤器&lt;/strong&gt;非常相似，不同之处在于filter返回一个数组，该数组的元素对给定函数返回true。</target>
        </trans-unit>
        <trans-unit id="271fc1eae66abadd19acb62d4033231ca149cfff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;for循环&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6730b771cabf57b04de93a3724c66df24b945a65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for...in loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;for ...在循环中&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41a75d50cd0e008efc00bd22fdc7462386f2f0fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for...of loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;对于...的循环&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2573e11cf7374a0bd5806f17739331b98d97a3d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for&lt;/strong&gt; - it's &lt;strong&gt;the most common one&lt;/strong&gt;. Full block of code for looping</source>
          <target state="translated">&lt;strong&gt;因为&lt;/strong&gt; -这是&lt;strong&gt;最常见的一种&lt;/strong&gt; 。 完整的代码块用于循环</target>
        </trans-unit>
        <trans-unit id="bf96d036e4a3af64d225f756d7cdb14e19eaa0d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;forEach&lt;/strong&gt; - Iterates through every item in the array and do whatever you need with each item.</source>
          <target state="translated">&lt;strong&gt;forEach-&lt;/strong&gt;遍历数组中的每个项目，并对每个项目执行所需的任何操作。</target>
        </trans-unit>
        <trans-unit id="ea31da07d585b6c78298f66e4e1cab0b4bf164cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;map&lt;/strong&gt; - It creates a new array with the result of the callback function. This method is good to be used when you need to format the elements of your array.</source>
          <target state="translated">map-使用回调函数的结果创建一个新数组。 需要格式化数组元素时，可以使用此方法。</target>
        </trans-unit>
        <trans-unit id="1d2abe3d817566b9ac069c513ac4125616984176" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;reduce&lt;/strong&gt; - As the name says, it reduces the array to a single value by calling the given function passing in the current element and the result of the previous execution.</source>
          <target state="translated">&lt;strong&gt;reduce-&lt;/strong&gt;顾名思义，它通过调用传入当前元素的给定函数以及上一次执行的结果，将数组&lt;strong&gt;简化&lt;/strong&gt;为单个值。</target>
        </trans-unit>
        <trans-unit id="bc7cb0747f251ea37bf8ac12f021c5f51bc464ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;while loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;while循环&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d59bd2da691ba295b8e0f0e005203a04e318b82d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;while&lt;/strong&gt; - loop while a condition is through. It seems to be the fastest loop</source>
          <target state="translated">while-在条件通过&lt;strong&gt;时&lt;/strong&gt;循环。 这似乎是最快的循环</target>
        </trans-unit>
        <trans-unit id="98ac7d9be42d78332ce549839259a6fa839e83f9" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;forEach&lt;/strong&gt; implementation (&lt;a href=&quot;http://jsfiddle.net/nmoliveira/zNsyB/&quot;&gt;see in jsFiddle&lt;/a&gt;):</source>
          <target state="translated">一个&lt;strong&gt;forEach&lt;/strong&gt;实现（ &lt;a href=&quot;http://jsfiddle.net/nmoliveira/zNsyB/&quot;&gt;请参阅jsFiddle&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="1593b174e119f27794747b6ca100ac5339012c07" translate="yes" xml:space="preserve">
          <source>A way closest to your idea would be to use &lt;code&gt;Array.forEach()&lt;/code&gt; which accepts a closure function which will be executed for each element of the array.</source>
          <target state="translated">与您的想法最接近的一种方法是使用 &lt;code&gt;Array.forEach()&lt;/code&gt; ，它接受将对数组的每个元素执行的闭包函数。</target>
        </trans-unit>
        <trans-unit id="461621dddb84f5684403289120de177b2681c313" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt; has added a &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;forEach&lt;/code&gt;&lt;/a&gt; method to &lt;code&gt;Array.prototype&lt;/code&gt; which can be used to enumerate over an array using a calback (the polyfill is in the docs so you can still use it for older browsers):</source>
          <target state="translated">此外， &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt;在 &lt;code&gt;Array.prototype&lt;/code&gt; 中添加了一个&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;forEach&lt;/code&gt; &lt;/a&gt;方法，该方法可用于使用回溯对数组进行枚举（polyfill在文档中，因此您仍可将其用于旧版浏览器）：</target>
        </trans-unit>
        <trans-unit id="636fc2fec13e68630984c3473aa5d7f358f03d69" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;forEach&lt;/code&gt; is the &quot;loop through them all&quot; function, but ES5 defined several other useful &quot;work your way through the array and do things&quot; functions, including:</source>
          <target state="translated">另外， &lt;code&gt;forEach&lt;/code&gt; 是&amp;ldquo;遍历所有对象&amp;rdquo;功能，但是ES5定义了其他几个有用的&amp;ldquo;遍历数组并执行操作&amp;rdquo;功能，包括：</target>
        </trans-unit>
        <trans-unit id="c9f143cb14712f08a4e4970f0a574a82e563a424" translate="yes" xml:space="preserve">
          <source>Advantages:</source>
          <target state="translated">Advantages:</target>
        </trans-unit>
        <trans-unit id="de209c6ef85b78db6e703d44fe0a792cf0cf2d79" translate="yes" xml:space="preserve">
          <source>Although the performance gains are usually insignificant, it sort of screams:</source>
          <target state="translated">虽然性能上的提升通常是微不足道的,但也算得上是惊呼。</target>
        </trans-unit>
        <trans-unit id="41e3fc9478f9b0602ab804e2073a64ab781383e9" translate="yes" xml:space="preserve">
          <source>An easy solution now would be to use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;underscore.js library&lt;/a&gt;. It's providing many useful tools, such as &lt;code&gt;each&lt;/code&gt; and will automatically delegate the job to the native &lt;code&gt;forEach&lt;/code&gt; if available.</source>
          <target state="translated">现在，一个简单的解决方案是使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;underscore.js库&lt;/a&gt; 。 它提供了许多有用的工具，例如 &lt;code&gt;each&lt;/code&gt; 工具，并且会自动将作业委派给本地 &lt;code&gt;forEach&lt;/code&gt; (如果有）。</target>
        </trans-unit>
        <trans-unit id="76134101719fc71647c5e2d29cf268ee6974b9a0" translate="yes" xml:space="preserve">
          <source>And finally the first 20 blue p tags are changed to green</source>
          <target state="translated">最后把前20个蓝色的P牌换成绿色的</target>
        </trans-unit>
        <trans-unit id="286bb782ad24f006d5ef3df1b25f01bf4ccf96dd" translate="yes" xml:space="preserve">
          <source>And furthermore &lt;code&gt;await&lt;/code&gt;&lt;a href=&quot;https://gist.github.com/joeytwiddle/37d2085425c049629b80956d3c618971&quot;&gt;does not work&lt;/a&gt; inside &lt;code&gt;forEach()&lt;/code&gt;.  Using &lt;code&gt;for..of&lt;/code&gt; is &lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-259876436&quot;&gt;the clearest pattern&lt;/a&gt; in this case.</source>
          <target state="translated">而且， &lt;code&gt;await&lt;/code&gt; 在 &lt;code&gt;forEach()&lt;/code&gt; 内部&lt;a href=&quot;https://gist.github.com/joeytwiddle/37d2085425c049629b80956d3c618971&quot;&gt;不起作用&lt;/a&gt; 。 在这种情况下，使用 &lt;code&gt;for..of&lt;/code&gt; 是&lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-259876436&quot;&gt;最清晰的模式&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2635b275be0c2dfc38d57182a9f17df25ac0fd4" translate="yes" xml:space="preserve">
          <source>And if you want it to be a function, you can do this:</source>
          <target state="translated">而如果你想让它成为一个功能,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="aa47cb48e650e1ab26dbe126a4f7ec3d29c4aae4" translate="yes" xml:space="preserve">
          <source>And there are many others for iteration.</source>
          <target state="translated">而且还有很多其他的迭代。</target>
        </trans-unit>
        <trans-unit id="cd8096180abe912c76cb829baeb8776e4097989f" translate="yes" xml:space="preserve">
          <source>And when you do that, not just &lt;code&gt;value&lt;/code&gt; but also &lt;code&gt;index&lt;/code&gt; is recreated for each loop iteration, meaning closures created in the loop body keep a reference to the &lt;code&gt;index&lt;/code&gt; (and &lt;code&gt;value&lt;/code&gt;) created for that specific iteration:</source>
          <target state="translated">而且，这样做时，不仅为每次循环迭代都重新创建 &lt;code&gt;value&lt;/code&gt; 而且还重新创建 &lt;code&gt;index&lt;/code&gt; ，这意味着在循环主体中创建的闭包保留对为该特定迭代创建的 &lt;code&gt;index&lt;/code&gt; （和 &lt;code&gt;value&lt;/code&gt; ）的引用：</target>
        </trans-unit>
        <trans-unit id="c5d23f01f61bcd35bfab142a15fd44885c61c3be" translate="yes" xml:space="preserve">
          <source>And/or counting backward:</source>
          <target state="translated">而且还是倒着数。</target>
        </trans-unit>
        <trans-unit id="c4dfb973c48c6519cc7b7dc31550d6b63562a6b8" translate="yes" xml:space="preserve">
          <source>Another viable way would be to use &lt;code&gt;Array.map()&lt;/code&gt; which works in the same way, but it also takes all values that you return and returns them in a new array (essentially mapping each element to a new one), like this:</source>
          <target state="translated">另一种可行的方法是使用 &lt;code&gt;Array.map()&lt;/code&gt; ，该方法的工作方式相同，但是它还会获取您返回的所有值，并将它们返回到新数组中（实质上是将每个元素映射到一个新元素），如下所示：</target>
        </trans-unit>
        <trans-unit id="e3e988d8ceb27456dc97896d4220b5940816a6af" translate="yes" xml:space="preserve">
          <source>Another way that is useful for copying items from one array to another is</source>
          <target state="translated">另一种从一个数组中复制项到另一个数组的方法是</target>
        </trans-unit>
        <trans-unit id="8d554cc4170a849cf2e0aa16b801259f0efd7018" translate="yes" xml:space="preserve">
          <source>As per question, user want code in javascript instead of jquery so the edit is</source>
          <target state="translated">根据问题,用户希望用javascript代码而不是jquery来编辑,所以编辑是</target>
        </trans-unit>
        <trans-unit id="bdc7e9a236af726f7038fbcebf901bc5de8a0e8f" translate="yes" xml:space="preserve">
          <source>As per the new updated feature ECMAScript 6 (ES6) and ECMAScript 2015, you can use the following options with loops:</source>
          <target state="translated">根据ECMAScript 6 (ES6)和ECMAScript 2015的新更新功能,你可以使用以下的循环选项。</target>
        </trans-unit>
        <trans-unit id="47e50940d71eac09fa64f7e1d6bcb6c40b08529b" translate="yes" xml:space="preserve">
          <source>Aside from true arrays, there are also &lt;em&gt;array-like&lt;/em&gt; objects that have a &lt;code&gt;length&lt;/code&gt; property and properties with numeric names: &lt;code&gt;NodeList&lt;/code&gt; instances, the &lt;code&gt;arguments&lt;/code&gt; object, etc. How do we loop through their contents?</source>
          <target state="translated">除了真正的数组之外，还有一些&lt;em&gt;类似数组的&lt;/em&gt;对象，它们具有 &lt;code&gt;length&lt;/code&gt; 属性和带有数字名称的属性： &lt;code&gt;NodeList&lt;/code&gt; 实例， &lt;code&gt;arguments&lt;/code&gt; 对象等。我们如何遍历它们的内容？</target>
        </trans-unit>
        <trans-unit id="eab486bae96770e7bd766cc0cc4ada63033b8966" translate="yes" xml:space="preserve">
          <source>At least some, and possibly most or even all, of the array approaches above frequently apply equally well to array-like objects:</source>
          <target state="translated">上述的数组方法中,至少有一些,甚至可能是大部分甚至全部的数组方法经常同样适用于类似数组的对象。</target>
        </trans-unit>
        <trans-unit id="70a2b96e30c86a111cdae7a47c5956d3a9d28e3e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;i--&lt;/code&gt; runs &lt;em&gt;before&lt;/em&gt; each iteration, on the first iteration we will actually be accessing the item at &lt;code&gt;array.length - 1&lt;/code&gt; which avoids any issues with &lt;strike&gt;Array-out-of-bounds&lt;/strike&gt;&lt;code&gt;undefined&lt;/code&gt; items.</source>
          <target state="translated">因为 &lt;code&gt;i--&lt;/code&gt; &lt;em&gt;在&lt;/em&gt;每次迭代&lt;em&gt;之前&lt;/em&gt;运行，所以在第一次迭代中，我们实际上将访问 &lt;code&gt;array.length - 1&lt;/code&gt; 的项，这避免了&lt;strike&gt;Array-bound-of-bounds&lt;/strike&gt; &lt;code&gt;undefined&lt;/code&gt; 项的任何问题。</target>
        </trans-unit>
        <trans-unit id="7e75fbda4fe70f4af05ef437f23c8019a6e0a056" translate="yes" xml:space="preserve">
          <source>But the above concerns is not applicable to Node.js applications, where &lt;code&gt;for..of&lt;/code&gt; is now well supported.</source>
          <target state="translated">但是上述问题不适用于Node.js应用程序，因为 &lt;code&gt;for..of&lt;/code&gt; 现在得到了很好的支持。</target>
        </trans-unit>
        <trans-unit id="877397eda4030d185b7ccf9f7ce92ef4e0c61e68" translate="yes" xml:space="preserve">
          <source>But there's &lt;strong&gt;lots&lt;/strong&gt; more to explore, read on...</source>
          <target state="translated">但是还有更多探索的地方，请继续阅读...</target>
        </trans-unit>
        <trans-unit id="ee106f8a0a3a9dae96b0d69d742bcd97b39bd261" translate="yes" xml:space="preserve">
          <source>But with modern JavaScript engines, it's rare you need to eke out that last bit of juice.</source>
          <target state="translated">但对于现代的JavaScript引擎来说,你很少会需要把最后一点汁液挖出来。</target>
        </trans-unit>
        <trans-unit id="3e709fabb3cf8ffb27a522d70327597b3b8cc4d2" translate="yes" xml:space="preserve">
          <source>Caution when using string as function: the function is created out-of-context and ought to be used only where you are certain of variable scoping.  Otherwise, better to pass functions where scoping is more intuitive.</source>
          <target state="translated">使用string作为函数时的注意事项:该函数是在上下文之外创建的,只有在确定了变量范围的情况下才能使用。否则,最好是传递函数,因为这样可以更直观地了解变量的范围界定。</target>
        </trans-unit>
        <trans-unit id="ebdda461e7af469834840795faba24136d9d0951" translate="yes" xml:space="preserve">
          <source>Caveat for host-provided objects</source>
          <target state="translated">主机提供的对象的注意事项</target>
        </trans-unit>
        <trans-unit id="5c0fa40086336662397974cdbd5ffa0407908978" translate="yes" xml:space="preserve">
          <source>Consider the following 2 nested loops, which do exactly the same thing. Let's say that we have 2 arrays of objects and each object contains an array of results, each of which has a Value property that's a string (or whatever). And let's say we need to iterate over each of the results and if they're equal then perform some action:</source>
          <target state="translated">考虑一下下面2个嵌套循环,它们做的事情完全一样。假设我们有2个对象的数组,每个对象都包含一个结果的数组,每个对象都有一个Value属性的字符串(或其他什么的)。假设我们需要对每个结果进行迭代,如果它们相等,那么就执行一些操作。</target>
        </trans-unit>
        <trans-unit id="dc657383123e3b34e3dc9324b5bc94793d6b0ec9" translate="yes" xml:space="preserve">
          <source>Create a true array</source>
          <target state="translated">创建一个真正的数组</target>
        </trans-unit>
        <trans-unit id="6ebbbdefb07c190cb50e696dfd8fd8b8232a9dd9" translate="yes" xml:space="preserve">
          <source>Destructuring and using of the spread operator have proven quite useful for newcomers to ECMAScript&amp;nbsp;6 as being more human-readable/aesthetic, although some JavaScript veterans might consider it messy. Juniors or some other people might find it useful.</source>
          <target state="translated">已证明，对ECMAScript 6的新手来说，散布运算符的解构和使用对人类更易读/更美观，因此对ECMAScript 6来说非常有用，尽管有些JavaScript老手可能认为它很杂乱。 青少年或其他人可能会发现它很有用。</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="1daaad0084c2604185e45c5a29dc6efeff0b7fce" translate="yes" xml:space="preserve">
          <source>Details:</source>
          <target state="translated">Details:</target>
        </trans-unit>
        <trans-unit id="c472a51872469dd7221cdb8ed81b476216096187" translate="yes" xml:space="preserve">
          <source>Disadvantages:</source>
          <target state="translated">Disadvantages:</target>
        </trans-unit>
        <trans-unit id="6c93fe8028eb2c06aa7aad788adaf00386420ed1" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;for-in&lt;/code&gt; unless you use it with safeguards or are at least aware of why it might bite you.</source>
          <target state="translated">除非您将 &lt;code&gt;for-in&lt;/code&gt; 用于防护措施，否则至少不要知道为什么它会咬伤您。</target>
        </trans-unit>
        <trans-unit id="d08ac59c6f776a259666b38bd6f6b67c6ac20550" translate="yes" xml:space="preserve">
          <source>ECMAScript&amp;nbsp;5 (the version on JavaScript) to work with Arrays:</source>
          <target state="translated">ECMAScript 5（JavaScript上的版本）可用于数组：</target>
        </trans-unit>
        <trans-unit id="d365e59cfe702f0dc8ea35a70c741654a39fed8f" translate="yes" xml:space="preserve">
          <source>ES2015 adds &lt;em&gt;iterators&lt;/em&gt; to JavaScript. The easiest way to use iterators is the new &lt;code&gt;for-of&lt;/code&gt; statement. It looks like this:</source>
          <target state="translated">ES2015将&lt;em&gt;迭代器&lt;/em&gt;添加到JavaScript。 使用迭代器的最简单方法是新的 &lt;code&gt;for-of&lt;/code&gt; 语句。 看起来像这样：</target>
        </trans-unit>
        <trans-unit id="89cce593f5131e64c65adfb3e7a2a8a99ecd6047" translate="yes" xml:space="preserve">
          <source>Each p tag gets &lt;code&gt;class=&quot;blue&quot;&lt;/code&gt;</source>
          <target state="translated">每个p标签都获得 &lt;code&gt;class=&quot;blue&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a03f898632fc9e1da60588b88699c530174fddff" translate="yes" xml:space="preserve">
          <source>Easy readability</source>
          <target state="translated">易读性</target>
        </trans-unit>
        <trans-unit id="a1360cfea2542d434b165c5be72693e776eefce5" translate="yes" xml:space="preserve">
          <source>Easy writability</source>
          <target state="translated">易写性</target>
        </trans-unit>
        <trans-unit id="5c260a8d97db3363bbeeb8cd4f1afd6ee2424cdf" translate="yes" xml:space="preserve">
          <source>Efficiency. &lt;code&gt;angular.forEach&lt;/code&gt;, and the native &lt;code&gt;forEach&lt;/code&gt;, for that matter, are both &lt;em&gt;so much&lt;/em&gt; slower than the normal &lt;code&gt;for&lt;/code&gt; loop....about &lt;a href=&quot;http://jsperf.com/angular-foreach-vs-native-for-loop/3&quot;&gt;90% slower&lt;/a&gt;. So for large data sets, best to stick to the native &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">效率。 &lt;code&gt;angular.forEach&lt;/code&gt; ， angular.forEach和本机 &lt;code&gt;forEach&lt;/code&gt; 都比普通的 &lt;code&gt;for&lt;/code&gt; 循环慢得多.... &lt;a href=&quot;http://jsperf.com/angular-foreach-vs-native-for-loop/3&quot;&gt;慢了&lt;/a&gt;约90％ 。 因此，对于大型数据集，最好坚持使用本机 &lt;code&gt;for&lt;/code&gt; 循环。</target>
        </trans-unit>
        <trans-unit id="9bbc4aeb0980cee945b58ff2f771d473c92abbcf" translate="yes" xml:space="preserve">
          <source>Every other p tag gets &lt;code&gt;class=&quot;red&quot;&lt;/code&gt;&amp;gt;</source>
          <target state="translated">每隔p个标签获得 &lt;code&gt;class=&quot;red&quot;&lt;/code&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="31d46401beeeb139181157a391e38208292ff52c" translate="yes" xml:space="preserve">
          <source>For Actual Arrays</source>
          <target state="translated">对于实际阵列</target>
        </trans-unit>
        <trans-unit id="574d2bfcf687ca1c9e5ae449855c6a7b3be2b282" translate="yes" xml:space="preserve">
          <source>For Array-Like Objects</source>
          <target state="translated">对于数组类对象</target>
        </trans-unit>
        <trans-unit id="4c9f1e7b36c7b85949136c05d06c3d1376f6fb79" translate="yes" xml:space="preserve">
          <source>For maximum browser support, &lt;code&gt;for..of&lt;/code&gt;&lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-471169142&quot;&gt;requires a polyfill&lt;/a&gt; for iterators, making your app slightly slower to execute and slightly larger to download.</source>
          <target state="translated">为了获得最大程度的浏览器支持， &lt;code&gt;for..of&lt;/code&gt; &lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-471169142&quot;&gt;需要&lt;/a&gt;为迭代器使用polyfill ，从而使您的应用执行速度稍慢，下载速度稍大。</target>
        </trans-unit>
        <trans-unit id="07dab6b0cba0aafb7fb630f2e41c7bbe0d2fa27e" translate="yes" xml:space="preserve">
          <source>For more information and examples about functional programming on arrays, look at the blog post &lt;em&gt;&lt;a href=&quot;http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/&quot;&gt;Functional programming in JavaScript: map, filter and reduce&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">有关数组上函数编程的更多信息和示例，请参阅博客文章&lt;em&gt;&lt;a href=&quot;http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/&quot;&gt;JavaScript中&lt;/a&gt;&lt;/em&gt;的&lt;em&gt;函数编程：map，filter和reduce&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5b5226b5b2f9ba8ea80f8e646bec60d9ae27902" translate="yes" xml:space="preserve">
          <source>For that reason (and to encourage use of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt;), &lt;a href=&quot;https://github.com/airbnb/javascript#iterators-and-generators&quot;&gt;some front-end style guides&lt;/a&gt; ban &lt;code&gt;for..of&lt;/code&gt; completely!</source>
          <target state="translated">因此（并鼓励使用 &lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;filter&lt;/code&gt; ）， &lt;a href=&quot;https://github.com/airbnb/javascript#iterators-and-generators&quot;&gt;一些前端样式指南&lt;/a&gt;完全禁止使用 &lt;code&gt;for..of&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="740b5208eb855ba5fe663f7061e6d63db399e3ab" translate="yes" xml:space="preserve">
          <source>For-each over an array in JavaScript</source>
          <target state="translated">JavaScript中的For-each over一个数组</target>
        </trans-unit>
        <trans-unit id="4b1bffa7198cab670a61e9e726dc8034ad855ba9" translate="yes" xml:space="preserve">
          <source>ForEach</source>
          <target state="translated">ForEach</target>
        </trans-unit>
        <trans-unit id="0b863337ad80c0e087cc5bb5e2ee2b6648e7963d" translate="yes" xml:space="preserve">
          <source>Foreach is basically a High Order Function, Which takes another function as its parameter.</source>
          <target state="translated">Foreach基本上是一个高阶函数,它把另一个函数作为参数。</target>
        </trans-unit>
        <trans-unit id="8a78ff713dd92b2ecbc101771445889515332055" translate="yes" xml:space="preserve">
          <source>Granted this is a very simple hypothetical example, but I've written triple embedded for loops using the second approach and it was &lt;em&gt;very&lt;/em&gt; hard to read, and write for that matter.</source>
          <target state="translated">当然，这是一个非常简单的假设示例，但是我使用第二种方法编写了三重嵌入式for循环，因此很难读取和编写。</target>
        </trans-unit>
        <trans-unit id="4007b162af20ada18ae8a52aec1f5ada3364061d" translate="yes" xml:space="preserve">
          <source>Host objects may implement these internal methods in any manner unless specified otherwise; for example, one possibility is that &lt;code&gt;[[Get]]&lt;/code&gt; and &lt;code&gt;[[Put]]&lt;/code&gt; for a particular host object indeed fetch and store property values but &lt;code&gt;[[HasProperty]]&lt;/code&gt; always generates &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">除非另有说明，否则宿主对象可以任何方式实现这些内部方法。 例如，一种可能性是特定宿主对象的 &lt;code&gt;[[Get]]&lt;/code&gt; 和 &lt;code&gt;[[Put]]&lt;/code&gt; 确实会获取并存储属性值，但 &lt;code&gt;[[HasProperty]]&lt;/code&gt; 始终会生成&lt;strong&gt;false&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="19813696848672a3c1fd16a6dcede994e8b0ea3c" translate="yes" xml:space="preserve">
          <source>How can I loop through all the entries in an array using JavaScript?</source>
          <target state="translated">如何使用JavaScript循环浏览数组中的所有条目?</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">它是如何运作的?</target>
        </trans-unit>
        <trans-unit id="ca7b3040f56acb6407fc724b0d2fd827a45691bf" translate="yes" xml:space="preserve">
          <source>However in practice that is &lt;strong&gt;not&lt;/strong&gt; actually a reliable indication of intent, since it is indistinguishable from those occasions when you &lt;strong&gt;&lt;em&gt;do&lt;/em&gt;&lt;/strong&gt; care about the order, and really do &lt;strong&gt;&lt;em&gt;need&lt;/em&gt;&lt;/strong&gt; to loop in reverse.  So in fact another construct would be needed to accurately express the &quot;don't care&quot; intent, something currently unavailable in most languages, including ECMAScript, but which could be called, for example, &lt;code&gt;forEachUnordered()&lt;/code&gt;.</source>
          <target state="translated">但是实际上，这实际上&lt;strong&gt;并不是&lt;/strong&gt;意图的可靠指示，因为与您关心订单的情况并确实&lt;strong&gt;&lt;em&gt;需要&lt;/em&gt;&lt;/strong&gt;反向循环时，这是无法区分的。 因此，实际上，将需要另一种构造来准确表达&amp;ldquo;不在乎&amp;rdquo;的意图，这在大多数语言（包括ECMAScript）中目前尚不可用，但是可以将其称为例如 &lt;code&gt;forEachUnordered()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61f75f3469a29e1942e3c3329af27ea060513a5e" translate="yes" xml:space="preserve">
          <source>However, note that there may be reasons to use an even simpler &lt;code&gt;for&lt;/code&gt; loop (see Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504&quot;&gt;Why is using &amp;ldquo;for&amp;hellip;in&amp;rdquo; with array iteration such a bad idea?&lt;/a&gt;&lt;/em&gt;)</source>
          <target state="translated">但是，请注意，可能有理由使用甚至更简单的 &lt;code&gt;for&lt;/code&gt; 循环（请参阅Stack Overflow问题， &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504&quot;&gt;为什么在数组迭代中使用&amp;ldquo; for&amp;hellip;in&amp;rdquo;是个坏主意？&lt;/a&gt;&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="a6aed835f2d563c4c3320a911d587d82dbda800c" translate="yes" xml:space="preserve">
          <source>I also would like to add this as a composition of a reverse loop and an answer above for someone that would like this syntax too.</source>
          <target state="translated">我还想把这个作为一个反向循环的组成和上面的答案补充一下,希望有人也喜欢这个语法。</target>
        </trans-unit>
        <trans-unit id="8477c992b5ade4df47cd7654aa1828b412e4a489" translate="yes" xml:space="preserve">
          <source>I know this is an old post, and there are so many great answers already. For a little more completeness I figured I'd throw in another one using &lt;a href=&quot;https://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;. Of course, this only applies if you're using Angular, obviously, nonetheless I'd like to put it anyway.</source>
          <target state="translated">我知道这是一篇旧文章，并且已经有很多不错的答案。 为了更加完整，我想我会使用&lt;a href=&quot;https://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;抛出另一个。 当然，仅当您使用Angular时，这才适用，尽管如此，无论如何我还是想放它。</target>
        </trans-unit>
        <trans-unit id="1c59ff4d9355404cf9a4b93a2e4792e99f5c4e05" translate="yes" xml:space="preserve">
          <source>I think the &lt;em&gt;reverse&lt;/em&gt; for loop deserves a mention here:</source>
          <target state="translated">我认为&lt;em&gt;反向&lt;/em&gt; for循环在这里值得一提：</target>
        </trans-unit>
        <trans-unit id="f6502d93534ccbe12812234fb241d45f4ba61f26" translate="yes" xml:space="preserve">
          <source>I thought it was something like this:</source>
          <target state="translated">我以为是这样的</target>
        </trans-unit>
        <trans-unit id="3603f48e92361f2a2fc432d1e620a715ff3fe622" translate="yes" xml:space="preserve">
          <source>I usually use the</source>
          <target state="translated">我通常用的是</target>
        </trans-unit>
        <trans-unit id="12bc6fc52aa07da9df836fd7799f22941f498dc1" translate="yes" xml:space="preserve">
          <source>I'll quickly note that you can use the ES2015 options &lt;em&gt;now&lt;/em&gt;, even on ES5 engines, by &lt;em&gt;transpiling&lt;/em&gt; ES2015 to ES5. Search for &quot;ES2015 transpiling&quot; / &quot;ES6 transpiling&quot; for more...</source>
          <target state="translated">我会很快注意到，您&lt;em&gt;现在&lt;/em&gt;可以通过将&lt;em&gt;ES2015&lt;/em&gt;转换为ES5，甚至在ES5引擎上使用ES2015选项。 搜索&amp;ldquo; ES2015 transpiling&amp;rdquo; /&amp;ldquo; ES6 transpiling&amp;rdquo;以了解更多...</target>
        </trans-unit>
        <trans-unit id="18c6f30a69467c4462f7d6abc615a72db576f06d" translate="yes" xml:space="preserve">
          <source>I'm sure there's various other pros and cons as well, and please feel free to add any that you see fit. I feel that, bottom line, if you need efficiency, stick with just the native &lt;code&gt;for&lt;/code&gt; loop for your looping needs. But, if your datasets are smaller and a some efficiency is okay to give up in exchange for readability and writability, then by all means throw an &lt;code&gt;angular.forEach&lt;/code&gt; in that bad boy.</source>
          <target state="translated">我敢肯定，还有其他各种利弊，请随时添加您认为合适的任何内容。 我认为，最重要的是，如果您需要效率，请坚持使用本机 &lt;code&gt;for&lt;/code&gt; 循环来满足您的循环需求。 但是，如果您的数据集较小，并且为了交换可读性和可写性而放弃某种效率是可以的，那么 &lt;code&gt;angular.forEach&lt;/code&gt; 在那个坏男孩中抛出一个angular.forEach 。</target>
        </trans-unit>
        <trans-unit id="06ac5670940bbfb285c1ba0308b4821c84d5e171" translate="yes" xml:space="preserve">
          <source>If available, &lt;code&gt;angular.forEach&lt;/code&gt; will use the ES5 forEach loop. Now, I will get to efficientcy in the cons section, as the forEach loops are &lt;em&gt;much&lt;/em&gt; slower than the for loops. I mention this as a pro because it's nice to be consistent and standardized.</source>
          <target state="translated">如果可用， &lt;code&gt;angular.forEach&lt;/code&gt; 将使用ES5 forEach循环。 现在，我将在cons部分中提高效率，因为forEach循环比for循环慢得多。 我将其作为专业人士提及是因为保持一致和标准化非常好。</target>
        </trans-unit>
        <trans-unit id="e8907402896b09c17431fc05797665a93d1d2ebc" translate="yes" xml:space="preserve">
          <source>If order doesn't matter, and &lt;strong&gt;efficiency&lt;/strong&gt; is a concern (in the innermost loop of a game or animation engine), then it may be acceptable to use the reverse for loop as your go-to pattern.  Just remember that seeing a reverse for loop in existing code &lt;strong&gt;does not necessarily mean&lt;/strong&gt; that the order irrelevant!</source>
          <target state="translated">如果顺序无关紧要，并且&lt;strong&gt;效率&lt;/strong&gt;是一个问题（在游戏或动画引擎的最内部循环中），则可以将反向for循环用作您的首选模式。 只要记住，在现有代码&lt;strong&gt;中&lt;/strong&gt;看到反向for循环&lt;strong&gt;并不一定意味着&lt;/strong&gt;顺序无关紧要！</target>
        </trans-unit>
        <trans-unit id="b80d2d2ba2c3b20f6e937c93c538d0e0be32e646" translate="yes" xml:space="preserve">
          <source>If the length of the array won't change during the loop, and it's in performance-sensitive code (unlikely), a slightly more complicated version grabbing the length up front might be a &lt;strong&gt;&lt;em&gt;tiny&lt;/em&gt;&lt;/strong&gt; bit faster:</source>
          <target state="translated">如果数组的长度在循环期间不会改变，并且是对性能敏感的代码（不太可能），那么稍微复杂一些的数组抢占长度可能会快一点：</target>
        </trans-unit>
        <trans-unit id="b92dceb455d82f7bd9cef350ebca0d33e590aa5b" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;modify the array&lt;/strong&gt; while looping, at or after index &lt;em&gt;i&lt;/em&gt; (for example you remove or insert an item at &lt;code&gt;array[i]&lt;/code&gt;), then a forward loop would skip the item that shifted left into position &lt;em&gt;i&lt;/em&gt;, or re-process the &lt;em&gt;i&lt;/em&gt;th item that was shifted right.  In a traditional for loop, you &lt;em&gt;could&lt;/em&gt; update &lt;em&gt;i&lt;/em&gt; to point to the next item that needs processing - 1, but simply reversing the direction of iteration is often a &lt;strong&gt;simpler&lt;/strong&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/23186254/javascript-splice-changing-earlier-values-in-an-array/23186450#23186450&quot;&gt;more elegant solution&lt;/a&gt;.</source>
          <target state="translated">如果在循环时，在索引&lt;em&gt;i&lt;/em&gt;处或索引&lt;em&gt;i&lt;/em&gt;之后&lt;strong&gt;修改数组&lt;/strong&gt; （例如，在 &lt;code&gt;array[i]&lt;/code&gt; 处删除或插入项目），则正向循环将跳过向左移到位置&lt;em&gt;i的项目&lt;/em&gt; ，或重新处理&lt;em&gt;i&lt;/em&gt;右移的项目。 在传统的for循环中，您&lt;em&gt;可以&lt;/em&gt;更新&lt;em&gt;i&lt;/em&gt;以指向需要处理的下一个项目-1，但是简单地反转迭代方向通常是一个&lt;strong&gt;更简单&lt;/strong&gt; ， &lt;a href=&quot;https://stackoverflow.com/questions/23186254/javascript-splice-changing-earlier-values-in-an-array/23186450#23186450&quot;&gt;更优雅的解决方案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e64946b63608dcfc94ea160317714137b7354db" translate="yes" xml:space="preserve">
          <source>If you are a jQuery &lt;em&gt;fan&lt;/em&gt; and already have a jQuery file running, you should reverse the positions of the index and value parameters</source>
          <target state="translated">如果您是jQuery &lt;em&gt;爱好者&lt;/em&gt;并且已经在运行jQuery文件，则应反转index和value参数的位置</target>
        </trans-unit>
        <trans-unit id="13ddd4cb90755914bc68cb46a5dcb9579aa341e2" translate="yes" xml:space="preserve">
          <source>If you don't mind emptying the array:</source>
          <target state="translated">如果你不介意清空阵列。</target>
        </trans-unit>
        <trans-unit id="ae87d418a37aaf3cda30fae440c63ffde95ff67b" translate="yes" xml:space="preserve">
          <source>If you had five divs, you'd get &quot;Index is: 0&quot; if you clicked the first and &quot;Index is: 4&quot; if you clicked the last. This does &lt;strong&gt;not&lt;/strong&gt; work if you use &lt;code&gt;var&lt;/code&gt; instead of &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">如果您有五个div，则单击第一个将获得&amp;ldquo;索引为：0&amp;rdquo;，如果单击最后一个则将获得&amp;ldquo;索引为：4&amp;rdquo;。 如果使用 &lt;code&gt;var&lt;/code&gt; 而不是 &lt;code&gt;let&lt;/code&gt; ,则此方法不起作用。</target>
        </trans-unit>
        <trans-unit id="5d8e10b19a52f515f5ce1b1b685c8f30f79143a6" translate="yes" xml:space="preserve">
          <source>If you have a massive array you should use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt;&lt;strong&gt;&lt;code&gt;iterators&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; to gain some efficiency. Iterators are a property of certain JavaScript collections (like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;). Even, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt;&lt;code&gt;for..of&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; uses &lt;strong&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/strong&gt; under-the-hood.</source>
          <target state="translated">如果您有大量数组，则应使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt;&lt;strong&gt; &lt;code&gt;iterators&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;以提高效率。 迭代器是某些JavaScript集合（例如&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; ， &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; ， &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; ， &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; ）的属性。 甚至&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt; &lt;code&gt;for..of&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;在&lt;strong&gt;后台&lt;/strong&gt;使用&lt;strong&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="937ed980f598e6ed46ab0a45f6808c763154dc2c" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;Array.prototype&lt;/code&gt; functions with &lt;em&gt;host-provided&lt;/em&gt; array-like objects (DOM lists and other things provided by the browser rather than the JavaScript engine), you need to be sure to test in your target environments to make sure the host-provided object behaves properly. &lt;strong&gt;Most do behave properly&lt;/strong&gt; (now), but it's important to test. The reason is that most of the &lt;code&gt;Array.prototype&lt;/code&gt; methods you're likely to want to use rely on the host-provided object giving an honest answer to the abstract &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p&quot;&gt;&lt;code&gt;[[HasProperty]]&lt;/code&gt;&lt;/a&gt; operation. As of this writing, browsers do a very good job of this, but the 5.1 spec did allow for the possibility a host-provided object may not be honest. It's in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2&quot;&gt;&amp;sect;8.6.2&lt;/a&gt;, several paragraphs below the big table near the beginning of that section), where it says:</source>
          <target state="translated">如果将 &lt;code&gt;Array.prototype&lt;/code&gt; 函数与&lt;em&gt;主机提供&lt;/em&gt;的类似数组的对象（DOM列表和浏览器而不是JavaScript引擎提供的其他东西）一起使用，则需要确保在目标环境中进行测试以确保主机提供了对象行为正常。 &lt;strong&gt;大多数&lt;/strong&gt; （现在） &lt;strong&gt;确实表现正常&lt;/strong&gt; ，但是测试很重要。 原因是您可能要使用的大多数 &lt;code&gt;Array.prototype&lt;/code&gt; 方法都依赖于主机提供的对象，该对象为抽象&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p&quot;&gt; &lt;code&gt;[[HasProperty]]&lt;/code&gt; &lt;/a&gt;操作提供了诚实的答案。 在撰写本文时，浏览器在这方面做得很好，但是5.1规范确实允许由主机提供的对象可能不诚实。 在&lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2&quot;&gt;&amp;sect;8.6.2中&lt;/a&gt; ，该部分开头附近的大表下方的几段中），其中表示：</target>
        </trans-unit>
        <trans-unit id="1cf65717377f5a0ffbf4016aa7b65a5777d9b6bb" translate="yes" xml:space="preserve">
          <source>If you want to break, a little more logic:</source>
          <target state="translated">如果你想打破的话,逻辑性要强一点。</target>
        </trans-unit>
        <trans-unit id="1aae02233e247aceba4786eb942d19b76a8c3c1d" translate="yes" xml:space="preserve">
          <source>If you want to loop over an array, use the standard three-part &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">如果要遍历数组，请使用标准的三部分式 &lt;code&gt;for&lt;/code&gt; 循环。</target>
        </trans-unit>
        <trans-unit id="11105b5c63e872bf555853378e76dfee57d8fded" translate="yes" xml:space="preserve">
          <source>If you want to loop through an array of objects with the arrow function:</source>
          <target state="translated">如果你想用箭头函数在一个对象的数组中循环使用。</target>
        </trans-unit>
        <trans-unit id="986435ae4b5acc19dfcae749d8f1c3e4994226d8" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;for()&lt;/code&gt;, it will look like -</source>
          <target state="translated">如果要使用 &lt;code&gt;for()&lt;/code&gt; ，它将看起来像-</target>
        </trans-unit>
        <trans-unit id="4acb3d06d2c92261570911bf5c1b6824ec6805ec" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;forEach()&lt;/code&gt;, it will look like -</source>
          <target state="translated">如果要使用 &lt;code&gt;forEach()&lt;/code&gt; ，它将看起来像-</target>
        </trans-unit>
        <trans-unit id="5fc44f65228be3d46253870a654fc920e523f6cf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the &lt;a href=&quot;http://jquery.com/&quot;&gt;&lt;strong&gt;jQuery&lt;/strong&gt;&lt;/a&gt; library, you can use &lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;&lt;strong&gt;jQuery.each&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;http://jquery.com/&quot;&gt;&lt;strong&gt;jQuery&lt;/strong&gt;&lt;/a&gt;库，则可以使用&lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;&lt;strong&gt;jQuery.each&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="6a9d6ebddd744df1593bd5988193105784652f8b" translate="yes" xml:space="preserve">
          <source>If you're going to do that a lot, you might want to grab a copy of the function reference into a variable for reuse, e.g.:</source>
          <target state="translated">如果你要经常这样做,你可能会想把函数引用抓取一份拷贝到一个变量中以备重用,例如。</target>
        </trans-unit>
        <trans-unit id="dd131ceaa21a63af287b484051a159dfdece2176" translate="yes" xml:space="preserve">
          <source>If you're worried about the runtime cost of making a function call for each array entry, don't be; &lt;a href=&quot;http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html&quot;&gt;details&lt;/a&gt;.</source>
          <target state="translated">如果您担心为每个数组条目进行函数调用的运行时成本，请不必担心； &lt;a href=&quot;http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html&quot;&gt;细节&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="40638a60a037cede5301ef987dee8d1ace1a9b0f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt; there will be a forEach method on the array prototype, but it is not supported in legacy browsers. So to be able to use it consistently you must either have an environment that supports it (for example, &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; for server side JavaScript), or use a &quot;Polyfill&quot;. The Polyfill for this functionality is, however, trivial and since it makes the code easier to read, it is a good polyfill to include.</source>
          <target state="translated">在&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5中&lt;/a&gt; ，数组原型上将有一个forEach方法，但是旧版浏览器不支持该方法。 因此，要能够始终如一地使用它，您必须具有一个支持它的环境（例如，用于服务器端JavaScript的&lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; ），或使用&amp;ldquo; Polyfill&amp;rdquo;。 但是，用于此功能的Polyfill很简单，并且由于它使代码更易于阅读，因此可以很好地包含它。</target>
        </trans-unit>
        <trans-unit id="1280ba4c719753e18ee74f317b64294340b96082" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in&quot;&gt;for_each...in&lt;/a&gt;&lt;/em&gt; (MDN) it is explained that &lt;code&gt;for each (variable in object)&lt;/code&gt; is deprecated as the part of ECMA-357 (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/E4X&quot;&gt;EAX&lt;/a&gt;) standard.</source>
          <target state="translated">在&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in&quot;&gt;for_each ... in&lt;/a&gt;&lt;/em&gt; （MDN）中，将解释 &lt;code&gt;for each (variable in object)&lt;/code&gt; 已被弃用为ECMA-357（ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/E4X&quot;&gt;EAX&lt;/a&gt; ）标准的一部分。</target>
        </trans-unit>
        <trans-unit id="9beb0c3410927f822bce0dcb01f44ccc46812376" translate="yes" xml:space="preserve">
          <source>In ES2015 and higher, you can make your index and value variables local to the &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">在ES2015及更高版本中，可以将索引和值变量设置为 &lt;code&gt;for&lt;/code&gt; 循环的本地变量：</target>
        </trans-unit>
        <trans-unit id="2cd3e11ca52c117696a761c0998ed90bfcd20a96" translate="yes" xml:space="preserve">
          <source>In any vaguely-modern environment (so, not IE8) where you have access to the &lt;code&gt;Array&lt;/code&gt; features added by ES5 (directly or using polyfills), you can use &lt;code&gt;forEach&lt;/code&gt; (&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt;&lt;code&gt;spec&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;MDN&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">在任何可以访问由ES5添加的 &lt;code&gt;Array&lt;/code&gt; 功能（直接或使用polyfills）的模糊现代环境（因此，不是IE8）中，都可以使用 &lt;code&gt;forEach&lt;/code&gt; （ &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt; &lt;code&gt;spec&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;MDN&lt;/code&gt; &lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="b3516d7a0d41bd0df93ef14853544e18b99e2cde" translate="yes" xml:space="preserve">
          <source>In case, more interested on operation on array using some inbuilt feature.</source>
          <target state="translated">如果,对使用一些内置的功能对数组操作更感兴趣。</target>
        </trans-unit>
        <trans-unit id="99006d079057d1e0af6e98a54c83d22f0c6ba073" translate="yes" xml:space="preserve">
          <source>In general for higher level code where &lt;strong&gt;clarity and safety&lt;/strong&gt; are greater concerns, I previously recommended using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array::forEach&lt;/code&gt;&lt;/a&gt; as your default pattern for looping (although these days I prefer to use &lt;code&gt;for..of&lt;/code&gt;).  Reasons to prefer &lt;code&gt;forEach&lt;/code&gt; over a reverse loop are:</source>
          <target state="translated">通常，对于更关注&lt;strong&gt;透明度和安全性的&lt;/strong&gt;高级代码，我以前建议使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array::forEach&lt;/code&gt; &lt;/a&gt;作为循环的默认模式（尽管这些天我更喜欢使用 &lt;code&gt;for..of&lt;/code&gt; ）。 选择 &lt;code&gt;forEach&lt;/code&gt; 而不是反向循环的原因是：</target>
        </trans-unit>
        <trans-unit id="268bee6cf2ad84db04fb8978e3c41ceecff7fc38" translate="yes" xml:space="preserve">
          <source>In tests we calculate the sum of array elements. I perform a test for small arrays (10 elements) and big arrays (1M elements) and divide them into three groups:</source>
          <target state="translated">在测试中,我们计算数组元素之和。我对小数组(10个元素)和大数组(1M元素)进行测试,并将其分为三组。</target>
        </trans-unit>
        <trans-unit id="3fb2676f32b14c1a1bbfd3126c8971f3d39c2fe6" translate="yes" xml:space="preserve">
          <source>In the traditional forwards for loop, &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; are interchangeable (as Douglas Crockford points out).  However in the reverse for loop, because our decrement is also our condition expression, we must stick with &lt;code&gt;i--&lt;/code&gt; if we want to process the item at index 0.</source>
          <target state="translated">在传统的循环转发中， &lt;code&gt;i++&lt;/code&gt; 和 &lt;code&gt;++i&lt;/code&gt; 是可互换的（正如Douglas Crockford所指出的）。 但是在相反的for循环中，因为我们的减量也是我们的条件表达式，所以如果要处理索引0处的项，则必须坚持使用 &lt;code&gt;i--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f2a940ef1876e18b0a2d2adbbb0054401c1e001" translate="yes" xml:space="preserve">
          <source>It gives you a free scope for closures.</source>
          <target state="translated">它给了你一个自由的关闭范围。</target>
        </trans-unit>
        <trans-unit id="a26206100bd26a40a1a52fbba4254be28b14f1b7" translate="yes" xml:space="preserve">
          <source>It indicates that &lt;em&gt;i&lt;/em&gt; is not going to be shifted within the block (which is always a possible surprise hiding in long &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; loops).</source>
          <target state="translated">它表明&lt;em&gt;我&lt;/em&gt;不会在块内移动（这总是可能会在long和 &lt;code&gt;while&lt;/code&gt; 循环中隐藏）。</target>
        </trans-unit>
        <trans-unit id="9c1e136ecc6d6ff5b0bb24c065a47cca352d2f77" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;shorter&lt;/strong&gt; to type, and &lt;strong&gt;read&lt;/strong&gt;, than some of the other options available.  Although it loses to &lt;code&gt;forEach()&lt;/code&gt; and to ES6's &lt;code&gt;for ... of&lt;/code&gt;.</source>
          <target state="translated">与其他可用选项相比，它的键入和&lt;strong&gt;读取&lt;/strong&gt; &lt;strong&gt;更短&lt;/strong&gt; 。 尽管 &lt;code&gt;for ... of&lt;/code&gt; &lt;code&gt;forEach()&lt;/code&gt; 和ES6而输了 。</target>
        </trans-unit>
        <trans-unit id="e1592309e0411fe23d697624a6b081cb0ad5da05" translate="yes" xml:space="preserve">
          <source>It is clearer to read.</source>
          <target state="translated">读起来比较清楚。</target>
        </trans-unit>
        <trans-unit id="6fa8793a5b9a126bead6bc588548bf65c1d59eff" translate="yes" xml:space="preserve">
          <source>It is now even better to use for..of!</source>
          <target state="translated">它现在更适合用于...的!</target>
        </trans-unit>
        <trans-unit id="4c654c5e846023844a47e14f6c000b121f5ea18b" translate="yes" xml:space="preserve">
          <source>It looks like the traditional &lt;code&gt;for i&lt;/code&gt; (&lt;strong&gt;Aa&lt;/strong&gt;) is a good choice to write fast code on all browsers.</source>
          <target state="translated">看起来传统 &lt;code&gt;for i&lt;/code&gt; （ &lt;strong&gt;Aa&lt;/strong&gt; ）是在所有浏览器上编写快速代码的不错选择。</target>
        </trans-unit>
        <trans-unit id="b05ec9bd35f4ee8f34e03d2c14bb2cf3574009f2" translate="yes" xml:space="preserve">
          <source>It processes the items in reverse order.  If you were building a new array from the results, or printing things on screen, naturally &lt;strong&gt;the output will be reversed&lt;/strong&gt; with respect to the original order.</source>
          <target state="translated">它以相反的顺序处理项目。 如果您要根据结果构建新的数组，或在屏幕上打印内容，则自然&lt;strong&gt;会&lt;/strong&gt;相对于原始顺序&lt;strong&gt;反转输出&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="92650d012635dc87fe3676b746f2df0b221ba0a1" translate="yes" xml:space="preserve">
          <source>It reduces leakage of local variables and accidental collision with (and mutation of) outer variables.</source>
          <target state="translated">它可以减少局部变量的泄漏,减少与外部变量的意外碰撞(和突变)。</target>
        </trans-unit>
        <trans-unit id="c027793c4fcbf7f7be6aed911c23cf2d476fffe0" translate="yes" xml:space="preserve">
          <source>It returns:</source>
          <target state="translated">它返回了。</target>
        </trans-unit>
        <trans-unit id="5a66b905f75247eeead429833c89c54b6d523c59" translate="yes" xml:space="preserve">
          <source>It was better to use forEach()</source>
          <target state="translated">最好是用forEach()</target>
        </trans-unit>
        <trans-unit id="970da87efbe446de6ff12d27fb12ff80a89bc4c8" translate="yes" xml:space="preserve">
          <source>It's a &lt;a href=&quot;http://en.wikipedia.org/wiki/Sparse_array&quot;&gt;&lt;em&gt;sparse&lt;/em&gt; arrays&lt;/a&gt; with &lt;strong&gt;massive&lt;/strong&gt; gaps in it, or</source>
          <target state="translated">这是一个&lt;a href=&quot;http://en.wikipedia.org/wiki/Sparse_array&quot;&gt;&lt;em&gt;稀疏的&lt;/em&gt;数组，里面&lt;/a&gt;有&lt;strong&gt;巨大的&lt;/strong&gt;空隙，或者</target>
        </trans-unit>
        <trans-unit id="76bb57f065042a04a16fd907fcb40021f5d1d715" translate="yes" xml:space="preserve">
          <source>It's also possible to use ES2015's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread syntax&lt;/a&gt; with JavaScript engines that support this feature:</source>
          <target state="translated">还可以将ES2015的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;扩展语法&lt;/a&gt;与支持此功能的JavaScript引擎一起使用：</target>
        </trans-unit>
        <trans-unit id="cf3b30579b92065eb7bc495af1fbdb1ca47efb2e" translate="yes" xml:space="preserve">
          <source>It's important to note that &lt;code&gt;Array.prototype.forEach&lt;/code&gt; doesn't break when the callback returns &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; provide their own variations on &lt;code&gt;each&lt;/code&gt; to provide loops that can be short-circuited.</source>
          <target state="translated">重要的是要注意，当回调返回 &lt;code&gt;false&lt;/code&gt; 时， &lt;code&gt;Array.prototype.forEach&lt;/code&gt; 不会中断。 &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt;各自提供了自己的变体，以提供可以短路的循环。</target>
        </trans-unit>
        <trans-unit id="8422ffb83ff856b5915a4e7e4e65862872e7a17c" translate="yes" xml:space="preserve">
          <source>Iterators are exhaustible in nature.</source>
          <target state="translated">迭代器在本质上是穷尽的。</target>
        </trans-unit>
        <trans-unit id="dd908ea29f0174193357642014bde7f4f593cc70" translate="yes" xml:space="preserve">
          <source>Iterators improve efficiency by letting you consume the items in a list one at a time as if they were a stream. What makes an iterator special is how it traverses a collection. Other loops need to load the entire collection up front in order to iterate over it, whereas an iterator only needs to know the current position in the collection.</source>
          <target state="translated">迭代器通过让你把列表中的项目像流一样一次一个个地消耗掉,从而提高了效率。迭代器的特别之处在于它如何遍历一个集合。其他的循环需要提前加载整个集合,然后再进行迭代,而迭代器只需要知道集合中的当前位置。</target>
        </trans-unit>
        <trans-unit id="b4cec08cd006bef91b92cd98b872c068dfc6d47a" translate="yes" xml:space="preserve">
          <source>JavaScript has powerful semantics for looping through arrays and array-like objects. I've split the answer into two parts: Options for genuine arrays, and options for things that are just array-&lt;em&gt;like&lt;/em&gt;, such as the &lt;code&gt;arguments&lt;/code&gt; object, other iterable objects (ES2015+), DOM collections, and so on.</source>
          <target state="translated">JavaScript具有用于遍历数组和类似数组的对象的强大语义。 我将答案分为两部分：真正数组的选项，以及仅是数组之&lt;em&gt;类的&lt;/em&gt;东西的选项，例如 &lt;code&gt;arguments&lt;/code&gt; 对象，其他可迭代对象（ES2015 +），DOM集合，等等。</target>
        </trans-unit>
        <trans-unit id="45b89ea7174719fe9456dfc7830bcd1c7b08f842" translate="yes" xml:space="preserve">
          <source>Looking only at that first example: You can use &lt;code&gt;for-in&lt;/code&gt; to visit those sparse array elements if you use appropriate safeguards:</source>
          <target state="translated">仅查看第一个示例：如果使用适当的保护措施，则可以使用 &lt;code&gt;for-in&lt;/code&gt; 访问那些稀疏数组元素：</target>
        </trans-unit>
        <trans-unit id="4839c1708da783319e9fbcbf7bb1edf7ed55c460" translate="yes" xml:space="preserve">
          <source>Loop backwards</source>
          <target state="translated">回环</target>
        </trans-unit>
        <trans-unit id="116eba95b7902da0b19b136ed240ca0e56d035ae" translate="yes" xml:space="preserve">
          <source>No break, continue, or return support. &lt;code&gt;continue&lt;/code&gt; is actually supported by &quot;&lt;a href=&quot;https://github.com/angular/angular.js/issues/263&quot;&gt;accident&lt;/a&gt;&quot;, to continue in an &lt;code&gt;angular.forEach&lt;/code&gt; you simple put a &lt;code&gt;return;&lt;/code&gt; statement in the function like &lt;code&gt;angular.forEach(array, function(item) { if (someConditionIsTrue) return; });&lt;/code&gt; which will cause it to continue out of the function for that iteration. This is also due to the fact that the native &lt;code&gt;forEach&lt;/code&gt; does not support break or continue either.</source>
          <target state="translated">没有中断，继续或返回支持。 &lt;code&gt;continue&lt;/code&gt; 实际上是由&amp;ldquo; &lt;a href=&quot;https://github.com/angular/angular.js/issues/263&quot;&gt;意外&lt;/a&gt; &amp;rdquo;支持的，以一定的角度继续 &lt;code&gt;return;&lt;/code&gt; 函数中的语句，例如 &lt;code&gt;angular.forEach(array, function(item) { if (someConditionIsTrue) return; });&lt;/code&gt; 这将导致它继续超出该迭代的功能。 这也是由于本机 &lt;code&gt;forEach&lt;/code&gt; 不支持break或Continue的事实。</target>
        </trans-unit>
        <trans-unit id="b8c4d2fd6737ec63b08a652d9add0b5b76e57401" translate="yes" xml:space="preserve">
          <source>Note the three checks:</source>
          <target state="translated">注意三查。</target>
        </trans-unit>
        <trans-unit id="98d5f549991350bbddfb1b3e02a8c7d43a397e2d" translate="yes" xml:space="preserve">
          <source>Note, however, that this approach is only good if you have a dense array, and each index is occupied by an element. If the array is sparse, then you can run into performance problems with this approach, since you will iterate over a lot of indices that do not &lt;em&gt;really&lt;/em&gt; exist in the array. In this case, a &lt;code&gt;for .. in&lt;/code&gt;-loop might be a better idea. &lt;strong&gt;However&lt;/strong&gt;, you must use the appropriate safeguards to ensure that only the desired properties of the array (that is, the array elements) are acted upon, since the &lt;code&gt;for..in&lt;/code&gt;-loop will also be enumerated in legacy browsers, or if the additional properties are defined as &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">但是请注意，这种方法仅在数组密集且每个索引都被一个元素占用的情况下才有用。 如果数组稀疏，则使用此方法会遇到性能问题，因为您将遍历数组中&lt;em&gt;实际上&lt;/em&gt;不存在的许多索引。 在这种情况下， &lt;code&gt;for .. in&lt;/code&gt; 。in-loop可能是一个更好的主意。 &lt;strong&gt;但是&lt;/strong&gt; ，您必须使用适当的保护措施以确保仅作用于数组的所需属性（即数组元素），因为 &lt;code&gt;for..in&lt;/code&gt; -loop也将在旧版浏览器中枚举，或者如果其他属性被定义为 &lt;code&gt;enumerable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdb386055d71d4e57655448305f3f266ba898acc" translate="yes" xml:space="preserve">
          <source>Now there are pros and cons of using the &lt;code&gt;angular.forEach&lt;/code&gt; function as opposed to the built in vanilla-flavored &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">现在，使用 &lt;code&gt;angular.forEach&lt;/code&gt; 函数与内置的香草味 &lt;code&gt;for&lt;/code&gt; 循环相比有优缺点。</target>
        </trans-unit>
        <trans-unit id="ca0defbc542adca7eb89b7d006ccdd58542fae1e" translate="yes" xml:space="preserve">
          <source>Objects are not &lt;code&gt;iterable&lt;/code&gt; by default. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for..in&lt;/code&gt;&lt;/a&gt; in that case because instead of values it works with keys.</source>
          <target state="translated">默认情况下，对象不可 &lt;code&gt;iterable&lt;/code&gt; 。 在这种情况下，请使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for..in&lt;/code&gt; &lt;/a&gt; ..，因为它可以代替键使用值。</target>
        </trans-unit>
        <trans-unit id="dac14b18ddbcf811caa6f41435770bfcac91def3" translate="yes" xml:space="preserve">
          <source>Obviously, a simple &lt;code&gt;for&lt;/code&gt; loop applies to array-like objects.</source>
          <target state="translated">显然，简单的 &lt;code&gt;for&lt;/code&gt; 循环适用于类似数组的对象。</target>
        </trans-unit>
        <trans-unit id="0b2eddf2aee3155f4ce4917a2380a892eac5b90f" translate="yes" xml:space="preserve">
          <source>Okay, let's look at our options:</source>
          <target state="translated">好吧,让我们来看看我们的选择。</target>
        </trans-unit>
        <trans-unit id="a72c2c53fbdfb2727533feb058f51addfd63ad98" translate="yes" xml:space="preserve">
          <source>Or if you wanted to get an array of the tag names of the elements with a given class, you'd use the mapping function:</source>
          <target state="translated">或者,如果你想得到一个数组中具有给定类的元素的标签名,你可以使用映射函数。</target>
        </trans-unit>
        <trans-unit id="073b8d82f68c2fdbe0506bde968834e71b06dd49" translate="yes" xml:space="preserve">
          <source>Other times, you may want to convert an array-like object into a true array. Doing that is surprisingly easy:</source>
          <target state="translated">其他时候,你可能想把一个类似数组的对象转换为真正的数组。这样做是非常容易的。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="aab5f282758bebdcb0646ab510ae5cc532d051d9" translate="yes" xml:space="preserve">
          <source>Personally, I tend to use whatever looks easiest to read, unless performance or minification has become a major concern.  So these days I prefer to use &lt;code&gt;for..of&lt;/code&gt; instead of &lt;code&gt;forEach()&lt;/code&gt;, but I will always use &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;&lt;code&gt;some&lt;/code&gt;&lt;/a&gt; when applicable. 
 (For the sake of my colleagues, I rarely use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">就个人而言，我倾向于使用最容易阅读的外观，除非性能或尺寸缩小已成为主要问题。 因此，这些天我更喜欢使用 &lt;code&gt;for..of&lt;/code&gt; 而不是 &lt;code&gt;forEach()&lt;/code&gt; ，但是在适用时，我将始终使用 &lt;code&gt;map&lt;/code&gt; 或 &lt;code&gt;filter&lt;/code&gt; 或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt; &lt;code&gt;some&lt;/code&gt; &lt;/a&gt; 。 （为了我的同事，我很少使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 。）</target>
        </trans-unit>
        <trans-unit id="d3e73cee41706cbf172168c939a770206031ae4a" translate="yes" xml:space="preserve">
          <source>Probably the &lt;code&gt;for(i = 0; i &amp;lt; array.length; i++)&lt;/code&gt; loop is not the best choice. Why? If you have this:</source>
          <target state="translated">可能 &lt;code&gt;for(i = 0; i &amp;lt; array.length; i++)&lt;/code&gt; 循环不是最佳选择。 为什么？ 如果您有这个：</target>
        </trans-unit>
        <trans-unit id="5ca16fb6579631abba9ef29095127fc1724ade2e" translate="yes" xml:space="preserve">
          <source>Repeatedly inserting siblings into the DOM as a first child in order to retain their order is &lt;strong&gt;less efficient&lt;/strong&gt;.  (The browser would keep having to shift things right.)  To create DOM nodes efficiently and in order, just loop forwards and append as normal (and also use a &quot;document fragment&quot;).</source>
          <target state="translated">重复将兄弟姐妹作为第一个孩子插入DOM以保持其顺序&lt;strong&gt;效率较低&lt;/strong&gt; 。 （浏览器将不得不保持正确的状态。）为了高效，有序地创建DOM节点，只需像往常一样循环并追加（并使用&amp;ldquo;文档片段&amp;rdquo;）即可。</target>
        </trans-unit>
        <trans-unit id="c3c204bcc11d0ba16e5b10935b855c9231c60df7" translate="yes" xml:space="preserve">
          <source>Results for Chrome. You can perform the test on your machine &lt;a href=&quot;https://jsbench.me/9uk4bj4svg&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">Chrome的搜索结果。 您可以在&lt;a href=&quot;https://jsbench.me/9uk4bj4svg&quot;&gt;这里&lt;/a&gt;在机器上执行测试</target>
        </trans-unit>
        <trans-unit id="2632a58b332b7d1089e6d3db9b89fa34f55982ee" translate="yes" xml:space="preserve">
          <source>Results for Chrome. You can perform the test on your machine &lt;a href=&quot;https://jsbench.me/pxk4bicjru&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Chrome的搜索结果。 您可以在&lt;a href=&quot;https://jsbench.me/pxk4bicjru&quot;&gt;此处&lt;/a&gt;在机器上执行测试。</target>
        </trans-unit>
        <trans-unit id="2941ce8fc00301085c9d7ce71d82ff621ce0e501" translate="yes" xml:space="preserve">
          <source>Results for all tested browsers</source>
          <target state="translated">所有测试的浏览器的结果</target>
        </trans-unit>
        <trans-unit id="3ab8b51db1affd18d3dd969199d9006feae51589" translate="yes" xml:space="preserve">
          <source>See #4, we'll have to see how iterators play out.</source>
          <target state="translated">见4号,我们要看迭代器如何发挥。</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="b492c5ea4eeb39652fee30d40510ca39a54045aa" translate="yes" xml:space="preserve">
          <source>See the &lt;em&gt;Caveat for host-provided objects&lt;/em&gt; below. In particular, note that this will fail in IE8 and earlier, which don't let you use host-provided objects as &lt;code&gt;this&lt;/code&gt; like that.</source>
          <target state="translated">请参阅下面的&lt;em&gt;警告，了解主机提供的对象&lt;/em&gt; 。 特别要注意的是，这将在IE8及更早版本中失败，因此不能像 &lt;code&gt;this&lt;/code&gt; 使用主机提供的对象。</target>
        </trans-unit>
        <trans-unit id="919b9d8e3baf041ad3035d3f106002059a32c5a7" translate="yes" xml:space="preserve">
          <source>Should I always use it?</source>
          <target state="translated">我应该经常使用吗?</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">显示代码片段</target>
        </trans-unit>
        <trans-unit id="90d4fe421bc14a9a7cd0cfb17b98bb87c323df29" translate="yes" xml:space="preserve">
          <source>Similarly, when modifying or removing &lt;strong&gt;nested&lt;/strong&gt; DOM elements, processing in reverse can &lt;strong&gt;circumvent errors&lt;/strong&gt;. For example, consider modifying the innerHTML of a parent node before handling its children.  By the time the child node is reached it will be detached from the DOM, having been replaced by a newly created child when the parent's innerHTML was written.</source>
          <target state="translated">类似地，在修改或删除&lt;strong&gt;嵌套的&lt;/strong&gt; DOM元素时，反向处理&lt;strong&gt;可以避免错误&lt;/strong&gt; 。 例如，考虑在处理父节点的子节点之前修改其内部HTML。 到子节点到达时，它将与DOM分离，在编写父节点的innerHTML时已被新创建的子节点替换。</target>
        </trans-unit>
        <trans-unit id="9042b86e2d8972b544eebed08f73160765222f7f" translate="yes" xml:space="preserve">
          <source>So for instance, if we want to convert a &lt;code&gt;NodeList&lt;/code&gt; into a true array, we could do this:</source>
          <target state="translated">因此，例如，如果我们想将 &lt;code&gt;NodeList&lt;/code&gt; 转换为一个真实的数组，我们可以这样做：</target>
        </trans-unit>
        <trans-unit id="1271c2d1e2ea0178abb1749d433619d8ba114b52" translate="yes" xml:space="preserve">
          <source>So for instance, if we want to convert a &lt;code&gt;NodeList&lt;/code&gt; into a true array, with spread syntax this becomes quite succinct:</source>
          <target state="translated">因此，例如，如果我们想将 &lt;code&gt;NodeList&lt;/code&gt; 转换为一个真实的数组，使用扩展语法，这将变得非常简洁：</target>
        </trans-unit>
        <trans-unit id="d778f77d45108db7a7e4ef37756d652130403fa5" translate="yes" xml:space="preserve">
          <source>So on the final iteration, &lt;em&gt;i&lt;/em&gt; was previously &lt;strong&gt;1&lt;/strong&gt; and the &lt;code&gt;i--&lt;/code&gt; expression changes it to &lt;strong&gt;0&lt;/strong&gt; but actually yields &lt;strong&gt;1&lt;/strong&gt; (truthy), and so the condition passes.  On the next iteration &lt;code&gt;i--&lt;/code&gt; changes &lt;em&gt;i&lt;/em&gt; to &lt;strong&gt;-1&lt;/strong&gt; but yields &lt;strong&gt;0&lt;/strong&gt; (falsey), causing execution to immediately drop out of the bottom of the loop.</source>
          <target state="translated">因此，在最后一次迭代中， &lt;em&gt;i&lt;/em&gt;以前为&lt;strong&gt;1&lt;/strong&gt; ， &lt;code&gt;i--&lt;/code&gt; 表达式将其更改为&lt;strong&gt;0，&lt;/strong&gt;但实际上产生&lt;strong&gt;1&lt;/strong&gt; （真实），因此条件通过。 在下一次迭代中， &lt;code&gt;i--&lt;/code&gt; 将&lt;em&gt;i&lt;/em&gt;更改为&lt;strong&gt;-1，&lt;/strong&gt;但产生&lt;strong&gt;0&lt;/strong&gt; （假），从而导致执行立即退出循环的底部。</target>
        </trans-unit>
        <trans-unit id="ec2c077f94e3ef98852872b7d08256a523f61745" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt;-style languages use &lt;code&gt;foreach&lt;/code&gt; to loop through enumerations. In JavaScript this is done with the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for..in&lt;/code&gt; loop structure&lt;/a&gt;:</source>
          <target state="translated">一些&lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt;风格的语言使用 &lt;code&gt;foreach&lt;/code&gt; 遍历枚举。 在JavaScript中，这是通过&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for..in&lt;/code&gt; 循环结构完成的&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="941bae0ecab27ddc205e29dd3a6d3b3bc8f9e89d" translate="yes" xml:space="preserve">
          <source>Some developers use the reverse for loop &lt;em&gt;by default&lt;/em&gt;, unless there is a good reason to loop forwards.</source>
          <target state="translated">某些开发人员&lt;em&gt;默认情况下&lt;/em&gt;使用反向for循环，除非有充分的理由进行向前循环。</target>
        </trans-unit>
        <trans-unit id="3163e5ac5c4f789da55694f27cb9f6c55a337dd5" translate="yes" xml:space="preserve">
          <source>Some people like to draw a little arrow in the reverse &lt;code&gt;for&lt;/code&gt; loop, and end with a wink:</source>
          <target state="translated">有些人喜欢在反面 &lt;code&gt;for&lt;/code&gt; 循环画一个小箭头，并以眨眼结束：</target>
        </trans-unit>
        <trans-unit id="b119d6cd5c4dc707a6167c6c075b24e4d7be734d" translate="yes" xml:space="preserve">
          <source>Sometimes the old ways are the best:</source>
          <target state="translated">有时候,老办法是最好的。</target>
        </trans-unit>
        <trans-unit id="59f86f5e3b9995bc329f5d4bc79c9d16c81b5fba" translate="yes" xml:space="preserve">
          <source>Sometimes, you might want to use an iterator &lt;em&gt;explicitly&lt;/em&gt;. You can do that, too, although it's a lot clunkier than &lt;code&gt;for-of&lt;/code&gt;. It looks like this:</source>
          <target state="translated">有时，您可能想&lt;em&gt;显式&lt;/em&gt;使用迭代器。 您也可以这样做，尽管它比 &lt;code&gt;for-of&lt;/code&gt; 笨拙得多。 看起来像这样：</target>
        </trans-unit>
        <trans-unit id="c7657c048f2c02f83c5e4cef8d5cbd16b976ff8a" translate="yes" xml:space="preserve">
          <source>Suppose you wanted to use &lt;code&gt;forEach&lt;/code&gt; on a &lt;code&gt;Node&lt;/code&gt;'s &lt;code&gt;childNodes&lt;/code&gt; property. You'd do this:</source>
          <target state="translated">假设您要在 &lt;code&gt;Node&lt;/code&gt; 的 &lt;code&gt;childNodes&lt;/code&gt; 属性上使用 &lt;code&gt;forEach&lt;/code&gt; 。 您可以这样做：</target>
        </trans-unit>
        <trans-unit id="2870c360b6a5c3b4d815964ddecea3817c257c4c" translate="yes" xml:space="preserve">
          <source>That the key is all decimal digits (e.g., normal string form, not scientific notation), and</source>
          <target state="translated">键是所有的小数位(例如,正常的字符串形式,科学符号),以及</target>
        </trans-unit>
        <trans-unit id="dce363e4d7896cca416fa7202976d0faa93b7cb7" translate="yes" xml:space="preserve">
          <source>That the key's value when coerced to a number is &amp;lt;= 2^32 - 2 (which is 4,294,967,294). Where does that number come from? It's part of the definition of an array index &lt;a href=&quot;https://tc39.github.io/ecma262/#array-index&quot;&gt;in the specification&lt;/a&gt;. Other numbers (non-integers, negative numbers, numbers greater than 2^32 - 2) are not array indexes. The reason it's 2^32 - &lt;strong&gt;2&lt;/strong&gt; is that that makes the greatest index value one lower than 2^32 - &lt;strong&gt;1&lt;/strong&gt;, which is the maximum value an array's &lt;code&gt;length&lt;/code&gt; can have. (E.g., an array's length fits in a 32-bit unsigned integer.) &lt;em&gt;(Props to RobG for pointing out in a comment &lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;on my blog post&lt;/a&gt; that my previous test wasn't quite right.)&lt;/em&gt;</source>
          <target state="translated">该键的值在被强制为数字时为&amp;lt;= 2 ^ 32-2（即4,294,967,294）。 这个数字从哪里来？ 它是&lt;a href=&quot;https://tc39.github.io/ecma262/#array-index&quot;&gt;规范中&lt;/a&gt;数组索引定义的一部分。 其他数字（非整数，负数，大于2 ^ 32-2的数字）不是数组索引。 之所以是2 ^ 32-2，是因为它使最大索引值比2 ^ 32-1（即数组 &lt;code&gt;length&lt;/code&gt; 可以具有的最大值）低一个。 （例如，数组的长度适合32位无符号整数。） &lt;em&gt;（向RobG表示支持，在&lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;我的博客文章&lt;/a&gt;的评论中指出我先前的测试不太正确。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a83ef01e292828af9f95ea6fd3cb1ad1a7e9b181" translate="yes" xml:space="preserve">
          <source>That the object has its &lt;em&gt;own&lt;/em&gt; property by that name (not one it inherits from its prototype), and</source>
          <target state="translated">该对象具有该名称的&lt;em&gt;自身&lt;/em&gt;属性（不是从其原型继承&lt;em&gt;的&lt;/em&gt;属性），并且</target>
        </trans-unit>
        <trans-unit id="410be7b6d8de783ae1460eb1fb1c418447a833c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i--&lt;/code&gt; like solutions where the loop starts from the last array element (&lt;strong&gt;Ac, Bc&lt;/strong&gt;) are usually ~30% slower than forward solutions - probably the reason is the way of &lt;a href=&quot;https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus&quot;&gt;CPU memory cache working&lt;/a&gt; - forward memory reading is more optimal for CPU caching). &lt;strong&gt;Is recommended to NOT USE such solutions.&lt;/strong&gt;</source>
          <target state="translated">循环从最后一个数组元素（ &lt;strong&gt;Ac，Bc&lt;/strong&gt; ）开始的 &lt;code&gt;i--&lt;/code&gt; like解决方案通常比正向解决方案慢30％-可能是因为&lt;a href=&quot;https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus&quot;&gt;CPU内存缓存的工作方式&lt;/a&gt; -前向存储器读取对于CPU而言更理想缓存）。 &lt;strong&gt;建议不要使用此类解决方案。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50fab3bc0666321dff613699d5e26402e68c7f7f" translate="yes" xml:space="preserve">
          <source>The benefit for this: You have the reference already in the first like that won't need to be declared later with another line. It is handy when looping trough the object array.</source>
          <target state="translated">这样做的好处。你在前面的引用中已经有了,不需要在后面再用另一行声明。当在对象数组中循环时,它很方便。</target>
        </trans-unit>
        <trans-unit id="8e2dba3330af35406fa3d1420af1173d75e136d6" translate="yes" xml:space="preserve">
          <source>The braces (&lt;code&gt;{}&lt;/code&gt;) can be omitted when there is only one command (e.g. in the example above).</source>
          <target state="translated">当只有一个命令时（例如，在上面的示例中），可以省略花括号（ &lt;code&gt;{}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c098c9f1a959378486a97457d4178958264ad2ec" translate="yes" xml:space="preserve">
          <source>The following examples will use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/a&gt; statement and the &lt;a href=&quot;https://developer.mozilla.org/ro/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;.forEach&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">以下示例将使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/a&gt;语句和&lt;a href=&quot;https://developer.mozilla.org/ro/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;.forEach&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="3a00e7fa39a3bdf93692adc3a257b29ca0ee5020" translate="yes" xml:space="preserve">
          <source>The iterator is an object matching the Iterator definition in the specification. Its &lt;code&gt;next&lt;/code&gt; method returns a new &lt;em&gt;result object&lt;/em&gt; each time you call it. The result object has a property, &lt;code&gt;done&lt;/code&gt;, telling us whether it's done, and a property &lt;code&gt;value&lt;/code&gt; with the value for that iteration. (&lt;code&gt;done&lt;/code&gt; is optional if it would be &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is optional if it would be &lt;code&gt;undefined&lt;/code&gt;.)</source>
          <target state="translated">迭代器是与规范中的迭代器定义匹配的对象。 每次调用它的 &lt;code&gt;next&lt;/code&gt; 方法都会返回一个新的&lt;em&gt;结果对象&lt;/em&gt; 。 结果对象具有一个属性 &lt;code&gt;done&lt;/code&gt; ，告诉我们是否已完成，以及一个具有该迭代值的属性 &lt;code&gt;value&lt;/code&gt; 。 （如果为 &lt;code&gt;false&lt;/code&gt; ，则 &lt;code&gt;done&lt;/code&gt; 是可选的；如果 &lt;code&gt;undefined&lt;/code&gt; ，则 &lt;code&gt;value&lt;/code&gt; 是可选的。）</target>
        </trans-unit>
        <trans-unit id="fb536e6fcbd5fa797f6c5702a97e23e4c75f5773" translate="yes" xml:space="preserve">
          <source>The lambda syntax doesn't usually work in Internet&amp;nbsp;Explorer&amp;nbsp;10  or below.</source>
          <target state="translated">Lambda语法通常在Internet Explorer 10或更低版本中不起作用。</target>
        </trans-unit>
        <trans-unit id="866f22286c83f5903a913086e3b75aeeb2603c3c" translate="yes" xml:space="preserve">
          <source>The loop will stop iterating when the condition &lt;code&gt;i--&lt;/code&gt; evaluates to a falsey value (when it yields 0).</source>
          <target state="translated">当条件 &lt;code&gt;i--&lt;/code&gt; 评估为假值时（当产生0时），循环将停止迭代。</target>
        </trans-unit>
        <trans-unit id="80992ad230888519239affffa93744a318eb6afc" translate="yes" xml:space="preserve">
          <source>The loops with array length cached in &lt;code&gt;n&lt;/code&gt; (&lt;strong&gt;Ab, Bb, Be&lt;/strong&gt;) are sometimes faster, sometimes not. Probably compilers automatically detect this situation and introduce caching. The speed differences between the cached and no-cached versions (&lt;strong&gt;Aa, Ba, Bd&lt;/strong&gt;) are about ~1%, so it looks like introduce &lt;code&gt;n&lt;/code&gt; is a &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;micro-optimisation&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">数组长度在 &lt;code&gt;n&lt;/code&gt; （ &lt;strong&gt;Ab，Bb，Be&lt;/strong&gt; ）中缓存的循环有时会更快，有时却不会。 编译器可能会自动检测到这种情况并引入缓存。 缓存版本和非缓存版本（ &lt;strong&gt;Aa，Ba，Bd&lt;/strong&gt; ）之间的速度差异约为1％，因此，引入 &lt;code&gt;n&lt;/code&gt; 似乎是一个&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;微优化&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e52b46122ec0efd9e5bc3d7eec0fac027826ce2" translate="yes" xml:space="preserve">
          <source>The meaning of &lt;code&gt;value&lt;/code&gt; varies depending on the iterator; arrays support (at least) three functions that return iterators:</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 的含义因迭代器而异； 数组至少支持三个返回迭代器的函数：</target>
        </trans-unit>
        <trans-unit id="6f4344e9b0061937311866ba4501ba441df9956f" translate="yes" xml:space="preserve">
          <source>The method will call from &lt;code&gt;array[0]&lt;/code&gt; to &lt;code&gt;array[2]&lt;/code&gt;. First, this will first reference variables you don't even have, second you would not have the variables in the array, and third this will make the code bolder. Look here, it's what I use:</source>
          <target state="translated">该方法将从 &lt;code&gt;array[0]&lt;/code&gt; 调用到 &lt;code&gt;array[2]&lt;/code&gt; 。 首先，这将首先引用您甚至没有的变量，其次，您将在数组中没有变量，然后，这将使代码更粗体。 看这里，这是我用的：</target>
        </trans-unit>
        <trans-unit id="74aa97507801ce4d05b427601775a33b918e48b3" translate="yes" xml:space="preserve">
          <source>The only real use cases for &lt;code&gt;for-in&lt;/code&gt; on an array are:</source>
          <target state="translated">数组上 &lt;code&gt;for-in&lt;/code&gt; 的唯一实际用例是：</target>
        </trans-unit>
        <trans-unit id="752c45d9e3f0bb5c04149934ef14e0e9e95a2014" translate="yes" xml:space="preserve">
          <source>The other solutions, like &lt;code&gt;for-of&lt;/code&gt; (&lt;strong&gt;Ad&lt;/strong&gt;), all in group &lt;strong&gt;C.&lt;/strong&gt;... are usually 2 - 10 (and more) times slower than &lt;strong&gt;Aa&lt;/strong&gt;, but for small arrays it is ok to use it - for the sake of increase code clarity.</source>
          <target state="translated">&lt;strong&gt;C&lt;/strong&gt;组中的所有其他解决方案，例如 &lt;code&gt;for-of&lt;/code&gt; （ &lt;strong&gt;Ad&lt;/strong&gt; ），通常比&lt;strong&gt;Aa&lt;/strong&gt;慢2-10倍（或更多）倍，但对于小阵列，可以使用它-为了增加代码清晰。</target>
        </trans-unit>
        <trans-unit id="e6e6a03f8cd96d0cc668913bda563a8e9ba99a69" translate="yes" xml:space="preserve">
          <source>The reverse loop is &lt;strong&gt;confusing&lt;/strong&gt; to junior developers.  (You may consider that an advantage, depending on your outlook.)</source>
          <target state="translated">反向循环&lt;strong&gt;使&lt;/strong&gt;初级开发人员&lt;strong&gt;感到困惑&lt;/strong&gt; 。 （根据您的前景，您可能会认为这是一种优势。）</target>
        </trans-unit>
        <trans-unit id="f1e91d86c7df92b8dd9b5472ca55e71a9d8cd69a" translate="yes" xml:space="preserve">
          <source>The standard way to iterate an array in &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; is a vanilla &lt;code&gt;for&lt;/code&gt;-loop:</source>
          <target state="translated">在&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript中&lt;/a&gt;迭代数组的标准方法是-loop的有效方法：</target>
        </trans-unit>
        <trans-unit id="f83ea1369d58b6fdc00c70cea4bb0aa9a818aa64" translate="yes" xml:space="preserve">
          <source>The trick is that unlike &lt;code&gt;--i&lt;/code&gt;, the trailing &lt;code&gt;i--&lt;/code&gt; operator decrements &lt;code&gt;i&lt;/code&gt; but yields the value &lt;strong&gt;&lt;em&gt;before&lt;/em&gt;&lt;/strong&gt; the decrement.  Your console can demonstrate this:</source>
          <target state="translated">诀窍在于，与 &lt;code&gt;--i&lt;/code&gt; 不同，尾随 &lt;code&gt;i--&lt;/code&gt; 运算符使 &lt;code&gt;i&lt;/code&gt; 减1，但是在减1 &lt;strong&gt;&lt;em&gt;之前&lt;/em&gt;&lt;/strong&gt;产生值。 您的控制台可以证明这一点：</target>
        </trans-unit>
        <trans-unit id="608bdf441fc2978c8b5bcb888401c074fd430bc1" translate="yes" xml:space="preserve">
          <source>The various functions on &lt;code&gt;Array.prototype&lt;/code&gt; are &quot;intentionally generic&quot; and can usually be used on array-like objects via &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.call&quot;&gt;&lt;code&gt;Function#call&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.apply&quot;&gt;&lt;code&gt;Function#apply&lt;/code&gt;&lt;/a&gt;. (See the &lt;em&gt;Caveat for host-provided objects&lt;/em&gt; at the end of this answer, but it's a rare issue.)</source>
          <target state="translated">&lt;code&gt;Array.prototype&lt;/code&gt; 上的各种函数是&amp;ldquo;有意通用的&amp;rdquo;，通常可以通过&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.call&quot;&gt; &lt;code&gt;Function#call&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.apply&quot;&gt; &lt;code&gt;Function#apply&lt;/code&gt; &lt;/a&gt;在类似数组的对象上使用 。 （在此答案的末尾，请参阅&lt;em&gt;警告，了解主机提供的对象&lt;/em&gt; ，但这是一个罕见的问题。）</target>
        </trans-unit>
        <trans-unit id="5b74a123ca6113288c61c01f944435ca7d90b342" translate="yes" xml:space="preserve">
          <source>Then when you do see the reverse for loop in your code, that is a hint that it is reversed for a good reason (perhaps one of the reasons described above).  And seeing a traditional forward for loop may indicate that shifting can take place.</source>
          <target state="translated">那么,当你在代码中看到反向for循环时,这就是一个暗示,它被反转的原因(可能是上面描述的原因之一)。而看到传统的正向for循环,可能预示着移位可能会发生。</target>
        </trans-unit>
        <trans-unit id="d150400a4ca68f73e954c6ea93f05e7de141942b" translate="yes" xml:space="preserve">
          <source>There are &lt;strong&gt;a few ways&lt;/strong&gt; to loop through an array in JavaScript, as below:</source>
          <target state="translated">有&lt;strong&gt;几种方法&lt;/strong&gt;可以遍历JavaScript中的数组，如下所示：</target>
        </trans-unit>
        <trans-unit id="0b51f25dbb23a6ed31b4ccfd1a12b3fdb1871919" translate="yes" xml:space="preserve">
          <source>There are different ways to use the forEach loop of angular. The simplest and probably most used is</source>
          <target state="translated">angular的forEach循环有不同的使用方法。最简单也可能是最常用的方法是</target>
        </trans-unit>
        <trans-unit id="43e3466064c6ca5060bfe7c0d8fe1a2296506e5e" translate="yes" xml:space="preserve">
          <source>There are three implementations of &lt;code&gt;foreach&lt;/code&gt; in &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; as follows.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery中&lt;/a&gt;有 &lt;code&gt;foreach&lt;/code&gt; 的三种实现，如下所示。</target>
        </trans-unit>
        <trans-unit id="d54c80c3143769b1187df474f58937273f32b476" translate="yes" xml:space="preserve">
          <source>There is a catch. &lt;code&gt;for..in&lt;/code&gt; will loop through each of the object's enumerable members, and the members on its prototype. To avoid reading values that are inherited through the object's prototype, simply check if the property belongs to the object:</source>
          <target state="translated">有一个陷阱。 &lt;code&gt;for..in&lt;/code&gt; 将遍历对象的每个可枚举成员，以及其原型上的成员。 为了避免读取通过对象原型继承的值，只需检查属性是否属于对象：</target>
        </trans-unit>
        <trans-unit id="93b99dbbcfcfef18eac3c5a89b5362f4491b1f4f" translate="yes" xml:space="preserve">
          <source>There is a debate about whether &lt;code&gt;for..of&lt;/code&gt; or &lt;code&gt;forEach()&lt;/code&gt; are preferable:</source>
          <target state="translated">关于 &lt;code&gt;for..of&lt;/code&gt; 或 &lt;code&gt;forEach()&lt;/code&gt; 是否可取存在争议：</target>
        </trans-unit>
        <trans-unit id="5162299771e3535e699131f35c2cf628ce13a63a" translate="yes" xml:space="preserve">
          <source>There isn't any &lt;code&gt;for each&lt;/code&gt; loop in native &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;. You can either use libraries to get this functionality (I recommend &lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt;), use a simple &lt;code&gt;for&lt;/code&gt; in loop.</source>
          <target state="translated">本机&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript中的&lt;/a&gt; &lt;code&gt;for each&lt;/code&gt; 循环都没有。 您可以使用库来获得此功能（我建议&lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; ），也可以使用简单的 &lt;code&gt;for&lt;/code&gt; in循环。</target>
        </trans-unit>
        <trans-unit id="55d52a0b513a03e6f341ec331ed111d51c87156a" translate="yes" xml:space="preserve">
          <source>There's no inbuilt ability to break in &lt;code&gt;forEach&lt;/code&gt;. To interrupt execution use the &lt;code&gt;Array#some&lt;/code&gt; like below:</source>
          <target state="translated">没有内置的能力闯入 &lt;code&gt;forEach&lt;/code&gt; 。 要中断执行，请使用 &lt;code&gt;Array#some&lt;/code&gt; ,如下所示：</target>
        </trans-unit>
        <trans-unit id="24112cc482e8cc4c078f7faf03d3a6612e321185" translate="yes" xml:space="preserve">
          <source>This is an iterator for NON-sparse list where the index starts at 0, which is the typical scenario when dealing with document.getElementsByTagName or document.querySelectorAll)</source>
          <target state="translated">这是一个NON-sparse列表的迭代器,其中索引从0开始,这是处理document.getElementsByTagName或document.querySelectorAll)时的典型情况。</target>
        </trans-unit>
        <trans-unit id="b109618ad05adb05d3d283e04dadad94a3074a14" translate="yes" xml:space="preserve">
          <source>This will break whenever the reference is false - falsey (undefined, etc.). It can be used as an advantage though. However, it would make it a little bit harder to read. And also depending on the browser it can be &quot;not&quot; optimized to work faster than the original one.</source>
          <target state="translated">只要引用是false-falsey(未定义等),就会被打破。虽然它可以作为一个优势来使用。但是,会让它的阅读难度大一点。而且还可以根据浏览器的不同,它可以 &quot;不 &quot;优化,工作速度比原来的快。</target>
        </trans-unit>
        <trans-unit id="cb8a12948118a05c21c4646e9b69844b0d2ce858" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;some&lt;/code&gt; returns true as soon as any of the callbacks, executed in array order, returns true, short-circuiting the execution of the rest. 
&lt;a href=&quot;https://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break&quot;&gt;Original Answer&lt;/a&gt;
see Array prototype for &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.17&quot;&gt;some&lt;/a&gt;</source>
          <target state="translated">之所以可行，是因为一旦按数组顺序执行的任何回调都返回true，则 &lt;code&gt;some&lt;/code&gt; 返回true，从而使其余的执行短路。 &lt;a href=&quot;https://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break&quot;&gt;原始答案&lt;/a&gt;请参阅数组原型</target>
        </trans-unit>
        <trans-unit id="4c334db464368d273947e54cf77b80331da64b0f" translate="yes" xml:space="preserve">
          <source>Though, you don't have to do that, you can simply do the following and it's equivalent to the previous example:</source>
          <target state="translated">虽然,你不一定要这样做,只需做下面的,就相当于前面的例子。</target>
        </trans-unit>
        <trans-unit id="257fcf65e941aa6ba5c5e06169df94cf19c12a87" translate="yes" xml:space="preserve">
          <source>Today (2019-12-18) I perform test on my &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra), on Chrome v 79.0, Safari v13.0.4 and Firefox v71.0 (64 bit) - conclusions about optimisation (and &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;micro-optimisation&lt;/a&gt;&lt;/em&gt; which usually is not worth to introduce it to code because the benefit is small, but code complexity grows).</source>
          <target state="translated">今天（2019-12-18）我在&lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; （High Sierra），Chrome v 79.0，Safari v13.0.4和Firefox v71.0（64位）上进行测试-有关优化（和&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;微优化&lt;/a&gt;&lt;/em&gt; ）的结论通常不值得将其介绍给代码，因为这样做的好处很小，但是代码复杂度却在增加。</target>
        </trans-unit>
        <trans-unit id="54b58f77bdc50c962ebcb489df02102329ea9473" translate="yes" xml:space="preserve">
          <source>Transform your regular array to iterator using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values&quot;&gt;&lt;code&gt;values()&lt;/code&gt;&lt;/a&gt; method like this:</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values&quot;&gt; &lt;code&gt;values()&lt;/code&gt; &lt;/a&gt;方法将常规数组转换为迭代器，如下所示：</target>
        </trans-unit>
        <trans-unit id="286e721a1890a58c29a5c4014f7f586f56cc077f" translate="yes" xml:space="preserve">
          <source>Trivia</source>
          <target state="translated">Trivia</target>
        </trans-unit>
        <trans-unit id="f2407f77f30d5cce56de1bb34c4429f7541eb397" translate="yes" xml:space="preserve">
          <source>Under the covers, that gets an &lt;em&gt;iterator&lt;/em&gt; from the array and loops through it, getting the values from it. This doesn't have the issue that using &lt;code&gt;for-in&lt;/code&gt; has, because it uses an iterator defined by the object (the array), and arrays define that their iterators iterate through their &lt;em&gt;entries&lt;/em&gt; (not their properties). Unlike &lt;code&gt;for-in&lt;/code&gt; in ES5, the order in which the entries are visited is the numeric order of their indexes.</source>
          <target state="translated">在幕后，它从数组中获取一个&lt;em&gt;迭代器&lt;/em&gt;并循环遍历，从而从中获取值。 这不存在使用 &lt;code&gt;for-in&lt;/code&gt; 的问题，因为它使用由对象（数组）定义的迭代器，并且数组定义其迭代器通过其&lt;em&gt;项&lt;/em&gt; （而不是其属性）进行迭代。 与ES5中的 &lt;code&gt;for-in&lt;/code&gt; 不同，访问条目的顺序是其索引的数字顺序。</target>
        </trans-unit>
        <trans-unit id="51d0fcbbedb44b967fe1846371188cf04d2c2452" translate="yes" xml:space="preserve">
          <source>Unless you're supporting obsolete browsers like IE8 (which NetApps shows at just over 4% market share as of this writing in September&amp;nbsp;2016), you can happily use &lt;code&gt;forEach&lt;/code&gt; in a general-purpose web page without a shim. If you do need to support obsolete browsers, shimming/polyfilling &lt;code&gt;forEach&lt;/code&gt; is easily done (search for &quot;es5 shim&quot; for several options).</source>
          <target state="translated">除非您支持IE8之类的过时浏览器（截至2016年9月，NetApps在该市场上所占份额刚刚超过4％），否则您可以在通用网页中愉快地使用 &lt;code&gt;forEach&lt;/code&gt; ，而无需填充。 如果您确实需要支持过时的浏览器，则可以轻松完成 &lt;code&gt;forEach&lt;/code&gt; 的填充/填充（搜索&amp;ldquo; es5 shim&amp;rdquo;以获得多个选项）。</target>
        </trans-unit>
        <trans-unit id="431a3b9a552efc88858519dfb72bdcfb495d5966" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for-in&lt;/code&gt;&lt;em&gt;correctly&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;正确&lt;/em&gt;使用&lt;em&gt;转售&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e0c11cbf7ef3c72db6fc4b3fe5d45b56bc12d21" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for-of&lt;/code&gt; (use an iterator implicitly) (ES2015+)</source>
          <target state="translated">使用 &lt;code&gt;for-of&lt;/code&gt; （隐式使用迭代器）（ES2015 +）</target>
        </trans-unit>
        <trans-unit id="734ae2379fe23a7a3bc38483ac1b653b9d9051b3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;forEach&lt;/code&gt; and related (ES5+)</source>
          <target state="translated">适用于 &lt;code&gt;forEach&lt;/code&gt; 及相关（ES5 +）</target>
        </trans-unit>
        <trans-unit id="2c08b442b76b66cca66b71d3f1ff947bdd36a587" translate="yes" xml:space="preserve">
          <source>Use a simple &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">使用简单的 &lt;code&gt;for&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="1ea53b376965f0df377f080711210f0ab1972b82" translate="yes" xml:space="preserve">
          <source>Use an iterator explicitly (ES2015+)</source>
          <target state="translated">明确使用迭代器(ES2015+)</target>
        </trans-unit>
        <trans-unit id="34c4927f746ab01e6fc5a9bc93966e26f8b7d962" translate="yes" xml:space="preserve">
          <source>Use any of the options above for arrays</source>
          <target state="translated">使用上面的任何一个选项来进行数组的设置。</target>
        </trans-unit>
        <trans-unit id="e906c3cdb43d16bd2a2f35eccf263373e93c2a7f" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;slice&lt;/code&gt; method of arrays, which like the other methods mentioned above is &quot;intentionally generic&quot; and so can be used with array-like objects, like this:</source>
          <target state="translated">我们可以使用数组的 &lt;code&gt;slice&lt;/code&gt; 方法，就像上面提到的其他方法一样，它是&amp;ldquo;故意通用的&amp;rdquo;，因此可以与类似数组的对象一起使用，如下所示：</target>
        </trans-unit>
        <trans-unit id="ef4d47774a48af8c2dc4198f272524f303720ef0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;of&lt;/code&gt; avoids the oddities associated with &lt;code&gt;in&lt;/code&gt; and makes it work like the &lt;code&gt;for&lt;/code&gt; loop of any other language, and &lt;code&gt;let&lt;/code&gt; binds &lt;code&gt;i&lt;/code&gt; within the loop as opposed to within the function.</source>
          <target state="translated">where避免与 &lt;code&gt;in&lt;/code&gt; 关联的奇数，并使它像任何其他语言的 &lt;code&gt;for&lt;/code&gt; 循环一样工作，并 &lt;code&gt;let&lt;/code&gt; &lt;code&gt;i&lt;/code&gt; 在循环内而不是在函数内绑定。</target>
        </trans-unit>
        <trans-unit id="941d4e5eb1ee2fa812450abac2b4faed7e49a69d" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;theArray&lt;/code&gt; is my array, but this seems to be incorrect.</source>
          <target state="translated">其中 &lt;code&gt;theArray&lt;/code&gt; 是我的数组，但这似乎是不正确的。</target>
        </trans-unit>
        <trans-unit id="08b975222d1b83cf89b60a81d765397d2dc1159f" translate="yes" xml:space="preserve">
          <source>You access the current item by calling the iterator&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; method. The next method will return the &lt;strong&gt;&lt;code&gt;value&lt;/code&gt;&lt;/strong&gt; of the current item and a &lt;strong&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/strong&gt; to indicate when you have reached the end of the collection. The following is an example of creating an iterator from an array.</source>
          <target state="translated">您可以通过调用迭代器的 &lt;code&gt;next&lt;/code&gt; 方法访问当前项。 下一个方法将返回当前项目的&lt;strong&gt; &lt;code&gt;value&lt;/code&gt; &lt;/strong&gt;和一个&lt;strong&gt; &lt;code&gt;boolean&lt;/code&gt; &lt;/strong&gt;以指示您何时到达集合的末尾。 以下是从数组创建迭代器的示例。</target>
        </trans-unit>
        <trans-unit id="faf0a839383e9ca040f86c77bb8d78628ddab12a" translate="yes" xml:space="preserve">
          <source>You can also iterate over an array like this:</source>
          <target state="translated">你也可以像这样在一个数组上迭代。</target>
        </trans-unit>
        <trans-unit id="a99d0a423bd91c6ab11d1bbc2ecccf23c5be4af8" translate="yes" xml:space="preserve">
          <source>You can also transform your regular &lt;code&gt;array&lt;/code&gt; to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">您还可以将常规 &lt;code&gt;array&lt;/code&gt; 转换为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/a&gt;如下所示：</target>
        </trans-unit>
        <trans-unit id="08ceb3749d20fa27c455e7e1a7300f32a149c3c7" translate="yes" xml:space="preserve">
          <source>You can also transform your regular array to iterator using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">您还可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt; &lt;code&gt;Symbol.iterator&lt;/code&gt; &lt;/a&gt;将常规数组转换为迭代器，如下所示：</target>
        </trans-unit>
        <trans-unit id="7f6f076641450693589f578d046aeeeb04ad8c10" translate="yes" xml:space="preserve">
          <source>You can call forEach like this:</source>
          <target state="translated">你可以像这样为Each调用。</target>
        </trans-unit>
        <trans-unit id="8704a38dea0e6f3deb1af2a2e5fcf2aa68370fc9" translate="yes" xml:space="preserve">
          <source>You can get some performance optimisations by caching &lt;code&gt;myArray.length&lt;/code&gt; or iterating over it backwards.</source>
          <target state="translated">您可以通过缓存 &lt;code&gt;myArray.length&lt;/code&gt; 或向后对其进行迭代来获得一些性能优化。</target>
        </trans-unit>
        <trans-unit id="7623d5152acc3867d2222ce3eedc5c77ffbac5a8" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;iteration protocol&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">您可以&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;在此处&lt;/a&gt;阅读有关 &lt;code&gt;iteration protocol&lt;/code&gt; 更多信息。</target>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">你可以使用。</target>
        </trans-unit>
        <trans-unit id="7d5badb0562b87f2a9430ec38445cdf3e13d52c2" translate="yes" xml:space="preserve">
          <source>You do not need to declare a temporary &lt;code&gt;len&lt;/code&gt; variable, or compare against &lt;code&gt;array.length&lt;/code&gt; on each iteration, either of which might be a minute optimisation.</source>
          <target state="translated">您不需要声明一个临时的 &lt;code&gt;len&lt;/code&gt; 变量，也不需要在每次迭代时与 &lt;code&gt;array.length&lt;/code&gt; 进行比较，这两者都可能只是一分钟的优化。</target>
        </trans-unit>
        <trans-unit id="021884629c616bb0e00f4dedc9401d5eeaae6b37" translate="yes" xml:space="preserve">
          <source>You have three options in &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript&amp;nbsp;5&lt;/a&gt; (&quot;ES5&quot;), the version most broadly supported at the moment, and two more added in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript&amp;nbsp;2015&lt;/a&gt; (&quot;ES2015&quot;, &quot;ES6&quot;):</source>
          <target state="translated">您目前在&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript 5&lt;/a&gt; （&amp;ldquo; ES5&amp;rdquo;）中拥有三个选项，这是目前最广泛支持的版本，在&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015中&lt;/a&gt;又添加了两个选项（&amp;ldquo; ES2015&amp;rdquo;，&amp;ldquo; ES6&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="5baba5e2792c7b4a97eeca7d33b55e99ec8dd7bb" translate="yes" xml:space="preserve">
          <source>You will notice that &lt;code&gt;i--&lt;/code&gt; is the middle clause (where we usually see a comparison) and the last clause is empty (where we usually see &lt;code&gt;i++&lt;/code&gt;).  That means that &lt;code&gt;i--&lt;/code&gt; is also used as the &lt;em&gt;condition&lt;/em&gt; for continuation.  Crucially, it is executed and checked &lt;em&gt;before&lt;/em&gt; each iteration.</source>
          <target state="translated">您会注意到， &lt;code&gt;i--&lt;/code&gt; 是中间子句（我们通常在其中看到一个比较），而最后一个子句为空（我们通常在其中看到 &lt;code&gt;i++&lt;/code&gt; ）。 这意味着我-也被用作继续的&lt;em&gt;条件&lt;/em&gt; 。 至关重要的是，它会&lt;em&gt;在&lt;/em&gt;每次迭代&lt;em&gt;之前&lt;/em&gt;执行并检查。</target>
        </trans-unit>
        <trans-unit id="1b92ca772f4a547ebbe1cecec130f971e1c7c39f" translate="yes" xml:space="preserve">
          <source>You wouldn't do that in inline code, of course. You'd write a utility function. Perhaps:</source>
          <target state="translated">当然,你不会在内联代码中这样做。你会写一个实用函数。也许吧。</target>
        </trans-unit>
        <trans-unit id="5b72435b1a6e0292938c5e939f2b0c7c3502eb4e" translate="yes" xml:space="preserve">
          <source>You'll get people telling you to use &lt;code&gt;for-in&lt;/code&gt;, but &lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;that's not what &lt;code&gt;for-in&lt;/code&gt; is for&lt;/a&gt;. &lt;code&gt;for-in&lt;/code&gt; loops through the &lt;em&gt;enumerable properties of an object&lt;/em&gt;, not the indexes of an array. &lt;strong&gt;The order is not guaranteed&lt;/strong&gt;, not even in ES2015 (ES6). ES2015+ does define an order to object properties (via &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys&quot;&gt;&lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-enumerate&quot;&gt;&lt;code&gt;[[Enumerate]]&lt;/code&gt;&lt;/a&gt;, and things that use them like &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getownpropertynames&quot;&gt;&lt;code&gt;Object.getOwnPropertyKeys&lt;/code&gt;&lt;/a&gt;), but it &lt;strong&gt;does not&lt;/strong&gt; define that &lt;code&gt;for-in&lt;/code&gt; will follow that order. (Details in &lt;a href=&quot;https://stackoverflow.com/a/30919039/157247&quot;&gt;this other answer&lt;/a&gt;.)</source>
          <target state="translated">您会看到有人告诉您使用 &lt;code&gt;for-in&lt;/code&gt; ，但这&lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;不是 &lt;code&gt;for-in&lt;/code&gt; 的目的&lt;/a&gt; 。 &lt;code&gt;for-in&lt;/code&gt; 遍历&lt;em&gt;对象&lt;/em&gt;的&lt;em&gt;可枚举属性&lt;/em&gt; ，而不是数组的索引。 甚至在ES2015（ES6）中&lt;strong&gt;也不保证顺序&lt;/strong&gt; 。 ES2015 +确实定义了对象属性的顺序（通过&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys&quot;&gt; &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; &lt;/a&gt; ， &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-enumerate&quot;&gt; &lt;code&gt;[[Enumerate]]&lt;/code&gt; &lt;/a&gt;以及使用它们的对象（如&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getownpropertynames&quot;&gt; &lt;code&gt;Object.getOwnPropertyKeys&lt;/code&gt; &lt;/a&gt; ），但&lt;strong&gt;并未&lt;/strong&gt;定义 &lt;code&gt;for-in&lt;/code&gt; 将遵循该顺序。 （ &lt;a href=&quot;https://stackoverflow.com/a/30919039/157247&quot;&gt;其他答案的&lt;/a&gt;详细信息。）</target>
        </trans-unit>
        <trans-unit id="589b6a96f50575d676fcf038d8105e7b1699be4a" translate="yes" xml:space="preserve">
          <source>You're using non-element properties and you want to include them in the loop</source>
          <target state="translated">您正在使用非元素属性,并希望将其包含在循环中。</target>
        </trans-unit>
        <trans-unit id="10d7cc4a29eba4f6a5a3ca2db2a762f5a236cc71" translate="yes" xml:space="preserve">
          <source>Your best bets are usually</source>
          <target state="translated">你最好的赌注通常是</target>
        </trans-unit>
        <trans-unit id="617846806ec9245ca6b1c7aac0723989e8f9ebee" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;for-of&lt;/code&gt; loop (ES2015+ only),</source>
          <target state="translated">&lt;code&gt;for-of&lt;/code&gt; 循环（仅适用于 ES2015 +），</target>
        </trans-unit>
        <trans-unit id="6b50530706e59258d411002d89ae4b283301aabf" translate="yes" xml:space="preserve">
          <source>a simple old-fashioned &lt;code&gt;for&lt;/code&gt; loop,</source>
          <target state="translated">一个简单的老式 &lt;code&gt;for&lt;/code&gt; 循环，</target>
        </trans-unit>
        <trans-unit id="6f15cde32ab6efb43a1b5c9033caf63a6feb7401" translate="yes" xml:space="preserve">
          <source>browsers**</source>
          <target state="translated">browsers**</target>
        </trans-unit>
        <trans-unit id="5873f666d03fb3fb39d0db9c71b5e1f769334088" translate="yes" xml:space="preserve">
          <source>every</source>
          <target state="translated">every</target>
        </trans-unit>
        <trans-unit id="4bb4ca75941b7bbc5bc6a12be44b22fc9c8d234e" translate="yes" xml:space="preserve">
          <source>filter</source>
          <target state="translated">filter</target>
        </trans-unit>
        <trans-unit id="43eef9a62abb8b1e1654f8a890aae054abffa82b" translate="yes" xml:space="preserve">
          <source>for</source>
          <target state="translated">for</target>
        </trans-unit>
        <trans-unit id="edc5ee22beb2b82f4da41914d8d41cca9c53020f" translate="yes" xml:space="preserve">
          <source>forEach</source>
          <target state="translated">forEach</target>
        </trans-unit>
        <trans-unit id="dc06788092621528ed3f0618bc0b6f3c356aa9e7" translate="yes" xml:space="preserve">
          <source>jQuery way using &lt;code&gt;$.map&lt;/code&gt;:</source>
          <target state="translated">jQuery使用 &lt;code&gt;$.map&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="263cce6e93f37573f1e7fe24662cad3400cc887c" translate="yes" xml:space="preserve">
          <source>or &lt;code&gt;for-in&lt;/code&gt; with safeguards.</source>
          <target state="translated">或采用防护措施。</target>
        </trans-unit>
        <trans-unit id="48c3689f6dd5e9e952f925b7ebebf64d7c43fc56" translate="yes" xml:space="preserve">
          <source>reduce</source>
          <target state="translated">reduce</target>
        </trans-unit>
        <trans-unit id="eb875812858d27b22cb2b75f992dffadc1b05c66" translate="yes" xml:space="preserve">
          <source>some</source>
          <target state="translated">some</target>
        </trans-unit>
        <trans-unit id="f13e27693c85aed522df8c3fcb0bb0110ca54e14" translate="yes" xml:space="preserve">
          <source>zip</source>
          <target state="translated">zip</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
