<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/9329446">
    <body>
      <group id="9329446">
        <trans-unit id="407418523e4b6661ebd3d7c0977b4358422a77b7" translate="yes" xml:space="preserve">
          <source>&quot;Just do this to every item in the list, I don't care about the order!&quot;</source>
          <target state="translated">&quot;목록에있는 모든 항목에이 작업을 수행하면 주문에 신경 쓰지 않습니다!&quot;</target>
        </trans-unit>
        <trans-unit id="828290fcafc33530b24d3d5dd4a9ad6ca15d4e08" translate="yes" xml:space="preserve">
          <source>(I couldn't find the equivalent verbiage in the ES2015 spec, but it's bound to still be the case.) Again, as of this writing the common host-provided array-like objects in modern browsers [&lt;code&gt;NodeList&lt;/code&gt; instances, for instance] &lt;strong&gt;do&lt;/strong&gt; handle &lt;code&gt;[[HasProperty]]&lt;/code&gt; correctly, but it's important to test.)</source>
          <target state="translated">(ES2015 사양에서 이에 상응하는 언어를 찾을 수는 없지만 여전히 그렇습니다.) 다시 말하지만, 현대 브라우저에서 일반적인 호스트 제공 배열과 같은 객체를 작성합니다 [예 : &lt;code&gt;NodeList&lt;/code&gt; 인스턴스] &lt;code&gt;[[HasProperty]]&lt;/code&gt; 를 올바르게 처리하지만 테스트하는 것이 중요합니다.)</target>
        </trans-unit>
        <trans-unit id="6b45776c77fb3cd134163e2ba508745f2d7fa17d" translate="yes" xml:space="preserve">
          <source>(If the discussion of intent makes no sense to you, then you and your code may benefit from watching Crockford's lecture on &lt;a href=&quot;https://www.youtube.com/watch?v=taaEzHI9xyY&amp;amp;t=480&quot;&gt;Programming Style &amp;amp; Your Brain&lt;/a&gt;.)</source>
          <target state="translated">(의도에 대한 논의가 당신에게 의미가 없다면, 당신과 당신의 코드는 Crockford의 &lt;a href=&quot;https://www.youtube.com/watch?v=taaEzHI9xyY&amp;amp;t=480&quot;&gt;Programming Style &amp;amp; Your Brain&lt;/a&gt; 에 관한 강의를 보는 것이 도움이 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="4123820b5846a3f7526a13d056cd330d08a55f64" translate="yes" xml:space="preserve">
          <source>1. Use &lt;code&gt;forEach&lt;/code&gt; and related</source>
          <target state="translated">1. 각 용도 및 관련 용도</target>
        </trans-unit>
        <trans-unit id="5a308f239da9f276808356c1264e14c4f42dba7f" translate="yes" xml:space="preserve">
          <source>2. Use a simple &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">2. 간단한 &lt;code&gt;for&lt;/code&gt; 루프를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="5547e5e05c2ee31034d6e9a26818f942561707ff" translate="yes" xml:space="preserve">
          <source>3. Use &lt;code&gt;for-in&lt;/code&gt;&lt;em&gt;correctly&lt;/em&gt;</source>
          <target state="translated">3. &lt;em&gt;올바르게 사용&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="799ce3e6b5064abe821148b3f183753446d2f3dc" translate="yes" xml:space="preserve">
          <source>4. Use &lt;code&gt;for-of&lt;/code&gt; (use an iterator implicitly) (ES2015+)</source>
          <target state="translated">4. &lt;code&gt;for-of&lt;/code&gt; (반복자를 사용하여) 사용 (ES2015 +)</target>
        </trans-unit>
        <trans-unit id="219586416c25d4118e0031c2b8c71aae94dda23d" translate="yes" xml:space="preserve">
          <source>5. Use an iterator explicitly (ES2015+)</source>
          <target state="translated">5. 반복자를 명시 적으로 사용하십시오 (ES2015 +)</target>
        </trans-unit>
        <trans-unit id="f808743c064b9869ab9f6547f7f8581b28fea109" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://codepen.io/Micka33/pen/nbyxf&quot;&gt;A CodePen example&lt;/a&gt; of how it works is:</source>
          <target state="translated">작동 방식 &lt;a href=&quot;http://codepen.io/Micka33/pen/nbyxf&quot;&gt;의 CodePen 예제&lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fedd9eb5c4d04a7948778748c41299d24255d66b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Documentation for native &lt;code&gt;Array.prototype.forEach()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;네이티브 &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; 대한 설명서입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33c4d33aaa1f39715e196efdb5603883d817169a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for...of&lt;/a&gt; (MDN) describes the next way of iterating using &lt;code&gt;for (variable of object)&lt;/code&gt; as the part of the Harmony (ECMAScript&amp;nbsp;6) proposal.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for ... of&lt;/a&gt; (MDN)는 &lt;code&gt;for (variable of object)&lt;/code&gt; 를 Harmony (ECMAScript 6) 제안의 일부로 사용하는 다음 반복 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dd98744e853daba8a03a51ff44a45ab285ef96ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.every&quot;&gt;&lt;code&gt;every&lt;/code&gt;&lt;/a&gt; (stops looping the first time the callback returns &lt;code&gt;false&lt;/code&gt; or something falsey)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.every&quot;&gt; &lt;code&gt;every&lt;/code&gt; &lt;/a&gt; (콜백이 처음으로 &lt;code&gt;false&lt;/code&gt; 또는 잘못된 것을 반환 할 때 루핑을 멈춤)</target>
        </trans-unit>
        <trans-unit id="1fe98b98ac1a303b3e5d9fe919c4bf1d837d054e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; (creates a new array including elements where the filter function returns &lt;code&gt;true&lt;/code&gt; and omitting the ones where it returns &lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; (필터 함수가 &lt;code&gt;true&lt;/code&gt; 를 리턴하는 요소를 포함하고 새 리턴 값을 생략하는 요소를 포함하여 새 배열을 작성 함)</target>
        </trans-unit>
        <trans-unit id="dd4ceb819717bc057bb5f5be12b2dcaa00cc6d46" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; (creates a new array from the values returned by the callback)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; (콜백에서 반환 된 값에서 새 배열을 만듭니다)</target>
        </trans-unit>
        <trans-unit id="967df601fa043b4383889e2892717dd399d122d6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; (builds up a value by repeatedly calling the callback, passing in previous values; see the spec for the details; useful for summing the contents of an array and many other things)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; (콜백을 반복적으로 호출하여 이전 값을 전달하여 값을 작성합니다. 세부 사항은 사양을 참조하십시오. 배열의 내용과 다른 많은 것들을 합산하는 데 유용합니다)</target>
        </trans-unit>
        <trans-unit id="cc8c405cc76a381935725e183d15ed035da147b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduceright&quot;&gt;&lt;code&gt;reduceRight&lt;/code&gt;&lt;/a&gt; (like &lt;code&gt;reduce&lt;/code&gt;, but works in descending rather than ascending order)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.reduceright&quot;&gt; &lt;code&gt;reduceRight&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;reduce&lt;/code&gt; 와 같지만 오름차순이 아닌 내림차순으로 작동)</target>
        </trans-unit>
        <trans-unit id="adfd7ff17249a9d39816111c7afab18302df88c6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.some&quot;&gt;&lt;code&gt;some&lt;/code&gt;&lt;/a&gt; (stops looping the first time the callback returns &lt;code&gt;true&lt;/code&gt; or something truthy)</source>
          <target state="translated">&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.some&quot;&gt; &lt;code&gt;some&lt;/code&gt; &lt;/a&gt; (콜백이 &lt;code&gt;true&lt;/code&gt; 또는 진실한 것을 반환 할 때 루핑을 중지 함)</target>
        </trans-unit>
        <trans-unit id="377286bac8d6282390dfb096683ce2f568297474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array#forEach&lt;/code&gt; (&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt;&lt;code&gt;spec&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;MDN&lt;/code&gt;&lt;/a&gt;) (or its relatives &lt;code&gt;some&lt;/code&gt; and such) (ES5+ only),</source>
          <target state="translated">&lt;code&gt;Array#forEach&lt;/code&gt; ( &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt; &lt;code&gt;spec&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;MDN&lt;/code&gt; &lt;/a&gt; ) (또는 그와 관련된 친척) (ES5 + 만 해당),</target>
        </trans-unit>
        <trans-unit id="d7e42662fabd1b4650592db96d131acd3a1e156b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array.from&lt;/code&gt; (ES2015+, but easily polyfilled) creates an array from an array-like object, optionally passing the entries through a mapping function first. So:</source>
          <target state="translated">&lt;code&gt;Array.from&lt;/code&gt; (ES2015 +, 쉽게 폴리 필됨)은 배열과 같은 객체로부터 배열을 생성하고, 선택적으로 매핑 함수를 통해 항목을 먼저 전달합니다. 그래서:</target>
        </trans-unit>
        <trans-unit id="b0e8f140b1faf7f02335c4444e052df5049591e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;angular.forEach&lt;/code&gt; takes 2 arguments and an optional third argument. The first argument is the object (array) to iterate over, the second argument is the iterator function, and the optional third argument is the object context (basically referred to inside the loop as 'this'.</source>
          <target state="translated">&lt;code&gt;angular.forEach&lt;/code&gt; 는 2 개의 인수와 선택적인 세 번째 인수를 취합니다. 첫 번째 인수는 반복 할 객체 (배열)이고 두 번째 인수는 반복자 함수이며 선택적 세 번째 인수는 객체 컨텍스트 (기본적으로 루프 내에서 'this'라고 함)입니다.</target>
        </trans-unit>
        <trans-unit id="9a8d763ba59a05f954f7c48ce76ecba0f7d62607" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;entries()&lt;/code&gt;: Returns an iterator where each &lt;code&gt;value&lt;/code&gt; is an array in the form &lt;code&gt;[key, value]&lt;/code&gt; for that iteration.</source>
          <target state="translated">&lt;code&gt;entries()&lt;/code&gt; : 각 &lt;code&gt;value&lt;/code&gt; 이 해당 반복에 대한 &lt;code&gt;[key, value]&lt;/code&gt; 형식의 배열 인 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b4cbd4974267f738d1be9503fdb7ebf5943cbd34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for-in&lt;/code&gt; with the same safeguards as with an array should work with array-like objects as well; the caveat for host-provided objects on #1 above may apply.</source>
          <target state="translated">배열과 동일한 보호 &lt;code&gt;for-in&lt;/code&gt; 갖춘 for-in 은 배열과 유사한 객체에서도 작동해야합니다. 위의 # 1에 호스트 제공 개체에 대한주의 사항이 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9fa350aa7ed228cd4b3e93d0298f289edbbed8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for-of&lt;/code&gt; will use the iterator provided by the object (if any); we'll have to see how this plays with the various array-like objects, particularly host-provided ones. For instance, the specification for the &lt;code&gt;NodeList&lt;/code&gt; from &lt;code&gt;querySelectorAll&lt;/code&gt; was updated to support iteration. The spec for the &lt;code&gt;HTMLCollection&lt;/code&gt; from &lt;code&gt;getElementsByTagName&lt;/code&gt; was not.</source>
          <target state="translated">&lt;code&gt;for-of&lt;/code&gt; 는 객체가 제공하는 반복자를 사용합니다 (있는 경우). 우리는 이것이 다양한 배열 형 객체, 특히 호스트 제공 객체와 어떻게 작동하는지 확인해야합니다. 예를 들어 &lt;code&gt;querySelectorAll&lt;/code&gt; 의 &lt;code&gt;NodeList&lt;/code&gt; 스펙이 반복을 지원하도록 업데이트되었습니다. &lt;code&gt;getElementsByTagName&lt;/code&gt; 의 &lt;code&gt;HTMLCollection&lt;/code&gt; 스펙이 없습니다.</target>
        </trans-unit>
        <trans-unit id="04cdb28da8f19e68125e4596f8a56b848aec15ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forEach&lt;/code&gt; accepts a callback function and, optionally, a value to use as &lt;code&gt;this&lt;/code&gt; when calling that callback (not used above). The callback is called for each entry in the array, in order, skipping non-existent entries in sparse arrays. Although I only used one argument above, the callback is called with three: The value of each entry, the index of that entry, and a reference to the array you're iterating over (in case your function doesn't already have it handy).</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; 는 콜백 함수 및 선택적으로 해당 콜백을 호출 할 때 사용할 값을 수락합니다 (위에서 사용되지 않음). 배열의 각 항목에 대해 콜백이 호출되어 희소 배열의 존재하지 않는 항목은 건너 뜁니다. 위의 인수는 하나만 사용했지만 콜백은 세 가지로 호출됩니다. 각 항목의 값, 해당 항목의 색인 및 반복하는 배열에 대한 참조 (함수에 아직 편리한 기능이없는 경우) ).</target>
        </trans-unit>
        <trans-unit id="10cc3315d863ec1f2a75337ba363aaa39af9ff7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forEach&lt;/code&gt; has the benefit that you don't have to declare indexing and value variables in the containing scope, as they're supplied as arguments to the iteration function, and so nicely scoped to just that iteration.</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; 는 반복 함수에 대한 인수로 제공되므로 포함 범위에서 인덱싱 및 값 변수를 선언 할 필요가 없다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d31603bd232d66e37b18d7476c0486024b09c2d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forEach&lt;/code&gt; will iterate over the array you provide and for each iteration it will have &lt;code&gt;element&lt;/code&gt; which holds the value of that iteration. If you need index you can get the current index by passing the &lt;code&gt;i&lt;/code&gt; as the second parameter in the callback function for forEach.</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; 는 제공하는 배열을 반복하고 각 반복마다 해당 반복 값을 보유하는 &lt;code&gt;element&lt;/code&gt; 를 갖습니다. 색인이 필요한 경우 forEach의 콜백 함수에서 &lt;code&gt;i&lt;/code&gt; 를 두 번째 매개 변수로 전달하여 현재 색인을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a637b50b32f61aa2eb966f27cbab468a25797cfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keys()&lt;/code&gt;: Returns an iterator where each &lt;code&gt;value&lt;/code&gt; is the key for that iteration (so for our &lt;code&gt;a&lt;/code&gt; above, that would be &lt;code&gt;&quot;0&quot;&lt;/code&gt;, then &lt;code&gt;&quot;1&quot;&lt;/code&gt;, then &lt;code&gt;&quot;2&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;keys()&lt;/code&gt; : 각 &lt;code&gt;value&lt;/code&gt; 이 해당 반복의 키인 반복자를 리턴합니다 (따라서 위의 경우 &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;1&quot;&lt;/code&gt; , &lt;code&gt;&quot;2&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e09aa066919616abd8401c1b7f350a3988032555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;values()&lt;/code&gt;: This is the one I used above. It returns an iterator where each &lt;code&gt;value&lt;/code&gt; is the array entry for that iteration (&lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;b&quot;&lt;/code&gt;, and &lt;code&gt;&quot;c&quot;&lt;/code&gt; in the example earlier).</source>
          <target state="translated">&lt;code&gt;values()&lt;/code&gt; : 이것은 위에서 사용한 것입니다. 각 &lt;code&gt;value&lt;/code&gt; 이 해당 반복에 대한 배열 항목 인 반복자를 리턴합니다 (이 예에서는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; , &lt;code&gt;&quot;b&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;c&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b95a3bad9c3b12555c2a9ef69ef39152f687a5c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; will contain the last value of &lt;code&gt;y&lt;/code&gt; and it will be removed from the array. You can also use &lt;code&gt;shift()&lt;/code&gt; which will give and remove the first item from &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;y&lt;/code&gt; 의 마지막 값을 포함하고 배열에서 제거됩니다. &lt;code&gt;y&lt;/code&gt; 에서 첫 번째 항목을 제공하고 제거하는 &lt;code&gt;shift()&lt;/code&gt; 를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="94d62988ff95e5983c9bb7336fe74b54beb70d31" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Credits go to WYL for showing me the benefits and horrors of the reverse for loop.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;크레딧은 WYL로 이동하여 리버스 for 루프의 이점과 공포를 보여주었습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ebe32016513b7b36eecf84f088911eaffc1e16a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A&lt;/strong&gt; - &lt;code&gt;for&lt;/code&gt; tests</source>
          <target state="translated">&lt;strong&gt;A-&lt;/strong&gt; 테스트 용</target>
        </trans-unit>
        <trans-unit id="9e681feccaa2f651d3f5e876dbe2e319c1d67118" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array with 1,000,000 elements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1,000,000 개의 요소로 구성된 배열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3255bc6f4f9492d8559a38233f24c1a81f7a3679" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array with 10 elements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;10 개의 요소로 구성된 배열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1730cb94cc2840238efe2ab02609e1acbb5d7877" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array.forEach()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Array.forEach()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f9864972c7c592b5676161c6e60aa0f51041edc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As of ECMAScript&amp;nbsp;6:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ECMAScript 6 현재 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="366729cb2dd9643a7a37c411a6350e8f3239e9fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;B&lt;/strong&gt; - &lt;code&gt;while&lt;/code&gt; tests</source>
          <target state="translated">&lt;strong&gt;B-&lt;/strong&gt; 테스트 중</target>
        </trans-unit>
        <trans-unit id="330f92001b0c02491afac466730ba9e45d684ab4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C&lt;/strong&gt; - other/alternative methods</source>
          <target state="translated">&lt;strong&gt;C-&lt;/strong&gt; 기타 / 대체 방법</target>
        </trans-unit>
        <trans-unit id="1a68ce6032c3740fd013d6c9b66b882246d9cf06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caf1f7a722c982dbd57c57da6fb19a30c4de09b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66201f31a06924bccc5252ec818cb13549b146b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cross browser results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;크로스 브라우저 결과&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="750c1a011ed83068ce4b750427dca4f8195eb051" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;편집하다 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40f5fee30dbaa97b495918cfcda19fd49d758e20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 # 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="184138f36fc9d5f1b134435fd6400d89d5dd3ef7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 # 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fbf2341d370757e8b1e3d68104c67efff5070bbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #3&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 # 3&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc261b2aaea005d1254afb5ea26e11f1deea56b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example #4&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실시 예 # 4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="076cc797a53b7cb38c7bf05c97b94635f200c2e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1:&lt;/strong&gt; Normal &lt;code&gt;for...of&lt;/code&gt; loop - no tricks here.</source>
          <target state="translated">&lt;strong&gt;예제 1 :&lt;/strong&gt; 루프의 일반 &lt;code&gt;for...of&lt;/code&gt; of-여기서 트릭은 없습니다.</target>
        </trans-unit>
        <trans-unit id="49d9fa2400580995d7bae707d928b0d3821aa741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2:&lt;/strong&gt; Split words to characters</source>
          <target state="translated">&lt;strong&gt;예 2 :&lt;/strong&gt; 단어를 문자로 나누기</target>
        </trans-unit>
        <trans-unit id="bdc1592f5ce50edf5193207a1607a8801ea11f33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 3:&lt;/strong&gt; Looping with a &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;예제 3 :&lt;/strong&gt; &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 반복</target>
        </trans-unit>
        <trans-unit id="78871da32ac6a0f7f115cb0b01a332656d6a8904" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 4:&lt;/strong&gt; Get object properties inline</source>
          <target state="translated">&lt;strong&gt;예 4 :&lt;/strong&gt; 인라인 객체 속성 가져 오기</target>
        </trans-unit>
        <trans-unit id="e558c5c128ffa4a0403278ee644502849ef174b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 5:&lt;/strong&gt; Get deep object properties of what you need</source>
          <target state="translated">&lt;strong&gt;예제 5 :&lt;/strong&gt; 필요한 것의 깊은 객체 속성 얻기</target>
        </trans-unit>
        <trans-unit id="0a55d796f49ed376bbdc8b840ed3ffef75a362c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 6:&lt;/strong&gt; Is &lt;strong&gt;Example 3&lt;/strong&gt; used with &lt;code&gt;.forEach&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;예 6 :&lt;/strong&gt; &lt;strong&gt;예 3&lt;/strong&gt; 을 &lt;code&gt;.forEach&lt;/code&gt; 와 함께 사용 합니까?</target>
        </trans-unit>
        <trans-unit id="1c576ad032b24d44f329a8bbbc699e346dfa84e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 7:&lt;/strong&gt; Is &lt;strong&gt;Example 4&lt;/strong&gt; used with &lt;code&gt;.forEach&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;예 7 :&lt;/strong&gt; &lt;strong&gt;예 4&lt;/strong&gt; 를 &lt;code&gt;.forEach&lt;/code&gt; 와 함께 사용 합니까?</target>
        </trans-unit>
        <trans-unit id="28f415a0afa402f72563bd9599b6360f208f4e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 8:&lt;/strong&gt; Is &lt;strong&gt;Example 5&lt;/strong&gt; used with &lt;code&gt;.forEach&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;예 8 :&lt;/strong&gt; &lt;code&gt;.forEach&lt;/code&gt; 와 함께 사용 된 &lt;strong&gt;예 5&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ce5e7fbb73dac5a612d22d4d58fd1306ab12eaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples 6, 7, and 8&lt;/strong&gt; can be used with any functional loops like &lt;code&gt;.map&lt;/code&gt;, &lt;code&gt;.filter&lt;/code&gt;, &lt;code&gt;.reduce&lt;/code&gt;, &lt;code&gt;.sort&lt;/code&gt;, &lt;code&gt;.every&lt;/code&gt;, &lt;code&gt;.some&lt;/code&gt;. For more information about these methods, check out the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;Array Object&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;예제 6, 7, 8&lt;/strong&gt; 은 &lt;code&gt;.map&lt;/code&gt; , &lt;code&gt;.reduce&lt;/code&gt; , &lt;code&gt;.sort&lt;/code&gt; , .sort , .every , .some 과 같은 기능적 루프와 함께 사용할 수 있습니다. 이러한 메소드에 대한 자세한 정보는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;Array Object를&lt;/a&gt; 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ea72b87b0bf2ace83cf5109381e93aeb066f2f76" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples of usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사용 예 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1b7b6fbb391b39121d3090835b1a7d329182a66c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functional loops&lt;/strong&gt; - &lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, also &lt;code&gt;reduce&lt;/code&gt; (they loop through the function, but they are used if you need to do something with your array, etc.</source>
          <target state="translated">&lt;strong&gt;기능적 루프&lt;/strong&gt; &lt;code&gt;forEach&lt;/code&gt; , &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;filter&lt;/code&gt; 또한 &lt;code&gt;reduce&lt;/code&gt; (함수를 통해 반복되지만 배열 등으로 무언가를 해야하는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="32fac35272abae62a061520fb1a2f945a7607806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How can it start at &lt;code&gt;array.length&lt;/code&gt; without exploding?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어떻게 폭발하지 않고 &lt;code&gt;array.length&lt;/code&gt; 에서 시작할 수 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b91663c8ee6622d139ccbcbdd48f45d5a5186122" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;NOTE&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="9df17e3bf34872a611d0e519ed5573d79bc888bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This answer is hopelessly out-of-date. For a more modern approach, look at &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;the methods available on an array&lt;/a&gt;. Methods of interest might be:</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 답변은 절망적 인 구식입니다. 보다 현대적인 접근 방식 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;은 배열에서 사용 가능한 방법을&lt;/a&gt; 살펴보십시오. 관심있는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e3161fd669d07159e3a7475c999f77628c85246" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="364d4fdee3e0bca52971cff9ce11bfd5c1cd8d29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0012595d3c17367fbb2f7b33de7378b0b6ab7340" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Removing siblings&lt;/strong&gt; from the DOM in reverse order is usually &lt;strong&gt;more efficient&lt;/strong&gt;.  (The browser needs to do less shifting of elements in its internal arrays.)</source>
          <target state="translated">DOM에서 &lt;strong&gt;형제&lt;/strong&gt; 를 역순으로 &lt;strong&gt;제거하는&lt;/strong&gt; 것이 일반적으로 &lt;strong&gt;더 효율적&lt;/strong&gt; 입니다. (브라우저는 내부 배열에서 요소를 덜 이동해야합니다.)</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07ae7a0c45d54d2ebb1dc0cd4ec4001979bca9ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread syntax (&lt;code&gt;...&lt;/code&gt;)&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;스프레드 구문&lt;/a&gt; 사용 ( &lt;code&gt;...&lt;/code&gt; )&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4022df37529f9de6389e8b44f78656816e01d469" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;Array.from&lt;/code&gt;&lt;/strong&gt;&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.from&quot;&gt;(spec)&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from&quot;&gt;(MDN)&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Array.from&lt;/code&gt; 사용&lt;/strong&gt; &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.from&quot;&gt;(사양)&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from&quot;&gt;(MDN)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46eac7e8f751f6f37b8572993152b573d2db8084" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;for-in&lt;/code&gt; &lt;em&gt;correctly&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;올바르게 사용&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d283294cac8da6d79925867e0ba6a307ede498df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;for-of&lt;/code&gt; (use an iterator implicitly) (ES2015+)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;For &lt;code&gt;for-of&lt;/code&gt; 사용 (이터레이터를 암시 적으로 사용) (ES2015 +)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bd126a72acb2ecb3b1451e2659a42fd39e32809" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;forEach&lt;/code&gt; and related (ES5+)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;각 제품 및 관련 제품 (ES5 +)에 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb2d92cc11b7a9d0aca33182e1bebdf4c726208b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use a simple &lt;code&gt;for&lt;/code&gt; loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 &lt;code&gt;for&lt;/code&gt; 루프를 사용하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f71bc706ab4a26bf9a13464f7b39c3aeaed0e52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use an iterator explicitly (ES2015+)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;반복자를 명시 적으로 사용하십시오 (ES2015 +)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c4b03a035270e1b8f7dd2084f9df26df262debc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use the &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; method of arrays&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;배열의 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt; 방법을 사용하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8aa2a7263e5c604aa1227ef93fc167e49c67b84c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using loops with ECMAScript&amp;nbsp;6  &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;destructuring&lt;/a&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread operator&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ECMAScript 6 디스트 럭처링 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;스프레드 연산자&lt;/a&gt; 와 함께 루프 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="43d6f90660b9cfa169cfb55c0d5f5781ab586f65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why doesn't it stop iterating before index 0?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;인덱스 0 이전의 반복을 멈추지 않는 이유는 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c7882bff3bd32e131ca75ee9b3310dc89ce137d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;do...while loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;루프 동안 ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="292b6043564aae6314fc4949f7b4dc07ffca89f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;do/while&lt;/strong&gt; - also loop through a block of code while the condition is true, will run at least one time</source>
          <target state="translated">&lt;strong&gt;do / while-&lt;/strong&gt; 조건이 참인 동안 코드 블록을 반복하면서 한 번 이상 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="59c2e1f4757834d90e32b8228c2ca6efbcc623e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;every&lt;/strong&gt; - Returns true or false if all the elements in the array pass the test in the callback function.</source>
          <target state="translated">&lt;strong&gt;every-&lt;/strong&gt; 배열의 모든 요소가 콜백 함수에서 테스트를 통과하면 true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="733d7f1b168a00ba327543b1d4fe7a84e1c306f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;filter&lt;/strong&gt; - Very similar to every except that filter returns an array with the elements that return true to the given function.</source>
          <target state="translated">&lt;strong&gt;filter-&lt;/strong&gt; 필터는 주어진 함수에 true를 반환하는 요소를 가진 배열을 반환한다는 점을 제외하고는 모든 것과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="271fc1eae66abadd19acb62d4033231ca149cfff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;for 루프&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6730b771cabf57b04de93a3724c66df24b945a65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for...in loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;for ... in 루프&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41a75d50cd0e008efc00bd22fdc7462386f2f0fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for...of loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;for ... of 루프&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2573e11cf7374a0bd5806f17739331b98d97a3d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for&lt;/strong&gt; - it's &lt;strong&gt;the most common one&lt;/strong&gt;. Full block of code for looping</source>
          <target state="translated">&lt;strong&gt;가장 일반적인 것&lt;/strong&gt; 입니다. 루핑을위한 전체 코드 블록</target>
        </trans-unit>
        <trans-unit id="bf96d036e4a3af64d225f756d7cdb14e19eaa0d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;forEach&lt;/strong&gt; - Iterates through every item in the array and do whatever you need with each item.</source>
          <target state="translated">&lt;strong&gt;forEach-&lt;/strong&gt; 배열의 모든 항목을 반복하고 각 항목에 필요한 모든 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ea31da07d585b6c78298f66e4e1cab0b4bf164cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;map&lt;/strong&gt; - It creates a new array with the result of the callback function. This method is good to be used when you need to format the elements of your array.</source>
          <target state="translated">map-콜백 함수의 결과로 새 배열을 만듭니다. 이 방법은 배열의 요소를 포맷해야 할 때 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1d2abe3d817566b9ac069c513ac4125616984176" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;reduce&lt;/strong&gt; - As the name says, it reduces the array to a single value by calling the given function passing in the current element and the result of the previous execution.</source>
          <target state="translated">&lt;strong&gt;reduce-&lt;/strong&gt; 이름에서 알 &lt;strong&gt;수&lt;/strong&gt; 있듯이 현재 요소와 이전 실행 결과를 전달하는 주어진 함수를 호출하여 배열을 단일 값으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="bc7cb0747f251ea37bf8ac12f021c5f51bc464ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;while loops&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;while 루프&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d59bd2da691ba295b8e0f0e005203a04e318b82d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;while&lt;/strong&gt; - loop while a condition is through. It seems to be the fastest loop</source>
          <target state="translated">&lt;strong&gt;while-&lt;/strong&gt; 조건이 통과되는 동안 루프. 가장 빠른 루프 인 것 같습니다</target>
        </trans-unit>
        <trans-unit id="98ac7d9be42d78332ce549839259a6fa839e83f9" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;forEach&lt;/strong&gt; implementation (&lt;a href=&quot;http://jsfiddle.net/nmoliveira/zNsyB/&quot;&gt;see in jsFiddle&lt;/a&gt;):</source>
          <target state="translated">&lt;strong&gt;forEach&lt;/strong&gt; 구현 ( &lt;a href=&quot;http://jsfiddle.net/nmoliveira/zNsyB/&quot;&gt;jsFiddle 참조&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="1593b174e119f27794747b6ca100ac5339012c07" translate="yes" xml:space="preserve">
          <source>A way closest to your idea would be to use &lt;code&gt;Array.forEach()&lt;/code&gt; which accepts a closure function which will be executed for each element of the array.</source>
          <target state="translated">아이디어에 가장 가까운 방법은 &lt;code&gt;Array.forEach()&lt;/code&gt; 를 사용하여 배열의 각 요소에 대해 실행될 클로저 함수를 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="461621dddb84f5684403289120de177b2681c313" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt; has added a &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;forEach&lt;/code&gt;&lt;/a&gt; method to &lt;code&gt;Array.prototype&lt;/code&gt; which can be used to enumerate over an array using a calback (the polyfill is in the docs so you can still use it for older browsers):</source>
          <target state="translated">또한 &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;forEach&lt;/code&gt; &lt;/a&gt; 메소드를 &lt;code&gt;Array.prototype&lt;/code&gt; 에 추가하여 콜백을 사용하여 배열을 열거하는 데 사용할 수 있습니다 (폴리 필은 문서에 있으므로 이전 브라우저에서도 계속 사용할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="636fc2fec13e68630984c3473aa5d7f358f03d69" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;forEach&lt;/code&gt; is the &quot;loop through them all&quot; function, but ES5 defined several other useful &quot;work your way through the array and do things&quot; functions, including:</source>
          <target state="translated">또한 &lt;code&gt;forEach&lt;/code&gt; 는 &quot;모두 반복&quot;기능이지만 ES5는 다음과 같은 몇 가지 유용한 &quot;어레이를 통해 작업하고 작업을 수행&quot;기능을 정의했습니다.</target>
        </trans-unit>
        <trans-unit id="c9f143cb14712f08a4e4970f0a574a82e563a424" translate="yes" xml:space="preserve">
          <source>Advantages:</source>
          <target state="translated">Advantages:</target>
        </trans-unit>
        <trans-unit id="de209c6ef85b78db6e703d44fe0a792cf0cf2d79" translate="yes" xml:space="preserve">
          <source>Although the performance gains are usually insignificant, it sort of screams:</source>
          <target state="translated">일반적으로 성능 향상은 미미하지만 비명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41e3fc9478f9b0602ab804e2073a64ab781383e9" translate="yes" xml:space="preserve">
          <source>An easy solution now would be to use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;underscore.js library&lt;/a&gt;. It's providing many useful tools, such as &lt;code&gt;each&lt;/code&gt; and will automatically delegate the job to the native &lt;code&gt;forEach&lt;/code&gt; if available.</source>
          <target state="translated">쉬운 해결책은 이제 &lt;a href=&quot;https://en.wikipedia.org/wiki/Underscore.js&quot;&gt;underscore.js 라이브러리&lt;/a&gt; 를 사용하는 것입니다. &lt;code&gt;each&lt;/code&gt; 도구와 같은 많은 유용한 도구를 제공하며 가능한 경우 작업을 기본 &lt;code&gt;forEach&lt;/code&gt; 에 자동으로 위임합니다.</target>
        </trans-unit>
        <trans-unit id="76134101719fc71647c5e2d29cf268ee6974b9a0" translate="yes" xml:space="preserve">
          <source>And finally the first 20 blue p tags are changed to green</source>
          <target state="translated">마지막으로 처음 20 개의 파란색 p 태그가 녹색으로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="286bb782ad24f006d5ef3df1b25f01bf4ccf96dd" translate="yes" xml:space="preserve">
          <source>And furthermore &lt;code&gt;await&lt;/code&gt;&lt;a href=&quot;https://gist.github.com/joeytwiddle/37d2085425c049629b80956d3c618971&quot;&gt;does not work&lt;/a&gt; inside &lt;code&gt;forEach()&lt;/code&gt;.  Using &lt;code&gt;for..of&lt;/code&gt; is &lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-259876436&quot;&gt;the clearest pattern&lt;/a&gt; in this case.</source>
          <target state="translated">또한 &lt;code&gt;await&lt;/code&gt; &lt;a href=&quot;https://gist.github.com/joeytwiddle/37d2085425c049629b80956d3c618971&quot;&gt;는&lt;/a&gt; &lt;code&gt;forEach()&lt;/code&gt; 내부에서 작동하지 않습니다 . 이 경우 &lt;code&gt;for..of&lt;/code&gt; 를 사용 하는 것이 &lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-259876436&quot;&gt;가장 명확한 패턴&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2635b275be0c2dfc38d57182a9f17df25ac0fd4" translate="yes" xml:space="preserve">
          <source>And if you want it to be a function, you can do this:</source>
          <target state="translated">그리고 그것이 기능이되기를 원한다면, 당신은 이것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="aa47cb48e650e1ab26dbe126a4f7ec3d29c4aae4" translate="yes" xml:space="preserve">
          <source>And there are many others for iteration.</source>
          <target state="translated">그리고 반복 할 다른 것들이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd8096180abe912c76cb829baeb8776e4097989f" translate="yes" xml:space="preserve">
          <source>And when you do that, not just &lt;code&gt;value&lt;/code&gt; but also &lt;code&gt;index&lt;/code&gt; is recreated for each loop iteration, meaning closures created in the loop body keep a reference to the &lt;code&gt;index&lt;/code&gt; (and &lt;code&gt;value&lt;/code&gt;) created for that specific iteration:</source>
          <target state="translated">그리고 그렇게 할 때, &lt;code&gt;value&lt;/code&gt; 뿐만 아니라 각 루프 반복에 대해 &lt;code&gt;index&lt;/code&gt; 가 다시 작성되므로 루프 본문에서 작성된 클로저는 해당 특정 반복에 대해 작성된 &lt;code&gt;index&lt;/code&gt; (및 &lt;code&gt;value&lt;/code&gt; )에 대한 참조를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="c5d23f01f61bcd35bfab142a15fd44885c61c3be" translate="yes" xml:space="preserve">
          <source>And/or counting backward:</source>
          <target state="translated">그리고 / 또는 뒤로 계산 :</target>
        </trans-unit>
        <trans-unit id="c4dfb973c48c6519cc7b7dc31550d6b63562a6b8" translate="yes" xml:space="preserve">
          <source>Another viable way would be to use &lt;code&gt;Array.map()&lt;/code&gt; which works in the same way, but it also takes all values that you return and returns them in a new array (essentially mapping each element to a new one), like this:</source>
          <target state="translated">또 다른 가능한 방법은 &lt;code&gt;Array.map()&lt;/code&gt; 을 사용하여 동일한 방식으로 작동하지만 반환하는 모든 값을 가져 와서 새 배열로 반환합니다 (필수적으로 각 요소를 새 요소에 매핑).</target>
        </trans-unit>
        <trans-unit id="e3e988d8ceb27456dc97896d4220b5940816a6af" translate="yes" xml:space="preserve">
          <source>Another way that is useful for copying items from one array to another is</source>
          <target state="translated">한 배열에서 다른 배열로 항목을 복사하는 데 유용한 또 다른 방법은</target>
        </trans-unit>
        <trans-unit id="8d554cc4170a849cf2e0aa16b801259f0efd7018" translate="yes" xml:space="preserve">
          <source>As per question, user want code in javascript instead of jquery so the edit is</source>
          <target state="translated">질문에 따라 사용자는 jquery 대신 자바 스크립트로 코드를 원하므로 편집은</target>
        </trans-unit>
        <trans-unit id="bdc7e9a236af726f7038fbcebf901bc5de8a0e8f" translate="yes" xml:space="preserve">
          <source>As per the new updated feature ECMAScript 6 (ES6) and ECMAScript 2015, you can use the following options with loops:</source>
          <target state="translated">새로운 업데이트 된 기능 ECMAScript 6 (ES6) 및 ECMAScript 2015에 따라 루프와 함께 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e50940d71eac09fa64f7e1d6bcb6c40b08529b" translate="yes" xml:space="preserve">
          <source>Aside from true arrays, there are also &lt;em&gt;array-like&lt;/em&gt; objects that have a &lt;code&gt;length&lt;/code&gt; property and properties with numeric names: &lt;code&gt;NodeList&lt;/code&gt; instances, the &lt;code&gt;arguments&lt;/code&gt; object, etc. How do we loop through their contents?</source>
          <target state="translated">실제 배열 외에도 &lt;code&gt;length&lt;/code&gt; 속성과 숫자 이름을 가진 속성을 가진 &lt;em&gt;배열과 같은&lt;/em&gt; 객체가 있습니다 : &lt;code&gt;NodeList&lt;/code&gt; 인스턴스, &lt;code&gt;arguments&lt;/code&gt; 객체 등. 우리는 그 내용을 어떻게 반복합니까?</target>
        </trans-unit>
        <trans-unit id="eab486bae96770e7bd766cc0cc4ada63033b8966" translate="yes" xml:space="preserve">
          <source>At least some, and possibly most or even all, of the array approaches above frequently apply equally well to array-like objects:</source>
          <target state="translated">위의 배열 접근법 중 적어도 일부, 또는 대부분 또는 전체는 종종 배열 유사 객체에 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="70a2b96e30c86a111cdae7a47c5956d3a9d28e3e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;i--&lt;/code&gt; runs &lt;em&gt;before&lt;/em&gt; each iteration, on the first iteration we will actually be accessing the item at &lt;code&gt;array.length - 1&lt;/code&gt; which avoids any issues with &lt;strike&gt;Array-out-of-bounds&lt;/strike&gt;&lt;code&gt;undefined&lt;/code&gt; items.</source>
          <target state="translated">&lt;code&gt;i--&lt;/code&gt; 는 각 반복 &lt;em&gt;전에&lt;/em&gt; 실행 &lt;em&gt;되기&lt;/em&gt; 때문에 첫 번째 반복에서 실제로 &lt;strike&gt;배열 범위를 벗어난&lt;/strike&gt; &lt;code&gt;undefined&lt;/code&gt; 항목 &lt;strike&gt;의&lt;/strike&gt; 문제를 피하는 &lt;code&gt;array.length - 1&lt;/code&gt; 의 항목에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="7e75fbda4fe70f4af05ef437f23c8019a6e0a056" translate="yes" xml:space="preserve">
          <source>But the above concerns is not applicable to Node.js applications, where &lt;code&gt;for..of&lt;/code&gt; is now well supported.</source>
          <target state="translated">그러나 위의 문제는 Node.js 응용 프로그램에는 적용되지 않으며 &lt;code&gt;for..of&lt;/code&gt; 는 현재 잘 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="877397eda4030d185b7ccf9f7ce92ef4e0c61e68" translate="yes" xml:space="preserve">
          <source>But there's &lt;strong&gt;lots&lt;/strong&gt; more to explore, read on...</source>
          <target state="translated">그러나 더 많은 것을 탐구하고 읽으십시오 ...</target>
        </trans-unit>
        <trans-unit id="ee106f8a0a3a9dae96b0d69d742bcd97b39bd261" translate="yes" xml:space="preserve">
          <source>But with modern JavaScript engines, it's rare you need to eke out that last bit of juice.</source>
          <target state="translated">그러나 최신 JavaScript 엔진을 사용하면 마지막 주스를 피할 필요가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e709fabb3cf8ffb27a522d70327597b3b8cc4d2" translate="yes" xml:space="preserve">
          <source>Caution when using string as function: the function is created out-of-context and ought to be used only where you are certain of variable scoping.  Otherwise, better to pass functions where scoping is more intuitive.</source>
          <target state="translated">문자열을 함수로 사용시주의 사항 : 함수가 컨텍스트 외부에서 작성되며 변수 범위가 지정된 경우에만 사용해야합니다. 그렇지 않으면 범위가 더 직관적 인 함수를 전달하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ebdda461e7af469834840795faba24136d9d0951" translate="yes" xml:space="preserve">
          <source>Caveat for host-provided objects</source>
          <target state="translated">호스트 제공 객체에 대한주의 사항</target>
        </trans-unit>
        <trans-unit id="5c0fa40086336662397974cdbd5ffa0407908978" translate="yes" xml:space="preserve">
          <source>Consider the following 2 nested loops, which do exactly the same thing. Let's say that we have 2 arrays of objects and each object contains an array of results, each of which has a Value property that's a string (or whatever). And let's say we need to iterate over each of the results and if they're equal then perform some action:</source>
          <target state="translated">정확히 같은 일을하는 다음 2 개의 중첩 루프를 고려하십시오. 두 개의 객체 배열이 있고 각 객체에 결과 배열이 포함되어 있다고 가정 해 봅시다. 각 배열에는 문자열 (또는 기타)의 Value 속성이 있습니다. 그리고 각각의 결과를 반복해야하고, 결과가 같으면 어떤 동작을 수행한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="dc657383123e3b34e3dc9324b5bc94793d6b0ec9" translate="yes" xml:space="preserve">
          <source>Create a true array</source>
          <target state="translated">진정한 배열 만들기</target>
        </trans-unit>
        <trans-unit id="6ebbbdefb07c190cb50e696dfd8fd8b8232a9dd9" translate="yes" xml:space="preserve">
          <source>Destructuring and using of the spread operator have proven quite useful for newcomers to ECMAScript&amp;nbsp;6 as being more human-readable/aesthetic, although some JavaScript veterans might consider it messy. Juniors or some other people might find it useful.</source>
          <target state="translated">스프레드 연산자의 구조화 및 사용은 ECMAScript 6을 처음 사용하는 사람들이 좀 더 사람이 읽을 수 있고 심미적 인 것으로 매우 유용한 것으로 입증되었지만 일부 JavaScript 재향 군인은 지저분한 것으로 간주 할 수 있습니다. 주니어 나 다른 사람들이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="1daaad0084c2604185e45c5a29dc6efeff0b7fce" translate="yes" xml:space="preserve">
          <source>Details:</source>
          <target state="translated">Details:</target>
        </trans-unit>
        <trans-unit id="c472a51872469dd7221cdb8ed81b476216096187" translate="yes" xml:space="preserve">
          <source>Disadvantages:</source>
          <target state="translated">Disadvantages:</target>
        </trans-unit>
        <trans-unit id="6c93fe8028eb2c06aa7aad788adaf00386420ed1" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;for-in&lt;/code&gt; unless you use it with safeguards or are at least aware of why it might bite you.</source>
          <target state="translated">안전 장치와 함께 사용하거나 그것이 왜 당신을 물릴 수 있는지 알지 못한다면 &lt;code&gt;for-in&lt;/code&gt; 을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d08ac59c6f776a259666b38bd6f6b67c6ac20550" translate="yes" xml:space="preserve">
          <source>ECMAScript&amp;nbsp;5 (the version on JavaScript) to work with Arrays:</source>
          <target state="translated">ECMAScript 5 (JavaScript의 버전)는 어레이와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d365e59cfe702f0dc8ea35a70c741654a39fed8f" translate="yes" xml:space="preserve">
          <source>ES2015 adds &lt;em&gt;iterators&lt;/em&gt; to JavaScript. The easiest way to use iterators is the new &lt;code&gt;for-of&lt;/code&gt; statement. It looks like this:</source>
          <target state="translated">ES2015는 JavaScript에 &lt;em&gt;반복자&lt;/em&gt; 를 추가 &lt;em&gt;합니다&lt;/em&gt; . 반복자를 사용하는 가장 쉬운 방법은 새로운 &lt;code&gt;for-of&lt;/code&gt; 문입니다. 다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="89cce593f5131e64c65adfb3e7a2a8a99ecd6047" translate="yes" xml:space="preserve">
          <source>Each p tag gets &lt;code&gt;class=&quot;blue&quot;&lt;/code&gt;</source>
          <target state="translated">각 p 태그는 &lt;code&gt;class=&quot;blue&quot;&lt;/code&gt; 를 받습니다.</target>
        </trans-unit>
        <trans-unit id="a03f898632fc9e1da60588b88699c530174fddff" translate="yes" xml:space="preserve">
          <source>Easy readability</source>
          <target state="translated">쉬운 가독성</target>
        </trans-unit>
        <trans-unit id="a1360cfea2542d434b165c5be72693e776eefce5" translate="yes" xml:space="preserve">
          <source>Easy writability</source>
          <target state="translated">손쉬운 쓰기</target>
        </trans-unit>
        <trans-unit id="5c260a8d97db3363bbeeb8cd4f1afd6ee2424cdf" translate="yes" xml:space="preserve">
          <source>Efficiency. &lt;code&gt;angular.forEach&lt;/code&gt;, and the native &lt;code&gt;forEach&lt;/code&gt;, for that matter, are both &lt;em&gt;so much&lt;/em&gt; slower than the normal &lt;code&gt;for&lt;/code&gt; loop....about &lt;a href=&quot;http://jsperf.com/angular-foreach-vs-native-for-loop/3&quot;&gt;90% slower&lt;/a&gt;. So for large data sets, best to stick to the native &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">능률. &lt;code&gt;angular.forEach&lt;/code&gt; 및 기본 &lt;code&gt;forEach&lt;/code&gt; 는 그 문제에 대해 일반 &lt;code&gt;for&lt;/code&gt; 루프보다 &lt;em&gt;훨씬&lt;/em&gt; 느리다 ... 약 &lt;a href=&quot;http://jsperf.com/angular-foreach-vs-native-for-loop/3&quot;&gt;90 % 느리다&lt;/a&gt; . 따라서 큰 데이터 세트의 경우 기본 &lt;code&gt;for&lt;/code&gt; 루프를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9bbc4aeb0980cee945b58ff2f771d473c92abbcf" translate="yes" xml:space="preserve">
          <source>Every other p tag gets &lt;code&gt;class=&quot;red&quot;&lt;/code&gt;&amp;gt;</source>
          <target state="translated">다른 모든 p 태그는 &lt;code&gt;class=&quot;red&quot;&lt;/code&gt; &amp;gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="31d46401beeeb139181157a391e38208292ff52c" translate="yes" xml:space="preserve">
          <source>For Actual Arrays</source>
          <target state="translated">실제 배열의 경우</target>
        </trans-unit>
        <trans-unit id="574d2bfcf687ca1c9e5ae449855c6a7b3be2b282" translate="yes" xml:space="preserve">
          <source>For Array-Like Objects</source>
          <target state="translated">배열과 같은 객체</target>
        </trans-unit>
        <trans-unit id="4c9f1e7b36c7b85949136c05d06c3d1376f6fb79" translate="yes" xml:space="preserve">
          <source>For maximum browser support, &lt;code&gt;for..of&lt;/code&gt;&lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-471169142&quot;&gt;requires a polyfill&lt;/a&gt; for iterators, making your app slightly slower to execute and slightly larger to download.</source>
          <target state="translated">브라우저를 최대한 지원 &lt;a href=&quot;https://github.com/airbnb/javascript/issues/1122#issuecomment-471169142&quot;&gt;하려면 for..of&lt;/a&gt; 에 반복 자를 위한 &lt;code&gt;for..of&lt;/code&gt; 필요하므로 앱 실행 속도가 약간 느려지고 다운로드 크기가 약간 커집니다.</target>
        </trans-unit>
        <trans-unit id="07dab6b0cba0aafb7fb630f2e41c7bbe0d2fa27e" translate="yes" xml:space="preserve">
          <source>For more information and examples about functional programming on arrays, look at the blog post &lt;em&gt;&lt;a href=&quot;http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/&quot;&gt;Functional programming in JavaScript: map, filter and reduce&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">배열의 함수형 프로그래밍에 대한 자세한 내용과 예제는 &lt;em&gt;&lt;a href=&quot;http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/&quot;&gt;map, filter and reduce :&lt;/a&gt;&lt;/em&gt; 블로그 &lt;em&gt;JavaScript 함수형 프로그래밍&lt;/em&gt; 블로그를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e5b5226b5b2f9ba8ea80f8e646bec60d9ae27902" translate="yes" xml:space="preserve">
          <source>For that reason (and to encourage use of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt;), &lt;a href=&quot;https://github.com/airbnb/javascript#iterators-and-generators&quot;&gt;some front-end style guides&lt;/a&gt; ban &lt;code&gt;for..of&lt;/code&gt; completely!</source>
          <target state="translated">이러한 이유로 (그리고 &lt;code&gt;map&lt;/code&gt; 과 &lt;code&gt;filter&lt;/code&gt; 사용을 장려하기 위해) &lt;a href=&quot;https://github.com/airbnb/javascript#iterators-and-generators&quot;&gt;일부 프론트 엔드 스타일 가이드는&lt;/a&gt; 완전히 금지됩니다!</target>
        </trans-unit>
        <trans-unit id="740b5208eb855ba5fe663f7061e6d63db399e3ab" translate="yes" xml:space="preserve">
          <source>For-each over an array in JavaScript</source>
          <target state="translated">JavaScript에서 각 배열에 대해</target>
        </trans-unit>
        <trans-unit id="4b1bffa7198cab670a61e9e726dc8034ad855ba9" translate="yes" xml:space="preserve">
          <source>ForEach</source>
          <target state="translated">ForEach</target>
        </trans-unit>
        <trans-unit id="0b863337ad80c0e087cc5bb5e2ee2b6648e7963d" translate="yes" xml:space="preserve">
          <source>Foreach is basically a High Order Function, Which takes another function as its parameter.</source>
          <target state="translated">Foreach는 기본적으로 다른 함수를 매개 변수로 사용하는 고차 함수입니다.</target>
        </trans-unit>
        <trans-unit id="8a78ff713dd92b2ecbc101771445889515332055" translate="yes" xml:space="preserve">
          <source>Granted this is a very simple hypothetical example, but I've written triple embedded for loops using the second approach and it was &lt;em&gt;very&lt;/em&gt; hard to read, and write for that matter.</source>
          <target state="translated">이것은 매우 간단한 가상의 예이지만, 두 번째 접근 방식을 사용하여 루프 용 트리플 임베디드를 작성했으며 읽기 및 쓰기가 &lt;em&gt;매우&lt;/em&gt; 어려웠습니다.</target>
        </trans-unit>
        <trans-unit id="4007b162af20ada18ae8a52aec1f5ada3364061d" translate="yes" xml:space="preserve">
          <source>Host objects may implement these internal methods in any manner unless specified otherwise; for example, one possibility is that &lt;code&gt;[[Get]]&lt;/code&gt; and &lt;code&gt;[[Put]]&lt;/code&gt; for a particular host object indeed fetch and store property values but &lt;code&gt;[[HasProperty]]&lt;/code&gt; always generates &lt;strong&gt;false&lt;/strong&gt;.</source>
          <target state="translated">호스트 객체는 달리 명시되지 않는 한 어떤 방식 으로든 이러한 내부 메소드를 구현할 수 있습니다. 예를 들어 특정 호스트 개체에 대한 &lt;code&gt;[[Get]]&lt;/code&gt; 및 &lt;code&gt;[[Put]]&lt;/code&gt; 은 실제로 속성 값을 가져오고 저장하지만 &lt;code&gt;[[HasProperty]]&lt;/code&gt; 는 항상 &lt;strong&gt;false를&lt;/strong&gt; 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19813696848672a3c1fd16a6dcede994e8b0ea3c" translate="yes" xml:space="preserve">
          <source>How can I loop through all the entries in an array using JavaScript?</source>
          <target state="translated">JavaScript를 사용하여 배열의 모든 항목을 반복하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="ca7b3040f56acb6407fc724b0d2fd827a45691bf" translate="yes" xml:space="preserve">
          <source>However in practice that is &lt;strong&gt;not&lt;/strong&gt; actually a reliable indication of intent, since it is indistinguishable from those occasions when you &lt;strong&gt;&lt;em&gt;do&lt;/em&gt;&lt;/strong&gt; care about the order, and really do &lt;strong&gt;&lt;em&gt;need&lt;/em&gt;&lt;/strong&gt; to loop in reverse.  So in fact another construct would be needed to accurately express the &quot;don't care&quot; intent, something currently unavailable in most languages, including ECMAScript, but which could be called, for example, &lt;code&gt;forEachUnordered()&lt;/code&gt;.</source>
          <target state="translated">그러나 실제로는 의도를 확실하게 나타내는 것은 &lt;strong&gt;아닙니다&lt;/strong&gt; . 순서를 신경 쓰면서 실제로 역순으로 반복 &lt;strong&gt;&lt;em&gt;해야하는&lt;/em&gt;&lt;/strong&gt; 경우와 구별 할 수 없기 때문입니다. 실제로 ECMAScript를 포함하여 대부분의 언어에서 사용할 수 없지만 &lt;code&gt;forEachUnordered()&lt;/code&gt; 와 같이 호출 할 수없는 &quot; 무정의 &quot;의도를 정확하게 표현하기 위해서는 다른 구성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="61f75f3469a29e1942e3c3329af27ea060513a5e" translate="yes" xml:space="preserve">
          <source>However, note that there may be reasons to use an even simpler &lt;code&gt;for&lt;/code&gt; loop (see Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504&quot;&gt;Why is using &amp;ldquo;for&amp;hellip;in&amp;rdquo; with array iteration such a bad idea?&lt;/a&gt;&lt;/em&gt;)</source>
          <target state="translated">그러나 더 간단한 &lt;code&gt;for&lt;/code&gt; 루프를 사용해야하는 이유가있을 수 있습니다 (스택 오버플로 질문 참조 : &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504&quot;&gt;배열 반복에서&amp;ldquo;for&amp;hellip; in&amp;rdquo;을 사용하는 것은 왜 그렇게 나쁜 생각입니까?&lt;/a&gt;&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="a6aed835f2d563c4c3320a911d587d82dbda800c" translate="yes" xml:space="preserve">
          <source>I also would like to add this as a composition of a reverse loop and an answer above for someone that would like this syntax too.</source>
          <target state="translated">나는 이것을 역 루프의 구성 과이 구문을 좋아하는 누군가를위한 위의 답변으로 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="8477c992b5ade4df47cd7654aa1828b412e4a489" translate="yes" xml:space="preserve">
          <source>I know this is an old post, and there are so many great answers already. For a little more completeness I figured I'd throw in another one using &lt;a href=&quot;https://angularjs.org/&quot;&gt;AngularJS&lt;/a&gt;. Of course, this only applies if you're using Angular, obviously, nonetheless I'd like to put it anyway.</source>
          <target state="translated">나는 이것이 오래된 게시물이라는 것을 알고 있으며 이미 많은 훌륭한 답변이 있습니다. 좀 더 완전성을 위해 &lt;a href=&quot;https://angularjs.org/&quot;&gt;AngularJS를&lt;/a&gt; 사용하여 다른 것을 던질 것이라고 생각했습니다. 물론 이것은 Angular를 사용하는 경우에만 적용되지만 분명히 어쨌든 넣고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="1c59ff4d9355404cf9a4b93a2e4792e99f5c4e05" translate="yes" xml:space="preserve">
          <source>I think the &lt;em&gt;reverse&lt;/em&gt; for loop deserves a mention here:</source>
          <target state="translated">&lt;em&gt;역&lt;/em&gt; for 루프는 여기에 언급 할 가치가 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="f6502d93534ccbe12812234fb241d45f4ba61f26" translate="yes" xml:space="preserve">
          <source>I thought it was something like this:</source>
          <target state="translated">나는 이것이 다음과 같다고 생각했다.</target>
        </trans-unit>
        <trans-unit id="3603f48e92361f2a2fc432d1e620a715ff3fe622" translate="yes" xml:space="preserve">
          <source>I usually use the</source>
          <target state="translated">나는 보통</target>
        </trans-unit>
        <trans-unit id="12bc6fc52aa07da9df836fd7799f22941f498dc1" translate="yes" xml:space="preserve">
          <source>I'll quickly note that you can use the ES2015 options &lt;em&gt;now&lt;/em&gt;, even on ES5 engines, by &lt;em&gt;transpiling&lt;/em&gt; ES2015 to ES5. Search for &quot;ES2015 transpiling&quot; / &quot;ES6 transpiling&quot; for more...</source>
          <target state="translated">ES2015를 ES5로 변환하여 ES5 엔진에서도 &lt;em&gt;지금&lt;/em&gt; ES2015 옵션을 사용할 수 있습니다. 자세한 내용은 &quot;ES2015 transpiling&quot;/ &quot;ES6 transpiling&quot;을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="18c6f30a69467c4462f7d6abc615a72db576f06d" translate="yes" xml:space="preserve">
          <source>I'm sure there's various other pros and cons as well, and please feel free to add any that you see fit. I feel that, bottom line, if you need efficiency, stick with just the native &lt;code&gt;for&lt;/code&gt; loop for your looping needs. But, if your datasets are smaller and a some efficiency is okay to give up in exchange for readability and writability, then by all means throw an &lt;code&gt;angular.forEach&lt;/code&gt; in that bad boy.</source>
          <target state="translated">나는 다양한 장단점이있을 것이라고 확신하며, 당신이 적합하다고 생각하는 것을 자유롭게 추가하십시오. 결론은 효율성이 필요한 경우 루핑 요구에 맞는 기본 &lt;code&gt;for&lt;/code&gt; 루프를 고수하는 것입니다. 그러나 데이터 세트가 더 작고 가독성 및 쓰기 가능성과 교환하여 포기할 수있는 효율성이 &lt;code&gt;angular.forEach&lt;/code&gt; , 반드시 나쁜 소년에게 각도 를 던져야합니다.</target>
        </trans-unit>
        <trans-unit id="06ac5670940bbfb285c1ba0308b4821c84d5e171" translate="yes" xml:space="preserve">
          <source>If available, &lt;code&gt;angular.forEach&lt;/code&gt; will use the ES5 forEach loop. Now, I will get to efficientcy in the cons section, as the forEach loops are &lt;em&gt;much&lt;/em&gt; slower than the for loops. I mention this as a pro because it's nice to be consistent and standardized.</source>
          <target state="translated">가능한 경우 &lt;code&gt;angular.forEach&lt;/code&gt; 는 ES5 forEach 루프를 사용합니다. forEach 루프가 for 루프보다 &lt;em&gt;훨씬&lt;/em&gt; 느리므로 단점 섹션에서 효율성을 얻을 것입니다. 일관성 있고 표준화 된 것이 좋기 때문에 이것을 전문가라고 언급합니다.</target>
        </trans-unit>
        <trans-unit id="e8907402896b09c17431fc05797665a93d1d2ebc" translate="yes" xml:space="preserve">
          <source>If order doesn't matter, and &lt;strong&gt;efficiency&lt;/strong&gt; is a concern (in the innermost loop of a game or animation engine), then it may be acceptable to use the reverse for loop as your go-to pattern.  Just remember that seeing a reverse for loop in existing code &lt;strong&gt;does not necessarily mean&lt;/strong&gt; that the order irrelevant!</source>
          <target state="translated">순서가 중요하지 않고 &lt;strong&gt;효율성&lt;/strong&gt; 이 문제가되는 경우 (게임 또는 애니메이션 엔진의 가장 안쪽 루프에서) 역방향 for 루프를 이동 패턴으로 사용하는 것이 좋습니다. 기존 코드에서 역 for 루프를 보는 &lt;strong&gt;것이 반드시&lt;/strong&gt; 순서와 관련 &lt;strong&gt;이 없다는 것을 의미하지는 않습니다&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="b80d2d2ba2c3b20f6e937c93c538d0e0be32e646" translate="yes" xml:space="preserve">
          <source>If the length of the array won't change during the loop, and it's in performance-sensitive code (unlikely), a slightly more complicated version grabbing the length up front might be a &lt;strong&gt;&lt;em&gt;tiny&lt;/em&gt;&lt;/strong&gt; bit faster:</source>
          <target state="translated">루프 동안 배열의 길이가 변경되지 않고 성능에 민감한 코드 인 경우 (앞의 경우), 앞쪽의 길이를 잡는 약간 더 복잡한 버전이 조금 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b92dceb455d82f7bd9cef350ebca0d33e590aa5b" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;modify the array&lt;/strong&gt; while looping, at or after index &lt;em&gt;i&lt;/em&gt; (for example you remove or insert an item at &lt;code&gt;array[i]&lt;/code&gt;), then a forward loop would skip the item that shifted left into position &lt;em&gt;i&lt;/em&gt;, or re-process the &lt;em&gt;i&lt;/em&gt;th item that was shifted right.  In a traditional for loop, you &lt;em&gt;could&lt;/em&gt; update &lt;em&gt;i&lt;/em&gt; to point to the next item that needs processing - 1, but simply reversing the direction of iteration is often a &lt;strong&gt;simpler&lt;/strong&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/23186254/javascript-splice-changing-earlier-values-in-an-array/23186450#23186450&quot;&gt;more elegant solution&lt;/a&gt;.</source>
          <target state="translated">반복하는 동안, 인덱스 &lt;em&gt;i&lt;/em&gt; 또는 그 이후에 &lt;strong&gt;배열&lt;/strong&gt; 을 &lt;strong&gt;수정하면&lt;/strong&gt; (예를 들어 &lt;code&gt;array[i]&lt;/code&gt; 에서 항목을 제거 또는 삽입), 순방향 루프는 &lt;em&gt;i&lt;/em&gt; 위치로 왼쪽으로 이동 한 항목을 건너 뛰거나 &lt;em&gt;i&lt;/em&gt; 를 다시 처리합니다. 오른쪽으로 이동 한 항목 전통적인 for 루프에서는 &lt;em&gt;i&lt;/em&gt; 를 처리해야하는 다음 항목을 가리 키도록 업데이트 할 &lt;em&gt;수&lt;/em&gt; 있지만 반복 방향을 반대로 바꾸는 것이 &lt;strong&gt;더 단순&lt;/strong&gt; 하고 &lt;a href=&quot;https://stackoverflow.com/questions/23186254/javascript-splice-changing-earlier-values-in-an-array/23186450#23186450&quot;&gt;더 우아한 솔루션 인&lt;/a&gt; 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="2e64946b63608dcfc94ea160317714137b7354db" translate="yes" xml:space="preserve">
          <source>If you are a jQuery &lt;em&gt;fan&lt;/em&gt; and already have a jQuery file running, you should reverse the positions of the index and value parameters</source>
          <target state="translated">jQuery &lt;em&gt;팬&lt;/em&gt; 이고 이미 jQuery 파일이 실행중인 경우 인덱스 및 값 매개 변수의 위치를 ​​반대로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="13ddd4cb90755914bc68cb46a5dcb9579aa341e2" translate="yes" xml:space="preserve">
          <source>If you don't mind emptying the array:</source>
          <target state="translated">배열을 비우지 않아도되는 경우 :</target>
        </trans-unit>
        <trans-unit id="ae87d418a37aaf3cda30fae440c63ffde95ff67b" translate="yes" xml:space="preserve">
          <source>If you had five divs, you'd get &quot;Index is: 0&quot; if you clicked the first and &quot;Index is: 4&quot; if you clicked the last. This does &lt;strong&gt;not&lt;/strong&gt; work if you use &lt;code&gt;var&lt;/code&gt; instead of &lt;code&gt;let&lt;/code&gt;.</source>
          <target state="translated">5 개의 div가있는 경우 첫 번째를 클릭하면 &quot;Index is : 0&quot;이 표시되고 마지막을 클릭하면 &quot;Index is : 4&quot;가 표시됩니다. &lt;code&gt;let&lt;/code&gt; 대신 &lt;code&gt;var&lt;/code&gt; 를 사용하면 작동하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5d8e10b19a52f515f5ce1b1b685c8f30f79143a6" translate="yes" xml:space="preserve">
          <source>If you have a massive array you should use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt;&lt;strong&gt;&lt;code&gt;iterators&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; to gain some efficiency. Iterators are a property of certain JavaScript collections (like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;). Even, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt;&lt;code&gt;for..of&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; uses &lt;strong&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/strong&gt; under-the-hood.</source>
          <target state="translated">대규모 배열을 사용하는 경우 효율성을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt;&lt;strong&gt; &lt;code&gt;iterators&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 려면 &lt;strong&gt;반복자&lt;/strong&gt; 를 사용해야 &lt;strong&gt;합니다&lt;/strong&gt; . 반복자는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 와 같은 특정 JavaScript 컬렉션의 속성입니다. 심지어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt; &lt;code&gt;for..of&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 는 &lt;strong&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/strong&gt; 를 사용 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="937ed980f598e6ed46ab0a45f6808c763154dc2c" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;Array.prototype&lt;/code&gt; functions with &lt;em&gt;host-provided&lt;/em&gt; array-like objects (DOM lists and other things provided by the browser rather than the JavaScript engine), you need to be sure to test in your target environments to make sure the host-provided object behaves properly. &lt;strong&gt;Most do behave properly&lt;/strong&gt; (now), but it's important to test. The reason is that most of the &lt;code&gt;Array.prototype&lt;/code&gt; methods you're likely to want to use rely on the host-provided object giving an honest answer to the abstract &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p&quot;&gt;&lt;code&gt;[[HasProperty]]&lt;/code&gt;&lt;/a&gt; operation. As of this writing, browsers do a very good job of this, but the 5.1 spec did allow for the possibility a host-provided object may not be honest. It's in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2&quot;&gt;&amp;sect;8.6.2&lt;/a&gt;, several paragraphs below the big table near the beginning of that section), where it says:</source>
          <target state="translated">&lt;em&gt;호스트 제공&lt;/em&gt; 배열과 유사한 객체 (JavaScript 엔진이 아닌 브라우저에서 제공하는 DOM 목록 및 기타 항목)와 함께 &lt;code&gt;Array.prototype&lt;/code&gt; 함수를 사용하는 경우 대상 환경에서 테스트하여 호스트 제공 여부를 확인해야합니다 개체가 올바르게 동작합니다. &lt;strong&gt;대부분은 올바르게 동작&lt;/strong&gt; 하지만 (지금) 테스트하는 것이 중요합니다. 사용하려는 &lt;code&gt;Array.prototype&lt;/code&gt; 메서드의 대부분은 추상 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-hasproperty-p&quot;&gt; &lt;code&gt;[[HasProperty]]&lt;/code&gt; &lt;/a&gt; 작업에 정직한 답변을 제공하는 호스트 제공 객체에 의존하기 때문입니다. 이 글을 쓰는 시점에서 브라우저는이 작업을 훌륭하게 수행하지만 5.1 사양에서는 호스트 제공 객체가 정직하지 않을 수 있습니다. 그것은 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-8.6.2&quot;&gt;&amp;sect;8.6.2&lt;/a&gt; 에 있으며 , 그 섹션의 시작 부분 근처에 큰 테이블 아래에 여러 단락이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cf65717377f5a0ffbf4016aa7b65a5777d9b6bb" translate="yes" xml:space="preserve">
          <source>If you want to break, a little more logic:</source>
          <target state="translated">깨고 싶다면 조금 더 논리를 :</target>
        </trans-unit>
        <trans-unit id="1aae02233e247aceba4786eb942d19b76a8c3c1d" translate="yes" xml:space="preserve">
          <source>If you want to loop over an array, use the standard three-part &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">배열을 반복하려면 표준 3 파트 &lt;code&gt;for&lt;/code&gt; 루프를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="11105b5c63e872bf555853378e76dfee57d8fded" translate="yes" xml:space="preserve">
          <source>If you want to loop through an array of objects with the arrow function:</source>
          <target state="translated">화살표 기능을 사용하여 객체 배열을 반복하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="986435ae4b5acc19dfcae749d8f1c3e4994226d8" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;for()&lt;/code&gt;, it will look like -</source>
          <target state="translated">&lt;code&gt;for()&lt;/code&gt; 를 사용하려는 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4acb3d06d2c92261570911bf5c1b6824ec6805ec" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;forEach()&lt;/code&gt;, it will look like -</source>
          <target state="translated">&lt;code&gt;forEach()&lt;/code&gt; 를 사용하려는 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fc44f65228be3d46253870a654fc920e523f6cf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the &lt;a href=&quot;http://jquery.com/&quot;&gt;&lt;strong&gt;jQuery&lt;/strong&gt;&lt;/a&gt; library, you can use &lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;&lt;strong&gt;jQuery.each&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://jquery.com/&quot;&gt;&lt;strong&gt;jQuery&lt;/strong&gt;&lt;/a&gt; 라이브러리를 사용하는 경우 &lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;&lt;strong&gt;jQuery.each&lt;/strong&gt;&lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a9d6ebddd744df1593bd5988193105784652f8b" translate="yes" xml:space="preserve">
          <source>If you're going to do that a lot, you might want to grab a copy of the function reference into a variable for reuse, e.g.:</source>
          <target state="translated">그렇게 많이 할 경우, 함수 참조의 복사본을 재사용을 위해 변수로 가져와야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd131ceaa21a63af287b484051a159dfdece2176" translate="yes" xml:space="preserve">
          <source>If you're worried about the runtime cost of making a function call for each array entry, don't be; &lt;a href=&quot;http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html&quot;&gt;details&lt;/a&gt;.</source>
          <target state="translated">각 배열 항목에 대한 함수 호출의 런타임 비용이 걱정된다면 걱정하지 마십시오. &lt;a href=&quot;http://blog.niftysnippets.org/2012/02/foreach-and-runtime-cost.html&quot;&gt;세부 사항&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40638a60a037cede5301ef987dee8d1ace1a9b0f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt; there will be a forEach method on the array prototype, but it is not supported in legacy browsers. So to be able to use it consistently you must either have an environment that supports it (for example, &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; for server side JavaScript), or use a &quot;Polyfill&quot;. The Polyfill for this functionality is, however, trivial and since it makes the code easier to read, it is a good polyfill to include.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/ECMAScript#ECMAScript.2C_5th_Edition&quot;&gt;ECMAScript 5&lt;/a&gt; 에는 어레이 프로토 타입에 forEach 메소드가 있지만 레거시 브라우저에서는 지원되지 않습니다. 일관성있게 사용하려면이를 지원하는 환경 (예 : 서버 측 JavaScript의 경우 &lt;a href=&quot;http://en.wikipedia.org/wiki/Node.js&quot;&gt;Node.js&lt;/a&gt; )이 있거나 &quot;폴리 필&quot;을 사용해야합니다. 그러나이 기능에 대한 Polyfill은 사소한 것이며 코드를 읽기 쉽도록 포함하기에 좋은 polyfill입니다.</target>
        </trans-unit>
        <trans-unit id="1280ba4c719753e18ee74f317b64294340b96082" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in&quot;&gt;for_each...in&lt;/a&gt;&lt;/em&gt; (MDN) it is explained that &lt;code&gt;for each (variable in object)&lt;/code&gt; is deprecated as the part of ECMA-357 (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/E4X&quot;&gt;EAX&lt;/a&gt;) standard.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in&quot;&gt;for_each ... in&lt;/a&gt;&lt;/em&gt; (MDN)에서는 &lt;code&gt;for each (variable in object)&lt;/code&gt; ECMA-357 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/E4X&quot;&gt;EAX&lt;/a&gt; ) 표준의 일부로 사용되지 않는다고 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9beb0c3410927f822bce0dcb01f44ccc46812376" translate="yes" xml:space="preserve">
          <source>In ES2015 and higher, you can make your index and value variables local to the &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">ES2015 이상에서는 인덱스 및 값 변수를 &lt;code&gt;for&lt;/code&gt; 루프에 대해 로컬로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd3e11ca52c117696a761c0998ed90bfcd20a96" translate="yes" xml:space="preserve">
          <source>In any vaguely-modern environment (so, not IE8) where you have access to the &lt;code&gt;Array&lt;/code&gt; features added by ES5 (directly or using polyfills), you can use &lt;code&gt;forEach&lt;/code&gt; (&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt;&lt;code&gt;spec&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;MDN&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">ES5에 의해 추가 된 &lt;code&gt;Array&lt;/code&gt; 기능 (직접 또는 폴리 필 사용)에 액세스 할 수있는 모호한 현대 환경 (IE8이 아님)에서 &lt;code&gt;forEach&lt;/code&gt; ( &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-array.prototype.foreach&quot;&gt; &lt;code&gt;spec&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;MDN&lt;/code&gt; &lt;/a&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3516d7a0d41bd0df93ef14853544e18b99e2cde" translate="yes" xml:space="preserve">
          <source>In case, more interested on operation on array using some inbuilt feature.</source>
          <target state="translated">내장 기능을 사용하는 어레이에서의 작업에 더 관심이있는 경우.</target>
        </trans-unit>
        <trans-unit id="99006d079057d1e0af6e98a54c83d22f0c6ba073" translate="yes" xml:space="preserve">
          <source>In general for higher level code where &lt;strong&gt;clarity and safety&lt;/strong&gt; are greater concerns, I previously recommended using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array::forEach&lt;/code&gt;&lt;/a&gt; as your default pattern for looping (although these days I prefer to use &lt;code&gt;for..of&lt;/code&gt;).  Reasons to prefer &lt;code&gt;forEach&lt;/code&gt; over a reverse loop are:</source>
          <target state="translated">일반적으로 &lt;strong&gt;명확성과 안전&lt;/strong&gt; 이 더 중요한 고급 코드의 경우 루프의 기본 패턴으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array::forEach&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 (요즘에는 &lt;code&gt;for..of&lt;/code&gt; 사용하는 것이 좋습니다 ). 역방향 루프보다 &lt;code&gt;forEach&lt;/code&gt; 를 선호하는 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="268bee6cf2ad84db04fb8978e3c41ceecff7fc38" translate="yes" xml:space="preserve">
          <source>In tests we calculate the sum of array elements. I perform a test for small arrays (10 elements) and big arrays (1M elements) and divide them into three groups:</source>
          <target state="translated">테스트에서 배열 요소의 합을 계산합니다. 작은 배열 (10 요소)과 큰 배열 (1M 요소)에 대한 테스트를 수행하고 세 그룹으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="3fb2676f32b14c1a1bbfd3126c8971f3d39c2fe6" translate="yes" xml:space="preserve">
          <source>In the traditional forwards for loop, &lt;code&gt;i++&lt;/code&gt; and &lt;code&gt;++i&lt;/code&gt; are interchangeable (as Douglas Crockford points out).  However in the reverse for loop, because our decrement is also our condition expression, we must stick with &lt;code&gt;i--&lt;/code&gt; if we want to process the item at index 0.</source>
          <target state="translated">기존의 forfor 루프에서는 &lt;code&gt;i++&lt;/code&gt; 와 &lt;code&gt;++i&lt;/code&gt; 가 서로 호환됩니다 (Douglas Crockford가 지적한 것처럼). 그러나 역 for 루프에서는 감소가 조건 표현식이기 때문에 인덱스 0에서 항목을 처리하려면 &lt;code&gt;i--&lt;/code&gt; 를 고수해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f2a940ef1876e18b0a2d2adbbb0054401c1e001" translate="yes" xml:space="preserve">
          <source>It gives you a free scope for closures.</source>
          <target state="translated">폐쇄의 자유 범위를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a26206100bd26a40a1a52fbba4254be28b14f1b7" translate="yes" xml:space="preserve">
          <source>It indicates that &lt;em&gt;i&lt;/em&gt; is not going to be shifted within the block (which is always a possible surprise hiding in long &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; loops).</source>
          <target state="translated">그것은 블록 내에서 &lt;em&gt;i&lt;/em&gt; 가 이동하지 않을 것임을 나타냅니다 (항상 long 루프와 &lt;code&gt;while&lt;/code&gt; 루프에서 숨길 수있는 놀라운 일입니다).</target>
        </trans-unit>
        <trans-unit id="9c1e136ecc6d6ff5b0bb24c065a47cca352d2f77" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;shorter&lt;/strong&gt; to type, and &lt;strong&gt;read&lt;/strong&gt;, than some of the other options available.  Although it loses to &lt;code&gt;forEach()&lt;/code&gt; and to ES6's &lt;code&gt;for ... of&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 다른 옵션 중 일부를 입력하고 &lt;strong&gt;읽는&lt;/strong&gt; 것이 &lt;strong&gt;더 짧&lt;/strong&gt; 습니다. &lt;code&gt;forEach()&lt;/code&gt; 및 ES6의 &lt;code&gt;for ... of&lt;/code&gt; 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="e1592309e0411fe23d697624a6b081cb0ad5da05" translate="yes" xml:space="preserve">
          <source>It is clearer to read.</source>
          <target state="translated">읽는 것이 더 명확합니다.</target>
        </trans-unit>
        <trans-unit id="6fa8793a5b9a126bead6bc588548bf65c1d59eff" translate="yes" xml:space="preserve">
          <source>It is now even better to use for..of!</source>
          <target state="translated">이제는 사용하는 것이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4c654c5e846023844a47e14f6c000b121f5ea18b" translate="yes" xml:space="preserve">
          <source>It looks like the traditional &lt;code&gt;for i&lt;/code&gt; (&lt;strong&gt;Aa&lt;/strong&gt;) is a good choice to write fast code on all browsers.</source>
          <target state="translated">전통적인 &lt;code&gt;for i&lt;/code&gt; ( &lt;strong&gt;Aa&lt;/strong&gt; )는 모든 브라우저에서 빠른 코드를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b05ec9bd35f4ee8f34e03d2c14bb2cf3574009f2" translate="yes" xml:space="preserve">
          <source>It processes the items in reverse order.  If you were building a new array from the results, or printing things on screen, naturally &lt;strong&gt;the output will be reversed&lt;/strong&gt; with respect to the original order.</source>
          <target state="translated">항목을 역순으로 처리합니다. 결과에서 새 배열을 작성하거나 화면에 항목을 인쇄하는 경우 원래 순서에 &lt;strong&gt;따라 출력이&lt;/strong&gt; 자연스럽게 &lt;strong&gt;반전&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="92650d012635dc87fe3676b746f2df0b221ba0a1" translate="yes" xml:space="preserve">
          <source>It reduces leakage of local variables and accidental collision with (and mutation of) outer variables.</source>
          <target state="translated">지역 변수의 누출과 외부 변수와의 우연한 충돌 (및 변이)을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="c027793c4fcbf7f7be6aed911c23cf2d476fffe0" translate="yes" xml:space="preserve">
          <source>It returns:</source>
          <target state="translated">다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a66b905f75247eeead429833c89c54b6d523c59" translate="yes" xml:space="preserve">
          <source>It was better to use forEach()</source>
          <target state="translated">forEach ()를 사용하는 것이 좋습니다</target>
        </trans-unit>
        <trans-unit id="970da87efbe446de6ff12d27fb12ff80a89bc4c8" translate="yes" xml:space="preserve">
          <source>It's a &lt;a href=&quot;http://en.wikipedia.org/wiki/Sparse_array&quot;&gt;&lt;em&gt;sparse&lt;/em&gt; arrays&lt;/a&gt; with &lt;strong&gt;massive&lt;/strong&gt; gaps in it, or</source>
          <target state="translated">&lt;strong&gt;큰&lt;/strong&gt; 간격이있는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Sparse_array&quot;&gt;&lt;em&gt;희소&lt;/em&gt; 배열&lt;/a&gt; 이거나</target>
        </trans-unit>
        <trans-unit id="76bb57f065042a04a16fd907fcb40021f5d1d715" translate="yes" xml:space="preserve">
          <source>It's also possible to use ES2015's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;spread syntax&lt;/a&gt; with JavaScript engines that support this feature:</source>
          <target state="translated">이 기능을 지원하는 JavaScript 엔진과 함께 ES2015의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax&quot;&gt;스프레드 구문&lt;/a&gt; 을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf3b30579b92065eb7bc495af1fbdb1ca47efb2e" translate="yes" xml:space="preserve">
          <source>It's important to note that &lt;code&gt;Array.prototype.forEach&lt;/code&gt; doesn't break when the callback returns &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; provide their own variations on &lt;code&gt;each&lt;/code&gt; to provide loops that can be short-circuited.</source>
          <target state="translated">콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 할 때 &lt;code&gt;Array.prototype.forEach&lt;/code&gt; 가 중단되지 않습니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; 와 &lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; 는 &lt;code&gt;each&lt;/code&gt; 단락을 일으킬 수있는 루프를 제공하기 위해 고유 한 변형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8422ffb83ff856b5915a4e7e4e65862872e7a17c" translate="yes" xml:space="preserve">
          <source>Iterators are exhaustible in nature.</source>
          <target state="translated">반복자는 본질적으로 소진됩니다.</target>
        </trans-unit>
        <trans-unit id="dd908ea29f0174193357642014bde7f4f593cc70" translate="yes" xml:space="preserve">
          <source>Iterators improve efficiency by letting you consume the items in a list one at a time as if they were a stream. What makes an iterator special is how it traverses a collection. Other loops need to load the entire collection up front in order to iterate over it, whereas an iterator only needs to know the current position in the collection.</source>
          <target state="translated">반복자는 목록의 항목을 마치 스트림 인 것처럼 한 번에 하나씩 사용할 수 있도록하여 효율성을 향상시킵니다. 이터레이터를 특별하게 만드는 것은 컬렉션을 순회하는 방법입니다. 다른 루프는 전체 컬렉션을 반복해서로드해야하며 반복자는 컬렉션의 현재 위치 만 알면됩니다.</target>
        </trans-unit>
        <trans-unit id="b4cec08cd006bef91b92cd98b872c068dfc6d47a" translate="yes" xml:space="preserve">
          <source>JavaScript has powerful semantics for looping through arrays and array-like objects. I've split the answer into two parts: Options for genuine arrays, and options for things that are just array-&lt;em&gt;like&lt;/em&gt;, such as the &lt;code&gt;arguments&lt;/code&gt; object, other iterable objects (ES2015+), DOM collections, and so on.</source>
          <target state="translated">JavaScript에는 배열 및 배열과 유사한 객체를 반복하는 강력한 의미가 있습니다. 대답은 두 가지 부분으로 나뉩니다. 정규 배열 옵션과 &lt;code&gt;arguments&lt;/code&gt; 객체, 기타 반복 가능한 객체 (ES2015 +), DOM 컬렉션 등과 같이 배열 &lt;em&gt;과 비슷한 항목에&lt;/em&gt; 대한 옵션.</target>
        </trans-unit>
        <trans-unit id="45b89ea7174719fe9456dfc7830bcd1c7b08f842" translate="yes" xml:space="preserve">
          <source>Looking only at that first example: You can use &lt;code&gt;for-in&lt;/code&gt; to visit those sparse array elements if you use appropriate safeguards:</source>
          <target state="translated">첫 번째 예만 살펴보십시오 : 적절한 보호 조치를 사용하는 경우 &lt;code&gt;for-in&lt;/code&gt; 을 사용하여 희소 배열 요소를 방문 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4839c1708da783319e9fbcbf7bb1edf7ed55c460" translate="yes" xml:space="preserve">
          <source>Loop backwards</source>
          <target state="translated">뒤로 루프</target>
        </trans-unit>
        <trans-unit id="116eba95b7902da0b19b136ed240ca0e56d035ae" translate="yes" xml:space="preserve">
          <source>No break, continue, or return support. &lt;code&gt;continue&lt;/code&gt; is actually supported by &quot;&lt;a href=&quot;https://github.com/angular/angular.js/issues/263&quot;&gt;accident&lt;/a&gt;&quot;, to continue in an &lt;code&gt;angular.forEach&lt;/code&gt; you simple put a &lt;code&gt;return;&lt;/code&gt; statement in the function like &lt;code&gt;angular.forEach(array, function(item) { if (someConditionIsTrue) return; });&lt;/code&gt; which will cause it to continue out of the function for that iteration. This is also due to the fact that the native &lt;code&gt;forEach&lt;/code&gt; does not support break or continue either.</source>
          <target state="translated">휴식, 계속 또는 반환 지원이 없습니다. &lt;code&gt;continue&lt;/code&gt; 는 실제로 &quot; &lt;a href=&quot;https://github.com/angular/angular.js/issues/263&quot;&gt;사고&lt;/a&gt; &quot;에 의해 지원되며 &lt;code&gt;angular.forEach&lt;/code&gt; 를 계속 유지합니다 &lt;code&gt;return;&lt;/code&gt; &lt;code&gt;angular.forEach(array, function(item) { if (someConditionIsTrue) return; });&lt;/code&gt; 와 같은 함수의 문장 {if (someConditionIsTrue) return;}); 해당 반복에 대한 기능을 계속 수행하게됩니다. 이는 또한 &lt;code&gt;forEach&lt;/code&gt; 기본이 중단 또는 계속을 지원하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b8c4d2fd6737ec63b08a652d9add0b5b76e57401" translate="yes" xml:space="preserve">
          <source>Note the three checks:</source>
          <target state="translated">세 가지 확인 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="98d5f549991350bbddfb1b3e02a8c7d43a397e2d" translate="yes" xml:space="preserve">
          <source>Note, however, that this approach is only good if you have a dense array, and each index is occupied by an element. If the array is sparse, then you can run into performance problems with this approach, since you will iterate over a lot of indices that do not &lt;em&gt;really&lt;/em&gt; exist in the array. In this case, a &lt;code&gt;for .. in&lt;/code&gt;-loop might be a better idea. &lt;strong&gt;However&lt;/strong&gt;, you must use the appropriate safeguards to ensure that only the desired properties of the array (that is, the array elements) are acted upon, since the &lt;code&gt;for..in&lt;/code&gt;-loop will also be enumerated in legacy browsers, or if the additional properties are defined as &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">그러나이 방법은 밀도가 높은 배열이 있고 각 인덱스가 요소에 의해 점유 된 경우에만 유용합니다. 배열이 희소 한 경우이 방법으로 성능 문제가 발생할 수 있습니다. 배열에 &lt;em&gt;실제로&lt;/em&gt; 존재하지 않는 많은 인덱스를 반복하기 때문입니다. 이 경우 &lt;code&gt;for .. in&lt;/code&gt; loop가 더 좋습니다. &lt;strong&gt;그러나&lt;/strong&gt; &lt;code&gt;for..in&lt;/code&gt; - loop가 레거시 브라우저에도 열거되거나 추가 브라우저가 표시되므로 배열의 원하는 속성 (즉, 배열 요소) 만 작동하도록하려면 적절한 보호 수단을 사용해야합니다. 속성은 &lt;code&gt;enumerable&lt;/code&gt; 것으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="cdb386055d71d4e57655448305f3f266ba898acc" translate="yes" xml:space="preserve">
          <source>Now there are pros and cons of using the &lt;code&gt;angular.forEach&lt;/code&gt; function as opposed to the built in vanilla-flavored &lt;code&gt;for&lt;/code&gt; loop.</source>
          <target state="translated">이제 내장 된 바닐라 풍미 &lt;code&gt;for&lt;/code&gt; 루프와는 반대로 &lt;code&gt;angular.forEach&lt;/code&gt; 함수를 사용하는 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca0defbc542adca7eb89b7d006ccdd58542fae1e" translate="yes" xml:space="preserve">
          <source>Objects are not &lt;code&gt;iterable&lt;/code&gt; by default. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for..in&lt;/code&gt;&lt;/a&gt; in that case because instead of values it works with keys.</source>
          <target state="translated">기본적으로 객체는 &lt;code&gt;iterable&lt;/code&gt; 할 수 없습니다. 이 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for..in&lt;/code&gt; &lt;/a&gt; 을 사용하십시오. 값 대신 키와 작동하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dac14b18ddbcf811caa6f41435770bfcac91def3" translate="yes" xml:space="preserve">
          <source>Obviously, a simple &lt;code&gt;for&lt;/code&gt; loop applies to array-like objects.</source>
          <target state="translated">분명히 간단한 &lt;code&gt;for&lt;/code&gt; 루프는 배열과 같은 객체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b2eddf2aee3155f4ce4917a2380a892eac5b90f" translate="yes" xml:space="preserve">
          <source>Okay, let's look at our options:</source>
          <target state="translated">자, 우리의 옵션을 보자.</target>
        </trans-unit>
        <trans-unit id="a72c2c53fbdfb2727533feb058f51addfd63ad98" translate="yes" xml:space="preserve">
          <source>Or if you wanted to get an array of the tag names of the elements with a given class, you'd use the mapping function:</source>
          <target state="translated">또는 주어진 클래스가있는 요소의 태그 이름 배열을 얻으려면 매핑 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="073b8d82f68c2fdbe0506bde968834e71b06dd49" translate="yes" xml:space="preserve">
          <source>Other times, you may want to convert an array-like object into a true array. Doing that is surprisingly easy:</source>
          <target state="translated">다른 경우에는 배열과 유사한 객체를 실제 배열로 변환 할 수 있습니다. 그렇게하는 것은 놀라 울 정도로 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="aab5f282758bebdcb0646ab510ae5cc532d051d9" translate="yes" xml:space="preserve">
          <source>Personally, I tend to use whatever looks easiest to read, unless performance or minification has become a major concern.  So these days I prefer to use &lt;code&gt;for..of&lt;/code&gt; instead of &lt;code&gt;forEach()&lt;/code&gt;, but I will always use &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;&lt;code&gt;some&lt;/code&gt;&lt;/a&gt; when applicable. 
 (For the sake of my colleagues, I rarely use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">개인적으로, 성능이나 축소가 주요 관심사가되지 않는 한 읽기 쉬운 것처럼 보이는 것을 사용하는 경향이 있습니다. 그래서 요즘에는 &lt;code&gt;forEach()&lt;/code&gt; 대신 &lt;code&gt;for..of&lt;/code&gt; 를 사용하는 것을 선호하지만 적용 가능한 경우 항상 &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;filter&lt;/code&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt; &lt;code&gt;some&lt;/code&gt; &lt;/a&gt; 를 사용합니다. (내 동료를 위해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; 를&lt;/a&gt; 거의 사용하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="d3e73cee41706cbf172168c939a770206031ae4a" translate="yes" xml:space="preserve">
          <source>Probably the &lt;code&gt;for(i = 0; i &amp;lt; array.length; i++)&lt;/code&gt; loop is not the best choice. Why? If you have this:</source>
          <target state="translated">아마도 &lt;code&gt;for(i = 0; i &amp;lt; array.length; i++)&lt;/code&gt; 루프가 최선의 선택이 아닙니다. 왜? 이것이 있다면 :</target>
        </trans-unit>
        <trans-unit id="5ca16fb6579631abba9ef29095127fc1724ade2e" translate="yes" xml:space="preserve">
          <source>Repeatedly inserting siblings into the DOM as a first child in order to retain their order is &lt;strong&gt;less efficient&lt;/strong&gt;.  (The browser would keep having to shift things right.)  To create DOM nodes efficiently and in order, just loop forwards and append as normal (and also use a &quot;document fragment&quot;).</source>
          <target state="translated">순서를 유지하기 위해 형제를 첫 번째 자식으로 DOM에 반복적으로 삽입하는 것은 &lt;strong&gt;덜 효율적&lt;/strong&gt; 입니다. (브라우저는 계속해서 일을 올바르게 이동해야합니다.) DOM 노드를 효율적이고 순서대로 만들려면 앞으로 루프하고 정상적으로 추가하십시오 (또한 &quot;문서 조각&quot;을 사용하십시오).</target>
        </trans-unit>
        <trans-unit id="c3c204bcc11d0ba16e5b10935b855c9231c60df7" translate="yes" xml:space="preserve">
          <source>Results for Chrome. You can perform the test on your machine &lt;a href=&quot;https://jsbench.me/9uk4bj4svg&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">Chrome에 대한 결과. &lt;a href=&quot;https://jsbench.me/9uk4bj4svg&quot;&gt;여기에서&lt;/a&gt; 컴퓨터 에서 테스트를 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2632a58b332b7d1089e6d3db9b89fa34f55982ee" translate="yes" xml:space="preserve">
          <source>Results for Chrome. You can perform the test on your machine &lt;a href=&quot;https://jsbench.me/pxk4bicjru&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Chrome에 대한 결과. &lt;a href=&quot;https://jsbench.me/pxk4bicjru&quot;&gt;여기&lt;/a&gt; 에서 컴퓨터 에서 테스트를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2941ce8fc00301085c9d7ce71d82ff621ce0e501" translate="yes" xml:space="preserve">
          <source>Results for all tested browsers</source>
          <target state="translated">모든 테스트 된 브라우저에 대한 결과</target>
        </trans-unit>
        <trans-unit id="3ab8b51db1affd18d3dd969199d9006feae51589" translate="yes" xml:space="preserve">
          <source>See #4, we'll have to see how iterators play out.</source>
          <target state="translated"># 4를 보시면 반복자가 어떻게 진행되는지 살펴 봐야합니다.</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="b492c5ea4eeb39652fee30d40510ca39a54045aa" translate="yes" xml:space="preserve">
          <source>See the &lt;em&gt;Caveat for host-provided objects&lt;/em&gt; below. In particular, note that this will fail in IE8 and earlier, which don't let you use host-provided objects as &lt;code&gt;this&lt;/code&gt; like that.</source>
          <target state="translated">아래의 &lt;em&gt;호스트 제공 객체에 대한주의 사항을&lt;/em&gt; 참조하십시오. 특히, 이것은 IE8 및 이전 버전에서는 실패하므로 호스트 제공 객체를 &lt;code&gt;this&lt;/code&gt; 같이 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="919b9d8e3baf041ad3035d3f106002059a32c5a7" translate="yes" xml:space="preserve">
          <source>Should I always use it?</source>
          <target state="translated">항상 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="90d4fe421bc14a9a7cd0cfb17b98bb87c323df29" translate="yes" xml:space="preserve">
          <source>Similarly, when modifying or removing &lt;strong&gt;nested&lt;/strong&gt; DOM elements, processing in reverse can &lt;strong&gt;circumvent errors&lt;/strong&gt;. For example, consider modifying the innerHTML of a parent node before handling its children.  By the time the child node is reached it will be detached from the DOM, having been replaced by a newly created child when the parent's innerHTML was written.</source>
          <target state="translated">마찬가지로 &lt;strong&gt;중첩 된&lt;/strong&gt; DOM 요소를 수정하거나 제거 할 때 반대로 처리하면 &lt;strong&gt;오류&lt;/strong&gt; 를 &lt;strong&gt;피할 수 있습니다&lt;/strong&gt; . 예를 들어, 하위 노드를 처리하기 전에 상위 노드의 innerHTML을 수정하십시오. 자식 노드에 도달하면 DOM에서 분리되어 부모의 innerHTML을 작성할 때 새로 만든 자식으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="9042b86e2d8972b544eebed08f73160765222f7f" translate="yes" xml:space="preserve">
          <source>So for instance, if we want to convert a &lt;code&gt;NodeList&lt;/code&gt; into a true array, we could do this:</source>
          <target state="translated">예를 들어 &lt;code&gt;NodeList&lt;/code&gt; 를 실제 배열로 변환하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1271c2d1e2ea0178abb1749d433619d8ba114b52" translate="yes" xml:space="preserve">
          <source>So for instance, if we want to convert a &lt;code&gt;NodeList&lt;/code&gt; into a true array, with spread syntax this becomes quite succinct:</source>
          <target state="translated">예를 들어, &lt;code&gt;NodeList&lt;/code&gt; 를 실제 배열로 변환하려면 확산 구문을 사용하면 상당히 간결 해집니다.</target>
        </trans-unit>
        <trans-unit id="d778f77d45108db7a7e4ef37756d652130403fa5" translate="yes" xml:space="preserve">
          <source>So on the final iteration, &lt;em&gt;i&lt;/em&gt; was previously &lt;strong&gt;1&lt;/strong&gt; and the &lt;code&gt;i--&lt;/code&gt; expression changes it to &lt;strong&gt;0&lt;/strong&gt; but actually yields &lt;strong&gt;1&lt;/strong&gt; (truthy), and so the condition passes.  On the next iteration &lt;code&gt;i--&lt;/code&gt; changes &lt;em&gt;i&lt;/em&gt; to &lt;strong&gt;-1&lt;/strong&gt; but yields &lt;strong&gt;0&lt;/strong&gt; (falsey), causing execution to immediately drop out of the bottom of the loop.</source>
          <target state="translated">따라서 최종 반복에서 &lt;em&gt;i&lt;/em&gt; 는 이전에 &lt;strong&gt;1&lt;/strong&gt; 이었고 &lt;code&gt;i--&lt;/code&gt; 식은 &lt;strong&gt;0으로&lt;/strong&gt; 변경하지만 실제로는 &lt;strong&gt;1&lt;/strong&gt; (거짓)을 산출하므로 조건이 통과합니다. 다음 반복에서 &lt;code&gt;i--&lt;/code&gt; &lt;em&gt;i&lt;/em&gt; 를 &lt;strong&gt;-1로&lt;/strong&gt; 변경하지만 &lt;strong&gt;0&lt;/strong&gt; (거짓)을 산출하여 루프 하단에서 즉시 실행을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="ec2c077f94e3ef98852872b7d08256a523f61745" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt;-style languages use &lt;code&gt;foreach&lt;/code&gt; to loop through enumerations. In JavaScript this is done with the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for..in&lt;/code&gt; loop structure&lt;/a&gt;:</source>
          <target state="translated">일부 &lt;a href=&quot;http://en.wikipedia.org/wiki/C_%28programming_language%29&quot;&gt;C&lt;/a&gt; 스타일 언어는 &lt;code&gt;foreach&lt;/code&gt; 를 사용하여 열거를 반복합니다. JavaScript에서 이것은 &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for..in&lt;/code&gt; 루프 구조로&lt;/a&gt; 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="941bae0ecab27ddc205e29dd3a6d3b3bc8f9e89d" translate="yes" xml:space="preserve">
          <source>Some developers use the reverse for loop &lt;em&gt;by default&lt;/em&gt;, unless there is a good reason to loop forwards.</source>
          <target state="translated">루프 포워드해야 할 이유가없는 한 일부 개발자 &lt;em&gt;는 기본적으로&lt;/em&gt; 역방향 for 루프 &lt;em&gt;를&lt;/em&gt; 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3163e5ac5c4f789da55694f27cb9f6c55a337dd5" translate="yes" xml:space="preserve">
          <source>Some people like to draw a little arrow in the reverse &lt;code&gt;for&lt;/code&gt; loop, and end with a wink:</source>
          <target state="translated">어떤 사람들은 반대로 &lt;code&gt;for&lt;/code&gt; 루프에 작은 화살표를 그리고 윙크로 끝나기를 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="b119d6cd5c4dc707a6167c6c075b24e4d7be734d" translate="yes" xml:space="preserve">
          <source>Sometimes the old ways are the best:</source>
          <target state="translated">때로는 오래된 방법이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="59f86f5e3b9995bc329f5d4bc79c9d16c81b5fba" translate="yes" xml:space="preserve">
          <source>Sometimes, you might want to use an iterator &lt;em&gt;explicitly&lt;/em&gt;. You can do that, too, although it's a lot clunkier than &lt;code&gt;for-of&lt;/code&gt;. It looks like this:</source>
          <target state="translated">때로는 반복자를 &lt;em&gt;명시 적으로&lt;/em&gt; 사용하고 싶을 수도 있습니다. &lt;code&gt;for-of&lt;/code&gt; 보다 훨씬 복잡하지만 그렇게 할 수도 있습니다. 다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="c7657c048f2c02f83c5e4cef8d5cbd16b976ff8a" translate="yes" xml:space="preserve">
          <source>Suppose you wanted to use &lt;code&gt;forEach&lt;/code&gt; on a &lt;code&gt;Node&lt;/code&gt;'s &lt;code&gt;childNodes&lt;/code&gt; property. You'd do this:</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 의 &lt;code&gt;childNodes&lt;/code&gt; 속성에서 &lt;code&gt;forEach&lt;/code&gt; 를 사용하려한다고 가정합니다. 당신은 이것을 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="2870c360b6a5c3b4d815964ddecea3817c257c4c" translate="yes" xml:space="preserve">
          <source>That the key is all decimal digits (e.g., normal string form, not scientific notation), and</source>
          <target state="translated">키는 모두 10 진수 (예 : 과학적 표기법이 아닌 일반 문자열 형식)이며</target>
        </trans-unit>
        <trans-unit id="dce363e4d7896cca416fa7202976d0faa93b7cb7" translate="yes" xml:space="preserve">
          <source>That the key's value when coerced to a number is &amp;lt;= 2^32 - 2 (which is 4,294,967,294). Where does that number come from? It's part of the definition of an array index &lt;a href=&quot;https://tc39.github.io/ecma262/#array-index&quot;&gt;in the specification&lt;/a&gt;. Other numbers (non-integers, negative numbers, numbers greater than 2^32 - 2) are not array indexes. The reason it's 2^32 - &lt;strong&gt;2&lt;/strong&gt; is that that makes the greatest index value one lower than 2^32 - &lt;strong&gt;1&lt;/strong&gt;, which is the maximum value an array's &lt;code&gt;length&lt;/code&gt; can have. (E.g., an array's length fits in a 32-bit unsigned integer.) &lt;em&gt;(Props to RobG for pointing out in a comment &lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;on my blog post&lt;/a&gt; that my previous test wasn't quite right.)&lt;/em&gt;</source>
          <target state="translated">숫자로 강제 변환 될 때 키의 값은 &amp;lt;= 2 ^ 32-2 (4,294,967,294)입니다. 그 번호는 어디에서 왔습니까? 그것은 &lt;a href=&quot;https://tc39.github.io/ecma262/#array-index&quot;&gt;사양에서&lt;/a&gt; 배열 인덱스의 정의의 일부입니다. 다른 숫자 (정수가 아닌 숫자, 음수, 2 ^ 32-2보다 큰 숫자)는 배열 인덱스가 아닙니다. 그것이 2 ^ 32-2 인 이유는 가장 큰 인덱스 값을 2 ^ 32-1보다 낮게 만드는 것입니다. 이는 배열의 &lt;code&gt;length&lt;/code&gt; 가 가질 수있는 최대 값입니다. (예를 들어, 배열의 길이는 부호없는 32 비트 정수에 맞습니다.) &lt;em&gt;(이전 &lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;블로그&lt;/a&gt; 테스트에서 내 이전 테스트가 옳지 않다는 의견을 지적하기 위해 RobG에게 요청합니다.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a83ef01e292828af9f95ea6fd3cb1ad1a7e9b181" translate="yes" xml:space="preserve">
          <source>That the object has its &lt;em&gt;own&lt;/em&gt; property by that name (not one it inherits from its prototype), and</source>
          <target state="translated">객체는 그 이름에 따라 &lt;em&gt;자체&lt;/em&gt; 속성을 가지고 있으며 (프로토 타입에서 상속 된 속성이 아님)</target>
        </trans-unit>
        <trans-unit id="410be7b6d8de783ae1460eb1fb1c418447a833c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i--&lt;/code&gt; like solutions where the loop starts from the last array element (&lt;strong&gt;Ac, Bc&lt;/strong&gt;) are usually ~30% slower than forward solutions - probably the reason is the way of &lt;a href=&quot;https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus&quot;&gt;CPU memory cache working&lt;/a&gt; - forward memory reading is more optimal for CPU caching). &lt;strong&gt;Is recommended to NOT USE such solutions.&lt;/strong&gt;</source>
          <target state="translated">루프가 마지막 배열 요소 ( &lt;strong&gt;Ac, Bc&lt;/strong&gt; )에서 시작하는 &lt;code&gt;i--&lt;/code&gt; 와 같은 솔루션은 일반적으로 순방향 솔루션보다 ~ 30 % 느립니다. 아마도 &lt;a href=&quot;https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus&quot;&gt;CPU 메모리 캐시 작업&lt;/a&gt; 방식 일 것입니다. 순방향 메모리 읽기가 CPU에 더 적합합니다. 캐싱). &lt;strong&gt;이러한 솔루션을 사용하지 않는 것이 좋습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50fab3bc0666321dff613699d5e26402e68c7f7f" translate="yes" xml:space="preserve">
          <source>The benefit for this: You have the reference already in the first like that won't need to be declared later with another line. It is handy when looping trough the object array.</source>
          <target state="translated">이것의 장점 : 당신은 이미 다른 줄로 선언 할 필요가없는 것과 같은 참조가 이미 있습니다. 객체 배열을 통해 루핑 할 때 편리합니다.</target>
        </trans-unit>
        <trans-unit id="8e2dba3330af35406fa3d1420af1173d75e136d6" translate="yes" xml:space="preserve">
          <source>The braces (&lt;code&gt;{}&lt;/code&gt;) can be omitted when there is only one command (e.g. in the example above).</source>
          <target state="translated">중괄호 ( &lt;code&gt;{}&lt;/code&gt; )는 하나의 명령 (예 : 위의 예) 만있는 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c098c9f1a959378486a97457d4178958264ad2ec" translate="yes" xml:space="preserve">
          <source>The following examples will use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/a&gt; statement and the &lt;a href=&quot;https://developer.mozilla.org/ro/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;.forEach&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/a&gt; 문과 &lt;a href=&quot;https://developer.mozilla.org/ro/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;.forEach&lt;/code&gt; &lt;/a&gt; 메서드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3a00e7fa39a3bdf93692adc3a257b29ca0ee5020" translate="yes" xml:space="preserve">
          <source>The iterator is an object matching the Iterator definition in the specification. Its &lt;code&gt;next&lt;/code&gt; method returns a new &lt;em&gt;result object&lt;/em&gt; each time you call it. The result object has a property, &lt;code&gt;done&lt;/code&gt;, telling us whether it's done, and a property &lt;code&gt;value&lt;/code&gt; with the value for that iteration. (&lt;code&gt;done&lt;/code&gt; is optional if it would be &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is optional if it would be &lt;code&gt;undefined&lt;/code&gt;.)</source>
          <target state="translated">반복자는 사양의 반복자 정의와 일치하는 객체입니다. &lt;code&gt;next&lt;/code&gt; 메소드는 호출 할 때마다 새 &lt;em&gt;결과 객체를&lt;/em&gt; 반환합니다. 결과 객체는 &lt;code&gt;done&lt;/code&gt; 여부를 알려주는 속성 및 완료 &lt;code&gt;value&lt;/code&gt; 을 갖는 속성 값 을가집니다. ( &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;done&lt;/code&gt; 은 선택 사항이고 &lt;code&gt;undefined&lt;/code&gt; 경우 &lt;code&gt;value&lt;/code&gt; 는 선택적입니다.)</target>
        </trans-unit>
        <trans-unit id="fb536e6fcbd5fa797f6c5702a97e23e4c75f5773" translate="yes" xml:space="preserve">
          <source>The lambda syntax doesn't usually work in Internet&amp;nbsp;Explorer&amp;nbsp;10  or below.</source>
          <target state="translated">람다 구문은 일반적으로 Internet Explorer 10 이하에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="866f22286c83f5903a913086e3b75aeeb2603c3c" translate="yes" xml:space="preserve">
          <source>The loop will stop iterating when the condition &lt;code&gt;i--&lt;/code&gt; evaluates to a falsey value (when it yields 0).</source>
          <target state="translated">조건 &lt;code&gt;i--&lt;/code&gt; 가 거짓 값으로 평가 될 때 (0을 생성 할 때) 루프는 반복을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="80992ad230888519239affffa93744a318eb6afc" translate="yes" xml:space="preserve">
          <source>The loops with array length cached in &lt;code&gt;n&lt;/code&gt; (&lt;strong&gt;Ab, Bb, Be&lt;/strong&gt;) are sometimes faster, sometimes not. Probably compilers automatically detect this situation and introduce caching. The speed differences between the cached and no-cached versions (&lt;strong&gt;Aa, Ba, Bd&lt;/strong&gt;) are about ~1%, so it looks like introduce &lt;code&gt;n&lt;/code&gt; is a &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;micro-optimisation&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; ( &lt;strong&gt;Ab, Bb, Be&lt;/strong&gt; )으로 캐시 된 배열 길이의 루프는 때로는 더 빠르며 때로는 그렇지 않습니다. 아마도 컴파일러는 자동으로이 상황을 감지하고 캐싱을 도입합니다. 캐시 된 버전과 캐시되지 않은 버전 ( &lt;strong&gt;Aa, Ba, Bd&lt;/strong&gt; ) 간의 속도 차이는 약 ~ 1 %이므로 소개 &lt;code&gt;n&lt;/code&gt; 이 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;미세 최적화 된&lt;/a&gt;&lt;/em&gt; 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="8e52b46122ec0efd9e5bc3d7eec0fac027826ce2" translate="yes" xml:space="preserve">
          <source>The meaning of &lt;code&gt;value&lt;/code&gt; varies depending on the iterator; arrays support (at least) three functions that return iterators:</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 의 의미는 반복자에 따라 다릅니다. 배열은 반복자를 반환하는 (적어도) 세 가지 함수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6f4344e9b0061937311866ba4501ba441df9956f" translate="yes" xml:space="preserve">
          <source>The method will call from &lt;code&gt;array[0]&lt;/code&gt; to &lt;code&gt;array[2]&lt;/code&gt;. First, this will first reference variables you don't even have, second you would not have the variables in the array, and third this will make the code bolder. Look here, it's what I use:</source>
          <target state="translated">이 메소드는 &lt;code&gt;array[0]&lt;/code&gt; 에서 &lt;code&gt;array[2]&lt;/code&gt; 호출합니다. 첫째, 이것은 먼저 가지고 있지 않은 변수를 참조하고, 둘째는 배열에 변수가 없으며, 세 번째는 코드를 대담하게 만듭니다. 여기를 보면 내가 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="74aa97507801ce4d05b427601775a33b918e48b3" translate="yes" xml:space="preserve">
          <source>The only real use cases for &lt;code&gt;for-in&lt;/code&gt; on an array are:</source>
          <target state="translated">배열에 대한 실제 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="752c45d9e3f0bb5c04149934ef14e0e9e95a2014" translate="yes" xml:space="preserve">
          <source>The other solutions, like &lt;code&gt;for-of&lt;/code&gt; (&lt;strong&gt;Ad&lt;/strong&gt;), all in group &lt;strong&gt;C.&lt;/strong&gt;... are usually 2 - 10 (and more) times slower than &lt;strong&gt;Aa&lt;/strong&gt;, but for small arrays it is ok to use it - for the sake of increase code clarity.</source>
          <target state="translated">그룹 &lt;strong&gt;C의&lt;/strong&gt; 모든 &lt;code&gt;for-of&lt;/code&gt; ( of) 와 같은 다른 솔루션은 ... &lt;strong&gt;Aa&lt;/strong&gt; 보다 일반적으로 &lt;strong&gt;2-10&lt;/strong&gt; 배 이상 느리지 만 작은 배열의 경우에는 더 많이 사용하기 위해 사용하는 것이 좋습니다. 코드 선명도.</target>
        </trans-unit>
        <trans-unit id="e6e6a03f8cd96d0cc668913bda563a8e9ba99a69" translate="yes" xml:space="preserve">
          <source>The reverse loop is &lt;strong&gt;confusing&lt;/strong&gt; to junior developers.  (You may consider that an advantage, depending on your outlook.)</source>
          <target state="translated">리버스 루프는 후배 개발자에게 &lt;strong&gt;혼란&lt;/strong&gt; 을줍니다. (전망에 따라 이점을 고려할 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="f1e91d86c7df92b8dd9b5472ca55e71a9d8cd69a" translate="yes" xml:space="preserve">
          <source>The standard way to iterate an array in &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; is a vanilla &lt;code&gt;for&lt;/code&gt;-loop:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; 에서 배열을 반복하는 표준 방법은 바닐라 &lt;code&gt;for&lt;/code&gt; -loop입니다.</target>
        </trans-unit>
        <trans-unit id="f83ea1369d58b6fdc00c70cea4bb0aa9a818aa64" translate="yes" xml:space="preserve">
          <source>The trick is that unlike &lt;code&gt;--i&lt;/code&gt;, the trailing &lt;code&gt;i--&lt;/code&gt; operator decrements &lt;code&gt;i&lt;/code&gt; but yields the value &lt;strong&gt;&lt;em&gt;before&lt;/em&gt;&lt;/strong&gt; the decrement.  Your console can demonstrate this:</source>
          <target state="translated">요령은 &lt;code&gt;--i&lt;/code&gt; 와 달리 후행 &lt;code&gt;i&lt;/code&gt; 연산자는 i를 감소 &lt;code&gt;i--&lt;/code&gt; 감소 &lt;strong&gt;&lt;em&gt;하기 전에&lt;/em&gt;&lt;/strong&gt; 값을 산출한다는 것입니다. 당신의 콘솔은 이것을 증명할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="608bdf441fc2978c8b5bcb888401c074fd430bc1" translate="yes" xml:space="preserve">
          <source>The various functions on &lt;code&gt;Array.prototype&lt;/code&gt; are &quot;intentionally generic&quot; and can usually be used on array-like objects via &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.call&quot;&gt;&lt;code&gt;Function#call&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.apply&quot;&gt;&lt;code&gt;Function#apply&lt;/code&gt;&lt;/a&gt;. (See the &lt;em&gt;Caveat for host-provided objects&lt;/em&gt; at the end of this answer, but it's a rare issue.)</source>
          <target state="translated">&lt;code&gt;Array.prototype&lt;/code&gt; 의 다양한 함수는 &quot;의도적으로 일반적&quot;이며 보통 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.call&quot;&gt; &lt;code&gt;Function#call&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-function.prototype.apply&quot;&gt; &lt;code&gt;Function#apply&lt;/code&gt; &lt;/a&gt; 를 통해 배열과 같은 객체에서 사용할 수 있습니다 . (이 답변 끝에 &lt;em&gt;호스트 제공 객체&lt;/em&gt; 에 &lt;em&gt;대한 경고를&lt;/em&gt; 참조하십시오. 그러나 드문 문제입니다.)</target>
        </trans-unit>
        <trans-unit id="5b74a123ca6113288c61c01f944435ca7d90b342" translate="yes" xml:space="preserve">
          <source>Then when you do see the reverse for loop in your code, that is a hint that it is reversed for a good reason (perhaps one of the reasons described above).  And seeing a traditional forward for loop may indicate that shifting can take place.</source>
          <target state="translated">그런 다음 코드에서 리버스 for 루프를 볼 때 이는 좋은 이유 (위에서 설명한 이유 중 하나)로 반전되었다는 힌트입니다. 그리고 전통적인 순방향 for 루프를 보면 시프트가 발생할 수 있음을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d150400a4ca68f73e954c6ea93f05e7de141942b" translate="yes" xml:space="preserve">
          <source>There are &lt;strong&gt;a few ways&lt;/strong&gt; to loop through an array in JavaScript, as below:</source>
          <target state="translated">아래와 같이 JavaScript에서 배열을 반복 &lt;strong&gt;하는 몇 가지 방법&lt;/strong&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b51f25dbb23a6ed31b4ccfd1a12b3fdb1871919" translate="yes" xml:space="preserve">
          <source>There are different ways to use the forEach loop of angular. The simplest and probably most used is</source>
          <target state="translated">각도의 forEach 루프를 사용하는 방법에는 여러 가지가 있습니다. 가장 단순하고 아마도 가장 많이 사용되는 것은</target>
        </trans-unit>
        <trans-unit id="43e3466064c6ca5060bfe7c0d8fe1a2296506e5e" translate="yes" xml:space="preserve">
          <source>There are three implementations of &lt;code&gt;foreach&lt;/code&gt; in &lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; as follows.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JQuery&quot;&gt;jQuery&lt;/a&gt; 에는 다음과 같은 세 가지 &lt;code&gt;foreach&lt;/code&gt; 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d54c80c3143769b1187df474f58937273f32b476" translate="yes" xml:space="preserve">
          <source>There is a catch. &lt;code&gt;for..in&lt;/code&gt; will loop through each of the object's enumerable members, and the members on its prototype. To avoid reading values that are inherited through the object's prototype, simply check if the property belongs to the object:</source>
          <target state="translated">캐치가 있습니다. &lt;code&gt;for..in&lt;/code&gt; 은 각 객체의 열거 가능한 멤버와 프로토 타입의 멤버를 반복합니다. 객체의 프로토 타입을 통해 상속 된 값을 읽지 않으려면 속성이 객체에 속하는지 확인하면됩니다.</target>
        </trans-unit>
        <trans-unit id="93b99dbbcfcfef18eac3c5a89b5362f4491b1f4f" translate="yes" xml:space="preserve">
          <source>There is a debate about whether &lt;code&gt;for..of&lt;/code&gt; or &lt;code&gt;forEach()&lt;/code&gt; are preferable:</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 또는 &lt;code&gt;forEach()&lt;/code&gt; 가 바람직한 지에 대한 논쟁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5162299771e3535e699131f35c2cf628ce13a63a" translate="yes" xml:space="preserve">
          <source>There isn't any &lt;code&gt;for each&lt;/code&gt; loop in native &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;. You can either use libraries to get this functionality (I recommend &lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt;), use a simple &lt;code&gt;for&lt;/code&gt; in loop.</source>
          <target state="translated">기본 &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; &lt;code&gt;for each&lt;/code&gt; 루프 마다 없습니다. 라이브러리를 사용 하여이 기능을 사용하고 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Underscore.js&quot;&gt;Underscore.js&lt;/a&gt; 권장) 간단한 &lt;code&gt;for&lt;/code&gt; 루프를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55d52a0b513a03e6f341ec331ed111d51c87156a" translate="yes" xml:space="preserve">
          <source>There's no inbuilt ability to break in &lt;code&gt;forEach&lt;/code&gt;. To interrupt execution use the &lt;code&gt;Array#some&lt;/code&gt; like below:</source>
          <target state="translated">&lt;code&gt;forEach&lt;/code&gt; 에 침입 할 수있는 기능이 없습니다. 실행을 중단하려면 아래와 같이 &lt;code&gt;Array#some&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="24112cc482e8cc4c078f7faf03d3a6612e321185" translate="yes" xml:space="preserve">
          <source>This is an iterator for NON-sparse list where the index starts at 0, which is the typical scenario when dealing with document.getElementsByTagName or document.querySelectorAll)</source>
          <target state="translated">인덱스가 0에서 시작하는 Non-spparse 목록의 반복자입니다. 이는 document.getElementsByTagName 또는 document.querySelectorAll를 처리 할 때의 일반적인 시나리오입니다.</target>
        </trans-unit>
        <trans-unit id="b109618ad05adb05d3d283e04dadad94a3074a14" translate="yes" xml:space="preserve">
          <source>This will break whenever the reference is false - falsey (undefined, etc.). It can be used as an advantage though. However, it would make it a little bit harder to read. And also depending on the browser it can be &quot;not&quot; optimized to work faster than the original one.</source>
          <target state="translated">참조가 false-false (정의되지 않은 등) 일 때마다 중단됩니다. 그래도 이점으로 사용할 수 있습니다. 그러나 읽기가 조금 더 어려워집니다. 또한 브라우저에 따라 원래보다 더 빠르게 작동하도록 &quot;최적화되지&quot;않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb8a12948118a05c21c4646e9b69844b0d2ce858" translate="yes" xml:space="preserve">
          <source>This works because &lt;code&gt;some&lt;/code&gt; returns true as soon as any of the callbacks, executed in array order, returns true, short-circuiting the execution of the rest. 
&lt;a href=&quot;https://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break&quot;&gt;Original Answer&lt;/a&gt;
see Array prototype for &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.17&quot;&gt;some&lt;/a&gt;</source>
          <target state="translated">이것은 배열 순서로 실행 된 콜백이 true를 반환하고 나머지는 실행을 단락시키는 즉시 true를 반환하기 때문에 작동합니다. &lt;a href=&quot;https://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break&quot;&gt;원래 답변&lt;/a&gt; &lt;a href=&quot;http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.17&quot;&gt;일부&lt;/a&gt; 배열 프로토 타입 참조</target>
        </trans-unit>
        <trans-unit id="4c334db464368d273947e54cf77b80331da64b0f" translate="yes" xml:space="preserve">
          <source>Though, you don't have to do that, you can simply do the following and it's equivalent to the previous example:</source>
          <target state="translated">그렇게 할 필요는 없지만 간단히 다음을 수행 할 수 있으며 이전 예제와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="257fcf65e941aa6ba5c5e06169df94cf19c12a87" translate="yes" xml:space="preserve">
          <source>Today (2019-12-18) I perform test on my &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra), on Chrome v 79.0, Safari v13.0.4 and Firefox v71.0 (64 bit) - conclusions about optimisation (and &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time/3471000#3471000&quot;&gt;micro-optimisation&lt;/a&gt;&lt;/em&gt; which usually is not worth to introduce it to code because the benefit is small, but code complexity grows).</source>
          <target state="translated">오늘 (2019-12-18) 저는 &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra), Chrome v 79.0, Safari v13.0.4 및 Firefox v71.0 (64 bit)에서 테스트를 수행합니다-최적화에 대한 결론 및 이점이 적지 만 코드 복잡성이 커지기 때문에 일반적으로 코드에 도입 할 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="54b58f77bdc50c962ebcb489df02102329ea9473" translate="yes" xml:space="preserve">
          <source>Transform your regular array to iterator using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values&quot;&gt;&lt;code&gt;values()&lt;/code&gt;&lt;/a&gt; method like this:</source>
          <target state="translated">다음과 같이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values&quot;&gt; &lt;code&gt;values()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 일반 배열을 반복자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="286e721a1890a58c29a5c4014f7f586f56cc077f" translate="yes" xml:space="preserve">
          <source>Trivia</source>
          <target state="translated">Trivia</target>
        </trans-unit>
        <trans-unit id="f2407f77f30d5cce56de1bb34c4429f7541eb397" translate="yes" xml:space="preserve">
          <source>Under the covers, that gets an &lt;em&gt;iterator&lt;/em&gt; from the array and loops through it, getting the values from it. This doesn't have the issue that using &lt;code&gt;for-in&lt;/code&gt; has, because it uses an iterator defined by the object (the array), and arrays define that their iterators iterate through their &lt;em&gt;entries&lt;/em&gt; (not their properties). Unlike &lt;code&gt;for-in&lt;/code&gt; in ES5, the order in which the entries are visited is the numeric order of their indexes.</source>
          <target state="translated">커버 아래에서 배열에서 &lt;em&gt;반복자&lt;/em&gt; 를 가져 와서 루프를 통해 값을 가져옵니다. &lt;code&gt;for-in&lt;/code&gt; 을 사용하면 객체 (배열)에 의해 정의 된 반복자를 사용하기 때문에 문제가 발생하지 않으며 배열은 반복자가 속성이 아닌 &lt;em&gt;항목을&lt;/em&gt; 통해 반복되도록 정의합니다. ES5의 &lt;code&gt;for-in&lt;/code&gt; 과 달리 항목을 방문하는 순서는 색인의 숫자 순서입니다.</target>
        </trans-unit>
        <trans-unit id="51d0fcbbedb44b967fe1846371188cf04d2c2452" translate="yes" xml:space="preserve">
          <source>Unless you're supporting obsolete browsers like IE8 (which NetApps shows at just over 4% market share as of this writing in September&amp;nbsp;2016), you can happily use &lt;code&gt;forEach&lt;/code&gt; in a general-purpose web page without a shim. If you do need to support obsolete browsers, shimming/polyfilling &lt;code&gt;forEach&lt;/code&gt; is easily done (search for &quot;es5 shim&quot; for several options).</source>
          <target state="translated">IE8 (2016 년 9 월이 글을 쓰는 시점에 NetApps가 시장 점유율을 4 % 이상으로 표시)과 같은 오래된 브라우저를 지원하지 않는 한 shim없이 범용 웹 페이지에서 각 foreach를 행복하게 사용할 수 있습니다. 더 이상 사용되지 않는 브라우저를 지원해야하는 경우, 각각에 대한 shimming / polyfilling이 쉽게 수행됩니다 (여러 옵션에 대해서는 &quot;es5 shim&quot;검색).</target>
        </trans-unit>
        <trans-unit id="431a3b9a552efc88858519dfb72bdcfb495d5966" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for-in&lt;/code&gt;&lt;em&gt;correctly&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;올바르게 사용&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e0c11cbf7ef3c72db6fc4b3fe5d45b56bc12d21" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;for-of&lt;/code&gt; (use an iterator implicitly) (ES2015+)</source>
          <target state="translated">For &lt;code&gt;for-of&lt;/code&gt; 사용 (이터레이터를 암시 적으로 사용) (ES2015 +)</target>
        </trans-unit>
        <trans-unit id="734ae2379fe23a7a3bc38483ac1b653b9d9051b3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;forEach&lt;/code&gt; and related (ES5+)</source>
          <target state="translated">각 제품 및 관련 제품 (ES5 +)에 사용</target>
        </trans-unit>
        <trans-unit id="2c08b442b76b66cca66b71d3f1ff947bdd36a587" translate="yes" xml:space="preserve">
          <source>Use a simple &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">간단한 &lt;code&gt;for&lt;/code&gt; 루프를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1ea53b376965f0df377f080711210f0ab1972b82" translate="yes" xml:space="preserve">
          <source>Use an iterator explicitly (ES2015+)</source>
          <target state="translated">반복자를 명시 적으로 사용하십시오 (ES2015 +)</target>
        </trans-unit>
        <trans-unit id="34c4927f746ab01e6fc5a9bc93966e26f8b7d962" translate="yes" xml:space="preserve">
          <source>Use any of the options above for arrays</source>
          <target state="translated">배열에 대해 위의 옵션 중 하나를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="e906c3cdb43d16bd2a2f35eccf263373e93c2a7f" translate="yes" xml:space="preserve">
          <source>We can use the &lt;code&gt;slice&lt;/code&gt; method of arrays, which like the other methods mentioned above is &quot;intentionally generic&quot; and so can be used with array-like objects, like this:</source>
          <target state="translated">위에서 언급 한 다른 방법들처럼 &quot;의도적으로 일반적인&quot;배열의 &lt;code&gt;slice&lt;/code&gt; 방법을 사용할 수 있으므로 다음과 같이 배열과 같은 객체와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef4d47774a48af8c2dc4198f272524f303720ef0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;of&lt;/code&gt; avoids the oddities associated with &lt;code&gt;in&lt;/code&gt; and makes it work like the &lt;code&gt;for&lt;/code&gt; loop of any other language, and &lt;code&gt;let&lt;/code&gt; binds &lt;code&gt;i&lt;/code&gt; within the loop as opposed to within the function.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 과 관련된 이상한 점 &lt;code&gt;of&lt;/code&gt; 피하고 다른 언어의 &lt;code&gt;for&lt;/code&gt; 루프처럼 작동 &lt;code&gt;let&lt;/code&gt; 하고 함수 내에서와 달리 루프 내에서 &lt;code&gt;i&lt;/code&gt; 를 바인딩하십시오.</target>
        </trans-unit>
        <trans-unit id="941d4e5eb1ee2fa812450abac2b4faed7e49a69d" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;theArray&lt;/code&gt; is my array, but this seems to be incorrect.</source>
          <target state="translated">&lt;code&gt;theArray&lt;/code&gt; 가 내 배열 인 곳이지만 이것은 잘못된 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="08b975222d1b83cf89b60a81d765397d2dc1159f" translate="yes" xml:space="preserve">
          <source>You access the current item by calling the iterator&amp;rsquo;s &lt;code&gt;next&lt;/code&gt; method. The next method will return the &lt;strong&gt;&lt;code&gt;value&lt;/code&gt;&lt;/strong&gt; of the current item and a &lt;strong&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/strong&gt; to indicate when you have reached the end of the collection. The following is an example of creating an iterator from an array.</source>
          <target state="translated">반복자의 &lt;code&gt;next&lt;/code&gt; 메소드를 호출하여 현재 항목에 액세스합니다. 다음 메소드는 현재 항목의 &lt;strong&gt; &lt;code&gt;value&lt;/code&gt; &lt;/strong&gt; 과 컬렉션의 끝에 도달했을 때를 나타내는 &lt;strong&gt; &lt;code&gt;boolean&lt;/code&gt; &lt;/strong&gt; 을 &lt;strong&gt;반환&lt;/strong&gt; 합니다. 다음은 배열에서 반복자를 만드는 예입니다.</target>
        </trans-unit>
        <trans-unit id="faf0a839383e9ca040f86c77bb8d78628ddab12a" translate="yes" xml:space="preserve">
          <source>You can also iterate over an array like this:</source>
          <target state="translated">다음과 같이 배열을 반복 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a99d0a423bd91c6ab11d1bbc2ecccf23c5be4af8" translate="yes" xml:space="preserve">
          <source>You can also transform your regular &lt;code&gt;array&lt;/code&gt; to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">다음과 같이 일반 &lt;code&gt;array&lt;/code&gt; 을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&quot;&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/a&gt; 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ceb3749d20fa27c455e7e1a7300f32a149c3c7" translate="yes" xml:space="preserve">
          <source>You can also transform your regular array to iterator using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt; &lt;code&gt;Symbol.iterator&lt;/code&gt; &lt;/a&gt; 과 같이 Symbol.iterator를 사용하여 일반 배열을 반복자로 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f6f076641450693589f578d046aeeeb04ad8c10" translate="yes" xml:space="preserve">
          <source>You can call forEach like this:</source>
          <target state="translated">다음과 같이 각각을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8704a38dea0e6f3deb1af2a2e5fcf2aa68370fc9" translate="yes" xml:space="preserve">
          <source>You can get some performance optimisations by caching &lt;code&gt;myArray.length&lt;/code&gt; or iterating over it backwards.</source>
          <target state="translated">&lt;code&gt;myArray.length&lt;/code&gt; 를 캐싱하거나 거꾸로 반복하여 성능 최적화를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7623d5152acc3867d2222ce3eedc5c77ffbac5a8" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;iteration protocol&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iteration protocol&lt;/code&gt; 에 대한 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28ce5baaf2a7e364a9e6393430ef2a639312b251" translate="yes" xml:space="preserve">
          <source>You can use:</source>
          <target state="translated">당신이 사용할 수있는:</target>
        </trans-unit>
        <trans-unit id="7d5badb0562b87f2a9430ec38445cdf3e13d52c2" translate="yes" xml:space="preserve">
          <source>You do not need to declare a temporary &lt;code&gt;len&lt;/code&gt; variable, or compare against &lt;code&gt;array.length&lt;/code&gt; on each iteration, either of which might be a minute optimisation.</source>
          <target state="translated">임시 &lt;code&gt;len&lt;/code&gt; 변수를 선언하거나 각 반복에서 &lt;code&gt;array.length&lt;/code&gt; 와 비교할 필요가 없습니다 ( 최소한의 최적화 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="021884629c616bb0e00f4dedc9401d5eeaae6b37" translate="yes" xml:space="preserve">
          <source>You have three options in &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript&amp;nbsp;5&lt;/a&gt; (&quot;ES5&quot;), the version most broadly supported at the moment, and two more added in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript&amp;nbsp;2015&lt;/a&gt; (&quot;ES2015&quot;, &quot;ES6&quot;):</source>
          <target state="translated">&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript 5&lt;/a&gt; ( &quot;ES5&quot;)에는 현재 가장 광범위하게 지원되는 버전과 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015&lt;/a&gt; ( &quot;ES2015&quot;, &quot;ES6&quot;)에 추가 된 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5baba5e2792c7b4a97eeca7d33b55e99ec8dd7bb" translate="yes" xml:space="preserve">
          <source>You will notice that &lt;code&gt;i--&lt;/code&gt; is the middle clause (where we usually see a comparison) and the last clause is empty (where we usually see &lt;code&gt;i++&lt;/code&gt;).  That means that &lt;code&gt;i--&lt;/code&gt; is also used as the &lt;em&gt;condition&lt;/em&gt; for continuation.  Crucially, it is executed and checked &lt;em&gt;before&lt;/em&gt; each iteration.</source>
          <target state="translated">&lt;code&gt;i--&lt;/code&gt; 는 중간 절 (보통 비교가 표시됨)이고 마지막 절은 비어 있습니다 (보통 &lt;code&gt;i++&lt;/code&gt; ). 이는 &lt;code&gt;i--&lt;/code&gt; 가 연속 &lt;em&gt;조건&lt;/em&gt; 으로도 사용됨을 의미합니다. 결정적으로, 각 반복 &lt;em&gt;전에&lt;/em&gt; 실행 및 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="1b92ca772f4a547ebbe1cecec130f971e1c7c39f" translate="yes" xml:space="preserve">
          <source>You wouldn't do that in inline code, of course. You'd write a utility function. Perhaps:</source>
          <target state="translated">물론 인라인 코드에서는 그렇게하지 않을 것입니다. 유틸리티 함수를 작성합니다. 혹시:</target>
        </trans-unit>
        <trans-unit id="5b72435b1a6e0292938c5e939f2b0c7c3502eb4e" translate="yes" xml:space="preserve">
          <source>You'll get people telling you to use &lt;code&gt;for-in&lt;/code&gt;, but &lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;that's not what &lt;code&gt;for-in&lt;/code&gt; is for&lt;/a&gt;. &lt;code&gt;for-in&lt;/code&gt; loops through the &lt;em&gt;enumerable properties of an object&lt;/em&gt;, not the indexes of an array. &lt;strong&gt;The order is not guaranteed&lt;/strong&gt;, not even in ES2015 (ES6). ES2015+ does define an order to object properties (via &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys&quot;&gt;&lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-enumerate&quot;&gt;&lt;code&gt;[[Enumerate]]&lt;/code&gt;&lt;/a&gt;, and things that use them like &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getownpropertynames&quot;&gt;&lt;code&gt;Object.getOwnPropertyKeys&lt;/code&gt;&lt;/a&gt;), but it &lt;strong&gt;does not&lt;/strong&gt; define that &lt;code&gt;for-in&lt;/code&gt; will follow that order. (Details in &lt;a href=&quot;https://stackoverflow.com/a/30919039/157247&quot;&gt;this other answer&lt;/a&gt;.)</source>
          <target state="translated">사람들이 당신에게 &lt;code&gt;for-in&lt;/code&gt; 을 사용하라고 말하게 할 것 입니다 . 그러나 &lt;a href=&quot;http://blog.niftysnippets.org/2010/11/myths-and-realities-of-forin.html&quot;&gt;그것은 &lt;code&gt;for-in&lt;/code&gt; 이 아닙니다&lt;/a&gt; . &lt;code&gt;for-in&lt;/code&gt; 은 배열의 인덱스가 아닌 &lt;em&gt;객체&lt;/em&gt; 의 &lt;em&gt;열거 가능한 속성을&lt;/em&gt; 반복합니다. ES2015 (ES6)에서도 &lt;strong&gt;주문이 보장&lt;/strong&gt; 되지 않습니다. ES2015 +는 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys&quot;&gt; &lt;code&gt;[[OwnPropertyKeys]]&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-enumerate&quot;&gt; &lt;code&gt;[[Enumerate]]&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getownpropertynames&quot;&gt; &lt;code&gt;Object.getOwnPropertyKeys&lt;/code&gt; &lt;/a&gt; 와 같은 속성을 사용하는 객체를 통해 객체 속성 순서를 정의하지만 &lt;code&gt;for-in&lt;/code&gt; 이 해당 순서를 따르도록 정의 &lt;strong&gt;하지는 않습니다&lt;/strong&gt; . ( &lt;a href=&quot;https://stackoverflow.com/a/30919039/157247&quot;&gt;이 다른 답변에 대한&lt;/a&gt; 자세한 내용)</target>
        </trans-unit>
        <trans-unit id="589b6a96f50575d676fcf038d8105e7b1699be4a" translate="yes" xml:space="preserve">
          <source>You're using non-element properties and you want to include them in the loop</source>
          <target state="translated">요소가 아닌 속성을 사용하고 있으며 루프에 포함하려는 경우</target>
        </trans-unit>
        <trans-unit id="10d7cc4a29eba4f6a5a3ca2db2a762f5a236cc71" translate="yes" xml:space="preserve">
          <source>Your best bets are usually</source>
          <target state="translated">가장 좋은 건은 보통</target>
        </trans-unit>
        <trans-unit id="617846806ec9245ca6b1c7aac0723989e8f9ebee" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;for-of&lt;/code&gt; loop (ES2015+ only),</source>
          <target state="translated">&lt;code&gt;for-of&lt;/code&gt; 루프 (ES2015 + 만 해당)</target>
        </trans-unit>
        <trans-unit id="6b50530706e59258d411002d89ae4b283301aabf" translate="yes" xml:space="preserve">
          <source>a simple old-fashioned &lt;code&gt;for&lt;/code&gt; loop,</source>
          <target state="translated">간단한 구식 &lt;code&gt;for&lt;/code&gt; 루프</target>
        </trans-unit>
        <trans-unit id="6f15cde32ab6efb43a1b5c9033caf63a6feb7401" translate="yes" xml:space="preserve">
          <source>browsers**</source>
          <target state="translated">browsers**</target>
        </trans-unit>
        <trans-unit id="5873f666d03fb3fb39d0db9c71b5e1f769334088" translate="yes" xml:space="preserve">
          <source>every</source>
          <target state="translated">every</target>
        </trans-unit>
        <trans-unit id="4bb4ca75941b7bbc5bc6a12be44b22fc9c8d234e" translate="yes" xml:space="preserve">
          <source>filter</source>
          <target state="translated">filter</target>
        </trans-unit>
        <trans-unit id="43eef9a62abb8b1e1654f8a890aae054abffa82b" translate="yes" xml:space="preserve">
          <source>for</source>
          <target state="translated">for</target>
        </trans-unit>
        <trans-unit id="edc5ee22beb2b82f4da41914d8d41cca9c53020f" translate="yes" xml:space="preserve">
          <source>forEach</source>
          <target state="translated">forEach</target>
        </trans-unit>
        <trans-unit id="dc06788092621528ed3f0618bc0b6f3c356aa9e7" translate="yes" xml:space="preserve">
          <source>jQuery way using &lt;code&gt;$.map&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$.map&lt;/code&gt; 사용하는 jQuery 방법 :</target>
        </trans-unit>
        <trans-unit id="37745ed7a0f005fb14522c5cc7c1ba3d9e0df579" translate="yes" xml:space="preserve">
          <source>map</source>
          <target state="translated">map</target>
        </trans-unit>
        <trans-unit id="263cce6e93f37573f1e7fe24662cad3400cc887c" translate="yes" xml:space="preserve">
          <source>or &lt;code&gt;for-in&lt;/code&gt; with safeguards.</source>
          <target state="translated">또는 안전 장치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="48c3689f6dd5e9e952f925b7ebebf64d7c43fc56" translate="yes" xml:space="preserve">
          <source>reduce</source>
          <target state="translated">reduce</target>
        </trans-unit>
        <trans-unit id="eb875812858d27b22cb2b75f992dffadc1b05c66" translate="yes" xml:space="preserve">
          <source>some</source>
          <target state="translated">some</target>
        </trans-unit>
        <trans-unit id="f13e27693c85aed522df8c3fcb0bb0110ca54e14" translate="yes" xml:space="preserve">
          <source>zip</source>
          <target state="translated">zip</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
