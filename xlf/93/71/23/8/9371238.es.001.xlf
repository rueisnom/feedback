<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/9371238">
    <body>
      <group id="9371238">
        <trans-unit id="2ada74fe85580bed0602d49b3709fcf15dcf240b" translate="yes" xml:space="preserve">
          <source>(TLDR answer: include the statement: &lt;code&gt;cin.sync_with_stdio(false)&lt;/code&gt; or just use &lt;code&gt;fgets&lt;/code&gt; instead.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Respuesta TLDR: incluya la declaraci&amp;oacute;n: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin.sync_with_stdio(false)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o simplemente use &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; en su&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lugar.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5604413a183cbc7d7544d68c94a6c7382ae5d413" translate="yes" xml:space="preserve">
          <source>-- this claims that `cat` consumed 74% of the CPU during the test; and indeed 1.34/1.83 is approximately 74%.  Perhaps a run of:</source>
          <target state="translated">--esto afirma que &quot;cat&quot; consumió el 74% del CPU durante la prueba;y de hecho 1.341.83 es aproximadamente el 74%.Tal vez una racha de:</target>
        </trans-unit>
        <trans-unit id="1348609af914ffea58e6f9f0adbfd5fc589de6d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline&lt;/code&gt;, stream operators, &lt;code&gt;scanf&lt;/code&gt;, can be convenient if you don't care about file loading time or if you are loading small text files. But, if the performance is something you care about, you should really just buffer the entire file into memory (assuming it will fit).</source>
          <target state="translated">&lt;code&gt;getline&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , operadores de transmisi&amp;oacute;n, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pueden ser convenientes si no le importa el tiempo de carga de archivos o si est&amp;aacute; cargando archivos de texto peque&amp;ntilde;os. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero, si el rendimiento es algo que le interesa, realmente deber&amp;iacute;a almacenar todo el archivo en la memoria (suponiendo que se ajuste).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c0915bf7a2ae1a20a3dd3d752c1dede09758b45d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I should note that I tried this both under Mac&amp;nbsp;OS&amp;nbsp;X&amp;nbsp;v10.6.8 (Snow&amp;nbsp;Leopard) and Linux 2.6.32 (Red Hat Linux 6.2). The former is a MacBook Pro, and the latter is a very beefy server, not that this is too pertinent.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Debo se&amp;ntilde;alar que prob&amp;eacute; esto tanto en Mac OS X v10.6.8 (Snow Leopard) como en Linux 2.6.32 (Red Hat Linux 6.2). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El primero es un MacBook Pro, y el segundo es un servidor muy robusto, no es que esto sea demasiado pertinente.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8119e8521189e9d54129bd0197536b2d962ff8bc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in practice&lt;/em&gt;, on modern machines, the added `cat` in the pipeline is probably of no real consequence</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;en la pr&amp;aacute;ctica&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , en m&amp;aacute;quinas modernas, el `cat` agregado en la tuber&amp;iacute;a probablemente no tenga consecuencias reales&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f625673762999b841e0b14d2b37dd1775f5d0bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C&amp;oacute;digo C ++:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e4899c39940c2a22b2171aa7540343dadef7018" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Here are my results:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; est&amp;aacute;n mis resultados:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d886917c5612dc7850a74f654f3ffa7d073dde44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python Equivalent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Equivalente a Python:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7ba7ad03822a6b3e0d1b23058b1f808ac10d2d6" translate="yes" xml:space="preserve">
          <source>A better construction would be:</source>
          <target state="translated">Una mejor construcción sería:</target>
        </trans-unit>
        <trans-unit id="8c484caf9d550a5b7b43988b6fc5cbdf31ee5cee" translate="yes" xml:space="preserve">
          <source>A first element of an answer: &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; is slow. Damn slow. I get a huge performance boost with &lt;code&gt;scanf&lt;/code&gt; as in the below, but it is still two times slower than Python.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un primer elemento de una respuesta: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es lento. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Maldita sea lento. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Obtengo un gran aumento de rendimiento con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como en el siguiente, pero sigue siendo dos veces m&amp;aacute;s lento que Python.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d606b8781f8d9cc1eb582fbcf3c012f3e5267c6" translate="yes" xml:space="preserve">
          <source>A. You could 'fix' this by timing only your program:</source>
          <target state="translated">A.Podrías 'arreglar' esto cronometrando sólo tu programa:</target>
        </trans-unit>
        <trans-unit id="6eacef433fa97c076753f8181b901c1df86fb0ee" translate="yes" xml:space="preserve">
          <source>Adding the following statements to the C++ version just before the &lt;code&gt;while&lt;/code&gt; loop brings it inline with the &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; version:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La adici&amp;oacute;n de las siguientes declaraciones a la versi&amp;oacute;n C ++ justo antes del &lt;/font&gt;&lt;/font&gt; &lt;code&gt;while&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de bucle lo lleva en l&amp;iacute;nea con el &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;pit&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; versi&amp;oacute;n:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa80c19e93d9b42ed6f60bba12683b734e770328" translate="yes" xml:space="preserve">
          <source>Also, if you are in control of the file, consider using a flat binary data format instead of text. It's more reliable to read and write because you don't have to deal with all the ambiguities of whitespace. It's also smaller and much faster to parse.</source>
          <target state="translated">Además,si tiene el control del archivo,considere la posibilidad de utilizar un formato de datos binarios planos en lugar de texto.Es más fiable para leer y escribir porque no tienes que lidiar con todas las ambigüedades de los espacios en blanco.También es más pequeño y mucho más rápido de analizar.</target>
        </trans-unit>
        <trans-unit id="d24cad29120afe707f62c6f3085b2a58c008227b" translate="yes" xml:space="preserve">
          <source>Also, yes, CPython does some caching to avoid harddisk reads.</source>
          <target state="translated">Además,sí,CPython hace un poco de caché para evitar lecturas en el disco duro.</target>
        </trans-unit>
        <trans-unit id="919616b80f9630eba97648eca9e6cc0700de45cc" translate="yes" xml:space="preserve">
          <source>B. or by timing the entire pipeline:</source>
          <target state="translated">B.o cronometrando todo el oleoducto:</target>
        </trans-unit>
        <trans-unit id="a5a9c426254eccca83c581dce40a33f86fc34cf9" translate="yes" xml:space="preserve">
          <source>BTW, didn't know about that sync thing, nice. But you should still try &lt;code&gt;fgets&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por cierto, no sab&amp;iacute;a sobre esa cosa de sincronizaci&amp;oacute;n, agradable. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero igual deber&amp;iacute;as probar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81bad2e8a0b6b2a52ce58ff5f5a60cc0c934ec2b" translate="yes" xml:space="preserve">
          <source>Both this examples too small to make any decisions about C++ vs Python speed. Because we just use some internal mechanism and compare it. So it is unfair to compare. But as we can see Python code match simpler to understand, but it makes inside some conversions (utf8 - decoding I think on Linux and Mac OS) and works on binary files too. C++ version failing to count '\n' on binary files (on Windows with g++ at least)</source>
          <target state="translated">Ambos ejemplos son demasiado pequeños para tomar cualquier decisión sobre la velocidad de C++vs Python.Porque sólo usamos algún mecanismo interno y lo comparamos.Así que es injusto comparar.Pero como podemos ver,el código Python es más simple de entender,pero hace algunas conversiones (utf8-decodificación creo que en Linux y Mac OS)y funciona en archivos binarios también.La versión C++no cuenta '\n' en los archivos binarios (en Windows con g++por lo menos)</target>
        </trans-unit>
        <trans-unit id="6691e104c45825c979a28bdf47ad2d042db64162" translate="yes" xml:space="preserve">
          <source>But I say that last thing with some hesitation.  If we examine the last result in 'Edit 5' --</source>
          <target state="translated">Pero digo eso último con cierta vacilación.Si examinamos el último resultado en 'Edición 5'...</target>
        </trans-unit>
        <trans-unit id="c9d36be2de6f8d949f97fad3693ed38300429c46" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;cin&lt;/code&gt; is synchronized with stdio, which causes it to avoid any input buffering.  If you add this to the top of your main, you should see much better performance:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;De forma predeterminada, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se sincroniza con stdio, lo que hace que evite cualquier almacenamiento intermedio de entrada. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si agrega esto a la parte superior de su p&amp;aacute;gina principal, deber&amp;iacute;a ver un rendimiento mucho mejor:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5c92dd35743a41498513f0900ff9df8a2de766a2" translate="yes" xml:space="preserve">
          <source>By the way, the reason the line count for the C++ version is one greater than the count for the Python version is that the eof flag only gets set when an attempt is made to read beyond eof. So the correct loop would be:</source>
          <target state="translated">Por cierto,la razón por la que la cuenta de líneas para la versión C++es una mayor que la cuenta de la versión Python es que la bandera de eof sólo se fija cuando se intenta leer más allá de eof.Así que el bucle correcto sería:</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="5d6cf463e19a68d2b9cb392046065a032a4d7137" translate="yes" xml:space="preserve">
          <source>For completeness, I thought I'd update the read speed for the same file on the same box with the original (synced) C++ code. Again, this is for a 100M line file on a fast disk. Here's the comparison, with several solutions/approaches:</source>
          <target state="translated">Para completar,pensé en actualizar la velocidad de lectura para el mismo archivo en la misma caja con el código original (sincronizado)de C++.De nuevo,esto es para un archivo de 100M líneas en un disco rápido.Aquí está la comparación,con varios enfoques de solución:</target>
        </trans-unit>
        <trans-unit id="05f418b280d6d0669a3d45dd130b92d3ef333c5e" translate="yes" xml:space="preserve">
          <source>Fortunately, the library designers decided that you should also be able to disable this feature to get improved performance if you knew what you were doing, so they provided the &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio&quot;&gt;&lt;code&gt;sync_with_stdio&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Afortunadamente, los dise&amp;ntilde;adores de la biblioteca decidieron que tambi&amp;eacute;n deber&amp;iacute;a poder desactivar esta funci&amp;oacute;n para obtener un mejor rendimiento si supiera lo que estaba haciendo, por lo que proporcionaron el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;m&amp;eacute;todo &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio&quot;&gt; &lt;code&gt;sync_with_stdio&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">Aquí hay un ejemplo:</target>
        </trans-unit>
        <trans-unit id="a3ec40e608105bf527fa8797040dcb94f345155d" translate="yes" xml:space="preserve">
          <source>I reproduced the original result on my computer using g++ on a Mac.</source>
          <target state="translated">Reproduje el resultado original en mi computadora usando g++en una Mac.</target>
        </trans-unit>
        <trans-unit id="57c10f7853150262360e29fdc0b93b16251f2f6f" translate="yes" xml:space="preserve">
          <source>I should add that there is at least one other significant difference between these styles of testing, and I can't say whether it is a benefit or fault; you have to decide this yourself:</source>
          <target state="translated">Debo añadir que hay al menos otra diferencia significativa entre estos estilos de prueba,y no puedo decir si es un beneficio o un fallo;tienes que decidirlo tú mismo:</target>
        </trans-unit>
        <trans-unit id="749119915fb9bcc67a990d0ef5d5665be585983a" translate="yes" xml:space="preserve">
          <source>I want other C++ version of code. I do not want to copy every line by line. I just want count how many '\n' in file.</source>
          <target state="translated">Quiero otra versión de código C++.No quiero copiar cada línea por línea.Sólo quiero contar cuántas '\N' hay en el archivo.</target>
        </trans-unit>
        <trans-unit id="260f22261673c0af873bb219f7a8ae1b2b64b573" translate="yes" xml:space="preserve">
          <source>I wanted to compare reading lines of string input from stdin using Python and C++ and was shocked to see my C++ code run an order of magnitude slower than the equivalent Python code. Since my C++ is rusty and I'm not yet an expert Pythonista, please tell me if I'm doing something wrong or if I'm misunderstanding something.</source>
          <target state="translated">Quería comparar las líneas de lectura de la cadena de entrada de stdin usando Python y C++y me sorprendió ver que mi código C++se ejecutaba un orden de magnitud más lento que el código Python equivalente.Como mi C++está oxidado y aún no soy un experto en Python,por favor dime si estoy haciendo algo mal o si estoy malinterpretando algo.</target>
        </trans-unit>
        <trans-unit id="7b0e802507be3a79fd0dc0f920f90f6ffd330e60" translate="yes" xml:space="preserve">
          <source>I will mention two possible, but actually wrong, 'fixes' which could also be considered (but I 'number' them differently as these are not things which were wrong in the original post):</source>
          <target state="translated">Mencionaré dos posibles,pero en realidad erróneas,&quot;correcciones&quot; que también podrían considerarse (pero las &quot;enumero&quot; de forma diferente ya que no son cosas que estuvieran mal en el post original):</target>
        </trans-unit>
        <trans-unit id="6396c98ecdd3cbb117338967b67fb60a0ce0e89a" translate="yes" xml:space="preserve">
          <source>I'm a few years behind here, but:</source>
          <target state="translated">Estoy unos cuantos años atrasado,pero:</target>
        </trans-unit>
        <trans-unit id="a604ccbbcf387ae81f374f69dbb6f6d257435681" translate="yes" xml:space="preserve">
          <source>If more input was read by &lt;code&gt;cin&lt;/code&gt; than it actually needed, then the second integer value wouldn't be available for the &lt;code&gt;scanf&lt;/code&gt; function, which has its own independent buffer.  This would lead to unexpected results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; le&amp;iacute;a m&amp;aacute;s entradas &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;de las que realmente necesitaba, entonces el segundo valor entero no estar&amp;iacute;a disponible para la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , que tiene su propio b&amp;uacute;fer independiente. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto llevar&amp;iacute;a a resultados inesperados.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d1103ccd841b2e817c9c4faecaf3bfaaa41295a" translate="yes" xml:space="preserve">
          <source>If you want, you can wrap a stream around that buffer for more convenient access like this:</source>
          <target state="translated">Si quieres,puedes envolver un arroyo alrededor de ese buffer para un acceso más conveniente como este:</target>
        </trans-unit>
        <trans-unit id="de548edc3c54e3d20a32f157bdac636d41f75a1c" translate="yes" xml:space="preserve">
          <source>In 'Edit 4/5/6' of the original post, you are using the construction:</source>
          <target state="translated">En el 'Edit 456' del post original,estás usando la construcción:</target>
        </trans-unit>
        <trans-unit id="b864261dceb4d9e0e5ccfbf23668633686af698a" translate="yes" xml:space="preserve">
          <source>In fact I did some quick tests with a 1.5 gigabyte file of garbage, on a Linux 3.13 (Ubuntu 14.04) system, obtaining these results (these are actually 'best of 3' results; after priming the cache, of course):</source>
          <target state="translated">De hecho hice algunas pruebas rápidas con un archivo de basura de 1,5 gigabytes,en un sistema Linux 3.13 (Ubuntu 14.04),obteniendo estos resultados (estos son en realidad los &quot;mejores de 3&quot; resultados;después de preparar la caché,por supuesto):</target>
        </trans-unit>
        <trans-unit id="d82551d6ef616e947fe345dd7b25f64f5a81ba27" translate="yes" xml:space="preserve">
          <source>In this statement it is the &lt;em&gt;shell&lt;/em&gt; which opens big_file, passing it to your program (well, actually to `time` which then executes your program as a subprocess) as an already-open file descriptor.  100% of the file reading is strictly the responsibility of the program you're trying to benchmark.  This gets you a real reading of its performance without spurious complications.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En esta declaraci&amp;oacute;n, es el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;shell&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que abre big_file, pas&amp;aacute;ndolo a su programa (bueno, en realidad a `time` que luego ejecuta su programa como un subproceso) como un descriptor de archivo ya abierto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El 100% de la lectura del archivo es estrictamente responsabilidad del programa que est&amp;aacute; intentando comparar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto le brinda una lectura real de su rendimiento sin complicaciones espurias.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3088ea2a71bf4e76dfdc1e96ad3c885aa2d2135e" translate="yes" xml:space="preserve">
          <source>In your second example (with scanf()) reason why this is still slower might be because scanf(&quot;%s&quot;) parses string and looks for any space char (space, tab, newline).</source>
          <target state="translated">En tu segundo ejemplo (con scanf())la razón por la que esto es aún más lento podría ser porque scanf(&quot;%s&quot;)analiza la cadena y busca cualquier espacio (espacio,tabulación,nueva línea).</target>
        </trans-unit>
        <trans-unit id="4ca2dae7f1b194d92017c3cab32ec8bae84a031f" translate="yes" xml:space="preserve">
          <source>It beats all my Python attempts by more than a factor 2.</source>
          <target state="translated">Le gana a todos mis intentos de Python por más de un factor 2.</target>
        </trans-unit>
        <trans-unit id="b74fb04c360a35cd5637f86f5f8966f681595e25" translate="yes" xml:space="preserve">
          <source>Just out of curiosity I've taken a look at what happens under the hood, and I've used &lt;a href=&quot;http://en.wikipedia.org/wiki/Strace&quot;&gt;dtruss/strace&lt;/a&gt; on each test.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Solo por curiosidad, he echado un vistazo a lo que sucede debajo del cap&amp;oacute; y he usado &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Strace&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;dtruss / strace&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en cada prueba.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdaf58eab95a0b731758003f39034b18ca7a08f7" translate="yes" xml:space="preserve">
          <source>Normally, when an input stream is buffered, instead of reading one character at a time, the stream will be read in larger chunks.  This reduces the number of system calls, which are typically relatively expensive.  However, since the &lt;code&gt;FILE*&lt;/code&gt; based &lt;code&gt;stdio&lt;/code&gt; and &lt;code&gt;iostreams&lt;/code&gt; often have separate implementations and therefore separate buffers, this could lead to a problem if both were used together.  For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Normalmente, cuando una secuencia de entrada est&amp;aacute; almacenada, en lugar de leer un car&amp;aacute;cter a la vez, la secuencia se leer&amp;aacute; en fragmentos m&amp;aacute;s grandes. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto reduce la cantidad de llamadas al sistema, que suelen ser relativamente caras. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, dado que el &lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; y los &lt;/font&gt; &lt;code&gt;iostreams&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; basados ​​en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;FILE*&lt;/code&gt; a&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; menudo tienen implementaciones separadas y, por lo tanto, buffers separados, esto podr&amp;iacute;a generar un problema si ambos se usan juntos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo:&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97fd295bbcf7715d2d1e8f86155c46f00aa5bcdb" translate="yes" xml:space="preserve">
          <source>Notice that the two pipeline results claim to have taken more CPU time (user+sys) than realtime.  This is because I'm using the shell (Bash)'s built-in 'time' command, which is cognizant of the pipeline; and I'm on a multi-core machine where separate processes in a pipeline can use separate cores, accumulating CPU time faster than realtime.  Using /usr/bin/time I see smaller CPU time than realtime -- showing that it can only time the single pipeline element passed to it on its command line.  Also, the shell's output gives milliseconds while /usr/bin/time only gives hundreths of a second.</source>
          <target state="translated">Fíjese que los resultados de los dos oleoductos afirman haber tomado más tiempo de CPU (usuario+sys)que en tiempo real.Esto se debe a que estoy usando el comando de &quot;tiempo&quot; incorporado en el shell (Bash),que es consciente de la tubería;y estoy en una máquina multinúcleo donde los procesos separados en una tubería pueden usar núcleos separados,acumulando el tiempo de CPU más rápido que en tiempo real.Usando usrbintime veo un tiempo de CPU más pequeño que el tiempo real-mostrando que sólo puede cronometrar el único elemento de la tubería que se le pasa en su línea de comandos.Además,la salida del armazón da milisegundos mientras que usrbintime sólo da centésimas de segundo.</target>
        </trans-unit>
        <trans-unit id="9b0c98872d79e9099677b6990de484ff7dbbe1de" translate="yes" xml:space="preserve">
          <source>Of course it is an interesting benchmark result if the same program performs significantly differently between the two cases.  It shows that, indeed, the program or its I/O libraries &lt;em&gt;are&lt;/em&gt; doing something interesting, like using mmap().  So in practice it might be good to run the benchmarks both ways; perhaps discounting the `cat` result by some small factor to &quot;forgive&quot; the cost of running `cat` itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por supuesto, es un resultado de referencia interesante si el mismo programa se desempe&amp;ntilde;a de manera significativamente diferente entre los dos casos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Muestra que, de hecho, el programa o sus bibliotecas de E / S &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;est&amp;aacute;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; haciendo algo interesante, como usar mmap (). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, en la pr&amp;aacute;ctica, podr&amp;iacute;a ser bueno ejecutar los puntos de referencia en ambos sentidos; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;quiz&amp;aacute;s descontando el resultado de 'cat' por alg&amp;uacute;n peque&amp;ntilde;o factor para &quot;perdonar&quot; el costo de ejecutar &quot;cat&quot; en s&amp;iacute;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="77fe33f271e30ea0be6216f64c174b1e2f493ad4" translate="yes" xml:space="preserve">
          <source>Python code I think we should change too</source>
          <target state="translated">El código Python,creo que también deberíamos cambiarlo.</target>
        </trans-unit>
        <trans-unit id="8d6f668d23cdb06ece2ffec8fd41bcf15e77b630" translate="yes" xml:space="preserve">
          <source>So at the efficiency level of `wc -l`, the `cat` makes a huge difference: 409 / 283 = 1.453 or 45.3% more realtime, and 775 / 280 = 2.768, or a whopping 177% more CPU used!  On my random it-was-there-at-the-time test box.</source>
          <target state="translated">Así que en el nivel de eficiencia de &quot;wc -l&quot;,el &quot;gato&quot; hace una gran diferencia:409 283=1.453 o 45.3% más de tiempo real,y 775 280=2.768,o un enorme 177% más de CPU utilizada! En mi caja de pruebas aleatorias de &quot;estaba en el tiempo&quot;.</target>
        </trans-unit>
        <trans-unit id="95b7b0ce50fd459cea21ab95da67ad7dc700d7da" translate="yes" xml:space="preserve">
          <source>Still, I predict you would be able to measure the difference between `cat file | wc -l` and `wc -l &amp;lt; file` and find a noticeable (2-digit percentage) difference.  Each of the slower tests will have paid a similar penalty in absolute time; which would however amount to a smaller fraction of its larger total time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A&amp;uacute;n as&amp;iacute;, predigo que ser&amp;iacute;a capaz de medir la diferencia entre `cat file | wc -l` y `wc -l &amp;lt;file` y encuentra una diferencia notable (porcentaje de 2 d&amp;iacute;gitos). Cada una de las pruebas m&amp;aacute;s lentas habr&amp;aacute; pagado una penalizaci&amp;oacute;n similar en tiempo absoluto; que sin embargo equivaldr&amp;iacute;a a una fracci&amp;oacute;n menor de su tiempo total m&amp;aacute;s grande.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c0d59470dee317a0bd4e3ed90af701235f5ceec" translate="yes" xml:space="preserve">
          <source>TLDR results: scroll all the way down to the bottom of my question and look at the table.)</source>
          <target state="translated">Resultados del TLDR:Desplácese hasta el fondo de mi pregunta y mire la tabla).</target>
        </trans-unit>
        <trans-unit id="26036044bf09499b66ab681b2636b0886eb6e6cf" translate="yes" xml:space="preserve">
          <source>The following code was faster for me than the other code posted here so far:
(Visual Studio 2013, 64-bit, 500 MB file with line length uniformly in [0, 1000)).</source>
          <target state="translated">El siguiente código fue más rápido para mí que el otro código publicado aquí hasta ahora:(Visual Studio 2013,archivo de 64 bits y 500 MB con longitud de línea uniforme en [0,1000]).</target>
        </trans-unit>
        <trans-unit id="d712bbe9542b29fb12a7ddae3053c86ac35d66ca" translate="yes" xml:space="preserve">
          <source>These are wrong for the same reasons as #2: they're still using `cat` unnecessarily.  I mention them for a few reasons:</source>
          <target state="translated">Estos están equivocados por las mismas razones que el #2:siguen usando &quot;gato&quot; innecesariamente.Los menciono por algunas razones:</target>
        </trans-unit>
        <trans-unit id="151f78cf3abe6db2af3d5bb863a668fb774d5c1e" translate="yes" xml:space="preserve">
          <source>This is wrong in a couple of different ways:</source>
          <target state="translated">Esto está mal de un par de maneras diferentes:</target>
        </trans-unit>
        <trans-unit id="31b18e50b32a9ad9d4e72e48e9d3d402a551f97a" translate="yes" xml:space="preserve">
          <source>Tiny benchmark addendum and recap</source>
          <target state="translated">Pequeña adición y recapitulación de los puntos de referencia</target>
        </trans-unit>
        <trans-unit id="12f64344295facbd95f90ce066c817fa5fbcff18" translate="yes" xml:space="preserve">
          <source>To avoid this, by default, streams are synchronized with &lt;code&gt;stdio&lt;/code&gt;.  One common way to achieve this is to have &lt;code&gt;cin&lt;/code&gt; read each character one at a time as needed using &lt;code&gt;stdio&lt;/code&gt; functions.  Unfortunately, this introduces a lot of overhead.  For small amounts of input, this isn't a big problem, but when you are reading millions of lines, the performance penalty is significant.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para evitar esto, de forma predeterminada, las transmisiones se sincronizan con &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una forma com&amp;uacute;n de lograr esto es que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; lea cada car&amp;aacute;cter uno a la vez, seg&amp;uacute;n sea necesario, utilizando &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; funciones &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;stdio&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desafortunadamente, esto introduce muchos gastos generales. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para peque&amp;ntilde;as cantidades de entrada, este no es un gran problema, pero cuando est&amp;aacute; leyendo millones de l&amp;iacute;neas, la penalizaci&amp;oacute;n de rendimiento es significativa.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c4af42a2bc6a8140f782f723d293d5612c973776" translate="yes" xml:space="preserve">
          <source>Use of `cat` is unnecessary and in fact counterproductive; you're adding moving parts.  If you were on a sufficiently old system (i.e.  with a single CPU and -- in certain generations of computers -- I/O faster than CPU) -- the mere fact that `cat` was running could substantially color the results.  You are also subject to whatever input and output buffering and other processing `cat` may do.  (This would likely earn you a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat&quot;&gt;'Useless Use Of Cat'&lt;/a&gt; award if I were Randal Schwartz.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El uso de 'cat' es innecesario y de hecho contraproducente; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Est&amp;aacute;s agregando partes m&amp;oacute;viles. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si estuviera en un sistema suficientemente antiguo (es decir, con una sola CPU y, en ciertas generaciones de computadoras, E / S m&amp;aacute;s r&amp;aacute;pido que la CPU), el simple hecho de que 'cat' se estaba ejecutando podr&amp;iacute;a colorear sustancialmente los resultados. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n est&amp;aacute; sujeto a todo lo que el almacenamiento intermedio de entrada y salida y otros procesamientos 'cat' puedan hacer. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Esto probablemente le &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;otorgar&amp;iacute;a &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;el&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; premio &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;'Uso in&amp;uacute;til del gato'&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; si fuera Randal Schwartz.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e687d0cf6ef10b35b782602f2bf1981f0e798157" translate="yes" xml:space="preserve">
          <source>Well, I see that in your second solution you switched from &lt;code&gt;cin&lt;/code&gt; to &lt;code&gt;scanf&lt;/code&gt;, which was the first suggestion I was going to make you (cin is sloooooooooooow). Now, if you switch from &lt;code&gt;scanf&lt;/code&gt; to &lt;code&gt;fgets&lt;/code&gt;, you would see another boost in performance: &lt;code&gt;fgets&lt;/code&gt; is the fastest C++ function for string input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bueno, veo que en tu segunda soluci&amp;oacute;n cambiaste de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , que fue la primera sugerencia que te har&amp;iacute;a (cin es sloooooooooooow). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora, si cambia de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , ver&amp;aacute; otro aumento en el rendimiento: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es la funci&amp;oacute;n C ++ m&amp;aacute;s r&amp;aacute;pida para la entrada de cadenas.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be8c0ffa13d1b9e5e48623ed2ff2306f02135d47" translate="yes" xml:space="preserve">
          <source>When you run `/usr/bin/time my_program &amp;lt; big_file`, your program receives an open file descriptor to the actual file.  Your program -- &lt;em&gt;or&lt;/em&gt; in many cases the I/O libraries of the language in which it was written -- may take different actions when presented with a file descriptor referencing a regular file.  It may use mmap(2) to map the input file into its address space, instead of using explicit read(2) system calls.  These differences could have a far larger effect on your benchmark results than the small cost of running the `cat` binary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuando ejecuta `/ usr / bin / time my_program &amp;lt;big_file`, su programa recibe un descriptor de archivo abierto para el archivo real. Su programa, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;o&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en muchos casos las bibliotecas de E / S del idioma en el que se escribi&amp;oacute;, puede tomar diferentes medidas cuando se le presenta un descriptor de archivo que hace referencia a un archivo normal. Puede usar mmap (2) para asignar el archivo de entrada a su espacio de direcciones, en lugar de usar llamadas expl&amp;iacute;citas al sistema read (2). Estas diferencias podr&amp;iacute;an tener un efecto mucho mayor en sus resultados de referencia que el peque&amp;ntilde;o costo de ejecutar el binario `cat`.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae6b11f7e1ce91c9e5497a2e4ac72a06aff02413" translate="yes" xml:space="preserve">
          <source>When you run `cat big_file | /usr/bin/time my_program`, your program is receiving input from a pipe, at precisely the pace sent by `cat`, and in chunks no larger than written by `cat`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99419ef0ccd4c72c0b4ec5ca34d06199b16630c5" translate="yes" xml:space="preserve">
          <source>Why is reading lines from stdin much slower in C++ than Python</source>
          <target state="translated">¿Por qué la lectura de líneas de la ETS es mucho más lenta en C++que en Python</target>
        </trans-unit>
        <trans-unit id="3de13424399dc6cf24b91661d84eaa2b31863a3b" translate="yes" xml:space="preserve">
          <source>You're actually timing the execution of `cat`, not your benchmark.  The 'user' and 'sys' CPU usage displayed by `time` are those of `cat`, not your benchmarked program.  Even worse, the 'real' time is also not necessarily accurate.  Depending on the implementation of `cat` and of pipelines in your local OS, it is possible that `cat` writes a final giant buffer and exits long before the reader process finishes its work.</source>
          <target state="translated">En realidad estás cronometrando la ejecución de ``cat``,no es tu punto de referencia.El uso de CPU del &quot;usuario&quot; y del &quot;sistema&quot; mostrado por &quot;time&quot; son los de &quot;cat&quot;,no los de tu programa de referencia.Aún peor,el tiempo &quot;real&quot; tampoco es necesariamente exacto.Dependiendo de la implementación de `cat` y de las tuberías en su sistema operativo local,es posible que `cat` escriba un buffer gigante final y salga mucho antes de que el proceso de lectura termine su trabajo.</target>
        </trans-unit>
        <trans-unit id="1e72498d28b08e47ce5ad19ced93a61314488cd0" translate="yes" xml:space="preserve">
          <source>actually python is implemented in c/c++ so it works because of a compiled language but its implementation algorithm makes things faster otherwise compiled code works faster than interpreted code.</source>
          <target state="translated">En realidad python está implementado en cc++por lo que funciona gracias a un lenguaje compilado pero su algoritmo de implementación hace las cosas más rápidas,de lo contrario el código compilado funciona más rápido que el código interpretado.</target>
        </trans-unit>
        <trans-unit id="0d927068d028fb0490208928ec2279c4ca6dbd74" translate="yes" xml:space="preserve">
          <source>normally &lt;code&gt;cin&lt;/code&gt;,&lt;code&gt;scanf&lt;/code&gt;,&lt;code&gt;File&lt;/code&gt; etc avoid input buffering and streams can handle huge amount of data,they uses different streams and  the does not providing major features of python because python itself running on python virtual machine if you type one python code which is equal to many lines of compiled code.python provides features such as &lt;strong&gt;cache  acceleration&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;normalmente &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;File&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;etc. evitan el almacenamiento en b&amp;uacute;fer de entrada y las secuencias pueden manejar una gran cantidad de datos, usan diferentes secuencias y no proporcionan caracter&amp;iacute;sticas principales de python porque Python se ejecuta en la m&amp;aacute;quina virtual de python si escribe un c&amp;oacute;digo de python que es igual a muchas l&amp;iacute;neas de code.python compilado proporcionan caracter&amp;iacute;sticas como la &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aceleraci&amp;oacute;n de cach&amp;eacute;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b9992e6edfd2287cdda8287f4cce7c746b5b04a" translate="yes" xml:space="preserve">
          <source>sync_with_stdio improved speed to 2 seconds, and setting a larger buffer brought it down to 1 second.</source>
          <target state="translated">La sincronización con la radio mejoró la velocidad a 2 segundos,y el ajuste de un búfer más grande lo redujo a 1 segundo.</target>
        </trans-unit>
        <trans-unit id="ab4f047c061b9c6bc642d54e86839a4e271cbb98" translate="yes" xml:space="preserve">
          <source>syscalls &lt;code&gt;sudo dtruss -c ./a.out &amp;lt; in&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;syscalls &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sudo dtruss -c ./a.out &amp;lt; in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4eeab4329aae3cae684e7c63ff686f21708cc5f2" translate="yes" xml:space="preserve">
          <source>syscalls &lt;code&gt;sudo dtruss -c ./a.py &amp;lt; in&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;syscalls &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sudo dtruss -c ./a.py &amp;lt; in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7dedc85579d9d10898c2fbc7e3119a830b23dc8" translate="yes" xml:space="preserve">
          <source>there may be cases where `cat` &lt;em&gt;is&lt;/em&gt; needed (e.g.: the file to be read requires some sort of privilege to access, and you do not want to grant that privilege to the program to be benchmarked: `sudo cat /dev/sda | /usr/bin/time my_compression_test --no-output`)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;puede haber casos en los que &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;se&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; necesita &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;`cat` &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(por ejemplo: el archivo a leer requiere alg&amp;uacute;n tipo de privilegio para acceder, y no desea otorgar ese privilegio al programa que se va a comparar:` sudo cat / dev / sda | / usr / bin / time my_compression_test --no-output`)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29470267bc79b4c90ccd78d52ec8d78a07736aad" translate="yes" xml:space="preserve">
          <source>they're more 'natural' for people who aren't entirely comfortable with the I/O redirection facilities of the POSIX shell</source>
          <target state="translated">son más &quot;naturales&quot; para las personas que no están del todo cómodas con las instalaciones de redireccionamiento IO de la carcasa POSIX</target>
        </trans-unit>
        <trans-unit id="c9006eab9fd1508da2bd2f79d9c89c2cb0f714a1" translate="yes" xml:space="preserve">
          <source>would have taken only the remaining .49 seconds!  Probably not: `cat` here had to pay for the read() system calls (or equivalent) which transferred the file from 'disk' (actually buffer cache), as well as the pipe writes to deliver them to `wc`.  The correct test would still have had to do those read() calls; only the write-to-pipe and read-from-pipe calls would have been saved, and those should be pretty cheap.</source>
          <target state="translated">...habría tomado sólo los restantes 0,49 segundos! Probablemente no:`cat` aquí tuvo que pagar por las llamadas de sistema read()(o equivalente)que transfirieron el archivo desde el `disco` (en realidad la caché del buffer),así como las escrituras de pipa para entregarlas a `wc`.La prueba correcta habría tenido que hacer esas llamadas de read();sólo las llamadas de escritura a pipa y de lectura desde pipa se habrían guardado,y esas deberían ser bastante baratas.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
