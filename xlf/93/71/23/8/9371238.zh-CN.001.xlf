<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/9371238">
    <body>
      <group id="9371238">
        <trans-unit id="2ada74fe85580bed0602d49b3709fcf15dcf240b" translate="yes" xml:space="preserve">
          <source>(TLDR answer: include the statement: &lt;code&gt;cin.sync_with_stdio(false)&lt;/code&gt; or just use &lt;code&gt;fgets&lt;/code&gt; instead.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（TLDR答案：包括以下语句：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin.sync_with_stdio(false)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或仅使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5604413a183cbc7d7544d68c94a6c7382ae5d413" translate="yes" xml:space="preserve">
          <source>-- this claims that `cat` consumed 74% of the CPU during the test; and indeed 1.34/1.83 is approximately 74%.  Perhaps a run of:</source>
          <target state="translated">--这声称 &quot;猫 &quot;在测试期间消耗了74%的CPU;而事实上,1.341.83大约是74%。可能是:</target>
        </trans-unit>
        <trans-unit id="1348609af914ffea58e6f9f0adbfd5fc589de6d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline&lt;/code&gt;, stream operators, &lt;code&gt;scanf&lt;/code&gt;, can be convenient if you don't care about file loading time or if you are loading small text files. But, if the performance is something you care about, you should really just buffer the entire file into memory (assuming it will fit).</source>
          <target state="translated">&lt;code&gt;getline&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您不关心文件加载时间或正在加载小型文本文件，则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getline&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，流运算符&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以很方便。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果性能是您所关心的，那么您实际上应该将整个文件缓冲到内存中（假设它将适合）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c0915bf7a2ae1a20a3dd3d752c1dede09758b45d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I should note that I tried this both under Mac&amp;nbsp;OS&amp;nbsp;X&amp;nbsp;v10.6.8 (Snow&amp;nbsp;Leopard) and Linux 2.6.32 (Red Hat Linux 6.2). The former is a MacBook Pro, and the latter is a very beefy server, not that this is too pertinent.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我应该注意，我在Mac OS X v10.6.8（Snow Leopard）和Linux 2.6.32（Red Hat Linux 6.2）下都尝试过。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;前者是MacBook Pro，后者是非常强大的服务器，并不是说这太相关了。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8119e8521189e9d54129bd0197536b2d962ff8bc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in practice&lt;/em&gt;, on modern machines, the added `cat` in the pipeline is probably of no real consequence</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在实践中&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，在现代机器上，管道中添加的&amp;ldquo; cat&amp;rdquo;可能没有实际意义&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f625673762999b841e0b14d2b37dd1775f5d0bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++代码：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e4899c39940c2a22b2171aa7540343dadef7018" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Here are my results:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是我的结果：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d886917c5612dc7850a74f654f3ffa7d073dde44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python Equivalent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等同于Python：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7ba7ad03822a6b3e0d1b23058b1f808ac10d2d6" translate="yes" xml:space="preserve">
          <source>A better construction would be:</source>
          <target state="translated">一个比较好的构造是:</target>
        </trans-unit>
        <trans-unit id="8c484caf9d550a5b7b43988b6fc5cbdf31ee5cee" translate="yes" xml:space="preserve">
          <source>A first element of an answer: &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; is slow. Damn slow. I get a huge performance boost with &lt;code&gt;scanf&lt;/code&gt; as in the below, but it is still two times slower than Python.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;答案的第一要素：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很慢。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该死的慢。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如下所示，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;获得了巨大的性能提升&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是它仍然比Python慢​​两倍。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d606b8781f8d9cc1eb582fbcf3c012f3e5267c6" translate="yes" xml:space="preserve">
          <source>A. You could 'fix' this by timing only your program:</source>
          <target state="translated">A.你可以通过只给你的程序计时来 &quot;解决 &quot;这个问题。</target>
        </trans-unit>
        <trans-unit id="6eacef433fa97c076753f8181b901c1df86fb0ee" translate="yes" xml:space="preserve">
          <source>Adding the following statements to the C++ version just before the &lt;code&gt;while&lt;/code&gt; loop brings it inline with the &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; version:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;while&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;循环&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之前将以下语句添加到C ++版本，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使其与&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Python&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;版本&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内联&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa80c19e93d9b42ed6f60bba12683b734e770328" translate="yes" xml:space="preserve">
          <source>Also, if you are in control of the file, consider using a flat binary data format instead of text. It's more reliable to read and write because you don't have to deal with all the ambiguities of whitespace. It's also smaller and much faster to parse.</source>
          <target state="translated">另外,如果你对文件有控制权,可以考虑使用平面二进制数据格式而不是文本。它的读和写更可靠,因为你不必处理所有的空白空间的模糊性。它也更小,解析起来也更快。</target>
        </trans-unit>
        <trans-unit id="d24cad29120afe707f62c6f3085b2a58c008227b" translate="yes" xml:space="preserve">
          <source>Also, yes, CPython does some caching to avoid harddisk reads.</source>
          <target state="translated">另外,是的,CPython做了一些缓存来避免硬盘读取。</target>
        </trans-unit>
        <trans-unit id="919616b80f9630eba97648eca9e6cc0700de45cc" translate="yes" xml:space="preserve">
          <source>B. or by timing the entire pipeline:</source>
          <target state="translated">B、或通过对整个管道进行计时。</target>
        </trans-unit>
        <trans-unit id="a5a9c426254eccca83c581dce40a33f86fc34cf9" translate="yes" xml:space="preserve">
          <source>BTW, didn't know about that sync thing, nice. But you should still try &lt;code&gt;fgets&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;顺便说一句，不知道同步的事情，很好。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是您仍然应该尝试&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81bad2e8a0b6b2a52ce58ff5f5a60cc0c934ec2b" translate="yes" xml:space="preserve">
          <source>Both this examples too small to make any decisions about C++ vs Python speed. Because we just use some internal mechanism and compare it. So it is unfair to compare. But as we can see Python code match simpler to understand, but it makes inside some conversions (utf8 - decoding I think on Linux and Mac OS) and works on binary files too. C++ version failing to count '\n' on binary files (on Windows with g++ at least)</source>
          <target state="translated">这两个例子都太小了,无法对C++vs Python的速度做出任何决定。因为我们只是用一些内部机制来比较。所以比较起来是不公平的。但我们可以看到Python的代码匹配更容易理解,但它在内部进行了一些转换(utf8--解码,我想在Linux和Mac OS上也是如此),并且在二进制文件上也可以工作。在二进制文件上,C++版本无法计算'\n'(至少在Windows的g++上是这样)。</target>
        </trans-unit>
        <trans-unit id="6691e104c45825c979a28bdf47ad2d042db64162" translate="yes" xml:space="preserve">
          <source>But I say that last thing with some hesitation.  If we examine the last result in 'Edit 5' --</source>
          <target state="translated">但我说这最后一句话时有些犹豫。如果我们研究一下 &quot;编辑5 &quot;中的最后一个结果 ----</target>
        </trans-unit>
        <trans-unit id="c9d36be2de6f8d949f97fad3693ed38300429c46" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;cin&lt;/code&gt; is synchronized with stdio, which causes it to avoid any input buffering.  If you add this to the top of your main, you should see much better performance:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缺省情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与stdio同步，这使它避免了任何输入缓冲。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果将其添加到主目录的顶部，应该会看到更好的性能：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5c92dd35743a41498513f0900ff9df8a2de766a2" translate="yes" xml:space="preserve">
          <source>By the way, the reason the line count for the C++ version is one greater than the count for the Python version is that the eof flag only gets set when an attempt is made to read beyond eof. So the correct loop would be:</source>
          <target state="translated">顺便说一下,C++版本的行数比Python版本的行数大的原因是,只有在尝试读取超过eof的时候才会设置eof标志。所以正确的循环应该是</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="5d6cf463e19a68d2b9cb392046065a032a4d7137" translate="yes" xml:space="preserve">
          <source>For completeness, I thought I'd update the read speed for the same file on the same box with the original (synced) C++ code. Again, this is for a 100M line file on a fast disk. Here's the comparison, with several solutions/approaches:</source>
          <target state="translated">为了完整起见,我想我更新一下在同一个盒子上的相同文件的读取速度和原始(同步的)C++代码。同样,这是针对快速磁盘上一个100M行的文件。下面是对比,有几种解决方法。</target>
        </trans-unit>
        <trans-unit id="05f418b280d6d0669a3d45dd130b92d3ef333c5e" translate="yes" xml:space="preserve">
          <source>Fortunately, the library designers decided that you should also be able to disable this feature to get improved performance if you knew what you were doing, so they provided the &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio&quot;&gt;&lt;code&gt;sync_with_stdio&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;幸运的是，库设计人员决定，如果您知道自己在做什么，则还应该能够禁用此功能以提高性能，因此他们提供了&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio&quot;&gt; &lt;code&gt;sync_with_stdio&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="a3ec40e608105bf527fa8797040dcb94f345155d" translate="yes" xml:space="preserve">
          <source>I reproduced the original result on my computer using g++ on a Mac.</source>
          <target state="translated">我在电脑上用g++在Mac上重现了原始结果。</target>
        </trans-unit>
        <trans-unit id="57c10f7853150262360e29fdc0b93b16251f2f6f" translate="yes" xml:space="preserve">
          <source>I should add that there is at least one other significant difference between these styles of testing, and I can't say whether it is a benefit or fault; you have to decide this yourself:</source>
          <target state="translated">我要补充的是,这些测试方式至少还有一个显著的区别,我不能说是好处还是过错,这一点要靠你自己去判断。</target>
        </trans-unit>
        <trans-unit id="749119915fb9bcc67a990d0ef5d5665be585983a" translate="yes" xml:space="preserve">
          <source>I want other C++ version of code. I do not want to copy every line by line. I just want count how many '\n' in file.</source>
          <target state="translated">我想要其他C++版本的代码。我不想逐行复制每一行代码。我只想计算文件里有多少个'n'。</target>
        </trans-unit>
        <trans-unit id="260f22261673c0af873bb219f7a8ae1b2b64b573" translate="yes" xml:space="preserve">
          <source>I wanted to compare reading lines of string input from stdin using Python and C++ and was shocked to see my C++ code run an order of magnitude slower than the equivalent Python code. Since my C++ is rusty and I'm not yet an expert Pythonista, please tell me if I'm doing something wrong or if I'm misunderstanding something.</source>
          <target state="translated">我想比较一下使用Python和C++从stdin读取字符串输入的行数,结果我的C++代码比Python代码慢了一个数量级。由于我的C++还很生疏,而且我还不是Python专家,请你告诉我,我是不是做错了什么,或者是我理解错了什么。</target>
        </trans-unit>
        <trans-unit id="7b0e802507be3a79fd0dc0f920f90f6ffd330e60" translate="yes" xml:space="preserve">
          <source>I will mention two possible, but actually wrong, 'fixes' which could also be considered (but I 'number' them differently as these are not things which were wrong in the original post):</source>
          <target state="translated">我会提到两个可能的,但实际上是错误的 &quot;修复&quot;,也可以考虑(但我 &quot;编号 &quot;的方式不同,因为这些都不是原帖中错误的东西)。</target>
        </trans-unit>
        <trans-unit id="6396c98ecdd3cbb117338967b67fb60a0ce0e89a" translate="yes" xml:space="preserve">
          <source>I'm a few years behind here, but:</source>
          <target state="translated">我在这里落后了几年,但是。</target>
        </trans-unit>
        <trans-unit id="a604ccbbcf387ae81f374f69dbb6f6d257435681" translate="yes" xml:space="preserve">
          <source>If more input was read by &lt;code&gt;cin&lt;/code&gt; than it actually needed, then the second integer value wouldn't be available for the &lt;code&gt;scanf&lt;/code&gt; function, which has its own independent buffer.  This would lead to unexpected results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;读取的输入&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多于实际需要的输入，那么第二个整数值将无法用于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数，该函数具有自己的独立缓冲区。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将导致意外的结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d1103ccd841b2e817c9c4faecaf3bfaaa41295a" translate="yes" xml:space="preserve">
          <source>If you want, you can wrap a stream around that buffer for more convenient access like this:</source>
          <target state="translated">如果你想的话,你可以像这样在缓冲区周围包裹一个流,这样访问起来更方便。</target>
        </trans-unit>
        <trans-unit id="de548edc3c54e3d20a32f157bdac636d41f75a1c" translate="yes" xml:space="preserve">
          <source>In 'Edit 4/5/6' of the original post, you are using the construction:</source>
          <target state="translated">在原帖的'编辑456'中,你用的是构造。</target>
        </trans-unit>
        <trans-unit id="b864261dceb4d9e0e5ccfbf23668633686af698a" translate="yes" xml:space="preserve">
          <source>In fact I did some quick tests with a 1.5 gigabyte file of garbage, on a Linux 3.13 (Ubuntu 14.04) system, obtaining these results (these are actually 'best of 3' results; after priming the cache, of course):</source>
          <target state="translated">事实上,我在一个Linux 3.13 (Ubuntu 14.04)系统上,用1.5G的垃圾文件做了一些快速测试,得到了以下结果(这些结果实际上是 &quot;3个中的最佳结果,当然是在启动缓存之后)。</target>
        </trans-unit>
        <trans-unit id="d82551d6ef616e947fe345dd7b25f64f5a81ba27" translate="yes" xml:space="preserve">
          <source>In this statement it is the &lt;em&gt;shell&lt;/em&gt; which opens big_file, passing it to your program (well, actually to `time` which then executes your program as a subprocess) as an already-open file descriptor.  100% of the file reading is strictly the responsibility of the program you're trying to benchmark.  This gets you a real reading of its performance without spurious complications.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在此语句中，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;外壳程序&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将打开big_file，并将其作为已打开的文件描述符传递给您的程序（实际上是传递给&amp;ldquo; time&amp;rdquo;，然后将其作为子进程执行）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所读取文件的100％严格是您要进行基准测试的程序的责任。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这使您可以真正了解其性能，而不会产生虚假的并发症。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3088ea2a71bf4e76dfdc1e96ad3c885aa2d2135e" translate="yes" xml:space="preserve">
          <source>In your second example (with scanf()) reason why this is still slower might be because scanf(&quot;%s&quot;) parses string and looks for any space char (space, tab, newline).</source>
          <target state="translated">在你的第二个例子中(用scanf())可能是由于scanf(&quot;%s&quot;)解析字符串并查找任何空格字符(空格、tab、newline)。</target>
        </trans-unit>
        <trans-unit id="4ca2dae7f1b194d92017c3cab32ec8bae84a031f" translate="yes" xml:space="preserve">
          <source>It beats all my Python attempts by more than a factor 2.</source>
          <target state="translated">它比我所有的Python尝试都要高出2倍以上。</target>
        </trans-unit>
        <trans-unit id="b74fb04c360a35cd5637f86f5f8966f681595e25" translate="yes" xml:space="preserve">
          <source>Just out of curiosity I've taken a look at what happens under the hood, and I've used &lt;a href=&quot;http://en.wikipedia.org/wiki/Strace&quot;&gt;dtruss/strace&lt;/a&gt; on each test.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出于好奇，我了解了实际情况，并且&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在每次测试中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都使用了&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Strace&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;dtruss / strace&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdaf58eab95a0b731758003f39034b18ca7a08f7" translate="yes" xml:space="preserve">
          <source>Normally, when an input stream is buffered, instead of reading one character at a time, the stream will be read in larger chunks.  This reduces the number of system calls, which are typically relatively expensive.  However, since the &lt;code&gt;FILE*&lt;/code&gt; based &lt;code&gt;stdio&lt;/code&gt; and &lt;code&gt;iostreams&lt;/code&gt; often have separate implementations and therefore separate buffers, this could lead to a problem if both were used together.  For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常，当缓冲输入流时，而不是一次读取一个字符，而是以较大的块读取该流。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这减少了通常较为昂贵的系统调用次数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，由于&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;FILE*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;iostreams&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常具有单独的实现，因此也具有单独的缓冲区，因此，如果将两者一起使用，可能会导致问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97fd295bbcf7715d2d1e8f86155c46f00aa5bcdb" translate="yes" xml:space="preserve">
          <source>Notice that the two pipeline results claim to have taken more CPU time (user+sys) than realtime.  This is because I'm using the shell (Bash)'s built-in 'time' command, which is cognizant of the pipeline; and I'm on a multi-core machine where separate processes in a pipeline can use separate cores, accumulating CPU time faster than realtime.  Using /usr/bin/time I see smaller CPU time than realtime -- showing that it can only time the single pipeline element passed to it on its command line.  Also, the shell's output gives milliseconds while /usr/bin/time only gives hundreths of a second.</source>
          <target state="translated">注意到这两个流水线结果声称比实时多花了更多的CPU时间(user+sys)。这是因为我使用的是shell(Bash)内置的 &quot;time &quot;命令,它对流水线有认知;而且我在一台多核机器上,流水线中的不同进程可以使用不同的内核,积累的CPU时间比实时的要快。使用usrbintime,我看到的CPU时间比realtime要小----说明它只能对命令行中传递给它的单个流水线元素进行计时。另外,shell的输出给出的时间是毫秒,而usrbintime只给出几百分之一秒。</target>
        </trans-unit>
        <trans-unit id="9b0c98872d79e9099677b6990de484ff7dbbe1de" translate="yes" xml:space="preserve">
          <source>Of course it is an interesting benchmark result if the same program performs significantly differently between the two cases.  It shows that, indeed, the program or its I/O libraries &lt;em&gt;are&lt;/em&gt; doing something interesting, like using mmap().  So in practice it might be good to run the benchmarks both ways; perhaps discounting the `cat` result by some small factor to &quot;forgive&quot; the cost of running `cat` itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，如果同一程序在两种情况下的执行情况显着不同，这将是一个有趣的基准测试结果。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它确实表明该程序或其I / O库&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正在&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;做一些有趣的事情，例如使用mmap（）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，在实践中最好同时使用两种基准。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也许将cat的结果折价一些，以&amp;ldquo;原谅&amp;rdquo; cat本身的运行成本。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="77fe33f271e30ea0be6216f64c174b1e2f493ad4" translate="yes" xml:space="preserve">
          <source>Python code I think we should change too</source>
          <target state="translated">我想我们也应该改一下Python代码</target>
        </trans-unit>
        <trans-unit id="8d6f668d23cdb06ece2ffec8fd41bcf15e77b630" translate="yes" xml:space="preserve">
          <source>So at the efficiency level of `wc -l`, the `cat` makes a huge difference: 409 / 283 = 1.453 or 45.3% more realtime, and 775 / 280 = 2.768, or a whopping 177% more CPU used!  On my random it-was-there-at-the-time test box.</source>
          <target state="translated">所以在 &quot;WC -L &quot;的效率水平上,&quot;猫 &quot;就有很大的差别。409 283=1.453 或 45.3%的实时性,而 775 280=2.768,即多用了 177% 的 CPU! 在我的随机测试箱中,我的随机测试箱中,它--是--是--当时---时的测试箱。</target>
        </trans-unit>
        <trans-unit id="95b7b0ce50fd459cea21ab95da67ad7dc700d7da" translate="yes" xml:space="preserve">
          <source>Still, I predict you would be able to measure the difference between `cat file | wc -l` and `wc -l &amp;lt; file` and find a noticeable (2-digit percentage) difference.  Each of the slower tests will have paid a similar penalty in absolute time; which would however amount to a smaller fraction of its larger total time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不过，我预计您将能够测量`cat file | wc -l`和`wc -l &amp;lt;​​file`并找到明显的差异（两位数百分比）。每个较慢的测试在绝对时间内都会付出相似的代价。但是，这只占其总时间的一小部分。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c0d59470dee317a0bd4e3ed90af701235f5ceec" translate="yes" xml:space="preserve">
          <source>TLDR results: scroll all the way down to the bottom of my question and look at the table.)</source>
          <target state="translated">TLDR结果:一路向下滚动到我的问题的底部,看一下表格。)</target>
        </trans-unit>
        <trans-unit id="26036044bf09499b66ab681b2636b0886eb6e6cf" translate="yes" xml:space="preserve">
          <source>The following code was faster for me than the other code posted here so far:
(Visual Studio 2013, 64-bit, 500 MB file with line length uniformly in [0, 1000)).</source>
          <target state="translated">下面的代码对我来说比这里发布的其他代码要快。(Visual Studio 2013,64位,500 MB文件,行长统一为[0,1000])。</target>
        </trans-unit>
        <trans-unit id="d712bbe9542b29fb12a7ddae3053c86ac35d66ca" translate="yes" xml:space="preserve">
          <source>These are wrong for the same reasons as #2: they're still using `cat` unnecessarily.  I mention them for a few reasons:</source>
          <target state="translated">这些都是错误的,原因和#2一样:他们还是在不必要地使用`猫'。我提到它们有几个原因。</target>
        </trans-unit>
        <trans-unit id="151f78cf3abe6db2af3d5bb863a668fb774d5c1e" translate="yes" xml:space="preserve">
          <source>This is wrong in a couple of different ways:</source>
          <target state="translated">这在几个方面都是错误的。</target>
        </trans-unit>
        <trans-unit id="31b18e50b32a9ad9d4e72e48e9d3d402a551f97a" translate="yes" xml:space="preserve">
          <source>Tiny benchmark addendum and recap</source>
          <target state="translated">微型基准增编和回顾</target>
        </trans-unit>
        <trans-unit id="12f64344295facbd95f90ce066c817fa5fbcff18" translate="yes" xml:space="preserve">
          <source>To avoid this, by default, streams are synchronized with &lt;code&gt;stdio&lt;/code&gt;.  One common way to achieve this is to have &lt;code&gt;cin&lt;/code&gt; read each character one at a time as needed using &lt;code&gt;stdio&lt;/code&gt; functions.  Unfortunately, this introduces a lot of overhead.  For small amounts of input, this isn't a big problem, but when you are reading millions of lines, the performance penalty is significant.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为避免这种情况，默认情况下，流与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同步&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实现此目的的一种常用方法是让&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一次读取每个字符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不幸的是，这带来了很多开销。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于少量输入而言，这不是一个大问题，但是当您读取数百万行时，性能损失将是巨大的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c4af42a2bc6a8140f782f723d293d5612c973776" translate="yes" xml:space="preserve">
          <source>Use of `cat` is unnecessary and in fact counterproductive; you're adding moving parts.  If you were on a sufficiently old system (i.e.  with a single CPU and -- in certain generations of computers -- I/O faster than CPU) -- the mere fact that `cat` was running could substantially color the results.  You are also subject to whatever input and output buffering and other processing `cat` may do.  (This would likely earn you a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat&quot;&gt;'Useless Use Of Cat'&lt;/a&gt; award if I were Randal Schwartz.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用cat是不必要的，实际上会适得其反；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您正在添加活动部件。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您使用的是足够老的系统（即具有单个CPU，并且-在某些代代计算机中-I / O比CPU快），那么`cat'正在运行这一事实就可能使结果显着变色。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您还可能受到任何输入和输出缓冲以及其他处理操作的影响。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我是Randal Schwartz，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这可能会为您赢得&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;猫的无用使用&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;奖。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e687d0cf6ef10b35b782602f2bf1981f0e798157" translate="yes" xml:space="preserve">
          <source>Well, I see that in your second solution you switched from &lt;code&gt;cin&lt;/code&gt; to &lt;code&gt;scanf&lt;/code&gt;, which was the first suggestion I was going to make you (cin is sloooooooooooow). Now, if you switch from &lt;code&gt;scanf&lt;/code&gt; to &lt;code&gt;fgets&lt;/code&gt;, you would see another boost in performance: &lt;code&gt;fgets&lt;/code&gt; is the fastest C++ function for string input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好吧，我看到在您的第二个解决方案中，您从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;切换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这是我要提出的第一个建议（cin是sloooooooooooow）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，如果您从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;切换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您将看到性能的另一个提升：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是用于字符串输入的最快的C ++函数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be8c0ffa13d1b9e5e48623ed2ff2306f02135d47" translate="yes" xml:space="preserve">
          <source>When you run `/usr/bin/time my_program &amp;lt; big_file`, your program receives an open file descriptor to the actual file.  Your program -- &lt;em&gt;or&lt;/em&gt; in many cases the I/O libraries of the language in which it was written -- may take different actions when presented with a file descriptor referencing a regular file.  It may use mmap(2) to map the input file into its address space, instead of using explicit read(2) system calls.  These differences could have a far larger effect on your benchmark results than the small cost of running the `cat` binary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您运行`/ usr / bin / time my_program &amp;lt;big_file`时，您的程序会收到一个指向实际文件的打开文件描述符。当您的程序（&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在许多情况下，该语言是使用其编写的语言的I / O库）在提供引用常规文件的文件描述符时可能会采取不同的操作。它可以使用mmap（2）将输入文件映射到其地址空间，而不是使用显式的read（2）系统调用。这些差异可能对您的基准测试结果产生的影响远大于运行&amp;ldquo; cat&amp;rdquo;二进制文件的少量费用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae6b11f7e1ce91c9e5497a2e4ac72a06aff02413" translate="yes" xml:space="preserve">
          <source>When you run `cat big_file | /usr/bin/time my_program`, your program is receiving input from a pipe, at precisely the pace sent by `cat`, and in chunks no larger than written by `cat`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99419ef0ccd4c72c0b4ec5ca34d06199b16630c5" translate="yes" xml:space="preserve">
          <source>Why is reading lines from stdin much slower in C++ than Python</source>
          <target state="translated">为什么在C++中从stdin读取行数比Python慢很多?</target>
        </trans-unit>
        <trans-unit id="3de13424399dc6cf24b91661d84eaa2b31863a3b" translate="yes" xml:space="preserve">
          <source>You're actually timing the execution of `cat`, not your benchmark.  The 'user' and 'sys' CPU usage displayed by `time` are those of `cat`, not your benchmarked program.  Even worse, the 'real' time is also not necessarily accurate.  Depending on the implementation of `cat` and of pipelines in your local OS, it is possible that `cat` writes a final giant buffer and exits long before the reader process finishes its work.</source>
          <target state="translated">你实际上是在给 &quot;cat &quot;的执行计时,而不是你的基准。`time`显示的 &quot;用户 &quot;和 &quot;系统 &quot;的CPU使用量是`cat`的,而不是你的基准程序。更糟糕的是,&quot;真实 &quot;时间也不一定准确。根据 &quot;cat &quot;和你的本地操作系统中的流水线的实现,&quot;cat &quot;有可能在读卡器进程完成工作前很久就会写入一个巨大的缓冲区并退出。</target>
        </trans-unit>
        <trans-unit id="1e72498d28b08e47ce5ad19ced93a61314488cd0" translate="yes" xml:space="preserve">
          <source>actually python is implemented in c/c++ so it works because of a compiled language but its implementation algorithm makes things faster otherwise compiled code works faster than interpreted code.</source>
          <target state="translated">实际上,Python是用cc++实现的,所以它的工作原理是因为编译后的语言,但它的实现算法使事情变得更快,否则编译后的代码比解释后的代码更快。</target>
        </trans-unit>
        <trans-unit id="0d927068d028fb0490208928ec2279c4ca6dbd74" translate="yes" xml:space="preserve">
          <source>normally &lt;code&gt;cin&lt;/code&gt;,&lt;code&gt;scanf&lt;/code&gt;,&lt;code&gt;File&lt;/code&gt; etc avoid input buffering and streams can handle huge amount of data,they uses different streams and  the does not providing major features of python because python itself running on python virtual machine if you type one python code which is equal to many lines of compiled code.python provides features such as &lt;strong&gt;cache  acceleration&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;File&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等避免输入缓冲，流可以处理大量数据，它们使用不同的流，并且不提供python的主要功能，因为如果您键入一个等于多行编译代码.python提供了诸如&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缓存加速之类的功能&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b9992e6edfd2287cdda8287f4cce7c746b5b04a" translate="yes" xml:space="preserve">
          <source>sync_with_stdio improved speed to 2 seconds, and setting a larger buffer brought it down to 1 second.</source>
          <target state="translated">sync_with_stdio将速度提高到了2秒,而设置一个较大的缓冲区将速度降低到1秒。</target>
        </trans-unit>
        <trans-unit id="ab4f047c061b9c6bc642d54e86839a4e271cbb98" translate="yes" xml:space="preserve">
          <source>syscalls &lt;code&gt;sudo dtruss -c ./a.out &amp;lt; in&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;系统调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sudo dtruss -c ./a.out &amp;lt; in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4eeab4329aae3cae684e7c63ff686f21708cc5f2" translate="yes" xml:space="preserve">
          <source>syscalls &lt;code&gt;sudo dtruss -c ./a.py &amp;lt; in&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;系统调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sudo dtruss -c ./a.py &amp;lt; in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7dedc85579d9d10898c2fbc7e3119a830b23dc8" translate="yes" xml:space="preserve">
          <source>there may be cases where `cat` &lt;em&gt;is&lt;/em&gt; needed (e.g.: the file to be read requires some sort of privilege to access, and you do not want to grant that privilege to the program to be benchmarked: `sudo cat /dev/sda | /usr/bin/time my_compression_test --no-output`)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能存在`cat`情况下&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;需要的（例如：要读取的文件需要某种特权来访问，并且不希望授予该特权的程序进行基准测试：`sudo的猫/ dev / sda上| / usr / bin / time my_compression_test --no-output`）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29470267bc79b4c90ccd78d52ec8d78a07736aad" translate="yes" xml:space="preserve">
          <source>they're more 'natural' for people who aren't entirely comfortable with the I/O redirection facilities of the POSIX shell</source>
          <target state="translated">它们对于那些对POSIX shell的IO重定向设施不完全适应的人来说更 &quot;自然&quot;。</target>
        </trans-unit>
        <trans-unit id="c9006eab9fd1508da2bd2f79d9c89c2cb0f714a1" translate="yes" xml:space="preserve">
          <source>would have taken only the remaining .49 seconds!  Probably not: `cat` here had to pay for the read() system calls (or equivalent) which transferred the file from 'disk' (actually buffer cache), as well as the pipe writes to deliver them to `wc`.  The correct test would still have had to do those read() calls; only the write-to-pipe and read-from-pipe calls would have been saved, and those should be pretty cheap.</source>
          <target state="translated">只花了0.49秒! 可能不是:这里的 &quot;cat &quot;必须支付读取()系统调用(或类似的调用)的费用,这些调用将文件从 &quot;磁盘&quot;(实际上是缓冲区缓存)中传送到 &quot;wc&quot;,以及管道写入将文件传送到 &quot;wc&quot;。正确的测试还是要做这些read()调用;只有write-to-pipe和read-from-pipe的调用才会被保存下来,这些应该是相当便宜的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
