<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/9371238">
    <body>
      <group id="9371238">
        <trans-unit id="2ada74fe85580bed0602d49b3709fcf15dcf240b" translate="yes" xml:space="preserve">
          <source>(TLDR answer: include the statement: &lt;code&gt;cin.sync_with_stdio(false)&lt;/code&gt; or just use &lt;code&gt;fgets&lt;/code&gt; instead.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Ответ TLDR: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin.sync_with_stdio(false)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; утверждение: &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cin.sync_with_stdio (false)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или просто используйте &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вместо него &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5604413a183cbc7d7544d68c94a6c7382ae5d413" translate="yes" xml:space="preserve">
          <source>-- this claims that `cat` consumed 74% of the CPU during the test; and indeed 1.34/1.83 is approximately 74%.  Perhaps a run of:</source>
          <target state="translated">--в нем утверждается,что `кат` потреблял 74% центрального процессора во время теста;и действительно 1.341.83 составляет приблизительно 74%.Возможно,пробег:</target>
        </trans-unit>
        <trans-unit id="1348609af914ffea58e6f9f0adbfd5fc589de6d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline&lt;/code&gt;, stream operators, &lt;code&gt;scanf&lt;/code&gt;, can be convenient if you don't care about file loading time or if you are loading small text files. But, if the performance is something you care about, you should really just buffer the entire file into memory (assuming it will fit).</source>
          <target state="translated">&lt;code&gt;getline&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , stream &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;scanf&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , могут быть удобны, если вам не важно время загрузки файла или если вы загружаете небольшие текстовые файлы. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но если вам важна производительность, вам нужно просто поместить весь файл в память (при условии, что он уместится).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c0915bf7a2ae1a20a3dd3d752c1dede09758b45d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I should note that I tried this both under Mac&amp;nbsp;OS&amp;nbsp;X&amp;nbsp;v10.6.8 (Snow&amp;nbsp;Leopard) and Linux 2.6.32 (Red Hat Linux 6.2). The former is a MacBook Pro, and the latter is a very beefy server, not that this is too pertinent.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Должен отметить, что я пробовал это как в Mac OS X 10.6.8 (Snow Leopard), так и в Linux 2.6.32 (Red Hat Linux 6.2). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Первый - это MacBook Pro, а второй - очень навороченный сервер, не то чтобы это было слишком уместно.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8119e8521189e9d54129bd0197536b2d962ff8bc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in practice&lt;/em&gt;, on modern machines, the added `cat` in the pipeline is probably of no real consequence</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;на практике&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на современных машинах добавление `cat` в конвейер, вероятно, не имеет реального значения&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f625673762999b841e0b14d2b37dd1775f5d0bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Код C ++:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e4899c39940c2a22b2171aa7540343dadef7018" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Here are my results:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот мои результаты:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d886917c5612dc7850a74f654f3ffa7d073dde44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python Equivalent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эквивалент Python:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7ba7ad03822a6b3e0d1b23058b1f808ac10d2d6" translate="yes" xml:space="preserve">
          <source>A better construction would be:</source>
          <target state="translated">Лучше было бы построить:</target>
        </trans-unit>
        <trans-unit id="8c484caf9d550a5b7b43988b6fc5cbdf31ee5cee" translate="yes" xml:space="preserve">
          <source>A first element of an answer: &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; is slow. Damn slow. I get a huge performance boost with &lt;code&gt;scanf&lt;/code&gt; as in the below, but it is still two times slower than Python.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Первый элемент ответа: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; медленный. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чертовски медленно. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я получаю огромный прирост производительности с помощью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; как &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;показано&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ниже, но он все еще в два раза медленнее, чем Python.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d606b8781f8d9cc1eb582fbcf3c012f3e5267c6" translate="yes" xml:space="preserve">
          <source>A. You could 'fix' this by timing only your program:</source>
          <target state="translated">A.Ты можешь &quot;исправить&quot; это,установив время только для своей программы:</target>
        </trans-unit>
        <trans-unit id="6eacef433fa97c076753f8181b901c1df86fb0ee" translate="yes" xml:space="preserve">
          <source>Adding the following statements to the C++ version just before the &lt;code&gt;while&lt;/code&gt; loop brings it inline with the &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; version:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Добавление следующих заявлений в версию C ++ непосредственно перед в &lt;/font&gt;&lt;/font&gt; &lt;code&gt;while&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; петля приносит его рядным с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Python&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; версией:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa80c19e93d9b42ed6f60bba12683b734e770328" translate="yes" xml:space="preserve">
          <source>Also, if you are in control of the file, consider using a flat binary data format instead of text. It's more reliable to read and write because you don't have to deal with all the ambiguities of whitespace. It's also smaller and much faster to parse.</source>
          <target state="translated">Также,если вы контролируете файл,подумайте об использовании плоского двоичного формата данных вместо текста.Читать и писать надежнее,потому что вам не придется иметь дело со всеми неясностями пробела.Также он меньше по размеру и намного быстрее для разбора.</target>
        </trans-unit>
        <trans-unit id="d24cad29120afe707f62c6f3085b2a58c008227b" translate="yes" xml:space="preserve">
          <source>Also, yes, CPython does some caching to avoid harddisk reads.</source>
          <target state="translated">Кроме того,да,CPython делает некоторые кэширования,чтобы избежать чтения жестких дисков.</target>
        </trans-unit>
        <trans-unit id="919616b80f9630eba97648eca9e6cc0700de45cc" translate="yes" xml:space="preserve">
          <source>B. or by timing the entire pipeline:</source>
          <target state="translated">Б.или по времени всего трубопровода:</target>
        </trans-unit>
        <trans-unit id="a5a9c426254eccca83c581dce40a33f86fc34cf9" translate="yes" xml:space="preserve">
          <source>BTW, didn't know about that sync thing, nice. But you should still try &lt;code&gt;fgets&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кстати, не знал об этой вещи синхронизации, хорошо. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но вы все равно должны попробовать &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81bad2e8a0b6b2a52ce58ff5f5a60cc0c934ec2b" translate="yes" xml:space="preserve">
          <source>Both this examples too small to make any decisions about C++ vs Python speed. Because we just use some internal mechanism and compare it. So it is unfair to compare. But as we can see Python code match simpler to understand, but it makes inside some conversions (utf8 - decoding I think on Linux and Mac OS) and works on binary files too. C++ version failing to count '\n' on binary files (on Windows with g++ at least)</source>
          <target state="translated">Оба примера слишком малы,чтобы принимать решения о скорости C++и Python.Потому что мы просто используем какой-то внутренний механизм и сравниваем его.Поэтому сравнивать нечестно.Но,как мы видим,код на Python совпадает проще для понимания,но он делает внутри некоторые преобразования (utf8-декодирование,я думаю,на Linux и Mac OS)и работает и на бинарных файлах.Версия для C++не учитывает '\n' на бинарных файлах (как минимум на Windows с g++).</target>
        </trans-unit>
        <trans-unit id="6691e104c45825c979a28bdf47ad2d042db64162" translate="yes" xml:space="preserve">
          <source>But I say that last thing with some hesitation.  If we examine the last result in 'Edit 5' --</source>
          <target state="translated">Но я говорю это последняя вещь с некоторыми колебаниями.Если мы рассмотрим последний результат в &quot;Редакторе 5&quot;...</target>
        </trans-unit>
        <trans-unit id="c9d36be2de6f8d949f97fad3693ed38300429c46" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;cin&lt;/code&gt; is synchronized with stdio, which causes it to avoid any input buffering.  If you add this to the top of your main, you should see much better performance:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По умолчанию, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; синхронизируется со stdio, что позволяет избежать буферизации ввода. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы добавите это в начало вашего основного списка, вы увидите гораздо лучшую производительность:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5c92dd35743a41498513f0900ff9df8a2de766a2" translate="yes" xml:space="preserve">
          <source>By the way, the reason the line count for the C++ version is one greater than the count for the Python version is that the eof flag only gets set when an attempt is made to read beyond eof. So the correct loop would be:</source>
          <target state="translated">Кстати,причина,по которой счетчик строк в версии для C++на один больше,чем счетчик в версии для Python,заключается в том,что флаг eof устанавливается только при попытке чтения за пределами eof.Так что правильный цикл будет:</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="5d6cf463e19a68d2b9cb392046065a032a4d7137" translate="yes" xml:space="preserve">
          <source>For completeness, I thought I'd update the read speed for the same file on the same box with the original (synced) C++ code. Again, this is for a 100M line file on a fast disk. Here's the comparison, with several solutions/approaches:</source>
          <target state="translated">Для полноты,я решил обновить скорость чтения для того же файла на той же коробке с оригинальным (синхронизированным)C++кодом.Опять же,это для 100М строчного файла на быстром диске.Вот сравнение,с несколькими решениями:</target>
        </trans-unit>
        <trans-unit id="05f418b280d6d0669a3d45dd130b92d3ef333c5e" translate="yes" xml:space="preserve">
          <source>Fortunately, the library designers decided that you should also be able to disable this feature to get improved performance if you knew what you were doing, so they provided the &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio&quot;&gt;&lt;code&gt;sync_with_stdio&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;К счастью, разработчики библиотек решили, что вы также должны иметь возможность отключить эту функцию, чтобы повысить производительность, если знаете, что делаете, и поэтому предоставили &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;метод &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio&quot;&gt; &lt;code&gt;sync_with_stdio&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="a3ec40e608105bf527fa8797040dcb94f345155d" translate="yes" xml:space="preserve">
          <source>I reproduced the original result on my computer using g++ on a Mac.</source>
          <target state="translated">Я воспроизвел оригинальный результат на моем компьютере с помощью g++на Mac.</target>
        </trans-unit>
        <trans-unit id="57c10f7853150262360e29fdc0b93b16251f2f6f" translate="yes" xml:space="preserve">
          <source>I should add that there is at least one other significant difference between these styles of testing, and I can't say whether it is a benefit or fault; you have to decide this yourself:</source>
          <target state="translated">Добавлю,что между этими стилями тестирования есть,по крайней мере,еще одна существенная разница,и я не могу сказать,является ли это выгодой или ошибкой,вы должны решить это сами:</target>
        </trans-unit>
        <trans-unit id="749119915fb9bcc67a990d0ef5d5665be585983a" translate="yes" xml:space="preserve">
          <source>I want other C++ version of code. I do not want to copy every line by line. I just want count how many '\n' in file.</source>
          <target state="translated">Мне нужна другая версия кода на Си++.Я не хочу копировать каждую строку за строкой.Я просто хочу посчитать,сколько '\n' в файле.</target>
        </trans-unit>
        <trans-unit id="260f22261673c0af873bb219f7a8ae1b2b64b573" translate="yes" xml:space="preserve">
          <source>I wanted to compare reading lines of string input from stdin using Python and C++ and was shocked to see my C++ code run an order of magnitude slower than the equivalent Python code. Since my C++ is rusty and I'm not yet an expert Pythonista, please tell me if I'm doing something wrong or if I'm misunderstanding something.</source>
          <target state="translated">Я хотел сравнить чтение строк из stdin,использующих Python и C++,и был шокирован,увидев,что мой код на C++работает на порядок медленнее,чем эквивалентный код на Python.Так как мой C++ржавчина,а я ещё не эксперт по Pythonista,пожалуйста,скажите мне,если я что-то делаю не так или если я что-то не так понял.</target>
        </trans-unit>
        <trans-unit id="7b0e802507be3a79fd0dc0f920f90f6ffd330e60" translate="yes" xml:space="preserve">
          <source>I will mention two possible, but actually wrong, 'fixes' which could also be considered (but I 'number' them differently as these are not things which were wrong in the original post):</source>
          <target state="translated">Упомяну два возможных,но на самом деле неправильных &quot;исправления&quot;,которые также можно было бы рассмотреть (но я &quot;пронумеровываю&quot; их по-другому,так как это не те вещи,которые были неправильными в первоначальном сообщении):</target>
        </trans-unit>
        <trans-unit id="6396c98ecdd3cbb117338967b67fb60a0ce0e89a" translate="yes" xml:space="preserve">
          <source>I'm a few years behind here, but:</source>
          <target state="translated">Я отстаю на несколько лет,но..:</target>
        </trans-unit>
        <trans-unit id="a604ccbbcf387ae81f374f69dbb6f6d257435681" translate="yes" xml:space="preserve">
          <source>If more input was read by &lt;code&gt;cin&lt;/code&gt; than it actually needed, then the second integer value wouldn't be available for the &lt;code&gt;scanf&lt;/code&gt; function, which has its own independent buffer.  This would lead to unexpected results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; прочитал больше входных данных, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чем фактически требовалось, то второе целочисленное значение было бы недоступно для &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функции &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , которая имеет собственный независимый буфер. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это привело бы к неожиданным результатам.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d1103ccd841b2e817c9c4faecaf3bfaaa41295a" translate="yes" xml:space="preserve">
          <source>If you want, you can wrap a stream around that buffer for more convenient access like this:</source>
          <target state="translated">При желании вы можете обернуть поток вокруг этого буфера для более удобного доступа:</target>
        </trans-unit>
        <trans-unit id="de548edc3c54e3d20a32f157bdac636d41f75a1c" translate="yes" xml:space="preserve">
          <source>In 'Edit 4/5/6' of the original post, you are using the construction:</source>
          <target state="translated">В &quot;Edit 456&quot; оригинального поста вы используете конструкцию:</target>
        </trans-unit>
        <trans-unit id="b864261dceb4d9e0e5ccfbf23668633686af698a" translate="yes" xml:space="preserve">
          <source>In fact I did some quick tests with a 1.5 gigabyte file of garbage, on a Linux 3.13 (Ubuntu 14.04) system, obtaining these results (these are actually 'best of 3' results; after priming the cache, of course):</source>
          <target state="translated">На самом деле я сделал несколько быстрых тестов с 1.5 гигабайт мусорного файла,на Linux 3.13 (Ubuntu 14.04)системы,получив эти результаты (это на самом деле &quot;лучший из 3&quot; результаты;после заливки кэша,конечно):</target>
        </trans-unit>
        <trans-unit id="d82551d6ef616e947fe345dd7b25f64f5a81ba27" translate="yes" xml:space="preserve">
          <source>In this statement it is the &lt;em&gt;shell&lt;/em&gt; which opens big_file, passing it to your program (well, actually to `time` which then executes your program as a subprocess) as an already-open file descriptor.  100% of the file reading is strictly the responsibility of the program you're trying to benchmark.  This gets you a real reading of its performance without spurious complications.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этом утверждении это &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;оболочка,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; которая открывает big_file, передавая его вашей программе (ну, на самом деле, `time`, которая затем выполняет вашу программу как подпроцесс) как уже открытый файловый дескриптор. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ответственность за чтение файла лежит на программе, которую вы пытаетесь сравнить. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это дает вам реальное прочтение его производительности без ложных осложнений.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3088ea2a71bf4e76dfdc1e96ad3c885aa2d2135e" translate="yes" xml:space="preserve">
          <source>In your second example (with scanf()) reason why this is still slower might be because scanf(&quot;%s&quot;) parses string and looks for any space char (space, tab, newline).</source>
          <target state="translated">Во втором примере (с функцией scanf())причина,по которой это все еще медленнее,может быть в том,что scanf(&quot;%s&quot;)разбирает строку и ищет любой пробел-чар (пробел,табуляция,новая строка).</target>
        </trans-unit>
        <trans-unit id="4ca2dae7f1b194d92017c3cab32ec8bae84a031f" translate="yes" xml:space="preserve">
          <source>It beats all my Python attempts by more than a factor 2.</source>
          <target state="translated">Это бьет все мои попытки на Питоне более чем в 2 раза.</target>
        </trans-unit>
        <trans-unit id="b74fb04c360a35cd5637f86f5f8966f681595e25" translate="yes" xml:space="preserve">
          <source>Just out of curiosity I've taken a look at what happens under the hood, and I've used &lt;a href=&quot;http://en.wikipedia.org/wiki/Strace&quot;&gt;dtruss/strace&lt;/a&gt; on each test.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Просто из любопытства я взглянул на то, что происходит под капотом, и я использовал &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Strace&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;dtruss / strace&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в каждом тесте.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdaf58eab95a0b731758003f39034b18ca7a08f7" translate="yes" xml:space="preserve">
          <source>Normally, when an input stream is buffered, instead of reading one character at a time, the stream will be read in larger chunks.  This reduces the number of system calls, which are typically relatively expensive.  However, since the &lt;code&gt;FILE*&lt;/code&gt; based &lt;code&gt;stdio&lt;/code&gt; and &lt;code&gt;iostreams&lt;/code&gt; often have separate implementations and therefore separate buffers, this could lead to a problem if both were used together.  For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обычно, когда входной поток буферизуется, вместо чтения по одному символу за раз, поток будет читаться большими кусками. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это уменьшает количество системных вызовов, которые обычно относительно дороги. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако, поскольку &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;основанные &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;FILE*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;iostreams&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; часто имеют отдельные реализации и, следовательно, отдельные буферы, это может привести к проблеме, если оба будут использоваться вместе. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97fd295bbcf7715d2d1e8f86155c46f00aa5bcdb" translate="yes" xml:space="preserve">
          <source>Notice that the two pipeline results claim to have taken more CPU time (user+sys) than realtime.  This is because I'm using the shell (Bash)'s built-in 'time' command, which is cognizant of the pipeline; and I'm on a multi-core machine where separate processes in a pipeline can use separate cores, accumulating CPU time faster than realtime.  Using /usr/bin/time I see smaller CPU time than realtime -- showing that it can only time the single pipeline element passed to it on its command line.  Also, the shell's output gives milliseconds while /usr/bin/time only gives hundreths of a second.</source>
          <target state="translated">Обратите внимание,что результаты двух конвейеров утверждают,что потребовалось больше процессорного времени (пользователь+системы),чем в реальном времени.Это потому,что я использую встроенную команду оболочки (Bash)'time',которая знает о конвейере;и я нахожусь на многоядерной машине,где отдельные процессы в конвейере могут использовать отдельные ядра,накапливая процессорное время быстрее,чем в реальном времени.Используя usrbintime,я вижу меньшее процессорное время,чем в реальном времени --показывая,что он может только время отдельного элемента конвейера,переданного ему в командной строке.Кроме того,выход оболочки дает миллисекунды,в то время как usrbintime дает только сотые доли секунды.</target>
        </trans-unit>
        <trans-unit id="9b0c98872d79e9099677b6990de484ff7dbbe1de" translate="yes" xml:space="preserve">
          <source>Of course it is an interesting benchmark result if the same program performs significantly differently between the two cases.  It shows that, indeed, the program or its I/O libraries &lt;em&gt;are&lt;/em&gt; doing something interesting, like using mmap().  So in practice it might be good to run the benchmarks both ways; perhaps discounting the `cat` result by some small factor to &quot;forgive&quot; the cost of running `cat` itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конечно, это интересный результат теста, если одна и та же программа работает по-разному в двух случаях. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это показывает , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что, действительно, программа или его библиотеки ввода / вывода &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;будут&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; делать что - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то интересное, как с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;помощью ММАП (). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, на практике может быть полезно выполнить тесты в обоих направлениях; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;возможно, мы не будем учитывать результат `cat`, чтобы&quot; простить &quot;стоимость запуска самого` cat`.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="77fe33f271e30ea0be6216f64c174b1e2f493ad4" translate="yes" xml:space="preserve">
          <source>Python code I think we should change too</source>
          <target state="translated">Питоновый код.Думаю,нам тоже нужно изменить.</target>
        </trans-unit>
        <trans-unit id="8d6f668d23cdb06ece2ffec8fd41bcf15e77b630" translate="yes" xml:space="preserve">
          <source>So at the efficiency level of `wc -l`, the `cat` makes a huge difference: 409 / 283 = 1.453 or 45.3% more realtime, and 775 / 280 = 2.768, or a whopping 177% more CPU used!  On my random it-was-there-at-the-time test box.</source>
          <target state="translated">Так что на уровне эффективности `wc -l`,`кошка` делает огромную разницу:409 283=1.453 или 45.3% больше в режиме реального времени,а 775 280=2.768,или на 177% больше используемого процессора! На моем случайном это было-было-время тест-боксе.</target>
        </trans-unit>
        <trans-unit id="95b7b0ce50fd459cea21ab95da67ad7dc700d7da" translate="yes" xml:space="preserve">
          <source>Still, I predict you would be able to measure the difference between `cat file | wc -l` and `wc -l &amp;lt; file` and find a noticeable (2-digit percentage) difference.  Each of the slower tests will have paid a similar penalty in absolute time; which would however amount to a smaller fraction of its larger total time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тем не менее, я предсказываю, что вы сможете измерить разницу между `cat file | wc -l` и `wc -l &amp;lt;file` и найдите заметную (двухзначный процент) разницу. Каждый из более медленных тестов будет платить аналогичный штраф в абсолютном времени; что, однако, составило бы меньшую долю общего времени.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c0d59470dee317a0bd4e3ed90af701235f5ceec" translate="yes" xml:space="preserve">
          <source>TLDR results: scroll all the way down to the bottom of my question and look at the table.)</source>
          <target state="translated">Результаты TLDR:прокрутите до конца моего вопроса и посмотрите на таблицу).</target>
        </trans-unit>
        <trans-unit id="26036044bf09499b66ab681b2636b0886eb6e6cf" translate="yes" xml:space="preserve">
          <source>The following code was faster for me than the other code posted here so far:
(Visual Studio 2013, 64-bit, 500 MB file with line length uniformly in [0, 1000)).</source>
          <target state="translated">Следующий код был для меня быстрее,чем другой код,размещенный здесь до сих пор:(Visual Studio 2013,64-битный,500-мегабайтный файл с длиной строки равномерно в [0,1000]).</target>
        </trans-unit>
        <trans-unit id="d712bbe9542b29fb12a7ddae3053c86ac35d66ca" translate="yes" xml:space="preserve">
          <source>These are wrong for the same reasons as #2: they're still using `cat` unnecessarily.  I mention them for a few reasons:</source>
          <target state="translated">Они ошибаются по тем же причинам,что и #2:они все еще используют `кошку` без необходимости.Я упоминаю их по нескольким причинам:</target>
        </trans-unit>
        <trans-unit id="151f78cf3abe6db2af3d5bb863a668fb774d5c1e" translate="yes" xml:space="preserve">
          <source>This is wrong in a couple of different ways:</source>
          <target state="translated">Это неправильно в нескольких отношениях:</target>
        </trans-unit>
        <trans-unit id="31b18e50b32a9ad9d4e72e48e9d3d402a551f97a" translate="yes" xml:space="preserve">
          <source>Tiny benchmark addendum and recap</source>
          <target state="translated">Крошечное контрольное приложение и краткое изложение</target>
        </trans-unit>
        <trans-unit id="12f64344295facbd95f90ce066c817fa5fbcff18" translate="yes" xml:space="preserve">
          <source>To avoid this, by default, streams are synchronized with &lt;code&gt;stdio&lt;/code&gt;.  One common way to achieve this is to have &lt;code&gt;cin&lt;/code&gt; read each character one at a time as needed using &lt;code&gt;stdio&lt;/code&gt; functions.  Unfortunately, this introduces a lot of overhead.  For small amounts of input, this isn't a big problem, but when you are reading millions of lines, the performance penalty is significant.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы избежать этого, по умолчанию потоки синхронизируются с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Один из распространенных способов достижения этого - заставить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; читать каждый символ по одному, когда это необходимо, используя &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функции &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;К сожалению, это вносит много накладных расходов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для небольших объемов ввода это не большая проблема, но когда вы читаете миллионы строк, снижение производительности является значительным.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c4af42a2bc6a8140f782f723d293d5612c973776" translate="yes" xml:space="preserve">
          <source>Use of `cat` is unnecessary and in fact counterproductive; you're adding moving parts.  If you were on a sufficiently old system (i.e.  with a single CPU and -- in certain generations of computers -- I/O faster than CPU) -- the mere fact that `cat` was running could substantially color the results.  You are also subject to whatever input and output buffering and other processing `cat` may do.  (This would likely earn you a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat&quot;&gt;'Useless Use Of Cat'&lt;/a&gt; award if I were Randal Schwartz.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Использование `cat` является ненужным и фактически контрпродуктивным; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вы добавляете движущиеся части. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы работали в достаточно старой системе (то есть с одним ЦП и - в некоторых поколениях компьютеров - ввод-вывод быстрее, чем ЦП) - сам факт запуска `cat` может существенно повлиять на результаты. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы также подвергаетесь любой буферизации ввода и вывода и другой обработке, которую может выполнять `cat`. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Это, вероятно, принесло бы вам награду &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Бесполезное использование кошки&amp;raquo;,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; если бы я был Рэндал Шварц.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e687d0cf6ef10b35b782602f2bf1981f0e798157" translate="yes" xml:space="preserve">
          <source>Well, I see that in your second solution you switched from &lt;code&gt;cin&lt;/code&gt; to &lt;code&gt;scanf&lt;/code&gt;, which was the first suggestion I was going to make you (cin is sloooooooooooow). Now, if you switch from &lt;code&gt;scanf&lt;/code&gt; to &lt;code&gt;fgets&lt;/code&gt;, you would see another boost in performance: &lt;code&gt;fgets&lt;/code&gt; is the fastest C++ function for string input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ну, я вижу, что в вашем втором решении вы переключились с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что было первым предложением, которое я собирался сделать вам (cin - sloooooooooooow). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь, если вы переключитесь с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , вы увидите еще одно повышение производительности: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - самая быстрая функция C ++ для строкового ввода.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be8c0ffa13d1b9e5e48623ed2ff2306f02135d47" translate="yes" xml:space="preserve">
          <source>When you run `/usr/bin/time my_program &amp;lt; big_file`, your program receives an open file descriptor to the actual file.  Your program -- &lt;em&gt;or&lt;/em&gt; in many cases the I/O libraries of the language in which it was written -- may take different actions when presented with a file descriptor referencing a regular file.  It may use mmap(2) to map the input file into its address space, instead of using explicit read(2) system calls.  These differences could have a far larger effect on your benchmark results than the small cost of running the `cat` binary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда вы запускаете `/ usr / bin / time my_program &amp;lt;big_file`, ваша программа получает дескриптор открытого файла к реальному файлу. Ваша программа - &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;или&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; во многих случаях библиотеки ввода / вывода того языка, на котором она была написана, - может выполнять различные действия при представлении файлового дескриптора, ссылающегося на обычный файл. Он может использовать mmap (2) для отображения входного файла в его адресное пространство вместо использования явных системных вызовов read (2). Эти различия могут оказать гораздо большее влияние на результаты тестов, чем небольшая стоимость запуска двоичного файла `cat`.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae6b11f7e1ce91c9e5497a2e4ac72a06aff02413" translate="yes" xml:space="preserve">
          <source>When you run `cat big_file | /usr/bin/time my_program`, your program is receiving input from a pipe, at precisely the pace sent by `cat`, and in chunks no larger than written by `cat`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99419ef0ccd4c72c0b4ec5ca34d06199b16630c5" translate="yes" xml:space="preserve">
          <source>Why is reading lines from stdin much slower in C++ than Python</source>
          <target state="translated">Почему чтение строк из stdin намного медленнее на C++,чем на Python.</target>
        </trans-unit>
        <trans-unit id="3de13424399dc6cf24b91661d84eaa2b31863a3b" translate="yes" xml:space="preserve">
          <source>You're actually timing the execution of `cat`, not your benchmark.  The 'user' and 'sys' CPU usage displayed by `time` are those of `cat`, not your benchmarked program.  Even worse, the 'real' time is also not necessarily accurate.  Depending on the implementation of `cat` and of pipelines in your local OS, it is possible that `cat` writes a final giant buffer and exits long before the reader process finishes its work.</source>
          <target state="translated">Ты на самом деле выбираешь время для исполнения &quot;Кошки&quot;,а не своего эталона.Использование процессора &quot;user&quot; и &quot;sys&quot;,отображаемое `время`,является использованием `cat`,а не Вашей эталонной программы.Хуже того,&quot;реальное&quot; время также не обязательно точное.В зависимости от реализации `cat` и конвейеров в Вашей локальной ОС,возможно,что `cat` записывает конечный гигантский буфер и выходит задолго до того,как процесс чтения завершит свою работу.</target>
        </trans-unit>
        <trans-unit id="1e72498d28b08e47ce5ad19ced93a61314488cd0" translate="yes" xml:space="preserve">
          <source>actually python is implemented in c/c++ so it works because of a compiled language but its implementation algorithm makes things faster otherwise compiled code works faster than interpreted code.</source>
          <target state="translated">На самом деле питон реализован в cc++,поэтому он работает благодаря скомпилированному языку,но алгоритм его реализации делает вещи быстрее,в противном случае скомпилированный код работает быстрее,чем интерпретированный.</target>
        </trans-unit>
        <trans-unit id="0d927068d028fb0490208928ec2279c4ca6dbd74" translate="yes" xml:space="preserve">
          <source>normally &lt;code&gt;cin&lt;/code&gt;,&lt;code&gt;scanf&lt;/code&gt;,&lt;code&gt;File&lt;/code&gt; etc avoid input buffering and streams can handle huge amount of data,they uses different streams and  the does not providing major features of python because python itself running on python virtual machine if you type one python code which is equal to many lines of compiled code.python provides features such as &lt;strong&gt;cache  acceleration&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обычно &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;File&lt;/code&gt; и&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; т. д. избегают буферизации ввода, и потоки могут обрабатывать огромное количество данных, они используют разные потоки и не предоставляют основных возможностей python, потому что сам python работает на виртуальной машине python, если вы вводите один код python, который равен много строк скомпилированного кода. Python предоставляет такие функции, как &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ускорение кэша&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b9992e6edfd2287cdda8287f4cce7c746b5b04a" translate="yes" xml:space="preserve">
          <source>sync_with_stdio improved speed to 2 seconds, and setting a larger buffer brought it down to 1 second.</source>
          <target state="translated">sync_with_stdio увеличила скорость до 2 секунд,а установка большего буфера снизила ее до 1 секунды.</target>
        </trans-unit>
        <trans-unit id="ab4f047c061b9c6bc642d54e86839a4e271cbb98" translate="yes" xml:space="preserve">
          <source>syscalls &lt;code&gt;sudo dtruss -c ./a.out &amp;lt; in&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;системные &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sudo dtruss -c ./a.out &amp;lt; in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4eeab4329aae3cae684e7c63ff686f21708cc5f2" translate="yes" xml:space="preserve">
          <source>syscalls &lt;code&gt;sudo dtruss -c ./a.py &amp;lt; in&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;системные &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sudo dtruss -c ./a.py &amp;lt; in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7dedc85579d9d10898c2fbc7e3119a830b23dc8" translate="yes" xml:space="preserve">
          <source>there may be cases where `cat` &lt;em&gt;is&lt;/em&gt; needed (e.g.: the file to be read requires some sort of privilege to access, and you do not want to grant that privilege to the program to be benchmarked: `sudo cat /dev/sda | /usr/bin/time my_compression_test --no-output`)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;могут быть случаи , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;когда `cat` &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;это&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; нужно (например: файл для чтения требует какой - &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;то привилегии доступа, и вы не хотите , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чтобы предоставить эту привилегию программы , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;которая будет протестированные:` Судо кошка / DEV / SDA | / usr / bin / time my_compression_test --no-output`)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29470267bc79b4c90ccd78d52ec8d78a07736aad" translate="yes" xml:space="preserve">
          <source>they're more 'natural' for people who aren't entirely comfortable with the I/O redirection facilities of the POSIX shell</source>
          <target state="translated">они более &quot;естественны&quot; для людей,которым не совсем удобны средства перенаправления ввода-вывода в оболочке POSIX.</target>
        </trans-unit>
        <trans-unit id="c9006eab9fd1508da2bd2f79d9c89c2cb0f714a1" translate="yes" xml:space="preserve">
          <source>would have taken only the remaining .49 seconds!  Probably not: `cat` here had to pay for the read() system calls (or equivalent) which transferred the file from 'disk' (actually buffer cache), as well as the pipe writes to deliver them to `wc`.  The correct test would still have had to do those read() calls; only the write-to-pipe and read-from-pipe calls would have been saved, and those should be pretty cheap.</source>
          <target state="translated">заняло бы только оставшиеся 49 секунд! Наверное,нет:`cat` здесь должен был заплатить за системные вызовы read()(или эквивалент),которые передавали файл с 'диска' (на самом деле буферного кэша),а также трубы записывали,чтобы доставить их в `wc`.Правильный тест все равно должен был бы делать эти вызовы read();только вызовы writee-to-pipe и read-from-pipe были бы сохранены,и они должны были бы быть довольно дешевыми.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
