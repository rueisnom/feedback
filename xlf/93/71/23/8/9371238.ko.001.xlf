<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/9371238">
    <body>
      <group id="9371238">
        <trans-unit id="2ada74fe85580bed0602d49b3709fcf15dcf240b" translate="yes" xml:space="preserve">
          <source>(TLDR answer: include the statement: &lt;code&gt;cin.sync_with_stdio(false)&lt;/code&gt; or just use &lt;code&gt;fgets&lt;/code&gt; instead.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(TLDR 답변 : &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin.sync_with_stdio(false)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 문을 포함 시키 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;거나 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대신 사용하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5604413a183cbc7d7544d68c94a6c7382ae5d413" translate="yes" xml:space="preserve">
          <source>-- this claims that `cat` consumed 74% of the CPU during the test; and indeed 1.34/1.83 is approximately 74%.  Perhaps a run of:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-이것은 고양이가 테스트하는 동안 CPU의 74 %를 소비했다고 주장합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 1.34 / 1.83은 대략 74 %입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아마도 다음과 같은 일이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1348609af914ffea58e6f9f0adbfd5fc589de6d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline&lt;/code&gt;, stream operators, &lt;code&gt;scanf&lt;/code&gt;, can be convenient if you don't care about file loading time or if you are loading small text files. But, if the performance is something you care about, you should really just buffer the entire file into memory (assuming it will fit).</source>
          <target state="translated">&lt;code&gt;getline&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파일 로딩 시간에 신경 쓰지 않거나 작은 텍스트 파일을로드하는 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;getline&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 스트림 연산자 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 편리 할 수 ​​있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 성능이 마음에 든다면 실제로 전체 파일을 메모리에 버퍼링해야합니다 (적합하다고 가정).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c0915bf7a2ae1a20a3dd3d752c1dede09758b45d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I should note that I tried this both under Mac&amp;nbsp;OS&amp;nbsp;X&amp;nbsp;v10.6.8 (Snow&amp;nbsp;Leopard) and Linux 2.6.32 (Red Hat Linux 6.2). The former is a MacBook Pro, and the latter is a very beefy server, not that this is too pertinent.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mac OS X v10.6.8 (Snow Leopard) 및 Linux 2.6.32 (Red Hat Linux 6.2)에서이 작업을 시도했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전자는 MacBook Pro이고 후자는 매우 강력한 서버이며 이것이 너무 적합하지는 않습니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8119e8521189e9d54129bd0197536b2d962ff8bc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in practice&lt;/em&gt;, on modern machines, the added `cat` in the pipeline is probably of no real consequence</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 현대 기계에서는 파이프 라인에 추가 된 '고양이'는 실제로 아무런 영향을 미치지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f625673762999b841e0b14d2b37dd1775f5d0bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 코드 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e4899c39940c2a22b2171aa7540343dadef7018" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Here are my results:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 결과는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d886917c5612dc7850a74f654f3ffa7d073dde44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python Equivalent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파이썬 동등 물 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7ba7ad03822a6b3e0d1b23058b1f808ac10d2d6" translate="yes" xml:space="preserve">
          <source>A better construction would be:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 나은 구성은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c484caf9d550a5b7b43988b6fc5cbdf31ee5cee" translate="yes" xml:space="preserve">
          <source>A first element of an answer: &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; is slow. Damn slow. I get a huge performance boost with &lt;code&gt;scanf&lt;/code&gt; as in the below, but it is still two times slower than Python.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대답의 첫 번째 요소 인 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 느립니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;천천히 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래 에서처럼 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;성능이 크게 향상 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;되었지만 여전히 파이썬보다 두 배 느립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d606b8781f8d9cc1eb582fbcf3c012f3e5267c6" translate="yes" xml:space="preserve">
          <source>A. You could 'fix' this by timing only your program:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A. 프로그램의 타이밍 만 지정하여이를 '수정'할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6eacef433fa97c076753f8181b901c1df86fb0ee" translate="yes" xml:space="preserve">
          <source>Adding the following statements to the C++ version just before the &lt;code&gt;while&lt;/code&gt; loop brings it inline with the &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; version:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;while&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 루프 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;바로 전에 C ++ 버전에 다음 명령문을 추가하면 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Python&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 버전 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;과 인라인됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa80c19e93d9b42ed6f60bba12683b734e770328" translate="yes" xml:space="preserve">
          <source>Also, if you are in control of the file, consider using a flat binary data format instead of text. It's more reliable to read and write because you don't have to deal with all the ambiguities of whitespace. It's also smaller and much faster to parse.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 파일을 제어하는 ​​경우 텍스트 대신 플랫 이진 데이터 형식을 사용하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공백의 모든 모호성을 처리 할 필요가 없기 때문에 읽고 쓰는 것이 더 안정적입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 작고 구문 분석이 훨씬 빠릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d24cad29120afe707f62c6f3085b2a58c008227b" translate="yes" xml:space="preserve">
          <source>Also, yes, CPython does some caching to avoid harddisk reads.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 CPython은 하드 디스크 읽기를 피하기 위해 일부 캐싱을 수행합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="919616b80f9630eba97648eca9e6cc0700de45cc" translate="yes" xml:space="preserve">
          <source>B. or by timing the entire pipeline:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B. 또는 전체 파이프 라인 타이밍 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5a9c426254eccca83c581dce40a33f86fc34cf9" translate="yes" xml:space="preserve">
          <source>BTW, didn't know about that sync thing, nice. But you should still try &lt;code&gt;fgets&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BTW, 그 동기화에 대해 몰랐어요. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 여전히 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 시도해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81bad2e8a0b6b2a52ce58ff5f5a60cc0c934ec2b" translate="yes" xml:space="preserve">
          <source>Both this examples too small to make any decisions about C++ vs Python speed. Because we just use some internal mechanism and compare it. So it is unfair to compare. But as we can see Python code match simpler to understand, but it makes inside some conversions (utf8 - decoding I think on Linux and Mac OS) and works on binary files too. C++ version failing to count '\n' on binary files (on Windows with g++ at least)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 예제는 너무 작아서 C ++ 대 Python 속도에 대한 결정을 내릴 수 없습니다. 내부 메커니즘을 사용하고 비교하기 때문입니다. 따라서 비교하기에는 불공평합니다. 그러나 파이썬 코드가 이해하기 더 단순하다는 것을 알 수 있지만, 일부 변환 (utf8-Linux 및 Mac OS에서 생각하는 디코딩) 내부에서 바이너리 파일에서도 작동합니다. 이진 파일에서 '\ n'을 계산하지 못하는 C ++ 버전 (최소한 g ++가있는 Windows)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6691e104c45825c979a28bdf47ad2d042db64162" translate="yes" xml:space="preserve">
          <source>But I say that last thing with some hesitation.  If we examine the last result in 'Edit 5' --</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 나는 주저하면서 마지막으로 말합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;'Edit 5'의 마지막 결과를 살펴보면-&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9d36be2de6f8d949f97fad3693ed38300429c46" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;cin&lt;/code&gt; is synchronized with stdio, which causes it to avoid any input buffering.  If you add this to the top of your main, you should see much better performance:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 stdio와 동기화되므로 입력 버퍼링을 피할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것을 메인 상단에 추가하면 성능이 훨씬 향상됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5c92dd35743a41498513f0900ff9df8a2de766a2" translate="yes" xml:space="preserve">
          <source>By the way, the reason the line count for the C++ version is one greater than the count for the Python version is that the eof flag only gets set when an attempt is made to read beyond eof. So the correct loop would be:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런데 C ++ 버전의 행 수가 Python 버전의 수보다 큰 이유는 eof를 넘어서 읽으려고 할 때 eof 플래그가 설정되기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;올바른 루프는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="5d6cf463e19a68d2b9cb392046065a032a4d7137" translate="yes" xml:space="preserve">
          <source>For completeness, I thought I'd update the read speed for the same file on the same box with the original (synced) C++ code. Again, this is for a 100M line file on a fast disk. Here's the comparison, with several solutions/approaches:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완벽을 기하기 위해 동일한 상자의 동일한 파일에 대한 읽기 속도를 원래의 (동기화 된) C ++ 코드로 업데이트한다고 생각했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다시 한 번, 이것은 빠른 디스크의 100M 라인 파일 용입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 몇 가지 솔루션 / 접근 방식을 사용한 비교입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="05f418b280d6d0669a3d45dd130b92d3ef333c5e" translate="yes" xml:space="preserve">
          <source>Fortunately, the library designers decided that you should also be able to disable this feature to get improved performance if you knew what you were doing, so they provided the &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio&quot;&gt;&lt;code&gt;sync_with_stdio&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다행히도 라이브러리 디자이너는 수행중인 작업을 알고있는 경우 성능을 향상시키기 위해이 기능을 비활성화 할 수 있어야하므로 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio&quot;&gt; &lt;code&gt;sync_with_stdio&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 메소드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 제공했습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3ec40e608105bf527fa8797040dcb94f345155d" translate="yes" xml:space="preserve">
          <source>I reproduced the original result on my computer using g++ on a Mac.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mac에서 g ++를 사용하여 컴퓨터에서 원래 결과를 재현했습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="57c10f7853150262360e29fdc0b93b16251f2f6f" translate="yes" xml:space="preserve">
          <source>I should add that there is at least one other significant difference between these styles of testing, and I can't say whether it is a benefit or fault; you have to decide this yourself:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 테스트 스타일 간에는 적어도 하나의 다른 중요한 차이점이 있으며 이것이 이점인지 결함인지 말할 수 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것을 스스로 결정해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="749119915fb9bcc67a990d0ef5d5665be585983a" translate="yes" xml:space="preserve">
          <source>I want other C++ version of code. I do not want to copy every line by line. I just want count how many '\n' in file.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 C ++ 버전의 코드를 원합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 줄을 한 줄씩 복사하고 싶지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파일의 '\ n'수를 세고 싶습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="260f22261673c0af873bb219f7a8ae1b2b64b573" translate="yes" xml:space="preserve">
          <source>I wanted to compare reading lines of string input from stdin using Python and C++ and was shocked to see my C++ code run an order of magnitude slower than the equivalent Python code. Since my C++ is rusty and I'm not yet an expert Pythonista, please tell me if I'm doing something wrong or if I'm misunderstanding something.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파이썬과 C ++을 사용하여 stdin에서 문자열 입력 행을 읽는 것을 비교하고 싶었고 C ++ 코드가 동등한 파이썬 코드보다 느린 속도로 실행되는 것을보고 충격을 받았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 C ++이 녹슨 상태이고 아직 전문가 Pythonista가 아니기 때문에 내가 잘못하고 있거나 잘못 이해하고 있는지 알려주십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7b0e802507be3a79fd0dc0f920f90f6ffd330e60" translate="yes" xml:space="preserve">
          <source>I will mention two possible, but actually wrong, 'fixes' which could also be considered (but I 'number' them differently as these are not things which were wrong in the original post):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 두 가지 가능성이 있지만 실제로 잘못된 '수정'도 언급 할 수 있다고 언급 할 것입니다 (그러나 원래 게시물에서 잘못된 것이 아니기 때문에 다르게 번호를 매 깁니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6396c98ecdd3cbb117338967b67fb60a0ce0e89a" translate="yes" xml:space="preserve">
          <source>I'm a few years behind here, but:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 몇 년 뒤에 있지만&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a604ccbbcf387ae81f374f69dbb6f6d257435681" translate="yes" xml:space="preserve">
          <source>If more input was read by &lt;code&gt;cin&lt;/code&gt; than it actually needed, then the second integer value wouldn't be available for the &lt;code&gt;scanf&lt;/code&gt; function, which has its own independent buffer.  This would lead to unexpected results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 실제로 필요한 것보다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;많은 입력을 읽은 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자체 독립 버퍼가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 함수에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 번째 정수 값을 사용할 수 없습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예기치 않은 결과가 발생할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d1103ccd841b2e817c9c4faecaf3bfaaa41295a" translate="yes" xml:space="preserve">
          <source>If you want, you can wrap a stream around that buffer for more convenient access like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원하는 경우 다음과 같이보다 편리한 액세스를 위해 해당 버퍼 주위에 스트림을 랩핑 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="de548edc3c54e3d20a32f157bdac636d41f75a1c" translate="yes" xml:space="preserve">
          <source>In 'Edit 4/5/6' of the original post, you are using the construction:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;원본 게시물의 '편집 4/5/6'에서 구성을 사용하고 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b864261dceb4d9e0e5ccfbf23668633686af698a" translate="yes" xml:space="preserve">
          <source>In fact I did some quick tests with a 1.5 gigabyte file of garbage, on a Linux 3.13 (Ubuntu 14.04) system, obtaining these results (these are actually 'best of 3' results; after priming the cache, of course):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 나는 Linux 3.13 (Ubuntu 14.04) 시스템에서 1.5 기가 바이트 가비지 파일로 몇 가지 빠른 테스트를 수행하여 이러한 결과를 얻었습니다 (물론 캐시를 프라이밍 한 후 실제로 '최고 3 결과'입니다).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d82551d6ef616e947fe345dd7b25f64f5a81ba27" translate="yes" xml:space="preserve">
          <source>In this statement it is the &lt;em&gt;shell&lt;/em&gt; which opens big_file, passing it to your program (well, actually to `time` which then executes your program as a subprocess) as an already-open file descriptor.  100% of the file reading is strictly the responsibility of the program you're trying to benchmark.  This gets you a real reading of its performance without spurious complications.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 성명에서 그것은이다 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;쉘&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이미 열린 파일 기술자로 (실제로 다음 서브 프로세스로 프로그램을 실행 time``로 잘) 프로그램에 전달, big_file 열립니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파일 읽기의 100 %는 벤치마킹하려는 프로그램의 책임입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 가짜 합병증없이 성능을 실제로 읽습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3088ea2a71bf4e76dfdc1e96ad3c885aa2d2135e" translate="yes" xml:space="preserve">
          <source>In your second example (with scanf()) reason why this is still slower might be because scanf(&quot;%s&quot;) parses string and looks for any space char (space, tab, newline).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 번째 예 (scanf () 사용)에서이 속도가 여전히 느린 이유는 scanf ( &quot;% s&quot;)가 문자열을 구문 분석하고 공백 문자 (공백, 탭, 줄 바꾸기)를 찾기 때문일 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ca2dae7f1b194d92017c3cab32ec8bae84a031f" translate="yes" xml:space="preserve">
          <source>It beats all my Python attempts by more than a factor 2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 모든 파이썬 시도보다 2 배 이상 뛰어납니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b74fb04c360a35cd5637f86f5f8966f681595e25" translate="yes" xml:space="preserve">
          <source>Just out of curiosity I've taken a look at what happens under the hood, and I've used &lt;a href=&quot;http://en.wikipedia.org/wiki/Strace&quot;&gt;dtruss/strace&lt;/a&gt; on each test.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;호기심 때문에 후드에서 어떤 일이 일어나는지 살펴 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Strace&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보았고&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 각 테스트에서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;dtruss / strace&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;했습니다&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdaf58eab95a0b731758003f39034b18ca7a08f7" translate="yes" xml:space="preserve">
          <source>Normally, when an input stream is buffered, instead of reading one character at a time, the stream will be read in larger chunks.  This reduces the number of system calls, which are typically relatively expensive.  However, since the &lt;code&gt;FILE*&lt;/code&gt; based &lt;code&gt;stdio&lt;/code&gt; and &lt;code&gt;iostreams&lt;/code&gt; often have separate implementations and therefore separate buffers, this could lead to a problem if both were used together.  For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 입력 스트림이 버퍼링되면 한 번에 하나의 문자를 읽는 대신 스트림이 더 큰 청크로 읽 힙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 일반적으로 비교적 비싼 시스템 호출 수를 줄입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;FILE*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기반 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;iostreams&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 종종 별도의 구현 및 따라서 별도의 버퍼를 가지므로 둘 다 함께 사용하면 문제가 발생할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들면 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97fd295bbcf7715d2d1e8f86155c46f00aa5bcdb" translate="yes" xml:space="preserve">
          <source>Notice that the two pipeline results claim to have taken more CPU time (user+sys) than realtime.  This is because I'm using the shell (Bash)'s built-in 'time' command, which is cognizant of the pipeline; and I'm on a multi-core machine where separate processes in a pipeline can use separate cores, accumulating CPU time faster than realtime.  Using /usr/bin/time I see smaller CPU time than realtime -- showing that it can only time the single pipeline element passed to it on its command line.  Also, the shell's output gives milliseconds while /usr/bin/time only gives hundreths of a second.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;두 파이프 라인 결과는 실시간보다 CPU 시간 (사용자 + 시스템)이 더 오래 걸린다고 주장합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파이프 라인을 인식하는 셸 (Bash)의 내장 '시간'명령을 사용하고 있기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 파이프 라인의 개별 프로세스가 별도의 코어를 사용하여 CPU 시간을 실시간보다 빠르게 누적 할 수있는 멀티 코어 머신을 사용하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;/ usr / bin / time을 사용하면 실시간보다 CPU 시간이 짧아 단일 파이프 라인 요소가 명령 줄에서 전달 된 시간 만 표시 할 수 있음을 보여줍니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한, 쉘의 출력은 밀리 초를 제공하고 / usr / bin / time은 단지 1 초를 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b0c98872d79e9099677b6990de484ff7dbbe1de" translate="yes" xml:space="preserve">
          <source>Of course it is an interesting benchmark result if the same program performs significantly differently between the two cases.  It shows that, indeed, the program or its I/O libraries &lt;em&gt;are&lt;/em&gt; doing something interesting, like using mmap().  So in practice it might be good to run the benchmarks both ways; perhaps discounting the `cat` result by some small factor to &quot;forgive&quot; the cost of running `cat` itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론 두 프로그램간에 동일한 프로그램이 크게 다른 성능을 발휘한다면 흥미로운 벤치 마크 결과입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 프로그램 또는 I / O 라이브러리 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; mmap () 사용과 같은 흥미로운 작업을 수행하고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있음을 보여줍니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 벤치 마크를 두 가지 방법으로 실행하는 것이 좋습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;'고양이'자체를 운영하는 비용을 &quot;용서&quot;하기 위해 작은 요소로 '고양이'결과를 할인 할 수도있다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="77fe33f271e30ea0be6216f64c174b1e2f493ad4" translate="yes" xml:space="preserve">
          <source>Python code I think we should change too</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파이썬 코드 우리도 바꿔야한다고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d6f668d23cdb06ece2ffec8fd41bcf15e77b630" translate="yes" xml:space="preserve">
          <source>So at the efficiency level of `wc -l`, the `cat` makes a huge difference: 409 / 283 = 1.453 or 45.3% more realtime, and 775 / 280 = 2.768, or a whopping 177% more CPU used!  On my random it-was-there-at-the-time test box.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서`wc -l`의 효율 수준에서`cat`은 409/283 = 1.453 또는 45.3 % 더 많은 실시간과 775/2280 = 2.768 또는 엄청나게 많은 177 % 더 많은 CPU를 사용합니다! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내 무작위로 그것은 당시 테스트 상자였습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="95b7b0ce50fd459cea21ab95da67ad7dc700d7da" translate="yes" xml:space="preserve">
          <source>Still, I predict you would be able to measure the difference between `cat file | wc -l` and `wc -l &amp;lt; file` and find a noticeable (2-digit percentage) difference.  Each of the slower tests will have paid a similar penalty in absolute time; which would however amount to a smaller fraction of its larger total time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아직도, 나는 당신이`cat file | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;wc -l` 및`wc -l &amp;lt;파일`로 눈에 띄는 (2 자리 백분율) 차이를 찾으십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각각의 느린 테스트는 절대 시간에 비슷한 페널티를 받았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 전체 시간의 작은 부분에 해당합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c0d59470dee317a0bd4e3ed90af701235f5ceec" translate="yes" xml:space="preserve">
          <source>TLDR results: scroll all the way down to the bottom of my question and look at the table.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TLDR 결과 : 내 질문의 맨 아래로 스크롤하여 표를보십시오.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26036044bf09499b66ab681b2636b0886eb6e6cf" translate="yes" xml:space="preserve">
          <source>The following code was faster for me than the other code posted here so far:
(Visual Studio 2013, 64-bit, 500 MB file with line length uniformly in [0, 1000)).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 코드는 지금까지 게시 된 다른 코드보다 더 빠릅니다. ([0, 1000)에서 균일하게 줄 길이를 가진 Visual Studio 2013, 64 비트, 500MB 파일).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d712bbe9542b29fb12a7ddae3053c86ac35d66ca" translate="yes" xml:space="preserve">
          <source>These are wrong for the same reasons as #2: they're still using `cat` unnecessarily.  I mention them for a few reasons:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것들은 # 2와 같은 이유로 잘못되었습니다 : 그들은 여전히`cat`을 불필요하게 사용하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;몇 가지 이유로 언급합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="151f78cf3abe6db2af3d5bb863a668fb774d5c1e" translate="yes" xml:space="preserve">
          <source>This is wrong in a couple of different ways:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 몇 가지 다른 방식으로 잘못되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="31b18e50b32a9ad9d4e72e48e9d3d402a551f97a" translate="yes" xml:space="preserve">
          <source>Tiny benchmark addendum and recap</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;초소형 벤치 마크 부록 및 요약&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="12f64344295facbd95f90ce066c817fa5fbcff18" translate="yes" xml:space="preserve">
          <source>To avoid this, by default, streams are synchronized with &lt;code&gt;stdio&lt;/code&gt;.  One common way to achieve this is to have &lt;code&gt;cin&lt;/code&gt; read each character one at a time as needed using &lt;code&gt;stdio&lt;/code&gt; functions.  Unfortunately, this introduces a lot of overhead.  For small amounts of input, this isn't a big problem, but when you are reading millions of lines, the performance penalty is significant.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 피하기 위해 기본적으로 스트림은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 동기화됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 달성하기위한 한 가지 일반적인 방법은 것입니다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사용하여 필요에 따라 한 번에 각 문자를 읽을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기능을. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;불행히도 이로 인해 많은 오버 헤드가 발생합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;적은 양의 입력의 경우 큰 문제는 아니지만 수백만 줄을 읽을 때는 성능이 저하됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c4af42a2bc6a8140f782f723d293d5612c973776" translate="yes" xml:space="preserve">
          <source>Use of `cat` is unnecessary and in fact counterproductive; you're adding moving parts.  If you were on a sufficiently old system (i.e.  with a single CPU and -- in certain generations of computers -- I/O faster than CPU) -- the mere fact that `cat` was running could substantially color the results.  You are also subject to whatever input and output buffering and other processing `cat` may do.  (This would likely earn you a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat&quot;&gt;'Useless Use Of Cat'&lt;/a&gt; award if I were Randal Schwartz.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;'고양이'의 사용은 불필요하며 실제로 역효과를 낳습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;움직이는 부분을 추가하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;충분히 오래된 시스템 (예 : 단일 CPU를 사용하고 특정 세대 컴퓨터에서는 CPU보다 I / O가 더 빠름)을 사용하는 경우 'cat'이 실행되고 있다는 사실만으로도 결과가 실제로 색상으로 표시 될 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 입력 및 출력 버퍼링 및 기타 처리 'cat'에 따라 달라질 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;랜들 슈왈츠 (Randal Schwartz) 였다면 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;'&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이것은 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;고양이의 쓸모없는 사용'&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 상을 받게 될 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e687d0cf6ef10b35b782602f2bf1981f0e798157" translate="yes" xml:space="preserve">
          <source>Well, I see that in your second solution you switched from &lt;code&gt;cin&lt;/code&gt; to &lt;code&gt;scanf&lt;/code&gt;, which was the first suggestion I was going to make you (cin is sloooooooooooow). Now, if you switch from &lt;code&gt;scanf&lt;/code&gt; to &lt;code&gt;fgets&lt;/code&gt;, you would see another boost in performance: &lt;code&gt;fgets&lt;/code&gt; is the fastest C++ function for string input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;글쎄, 나는 당신의 두 번째 솔루션에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 전환 한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;것을 보았습니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; 로&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 전환 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면 성능이 다시 향상됩니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 문자열 입력을위한 가장 빠른 C ++ 함수입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be8c0ffa13d1b9e5e48623ed2ff2306f02135d47" translate="yes" xml:space="preserve">
          <source>When you run `/usr/bin/time my_program &amp;lt; big_file`, your program receives an open file descriptor to the actual file.  Your program -- &lt;em&gt;or&lt;/em&gt; in many cases the I/O libraries of the language in which it was written -- may take different actions when presented with a file descriptor referencing a regular file.  It may use mmap(2) to map the input file into its address space, instead of using explicit read(2) system calls.  These differences could have a far larger effect on your benchmark results than the small cost of running the `cat` binary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;`/ usr / bin / time my_program &amp;lt;big_file`을 실행하면 프로그램은 실제 파일에 열린 파일 디스크립터를받습니다. 프로그램 ( &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대부분의 경우 작성된 ​​언어의 I / O 라이브러리)은 일반 파일을 참조하는 파일 디스크립터가 표시 될 때 다른 조치를 취할 수 있습니다. 명시적인 read (2) 시스템 호출을 사용하는 대신 mmap (2)를 사용하여 입력 파일을 해당 주소 공간에 매핑 할 수 있습니다. 이러한 차이는 'cat'바이너리를 실행하는 적은 비용보다 벤치 마크 결과에 훨씬 큰 영향을 줄 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae6b11f7e1ce91c9e5497a2e4ac72a06aff02413" translate="yes" xml:space="preserve">
          <source>When you run `cat big_file | /usr/bin/time my_program`, your program is receiving input from a pipe, at precisely the pace sent by `cat`, and in chunks no larger than written by `cat`.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;`cat big_file | &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;/ usr / bin / time my_program`, 당신의 프로그램은 파이프로부터 입력을 받고 있습니다. 정확하게`cat`에 의해 전송 된 속도로,`cat`에 의해 쓰여진 것보다 크지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="99419ef0ccd4c72c0b4ec5ca34d06199b16630c5" translate="yes" xml:space="preserve">
          <source>Why is reading lines from stdin much slower in C++ than Python</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++에서 stdin에서 행을 읽는 것이 파이썬보다 속도가 느린 이유&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3de13424399dc6cf24b91661d84eaa2b31863a3b" translate="yes" xml:space="preserve">
          <source>You're actually timing the execution of `cat`, not your benchmark.  The 'user' and 'sys' CPU usage displayed by `time` are those of `cat`, not your benchmarked program.  Even worse, the 'real' time is also not necessarily accurate.  Depending on the implementation of `cat` and of pipelines in your local OS, it is possible that `cat` writes a final giant buffer and exits long before the reader process finishes its work.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 벤치 마크가 아닌`cat`의 실행 타이밍을 정하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;`time`에 표시된 'user'및 'sys'CPU 사용량은 벤치마킹 된 프로그램이 아니라`cat`의 사용량입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 나쁜 것은 '실시간'도 반드시 정확하지는 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;`cat` 및 로컬 OS의 파이프 라인 구현에 따라`cat`는 최종 거대한 버퍼를 작성하고 리더 프로세스가 작업을 마치기 오래 전에 종료 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1e72498d28b08e47ce5ad19ced93a61314488cd0" translate="yes" xml:space="preserve">
          <source>actually python is implemented in c/c++ so it works because of a compiled language but its implementation algorithm makes things faster otherwise compiled code works faster than interpreted code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 파이썬은 c / c ++로 구현되므로 컴파일 된 언어로 인해 작동하지만 구현 알고리즘은 일을 더 빠르게 만듭니다. 그렇지 않으면 컴파일 된 코드가 해석 된 코드보다 빠르게 작동합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d927068d028fb0490208928ec2279c4ca6dbd74" translate="yes" xml:space="preserve">
          <source>normally &lt;code&gt;cin&lt;/code&gt;,&lt;code&gt;scanf&lt;/code&gt;,&lt;code&gt;File&lt;/code&gt; etc avoid input buffering and streams can handle huge amount of data,they uses different streams and  the does not providing major features of python because python itself running on python virtual machine if you type one python code which is equal to many lines of compiled code.python provides features such as &lt;strong&gt;cache  acceleration&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;File&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 등은 입력 버퍼링을 피하고 스트림은 많은 양의 데이터를 처리 할 수 ​​있으며 다른 스트림을 사용하고 파이썬의 주요 기능을 제공하지 않기 때문에 파이썬 자체는 파이썬 가상 머신에서 실행하기 때문에 파이썬 코드를 입력하면 많은 줄의 컴파일 된 코드. 파이썬은 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;캐시 가속&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 같은 기능을 제공합니다.&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b9992e6edfd2287cdda8287f4cce7c746b5b04a" translate="yes" xml:space="preserve">
          <source>sync_with_stdio improved speed to 2 seconds, and setting a larger buffer brought it down to 1 second.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sync_with_stdio의 속도가 2 초로 향상되었으며 더 큰 버퍼를 설정하면 1 초로 줄었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ab4f047c061b9c6bc642d54e86839a4e271cbb98" translate="yes" xml:space="preserve">
          <source>syscalls &lt;code&gt;sudo dtruss -c ./a.out &amp;lt; in&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;syscalls &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sudo dtruss -c ./a.out &amp;lt; in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4eeab4329aae3cae684e7c63ff686f21708cc5f2" translate="yes" xml:space="preserve">
          <source>syscalls &lt;code&gt;sudo dtruss -c ./a.py &amp;lt; in&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;syscalls &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sudo dtruss -c ./a.py &amp;lt; in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7dedc85579d9d10898c2fbc7e3119a830b23dc8" translate="yes" xml:space="preserve">
          <source>there may be cases where `cat` &lt;em&gt;is&lt;/em&gt; needed (e.g.: the file to be read requires some sort of privilege to access, and you do not want to grant that privilege to the program to be benchmarked: `sudo cat /dev/sda | /usr/bin/time my_compression_test --no-output`)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;`cat` &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 필요한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;경우가있을 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(예 : 읽을 파일에 액세스하려면 일종의 권한이 필요하며 벤치마킹 할 프로그램에 해당 권한을 부여하지 않으려는 경우 :`sudo cat / dev / sda | / usr / bin / time my_compression_test --no-output`)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29470267bc79b4c90ccd78d52ec8d78a07736aad" translate="yes" xml:space="preserve">
          <source>they're more 'natural' for people who aren't entirely comfortable with the I/O redirection facilities of the POSIX shell</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;POSIX 쉘의 I / O 리디렉션 기능에 완전히 익숙하지 않은 사람들에게는 더 '자연적'입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9006eab9fd1508da2bd2f79d9c89c2cb0f714a1" translate="yes" xml:space="preserve">
          <source>would have taken only the remaining .49 seconds!  Probably not: `cat` here had to pay for the read() system calls (or equivalent) which transferred the file from 'disk' (actually buffer cache), as well as the pipe writes to deliver them to `wc`.  The correct test would still have had to do those read() calls; only the write-to-pipe and read-from-pipe calls would have been saved, and those should be pretty cheap.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;남은 .49 초만 걸렸을 것입니다! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아마도 'cat'은 여기서 'disk'(실제로는 버퍼 캐시)에서 파일을 전송 한 read () 시스템 호출 (또는 이에 상응하는)과 파이프가`wc '에 전달하기 위해 쓰는 것을 지불해야했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;올바른 테스트는 여전히 read () 호출을 수행해야했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;파이프에 쓰기 및 파이프에서 읽기 호출 만 저장되었을 것이므로 매우 저렴해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
