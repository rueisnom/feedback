<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/9371238">
    <body>
      <group id="9371238">
        <trans-unit id="2ada74fe85580bed0602d49b3709fcf15dcf240b" translate="yes" xml:space="preserve">
          <source>(TLDR answer: include the statement: &lt;code&gt;cin.sync_with_stdio(false)&lt;/code&gt; or just use &lt;code&gt;fgets&lt;/code&gt; instead.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（TLDRの答え：ステートメントを含める：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin.sync_with_stdio(false)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または単に使用することは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代わりに。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5604413a183cbc7d7544d68c94a6c7382ae5d413" translate="yes" xml:space="preserve">
          <source>-- this claims that `cat` consumed 74% of the CPU during the test; and indeed 1.34/1.83 is approximately 74%.  Perhaps a run of:</source>
          <target state="translated">--これは `cat` がテスト中に CPU の 74% を消費したと主張しています;実際には 1.341.83 が約 74% です。おそらく実行したのでしょう。</target>
        </trans-unit>
        <trans-unit id="1348609af914ffea58e6f9f0adbfd5fc589de6d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline&lt;/code&gt;, stream operators, &lt;code&gt;scanf&lt;/code&gt;, can be convenient if you don't care about file loading time or if you are loading small text files. But, if the performance is something you care about, you should really just buffer the entire file into memory (assuming it will fit).</source>
          <target state="translated">&lt;code&gt;getline&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ストリーム演算子、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; は&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、ファイルの読み込み時間を気にしない場合、または小さなテキストファイルを読み込む場合に便利です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、パフォーマンスが気になる場合は、ファイル全体をメモリにバッファリングするだけで十分です（ファイルが収まると想定）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c0915bf7a2ae1a20a3dd3d752c1dede09758b45d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I should note that I tried this both under Mac&amp;nbsp;OS&amp;nbsp;X&amp;nbsp;v10.6.8 (Snow&amp;nbsp;Leopard) and Linux 2.6.32 (Red Hat Linux 6.2). The former is a MacBook Pro, and the latter is a very beefy server, not that this is too pertinent.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mac OS X v10.6.8（Snow Leopard）とLinux 2.6.32（Red Hat Linux 6.2）の両方でこれを試したことに注意してください。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;前者はMacBook Proであり、後者は非常に頑丈なサーバーです。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8119e8521189e9d54129bd0197536b2d962ff8bc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;in practice&lt;/em&gt;, on modern machines, the added `cat` in the pipeline is probably of no real consequence</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際に&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、最新のマシンでは、パイプラインに追加された「猫」はおそらく実際の結果ではありません&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9f625673762999b841e0b14d2b37dd1775f5d0bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++ code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++コード：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7e4899c39940c2a22b2171aa7540343dadef7018" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Here are my results:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これが私の結果です：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d886917c5612dc7850a74f654f3ffa7d073dde44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python Equivalent:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同等のPython：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7ba7ad03822a6b3e0d1b23058b1f808ac10d2d6" translate="yes" xml:space="preserve">
          <source>A better construction would be:</source>
          <target state="translated">もっといい工事があるだろう。</target>
        </trans-unit>
        <trans-unit id="8c484caf9d550a5b7b43988b6fc5cbdf31ee5cee" translate="yes" xml:space="preserve">
          <source>A first element of an answer: &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; is slow. Damn slow. I get a huge performance boost with &lt;code&gt;scanf&lt;/code&gt; as in the below, but it is still two times slower than Python.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;回答の最初の要素：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は遅いです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;遅い。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下のように&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とパフォーマンスが大幅に向上し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ますが、それでもPythonの2倍の速度です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d606b8781f8d9cc1eb582fbcf3c012f3e5267c6" translate="yes" xml:space="preserve">
          <source>A. You could 'fix' this by timing only your program:</source>
          <target state="translated">A.あなたのプログラムのタイミングだけを計ることで、これを「修正」することができます。</target>
        </trans-unit>
        <trans-unit id="6eacef433fa97c076753f8181b901c1df86fb0ee" translate="yes" xml:space="preserve">
          <source>Adding the following statements to the C++ version just before the &lt;code&gt;while&lt;/code&gt; loop brings it inline with the &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; version:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;while&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ループの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;直前のC ++バージョンに次のステートメントを追加する&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Python&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;バージョン&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とインラインになり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa80c19e93d9b42ed6f60bba12683b734e770328" translate="yes" xml:space="preserve">
          <source>Also, if you are in control of the file, consider using a flat binary data format instead of text. It's more reliable to read and write because you don't have to deal with all the ambiguities of whitespace. It's also smaller and much faster to parse.</source>
          <target state="translated">また、ファイルを管理しているのであれば、テキストの代わりにフラットなバイナリデータ形式を使用することを検討してください。空白の曖昧さに対処する必要がないので、読み書きの信頼性が高くなります。また、より小さく、より速く解析することができます。</target>
        </trans-unit>
        <trans-unit id="d24cad29120afe707f62c6f3085b2a58c008227b" translate="yes" xml:space="preserve">
          <source>Also, yes, CPython does some caching to avoid harddisk reads.</source>
          <target state="translated">また、CPythonはハードディスクの読み込みを避けるためにキャッシュを行います。</target>
        </trans-unit>
        <trans-unit id="919616b80f9630eba97648eca9e6cc0700de45cc" translate="yes" xml:space="preserve">
          <source>B. or by timing the entire pipeline:</source>
          <target state="translated">B.またはパイプライン全体のタイミングによって。</target>
        </trans-unit>
        <trans-unit id="a5a9c426254eccca83c581dce40a33f86fc34cf9" translate="yes" xml:space="preserve">
          <source>BTW, didn't know about that sync thing, nice. But you should still try &lt;code&gt;fgets&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ところで、同期については知りませんでした。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、それでも&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;試してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81bad2e8a0b6b2a52ce58ff5f5a60cc0c934ec2b" translate="yes" xml:space="preserve">
          <source>Both this examples too small to make any decisions about C++ vs Python speed. Because we just use some internal mechanism and compare it. So it is unfair to compare. But as we can see Python code match simpler to understand, but it makes inside some conversions (utf8 - decoding I think on Linux and Mac OS) and works on binary files too. C++ version failing to count '\n' on binary files (on Windows with g++ at least)</source>
          <target state="translated">この例はどちらも小さすぎて、C++対Pythonの速度を判断することができません。なぜなら、我々は内部メカニズムを使って比較しているだけだからです。だから、比較するのは不公平です。しかし、Pythonのコードは理解しやすいが、内部での変換(LinuxとMac OSではutf8-デコードだと思う)を行っており、バイナリファイルでも動作する。C++版ではバイナリファイル上での '\n' のカウントに失敗しています。</target>
        </trans-unit>
        <trans-unit id="6691e104c45825c979a28bdf47ad2d042db64162" translate="yes" xml:space="preserve">
          <source>But I say that last thing with some hesitation.  If we examine the last result in 'Edit 5' --</source>
          <target state="translated">しかし、その最後の言葉は少し躊躇しながら言う。編集5」の最後の結果を見てみると--。</target>
        </trans-unit>
        <trans-unit id="c9d36be2de6f8d949f97fad3693ed38300429c46" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;cin&lt;/code&gt; is synchronized with stdio, which causes it to avoid any input buffering.  If you add this to the top of your main, you should see much better performance:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;デフォルトでは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はstdioと同期しており、入力バッファリングを回避します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これをメインの上部に追加すると、パフォーマンスが大幅に向上します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5c92dd35743a41498513f0900ff9df8a2de766a2" translate="yes" xml:space="preserve">
          <source>By the way, the reason the line count for the C++ version is one greater than the count for the Python version is that the eof flag only gets set when an attempt is made to read beyond eof. So the correct loop would be:</source>
          <target state="translated">ところで、C++版の行数がPython版の行数よりも1行多いのは、eofフラグが設定されるのはeofを超えて読み込もうとしたときだけだからです。したがって、正しいループは次のようになります。</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="5d6cf463e19a68d2b9cb392046065a032a4d7137" translate="yes" xml:space="preserve">
          <source>For completeness, I thought I'd update the read speed for the same file on the same box with the original (synced) C++ code. Again, this is for a 100M line file on a fast disk. Here's the comparison, with several solutions/approaches:</source>
          <target state="translated">完全性を高めるために、元の(同期された)C++コードを使って、同じボックス上の同じファイルの読み取り速度を更新しようと思いました。繰り返しになりますが、これは高速ディスク上の 100M 行のファイルのためのものです。以下に、いくつかの解決策を用いた比較を示します。</target>
        </trans-unit>
        <trans-unit id="05f418b280d6d0669a3d45dd130b92d3ef333c5e" translate="yes" xml:space="preserve">
          <source>Fortunately, the library designers decided that you should also be able to disable this feature to get improved performance if you knew what you were doing, so they provided the &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio&quot;&gt;&lt;code&gt;sync_with_stdio&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;幸いにも、ライブラリの設計者は、自分が何をしているのかわかっている場合は、この機能を無効にしてパフォーマンスを向上させることもできると判断し、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio&quot;&gt; &lt;code&gt;sync_with_stdio&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッド&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を提供しました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">一例を挙げてみます。</target>
        </trans-unit>
        <trans-unit id="a3ec40e608105bf527fa8797040dcb94f345155d" translate="yes" xml:space="preserve">
          <source>I reproduced the original result on my computer using g++ on a Mac.</source>
          <target state="translated">Macでg++を使ってパソコンで元の結果を再現してみました。</target>
        </trans-unit>
        <trans-unit id="57c10f7853150262360e29fdc0b93b16251f2f6f" translate="yes" xml:space="preserve">
          <source>I should add that there is at least one other significant difference between these styles of testing, and I can't say whether it is a benefit or fault; you have to decide this yourself:</source>
          <target state="translated">これらのテストスタイルの間には、少なくとももう一つ大きな違いがあることを付け加えておかなければなりません。</target>
        </trans-unit>
        <trans-unit id="749119915fb9bcc67a990d0ef5d5665be585983a" translate="yes" xml:space="preserve">
          <source>I want other C++ version of code. I do not want to copy every line by line. I just want count how many '\n' in file.</source>
          <target state="translated">他のC++バージョンのコードが欲しい 一行ずつコピーするのではなく、ファイルの中に何個の'\n'が入っているかを数えたいだけ。ファイルの中に何個の「♪」があるか数えたいだけだ。</target>
        </trans-unit>
        <trans-unit id="260f22261673c0af873bb219f7a8ae1b2b64b573" translate="yes" xml:space="preserve">
          <source>I wanted to compare reading lines of string input from stdin using Python and C++ and was shocked to see my C++ code run an order of magnitude slower than the equivalent Python code. Since my C++ is rusty and I'm not yet an expert Pythonista, please tell me if I'm doing something wrong or if I'm misunderstanding something.</source>
          <target state="translated">私はPythonとC++を使用してstdinから入力された文字列の行を読み取ることを比較したいと思い、私のC++コードが同等のPythonコードよりも桁違いに遅く実行されているのを見てショックを受けました。私のC++は錆びついていて、まだPythonの専門家ではないので、私が何か間違ったことをしているのか、何か誤解しているのか、教えてください。</target>
        </trans-unit>
        <trans-unit id="7b0e802507be3a79fd0dc0f920f90f6ffd330e60" translate="yes" xml:space="preserve">
          <source>I will mention two possible, but actually wrong, 'fixes' which could also be considered (but I 'number' them differently as these are not things which were wrong in the original post):</source>
          <target state="translated">2つの可能性がありますが、実際には間違っていますが、これも考慮される可能性がある「修正」について言及します (しかし、これらは元の投稿で間違っていたものではないので、私はそれらに異なる「番号」を付けています)。</target>
        </trans-unit>
        <trans-unit id="6396c98ecdd3cbb117338967b67fb60a0ce0e89a" translate="yes" xml:space="preserve">
          <source>I'm a few years behind here, but:</source>
          <target state="translated">ここでは数年遅れていますが</target>
        </trans-unit>
        <trans-unit id="a604ccbbcf387ae81f374f69dbb6f6d257435681" translate="yes" xml:space="preserve">
          <source>If more input was read by &lt;code&gt;cin&lt;/code&gt; than it actually needed, then the second integer value wouldn't be available for the &lt;code&gt;scanf&lt;/code&gt; function, which has its own independent buffer.  This would lead to unexpected results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際に必要な数よりも&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多くの入力が&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;によって読み取られた場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、2番目の整数値&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、独自の独立したバッファーを持つ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は使用できません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは予期しない結果につながります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d1103ccd841b2e817c9c4faecaf3bfaaa41295a" translate="yes" xml:space="preserve">
          <source>If you want, you can wrap a stream around that buffer for more convenient access like this:</source>
          <target state="translated">必要であれば、このようにバッファの周りにストリームを巻いてアクセスを便利にすることができます。</target>
        </trans-unit>
        <trans-unit id="de548edc3c54e3d20a32f157bdac636d41f75a1c" translate="yes" xml:space="preserve">
          <source>In 'Edit 4/5/6' of the original post, you are using the construction:</source>
          <target state="translated">元の投稿の「編集456」では、構築を使用していますね。</target>
        </trans-unit>
        <trans-unit id="b864261dceb4d9e0e5ccfbf23668633686af698a" translate="yes" xml:space="preserve">
          <source>In fact I did some quick tests with a 1.5 gigabyte file of garbage, on a Linux 3.13 (Ubuntu 14.04) system, obtaining these results (these are actually 'best of 3' results; after priming the cache, of course):</source>
          <target state="translated">実際、私はLinux 3.13 (Ubuntu 14.04)システム上で、1.5ギガバイトのゴミファイルでいくつかのクイックテストを行い、以下の結果を得ました(これらは実際には「3つの中で最高の」結果です;もちろん、キャッシュをプライミングした後)。</target>
        </trans-unit>
        <trans-unit id="d82551d6ef616e947fe345dd7b25f64f5a81ba27" translate="yes" xml:space="preserve">
          <source>In this statement it is the &lt;em&gt;shell&lt;/em&gt; which opens big_file, passing it to your program (well, actually to `time` which then executes your program as a subprocess) as an already-open file descriptor.  100% of the file reading is strictly the responsibility of the program you're trying to benchmark.  This gets you a real reading of its performance without spurious complications.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このステートメントでは、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;big_fileを開いて、既に開いているファイル記述子としてプログラムに（まあ、実際には、プログラムをサブプロセスとして実行する「time」に）渡す&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;シェル&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ファイルの読み取りの100％は、厳密にベンチマークしようとしているプログラムの責任です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これにより、偽の複雑化なしに、パフォーマンスを実際に読み取ることができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3088ea2a71bf4e76dfdc1e96ad3c885aa2d2135e" translate="yes" xml:space="preserve">
          <source>In your second example (with scanf()) reason why this is still slower might be because scanf(&quot;%s&quot;) parses string and looks for any space char (space, tab, newline).</source>
          <target state="translated">2 番目の例では (scanf()を使用して)これでも遅いのは、scanf(&quot;%s&quot;)が文字列を解析してスペース文字 (スペース、タブ、改行)を探しているからかもしれません。</target>
        </trans-unit>
        <trans-unit id="4ca2dae7f1b194d92017c3cab32ec8bae84a031f" translate="yes" xml:space="preserve">
          <source>It beats all my Python attempts by more than a factor 2.</source>
          <target state="translated">これは私のPythonのすべての試みを2倍以上も上回るものです。</target>
        </trans-unit>
        <trans-unit id="b74fb04c360a35cd5637f86f5f8966f681595e25" translate="yes" xml:space="preserve">
          <source>Just out of curiosity I've taken a look at what happens under the hood, and I've used &lt;a href=&quot;http://en.wikipedia.org/wiki/Strace&quot;&gt;dtruss/strace&lt;/a&gt; on each test.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好奇心から、私はフードの下で何が起こるかを調べ、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;各テストで&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Strace&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;dtruss / strace&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用しました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdaf58eab95a0b731758003f39034b18ca7a08f7" translate="yes" xml:space="preserve">
          <source>Normally, when an input stream is buffered, instead of reading one character at a time, the stream will be read in larger chunks.  This reduces the number of system calls, which are typically relatively expensive.  However, since the &lt;code&gt;FILE*&lt;/code&gt; based &lt;code&gt;stdio&lt;/code&gt; and &lt;code&gt;iostreams&lt;/code&gt; often have separate implementations and therefore separate buffers, this could lead to a problem if both were used together.  For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常、入力ストリームがバッファリングされている場合、一度に1文字を読み取るのではなく、ストリームはより大きなチャンクで読み取られます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これにより、通常は比較的コストのかかるシステムコールの数が減少します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;FILE*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ベースの&lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と&lt;/font&gt;&lt;/font&gt; &lt;code&gt;iostreams&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は別々の実装があり、したがって別々のバッファーがあるため、両方を一緒に使用すると問題が発生する可能性があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例えば：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="97fd295bbcf7715d2d1e8f86155c46f00aa5bcdb" translate="yes" xml:space="preserve">
          <source>Notice that the two pipeline results claim to have taken more CPU time (user+sys) than realtime.  This is because I'm using the shell (Bash)'s built-in 'time' command, which is cognizant of the pipeline; and I'm on a multi-core machine where separate processes in a pipeline can use separate cores, accumulating CPU time faster than realtime.  Using /usr/bin/time I see smaller CPU time than realtime -- showing that it can only time the single pipeline element passed to it on its command line.  Also, the shell's output gives milliseconds while /usr/bin/time only gives hundreths of a second.</source>
          <target state="translated">2つのパイプラインの結果は、リアルタイムよりもCPU時間(user+sys)がかかっていると主張していることに注目してください。これは私がシェル(Bash)の組み込みの 'time' コマンドを使っているためで、パイプラインを認識しているからです。usrbintimeを使用すると、リアルタイムよりもCPU時間が短くなります --コマンドラインで渡された単一のパイプライン要素だけを処理できることを示しています。また、シェルの出力がミリ秒であるのに対し、usrbintime は数十分の一秒しか出力しません。</target>
        </trans-unit>
        <trans-unit id="9b0c98872d79e9099677b6990de484ff7dbbe1de" translate="yes" xml:space="preserve">
          <source>Of course it is an interesting benchmark result if the same program performs significantly differently between the two cases.  It shows that, indeed, the program or its I/O libraries &lt;em&gt;are&lt;/em&gt; doing something interesting, like using mmap().  So in practice it might be good to run the benchmarks both ways; perhaps discounting the `cat` result by some small factor to &quot;forgive&quot; the cost of running `cat` itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、2つのケース間で同じプログラムのパフォーマンスが大幅に異なる場合、それは興味深いベンチマーク結果です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際、プログラムまたはそのI / Oライブラリ&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; mmap（）を使用するなどの興味深いことをしていることを示しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、実際には、ベンチマークを両方の方法で実行することをお勧めします。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;おそらく、 `cat`自体を実行するコストを「許す」ために、` cat`の結果をいくつかの小さな要因で割り引いています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="77fe33f271e30ea0be6216f64c174b1e2f493ad4" translate="yes" xml:space="preserve">
          <source>Python code I think we should change too</source>
          <target state="translated">私たちも変えるべきだと思うPythonのコード</target>
        </trans-unit>
        <trans-unit id="8d6f668d23cdb06ece2ffec8fd41bcf15e77b630" translate="yes" xml:space="preserve">
          <source>So at the efficiency level of `wc -l`, the `cat` makes a huge difference: 409 / 283 = 1.453 or 45.3% more realtime, and 775 / 280 = 2.768, or a whopping 177% more CPU used!  On my random it-was-there-at-the-time test box.</source>
          <target state="translated">つまり、`wc -l`の効率レベルでは、`cat`は大きな違いをもたらします。409 283=1.453、つまり45.3%のリアルタイム性の向上、775 280=2.768、つまり177%のCPU使用率の向上です。409 283=1,453、45.3%のリアルタイム性、775 280=2.768、177%のCPU使用率となります。</target>
        </trans-unit>
        <trans-unit id="95b7b0ce50fd459cea21ab95da67ad7dc700d7da" translate="yes" xml:space="preserve">
          <source>Still, I predict you would be able to measure the difference between `cat file | wc -l` and `wc -l &amp;lt; file` and find a noticeable (2-digit percentage) difference.  Each of the slower tests will have paid a similar penalty in absolute time; which would however amount to a smaller fraction of its larger total time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それでも、 `catファイルの違いを測定できると思います| wc -l`および `wc -l &amp;lt;​​file`を実行して、顕著な（2桁のパーセンテージ）違いを見つけます。より遅いテストのそれぞれは、絶対時間で同様のペナルティを支払ったでしょう。ただし、これはその合計時間のごく一部にすぎません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8c0d59470dee317a0bd4e3ed90af701235f5ceec" translate="yes" xml:space="preserve">
          <source>TLDR results: scroll all the way down to the bottom of my question and look at the table.)</source>
          <target state="translated">TLDR結果:私の質問の一番下までスクロールして表を見てください)</target>
        </trans-unit>
        <trans-unit id="26036044bf09499b66ab681b2636b0886eb6e6cf" translate="yes" xml:space="preserve">
          <source>The following code was faster for me than the other code posted here so far:
(Visual Studio 2013, 64-bit, 500 MB file with line length uniformly in [0, 1000)).</source>
          <target state="translated">これまでここに投稿された他のコードよりも、以下のコードの方が私には速かったです。(Visual Studio 2013,64bit,500MBのファイルを[0,1000]で行数を一律にしたもの)。</target>
        </trans-unit>
        <trans-unit id="d712bbe9542b29fb12a7ddae3053c86ac35d66ca" translate="yes" xml:space="preserve">
          <source>These are wrong for the same reasons as #2: they're still using `cat` unnecessarily.  I mention them for a few reasons:</source>
          <target state="translated">これらは#2と同じ理由で間違っています:彼らはまだ `cat` を不必要に使っています。これにはいくつかの理由があります。</target>
        </trans-unit>
        <trans-unit id="151f78cf3abe6db2af3d5bb863a668fb774d5c1e" translate="yes" xml:space="preserve">
          <source>This is wrong in a couple of different ways:</source>
          <target state="translated">これはいくつかの方法で間違っています。</target>
        </trans-unit>
        <trans-unit id="31b18e50b32a9ad9d4e72e48e9d3d402a551f97a" translate="yes" xml:space="preserve">
          <source>Tiny benchmark addendum and recap</source>
          <target state="translated">ちっちゃいベンチマークの追記と復習</target>
        </trans-unit>
        <trans-unit id="12f64344295facbd95f90ce066c817fa5fbcff18" translate="yes" xml:space="preserve">
          <source>To avoid this, by default, streams are synchronized with &lt;code&gt;stdio&lt;/code&gt;.  One common way to achieve this is to have &lt;code&gt;cin&lt;/code&gt; read each character one at a time as needed using &lt;code&gt;stdio&lt;/code&gt; functions.  Unfortunately, this introduces a lot of overhead.  For small amounts of input, this isn't a big problem, but when you are reading millions of lines, the performance penalty is significant.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これを回避するために、デフォルトでは、ストリームは&lt;/font&gt;&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; と&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同期され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これを実現する一般的な方法の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1つは、必要に応じて&lt;/font&gt; &lt;code&gt;stdio&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;して、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が各文字を一度に1つずつ読み取る&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ようにすることです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;残念ながら、これは多くのオーバーヘッドをもたらします。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;少量の入力の場合、これは大きな問題ではありませんが、数百万行を読み取る場合、パフォーマンスの低下は重大です。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c4af42a2bc6a8140f782f723d293d5612c973776" translate="yes" xml:space="preserve">
          <source>Use of `cat` is unnecessary and in fact counterproductive; you're adding moving parts.  If you were on a sufficiently old system (i.e.  with a single CPU and -- in certain generations of computers -- I/O faster than CPU) -- the mere fact that `cat` was running could substantially color the results.  You are also subject to whatever input and output buffering and other processing `cat` may do.  (This would likely earn you a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat&quot;&gt;'Useless Use Of Cat'&lt;/a&gt; award if I were Randal Schwartz.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;`cat`の使用は不要であり、実際には逆効果です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可動部品を追加しています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;十分に古いシステム（つまり、単一のCPUがあり、特定の世代のコンピューターでは、CPUよりもI / Oが速い）を使用している場合、 `cat`が実行されているという単なる事実によって、結果がかなり色付けされる可能性があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、 `cat`が実行する可能性のあるすべての入力および出力のバッファリングとその他の処理の影響を受けます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私がRandal Schwartzだった場合&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、これはおそらく&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「Useless Use Of Cat」&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;賞を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;獲得するでしょう&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e687d0cf6ef10b35b782602f2bf1981f0e798157" translate="yes" xml:space="preserve">
          <source>Well, I see that in your second solution you switched from &lt;code&gt;cin&lt;/code&gt; to &lt;code&gt;scanf&lt;/code&gt;, which was the first suggestion I was going to make you (cin is sloooooooooooow). Now, if you switch from &lt;code&gt;scanf&lt;/code&gt; to &lt;code&gt;fgets&lt;/code&gt;, you would see another boost in performance: &lt;code&gt;fgets&lt;/code&gt; is the fastest C++ function for string input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;さて、あなたの2番目のソリューションでは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;切り替えた&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことがわかります。これは、私があなたにしようとした最初の提案でした（cinはsloooooooooooooow）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; に&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;切り替えると&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、パフォーマンスがさらに向上します&lt;/font&gt;&lt;/font&gt; &lt;code&gt;fgets&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、文字列入力用の最速のC ++関数です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be8c0ffa13d1b9e5e48623ed2ff2306f02135d47" translate="yes" xml:space="preserve">
          <source>When you run `/usr/bin/time my_program &amp;lt; big_file`, your program receives an open file descriptor to the actual file.  Your program -- &lt;em&gt;or&lt;/em&gt; in many cases the I/O libraries of the language in which it was written -- may take different actions when presented with a file descriptor referencing a regular file.  It may use mmap(2) to map the input file into its address space, instead of using explicit read(2) system calls.  These differences could have a far larger effect on your benchmark results than the small cost of running the `cat` binary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;`/ usr / bin / time my_program &amp;lt;big_file`を実行すると、プログラムは実際のファイルへのオープンファイル記述子を受け取ります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常のファイルを参照するファイル記述子が提示されると、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;プログラム（&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多くの場合、それが記述された言語のI / Oライブラリ）は異なるアクションを実行する可能性があります。明示的なread（2）システムコールを使用する代わりに、mmap（2）を使用して、入力ファイルをそのアドレススペースにマップできます。これらの違いは、 `cat`バイナリを実行するための小さなコストよりも、ベンチマーク結果にはるかに大きな影響を与える可能性があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae6b11f7e1ce91c9e5497a2e4ac72a06aff02413" translate="yes" xml:space="preserve">
          <source>When you run `cat big_file | /usr/bin/time my_program`, your program is receiving input from a pipe, at precisely the pace sent by `cat`, and in chunks no larger than written by `cat`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99419ef0ccd4c72c0b4ec5ca34d06199b16630c5" translate="yes" xml:space="preserve">
          <source>Why is reading lines from stdin much slower in C++ than Python</source>
          <target state="translated">C++では標準入力からの行の読み込みがPythonよりも遅いのはなぜでしょうか?</target>
        </trans-unit>
        <trans-unit id="3de13424399dc6cf24b91661d84eaa2b31863a3b" translate="yes" xml:space="preserve">
          <source>You're actually timing the execution of `cat`, not your benchmark.  The 'user' and 'sys' CPU usage displayed by `time` are those of `cat`, not your benchmarked program.  Even worse, the 'real' time is also not necessarily accurate.  Depending on the implementation of `cat` and of pipelines in your local OS, it is possible that `cat` writes a final giant buffer and exits long before the reader process finishes its work.</source>
          <target state="translated">実際には、ベンチマークではなく `cat` の実行のタイミングを計っています。time` で表示される 'ユーザ' と 'sys' の CPU 使用率は `cat` のものであり、ベンチマークされたプログラムのものではありません。さらに悪いことに、「実際の」時間は必ずしも正確ではありません。cat`やローカルOSのパイプラインの実装によっては、`cat`が最終的に巨大なバッファを書き込んで、リーダプロセスが作業を終えるずっと前に終了する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1e72498d28b08e47ce5ad19ced93a61314488cd0" translate="yes" xml:space="preserve">
          <source>actually python is implemented in c/c++ so it works because of a compiled language but its implementation algorithm makes things faster otherwise compiled code works faster than interpreted code.</source>
          <target state="translated">実際には python は cc++で実装されているので、コンパイルされた言語のために動作しますが、その実装アルゴリズムは物事をより速くします。</target>
        </trans-unit>
        <trans-unit id="0d927068d028fb0490208928ec2279c4ca6dbd74" translate="yes" xml:space="preserve">
          <source>normally &lt;code&gt;cin&lt;/code&gt;,&lt;code&gt;scanf&lt;/code&gt;,&lt;code&gt;File&lt;/code&gt; etc avoid input buffering and streams can handle huge amount of data,they uses different streams and  the does not providing major features of python because python itself running on python virtual machine if you type one python code which is equal to many lines of compiled code.python provides features such as &lt;strong&gt;cache  acceleration&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;cin&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;File&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などは入力バッファリングを回避し、ストリームは大量のデータを処理できます。それらは異なるストリームを使用し、はPythonの主要機能を提供しません。コンパイルされたコードの多くの行.pythonは&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;キャッシュアクセラレーション&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などの機能を提供します&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b9992e6edfd2287cdda8287f4cce7c746b5b04a" translate="yes" xml:space="preserve">
          <source>sync_with_stdio improved speed to 2 seconds, and setting a larger buffer brought it down to 1 second.</source>
          <target state="translated">sync_with_stdioの速度を2秒に改善し、バッファを大きくして設定すると1秒に短縮されました。</target>
        </trans-unit>
        <trans-unit id="ab4f047c061b9c6bc642d54e86839a4e271cbb98" translate="yes" xml:space="preserve">
          <source>syscalls &lt;code&gt;sudo dtruss -c ./a.out &amp;lt; in&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;システムコール&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sudo dtruss -c ./a.out &amp;lt; in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4eeab4329aae3cae684e7c63ff686f21708cc5f2" translate="yes" xml:space="preserve">
          <source>syscalls &lt;code&gt;sudo dtruss -c ./a.py &amp;lt; in&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;システムコール&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sudo dtruss -c ./a.py &amp;lt; in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7dedc85579d9d10898c2fbc7e3119a830b23dc8" translate="yes" xml:space="preserve">
          <source>there may be cases where `cat` &lt;em&gt;is&lt;/em&gt; needed (e.g.: the file to be read requires some sort of privilege to access, and you do not want to grant that privilege to the program to be benchmarked: `sudo cat /dev/sda | /usr/bin/time my_compression_test --no-output`)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;`cat` &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要な&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合が&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あり&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます（例：読み取るファイルにアクセスするには何らかの特権が必要であり、ベンチマーク対象のプログラムにその特権を付与したくない場合：` sudo cat / dev / sda | / usr / bin / time my_compression_test --no-output`）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29470267bc79b4c90ccd78d52ec8d78a07736aad" translate="yes" xml:space="preserve">
          <source>they're more 'natural' for people who aren't entirely comfortable with the I/O redirection facilities of the POSIX shell</source>
          <target state="translated">は、POSIX シェルの IO リダイレクト機能を完全に使いこなせていない人にとっては、より「自然な」ものです。</target>
        </trans-unit>
        <trans-unit id="c9006eab9fd1508da2bd2f79d9c89c2cb0f714a1" translate="yes" xml:space="preserve">
          <source>would have taken only the remaining .49 seconds!  Probably not: `cat` here had to pay for the read() system calls (or equivalent) which transferred the file from 'disk' (actually buffer cache), as well as the pipe writes to deliver them to `wc`.  The correct test would still have had to do those read() calls; only the write-to-pipe and read-from-pipe calls would have been saved, and those should be pretty cheap.</source>
          <target state="translated">は残りの0.49秒しかかかりませんでした! おそらくそうではないでしょう:ここでの `cat` は、ファイルを 'disk' (実際にはバッファキャッシュ)から転送する read()システムコール (またはそれに相当するもの)と、それらを `wc` に配送するためのパイプ書き込みのための費用を支払わなければなりませんでした。パイプへの書き込みとパイプからの読み込みだけが保存され、それらはかなり安く済むはずです。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
