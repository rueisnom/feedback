<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/8881291">
    <body>
      <group id="8881291">
        <trans-unit id="8b5cc79fdd91f3cbabe317bb10b94a8fc9da92e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.oracle.com/technetwork/java/seccodeguide-139067.html#2&quot;&gt;Guideline 2-2 of the Secure Coding Guidelines for the Java Programming Language, Version 4.0&lt;/a&gt; also says something similar (although it is originally in the context of logging):</source>
          <target state="translated">&lt;a href=&quot;http://www.oracle.com/technetwork/java/seccodeguide-139067.html#2&quot;&gt;В Руководстве 2-2 Руководства по безопасному кодированию для языка программирования Java, версия 4.0&lt;/a&gt; также говорится нечто подобное (хотя изначально оно относится к ведению журнала):</target>
        </trans-unit>
        <trans-unit id="e262fa514b2ff9a9cdfcbd1e05ba0e4a0e8eab24" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://security.stackexchange.com/a/83671&quot;&gt;A discussion about timing attacks&lt;/a&gt; over on Information Security Stack Exchange</source>
          <target state="translated">&lt;a href=&quot;https://security.stackexchange.com/a/83671&quot;&gt;Обсуждение времени атаки&lt;/a&gt; на стек информационной безопасности</target>
        </trans-unit>
        <trans-unit id="546581ef303b186fcfa524db41590bb28383b19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Strings&lt;/code&gt; in Java are immutable objects. That is why they can't be modified once created, and therefore the only way for their contents to be removed from memory is to have them garbage collected. It will be only then when the memory freed by the object can be overwritten, and the data will be gone.</source>
          <target state="translated">&lt;code&gt;Strings&lt;/code&gt; в Java являются неизменяемыми объектами. Вот почему они не могут быть изменены после создания, и поэтому единственный способ удаления их содержимого из памяти - это сбор мусора. Только тогда память, освобожденная объектом, может быть перезаписана, и данные исчезнут.</target>
        </trans-unit>
        <trans-unit id="31db751b481dd56268b798ca07bdcab69947d650" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char[]&lt;/code&gt; is an array which you should overwrite once you used the password and this is how it should be done:</source>
          <target state="translated">&lt;code&gt;char[]&lt;/code&gt; - это массив, который вы должны перезаписать после того, как используете пароль, и вот как это должно быть сделано:</target>
        </trans-unit>
        <trans-unit id="397be38dc3f561874a0b47a76aa1154fa7e83414" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Guideline 2-2: Do not log highly sensitive information&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Рекомендация 2-2: не регистрировать особо конфиденциальную информацию&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dea03c5dc15d1e7cf9dfb8c1ea63a39c96a370f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt;  Since Strings are immutable in Java, if you store the password as plain text it will be available in memory until the Garbage collector clears it, and since String is used in the String pool for reusability there is a pretty high chance that it will remain in memory for a long duration, which poses a security threat.</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt; Поскольку строки являются неизменяемыми в Java, если вы сохраните пароль в виде обычного текста, он будет доступен в памяти до тех пор, пока сборщик мусора не очистит его, и поскольку String используется в пуле строк для повторного использования, существует довольно высокая вероятность того, что он будет остаются в памяти на долгое время, что создает угрозу безопасности.</target>
        </trans-unit>
        <trans-unit id="fa50fb41f6a3f808bb31590fb5c49da04a28ef18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt;  Java itself recommends using the getPassword() method of JPasswordField which returns a char[], instead of the deprecated getText() method which returns passwords in clear text stating security reasons. It's good to follow advice from the Java team and adhere to standards rather than going against them.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt; Сама Java рекомендует использовать метод getPassword () из JPasswordField, который возвращает char [], вместо устаревшего метода getText (), который возвращает пароли в виде открытого текста с указанием соображений безопасности. Хорошо следовать советам команды Java и придерживаться стандартов, а не идти против них.</target>
        </trans-unit>
        <trans-unit id="31024e792a22c2125636d2085a3babcbaad4dd64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.&lt;/strong&gt;  With String there is always a risk of printing plain text in a log file or console but if you use an Array you won't print contents of an array, but instead its memory location gets printed. Though not a real reason, it still makes sense.</source>
          <target state="translated">&lt;strong&gt;3.&lt;/strong&gt; При использовании String всегда существует риск печати простого текста в файле журнала или консоли, но если вы используете массив, вы не будете печатать содержимое массива, а вместо этого будет напечатано его расположение в памяти. Хотя это и не реальная причина, это все же имеет смысл.</target>
        </trans-unit>
        <trans-unit id="69b7f956cdb0d8e690f8921a39588f88b303dc69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; Coming back to this answer after a year of security research, I realize it makes the rather unfortunate implication that you would ever actually compare plaintext passwords. Please don't. &lt;a href=&quot;https://stackoverflow.com/questions/2860943/how-can-i-hash-a-password-in-java&quot;&gt;Use a secure one-way hash with a salt and a reasonable number of iterations&lt;/a&gt;. Consider using a library: this stuff is hard to get right!</source>
          <target state="translated">&lt;strong&gt;Редактировать:&lt;/strong&gt; Возвращаясь к этому ответу после года исследований в области безопасности, я понимаю, что это весьма прискорбно, что вы когда-либо будете сравнивать незашифрованные пароли. Пожалуйста, не надо. &lt;a href=&quot;https://stackoverflow.com/questions/2860943/how-can-i-hash-a-password-in-java&quot;&gt;Используйте безопасный односторонний хеш с солью и разумным количеством итераций&lt;/a&gt; . Подумайте об использовании библиотеки: этот материал трудно понять правильно!</target>
        </trans-unit>
        <trans-unit id="e60aa3b140458b9e42618bd0b3a05e257cc2dc56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original answer:&lt;/strong&gt; What about the fact that String.equals() uses &lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/lang/String.java#String.equals%28java.lang.Object%29&quot;&gt;short-circuit evaluation&lt;/a&gt;, and is therefore vulnerable to a timing attack? It may be unlikely, but you could &lt;em&gt;theoretically&lt;/em&gt; time the password comparison in order to determine the correct sequence of characters.</source>
          <target state="translated">&lt;strong&gt;Оригинальный ответ:&lt;/strong&gt; А как насчет того факта, что String.equals () использует &lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/lang/String.java#String.equals%28java.lang.Object%29&quot;&gt;оценку короткого замыкания&lt;/a&gt; и поэтому уязвим для временной атаки? Это может быть маловероятно, но &lt;em&gt;теоретически&lt;/em&gt; вы можете рассчитать время сравнения пароля, чтобы определить правильную последовательность символов.</target>
        </trans-unit>
        <trans-unit id="71c1051a13130dc057ae957211603eb7b21660e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strings are immutable&lt;/strong&gt;. That means once you've created the &lt;code&gt;String&lt;/code&gt;, if another process can dump memory, there's no way (aside from &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt;) you can get rid of the data before &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;garbage collection&lt;/a&gt; kicks in.</source>
          <target state="translated">&lt;strong&gt;Строки неизменны&lt;/strong&gt; . Это означает, что после того, как вы создали &lt;code&gt;String&lt;/code&gt; , если другой процесс может создавать дамп памяти, вы не сможете (кроме &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;рефлексии&lt;/a&gt; ) избавиться от данных до того, как &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;начнется сборка мусора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bf1fec4ea517ac75d82aa127b348cecaa117a7d" translate="yes" xml:space="preserve">
          <source>A Lesson In Timing Attacks</source>
          <target state="translated">Урок атак на время.</target>
        </trans-unit>
        <trans-unit id="94ac581f37ab2d56dfe8fa01845f896c48ea2c7c" translate="yes" xml:space="preserve">
          <source>And as it turns out, there is nothing that lets you clear the private information of a &lt;code&gt;PrivateKey&lt;/code&gt; from memory, because there's no API that lets you wipe the bytes that form the corresponding information.</source>
          <target state="translated">И, как выясняется, нет ничего, что &lt;code&gt;PrivateKey&lt;/code&gt; бы вам удалять личную информацию PrivateKey из памяти, потому что нет API, который позволял бы стирать байты, которые формируют соответствующую информацию.</target>
        </trans-unit>
        <trans-unit id="698e47ef5df7856861e6bd29ada26e30e6c56a65" translate="yes" xml:space="preserve">
          <source>And of course, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Timing_attack&quot;&gt;Timing Attack Wikipedia page&lt;/a&gt;</source>
          <target state="translated">И, конечно же, &lt;a href=&quot;http://en.wikipedia.org/wiki/Timing_attack&quot;&gt;страница Википедии Timing Attack&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35879106f4ed216fdb6c73f43b27a8729c325a87" translate="yes" xml:space="preserve">
          <source>As Jon Skeet states, there is no way except by using reflection.</source>
          <target state="translated">Как утверждает Джон Скит,нет другого способа,кроме как использовать отражение.</target>
        </trans-unit>
        <trans-unit id="36331cef84c6d35142e7b76dbacd89b8ff6a7d65" translate="yes" xml:space="preserve">
          <source>As noted in the comments, it's possible that arrays being moved by the garbage collector will leave stray copies of the data in memory. I believe this is implementation-specific - the garbage collector &lt;em&gt;may&lt;/em&gt; clear all memory as it goes, to avoid this sort of thing. Even if it does, there's still the time during which the &lt;code&gt;char[]&lt;/code&gt; contains the actual characters as an attack window.</source>
          <target state="translated">Как отмечено в комментариях, возможно, что массивы, перемещаемые сборщиком мусора, будут оставлять в памяти случайные копии данных. Я полагаю, что это зависит от реализации - сборщик мусора &lt;em&gt;может&lt;/em&gt; очистить всю память, чтобы избежать подобных вещей. Даже если это произойдет, есть время, в течение которого &lt;code&gt;char[]&lt;/code&gt; содержит реальных символов в качестве окна атаки.</target>
        </trans-unit>
        <trans-unit id="ea94246ffb44ab6b727efb8d392dd9232ef47c1b" translate="yes" xml:space="preserve">
          <source>Based on the above circumstances, one can get an idea whether to go with String or to go with Char[] for their requirements.</source>
          <target state="translated">Исходя из вышеперечисленных обстоятельств,можно получить представление о том,следует ли идти со Стрингом или со Сар[]для их требований.</target>
        </trans-unit>
        <trans-unit id="ff08257691f084f5bb4321a9521146f84621c841" translate="yes" xml:space="preserve">
          <source>Because of the security concern it is better to store password as a character array.</source>
          <target state="translated">Из-за соображений безопасности лучше хранить пароль в виде массива символов.</target>
        </trans-unit>
        <trans-unit id="fc94856bbf7a5446009d35b73ca294f9cc65c6ce" translate="yes" xml:space="preserve">
          <source>But that alone isn't a good answer; why not just make sure a reference to the &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; doesn't escape? Then there's no security issue. But the thing is that &lt;code&gt;String&lt;/code&gt; objects can be &lt;code&gt;intern()&lt;/code&gt;ed in theory and kept alive inside the constant pool. I suppose using &lt;code&gt;char[]&lt;/code&gt; forbids this possibility.</source>
          <target state="translated">Но это само по себе не хороший ответ; почему бы просто не убедиться, что ссылка на &lt;code&gt;char[]&lt;/code&gt; или &lt;code&gt;String&lt;/code&gt; не уходит? Тогда нет проблем с безопасностью. Но дело в том, что &lt;code&gt;String&lt;/code&gt; объекты могут быть &lt;code&gt;intern()&lt;/code&gt; теоретически и поддерживаться в постоянном пуле. Я полагаю, использование &lt;code&gt;char[]&lt;/code&gt; запрещает эту возможность.</target>
        </trans-unit>
        <trans-unit id="f7b798d770ca2df60818ef3a16e84e4d0302362b" translate="yes" xml:space="preserve">
          <source>Char[] is mutable, but it has the advantage that after its usage the programmer can explicitly clean the array or override values. So when it's done being used it is cleaned and no one could ever know about the information you had stored.</source>
          <target state="translated">Char[]является мутируемым,но имеет то преимущество,что после его использования программист может явно очистить массив или переопределить значения.Таким образом,когда он закончен,он очищается,и никто никогда не может узнать о сохраненной информации.</target>
        </trans-unit>
        <trans-unit id="f2d5fad3855bcb5cf79c403b8fae8134166583c5" translate="yes" xml:space="preserve">
          <source>Character arrays (&lt;code&gt;char[]&lt;/code&gt;) can be cleared after use by setting each character to zero and Strings not. If someone can somehow see the memory image, they can see a password in plain text if Strings are used, but if &lt;code&gt;char[]&lt;/code&gt; is used, after purging data with 0's, the password is secure.</source>
          <target state="translated">Массивы символов ( &lt;code&gt;char[]&lt;/code&gt; ) можно очистить после использования, установив для каждого символа ноль, а для строк - нет. Если кто-то каким-то образом может видеть образ памяти, он может видеть пароль в виде простого текста, если используются строки, но если используется &lt;code&gt;char[]&lt;/code&gt; , после очистки данных с нулями пароль является безопасным.</target>
        </trans-unit>
        <trans-unit id="fe2e10fde78683521d4003ae2215af5b39ef6231" translate="yes" xml:space="preserve">
          <source>Consider this:</source>
          <target state="translated">Подумай об этом:</target>
        </trans-unit>
        <trans-unit id="61da8effd39d181e7d2fbf216216c68b5d82129d" translate="yes" xml:space="preserve">
          <source>However, Java changes all the time, and some scary features like &lt;a href=&quot;https://stackoverflow.com/questions/27949213/string-deduplication-feature-of-java-8&quot;&gt;String Deduplication feature of Java 8&lt;/a&gt; might intern String objects without your knowledge. But that's a different conversation.</source>
          <target state="translated">Тем не менее, Java постоянно меняется, и некоторые страшные функции, такие как &lt;a href=&quot;https://stackoverflow.com/questions/27949213/string-deduplication-feature-of-java-8&quot;&gt;функция дедупликации String в Java 8,&lt;/a&gt; могут работать с объектами String без вашего ведома. Но это другой разговор.</target>
        </trans-unit>
        <trans-unit id="4085390bb3f3a972df1be47fd22afa929e468c7e" translate="yes" xml:space="preserve">
          <source>However, if reflection is an option for you, you can do this.</source>
          <target state="translated">Однако,если для вас есть возможность поразмышлять,вы можете это сделать.</target>
        </trans-unit>
        <trans-unit id="2ce1845c70b9dc4de0441f1a0e5b0d33534ff75d" translate="yes" xml:space="preserve">
          <source>I don't think this is a valid suggestion, but, I can at least guess at the reason.</source>
          <target state="translated">Я не думаю,что это обоснованное предложение,но,по крайней мере,я могу догадаться о причине.</target>
        </trans-unit>
        <trans-unit id="151bc7b0c4f1b70bc4b73e26ef103e85b31bf68d" translate="yes" xml:space="preserve">
          <source>I think the motivation is wanting to make sure that you can erase all trace of the password in memory promptly and with certainty after it is used. With a &lt;code&gt;char[]&lt;/code&gt; you could overwrite each element of the array with a blank or something for sure. You can't edit the internal value of a &lt;code&gt;String&lt;/code&gt; that way.</source>
          <target state="translated">Я думаю, что мотивация состоит в том, чтобы убедиться, что вы можете стереть все следы пароля в памяти быстро и с уверенностью после его использования. С &lt;code&gt;char[]&lt;/code&gt; вы можете перезаписать каждый элемент массива пробелом или чем-то еще. Вы не можете редактировать внутреннее значение &lt;code&gt;String&lt;/code&gt; таким образом.</target>
        </trans-unit>
        <trans-unit id="ac37450fb5de9b14d5b22b707a61b326fc006e75" translate="yes" xml:space="preserve">
          <source>I'm thinking of e.g. the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/security/PrivateKey.html&quot;&gt;PrivateKey&lt;/a&gt; class. Consider a scenario where you would load a private RSA key from a PKCS#12 file, using it to perform some operation. Now in this case, sniffing the password alone wouldn't help you much as long as physical access to the key file is properly restricted. As an attacker, you would be much better off if you obtained the key directly instead of the password. The desired information can be leaked manifold, core dumps, a debugger session or swap files are just some examples.</source>
          <target state="translated">Я имею в виду, например, класс &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/security/PrivateKey.html&quot;&gt;PrivateKey&lt;/a&gt; . Рассмотрим сценарий, в котором вы бы загружали закрытый ключ RSA из файла PKCS # 12, используя его для выполнения какой-либо операции. Теперь, в этом случае, прослушивание пароля само по себе не очень поможет, если физический доступ к файлу ключа должным образом ограничен. Как злоумышленнику, вам будет гораздо лучше, если вы получите ключ вместо пароля. Желаемой информацией может быть утечка коллектора, дампы ядра, сеанс отладки или файлы подкачки - это только некоторые примеры.</target>
        </trans-unit>
        <trans-unit id="57001b779997c68b84ea322da58afc3b9aee11b7" translate="yes" xml:space="preserve">
          <source>If possible, disabling core dumps and the swap file would take care of both problems. However, they would require administrator rights and may reduce functionality (less memory to use) and pulling RAM from a running system would still be a valid concern.</source>
          <target state="translated">Если возможно,отключение дампа ядра и файла подкачки решит обе проблемы.Однако,они потребуют прав администратора и могут уменьшить функциональность (использовать меньше памяти),а извлечение оперативной памяти из работающей системы все равно будет обоснованной проблемой.</target>
        </trans-unit>
        <trans-unit id="33fe3db7ec48beac0c68de9fcd8d0c76bda59e6e" translate="yes" xml:space="preserve">
          <source>If the value of the string is modified then it will end up creating a new string. So both the original value and the modified value stay in the memory until it is garbage collected.</source>
          <target state="translated">Если значение строки будет изменено,то в итоге будет создана новая строка.Таким образом,и исходное значение,и модифицированное остаются в памяти до тех пор,пока не будет собран мусор.</target>
        </trans-unit>
        <trans-unit id="914d4c3b06c646d3115826f9e7120eefcb75df0a" translate="yes" xml:space="preserve">
          <source>In Swing, the password field has a &lt;code&gt;getPassword()&lt;/code&gt; (returns &lt;code&gt;char[]&lt;/code&gt;) method instead of the usual &lt;code&gt;getText()&lt;/code&gt; (returns &lt;code&gt;String&lt;/code&gt;) method. Similarly, I have come across a suggestion not to use &lt;code&gt;String&lt;/code&gt; to handle passwords.</source>
          <target state="translated">В Swing поле пароля имеет &lt;code&gt;getPassword()&lt;/code&gt; (возвращает &lt;code&gt;char[]&lt;/code&gt; ) вместо обычного &lt;code&gt;getText()&lt;/code&gt; (возвращает &lt;code&gt;String&lt;/code&gt; ). Точно так же я натолкнулся на предложение не использовать &lt;code&gt;String&lt;/code&gt; для обработки паролей.</target>
        </trans-unit>
        <trans-unit id="f3e385fc6478055a321c64cb02009cc9d7e54bd6" translate="yes" xml:space="preserve">
          <source>It is debatable as to whether you should use String or use Char[] for this purpose because both have their advantages and disadvantages. It depends on what the user needs.</source>
          <target state="translated">Спорно,следует ли вам использовать String или Char[]для этой цели,так как и то,и другое имеет свои преимущества и недостатки.Это зависит от того,что нужно пользователю.</target>
        </trans-unit>
        <trans-unit id="6892d03a0b1a14ba14ef1fe5bba377b5df3f74f4" translate="yes" xml:space="preserve">
          <source>It would seem logical to collect and store the password in an object
  of type &lt;code&gt;java.lang.String&lt;/code&gt;. However, here's the caveat: &lt;code&gt;Object&lt;/code&gt;s of
  type &lt;code&gt;String&lt;/code&gt; are immutable, i.e., there are no methods defined that
  allow you to change (overwrite) or zero out the contents of a &lt;code&gt;String&lt;/code&gt;
  after usage. This feature makes &lt;code&gt;String&lt;/code&gt; objects unsuitable for
  storing security sensitive information such as user passwords. You
  should always collect and store security sensitive information in a
  &lt;code&gt;char&lt;/code&gt; array instead.</source>
          <target state="translated">Казалось бы логичным собирать и хранить пароль в объекте типа &lt;code&gt;java.lang.String&lt;/code&gt; . Однако, вот вам предостережение: &lt;code&gt;Object&lt;/code&gt; типа &lt;code&gt;String&lt;/code&gt; являются неизменяемыми, т. Е. Не определены методы, позволяющие вам изменять (перезаписывать) или обнулять содержимое &lt;code&gt;String&lt;/code&gt; после использования. Эта функция делает объекты &lt;code&gt;String&lt;/code&gt; непригодными для хранения конфиденциальной информации, такой как пароли пользователей. Вместо этого вы всегда должны собирать и хранить конфиденциальную информацию о безопасности в массиве &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8684c3b4018676a3106d93184438755a93bce417" translate="yes" xml:space="preserve">
          <source>Note: if the String's char[] has been copied as a part of a GC cycle, there is a chance the previous copy is somewhere in memory.</source>
          <target state="translated">Замечание:если строка char[]была скопирована как часть цикла GC,есть вероятность,что предыдущая копия находится где-то в памяти.</target>
        </trans-unit>
        <trans-unit id="a4510da9e949f0f4ef9576982abd7e611df40556" translate="yes" xml:space="preserve">
          <source>Now garbage collection in Java doesn't happen at any guaranteed interval. The &lt;code&gt;String&lt;/code&gt; can thus persist in memory for a long time, and if a process crashes during this time, the contents of the string may end up in a memory dump or some log.</source>
          <target state="translated">Теперь сборка мусора в Java не происходит с гарантированным интервалом. Таким образом, &lt;code&gt;String&lt;/code&gt; может сохраняться в памяти в течение длительного времени, и если в течение этого времени произойдет сбой процесса, содержимое строки может оказаться в дампе памяти или в каком-либо журнале.</target>
        </trans-unit>
        <trans-unit id="009c1ad62959bdccaf0ac3c21fa53db992bb4841" translate="yes" xml:space="preserve">
          <source>On the other side char[] are mutable as soon as the authentication is done you can overwrite them with any character like all M's or backslashes. Now even if someone takes a heap dump he might not be able to get the passwords which are not currently in use. This gives you more control in the sense like clearing the Object content yourself vs waiting for the GC to do it.</source>
          <target state="translated">С другой стороны char[]являются мутируемыми,как только аутентификация завершена,вы можете перезаписать их любым символом,как все M или обратные слэши.Теперь,даже если кто-то берет кучу данных,он может не получить пароли,которые в данный момент не используются.Это дает вам больше контроля в том смысле,что вы можете очистить содержимое объекта самостоятельно,а не ждать,пока GC сделает это.</target>
        </trans-unit>
        <trans-unit id="808ddd5c0f070dc1407e36a6c3bd4a098c623be2" translate="yes" xml:space="preserve">
          <source>One scenario where the attacker could use it is a crashdump - when the JVM crashes and generates a memory dump - you will be able to see the password.</source>
          <target state="translated">Один из сценариев,в котором злоумышленник мог бы использовать его,это crashdump-когда JVM разбивается и генерирует дамп памяти-вы сможете увидеть пароль.</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="d23d8cc1d470710d96e727d64982b4e074a1ad39" translate="yes" xml:space="preserve">
          <source>Referenced from &lt;a href=&quot;http://javarevisited.blogspot.com/2012/03/why-character-array-is-better-than.html&quot;&gt;this blog&lt;/a&gt;.
I hope this helps.</source>
          <target state="translated">Ссылка из &lt;a href=&quot;http://javarevisited.blogspot.com/2012/03/why-character-array-is-better-than.html&quot;&gt;этого блога&lt;/a&gt; . Надеюсь, это поможет.</target>
        </trans-unit>
        <trans-unit id="da39838ea50b051a48f69227a80db6d3ae54cb71" translate="yes" xml:space="preserve">
          <source>Since Strings in Java are immutable, whenever some tries to manipulate your string it creates a new Object and the existing String remains unaffected. This could be seen as an advantage for storing a password as a String, but the object remains in memory even after use. So if anyone somehow got the memory location of the object, that person can easily trace your password stored at that location.</source>
          <target state="translated">Так как Строки в Java неизменны,всякий раз,когда кто-то пытается манипулировать Вашей строкой,он создает новый Объект,и существующая Строка остается незатронутой.Это можно рассматривать как преимущество хранения пароля в виде Строки,но объект остается в памяти даже после использования.Так что если кто-то каким-то образом получил место в памяти объекта,то этот человек может легко отследить ваш пароль,хранящийся в этом месте.</target>
        </trans-unit>
        <trans-unit id="6539fcd58f3cfe01d8e3345fd5cc498d2c1757ca" translate="yes" xml:space="preserve">
          <source>Since anyone who has access to the memory dump can find the password in clear text, that's another reason you should always use an encrypted password rather than plain text. Since Strings are immutable there is no way the contents of Strings can be changed because any change will produce a new String, while if you use a char[] you can still set all the elements as blank or zero. So storing a password in a character array clearly mitigates the security risk of stealing a password.</source>
          <target state="translated">Так как любой,кто имеет доступ к дампу памяти,может найти пароль открытым текстом,это еще одна причина,по которой вы всегда должны использовать зашифрованный пароль,а не простой текст.Так как Строки являются неизменяемыми,нет никакой возможности изменить содержимое Строк,потому что любое изменение приведет к появлению новой Строки,в то время как,если вы используете char[],вы все равно можете установить все элементы как пустые или нулевые.Таким образом,хранение пароля в массиве символов явно снижает риск кражи пароля.</target>
        </trans-unit>
        <trans-unit id="2adb89ba4d12684aa374a2b6fe43ad82b7834618" translate="yes" xml:space="preserve">
          <source>So yes, this &lt;em&gt;is&lt;/em&gt; a security concern - but even using &lt;code&gt;char[]&lt;/code&gt; only reduces the window of opportunity for an attacker, and it's only for this specific type of attack.</source>
          <target state="translated">Так что да, это проблема безопасности - но даже использование &lt;code&gt;char[]&lt;/code&gt; только сокращает окно возможностей для атакующего, и это только для этого конкретного типа атаки.</target>
        </trans-unit>
        <trans-unit id="1de0b546e683d80be916c3f763396811703e5bf0" translate="yes" xml:space="preserve">
          <source>Some information, such as Social Security numbers (SSNs) and
  passwords, is highly sensitive. This information should not be kept
  for longer than necessary nor where it may be seen, even by
  administrators. For instance, it should not be sent to log files and
  its presence should not be detectable through searches. Some transient
  data may be kept in mutable data structures, such as char arrays, and
  cleared immediately after use. Clearing data structures has reduced
  effectiveness on typical Java runtime systems as objects are moved in
  memory transparently to the programmer.</source>
          <target state="translated">Некоторая информация,например,номера социального страхования (SSN)и пароли,является очень конфиденциальной.Эту информацию не следует хранить дольше,чем это необходимо,и там,где ее могут увидеть даже администраторы.Например,ее не следует отправлять в лог-файлы,а ее наличие не должно быть обнаружено с помощью поиска.Некоторые переходные данные могут храниться в изменяемых структурах данных,таких как char-массивы,и очищаться сразу после использования.Очистка структур данных снизила эффективность на типичных системах исполнения Java,так как объекты перемещаются в памяти прозрачно для программиста.</target>
        </trans-unit>
        <trans-unit id="342e9eaee08708bfd19f663e2797e6c4835f202f" translate="yes" xml:space="preserve">
          <source>Some more resources on timing attacks:</source>
          <target state="translated">Еще несколько ресурсов на временные атаки:</target>
        </trans-unit>
        <trans-unit id="70ec593d69ff444a0c4f8c40a5b655665549f9ff" translate="yes" xml:space="preserve">
          <source>Some people believe that you have to overwrite the memory used to store the password once you no longer need it. This reduces the time window an attacker has to read the password from your system and completely ignores the fact that the attacker already needs enough access to hijack the JVM memory to do this. An attacker with that much access can catch your key events making this completely useless (AFAIK, so please correct me if I am wrong).</source>
          <target state="translated">Некоторые люди считают,что нужно перезаписать память,используемую для хранения пароля,когда он больше не нужен.Это сокращает время,в течение которого злоумышленнику приходится считывать пароль из вашей системы,и полностью игнорирует тот факт,что для этого злоумышленнику уже требуется достаточный доступ для взлома памяти JVM.Атакующий с таким количеством доступа может поймать ваши ключевые события,делая это совершенно бесполезным (AFAIK,поэтому,пожалуйста,поправьте меня,если я ошибаюсь).</target>
        </trans-unit>
        <trans-unit id="a15471736d5db023d6a76ce568c8d2f6f77e6fd4" translate="yes" xml:space="preserve">
          <source>String in java is immutable. So whenever a string is created, it will remain in the memory until it is garbage collected. So anyone who has access to the memory can read the value of the string.</source>
          <target state="translated">Струна в яве незыблема.Поэтому всякий раз,когда создается строка,она будет оставаться в памяти до тех пор,пока не будет собрана всякий мусор.Таким образом,любой,кто имеет доступ к памяти,может прочитать значение строки.</target>
        </trans-unit>
        <trans-unit id="70292d1b61c498137fcfe048ab768be8db94f7d9" translate="yes" xml:space="preserve">
          <source>String is immutable and it goes to the string pool. Once written, it cannot be overwritten.</source>
          <target state="translated">Строка является неизменной и попадает в пул строк.После написания она не может быть перезаписана.</target>
        </trans-unit>
        <trans-unit id="7d63b7c3c393127b2e12ff515941706150a569e2" translate="yes" xml:space="preserve">
          <source>Strings are immutable and cannot be altered once they have been created. Creating a password as a string will leave stray references to the password on the heap or on the String pool. Now if someone takes a heap dump of the Java process and carefully scans through he might be able to guess the passwords. Of course these non used strings will be garbage collected but that depends on when the GC kicks in.</source>
          <target state="translated">Строки неизменны и не могут быть изменены после их создания.Создание пароля в виде строки оставит бродячие ссылки на пароль на куче или в пуле строк.Теперь,если кто-нибудь возьмет кучу дампа Java-процесса и тщательно просканирует ее,он сможет угадать пароли.Конечно,эти неиспользуемые строки будут собраны в мусор,но это зависит от того,когда ляжет GC.</target>
        </trans-unit>
        <trans-unit id="a50bf4dfb5987fd653ea7a3d545740bdb6a92ca3" translate="yes" xml:space="preserve">
          <source>Take a look at the &lt;sub&gt;widely used&lt;/sub&gt; Spring Security library &lt;a href=&quot;http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.security/spring-security-web/3.0.1.RELEASE/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.java#73&quot;&gt;here&lt;/a&gt; and ask yourself - are Spring Security guys incompetent or char[] passwords just don't make much sense. When some nasty hacker grabs memory dumps of your RAM be sure s/he'll get all the passwords even if you use sophisticated ways to hide them.</source>
          <target state="translated">Взгляните на &lt;sub&gt;широко используемую&lt;/sub&gt; библиотеку Spring Security и спросите себя: неуместны ли пользователи Spring Security или пароли char [] просто не имеют особого смысла. Когда какой-нибудь злобный хакер захватывает дампы памяти вашей оперативной памяти, убедитесь, что он / она получит все пароли, даже если вы используете сложные способы их скрытия.</target>
        </trans-unit>
        <trans-unit id="a7a4c75efd48757679ac6c3d07cd60ad382ace9d" translate="yes" xml:space="preserve">
          <source>Thanks to the comments I have to update my answer. Apparently there are two cases where this can add a (very) minor security improvement as it reduces the time a password could land on the hard drive. Still I think it's overkill for most use cases.</source>
          <target state="translated">Благодаря комментариям я должен обновить свой ответ.Очевидно,есть два случая,когда это может добавить (очень)незначительное улучшение безопасности,так как это уменьшает время,когда пароль может приземлиться на жесткий диск.Тем не менее,я думаю,что это перебор для большинства случаев использования.</target>
        </trans-unit>
        <trans-unit id="2b26660b7b422e0609c382be6b48bf115b3c7e78" translate="yes" xml:space="preserve">
          <source>That is not necessarily a malicious external attacker. This could be a support user that has access to the server for monitoring purposes. He could peek into a crashdump and find the passwords.</source>
          <target state="translated">Это не обязательно злоумышленник извне.Это может быть пользователь службы поддержки,который имеет доступ к серверу в целях мониторинга.Он может заглянуть в crashdump и найти пароли.</target>
        </trans-unit>
        <trans-unit id="87c04911712a5eca03edfca8a7dc86c33db8574d" translate="yes" xml:space="preserve">
          <source>The OpenSSL library for example overwrites critical memory sections before private keys are freed. Since Java is garbage-collected, we would need explicit methods to wipe and invalidate private information for Java keys, which are to be applied immediately after using the key.</source>
          <target state="translated">Например,библиотека OpenSSL перезаписывает критические секции памяти перед освобождением закрытых ключей.Поскольку Java собирает мусор,нам понадобятся явные методы для стирания и аннулирования закрытой информации для Java-ключей,которые должны применяться сразу после использования ключа.</target>
        </trans-unit>
        <trans-unit id="5d904c18a0d5e2b983c5e3b0a1ec77093be40a8a" translate="yes" xml:space="preserve">
          <source>The answer has already been given, but I'd like to share an issue that I discovered lately with Java standard libraries. While they take great care now of replacing password strings with &lt;code&gt;char[]&lt;/code&gt; everywhere (which of course is a good thing), other security-critical data seems to be overlooked when it comes to clearing it from memory.</source>
          <target state="translated">Ответ уже дан, но я хотел бы поделиться проблемой, которую я обнаружил в последнее время, со стандартными библиотеками Java. Несмотря на то, что они очень внимательно относятся к замене строк пароля на &lt;code&gt;char[]&lt;/code&gt; везде (что, конечно, хорошо), другие важные для безопасности данные, похоже, упускаются из виду, когда дело доходит до очистки их из памяти.</target>
        </trans-unit>
        <trans-unit id="9cdb971985ae17b650f8064ac735ff984c433ea3" translate="yes" xml:space="preserve">
          <source>The short and straightforward answer would be because &lt;code&gt;char[]&lt;/code&gt; is mutable while &lt;code&gt;String&lt;/code&gt; objects are not.</source>
          <target state="translated">Короткий и простой ответ будет потому, что &lt;code&gt;char[]&lt;/code&gt; является изменяемым, а объекты &lt;code&gt;String&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="c831e687484a08e9210ad3468fba111f383b12f4" translate="yes" xml:space="preserve">
          <source>There is nothing that char array gives you vs String unless you clean it up manually after use, and I haven't seen anyone actually doing that. So to me the preference of char[] vs String is a bit exaggerated.</source>
          <target state="translated">Нет ничего,что дает char-массив против String,если только вы не очистите его вручную после использования,и я не видел,чтобы кто-то на самом деле делал это.Так что для меня предпочтение char[]против String немного преувеличено.</target>
        </trans-unit>
        <trans-unit id="c29c1dc60896ca5c2015a47b5d9b6fedd7054557" translate="yes" xml:space="preserve">
          <source>These are all the reasons, one should choose a &lt;strong&gt;char[]&lt;/strong&gt; array instead of &lt;strong&gt;String&lt;/strong&gt; for a password.</source>
          <target state="translated">Это все причины, для пароля следует выбрать массив &lt;strong&gt;char []&lt;/strong&gt; вместо &lt;strong&gt;String&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5fd0d8098dcf68fcf92acb8477b5a5f142c06ffb" translate="yes" xml:space="preserve">
          <source>This guideline also has implications for implementation and use of
  lower-level libraries that do not have semantic knowledge of the data
  they are dealing with. As an example, a low-level string parsing
  library may log the text it works on. An application may parse an SSN
  with the library. This creates a situation where the SSNs are
  available to administrators with access to the log files.</source>
          <target state="translated">Это руководство также имеет последствия для реализации и использования библиотек нижнего уровня,которые не обладают семантическими знаниями о данных,с которыми они имеют дело.Например,низкоуровневая библиотека для разбора строк может записывать в журнал текст,над которым она работает.Приложение может разобрать SSN с помощью библиотеки.Это создает ситуацию,когда SSN доступны администраторам,имеющим доступ к лог-файлам.</target>
        </trans-unit>
        <trans-unit id="0b542944974a2f4551f2b6ab738b0d93fd70b517" translate="yes" xml:space="preserve">
          <source>This is a bad situation, as this &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.77.3297&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;paper&lt;/a&gt; describes how this circumstance could be potentially exploited.</source>
          <target state="translated">Это плохая ситуация, так как эта &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.77.3297&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;статья&lt;/a&gt; описывает, как это обстоятельство может быть потенциально использовано.</target>
        </trans-unit>
        <trans-unit id="60a8a4000e8f0bc7de20f87190fb4c8e81516e21" translate="yes" xml:space="preserve">
          <source>This old copy wouldn't appear in a heap dump, but if you have direct access to the raw memory of the process you could see it.  In general you should avoid anyone having such access.</source>
          <target state="translated">Эта старая копия не появится в кучевой дампе,но если у вас есть прямой доступ к необработанной памяти процесса,вы можете ее увидеть.В общем,вы должны избегать любого,кто имеет такой доступ.</target>
        </trans-unit>
        <trans-unit id="9c1079be9137eb36b54da5688745bf117e61534d" translate="yes" xml:space="preserve">
          <source>To quote an official document, the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#PBEEx&quot;&gt;Java Cryptography Architecture guide&lt;/a&gt; says this about &lt;code&gt;char[]&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; passwords (about password-based encryption, but this is more generally about passwords of course):</source>
          <target state="translated">Чтобы процитировать официальный документ, в &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#PBEEx&quot;&gt;руководстве по архитектуре криптографии Java&lt;/a&gt; говорится о паролях &lt;code&gt;char[]&lt;/code&gt; и &lt;code&gt;String&lt;/code&gt; паролях (о шифровании на основе паролей, но, конечно, речь идет в основном о паролях):</target>
        </trans-unit>
        <trans-unit id="09c96217cecf5158d9c599143709c0bf43a4b916" translate="yes" xml:space="preserve">
          <source>While other suggestions here seem valid, there is one other good reason. With plain &lt;code&gt;String&lt;/code&gt; you have much higher chances of &lt;strong&gt;accidentally printing the password to logs&lt;/strong&gt;, monitors or some other insecure place. &lt;code&gt;char[]&lt;/code&gt; is less vulnerable.</source>
          <target state="translated">В то время как другие предложения здесь кажутся действительными, есть еще одна веская причина. С простой &lt;code&gt;String&lt;/code&gt; вас гораздо больше шансов &lt;strong&gt;случайно напечатать пароль в журналах&lt;/strong&gt; , мониторах или других небезопасных местах. &lt;code&gt;char[]&lt;/code&gt; менее уязвим.</target>
        </trans-unit>
        <trans-unit id="f86d971b4a867c5b4b839105b6b5d514d24257f3" translate="yes" xml:space="preserve">
          <source>Why does &lt;code&gt;String&lt;/code&gt; pose a threat to security when it comes to passwords?
It feels inconvenient to use &lt;code&gt;char[]&lt;/code&gt;.</source>
          <target state="translated">Почему &lt;code&gt;String&lt;/code&gt; представляет угрозу безопасности, когда речь идет о паролях? Использование &lt;code&gt;char[]&lt;/code&gt; неудобно.</target>
        </trans-unit>
        <trans-unit id="be87eb63b17c07d23faf558d201b11e61486e392" translate="yes" xml:space="preserve">
          <source>Why is char[] preferred over String for passwords</source>
          <target state="translated">Почему для паролей предпочитается char[],а не string.</target>
        </trans-unit>
        <trans-unit id="96c058528af12a3ec3c0a6a4356b9a336391a6da" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;character array&lt;/em&gt;, you can read the password, finish working with it as soon as you can, and then immediately change the contents.</source>
          <target state="translated">С помощью &lt;em&gt;массива символов&lt;/em&gt; вы можете прочитать пароль, закончить работу с ним, как только сможете, и сразу же изменить его содержимое.</target>
        </trans-unit>
        <trans-unit id="252e94464c28d121b2ac7065cfdc63317b907d6d" translate="yes" xml:space="preserve">
          <source>With an array, you can explicitly wipe the data after you're done with it. You can overwrite the array with anything you like, and the password won't be present anywhere in the system, even before garbage collection.</source>
          <target state="translated">С помощью массива вы можете явно стереть данные после того,как закончите работу с ними.Вы можете перезаписать массив чем угодно,и пароль не будет присутствовать нигде в системе,даже до сбора мусора.</target>
        </trans-unit>
        <trans-unit id="7b2e2713e36f214c8c2b0f0732ccc93580279e73" translate="yes" xml:space="preserve">
          <source>With the character array, the contents of the array can be modified or erased once the purpose of the password is served. The original contents of the array will not be found in memory after it is modified and even before the garbage collection kicks in.</source>
          <target state="translated">С помощью символьного массива содержимое массива можно изменить или стереть,как только будет подан пароль.Оригинальное содержимое массива не будет найдено в памяти после его модификации и еще до того,как начнется сборка мусора.</target>
        </trans-unit>
        <trans-unit id="5e436ad0706341ed15fd79a042f530dfaa544abb" translate="yes" xml:space="preserve">
          <source>Your software has to be overly paranoid to prevent data leaks with the attacker gaining access to the hardware - using things like &lt;a href=&quot;http://en.wikipedia.org/wiki/TrueCrypt&quot;&gt;TrueCrypt&lt;/a&gt; (discontinued), &lt;a href=&quot;https://veracrypt.codeplex.com/&quot;&gt;VeraCrypt&lt;/a&gt;, or &lt;a href=&quot;https://ciphershed.org/&quot;&gt;CipherShed&lt;/a&gt;.</source>
          <target state="translated">Ваше программное обеспечение должно быть чрезмерно параноидальным, чтобы предотвратить утечку данных, когда злоумышленник получит доступ к оборудованию - используя такие вещи, как &lt;a href=&quot;http://en.wikipedia.org/wiki/TrueCrypt&quot;&gt;TrueCrypt&lt;/a&gt; (прекращено), &lt;a href=&quot;https://veracrypt.codeplex.com/&quot;&gt;VeraCrypt&lt;/a&gt; или &lt;a href=&quot;https://ciphershed.org/&quot;&gt;CipherShed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6006f436777ec8eee5cc060e91d43457b96b5534" translate="yes" xml:space="preserve">
          <source>Your target system may be badly configured or you have to assume it is and you have to be paranoid about core dumps (can be valid if the systems are not managed by an administrator).</source>
          <target state="translated">Ваша целевая система может быть плохо сконфигурирована или вы должны предполагать,что это так,и вы должны быть параноиком в отношении дампов ядра (может быть действительным,если системы не управляются администратором).</target>
        </trans-unit>
        <trans-unit id="f47a56647d19f0875be1a2557456e6f93d01cc5b" translate="yes" xml:space="preserve">
          <source>when run</source>
          <target state="translated">во время бега</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
