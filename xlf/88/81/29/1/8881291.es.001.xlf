<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/8881291">
    <body>
      <group id="8881291">
        <trans-unit id="8b5cc79fdd91f3cbabe317bb10b94a8fc9da92e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.oracle.com/technetwork/java/seccodeguide-139067.html#2&quot;&gt;Guideline 2-2 of the Secure Coding Guidelines for the Java Programming Language, Version 4.0&lt;/a&gt; also says something similar (although it is originally in the context of logging):</source>
          <target state="translated">&lt;a href=&quot;http://www.oracle.com/technetwork/java/seccodeguide-139067.html#2&quot;&gt;La Pauta 2-2 de las Pautas de codificaci&amp;oacute;n segura para el lenguaje de programaci&amp;oacute;n Java, versi&amp;oacute;n 4.0&lt;/a&gt; tambi&amp;eacute;n dice algo similar (aunque originalmente se encuentra en el contexto del registro):</target>
        </trans-unit>
        <trans-unit id="e262fa514b2ff9a9cdfcbd1e05ba0e4a0e8eab24" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://security.stackexchange.com/a/83671&quot;&gt;A discussion about timing attacks&lt;/a&gt; over on Information Security Stack Exchange</source>
          <target state="translated">&lt;a href=&quot;https://security.stackexchange.com/a/83671&quot;&gt;Una discusi&amp;oacute;n sobre el tiempo de los ataques&lt;/a&gt; en el intercambio de pilas de seguridad de la informaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="546581ef303b186fcfa524db41590bb28383b19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Strings&lt;/code&gt; in Java are immutable objects. That is why they can't be modified once created, and therefore the only way for their contents to be removed from memory is to have them garbage collected. It will be only then when the memory freed by the object can be overwritten, and the data will be gone.</source>
          <target state="translated">&lt;code&gt;Strings&lt;/code&gt; en Java son objetos inmutables. Es por eso que no se pueden modificar una vez creados, y por lo tanto, la &amp;uacute;nica forma de eliminar su contenido de la memoria es recolectar basura. Ser&amp;aacute; solo entonces cuando la memoria liberada por el objeto pueda sobrescribirse y los datos se habr&amp;aacute;n ido.</target>
        </trans-unit>
        <trans-unit id="31db751b481dd56268b798ca07bdcab69947d650" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char[]&lt;/code&gt; is an array which you should overwrite once you used the password and this is how it should be done:</source>
          <target state="translated">&lt;code&gt;char[]&lt;/code&gt; es una matriz que debe sobrescribir una vez que utiliz&amp;oacute; la contrase&amp;ntilde;a y as&amp;iacute; es como debe hacerse:</target>
        </trans-unit>
        <trans-unit id="397be38dc3f561874a0b47a76aa1154fa7e83414" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Guideline 2-2: Do not log highly sensitive information&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Pauta 2-2: No registrar informaci&amp;oacute;n altamente confidencial&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dea03c5dc15d1e7cf9dfb8c1ea63a39c96a370f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt;  Since Strings are immutable in Java, if you store the password as plain text it will be available in memory until the Garbage collector clears it, and since String is used in the String pool for reusability there is a pretty high chance that it will remain in memory for a long duration, which poses a security threat.</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt; Dado que las cadenas son inmutables en Java, si almacena la contrase&amp;ntilde;a como texto sin formato, estar&amp;aacute; disponible en la memoria hasta que el recolector de basura la borre, y dado que la cadena se usa en el grupo de cadenas para su reutilizaci&amp;oacute;n, existe una posibilidad bastante alta de que lo haga permanecer en la memoria durante un per&amp;iacute;odo prolongado, lo que representa una amenaza para la seguridad.</target>
        </trans-unit>
        <trans-unit id="fa50fb41f6a3f808bb31590fb5c49da04a28ef18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt;  Java itself recommends using the getPassword() method of JPasswordField which returns a char[], instead of the deprecated getText() method which returns passwords in clear text stating security reasons. It's good to follow advice from the Java team and adhere to standards rather than going against them.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt; Java mismo recomienda usar el m&amp;eacute;todo getPassword () de JPasswordField que devuelve un char [], en lugar del m&amp;eacute;todo obsoleto getText () que devuelve las contrase&amp;ntilde;as en texto claro indicando razones de seguridad. Es bueno seguir los consejos del equipo de Java y adherirse a los est&amp;aacute;ndares en lugar de ir en contra de ellos.</target>
        </trans-unit>
        <trans-unit id="31024e792a22c2125636d2085a3babcbaad4dd64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.&lt;/strong&gt;  With String there is always a risk of printing plain text in a log file or console but if you use an Array you won't print contents of an array, but instead its memory location gets printed. Though not a real reason, it still makes sense.</source>
          <target state="translated">&lt;strong&gt;3.&lt;/strong&gt; Con String siempre existe el riesgo de imprimir texto sin formato en un archivo de registro o consola, pero si usa una matriz, no imprimir&amp;aacute; el contenido de una matriz, sino que se imprimir&amp;aacute; su ubicaci&amp;oacute;n de memoria. Aunque no es una raz&amp;oacute;n real, todav&amp;iacute;a tiene sentido.</target>
        </trans-unit>
        <trans-unit id="69b7f956cdb0d8e690f8921a39588f88b303dc69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; Coming back to this answer after a year of security research, I realize it makes the rather unfortunate implication that you would ever actually compare plaintext passwords. Please don't. &lt;a href=&quot;https://stackoverflow.com/questions/2860943/how-can-i-hash-a-password-in-java&quot;&gt;Use a secure one-way hash with a salt and a reasonable number of iterations&lt;/a&gt;. Consider using a library: this stuff is hard to get right!</source>
          <target state="translated">&lt;strong&gt;Editar:&lt;/strong&gt; Volviendo a esta respuesta despu&amp;eacute;s de un a&amp;ntilde;o de investigaci&amp;oacute;n de seguridad, me doy cuenta de que tiene la desafortunada implicaci&amp;oacute;n de que realmente comparar&amp;iacute;a las contrase&amp;ntilde;as de texto sin formato. Por favor no &lt;a href=&quot;https://stackoverflow.com/questions/2860943/how-can-i-hash-a-password-in-java&quot;&gt;Use un hash unidireccional seguro con sal y un n&amp;uacute;mero razonable de iteraciones&lt;/a&gt; . Considere usar una biblioteca: &amp;iexcl;esto es dif&amp;iacute;cil de entender!</target>
        </trans-unit>
        <trans-unit id="e60aa3b140458b9e42618bd0b3a05e257cc2dc56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original answer:&lt;/strong&gt; What about the fact that String.equals() uses &lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/lang/String.java#String.equals%28java.lang.Object%29&quot;&gt;short-circuit evaluation&lt;/a&gt;, and is therefore vulnerable to a timing attack? It may be unlikely, but you could &lt;em&gt;theoretically&lt;/em&gt; time the password comparison in order to determine the correct sequence of characters.</source>
          <target state="translated">&lt;strong&gt;Respuesta original:&lt;/strong&gt; &amp;iquest;Qu&amp;eacute; pasa con el hecho de que String.equals () utiliza la &lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/lang/String.java#String.equals%28java.lang.Object%29&quot;&gt;evaluaci&amp;oacute;n de cortocircuito&lt;/a&gt; y, por lo tanto, es vulnerable a un ataque de sincronizaci&amp;oacute;n? Puede ser improbable, pero &lt;em&gt;te&amp;oacute;ricamente&lt;/em&gt; podr&amp;iacute;a &lt;em&gt;cronometrar&lt;/em&gt; la comparaci&amp;oacute;n de la contrase&amp;ntilde;a para determinar la secuencia correcta de caracteres.</target>
        </trans-unit>
        <trans-unit id="71c1051a13130dc057ae957211603eb7b21660e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strings are immutable&lt;/strong&gt;. That means once you've created the &lt;code&gt;String&lt;/code&gt;, if another process can dump memory, there's no way (aside from &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt;) you can get rid of the data before &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;garbage collection&lt;/a&gt; kicks in.</source>
          <target state="translated">&lt;strong&gt;Las cuerdas son inmutables&lt;/strong&gt; . Eso significa que una vez que haya creado la &lt;code&gt;String&lt;/code&gt; , si otro proceso puede volcar la memoria, no hay forma (aparte de la &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflexi&amp;oacute;n&lt;/a&gt; ) de que pueda deshacerse de los datos antes de que comience la &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;recolecci&amp;oacute;n de basura&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bf1fec4ea517ac75d82aa127b348cecaa117a7d" translate="yes" xml:space="preserve">
          <source>A Lesson In Timing Attacks</source>
          <target state="translated">Una lección sobre el tiempo de los ataques</target>
        </trans-unit>
        <trans-unit id="94ac581f37ab2d56dfe8fa01845f896c48ea2c7c" translate="yes" xml:space="preserve">
          <source>And as it turns out, there is nothing that lets you clear the private information of a &lt;code&gt;PrivateKey&lt;/code&gt; from memory, because there's no API that lets you wipe the bytes that form the corresponding information.</source>
          <target state="translated">Y resulta que no hay nada que le permita borrar la informaci&amp;oacute;n privada de una &lt;code&gt;PrivateKey&lt;/code&gt; de la memoria, porque no hay una API que le permita borrar los bytes que forman la informaci&amp;oacute;n correspondiente.</target>
        </trans-unit>
        <trans-unit id="698e47ef5df7856861e6bd29ada26e30e6c56a65" translate="yes" xml:space="preserve">
          <source>And of course, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Timing_attack&quot;&gt;Timing Attack Wikipedia page&lt;/a&gt;</source>
          <target state="translated">Y, por supuesto, la &lt;a href=&quot;http://en.wikipedia.org/wiki/Timing_attack&quot;&gt;p&amp;aacute;gina Wikipedia de Timing Attack&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35879106f4ed216fdb6c73f43b27a8729c325a87" translate="yes" xml:space="preserve">
          <source>As Jon Skeet states, there is no way except by using reflection.</source>
          <target state="translated">Como afirma Jon Skeet,no hay otra manera excepto usando la reflexión.</target>
        </trans-unit>
        <trans-unit id="36331cef84c6d35142e7b76dbacd89b8ff6a7d65" translate="yes" xml:space="preserve">
          <source>As noted in the comments, it's possible that arrays being moved by the garbage collector will leave stray copies of the data in memory. I believe this is implementation-specific - the garbage collector &lt;em&gt;may&lt;/em&gt; clear all memory as it goes, to avoid this sort of thing. Even if it does, there's still the time during which the &lt;code&gt;char[]&lt;/code&gt; contains the actual characters as an attack window.</source>
          <target state="translated">Como se se&amp;ntilde;al&amp;oacute; en los comentarios, es posible que las matrices que mueve el recolector de basura dejar&amp;aacute;n copias perdidas de los datos en la memoria. Creo que esto es espec&amp;iacute;fico de la implementaci&amp;oacute;n: el recolector de basura &lt;em&gt;puede&lt;/em&gt; borrar toda la memoria a medida que avanza, para evitar este tipo de cosas. Incluso si lo hace, todav&amp;iacute;a hay un tiempo durante el cual el &lt;code&gt;char[]&lt;/code&gt; contiene los caracteres reales como una ventana de ataque.</target>
        </trans-unit>
        <trans-unit id="ea94246ffb44ab6b727efb8d392dd9232ef47c1b" translate="yes" xml:space="preserve">
          <source>Based on the above circumstances, one can get an idea whether to go with String or to go with Char[] for their requirements.</source>
          <target state="translated">Basándose en las circunstancias anteriores,uno puede hacerse una idea de si ir con String o con Char[]para sus necesidades.</target>
        </trans-unit>
        <trans-unit id="ff08257691f084f5bb4321a9521146f84621c841" translate="yes" xml:space="preserve">
          <source>Because of the security concern it is better to store password as a character array.</source>
          <target state="translated">Debido a la preocupación por la seguridad es mejor almacenar la contraseña como una matriz de caracteres.</target>
        </trans-unit>
        <trans-unit id="fc94856bbf7a5446009d35b73ca294f9cc65c6ce" translate="yes" xml:space="preserve">
          <source>But that alone isn't a good answer; why not just make sure a reference to the &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; doesn't escape? Then there's no security issue. But the thing is that &lt;code&gt;String&lt;/code&gt; objects can be &lt;code&gt;intern()&lt;/code&gt;ed in theory and kept alive inside the constant pool. I suppose using &lt;code&gt;char[]&lt;/code&gt; forbids this possibility.</source>
          <target state="translated">Pero eso solo no es una buena respuesta; &amp;iquest;por qu&amp;eacute; no solo asegurarse de que no se escape una referencia al &lt;code&gt;char[]&lt;/code&gt; o &lt;code&gt;String&lt;/code&gt; ? Entonces no hay problema de seguridad. Pero la cuesti&amp;oacute;n es que los objetos &lt;code&gt;String&lt;/code&gt; pueden ser &lt;code&gt;intern()&lt;/code&gt; en teor&amp;iacute;a y mantenerse vivos dentro del grupo constante. Supongo que usar &lt;code&gt;char[]&lt;/code&gt; proh&amp;iacute;be esta posibilidad.</target>
        </trans-unit>
        <trans-unit id="f7b798d770ca2df60818ef3a16e84e4d0302362b" translate="yes" xml:space="preserve">
          <source>Char[] is mutable, but it has the advantage that after its usage the programmer can explicitly clean the array or override values. So when it's done being used it is cleaned and no one could ever know about the information you had stored.</source>
          <target state="translated">Char[]es mutable,pero tiene la ventaja de que después de su uso el programador puede explícitamente limpiar la matriz o anular los valores.Así que cuando termina de ser usado se limpia y nadie puede saber nunca sobre la información que ha almacenado.</target>
        </trans-unit>
        <trans-unit id="f2d5fad3855bcb5cf79c403b8fae8134166583c5" translate="yes" xml:space="preserve">
          <source>Character arrays (&lt;code&gt;char[]&lt;/code&gt;) can be cleared after use by setting each character to zero and Strings not. If someone can somehow see the memory image, they can see a password in plain text if Strings are used, but if &lt;code&gt;char[]&lt;/code&gt; is used, after purging data with 0's, the password is secure.</source>
          <target state="translated">Las matrices de caracteres ( &lt;code&gt;char[]&lt;/code&gt; ) se pueden borrar despu&amp;eacute;s del uso al establecer cada car&amp;aacute;cter en cero y las cadenas no. Si alguien puede ver de alguna manera la imagen de la memoria, puede ver una contrase&amp;ntilde;a en texto sin formato si se usan Strings, pero si se usa &lt;code&gt;char[]&lt;/code&gt; , despu&amp;eacute;s de purgar los datos con 0, la contrase&amp;ntilde;a es segura.</target>
        </trans-unit>
        <trans-unit id="fe2e10fde78683521d4003ae2215af5b39ef6231" translate="yes" xml:space="preserve">
          <source>Consider this:</source>
          <target state="translated">Considere esto:</target>
        </trans-unit>
        <trans-unit id="61da8effd39d181e7d2fbf216216c68b5d82129d" translate="yes" xml:space="preserve">
          <source>However, Java changes all the time, and some scary features like &lt;a href=&quot;https://stackoverflow.com/questions/27949213/string-deduplication-feature-of-java-8&quot;&gt;String Deduplication feature of Java 8&lt;/a&gt; might intern String objects without your knowledge. But that's a different conversation.</source>
          <target state="translated">Sin embargo, Java cambia todo el tiempo, y algunas caracter&amp;iacute;sticas aterradoras como &lt;a href=&quot;https://stackoverflow.com/questions/27949213/string-deduplication-feature-of-java-8&quot;&gt;la caracter&amp;iacute;stica de deduplicaci&amp;oacute;n de cadenas de Java 8&lt;/a&gt; pueden internar objetos de cadenas sin su conocimiento. Pero esa es una conversaci&amp;oacute;n diferente.</target>
        </trans-unit>
        <trans-unit id="4085390bb3f3a972df1be47fd22afa929e468c7e" translate="yes" xml:space="preserve">
          <source>However, if reflection is an option for you, you can do this.</source>
          <target state="translated">Sin embargo,si la reflexión es una opción para ti,puedes hacerlo.</target>
        </trans-unit>
        <trans-unit id="2ce1845c70b9dc4de0441f1a0e5b0d33534ff75d" translate="yes" xml:space="preserve">
          <source>I don't think this is a valid suggestion, but, I can at least guess at the reason.</source>
          <target state="translated">No creo que sea una sugerencia válida,pero,al menos puedo adivinar la razón.</target>
        </trans-unit>
        <trans-unit id="151bc7b0c4f1b70bc4b73e26ef103e85b31bf68d" translate="yes" xml:space="preserve">
          <source>I think the motivation is wanting to make sure that you can erase all trace of the password in memory promptly and with certainty after it is used. With a &lt;code&gt;char[]&lt;/code&gt; you could overwrite each element of the array with a blank or something for sure. You can't edit the internal value of a &lt;code&gt;String&lt;/code&gt; that way.</source>
          <target state="translated">Creo que la motivaci&amp;oacute;n es querer asegurarse de que puede borrar todo rastro de la contrase&amp;ntilde;a en la memoria de manera r&amp;aacute;pida y segura despu&amp;eacute;s de su uso. Con un &lt;code&gt;char[]&lt;/code&gt; podr&amp;iacute;a sobrescribir cada elemento de la matriz con un espacio en blanco o algo seguro. No puede editar el valor interno de una &lt;code&gt;String&lt;/code&gt; esa manera.</target>
        </trans-unit>
        <trans-unit id="ac37450fb5de9b14d5b22b707a61b326fc006e75" translate="yes" xml:space="preserve">
          <source>I'm thinking of e.g. the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/security/PrivateKey.html&quot;&gt;PrivateKey&lt;/a&gt; class. Consider a scenario where you would load a private RSA key from a PKCS#12 file, using it to perform some operation. Now in this case, sniffing the password alone wouldn't help you much as long as physical access to the key file is properly restricted. As an attacker, you would be much better off if you obtained the key directly instead of the password. The desired information can be leaked manifold, core dumps, a debugger session or swap files are just some examples.</source>
          <target state="translated">Estoy pensando, por ejemplo, en la clase &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/security/PrivateKey.html&quot;&gt;PrivateKey&lt;/a&gt; . Considere un escenario en el que cargar&amp;iacute;a una clave RSA privada desde un archivo PKCS # 12, utiliz&amp;aacute;ndola para realizar alguna operaci&amp;oacute;n. Ahora, en este caso, solo rastrear la contrase&amp;ntilde;a no lo ayudar&amp;iacute;a siempre y cuando el acceso f&amp;iacute;sico al archivo de clave est&amp;eacute; restringido correctamente. Como atacante, estar&amp;iacute;a mucho mejor si obtuviera la clave directamente en lugar de la contrase&amp;ntilde;a. La informaci&amp;oacute;n deseada puede ser filtrada, volcados de n&amp;uacute;cleo, una sesi&amp;oacute;n de depurador o archivos de intercambio son solo algunos ejemplos.</target>
        </trans-unit>
        <trans-unit id="57001b779997c68b84ea322da58afc3b9aee11b7" translate="yes" xml:space="preserve">
          <source>If possible, disabling core dumps and the swap file would take care of both problems. However, they would require administrator rights and may reduce functionality (less memory to use) and pulling RAM from a running system would still be a valid concern.</source>
          <target state="translated">Si es posible,deshabilitar los volcados de núcleo y el archivo de intercambio se encargaría de ambos problemas.Sin embargo,requerirían derechos de administrador y podrían reducir la funcionalidad (menos memoria para utilizar)y extraer la memoria RAM de un sistema en ejecución seguiría siendo una preocupación válida.</target>
        </trans-unit>
        <trans-unit id="33fe3db7ec48beac0c68de9fcd8d0c76bda59e6e" translate="yes" xml:space="preserve">
          <source>If the value of the string is modified then it will end up creating a new string. So both the original value and the modified value stay in the memory until it is garbage collected.</source>
          <target state="translated">Si el valor de la cadena se modifica,entonces terminará creando una nueva cadena.Así que tanto el valor original como el valor modificado permanecen en la memoria hasta que se recoge la basura.</target>
        </trans-unit>
        <trans-unit id="914d4c3b06c646d3115826f9e7120eefcb75df0a" translate="yes" xml:space="preserve">
          <source>In Swing, the password field has a &lt;code&gt;getPassword()&lt;/code&gt; (returns &lt;code&gt;char[]&lt;/code&gt;) method instead of the usual &lt;code&gt;getText()&lt;/code&gt; (returns &lt;code&gt;String&lt;/code&gt;) method. Similarly, I have come across a suggestion not to use &lt;code&gt;String&lt;/code&gt; to handle passwords.</source>
          <target state="translated">En Swing, el campo de contrase&amp;ntilde;a tiene un &lt;code&gt;getPassword()&lt;/code&gt; (devuelve &lt;code&gt;char[]&lt;/code&gt; ) en lugar del m&amp;eacute;todo habitual &lt;code&gt;getText()&lt;/code&gt; (devuelve &lt;code&gt;String&lt;/code&gt; ). Del mismo modo, me he encontrado con una sugerencia de no usar &lt;code&gt;String&lt;/code&gt; para manejar contrase&amp;ntilde;as.</target>
        </trans-unit>
        <trans-unit id="f3e385fc6478055a321c64cb02009cc9d7e54bd6" translate="yes" xml:space="preserve">
          <source>It is debatable as to whether you should use String or use Char[] for this purpose because both have their advantages and disadvantages. It depends on what the user needs.</source>
          <target state="translated">Es discutible si se debe usar String o Char[]para este propósito porque ambos tienen sus ventajas y desventajas.Depende de lo que el usuario necesite.</target>
        </trans-unit>
        <trans-unit id="6892d03a0b1a14ba14ef1fe5bba377b5df3f74f4" translate="yes" xml:space="preserve">
          <source>It would seem logical to collect and store the password in an object
  of type &lt;code&gt;java.lang.String&lt;/code&gt;. However, here's the caveat: &lt;code&gt;Object&lt;/code&gt;s of
  type &lt;code&gt;String&lt;/code&gt; are immutable, i.e., there are no methods defined that
  allow you to change (overwrite) or zero out the contents of a &lt;code&gt;String&lt;/code&gt;
  after usage. This feature makes &lt;code&gt;String&lt;/code&gt; objects unsuitable for
  storing security sensitive information such as user passwords. You
  should always collect and store security sensitive information in a
  &lt;code&gt;char&lt;/code&gt; array instead.</source>
          <target state="translated">Parece l&amp;oacute;gico recopilar y almacenar la contrase&amp;ntilde;a en un objeto de tipo &lt;code&gt;java.lang.String&lt;/code&gt; . Sin embargo, esta es la advertencia: los &lt;code&gt;Object&lt;/code&gt; de tipo &lt;code&gt;String&lt;/code&gt; son inmutables, es decir, no hay m&amp;eacute;todos definidos que le permitan cambiar (sobrescribir) o poner a cero el contenido de una &lt;code&gt;String&lt;/code&gt; despu&amp;eacute;s del uso. Esta caracter&amp;iacute;stica hace que los objetos &lt;code&gt;String&lt;/code&gt; no sean adecuados para almacenar informaci&amp;oacute;n confidencial de seguridad, como las contrase&amp;ntilde;as de los usuarios. En su lugar, siempre debe recopilar y almacenar informaci&amp;oacute;n confidencial de seguridad en una matriz de caracteres.</target>
        </trans-unit>
        <trans-unit id="8684c3b4018676a3106d93184438755a93bce417" translate="yes" xml:space="preserve">
          <source>Note: if the String's char[] has been copied as a part of a GC cycle, there is a chance the previous copy is somewhere in memory.</source>
          <target state="translated">Nota:si el char[]de la Cadena ha sido copiado como parte de un ciclo de GC,existe la posibilidad de que la copia anterior esté en algún lugar de la memoria.</target>
        </trans-unit>
        <trans-unit id="a4510da9e949f0f4ef9576982abd7e611df40556" translate="yes" xml:space="preserve">
          <source>Now garbage collection in Java doesn't happen at any guaranteed interval. The &lt;code&gt;String&lt;/code&gt; can thus persist in memory for a long time, and if a process crashes during this time, the contents of the string may end up in a memory dump or some log.</source>
          <target state="translated">Ahora la recolecci&amp;oacute;n de basura en Java no ocurre en ning&amp;uacute;n intervalo garantizado. Por lo tanto, la &lt;code&gt;String&lt;/code&gt; puede persistir en la memoria durante mucho tiempo, y si un proceso se bloquea durante este tiempo, el contenido de la cadena puede terminar en un volcado de memoria o alg&amp;uacute;n registro.</target>
        </trans-unit>
        <trans-unit id="009c1ad62959bdccaf0ac3c21fa53db992bb4841" translate="yes" xml:space="preserve">
          <source>On the other side char[] are mutable as soon as the authentication is done you can overwrite them with any character like all M's or backslashes. Now even if someone takes a heap dump he might not be able to get the passwords which are not currently in use. This gives you more control in the sense like clearing the Object content yourself vs waiting for the GC to do it.</source>
          <target state="translated">En el otro lado los caracteres[]son mutables tan pronto como se hace la autentificación,puedes sobreescribirlos con cualquier carácter como todas las M o barras invertidas.Ahora bien,incluso si alguien hace un volcado de pila,podría no ser capaz de obtener las contraseñas que no están actualmente en uso.Esto te da más control en el sentido de limpiar el contenido del objeto por ti mismo vs.esperar a que el GC lo haga.</target>
        </trans-unit>
        <trans-unit id="808ddd5c0f070dc1407e36a6c3bd4a098c623be2" translate="yes" xml:space="preserve">
          <source>One scenario where the attacker could use it is a crashdump - when the JVM crashes and generates a memory dump - you will be able to see the password.</source>
          <target state="translated">Un escenario en el que el atacante podría usarlo es un crashdump-cuando la JVM se bloquea y genera un volcado de memoria-podrás ver la contraseña.</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="d23d8cc1d470710d96e727d64982b4e074a1ad39" translate="yes" xml:space="preserve">
          <source>Referenced from &lt;a href=&quot;http://javarevisited.blogspot.com/2012/03/why-character-array-is-better-than.html&quot;&gt;this blog&lt;/a&gt;.
I hope this helps.</source>
          <target state="translated">Referenciado desde &lt;a href=&quot;http://javarevisited.blogspot.com/2012/03/why-character-array-is-better-than.html&quot;&gt;este blog&lt;/a&gt; . Espero que esto ayude.</target>
        </trans-unit>
        <trans-unit id="da39838ea50b051a48f69227a80db6d3ae54cb71" translate="yes" xml:space="preserve">
          <source>Since Strings in Java are immutable, whenever some tries to manipulate your string it creates a new Object and the existing String remains unaffected. This could be seen as an advantage for storing a password as a String, but the object remains in memory even after use. So if anyone somehow got the memory location of the object, that person can easily trace your password stored at that location.</source>
          <target state="translated">Como las cadenas en Java son inmutables,cada vez que alguien intenta manipular su cadena crea un nuevo objeto y la cadena existente no se ve afectada.Esto podría ser visto como una ventaja para almacenar una contraseña como una Cadena,pero el objeto permanece en la memoria incluso después de su uso.Así que si alguien de alguna manera consiguió la ubicación de memoria del objeto,esa persona puede rastrear fácilmente tu contraseña almacenada en esa ubicación.</target>
        </trans-unit>
        <trans-unit id="6539fcd58f3cfe01d8e3345fd5cc498d2c1757ca" translate="yes" xml:space="preserve">
          <source>Since anyone who has access to the memory dump can find the password in clear text, that's another reason you should always use an encrypted password rather than plain text. Since Strings are immutable there is no way the contents of Strings can be changed because any change will produce a new String, while if you use a char[] you can still set all the elements as blank or zero. So storing a password in a character array clearly mitigates the security risk of stealing a password.</source>
          <target state="translated">Dado que cualquiera que tenga acceso al volcado de memoria puede encontrar la contraseña en texto claro,esa es otra razón por la que siempre se debe utilizar una contraseña cifrada en lugar de texto plano.Como las cadenas son inmutables no hay forma de que el contenido de las mismas pueda ser cambiado porque cualquier cambio producirá una nueva cadena,mientras que si usas un char[]todavía puedes poner todos los elementos como en blanco o en cero.Por lo tanto,almacenar una contraseña en una matriz de caracteres claramente mitiga el riesgo de seguridad de robar una contraseña.</target>
        </trans-unit>
        <trans-unit id="2adb89ba4d12684aa374a2b6fe43ad82b7834618" translate="yes" xml:space="preserve">
          <source>So yes, this &lt;em&gt;is&lt;/em&gt; a security concern - but even using &lt;code&gt;char[]&lt;/code&gt; only reduces the window of opportunity for an attacker, and it's only for this specific type of attack.</source>
          <target state="translated">Entonces, s&amp;iacute;, esto &lt;em&gt;es&lt;/em&gt; un problema de seguridad, pero incluso usar &lt;code&gt;char[]&lt;/code&gt; solo reduce la ventana de oportunidad para un atacante, y es solo para este tipo espec&amp;iacute;fico de ataque.</target>
        </trans-unit>
        <trans-unit id="1de0b546e683d80be916c3f763396811703e5bf0" translate="yes" xml:space="preserve">
          <source>Some information, such as Social Security numbers (SSNs) and
  passwords, is highly sensitive. This information should not be kept
  for longer than necessary nor where it may be seen, even by
  administrators. For instance, it should not be sent to log files and
  its presence should not be detectable through searches. Some transient
  data may be kept in mutable data structures, such as char arrays, and
  cleared immediately after use. Clearing data structures has reduced
  effectiveness on typical Java runtime systems as objects are moved in
  memory transparently to the programmer.</source>
          <target state="translated">Alguna información,como los números de seguro social (SSN)y las contraseñas,es altamente sensible.Esta información no debe guardarse más tiempo del necesario ni donde pueda ser vista,incluso por los administradores.Por ejemplo,no debe enviarse a los archivos de registro y su presencia no debe ser detectable a través de búsquedas.Algunos datos transitorios pueden conservarse en estructuras de datos mutables,como las matrices de caracteres,y eliminarse inmediatamente después de su uso.La eliminación de las estructuras de datos ha reducido la eficacia en los sistemas típicos de ejecución de Java,ya que los objetos se mueven en la memoria de forma transparente para el programador.</target>
        </trans-unit>
        <trans-unit id="342e9eaee08708bfd19f663e2797e6c4835f202f" translate="yes" xml:space="preserve">
          <source>Some more resources on timing attacks:</source>
          <target state="translated">Algunos recursos más sobre los ataques de tiempo:</target>
        </trans-unit>
        <trans-unit id="70ec593d69ff444a0c4f8c40a5b655665549f9ff" translate="yes" xml:space="preserve">
          <source>Some people believe that you have to overwrite the memory used to store the password once you no longer need it. This reduces the time window an attacker has to read the password from your system and completely ignores the fact that the attacker already needs enough access to hijack the JVM memory to do this. An attacker with that much access can catch your key events making this completely useless (AFAIK, so please correct me if I am wrong).</source>
          <target state="translated">Algunas personas creen que hay que sobrescribir la memoria utilizada para almacenar la contraseña una vez que ya no se necesita.Esto reduce la ventana de tiempo que un atacante tiene para leer la contraseña de su sistema e ignora por completo el hecho de que el atacante ya necesita suficiente acceso para secuestrar la memoria de la JVM para hacer esto.Un atacante con tanto acceso puede captar sus eventos clave haciendo esto completamente inútil (AFAIK,así que por favor corríjame si me equivoco).</target>
        </trans-unit>
        <trans-unit id="a15471736d5db023d6a76ce568c8d2f6f77e6fd4" translate="yes" xml:space="preserve">
          <source>String in java is immutable. So whenever a string is created, it will remain in the memory until it is garbage collected. So anyone who has access to the memory can read the value of the string.</source>
          <target state="translated">La cuerda en el java es inmutable.Así que cada vez que se crea una cadena,permanecerá en la memoria hasta que se recoja la basura.Así que cualquiera que tenga acceso a la memoria puede leer el valor de la cadena.</target>
        </trans-unit>
        <trans-unit id="70292d1b61c498137fcfe048ab768be8db94f7d9" translate="yes" xml:space="preserve">
          <source>String is immutable and it goes to the string pool. Once written, it cannot be overwritten.</source>
          <target state="translated">La cuerda es inmutable y va a la piscina de cuerdas.Una vez escrita,no puede ser sobrescrita.</target>
        </trans-unit>
        <trans-unit id="7d63b7c3c393127b2e12ff515941706150a569e2" translate="yes" xml:space="preserve">
          <source>Strings are immutable and cannot be altered once they have been created. Creating a password as a string will leave stray references to the password on the heap or on the String pool. Now if someone takes a heap dump of the Java process and carefully scans through he might be able to guess the passwords. Of course these non used strings will be garbage collected but that depends on when the GC kicks in.</source>
          <target state="translated">Las cuerdas son inmutables y no pueden ser alteradas una vez que han sido creadas.La creación de una contraseña como una cadena dejará referencias perdidas a la contraseña en el montón o en la piscina de cadenas.Ahora,si alguien hace un volcado del proceso de Java y lo escanea cuidadosamente,podría ser capaz de adivinar las contraseñas.Por supuesto que estas cadenas no utilizadas serán basura recogida,pero eso depende de cuando el GC se ponga en marcha.</target>
        </trans-unit>
        <trans-unit id="a50bf4dfb5987fd653ea7a3d545740bdb6a92ca3" translate="yes" xml:space="preserve">
          <source>Take a look at the &lt;sub&gt;widely used&lt;/sub&gt; Spring Security library &lt;a href=&quot;http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.security/spring-security-web/3.0.1.RELEASE/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.java#73&quot;&gt;here&lt;/a&gt; and ask yourself - are Spring Security guys incompetent or char[] passwords just don't make much sense. When some nasty hacker grabs memory dumps of your RAM be sure s/he'll get all the passwords even if you use sophisticated ways to hide them.</source>
          <target state="translated">Eche un vistazo a la biblioteca Spring Security &lt;sub&gt;ampliamente utilizada&lt;/sub&gt; &lt;a href=&quot;http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.security/spring-security-web/3.0.1.RELEASE/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.java#73&quot;&gt;aqu&amp;iacute;&lt;/a&gt; y preg&amp;uacute;ntese: &amp;iquest;son incompetentes los tipos de Spring Security o las contrase&amp;ntilde;as char [] simplemente no tienen mucho sentido? Cuando un pirata inform&amp;aacute;tico desagradable toma volcados de memoria de su RAM, aseg&amp;uacute;rese de obtener todas las contrase&amp;ntilde;as, incluso si utiliza formas sofisticadas para ocultarlas.</target>
        </trans-unit>
        <trans-unit id="a7a4c75efd48757679ac6c3d07cd60ad382ace9d" translate="yes" xml:space="preserve">
          <source>Thanks to the comments I have to update my answer. Apparently there are two cases where this can add a (very) minor security improvement as it reduces the time a password could land on the hard drive. Still I think it's overkill for most use cases.</source>
          <target state="translated">Gracias a los comentarios tengo que actualizar mi respuesta.Aparentemente hay dos casos en los que esto puede añadir una (muy)pequeña mejora de seguridad,ya que reduce el tiempo en que una contraseña podría aterrizar en el disco duro.Aún así creo que es exagerado para la mayoría de los casos de uso.</target>
        </trans-unit>
        <trans-unit id="2b26660b7b422e0609c382be6b48bf115b3c7e78" translate="yes" xml:space="preserve">
          <source>That is not necessarily a malicious external attacker. This could be a support user that has access to the server for monitoring purposes. He could peek into a crashdump and find the passwords.</source>
          <target state="translated">No se trata necesariamente de un atacante externo malintencionado.Podría ser un usuario de apoyo que tiene acceso al servidor con fines de vigilancia.Podría echar un vistazo a un crashdump y encontrar las contraseñas.</target>
        </trans-unit>
        <trans-unit id="87c04911712a5eca03edfca8a7dc86c33db8574d" translate="yes" xml:space="preserve">
          <source>The OpenSSL library for example overwrites critical memory sections before private keys are freed. Since Java is garbage-collected, we would need explicit methods to wipe and invalidate private information for Java keys, which are to be applied immediately after using the key.</source>
          <target state="translated">La biblioteca OpenSSL,por ejemplo,sobrescribe las secciones de memoria crítica antes de que se liberen las claves privadas.Como Java es una basura,necesitaríamos métodos explícitos para borrar e invalidar la información privada de las claves de Java,que deben aplicarse inmediatamente después de usar la clave.</target>
        </trans-unit>
        <trans-unit id="5d904c18a0d5e2b983c5e3b0a1ec77093be40a8a" translate="yes" xml:space="preserve">
          <source>The answer has already been given, but I'd like to share an issue that I discovered lately with Java standard libraries. While they take great care now of replacing password strings with &lt;code&gt;char[]&lt;/code&gt; everywhere (which of course is a good thing), other security-critical data seems to be overlooked when it comes to clearing it from memory.</source>
          <target state="translated">La respuesta ya se ha dado, pero me gustar&amp;iacute;a compartir un problema que descubr&amp;iacute; &amp;uacute;ltimamente con las bibliotecas est&amp;aacute;ndar de Java. Si bien ahora tienen mucho cuidado de reemplazar las cadenas de contrase&amp;ntilde;a con &lt;code&gt;char[]&lt;/code&gt; todas partes (lo cual, por supuesto, es algo bueno), otros datos cr&amp;iacute;ticos de seguridad parecen pasarse por alto cuando se trata de borrarlos de la memoria.</target>
        </trans-unit>
        <trans-unit id="9cdb971985ae17b650f8064ac735ff984c433ea3" translate="yes" xml:space="preserve">
          <source>The short and straightforward answer would be because &lt;code&gt;char[]&lt;/code&gt; is mutable while &lt;code&gt;String&lt;/code&gt; objects are not.</source>
          <target state="translated">La respuesta corta y directa ser&amp;iacute;a porque &lt;code&gt;char[]&lt;/code&gt; es mutable mientras que los objetos &lt;code&gt;String&lt;/code&gt; no lo son.</target>
        </trans-unit>
        <trans-unit id="c831e687484a08e9210ad3468fba111f383b12f4" translate="yes" xml:space="preserve">
          <source>There is nothing that char array gives you vs String unless you clean it up manually after use, and I haven't seen anyone actually doing that. So to me the preference of char[] vs String is a bit exaggerated.</source>
          <target state="translated">No hay nada que la matriz de caracteres te dé vs.String a menos que lo limpies manualmente después de usarlo,y no he visto a nadie que lo haga.Así que para mí la preferencia de char[]vs String es un poco exagerada.</target>
        </trans-unit>
        <trans-unit id="c29c1dc60896ca5c2015a47b5d9b6fedd7054557" translate="yes" xml:space="preserve">
          <source>These are all the reasons, one should choose a &lt;strong&gt;char[]&lt;/strong&gt; array instead of &lt;strong&gt;String&lt;/strong&gt; for a password.</source>
          <target state="translated">Estas son todas las razones, uno debe elegir una matriz &lt;strong&gt;char [] en&lt;/strong&gt; lugar de &lt;strong&gt;String&lt;/strong&gt; para una contrase&amp;ntilde;a.</target>
        </trans-unit>
        <trans-unit id="5fd0d8098dcf68fcf92acb8477b5a5f142c06ffb" translate="yes" xml:space="preserve">
          <source>This guideline also has implications for implementation and use of
  lower-level libraries that do not have semantic knowledge of the data
  they are dealing with. As an example, a low-level string parsing
  library may log the text it works on. An application may parse an SSN
  with the library. This creates a situation where the SSNs are
  available to administrators with access to the log files.</source>
          <target state="translated">Esta directriz también tiene repercusiones en la aplicación y el uso de las bibliotecas de nivel inferior que no tienen un conocimiento semántico de los datos que están tratando.Por ejemplo,una biblioteca de análisis de cadenas de bajo nivel puede registrar el texto con el que trabaja.Una aplicación puede analizar un SSN con la biblioteca.Esto crea una situación en la que los SSN están disponibles para los administradores con acceso a los archivos de registro.</target>
        </trans-unit>
        <trans-unit id="0b542944974a2f4551f2b6ab738b0d93fd70b517" translate="yes" xml:space="preserve">
          <source>This is a bad situation, as this &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.77.3297&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;paper&lt;/a&gt; describes how this circumstance could be potentially exploited.</source>
          <target state="translated">Esta es una mala situaci&amp;oacute;n, ya que este &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.77.3297&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;documento&lt;/a&gt; describe c&amp;oacute;mo esta circunstancia podr&amp;iacute;a ser potencialmente explotada.</target>
        </trans-unit>
        <trans-unit id="60a8a4000e8f0bc7de20f87190fb4c8e81516e21" translate="yes" xml:space="preserve">
          <source>This old copy wouldn't appear in a heap dump, but if you have direct access to the raw memory of the process you could see it.  In general you should avoid anyone having such access.</source>
          <target state="translated">Esta vieja copia no aparecería en un vertedero de basura,pero si tienes acceso directo a la memoria en bruto del proceso podrías verla.En general,deberías evitar que alguien tenga ese acceso.</target>
        </trans-unit>
        <trans-unit id="9c1079be9137eb36b54da5688745bf117e61534d" translate="yes" xml:space="preserve">
          <source>To quote an official document, the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#PBEEx&quot;&gt;Java Cryptography Architecture guide&lt;/a&gt; says this about &lt;code&gt;char[]&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; passwords (about password-based encryption, but this is more generally about passwords of course):</source>
          <target state="translated">Para citar un documento oficial, la &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#PBEEx&quot;&gt;gu&amp;iacute;a de Java Cryptography Architecture&lt;/a&gt; dice esto sobre las contrase&amp;ntilde;as &lt;code&gt;char[]&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; (sobre el cifrado basado en contrase&amp;ntilde;a, pero esto es m&amp;aacute;s general sobre las contrase&amp;ntilde;as, por supuesto):</target>
        </trans-unit>
        <trans-unit id="09c96217cecf5158d9c599143709c0bf43a4b916" translate="yes" xml:space="preserve">
          <source>While other suggestions here seem valid, there is one other good reason. With plain &lt;code&gt;String&lt;/code&gt; you have much higher chances of &lt;strong&gt;accidentally printing the password to logs&lt;/strong&gt;, monitors or some other insecure place. &lt;code&gt;char[]&lt;/code&gt; is less vulnerable.</source>
          <target state="translated">Si bien otras sugerencias aqu&amp;iacute; parecen v&amp;aacute;lidas, hay otra buena raz&amp;oacute;n. Con &lt;code&gt;String&lt;/code&gt; simple, tiene muchas m&amp;aacute;s posibilidades de &lt;strong&gt;imprimir accidentalmente la contrase&amp;ntilde;a en registros&lt;/strong&gt; , monitores u otro lugar inseguro. &lt;code&gt;char[]&lt;/code&gt; es menos vulnerable.</target>
        </trans-unit>
        <trans-unit id="f86d971b4a867c5b4b839105b6b5d514d24257f3" translate="yes" xml:space="preserve">
          <source>Why does &lt;code&gt;String&lt;/code&gt; pose a threat to security when it comes to passwords?
It feels inconvenient to use &lt;code&gt;char[]&lt;/code&gt;.</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; &lt;code&gt;String&lt;/code&gt; representa una amenaza para la seguridad cuando se trata de contrase&amp;ntilde;as? Se siente inconveniente usar &lt;code&gt;char[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be87eb63b17c07d23faf558d201b11e61486e392" translate="yes" xml:space="preserve">
          <source>Why is char[] preferred over String for passwords</source>
          <target state="translated">¿Por qué se prefiere char[]a String para las contraseñas</target>
        </trans-unit>
        <trans-unit id="96c058528af12a3ec3c0a6a4356b9a336391a6da" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;character array&lt;/em&gt;, you can read the password, finish working with it as soon as you can, and then immediately change the contents.</source>
          <target state="translated">Con una &lt;em&gt;matriz de caracteres&lt;/em&gt; , puede leer la contrase&amp;ntilde;a, terminar de trabajar con ella tan pronto como sea posible y luego cambiar de inmediato el contenido.</target>
        </trans-unit>
        <trans-unit id="252e94464c28d121b2ac7065cfdc63317b907d6d" translate="yes" xml:space="preserve">
          <source>With an array, you can explicitly wipe the data after you're done with it. You can overwrite the array with anything you like, and the password won't be present anywhere in the system, even before garbage collection.</source>
          <target state="translated">Con una matriz,puedes borrar los datos explícitamente después de que hayas terminado con ellos.Puedes sobreescribir la matriz con lo que quieras,y la contraseña no estará presente en ninguna parte del sistema,incluso antes de la recogida de basura.</target>
        </trans-unit>
        <trans-unit id="7b2e2713e36f214c8c2b0f0732ccc93580279e73" translate="yes" xml:space="preserve">
          <source>With the character array, the contents of the array can be modified or erased once the purpose of the password is served. The original contents of the array will not be found in memory after it is modified and even before the garbage collection kicks in.</source>
          <target state="translated">Con la matriz de caracteres,el contenido de la matriz puede ser modificado o borrado una vez que se cumple el propósito de la contraseña.El contenido original de la matriz no se encontrará en la memoria después de ser modificada e incluso antes de que la recogida de basura se ponga en marcha.</target>
        </trans-unit>
        <trans-unit id="5e436ad0706341ed15fd79a042f530dfaa544abb" translate="yes" xml:space="preserve">
          <source>Your software has to be overly paranoid to prevent data leaks with the attacker gaining access to the hardware - using things like &lt;a href=&quot;http://en.wikipedia.org/wiki/TrueCrypt&quot;&gt;TrueCrypt&lt;/a&gt; (discontinued), &lt;a href=&quot;https://veracrypt.codeplex.com/&quot;&gt;VeraCrypt&lt;/a&gt;, or &lt;a href=&quot;https://ciphershed.org/&quot;&gt;CipherShed&lt;/a&gt;.</source>
          <target state="translated">Su software debe ser demasiado paranoico para evitar fugas de datos con el atacante obteniendo acceso al hardware, utilizando cosas como &lt;a href=&quot;http://en.wikipedia.org/wiki/TrueCrypt&quot;&gt;TrueCrypt&lt;/a&gt; (descontinuado), &lt;a href=&quot;https://veracrypt.codeplex.com/&quot;&gt;VeraCrypt&lt;/a&gt; o &lt;a href=&quot;https://ciphershed.org/&quot;&gt;CipherShed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6006f436777ec8eee5cc060e91d43457b96b5534" translate="yes" xml:space="preserve">
          <source>Your target system may be badly configured or you have to assume it is and you have to be paranoid about core dumps (can be valid if the systems are not managed by an administrator).</source>
          <target state="translated">El sistema objetivo puede estar mal configurado o hay que suponer que lo está y hay que ser paranoico con los volcados de núcleos (puede ser válido si los sistemas no están gestionados por un administrador).</target>
        </trans-unit>
        <trans-unit id="f47a56647d19f0875be1a2557456e6f93d01cc5b" translate="yes" xml:space="preserve">
          <source>when run</source>
          <target state="translated">cuando se ejecuta</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
