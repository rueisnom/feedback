<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/8881291">
    <body>
      <group id="8881291">
        <trans-unit id="8b5cc79fdd91f3cbabe317bb10b94a8fc9da92e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.oracle.com/technetwork/java/seccodeguide-139067.html#2&quot;&gt;Guideline 2-2 of the Secure Coding Guidelines for the Java Programming Language, Version 4.0&lt;/a&gt; also says something similar (although it is originally in the context of logging):</source>
          <target state="translated">&lt;a href=&quot;http://www.oracle.com/technetwork/java/seccodeguide-139067.html#2&quot;&gt;Java 프로그래밍 언어 용 보안 코딩 지침, 버전 4.0의 지침 2-2&lt;/a&gt; 에도 비슷한 내용이 나와 있습니다 (원래 로깅 컨텍스트에 있음).</target>
        </trans-unit>
        <trans-unit id="e262fa514b2ff9a9cdfcbd1e05ba0e4a0e8eab24" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://security.stackexchange.com/a/83671&quot;&gt;A discussion about timing attacks&lt;/a&gt; over on Information Security Stack Exchange</source>
          <target state="translated">정보 보안 스택 교환에서의 &lt;a href=&quot;https://security.stackexchange.com/a/83671&quot;&gt;타이밍 공격&lt;/a&gt; 에 대한 토론</target>
        </trans-unit>
        <trans-unit id="546581ef303b186fcfa524db41590bb28383b19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Strings&lt;/code&gt; in Java are immutable objects. That is why they can't be modified once created, and therefore the only way for their contents to be removed from memory is to have them garbage collected. It will be only then when the memory freed by the object can be overwritten, and the data will be gone.</source>
          <target state="translated">Java의 &lt;code&gt;Strings&lt;/code&gt; 은 변경할 수없는 객체입니다. 그렇기 때문에 파일을 만든 후에는 수정할 수 없으므로 메모리에서 내용을 제거하는 유일한 방법은 가비지 수집을 수행하는 것입니다. 그때 개체에 의해 해제 된 메모리를 덮어 쓸 수 있고 데이터가 사라질 때만됩니다.</target>
        </trans-unit>
        <trans-unit id="31db751b481dd56268b798ca07bdcab69947d650" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char[]&lt;/code&gt; is an array which you should overwrite once you used the password and this is how it should be done:</source>
          <target state="translated">&lt;code&gt;char[]&lt;/code&gt; 은 일단 암호를 사용한 후에 덮어 써야하는 배열이며 다음과 같이 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="397be38dc3f561874a0b47a76aa1154fa7e83414" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Guideline 2-2: Do not log highly sensitive information&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;지침 2-2 : 매우 민감한 정보를 기록하지 마십시오&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dea03c5dc15d1e7cf9dfb8c1ea63a39c96a370f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt;  Since Strings are immutable in Java, if you store the password as plain text it will be available in memory until the Garbage collector clears it, and since String is used in the String pool for reusability there is a pretty high chance that it will remain in memory for a long duration, which poses a security threat.</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt; 문자열은 Java에서 변경할 수 없으므로 암호를 일반 텍스트로 저장하면 가비지 콜렉터가 지울 때까지 메모리에서 사용할 수 있으며 재사용을 위해 문자열이 문자열 풀에서 사용되므로 문자열은 재사용 가능성이 매우 높습니다. 보안 상 위협이되는 메모리에 오랫동안 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa50fb41f6a3f808bb31590fb5c49da04a28ef18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt;  Java itself recommends using the getPassword() method of JPasswordField which returns a char[], instead of the deprecated getText() method which returns passwords in clear text stating security reasons. It's good to follow advice from the Java team and adhere to standards rather than going against them.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt; Java 자체는 보안상의 이유로 명확한 텍스트로 비밀번호를 리턴하는 사용되지 않는 getText () 메소드 대신 char []를 리턴하는 JPasswordField의 getPassword () 메소드를 사용하도록 권장합니다. Java 팀의 조언을 따르고 표준에 반하는 것이 아니라 표준을 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="31024e792a22c2125636d2085a3babcbaad4dd64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.&lt;/strong&gt;  With String there is always a risk of printing plain text in a log file or console but if you use an Array you won't print contents of an array, but instead its memory location gets printed. Though not a real reason, it still makes sense.</source>
          <target state="translated">&lt;strong&gt;3.&lt;/strong&gt; 문자열을 사용하면 항상 로그 파일이나 콘솔에 일반 텍스트를 인쇄 할 위험이 있지만 배열을 사용하면 배열의 내용을 인쇄하지 않고 대신 메모리 위치가 인쇄됩니다. 실제 이유는 아니지만 여전히 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b7f956cdb0d8e690f8921a39588f88b303dc69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; Coming back to this answer after a year of security research, I realize it makes the rather unfortunate implication that you would ever actually compare plaintext passwords. Please don't. &lt;a href=&quot;https://stackoverflow.com/questions/2860943/how-can-i-hash-a-password-in-java&quot;&gt;Use a secure one-way hash with a salt and a reasonable number of iterations&lt;/a&gt;. Consider using a library: this stuff is hard to get right!</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 1 년의 보안 연구 후이 답변으로 돌아와서 실제로 평문 암호를 비교할 때 불행한 결과를 초래한다는 것을 알았습니다. 제발 하지마 &lt;a href=&quot;https://stackoverflow.com/questions/2860943/how-can-i-hash-a-password-in-java&quot;&gt;소금과 합리적인 반복 횟수로 안전한 단방향 해시를 사용하십시오&lt;/a&gt; . 라이브러리 사용을 고려하십시오.이 물건은 제대로 얻기가 어렵습니다!</target>
        </trans-unit>
        <trans-unit id="e60aa3b140458b9e42618bd0b3a05e257cc2dc56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original answer:&lt;/strong&gt; What about the fact that String.equals() uses &lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/lang/String.java#String.equals%28java.lang.Object%29&quot;&gt;short-circuit evaluation&lt;/a&gt;, and is therefore vulnerable to a timing attack? It may be unlikely, but you could &lt;em&gt;theoretically&lt;/em&gt; time the password comparison in order to determine the correct sequence of characters.</source>
          <target state="translated">&lt;strong&gt;원래 답변 :&lt;/strong&gt; String.equals ()가 &lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/lang/String.java#String.equals%28java.lang.Object%29&quot;&gt;단락 평가&lt;/a&gt; 를 사용하여 타이밍 공격에 취약하다는 사실은 어떻습니까? 가능하지 않을 수도 있지만 &lt;em&gt;이론적&lt;/em&gt; 으로 올바른 문자 순서를 결정하기 위해 암호 비교 시간을 정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71c1051a13130dc057ae957211603eb7b21660e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strings are immutable&lt;/strong&gt;. That means once you've created the &lt;code&gt;String&lt;/code&gt;, if another process can dump memory, there's no way (aside from &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt;) you can get rid of the data before &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;garbage collection&lt;/a&gt; kicks in.</source>
          <target state="translated">&lt;strong&gt;문자열은 변경할 수 없습니다&lt;/strong&gt; . 즉, 일단 &lt;code&gt;String&lt;/code&gt; 을 만든 후에 다른 프로세스가 메모리를 덤프 할 수 있다면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;가비지 수집이&lt;/a&gt; 시작되기 전에 데이터를 제거 할 수있는 방법이 없습니다 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;반사&lt;/a&gt; 제외).</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bf1fec4ea517ac75d82aa127b348cecaa117a7d" translate="yes" xml:space="preserve">
          <source>A Lesson In Timing Attacks</source>
          <target state="translated">타이밍 공격에 대한 교훈</target>
        </trans-unit>
        <trans-unit id="94ac581f37ab2d56dfe8fa01845f896c48ea2c7c" translate="yes" xml:space="preserve">
          <source>And as it turns out, there is nothing that lets you clear the private information of a &lt;code&gt;PrivateKey&lt;/code&gt; from memory, because there's no API that lets you wipe the bytes that form the corresponding information.</source>
          <target state="translated">&lt;code&gt;PrivateKey&lt;/code&gt; 으로, 해당 정보를 형성하는 바이트를 지우는 API가 없기 때문에 PrivateKey 의 개인 정보를 메모리에서 지울 수있는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="698e47ef5df7856861e6bd29ada26e30e6c56a65" translate="yes" xml:space="preserve">
          <source>And of course, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Timing_attack&quot;&gt;Timing Attack Wikipedia page&lt;/a&gt;</source>
          <target state="translated">물론 &lt;a href=&quot;http://en.wikipedia.org/wiki/Timing_attack&quot;&gt;Timing Attack Wikipedia 페이지는&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35879106f4ed216fdb6c73f43b27a8729c325a87" translate="yes" xml:space="preserve">
          <source>As Jon Skeet states, there is no way except by using reflection.</source>
          <target state="translated">Jon Skeet이 말했듯이 반사를 사용하는 것 외에는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="36331cef84c6d35142e7b76dbacd89b8ff6a7d65" translate="yes" xml:space="preserve">
          <source>As noted in the comments, it's possible that arrays being moved by the garbage collector will leave stray copies of the data in memory. I believe this is implementation-specific - the garbage collector &lt;em&gt;may&lt;/em&gt; clear all memory as it goes, to avoid this sort of thing. Even if it does, there's still the time during which the &lt;code&gt;char[]&lt;/code&gt; contains the actual characters as an attack window.</source>
          <target state="translated">주석에서 언급했듯이 가비지 수집기에 의해 이동되는 배열은 메모리에 부유 한 데이터 복사본을 남길 수 있습니다. 나는 이것이 구현에 특정 적이라고 믿습니다. 가비지 수집기 &lt;em&gt;는&lt;/em&gt; 이런 종류의 일을 피하기 위해 모든 메모리를 지울 &lt;em&gt;수 있습니다&lt;/em&gt; . 그렇더라도 &lt;code&gt;char[]&lt;/code&gt; 에 실제 문자가 공격 창으로 포함되는 시간이 여전히 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea94246ffb44ab6b727efb8d392dd9232ef47c1b" translate="yes" xml:space="preserve">
          <source>Based on the above circumstances, one can get an idea whether to go with String or to go with Char[] for their requirements.</source>
          <target state="translated">위의 상황에 따라 요구 사항에 대해 String과 함께 갈 것인지 Char []와 함께 갈 것인지에 대한 아이디어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff08257691f084f5bb4321a9521146f84621c841" translate="yes" xml:space="preserve">
          <source>Because of the security concern it is better to store password as a character array.</source>
          <target state="translated">보안상의 문제로 인해 암호를 문자 배열로 저장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fc94856bbf7a5446009d35b73ca294f9cc65c6ce" translate="yes" xml:space="preserve">
          <source>But that alone isn't a good answer; why not just make sure a reference to the &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; doesn't escape? Then there's no security issue. But the thing is that &lt;code&gt;String&lt;/code&gt; objects can be &lt;code&gt;intern()&lt;/code&gt;ed in theory and kept alive inside the constant pool. I suppose using &lt;code&gt;char[]&lt;/code&gt; forbids this possibility.</source>
          <target state="translated">그러나 이것만으로는 좋은 대답이 아닙니다. &lt;code&gt;char[]&lt;/code&gt; 또는 &lt;code&gt;String&lt;/code&gt; 에 대한 참조가 이스케이프되지 않는 이유는 무엇입니까? 그런 다음 보안 문제가 없습니다. 그러나 문제는 &lt;code&gt;String&lt;/code&gt; 객체가 이론적으로 &lt;code&gt;intern()&lt;/code&gt; 될 수 있고 상수 풀 내부에서 살아있을 수 있다는 것입니다. &lt;code&gt;char[]&lt;/code&gt; 사용하면이 가능성이 없다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="f7b798d770ca2df60818ef3a16e84e4d0302362b" translate="yes" xml:space="preserve">
          <source>Char[] is mutable, but it has the advantage that after its usage the programmer can explicitly clean the array or override values. So when it's done being used it is cleaned and no one could ever know about the information you had stored.</source>
          <target state="translated">Char []는 변경 가능하지만, 사용 후 프로그래머가 명시 적으로 배열을 정리하거나 값을 대체 할 수 있다는 장점이 있습니다. 따라서 사용이 끝나면 청소가 완료되어 저장된 정보에 대해 아무도 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2d5fad3855bcb5cf79c403b8fae8134166583c5" translate="yes" xml:space="preserve">
          <source>Character arrays (&lt;code&gt;char[]&lt;/code&gt;) can be cleared after use by setting each character to zero and Strings not. If someone can somehow see the memory image, they can see a password in plain text if Strings are used, but if &lt;code&gt;char[]&lt;/code&gt; is used, after purging data with 0's, the password is secure.</source>
          <target state="translated">문자 배열 ( &lt;code&gt;char[]&lt;/code&gt; )은 사용 후 각 문자를 0으로 설정하고 문자열을 설정하지 않고 지울 수 있습니다. 누군가가 어떻게 메모리 이미지를 볼 수 있다면 문자열을 사용하면 일반 텍스트로 암호를 볼 수 있지만 &lt;code&gt;char[]&lt;/code&gt; 를 사용하면 0으로 데이터를 제거한 후 암호는 안전합니다.</target>
        </trans-unit>
        <trans-unit id="fe2e10fde78683521d4003ae2215af5b39ef6231" translate="yes" xml:space="preserve">
          <source>Consider this:</source>
          <target state="translated">이걸 고려하세요:</target>
        </trans-unit>
        <trans-unit id="61da8effd39d181e7d2fbf216216c68b5d82129d" translate="yes" xml:space="preserve">
          <source>However, Java changes all the time, and some scary features like &lt;a href=&quot;https://stackoverflow.com/questions/27949213/string-deduplication-feature-of-java-8&quot;&gt;String Deduplication feature of Java 8&lt;/a&gt; might intern String objects without your knowledge. But that's a different conversation.</source>
          <target state="translated">그러나 Java는 항상 변경되며 &lt;a href=&quot;https://stackoverflow.com/questions/27949213/string-deduplication-feature-of-java-8&quot;&gt;Java 8의 String Deduplication 기능&lt;/a&gt; 과 같은 일부 무서운 기능은 사용자 모르게 String 객체를 인턴 할 수 있습니다. 그러나 그것은 다른 대화입니다.</target>
        </trans-unit>
        <trans-unit id="4085390bb3f3a972df1be47fd22afa929e468c7e" translate="yes" xml:space="preserve">
          <source>However, if reflection is an option for you, you can do this.</source>
          <target state="translated">그러나 리플렉션이 적합한 경우이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ce1845c70b9dc4de0441f1a0e5b0d33534ff75d" translate="yes" xml:space="preserve">
          <source>I don't think this is a valid suggestion, but, I can at least guess at the reason.</source>
          <target state="translated">나는 이것이 유효한 제안이라고 생각하지 않지만 적어도 그 이유를 추측 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="151bc7b0c4f1b70bc4b73e26ef103e85b31bf68d" translate="yes" xml:space="preserve">
          <source>I think the motivation is wanting to make sure that you can erase all trace of the password in memory promptly and with certainty after it is used. With a &lt;code&gt;char[]&lt;/code&gt; you could overwrite each element of the array with a blank or something for sure. You can't edit the internal value of a &lt;code&gt;String&lt;/code&gt; that way.</source>
          <target state="translated">동기 부여는 메모리에서 암호의 모든 흔적을 즉시 사용하고 확실하게 지울 수 있기를 원한다고 생각합니다. &lt;code&gt;char[]&lt;/code&gt; 를 사용하면 배열의 각 요소를 공백 또는 무언가로 덮어 쓸 수 있습니다. 그런 식으로 &lt;code&gt;String&lt;/code&gt; 의 내부 값을 편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac37450fb5de9b14d5b22b707a61b326fc006e75" translate="yes" xml:space="preserve">
          <source>I'm thinking of e.g. the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/security/PrivateKey.html&quot;&gt;PrivateKey&lt;/a&gt; class. Consider a scenario where you would load a private RSA key from a PKCS#12 file, using it to perform some operation. Now in this case, sniffing the password alone wouldn't help you much as long as physical access to the key file is properly restricted. As an attacker, you would be much better off if you obtained the key directly instead of the password. The desired information can be leaked manifold, core dumps, a debugger session or swap files are just some examples.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/security/PrivateKey.html&quot;&gt;PrivateKey&lt;/a&gt; 클래스를 생각하고 있습니다. PKCS # 12 파일에서 개인 RSA 키를 사용하여 일부 작업을 수행하는 시나리오를 고려하십시오. 이제이 경우 암호 만 스니핑해도 키 파일에 대한 물리적 액세스가 제대로 제한되는 한 도움이되지 않습니다. 공격자는 암호 대신 키를 직접 입수하면 훨씬 나을 것입니다. 원하는 정보가 유출 될 수있는 것은 매니 폴드, 코어 덤프, 디버거 세션 또는 스왑 파일입니다.</target>
        </trans-unit>
        <trans-unit id="57001b779997c68b84ea322da58afc3b9aee11b7" translate="yes" xml:space="preserve">
          <source>If possible, disabling core dumps and the swap file would take care of both problems. However, they would require administrator rights and may reduce functionality (less memory to use) and pulling RAM from a running system would still be a valid concern.</source>
          <target state="translated">가능하면 코어 덤프와 스왑 파일을 비활성화하면 두 가지 문제가 모두 해결됩니다. 그러나 관리자 권한이 필요하고 기능 (사용할 메모리가 적음)이 줄어들고 실행중인 시스템에서 RAM을 가져 오는 것이 여전히 유효한 문제입니다.</target>
        </trans-unit>
        <trans-unit id="33fe3db7ec48beac0c68de9fcd8d0c76bda59e6e" translate="yes" xml:space="preserve">
          <source>If the value of the string is modified then it will end up creating a new string. So both the original value and the modified value stay in the memory until it is garbage collected.</source>
          <target state="translated">문자열 값이 수정되면 새 문자열이 만들어집니다. 따라서 원래 값과 수정 된 값은 모두 가비지 수집 될 때까지 메모리에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="914d4c3b06c646d3115826f9e7120eefcb75df0a" translate="yes" xml:space="preserve">
          <source>In Swing, the password field has a &lt;code&gt;getPassword()&lt;/code&gt; (returns &lt;code&gt;char[]&lt;/code&gt;) method instead of the usual &lt;code&gt;getText()&lt;/code&gt; (returns &lt;code&gt;String&lt;/code&gt;) method. Similarly, I have come across a suggestion not to use &lt;code&gt;String&lt;/code&gt; to handle passwords.</source>
          <target state="translated">Swing에서, 패스워드 필드는 일반적인 &lt;code&gt;getText()&lt;/code&gt; (returns &lt;code&gt;String&lt;/code&gt; ) 메소드 대신 &lt;code&gt;getPassword()&lt;/code&gt; ( &lt;code&gt;char[]&lt;/code&gt; ) 메소드를 갖습니다. 마찬가지로 &lt;code&gt;String&lt;/code&gt; 을 사용하여 암호를 처리하지 말 것을 제안했습니다.</target>
        </trans-unit>
        <trans-unit id="f3e385fc6478055a321c64cb02009cc9d7e54bd6" translate="yes" xml:space="preserve">
          <source>It is debatable as to whether you should use String or use Char[] for this purpose because both have their advantages and disadvantages. It depends on what the user needs.</source>
          <target state="translated">이 목적을 위해 String을 사용해야하는지 또는 Char []를 사용해야하는지에 대해서는 논쟁의 여지가 있습니다. 사용자가 원하는 것에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="6892d03a0b1a14ba14ef1fe5bba377b5df3f74f4" translate="yes" xml:space="preserve">
          <source>It would seem logical to collect and store the password in an object
  of type &lt;code&gt;java.lang.String&lt;/code&gt;. However, here's the caveat: &lt;code&gt;Object&lt;/code&gt;s of
  type &lt;code&gt;String&lt;/code&gt; are immutable, i.e., there are no methods defined that
  allow you to change (overwrite) or zero out the contents of a &lt;code&gt;String&lt;/code&gt;
  after usage. This feature makes &lt;code&gt;String&lt;/code&gt; objects unsuitable for
  storing security sensitive information such as user passwords. You
  should always collect and store security sensitive information in a
  &lt;code&gt;char&lt;/code&gt; array instead.</source>
          <target state="translated">&lt;code&gt;java.lang.String&lt;/code&gt; 유형의 오브젝트에 비밀번호를 수집하여 저장하는 것이 논리적으로 보입니다. 그러나주의해야 할 점은 다음과 같습니다. &lt;code&gt;String&lt;/code&gt; 유형의 &lt;code&gt;Object&lt;/code&gt; 는 변경할 수 없습니다. 즉, 사용 후 &lt;code&gt;String&lt;/code&gt; 의 내용을 변경 (덮어 쓰기)하거나 제로화 할 수있는 정의 된 메소드가 없습니다. 이 기능은 &lt;code&gt;String&lt;/code&gt; 객체를 사용자 비밀번호와 같은 보안에 민감한 정보를 저장하기에 적합하지 않게합니다. 대신 보안에 민감한 정보를 항상 &lt;code&gt;char&lt;/code&gt; 배열로 수집하고 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="8684c3b4018676a3106d93184438755a93bce417" translate="yes" xml:space="preserve">
          <source>Note: if the String's char[] has been copied as a part of a GC cycle, there is a chance the previous copy is somewhere in memory.</source>
          <target state="translated">참고 : 문자열의 char []가 GC주기의 일부로 복사 된 경우 이전 사본이 메모리에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4510da9e949f0f4ef9576982abd7e611df40556" translate="yes" xml:space="preserve">
          <source>Now garbage collection in Java doesn't happen at any guaranteed interval. The &lt;code&gt;String&lt;/code&gt; can thus persist in memory for a long time, and if a process crashes during this time, the contents of the string may end up in a memory dump or some log.</source>
          <target state="translated">이제 Java에서 가비지 콜렉션이 보장 된 간격으로 발생하지 않습니다. 따라서 &lt;code&gt;String&lt;/code&gt; 은 메모리에 오랫동안 지속될 수 있으며이 시간 동안 프로세스가 충돌하면 문자열의 내용이 메모리 덤프 또는 일부 로그에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="009c1ad62959bdccaf0ac3c21fa53db992bb4841" translate="yes" xml:space="preserve">
          <source>On the other side char[] are mutable as soon as the authentication is done you can overwrite them with any character like all M's or backslashes. Now even if someone takes a heap dump he might not be able to get the passwords which are not currently in use. This gives you more control in the sense like clearing the Object content yourself vs waiting for the GC to do it.</source>
          <target state="translated">다른 한편으로, 인증이 완료 되 자마자 char []는 변경 가능합니다. 모든 M 또는 백 슬래시와 같은 문자로 덮어 쓸 수 있습니다. 누군가 누군가 힙 덤프를하더라도 현재 사용하지 않는 비밀번호를 얻지 못할 수 있습니다. 이를 통해 Object 컨텐츠를 직접 지우는 것과 GC가 기다리는 것을보다 강력하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="808ddd5c0f070dc1407e36a6c3bd4a098c623be2" translate="yes" xml:space="preserve">
          <source>One scenario where the attacker could use it is a crashdump - when the JVM crashes and generates a memory dump - you will be able to see the password.</source>
          <target state="translated">공격자가이를 사용할 수있는 한 가지 시나리오는 JVM이 충돌하고 메모리 덤프를 생성 할 때 충돌 덤프입니다. 암호를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="d23d8cc1d470710d96e727d64982b4e074a1ad39" translate="yes" xml:space="preserve">
          <source>Referenced from &lt;a href=&quot;http://javarevisited.blogspot.com/2012/03/why-character-array-is-better-than.html&quot;&gt;this blog&lt;/a&gt;.
I hope this helps.</source>
          <target state="translated">&lt;a href=&quot;http://javarevisited.blogspot.com/2012/03/why-character-array-is-better-than.html&quot;&gt;이 블로그&lt;/a&gt; 에서 참조 하십시오 . 이게 도움이 되길 바란다.</target>
        </trans-unit>
        <trans-unit id="da39838ea50b051a48f69227a80db6d3ae54cb71" translate="yes" xml:space="preserve">
          <source>Since Strings in Java are immutable, whenever some tries to manipulate your string it creates a new Object and the existing String remains unaffected. This could be seen as an advantage for storing a password as a String, but the object remains in memory even after use. So if anyone somehow got the memory location of the object, that person can easily trace your password stored at that location.</source>
          <target state="translated">Java의 문자열은 변경할 수 없으므로 일부 문자열을 조작하려고 할 때마다 새 객체가 생성되고 기존 문자열은 영향을받지 않습니다. 이것은 암호를 문자열로 저장하는 이점으로 보일 수 있지만 사용 후에도 개체는 메모리에 남아 있습니다. 따라서 누군가 어떻게 든 객체의 메모리 위치를 확보 한 경우 해당 위치에 저장된 비밀번호를 쉽게 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6539fcd58f3cfe01d8e3345fd5cc498d2c1757ca" translate="yes" xml:space="preserve">
          <source>Since anyone who has access to the memory dump can find the password in clear text, that's another reason you should always use an encrypted password rather than plain text. Since Strings are immutable there is no way the contents of Strings can be changed because any change will produce a new String, while if you use a char[] you can still set all the elements as blank or zero. So storing a password in a character array clearly mitigates the security risk of stealing a password.</source>
          <target state="translated">메모리 덤프에 액세스 할 수있는 사람은 누구나 일반 텍스트로 비밀번호를 찾을 수 있기 때문에 항상 일반 텍스트 대신 암호화 된 비밀번호를 사용해야합니다. 문자열은 변경할 수 없으므로 변경하면 새 문자열이 생성되므로 문자열의 내용을 변경할 수있는 방법은 없지만 char []를 사용하면 모든 요소를 ​​공백 또는 0으로 설정할 수 있습니다. 따라서 문자 배열에 암호를 저장하면 암호를 훔칠 수있는 보안 위험이 분명히 완화됩니다.</target>
        </trans-unit>
        <trans-unit id="2adb89ba4d12684aa374a2b6fe43ad82b7834618" translate="yes" xml:space="preserve">
          <source>So yes, this &lt;em&gt;is&lt;/em&gt; a security concern - but even using &lt;code&gt;char[]&lt;/code&gt; only reduces the window of opportunity for an attacker, and it's only for this specific type of attack.</source>
          <target state="translated">그렇습니다. 이것은 보안상의 문제입니다. 그러나 &lt;code&gt;char[]&lt;/code&gt; 사용하더라도 공격자의 기회는 줄어들고이 특정 유형의 공격에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="1de0b546e683d80be916c3f763396811703e5bf0" translate="yes" xml:space="preserve">
          <source>Some information, such as Social Security numbers (SSNs) and
  passwords, is highly sensitive. This information should not be kept
  for longer than necessary nor where it may be seen, even by
  administrators. For instance, it should not be sent to log files and
  its presence should not be detectable through searches. Some transient
  data may be kept in mutable data structures, such as char arrays, and
  cleared immediately after use. Clearing data structures has reduced
  effectiveness on typical Java runtime systems as objects are moved in
  memory transparently to the programmer.</source>
          <target state="translated">사회 보장 번호 (SSN) 및 비밀번호와 같은 일부 정보는 매우 중요합니다. 이 정보는 필요 이상으로 보거나 관리자가 볼 수있는 위치에 보관해서는 안됩니다. 예를 들어, 로그 파일로 보내지 않아야하며 검색을 통해 존재 여부를 감지 할 수 없습니다. 일부 일시적인 데이터는 char 배열과 같은 가변 데이터 구조로 유지 될 수 있으며 사용 후 즉시 지워질 수 있습니다. 데이터 구조를 지우면 객체가 메모리에서 프로그래머에게 투명하게 이동되므로 일반적인 Java 런타임 시스템에서 효율성이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="342e9eaee08708bfd19f663e2797e6c4835f202f" translate="yes" xml:space="preserve">
          <source>Some more resources on timing attacks:</source>
          <target state="translated">타이밍 공격에 대한 추가 자료 :</target>
        </trans-unit>
        <trans-unit id="70ec593d69ff444a0c4f8c40a5b655665549f9ff" translate="yes" xml:space="preserve">
          <source>Some people believe that you have to overwrite the memory used to store the password once you no longer need it. This reduces the time window an attacker has to read the password from your system and completely ignores the fact that the attacker already needs enough access to hijack the JVM memory to do this. An attacker with that much access can catch your key events making this completely useless (AFAIK, so please correct me if I am wrong).</source>
          <target state="translated">어떤 사람들은 더 이상 필요하지 않은 암호를 저장하는 데 사용 된 메모리를 덮어 써야한다고 생각합니다. 이를 통해 공격자가 시스템에서 암호를 읽는 데 걸리는 시간이 줄어들고 공격자가 이미이를 수행하기 위해 JVM 메모리를 하이재킹 할 수있는 충분한 액세스 권한이 필요하다는 사실을 완전히 무시합니다. 많은 액세스 권한을 가진 공격자는 주요 이벤트를 포착하여이를 완전히 쓸모 없게 만들 수 있습니다 (AFAIK, 내가 틀렸다면 바로 정정하십시오).</target>
        </trans-unit>
        <trans-unit id="a15471736d5db023d6a76ce568c8d2f6f77e6fd4" translate="yes" xml:space="preserve">
          <source>String in java is immutable. So whenever a string is created, it will remain in the memory until it is garbage collected. So anyone who has access to the memory can read the value of the string.</source>
          <target state="translated">Java의 문자열은 변경할 수 없습니다. 따라서 문자열이 생성 될 때마다 가비지 수집 될 때까지 메모리에 남아 있습니다. 따라서 메모리에 액세스 할 수있는 사람은 누구나 문자열 값을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70292d1b61c498137fcfe048ab768be8db94f7d9" translate="yes" xml:space="preserve">
          <source>String is immutable and it goes to the string pool. Once written, it cannot be overwritten.</source>
          <target state="translated">문자열은 변경할 수 없으며 문자열 풀로 이동합니다. 일단 작성된 후에는 덮어 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d63b7c3c393127b2e12ff515941706150a569e2" translate="yes" xml:space="preserve">
          <source>Strings are immutable and cannot be altered once they have been created. Creating a password as a string will leave stray references to the password on the heap or on the String pool. Now if someone takes a heap dump of the Java process and carefully scans through he might be able to guess the passwords. Of course these non used strings will be garbage collected but that depends on when the GC kicks in.</source>
          <target state="translated">문자열은 변경할 수 없으며 일단 생성 된 후에는 변경할 수 없습니다. 문자열로 비밀번호를 작성하면 힙 또는 문자열 풀의 비밀번호에 대한 참조가 잘못 표시됩니다. 이제 누군가 Java 프로세스의 힙 덤프를 가져 와서 신중하게 스캔하면 암호를 추측 할 수 있습니다. 물론 이러한 사용되지 않는 문자열은 가비지 수집되지만 GC가 시작되는 시점에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a50bf4dfb5987fd653ea7a3d545740bdb6a92ca3" translate="yes" xml:space="preserve">
          <source>Take a look at the &lt;sub&gt;widely used&lt;/sub&gt; Spring Security library &lt;a href=&quot;http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.security/spring-security-web/3.0.1.RELEASE/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.java#73&quot;&gt;here&lt;/a&gt; and ask yourself - are Spring Security guys incompetent or char[] passwords just don't make much sense. When some nasty hacker grabs memory dumps of your RAM be sure s/he'll get all the passwords even if you use sophisticated ways to hide them.</source>
          <target state="translated">&lt;a href=&quot;http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.security/spring-security-web/3.0.1.RELEASE/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.java#73&quot;&gt;여기&lt;/a&gt; 에서 &lt;sub&gt;널리 사용되는&lt;/sub&gt; Spring Security 라이브러리를 살펴보고 스스로에게 물어보십시오. Spring Security 사용자가 무능하거나 char [] 비밀번호가 그다지 의미가 없습니다. 불쾌한 해커가 RAM의 메모리 덤프를 가져 오면 정교한 비밀번호를 숨기는 방법을 사용하더라도 모든 비밀번호를 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="a7a4c75efd48757679ac6c3d07cd60ad382ace9d" translate="yes" xml:space="preserve">
          <source>Thanks to the comments I have to update my answer. Apparently there are two cases where this can add a (very) minor security improvement as it reduces the time a password could land on the hard drive. Still I think it's overkill for most use cases.</source>
          <target state="translated">의견 덕분에 답변을 업데이트해야합니다. 암호가 하드 드라이브에 도달 할 수있는 시간을 줄임으로써 약간의 보안 향상을 추가 할 수있는 두 가지 경우가 있습니다. 여전히 대부분의 사용 사례에서는 과잉이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="2b26660b7b422e0609c382be6b48bf115b3c7e78" translate="yes" xml:space="preserve">
          <source>That is not necessarily a malicious external attacker. This could be a support user that has access to the server for monitoring purposes. He could peek into a crashdump and find the passwords.</source>
          <target state="translated">반드시 악의적 인 외부 공격자는 아닙니다. 모니터링 목적으로 서버에 액세스 할 수있는 지원 사용자 일 수 있습니다. 그는 충돌 덤프를 들여다보고 암호를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87c04911712a5eca03edfca8a7dc86c33db8574d" translate="yes" xml:space="preserve">
          <source>The OpenSSL library for example overwrites critical memory sections before private keys are freed. Since Java is garbage-collected, we would need explicit methods to wipe and invalidate private information for Java keys, which are to be applied immediately after using the key.</source>
          <target state="translated">예를 들어 OpenSSL 라이브러리는 개인 키가 해제되기 전에 중요한 메모리 섹션을 덮어 씁니다. Java는 가비지 수집되므로 Java 키에 대한 개인 정보를 지우고 무효화하는 명시적인 방법이 필요합니다.이 키는 사용 후 즉시 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d904c18a0d5e2b983c5e3b0a1ec77093be40a8a" translate="yes" xml:space="preserve">
          <source>The answer has already been given, but I'd like to share an issue that I discovered lately with Java standard libraries. While they take great care now of replacing password strings with &lt;code&gt;char[]&lt;/code&gt; everywhere (which of course is a good thing), other security-critical data seems to be overlooked when it comes to clearing it from memory.</source>
          <target state="translated">답변이 이미 제공되었지만 최근에 Java 표준 라이브러리에서 발견 한 문제를 공유하고 싶습니다. 암호 문자열을 모든 곳에서 &lt;code&gt;char[]&lt;/code&gt; 로 바꾸는 데 많은주의를 기울이지 만 (물론 좋은 것임), 메모리에서 지우는 데있어 보안 상 중요한 다른 데이터는 간과되는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cdb971985ae17b650f8064ac735ff984c433ea3" translate="yes" xml:space="preserve">
          <source>The short and straightforward answer would be because &lt;code&gt;char[]&lt;/code&gt; is mutable while &lt;code&gt;String&lt;/code&gt; objects are not.</source>
          <target state="translated">짧고 간단한 대답은 &lt;code&gt;char[]&lt;/code&gt; 객체가 변경 가능하지만 &lt;code&gt;String&lt;/code&gt; 객체는 변경할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c831e687484a08e9210ad3468fba111f383b12f4" translate="yes" xml:space="preserve">
          <source>There is nothing that char array gives you vs String unless you clean it up manually after use, and I haven't seen anyone actually doing that. So to me the preference of char[] vs String is a bit exaggerated.</source>
          <target state="translated">char 배열은 사용 후 수동으로 정리하지 않는 한 vs 문자열을 제공하는 것이 없으며 실제로 그렇게하는 사람을 보지 못했습니다. 그래서 char [] vs String의 선호도는 약간 과장되었습니다.</target>
        </trans-unit>
        <trans-unit id="c29c1dc60896ca5c2015a47b5d9b6fedd7054557" translate="yes" xml:space="preserve">
          <source>These are all the reasons, one should choose a &lt;strong&gt;char[]&lt;/strong&gt; array instead of &lt;strong&gt;String&lt;/strong&gt; for a password.</source>
          <target state="translated">이러한 모든 이유 때문에 암호 대신 &lt;strong&gt;문자열&lt;/strong&gt; 대신 &lt;strong&gt;char []&lt;/strong&gt; 배열을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fd0d8098dcf68fcf92acb8477b5a5f142c06ffb" translate="yes" xml:space="preserve">
          <source>This guideline also has implications for implementation and use of
  lower-level libraries that do not have semantic knowledge of the data
  they are dealing with. As an example, a low-level string parsing
  library may log the text it works on. An application may parse an SSN
  with the library. This creates a situation where the SSNs are
  available to administrators with access to the log files.</source>
          <target state="translated">이 지침은 또한 다루고있는 데이터에 대한 의미 지식이없는 하위 수준 라이브러리의 구현 및 사용에 영향을 미칩니다. 예를 들어, 하위 수준 문자열 구문 분석 라이브러리는 작동하는 텍스트를 기록 할 수 있습니다. 애플리케이션은 라이브러리와 SSN을 구문 분석 할 수 있습니다. 이로 인해 관리자가 SSN을 사용하여 로그 파일에 액세스 할 수있는 상황이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0b542944974a2f4551f2b6ab738b0d93fd70b517" translate="yes" xml:space="preserve">
          <source>This is a bad situation, as this &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.77.3297&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;paper&lt;/a&gt; describes how this circumstance could be potentially exploited.</source>
          <target state="translated">이 &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.77.3297&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;백서&lt;/a&gt; 에서는 이러한 상황이 어떻게 악용 될 수 있는지 설명하기 때문에 이는 나쁜 상황입니다.</target>
        </trans-unit>
        <trans-unit id="60a8a4000e8f0bc7de20f87190fb4c8e81516e21" translate="yes" xml:space="preserve">
          <source>This old copy wouldn't appear in a heap dump, but if you have direct access to the raw memory of the process you could see it.  In general you should avoid anyone having such access.</source>
          <target state="translated">이 오래된 사본은 힙 덤프에 나타나지 않지만 프로세스의 원시 메모리에 직접 액세스 할 수있는 경우이를 볼 수 있습니다. 일반적으로 그러한 액세스 권한을 가진 사람은 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c1079be9137eb36b54da5688745bf117e61534d" translate="yes" xml:space="preserve">
          <source>To quote an official document, the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#PBEEx&quot;&gt;Java Cryptography Architecture guide&lt;/a&gt; says this about &lt;code&gt;char[]&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; passwords (about password-based encryption, but this is more generally about passwords of course):</source>
          <target state="translated">공식 문서를 인용하기 위해, &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#PBEEx&quot;&gt;Java Cryptography Architecture 안내서&lt;/a&gt; 는 &lt;code&gt;char[]&lt;/code&gt; 대 &lt;code&gt;String&lt;/code&gt; 비밀번호 (비밀번호 기반 암호화에 관한 것이지만 더 일반적으로 비밀번호에 관한 것)에 대해 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="09c96217cecf5158d9c599143709c0bf43a4b916" translate="yes" xml:space="preserve">
          <source>While other suggestions here seem valid, there is one other good reason. With plain &lt;code&gt;String&lt;/code&gt; you have much higher chances of &lt;strong&gt;accidentally printing the password to logs&lt;/strong&gt;, monitors or some other insecure place. &lt;code&gt;char[]&lt;/code&gt; is less vulnerable.</source>
          <target state="translated">여기에 다른 제안이 유효 해 보이지만 다른 좋은 이유가 있습니다. 일반 &lt;code&gt;String&lt;/code&gt; 을 사용하면 &lt;strong&gt;실수로 암호를 로그&lt;/strong&gt; , 모니터 또는 기타 안전하지 않은 장소에 &lt;strong&gt;인쇄&lt;/strong&gt; 할 가능성이 훨씬 높아집니다. &lt;code&gt;char[]&lt;/code&gt; 는 덜 취약합니다.</target>
        </trans-unit>
        <trans-unit id="f86d971b4a867c5b4b839105b6b5d514d24257f3" translate="yes" xml:space="preserve">
          <source>Why does &lt;code&gt;String&lt;/code&gt; pose a threat to security when it comes to passwords?
It feels inconvenient to use &lt;code&gt;char[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 이 암호와 관련하여 보안에 위협이되는 이유는 무엇입니까? &lt;code&gt;char[]&lt;/code&gt; 를 사용하는 것은 불편합니다.</target>
        </trans-unit>
        <trans-unit id="be87eb63b17c07d23faf558d201b11e61486e392" translate="yes" xml:space="preserve">
          <source>Why is char[] preferred over String for passwords</source>
          <target state="translated">비밀번호에서 char []가 String보다 선호되는 이유</target>
        </trans-unit>
        <trans-unit id="96c058528af12a3ec3c0a6a4356b9a336391a6da" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;character array&lt;/em&gt;, you can read the password, finish working with it as soon as you can, and then immediately change the contents.</source>
          <target state="translated">&lt;em&gt;문자형 배열을&lt;/em&gt; 사용하면 암호를 읽고 최대한 빨리 작업을 마친 후 즉시 내용을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="252e94464c28d121b2ac7065cfdc63317b907d6d" translate="yes" xml:space="preserve">
          <source>With an array, you can explicitly wipe the data after you're done with it. You can overwrite the array with anything you like, and the password won't be present anywhere in the system, even before garbage collection.</source>
          <target state="translated">배열을 사용하면 데이터를 완성한 후에 데이터를 명시 적으로 지울 수 있습니다. 배열을 원하는 것으로 덮어 쓸 수 있으며 가비지 수집 전에도 시스템의 어느 곳에도 암호가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b2e2713e36f214c8c2b0f0732ccc93580279e73" translate="yes" xml:space="preserve">
          <source>With the character array, the contents of the array can be modified or erased once the purpose of the password is served. The original contents of the array will not be found in memory after it is modified and even before the garbage collection kicks in.</source>
          <target state="translated">문자 배열을 사용하면 암호의 목적이 제공되면 배열의 내용을 수정하거나 지울 수 있습니다. 배열의 원래 내용은 수정 된 후 및 가비지 수집이 시작되기 전에도 메모리에서 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e436ad0706341ed15fd79a042f530dfaa544abb" translate="yes" xml:space="preserve">
          <source>Your software has to be overly paranoid to prevent data leaks with the attacker gaining access to the hardware - using things like &lt;a href=&quot;http://en.wikipedia.org/wiki/TrueCrypt&quot;&gt;TrueCrypt&lt;/a&gt; (discontinued), &lt;a href=&quot;https://veracrypt.codeplex.com/&quot;&gt;VeraCrypt&lt;/a&gt;, or &lt;a href=&quot;https://ciphershed.org/&quot;&gt;CipherShed&lt;/a&gt;.</source>
          <target state="translated">공격자가 &lt;a href=&quot;http://en.wikipedia.org/wiki/TrueCrypt&quot;&gt;TrueCrypt&lt;/a&gt; (단종), &lt;a href=&quot;https://veracrypt.codeplex.com/&quot;&gt;VeraCrypt&lt;/a&gt; 또는 &lt;a href=&quot;https://ciphershed.org/&quot;&gt;CipherShed&lt;/a&gt; 와 같은 것을 사용하여 하드웨어에 액세스 할 때 데이터 유출을 방지하려면 소프트웨어가 과도하게 편집증을 일으켜야 합니다.</target>
        </trans-unit>
        <trans-unit id="6006f436777ec8eee5cc060e91d43457b96b5534" translate="yes" xml:space="preserve">
          <source>Your target system may be badly configured or you have to assume it is and you have to be paranoid about core dumps (can be valid if the systems are not managed by an administrator).</source>
          <target state="translated">대상 시스템이 잘못 구성되었거나 구성되어 있다고 가정해야하며 코어 덤프에 대한 편집증이 있어야합니다 (관리자가 시스템을 관리하지 않는 경우 유효 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="f47a56647d19f0875be1a2557456e6f93d01cc5b" translate="yes" xml:space="preserve">
          <source>when run</source>
          <target state="translated">실행될 때</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
