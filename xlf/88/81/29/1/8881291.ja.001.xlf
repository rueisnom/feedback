<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/8881291">
    <body>
      <group id="8881291">
        <trans-unit id="8b5cc79fdd91f3cbabe317bb10b94a8fc9da92e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.oracle.com/technetwork/java/seccodeguide-139067.html#2&quot;&gt;Guideline 2-2 of the Secure Coding Guidelines for the Java Programming Language, Version 4.0&lt;/a&gt; also says something similar (although it is originally in the context of logging):</source>
          <target state="translated">&lt;a href=&quot;http://www.oracle.com/technetwork/java/seccodeguide-139067.html#2&quot;&gt;Javaプログラミング言語、バージョン4.0のセキュアコーディングガイドラインのガイドライン2-2&lt;/a&gt;も同様のことを言っています（ただし、それはもともとロギングのコンテキストにあります）。</target>
        </trans-unit>
        <trans-unit id="e262fa514b2ff9a9cdfcbd1e05ba0e4a0e8eab24" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://security.stackexchange.com/a/83671&quot;&gt;A discussion about timing attacks&lt;/a&gt; over on Information Security Stack Exchange</source>
          <target state="translated">情報セキュリティスタック交換&lt;a href=&quot;https://security.stackexchange.com/a/83671&quot;&gt;に対する攻撃のタイミングに関する議論&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="546581ef303b186fcfa524db41590bb28383b19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Strings&lt;/code&gt; in Java are immutable objects. That is why they can't be modified once created, and therefore the only way for their contents to be removed from memory is to have them garbage collected. It will be only then when the memory freed by the object can be overwritten, and the data will be gone.</source>
          <target state="translated">Javaの &lt;code&gt;Strings&lt;/code&gt; 列は不変オブジェクトです。 そのため、一度作成すると変更できないため、コンテンツをメモリから削除する唯一の方法は、ガベージコレクションを実行することです。 オブジェクトによって解放されたメモリを上書きできるようになって初めて、データは失われます。</target>
        </trans-unit>
        <trans-unit id="31db751b481dd56268b798ca07bdcab69947d650" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char[]&lt;/code&gt; is an array which you should overwrite once you used the password and this is how it should be done:</source>
          <target state="translated">&lt;code&gt;char[]&lt;/code&gt; は、パスワードを使用した後に上書きする必要がある配列であり、次のように実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="397be38dc3f561874a0b47a76aa1154fa7e83414" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Guideline 2-2: Do not log highly sensitive information&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ガイドライン2-2：機密性の高い情報を記録しない&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dea03c5dc15d1e7cf9dfb8c1ea63a39c96a370f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt;  Since Strings are immutable in Java, if you store the password as plain text it will be available in memory until the Garbage collector clears it, and since String is used in the String pool for reusability there is a pretty high chance that it will remain in memory for a long duration, which poses a security threat.</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt;文字列はJavaでは不変なので、パスワードをプレーンテキストとして保存すると、ガベージコレクターがそれをクリアするまでメモリで使用できます。また、文字列は再利用性のために文字列プールで使用されるため、かなり高い可能性があります。セキュリティ上の脅威となる長期間メモリに残ります。</target>
        </trans-unit>
        <trans-unit id="fa50fb41f6a3f808bb31590fb5c49da04a28ef18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt;  Java itself recommends using the getPassword() method of JPasswordField which returns a char[], instead of the deprecated getText() method which returns passwords in clear text stating security reasons. It's good to follow advice from the Java team and adhere to standards rather than going against them.</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt; Java自体は、セキュリティ上の理由からパスワードをクリアテキストで返す非推奨のgetText（）メソッドの代わりに、char []を返すJPasswordFieldのgetPassword（）メソッドを使用することをお勧めします。 Javaチームからのアドバイスに従い、標準に反するのではなく、標準に準拠することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="31024e792a22c2125636d2085a3babcbaad4dd64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.&lt;/strong&gt;  With String there is always a risk of printing plain text in a log file or console but if you use an Array you won't print contents of an array, but instead its memory location gets printed. Though not a real reason, it still makes sense.</source>
          <target state="translated">&lt;strong&gt;3.&lt;/strong&gt;文字列を使用すると、常にプレーンテキストがログファイルまたはコンソールに印刷されるリスクがありますが、配列を使用すると、配列の内容は印刷されず、代わりにメモリの場所が印刷されます。 本当の理由ではありませんが、それでも意味があります。</target>
        </trans-unit>
        <trans-unit id="69b7f956cdb0d8e690f8921a39588f88b303dc69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; Coming back to this answer after a year of security research, I realize it makes the rather unfortunate implication that you would ever actually compare plaintext passwords. Please don't. &lt;a href=&quot;https://stackoverflow.com/questions/2860943/how-can-i-hash-a-password-in-java&quot;&gt;Use a secure one-way hash with a salt and a reasonable number of iterations&lt;/a&gt;. Consider using a library: this stuff is hard to get right!</source>
          <target state="translated">&lt;strong&gt;編集：&lt;/strong&gt; 1年のセキュリティ調査の後にこの回答に戻ると、プレーンテキストのパスワードを実際に比較することはかなり残念なことです。 しないでください。 &lt;a href=&quot;https://stackoverflow.com/questions/2860943/how-can-i-hash-a-password-in-java&quot;&gt;ソルトと妥当な回数の反復を伴う安全な一方向ハッシュを使用します&lt;/a&gt; 。 ライブラリの使用を検討してください。これを正しく行うのは困難です。</target>
        </trans-unit>
        <trans-unit id="e60aa3b140458b9e42618bd0b3a05e257cc2dc56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original answer:&lt;/strong&gt; What about the fact that String.equals() uses &lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/lang/String.java#String.equals%28java.lang.Object%29&quot;&gt;short-circuit evaluation&lt;/a&gt;, and is therefore vulnerable to a timing attack? It may be unlikely, but you could &lt;em&gt;theoretically&lt;/em&gt; time the password comparison in order to determine the correct sequence of characters.</source>
          <target state="translated">&lt;strong&gt;元の回答：&lt;/strong&gt; String.equals（）が&lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8-b132/java/lang/String.java#String.equals%28java.lang.Object%29&quot;&gt;短絡評価を&lt;/a&gt;使用しているため、タイミング攻撃に対して脆弱であるという事実はどうですか？ ありそうもないかもしれませんが、正しい文字シーケンスを決定するために、 &lt;em&gt;理論的に&lt;/em&gt;はパスワード比較の時間を&lt;em&gt;計る&lt;/em&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="71c1051a13130dc057ae957211603eb7b21660e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strings are immutable&lt;/strong&gt;. That means once you've created the &lt;code&gt;String&lt;/code&gt;, if another process can dump memory, there's no way (aside from &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt;) you can get rid of the data before &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;garbage collection&lt;/a&gt; kicks in.</source>
          <target state="translated">&lt;strong&gt;文字列は不変&lt;/strong&gt;です。 つまり、 &lt;code&gt;String&lt;/code&gt; を作成した後、別のプロセスがメモリをダンプできる場合、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29&quot;&gt;ガベージコレクション&lt;/a&gt;が開始する前に（ &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;リフレクションを&lt;/a&gt;除いて）データを削除することはできません。</target>
        </trans-unit>
        <trans-unit id="200627b0eb37efd54845f9a6bd7c0133da5e8d51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bf1fec4ea517ac75d82aa127b348cecaa117a7d" translate="yes" xml:space="preserve">
          <source>A Lesson In Timing Attacks</source>
          <target state="translated">タイミングアタックのレッスン</target>
        </trans-unit>
        <trans-unit id="94ac581f37ab2d56dfe8fa01845f896c48ea2c7c" translate="yes" xml:space="preserve">
          <source>And as it turns out, there is nothing that lets you clear the private information of a &lt;code&gt;PrivateKey&lt;/code&gt; from memory, because there's no API that lets you wipe the bytes that form the corresponding information.</source>
          <target state="translated">&lt;code&gt;PrivateKey&lt;/code&gt; 、対応する情報を形成するバイトをワイプできるAPIがないため、メモリからPrivateKeyのプライベート情報をクリアできるものはありません。</target>
        </trans-unit>
        <trans-unit id="698e47ef5df7856861e6bd29ada26e30e6c56a65" translate="yes" xml:space="preserve">
          <source>And of course, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Timing_attack&quot;&gt;Timing Attack Wikipedia page&lt;/a&gt;</source>
          <target state="translated">そしてもちろん、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Timing_attack&quot;&gt;タイミング攻撃ウィキペディアのページ&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35879106f4ed216fdb6c73f43b27a8729c325a87" translate="yes" xml:space="preserve">
          <source>As Jon Skeet states, there is no way except by using reflection.</source>
          <target state="translated">Jon Skeetが述べているように、反射を使う以外に方法はありません。</target>
        </trans-unit>
        <trans-unit id="36331cef84c6d35142e7b76dbacd89b8ff6a7d65" translate="yes" xml:space="preserve">
          <source>As noted in the comments, it's possible that arrays being moved by the garbage collector will leave stray copies of the data in memory. I believe this is implementation-specific - the garbage collector &lt;em&gt;may&lt;/em&gt; clear all memory as it goes, to avoid this sort of thing. Even if it does, there's still the time during which the &lt;code&gt;char[]&lt;/code&gt; contains the actual characters as an attack window.</source>
          <target state="translated">コメントで述べたように、ガベージコレクターによって移動されている配列がメモリにデータの浮遊コピーを残す可能性があります。 これは実装固有のものだと思います。ガベージコレクターは、このような事態を避けるために、すべてのメモリをクリアする&lt;em&gt;可能性&lt;/em&gt;があります。 そうしたとしても、 &lt;code&gt;char[]&lt;/code&gt; が実際の文字を攻撃ウィンドウとして含む時間はまだあります。</target>
        </trans-unit>
        <trans-unit id="ea94246ffb44ab6b727efb8d392dd9232ef47c1b" translate="yes" xml:space="preserve">
          <source>Based on the above circumstances, one can get an idea whether to go with String or to go with Char[] for their requirements.</source>
          <target state="translated">上記のような状況を踏まえて、要件に応じてStringを使用するかChar[]を使用するかを判断することができます。</target>
        </trans-unit>
        <trans-unit id="ff08257691f084f5bb4321a9521146f84621c841" translate="yes" xml:space="preserve">
          <source>Because of the security concern it is better to store password as a character array.</source>
          <target state="translated">セキュリティ上の懸念があるため、パスワードは文字列の配列として保存した方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="fc94856bbf7a5446009d35b73ca294f9cc65c6ce" translate="yes" xml:space="preserve">
          <source>But that alone isn't a good answer; why not just make sure a reference to the &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; doesn't escape? Then there's no security issue. But the thing is that &lt;code&gt;String&lt;/code&gt; objects can be &lt;code&gt;intern()&lt;/code&gt;ed in theory and kept alive inside the constant pool. I suppose using &lt;code&gt;char[]&lt;/code&gt; forbids this possibility.</source>
          <target state="translated">しかし、それだけでは良い答えではありません。 &lt;code&gt;char[]&lt;/code&gt; または &lt;code&gt;String&lt;/code&gt; への参照がエスケープしないことを確認しないでください。 その後、セキュリティの問題はありません。 しかし、重要なことは、 &lt;code&gt;String&lt;/code&gt; オブジェクトは理論的には &lt;code&gt;intern()&lt;/code&gt; で編集され、定数プール内で存続できるということです。 &lt;code&gt;char[]&lt;/code&gt; を使用すると、この可能性が禁止されると思います。</target>
        </trans-unit>
        <trans-unit id="f7b798d770ca2df60818ef3a16e84e4d0302362b" translate="yes" xml:space="preserve">
          <source>Char[] is mutable, but it has the advantage that after its usage the programmer can explicitly clean the array or override values. So when it's done being used it is cleaned and no one could ever know about the information you had stored.</source>
          <target state="translated">Char[]は突然変異可能ですが、使用後にプログラマが明示的に配列をクリーンアップしたり、値をオーバーライドしたりできるという利点があります。そのため、使用が終了すると、それはクリーンアップされ、誰もあなたが保存していた情報を知ることができなくなります。</target>
        </trans-unit>
        <trans-unit id="f2d5fad3855bcb5cf79c403b8fae8134166583c5" translate="yes" xml:space="preserve">
          <source>Character arrays (&lt;code&gt;char[]&lt;/code&gt;) can be cleared after use by setting each character to zero and Strings not. If someone can somehow see the memory image, they can see a password in plain text if Strings are used, but if &lt;code&gt;char[]&lt;/code&gt; is used, after purging data with 0's, the password is secure.</source>
          <target state="translated">文字配列（ &lt;code&gt;char[]&lt;/code&gt; ）は、使用後に各文字をゼロに設定し、文字列をゼロに設定しないことでクリアできます。 誰かが何らかの形でメモリイメージを見ることができる場合、文字列を使用するとパスワードはプレーンテキストで表示されますが、 &lt;code&gt;char[]&lt;/code&gt; を使用すると、0でデータを消去した後、パスワードは安全です。</target>
        </trans-unit>
        <trans-unit id="fe2e10fde78683521d4003ae2215af5b39ef6231" translate="yes" xml:space="preserve">
          <source>Consider this:</source>
          <target state="translated">これを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="61da8effd39d181e7d2fbf216216c68b5d82129d" translate="yes" xml:space="preserve">
          <source>However, Java changes all the time, and some scary features like &lt;a href=&quot;https://stackoverflow.com/questions/27949213/string-deduplication-feature-of-java-8&quot;&gt;String Deduplication feature of Java 8&lt;/a&gt; might intern String objects without your knowledge. But that's a different conversation.</source>
          <target state="translated">ただし、Javaは常に変化し、 &lt;a href=&quot;https://stackoverflow.com/questions/27949213/string-deduplication-feature-of-java-8&quot;&gt;Java 8の文字列重複排除機能&lt;/a&gt;などのいくつかの恐ろしい機能は、知らないうちにStringオブジェクトをインターンする可能性があります。 しかし、それは別の会話です。</target>
        </trans-unit>
        <trans-unit id="4085390bb3f3a972df1be47fd22afa929e468c7e" translate="yes" xml:space="preserve">
          <source>However, if reflection is an option for you, you can do this.</source>
          <target state="translated">しかし、リフレが選択肢の一つになるのであれば、このようにすることができます。</target>
        </trans-unit>
        <trans-unit id="2ce1845c70b9dc4de0441f1a0e5b0d33534ff75d" translate="yes" xml:space="preserve">
          <source>I don't think this is a valid suggestion, but, I can at least guess at the reason.</source>
          <target state="translated">妥当な提案ではないと思いますが、理由くらいは推測できます。</target>
        </trans-unit>
        <trans-unit id="151bc7b0c4f1b70bc4b73e26ef103e85b31bf68d" translate="yes" xml:space="preserve">
          <source>I think the motivation is wanting to make sure that you can erase all trace of the password in memory promptly and with certainty after it is used. With a &lt;code&gt;char[]&lt;/code&gt; you could overwrite each element of the array with a blank or something for sure. You can't edit the internal value of a &lt;code&gt;String&lt;/code&gt; that way.</source>
          <target state="translated">動機は、メモリ内のパスワードのすべての痕跡を、使用後に迅速かつ確実に消去できるようにすることです。 &lt;code&gt;char[]&lt;/code&gt; を使用すると、配列の各要素を確実に空白などで上書きできます。 &lt;code&gt;String&lt;/code&gt; の内部値をそのように編集することはできません。</target>
        </trans-unit>
        <trans-unit id="ac37450fb5de9b14d5b22b707a61b326fc006e75" translate="yes" xml:space="preserve">
          <source>I'm thinking of e.g. the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/security/PrivateKey.html&quot;&gt;PrivateKey&lt;/a&gt; class. Consider a scenario where you would load a private RSA key from a PKCS#12 file, using it to perform some operation. Now in this case, sniffing the password alone wouldn't help you much as long as physical access to the key file is properly restricted. As an attacker, you would be much better off if you obtained the key directly instead of the password. The desired information can be leaked manifold, core dumps, a debugger session or swap files are just some examples.</source>
          <target state="translated">私は&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/security/PrivateKey.html&quot;&gt;PrivateKey&lt;/a&gt;クラスなどを考えています。 RSA秘密鍵をPKCS＃12ファイルからロードし、それを使用して何らかの操作を実行するシナリオを考えてみます。 この場合、キーファイルへの物理的なアクセスが適切に制限されている限り、パスワードを盗聴するだけではあまり役に立ちません。 攻撃者は、パスワードの代わりにキーを直接入手した方がはるかによいでしょう。 必要な情報は、リークされたマニホールド、コアダンプ、デバッガセッション、スワップファイルなどです。</target>
        </trans-unit>
        <trans-unit id="57001b779997c68b84ea322da58afc3b9aee11b7" translate="yes" xml:space="preserve">
          <source>If possible, disabling core dumps and the swap file would take care of both problems. However, they would require administrator rights and may reduce functionality (less memory to use) and pulling RAM from a running system would still be a valid concern.</source>
          <target state="translated">可能であれば、コアダンプとスワップファイルを無効にすれば、両方の問題を解決できるでしょう。しかし、それらは管理者権限を必要とし、機能性を低下させる可能性があります(使用するメモリが少なくなる)。</target>
        </trans-unit>
        <trans-unit id="33fe3db7ec48beac0c68de9fcd8d0c76bda59e6e" translate="yes" xml:space="preserve">
          <source>If the value of the string is modified then it will end up creating a new string. So both the original value and the modified value stay in the memory until it is garbage collected.</source>
          <target state="translated">文字列の値が変更された場合、新しい文字列が作成されます。そのため、元の値と修正された値の両方がガベージコレクションされるまでメモリ内に残ります。</target>
        </trans-unit>
        <trans-unit id="914d4c3b06c646d3115826f9e7120eefcb75df0a" translate="yes" xml:space="preserve">
          <source>In Swing, the password field has a &lt;code&gt;getPassword()&lt;/code&gt; (returns &lt;code&gt;char[]&lt;/code&gt;) method instead of the usual &lt;code&gt;getText()&lt;/code&gt; (returns &lt;code&gt;String&lt;/code&gt;) method. Similarly, I have come across a suggestion not to use &lt;code&gt;String&lt;/code&gt; to handle passwords.</source>
          <target state="translated">Swingでは、パスワードフィールドに、通常の &lt;code&gt;getText()&lt;/code&gt; （ &lt;code&gt;String&lt;/code&gt; 返す）メソッドの代わりに、 &lt;code&gt;getPassword()&lt;/code&gt; （ &lt;code&gt;char[]&lt;/code&gt; 返す）メソッドがあります。 同様に、 &lt;code&gt;String&lt;/code&gt; を使用してパスワードを処理しないという提案を見つけました。</target>
        </trans-unit>
        <trans-unit id="f3e385fc6478055a321c64cb02009cc9d7e54bd6" translate="yes" xml:space="preserve">
          <source>It is debatable as to whether you should use String or use Char[] for this purpose because both have their advantages and disadvantages. It depends on what the user needs.</source>
          <target state="translated">この目的のためにStringを使うべきか、Char[]を使うべきかは、どちらにも長所と短所があるので議論の余地があります。ユーザーが何を必要としているかによります。</target>
        </trans-unit>
        <trans-unit id="6892d03a0b1a14ba14ef1fe5bba377b5df3f74f4" translate="yes" xml:space="preserve">
          <source>It would seem logical to collect and store the password in an object
  of type &lt;code&gt;java.lang.String&lt;/code&gt;. However, here's the caveat: &lt;code&gt;Object&lt;/code&gt;s of
  type &lt;code&gt;String&lt;/code&gt; are immutable, i.e., there are no methods defined that
  allow you to change (overwrite) or zero out the contents of a &lt;code&gt;String&lt;/code&gt;
  after usage. This feature makes &lt;code&gt;String&lt;/code&gt; objects unsuitable for
  storing security sensitive information such as user passwords. You
  should always collect and store security sensitive information in a
  &lt;code&gt;char&lt;/code&gt; array instead.</source>
          <target state="translated">パスワードを収集して &lt;code&gt;java.lang.String&lt;/code&gt; 型のオブジェクトに格納するのは理にかなっているようです。 ただし、ここで注意点があります。String型の &lt;code&gt;Object&lt;/code&gt; は不変です。つまり、使用後に &lt;code&gt;String&lt;/code&gt; の内容を変更（上書き）またはゼロ化できるメソッドは定義されていません。 この機能により、 &lt;code&gt;String&lt;/code&gt; オブジェクトは、ユーザーのパスワードなどの機密情報を格納するのに不適切になります。 代わりに、セキュリティの機密情報を収集して &lt;code&gt;char&lt;/code&gt; 配列に保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="8684c3b4018676a3106d93184438755a93bce417" translate="yes" xml:space="preserve">
          <source>Note: if the String's char[] has been copied as a part of a GC cycle, there is a chance the previous copy is somewhere in memory.</source>
          <target state="translated">注意:もしStringのchar[]がGCサイクルの一部としてコピーされている場合、前のコピーがメモリのどこかにある可能性があります。</target>
        </trans-unit>
        <trans-unit id="a4510da9e949f0f4ef9576982abd7e611df40556" translate="yes" xml:space="preserve">
          <source>Now garbage collection in Java doesn't happen at any guaranteed interval. The &lt;code&gt;String&lt;/code&gt; can thus persist in memory for a long time, and if a process crashes during this time, the contents of the string may end up in a memory dump or some log.</source>
          <target state="translated">現在、Javaのガベージコレクションは保証された間隔で発生しません。 したがって、 &lt;code&gt;String&lt;/code&gt; はメモリ内に長期間存続する可能性があり、この間にプロセスがクラッシュした場合、文字列の内容がメモリダンプまたはログに記録される可能性があります。</target>
        </trans-unit>
        <trans-unit id="009c1ad62959bdccaf0ac3c21fa53db992bb4841" translate="yes" xml:space="preserve">
          <source>On the other side char[] are mutable as soon as the authentication is done you can overwrite them with any character like all M's or backslashes. Now even if someone takes a heap dump he might not be able to get the passwords which are not currently in use. This gives you more control in the sense like clearing the Object content yourself vs waiting for the GC to do it.</source>
          <target state="translated">一方、char[]は認証が完了するとすぐに、すべての M やバックスラッシュのような任意の文字で上書きすることができます。これで、誰かがヒープダンプを取ったとしても、現在使用されていないパスワードを取得できなくなるかもしれません。これは、GC がそれを行うのを待つのではなく、自分でオブジェクトの内容をクリアするような意味で、より多くの制御を可能にします。</target>
        </trans-unit>
        <trans-unit id="808ddd5c0f070dc1407e36a6c3bd4a098c623be2" translate="yes" xml:space="preserve">
          <source>One scenario where the attacker could use it is a crashdump - when the JVM crashes and generates a memory dump - you will be able to see the password.</source>
          <target state="translated">攻撃者がこれを使用する可能性があるシナリオの1つは、クラッシュダンプです-JVMがクラッシュしてメモリダンプを生成すると、パスワードを見ることができます。</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="d23d8cc1d470710d96e727d64982b4e074a1ad39" translate="yes" xml:space="preserve">
          <source>Referenced from &lt;a href=&quot;http://javarevisited.blogspot.com/2012/03/why-character-array-is-better-than.html&quot;&gt;this blog&lt;/a&gt;.
I hope this helps.</source>
          <target state="translated">&lt;a href=&quot;http://javarevisited.blogspot.com/2012/03/why-character-array-is-better-than.html&quot;&gt;このブログ&lt;/a&gt;から参照。 これがお役に立てば幸いです。</target>
        </trans-unit>
        <trans-unit id="da39838ea50b051a48f69227a80db6d3ae54cb71" translate="yes" xml:space="preserve">
          <source>Since Strings in Java are immutable, whenever some tries to manipulate your string it creates a new Object and the existing String remains unaffected. This could be seen as an advantage for storing a password as a String, but the object remains in memory even after use. So if anyone somehow got the memory location of the object, that person can easily trace your password stored at that location.</source>
          <target state="translated">Java の文字列は不変なので、何者かが文字列を操作しようとするといつでも新しいオブジェクトが作成され、既存の文字列は影響を受けません。これは、パスワードを文字列として保存する場合の利点とも言えますが、オブジェクトは使用後もメモリ内に残ります。そのため、もし誰かが何らかの方法でオブジェクトのメモリの場所を取得した場合、その人はその場所に保存されているパスワードを簡単にトレースすることができます。</target>
        </trans-unit>
        <trans-unit id="6539fcd58f3cfe01d8e3345fd5cc498d2c1757ca" translate="yes" xml:space="preserve">
          <source>Since anyone who has access to the memory dump can find the password in clear text, that's another reason you should always use an encrypted password rather than plain text. Since Strings are immutable there is no way the contents of Strings can be changed because any change will produce a new String, while if you use a char[] you can still set all the elements as blank or zero. So storing a password in a character array clearly mitigates the security risk of stealing a password.</source>
          <target state="translated">メモリダンプにアクセスできる人は誰でもパスワードをクリアテキストで見つけることができるので、パスワードは常にプレーンテキストではなく暗号化されたものを使うべきです。文字列は不変なので、文字列の内容を変更することはできません。ですから、文字列配列にパスワードを格納することで、パスワードを盗むというセキュリティ上のリスクを明らかに軽減することができます。</target>
        </trans-unit>
        <trans-unit id="2adb89ba4d12684aa374a2b6fe43ad82b7834618" translate="yes" xml:space="preserve">
          <source>So yes, this &lt;em&gt;is&lt;/em&gt; a security concern - but even using &lt;code&gt;char[]&lt;/code&gt; only reduces the window of opportunity for an attacker, and it's only for this specific type of attack.</source>
          <target state="translated">つまり、これ&lt;em&gt;は&lt;/em&gt;セキュリティ上の問題です。ただし、 &lt;code&gt;char[]&lt;/code&gt; を使用しても、攻撃者にとっての機会の窓が減るだけであり、これは、この特定の種類の攻撃のためだけのものです。</target>
        </trans-unit>
        <trans-unit id="1de0b546e683d80be916c3f763396811703e5bf0" translate="yes" xml:space="preserve">
          <source>Some information, such as Social Security numbers (SSNs) and
  passwords, is highly sensitive. This information should not be kept
  for longer than necessary nor where it may be seen, even by
  administrators. For instance, it should not be sent to log files and
  its presence should not be detectable through searches. Some transient
  data may be kept in mutable data structures, such as char arrays, and
  cleared immediately after use. Clearing data structures has reduced
  effectiveness on typical Java runtime systems as objects are moved in
  memory transparently to the programmer.</source>
          <target state="translated">社会保障番号(SSN)やパスワードなどの情報の中には、非常に機密性の高いものがあります。この情報は必要以上に長く保管したり、管理者であっても見られる可能性のある場所に保管してはいけません。例えば、ログファイルに送信してはならず、また検索によってその存在が検出されないようにしてください。一時的なデータの中には、char 配列のような変異可能なデータ構造に保存され、使用後すぐにクリアされるものもあります。データ構造をクリアすることは、典型的なJavaランタイムシステムでは、オブジェクトがプログラマに透過的にメモリ内を移動するため、有効性が低下します。</target>
        </trans-unit>
        <trans-unit id="342e9eaee08708bfd19f663e2797e6c4835f202f" translate="yes" xml:space="preserve">
          <source>Some more resources on timing attacks:</source>
          <target state="translated">タイミングアタックに関するいくつかのリソース。</target>
        </trans-unit>
        <trans-unit id="70ec593d69ff444a0c4f8c40a5b655665549f9ff" translate="yes" xml:space="preserve">
          <source>Some people believe that you have to overwrite the memory used to store the password once you no longer need it. This reduces the time window an attacker has to read the password from your system and completely ignores the fact that the attacker already needs enough access to hijack the JVM memory to do this. An attacker with that much access can catch your key events making this completely useless (AFAIK, so please correct me if I am wrong).</source>
          <target state="translated">パスワードを保存するために使用されていたメモリを、必要なくなったら上書きしなければならないと考える人もいます。これは、攻撃者がシステムからパスワードを読み取る時間を短縮し、攻撃者がこれを行うためにJVMメモリをハイジャックするのに十分なアクセスをすでに必要としているという事実を完全に無視しています。これだけのアクセスを持つ攻撃者は、あなたのキーイベントをキャッチすることができるので、これは完全に無意味です(AFAIKではありませんので、私が間違っていたら訂正してください)。</target>
        </trans-unit>
        <trans-unit id="a15471736d5db023d6a76ce568c8d2f6f77e6fd4" translate="yes" xml:space="preserve">
          <source>String in java is immutable. So whenever a string is created, it will remain in the memory until it is garbage collected. So anyone who has access to the memory can read the value of the string.</source>
          <target state="translated">javaの文字列は不変です。そのため、文字列が作成されるたびに、それがガベージコレクションされるまでメモリ内に残ります。つまり、メモリにアクセスできる人は誰でも文字列の値を読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="70292d1b61c498137fcfe048ab768be8db94f7d9" translate="yes" xml:space="preserve">
          <source>String is immutable and it goes to the string pool. Once written, it cannot be overwritten.</source>
          <target state="translated">Stringは不変で、文字列プールに行きます。一度書き込まれたものは上書きできません。</target>
        </trans-unit>
        <trans-unit id="7d63b7c3c393127b2e12ff515941706150a569e2" translate="yes" xml:space="preserve">
          <source>Strings are immutable and cannot be altered once they have been created. Creating a password as a string will leave stray references to the password on the heap or on the String pool. Now if someone takes a heap dump of the Java process and carefully scans through he might be able to guess the passwords. Of course these non used strings will be garbage collected but that depends on when the GC kicks in.</source>
          <target state="translated">文字列は不変であり、一度作成したものは変更できません。パスワードを文字列として作成すると、ヒープや文字列プールにパスワードへの参照が残ります。もし誰かがJavaプロセスのヒープダンプを取って注意深くスキャンすれば、パスワードを推測できるかもしれません。もちろん、これらの使用されていない文字列はガベージコレクションされますが、それはGCがいつキックインするかに依存します。</target>
        </trans-unit>
        <trans-unit id="a50bf4dfb5987fd653ea7a3d545740bdb6a92ca3" translate="yes" xml:space="preserve">
          <source>Take a look at the &lt;sub&gt;widely used&lt;/sub&gt; Spring Security library &lt;a href=&quot;http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.security/spring-security-web/3.0.1.RELEASE/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.java#73&quot;&gt;here&lt;/a&gt; and ask yourself - are Spring Security guys incompetent or char[] passwords just don't make much sense. When some nasty hacker grabs memory dumps of your RAM be sure s/he'll get all the passwords even if you use sophisticated ways to hide them.</source>
          <target state="translated">&lt;a href=&quot;http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.security/spring-security-web/3.0.1.RELEASE/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.java#73&quot;&gt;ここで&lt;/a&gt; &lt;sub&gt;広く使用されている&lt;/sub&gt; Spring Securityライブラリを見て、考えてみてください。SpringSecurityの無能なパスワードやchar []パスワードは、あまり意味がありません。 悪意のあるハッカーがRAMのメモリダンプを取得した場合、高度な方法でパスワードを非表示にしても、すべてのパスワードを入手できることを確認してください。</target>
        </trans-unit>
        <trans-unit id="a7a4c75efd48757679ac6c3d07cd60ad382ace9d" translate="yes" xml:space="preserve">
          <source>Thanks to the comments I have to update my answer. Apparently there are two cases where this can add a (very) minor security improvement as it reduces the time a password could land on the hard drive. Still I think it's overkill for most use cases.</source>
          <target state="translated">コメントのおかげで、私は私の答えを更新する必要があります。どうやら、パスワードがハードドライブに届くまでの時間を短縮することで、(非常に)マイナーなセキュリティの改善を加えることができる2つのケースがあるようです。それでも私は、ほとんどのユースケースではやりすぎだと思います。</target>
        </trans-unit>
        <trans-unit id="2b26660b7b422e0609c382be6b48bf115b3c7e78" translate="yes" xml:space="preserve">
          <source>That is not necessarily a malicious external attacker. This could be a support user that has access to the server for monitoring purposes. He could peek into a crashdump and find the passwords.</source>
          <target state="translated">それは必ずしも悪意のある外部からの攻撃者とは限りません。これは監視目的でサーバにアクセスできるサポートユーザかもしれません。クラッシュダンプを覗き見してパスワードを見つけられるかもしれません。</target>
        </trans-unit>
        <trans-unit id="87c04911712a5eca03edfca8a7dc86c33db8574d" translate="yes" xml:space="preserve">
          <source>The OpenSSL library for example overwrites critical memory sections before private keys are freed. Since Java is garbage-collected, we would need explicit methods to wipe and invalidate private information for Java keys, which are to be applied immediately after using the key.</source>
          <target state="translated">例えばOpenSSLライブラリは、秘密鍵が解放される前に重要なメモリセクションを上書きします。Java はガベージコレクションされているので、Java 鍵の秘密情報を消去したり無効にしたりするための明示的なメソッドが必要になります。</target>
        </trans-unit>
        <trans-unit id="5d904c18a0d5e2b983c5e3b0a1ec77093be40a8a" translate="yes" xml:space="preserve">
          <source>The answer has already been given, but I'd like to share an issue that I discovered lately with Java standard libraries. While they take great care now of replacing password strings with &lt;code&gt;char[]&lt;/code&gt; everywhere (which of course is a good thing), other security-critical data seems to be overlooked when it comes to clearing it from memory.</source>
          <target state="translated">答えはすでに出ていますが、最近発見した問題をJava標準ライブラリと共有したいと思います。 今ではパスワード文字列をどこでも &lt;code&gt;char[]&lt;/code&gt; で置き換えることに注意を払っていますが（もちろん、これは良いことです）、メモリからデータを消去するときに、他のセキュリティ上重要なデータを見落としているようです。</target>
        </trans-unit>
        <trans-unit id="9cdb971985ae17b650f8064ac735ff984c433ea3" translate="yes" xml:space="preserve">
          <source>The short and straightforward answer would be because &lt;code&gt;char[]&lt;/code&gt; is mutable while &lt;code&gt;String&lt;/code&gt; objects are not.</source>
          <target state="translated">短く簡単な答えは、 &lt;code&gt;char[]&lt;/code&gt; は変更可能ですが、 &lt;code&gt;String&lt;/code&gt; オブジェクトは変更できないためです。</target>
        </trans-unit>
        <trans-unit id="c831e687484a08e9210ad3468fba111f383b12f4" translate="yes" xml:space="preserve">
          <source>There is nothing that char array gives you vs String unless you clean it up manually after use, and I haven't seen anyone actually doing that. So to me the preference of char[] vs String is a bit exaggerated.</source>
          <target state="translated">使用後に手動でクリーンアップしない限り、char配列がStringに対して与えるものは何もありませんし、実際にそうしている人を見たことがありません。ですから、char[]対Stringの優劣は少し誇張されていると思います。</target>
        </trans-unit>
        <trans-unit id="c29c1dc60896ca5c2015a47b5d9b6fedd7054557" translate="yes" xml:space="preserve">
          <source>These are all the reasons, one should choose a &lt;strong&gt;char[]&lt;/strong&gt; array instead of &lt;strong&gt;String&lt;/strong&gt; for a password.</source>
          <target state="translated">これらはすべて理由です。パスワードには&lt;strong&gt;String&lt;/strong&gt;ではなく&lt;strong&gt;char []&lt;/strong&gt;配列を選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="5fd0d8098dcf68fcf92acb8477b5a5f142c06ffb" translate="yes" xml:space="preserve">
          <source>This guideline also has implications for implementation and use of
  lower-level libraries that do not have semantic knowledge of the data
  they are dealing with. As an example, a low-level string parsing
  library may log the text it works on. An application may parse an SSN
  with the library. This creates a situation where the SSNs are
  available to administrators with access to the log files.</source>
          <target state="translated">このガイドラインは、扱うデータの意味的な知識を持たない低レベルのライブラリの実装や利用にも影響を与えます。例えば、低レベルの文字列解析ライブラリは、作業したテキストをログに記録しているかもしれません。アプリケーションは、ライブラリを使ってSSNを解析するかもしれません。これは、ログファイルにアクセスできる管理者がSSNを利用できる状況を作り出します。</target>
        </trans-unit>
        <trans-unit id="0b542944974a2f4551f2b6ab738b0d93fd70b517" translate="yes" xml:space="preserve">
          <source>This is a bad situation, as this &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.77.3297&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;paper&lt;/a&gt; describes how this circumstance could be potentially exploited.</source>
          <target state="translated">この&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.77.3297&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;ホワイトペーパーで&lt;/a&gt;は、この状況がどのように悪用される可能性があるかについて説明しているため、これは悪い状況です。</target>
        </trans-unit>
        <trans-unit id="60a8a4000e8f0bc7de20f87190fb4c8e81516e21" translate="yes" xml:space="preserve">
          <source>This old copy wouldn't appear in a heap dump, but if you have direct access to the raw memory of the process you could see it.  In general you should avoid anyone having such access.</source>
          <target state="translated">この古いコピーはヒープダンプには表示されませんが、プロセスの生のメモリに直接アクセスすることができれば、それを見ることができます。一般的には、そのようなアクセス権を持っている人は避けるべきです。</target>
        </trans-unit>
        <trans-unit id="9c1079be9137eb36b54da5688745bf117e61534d" translate="yes" xml:space="preserve">
          <source>To quote an official document, the &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#PBEEx&quot;&gt;Java Cryptography Architecture guide&lt;/a&gt; says this about &lt;code&gt;char[]&lt;/code&gt; vs. &lt;code&gt;String&lt;/code&gt; passwords (about password-based encryption, but this is more generally about passwords of course):</source>
          <target state="translated">公式ドキュメントを引用すると、 &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#PBEEx&quot;&gt;Java暗号化アーキテクチャガイドで&lt;/a&gt;は、 &lt;code&gt;char[]&lt;/code&gt; と &lt;code&gt;String&lt;/code&gt; パスワードについて（パスワードベースの暗号化についてですが、より一般的にはパスワードについてです）と述べています。</target>
        </trans-unit>
        <trans-unit id="09c96217cecf5158d9c599143709c0bf43a4b916" translate="yes" xml:space="preserve">
          <source>While other suggestions here seem valid, there is one other good reason. With plain &lt;code&gt;String&lt;/code&gt; you have much higher chances of &lt;strong&gt;accidentally printing the password to logs&lt;/strong&gt;, monitors or some other insecure place. &lt;code&gt;char[]&lt;/code&gt; is less vulnerable.</source>
          <target state="translated">ここでの他の提案は有効であるように見えますが、もう1つの理由があります。 プレーンな &lt;code&gt;String&lt;/code&gt; を使用すると、 &lt;strong&gt;誤ってパスワードをログ&lt;/strong&gt; 、モニター、またはその他の安全でない場所に出力する可能性が高く&lt;strong&gt;なります&lt;/strong&gt; 。 &lt;code&gt;char[]&lt;/code&gt; は脆弱性が低いです。</target>
        </trans-unit>
        <trans-unit id="f86d971b4a867c5b4b839105b6b5d514d24257f3" translate="yes" xml:space="preserve">
          <source>Why does &lt;code&gt;String&lt;/code&gt; pose a threat to security when it comes to passwords?
It feels inconvenient to use &lt;code&gt;char[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; の場合、 Stringはなぜセキュリティを脅かすのですか？ &lt;code&gt;char[]&lt;/code&gt; を使用するのは不便です。</target>
        </trans-unit>
        <trans-unit id="be87eb63b17c07d23faf558d201b11e61486e392" translate="yes" xml:space="preserve">
          <source>Why is char[] preferred over String for passwords</source>
          <target state="translated">パスワードに文字列よりも char[]を使用する理由</target>
        </trans-unit>
        <trans-unit id="96c058528af12a3ec3c0a6a4356b9a336391a6da" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;character array&lt;/em&gt;, you can read the password, finish working with it as soon as you can, and then immediately change the contents.</source>
          <target state="translated">&lt;em&gt;文字配列を&lt;/em&gt;使用すると、パスワードを読み取り、できるだけ早くパスワードの操作を終了して、すぐに内容を変更できます。</target>
        </trans-unit>
        <trans-unit id="252e94464c28d121b2ac7065cfdc63317b907d6d" translate="yes" xml:space="preserve">
          <source>With an array, you can explicitly wipe the data after you're done with it. You can overwrite the array with anything you like, and the password won't be present anywhere in the system, even before garbage collection.</source>
          <target state="translated">配列を使えば、データを消去した後に明示的にデータを消去することができます。配列を好きなもので上書きすることができ、ガベージコレクションの前でもパスワードはシステムのどこにも存在しません。</target>
        </trans-unit>
        <trans-unit id="7b2e2713e36f214c8c2b0f0732ccc93580279e73" translate="yes" xml:space="preserve">
          <source>With the character array, the contents of the array can be modified or erased once the purpose of the password is served. The original contents of the array will not be found in memory after it is modified and even before the garbage collection kicks in.</source>
          <target state="translated">文字配列では、パスワードの目的が達成されると、配列の内容を変更したり、消去したりすることができます。配列の元の内容は、変更された後も、ガベージコレクションが開始される前であっても、メモリ内には見つかりません。</target>
        </trans-unit>
        <trans-unit id="5e436ad0706341ed15fd79a042f530dfaa544abb" translate="yes" xml:space="preserve">
          <source>Your software has to be overly paranoid to prevent data leaks with the attacker gaining access to the hardware - using things like &lt;a href=&quot;http://en.wikipedia.org/wiki/TrueCrypt&quot;&gt;TrueCrypt&lt;/a&gt; (discontinued), &lt;a href=&quot;https://veracrypt.codeplex.com/&quot;&gt;VeraCrypt&lt;/a&gt;, or &lt;a href=&quot;https://ciphershed.org/&quot;&gt;CipherShed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/TrueCrypt&quot;&gt;TrueCrypt&lt;/a&gt; （廃止）、 &lt;a href=&quot;https://veracrypt.codeplex.com/&quot;&gt;VeraCrypt&lt;/a&gt; 、 &lt;a href=&quot;https://ciphershed.org/&quot;&gt;CipherShed&lt;/a&gt;などを使用して、攻撃者によるハードウェアへのアクセスによるデータ漏洩を防ぐために、ソフトウェアは過度に偏執的でなければなりません。</target>
        </trans-unit>
        <trans-unit id="6006f436777ec8eee5cc060e91d43457b96b5534" translate="yes" xml:space="preserve">
          <source>Your target system may be badly configured or you have to assume it is and you have to be paranoid about core dumps (can be valid if the systems are not managed by an administrator).</source>
          <target state="translated">ターゲットシステムの設定が悪いのかもしれませんし、そうだと仮定してコアダンプを妄想する必要があります(システムが管理者によって管理されていない場合に有効です)。</target>
        </trans-unit>
        <trans-unit id="f47a56647d19f0875be1a2557456e6f93d01cc5b" translate="yes" xml:space="preserve">
          <source>when run</source>
          <target state="translated">実行時</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
