<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/487258">
    <body>
      <group id="487258">
        <trans-unit id="df498b6e1ddfb06035cc2f060b77dcae692ec7ef" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;What is a plain English explanation of Big O? With as little formal
  definition as possible and simple mathematics.&lt;/em&gt;&quot;</source>
          <target state="translated">&quot; &lt;em&gt;Big O에 대한 평범한 영어 설명은 무엇입니까? 가능한 한 공식적인 정의가 적고 간단한 수학으로&lt;/em&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="743ffd5e6c073307e39f8ab64f2a620592932e7f" translate="yes" xml:space="preserve">
          <source>&quot;Big O&quot; describes the algorithm's performance and evaluates it.</source>
          <target state="translated">&quot;Big O&quot;는 알고리즘의 성능을 설명하고 평가합니다.</target>
        </trans-unit>
        <trans-unit id="b462328e08f4909b285edec4ff0990d6976efaea" translate="yes" xml:space="preserve">
          <source>&quot;Big O' achieves the above two with standardized &lt;code&gt;Notations&lt;/code&gt;.</source>
          <target state="translated">&quot;Big O '는 표준화 된 &lt;code&gt;Notations&lt;/code&gt; 위의 두 가지를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="13f9f8a3d4d7d94edeaf3b7b38263362fa788e6a" translate="yes" xml:space="preserve">
          <source>&quot;For large enough inputsize=N, no matter what the constant factor is, if I &lt;strong&gt;&lt;em&gt;double&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; the input size&lt;/em&gt;...</source>
          <target state="translated">&quot; &lt;em&gt;입력 크기를&lt;/em&gt; 충분히 크게하려면 상수 &lt;em&gt;크기&lt;/em&gt; 가 무엇이든 &lt;em&gt;입력 크기를&lt;/em&gt; &lt;strong&gt;&lt;em&gt;두 배로&lt;/em&gt;&lt;/strong&gt; 늘리면 ...</target>
        </trans-unit>
        <trans-unit id="839e4a2006b278a93c4dc0f1936567078302c3f3" translate="yes" xml:space="preserve">
          <source>&amp;hellip;</source>
          <target state="translated">&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="12f5efd72c115a3dfdb9aef75a93d8f6398d2f03" translate="yes" xml:space="preserve">
          <source>( *in a wonderful, &lt;em&gt;unit-free&lt;/em&gt; sense of time!)</source>
          <target state="translated">(* &lt;em&gt;단위가없는&lt;/em&gt; 멋진 시간 감!)</target>
        </trans-unit>
        <trans-unit id="5f85db481a01c4c068358bc082055af7e5738d77" translate="yes" xml:space="preserve">
          <source>(**which is what matters, because people will &lt;a href=&quot;http://www.youtube.com/watch?v=OnA3C9Af_oc&quot;&gt;&lt;em&gt;always&lt;/em&gt; want more&lt;/a&gt;, whether they live today or tomorrow)</source>
          <target state="translated">(** 사람들이 오늘 또는 내일 살든 &lt;a href=&quot;http://www.youtube.com/watch?v=OnA3C9Af_oc&quot;&gt;&lt;em&gt;항상&lt;/em&gt; 더 많이 원&lt;/a&gt; 하기 때문에 중요한 일입니다.)</target>
        </trans-unit>
        <trans-unit id="111ed31dcbac4c6bfe6846c61c61ca1b11df6d01" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;edit&lt;/em&gt;: The &quot;plain English&quot; explanation ends here.)</source>
          <target state="translated">( &lt;em&gt;편집&lt;/em&gt; : &quot;일반 영어&quot;설명은 여기서 끝납니다.)</target>
        </trans-unit>
        <trans-unit id="6ce684a7aaa9d4a76848668e020344c53ae2b9ae" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;https://stackoverflow.com/q/7333376/711085&quot;&gt;Difference between average case and amortized analysis&lt;/a&gt; if interested in this subtopic.)</source>
          <target state="translated">이 하위 주제에 관심이있는 경우 &lt;a href=&quot;https://stackoverflow.com/q/7333376/711085&quot;&gt;평균 사례와 상각 분석의 차이를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="acf9d80cf9dbb5bb7520ab6662ebded396c6f175" translate="yes" xml:space="preserve">
          <source>(here, the &lt;code&gt;x&lt;/code&gt;s represent constant-time units of work, processor instructions, interpreter opcodes, whatever)</source>
          <target state="translated">(여기서, &lt;code&gt;x&lt;/code&gt; 는 상수 시간 단위, 프로세서 명령어, 인터프리터 opcode 등을 나타냅니다)</target>
        </trans-unit>
        <trans-unit id="e095c7e86ea34ae9aa5df712384da64165e0768e" translate="yes" xml:space="preserve">
          <source>(technically the constant factor could maybe matter in some more esoteric examples, but I've phrased things above (e.g. in log(N)) such that it doesn't)</source>
          <target state="translated">(기술적으로 일정한 요소는 좀 더 난해한 예에서 중요 할 수 있지만 위의 내용을 말하지 않았습니다 (예 : log (N)) 그렇지 않습니다)</target>
        </trans-unit>
        <trans-unit id="06d7bf9932a7f33791291e583cc05892187c54d8" translate="yes" xml:space="preserve">
          <source>(temporary digression from &quot;plain English&quot;:) If you wanted to prove this to yourself, you could perform some simple algebra on the ratio to split it up into multiple terms (&lt;code&gt;lim&lt;/code&gt; means &quot;considered in the limit of&quot;, just ignore it if you haven't seen it, it's just notation for &quot;and N is really really big&quot;):</source>
          <target state="translated">( &quot;평범한 영어&quot;의 일시적인 탈선 :) 이것을 스스로 증명하고 싶다면 비율에 대해 간단한 대수를 수행하여 여러 용어로 나눌 수 있습니다 ( &lt;code&gt;lim&lt;/code&gt; 은 &quot;한도에서 고려 됨&quot;을 의미합니다. 당신은 그것을 보지 못했습니다, 그것은 &quot;그리고 N은 정말로 크다&quot;라는 표기입니다.)</target>
        </trans-unit>
        <trans-unit id="11b4e1bb86ac129d3782b8fb89778b82b4699643" translate="yes" xml:space="preserve">
          <source>(with credit to &lt;a href=&quot;https://stackoverflow.com/a/487292/711085&quot;&gt;https://stackoverflow.com/a/487292/711085&lt;/a&gt; )</source>
          <target state="translated">( &lt;a href=&quot;https://stackoverflow.com/a/487292/711085&quot;&gt;https://stackoverflow.com/a/487292/711085에&lt;/a&gt; 크레딧으로)</target>
        </trans-unit>
        <trans-unit id="7bedee6fc739cfe745b69e77230823ca7b506921" translate="yes" xml:space="preserve">
          <source>... I &quot;(basically) double&quot; the time an O(N log(N)) algorithm takes.&quot; &lt;em&gt;(fairly common)&lt;/em&gt;</source>
          <target state="translated">... 나는 O (N log (N)) 알고리즘이 걸리는 시간을 &quot;(기본적으로) 배가&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="c2cc664a183cfc04e1a64249ea8f7c45673b79cb" translate="yes" xml:space="preserve">
          <source>... I add a fixed amount to the time an O(log(N)) (&quot;logarithmic time&quot;) algorithm takes.&quot; &lt;em&gt;(cheap!)&lt;/em&gt;</source>
          <target state="translated">... 나는 O (log (N)) ( &quot;logarithmic time&quot;) 알고리즘이 걸리는 시간에 고정 된 금액을 추가합니다. &quot; &lt;em&gt;(싼!)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9288b2e9d99d26a40d9f6f5b3a3990d8e5204b8b" translate="yes" xml:space="preserve">
          <source>... I don't change the time an O(1) (&quot;constant time&quot;) algorithm takes.&quot; &lt;em&gt;(the cheapest!)&lt;/em&gt;</source>
          <target state="translated">... 나는 O (1) ( &quot;일정 시간&quot;) 알고리즘이 걸리는 시간을 바꾸지 않습니다. &quot; &lt;em&gt;(가장 저렴합니다!)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac3db673dfe1df5538b14e8981fdd7f64c253879" translate="yes" xml:space="preserve">
          <source>... I double the time an O(N) (&quot;linear time&quot;) algorithm takes.&quot;</source>
          <target state="translated">... 나는 O (N) ( &quot;선형 시간&quot;) 알고리즘에 걸리는 시간을 두 배로 늘 렸습니다. &quot;</target>
        </trans-unit>
        <trans-unit id="a1e7e1ffe28ec1263008a387034b2aaa20a40664" translate="yes" xml:space="preserve">
          <source>... I double-cubed (octuple) the time an O(N&amp;sup3;) (&quot;cubic time&quot;) algorithm takes.&quot; &lt;em&gt;(e.g. a problem 100x as big takes 100&amp;sup3;=1000000x as long... very unsustainable)&lt;/em&gt;</source>
          <target state="translated">... 나는 O (N&amp;sup3;) ( &quot;cubic time&quot;) 알고리즘이 걸리는 시간을 두 배로 (옥수) 나눠 넣었습니다. &quot; &lt;em&gt;(예를 들어 100x 큰 문제는 100&amp;sup3; = 1000000x 긴 시간 ... 매우 지속 불가능한 문제)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eab0d87ea3058c371ba99238d90dc25bc68910e0" translate="yes" xml:space="preserve">
          <source>... I double-squared (quadruple) the time an O(N&amp;sup2;) (&quot;quadratic time&quot;) algorithm takes.&quot; &lt;em&gt;(e.g. a problem 100x as big takes 100&amp;sup2;=10000x as long... possibly unsustainable)&lt;/em&gt;</source>
          <target state="translated">... 나는 O (N&amp;sup2;) ( &quot;이차 시간&quot;) 알고리즘이 걸리는 시간을 2 제곱 (사 분위수)합니다. &quot; &lt;em&gt;(예를 들어 100x 큰 문제는 100&amp;sup2; = 10000x 오래 걸리지 만 아마도 지속 불가능한 문제)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a87538c4cde56e0a42c94f671c99d158235fbb02" translate="yes" xml:space="preserve">
          <source>... I ridiculously increase the time a O(2&lt;sup&gt;N&lt;/sup&gt;) (&quot;exponential time&quot;) algorithm takes.&quot; &lt;em&gt;(you'd double (or triple, etc.) the time just by increasing the problem by a single unit)&lt;/em&gt;</source>
          <target state="translated">... 나는 O (2 &lt;sup&gt;N&lt;/sup&gt; ) ( &quot;지수 시간&quot;) 알고리즘이 걸리는 시간을 엄청나게 증가시킵니다. &quot; &lt;em&gt;(단일 단위로 문제를 증가 시켜서 시간을 두 배로 (또는 삼중 등으로) 계산했습니다.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="758995d5c0c86f523c06ebeba129d83d2b577e5c" translate="yes" xml:space="preserve">
          <source>... and the ugly:</source>
          <target state="translated">... 그리고 못생긴 :</target>
        </trans-unit>
        <trans-unit id="5f8dd699eca2f4c835f1d41e82c48c0ee2badc97" translate="yes" xml:space="preserve">
          <source>... this means that &lt;strong&gt;&lt;em&gt;for &quot;large enough&quot; problem sizes N&lt;/em&gt;&lt;/strong&gt; (if we ignore stuff near the origin), there exists some constant (e.g. 2.5, completely made up) such that:</source>
          <target state="translated">... 이것은 &lt;strong&gt;&lt;em&gt;&quot;충분히 큰&quot;문제 크기 N&lt;/em&gt;&lt;/strong&gt; (원점 근처의 것을 무시하는 경우)에 대해 다음과 같은 상수 (예 : 2.5, 완전히 구성됨)가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="02da7ab518ed35b63049ed24f5f7b780a03cf03c" translate="yes" xml:space="preserve">
          <source>1 item: 1 second</source>
          <target state="translated">1 개 항목 : 1 초</target>
        </trans-unit>
        <trans-unit id="311ddef12fccab210777747c79f3b6e098829cf8" translate="yes" xml:space="preserve">
          <source>10 items: 1 second</source>
          <target state="translated">10 개 항목 : 1 초</target>
        </trans-unit>
        <trans-unit id="b0174046184ef586844edb37f738266a6b609bf9" translate="yes" xml:space="preserve">
          <source>10 items: 10 seconds</source>
          <target state="translated">10 개 항목 : 10 초</target>
        </trans-unit>
        <trans-unit id="689340b4e2631ad08bd04332ba871630466acec6" translate="yes" xml:space="preserve">
          <source>10 items: 100 seconds</source>
          <target state="translated">10 개 항목 : 100 초</target>
        </trans-unit>
        <trans-unit id="487a07e5ea7f045eaef47700eca5782bdc2698c0" translate="yes" xml:space="preserve">
          <source>10 items: 2 seconds</source>
          <target state="translated">10 개 항목 : 2 초</target>
        </trans-unit>
        <trans-unit id="e9339141f2aa5963a587e850388974cfe8b47716" translate="yes" xml:space="preserve">
          <source>100 items: 1 second</source>
          <target state="translated">100 개 항목 : 1 초</target>
        </trans-unit>
        <trans-unit id="f78d9065d61742cbe71ea04a50c760c0aad8e2f0" translate="yes" xml:space="preserve">
          <source>100 items: 100 seconds</source>
          <target state="translated">100 개 항목 : 100 초</target>
        </trans-unit>
        <trans-unit id="b9a9aeacdc04be6832d92a9113f361be8c4fe731" translate="yes" xml:space="preserve">
          <source>100 items: 10000 seconds</source>
          <target state="translated">100 개 항목 : 10000 초</target>
        </trans-unit>
        <trans-unit id="e626224265872fce291da52ed1c64e5aa6578829" translate="yes" xml:space="preserve">
          <source>100 items: 3 seconds</source>
          <target state="translated">100 개 항목 : 3 초</target>
        </trans-unit>
        <trans-unit id="4479af418a5535ecef4c1769fe04b3e262bd0ce2" translate="yes" xml:space="preserve">
          <source>1000 items: 4 seconds</source>
          <target state="translated">1000 개 항목 : 4 초</target>
        </trans-unit>
        <trans-unit id="59b0f1da90751fd2ff98593e8e90a885934dbe5d" translate="yes" xml:space="preserve">
          <source>10000 items: 5 seconds</source>
          <target state="translated">10000 개 항목 : 5 초</target>
        </trans-unit>
        <trans-unit id="085fdb777863ed85e33fb2c51dc325a0803c3300" translate="yes" xml:space="preserve">
          <source>25! = 25 &amp;times; 24 &amp;times; &amp;hellip; &amp;times; 2 &amp;times; 1 = 15,511,210,043,330,985,984,000,000</source>
          <target state="translated">25! = 25 &amp;times; 24 &amp;times;&amp;hellip; &amp;times; 2 &amp;times; 1 = 15,511,210,043,330,985,984,000,000</target>
        </trans-unit>
        <trans-unit id="1cf1a4fd3744013ce7ee0b7c1d54d91a24a35640" translate="yes" xml:space="preserve">
          <source>5! = 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 120</source>
          <target state="translated">5! = 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 120</target>
        </trans-unit>
        <trans-unit id="5ff18ebe3d87d9ac7b38e9bc7546904650421471" translate="yes" xml:space="preserve">
          <source>50! = 50 &amp;times; 49 &amp;times; &amp;hellip; &amp;times; 2 &amp;times; 1 = 3.04140932 &amp;times; 10&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">50! = 50 &amp;times; 49 &amp;times;&amp;hellip; &amp;times; 2 &amp;times; 1 = 3.04140932 &amp;times; 10 &lt;sup&gt;64&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="65decea121bc59733f31fb00d9968ddd605ec56d" translate="yes" xml:space="preserve">
          <source>6 becomes 360.</source>
          <target state="translated">6은 360이됩니다.</target>
        </trans-unit>
        <trans-unit id="c649be492e31261bc490084ea0f4061c188e3cef" translate="yes" xml:space="preserve">
          <source>6! = 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 720</source>
          <target state="translated">6! = 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 720</target>
        </trans-unit>
        <trans-unit id="c8333818a5f4310605f53fef7090df38bab14cef" translate="yes" xml:space="preserve">
          <source>7! = 7 &amp;times; 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 5040</source>
          <target state="translated">7! = 7 &amp;times; 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 5040</target>
        </trans-unit>
        <trans-unit id="82d23a6f8035f1269cf4ccfacb8ebe4510c824fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(1)&lt;/code&gt;&lt;strong&gt;Constant&lt;/strong&gt;: The program takes the same time to run no matter how big the input is.</source>
          <target state="translated">&lt;code&gt;O(1)&lt;/code&gt; &lt;strong&gt;Constant&lt;/strong&gt; : 입력의 크기에 관계없이 프로그램 실행에 동일한 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="056a18f82b6af88dc008fbe3a7787f86b596f6a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(N)&lt;/code&gt; algorithms are in some sense the &quot;best&quot; algorithms if you need to read all your data. The &lt;strong&gt;very act of reading&lt;/strong&gt; a bunch of data is an &lt;code&gt;O(N)&lt;/code&gt; operation. Loading it into memory is usually &lt;code&gt;O(N)&lt;/code&gt; (or faster if you have hardware support, or no time at all if you've already read the data). However, if you touch or even &lt;em&gt;look&lt;/em&gt; at every piece of data (or even every other piece of data), your algorithm will take &lt;code&gt;O(N)&lt;/code&gt; time to perform this looking. No matter how long your actual algorithm takes, it will be at least &lt;code&gt;O(N)&lt;/code&gt; because it spent that time looking at all the data.</source>
          <target state="translated">모든 데이터를 읽어야하는 경우 &lt;code&gt;O(N)&lt;/code&gt; 알고리즘은 &quot;최상의&quot;알고리즘입니다. 많은 데이터 &lt;strong&gt;를 읽는&lt;/strong&gt; 것은 &lt;code&gt;O(N)&lt;/code&gt; 연산입니다. 메모리에로드하는 것은 일반적으로 &lt;code&gt;O(N)&lt;/code&gt; (또는 하드웨어 지원이있는 경우 더 빠르거나 이미 데이터를 읽은 경우 전혀 시간이 없습니다). 그러나 모든 데이터 조각 (또는 다른 모든 데이터 조각)을 만지거나 &lt;em&gt;살펴보면&lt;/em&gt; 알고리즘이이 모양을 수행하는 데 &lt;code&gt;O(N)&lt;/code&gt; 시간이 걸립니다. 실제 알고리즘에 시간이 오래 걸리더라도 모든 데이터를 보는 데 시간이 걸리기 때문에 &lt;code&gt;O(N)&lt;/code&gt; 이상이됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e73910621a4a87a24289f5d1c6be72edc01699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(k^n)&lt;/code&gt;&lt;strong&gt;Exponential&lt;/strong&gt; The program run-time increases very quickly with even moderate increases in the size of the problem - it is only practical to process small data sets with exponential algorithms.</source>
          <target state="translated">&lt;code&gt;O(k^n)&lt;/code&gt; &lt;strong&gt;지수&lt;/strong&gt; 문제의 크기가 약간만 증가해도 프로그램 런타임이 매우 빠르게 증가합니다. 지수 알고리즘으로 작은 데이터 세트를 처리하는 것만 실용적입니다.</target>
        </trans-unit>
        <trans-unit id="dd8fc41eb8e642b8c7be077a43f8b40003fc551c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt;&lt;strong&gt;Logarithmic&lt;/strong&gt;: The program run-time increases only slowly, even with big increases in the size of the input.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;strong&gt;Logarithmic&lt;/strong&gt; : 입력 크기가 크게 증가하더라도 프로그램 런타임은 느리게 증가합니다.</target>
        </trans-unit>
        <trans-unit id="5537ff56d10d57079a34acd64955d17beb7d3a76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n!)&lt;/code&gt;&lt;strong&gt;Factorial&lt;/strong&gt; The program run-time will be longer than you can afford to wait for anything but the very smallest and most trivial-seeming datasets.</source>
          <target state="translated">&lt;code&gt;O(n!)&lt;/code&gt; &lt;strong&gt;Factorial&lt;/strong&gt; 프로그램 실행 시간은 가장 작고 가장 사소한 데이터 세트 이외의 다른 항목을 대기 할 수있는 시간보다 길어집니다.</target>
        </trans-unit>
        <trans-unit id="461878ff8b0db16418e81fc04a687228bdddb9cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n)&lt;/code&gt;&lt;strong&gt;Linear&lt;/strong&gt;: The program run-time increases proportionally to the size of the input.</source>
          <target state="translated">&lt;code&gt;O(n)&lt;/code&gt; &lt;strong&gt;선형&lt;/strong&gt; : 프로그램 런타임이 입력 크기에 비례하여 증가합니다.</target>
        </trans-unit>
        <trans-unit id="c217eda9395d53638ead2adab477fe11bdcd7bed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n^k)&lt;/code&gt;&lt;strong&gt;Polynomial&lt;/strong&gt;: - Processing time grows faster and faster - as a polynomial function - as the size of the input increases.</source>
          <target state="translated">&lt;code&gt;O(n^k)&lt;/code&gt; &lt;strong&gt;다항식&lt;/strong&gt; :-입력의 크기가 커짐에 따라 다항식 함수로 처리 시간이 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="487d91ff83198cfbc6a54c925fe5eb11d2aa1e78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; &amp;Omega;(lowerbound)&lt;/code&gt; means &lt;code&gt;f&lt;/code&gt; &quot;grows no slower than&quot; &lt;code&gt;lowerbound&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; &amp;Omega;(lowerbound)&lt;/code&gt; 은 &lt;code&gt;f&lt;/code&gt; &quot; &lt;code&gt;lowerbound&lt;/code&gt; 보다 느리게 성장하지 않음&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b822bda6e416f32092b9f10f8f055c41f8035dcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; means &lt;code&gt;f&lt;/code&gt; &quot;grows no faster than&quot; &lt;code&gt;upperbound&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; &quot; &lt;code&gt;upperbound&lt;/code&gt; 보다 더 빨리 자라지 않음&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b5d65077f782632cf020f9dc10bb5515c203e5c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; Ɵ(justlikethis)&lt;/code&gt; mean &lt;code&gt;f&lt;/code&gt; &quot;grows exactly like&quot; &lt;code&gt;justlikethis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; Ɵ(justlikethis)&lt;/code&gt; &lt;code&gt;f&lt;/code&gt; 는 이것처럼 &quot;정확하게 자랍니다&quot;</target>
        </trans-unit>
        <trans-unit id="e4961257cbe0182882cfdaf21754b651a2f9dd8e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Big-O notation represent the upper-bound on the Complexity (Time, Space, ..)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Big-O 표기법은 복잡성의 상한을 나타냅니다 (시간, 공간, ..)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b6ee9747fe724799f360b3f5740e340e9d6e0bc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Examples&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Examples&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dda2198e2a2e6a8edab7d156a0212aab2797c3a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Math addenda&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;수학 부록&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53c547884adc7e294b855c4c5480cbf77fa6513e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;More examples&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;더 많은 예&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="16299135c5a827dc53d250d6ee80162f6e351d93" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;example:&lt;/em&gt; you and a friend are asked to create a function to sum the numbers from 0 to N. You come up with f(x) and your friend comes up with g(x). Both functions have the same result, but a different algorithm. In order to objectively compare the efficiency of the algorithms we use &lt;strong&gt;Big-O notation&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;예 :&lt;/em&gt; 당신과 친구는 0에서 N까지의 숫자를 합산하는 함수를 만들도록 요청받습니다. f (x)가 나오고 친구가 g (x)가됩니다. 두 함수 모두 결과는 같지만 알고리즘은 다릅니다. 알고리즘의 효율성을 객관적으로 비교하기 위해 &lt;strong&gt;Big-O 표기법을 사용&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="62471f46793f8b6a5cc659e14e96cdc437a86276" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = &lt;em&gt;k&lt;/em&gt;(x)&lt;em&gt;g&lt;/em&gt;(x)</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; (x) = &lt;em&gt;k&lt;/em&gt; (x) &lt;em&gt;g&lt;/em&gt; (x)</target>
        </trans-unit>
        <trans-unit id="150577e3855332cfa9b847f25eb077da526cdf9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = O(&lt;em&gt;g&lt;/em&gt;(x)) when x goes to a (for example, a = +&amp;infin;) means that there is a function &lt;em&gt;k&lt;/em&gt; such that:</source>
          <target state="translated">x가 a (예 : a = + &amp;infin;)로 갈 때 &lt;em&gt;f&lt;/em&gt; (x) = O ( &lt;em&gt;g&lt;/em&gt; (x))는 다음과 같은 함수 &lt;em&gt;k&lt;/em&gt; 가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f39e0610bb58307821a0194948212519a3857fe0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = o(&lt;em&gt;g&lt;/em&gt;(x)) when x goes to a means that there is a function k such that:</source>
          <target state="translated">x가 a로 갈 때 &lt;em&gt;f&lt;/em&gt; (x) = o ( &lt;em&gt;g&lt;/em&gt; (x))는 다음과 같은 함수 k가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="60efe2817e6b6dc1067de924ce07bd71c241b66c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;k&lt;/em&gt;(x) goes to 0 when x goes to a.</source>
          <target state="translated">x가 a에 가면 &lt;em&gt;k&lt;/em&gt; (x)는 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="df9a7b04d24a410a550a80633b5c46b22b5f4454" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;Big O&quot; does two things:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;Big O&quot;는 두 가지 작업을 수행합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1daaf609ea760d49121da39fad36df3d4c70428" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2&lt;sup&gt;2N&lt;/sup&gt; = (4&lt;sup&gt;N&lt;/sup&gt;)............put another way...... &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2&lt;sup&gt;N+1&lt;/sup&gt; = 2&lt;sup&gt;N&lt;/sup&gt;2&lt;sup&gt;1&lt;/sup&gt; = 2 &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2 &lt;sup&gt;2N&lt;/sup&gt; = (4 &lt;sup&gt;N&lt;/sup&gt; ) ............ 다른 방법으로 ............ &lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2 &lt;sup&gt;N + 1&lt;/sup&gt; = 2 &lt;sup&gt;N&lt;/sup&gt; 2 &lt;sup&gt;1&lt;/sup&gt; = 2 &lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bafc82a1bb664838622cc7d1e8482db598079440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3 key takeaways:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3 가지 주요 테이크 아웃 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae00ba228fe3cdd0cfce107b955e3f34920862ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Plain English Explanation of &lt;em&gt;What&lt;/em&gt; Big O Notation is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big O 표기법에 대한 일반 영어 설명 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="effebafa8908442aac2c8ca79cf7084917151477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Plain English Explanation of the &lt;em&gt;Need&lt;/em&gt; for Big-O Notation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big-O 표기법에 대한 일반 영어 설명 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dc1a218f6a731c6560f65be4a2784929627a928" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A more accurate explanation (mathematical)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;보다 정확한 설명 (수학적)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73f82c5b1f0e86127e3020556cc882893d6cf6cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm description:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;알고리즘 설명 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f5537eaa639ac5f94aa2c74841f5eaaa9254c7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm example (Java):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;알고리즘 예 (자바) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8aab72c29f5ef095ba2621ef23e8bc30d58b5ec1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Amortized Worst-Case&lt;/strong&gt;: Some data structures may have a worst-case complexity that is large, but guarantee that if you do many of these operations, the average amount of work you do will be better than worst-case. For example, you may have a data structure that normally takes constant &lt;code&gt;O(1)&lt;/code&gt; time. However, occasionally it will 'hiccup' and take &lt;code&gt;O(N)&lt;/code&gt; time for one random operation, because maybe it needs to do some bookkeeping or garbage collection or something... but it promises you that if it does hiccup, it won't hiccup again for N more operations. The worst-case cost is still &lt;code&gt;O(N)&lt;/code&gt; per operation, but the amortized cost &lt;em&gt;over many runs&lt;/em&gt; is &lt;code&gt;O(N)/N&lt;/code&gt; = &lt;code&gt;O(1)&lt;/code&gt; per operation. Because the big operations are sufficiently rare, the massive amount of occasional work can be considered to blend in with the rest of the work as a constant factor. We say the work is &quot;amortized&quot; over a sufficiently large number of calls that it disappears asymptotically.</source>
          <target state="translated">&lt;strong&gt;Amortized Worst-Case&lt;/strong&gt; : 일부 데이터 구조는 최악의 경우 복잡도를 가질 수 있지만 이러한 작업을 많이 수행하면 평균 작업량이 최악의 경우보다 낫습니다. 예를 들어, 일반적으로 일정한 &lt;code&gt;O(1)&lt;/code&gt; 시간이 걸리는 데이터 구조가있을 수 있습니다. 그러나 때로는 부기 또는 가비지 수집 또는 무언가를해야 할 수도 있기 때문에 하나의 임의 작업에 대해 '딸꾹질'이 걸리고 &lt;code&gt;O(N)&lt;/code&gt; 시간이 걸리지 만 딸꾹질을하면 딸꾹질하지 않을 것이라고 약속합니다. N 더 많은 작업을 위해 다시 딸꾹질하십시오. 최악의 비용은 여전히 ​​작업 당 &lt;code&gt;O(N)&lt;/code&gt; 이지만 &lt;em&gt;많은 실행&lt;/em&gt; 에서 상각 된 비용은 작업 당 &lt;code&gt;O(N)/N&lt;/code&gt; = &lt;code&gt;O(1)&lt;/code&gt; 입니다. 큰 작업은 충분히 드물기 때문에 가끔씩 많은 작업이 작업의 나머지 부분과 일정한 요소로 혼합되는 것으로 간주 될 수 있습니다. 우리는 그 작업이 무의식적으로 사라지는 충분히 많은 수의 호출을 통해 &quot;완전히 암시되어있다&quot;고 말합니다.</target>
        </trans-unit>
        <trans-unit id="bf7370e1d0177c50c4c0d7fb024561f2bab440cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Amortized and average-case complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;상각 및 평균 대소 문자 복잡성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab4389896132cbec29ee3f0554d686383b2d60f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Applications&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Applications&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b3d5404d360c404fd2bf84459010109192eb8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Attention!&lt;/strong&gt; The notation with the equal sign &quot;=&quot; uses a &quot;fake equality&quot;: it is true that o(g(x)) = O(g(x)), but false that O(g(x)) = o(g(x)).  Similarly, it is ok to write &quot;ln(x) = o(x) when x &amp;rarr; +&amp;infin;&quot;, but the formula &quot;o(x) = ln(x)&quot; would make no sense.</source>
          <target state="translated">&lt;strong&gt;주의!&lt;/strong&gt; 등호가 &quot;=&quot;인 표기법은 &quot;가짜 평등&quot;을 사용합니다. o (g (x)) = O (g (x)) 인 것은 사실이지만 O (g (x)) = o (g 인 경우는 거짓입니다. (엑스)). 마찬가지로 &quot;x &amp;rarr; + &amp;infin;&quot;일 때 &quot;ln (x) = o (x)&quot;를 쓰는 것이 좋지만 공식 &quot;o (x) = ln (x)&quot;는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="34dd92c00819162397c366f49572746e28f5f1c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Average Case&lt;/strong&gt;: This is no more than using big-O notation for the expected value of a function, rather than the function itself. In the usual case where you consider all inputs to be equally likely, the average case is just the average of the running time. For example with quicksort, even though the worst-case is &lt;code&gt;O(N^2)&lt;/code&gt; for some really bad inputs, the average case is the usual &lt;code&gt;O(N log(N))&lt;/code&gt; (the really bad inputs are very small in number, so few that we don't notice them in the average case).</source>
          <target state="translated">&lt;strong&gt;평균 사례&lt;/strong&gt; : 이것은 함수 자체가 아니라 함수의 예상 값에 big-O 표기법을 사용하는 것입니다. 모든 입력이 동일하게 고려되는 일반적인 경우 평균 사례는 실행 시간의 평균입니다. 예를 들어 quicksort를 사용하면 최악의 입력이 실제로는 일부 입력에 대해 &lt;code&gt;O(N^2)&lt;/code&gt; 경우에도 일반적인 경우는 일반적인 &lt;code&gt;O(N log(N))&lt;/code&gt; (실제로 잘못된 입력의 수는 매우 작으므로 우리는 평균적인 경우에 눈치 채지 못합니다).</target>
        </trans-unit>
        <trans-unit id="3220576162b61267d1a4a26767219ea6e4545c4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Back to English&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;영어로 돌아 가기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0cac323801b8e9b2b0c915a6c542a3bbb241cb47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basics&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Basics&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deeb35e60114ce47ff18984e39930c946fc62ed4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Case:&lt;/strong&gt; In the telephone book search, the best case is that we find the name in one comparison.  This is &lt;strong&gt;O(1)&lt;/strong&gt; or &lt;strong&gt;constant complexity&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong&gt;최상의 경우 :&lt;/strong&gt; 전화 번호부 검색에서 가장 좋은 경우는 한 번의 비교에서 이름을 찾는 것입니다. 이것은 &lt;strong&gt;O (1)&lt;/strong&gt; 또는 &lt;strong&gt;일정한 복잡성입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="41bdf2eff0707b735977a7b17f99ea1599797803" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Case:&lt;/strong&gt; O(1);</source>
          <target state="translated">&lt;strong&gt;가장 좋은 경우 :&lt;/strong&gt; O (1);</target>
        </trans-unit>
        <trans-unit id="7914d10c281c86a759e82a40640c5f8d93756303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big O describes the fundamental scaling nature of an algorithm.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big O는 알고리즘의 기본 스케일링 특성을 설명합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e271d8846f3715b1a024f21916128b7d4259417" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big O&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;빅 오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dd5e066b9eba73f69ac911aaff371d1d5517277" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big-O notation is a relative representation of the complexity of an algorithm.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big-O 표기법은 알고리즘의 복잡성을 나타내는 상대적인 표현입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c911dd80e980898d8f2c1e27f8c346fb06ef9ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big-O notation:&lt;/strong&gt; describes &lt;em&gt;how quickly runtime will grow relative to the input as the input get arbitrarily large.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Big-O 표기법 :&lt;/strong&gt; &lt;em&gt;입력이 임의로 커짐에 따라 런타임이 입력에 비해 얼마나 빨리 증가하는지&lt;/em&gt; 설명 &lt;em&gt;합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1070a59c780c49217b3d9ef6075f07036a4de4f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Building Intuition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;직관&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f587b858f8d6fe44a8225f82326a30f53c9d5650" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;By the time you get to 200 towns there isn't enough time left in the universe to solve the problem with traditional computers.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;200 개 도시에 도착할 때까지, 기존 컴퓨터의 문제를 해결하기에는 우주에 남아있는 시간이 충분하지 않습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1d2d8d2f9c4e97fb709d00d85e5dfaceb74c57d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant factors&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;일정한 요인&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9efca8768fe35240139284fbd68b4fe07fc97b92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Case:&lt;/strong&gt; As discussed above this is O(log n); and</source>
          <target state="translated">&lt;strong&gt;예상 사례 :&lt;/strong&gt; 위에서 논의한 바와 같이 이것은 O (log n)입니다. 과</target>
        </trans-unit>
        <trans-unit id="9587614449d0127777f6fe21db3683733e748143" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Case:&lt;/strong&gt; O(n) (for 500,000); and</source>
          <target state="translated">&lt;strong&gt;예상 사례 :&lt;/strong&gt; O (n) (50 만); 과</target>
        </trans-unit>
        <trans-unit id="cdd089580422378d4ca18f0f8f5cf50cf6b830ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do analyze algorithms and how can we compare algorithms against each other?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;알고리즘을 어떻게 분석하고 알고리즘을 서로 비교할 수 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea84419042cce91d342892912299eab7b4c9fa1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you're unlucky when executing A, it might take as much as X(n) operations to
  complete.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;A를 실행할 때 운이 좋지 않으면 X (n) 작업을 완료하는 데 많은 시간이 걸릴 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5f526b740d48e1e3fd49fd9918ce4ec61555a90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multidimensional big-O&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다차원 빅오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6acc739d0b13f807318bf1624de37df1094994ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N&amp;sup2;&lt;/strong&gt; &amp;rarr; (2N)&amp;sup2; = 4(&lt;strong&gt;N&amp;sup2;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;N&amp;sup2;&lt;/strong&gt; &amp;rarr; (2N) &amp;sup2; = 4 ( &lt;strong&gt;N&amp;sup2;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="61702d5685c60ef63ef6fe3ad5ab08a71dd8a2d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N&lt;/strong&gt; &amp;rarr; (2N) = 2(&lt;strong&gt;N&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;N&lt;/strong&gt; &amp;rarr; (2N) = 2 ( &lt;strong&gt;N&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="21cce32ea86e14da51ca9a5664ed1f0ffeff0b0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Big O notation represents the &lt;strong&gt;worst-case scenario&lt;/strong&gt; of an algorithm. Let&amp;rsquo;s assume that &lt;strong&gt;O(1)&lt;/strong&gt; and &lt;strong&gt;O(n)&lt;/strong&gt; are the worst-case scenarios of the example above.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Big O 표기법은 &lt;strong&gt;최악&lt;/strong&gt; 의 알고리즘 &lt;strong&gt;시나리오&lt;/strong&gt; 를 나타냅니다. &lt;strong&gt;O (1)&lt;/strong&gt; 과 &lt;strong&gt;O (n)&lt;/strong&gt; 이 위 예제의 최악의 시나리오라고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="252fabf6945e589a9b0b19016a058e011afbcc3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(1):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68d75ca052377c566336069afee258c69b9aec6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1)&lt;/strong&gt; - Time to complete is the same regardless of the size of input set. An example is accessing an array element by index.</source>
          <target state="translated">&lt;strong&gt;O (1)&lt;/strong&gt; -완료 시간은 입력 세트의 크기에 관계없이 동일합니다. 예를 들어 인덱스로 배열 요소에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="f9afcf401f691a7c75faeb32231d92fde83ecee4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1)&lt;/strong&gt;:  known as &lt;strong&gt;Constant complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (1)&lt;/strong&gt; : &lt;strong&gt;상수 복잡성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dd564fa0710bbf0a0a6d4f2c0d4f0f4442e00d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e72a614b62847ef5617dfe85cfaca13129fb5ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; &lt;em&gt;logn&lt;/em&gt; ) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="635e753fee8296bf321ba6bb90e4518245442fc7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d4b1b888d0086c21997e7a8ecfa829f30374361" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22ac35f2cdc52d148b68da9ed9dd29461e980fe3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(Log N)&lt;/strong&gt; - Time to complete increases roughly in line with the log2(n). For example 1024 items takes roughly twice as long as 32 items, because Log2(1024) = 10 and Log2(32) = 5. An example is finding an item in a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;binary search tree&lt;/a&gt; (BST).</source>
          <target state="translated">&lt;strong&gt;O (Log N)&lt;/strong&gt; -완료 시간이 log2 (n)에 따라 대략 증가합니다. 예를 들어 Log2 (1024) = 10 및 Log2 (32) = 5이므로 1024 개의 항목은 32 개의 항목보다 약 두 배가 걸립니다. 예를 들어 &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;이진 검색 트리&lt;/a&gt; (BST)에서 항목을 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d26adbc9eb537a7d0d5f9ae0552e61b12d6c54bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N Log N)&lt;/strong&gt; - Time to complete increases by the number of items times the result of Log2(N). An example of this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap_sort&quot;&gt;heap sort&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Quick_sort&quot;&gt;quick sort&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O (N Log N)&lt;/strong&gt; -완료 시간이 Log2 (N) 결과의 항목 수의 수만큼 증가합니다. 이에 대한 예는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap_sort&quot;&gt;힙 정렬&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/Quick_sort&quot;&gt;빠른 정렬&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd630f970ed12459c9538aee894e4fca49869a98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N!)&lt;/strong&gt; - Time to complete is the factorial of the input set. An example of this is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;traveling salesman problem brute-force solution&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O (N!)&lt;/strong&gt; -완료 시간은 입력 세트의 계승입니다. 이것의 예는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;여행하는 세일즈맨 문제 무차별 대입 솔루션&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c2e179b7e171e252effc28bae4e6ee136e75dba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N)&lt;/strong&gt; - Time to complete that scales linearly with the size of the input set. In other words if you double the number of items in the input set, the algorithm takes roughly twice as long. An example is counting the number of items in a linked list.</source>
          <target state="translated">&lt;strong&gt;O (N)&lt;/strong&gt; -입력 세트의 크기에 따라 선형으로 확장되는 완료 시간입니다. 즉, 입력 세트의 항목 수를 두 배로 늘리면 알고리즘의 길이가 약 두 배가 걸립니다. 예를 들어 링크 된 목록의 항목 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4784dc4311f56c18cde15b50f60f2194c6df45fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N^2)&lt;/strong&gt; - Time to complete is roughly equal to the square of the number of items. An example of this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;bubble sort&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O (N ^ 2)&lt;/strong&gt; -완료 시간은 항목 수의 제곱과 거의 같습니다. 이에 대한 예는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;bubble sort&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf8d37b23321b288f2b44644bc4c145c6315466f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log &lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (log &lt;em&gt;n&lt;/em&gt; ) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32f6df92bfa553861340db36e2f34e2204cc3856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log n)&lt;/strong&gt;:  known as &lt;strong&gt;Logarithmic complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (log n)&lt;/strong&gt; : &lt;strong&gt;대수 복잡성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9a156d671486ba42c9d6bc4f718b4ad56ae4429" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n)&lt;/strong&gt;:  known as &lt;strong&gt;Linear complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (n)&lt;/strong&gt; : &lt;strong&gt;선형 복잡도&lt;/strong&gt; 로 알려진</target>
        </trans-unit>
        <trans-unit id="25021c74f1f7cc3f73ce24095087c41055c38051" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;:  known as &lt;strong&gt;Quadratic complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (n &lt;sup&gt;2&lt;/sup&gt; )&lt;/strong&gt; : &lt;strong&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/strong&gt; &lt;strong&gt;차 복잡성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ad18baa396b629a872133cacda5df06a167689b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Practical example: visualizing orders of growth while coding&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;실제 예 : 코딩하는 동안 성장 순서 시각화&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee51f001b7ef2c276ec42b4e704f02dd05a4cccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt; : &lt;a href=&quot;http://carlcheo.com/compsci&quot;&gt;http://carlcheo.com/compsci&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참조&lt;/strong&gt; : &lt;a href=&quot;http://carlcheo.com/compsci&quot;&gt;http://carlcheo.com/compsci&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63fd89842e817d63e08af214f7f5c992e4999387" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplest way to look at it (in plain English)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그것을 보는 가장 간단한 방법 (일반 영어)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f8b58e2bc4650ab1f5fd985238dd4f0a986d132" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Small o&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;작은 오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff25f85074d21875430e07bd8801b858e31f7be6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Space complexity:&lt;/strong&gt; aside from time complexity, we also care about space complexity (how much memory/space an algorithm uses). Instead of checking the time of operations, we check the size of the allocation of memory.</source>
          <target state="translated">&lt;strong&gt;공간 복잡성 :&lt;/strong&gt; 시간 복잡성 외에도 공간 복잡성 (알고리즘이 사용하는 메모리 / 공간의 양)도 중요합니다. 작업 시간을 확인하는 대신 메모리 할당 크기를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aea48c460158f9801c2ff1547226bfcd94a4ab48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The whole story&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;전체 이야기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5841737d9f1f0f3920b87ca2d61ff0c8311a9f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are seven most used notations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가장 많이 사용되는 표기법이 7 개 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="898a1558a3534794d5a58e6000c3473375b52eb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There's also Big-Omega, which represent complexity of the Best-Case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Best-Case의 복잡성을 나타내는 Big-Omega도 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a11037fecab22049818b34474fe8e78b05b5b18c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To find The Big-O on Time Complexity:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;시간 복잡성에 대한 Big-O를 찾으려면 다음을 수행하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07f6120a26e2f3f8456ca56f2c44ce3f39c3119c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We only care about the most significant portion of complexity.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;우리는 복잡성의 가장 중요한 부분에 대해서만 관심을 기울입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7974c46035c46b41ac44b7f0b9e92098bfa014df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why O(N) is sometimes the best you can do, i.e. why we need datastructures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (N)이 때로는 최선 인 이유, 즉 데이터 구조가 필요한 이유&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4207c81d75e6ff00a2ab700fd03b10c9d6ef7476" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst Case:&lt;/strong&gt; O(n) (for 1,000,000).</source>
          <target state="translated">&lt;strong&gt;최악의 경우 :&lt;/strong&gt; O (n) (100,000).</target>
        </trans-unit>
        <trans-unit id="575be9f02c898b973aff9fb1bd5bd357e2752a80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst Case:&lt;/strong&gt; This is also O(log n).</source>
          <target state="translated">&lt;strong&gt;최악의 경우 :&lt;/strong&gt; 이것은 또한 O (log n)입니다.</target>
        </trans-unit>
        <trans-unit id="8259671e56bc51a9fd25fab5b93ec32f6a9f6007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;algorithm&lt;/strong&gt;: procedure/formula for solving a problem</source>
          <target state="translated">&lt;strong&gt;알고리즘&lt;/strong&gt; : 문제 해결을위한 절차 / 수식</target>
        </trans-unit>
        <trans-unit id="bf91eb2b18b1a94ff6bc8b8c14b3d1250c603cbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;analogy&lt;/strong&gt;: The analogy in this particular case is a jigsaw puzzle: We created a data structure that exploits some property of the data. If our road segments are like puzzle pieces, we group them by matching color and pattern. We then exploit this to avoid doing extra work later (comparing puzzle pieces of like color to each other, not to every other single puzzle piece).</source>
          <target state="translated">&lt;strong&gt;유추&lt;/strong&gt; :이 특별한 경우의 유추는 직소 퍼즐입니다. 데이터의 일부 속성을 활용하는 데이터 구조를 만들었습니다. 도로 구간이 퍼즐 조각과 같으면 색상과 패턴을 일치시켜 그룹화합니다. 그런 다음 나중에 추가 작업을 수행하지 않기 위해 (이것은 다른 모든 단일 퍼즐 조각이 아니라 서로 같은 퍼즐 조각을 비교) 피합니다.</target>
        </trans-unit>
        <trans-unit id="3fd5be370782e9eefda17f79f700c59070a53c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;c log(N)&lt;/strong&gt; &amp;rarr; c log(2N) = (c log(2))+(&lt;strong&gt;c log(N)&lt;/strong&gt;) = (fixed amount)+(&lt;strong&gt;c log(N)&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;c log (N)&lt;/strong&gt; &amp;rarr; c log (2N) = (c log (2)) + ( &lt;strong&gt;c log (N)&lt;/strong&gt; ) = (고정 금액) + ( &lt;strong&gt;c log (N)&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="6bd6f3f7face459b8ad4a2440f178d8320099c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;c*1&lt;/strong&gt; &amp;rarr; &lt;strong&gt;c*1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;c * 1&lt;/strong&gt; &amp;rarr; &lt;strong&gt;c * 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae34a86dbd8e294559fb6de015a86203c6d6210c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; &amp;rarr; c(2N)&amp;sup3; = 8(&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; &amp;rarr; c (2N) &amp;sup3; = 8 ( &lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="27b5788854d51bd893ea7a5207a2a3c0a233aee4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;complexity:&lt;/strong&gt; if it takes me one second to sort 10,000 elements, how long will it take me to sort one million?  Complexity in this instance is a relative measure to something else.</source>
          <target state="translated">&lt;strong&gt;복잡성 :&lt;/strong&gt; 10,000 개의 요소를 정렬하는 데 1 초가 걸리면 백만을 정렬하는 데 얼마나 걸립니까? 이 경우의 복잡성은 다른 것에 대한 상대적인 척도입니다.</target>
        </trans-unit>
        <trans-unit id="5457665c30d0585dc37a4fd244075c3a2b2ad61b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for &quot;sufficiently&quot; large inputs...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;충분히&quot;큰 입력을 위해 ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2acb65b1907221e1bdd5284f08ac1b0df4ea0231" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;relative:&lt;/strong&gt; you can only compare apples to apples.  You can't compare an algorithm to do arithmetic multiplication to an algorithm that sorts a list of integers.  But a comparison of two algorithms to do arithmetic operations (one multiplication, one addition) will tell you something meaningful;</source>
          <target state="translated">&lt;strong&gt;상대 :&lt;/strong&gt; 사과와 사과 만 비교할 수 있습니다. 산술 곱셈을 수행하기 위해 알고리즘을 정수 목록을 정렬하는 알고리즘과 비교할 수 없습니다. 그러나 산술 연산을 수행하는 두 알고리즘 (하나의 곱셈, 하나의 덧셈)을 비교하면 의미있는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="527b57aaeb37446d8c211474a094432da292f875" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;representation:&lt;/strong&gt; Big-O (in its simplest form) reduces the comparison between algorithms to a single variable.  That variable is chosen based on observations or assumptions.  For example, sorting algorithms are typically compared based on comparison operations (comparing two nodes to determine their relative ordering).  This assumes that comparison is expensive.  But what if comparison is cheap but swapping is expensive?  It changes the comparison; and</source>
          <target state="translated">&lt;strong&gt;표현 :&lt;/strong&gt; Big-O (가장 간단한 형식)는 알고리즘 간의 단일 변수 비교를 줄입니다. 해당 변수는 관찰 또는 가정에 따라 선택됩니다. 예를 들어, 정렬 알고리즘은 일반적으로 비교 작업을 기반으로 비교됩니다 (상대 순서를 결정하기 위해 두 노드를 비교). 이것은 비교가 비싸다고 가정합니다. 그러나 비교가 저렴하지만 교환이 비싸면 어떨까요? 비교를 변경합니다. 과</target>
        </trans-unit>
        <trans-unit id="19518fd2e0a8446c92d07859c82f3fdb9396de2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr: The number of handshakes 'looks like' x&amp;sup2; so much for large values, that if we were to write down the ratio #handshakes/x&amp;sup2;, the fact that we don't need &lt;em&gt;exactly&lt;/em&gt; x&amp;sup2; handshakes wouldn't even show up in the decimal for an arbitrarily large while.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tl; dr : 큰 값의 경우 핸드 셰이크 수 'x&amp;sup2;'가 너무 커서 # handshakes / x&amp;sup2; 비율을 쓰면 &lt;em&gt;정확히&lt;/em&gt; x&amp;sup2; 핸드 셰이크가 필요하지 않다는 사실조차 나타나지 않습니다. 임의로 큰 동안 10 진수로.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc58ee0a287cef32ca985382490b5ed483c76fc8" translate="yes" xml:space="preserve">
          <source>A &amp;rarr; B &amp;rarr; C</source>
          <target state="translated">A &amp;rarr; B &amp;rarr; C</target>
        </trans-unit>
        <trans-unit id="9814460aaaa82f895fab69aa1e7b80cc39fcf625" translate="yes" xml:space="preserve">
          <source>A &amp;rarr; C &amp;rarr; B</source>
          <target state="translated">A &amp;rarr; C &amp;rarr; B</target>
        </trans-unit>
        <trans-unit id="6fa316481ef216118bd579775f4816b14c18a0f7" translate="yes" xml:space="preserve">
          <source>A simple straightforward answer can be:</source>
          <target state="translated">간단한 대답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fa68420a293bc47b500623963e3f939ae51a473" translate="yes" xml:space="preserve">
          <source>A typical implementation might be to open up to the middle, take the 500,000&lt;sup&gt;th&lt;/sup&gt; and compare it to &quot;Smith&quot;. If it happens to be &quot;Smith, John&quot;, we just got real lucky.  Far more likely is that &quot;John Smith&quot; will be before or after that name.  If it's after we then divide the last half of the phone book in half and repeat.  If it's before then we divide the first half of the phone book in half and repeat.  And so on.</source>
          <target state="translated">일반적인 구현은 중간에 열리고 50 만 &lt;sup&gt;번째&lt;/sup&gt; 를 &quot;Smith&quot;와 비교하는 것입니다. 그것이 &quot;Smith, John&quot;이라면, 우리는 정말 운이 좋았습니다. &quot;John Smith&quot;가 그 이름 앞이나 뒤에있을 가능성이 훨씬 더 높습니다. 그런 다음 전화 번호부의 마지막 절반을 반으로 나누고 반복하십시오. 이전의 경우 전화 번호부의 전반부를 반으로 나누고 반복합니다. 등등.</target>
        </trans-unit>
        <trans-unit id="b2eaa9e11c09c682e15e1f9214b1b8f85ad77873" translate="yes" xml:space="preserve">
          <source>Addition is the simplest.  You line the numbers up (to the right) and add the digits in a column writing the last number of that addition in the result.  The 'tens' part of that number is carried over to the next column.</source>
          <target state="translated">덧셈이 가장 간단합니다. 숫자를 오른쪽으로 정렬하고 결과에 해당 추가의 마지막 숫자를 기록하는 열에 숫자를 추가합니다. 해당 숫자의 '수십'부분이 다음 열로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="06a8ddf90a58cac434d9dddb41eadc549d53c934" translate="yes" xml:space="preserve">
          <source>Also keep in mind that due to hidden constraints of your program, you might not really care about asymptotic behavior. You may be working with a bounded number of values, for example:</source>
          <target state="translated">또한 프로그램의 숨겨진 제약으로 인해 실제로 점근 적 행동에 신경 쓰지 않을 수도 있습니다. 다음과 같이 제한된 수의 값으로 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="580cbd5744ce3d45f6d2b723b41c7344947edda0" translate="yes" xml:space="preserve">
          <source>Although anything &quot;larger&quot; than a constant factor can be detected, however.</source>
          <target state="translated">그러나 상수 인자보다 &quot;큰&quot;것이 감지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5bfda3d2781b7d70658d5d11b9d005ba3e1398e" translate="yes" xml:space="preserve">
          <source>Amortized worst-case: If you use an amortized worst-case data structure, the performance is guaranteed to be within the amortized worst-case... eventually (even if the inputs are chosen by an evil demon who knows everything and is trying to screw you over). Usually, we use this to analyze algorithms that may be very 'choppy' in performance with unexpected large hiccups, but over time perform just as well as other algorithms. (However unless your data structure has upper limits for much outstanding work it is willing to procrastinate on, an evil attacker could perhaps force you to catch up on the maximum amount of procrastinated work all-at-once.</source>
          <target state="translated">상각 최악의 데이터 구조 : 상각 최악의 데이터 구조를 사용하는 경우, 상각 최악의 데이터 범위 내에서 성능이 보장됩니다. 결국 모든 것을 알고 악의적 인 악마가 입력을 선택하더라도 당신을 망치십시오). 일반적으로 예기치 않은 큰 딸꾹질로 인해 성능이 '고르지 않은'알고리즘을 분석하는 데 사용하지만 시간이 지남에 따라 다른 알고리즘과 마찬가지로 성능이 향상됩니다. (데이터 구조에 미루고 자하는 뛰어난 작업에 대한 상한이없는 한 악의적 인 공격자는 한 번에 최대의 미루는 작업을 따라 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c08025d0af34b0e733dff69c38b8140014e0dcfb" translate="yes" xml:space="preserve">
          <source>And furthermore</source>
          <target state="translated">그리고 더</target>
        </trans-unit>
        <trans-unit id="6896d57deefe7dcce6486c33a6e908bb66a0f2d5" translate="yes" xml:space="preserve">
          <source>Another point I wanted to make quick mention of is that any algorithm that has a complexity of &lt;strong&gt;O(n&lt;sup&gt;a&lt;/sup&gt;)&lt;/strong&gt; is said to have &lt;strong&gt;polynomial complexity&lt;/strong&gt; or is solvable in &lt;strong&gt;polynomial time&lt;/strong&gt;.</source>
          <target state="translated">내가 간단히 언급하고 싶었던 또 다른 요점은 &lt;strong&gt;O (n &lt;sup&gt;a&lt;/sup&gt; )&lt;/strong&gt; 의 복잡성을 갖는 알고리즘은 &lt;strong&gt;다항식 복잡성&lt;/strong&gt; 을 가지고 있거나 &lt;strong&gt;다항식 시간으로&lt;/strong&gt; 해결할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="18d608bf5ee39a542ef2abc8b2c8aa9502e49075" translate="yes" xml:space="preserve">
          <source>Anyone who's read Programming Pearls or any other Computer Science
  books and doesn&amp;rsquo;t have a grounding in Mathematics will have hit a wall
  when they reached chapters that mention O(N log N) or other seemingly
  crazy syntax. Hopefully this article will help you gain an
  understanding of the basics of Big O and Logarithms.</source>
          <target state="translated">Programming Pearls이나 다른 Computer Science 책을 읽고 수학에 대한 근거가없는 사람은 O (N log N) 또는 다른 겉보기에는 미묘한 구문을 언급하는 장에 도달했을 때 벽에 부딪쳤을 것입니다. 이 기사가 Big O와 Logarithms의 기초를 이해하는 데 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="ca7668976286f5ad8d5eca2a7fadcc44aba0a83b" translate="yes" xml:space="preserve">
          <source>Anyway, that's it for my (hopefully plain English) explanation of Big O (revised).</source>
          <target state="translated">어쨌든, 그것은 Big O (개정)에 대한 나의 (희망 평범한 영어) 설명을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="010115fea8e63b4e720d7c742f8033325bf02f8e" translate="yes" xml:space="preserve">
          <source>As &lt;em&gt;n&lt;/em&gt; gets arbitrarily large, focus on the terms that will grow the fastest as n gets large (think infinity) AKA &lt;strong&gt;asymptotic analysis&lt;/strong&gt;</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 이 임의로 커짐에 따라 &lt;em&gt;n&lt;/em&gt; 이 커짐에 따라 가장 빠르게 성장하는 용어에 초점을 맞 춥니 다 (무한대 생각) AKA &lt;strong&gt;점근 분석&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="870ad13cbf6243c698d7d2bf03ab24ac0048aa57" translate="yes" xml:space="preserve">
          <source>As a programmer first and a mathematician second (or maybe third or
  fourth) I found the best way to understand Big O thoroughly was to
  produce some examples in code. So, below are some common orders of
  growth along with descriptions and examples where possible.</source>
          <target state="translated">프로그래머로서 첫 번째이고 수학자 인 두 번째 (또는 아마도 세 번째 또는 네 번째)로서 Big O를 완전히 이해하는 가장 좋은 방법은 코드로 예제를 만드는 것입니다. 아래는 가능한 경우 설명과 예와 함께 몇 가지 일반적인 성장 순서입니다.</target>
        </trans-unit>
        <trans-unit id="483f1c4417fdd5afc1f2915ce24ff5ba0f7520e8" translate="yes" xml:space="preserve">
          <source>As a purely mathematical construct, big-O notation is not limited to talking about processing time and memory. You can use it to discuss the asymptotics of anything where scaling is meaningful, such as:</source>
          <target state="translated">순전히 수학적 구성 인 big-O 표기법은 처리 시간과 메모리에 대한 이야기에만 국한되지 않습니다. 이를 사용하여 다음과 같이 스케일링이 의미가있는 모든 것의 무증상을 논의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7f64f73685e6f247cbf73eed79f3d10cdb73567" translate="yes" xml:space="preserve">
          <source>As a result of all this unhelpful complexity, people try to describe the speed of software programs using the smallest and least complex (mathematical) expressions possible. These expressions are very very crude approximations: Although, with a bit of luck, they will capture the &quot;essence&quot; of whether a piece of software is fast or slow.</source>
          <target state="translated">이 모든 도움이되지 않는 복잡성의 결과로 사람들은 가능한 가장 작고 복잡한 (수학적) 표현을 사용하여 소프트웨어 프로그램의 속도를 설명하려고합니다. 이러한 표현은 매우 조잡한 근사치입니다. 약간의 운이 있지만 소프트웨어 조각이 빠르거나 느린 지의 &quot;본질&quot;을 포착합니다.</target>
        </trans-unit>
        <trans-unit id="7f8315a19f8a52da5d9ef1a40ab83006a844cfd3" translate="yes" xml:space="preserve">
          <source>As it happens, there are certain functions (think of them as &lt;em&gt;implementations&lt;/em&gt; of &lt;strong&gt;X(n)&lt;/strong&gt;) that tend to occur quite often. These are well known and easily compared (Examples: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Log N&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;N^2&lt;/code&gt;, &lt;code&gt;N!&lt;/code&gt;, etc..)</source>
          <target state="translated">발생하는 것처럼 꽤 자주 발생하는 특정 함수 ( &lt;strong&gt;X (n)&lt;/strong&gt; &lt;em&gt;구현&lt;/em&gt; 으로 생각)가 있습니다. 이들은 잘 알려져 있고 쉽게 비교됩니다 (예 : &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;Log N&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;N^2&lt;/code&gt; , &lt;code&gt;N!&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="58635748eb80ad2370517e468a337e1bd88c9cc8" translate="yes" xml:space="preserve">
          <source>As the algorithm scales with n-&lt;em&gt;squared&lt;/em&gt;, this is &lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt; or &lt;strong&gt;quadratic complexity&lt;/strong&gt;. This is a good time to introduce another important concept:</source>
          <target state="translated">알고리즘이 n &lt;em&gt;제곱으로&lt;/em&gt; 확장됨에 따라 이것은 &lt;strong&gt;O (n &lt;sup&gt;2&lt;/sup&gt; )&lt;/strong&gt; 또는 &lt;strong&gt;2 차 복잡성&lt;/strong&gt; 입니다. 또 다른 중요한 개념을 소개하기에 좋은시기입니다.</target>
        </trans-unit>
        <trans-unit id="db509c6991e60440b1722a307f8ef3f99bc3043d" translate="yes" xml:space="preserve">
          <source>Assume we're talking about an algorithm &lt;strong&gt;A&lt;/strong&gt;, which should do something with a dataset of size &lt;strong&gt;n&lt;/strong&gt;.</source>
          <target state="translated">크기가 &lt;strong&gt;n 인&lt;/strong&gt; 데이터 세트로 무언가를 수행 해야하는 알고리즘 &lt;strong&gt;A&lt;/strong&gt; 에 대해 이야기한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5e269fc76f0e879e9586e4d2d5b07a5bf29feecd" translate="yes" xml:space="preserve">
          <source>Asymptotic notation is, at its core, quite separate from programming. Asymptotic notation is a mathematical framework for thinking about how things scale and can be used in many different fields. That said... this is how you &lt;em&gt;apply&lt;/em&gt; asymptotic notation to coding.</source>
          <target state="translated">점근 적 표기법의 핵심은 프로그래밍과는 별개입니다. 점근 적 표기법은 다양한 분야에서 사물이 어떻게 확장되고 사용될 수 있는지 생각하기위한 수학적 프레임 워크입니다. 그것은 말했다 ... 이것은 코딩에 점근 표기법을 &lt;em&gt;적용&lt;/em&gt; 하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b1fcf30b1f3fc218decd89222f7ae2f077cdd616" translate="yes" xml:space="preserve">
          <source>At some point, at some time, there will be no swaps, and our sort of the deck would be done.  So much work!</source>
          <target state="translated">어떤 시점에서 언젠가는 스왑이 없을 것이며 우리의 데크는 완료 될 것입니다. 너무 많은 일!</target>
        </trans-unit>
        <trans-unit id="bfb8cbb068a5baea44b500d50ed4ead05e487564" translate="yes" xml:space="preserve">
          <source>At some point, this loop (from Two to Three) will end.  It ends when both halves of this search meet at the splay card.  Then, we have just splayed the deck with the card you chose in step One.  Now, all the cards near the start are more low than the splay card; and the cards near the end are more high than the splay card.  Cool trick!</source>
          <target state="translated">어느 시점 에서이 루프 (2에서 3까지)가 끝납니다. 이 검색의 양쪽 절반이 스플레이 카드에서 만나면 종료됩니다. 그런 다음, 1 단계에서 선택한 카드로 덱을 플레이했습니다. 이제 시작 근처의 모든 카드가 스플레이 카드보다 낮습니다. 끝 근처의 카드는 스플레이 카드보다 더 높습니다. 멋진 트릭!</target>
        </trans-unit>
        <trans-unit id="6ad9a691d1120dce91af1178eb6b497f4f7e37f7" translate="yes" xml:space="preserve">
          <source>Average-case: We make some assumptions about our inputs; i.e. if our inputs have different probabilities, then our outputs/runtimes will have different probabilities (which we take the average of). Usually, we assume that our inputs are all equally likely (uniform probability), but if the real-world inputs don't fit our assumptions of &quot;average input&quot;, the average output/runtime calculations may be meaningless. If you anticipate uniformly random inputs though, this is useful to think about!</source>
          <target state="translated">평균 사례 : 입력에 대해 몇 가지 가정을합니다. 즉, 입력에 다른 확률이있는 경우 출력 / 런타임에 다른 확률 (평균을 취함)을 갖게됩니다. 일반적으로 입력이 모두 동일 할 가능성이 있다고 가정하지만 (실제 입력) 실제 입력이 &quot;평균 입력&quot;이라는 가정에 맞지 않으면 평균 출력 / 런타임 계산이 의미가 없을 수 있습니다. 그래도 균일하게 임의의 입력을 예상한다면, 이것은 생각하는 데 유용합니다!</target>
        </trans-unit>
        <trans-unit id="832a8d90127d5ca48f6556477abd38a77ce36f33" translate="yes" xml:space="preserve">
          <source>B &amp;rarr; A &amp;rarr; C</source>
          <target state="translated">B &amp;rarr; A &amp;rarr; C</target>
        </trans-unit>
        <trans-unit id="d813322c7a347a65c04fed32bbe445579ce7e1e8" translate="yes" xml:space="preserve">
          <source>B &amp;rarr; C &amp;rarr; A</source>
          <target state="translated">B &amp;rarr; C &amp;rarr; A</target>
        </trans-unit>
        <trans-unit id="cc07b18b222d704f4ad25abdb8dc152106fba5a0" translate="yes" xml:space="preserve">
          <source>Back to the telephone book.</source>
          <target state="translated">전화 번호부로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="56a13e8f97147d6679bf9d3baf62cda1ea3b33ca" translate="yes" xml:space="preserve">
          <source>Back up a bit: the number of handshakes is exactly n-choose-2 or &lt;code&gt;N*(N-1)/2&lt;/code&gt; (each of N people shakes the hands of N-1 other people, but this double-counts handshakes so divide by 2):</source>
          <target state="translated">약간 백업하십시오 : 핸드 셰이크 수는 정확히 n-choose-2 또는 &lt;code&gt;N*(N-1)/2&lt;/code&gt; 입니다 (각 N 명의 사람들은 N-1 명의 다른 사람들의 악수를하지만이 두 번의 핸드 셰이크는 2) :</target>
        </trans-unit>
        <trans-unit id="5120b09510b1d63d87c9c5faa58192336bbcb191" translate="yes" xml:space="preserve">
          <source>Based on the mathematical definition above, if you say your algorithm is a Big O of n, it means it is a function of n (number of input parameters) &lt;strong&gt;or faster&lt;/strong&gt;. If your algorithm is Big O of n, then it is also automatically the Big O of n square.</source>
          <target state="translated">위의 수학적 정의에 따르면 알고리즘이 n의 Big O라고하면 n (입력 매개 변수 수) &lt;strong&gt;이상의&lt;/strong&gt; 함수라는 의미입니다. 알고리즘이 Big O of n이면 자동으로 n의 Big O 제곱입니다.</target>
        </trans-unit>
        <trans-unit id="db284bf74073477f62953e8e8e02b1401e213f94" translate="yes" xml:space="preserve">
          <source>Because they are approximations, we use the letter &quot;O&quot; (Big Oh) in the expression, as a convention to signal to the reader that we are making a gross oversimplification. (And to make sure that nobody mistakenly thinks that the expression is in any way accurate).</source>
          <target state="translated">그것들은 근사치이므로, 표현에 문자 &quot;O&quot;(Big Oh)를 사용하여 독자에게 우리가 과도하게 단순화하고 있음을 신호로 보냅니다. (그리고 그 표현이 어떤 식 으로든 정확하다고 아무도 잘못 생각하지 않도록).</target>
        </trans-unit>
        <trans-unit id="ac9bfd81f5e9c61b91f03629f317cefc5ed3f40a" translate="yes" xml:space="preserve">
          <source>Best-Case: the key is the first item.</source>
          <target state="translated">베스트 케이스 : 키가 첫 번째 항목입니다.</target>
        </trans-unit>
        <trans-unit id="8871063a9de2c96323fce812e3e16047b1b9b0c8" translate="yes" xml:space="preserve">
          <source>Big O comes in and says: for a deck of n cards, to sort it this way will be done in O(N squared) time.</source>
          <target state="translated">Big O가 들어 와서 말합니다 : n 카드의 덱의 경우, 이런 방식으로 정렬하려면 O (N 제곱) 시간에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e28ca34381715acfd2716526a419b0f386a39327" translate="yes" xml:space="preserve">
          <source>Big O complexity can be visualized with this graph:</source>
          <target state="translated">이 그래프를 통해 큰 O 복잡성을 시각화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01191d73dc858c84e96603e205ce6cf90b305595" translate="yes" xml:space="preserve">
          <source>Big O describes an upper limit on the growth behaviour of a function, for example the runtime of a program, when inputs become large.</source>
          <target state="translated">Big O는 입력이 커질 때 함수의 증가 동작 (예 : 프로그램 런타임)의 상한을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6d6c6ee7d49379298994bf2d0373e24c46b6260e" translate="yes" xml:space="preserve">
          <source>Big O does not solve the work for us.  Big O tells us how hard the work is.</source>
          <target state="translated">Big O는 우리를 위해 일을 해결하지 않습니다. Big O는 작업이 얼마나 힘든지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="067d8c2c09524ec3079760262aecc198a00b16eb" translate="yes" xml:space="preserve">
          <source>Big O ignores factors that do not contribute in a meaningful way to the growth curve of a function as the input size increases towards infinity. This means that constants that are added to or multiplied by the function are simply ignored.</source>
          <target state="translated">Big O는 입력 크기가 무한대로 증가함에 따라 함수의 성장 곡선에 의미있는 방식으로 기여하지 않는 요소를 무시합니다. 즉, 함수에 더하거나 곱한 상수는 단순히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5ef0b065d98e11f17dc80d42a717ef47eb65fe1e" translate="yes" xml:space="preserve">
          <source>Big O is a measure of how much time/space an algorithm uses relative to the size of its input.</source>
          <target state="translated">Big O는 알고리즘이 입력 크기와 관련하여 사용하는 시간 / 공간의 양을 측정 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e04dd1651f885b1cee3374bf9f1eb929407c8c2" translate="yes" xml:space="preserve">
          <source>Big O is just a way to &quot;Express&quot; yourself in a common way, &quot;How much time / space does it take to run my code?&quot;.</source>
          <target state="translated">Big O는 일반적인 방법으로 &quot;내 코드를 실행하는 데 시간 / 공간이 얼마나 걸립니까?&quot;</target>
        </trans-unit>
        <trans-unit id="615e13e08dc48881c60e9af49cb00312f337463a" translate="yes" xml:space="preserve">
          <source>Big O is useful to compare how well two algorithms will scale up as the number of inputs is increased.</source>
          <target state="translated">Big O는 입력 수가 증가함에 따라 두 알고리즘이 얼마나 잘 확장되는지 비교하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d8cd4344a90d7e5c64b849cbdbe8173c868330b0" translate="yes" xml:space="preserve">
          <source>Big O is your friend and mine.  Big O helps us think on how much work we have to do, so we can plan.  And, if we are friends with big O, he can help us choose work that is not so hard!</source>
          <target state="translated">Big O는 당신의 친구이자 나의 것입니다. Big O는 우리가해야 할 일의 양을 생각하도록 도와 주므로 계획을 세울 수 있습니다. 그리고 우리가 큰 O를 가진 친구라면, 그렇게 어려운 일을 선택하도록 도와 줄 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="63a54321034901fba163b3e5364e8adebdcce5cc" translate="yes" xml:space="preserve">
          <source>Big O notation also shines a spotlight directly on the most important principle of computer programming/engineering, the fact which inspires all good programmers to keep thinking and dreaming: the only way to achieve results beyond the slow forward march of technology is to &lt;em&gt;invent a better algorithm&lt;/em&gt;.</source>
          <target state="translated">Big O 표기법은 또한 컴퓨터 프로그래밍 / 엔지니어링의 가장 중요한 원칙, 즉 모든 훌륭한 프로그래머가 계속해서 생각하고 꿈꾸도록하는 사실에 주목합니다. 기술의 느린 행진을 넘어서서 결과를 달성하는 유일한 방법 &lt;em&gt;은 더 나은 발명을하는 것입니다 알고리즘&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a168ec8cf3b032681504a8e27d40ac24591c31bc" translate="yes" xml:space="preserve">
          <source>Big O notation is a way of describing how quickly an algorithm will run given an arbitrary number of input parameters, which we'll call &quot;n&quot;. It is useful in computer science because different machines operate at different speeds, and simply saying that an algorithm takes 5 seconds doesn't tell you much because while you may be running a system with a 4.5 Ghz octo-core processor, I may be running a 15 year old, 800 Mhz system, which could take longer regardless of the algorithm. So instead of specifying how fast an algorithm runs in terms of time, we say how fast it runs in terms of number of input parameters, or &quot;n&quot;. By describing algorithms in this way, we are able to compare the speeds of algorithms without having to take into account the speed of the computer itself.</source>
          <target state="translated">Big O 표기법은 임의의 수의 입력 매개 변수가 주어지면 알고리즘이 얼마나 빨리 실행되는지 설명하는 방법으로 &quot;n&quot;이라고합니다. 다른 컴퓨터가 다른 속도로 작동하기 때문에 컴퓨터 과학에 유용하며 4.5Ghz 옥토 코어 프로세서가있는 시스템을 실행하는 동안 알고리즘이 5 초가 걸린다는 말은 많이 알려주지 않습니다. 알고리즘에 관계없이 15 년 된 800MHz 시스템. 따라서 알고리즘이 시간 측면에서 얼마나 빨리 실행되는지 지정하는 대신 입력 매개 변수 수 또는 &quot;n&quot;으로 실행되는 속도를 말합니다. 이러한 방식으로 알고리즘을 설명함으로써 컴퓨터 자체의 속도를 고려하지 않고도 알고리즘의 속도를 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b0a116919ddeacd83d71ce31ad376da360a026c" translate="yes" xml:space="preserve">
          <source>Big O notation is a way of describing the upper bound of an algorithm in terms of space or running time.  The n is the number of elements in the the problem (i.e size of an array, number of nodes in a tree, etc.)  We are interested in describing the running time as n gets  big.</source>
          <target state="translated">Big O 표기법은 공간 또는 실행 시간 측면에서 알고리즘의 상한을 설명하는 방법입니다. n은 문제의 요소 수 (즉, 배열의 크기, 트리의 노드 수 등)입니다. n이 커질수록 실행 시간을 설명하는 데 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c8f74fc1bdc10685b2177c45ec160d36cadb907" translate="yes" xml:space="preserve">
          <source>Big O notation is most commonly used by programmers as an approximate measure of how long a computation (algorithm) will take to complete expressed as a function of the size of the input set.</source>
          <target state="translated">Big O 표기법은 입력 집합의 크기에 따라 계산 (알고리즘)을 완료하는 데 걸리는 대략적인 측정 값으로 프로그래머가 가장 일반적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="35d0c4e9b1c9e1dda535f62f93fc8e1e6b9b14c1" translate="yes" xml:space="preserve">
          <source>Big O notation is used in Computer Science to describe the performance
  or complexity of an algorithm. Big O specifically describes the
  worst-case scenario, and can be used to describe the execution time
  required or the space used (e.g. in memory or on disk) by an
  algorithm.</source>
          <target state="translated">Big O 표기법은 Computer Science에서 알고리즘의 성능 또는 복잡성을 설명하는 데 사용됩니다. Big O는 특히 최악의 시나리오를 설명하며 필요한 실행 시간 또는 알고리즘에 의해 사용되는 공간 (예 : 메모리 또는 디스크)을 설명하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="029dd5426c412001fb487f1ee4fae8a55e3c8c3b" translate="yes" xml:space="preserve">
          <source>Big O notation simply tells how much time* an algorithm can run within,
  in terms of &lt;em&gt;only the amount of input data&lt;/em&gt;**.</source>
          <target state="translated">Big O 표기법 &lt;em&gt;은 입력 데이터 양&lt;/em&gt; **에 &lt;em&gt;대해서만&lt;/em&gt; 알고리즘이 얼마나 많은 시간 내에 실행될 수 있는지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ac3a3f5b5b610616ecbb8b264905e5ee4de505c6" translate="yes" xml:space="preserve">
          <source>Big O notation tells you the cost of solving an infinitely large problem.</source>
          <target state="translated">Big O 표기법은 무한히 큰 문제를 해결하는 비용을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="f4998d7a032917937335ae6425e4667cbea54bd2" translate="yes" xml:space="preserve">
          <source>Big O of n means my algorithm runs at least as fast as this. You cannot look at Big O notation of your algorithm and say its slow. You can only say its fast.</source>
          <target state="translated">n의 Big O는 내 알고리즘이 적어도 이만큼 빠르게 실행됨을 의미합니다. 알고리즘의 Big O 표기법을보고 느리게 말할 수는 없습니다. 당신은 빨리 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aabaf3aedb4e0aa46fb4d5ff8c2ab4e6073ca94" translate="yes" xml:space="preserve">
          <source>Big O points out this: as n gets big, when we sort cards, the job gets MUCH MUCH MORE HARD than the old just-add-these-things job.  How do we know this?</source>
          <target state="translated">Big O는 이것을 지적합니다. n이 커질수록 우리가 카드를 정렬 할 때 작업은 기존의 추가 기능 작업보다 훨씬 더 심해집니다. 우리는 이것을 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="93a1b436d9d2b6befbc854db9c969659b8e5b77f" translate="yes" xml:space="preserve">
          <source>Big O represents the worst possible time/space for that algorithm. The algorithm will never take more space/time above that limit. Big O represents time/space complexity in the extreme case.</source>
          <target state="translated">큰 O는 해당 알고리즘에 대한 최악의 시간 / 공간을 나타냅니다. 알고리즘은 해당 한계보다 더 많은 공간 / 시간을 차지하지 않습니다. 큰 O는 극단적 인 경우 시간 / 공간의 복잡성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2897bc170748c75b1afb0452b1633a9f90eeaa23" translate="yes" xml:space="preserve">
          <source>Big O says: we must do six adds to solve this.  One add, for each thing from one to six.  Six small bits of work... each bit of work is one add.</source>
          <target state="translated">Big O의 말 :이 문제를 해결하려면 6 가지를 추가해야합니다. 1에서 6까지 각 항목에 대해 하나의 추가. 6 개의 작은 작업 ... 각 작업은 하나의 추가입니다.</target>
        </trans-unit>
        <trans-unit id="01a1c3b9e0eae37b04b930c9e959423669d00b8b" translate="yes" xml:space="preserve">
          <source>Big O tells us that to sort things is more hard than to add things.  O(n squared) is more than O(n) for big n.  That means: if n gets real big, to sort a mixed deck of n things MUST take more time, than to just add n mixed things.</source>
          <target state="translated">Big O는 물건을 정렬하는 것이 물건을 추가하는 것보다 어렵다고 말합니다. 큰 n의 경우 O (n 제곱)이 O (n)보다 큽니다. 즉, n이 실제로 커지면 n 개의 혼합 데크를 정렬하려면 n 개의 혼합 된 것을 추가하는 것보다 시간이 더 많이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="ff2337e8063fec003cbedd7750338ff7fc025f36" translate="yes" xml:space="preserve">
          <source>Big O, help me!</source>
          <target state="translated">빅 오, 도와주세요!</target>
        </trans-unit>
        <trans-unit id="f0939bd08a02841e66e2310a89ddfeb9c0a7055e" translate="yes" xml:space="preserve">
          <source>Big-&amp;Omega; (Big-Omega) notation (article) | Khan Academy</source>
          <target state="translated">Big-&amp;Omega; (Big-Omega) 표기법 (문서) | 칸 아카데미</target>
        </trans-unit>
        <trans-unit id="9ffc7ec8bbe6223b3d70e4376f89b6eab1b1a639" translate="yes" xml:space="preserve">
          <source>Big-O notation (also called &quot;asymptotic growth&quot; notation) is &lt;em&gt;what functions &quot;look like&quot; when you ignore constant factors and stuff near the origin&lt;/em&gt;. We use it to talk about &lt;strong&gt;how thing scale&lt;/strong&gt;.</source>
          <target state="translated">Big-O 표기법 ( &quot;점근선 성장&quot;표기법이라고도 함)은 &lt;em&gt;원점 근처에서 일정한 요인과 물건을 무시할 때 기능&lt;/em&gt; 이 &lt;em&gt;어떻게 보이는지&lt;/em&gt; 입니다. 우리는 그것을 사용하여 &lt;strong&gt;물건의 규모&lt;/strong&gt; 에 &lt;strong&gt;대해&lt;/strong&gt; 이야기 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1769664f1e1ca72f099882bf25e7d2f39574cca3" translate="yes" xml:space="preserve">
          <source>Big-O, is &lt;strong&gt;rate of increase&lt;/strong&gt; of resource consumed by program, w.r.t. problem-instance-size</source>
          <target state="translated">Big-O는 프로그램이 소비하는 자원 &lt;strong&gt;의 증가율&lt;/strong&gt; 로 문제 인스턴스 크기</target>
        </trans-unit>
        <trans-unit id="a380e8c171aa6d7e586e8f15b66e52968c776a75" translate="yes" xml:space="preserve">
          <source>Binary search is a technique used to search sorted data sets. It works
  by selecting the middle element of the data set, essentially the
  median, and compares it against a target value. If the values match it
  will return success. If the target value is higher than the value of
  the probe element it will take the upper half of the data set and
  perform the same operation against it. Likewise, if the target value
  is lower than the value of the probe element it will perform the
  operation against the lower half. It will continue to halve the data
  set with each iteration until the value has been found or until it can
  no longer split the data set.</source>
          <target state="translated">이진 검색은 정렬 된 데이터 세트를 검색하는 데 사용되는 기술입니다. 데이터 세트의 중간 요소 (기본적으로 중앙값)를 선택하여 작동하며 목표 값과 비교합니다. 값이 일치하면 성공을 반환합니다. 목표 값이 프로브 요소의 값보다 높으면 데이터 세트의 상반부를 가져 와서 동일한 작업을 수행합니다. 마찬가지로, 목표 값이 프로브 요소의 값보다 낮 으면 하반부에 대해 작업을 수행합니다. 값을 찾을 때까지 또는 더 이상 데이터 세트를 분할 할 수 없을 때까지 각 반복마다 데이터 세트를 절반으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="84e2d5bd3333a554d3c328ae36cecdeea3f085c1" translate="yes" xml:space="preserve">
          <source>Both average-case and amortization are incredibly useful tools for thinking about and designing with scaling in mind.</source>
          <target state="translated">평균 사례와 할부 상환은 모두 스케일링을 염두에두고 생각하고 디자인하는 데 매우 유용한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="81fa41afe9d47413eda0c47da5969d56124c07cf" translate="yes" xml:space="preserve">
          <source>But remember, Big O is just a way to experss yourself in the manner of time and space.</source>
          <target state="translated">그러나 Big O는 시간과 공간의 방식으로 자신을 표현하는 방법 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="3ddd3cf4c5b5b439921cdd63b830507cc2d92e01" translate="yes" xml:space="preserve">
          <source>But though we will not do the work now, we can guess how hard it would be, if we knew n.  We would have to add up n things, right?  Of course!</source>
          <target state="translated">그러나 지금 우리는 그 일을하지 않을 것이지만, 우리가 n을 알고 있다면 그것이 얼마나 어려울 지 추측 할 수 있습니다. 우리는 n 개의 것을 더해야했을까요? 물론이야!</target>
        </trans-unit>
        <trans-unit id="de004be9935e007a2aa4a8dd96ba9ccf3e285c6c" translate="yes" xml:space="preserve">
          <source>But, programmers don't think like this because eventually, algorithm intuition just becomes second nature. You will start to code something inefficient and immediately think &quot;am I doing something &lt;strong&gt;grossly inefficient?&lt;/strong&gt;&quot;. If the answer is &quot;yes&quot; AND you foresee it actually mattering, then you can take a step back and think of various tricks to make things run faster (the answer is almost always &quot;use a hashtable&quot;, rarely &quot;use a tree&quot;, and very rarely something a bit more complicated).</source>
          <target state="translated">그러나 프로그래머는 알고리즘 직관이 단지 제 2의 본성이되기 때문에 이와 같이 생각하지 않습니다. 당신은 무언가 비효율적 인 것을 코딩하기 시작하고 즉시 &quot; &lt;strong&gt;엄청나게 비효율적 인&lt;/strong&gt; 일을하고 &lt;strong&gt;있습니까?&lt;/strong&gt; &quot;라고 생각할 것입니다. 대답이 &quot;예&quot;이고 실제로 중요하다고 생각하면 한 걸음 물러나서 여러 가지 속임수를 사용하여 더 빠르게 실행할 수 있습니다 (대답은 항상 &quot;해시 테이블 사용&quot;, &quot;트리 사용&quot;은 거의 없음), 좀 더 복잡한 것이 거의 없습니다).</target>
        </trans-unit>
        <trans-unit id="0d8f8969e0785f14a21dfca5ea753a20c18775cc" translate="yes" xml:space="preserve">
          <source>By comparing these when talking about &lt;strong&gt;A&lt;/strong&gt; and other algorithms, it is easy to rank the algorithms according to the number of operations they &lt;em&gt;may&lt;/em&gt; (worst-case) require to complete.</source>
          <target state="translated">&lt;strong&gt;A&lt;/strong&gt; 와 다른 알고리즘에 대해 이야기 할 때 이들을 비교함으로써, (최악의 경우) 완료해야 &lt;em&gt;할&lt;/em&gt; 작업 수에 따라 알고리즘의 순위를 쉽게 &lt;em&gt;지정할 수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0d58ba7567f14e061427da47056514f59b5370bc" translate="yes" xml:space="preserve">
          <source>By the way, here is for comparison the definition of small o.</source>
          <target state="translated">그건 그렇고, 여기에 작은 o의 정의를 비교하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cbb489069914d301d52853c36730ee0f0e267708" translate="yes" xml:space="preserve">
          <source>C &amp;rarr; A &amp;rarr; B</source>
          <target state="translated">C &amp;rarr; A &amp;rarr; B</target>
        </trans-unit>
        <trans-unit id="6998b04e08785bbdf1c7af58eecf38c1a28d31da" translate="yes" xml:space="preserve">
          <source>C &amp;rarr; B &amp;rarr; A</source>
          <target state="translated">C &amp;rarr; B &amp;rarr; A</target>
        </trans-unit>
        <trans-unit id="6cbbd09b2268ff81c9d2447ddd6efd0ece964c0a" translate="yes" xml:space="preserve">
          <source>Calculate how much time (regarding input size) the worst case takes:</source>
          <target state="translated">최악의 경우에 걸리는 시간 (입력 크기에 관한)을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="12668f37b6831ee2e32bd194cd1af2fa68690568" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;https://www.youtube.com/watch?v=V1xXmQkzkZI&amp;amp;index=13&amp;amp;list=PLZBP-86GmPTxpbvoFFzad0qYw5dKA8MV2&quot;&gt;this&lt;/a&gt; out for a video tutorial on Big O from UC Berkley. It's is actually a simple concept. If you hear professor Shewchuck (aka God level teacher) explaining it, you will say &quot;Oh that's all it is!&quot;.</source>
          <target state="translated">UC Berkley의 Big O에 대한 비디오 자습서를 확인하십시오. 실제로는 간단한 개념입니다. Shewchuck 교수 (일명 신 수준 교사)가 그것을 설명한다고 들으면 &quot;아, 그게 다야!&quot;라고 말할 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4523b29b5c7ed6f8c2abc5e9a4c38da02d06afc" translate="yes" xml:space="preserve">
          <source>Come back and reread the above when you've read the rest.</source>
          <target state="translated">나머지를 읽었을 때 되돌아 와서 위의 내용을 다시 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="55a7f0d03a20d7e0d958646e51faf45416912637" translate="yes" xml:space="preserve">
          <source>Compare 1 and 6, which is biggest? Ok 6 is in the right position, moving forward!</source>
          <target state="translated">1과 6을 비교해보십시오. Ok 6은 올바른 위치에 있으며 앞으로 나아갑니다!</target>
        </trans-unit>
        <trans-unit id="1c5884fcffc252b00f765da994d3959a5bea1cc4" translate="yes" xml:space="preserve">
          <source>Compare 6 and 3, oh, 3 is less! Let's move that, Ok the list changed, we need to start from the begining now!</source>
          <target state="translated">6과 3을 비교하면 3이 적습니다! 목록을 변경 했으니 시작부터 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5ae65887f49fb01b8aa1e42c87a37e72b0918ca" translate="yes" xml:space="preserve">
          <source>Compare &lt;em&gt;how quickly runtime grows&lt;/em&gt;&lt;strong&gt;NOT&lt;/strong&gt;&lt;em&gt;compare exact runtimes&lt;/em&gt; (depends on hardware)</source>
          <target state="translated">&lt;em&gt;런타임이 얼마나 빨리 증가하는지&lt;/em&gt; &lt;em&gt;비교 정확한 런타임을 비교&lt;/em&gt; &lt;strong&gt;하지 않음&lt;/strong&gt; (하드웨어에 따라 다름)</target>
        </trans-unit>
        <trans-unit id="3d11d48dee34717db426c8a89bfdced368207e28" translate="yes" xml:space="preserve">
          <source>Comparison between average-case and amortized worst-case:</source>
          <target state="translated">평균 사례와 상각 된 최악 사례의 비교 :</target>
        </trans-unit>
        <trans-unit id="ad8df7363e12666a15da250cd1535079ed8d98cb" translate="yes" xml:space="preserve">
          <source>Consider the canonical sorting example. Bubble-sort is O(n&lt;sup&gt;2&lt;/sup&gt;) while merge-sort is O(n log n). Let's say you have two sorting applications, application A which uses bubble-sort and application B which uses merge-sort, and let's say that for input sizes of around 30 elements application A is 1,000x faster than application B at sorting. If you never have to sort much more than 30 elements then it's obvious that you should prefer application A, as it is much faster at these input sizes. However, if you find that you may have to sort ten million items then what you'd expect is that application B actually ends up being thousands of times faster than application A in this case, entirely due to the way each algorithm scales.</source>
          <target state="translated">표준 정렬 예를 고려하십시오. 버블 정렬은 O (n &lt;sup&gt;2&lt;/sup&gt; )이고 병합 정렬은 O (n log n)입니다. 거품 정렬을 사용하는 응용 프로그램 A와 병합 정렬을 사용하는 응용 프로그램 B의 두 가지 정렬 응용 프로그램이 있고 약 30 요소의 입력 크기의 경우 응용 프로그램 A가 정렬시 응용 프로그램 B보다 1,000 배 빠르다고 가정 해 봅시다. 30 개 이상의 요소를 정렬 할 필요가없는 경우 이러한 입력 크기에서 훨씬 빠르기 때문에 응용 프로그램 A를 선호해야합니다. 그러나 천만 개의 항목을 정렬 해야하는 경우 응용 프로그램 B는 실제로이 경우 각 알고리즘의 확장 방식으로 인해 응용 프로그램 A보다 실제로 수천 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="a7c2b8ba88bf46f0dfe0a0ff9f1b26cb00f3ba83" translate="yes" xml:space="preserve">
          <source>Consider the difference between a steam engine and a rocket. They are not merely different varieties of the same thing (as, say, a Prius engine vs. a Lamborghini engine) but they are dramatically different kinds of propulsion systems, at their core. A steam engine may be faster than a toy rocket, but no steam piston engine will be able to achieve the speeds of an orbital launch vehicle. This is because these systems have different scaling characteristics with regards to the relation of fuel required (&quot;resource usage&quot;) to reach a given speed (&quot;input size&quot;).</source>
          <target state="translated">증기 기관과 로켓의 차이점을 고려하십시오. 프리우스 엔진과 람보르기니 엔진과 같이 같은 종류의 다른 종류 일뿐 아니라 핵심적으로 추진 시스템의 종류가 극적으로 다릅니다. 증기 기관은 장난감 로켓보다 빠르지 만 증기 피스톤 엔진은 궤도 발사 차량의 속도를 달성 할 수 없습니다. 이는 이들 시스템이 주어진 속도 ( &quot;입력 크기&quot;)에 도달하기 위해 필요한 연료 ( &quot;자원 사용량&quot;)의 관계와 관련하여 다른 스케일링 특성을 갖기 때문이다.</target>
        </trans-unit>
        <trans-unit id="6a8cfee71662bf83fd7610d0447480c8f098dc3b" translate="yes" xml:space="preserve">
          <source>Constant factors are negligible</source>
          <target state="translated">일정한 요소는 무시할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0da1286a9bca7edf66b07ff225ea54f102d5a653" translate="yes" xml:space="preserve">
          <source>Depending on N and X, your algorithm will require some operations, for example in the WORST case it's &lt;code&gt;3(N^2) + log(X)&lt;/code&gt; operations.</source>
          <target state="translated">N과 X에 따라 알고리즘에는 몇 가지 연산이 필요합니다. 예를 들어 WORST의 경우 &lt;code&gt;3(N^2) + log(X)&lt;/code&gt; 연산입니다.</target>
        </trans-unit>
        <trans-unit id="f8e74a3a562ba5774725315dfe1782d1a1275af0" translate="yes" xml:space="preserve">
          <source>Does not scale.  You have no hope of solving any non-trivially sized problem.  Useful for knowing what to avoid, and for experts to find approximate algorithms which are in &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt;.</source>
          <target state="translated">확장되지 않습니다. 사소한 규모의 문제를 해결할 희망은 없습니다. 피해야 할 사항을 알고 전문가가 &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; &lt;sup&gt;k&lt;/sup&gt; )&lt;/strong&gt; 에있는 대략적인 알고리즘을 찾는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c81313d6a9457c1a28868d8aaaff914cf1b3213c" translate="yes" xml:space="preserve">
          <source>Does this make a hashtable faster than an array for lookups? Not necessarily. If you've got a very small collection of entries, an array may well be faster &amp;mdash; you may be able to check all the strings in the time that it takes to just calculate the hashcode of the one you're looking at. As the data set grows larger, however, the hashtable will eventually beat the array.</source>
          <target state="translated">조회 배열보다 해시 테이블이 더 빠릅니까? 반드시 그런 것은 아닙니다. 매우 적은 수의 항목 모음이있는 경우 배열이 더 빠를 수 있습니다.보고있는 코드의 해시 코드를 계산하는 데 걸리는 시간에 모든 문자열을 확인할 수 있습니다. 그러나 데이터 세트가 커지면 해시 테이블은 결국 배열을 이길 것입니다.</target>
        </trans-unit>
        <trans-unit id="38f6893266ac6c8513618653e41d6736baa03b7c" translate="yes" xml:space="preserve">
          <source>EDIT: Quick note, this is almost certainly confusing &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; (which is an upper bound) with Theta notation (which is both an upper and lower bound). In my experience this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</source>
          <target state="translated">편집 : 빠른 참고, 이것은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O 표기법&lt;/a&gt; (상한)과 Theta 표기법 (상한 및 하한 모두)과 거의 혼동됩니다. 내 경험상 이것은 비 학술적 환경에서의 토론에서 실제로 일반적입니다. 혼란에 대한 사과.</target>
        </trans-unit>
        <trans-unit id="c8861868012e671e5ca7903151be427897869332" translate="yes" xml:space="preserve">
          <source>Each of these is an operation or a problem.  A method of solving these is called an &lt;strong&gt;algorithm&lt;/strong&gt;.</source>
          <target state="translated">이들 각각은 작업 또는 문제입니다. 이를 해결하는 방법을 &lt;strong&gt;알고리즘&lt;/strong&gt; 이라고합니다.</target>
        </trans-unit>
        <trans-unit id="b62541479f03733e3001473267dd14900d0760bc" translate="yes" xml:space="preserve">
          <source>Ergh.  That sounds like a lot of work!</source>
          <target state="translated">어. 그것은 많은 일처럼 들린다!</target>
        </trans-unit>
        <trans-unit id="b6dc6935629b7d3402db5c466e6d14aa566e6056" translate="yes" xml:space="preserve">
          <source>Estimates how many steps of the method your computer applies to accomplish a task.</source>
          <target state="translated">컴퓨터가 작업을 수행하기 위해 적용하는 방법의 단계 수를 추정합니다.</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">예 2 :</target>
        </trans-unit>
        <trans-unit id="1d4166bf97179d81c42dccef3ab9d1594a5dec5d" translate="yes" xml:space="preserve">
          <source>Example 3:</source>
          <target state="translated">예 3 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="184ce50741de2b5a2d508d5c7f7deb72ee16f548" translate="yes" xml:space="preserve">
          <source>Facilitate the process to compare with others in order to determine whether it's good or not?</source>
          <target state="translated">그것이 좋은지 아닌지를 결정하기 위해 다른 사람들과 비교하는 과정을 촉진합니까?</target>
        </trans-unit>
        <trans-unit id="8b846e7060b9a483588329ba98d3b24f7db5b0ed" translate="yes" xml:space="preserve">
          <source>For 1,000,000 it takes 20.</source>
          <target state="translated">1,000,000의 경우 20이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="bfc4a756390564c98c0f9ee2960940b370613e43" translate="yes" xml:space="preserve">
          <source>For 15 it takes 4.</source>
          <target state="translated">15의 경우 4가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="c4dcc93d74ce33740712a8b30e5dfa1a16cc492d" translate="yes" xml:space="preserve">
          <source>For 7 it takes at most 3.</source>
          <target state="translated">7의 경우 최대 3이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="8387ae59db1ca9e3e2f91943f6392088dfd4aa1a" translate="yes" xml:space="preserve">
          <source>For a phone book of 3 names it takes 2 comparisons (at most).</source>
          <target state="translated">이름이 3 개인 전화 번호부의 경우 최대 2 개의 비교가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5052922ba19448289d5da9158883ce125e05b963" translate="yes" xml:space="preserve">
          <source>For big n, n squared is more large than n.</source>
          <target state="translated">큰 n의 경우 n 제곱은 n보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="e5054e967dbdba1361ba3fb55414b378a8efdbff" translate="yes" xml:space="preserve">
          <source>For completeness, the precise definition of big-O notation is as follows: &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; means that &quot;f is asymptotically upper-bounded by const*g&quot;: ignoring everything below some finite value of x, there exists a constant such that &lt;code&gt;|f(x)| &amp;le; const * |g(x)|&lt;/code&gt;. (The other symbols are as follows: just like &lt;code&gt;O&lt;/code&gt; means &amp;le;, &lt;code&gt;&amp;Omega;&lt;/code&gt; means &amp;ge;. There are lowercase variants: &lt;code&gt;o&lt;/code&gt; means &amp;lt;, and &lt;code&gt;&amp;omega;&lt;/code&gt; means &amp;gt;.) &lt;code&gt;f(x) &amp;isin; Ɵ(g(x))&lt;/code&gt; means both &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; and &lt;code&gt;f(x) &amp;isin; &amp;Omega;(g(x))&lt;/code&gt; (upper- and lower-bounded by g): there exists some constants such that f will always lie in the &quot;band&quot; between &lt;code&gt;const1*g(x)&lt;/code&gt; and &lt;code&gt;const2*g(x)&lt;/code&gt;. It is the strongest asymptotic statement you can make and roughly equivalent to &lt;code&gt;==&lt;/code&gt;. (Sorry, I elected to delay the mention of the absolute-value symbols until now, for clarity's sake; especially because I have never seen negative values come up in a computer science context.)</source>
          <target state="translated">완전성을 기하기 위해 big-O 표기법의 정확한 정의는 다음과 같습니다. &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; 는 &quot;f가 const * g에 의해 무정형 상한&quot;이라는 것을 의미합니다. x의 유한 값 x 이하의 모든 것을 무시합니다. &lt;code&gt;|f(x)| &amp;le; const * |g(x)|&lt;/code&gt; 와 같은 상수가 있습니다. &amp;le; const * | g (x) | . (다른 기호는 다음과 같습니다. &lt;code&gt;O&lt;/code&gt; 는 &amp;le;을 의미하고 &lt;code&gt;&amp;Omega;&lt;/code&gt; 은 &amp;ge;를 의미합니다. 소문자 변형이 있습니다 : &lt;code&gt;o&lt;/code&gt; 는 &amp;lt;를 의미하고 &lt;code&gt;&amp;omega;&lt;/code&gt; 는&amp;gt;를 의미합니다) &lt;code&gt;f(x) &amp;isin; Ɵ(g(x))&lt;/code&gt; 는 &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; 및 &lt;code&gt;f(x) &amp;isin; &amp;Omega;(g(x))&lt;/code&gt; (g에 의해 상한 및 하한) f가 항상 &lt;code&gt;const1*g(x)&lt;/code&gt; 사이의 &quot;대역&quot;에 있도록하는 상수가 있습니다 * g (x) 및 &lt;code&gt;const2*g(x)&lt;/code&gt; 입니다. 그것은 당신이 만들 수있는 가장 강력한 점근 적 진술이며 &lt;code&gt;==&lt;/code&gt; 와 거의 같습니다. (죄송하지만, 명확성을 기하기 위해 지금까지 절대 값 기호에 대한 언급을 연기하기로 결정했습니다. 특히 컴퓨터 과학 상황에서 음수 값이 나타나는 것을 본 적이 없기 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="49654e3774111fb16128651b4d224ad6b75c2b89" translate="yes" xml:space="preserve">
          <source>For example, say you had the latitude and longitude coordinates of millions of road segments and wanted to find all street intersections.</source>
          <target state="translated">예를 들어, 수백만 개의 도로 세그먼트의 위도 및 경도 좌표가 있고 모든 거리 교차로를 찾고 싶다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="b3611110a9125b6ab52f37ddd431b3585818e9dd" translate="yes" xml:space="preserve">
          <source>For input of size &quot;n&quot; the program is growing at speed of &quot;n&quot; iterations in array. Hence Big-O is N expressed as  O(n)</source>
          <target state="translated">&quot;n&quot;크기의 입력에 대해 프로그램은 어레이에서 &quot;n&quot;반복 속도로 증가하고 있습니다. 따라서 Big-O는 N으로 O (n)으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="09e7373f604bf7164bb0dca1297d67c519bcfba7" translate="yes" xml:space="preserve">
          <source>For input of size &quot;n&quot; the program is growing at speed of &quot;n*n&quot; iterations in array. Hence Big-O is N&lt;sup&gt;2&lt;/sup&gt; expressed as  O(n&lt;sup&gt;2&lt;/sup&gt;)</source>
          <target state="translated">크기 &quot;n&quot;의 입력에 대해 프로그램은 어레이에서 &quot;n * n&quot;반복 속도로 증가하고 있습니다. 따라서 Big-O는 N &lt;sup&gt;2&lt;/sup&gt; 로 O (n &lt;sup&gt;2&lt;/sup&gt; )로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8a6ae78506dc4ee34684d9e0638c4281f35c545f" translate="yes" xml:space="preserve">
          <source>For online downloading, the download time is directly proportional to the movie file sizes (input). We call this &lt;strong&gt;O(n)&lt;/strong&gt;.</source>
          <target state="translated">온라인 다운로드의 경우 다운로드 시간은 동영상 파일 크기 (입력)에 정비례합니다. 우리는 이것을 &lt;strong&gt;O (n)&lt;/strong&gt; 이라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="67cc9e8bfc7b47bffe767706a99579808a311dcc" translate="yes" xml:space="preserve">
          <source>For the handshake example above, everyone in a room shakes everyone else's hand. In that example, &lt;code&gt;#handshakes &amp;isin; Ɵ(N&amp;sup2;)&lt;/code&gt;. Why?</source>
          <target state="translated">위의 핸드 셰이크 예에서는 방의 모든 사람이 다른 사람의 손을 흔 듭니다. 이 예에서 &lt;code&gt;#handshakes &amp;isin; Ɵ(N&amp;sup2;)&lt;/code&gt; 입니다. 왜?</target>
        </trans-unit>
        <trans-unit id="c5e2547d0bc6ba3ff90e388af4f7fa819fdfb175" translate="yes" xml:space="preserve">
          <source>Four (and this is the fun part): I have two small decks now, one more low than the splay card, and one more high.  Now I go to step one, on each small deck!  That is to say, I start from step One on the first small deck, and when that work is done, I start from step One on the next small deck.</source>
          <target state="translated">네 개 (그리고 이것은 재미있는 부분입니다) : 나는 두 개의 작은 데크를 가지고 있습니다. 하나는 스플레이 카드보다 낮고 하나는 더 높습니다. 이제 각 작은 갑판에서 1 단계로갑니다! 즉, 첫 번째 작은 데크의 1 단계부터 시작하여 작업이 완료되면 다음 작은 데크의 1 단계부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4a6b77756dd510894ce0e5f9cee853f3dfb273a0" translate="yes" xml:space="preserve">
          <source>From the experiments, we know that online shopping scales better than online downloading. It is very important to understand big O notation because it helps you to analyze the &lt;strong&gt;scalability&lt;/strong&gt; and &lt;strong&gt;efficiency&lt;/strong&gt; of algorithms.</source>
          <target state="translated">실험에서 우리는 온라인 쇼핑이 온라인 다운로드보다 더 잘 확장된다는 것을 알고 있습니다. 알고리즘의 &lt;strong&gt;확장&lt;/strong&gt; 성과 &lt;strong&gt;효율성&lt;/strong&gt; 을 분석하는 데 도움이되므로 큰 O 표기법을 이해하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e19041281d0dd99d852a13a94e9ffca8398dc327" translate="yes" xml:space="preserve">
          <source>Grows as a square, where &lt;em&gt;n&lt;/em&gt; is the length of the side of a square.  This is the same growth rate as the &quot;network effect&quot;, where everyone in a network might know everyone else in the network.  Growth is expensive.  Most scalable solutions cannot use algorithms with this level of complexity without doing significant gymnastics.  This generally applies to all other polynomial complexities - &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; - as well.</source>
          <target state="translated">사각형으로 자라며, 여기서 &lt;em&gt;n&lt;/em&gt; 은 사각형의 변의 길이입니다. 이는 네트워크의 모든 사람이 네트워크의 다른 모든 사람을 알 수있는 &quot;네트워크 효과&quot;와 동일한 성장률입니다. 성장은 비싸다. 대부분의 확장 가능한 솔루션은 상당한 체조를 수행하지 않으면 이러한 수준의 복잡성을 가진 알고리즘을 사용할 수 없습니다. 이것은 일반적으로 다른 모든 다항식 복잡성 &lt;strong&gt;-O ( &lt;em&gt;n&lt;/em&gt; &lt;sup&gt;k&lt;/sup&gt; )&lt;/strong&gt; 에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="36f6624b28e90d7b5439820ddf4b791141546e8a" translate="yes" xml:space="preserve">
          <source>Here comes big O, to tell us just how hard this math is.</source>
          <target state="translated">이 수학이 얼마나 어려운지를 알려주기 위해 여기에 큰 O가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e58c431d0ce6f70610939ce98c97531f57d61cc" translate="yes" xml:space="preserve">
          <source>Here is another thing we can recognize visually:</source>
          <target state="translated">시각적으로 인식 할 수있는 또 다른 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ab646045794b15182529717713fd6393652d11a" translate="yes" xml:space="preserve">
          <source>Here is the Wikipedia article: &lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;https://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;</source>
          <target state="translated">다음은 Wikipedia 기사입니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;https://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="001cff8786bd37eff234c46bb9b1b48e0988d759" translate="yes" xml:space="preserve">
          <source>Here is the plain English bestiary I tend to use when explaining the common varieties of Big-O</source>
          <target state="translated">다음은 Big-O의 일반적인 품종을 설명 할 때 사용하는 평범한 영어 기사입니다.</target>
        </trans-unit>
        <trans-unit id="43e41c55f998f736fd0e01106d1006e4f8370dd7" translate="yes" xml:space="preserve">
          <source>Here's an example where we have N T-shirts which we want to dry. We'll &lt;em&gt;assume&lt;/em&gt; it's incredibly quick to get them in the drying position (i.e. the human interaction is negligible). That's not the case in real life, of course...</source>
          <target state="translated">다음은 건조시키고 싶은 N- 셔츠가있는 예입니다. 건조 위치에 놓는 것이 매우 빠르다고 &lt;em&gt;가정&lt;/em&gt; 합니다 (즉, 인간의 상호 작용은 무시할 수 있습니다). 물론 현실에서는 그렇지 않습니다 ...</target>
        </trans-unit>
        <trans-unit id="c5af9b41639623efa7baf5be1ecd016aee231408" translate="yes" xml:space="preserve">
          <source>Here, the smallest recognizable outline you can draw is what matters; a triangle is a two dimensional shape (0.5 A^2), just like a square is a two-dimensional shape (A^2); the constant factor of two here remains in the asymptotic ratio between the two, however, we ignore it like all factors... (There are some unfortunate nuances to this technique I don't go into here; it can mislead you.)</source>
          <target state="translated">여기서 가장 작은 인식 가능한 윤곽선이 중요합니다. 삼각형은 2 차원 모양 (A ^ 2)과 마찬가지로 2 차원 모양 (0.5A ^ 2)입니다. 여기서 2의 상수 인자는 둘 사이의 점근 비율로 유지되지만 모든 요소와 마찬가지로 무시합니다 ... (이 기술에 대한 불행한 뉘앙스가 있지만 여기에 들어 가지 않을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="1d2dc7900c252d720e30b05b14c6ffb4be0d882b" translate="yes" xml:space="preserve">
          <source>Hmmm.  There may be a rule in there, I think.  To make big tasks small, break them up.</source>
          <target state="translated">흠. 거기에 규칙이있을 수 있습니다. 큰 작업을 작게하려면 해체하십시오.</target>
        </trans-unit>
        <trans-unit id="9c06c7ddd3fdd4ff139df20d27d2e5e8fe694d25" translate="yes" xml:space="preserve">
          <source>How can we sort this deck?  I have a plan.</source>
          <target state="translated">이 갑판을 어떻게 분류 할 수 있습니까? 난 계획을 가지고있어.</target>
        </trans-unit>
        <trans-unit id="b80eb8a9b1ad872be834851527556c78aaff922e" translate="yes" xml:space="preserve">
          <source>How do I know Quick Sort is less work?  I know that O(n log n) is less than O(n squared).  The O's are more small, so Quick Sort is less work!</source>
          <target state="translated">빠른 정렬이 덜 작동하는지 어떻게 알 수 있습니까? O (n log n)이 O (n squared)보다 작다는 것을 알고 있습니다. O는 더 작으므로 퀵 정렬은 덜 작동합니다!</target>
        </trans-unit>
        <trans-unit id="ce3005d8e3f4f0dd8dec37227d002f3f7de3b04c" translate="yes" xml:space="preserve">
          <source>How much more hard would it be?  How much more work would I have to do?  Do I need more or less steps?</source>
          <target state="translated">얼마나 더 힘들까요? 더 많은 일을해야합니까? 더 많거나 적은 단계가 필요합니까?</target>
        </trans-unit>
        <trans-unit id="a4daa40555f4cdbc41aa891d89c4fbcc8ad0f51b" translate="yes" xml:space="preserve">
          <source>However, for very large numbers of people, the linear term &lt;code&gt;N&lt;/code&gt; is dwarfed and effectively contributes 0 to the ratio (in the chart: the fraction of empty boxes on the diagonal over total boxes gets smaller as the number of participants becomes larger). Therefore the scaling behavior is &lt;code&gt;order N&amp;sup2;&lt;/code&gt;, or the number of handshakes &quot;grows like N&amp;sup2;&quot;.</source>
          <target state="translated">그러나 매우 많은 수의 사람들의 경우 선형 항 &lt;code&gt;N&lt;/code&gt; 은 왜소하고 0에 효과적으로 비율을 기여합니다 (차트에서 : 전체 상자에 대해 대각선의 빈 상자 비율은 참가자 수가 많아 질수록 작아짐). 따라서 스케일링 동작은 &lt;code&gt;order N&amp;sup2;&lt;/code&gt; 또는 핸드 셰이크 수가 &quot;N&amp;sup2;처럼 커짐&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="9f6b7a8c3e101e7571405d26663a1a4d8aefb762" translate="yes" xml:space="preserve">
          <source>I break up the deck in parts, and sort each part, more small and more small, and at some time I have no more work to do.  Now this may seem slow, with all the rules.  But trust me, it is not slow at all.  It is much less work than the first way to sort things!</source>
          <target state="translated">나는 갑판을 여러 부분으로 나누고 각 부분을 더 작고 작게 분류하며 때로는 더 이상 할 일이 없습니다. 이제 모든 규칙에 따라 속도가 느려질 수 있습니다. 그러나 나를 믿어 라. 그것은 결코 느리지 않다. 물건을 분류하는 첫 번째 방법보다 훨씬 적은 작업입니다!</target>
        </trans-unit>
        <trans-unit id="819fcf72178711a5bc5e8d2f9d5dd724ea8d6e5e" translate="yes" xml:space="preserve">
          <source>I care lots for big O.  Why?  I do not like to work!  No one likes to work.  That is why we all love big O!  He tells us how fast we can work.  He helps us think of how hard work is.</source>
          <target state="translated">나는 큰 O를 위해 많은 관심을 가지고있다. 왜? 나는 일하고 싶지 않다! 아무도 일하는 것을 좋아하지 않습니다. 그래서 우리 모두 큰 O를 좋아합니다! 그는 우리가 얼마나 빨리 일할 수 있는지 알려줍니다. 그는 우리가 얼마나 힘든 일인지 생각하도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="482a49f03db93f2d8f5d5daa020b481189471c57" translate="yes" xml:space="preserve">
          <source>I do not like to go to work.  I do not like to spend time at work.  If I had my way, I would like just to play, and do fun things.  Do you feel the same as I do?</source>
          <target state="translated">나는 일하러 가고 싶지 않습니다. 나는 직장에서 시간을 보내고 싶지 않습니다. 만약 내가 길을 가졌다면, 그냥 놀고, 재미있는 일을하고 싶습니다. 나처럼 느끼나요?</target>
        </trans-unit>
        <trans-unit id="ad52c5fb30262f15e8d3a80bd1081996754096a0" translate="yes" xml:space="preserve">
          <source>I do not want to add right now.  I just want to think on how hard it might be to add that much.  And, I hope, to play as soon as I can.</source>
          <target state="translated">지금 추가하고 싶지 않습니다. 나는 단지 그렇게 많은 것을 추가하는 것이 어려울 것이라고 생각하고 싶습니다. 그리고 가능한 빨리 플레이하기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="a8b731da95dde2cc32a2a652b9321f54f34bd44a" translate="yes" xml:space="preserve">
          <source>I found a really great explanation about big O notation especially for a someone who's not much into mathematics.</source>
          <target state="translated">나는 큰 O 표기법에 대해 특히 수학에별로 익숙하지 않은 사람에게 정말 훌륭한 설명을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="dab9c64b9a46ec0457c94246c45926dfd570f6b3" translate="yes" xml:space="preserve">
          <source>I have a deck of cards.  I did sort them.  You helped.  Thanks.</source>
          <target state="translated">카드 한 벌이 있습니다. 나는 그들을 분류했다. 당신은 도와주었습니다. 감사.</target>
        </trans-unit>
        <trans-unit id="3f1e4073256cafed9c07f32d545cc56213aba0e9" translate="yes" xml:space="preserve">
          <source>I have ten cards.  And, most of the time -- that is, if I don&amp;rsquo;t have lots of luck -- I must go through the whole deck up to ten times, with up to ten card swaps each time through the deck.</source>
          <target state="translated">10 장의 카드가 있습니다. 그리고 대부분의 경우, 즉 행운이 없다면, 갑판을 통해 매번 최대 10 장의 카드 스왑으로 전체 덱을 10 번까지 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ec03029a11a10972a0136154949cfcba5dbed69" translate="yes" xml:space="preserve">
          <source>I hope this is as simple as you want it.</source>
          <target state="translated">나는 이것이 당신이 원하는만큼 간단하기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="53ae10c16d270153bdbf8c1a9e6f93c880d6182f" translate="yes" xml:space="preserve">
          <source>I will look at each pair of cards, pair by pair, through the deck, from first to last.  If the first card in one pair is big and the next card in that pair is small, I swap them.  Else, I go to the next pair, and so on and so on... and soon, the deck is done.</source>
          <target state="translated">데크를 통해 각 카드 쌍을 한 쌍씩 살펴보고 처음부터 끝까지 살펴 보겠습니다. 한 쌍의 첫 번째 카드가 크고 그 쌍의 다음 카드가 작은 경우 교체합니다. 그렇지 않으면, 나는 다음 쌍으로 간다 등등. 그리고 곧, 갑판은 끝났다.</target>
        </trans-unit>
        <trans-unit id="b9d44117c5235dda1f72fad7eec883c624ba20a4" translate="yes" xml:space="preserve">
          <source>I'd prefer as little formal definition as possible and simple mathematics.</source>
          <target state="translated">가능한 한 공식적인 정의와 간단한 수학을 선호하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6bbf69b7602636fdd09cc6e847b5d115ba9d058" translate="yes" xml:space="preserve">
          <source>I've more simpler way to understand the time complexity
he most common metric for calculating time complexity is Big O notation. This removes all constant factors so that the running time can be estimated in relation to N as N approaches infinity. In general you can think of it like this:</source>
          <target state="translated">시간 복잡도를 계산하기 위해 가장 일반적으로 사용하는 시간 복잡도를 이해하는 더 간단한 방법은 Big O 표기법입니다. 이렇게하면 N이 무한대에 가까워 질 때 N과 관련하여 실행 시간을 추정 할 수 있도록 모든 상수 요소가 제거됩니다. 일반적으로 다음과 같이 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c93039db5b8dea862d7aba7ac7a736523f2e466" translate="yes" xml:space="preserve">
          <source>If an algorithm is O(n) then the time/space will increase at the same rate as its input.</source>
          <target state="translated">알고리즘이 O (n)이면 시간 / 공간이 입력과 동일한 속도로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="b93496435ccac02920ca75abbec4e210c6e1376f" translate="yes" xml:space="preserve">
          <source>If an algorithm is O(n&lt;sup&gt;2&lt;/sup&gt;) then the time/space increase at the rate of its input squared.</source>
          <target state="translated">알고리즘이 O (n &lt;sup&gt;2&lt;/sup&gt; )이면 입력 / 제곱 속도로 시간 / 공간이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="42bcc6138049b638ae7478e9aaa755e8a5fae576" translate="yes" xml:space="preserve">
          <source>If some values are effectively bounded due to some hidden fact (e.g. the average human name is softly bounded at perhaps 40 letters, and human age is softly bounded at around 150). You can also impose bounds on your input to effectively make terms constant.</source>
          <target state="translated">숨겨진 사실로 인해 일부 값이 효과적으로 제한되는 경우 (예 : 평균 사람 이름은 약 40 자로 부드럽게 묶이고, 나이는 약 150으로 부드럽게 묶입니다). 용어를 효과적으로 일정하게 만들기 위해 입력에 경계를 부과 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eadacee139f919b0ca67cb2be538cca322087b44" translate="yes" xml:space="preserve">
          <source>If the above doesn't make sense, then you don't have a compatible intuitive notion of infinity in your head, and you should probably disregard all of the above; the only way I know to make these ideas rigorous, or to explain them if they aren't already intuitively useful, is to first teach you big O notation or something similar. (although, once you well understand big O notation in the future, it may be worthwhile to revisit these ideas)</source>
          <target state="translated">위의 내용이 의미가 없으면 머리에 호환 가능한 직관적 인 무한대 개념이 없으므로 위의 내용을 모두 무시해야합니다. 이 아이디어를 엄격하게하거나 이미 직관적으로 유용하지 않은 경우 설명 할 수있는 유일한 방법은 먼저 큰 O 표기법이나 이와 유사한 것을 가르치는 것입니다. (앞으로 큰 O 표기법을 잘 이해했다면 이러한 아이디어를 다시 살펴 보는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="fc0f303936e49cce64dec3515e323c65eb23edc5" translate="yes" xml:space="preserve">
          <source>If the loop has finished without finding the key, return False.</source>
          <target state="translated">키를 찾지 않고 루프가 완료되면 False를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="1f90ef8cce8695b2d4c7c46d902314ff3d88ced2" translate="yes" xml:space="preserve">
          <source>If we do something slightly complicated, you might still be able to imagine visually what's going on:</source>
          <target state="translated">약간 복잡한 작업을 수행해도 현재 상황을 시각적으로 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="498ad5ebf90abce6c7640e5178604bd12d2cb5dd" translate="yes" xml:space="preserve">
          <source>If we do something very complicated, such as with a recursive function or divide-and-conquer algorithm, &lt;strike&gt;you can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem&quot;&gt;Master Theorem&lt;/a&gt; (usually works), or in ridiculous cases the Akra-Bazzi Theorem (almost always works)&lt;/strike&gt; you look up the running time of your algorithm on Wikipedia.</source>
          <target state="translated">재귀 함수 또는 분할 및 정복 알고리즘과 같이 매우 복잡한 작업을 수행 &lt;strike&gt;하는 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem&quot;&gt;Master Theorem&lt;/a&gt; (보통 작동)을 사용하거나 어리석은 경우 Akra-Bazzi Theorem (거의 항상 작동)&lt;/strike&gt; 을 사용할 수 있습니다. Wikipedia에서 알고리즘 실행 시간.</target>
        </trans-unit>
        <trans-unit id="f340d38ad5275f65c3f3c98f00a52fd253da01b5" translate="yes" xml:space="preserve">
          <source>If we have two 100-digit numbers we need to do 10,000 multiplications and 200 adds.  For two one million digit numbers we need to do one trillion (10&lt;sup&gt;12&lt;/sup&gt;) multiplications and two million adds.</source>
          <target state="translated">100 자리 숫자가 두 개인 경우 10,000 곱하기와 200을 더해야합니다. 2 백만 자리 숫자의 경우 1 조 (10 &lt;sup&gt;12&lt;/sup&gt; ) 곱셈과 2 백만 더하기를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a7797f63ba1469547a1c7c05a0e4651c75d6f7f" translate="yes" xml:space="preserve">
          <source>If we use a simple structure called a hash table (an instant-speed lookup table, also known as a hashmap or dictionary), we pay a small cost by preprocessing everything in &lt;code&gt;O(N)&lt;/code&gt; time. Thereafter, it only takes constant time on average to look up something by its key (in this case, our key is the latitude and longitude coordinates, rounded into a grid; we search the adjacent gridspaces of which there are only 9, which is a constant).</source>
          <target state="translated">해시 테이블 (해시 맵 또는 사전이라고도하는 인스턴트 속도 조회 테이블)이라는 간단한 구조를 사용하는 경우 &lt;code&gt;O(N)&lt;/code&gt; 시간 안에 모든 것을 사전 처리하여 적은 비용을 지불합니다. 그 후, 키로 무언가를 찾는 데 평균적으로 일정한 시간이 걸립니다 (이 경우 키는 위도 및 경도 좌표이며 그리드로 반올림됩니다. 우리는 인접한 그리드 공간을 9 개만 찾습니다. 일정한).</target>
        </trans-unit>
        <trans-unit id="532d60c07f8308239c74d78cfd8bd61382460fae" translate="yes" xml:space="preserve">
          <source>If you have 3 towns A, B and C with roads between all pairs then you could go:</source>
          <target state="translated">모든 쌍 사이에 도로가있는 3 개의 도시 A, B 및 C가있는 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e55a9c0f7521ee220edb5e820f851626c00f8e" translate="yes" xml:space="preserve">
          <source>If you have a suitable notion of infinity in your head, then there is a very brief description:</source>
          <target state="translated">머리에 적절한 무한대 개념이 있다면 매우 간단한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a391595810bc224de5ec62db4d75a23a1dd6b419" translate="yes" xml:space="preserve">
          <source>If you have to sort a deck, what is the best way?  Well, you can do what you want, but I would choose Quick Sort.</source>
          <target state="translated">데크를 정렬해야하는 경우 가장 좋은 방법은 무엇입니까? 글쎄, 원하는 것을 할 수 있지만 빠른 정렬을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c8f0c3e48ae6bc0a6ae30c3840b7e3d5da5a2114" translate="yes" xml:space="preserve">
          <source>If you only needed to do this once, it would not be a problem to have to do the naive method of &lt;code&gt;O(N)&lt;/code&gt; work only once, but if you want to do it many times (in this case, &lt;code&gt;N&lt;/code&gt; times, once for each segment), we'd have to do &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; work, or 1000000&amp;sup2;=1000000000000 operations. Not good (a modern computer can perform about a billion operations per second).</source>
          <target state="translated">이 작업을 한 번만 수행하면 &lt;code&gt;O(N)&lt;/code&gt; 의 순진한 방법을 한 번만 수행해야하는 문제가되지 않지만 여러 번 (이 경우 &lt;code&gt;N&lt;/code&gt; 번, 각 세그먼트)에 대해 &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; 작업 또는 1000000&amp;sup2; = 1000000000000 작업을 수행해야합니다. 좋지 않습니다 (현대 컴퓨터는 초당 약 10 억 번의 작업을 수행 할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="b0ce2012a9d7c727364cedfce54d754ac83295bd" translate="yes" xml:space="preserve">
          <source>If you read the &quot;Oh&quot; as meaning &quot;on the order of&quot; or &quot;approximately&quot; you will not go too far wrong. (I think the choice of the Big-Oh might have been an attempt at humour).</source>
          <target state="translated">&quot;Oh&quot;를 &quot;순서대로&quot;또는 &quot;대략&quot;을 의미하는 것으로 읽는다면 너무 잘못되지 않을 것입니다. (나는 Big-Oh의 선택이 유머를 시도한 것이라고 생각한다).</target>
        </trans-unit>
        <trans-unit id="879d10b4ee33a790e641d1a246a7c4921f058217" translate="yes" xml:space="preserve">
          <source>If you upgrade to a computer that can run your algorithm twice as fast, big O notation won't notice that. Constant factor improvements are too small to even be noticed in the scale that big O notation works with. Note that this is an intentional part of the design of big O notation.</source>
          <target state="translated">알고리즘을 두 배 빠르게 실행할 수있는 컴퓨터로 업그레이드하면 큰 O 표기법이이를 인식하지 못합니다. 상수 인자 개선은 너무 작아서 큰 O 표기법이 작동하는 규모에서도 눈에 띄지 않습니다. 이것은 큰 O 표기법 디자인의 의도적 인 부분입니다.</target>
        </trans-unit>
        <trans-unit id="4ca1f62a00fa89bcd7628fd712226caf431517e2" translate="yes" xml:space="preserve">
          <source>If you're sorting something like 5 elements, you don't want to use the speedy &lt;code&gt;O(N log(N))&lt;/code&gt; quicksort; you want to use insertion sort, which happens to perform well on small inputs. These situations often come up in divide-and-conquer algorithms, where you split up the problem into smaller and smaller subproblems, such as recursive sorting, fast Fourier transforms, or matrix multiplication.</source>
          <target state="translated">5 개의 요소와 같은 것을 정렬하는 경우 빠른 &lt;code&gt;O(N log(N))&lt;/code&gt; 퀵 정렬을 사용하고 싶지 않습니다. 작은 입력에서 잘 수행되는 삽입 정렬을 사용하려고합니다. 이러한 상황은 종종 재귀 정렬, 빠른 푸리에 변환 또는 행렬 곱셈과 같은 문제를 더 작은 하위 문제로 나누는 분할 및 정복 알고리즘에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b1d27a710e5b2deff8083ff199e610d9f97f11b2" translate="yes" xml:space="preserve">
          <source>In Big-O terms this is &lt;strong&gt;O(log n)&lt;/strong&gt; or &lt;strong&gt;logarithmic complexity&lt;/strong&gt;.  Now the logarithm in question could be ln (base e), log&lt;sub&gt;10&lt;/sub&gt;, log&lt;sub&gt;2&lt;/sub&gt; or some other base.  It doesn't matter it's still O(log n) just like O(2n&lt;sup&gt;2&lt;/sup&gt;) and O(100n&lt;sup&gt;2&lt;/sup&gt;) are still both O(n&lt;sup&gt;2&lt;/sup&gt;).</source>
          <target state="translated">Big-O 용어에서 이것은 &lt;strong&gt;O (log n)&lt;/strong&gt; 또는 &lt;strong&gt;로그 복잡도&lt;/strong&gt; 입니다. 이제 해당 로그는 ln (base e), log &lt;sub&gt;10&lt;/sub&gt; , log &lt;sub&gt;2&lt;/sub&gt; 또는 다른 염기가 될 수 있습니다. O (2n &lt;sup&gt;2&lt;/sup&gt; )와 O (100n &lt;sup&gt;2&lt;/sup&gt; )가 여전히 O (n &lt;sup&gt;2&lt;/sup&gt; )와 마찬가지로 여전히 O (log n)인지는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88e50d90d1750553c39e16c7f8930e4119cfca57" translate="yes" xml:space="preserve">
          <source>In CS, the set of steps to accomplish a task is called algorithms.</source>
          <target state="translated">CS에서는 작업을 수행하기위한 일련의 단계를 알고리즘이라고합니다.</target>
        </trans-unit>
        <trans-unit id="d95044d68f300f358a3a51cf89c9474f6f16e349" translate="yes" xml:space="preserve">
          <source>In Terminology, Big O notation is used to describe the performance or complexity of an algorithm.</source>
          <target state="translated">용어에서 Big O 표기법은 알고리즘의 성능 또는 복잡성을 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d65e5f9e362ebe36bedba5b57e018e3acbfc0c7b" translate="yes" xml:space="preserve">
          <source>In actuality there are 3 possibilities.</source>
          <target state="translated">실제로 3 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07046d757b1f2b48e849414a4e96d5ff13dade7a" translate="yes" xml:space="preserve">
          <source>In addition, Big O establishes the worst-case or measure the Upper-Bound steps.</source>
          <target state="translated">또한 Big O는 최악의 경우를 설정하거나 상한 단계를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="baa93a55b3140739514a5c40f8e2cdd9810a3c85" translate="yes" xml:space="preserve">
          <source>In all cases, prefer algorithms higher up on the list to those lower on the list.  However, the cost of moving to a more expensive complexity class varies significantly.</source>
          <target state="translated">모든 경우에, 목록에서 더 높은 알고리즘을 목록에서 더 낮은 알고리즘보다 선호하십시오. 그러나 더 비싼 복잡성 클래스로 이동하는 비용은 크게 다릅니다.</target>
        </trans-unit>
        <trans-unit id="30b960998b211299ef1c91dabf4d8dd22d39e434" translate="yes" xml:space="preserve">
          <source>In big O notation this is written as</source>
          <target state="translated">큰 O 표기법에서 이것은 다음과 같이 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="64aaef6ec6705e0f6426bbcc5b5fde04c862b7d5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;O(...)&lt;/code&gt; is the most useful one because we often care about worst-case behavior. If &lt;code&gt;f(x)&lt;/code&gt; represents something &quot;bad&quot; like the processor or memory usage, then &quot;&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt;&quot; means &quot;&lt;code&gt;upperbound&lt;/code&gt; is the worst-case scenario of processor/memory usage&quot;.</source>
          <target state="translated">일반적으로 &lt;code&gt;O(...)&lt;/code&gt; 가 가장 유용합니다. 왜냐하면 최악의 경우 행동에 관심이 있기 때문입니다. &lt;code&gt;f(x)&lt;/code&gt; 가 프로세서 또는 메모리 사용량과 같이 &quot;나쁜&quot;것을 나타내는 경우 &quot; &lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; &quot;은 &quot; &lt;code&gt;upperbound&lt;/code&gt; 은 프로세서 / 메모리 사용량의 최악의 시나리오&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e9fddaf6556848124995ffd1ed9ddc0b950170ab" translate="yes" xml:space="preserve">
          <source>In general, doing something with every item in one dimension is linear, doing something with every item in two dimensions is quadratic, and dividing the working area in half is logarithmic. There are other Big O measures such as cubic, exponential, and square root, but they're not nearly as common. Big O notation is described as O (  ) where  is the measure. The quicksort algorithm would be described as O ( N * log ( N ) ).</source>
          <target state="translated">일반적으로 한 차원의 모든 항목으로 작업을 수행하는 것은 선형이며, 두 차원의 모든 항목으로 작업을 수행하는 것은 2 차적이며 작업 영역을 반으로 나누는 것이 로그입니다. 3 차, 지수 및 제곱근과 같은 다른 Big O 측정 값이 있지만 거의 공통적이지는 않습니다. 큰 O 표기법은 측정 단위 인 O ()로 설명됩니다. 퀵 정렬 알고리즘은 O (N * log (N))로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="63a8eaf6bf07c1752a4bb48aa0c8cfc63edc138d" translate="yes" xml:space="preserve">
          <source>In general, our goal will be to find or structure an algorithm &lt;strong&gt;A&lt;/strong&gt; in such a way that it will have a function &lt;code&gt;X(n)&lt;/code&gt; that returns as low a number as possible.</source>
          <target state="translated">일반적으로 우리의 목표는 가능한 한 낮은 숫자를 반환하는 함수 &lt;code&gt;X(n)&lt;/code&gt; 을 갖도록 알고리즘 &lt;strong&gt;A&lt;/strong&gt; 를 찾거나 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7de7cd6bc8a2b03ecb0a68fecd7a6051d0934bd9" translate="yes" xml:space="preserve">
          <source>In many cases the &quot;O&quot; of an algorithm will fall into one of the following cases:</source>
          <target state="translated">많은 경우 알고리즘의 &quot;O&quot;는 다음 경우 중 하나에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a763bcaebb1bc5faa9ba3036763e8474d16f2b73" translate="yes" xml:space="preserve">
          <source>In one sentence: As the size of your job goes up, how much longer does it take to complete it?</source>
          <target state="translated">한 마디로 : 직업의 규모가 커질수록 완료하는 데 시간이 얼마나 더 걸립니까?</target>
        </trans-unit>
        <trans-unit id="4bfe8a12e0a2be2aee41e7617d2857524d177ee2" translate="yes" xml:space="preserve">
          <source>In other words where g(n) is the running time of your algorithm, we say that g(n) = O(f(n)) when g(n) &amp;lt;= c*f(n) when n &amp;gt; k, where c and k are some constants.</source>
          <target state="translated">즉, g (n)이 알고리즘의 실행 시간 인 경우 g (n) &amp;lt;= c * f (n) 일 때 n&amp;gt; k 일 때 g (n) = O (f (n))이라고합니다. c와 k는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="4e02f4f6e256066f1d4123d571431ca1ed48ec48" translate="yes" xml:space="preserve">
          <source>In other words, in plain English: &lt;em&gt;f&lt;/em&gt;(x) = O(&lt;em&gt;g&lt;/em&gt;(x)), x &amp;rarr; a, means that in a neighborhood of a, &lt;em&gt;f&lt;/em&gt; decomposes into the product of &lt;em&gt;g&lt;/em&gt; and some bounded function.</source>
          <target state="translated">다시 말해, 일반 영어로 : &lt;em&gt;f&lt;/em&gt; (x) = O ( &lt;em&gt;g&lt;/em&gt; (x)), x &amp;rarr; a는 a 근처에서 &lt;em&gt;f&lt;/em&gt; 가 &lt;em&gt;g&lt;/em&gt; 와 일부 한정된 함수의 곱으로 분해됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="68079fad5ce0cb40c968faed5e24541715996023" translate="yes" xml:space="preserve">
          <source>In practice, even among algorithms which have the same or similar asymptotic performance, their relative merit may actually be driven by other things, such as: other performance factors (quicksort and mergesort are both &lt;code&gt;O(N log(N))&lt;/code&gt;, but quicksort takes advantage of CPU caches); non-performance considerations, like ease of implementation; whether a library is available, and how reputable and maintained the library is.</source>
          <target state="translated">실제로는 동일하거나 유사한 점근 적 성능을 갖는 알고리즘 중에서도 상대적인 장점은 실제로 다음과 같은 다른 요인에 의해 좌우 될 수 있습니다. 다른 성능 요소 (quicksort 및 mergesort는 &lt;code&gt;O(N log(N))&lt;/code&gt; 이지만 quicksort는 CPU 캐시의 장점); 구현의 용이성과 같은 비 성능 고려 사항; 도서관의 이용 가능 여부 및 도서관의 평판 및 유지 관리 수준</target>
        </trans-unit>
        <trans-unit id="84ff32c19c195c6e0453458a4af8916d40d60004" translate="yes" xml:space="preserve">
          <source>In this new way to sort a deck, we do not check pairs of cards the way we did a while ago.  Here are your new rules to sort this deck:</source>
          <target state="translated">덱을 분류하는이 새로운 방법에서는, 우리가 한참 전에 한 쌍의 카드를 확인하지 않습니다. 이 데크를 정렬하는 새로운 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9da7190c61b8b40d9ee9d7282639dd113f829a6" translate="yes" xml:space="preserve">
          <source>Is N * log ( N ). The running time consists of N loops (iterative or recursive) that are logarithmic, thus the algorithm is a combination of linear and logarithmic.</source>
          <target state="translated">N * log (N)입니다. 실행 시간은 로그인 N 루프 (반복 또는 재귀)로 구성되므로 알고리즘은 선형 및 로그의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="998b8dec061b127d4bd37309e498d87df1954ca7" translate="yes" xml:space="preserve">
          <source>Is constant. The running time of the statement will not change in relation to N</source>
          <target state="translated">일정하다. 문의 실행 시간은 N과 관련하여 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c262ad477a4821f4fb1c7733312befe0c8fe05a" translate="yes" xml:space="preserve">
          <source>Is it more or less fast than the first sort?  Big O, please help!</source>
          <target state="translated">첫 번째 정렬보다 다소 빠르지 않습니까? 빅 오, 도와주세요!</target>
        </trans-unit>
        <trans-unit id="29e49e4fc142b2d0f2b1a400df6ab96e4a918158" translate="yes" xml:space="preserve">
          <source>Is linear. The running time of the loop is directly proportional to N. When N doubles, so does the running time.</source>
          <target state="translated">선형입니다. 루프의 작동 시간은 N에 정비례합니다. N이 두 배가되면 작동 시간도 증가합니다.</target>
        </trans-unit>
        <trans-unit id="0669d4a8187abfada364d0bb775de3933241efd7" translate="yes" xml:space="preserve">
          <source>Is logarithmic. The running time of the algorithm is proportional to the number of times N can be divided by 2. This is because the algorithm divides the working area in half with each iteration.</source>
          <target state="translated">로그입니다. 알고리즘의 실행 시간은 N을 2로 나눌 수있는 횟수에 비례합니다. 이는 알고리즘이 작업 영역을 각 반복마다 절반으로 나누기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f9cef10a1858aa5a865ebf26c425725395a40d0a" translate="yes" xml:space="preserve">
          <source>Is quadratic. The running time of the two loops is proportional to the square of N. When N doubles, the running time increases by N * N.</source>
          <target state="translated">이차입니다. 두 루프의 실행 시간은 N의 제곱에 비례합니다. N이 두 배가되면 실행 시간이 N * N만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="1189cb04bbafbceb75864abdc92eb47236ec61c3" translate="yes" xml:space="preserve">
          <source>Is there a more fast way to sort the cards?  Can big O help us?</source>
          <target state="translated">더 빠른 카드 분류 방법이 있습니까? 큰 O가 우리를 도울 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="bdcb0de02955e320abf0c31ab2a8744682cbbe08" translate="yes" xml:space="preserve">
          <source>It is very difficult to measure the speed of software programs, and when we try, the answers can be very complex and filled with exceptions and special cases. This is a big problem, because all those exceptions and special cases are distracting and unhelpful when we want to compare two different programs with one another to find out which is &quot;fastest&quot;.</source>
          <target state="translated">소프트웨어 프로그램의 속도를 측정하는 것은 매우 어렵고, 시도 할 때 답변은 매우 복잡하고 예외 및 특수 사례로 채워질 수 있습니다. 두 가지 다른 프로그램을 서로 비교하여 &quot;가장 빠른&quot;프로그램을 찾을 때 모든 예외 및 특수 사례가 혼란스럽고 도움이되지 않기 때문에 이는 큰 문제입니다.</target>
        </trans-unit>
        <trans-unit id="52df2acf675e9663e6643a99463b7ca8b662796f" translate="yes" xml:space="preserve">
          <source>It shows how an algorithm scales based on input size.</source>
          <target state="translated">입력 크기에 따라 알고리즘이 어떻게 확장되는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="293ad219691b62a126a8db817cbbea70a32b0c5f" translate="yes" xml:space="preserve">
          <source>It's as if the empty boxes on the diagonal of the chart (N*(N-1)/2 checkmarks) weren't even there (N&lt;sup&gt;2&lt;/sup&gt; checkmarks asymptotically).</source>
          <target state="translated">마치 차트 대각선의 빈 상자 (N * (N-1) / 2 확인 표시)가없는 것처럼 보입니다 (N &lt;sup&gt;2 확인&lt;/sup&gt; 표시가 그대로 표시됨).</target>
        </trans-unit>
        <trans-unit id="ec70bfe19e1f4d33f015bf1ed0c0eb3f05117561" translate="yes" xml:space="preserve">
          <source>It's worthwhile at this point to explain that Big O can be used to determine three cases with an algorithm:</source>
          <target state="translated">이 시점에서 Big O를 사용하여 알고리즘으로 세 가지 경우를 결정할 수 있다고 설명하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="29cba760a7e3ba133866ed85852ba33956337368" translate="yes" xml:space="preserve">
          <source>Iterating on each item in the list, if it's the key then return True,</source>
          <target state="translated">목록의 각 항목을 반복하여 키인 경우 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53da104c94a561d37e7b0bbeefcf47818dc3f2be" translate="yes" xml:space="preserve">
          <source>Keep in mind that big-O is not the whole story. You can drastically speed up some algorithms by using caching, making them cache-oblivious, avoiding bottlenecks by working with RAM instead of disk, using parallelization, or doing work ahead of time -- these techniques are often &lt;em&gt;independent&lt;/em&gt; of the order-of-growth &quot;big-O&quot; notation, though you will often see the number of cores in the big-O notation of parallel algorithms.</source>
          <target state="translated">big-O는 전체 이야기가 아니라는 점을 명심하십시오. 캐시 대신 캐시를 사용하거나 디스크 대신 RAM을 사용하거나 병렬화를 사용하거나 미리 작업을 수행하여 병목 현상을 피함으로써 일부 알고리즘의 속도를 크게 높일 수 있습니다. 이러한 기술은 종종 성장 순서와 &lt;em&gt;무관&lt;/em&gt; 합니다. &quot;big-O&quot;표기법이지만 병렬 알고리즘의 big-O 표기법에서 코어 수를 자주 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc8c7b0e9f3998b53c3c3a45f086e6279211fb80" translate="yes" xml:space="preserve">
          <source>Let's assume that the addition of these numbers is the most expensive operation in this algorithm. It stands to reason that to add these two numbers together we have to add together 6 digits (and possibly carry a 7th). If we add two 100 digit numbers together we have to do 100 additions.  If we add &lt;strong&gt;two&lt;/strong&gt; 10,000 digit numbers we have to do 10,000 additions.</source>
          <target state="translated">이 숫자를 더하는 것이이 알고리즘에서 가장 비싼 연산이라고 가정 해 봅시다. 이 두 숫자를 더하기 위해서는 6 자리 숫자를 더해야합니다 (그리고 7 번째 숫자도 가능). 두 100 자리 숫자를 더하면 100을 더해야합니다. 10,000 자리 숫자를 &lt;strong&gt;두&lt;/strong&gt; 개 더하면 10,000을 더해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e3d7a37946e8fa9bb0f4b9c5caa0b1e6214f02f" translate="yes" xml:space="preserve">
          <source>Let's say your algorithm dealing with the problem depends on some 'factors', for example let's make it N and X.</source>
          <target state="translated">문제를 다루는 알고리즘이 일부 '인자'에 의존한다고 가정 해 봅시다. 예를 들어 N과 X로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e09ce0464689a88f3f8747581ffb2d480edd57b6" translate="yes" xml:space="preserve">
          <source>Logarithms</source>
          <target state="translated">Logarithms</target>
        </trans-unit>
        <trans-unit id="0f768f66724b1ab90c8b65c4b90be682a8ff30a2" translate="yes" xml:space="preserve">
          <source>Logarithms are slightly trickier to explain so I'll use a common
  example:</source>
          <target state="translated">로그는 설명하기가 약간 까다롭기 때문에 일반적인 예를 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="818cd71ba05516b0c7d38db784302c45d9d62431" translate="yes" xml:space="preserve">
          <source>More precisely &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; is used to express the asymptotic behavior of a function. That means how the function behaves as it approaches infinity.</source>
          <target state="translated">보다 정확하게는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O 표기법&lt;/a&gt; 을 사용하여 함수의 점근 적 동작을 표현합니다. 이는 함수가 무한대에 접근함에 따라 어떻게 동작 하는지를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="53558434954a9542c40a6931db4c48fcfc391a05" translate="yes" xml:space="preserve">
          <source>Most of the time, people don't realize that there's more than one variable at work. For example, in a string-search algorithm, your algorithm may take time &lt;code&gt;O([length of text] + [length of query])&lt;/code&gt;, i.e. it is linear in two variables like &lt;code&gt;O(N+M)&lt;/code&gt;. Other more naive algorithms may be &lt;code&gt;O([length of text]*[length of query])&lt;/code&gt; or &lt;code&gt;O(N*M)&lt;/code&gt;. Ignoring multiple variables is one of the most common oversights I see in algorithm analysis, and can handicap you when designing an algorithm.</source>
          <target state="translated">대부분의 사람들은 직장에 하나 이상의 변수가 있다는 것을 인식하지 못합니다. 예를 들어, 문자열 검색 알고리즘에서 알고리즘은 시간 &lt;code&gt;O([length of text] + [length of query])&lt;/code&gt; 취할 수 있습니다. 즉, &lt;code&gt;O(N+M)&lt;/code&gt; 과 같은 두 변수에서 선형입니다. 다른 더 순수한 알고리즘은 &lt;code&gt;O([length of text]*[length of query])&lt;/code&gt; 또는 &lt;code&gt;O(N*M)&lt;/code&gt; 있습니다. 여러 변수를 무시하는 것은 알고리즘 분석에서 볼 수있는 가장 일반적인 감독 중 하나이며 알고리즘을 설계 할 때 장애를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="046638077884a582146518106d52398b493200ef" translate="yes" xml:space="preserve">
          <source>Multiplication is different. You line the numbers up, take the first digit in the bottom number and multiply it in turn against each digit in the top number and so on through each digit. So to multiply our two 6 digit numbers we must do 36 multiplications. We may need to do as many as 10 or 11 column adds to get the end result too.</source>
          <target state="translated">곱셈이 다릅니다. 숫자를 정렬하고 맨 아래 숫자의 첫 번째 숫자를 취한 다음 맨 위 숫자의 각 숫자와 차례로 각 숫자를 곱합니다. 6 자리 숫자 두 개를 곱하려면 36 곱셈을해야합니다. 최종 결과를 얻으려면 10 또는 11 열을 추가해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b1b53f8f44ad3ed2592eb6c68dec183ea16ec21" translate="yes" xml:space="preserve">
          <source>My list</source>
          <target state="translated">나의 목록</target>
        </trans-unit>
        <trans-unit id="f7535aeee1a8d7280cd70d9997d4349f35bb3d3e" translate="yes" xml:space="preserve">
          <source>Naive method: If you had the coordinates of a street intersection, and wanted to examine nearby streets, you would have to go through the millions of segments each time, and check each one for adjacency.</source>
          <target state="translated">순진한 방법 : 거리 교차로의 좌표가 있고 근처의 거리를 조사하려면 매번 수백만 개의 세그먼트를 거쳐 각 인접성을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d68869609a9235101b6bdb59cfad0ecf3bbe23e" translate="yes" xml:space="preserve">
          <source>No growth.  Regardless of how big as the problem is, you can solve it in the same amount of time.  This is somewhat analogous to broadcasting where it takes the same amount of energy to broadcast over a given distance, regardless of the number of people that lie within the broadcast range.</source>
          <target state="translated">성장이 없습니다. 문제의 크기에 관계없이 같은 시간에 문제를 해결할 수 있습니다. 이것은 브로드 캐스트 범위 내에있는 사람들의 수에 관계없이 주어진 거리에서 브로드 캐스트하는 데 동일한 양의 에너지를 소비하는 브로드 캐스트와 다소 유사합니다.</target>
        </trans-unit>
        <trans-unit id="fe33dcb0f45062333e4e71b8e3449ababa913575" translate="yes" xml:space="preserve">
          <source>Normally we don't care about the best case.  We're interested in the expected and worst case.  Sometimes one or the other of these will be more important.</source>
          <target state="translated">일반적으로 우리는 최선의 경우에 관심이 없습니다. 우리는 예상과 최악의 경우에 관심이 있습니다. 때때로 이들 중 하나 또는 다른 것이 더 중요 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a399a408e72ce4d50e1c555e9e14eb8f828e225" translate="yes" xml:space="preserve">
          <source>Not all algorithms run in the same amount of time, and can vary based on the number of items in the input, which we'll call &lt;em&gt;n&lt;/em&gt;. Based on this, we consider the worse case analysis, or an upper-bound of the run-time as &lt;em&gt;n&lt;/em&gt; get larger and larger. We must be aware of what &lt;em&gt;n&lt;/em&gt; is, because many of the Big O notations reference it.</source>
          <target state="translated">모든 알고리즘이 같은 시간에 실행되는 것은 아니며 입력 항목 수에 따라 다를 수 있으며,이를 &lt;em&gt;n이라고&lt;/em&gt; 합니다. 이를 바탕으로 우리는 더 나쁜 사례 분석 또는 &lt;em&gt;n이&lt;/em&gt; 점점 커질수록 런타임의 상한을 고려합니다. 많은 Big O 표기법이이를 참조하기 때문에 &lt;em&gt;n&lt;/em&gt; 이 무엇인지 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9701d8a66e2332c79e3006b450aca766fa1d69b7" translate="yes" xml:space="preserve">
          <source>Not sure I'm further contributing to the subject but still thought I'd share: I once found &lt;a href=&quot;http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/&quot;&gt;this blog post&lt;/a&gt; to have some quite helpful (though very basic) explanations &amp;amp; examples on Big O:</source>
          <target state="translated">내가 주제에 더 기여하고 있는지 잘 모르겠지만 여전히 공유하고 싶다고 생각했습니다. &lt;a href=&quot;http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/&quot;&gt;이 블로그 게시물&lt;/a&gt; 에서 Big O에 대한 매우 유용한 (아주 기본적이지만) 설명과 예를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="ed45d6f0b33afd4fda7acc9a90c9a6ded141d1e6" translate="yes" xml:space="preserve">
          <source>Note: None of this has taken into account best, average, and worst case measures. Each would have its own Big O notation. Also note that this is a VERY simplistic explanation. Big O is the most common, but it's also more complex that I've shown. There are also other notations such as big omega, little o, and big theta. You probably won't encounter them outside of an algorithm analysis course.</source>
          <target state="translated">참고 :이 중 어느 것도 최선, 평균 및 최악의 경우를 고려하지 않았습니다. 각각 고유 한 Big O 표기법이 있습니다. 또한 이것은 매우 간단한 설명입니다. Big O가 가장 일반적이지만 내가 보여준 것보다 더 복잡합니다. 큰 오메가, 작은 o 및 큰 세타와 같은 다른 표기법도 있습니다. 아마도 알고리즘 분석 과정 밖에서 그것들을 만나지 못할 것입니다.</target>
        </trans-unit>
        <trans-unit id="2238088b0eacca225a542e4f91ecc2965d263d59" translate="yes" xml:space="preserve">
          <source>Notice that the number of items increases by a factor of 10, but the time increases by a factor of 10&lt;sup&gt;2&lt;/sup&gt;. Basically, n=10 and so O(n&lt;sup&gt;2&lt;/sup&gt;) gives us the scaling factor n&lt;sup&gt;2&lt;/sup&gt; which is 10&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">항목 수는 10 배 증가하지만 시간은 10 &lt;sup&gt;2&lt;/sup&gt; 배 증가합니다. 기본적으로 n = 10이므로 O (n &lt;sup&gt;2&lt;/sup&gt; )는 10 &lt;sup&gt;2 인&lt;/sup&gt; 스케일링 계수 n &lt;sup&gt;2&lt;/sup&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="257c3797269830bc9710d43ca3694a583cd402ae" translate="yes" xml:space="preserve">
          <source>Now I have some work.  I have this list: one, two, three, four, five, six.  I must add all things in this list.</source>
          <target state="translated">이제 일이 있습니다. 나는이 목록을 가지고 있습니다 : 하나, 둘, 셋, 넷, 다섯, 여섯. 이 목록에 모든 것을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce4444486678ac072c200b97ac0870621f89a826" translate="yes" xml:space="preserve">
          <source>Now at times, I do have to go to work.  It is sad, but true.  So, when I am at work, I have a rule: I try to do less work.  As near to no work as I can.  Then I go play!</source>
          <target state="translated">지금은 때때로 일하러 가야합니다. 슬프지만 사실입니다. 따라서 직장에있을 때는 규칙이 있습니다. 일을 줄이려고합니다. 내가 할 수있는 일이 거의없는 것처럼. 그럼 놀러가요!</target>
        </trans-unit>
        <trans-unit id="4af2bcb5c492dc62ee7f7d5ed90f520c4c05c4e0" translate="yes" xml:space="preserve">
          <source>Now here comes big O, and he will tell us how hard this work is.  He says: to add all things from one to N, one by one, is O(n).  To add all these things, [I know I must add n times.][1]  That is big O!  He tells us how hard it is to do some type of work.</source>
          <target state="translated">이제 여기 O가 오는데, 그는이 작업이 얼마나 힘든지 알려줄 것입니다. 그는 말합니다. 하나부터 N까지 모든 것을 하나씩 더하는 것은 O (n)입니다. 이 모든 것을 추가하려면 [n을 더해야한다는 것을 알고 있습니다.] [1] O입니다! 그는 어떤 유형의 일을하는 것이 얼마나 어려운지를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6c34478c5f5b54c8853b19d59a2824aed411c88f" translate="yes" xml:space="preserve">
          <source>Now here is where big O is our friend.</source>
          <target state="translated">이제 여기에 큰 O가 우리의 친구입니다.</target>
        </trans-unit>
        <trans-unit id="110a534fc79ede4defb1ebec55d0413c614f421d" translate="yes" xml:space="preserve">
          <source>Now if you were instructing a computer to look up the phone number for &quot;John Smith&quot; in a telephone book that contains 1,000,000 names, what would you do?  Ignoring the fact that you could guess how far in the S's started (let's assume you can't), what would you do?</source>
          <target state="translated">이제 1,000,000 개의 이름이 포함 된 전화 번호부에서 &quot;John Smith&quot;의 전화 번호를 찾도록 컴퓨터에 지시 한 경우 어떻게 하시겠습니까? S가 얼마나 멀리 시작했는지 추측 할 수 없다는 사실을 무시하고 (그렇지 않다고 가정하자), 어떻게 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="9540b13ba056381a0510ad691215a7809e459df8" translate="yes" xml:space="preserve">
          <source>Now that work is done, let&amp;rsquo;s go play!</source>
          <target state="translated">이제 작업이 끝났습니다. 놀러 가자!</target>
        </trans-unit>
        <trans-unit id="d6eba09ebedd6f51a03a1027fa2fafcd89c71acb" translate="yes" xml:space="preserve">
          <source>Now they ask me to add from one to ten!  Why would I do that?  I did not want to add one to six.  To add from one to ten&amp;hellip; well&amp;hellip; that would be even more hard!</source>
          <target state="translated">이제 그들은 1에서 10까지 추가하도록 요청합니다! 내가 그런 짓을 왜 하겠어? 1-6을 추가하고 싶지 않았습니다. 1에서 10까지 추가하는 것은 ... 음&amp;hellip; 훨씬 더 어려울 것입니다!</target>
        </trans-unit>
        <trans-unit id="00988e447c66a2cb48babcb9e00cb583a7ea2cdd" translate="yes" xml:space="preserve">
          <source>Now we must do new work.  Oh, no.  I don&amp;rsquo;t like this work thing at all.</source>
          <target state="translated">이제 우리는 새로운 일을해야합니다. 아뇨 나는이 일을 전혀 좋아하지 않는다.</target>
        </trans-unit>
        <trans-unit id="2649fa4f7ace90e5e3a42578e0c5f2755906f188" translate="yes" xml:space="preserve">
          <source>Now when big O says it will take O(n squared) work, he does not mean n squared adds, on the nose.  It might be some small bit less, for some case.  But in the worst case, it will be near n squared steps of work to sort the deck.</source>
          <target state="translated">이제 큰 O가 O (n 제곱) 작업을 수행한다고 말하면 코에 n 제곱 추가를 의미하지는 않습니다. 경우에 따라 약간 작을 수도 있습니다. 그러나 최악의 경우 데크를 분류하는 작업은 n 제곱 단계에 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="08d4d2dadf777a65ea195b7215d064cef2cd8721" translate="yes" xml:space="preserve">
          <source>Now you know my friend, Big O.  He helps us do less work.  And if you know big O, you can do less work too!</source>
          <target state="translated">이제 내 친구 Big O를 알았습니다. 그는 우리가 일을 덜하도록 도와줍니다. 그리고 당신이 큰 O를 안다면, 당신은 더 적은 일을 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="05dc08a4c399781657ad8add0a8aafb1f260a439" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s you and me talk of work. Most of the time, I do not like work.  Do you like work?  It may be the case that you do, but I am sure I do not.</source>
          <target state="translated">자, 저와 일에 대해 이야기합시다. 대부분의 경우, 나는 일을 좋아하지 않습니다. 당신은 일을 좋아합니까? 당신이하는 경우 일 수 있지만, 나는 확신하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="205e8cfdfc5930c2d0673af6524af6317388bfed" translate="yes" xml:space="preserve">
          <source>O and Ω are not symmetric (n = O(n&amp;sup2;), but n&amp;sup2; is not O(n)), but Ɵ is symmetric, and (since these relations are all transitive and reflexive) Ɵ, therefore, is symmetric and transitive and reflexive, and therefore partitions the set of all functions into &lt;em&gt;equivalence classes&lt;/em&gt;. An equivalence class is a set of things that we consider to be the same. That is to say, given any function you can think of, you can find a canonical/unique 'asymptotic representative' of the class (by generally taking the limit... I &lt;em&gt;think&lt;/em&gt;); just like you can group all integers into odds or evens, you can group all functions with Ɵ into x-ish, log(x)^2-ish, etc... by basically ignoring smaller terms (but sometimes you might be stuck with more complicated functions which are separate classes unto themselves).</source>
          <target state="translated">O와 &amp;Omega;는 대칭이 아니며 (n = O (n&amp;sup2;), n&amp;sup2;는 O (n)이 아님), Ɵ는 대칭이며, (이 관계가 모두 전이적이고 반사적이므로) therefore, 따라서 대칭과 전이 및 반사 따라서 모든 함수 집합을 &lt;em&gt;동등성 클래스&lt;/em&gt; 로 분할합니다. 동등성 클래스는 우리가 동일하다고 생각하는 것들의 집합입니다. 다시 말해서, 당신이 생각할 수있는 어떤 기능이 주어지면, 당신은 클래스의 정식 / 독특한 '점근 적 대표자'를 찾을 수 있습니다 (일반적으로 한계를 가져서 ... 모든 정수를 홀수 또는 짝수로 그룹화 할 수 있듯이 기본적으로 작은 용어를 무시하여 Ɵ가있는 모든 함수를 x-ish, log (x) ^ 2-ish 등으로 그룹화 할 수 있습니다 (그러나 때로는 별도의 클래스 인 더 복잡한 함수).</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="98e642472708191e8a65ac2ab3cf6a96d7f6885e" translate="yes" xml:space="preserve">
          <source>O(1) = O(n) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin; (but not the other way around, the equality is &quot;fake&quot;),</source>
          <target state="translated">n &amp;rarr; + &amp;infin; 일 때 O (1) = O (n) = O (n &lt;sup&gt;2&lt;/sup&gt; ) (반대가 아니라면, 동일성은 &quot;가짜&quot;),</target>
        </trans-unit>
        <trans-unit id="25c301e3f5329dedc950de0f1c38ac8d3d8286a2" translate="yes" xml:space="preserve">
          <source>O(1) describes an algorithm that will always execute in the same time
  (or space) regardless of the size of the input data set.</source>
          <target state="translated">O (1)은 입력 데이터 세트의 크기에 관계없이 항상 같은 시간 (또는 공간)으로 실행되는 알고리즘을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1e77cb950a650cbda7e41c7e563dfc7d75184ce0" translate="yes" xml:space="preserve">
          <source>O(1), means your computer gets a task done with &lt;code&gt;1&lt;/code&gt; step, it's excellent, Ordered No.1</source>
          <target state="translated">O (1), 컴퓨터가 &lt;code&gt;1&lt;/code&gt; 단계로 작업을 수행한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8681bf4e62cb366ee6970996fa273715542e1c24" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;N&lt;/sup&gt;)</source>
          <target state="translated">O(2&lt;sup&gt;N&lt;/sup&gt;)</target>
        </trans-unit>
        <trans-unit id="e3d80bfb500c859c180f245124c30408ce843ee8" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;N&lt;/sup&gt;) denotes an algorithm whose growth doubles with each additon to
  the input data set. The growth curve of an O(2&lt;sup&gt;N&lt;/sup&gt;) function is
  exponential - starting off very shallow, then rising meteorically. An
  example of an O(2&lt;sup&gt;N&lt;/sup&gt;) function is the recursive calculation of Fibonacci
  numbers:</source>
          <target state="translated">O (2 &lt;sup&gt;N&lt;/sup&gt; )은 입력 데이터 세트에 각 additon마다 성장이 두 배로 증가하는 알고리즘을 나타냅니다. O (2 &lt;sup&gt;N&lt;/sup&gt; ) 함수의 성장 곡선은 기하 급수적으로 매우 얕게 시작하여 기상 적으로 상승합니다. O (2 &lt;sup&gt;N&lt;/sup&gt; ) 함수의 예는 피보나치 수의 재귀 계산입니다.</target>
        </trans-unit>
        <trans-unit id="68bc7ad068f5c61d49e37e6fc72efd56e5f32c9c" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;n&lt;/sup&gt;): If the input size increases by one, the runtime doubles</source>
          <target state="translated">O (2 &lt;sup&gt;n&lt;/sup&gt; ) : 입력 크기가 1 씩 증가하면 런타임이 두 배가됩니다</target>
        </trans-unit>
        <trans-unit id="63e9d8727f40f7ec9e8552148c03efe752771415" translate="yes" xml:space="preserve">
          <source>O(2^N),  get a task done with &lt;code&gt;2^N&lt;/code&gt; steps, it's horrible, Order No.6</source>
          <target state="translated">O (2 ^ N), &lt;code&gt;2^N&lt;/code&gt; 단계로 작업 완료, 끔찍합니다, 주문 번호 6</target>
        </trans-unit>
        <trans-unit id="308b527a11caed66089316ea8a6e1067c1969f82" translate="yes" xml:space="preserve">
          <source>O(N!),  get a task done with &lt;code&gt;N!&lt;/code&gt; steps, it's terrible, Order No.7</source>
          <target state="translated">O (N!), N로 과제를 완수하십시오 &lt;code&gt;N!&lt;/code&gt; 단계, 끔찍하다, 주문 번호 7</target>
        </trans-unit>
        <trans-unit id="a257064879b3c5b994b0c4eb5698b028eb534479" translate="yes" xml:space="preserve">
          <source>O(N)</source>
          <target state="translated">O(N)</target>
        </trans-unit>
        <trans-unit id="c3f150e3661faff6df87ef3476136d42ffe76b00" translate="yes" xml:space="preserve">
          <source>O(N) describes an algorithm whose performance will grow linearly and
  in direct proportion to the size of the input data set. The example
  below also demonstrates how Big O favours the worst-case performance
  scenario; a matching string could be found during any iteration of the
  for loop and the function would return early, but Big O notation will
  always assume the upper limit where the algorithm will perform the
  maximum number of iterations.</source>
          <target state="translated">O (N)은 성능이 입력 데이터 세트의 크기에 비례하여 선형 적으로 증가하는 알고리즘을 설명합니다. 아래 예는 또한 Big O가 최악의 성능 시나리오를 선호하는 방법을 보여줍니다. for 루프를 반복하는 동안 일치하는 문자열을 찾을 수 있으며 함수는 일찍 리턴하지만 Big O 표기법은 항상 알고리즘이 최대 반복 횟수를 수행하는 상한을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="50a60625d0c152951efa7ecdbe93cfe7f46beda6" translate="yes" xml:space="preserve">
          <source>O(N), finish a task with &lt;code&gt;N&lt;/code&gt; steps, its fair, Order No.3</source>
          <target state="translated">O (N), &lt;code&gt;N&lt;/code&gt; 단계, 공정, 주문 번호 3으로 작업 완료</target>
        </trans-unit>
        <trans-unit id="56b0b7dfdc166b52f3daf1b1c70a817924759e73" translate="yes" xml:space="preserve">
          <source>O(N&lt;sup&gt;2&lt;/sup&gt;)</source>
          <target state="translated">O(N&lt;sup&gt;2&lt;/sup&gt;)</target>
        </trans-unit>
        <trans-unit id="8c2b565c37a449cbce6a610382372bb9973c5a59" translate="yes" xml:space="preserve">
          <source>O(N&lt;sup&gt;2&lt;/sup&gt;) represents an algorithm whose performance is directly
  proportional to the square of the size of the input data set. This is
  common with algorithms that involve nested iterations over the data
  set. Deeper nested iterations will result in O(N&lt;sup&gt;3&lt;/sup&gt;), O(N&lt;sup&gt;4&lt;/sup&gt;) etc.</source>
          <target state="translated">O (N &lt;sup&gt;2&lt;/sup&gt; )는 성능이 입력 데이터 세트 크기의 제곱에 직접 비례하는 알고리즘을 나타냅니다. 이는 데이터 세트에 대해 중첩 된 반복을 포함하는 알고리즘에서 일반적입니다. 더 깊은 중첩 반복은 O (N &lt;sup&gt;3&lt;/sup&gt; ), O (N &lt;sup&gt;4&lt;/sup&gt; ) 등을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="de99ca4237dd94527753ecf95f080066d3a66999" translate="yes" xml:space="preserve">
          <source>O(N^2),  get a task done with &lt;code&gt;N^2&lt;/code&gt; steps, it's bad, Order No.5</source>
          <target state="translated">O (N ^ 2), &lt;code&gt;N^2&lt;/code&gt; 단계로 작업 완료, 나쁘다, 주문 번호 5</target>
        </trans-unit>
        <trans-unit id="044f421fbafcb690927916033a456e1ccb0b67d2" translate="yes" xml:space="preserve">
          <source>O(NlogN), ends a task with &lt;code&gt;O(NlogN)&lt;/code&gt; steps, it's not good, Order No.4</source>
          <target state="translated">O (NlogN), &lt;code&gt;O(NlogN)&lt;/code&gt; 단계로 작업을 종료합니다. 좋지 않습니다. 주문 번호 4</target>
        </trans-unit>
        <trans-unit id="adcb5e72616abf45d10a5b515b2a078ad0f91adb" translate="yes" xml:space="preserve">
          <source>O(O(n&lt;sup&gt;2&lt;/sup&gt;)) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">n &amp;rarr; + &amp;infin; 인 경우 O (O (n &lt;sup&gt;2&lt;/sup&gt; )) = O (n &lt;sup&gt;2&lt;/sup&gt; )</target>
        </trans-unit>
        <trans-unit id="ece6ebf71b235bbf6ca0d80731462a53a21f231d" translate="yes" xml:space="preserve">
          <source>O(log n): If the input size doubles the runtime increases by one</source>
          <target state="translated">O (log n) : 입력 크기가 두 배가되면 런타임이 1 씩 증가합니다</target>
        </trans-unit>
        <trans-unit id="7e25f642c5b31ae751d0fbe5acb56b926e9390ba" translate="yes" xml:space="preserve">
          <source>O(logN), means your computer complete a task with &lt;code&gt;logN&lt;/code&gt; steps, its good, Ordered No.2</source>
          <target state="translated">O (logN), 컴퓨터가 &lt;code&gt;logN&lt;/code&gt; 단계로 작업을 완료 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d09f9f7cdec58e339154e9a9c832d0991809a760" translate="yes" xml:space="preserve">
          <source>O(n) + O(n&lt;sup&gt;2&lt;/sup&gt;) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">n &amp;rarr; + &amp;infin; 인 경우 O (n) + O (n &lt;sup&gt;2&lt;/sup&gt; ) = O (n &lt;sup&gt;2&lt;/sup&gt; )</target>
        </trans-unit>
        <trans-unit id="97dd63fef8702296bf87a4c2e21f4bd48ff0b539" translate="yes" xml:space="preserve">
          <source>O(n) means Big O is n, and now you might think, &quot;What is n!?&quot; Well &quot;n&quot; is the amount of elements. Imaging you want to search for an Item in an Array. You would have to look on Each element and as &quot;Are you the correct element/item?&quot; in the worst case, the item is at the last index, which means that it took as much time as there are items in the list, so to be generic, we say &quot;oh hey, n is a fair given amount of values!&quot;.</source>
          <target state="translated">O (n)은 Big O가 n임을 의미하며 이제 &quot;N이란 무엇입니까?&quot; &quot;n&quot;은 원소의 양입니다. 이미징 배열에서 항목을 검색하려고합니다. 각 요소와 &quot;정확한 요소 / 항목입니까?&quot;로 살펴 봐야합니다. 최악의 경우, 항목은 마지막 색인에 있습니다. 즉, 목록에 항목이있는 것보다 많은 시간이 걸렸으므로, 일반적으로 &quot;오, n은 값이 주어진 공정한 값입니다!&quot; .</target>
        </trans-unit>
        <trans-unit id="d0849346fa8631d6b61d0173d101e04d26feaa94" translate="yes" xml:space="preserve">
          <source>O(n) ~ Linear</source>
          <target state="translated">O (n) ~ 선형</target>
        </trans-unit>
        <trans-unit id="a5fa19f57aec98afc3fc69df842b447d2a094f4c" translate="yes" xml:space="preserve">
          <source>O(n), O(n&lt;sup&gt;2&lt;/sup&gt;) etc. are all polynomial time. Some problems cannot be solved in polynomial time. Certain things are used in the world because of this. &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;Public Key Cryptography&lt;/a&gt; is a prime example. It is computationally hard to find two prime factors of a very large number. If it wasn't, we couldn't use the public key systems we use.</source>
          <target state="translated">O (n), O (n &lt;sup&gt;2&lt;/sup&gt; ) 등은 모두 다항식 시간입니다. 다항식 시간에서는 일부 문제를 해결할 수 없습니다. 이 때문에 세상에는 어떤 것들이 사용됩니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;공개 키 암호화&lt;/a&gt; 가 대표적인 예입니다. 매우 큰 두 가지 주요 요소를 찾는 것은 계산 상 어렵습니다. 그렇지 않은 경우 사용하는 공개 키 시스템을 사용할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="f995f059c281a355753f38679edd0e7f61f9dfcf" translate="yes" xml:space="preserve">
          <source>O(n): If I double the input size the runtime doubles</source>
          <target state="translated">O (n) : 입력 크기를 두 배로 늘리면 런타임이 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="830c15d5357ce8008571a4bcc897c78270ce5607" translate="yes" xml:space="preserve">
          <source>O(n&lt;sup&gt;2&lt;/sup&gt;): If the input size doubles the runtime quadruples</source>
          <target state="translated">O (n &lt;sup&gt;2&lt;/sup&gt; ) : 입력 크기가 런타임 4 배를 두 배로 늘리는 경우</target>
        </trans-unit>
        <trans-unit id="8639ae6910d96d5623a09688e0818a131fb8c50f" translate="yes" xml:space="preserve">
          <source>O(n&lt;sup&gt;2&lt;/sup&gt;)O(n&lt;sup&gt;3&lt;/sup&gt;) = O(n&lt;sup&gt;5&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">n &amp;rarr; + &amp;infin; 인 경우 O (n &lt;sup&gt;2&lt;/sup&gt; ) O (n &lt;sup&gt;3&lt;/sup&gt; ) = O (n &lt;sup&gt;5&lt;/sup&gt; )</target>
        </trans-unit>
        <trans-unit id="ac18ee6983cc2eb537d0f2f25351e9df638a26bd" translate="yes" xml:space="preserve">
          <source>Obviously that's only using &quot;size&quot; as the input and &quot;time taken&quot; as the output &amp;mdash; the same idea applies if you want to talk about memory usage etc.</source>
          <target state="translated">분명히 이것은 &quot;size&quot;를 입력으로 사용하고 &quot;take time&quot;을 출력으로 사용하는 것입니다. 메모리 사용 등에 대해 이야기하려는 경우에도 동일한 아이디어가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="047235fd8fb4d12aece908a6c0ecf01e2c06606a" translate="yes" xml:space="preserve">
          <source>Of course this does not mean that loops and functions are bad; on the contrary, they are the building blocks of modern programming languages, and we love them. However, we can see that the way we weave loops and functions and conditionals together with our data (control flow, etc.) mimics the time and space usage of our program! If time and space usage becomes an issue, that is when we resort to cleverness and find an easy algorithm or data structure we hadn't considered, to reduce the order of growth somehow. Nevertheless, these visualization techniques (though they don't always work) can give you a naive guess at a worst-case running time.</source>
          <target state="translated">물론 이것이 루프와 함수가 나쁘다는 것을 의미하지는 않습니다. 반대로, 그들은 현대 프로그래밍 언어의 빌딩 블록이며, 우리는 그것들을 좋아합니다. 그러나 데이터와 함께 루프와 함수 및 조건을 짜는 방식 (제어 흐름 등)이 프로그램의 시간 및 공간 사용량을 모방한다는 것을 알 수 있습니다! 시간과 공간 사용이 문제가된다면, 그것은 우리가 영리함에 의지하고 우리가 고려하지 않은 쉬운 알고리즘이나 데이터 구조를 찾아서 어떻게 든 성장 순서를 줄이는 것입니다. 그럼에도 불구하고, 이러한 시각화 기술 (항상 작동하지는 않지만)은 최악의 실행 시간에서 순진한 추측을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02eb439e917fc58abf025b96d214507c593cd917" translate="yes" xml:space="preserve">
          <source>Oh no, now I have more work.  Sheesh.  Who makes this kind of stuff?!</source>
          <target state="translated">아뇨, 이제 더 많은 일이 있습니다. esh. 누가 이런 종류의 물건을 만드는가?!</target>
        </trans-unit>
        <trans-unit id="846bee0b9db59985faaa143bf6c6677865b72c7b" translate="yes" xml:space="preserve">
          <source>Ok, my 2cents.</source>
          <target state="translated">좋아, 내 2 센트.</target>
        </trans-unit>
        <trans-unit id="4d41abb6d91ed8426b9c48d248c476619fafc156" translate="yes" xml:space="preserve">
          <source>Once I have found these two cards, I swap them, and go on to look for more cards to swap.  That is, I go back to step Two, and splay on the card you chose some more.</source>
          <target state="translated">이 두 카드를 찾으면 카드를 교환하고 교체 할 카드를 더 찾습니다. 즉, 나는 2 단계로 돌아가서 당신이 선택한 카드를 더 플레이합니다.</target>
        </trans-unit>
        <trans-unit id="bbe0abb1706b2ab494f9baaf3f32394aa9b1d99e" translate="yes" xml:space="preserve">
          <source>One can notice that we've assumed the worst case scenario here. While multiplying 6 digit numbers, if one of them has 4 digits and the other one has 6 digits, then we only have 24 multiplications. Still, we calculate the worst case scenario for that 'n', i.e when both are 6 digit numbers. Hence Big-O notation is about the Worst-case scenario of an algorithm.</source>
          <target state="translated">우리는 여기서 최악의 시나리오를 가정 한 것을 알 수 있습니다. 6 자리 숫자를 곱하는 동안 그 중 하나에 4 자리 숫자가 있고 다른 하나에 6 자리 숫자가 있으면 24 개의 곱셈 만 있습니다. 여전히, 우리는 그 'n'에 대한 최악의 시나리오, 즉 두 숫자가 모두 6 자리 숫자 인 경우를 계산합니다. 따라서 Big-O 표기법은 알고리즘의 최악의 시나리오에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="aa31e9cc8ee30f1096d7841ca16202599811c4d7" translate="yes" xml:space="preserve">
          <source>One important aspect of &quot;big O&quot; notation is that it &lt;em&gt;doesn't&lt;/em&gt; say which algorithm will be faster for a given size. Take a hashtable (string key, integer value)  vs an array of pairs (string, integer). Is it faster to find a key in the hashtable or an element in the array, based on a string? (i.e. for the array, &quot;find the first element where the string part matches the given key.&quot;) Hashtables are generally amortised (~= &quot;on average&quot;) O(1) &amp;mdash; once they're set up, it should take about the same time to find an entry in a 100 entry table as in a 1,000,000 entry table. Finding an element in an array (based on content rather than index) is linear, i.e. O(N) &amp;mdash; on average, you're going to have to look at half the entries.</source>
          <target state="translated">&quot;big O&quot;표기법의 중요한 측면 중 하나는 주어진 크기에 대해 어떤 알고리즘이 더 빠를 &lt;em&gt;지&lt;/em&gt; 말하지 &lt;em&gt;않는다는&lt;/em&gt; 것입니다. 해시 테이블 (문자열 키, 정수 값)과 쌍 배열 (문자열, 정수)을 가져옵니다. 문자열을 기반으로 해시 테이블에서 키를 찾거나 배열의 요소를 찾는 것이 더 빠릅니까? (즉, 배열의 경우, &quot;문자열 부분이 주어진 키와 일치하는 첫 번째 요소를 찾으십시오.&quot;) 해시 테이블은 일반적으로 상각됩니다 (~ = &quot;평균&quot;) O (1) &amp;mdash; 일단 설정되면 약 1,000,000 개의 엔트리 테이블에서와 같이 100 개의 엔트리 테이블에서 엔트리를 찾는 동시에. 배열에서 요소를 찾는 것은 (인덱스가 아닌 내용을 기반으로) 선형 적입니다. 즉, O (N) &amp;mdash; 평균적으로 항목의 절반을 봐야합니다.</target>
        </trans-unit>
        <trans-unit id="455ac552ede28e8384f4279d82396b29180d80b5" translate="yes" xml:space="preserve">
          <source>One plus two is three&amp;hellip; plus three is six... and four is... I don&amp;rsquo;t know.  I got lost.  It is too hard for me to do in my head.  I don&amp;rsquo;t much care for this kind of work.</source>
          <target state="translated">1 더하기 2는 3입니다. 더하기 3은 6입니다 ... 4는 ... 모르겠습니다. 나는 길을 잃었다. 머리 속에서하기가 너무 어렵다. 나는 이런 종류의 일을별로 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc82ac3fdfa2c36fc2c53eae610e61a05eb3407a" translate="yes" xml:space="preserve">
          <source>One: I choose one card in the part of the deck we work on now.  You can choose one for me if you like.  (The first time we do this, &amp;ldquo;the part of the deck we work on now&amp;rdquo; is the whole deck, of course.)</source>
          <target state="translated">하나 : 나는 우리가 현재 작업하는 덱 부분에서 하나의 카드를 선택합니다. 원한다면 나를 위해 하나를 선택할 수 있습니다. (처음으로&amp;ldquo;지금 작업하는 데크의 일부&amp;rdquo;는 전체 데크입니다.)</target>
        </trans-unit>
        <trans-unit id="6f7dd336bd44297d43d1e2584ebc5605a1581c94" translate="yes" xml:space="preserve">
          <source>Only concerned with runtime grow relative to the input &lt;strong&gt;(n)&lt;/strong&gt;</source>
          <target state="translated">입력에 상대적으로 런타임 증가에만 관심이 있습니다 &lt;strong&gt;(n)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e64c05fb1f7a3fd3c0cf63d3e43c979084e566b1" translate="yes" xml:space="preserve">
          <source>Or maybe you do log(N) passes of the data, for O(N*log(N)) total time:</source>
          <target state="translated">또는 O (N * log (N)) 총 시간 동안 데이터의 log (N) 패스를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e6e7bc29b2694c5ad9d0d21e7d44ffe2e43e41" translate="yes" xml:space="preserve">
          <source>Our task went from an infeasible &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; to a manageable &lt;code&gt;O(N)&lt;/code&gt;, and all we had to do was pay a minor cost to make a hash table.</source>
          <target state="translated">우리의 임무는 실행 불가능한 &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; 에서 관리 가능한 &lt;code&gt;O(N)&lt;/code&gt; 로 진행되었으며, 우리가해야 할 일은 해시 테이블을 만들기 위해 약간의 비용을 지불하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0732d399cd128b93b16b9a0583b8df0ddb1d224b" translate="yes" xml:space="preserve">
          <source>People will often use &lt;code&gt;= O(...)&lt;/code&gt;, which is perhaps the more correct 'comp-sci' notation, and entirely legitimate to use; &quot;f = O(...)&quot; is read &quot;f is order ... / f is xxx-bounded by ...&quot; and is thought of as &quot;f is some expression whose asymptotics are ...&quot;. I was taught to use the more rigorous &lt;code&gt;&amp;isin; O(...)&lt;/code&gt;. &lt;code&gt;&amp;isin;&lt;/code&gt; means &quot;is an element of&quot; (still read as before). In this particular case, &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; contains elements like {&lt;code&gt;2 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;3 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;1/2 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;2 N&amp;sup2; + log(N)&lt;/code&gt;, &lt;code&gt;- N&amp;sup2; + N^1.9&lt;/code&gt;, ...} and is infinitely large, but it's still a set.</source>
          <target state="translated">사람들은 종종 &lt;code&gt;= O(...)&lt;/code&gt; 을 사용할 것인데, 이는 아마도 더 정확한 'comp-sci'표기법이며 완전히 사용하기에 합법적입니다. &quot;f = O (...)&quot;는 &quot;f is order ... / f는 ...에 의해 xxx-bounded입니다.&quot;로 읽히고 &quot;f는 무증상이 ... 인 표현입니다&quot;라고 생각됩니다. 나는 더 엄격한 &lt;code&gt;&amp;isin; O(...)&lt;/code&gt; 을 사용하도록 배웠다. &lt;code&gt;&amp;isin;&lt;/code&gt; 는 &quot;의 요소&quot;를 의미합니다 (여전과 같이 읽음). 이 특정 경우에 &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; 는 { &lt;code&gt;2 N&amp;sup2;&lt;/code&gt; , &lt;code&gt;3 N&amp;sup2;&lt;/code&gt; , &lt;code&gt;1/2 N&amp;sup2;&lt;/code&gt; , &lt;code&gt;2 N&amp;sup2; + log(N)&lt;/code&gt; , &lt;code&gt;- N&amp;sup2; + N^1.9&lt;/code&gt; , ...}와 같은 요소를 포함하며 무한대로 크지 만 여전히 세트.</target>
        </trans-unit>
        <trans-unit id="aff7f1ca724e63fb9ec4afc2e9f2dbdfa5bff1a0" translate="yes" xml:space="preserve">
          <source>Please note the order at line end, just for your better understanding.There's more than 7 notations if all possibilities considered.</source>
          <target state="translated">이해하기 쉽도록 줄 끝에서 주문하십시오. 모든 가능성을 고려하면 7 개 이상의 표기법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff6f34b84d9b2e644758179e12f471c8957fb41f" translate="yes" xml:space="preserve">
          <source>Polynomial Time</source>
          <target state="translated">다항식 시간</target>
        </trans-unit>
        <trans-unit id="c745366182e555ccc5603f9f335f3de2d95eae3a" translate="yes" xml:space="preserve">
          <source>Practically speaking, Big O analysis is &lt;em&gt;so useful and important&lt;/em&gt; because Big O puts the focus squarely on the algorithm's &lt;em&gt;own&lt;/em&gt; complexity and completely &lt;em&gt;ignores&lt;/em&gt; anything that is merely a proportionality constant&amp;mdash;like a JavaScript engine, the speed of a CPU, your Internet connection, and all those things which become quickly become as laughably outdated as a Model &lt;em&gt;T&lt;/em&gt;. Big O focuses on performance only in the way that matters equally as much to people living in the present or in the future.</source>
          <target state="translated">실제로 Big O 분석은 알고리즘 &lt;em&gt;자체의&lt;/em&gt; 복잡성에 초점을 맞추고 JavaScript 엔진, CPU 속도, 인터넷 연결 및 모델 &lt;em&gt;T&lt;/em&gt; 만큼 재 빠르게 구식이 된 모든 것들. Big O는 현재 또는 미래에 살고있는 사람들에게 똑같이 중요한 방식으로 만 성과에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="707ddefda8b9d501a1d63dad3fcb74d0cb28b51a" translate="yes" xml:space="preserve">
          <source>Preface</source>
          <target state="translated">Preface</target>
        </trans-unit>
        <trans-unit id="c96271fcfba3e64dd9236be70e3f3f5fc45c32c9" translate="yes" xml:space="preserve">
          <source>Programs will also run slower on a 500MHz computer vs 2GHz computer. We don't really consider this as part of the resource bounds, because we think of the scaling in terms of machine resources (e.g. per clock cycle), not per real second. However, there are similar things which can 'secretly' affect performance, such as whether you are running under emulation, or whether the compiler optimized code or not. These might make some basic operations take longer (even relative to each other), or even speed up or slow down some operations asymptotically (even relative to each other). The effect may be small or large between different implementation and/or environment. Do you switch languages or machines to eke out that little extra work? That depends on a hundred other reasons (necessity, skills, coworkers, programmer productivity, the monetary value of your time, familiarity, workarounds, why not assembly or GPU, etc...), which may be more important than performance.</source>
          <target state="translated">프로그램은 또한 500MHz 컴퓨터와 2GHz 컴퓨터에서 느리게 실행됩니다. 실제 초 단위가 아닌 시스템 리소스 (예 : 클럭주기 당)로 스케일링을 생각하기 때문에이를 리소스 한계의 일부로 간주하지 않습니다. 그러나 에뮬레이션에서 실행 중인지 또는 컴파일러가 코드를 최적화했는지의 여부와 같이 성능에 '비밀'로 영향을 줄 수있는 유사한 것들이 있습니다. 이로 인해 일부 기본 작업이 더 길어 지거나 (상대적으로) 일부 작업의 속도가 빨라지거나 속도가 느려질 수 있습니다 (서로에 비해). 효과는 다른 구현 및 / 또는 환경 사이에서 작거나 클 수 있습니다. 약간의 추가 작업을 피하기 위해 언어 또는 기계를 전환합니까? 이는 성능보다 더 중요한 수백 가지 이유 (필요성, 기술, 동료, 프로그래머 생산성, 시간의 금전적 가치, 친숙성, 해결 방법, 어셈블리 또는 GPU 등이 아닌 이유 등)에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="0d31501e03db9492d0d452e6624c95d2a7fc34fc" translate="yes" xml:space="preserve">
          <source>Put another way, it's all about the &lt;strong&gt;ratio&lt;/strong&gt; as you go to infinity. &lt;em&gt;If you divide the actual time it takes by the &lt;code&gt;O(...)&lt;/code&gt;, you will get a constant factor in the limit of large inputs.&lt;/em&gt; Intuitively this makes sense: functions &quot;scale like&quot; one another if you can multiply one to get the other. That is when we say...</source>
          <target state="translated">다시 말해, 무한대로 갈 때의 &lt;strong&gt;비율&lt;/strong&gt; 에 관한 것입니다. &lt;em&gt;실제 시간을 &lt;code&gt;O(...)&lt;/code&gt; 나누면 큰 입력 한계에 일정한 요소가 생깁니다.&lt;/em&gt; 직관적으로 이것은 의미가 있습니다. 함수를 곱하여 다른 것을 얻을 수 있다면 함수는 서로 &quot;비율&quot;입니다. 우리가 말할 때입니다 ...</target>
        </trans-unit>
        <trans-unit id="b123240c4cc86a314f0b2ff2c7fcffe4a190bdd3" translate="yes" xml:space="preserve">
          <source>Putting everything in an airing cupboard: If we put everything in one big pile and just let general warmth do it, it will take a long time for the middle shirts to get dry. I wouldn't like to guess at the detail, but I suspect this is at least O(N^2) &amp;mdash; as you increase the wash load, the drying time increases faster.</source>
          <target state="translated">방송 찬장에 모든 것을 담기 : 모든 것을 하나의 큰 더미에 넣고 일반적인 따뜻함을 유지하면 중간 셔츠가 마르는 데 오랜 시간이 걸립니다. 세부 사항을 추측하고 싶지는 않지만 적어도 O (N ^ 2)라고 생각합니다. 세척 부하를 늘리면 건조 시간이 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="44d6998253d7ce7630dea94f49784bcc34a98b86" translate="yes" xml:space="preserve">
          <source>Quick Sort breaks up big decks in small ones.  That is to say, it breaks up big tasks in small ones.</source>
          <target state="translated">빠른 정렬은 작은 데크에서 큰 데크를 분할합니다. 즉, 작은 작업에서 큰 작업을 나눕니다.</target>
        </trans-unit>
        <trans-unit id="aafbf15c3d2cb24c90abf21327172d843932cd8c" translate="yes" xml:space="preserve">
          <source>Quick note, this is almost certainly confusing &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; (which is an upper bound) with Theta notation &quot;&amp;Theta;&quot; (which is a two-side bound). In my experience, this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</source>
          <target state="translated">참고로, 이것은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O 표기법&lt;/a&gt; (상한)과 Theta 표기법 &quot;&amp;Theta;&quot;(양쪽 바인딩)와 거의 혼동됩니다. 내 경험상, 이것은 실제로 비 학술적 환경에서의 토론에서 일반적입니다. 혼란에 대한 사과.</target>
        </trans-unit>
        <trans-unit id="78240c3b95a799ddc676899ee3f052157355ad48" translate="yes" xml:space="preserve">
          <source>Resource : Could be total-CPU time, could be maximum RAM space. By default refers to CPU time.</source>
          <target state="translated">리소스 : 총 CPU 시간 일 수 있으며 최대 RAM 공간 일 수 있습니다. 기본적으로 CPU 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ac86f485121aebe3e0cdccd29ad1f58c3d7af9cc" translate="yes" xml:space="preserve">
          <source>Say the problem is &quot;Find the Combination&quot;,</source>
          <target state="translated">문제가 &quot;조합 찾기&quot;라고 말하면</target>
        </trans-unit>
        <trans-unit id="a93e27c51787651f155cd14f8a574fade12b6fb2" translate="yes" xml:space="preserve">
          <source>Say the problem is &quot;Find the sum&quot;,</source>
          <target state="translated">문제가 &quot;계산 찾기&quot;라고 말하면</target>
        </trans-unit>
        <trans-unit id="a090d13ccede8e7fd94f3cd08042cf4d8572f583" translate="yes" xml:space="preserve">
          <source>Say you order Harry Potter: Complete 8-Film Collection [Blu-ray] from Amazon and download the same film collection online at the same time. You want to test which method is faster. The delivery takes almost a day to arrive and the download completed about 30 minutes earlier. Great! So it&amp;rsquo;s a tight race.</source>
          <target state="translated">Amazon에서 Harry Potter : Complete 8-Film Collection [Blu-ray]을 주문하고 동시에 온라인으로 동일한 영화 컬렉션을 다운로드한다고 가정 해보십시오. 어떤 방법이 더 빠른지 테스트하려고합니다. 배송은 거의 하루가 걸리며 다운로드는 약 30 분 일찍 완료되었습니다. 큰! 따라서 경쟁이 치열합니다.</target>
        </trans-unit>
        <trans-unit id="7c15a59b277cd7091e5fcf18a82064b3a5dd08e6" translate="yes" xml:space="preserve">
          <source>See more at: &lt;a href=&quot;http://proprogramming.org/2015/01/how-to-calculate-time-complexity-of.html#sthash.URrGFhqm.dpuf&quot;&gt;Here&lt;/a&gt;</source>
          <target state="translated">더보기 : &lt;a href=&quot;http://proprogramming.org/2015/01/how-to-calculate-time-complexity-of.html#sthash.URrGFhqm.dpuf&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1401abdd96246a6a7cc788610b57a7b896aa0b20" translate="yes" xml:space="preserve">
          <source>See the pattern?  The &lt;strong&gt;complexity&lt;/strong&gt; (being the number of operations) is directly proportional to the number of digits &lt;em&gt;n&lt;/em&gt; in the larger number.  We call this &lt;strong&gt;O(n)&lt;/strong&gt; or &lt;strong&gt;linear complexity&lt;/strong&gt;.</source>
          <target state="translated">패턴을 보시겠습니까? &lt;strong&gt;복잡도&lt;/strong&gt; (작업 수)는 큰 숫자의 자릿수 &lt;em&gt;n&lt;/em&gt; 에 정비례합니다. 이것을 &lt;strong&gt;O (n)&lt;/strong&gt; 또는 &lt;strong&gt;선형 복잡성이라고&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7bb8c396c1b1d4188f90d674eebb67f47ab45d2b" translate="yes" xml:space="preserve">
          <source>Since Big-O doesn't care too much about constant factor (aka 3), the Big-O of your algorithm is &lt;code&gt;O(N^2 + log(X))&lt;/code&gt;. It basically translates 'the amount of operations your algorithm needs for the worst case scales with this'.</source>
          <target state="translated">Big-O는 상수 인자 (일명 3)에 대해 너무 신경 쓰지 않기 때문에 알고리즘의 Big-O는 &lt;code&gt;O(N^2 + log(X))&lt;/code&gt; 입니다. 기본적으로 '이것으로 최악의 경우에 알고리즘이 필요한 연산량'을 번역합니다.</target>
        </trans-unit>
        <trans-unit id="185fbeb7236225913f02d9ced51afffe91dadcbe" translate="yes" xml:space="preserve">
          <source>So here is the big news: the big O can help me not to do work!  I can play more of the time, if I know big O.  Less work, more play!  That is what big O helps me do.</source>
          <target state="translated">여기 큰 소식이 있습니다. 큰 O는 내가 일하지 않도록 도와 줄 수 있습니다! 큰 O를 알면 더 많은 시간을 할 수 있습니다. 적은 일, 더 많은 놀이! 그것이 큰 O가 나를 돕는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f282cf5ef96e90a6a7f9b1e3944e8a0596d69aa5" translate="yes" xml:space="preserve">
          <source>So if you want to find a name in a phone book of a million names you can actually find any name by doing this at most 20 times.  In comparing search algorithms we decide that this comparison is our 'n'.</source>
          <target state="translated">따라서 백만 개의 전화 번호부에서 이름을 찾으려면 실제로 최대 20 회이 작업을 수행하여 이름을 찾을 수 있습니다. 검색 알고리즘을 비교할 때 우리는이 비교가 'n'이라고 결정합니다.</target>
        </trans-unit>
        <trans-unit id="54d9d5007b7529ef62839a976a2c108028d8927a" translate="yes" xml:space="preserve">
          <source>So let's not do the work.  Let's you and me just think how hard it is.  How much work would I have to do, to add six numbers?</source>
          <target state="translated">그러니 일하지 말자 당신과 저가 얼마나 힘든지 생각해 봅시다. 6 자리 숫자를 더하려면 얼마나해야합니까?</target>
        </trans-unit>
        <trans-unit id="0f7963f5bf0d662a36fd7990d2218173d00f1e7f" translate="yes" xml:space="preserve">
          <source>So the Big-O of the Traveling Salesman problem is &lt;strong&gt;O(n!)&lt;/strong&gt; or &lt;strong&gt;factorial or combinatorial complexity&lt;/strong&gt;.</source>
          <target state="translated">따라서 Traveling Salesman 문제의 Big-O는 &lt;strong&gt;O (n!)&lt;/strong&gt; 또는 &lt;strong&gt;계승 또는 조합 복잡성&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31cbba1dd119c95cd531f79932736280f8bc1df4" translate="yes" xml:space="preserve">
          <source>So then you might understand what &quot;n&lt;sup&gt;2&lt;/sup&gt;&quot; means, but to be even more specific, play with the thought you have a simple, the simpliest of the sorting algorithms; bubblesort. This algorithm needs to look through the whole list, for each item.</source>
          <target state="translated">따라서 &quot;n &lt;sup&gt;2&lt;/sup&gt; &quot;가 무엇을 의미하는지 이해할 수 있지만 더 구체적으로 말하면 가장 간단하고 간단한 정렬 알고리즘을 가지고 있다는 생각을 가지고 놀 수 있습니다. bubblesort. 이 알고리즘은 각 항목에 대해 전체 목록을 살펴 봐야합니다.</target>
        </trans-unit>
        <trans-unit id="f8d83ca9666fef6b181abee5dce4073e31010f19" translate="yes" xml:space="preserve">
          <source>So to find a name given the phone number (reverse lookup):</source>
          <target state="translated">전화 번호가 주어진 이름을 찾으려면 (역방향 조회) :</target>
        </trans-unit>
        <trans-unit id="d9f1ae7f841915d3f4dd37e4ec3ed8f5c6a2d975" translate="yes" xml:space="preserve">
          <source>So to talk of big O, I will use words that have just one beat in them.  One sound per word.  Small words are quick.  You know these words, and so do I.  We will use words with one sound.  They are small.  I am sure you will know all of the words we will use!</source>
          <target state="translated">그래서 큰 O에 대해 이야기하기 위해, 나는 단지 한 비트를 가진 단어를 사용할 것입니다. 단어 당 하나의 소리. 작은 단어는 빠릅니다. 당신은이 단어들을 알고 있습니다. 저도 마찬가지입니다. 우리는 하나의 소리로 단어를 사용할 것입니다. 그들은 작다. 우리가 사용할 모든 단어를 알게 될 것입니다!</target>
        </trans-unit>
        <trans-unit id="1a6bae9cafba4af7ae15b7b23952da6ff1ac18ed" translate="yes" xml:space="preserve">
          <source>Some asymptotically superior algorithms (e.g. a non-comparison &lt;code&gt;O(N log(log(N)))&lt;/code&gt; sort) can have so large a constant factor (e.g. &lt;code&gt;100000*N log(log(N))&lt;/code&gt;), or overhead that is relatively large like &lt;code&gt;O(N log(log(N)))&lt;/code&gt; with a hidden &lt;code&gt;+ 100*N&lt;/code&gt;, that they are rarely worth using even on &quot;big data&quot;.</source>
          <target state="translated">무조건적으로 우수한 일부 알고리즘 (예 : 비 비교 &lt;code&gt;O(N log(log(N)))&lt;/code&gt; 정렬은 너무 큰 상수 요소 (예 : &lt;code&gt;100000*N log(log(N))&lt;/code&gt; ) 또는 오버 헤드가 상대적으로 클 수 있음 숨겨진 &lt;code&gt;+ 100*N&lt;/code&gt; 인 &lt;code&gt;O(N log(log(N)))&lt;/code&gt; 와 같이 &quot;빅 데이터&quot;에서도 사용할 가치가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c3a47a93192e21e7b8da9213efad49591e03019" translate="yes" xml:space="preserve">
          <source>Something to think about.</source>
          <target state="translated">생각할 것.</target>
        </trans-unit>
        <trans-unit id="4039fdaf71cb4809949b869888d7b88d6c807b40" translate="yes" xml:space="preserve">
          <source>Sounds simple?  Think again.</source>
          <target state="translated">간단하게 들리나요? 다시 생각 해봐.</target>
        </trans-unit>
        <trans-unit id="3b9b41baa4e75cb4e6d6c6fd70132096551ccfd4" translate="yes" xml:space="preserve">
          <source>Subtraction is similar (except you may need to borrow instead of carry).</source>
          <target state="translated">빼기는 비슷합니다 (캐리지 대신 빌려야 할 수도 있습니다).</target>
        </trans-unit>
        <trans-unit id="92cba8f42714e9e6f65905758a187f5dc1f81125" translate="yes" xml:space="preserve">
          <source>Such a beautifully simple and short question seems at least to deserve an equally short answer, like a student might receive during tutoring.</source>
          <target state="translated">이러한 아름답고 간단하고 짧은 질문은 적어도 학생이 과외 수업 중에받을 수있는 것처럼 짧은 답변을받을 자격이있는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c2db9ddb042cb95f6f3da33f58156282aae57f5" translate="yes" xml:space="preserve">
          <source>Suppose</source>
          <target state="translated">Suppose</target>
        </trans-unit>
        <trans-unit id="6497864fec97aa054dc0495fd9cf472b076841fc" translate="yes" xml:space="preserve">
          <source>Suppose you get notation &lt;code&gt;O(N^2)&lt;/code&gt;, not only you are clear the method takes N*N steps to accomplish a task, also you see that it's not good as &lt;code&gt;O(NlogN)&lt;/code&gt; from its ranking.</source>
          <target state="translated">&lt;code&gt;O(N^2)&lt;/code&gt; 표기법을 사용한다고 가정하면, 방법이 작업을 수행하기 위해 N * N 단계를 취하는 것이 확실 할뿐만 아니라 순위에서 &lt;code&gt;O(NlogN)&lt;/code&gt; 만큼 좋지 않다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b05781eb417d58d8870e0c54b7d3d4450a3c5cf7" translate="yes" xml:space="preserve">
          <source>T(n)= The actual function that expresses the running time of the algorithm as a function of n</source>
          <target state="translated">T (n) = 알고리즘의 실행 시간을 n의 함수로 표현하는 실제 함수</target>
        </trans-unit>
        <trans-unit id="223cc76142198af8e0fb0a088ef6eb8d1fdff9c7" translate="yes" xml:space="preserve">
          <source>Take this to 4 towns and you have (iirc) 12 possibilities.</source>
          <target state="translated">이것을 4 개 도시로 가져 가면 12 개의 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6717a00806c940ae11e172679a7461df17fb3524" translate="yes" xml:space="preserve">
          <source>That is staggeringly good isn't it?</source>
          <target state="translated">그것은 엄청나게 좋지 않습니까?</target>
        </trans-unit>
        <trans-unit id="2b3ca8fd4b8fd6b2746880e61409e1fcd178be5c" translate="yes" xml:space="preserve">
          <source>That's the gist of it. They reduce the maths down so it might not be exactly n&lt;sup&gt;2&lt;/sup&gt; or whatever they say it is, but that'll be the dominating factor in the scaling.</source>
          <target state="translated">그것이 요점입니다. 수학을 줄이면 정확히 n &lt;sup&gt;2&lt;/sup&gt; 이 아니거나 말한 것이 아닐 수 있지만 스케일링에서 지배적 인 요소가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="a335b2fdf194a4b123c6adefad53cd69da1191ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&lt;/code&gt; notation might be the more common one and is even used in papers by world-renowned computer scientists. Additionally, it is often the case that in a casual setting, people will say &lt;code&gt;O(...)&lt;/code&gt; when they mean &lt;code&gt;Ɵ(...)&lt;/code&gt;; this is technically true since the set of things &lt;code&gt;Ɵ(exactlyThis)&lt;/code&gt; is a subset of &lt;code&gt;O(noGreaterThanThis)&lt;/code&gt;... and it's easier to type. ;-)</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; 표기법이 더 일반적 일 수 있으며 세계적으로 유명한 컴퓨터 과학자들이 논문에 사용하기도합니다. 또한 캐주얼 한 환경에서 사람들이 &lt;code&gt;Ɵ(...)&lt;/code&gt; 을 의미 할 때 &lt;code&gt;O(...)&lt;/code&gt; 라고 말하는 경우가 종종 있습니다. &lt;code&gt;Ɵ(exactlyThis)&lt;/code&gt; 는 &lt;code&gt;O(noGreaterThanThis)&lt;/code&gt; 의 하위 집합이므로 입력하기가 쉽기 때문에 이것은 기술적으로 사실입니다. ;-)</target>
        </trans-unit>
        <trans-unit id="aee94d96800326a2e37c8dd00dc11f09cbb047c7" translate="yes" xml:space="preserve">
          <source>The O in &quot;Big O&quot; refers to as &quot;Order&quot;(or precisely &quot;order of&quot;)</source>
          <target state="translated">&quot;Big O&quot;의 O는 &quot;주문&quot;(또는 정확하게 &quot;순서&quot;)이라고합니다.</target>
        </trans-unit>
        <trans-unit id="bc4389e9f64069d428331282297c6e278a98864d" translate="yes" xml:space="preserve">
          <source>The Telephone Book</source>
          <target state="translated">전화 번호부</target>
        </trans-unit>
        <trans-unit id="8cb03116d21f7000400f4bb7814a757a5f5a7de1" translate="yes" xml:space="preserve">
          <source>The Traveling Salesman</source>
          <target state="translated">여행 세일즈맨</target>
        </trans-unit>
        <trans-unit id="72a9a665cf2e8f84b6ab25450c58c79f3d3908aa" translate="yes" xml:space="preserve">
          <source>The above issues, like the effect of the choice of which programming language is used, are almost never considered as part of the constant factor (nor should they be); yet one should be aware of them because &lt;em&gt;sometimes&lt;/em&gt; (though rarely) they may affect things. For example in cpython, the native priority queue implementation is asymptotically non-optimal (&lt;code&gt;O(log(N))&lt;/code&gt; rather than &lt;code&gt;O(1)&lt;/code&gt; for your choice of insertion or find-min); do you use another implementation? Probably not, since the C implementation is probably faster, and there are probably other similar issues elsewhere. There are tradeoffs; sometimes they matter and sometimes they don't.</source>
          <target state="translated">프로그래밍 언어가 사용되는 선택의 효과와 같은 위의 문제는 상수 요소의 일부로 간주되지 않습니다. 그러나 &lt;em&gt;때로는&lt;/em&gt; (드물기는하지만) 영향을 줄 수 있기 때문에이를 알고 있어야합니다. 예를 들어, cpython에서 기본 우선 순위 큐 구현은 무조건 최적이 아닙니다 &lt;code&gt;O(1)&lt;/code&gt; 삽입 또는 find-min 선택에 대해 O (1) 대신 &lt;code&gt;O(log(N))&lt;/code&gt; ). 다른 구현을 사용하십니까? 아마도 C 구현이 더 빠르고 다른 곳에서도 비슷한 문제가있을 수 있기 때문에 아마도 아닙니다. 트레이드 오프가 있습니다. 때때로 그들은 중요하고 때로는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a92aef1bcf2b613748cc674288c56712f50682e2" translate="yes" xml:space="preserve">
          <source>The above statement is a good start but not completely true.</source>
          <target state="translated">위의 진술은 좋은 출발이지만 완전히 사실은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="af10522e397a98644d31608e45e48cac65ff2486" translate="yes" xml:space="preserve">
          <source>The analogy for amortized analysis:</source>
          <target state="translated">상각 분석에 대한 유추 :</target>
        </trans-unit>
        <trans-unit id="fccd0576a93e2738b676fa9e76398601f6ab71b0" translate="yes" xml:space="preserve">
          <source>The astute may have realized that we could express the number of operations as: n&lt;sup&gt;2&lt;/sup&gt; + 2n.  But as you saw from our example with two numbers of a million digits apiece, the second term (2n) becomes insignificant (accounting for 0.0002% of the total operations by that stage).</source>
          <target state="translated">현명한 사람은 우리가 n &lt;sup&gt;2&lt;/sup&gt; + 2n의 연산 수를 표현할 수 있음을 깨달을 수도 있습니다. 그러나 두 개의 숫자 (백만 자릿수)를 가진 예제에서 보았 듯이 두 번째 항 (2n)은 중요하지 않습니다 (해당 단계의 총 작업 중 0.0002 %를 차지함).</target>
        </trans-unit>
        <trans-unit id="11fa8c026f804b110c22f62945ac720ce5e2b7ce" translate="yes" xml:space="preserve">
          <source>The bad:</source>
          <target state="translated">나쁜 점 :</target>
        </trans-unit>
        <trans-unit id="8b80f48d4022e94ff91f1dba565c167cfe545120" translate="yes" xml:space="preserve">
          <source>The basics: Whenever we interact with every element in a collection of size A (such as an array, a set, all keys of a map, etc.), or perform A iterations of a loop, that is a multiplicative factor of size A. Why do I say &quot;a multiplicative factor&quot;?--because loops and functions (almost by definition) have multiplicative running time: the number of iterations, times work done in the loop (or for functions: the number of times you call the function, times work done in the function). (This holds if we don't do anything fancy, like skip loops or exit the loop early, or change control flow in the function based on arguments, which is very common.) Here are some examples of visualization techniques, with accompanying pseudocode.</source>
          <target state="translated">기본 사항 : 크기 A의 컬렉션 (예 : 배열, 집합,지도의 모든 키 등)의 모든 요소와 상호 작용하거나 루프의 반복을 수행 할 때마다 크기 A의 곱셈 요소 루프와 함수 (거의 정의에 따라)에 곱하기 실행 시간이 있기 때문에 반복 횟수, 루프에서 작업 한 횟수 (또는 함수 : 호출 횟수) 기능, 시간은 기능에서 수행됩니다). (루프 건너 뛰기 또는 루프를 조기에 종료하거나 인수를 기반으로 함수의 제어 흐름을 변경하는 것과 같이 멋진 작업을 수행하지 않는 경우 유지됩니다. 의사 코드와 함께 시각화 기술의 몇 가지 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ed7c47cc1915e8456623ae236c31623cd7a6dd2" translate="yes" xml:space="preserve">
          <source>The best example of Big-O I can think of is doing arithmetic.  Take two numbers (123456 and 789012).  The basic arithmetic operations we learnt in school were:</source>
          <target state="translated">내가 생각할 수있는 Big-O의 가장 좋은 예는 산술입니다. 두 개의 숫자 (123456 및 789012)를 사용하십시오. 우리가 학교에서 배운 기본 산술 연산은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ae878297661e38f79a2d80036a322346800b990" translate="yes" xml:space="preserve">
          <source>The cost of solving the problem is proportional to the size of the problem.  If your problem doubles in size, then the cost of the solution doubles.  Since most problems have to be scanned into the computer in some way, as data entry, disk reads, or network traffic, this is generally an affordable scaling factor.</source>
          <target state="translated">문제 해결 비용은 문제의 크기에 비례합니다. 문제의 크기가 두 배가되면 솔루션 비용이 두 배가됩니다. 데이터 입력, 디스크 읽기 또는 네트워크 트래픽과 같은 방식으로 대부분의 문제를 컴퓨터로 스캔해야하므로 이는 일반적으로 저렴한 확장 요소입니다.</target>
        </trans-unit>
        <trans-unit id="edbb1eb4311e72da0d8581264edd414e194f9ea0" translate="yes" xml:space="preserve">
          <source>The equation is read as 
As n approaches infinity, T of n, is less than or equal to c times f of n.</source>
          <target state="translated">n이 무한대에 가까워짐에 따라 방정식 T는 n의 c 곱하기 f의 n보다 작거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="7696e2ee0fe03e7287025d1b9b1e590710edef6e" translate="yes" xml:space="preserve">
          <source>The first sort was O(n squared).  But Quick Sort is O(n log n).  You know that n log n is less than n squared, for big n, right?  Well, that is how we know that Quick Sort is fast!</source>
          <target state="translated">첫 번째 정렬은 O (n 제곱)입니다. 그러나 빠른 정렬은 O (n log n)입니다. n log n이 n 제곱보다 작다는 것을 알고 있습니다. 그렇기 때문에 빠른 정렬이 빠르다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef63c6ddf6e7a7898b093aa5fa501850b023edae" translate="yes" xml:space="preserve">
          <source>The flow here would be:</source>
          <target state="translated">흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7c2775507fbff85fd208fcd7a9eefd861c88ccd" translate="yes" xml:space="preserve">
          <source>The good:</source>
          <target state="translated">좋은 점 :</target>
        </trans-unit>
        <trans-unit id="40776bd664da80434dcafa973f539de3f9f745d5" translate="yes" xml:space="preserve">
          <source>The input size is usually the space in bits needed to represent the input.</source>
          <target state="translated">입력 크기는 일반적으로 입력을 나타내는 데 필요한 비트 단위의 공간입니다.</target>
        </trans-unit>
        <trans-unit id="d1b781877a2eef3021049a9a0ec22cac469bc50c" translate="yes" xml:space="preserve">
          <source>The moral of the story: a data structure lets us speed up operations. Even more, advanced data structures can let you combine, delay, or even ignore operations in incredibly clever ways. Different problems would have different analogies, but they'd all involve organizing the data in a way that exploits some structure we care about, or which we've artificially imposed on it for bookkeeping. We do work ahead of time (basically planning and organizing), and now repeated tasks are much much easier!</source>
          <target state="translated">이야기의 교훈 : 데이터 구조를 통해 작업 속도를 높일 수 있습니다. 더욱이, 고급 데이터 구조를 사용하면 믿을 수 없을 정도로 영리한 방식으로 작업을 결합, 지연 또는 무시할 수 있습니다. 다른 문제는 다른 유추가있을 수 있지만, 우리가 관심을 갖는 일부 구조를 활용하거나 부기 관리를 위해 인위적으로 부과 한 방식으로 데이터를 구성해야합니다. 사전 계획 (기본 계획 및 구성)을 수행하므로 반복 작업이 훨씬 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="431150559f3afdb40719059de8cafc2364a6f27a" translate="yes" xml:space="preserve">
          <source>The new work is: add all things from one to n.</source>
          <target state="translated">새로운 작업은 1에서 n까지 모든 것을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9734a1f2bb99a793e146aed547eba3d5bde616de" translate="yes" xml:space="preserve">
          <source>The next best example I can think of is the telephone book, normally called the White Pages or similar but it varies from country to country.  But I'm talking about the one that lists people by surname and then initials or first name, possibly address and then telephone numbers.</source>
          <target state="translated">내가 생각할 수있는 다음으로 가장 좋은 예는 전화 번호부 (일반적으로 화이트 페이지 또는 이와 유사 함)이지만 국가마다 다릅니다. 그러나 나는 성을 기준으로 사람들을 나열 한 다음 이니셜이나 이름, 주소 및 전화 번호에 대해 이야기하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="30a4b2c863fa4772ef38b8845a347878d2aa00fa" translate="yes" xml:space="preserve">
          <source>The number of computations is only increased by a log of the input value.  So in this case, assuming each computation takes 1 second, the log of the input &lt;code&gt;n&lt;/code&gt; is the time required, hence &lt;code&gt;log n&lt;/code&gt;.</source>
          <target state="translated">계산 횟수는 입력 값의 로그만큼만 증가합니다. 따라서이 경우 각 계산에 1 초가 걸리는 경우 입력 &lt;code&gt;n&lt;/code&gt; 의 로그는 필요한 시간이므로 &lt;code&gt;log n&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3aad895641cfd48567e63f48472fae12fcf69c0b" translate="yes" xml:space="preserve">
          <source>The number of items is still increasing by a factor of 10, but the scaling factor of O(1) is always 1.</source>
          <target state="translated">항목 수는 여전히 10 배 증가하지만 O (1)의 배율은 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="4e86a40dc1403a10780f816da6e77341ee5ea1e5" translate="yes" xml:space="preserve">
          <source>The only thing that these &quot;Big-Oh&quot; expressions try to do is to describe how much the software slows down as we increase the amount of data that the software has to process. If we double the amount of data that needs to be processed, does the software need twice as long to finish it's work? Ten times as long? In practice, there are a very limited number of big-Oh expressions that you will encounter and need to worry about:</source>
          <target state="translated">이러한 &quot;Big-Oh&quot;표현이 시도하는 유일한 것은 소프트웨어가 처리해야하는 데이터의 양을 증가시키면서 소프트웨어가 얼마나 느려지는지를 설명하는 것입니다. 처리해야 할 데이터 양을 두 배로 늘리면 소프트웨어가 작동하는 데 두 배의 시간이 필요합니까? 열 배나? 실제로, 당신은 직면하게 될 걱정할 필요가있는 매우 큰 수의 큰 오 표현이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0c4ac6494f1b66e30eda83ca592154e03a3a8fc2" translate="yes" xml:space="preserve">
          <source>The same can be said for the &lt;strong&gt;very act of writing&lt;/strong&gt;. All algorithms which print out N things will take N time because the output is at least that long (e.g. printing out all permutations (ways to rearrange) a set of N playing cards is factorial: &lt;code&gt;O(N!)&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;바로 글쓰기 행위에&lt;/strong&gt; 대해서도 마찬가지입니다. N 개를 출력하는 모든 알고리즘은 출력이 적어도 그 시간이 길기 때문에 N 시간이 걸립니다 (예 : N 개의 재생 카드 세트가 모든 순열을 인쇄 (다시 정렬하는 방법)하는 것은 계승 : &lt;code&gt;O(N!)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf763b5c77d1eaec2bb764fe4187dc0b86926fc4" translate="yes" xml:space="preserve">
          <source>The simplest definition I can give for Big-O notation is this:</source>
          <target state="translated">Big-O 표기법에 대한 가장 간단한 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9316c2f2fa69e85df7f06354c94d1417cfb91787" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;O( &amp;lt;some expression X involving n&amp;gt; )&lt;/code&gt; means, in simple English:</source>
          <target state="translated">그런 다음 &lt;code&gt;O( &amp;lt;some expression X involving n&amp;gt; )&lt;/code&gt; 는 간단한 영어로 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8d780e455cede763fea2fd15a77afe9241e0ac7a" translate="yes" xml:space="preserve">
          <source>Then as far as Big O is concerned, the approximation f(n) is considered good enough as long as the below condition is true.</source>
          <target state="translated">그런 다음 Big O에 관한 한, 근사 f (n)은 아래 조건이 참인 한 충분히 양호한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ee898084770160432d4052d1b6366394874b74dc" translate="yes" xml:space="preserve">
          <source>There are many choices of constant; often the &quot;best&quot; choice is known as the &quot;constant factor&quot; of the algorithm... but we often ignore it like we ignore non-largest terms (see Constant Factors section for why they don't usually matter). You can also think of the above equation as a bound, saying &quot;&lt;em&gt;In the worst-case scenario, the time it takes will never be worse than roughly &lt;code&gt;N*log(N)&lt;/code&gt;, within a factor of 2.5 (a constant factor we don't care much about)&lt;/em&gt;&quot;.</source>
          <target state="translated">많은 상수 선택이 있습니다. 종종 &quot;최상의&quot;선택은 알고리즘의 &quot;일정한 요인&quot;으로 알려져 있지만 가장 큰 용어를 무시하는 것처럼 종종 무시합니다 (일반적으로 중요하지 않은 이유는 상수 요인 섹션 참조). 위의 방정식을 경계로 생각할 수도 있습니다. &quot; &lt;em&gt;가장 최악의 시나리오에서는 걸리는 시간이 2.5 배 (약속 계수 &lt;code&gt;N*log(N)&lt;/code&gt; 내에서 대략 N * log (N) 보다 나 빠지지 않을 것입니다. t는&lt;/em&gt; &quot; &lt;em&gt;)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f3b28edc57f1a5b8e2ff6393649371701cff785f" translate="yes" xml:space="preserve">
          <source>There are some important and deliberately chosen words in that sentence:</source>
          <target state="translated">그 문장에는 중요하고 일부러 선택된 단어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="735800377cfb894185f412511981fdfbdcaa94c0" translate="yes" xml:space="preserve">
          <source>There is a lot of information that Big O does not tell you about a given algorithm. It cuts to the bone and gives only information about the scaling nature of an algorithm, specifically how the resource use (think time or memory) of an algorithm scales in response to the &quot;input size&quot;.</source>
          <target state="translated">Big O가 주어진 알고리즘에 대해 알려주지 않는 많은 정보가 있습니다. 뼈를 자르고 알고리즘의 스케일링 특성, 특히 &quot;입력 크기&quot;에 대한 응답으로 알고리즘의 자원 사용 (시간 또는 메모리 생각) 스케일링 방법에 대한 정보 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7dc156313731adb22242f60a31c42c25a7fac861" translate="yes" xml:space="preserve">
          <source>There is also the concept of &quot;amortized&quot; and/or &quot;average case&quot; (note that these are different).</source>
          <target state="translated">&quot;약탈 된&quot;및 / 또는 &quot;평균 사례&quot;라는 개념도 있습니다 (이것은 다릅니다).</target>
        </trans-unit>
        <trans-unit id="e29aa2b4c76e872003711e1f9ca7f22087d1cd30" translate="yes" xml:space="preserve">
          <source>These are the bread-and-butter orders of growth that programmers and applied computer scientists use as reference points. They see these all the time. (So while you could technically think &quot;Doubling the input makes an O(&amp;radic;N) algorithm 1.414 times slower,&quot; it's better to think of it as &quot;this is worse than logarithmic but better than linear&quot;.)</source>
          <target state="translated">이들은 프로그래머와 응용 컴퓨터 과학자가 참조 점으로 사용하는 빵과 버터의 성장 순서입니다. 그들은 항상 이것을 본다. (기술적으로 &quot;입력을 두 배로하면 O (&amp;radic;N) 알고리즘이 1.414 배 느려진다&quot;고 생각할 수 있지만 &quot;로그보다 나쁘지만 선형보다는 낫다&quot;고 생각하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="337e7f754779241ba422c3ed16228e880e17fea7" translate="yes" xml:space="preserve">
          <source>They gave us a deck of ten cards.  They are all mixed up: seven, four, two, six&amp;hellip; not straight at all.  And now... our job is to sort them.</source>
          <target state="translated">그들은 우리에게 10 장의 카드를주었습니다. 그것들은 모두 섞여 있습니다 : 7, 4, 2, 6&amp;hellip; 전혀 똑바로 아닙니다. 그리고 지금 ... 우리의 임무는 그것들을 정렬하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a4cba2479bcff691f23bf7a823abac5f2bfc677" translate="yes" xml:space="preserve">
          <source>This algorithm search a list, item by item, looking for a key,</source>
          <target state="translated">이 알고리즘은 항목을 목록으로 검색하고 키를 찾고</target>
        </trans-unit>
        <trans-unit id="b5ccab1dbe3c98b30c65b7179a45c56dcba85b06" translate="yes" xml:space="preserve">
          <source>This complexity is the same as &lt;strong&gt;O(1)&lt;/strong&gt; except that it's just a little bit worse.  For all practical purposes, you can consider this as a very large constant scaling.  The difference in work between processing 1 thousand and 1 billion items is only a factor six.</source>
          <target state="translated">이 복잡성은 조금 더 나쁘다는 점을 제외하면 &lt;strong&gt;O (1)&lt;/strong&gt; 과 같습니다. 모든 실제적인 목적을 위해 이것을 매우 큰 상수 스케일링으로 간주 할 수 있습니다. 1,000 개 항목과 10 억 개 항목을 처리하는 작업의 차이는 단지 6 배에 불과합니다.</target>
        </trans-unit>
        <trans-unit id="a8f1f1c12dab816384a465eef99dc533c1871709" translate="yes" xml:space="preserve">
          <source>This complexity is very similar to &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt;.  For all practical purposes, the two are equivalent.  This level of complexity would generally still be considered scalable.  By tweaking assumptions some &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; algorithms can be transformed into &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; algorithms.  For example, bounding the size of keys reduces sorting from &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; to &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt;.</source>
          <target state="translated">이 복잡성은 &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; 과 매우 유사합니다. 모든 실질적인 목적을 위해, 둘은 동등합니다. 이러한 수준의 복잡성은 일반적으로 여전히 확장 가능한 것으로 간주됩니다. 가정을 조정하여 일부 &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; 알고리즘을 &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; 알고리즘으로 변환 할 수 있습니다. 예를 들어, 키 크기를 제한하면 &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; 에서 &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; )으로&lt;/strong&gt; 정렬이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="c5691b3f2dea4e40f3c7e1067faf693cc2b99d29" translate="yes" xml:space="preserve">
          <source>This is O n&lt;sup&gt;2&lt;/sup&gt; because, you need to look at all items in the list there are &quot;n&quot; items. For each item, you look at all items once more, for comparing, this is also &quot;n&quot;, so for every item, you look &quot;n&quot; times meaning n*n = n&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">이것은 목록에 &quot;n&quot;개의 항목이있는 모든 항목을 봐야하기 때문에 O n &lt;sup&gt;2&lt;/sup&gt; 입니다. 각 항목에 대해 모든 항목을 한 번 더보고 비교를 위해이 항목도 &quot;n&quot;이므로 모든 항목에 대해 n * n = n &lt;sup&gt;2를&lt;/sup&gt; 의미하는 &quot;n&quot;번을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="653edd1e3ffbc6849cab3e84f2d2f1adb0553312" translate="yes" xml:space="preserve">
          <source>This is a function of a mathematical operation called a &lt;strong&gt;factorial&lt;/strong&gt;.  Basically:</source>
          <target state="translated">이것은 &lt;strong&gt;factorial&lt;/strong&gt; 이라는 수학적 연산의 함수입니다. 원래:</target>
        </trans-unit>
        <trans-unit id="68bbac89d75f8c9b12a85ecf9405e267e936bef2" translate="yes" xml:space="preserve">
          <source>This is a very simplified explanation, but I hope it covers most important details.</source>
          <target state="translated">이것은 매우 간단한 설명이지만 가장 중요한 세부 사항을 다루기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="690e85c5f1f320cb604423824b8a84e4db475373" translate="yes" xml:space="preserve">
          <source>This is called a &lt;strong&gt;binary search&lt;/strong&gt; and is used every day in programming whether you realize it or not.</source>
          <target state="translated">이를 &lt;strong&gt;이진 검색&lt;/strong&gt; 이라고하며이를 인식하는지 여부에 관계없이 매일 프로그래밍에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="903158538d58a924a96daad121dc96f748e16115" translate="yes" xml:space="preserve">
          <source>This is quite a famous problem in computer science and deserves a mention.  In this problem you have N towns. Each of those towns is linked to 1 or more other towns by a road of a certain distance. The Traveling Salesman problem is to find the shortest tour that visits every town.</source>
          <target state="translated">이것은 컴퓨터 과학에서 매우 유명한 문제이며 언급 할 가치가 있습니다. 이 문제에는 N 개의 도시가 있습니다. 각 도시는 일정 거리의 도로로 1 개 이상의 다른 도시와 연결되어 있습니다. Traveling Salesman 문제는 모든 도시를 방문하는 가장 짧은 여행을 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9d90c6f6b5d97d1a3566515111185bfdbbdad847" translate="yes" xml:space="preserve">
          <source>This is read as T of n is in big O of n.</source>
          <target state="translated">이것은 T의 n이 n의 큰 O에있을 때 읽 힙니다.</target>
        </trans-unit>
        <trans-unit id="581db2374f66d9fecedf4263af206b8b003578d9" translate="yes" xml:space="preserve">
          <source>This lets us make statements like...</source>
          <target state="translated">이를 통해 다음과 같은 진술을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f23f5a057b81398db00b66517d931e311e15ad5" translate="yes" xml:space="preserve">
          <source>This motivates the use of &lt;strong&gt;data structures&lt;/strong&gt;: a data structure requires reading the data only once (usually &lt;code&gt;O(N)&lt;/code&gt; time), plus some arbitrary amount of preprocessing (e.g. &lt;code&gt;O(N)&lt;/code&gt; or &lt;code&gt;O(N log(N))&lt;/code&gt; or &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt;) which we try to keep small. Thereafter, modifying the data structure (insertions/deletions/ etc.) and making queries on the data take very little time, such as &lt;code&gt;O(1)&lt;/code&gt; or &lt;code&gt;O(log(N))&lt;/code&gt;. You then proceed to make a large number of queries! In general, the more work you're willing to do ahead of time, the less work you'll have to do later on.</source>
          <target state="translated">이것은 &lt;strong&gt;데이터 구조&lt;/strong&gt; 의 사용에 동기를 부여합니다. 데이터 구조는 한 번만 (일반적으로 &lt;code&gt;O(N)&lt;/code&gt; 시간) 데이터를 읽고 임의의 양의 전처리 (예 : &lt;code&gt;O(N)&lt;/code&gt; 또는 &lt;code&gt;O(N log(N))&lt;/code&gt; 또는 &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; 우리는 작게 유지하려고합니다. 그런 다음 데이터 구조를 수정하고 (삽입 / 삭제 등) &lt;code&gt;O(1)&lt;/code&gt; 또는 &lt;code&gt;O(log(N))&lt;/code&gt; 과 같이 데이터에 대한 쿼리를 수행하는 데 시간이 거의 걸리지 않습니다. 그런 다음 많은 수의 쿼리를 진행합니다! 일반적으로 미리 할 일이 많을수록 나중에해야 할 일이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="4d08321928b5477592d3f3be8d0fbf595ccedfeb" translate="yes" xml:space="preserve">
          <source>This sort is quite quick.  How quick?  Big O tells us: this sort needs O(n log n) work to be done, in the mean case.</source>
          <target state="translated">이 종류는 매우 빠릅니다. 얼마나 빨리? Big O는 우리에게 알려줍니다.이 종류의 경우 O (n log n) 작업이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="efa77e0837d728c026f108a7c6a880857648e39a" translate="yes" xml:space="preserve">
          <source>This time the number of items increases by a factor of 10, and so does the time. n=10 and so O(n)'s scaling factor is 10.</source>
          <target state="translated">이번에는 항목 수가 10 배 증가하여 시간도 늘어납니다. n = 10이므로 O (n)의 스케일링 계수는 10입니다.</target>
        </trans-unit>
        <trans-unit id="e6a399976506e2d7ce3f3c1d1884c9c4671f0528" translate="yes" xml:space="preserve">
          <source>This type of algorithm is described as O(log N). The iterative halving
  of data sets described in the binary search example produces a growth
  curve that peaks at the beginning and slowly flattens out as the size
  of the data sets increase e.g. an input data set containing 10 items
  takes one second to complete, a data set containing 100 items takes
  two seconds, and a data set containing 1000 items will take three
  seconds. Doubling the size of the input data set has little effect on
  its growth as after a single iteration of the algorithm the data set
  will be halved and therefore on a par with an input data set half the
  size. This makes algorithms like binary search extremely efficient
  when dealing with large data sets.</source>
          <target state="translated">이 유형의 알고리즘은 O (log N)으로 설명됩니다. 이진 검색 예제에 설명 된 데이터 세트의 반복 절반은 데이터 세트의 크기가 증가함에 따라 시작시 최고점에 도달하고 천천히 평평 해지는 성장 곡선을 생성합니다. 예를 들어 10 개의 항목을 포함하는 입력 데이터 세트는 완료하는 데 1 초가 소요됩니다. 100 개의 항목을 포함하는 데 2 ​​초가 걸리고 1000 개의 항목을 포함하는 데이터 세트에는 3 초가 걸립니다. 입력 데이터 세트의 크기를 두 배로 늘리면 알고리즘을 한 번 반복 한 후 데이터 세트가 절반으로 줄어들어 입력 데이터 세트의 크기가 절반으로 줄어듦에 따라 성장에 거의 영향을 미치지 않습니다. 따라서 큰 데이터 세트를 처리 할 때 이진 검색과 같은 알고리즘이 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ff64700b92668ef5d8bf1eab2150e242d95be66f" translate="yes" xml:space="preserve">
          <source>Though, if you're &lt;a href=&quot;https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks&quot;&gt;reasonably worried&lt;/a&gt; about an attacker, there are many other algorithmic attack vectors to worry about besides amortization and average-case.)</source>
          <target state="translated">공격자에 대해 &lt;a href=&quot;https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks&quot;&gt;합리적으로 걱정&lt;/a&gt; 한다면 할부 상환 및 평균 사례 외에도 걱정할 다른 알고리즘 공격 벡터가 많이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="7c6809222de67cf731ce03e2166eb7926bfb38c0" translate="yes" xml:space="preserve">
          <source>Three: I go from the end card up, and I look for a card that is more low than the splay card.</source>
          <target state="translated">셋째 : 엔드 카드에서 위로 올라가 스플레이 카드보다 낮은 카드를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="b5dad2a734641d4c6735ae21c27019cfea0c15e8" translate="yes" xml:space="preserve">
          <source>Time(Best-Case) = 4</source>
          <target state="translated">시간 (최고의 경우) = 4</target>
        </trans-unit>
        <trans-unit id="2f997ae62ba9c69b3cf6edcf0d119e5ddad840f2" translate="yes" xml:space="preserve">
          <source>Time(Worst-Case) = 4n+1</source>
          <target state="translated">시간 (가장 최악의 경우) = 4n + 1</target>
        </trans-unit>
        <trans-unit id="2b30e732d21d07f2640a46e069dde7480df7216e" translate="yes" xml:space="preserve">
          <source>Time: &amp;Omega;(4) = O(1) ~ Instant\Constant</source>
          <target state="translated">시간 : &amp;Omega; (4) = O (1) ~ 즉시 \ 일정</target>
        </trans-unit>
        <trans-unit id="8d4bf6a7efc118b94944a2fdcb4199b6b5436673" translate="yes" xml:space="preserve">
          <source>Time: O(4n+1) = O(n) | in Big-O, constants are neglected</source>
          <target state="translated">시간 : O (4n + 1) = O (n) | Big-O에서는 상수가 무시됩니다</target>
        </trans-unit>
        <trans-unit id="78b1d548645a6f4313e845c0d6995f63dbc656ee" translate="yes" xml:space="preserve">
          <source>To add from one to six, that is some work.  But do you see, to add from one to ten, that is more work?</source>
          <target state="translated">1에서 6까지 추가하려면 약간의 작업이 있습니다. 그러나 1에서 10까지 더하면 더 많은 작업이 보입니까?</target>
        </trans-unit>
        <trans-unit id="2ee6a9060e778ab6f2fbe6d42d7bf3bf75ff7755" translate="yes" xml:space="preserve">
          <source>To me, I think of big O like a big, slow, boss man.  He thinks on work, but he does not do it.  He might say, &quot;That work is quick.&quot;  Or, he might say, &quot;That work is so slow and hard!&quot;  But he does not do the work.  He just looks at the work, and then he tells us how much time it might take.</source>
          <target state="translated">나에게 큰 O는 크고 느리고 보스 같은 사람이라고 생각합니다. 그는 일을 생각하지만하지 않습니다. 그는 &quot;그 일이 빠르다&quot;고 말할 수도 있습니다. 또는 그는 &quot;그 작업은 너무 느리고 힘들다&quot;고 말할 수 있습니다. 그러나 그는 일을하지 않습니다. 그는 단지 그 일을보고 나서 시간이 얼마나 걸릴지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="5580a107c59a84aea6247983205780ae9a93ffac" translate="yes" xml:space="preserve">
          <source>To say that binary search has a running time of O(logn) is to say that there exists some constant c which you can multiply log(n) by that will always be larger than the running time of binary search.  In this case you will always have some constant factor of log(n) comparisons.</source>
          <target state="translated">이진 검색에 O (logn)의 실행 시간이 있다고 말하는 것은 log (n)에 곱할 수있는 상수 c가 있다는 것입니다.이 상수는 항상 이진 검색의 실행 시간보다 큽니다. 이 경우 항상 일정한 log (n) 비교 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4476ee9defb91e4168e19a3dcd129163cca85a4" translate="yes" xml:space="preserve">
          <source>Two: I splay the deck on that card you chose.  What is this splay; how do I splay?  Well, I go from the start card down, one by one, and I look for a card that is more high than the splay card.</source>
          <target state="translated">2 : 선택한 카드에서 덱을 펼칩니다. 이 플레이는 무엇입니까? 어떻게합니까? 글쎄, 나는 시작 카드에서 하나씩 내려 가서 스플레이 카드보다 높은 카드를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="7b569bf8286d4c929a479c4976f45922a580f422" translate="yes" xml:space="preserve">
          <source>Uh oh, more work.  Now, let&amp;rsquo;s not do the work.  But, let&amp;rsquo;s make a plan to do it, step by step.</source>
          <target state="translated">아, 더 많은 일. 이제 일을하지 말자. 그러나 단계별로 계획을 세우십시오.</target>
        </trans-unit>
        <trans-unit id="66ec3cb6bc2e6fcaea19ddeb58c0027ecdebce58" translate="yes" xml:space="preserve">
          <source>Unrelatedly but worth mentioning again: If we perform a hash (e.g. a dictionary/hashtable lookup), that is a factor of O(1). That's pretty fast.</source>
          <target state="translated">관련이 없지만 다시 언급 할 가치가 있습니다. 해시 (예 : 사전 / 해시 테이블 조회)를 수행하는 경우 이는 O (1)의 요소입니다. 꽤 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ceb436949ce49c2aad7d40dd4b74113a2a9f4743" translate="yes" xml:space="preserve">
          <source>Using a tumble dryer: you put 10 shirts in each load, and then they're done an hour later. (Ignore the actual numbers here &amp;mdash; they're irrelevant.) So drying 50 shirts takes &lt;em&gt;about&lt;/em&gt; 5 times as long as drying 10 shirts.</source>
          <target state="translated">회전식 건조기 사용 : 각 적재에 10 개의 셔츠를 넣은 다음 1 시간 후에 완료됩니다. (실제 숫자는 무시하십시오. 관련이 없습니다.) 따라서 50 개의 셔츠를 건조하는 것은 10 개의 셔츠를 건조하는 데 &lt;em&gt;약&lt;/em&gt; 5 배가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="c1627c2d9bf38d1a8bf4e6c4db14ba36e137fed7" translate="yes" xml:space="preserve">
          <source>Using a washing line outside: assuming you have an infinitely large back yard, washing dries in O(1) time. However much you have of it, it'll get the same sun and fresh air, so the size doesn't affect the drying time.</source>
          <target state="translated">외부 세척 라인 사용 : 무한히 큰 뒤뜰이 있다고 가정하면 세척은 O (1) 시간에 건조됩니다. 당신이 그것을 많이 가지고 있지만, 그것은 동일한 태양과 신선한 공기를 얻을 것이므로 크기는 건조 시간에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32fee750e2bced1ef4713977d7422997ac4d01b8" translate="yes" xml:space="preserve">
          <source>Usually, we don't care what the specific constant factors are, because they don't affect the way the function grows. For example, two algorithms may both take &lt;code&gt;O(N)&lt;/code&gt; time to complete, but one may be twice as slow as the other. We usually don't care too much unless the factor is very large since optimizing is tricky business ( &lt;a href=&quot;https://stackoverflow.com/questions/385506/when-is-optimisation-premature&quot;&gt;When is optimisation premature?&lt;/a&gt; ); also the mere act of picking an algorithm with a better big-O will often improve performance by orders of magnitude.</source>
          <target state="translated">일반적으로 특정 상수 요소가 무엇인지는 중요하지 않습니다. 함수가 성장하는 방식에 영향을 미치지 않기 때문입니다. 예를 들어, 두 알고리즘 모두 완료하는 데 &lt;code&gt;O(N)&lt;/code&gt; 시간이 걸리지 만 하나는 다른 것보다 두 배 느릴 수 있습니다. 최적화가 까다로운 사업이기 때문에 요소가 너무 크지 않으면 우리는 일반적으로 너무 신경 쓰지 않습니다 (최적화는 &lt;a href=&quot;https://stackoverflow.com/questions/385506/when-is-optimisation-premature&quot;&gt;언제입니까?&lt;/a&gt; ); 또한 더 큰 big-O로 알고리즘을 선택하는 단순한 행동은 종종 성능을 몇 배나 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="ec6a77a1f38d77785d38e6e7cc1d9af0e804cfa3" translate="yes" xml:space="preserve">
          <source>Very Quick Note:</source>
          <target state="translated">매우 빠른 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="6d21f45bec9f10023aec098341e6f6c03c5b13c1" translate="yes" xml:space="preserve">
          <source>Via examples, this helped get the bare basics into my tortoiseshell-like skull, so I think it's a pretty descent 10-minute read to get you headed in the right direction.</source>
          <target state="translated">예를 들어, 이것은 거북이 기초와 같은 두개골에 대한 기본 사항을 이해하는 데 도움이되었으므로 올바른 방향으로 향하게하는 것은 꽤 10 분 동안 읽은 것으로 생각됩니다.</target>
        </trans-unit>
        <trans-unit id="6aab5f5e334f1c425e8cc5c3149d2485a2ab6b43" translate="yes" xml:space="preserve">
          <source>Wait!  What is n?  Did I miss that?  How can I add from one to n if you don&amp;rsquo;t tell me what n is?</source>
          <target state="translated">기다림! N은 무엇입니까? 내가 그리워 했니? n이 무엇인지 말하지 않으면 어떻게 1에서 n까지 추가 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2f7ade3e8b4a45caea9bbfc55450f4d016746563" translate="yes" xml:space="preserve">
          <source>We are trying to see how the number of input parameters, affects the running time of an algorithm. If the running time of your application is proportional to the number of input parameters, then it is said to be in Big O of n.</source>
          <target state="translated">입력 매개 변수의 수가 알고리즘의 실행 시간에 어떤 영향을 미치는지 확인하려고합니다. 응용 프로그램의 실행 시간이 입력 매개 변수의 수에 비례하면 n의 Big O라고합니다.</target>
        </trans-unit>
        <trans-unit id="d3658b52f527a76c6421772c73ea4511ef27a0b9" translate="yes" xml:space="preserve">
          <source>We can just rearrange this and see it's O(N):</source>
          <target state="translated">우리는 이것을 재정렬하고 O (N)을 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a081699494ed4f022754488ece9b2b843bf6728d" translate="yes" xml:space="preserve">
          <source>Well actually there's less than that because some of these are equivalent (A &amp;rarr; B &amp;rarr; C and C &amp;rarr; B &amp;rarr; A are equivalent, for example, because they use the same roads, just in reverse).</source>
          <target state="translated">실제로는 그보다 작습니다.이 중 일부는 동일하기 때문에 (A &amp;rarr; B &amp;rarr; C 및 C &amp;rarr; B &amp;rarr; A는 예를 들어 동일한 도로를 반대로 사용하기 때문에 동일합니다).</target>
        </trans-unit>
        <trans-unit id="f33910e9a426fbc1a12d1f88603bfdd1d8ca337f" translate="yes" xml:space="preserve">
          <source>Well, I don&amp;rsquo;t know what n is.  I was not told.  Were you?  No?   Oh well.  So we can&amp;rsquo;t do the work.  Whew.</source>
          <target state="translated">글쎄, 나는 n이 무엇인지 모른다. 나는 들리지 않았다. 당신은? 아니? 오 잘 그래서 우리는 일을 할 수 없습니다. 아휴.</target>
        </trans-unit>
        <trans-unit id="4b2089e7aacf0c6fcb7cbbe9c09999beabffc5dd" translate="yes" xml:space="preserve">
          <source>Well, I guess I would have to do ten adds&amp;hellip; one for each thing from one to ten.  Ten is more than six.  I would have to work that much more to add from one to ten, than one to six!</source>
          <target state="translated">글쎄, 나는 10 개의 추가를해야한다고 생각한다. 열은 여섯 이상입니다. 나는 1에서 6보다 1에서 10까지 더 많이 추가해야합니다!</target>
        </trans-unit>
        <trans-unit id="448ecbc620762a34ee90c323b9d2af296de94e73" translate="yes" xml:space="preserve">
          <source>Well, I will not do the work to add them now.  But I know how hard it would be.  It would be six adds.</source>
          <target state="translated">글쎄, 나는 지금 그들을 추가하기 위해 노력하지 않을 것입니다. 그러나 나는 그것이 얼마나 어려울 지 안다. 6이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e6092f44041d9afec7369ff2f52755377d43518f" translate="yes" xml:space="preserve">
          <source>Well, how much work would that be, to sort the cards with those rules?</source>
          <target state="translated">글쎄, 그 규칙에 따라 카드를 정렬하는 것이 얼마나 많은 일입니까?</target>
        </trans-unit>
        <trans-unit id="3a69be1de24839373d5d994ccbcc98a836e1d23b" translate="yes" xml:space="preserve">
          <source>Well, if n gets real big, we do not care what we might add to n or n squared.</source>
          <target state="translated">음, n이 실제로 커지면 n 또는 n 제곱에 추가 할 수있는 것을 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d9059fb09bbdcd3a55d09451a9fcb425e83ec53" translate="yes" xml:space="preserve">
          <source>Well, let&amp;rsquo;s see.  I must add one and two, and then add that to three, and then add that to four&amp;hellip; All in all, I count six adds.  I have to do six adds to solve this.</source>
          <target state="translated">음 .. 어디 한번 보자. 1과 2를 더한 다음 3에 더한 다음 4에 더해야합니다. 전체적으로 6 개의 추가를 계산합니다. 이 문제를 해결하려면 6 가지를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="329e7c685300ef2d2b4c47c92157c7ce7ca7c71a" translate="yes" xml:space="preserve">
          <source>Well, what's so wonderful about Big O notation if that's what it does?</source>
          <target state="translated">그렇다면 Big O 표기법이 그렇게 훌륭한 점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="27f2ea453fa647e6745114288459cdbdc09377db" translate="yes" xml:space="preserve">
          <source>Well, you know n squared is n times n.  Now, I get it: n cards checked, up to what might be n times through the deck.  That is two loops, each with n steps.  That is n squared much work to be done.  A lot of work, for sure!</source>
          <target state="translated">음, n 제곱은 n 곱하기 n입니다. 이제, 나는 그것을 얻는다 : n 개의 카드가 점검되었고, 덱을 통해 n 번까지있을 수있는 것. 그것은 각각 n 단계를 가진 두 개의 루프입니다. 그것은해야 할 일의 제곱입니다. 많은 작업, 확실히!</target>
        </trans-unit>
        <trans-unit id="f37e46082d9d7fea2de0995ec35f0ebec2aa85b9" translate="yes" xml:space="preserve">
          <source>What if I order several Blu-ray movies like The Lord of the Rings, Twilight, The Dark Knight Trilogy, etc. and download all the movies online at the same time? This time, the delivery still take a day to complete, but the online download takes 3 days to finish.
For online shopping, the number of purchased item (input) doesn&amp;rsquo;t affect the delivery time. The output is constant. We call this &lt;strong&gt;O(1)&lt;/strong&gt;.</source>
          <target state="translated">반지의 제왕, 트와 일 라잇, 다크 나이트 트릴로지 등과 같은 여러 블루 레이 영화를 주문하고 동시에 모든 영화를 온라인으로 다운로드하면 어떻게됩니까? 이번에는 배송이 완료 되려면 하루가 걸리지 만 온라인 다운로드는 완료하는 데 3 일이 걸립니다. 온라인 쇼핑의 경우 구매 한 항목 수 (입력)는 배달 시간에 영향을 미치지 않습니다. 출력은 일정합니다. 우리는 이것을 &lt;strong&gt;O (1)&lt;/strong&gt; 이라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="7ae3452404f7d023c914234c52fa39dc716c5a20" translate="yes" xml:space="preserve">
          <source>What if you have a phone number and want to find a name?  The police have a reverse phone book but such look-ups are denied to the general public.  Or are they?  Technically you can reverse look-up a number in an ordinary phone book.  How?</source>
          <target state="translated">전화 번호가 있고 이름을 찾으려면 어떻게합니까? 경찰은 전화 번호부를 역으로 가지고 있지만, 그러한 조회는 일반인에게 거부됩니다. 아니면 그들입니까? 기술적으로 일반 전화 번호부에서 번호 조회를 반대로 할 수 있습니다. 어떻게?</target>
        </trans-unit>
        <trans-unit id="373e1d2a10f1cbeda45147e21f05a41927cb80df" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of &amp;ldquo;Big O&amp;rdquo; notation?</source>
          <target state="translated">&quot;Big O&quot;표기법에 대한 일반적인 영어 설명은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="05e7612ca7f7ef6fa7a4103f167b120617cb813f" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of Big O? With as little formal definition as possible and simple mathematics.</source>
          <target state="translated">Big O에 대한 평범한 영어 설명은 무엇입니까? 가능한 한 공식적인 정의가 적고 간단한 수학.</target>
        </trans-unit>
        <trans-unit id="f89a18eb1e0fc978c591793d435b46bfc0826855" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of “Big O” notation</source>
          <target state="translated">&quot;Big O&quot;표기법에 대한 평범한 영어 설명은 무엇입니까</target>
        </trans-unit>
        <trans-unit id="2cc611dba256f3aa30150ddcf404bfb6a56af65d" translate="yes" xml:space="preserve">
          <source>What is this sort called?  It is called Quick Sort!  That sort was made by a man called &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;C. A. R. Hoare&lt;/a&gt; and he called it Quick Sort.  Now, Quick Sort gets used all the time!</source>
          <target state="translated">이 종류는 무엇입니까? 퀵 정렬이라고합니다! 그 종류는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;CAR Hoare&lt;/a&gt; 라는 사람에 의해 만들어졌으며 그는 그것을 Quick Sort라고 불렀습니다. 이제 빠른 정렬이 항상 사용됩니다!</target>
        </trans-unit>
        <trans-unit id="bf023f1a273e5e8e203698a520653800da906866" translate="yes" xml:space="preserve">
          <source>When interested in doing computations whose size is &quot;large&quot; enough to be considered as approximately infinity, then big O notation is approximately the cost of solving your problem.</source>
          <target state="translated">크기가 &quot;무거운&quot;크기의 계산을 수행하여 대략 무한대로 간주되는 경우 큰 O 표기법은 대략 문제를 해결하는 비용입니다.</target>
        </trans-unit>
        <trans-unit id="adc3d5b71af09ac58be8764be77408df12df041d" translate="yes" xml:space="preserve">
          <source>When the deck is done, I ask: did I swap cards in that pass?  If so, I must do it all once more, from the top.</source>
          <target state="translated">덱이 완료되면 묻습니다. 해당 패스에서 카드를 교환 했습니까? 그렇다면 맨 위에서 다시 한 번 더해야합니다.</target>
        </trans-unit>
        <trans-unit id="9028c7b55a2b4ecb9c2a82958fa89f7a7fc1daa5" translate="yes" xml:space="preserve">
          <source>When we program, we are trying to solve a problem. What we code is called an algorithm. Big O notation allows us to compare the worse case performance of our algorithms in a standardized way. Hardware specs vary over time and improvements in hardware can reduce the time it takes an algorithms to run. But replacing the hardware does not mean our algorithm is any better or improved over time, as our algorithm is still the same. So in order to allow us to compare different algorithms, to determine if one is better or not, we use Big O notation.</source>
          <target state="translated">프로그래밍 할 때 문제를 해결하려고합니다. 우리가 코딩하는 것을 알고리즘이라고합니다. Big O 표기법을 사용하면 알고리즘의 최악의 성능을 표준화 된 방식으로 비교할 수 있습니다. 하드웨어 사양은 시간이 지남에 따라 다르며 하드웨어를 개선하면 알고리즘 실행 시간을 줄일 수 있습니다. 그러나 하드웨어를 교체한다고해서 알고리즘이 여전히 동일하기 때문에 시간이 지남에 따라 알고리즘이 더 좋아 지거나 향상되지는 않습니다. 따라서 다른 알고리즘을 비교하고 더 나은지 아닌지를 결정하기 위해 Big O 표기법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="54c2c9229bcd771be7710eabeb971bc3f8e0eb85" translate="yes" xml:space="preserve">
          <source>When we say some algorithm is O(f(n)) we are saying that the running time (or space required) by that algorithm is always lower than some constant times f(n).</source>
          <target state="translated">우리가 어떤 알고리즘이 O (f (n))라고 말할 때, 우리는 그 알고리즘에 의해 실행 시간 (또는 필요한 공간)이 항상 일정한 시간 f (n)보다 낮다는 것을 말하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d1cb020f38d2820c9eec88a25e1be3ef2a6c892" translate="yes" xml:space="preserve">
          <source>Why do I choose Quick Sort?  I do not like to work, of course!  I want work done as soon as I can get it done.</source>
          <target state="translated">빠른 정렬을 선택하는 이유는 무엇입니까? 물론 일하는 것을 좋아하지 않습니다! 할 수있는대로 빨리 일을하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="ccaa8eba13667623c9638dcc1af96e87d1ce8695" translate="yes" xml:space="preserve">
          <source>Why does he say n squared?</source>
          <target state="translated">그는 왜 n 제곱이라고 말합니까?</target>
        </trans-unit>
        <trans-unit id="ed876af93299c7d2e7470f312b49d7963f03e745" translate="yes" xml:space="preserve">
          <source>Why is this so important? Because software deals with problems that may differ in size by factors up to a trillion. Consider that for a moment. The ratio between the speed necessary to travel to the Moon and human walking speed is less than 10,000:1, and that is absolutely tiny compared to the range in input sizes software may face. And because software may face an astronomical range in input sizes there is the potential for the Big O complexity of an algorithm, it's fundamental scaling nature, to trump any implementation details.</source>
          <target state="translated">이것이 왜 중요한가? 소프트웨어는 최대 1 조 개의 요인으로 크기가 다를 수있는 문제를 처리하기 때문입니다. 잠시 생각해보십시오. 달로 이동하는 데 필요한 속도와 사람의 보행 속도 사이의 비율은 10,000 : 1 미만이며 소프트웨어가 직면 할 수있는 입력 크기 범위에 비해 절대적으로 작습니다. 소프트웨어가 입력 크기에서 천문학적 범위에 직면 할 수 있기 때문에 알고리즘의 Big O 복잡성에 대한 가능성이 있으며, 기본 확장 성으로 인해 구현 세부 사항을 능가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a693d58d361e39c4c6dfbf09d0fc6a088f14c901" translate="yes" xml:space="preserve">
          <source>Why would you want to ignore the smaller parts of the equation? Because they become completely dwarfed by the big parts of the equation as you consider larger and larger scales; their contribution becomes dwarfed and irrelevant. (See example section.)</source>
          <target state="translated">왜 방정식의 작은 부분을 무시하고 싶습니까? 더 큰 스케일을 고려할 때 방정식의 큰 부분으로 인해 왜소하게 왜곡되기 때문입니다. 그들의 기여는 왜소하고 무관심해진다. (예제 섹션 참조)</target>
        </trans-unit>
        <trans-unit id="b03cf50f7e5382fcef1451bd7a03322e40c6839f" translate="yes" xml:space="preserve">
          <source>With 5 it's 60.</source>
          <target state="translated">5로 60입니다.</target>
        </trans-unit>
        <trans-unit id="19778bc5e290319ee50f4c5296b015273dc9262c" translate="yes" xml:space="preserve">
          <source>Worst-Case: the key doesn't exist in the list.</source>
          <target state="translated">최악의 경우 : 키가 목록에 없습니다.</target>
        </trans-unit>
        <trans-unit id="5fabd786be014d83764164facee56b049790e363" translate="yes" xml:space="preserve">
          <source>Wow, I hate work.  But oh well, I have to do this.  So here I go.</source>
          <target state="translated">와우, 나는 일이 싫어. 그러나 오, 나는 이것을해야합니다. 그래서 여기 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c8c4cd8f5043686e05d837663d4022a92d73016" translate="yes" xml:space="preserve">
          <source>Yes, there is a more fast way!  It takes some time to learn, but it works... and it works quite fast.  You can try it too, but take your time with each step and do not lose your place.</source>
          <target state="translated">더 빠른 방법이 있습니다! 배우는 데 약간의 시간이 걸리지 만 작동합니다 ... 아주 빠르게 작동합니다. 당신도 시도해 볼 수 있지만, 각 단계마다 시간을내어 자리를 잃지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cfe414e40bd3874b327354ff113f428d54d21253" translate="yes" xml:space="preserve">
          <source>You could refer to Big-&amp;Omega; (Big-Omega) for best case.</source>
          <target state="translated">최상의 경우 Big-&amp;Omega; (Big-Omega)을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bfc8ee77cbab3d00050185496cbe7e412b4bf8a" translate="yes" xml:space="preserve">
          <source>You drive a car. Occasionally, you need to spend 10 minutes going to
  the gas station and then spend 1 minute refilling the tank with gas.
  If you did this every time you went anywhere with your car (spend 10
  minutes driving to the gas station, spend a few seconds filling up a
  fraction of a gallon), it would be very inefficient. But if you fill
  up the tank once every few days, the 11 minutes spent driving to the
  gas station is &quot;amortized&quot; over a sufficiently large number of trips,
  that you can ignore it and pretend all your trips were maybe 5% longer.</source>
          <target state="translated">당신은 차를 운전합니다. 때때로, 주유소로가는 데 10 분을 소비 한 다음 탱크에 가스를 채우는 데 1 분을 소비해야합니다. 당신이 당신의 차와 함께 어디든지 갈 때마다 (주유소까지 운전 10 분을 보내고, 몇 갤런을 채우는 데 몇 초를 소비한다면)이 작업을 수행하면 매우 비효율적입니다. 그러나 며칠에 한 번씩 탱크를 채우면 주유소로 운전하는 데 소요 된 11 분이 충분히 많은 횟수의 여행으로 &quot;완성&quot;되어 무시할 수 있고 모든 여행이 5 % 더 길다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c6bcba6f752f5cfdc961fb84683b404f55a2f21" translate="yes" xml:space="preserve">
          <source>You learned all that with me!  You are so smart!  Thank you so much!</source>
          <target state="translated">당신은 나와 함께 모든 것을 배웠습니다! 당신은 너무 똑똑합니다! 정말 고맙습니다!</target>
        </trans-unit>
        <trans-unit id="e8fd35a375e8ec51f2b6feca80545b2feec31781" translate="yes" xml:space="preserve">
          <source>You may often see O(n), O(n&lt;sup&gt;2&lt;/sup&gt;), O(nlogn) and so forth, all these are just ways to show; How does an algorithm change?</source>
          <target state="translated">당신은 종종 O (n), O (n &lt;sup&gt;2&lt;/sup&gt; ), O (nlogn) 등을 볼 수 있습니다. 알고리즘은 어떻게 변경됩니까?</target>
        </trans-unit>
        <trans-unit id="f0c088b8e94d146df79970184c217c58b7b97083" translate="yes" xml:space="preserve">
          <source>You start at the first name and compare the number.  If it's a match, great, if not, you move on to the next.  You have to do it this way because the phone book is &lt;strong&gt;unordered&lt;/strong&gt; (by phone number anyway).</source>
          <target state="translated">이름에서 시작하여 숫자를 비교하십시오. 일치하는 경우, 그렇지 않으면 다음으로 넘어갑니다. 전화 번호부가 &lt;strong&gt;순서&lt;/strong&gt; 가 맞지 않기 때문에 (전화 번호로)이 방법을 &lt;strong&gt;사용해야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4784b5173ab05221f2b6abc84330bf0f13d31a7c" translate="yes" xml:space="preserve">
          <source>You want to know all there is to know of big O?  So do I.</source>
          <target state="translated">큰 O에 대해 알아야 할 모든 것을 알고 싶습니까? 나도 그래.</target>
        </trans-unit>
        <trans-unit id="648ba0204f36666cba11a8e63d6db611dae8658b" translate="yes" xml:space="preserve">
          <source>[1]: There is a way to cheat and add all the things from one to n, all at one time.  Some kid named Gauss found this out when he was eight.  I am not that smart though, so &lt;a href=&quot;http://nzmaths.co.nz/gauss-trick-staff-seminar&quot;&gt;don't ask me how he did it&lt;/a&gt;.</source>
          <target state="translated">[1] : 한 번에 하나의 모든 것을 속이고 추가하는 방법이 있습니다. Gauss라는 일부 어린이는 8 살 때 이것을 알아 냈습니다. 나는 그렇게 똑똑 &lt;a href=&quot;http://nzmaths.co.nz/gauss-trick-staff-seminar&quot;&gt;하지 않다.&lt;/a&gt; 그래서 그가 어떻게했는지 묻지 마라 .</target>
        </trans-unit>
        <trans-unit id="4229c03c35f915409c958fce305574599037d757" translate="yes" xml:space="preserve">
          <source>[for the mathematically inclined, you can mouse over the spoilers for minor sidenotes]</source>
          <target state="translated">[수학적으로 기울어 진 경우 작은 스포일러 위로 마우스를 움직일 수 있습니다]</target>
        </trans-unit>
        <trans-unit id="320f1d7c3f87e62df035bd8c3fff9fceb851f278" translate="yes" xml:space="preserve">
          <source>addition;</source>
          <target state="translated">addition;</target>
        </trans-unit>
        <trans-unit id="cc72a00bf5f82a31e19586f8d5648eeb9609f807" translate="yes" xml:space="preserve">
          <source>and so on.</source>
          <target state="translated">등등.</target>
        </trans-unit>
        <trans-unit id="41f2ef38a3521fb432c176bb3d6eec433f0e7d29" translate="yes" xml:space="preserve">
          <source>big-O notation doesn't care about constant factors: the function &lt;code&gt;9x&amp;sup2;&lt;/code&gt; is said to &quot;grow exactly like&quot; &lt;code&gt;10x&amp;sup2;&lt;/code&gt;. Neither does big-O &lt;em&gt;asymptotic&lt;/em&gt; notation care about &lt;em&gt;non-asymptotic&lt;/em&gt; stuff (&quot;stuff near the origin&quot; or &quot;what happens when the problem size is small&quot;): the function &lt;code&gt;10x&amp;sup2;&lt;/code&gt; is said to &quot;grow exactly like&quot; &lt;code&gt;10x&amp;sup2; - x + 2&lt;/code&gt;.</source>
          <target state="translated">big-O 표기법은 상수 요소에 신경 쓰지 않습니다. &lt;code&gt;9x&amp;sup2;&lt;/code&gt; 함수는 10x&amp;sup2; &quot;정확하게 성장&quot; &lt;code&gt;10x&amp;sup2;&lt;/code&gt; 합니다. big-O &lt;em&gt;asymptotic&lt;/em&gt; 표기법은 &lt;em&gt;비 점근 적&lt;/em&gt; 물건 ( &quot;원점 근처의 물건&quot;또는 &quot;문제 크기가 작을 때 발생하는 일&quot;)에 &lt;code&gt;10x&amp;sup2; - x + 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fed40854ecbd633619a5d431600a671eeed9292" translate="yes" xml:space="preserve">
          <source>c= a constant</source>
          <target state="translated">c = 상수</target>
        </trans-unit>
        <trans-unit id="e923389b125ffc7cdb2e423a899d4348e7439235" translate="yes" xml:space="preserve">
          <source>division.</source>
          <target state="translated">division.</target>
        </trans-unit>
        <trans-unit id="714de604846fa9d95f2b9fc4aaa27f67caadafd4" translate="yes" xml:space="preserve">
          <source>e.g. for x=1million, ratio #handshakes/x&amp;sup2;: 0.499999...</source>
          <target state="translated">예 : x = 1 백만, 비율 # handshakes / x&amp;sup2; : 0.499999 ...</target>
        </trans-unit>
        <trans-unit id="f42454a2adeb8a0c26a29f629c55ab5dda69a64d" translate="yes" xml:space="preserve">
          <source>f(n)= An approximate function that expresses the running time of the algorithm as a function of n</source>
          <target state="translated">f (n) = 알고리즘의 실행 시간을 n의 함수로 표현하는 근사 함수</target>
        </trans-unit>
        <trans-unit id="6b7dffac98fa2e9f18d9b09123953c56c601da05" translate="yes" xml:space="preserve">
          <source>how heat output scales on CPU dies as a function of transistor count, voltage, etc.</source>
          <target state="translated">트랜지스터 카운트, 전압 등의 함수로 CPU에서 열 출력 스케일링이 어떻게 감소하는지</target>
        </trans-unit>
        <trans-unit id="077a4887c6602aedfb17f44dd051822aa960da2d" translate="yes" xml:space="preserve">
          <source>how much space an algorithm needs to run, as a function of input size</source>
          <target state="translated">입력 크기의 함수로 알고리즘을 실행해야하는 공간</target>
        </trans-unit>
        <trans-unit id="4d80174ea25f9828dcb069496071916d7c70255b" translate="yes" xml:space="preserve">
          <source>how much time an algorithm needs to run, as a function of input size</source>
          <target state="translated">입력 크기의 함수로 알고리즘을 실행해야하는 시간</target>
        </trans-unit>
        <trans-unit id="f2dbea261a6334b636fcb8245379760585160604" translate="yes" xml:space="preserve">
          <source>how website latency scales with the number of processing units in a CPU or GPU or computer cluster</source>
          <target state="translated">웹 사이트 대기 시간이 CPU 또는 GPU 또는 컴퓨터 클러스터의 처리 장치 수에 따라 확장되는 방법</target>
        </trans-unit>
        <trans-unit id="5aa429e0444abdc08467c70c26cbff2d88e2345a" translate="yes" xml:space="preserve">
          <source>it's less than O(N&lt;sup&gt;1.000001&lt;/sup&gt;), which you might be willing to call basically linear</source>
          <target state="translated">O (N &lt;sup&gt;1.000001&lt;/sup&gt; )보다 작습니다. 기본적으로 선형이라고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e97d6456227b5a58913c9ed733df644f1e01e91" translate="yes" xml:space="preserve">
          <source>k is bounded in some neighborhood of a (if a = +&amp;infin;, this means that there are numbers N and M such that for every x &amp;gt; N, |&lt;em&gt;k&lt;/em&gt;(x)| &amp;lt; M).</source>
          <target state="translated">k는 (a = + &amp;infin; 인 경우 모든 x&amp;gt; N, | &lt;em&gt;k&lt;/em&gt; (x) | &amp;lt;M과 같이 숫자 N과 M이 있음을 의미)에 경계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6005c391c2f680a2452cd2577c2564dbcef8e9c9" translate="yes" xml:space="preserve">
          <source>ln(x) = o(x) = O(x) when x &amp;rarr; +&amp;infin;.</source>
          <target state="translated">x &amp;rarr; + &amp;infin; 인 경우 ln (x) = o (x) = O (x)입니다.</target>
        </trans-unit>
        <trans-unit id="273b9bcfed53ba997f70f8aa75c36bda6fde8958" translate="yes" xml:space="preserve">
          <source>multiplication; and</source>
          <target state="translated">곱셈; 과</target>
        </trans-unit>
        <trans-unit id="a4393b9a14bdfd4f4c0eeaaf31bad2e0b9cfef0d" translate="yes" xml:space="preserve">
          <source>n=number of input parameters</source>
          <target state="translated">n = 입력 매개 변수 수</target>
        </trans-unit>
        <trans-unit id="463f52bc275366887f835ed5e5f95c1fe198e8af" translate="yes" xml:space="preserve">
          <source>or address it formally, &quot;Big O&quot; classifies the algorithms and standardize the comparison process.</source>
          <target state="translated">&quot;Big O&quot;는 알고리즘을 분류하고 비교 프로세스를 표준화합니다.</target>
        </trans-unit>
        <trans-unit id="27c0dba7b6e5e26123d57265908dfa7204907ffd" translate="yes" xml:space="preserve">
          <source>probabilistic expected number of people who have seen some viral marketing as a function of time</source>
          <target state="translated">바이러스 성 마케팅을 시간의 함수로 본 확률 론적 예상 인원</target>
        </trans-unit>
        <trans-unit id="0c2b90eddd63a783f5f290989f744b1bf85f87bd" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15,20,25}  ==&amp;gt; problem-instance-size = 5 iterations-in-loop = 5</source>
          <target state="translated">문제 인스턴스 = {5,10,15,20,25} ==&amp;gt; 문제 인스턴스 크기 = 5 루프 내 반복 = 5</target>
        </trans-unit>
        <trans-unit id="e4b7c82dda906533e8c2824c6df8639b2a23a367" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15,20,25}  ==&amp;gt; problem-instance-size = 5, total-iterations= 5*5 =25</source>
          <target state="translated">problem-instance = {5,10,15,20,25} ==&amp;gt; problem-instance-size = 5, 총 반복 횟수 = 5 * 5 = 25</target>
        </trans-unit>
        <trans-unit id="7b9571101e4cfebe964dd712258a749bb36005e9" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15}  ==&amp;gt; problem-instance-size = 3, iterations-in-loop= 3</source>
          <target state="translated">problem-instance = {5,10,15} ==&amp;gt; problem-instance-size = 3, 루프 내 반복 = 3</target>
        </trans-unit>
        <trans-unit id="41a7ac7c629f59f13ed8b74173f006eb424e46ac" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15}  ==&amp;gt; problem-instance-size = 3, total-iterations = 3*3 = 9</source>
          <target state="translated">problem-instance = {5,10,15} ==&amp;gt; problem-instance-size = 3, 총 반복 = 3 * 3 = 9</target>
        </trans-unit>
        <trans-unit id="6adf164f31eaa024e8cd62ab3a7db4601ada676a" translate="yes" xml:space="preserve">
          <source>sin x = O(1) when x &amp;rarr; +&amp;infin;,</source>
          <target state="translated">x &amp;rarr; + &amp;infin; 인 경우 sin x = O (1)</target>
        </trans-unit>
        <trans-unit id="01a98a9d29b98d64c9b325ce600cfccdddb4209c" translate="yes" xml:space="preserve">
          <source>sin x = O(x) when x &amp;rarr; 0.</source>
          <target state="translated">x &amp;rarr; 0 일 때 sin x = O (x).</target>
        </trans-unit>
        <trans-unit id="0f7b476dccef1271c4d6a97311ca082c68f64f7e" translate="yes" xml:space="preserve">
          <source>so you could get its idea literally that it's used to order something to  compare them.</source>
          <target state="translated">문자 그대로 그것들을 비교하기 위해 무언가를 주문하는 데 사용된다는 아이디어를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2411b10604909e08dc5dd9f0ef7bed5327f33858" translate="yes" xml:space="preserve">
          <source>subtraction;</source>
          <target state="translated">subtraction;</target>
        </trans-unit>
        <trans-unit id="1dfbbc899d7564b2c25e7c8e5668555967ef21c9" translate="yes" xml:space="preserve">
          <source>the number of possible handshakes among &lt;code&gt;N&lt;/code&gt; people at a party (&lt;code&gt;Ɵ(N&amp;sup2;)&lt;/code&gt;, specifically &lt;code&gt;N(N-1)/2&lt;/code&gt;, but what matters is that it &quot;scales like&quot; &lt;code&gt;N&amp;sup2;&lt;/code&gt;)</source>
          <target state="translated">파티에서 &lt;code&gt;N&lt;/code&gt; 명의 사람들 사이에 가능한 핸드 셰이크 수 ( &lt;code&gt;Ɵ(N&amp;sup2;)&lt;/code&gt; , 특히 &lt;code&gt;N(N-1)/2&lt;/code&gt; 이지만 중요한 것은 &lt;code&gt;N&amp;sup2;&lt;/code&gt; 와 같이 &quot;확장&quot; 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a673eb6514c9181588ced3c270df39095e5c61da" translate="yes" xml:space="preserve">
          <source>x&lt;sup&gt;2&lt;/sup&gt; + x = O(x) when x &amp;rarr; 0,</source>
          <target state="translated">x &amp;rarr; 0 일 때 x &lt;sup&gt;2&lt;/sup&gt; + x = O (x)</target>
        </trans-unit>
        <trans-unit id="4588b59a6bc0b7081d698604a73689ff94c6669e" translate="yes" xml:space="preserve">
          <source>x&lt;sup&gt;2&lt;/sup&gt; + x = O(x&lt;sup&gt;2&lt;/sup&gt;) when x &amp;rarr; +&amp;infin;,</source>
          <target state="translated">x &amp;rarr; + &amp;infin; 일 때 x &lt;sup&gt;2&lt;/sup&gt; + x = O (x &lt;sup&gt;2&lt;/sup&gt; ),</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
