<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/487258">
    <body>
      <group id="487258">
        <trans-unit id="df498b6e1ddfb06035cc2f060b77dcae692ec7ef" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;What is a plain English explanation of Big O? With as little formal
  definition as possible and simple mathematics.&lt;/em&gt;&quot;</source>
          <target state="translated">&amp;ldquo; &lt;em&gt;Big O的简单英语解释是什么？用尽可能少的正式定义和简单的数学方法。&lt;/em&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="743ffd5e6c073307e39f8ab64f2a620592932e7f" translate="yes" xml:space="preserve">
          <source>&quot;Big O&quot; describes the algorithm's performance and evaluates it.</source>
          <target state="translated">&quot;大O &quot;描述算法的性能,并对其进行评价。</target>
        </trans-unit>
        <trans-unit id="b462328e08f4909b285edec4ff0990d6976efaea" translate="yes" xml:space="preserve">
          <source>&quot;Big O' achieves the above two with standardized &lt;code&gt;Notations&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; Big O'以标准化的 &lt;code&gt;Notations&lt;/code&gt; 实现了上述两个目标。</target>
        </trans-unit>
        <trans-unit id="13f9f8a3d4d7d94edeaf3b7b38263362fa788e6a" translate="yes" xml:space="preserve">
          <source>&quot;For large enough inputsize=N, no matter what the constant factor is, if I &lt;strong&gt;&lt;em&gt;double&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; the input size&lt;/em&gt;...</source>
          <target state="translated">&amp;ldquo;对于足够大的inputsize = N，无论常数因子是多少，如果我&lt;em&gt;将输入大小&lt;/em&gt; &lt;strong&gt;&lt;em&gt;加倍&lt;/em&gt;&lt;/strong&gt; ...</target>
        </trans-unit>
        <trans-unit id="839e4a2006b278a93c4dc0f1936567078302c3f3" translate="yes" xml:space="preserve">
          <source>&amp;hellip;</source>
          <target state="translated">&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="12f5efd72c115a3dfdb9aef75a93d8f6398d2f03" translate="yes" xml:space="preserve">
          <source>( *in a wonderful, &lt;em&gt;unit-free&lt;/em&gt; sense of time!)</source>
          <target state="translated">（*在无&lt;em&gt;单位&lt;/em&gt;的美好时光中！）</target>
        </trans-unit>
        <trans-unit id="5f85db481a01c4c068358bc082055af7e5738d77" translate="yes" xml:space="preserve">
          <source>(**which is what matters, because people will &lt;a href=&quot;http://www.youtube.com/watch?v=OnA3C9Af_oc&quot;&gt;&lt;em&gt;always&lt;/em&gt; want more&lt;/a&gt;, whether they live today or tomorrow)</source>
          <target state="translated">（**这很重要，因为无论今天还是明天，人们&lt;a href=&quot;http://www.youtube.com/watch?v=OnA3C9Af_oc&quot;&gt;&lt;em&gt;总是&lt;/em&gt;想要更多&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="111ed31dcbac4c6bfe6846c61c61ca1b11df6d01" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;edit&lt;/em&gt;: The &quot;plain English&quot; explanation ends here.)</source>
          <target state="translated">（ &lt;em&gt;编辑&lt;/em&gt; ：&amp;ldquo;普通英语&amp;rdquo;的解释到此结束。）</target>
        </trans-unit>
        <trans-unit id="6ce684a7aaa9d4a76848668e020344c53ae2b9ae" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;https://stackoverflow.com/q/7333376/711085&quot;&gt;Difference between average case and amortized analysis&lt;/a&gt; if interested in this subtopic.)</source>
          <target state="translated">（如果对此子主题感兴趣，请参阅&lt;a href=&quot;https://stackoverflow.com/q/7333376/711085&quot;&gt;平均案例与摊销分析之间的差异&lt;/a&gt; 。）</target>
        </trans-unit>
        <trans-unit id="acf9d80cf9dbb5bb7520ab6662ebded396c6f175" translate="yes" xml:space="preserve">
          <source>(here, the &lt;code&gt;x&lt;/code&gt;s represent constant-time units of work, processor instructions, interpreter opcodes, whatever)</source>
          <target state="translated">（此处， &lt;code&gt;x&lt;/code&gt; 代表工作的恒定时间单位，处理器指令，解释器操作码等）</target>
        </trans-unit>
        <trans-unit id="e095c7e86ea34ae9aa5df712384da64165e0768e" translate="yes" xml:space="preserve">
          <source>(technically the constant factor could maybe matter in some more esoteric examples, but I've phrased things above (e.g. in log(N)) such that it doesn't)</source>
          <target state="translated">(从技术上讲,常数因素也许在一些更深奥的例子中可能会很重要,但我在上面的措辞(例如,用log(N)表示),所以它不重要)</target>
        </trans-unit>
        <trans-unit id="06d7bf9932a7f33791291e583cc05892187c54d8" translate="yes" xml:space="preserve">
          <source>(temporary digression from &quot;plain English&quot;:) If you wanted to prove this to yourself, you could perform some simple algebra on the ratio to split it up into multiple terms (&lt;code&gt;lim&lt;/code&gt; means &quot;considered in the limit of&quot;, just ignore it if you haven't seen it, it's just notation for &quot;and N is really really big&quot;):</source>
          <target state="translated">（暂时偏离&amp;ldquo;普通英语&amp;rdquo; ：）如果您想向自己证明这一点，则可以对比率进行一些简单的代数运算，以将其分解为多个项（ &lt;code&gt;lim&lt;/code&gt; 表示&amp;ldquo;考虑为...的极限&amp;rdquo;，如果您还没有看到它，只是&amp;ldquo; N非常大&amp;rdquo;的记法）：</target>
        </trans-unit>
        <trans-unit id="11b4e1bb86ac129d3782b8fb89778b82b4699643" translate="yes" xml:space="preserve">
          <source>(with credit to &lt;a href=&quot;https://stackoverflow.com/a/487292/711085&quot;&gt;https://stackoverflow.com/a/487292/711085&lt;/a&gt; )</source>
          <target state="translated">（感谢&lt;a href=&quot;https://stackoverflow.com/a/487292/711085&quot;&gt;https://stackoverflow.com/a/487292/711085&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="7bedee6fc739cfe745b69e77230823ca7b506921" translate="yes" xml:space="preserve">
          <source>... I &quot;(basically) double&quot; the time an O(N log(N)) algorithm takes.&quot; &lt;em&gt;(fairly common)&lt;/em&gt;</source>
          <target state="translated">...&amp;ldquo;我（基本上）将O（N log（N））算法花费的时间加倍。&amp;rdquo; &lt;em&gt;（相当普遍）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c2cc664a183cfc04e1a64249ea8f7c45673b79cb" translate="yes" xml:space="preserve">
          <source>... I add a fixed amount to the time an O(log(N)) (&quot;logarithmic time&quot;) algorithm takes.&quot; &lt;em&gt;(cheap!)&lt;/em&gt;</source>
          <target state="translated">...我向O（log（N））（&amp;ldquo;对数时间&amp;rdquo;）算法所花费的时间加上固定的数量。&amp;rdquo; &lt;em&gt;（便宜！）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9288b2e9d99d26a40d9f6f5b3a3990d8e5204b8b" translate="yes" xml:space="preserve">
          <source>... I don't change the time an O(1) (&quot;constant time&quot;) algorithm takes.&quot; &lt;em&gt;(the cheapest!)&lt;/em&gt;</source>
          <target state="translated">...我不会更改O（1）（&amp;ldquo;恒定时间&amp;rdquo;）算法所花费的时间。&amp;rdquo; &lt;em&gt;（最便宜！）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac3db673dfe1df5538b14e8981fdd7f64c253879" translate="yes" xml:space="preserve">
          <source>... I double the time an O(N) (&quot;linear time&quot;) algorithm takes.&quot;</source>
          <target state="translated">...我的时间是O(N)(&quot;线性时间&quot;)算法的两倍。&quot;</target>
        </trans-unit>
        <trans-unit id="a1e7e1ffe28ec1263008a387034b2aaa20a40664" translate="yes" xml:space="preserve">
          <source>... I double-cubed (octuple) the time an O(N&amp;sup3;) (&quot;cubic time&quot;) algorithm takes.&quot; &lt;em&gt;(e.g. a problem 100x as big takes 100&amp;sup3;=1000000x as long... very unsustainable)&lt;/em&gt;</source>
          <target state="translated">...我将O（N&amp;sup3;）（&amp;ldquo;立方时间&amp;rdquo;）算法所花费的时间加倍（八倍）。&amp;rdquo; &lt;em&gt;（例如，问题的100倍大需要100&amp;sup3;= 1000000x的长久&amp;hellip;&amp;hellip;非常不可持续）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eab0d87ea3058c371ba99238d90dc25bc68910e0" translate="yes" xml:space="preserve">
          <source>... I double-squared (quadruple) the time an O(N&amp;sup2;) (&quot;quadratic time&quot;) algorithm takes.&quot; &lt;em&gt;(e.g. a problem 100x as big takes 100&amp;sup2;=10000x as long... possibly unsustainable)&lt;/em&gt;</source>
          <target state="translated">...我将O（N&amp;sup2;）（&amp;ldquo;二次时间&amp;rdquo;）算法所花费的时间加倍（四倍）。&amp;rdquo; &lt;em&gt;（例如，问题的100倍大需要100&amp;sup2;= 10000倍长&amp;hellip;&amp;hellip;可能是不可持续的）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a87538c4cde56e0a42c94f671c99d158235fbb02" translate="yes" xml:space="preserve">
          <source>... I ridiculously increase the time a O(2&lt;sup&gt;N&lt;/sup&gt;) (&quot;exponential time&quot;) algorithm takes.&quot; &lt;em&gt;(you'd double (or triple, etc.) the time just by increasing the problem by a single unit)&lt;/em&gt;</source>
          <target state="translated">&amp;hellip;&amp;hellip;我荒谬地增加了O（2 &lt;sup&gt;N&lt;/sup&gt; ）（&amp;ldquo;指数时间&amp;rdquo;）算法所花费的时间。&amp;rdquo; &lt;em&gt;（仅通过将问题增加一个单位就可以使时间增加一倍（或三倍，等等）。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="758995d5c0c86f523c06ebeba129d83d2b577e5c" translate="yes" xml:space="preserve">
          <source>... and the ugly:</source>
          <target state="translated">...和丑陋。</target>
        </trans-unit>
        <trans-unit id="5f8dd699eca2f4c835f1d41e82c48c0ee2badc97" translate="yes" xml:space="preserve">
          <source>... this means that &lt;strong&gt;&lt;em&gt;for &quot;large enough&quot; problem sizes N&lt;/em&gt;&lt;/strong&gt; (if we ignore stuff near the origin), there exists some constant (e.g. 2.5, completely made up) such that:</source>
          <target state="translated">...这意味着&lt;strong&gt;&lt;em&gt;对于&amp;ldquo;足够大&amp;rdquo;的问题大小N&lt;/em&gt;&lt;/strong&gt; （如果我们忽略原点附近的东西），存在一些常数（例如2.5，完全组成），使得：</target>
        </trans-unit>
        <trans-unit id="02da7ab518ed35b63049ed24f5f7b780a03cf03c" translate="yes" xml:space="preserve">
          <source>1 item: 1 second</source>
          <target state="translated">1个项目。1个项目:1秒</target>
        </trans-unit>
        <trans-unit id="311ddef12fccab210777747c79f3b6e098829cf8" translate="yes" xml:space="preserve">
          <source>10 items: 1 second</source>
          <target state="translated">10个项目。1秒</target>
        </trans-unit>
        <trans-unit id="b0174046184ef586844edb37f738266a6b609bf9" translate="yes" xml:space="preserve">
          <source>10 items: 10 seconds</source>
          <target state="translated">10个项目。10个项目:10秒</target>
        </trans-unit>
        <trans-unit id="689340b4e2631ad08bd04332ba871630466acec6" translate="yes" xml:space="preserve">
          <source>10 items: 100 seconds</source>
          <target state="translated">10个项目。100秒</target>
        </trans-unit>
        <trans-unit id="487a07e5ea7f045eaef47700eca5782bdc2698c0" translate="yes" xml:space="preserve">
          <source>10 items: 2 seconds</source>
          <target state="translated">10个项目。2秒</target>
        </trans-unit>
        <trans-unit id="e9339141f2aa5963a587e850388974cfe8b47716" translate="yes" xml:space="preserve">
          <source>100 items: 1 second</source>
          <target state="translated">100个项目。1秒</target>
        </trans-unit>
        <trans-unit id="f78d9065d61742cbe71ea04a50c760c0aad8e2f0" translate="yes" xml:space="preserve">
          <source>100 items: 100 seconds</source>
          <target state="translated">100个项目。100秒</target>
        </trans-unit>
        <trans-unit id="b9a9aeacdc04be6832d92a9113f361be8c4fe731" translate="yes" xml:space="preserve">
          <source>100 items: 10000 seconds</source>
          <target state="translated">100个项目。10000秒</target>
        </trans-unit>
        <trans-unit id="e626224265872fce291da52ed1c64e5aa6578829" translate="yes" xml:space="preserve">
          <source>100 items: 3 seconds</source>
          <target state="translated">100个项目。3秒</target>
        </trans-unit>
        <trans-unit id="4479af418a5535ecef4c1769fe04b3e262bd0ce2" translate="yes" xml:space="preserve">
          <source>1000 items: 4 seconds</source>
          <target state="translated">1000个项目。4秒</target>
        </trans-unit>
        <trans-unit id="59b0f1da90751fd2ff98593e8e90a885934dbe5d" translate="yes" xml:space="preserve">
          <source>10000 items: 5 seconds</source>
          <target state="translated">10000个项目。5秒</target>
        </trans-unit>
        <trans-unit id="085fdb777863ed85e33fb2c51dc325a0803c3300" translate="yes" xml:space="preserve">
          <source>25! = 25 &amp;times; 24 &amp;times; &amp;hellip; &amp;times; 2 &amp;times; 1 = 15,511,210,043,330,985,984,000,000</source>
          <target state="translated">25！ = 25&amp;times;24&amp;times;&amp;hellip;&amp;times;2&amp;times;1 = 15,511,210,043,330,985,984,000,000</target>
        </trans-unit>
        <trans-unit id="1cf1a4fd3744013ce7ee0b7c1d54d91a24a35640" translate="yes" xml:space="preserve">
          <source>5! = 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 120</source>
          <target state="translated">5！ = 5&amp;times;4&amp;times;3&amp;times;2&amp;times;1 = 120</target>
        </trans-unit>
        <trans-unit id="5ff18ebe3d87d9ac7b38e9bc7546904650421471" translate="yes" xml:space="preserve">
          <source>50! = 50 &amp;times; 49 &amp;times; &amp;hellip; &amp;times; 2 &amp;times; 1 = 3.04140932 &amp;times; 10&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">50！ = 50&amp;times;49&amp;times;&amp;hellip;&amp;times;2&amp;times;1 = 3.04140932&amp;times;10 &lt;sup&gt;64&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="65decea121bc59733f31fb00d9968ddd605ec56d" translate="yes" xml:space="preserve">
          <source>6 becomes 360.</source>
          <target state="translated">6变成360。</target>
        </trans-unit>
        <trans-unit id="c649be492e31261bc490084ea0f4061c188e3cef" translate="yes" xml:space="preserve">
          <source>6! = 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 720</source>
          <target state="translated">6！ = 6&amp;times;5&amp;times;4&amp;times;3&amp;times;2&amp;times;1 = 720</target>
        </trans-unit>
        <trans-unit id="c8333818a5f4310605f53fef7090df38bab14cef" translate="yes" xml:space="preserve">
          <source>7! = 7 &amp;times; 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 5040</source>
          <target state="translated">7！ = 7&amp;times;6&amp;times;5&amp;times;4&amp;times;3&amp;times;2&amp;times;1 = 5040</target>
        </trans-unit>
        <trans-unit id="82d23a6f8035f1269cf4ccfacb8ebe4510c824fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(1)&lt;/code&gt;&lt;strong&gt;Constant&lt;/strong&gt;: The program takes the same time to run no matter how big the input is.</source>
          <target state="translated">&lt;code&gt;O(1)&lt;/code&gt; &lt;strong&gt;常数&lt;/strong&gt; ：无论输入多大，程序都需要花费相同的时间来运行。</target>
        </trans-unit>
        <trans-unit id="056a18f82b6af88dc008fbe3a7787f86b596f6a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(N)&lt;/code&gt; algorithms are in some sense the &quot;best&quot; algorithms if you need to read all your data. The &lt;strong&gt;very act of reading&lt;/strong&gt; a bunch of data is an &lt;code&gt;O(N)&lt;/code&gt; operation. Loading it into memory is usually &lt;code&gt;O(N)&lt;/code&gt; (or faster if you have hardware support, or no time at all if you've already read the data). However, if you touch or even &lt;em&gt;look&lt;/em&gt; at every piece of data (or even every other piece of data), your algorithm will take &lt;code&gt;O(N)&lt;/code&gt; time to perform this looking. No matter how long your actual algorithm takes, it will be at least &lt;code&gt;O(N)&lt;/code&gt; because it spent that time looking at all the data.</source>
          <target state="translated">如果需要读取所有数据，则 &lt;code&gt;O(N)&lt;/code&gt; 算法在某种意义上是&amp;ldquo;最佳&amp;rdquo;算法。 &lt;strong&gt;读取&lt;/strong&gt;一堆数据的&lt;strong&gt;真正动作&lt;/strong&gt;是 &lt;code&gt;O(N)&lt;/code&gt; 操作。 通常将其加载到内存中的时间为 &lt;code&gt;O(N)&lt;/code&gt; （如果有硬件支持，则加载速度更快；如果已经读取了数据，则完全没有时间加载）。 但是，如果您触摸甚至&lt;em&gt;查看&lt;/em&gt;每条数据（甚至每条其他数据），您的算法都将花费 &lt;code&gt;O(N)&lt;/code&gt; 时间来执行此查找。 无论您的实际算法花费多长时间，它至少都将是 &lt;code&gt;O(N)&lt;/code&gt; ,因为它花费了时间查看所有数据。</target>
        </trans-unit>
        <trans-unit id="b1e73910621a4a87a24289f5d1c6be72edc01699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(k^n)&lt;/code&gt;&lt;strong&gt;Exponential&lt;/strong&gt; The program run-time increases very quickly with even moderate increases in the size of the problem - it is only practical to process small data sets with exponential algorithms.</source>
          <target state="translated">&lt;code&gt;O(k^n)&lt;/code&gt; &lt;strong&gt;指数&lt;/strong&gt;程序运行时非常迅速地增加，甚至问题的大小适度增加-仅适用于使用指数算法处理小的数据集。</target>
        </trans-unit>
        <trans-unit id="dd8fc41eb8e642b8c7be077a43f8b40003fc551c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt;&lt;strong&gt;Logarithmic&lt;/strong&gt;: The program run-time increases only slowly, even with big increases in the size of the input.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;strong&gt;对数&lt;/strong&gt; ：即使输入大小增加很多，程序运行时间也仅缓慢增加。</target>
        </trans-unit>
        <trans-unit id="5537ff56d10d57079a34acd64955d17beb7d3a76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n!)&lt;/code&gt;&lt;strong&gt;Factorial&lt;/strong&gt; The program run-time will be longer than you can afford to wait for anything but the very smallest and most trivial-seeming datasets.</source>
          <target state="translated">&lt;code&gt;O(n!)&lt;/code&gt; &lt;strong&gt;阶乘&lt;/strong&gt;程序的运行时间将比您等待不起最小且最琐碎的数据集所需的时间更长。</target>
        </trans-unit>
        <trans-unit id="461878ff8b0db16418e81fc04a687228bdddb9cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n)&lt;/code&gt;&lt;strong&gt;Linear&lt;/strong&gt;: The program run-time increases proportionally to the size of the input.</source>
          <target state="translated">&lt;code&gt;O(n)&lt;/code&gt; &lt;strong&gt;线性&lt;/strong&gt; ：程序运行时间与输入大小成比例增加。</target>
        </trans-unit>
        <trans-unit id="c217eda9395d53638ead2adab477fe11bdcd7bed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n^k)&lt;/code&gt;&lt;strong&gt;Polynomial&lt;/strong&gt;: - Processing time grows faster and faster - as a polynomial function - as the size of the input increases.</source>
          <target state="translated">&lt;code&gt;O(n^k)&lt;/code&gt; &lt;strong&gt;多项式&lt;/strong&gt; ：-处理时间增长得越来越快-作为多项式函数-随着输入大小的增加。</target>
        </trans-unit>
        <trans-unit id="487d91ff83198cfbc6a54c925fe5eb11d2aa1e78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; &amp;Omega;(lowerbound)&lt;/code&gt; means &lt;code&gt;f&lt;/code&gt; &quot;grows no slower than&quot; &lt;code&gt;lowerbound&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; &amp;Omega;(lowerbound)&lt;/code&gt; 表示 &lt;code&gt;f&lt;/code&gt; &amp;ldquo;增长不慢于&amp;rdquo; &lt;code&gt;lowerbound&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b822bda6e416f32092b9f10f8f055c41f8035dcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; means &lt;code&gt;f&lt;/code&gt; &quot;grows no faster than&quot; &lt;code&gt;upperbound&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; 意味着 &lt;code&gt;f&lt;/code&gt; &amp;ldquo;增长 &lt;code&gt;upperbound&lt;/code&gt; 于&amp;rdquo; 上限</target>
        </trans-unit>
        <trans-unit id="b5d65077f782632cf020f9dc10bb5515c203e5c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; Ɵ(justlikethis)&lt;/code&gt; mean &lt;code&gt;f&lt;/code&gt; &quot;grows exactly like&quot; &lt;code&gt;justlikethis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; Ɵ(justlikethis)&lt;/code&gt; 意思是 &lt;code&gt;f&lt;/code&gt; &amp;ldquo;正好生长&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e4961257cbe0182882cfdaf21754b651a2f9dd8e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Big-O notation represent the upper-bound on the Complexity (Time, Space, ..)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Big-O表示复杂度的上限（时间，空间，..）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b6ee9747fe724799f360b3f5740e340e9d6e0bc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Examples&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Examples&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dda2198e2a2e6a8edab7d156a0212aab2797c3a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Math addenda&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;数学附录&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53c547884adc7e294b855c4c5480cbf77fa6513e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;More examples&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;更多例子&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="16299135c5a827dc53d250d6ee80162f6e351d93" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;example:&lt;/em&gt; you and a friend are asked to create a function to sum the numbers from 0 to N. You come up with f(x) and your friend comes up with g(x). Both functions have the same result, but a different algorithm. In order to objectively compare the efficiency of the algorithms we use &lt;strong&gt;Big-O notation&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;例如：&lt;/em&gt;您和您的朋友被要求创建一个将0到N的数字求和的函数。您得出f（x），而您的朋友得出g（x）。 这两个函数具有相同的结果，但算法不同。 为了客观地比较算法的效率，我们使用&lt;strong&gt;Big-O表示法&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="62471f46793f8b6a5cc659e14e96cdc437a86276" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = &lt;em&gt;k&lt;/em&gt;(x)&lt;em&gt;g&lt;/em&gt;(x)</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; （x）= &lt;em&gt;k&lt;/em&gt; （x） &lt;em&gt;g&lt;/em&gt; （x）</target>
        </trans-unit>
        <trans-unit id="150577e3855332cfa9b847f25eb077da526cdf9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = O(&lt;em&gt;g&lt;/em&gt;(x)) when x goes to a (for example, a = +&amp;infin;) means that there is a function &lt;em&gt;k&lt;/em&gt; such that:</source>
          <target state="translated">当x到达a（例如a = +&amp;infin;）时， &lt;em&gt;f&lt;/em&gt; （x）= O（ &lt;em&gt;g&lt;/em&gt; （x））意味着存在一个函数&lt;em&gt;k&lt;/em&gt; ，使得：</target>
        </trans-unit>
        <trans-unit id="f39e0610bb58307821a0194948212519a3857fe0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = o(&lt;em&gt;g&lt;/em&gt;(x)) when x goes to a means that there is a function k such that:</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; （x）= o（ &lt;em&gt;g&lt;/em&gt; （x）），当x到达一个意味着存在一个函数k时：</target>
        </trans-unit>
        <trans-unit id="60efe2817e6b6dc1067de924ce07bd71c241b66c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;k&lt;/em&gt;(x) goes to 0 when x goes to a.</source>
          <target state="translated">当x到达a时， &lt;em&gt;k&lt;/em&gt; （x）变为0。</target>
        </trans-unit>
        <trans-unit id="df9a7b04d24a410a550a80633b5c46b22b5f4454" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;Big O&quot; does two things:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;ldquo;大O&amp;rdquo;做两件事：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1daaf609ea760d49121da39fad36df3d4c70428" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2&lt;sup&gt;2N&lt;/sup&gt; = (4&lt;sup&gt;N&lt;/sup&gt;)............put another way...... &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2&lt;sup&gt;N+1&lt;/sup&gt; = 2&lt;sup&gt;N&lt;/sup&gt;2&lt;sup&gt;1&lt;/sup&gt; = 2 &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr;2 &lt;sup&gt;2N&lt;/sup&gt; =（4 &lt;sup&gt;N&lt;/sup&gt; ）............换一种方式...... &lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr;2 &lt;sup&gt;N + 1&lt;/sup&gt; = 2 &lt;sup&gt;N&lt;/sup&gt; 2 &lt;sup&gt;1&lt;/sup&gt; = 2 &lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bafc82a1bb664838622cc7d1e8482db598079440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3 key takeaways:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3个关键要点：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae00ba228fe3cdd0cfce107b955e3f34920862ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Plain English Explanation of &lt;em&gt;What&lt;/em&gt; Big O Notation is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;大O符号的简单英语解释：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="effebafa8908442aac2c8ca79cf7084917151477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Plain English Explanation of the &lt;em&gt;Need&lt;/em&gt; for Big-O Notation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;需要&lt;/em&gt;大O标记的简单英语解释：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dc1a218f6a731c6560f65be4a2784929627a928" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A more accurate explanation (mathematical)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更准确的解释（数学的）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73f82c5b1f0e86127e3020556cc882893d6cf6cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm description:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;算法说明：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f5537eaa639ac5f94aa2c74841f5eaaa9254c7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm example (Java):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;算法示例（Java）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8aab72c29f5ef095ba2621ef23e8bc30d58b5ec1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Amortized Worst-Case&lt;/strong&gt;: Some data structures may have a worst-case complexity that is large, but guarantee that if you do many of these operations, the average amount of work you do will be better than worst-case. For example, you may have a data structure that normally takes constant &lt;code&gt;O(1)&lt;/code&gt; time. However, occasionally it will 'hiccup' and take &lt;code&gt;O(N)&lt;/code&gt; time for one random operation, because maybe it needs to do some bookkeeping or garbage collection or something... but it promises you that if it does hiccup, it won't hiccup again for N more operations. The worst-case cost is still &lt;code&gt;O(N)&lt;/code&gt; per operation, but the amortized cost &lt;em&gt;over many runs&lt;/em&gt; is &lt;code&gt;O(N)/N&lt;/code&gt; = &lt;code&gt;O(1)&lt;/code&gt; per operation. Because the big operations are sufficiently rare, the massive amount of occasional work can be considered to blend in with the rest of the work as a constant factor. We say the work is &quot;amortized&quot; over a sufficiently large number of calls that it disappears asymptotically.</source>
          <target state="translated">&lt;strong&gt;摊销最坏情况&lt;/strong&gt; ：某些数据结构可能具有最坏情况的复杂性，但是要保证，如果您执行许多此类操作，则平均工作量将比最坏情况要好。 例如，您可能具有通常需要恒定 &lt;code&gt;O(1)&lt;/code&gt; 时间的数据结构。 但是，偶尔它会&amp;ldquo;打ic&amp;rdquo;并花 &lt;code&gt;O(N)&lt;/code&gt; 的时间进行一次随机操作，因为它可能需要做一些簿记或垃圾收集之类的工作&amp;hellip;&amp;hellip;但是它向您保证，如果打h，它不会再次打N，需要进行N次以上的操作。 最坏的情况下，每次操作的成本仍为 &lt;code&gt;O(N)&lt;/code&gt; ，但&lt;em&gt;多次运行&lt;/em&gt;的摊销成本为 &lt;code&gt;O(N)/N&lt;/code&gt; = &lt;code&gt;O(1)&lt;/code&gt; 。 由于大型操作非常罕见，因此可以将大量的偶然工作与其他工作融合为一个恒定因素。 我们说该作品在足够多的通话中被&amp;ldquo;摊销&amp;rdquo;，以至于渐渐消失。</target>
        </trans-unit>
        <trans-unit id="bf7370e1d0177c50c4c0d7fb024561f2bab440cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Amortized and average-case complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;摊销和平均情况下的复杂性&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab4389896132cbec29ee3f0554d686383b2d60f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Applications&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Applications&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b3d5404d360c404fd2bf84459010109192eb8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Attention!&lt;/strong&gt; The notation with the equal sign &quot;=&quot; uses a &quot;fake equality&quot;: it is true that o(g(x)) = O(g(x)), but false that O(g(x)) = o(g(x)).  Similarly, it is ok to write &quot;ln(x) = o(x) when x &amp;rarr; +&amp;infin;&quot;, but the formula &quot;o(x) = ln(x)&quot; would make no sense.</source>
          <target state="translated">&lt;strong&gt;注意！&lt;/strong&gt; 等号&amp;ldquo; =&amp;rdquo;的表示法使用&amp;ldquo;假相等&amp;rdquo;：o（g（x））= O（g（x））是正确的，但O（g（x））= o（g （X））。 类似地，可以在x&amp;rarr;+&amp;infin;时写下&amp;ldquo; ln（x）= o（x）&amp;rdquo;，但是公式&amp;ldquo; o（x）= ln（x）&amp;rdquo;没有任何意义。</target>
        </trans-unit>
        <trans-unit id="34dd92c00819162397c366f49572746e28f5f1c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Average Case&lt;/strong&gt;: This is no more than using big-O notation for the expected value of a function, rather than the function itself. In the usual case where you consider all inputs to be equally likely, the average case is just the average of the running time. For example with quicksort, even though the worst-case is &lt;code&gt;O(N^2)&lt;/code&gt; for some really bad inputs, the average case is the usual &lt;code&gt;O(N log(N))&lt;/code&gt; (the really bad inputs are very small in number, so few that we don't notice them in the average case).</source>
          <target state="translated">&lt;strong&gt;平均情况&lt;/strong&gt; ：这仅是针对函数的期望值而不是函数本身使用big-O表示法。 在通常情况下，您认为所有输入的可能性均等，平均情况只是运行时间的平均值。 例如，对于快速排序，即使对于某些非常糟糕的输入，最坏的情况是 &lt;code&gt;O(N^2)&lt;/code&gt; ，但平均情况是通常的 &lt;code&gt;O(N log(N))&lt;/code&gt; （真正糟糕的输入的数量非常小，因此在一般情况下，我们很少会注意到它们）。</target>
        </trans-unit>
        <trans-unit id="3220576162b61267d1a4a26767219ea6e4545c4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Back to English&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;返回英文&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0cac323801b8e9b2b0c915a6c542a3bbb241cb47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basics&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Basics&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deeb35e60114ce47ff18984e39930c946fc62ed4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Case:&lt;/strong&gt; In the telephone book search, the best case is that we find the name in one comparison.  This is &lt;strong&gt;O(1)&lt;/strong&gt; or &lt;strong&gt;constant complexity&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong&gt;最佳情况：&lt;/strong&gt;在电话簿搜索中，最佳情况是我们在一次比较中找到了姓名。 这是&lt;strong&gt;O（1）&lt;/strong&gt;或&lt;strong&gt;不变的复杂度&lt;/strong&gt; ；</target>
        </trans-unit>
        <trans-unit id="41bdf2eff0707b735977a7b17f99ea1599797803" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Case:&lt;/strong&gt; O(1);</source>
          <target state="translated">&lt;strong&gt;最佳情况：&lt;/strong&gt; O（1）;</target>
        </trans-unit>
        <trans-unit id="7914d10c281c86a759e82a40640c5f8d93756303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big O describes the fundamental scaling nature of an algorithm.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;大O描述了算法的基本缩放性质。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e271d8846f3715b1a024f21916128b7d4259417" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big O&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;大O&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dd5e066b9eba73f69ac911aaff371d1d5517277" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big-O notation is a relative representation of the complexity of an algorithm.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big-O表示法是算法复杂度的相对表示。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c911dd80e980898d8f2c1e27f8c346fb06ef9ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big-O notation:&lt;/strong&gt; describes &lt;em&gt;how quickly runtime will grow relative to the input as the input get arbitrarily large.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Big-O表示法：&lt;/strong&gt;描述&lt;em&gt;当输入任意大时，运行时相对于输入的增长速度。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1070a59c780c49217b3d9ef6075f07036a4de4f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Building Intuition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;建立直觉&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f587b858f8d6fe44a8225f82326a30f53c9d5650" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;By the time you get to 200 towns there isn't enough time left in the universe to solve the problem with traditional computers.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;到200个城镇时，宇宙中没有足够的时间来解决传统计算机的问题。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1d2d8d2f9c4e97fb709d00d85e5dfaceb74c57d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant factors&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;恒定因素&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9efca8768fe35240139284fbd68b4fe07fc97b92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Case:&lt;/strong&gt; As discussed above this is O(log n); and</source>
          <target state="translated">&lt;strong&gt;预期情况：&lt;/strong&gt;如上所述，这是O（log n）; 和</target>
        </trans-unit>
        <trans-unit id="9587614449d0127777f6fe21db3683733e748143" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Case:&lt;/strong&gt; O(n) (for 500,000); and</source>
          <target state="translated">&lt;strong&gt;预期案例：&lt;/strong&gt; O（n）（500,000）； 和</target>
        </trans-unit>
        <trans-unit id="cdd089580422378d4ca18f0f8f5cf50cf6b830ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do analyze algorithms and how can we compare algorithms against each other?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如何分析算法，如何相互比较算法？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea84419042cce91d342892912299eab7b4c9fa1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you're unlucky when executing A, it might take as much as X(n) operations to
  complete.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果执行A时不走运，则可能需要多达X（n）个操作才能完成。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5f526b740d48e1e3fd49fd9918ce4ec61555a90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multidimensional big-O&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;多维big-O&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6acc739d0b13f807318bf1624de37df1094994ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N&amp;sup2;&lt;/strong&gt; &amp;rarr; (2N)&amp;sup2; = 4(&lt;strong&gt;N&amp;sup2;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;N&amp;sup2;&lt;/strong&gt; &amp;rarr;（2N）&amp;sup2;= 4（ &lt;strong&gt;N&amp;sup2;&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="61702d5685c60ef63ef6fe3ad5ab08a71dd8a2d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N&lt;/strong&gt; &amp;rarr; (2N) = 2(&lt;strong&gt;N&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;N&lt;/strong&gt; &amp;rarr;（2N）= 2（ &lt;strong&gt;N&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="21cce32ea86e14da51ca9a5664ed1f0ffeff0b0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Big O notation represents the &lt;strong&gt;worst-case scenario&lt;/strong&gt; of an algorithm. Let&amp;rsquo;s assume that &lt;strong&gt;O(1)&lt;/strong&gt; and &lt;strong&gt;O(n)&lt;/strong&gt; are the worst-case scenarios of the example above.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;大O表示法表示算法的&lt;strong&gt;最坏情况&lt;/strong&gt; 。 假设&lt;strong&gt;O（1）&lt;/strong&gt;和&lt;strong&gt;O（n）&lt;/strong&gt;是以上示例的最坏情况。</target>
        </trans-unit>
        <trans-unit id="252fabf6945e589a9b0b19016a058e011afbcc3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(1):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68d75ca052377c566336069afee258c69b9aec6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1)&lt;/strong&gt; - Time to complete is the same regardless of the size of input set. An example is accessing an array element by index.</source>
          <target state="translated">&lt;strong&gt;O（1）&lt;/strong&gt; -完成时间是相同的，与输入集的大小无关。 一个示例是按索引访问数组元素。</target>
        </trans-unit>
        <trans-unit id="f9afcf401f691a7c75faeb32231d92fde83ecee4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1)&lt;/strong&gt;:  known as &lt;strong&gt;Constant complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（1）&lt;/strong&gt; ： &lt;strong&gt;恒定复杂度&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dd564fa0710bbf0a0a6d4f2c0d4f0f4442e00d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e72a614b62847ef5617dfe85cfaca13129fb5ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; ）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="635e753fee8296bf321ba6bb90e4518245442fc7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d4b1b888d0086c21997e7a8ecfa829f30374361" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22ac35f2cdc52d148b68da9ed9dd29461e980fe3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(Log N)&lt;/strong&gt; - Time to complete increases roughly in line with the log2(n). For example 1024 items takes roughly twice as long as 32 items, because Log2(1024) = 10 and Log2(32) = 5. An example is finding an item in a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;binary search tree&lt;/a&gt; (BST).</source>
          <target state="translated">&lt;strong&gt;O（Log N）&lt;/strong&gt; -完成时间大致与log2（n）一致。 例如，1024个项目花费的时间大约是32个项目的两倍，因为Log2（1024）= 10且Log2（32）=5。一个示例是在&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;二进制搜索树&lt;/a&gt; （BST）中查找一个项目。</target>
        </trans-unit>
        <trans-unit id="d26adbc9eb537a7d0d5f9ae0552e61b12d6c54bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N Log N)&lt;/strong&gt; - Time to complete increases by the number of items times the result of Log2(N). An example of this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap_sort&quot;&gt;heap sort&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Quick_sort&quot;&gt;quick sort&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O（N Log N）&lt;/strong&gt; -完成时间增加的项目数乘以Log2（N）的结果。 一个例子就是&lt;a href=&quot;http://en.wikipedia.org/wiki/Heap_sort&quot;&gt;堆排序&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Quick_sort&quot;&gt;快速排序&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd630f970ed12459c9538aee894e4fca49869a98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N!)&lt;/strong&gt; - Time to complete is the factorial of the input set. An example of this is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;traveling salesman problem brute-force solution&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O（N！）&lt;/strong&gt; -完成时间是输入集的阶乘。 一个例子就是&lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;旅行推销员问题暴力解决方案&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c2e179b7e171e252effc28bae4e6ee136e75dba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N)&lt;/strong&gt; - Time to complete that scales linearly with the size of the input set. In other words if you double the number of items in the input set, the algorithm takes roughly twice as long. An example is counting the number of items in a linked list.</source>
          <target state="translated">&lt;strong&gt;O（N）&lt;/strong&gt; -完成时间与输入集的大小成线性比例。 换句话说，如果将输入集中的项数加倍，则该算法所需的时间大约是原来的两倍。 一个示例是计算链接列表中的项目数。</target>
        </trans-unit>
        <trans-unit id="4784dc4311f56c18cde15b50f60f2194c6df45fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N^2)&lt;/strong&gt; - Time to complete is roughly equal to the square of the number of items. An example of this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;bubble sort&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O（N ^ 2）&lt;/strong&gt; -完成时间大致等于项数的平方。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;气泡排序&lt;/a&gt;就是一个例子。</target>
        </trans-unit>
        <trans-unit id="bf8d37b23321b288f2b44644bc4c145c6315466f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log &lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（log &lt;em&gt;n&lt;/em&gt; ）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32f6df92bfa553861340db36e2f34e2204cc3856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log n)&lt;/strong&gt;:  known as &lt;strong&gt;Logarithmic complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（log n）&lt;/strong&gt; ：称为&lt;strong&gt;对数复杂度&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9a156d671486ba42c9d6bc4f718b4ad56ae4429" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n)&lt;/strong&gt;:  known as &lt;strong&gt;Linear complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（n）&lt;/strong&gt; ：称为&lt;strong&gt;线性复杂度&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25021c74f1f7cc3f73ce24095087c41055c38051" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;:  known as &lt;strong&gt;Quadratic complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（n &lt;sup&gt;2&lt;/sup&gt; ）&lt;/strong&gt; ：称为&lt;strong&gt;二次复杂度&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ad18baa396b629a872133cacda5df06a167689b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Practical example: visualizing orders of growth while coding&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;实际示例：在编码时可视化增长顺序&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee51f001b7ef2c276ec42b4e704f02dd05a4cccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt; : &lt;a href=&quot;http://carlcheo.com/compsci&quot;&gt;http://carlcheo.com/compsci&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;参考&lt;/strong&gt; ： &lt;a href=&quot;http://carlcheo.com/compsci&quot;&gt;http&lt;/a&gt; : //carlcheo.com/compsci</target>
        </trans-unit>
        <trans-unit id="63fd89842e817d63e08af214f7f5c992e4999387" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplest way to look at it (in plain English)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最简单的查看方式（用英语）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f8b58e2bc4650ab1f5fd985238dd4f0a986d132" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Small o&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;小o&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff25f85074d21875430e07bd8801b858e31f7be6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Space complexity:&lt;/strong&gt; aside from time complexity, we also care about space complexity (how much memory/space an algorithm uses). Instead of checking the time of operations, we check the size of the allocation of memory.</source>
          <target state="translated">&lt;strong&gt;空间复杂度：&lt;/strong&gt;除了时间复杂度外，我们还关心空间复杂度（算法使用多少内存/空间）。 我们不检查操作时间，而是检查内存分配的大小。</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aea48c460158f9801c2ff1547226bfcd94a4ab48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The whole story&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;整个故事&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5841737d9f1f0f3920b87ca2d61ff0c8311a9f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are seven most used notations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;有七个最常用的符号&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="898a1558a3534794d5a58e6000c3473375b52eb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There's also Big-Omega, which represent complexity of the Best-Case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;还有Big-Omega，它代表了Best-Case的复杂性：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a11037fecab22049818b34474fe8e78b05b5b18c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To find The Big-O on Time Complexity:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;要找到关于时间复杂性的大O：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07f6120a26e2f3f8456ca56f2c44ce3f39c3119c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We only care about the most significant portion of complexity.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我们只关心复杂性的最重要部分。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7974c46035c46b41ac44b7f0b9e92098bfa014df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why O(N) is sometimes the best you can do, i.e. why we need datastructures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为什么O（N）有时是您可以做的最好的事情，即为什么我们需要数据结构&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4207c81d75e6ff00a2ab700fd03b10c9d6ef7476" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst Case:&lt;/strong&gt; O(n) (for 1,000,000).</source>
          <target state="translated">&lt;strong&gt;最坏的情况：&lt;/strong&gt; O（n）（代表1,000,000）。</target>
        </trans-unit>
        <trans-unit id="575be9f02c898b973aff9fb1bd5bd357e2752a80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst Case:&lt;/strong&gt; This is also O(log n).</source>
          <target state="translated">&lt;strong&gt;最坏的情况：&lt;/strong&gt;这也是O（log n）。</target>
        </trans-unit>
        <trans-unit id="8259671e56bc51a9fd25fab5b93ec32f6a9f6007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;algorithm&lt;/strong&gt;: procedure/formula for solving a problem</source>
          <target state="translated">&lt;strong&gt;算法&lt;/strong&gt; ：解决问题的过程/公式</target>
        </trans-unit>
        <trans-unit id="bf91eb2b18b1a94ff6bc8b8c14b3d1250c603cbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;analogy&lt;/strong&gt;: The analogy in this particular case is a jigsaw puzzle: We created a data structure that exploits some property of the data. If our road segments are like puzzle pieces, we group them by matching color and pattern. We then exploit this to avoid doing extra work later (comparing puzzle pieces of like color to each other, not to every other single puzzle piece).</source>
          <target state="translated">&lt;strong&gt;类比&lt;/strong&gt; ：在这种特殊情况下的类比是一个拼图游戏：我们创建了一个利用数据某些属性的数据结构。 如果我们的路段像拼图一样，我们通过匹配颜色和图案将它们分组。 然后，我们利用它来避免以后做额外的工作（将颜色相似的拼图相互比较，而不是将每个拼图相互比较）。</target>
        </trans-unit>
        <trans-unit id="3fd5be370782e9eefda17f79f700c59070a53c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;c log(N)&lt;/strong&gt; &amp;rarr; c log(2N) = (c log(2))+(&lt;strong&gt;c log(N)&lt;/strong&gt;) = (fixed amount)+(&lt;strong&gt;c log(N)&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;c log（N）&lt;/strong&gt; &amp;rarr;c log（2N）=（c log（2））+（ &lt;strong&gt;c log（N）&lt;/strong&gt; ）=（固定数量）+（ &lt;strong&gt;c log（N）&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="6bd6f3f7face459b8ad4a2440f178d8320099c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;c*1&lt;/strong&gt; &amp;rarr; &lt;strong&gt;c*1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;c * 1&lt;/strong&gt; &amp;rarr; &lt;strong&gt;c * 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae34a86dbd8e294559fb6de015a86203c6d6210c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; &amp;rarr; c(2N)&amp;sup3; = 8(&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; &amp;rarr;c（2N）&amp;sup3;= 8（ &lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="27b5788854d51bd893ea7a5207a2a3c0a233aee4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;complexity:&lt;/strong&gt; if it takes me one second to sort 10,000 elements, how long will it take me to sort one million?  Complexity in this instance is a relative measure to something else.</source>
          <target state="translated">&lt;strong&gt;复杂性：&lt;/strong&gt;如果我花一秒钟来排序10,000个元素，我要花多长时间来排序一百万个元素？ 在这种情况下，复杂性是相对于其他事物的相对度量。</target>
        </trans-unit>
        <trans-unit id="5457665c30d0585dc37a4fd244075c3a2b2ad61b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for &quot;sufficiently&quot; large inputs...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;用于&amp;ldquo;足够&amp;rdquo;的大投入...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2acb65b1907221e1bdd5284f08ac1b0df4ea0231" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;relative:&lt;/strong&gt; you can only compare apples to apples.  You can't compare an algorithm to do arithmetic multiplication to an algorithm that sorts a list of integers.  But a comparison of two algorithms to do arithmetic operations (one multiplication, one addition) will tell you something meaningful;</source>
          <target state="translated">&lt;strong&gt;相对的：&lt;/strong&gt;您只能将苹果与苹果进行比较。 您无法将进行算术乘法的算法与对整数列表进行排序的算法进行比较。 但是，将两种进行算术运算的算法进行比较（一次乘法，一次加法）将告诉您一些有意义的事情；</target>
        </trans-unit>
        <trans-unit id="527b57aaeb37446d8c211474a094432da292f875" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;representation:&lt;/strong&gt; Big-O (in its simplest form) reduces the comparison between algorithms to a single variable.  That variable is chosen based on observations or assumptions.  For example, sorting algorithms are typically compared based on comparison operations (comparing two nodes to determine their relative ordering).  This assumes that comparison is expensive.  But what if comparison is cheap but swapping is expensive?  It changes the comparison; and</source>
          <target state="translated">&lt;strong&gt;表示形式：&lt;/strong&gt; Big-O（以最简单的形式）将算法之间的比较简化为单个变量。 该变量是根据观察或假设选择的。 例如，排序算法通常基于比较操作进行比较（比较两个节点以确定它们的相对顺序）。 这假定比较是昂贵的。 但是，如果比较便宜但交换昂贵呢？ 它改变了比较； 和</target>
        </trans-unit>
        <trans-unit id="19518fd2e0a8446c92d07859c82f3fdb9396de2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr: The number of handshakes 'looks like' x&amp;sup2; so much for large values, that if we were to write down the ratio #handshakes/x&amp;sup2;, the fact that we don't need &lt;em&gt;exactly&lt;/em&gt; x&amp;sup2; handshakes wouldn't even show up in the decimal for an arbitrarily large while.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tl; dr：对于较大的值，握手的数量看起来&amp;ldquo;x&amp;sup2;如此之多&amp;rdquo;，以至于我们记下＃handshakes /x&amp;sup2;的比率，甚至不需要x&amp;sup2;握手的事实甚至都不会出现在小数点后任意一会儿。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc58ee0a287cef32ca985382490b5ed483c76fc8" translate="yes" xml:space="preserve">
          <source>A &amp;rarr; B &amp;rarr; C</source>
          <target state="translated">A&amp;rarr;B&amp;rarr;C</target>
        </trans-unit>
        <trans-unit id="9814460aaaa82f895fab69aa1e7b80cc39fcf625" translate="yes" xml:space="preserve">
          <source>A &amp;rarr; C &amp;rarr; B</source>
          <target state="translated">A&amp;rarr;C&amp;rarr;B</target>
        </trans-unit>
        <trans-unit id="6fa316481ef216118bd579775f4816b14c18a0f7" translate="yes" xml:space="preserve">
          <source>A simple straightforward answer can be:</source>
          <target state="translated">一个简单直接的答案可以是:</target>
        </trans-unit>
        <trans-unit id="2fa68420a293bc47b500623963e3f939ae51a473" translate="yes" xml:space="preserve">
          <source>A typical implementation might be to open up to the middle, take the 500,000&lt;sup&gt;th&lt;/sup&gt; and compare it to &quot;Smith&quot;. If it happens to be &quot;Smith, John&quot;, we just got real lucky.  Far more likely is that &quot;John Smith&quot; will be before or after that name.  If it's after we then divide the last half of the phone book in half and repeat.  If it's before then we divide the first half of the phone book in half and repeat.  And so on.</source>
          <target state="translated">一个典型的实现方式可能是打开中间位置，占据第500,000 &lt;sup&gt;个位置&lt;/sup&gt;并将其与&amp;ldquo; Smith&amp;rdquo;进行比较。 如果碰巧是&amp;ldquo;史密斯，约翰&amp;rdquo;，我们真的很幸运。 &amp;ldquo; John Smith&amp;rdquo;更可能在该名称之前或之后。 如果是在那之后，我们将电话簿的后半部分一分为二并重复。 如果在此之前，则将电话簿的前半部分分成两半，然后重复。 等等。</target>
        </trans-unit>
        <trans-unit id="b2eaa9e11c09c682e15e1f9214b1b8f85ad77873" translate="yes" xml:space="preserve">
          <source>Addition is the simplest.  You line the numbers up (to the right) and add the digits in a column writing the last number of that addition in the result.  The 'tens' part of that number is carried over to the next column.</source>
          <target state="translated">加法是最简单的。你把数字排成一列(向右看),然后把数字加在一列中,在结果中写上加法的最后一个数字。这个数字中的 &quot;十 &quot;的部分会转移到下一列。</target>
        </trans-unit>
        <trans-unit id="06a8ddf90a58cac434d9dddb41eadc549d53c934" translate="yes" xml:space="preserve">
          <source>Also keep in mind that due to hidden constraints of your program, you might not really care about asymptotic behavior. You may be working with a bounded number of values, for example:</source>
          <target state="translated">另外,请记住,由于程序的隐藏约束,你可能并不关心近似行为。比如说,你可能是在处理一个有约束的数值。</target>
        </trans-unit>
        <trans-unit id="580cbd5744ce3d45f6d2b723b41c7344947edda0" translate="yes" xml:space="preserve">
          <source>Although anything &quot;larger&quot; than a constant factor can be detected, however.</source>
          <target state="translated">虽然任何 &quot;大于常数因子的东西都可以检测到,但是。</target>
        </trans-unit>
        <trans-unit id="f5bfda3d2781b7d70658d5d11b9d005ba3e1398e" translate="yes" xml:space="preserve">
          <source>Amortized worst-case: If you use an amortized worst-case data structure, the performance is guaranteed to be within the amortized worst-case... eventually (even if the inputs are chosen by an evil demon who knows everything and is trying to screw you over). Usually, we use this to analyze algorithms that may be very 'choppy' in performance with unexpected large hiccups, but over time perform just as well as other algorithms. (However unless your data structure has upper limits for much outstanding work it is willing to procrastinate on, an evil attacker could perhaps force you to catch up on the maximum amount of procrastinated work all-at-once.</source>
          <target state="translated">摊余最坏情况。如果你使用摊余最坏情况下的数据结构,那么最终的性能会保证在摊余最坏情况下...........(即使输入是由一个邪恶的恶魔选择的,他什么都知道,并试图欺骗你)。通常情况下,我们用这个来分析那些可能在性能上非常 &quot;不稳定 &quot;的算法,会出现意想不到的大打嗝,但随着时间的推移,其性能和其他算法一样好。然而,除非你的数据结构对它愿意拖延很多未完成的工作有上限,否则邪恶的攻击者或许会强迫你一次性赶上最大限度的拖延工作)。</target>
        </trans-unit>
        <trans-unit id="c08025d0af34b0e733dff69c38b8140014e0dcfb" translate="yes" xml:space="preserve">
          <source>And furthermore</source>
          <target state="translated">此外,还包括</target>
        </trans-unit>
        <trans-unit id="6896d57deefe7dcce6486c33a6e908bb66a0f2d5" translate="yes" xml:space="preserve">
          <source>Another point I wanted to make quick mention of is that any algorithm that has a complexity of &lt;strong&gt;O(n&lt;sup&gt;a&lt;/sup&gt;)&lt;/strong&gt; is said to have &lt;strong&gt;polynomial complexity&lt;/strong&gt; or is solvable in &lt;strong&gt;polynomial time&lt;/strong&gt;.</source>
          <target state="translated">我想快速提及的另一点是，任何具有&lt;strong&gt;O（n &lt;sup&gt;a&lt;/sup&gt; ）&lt;/strong&gt;复杂度的算法都被认为具有&lt;strong&gt;多项式复杂度&lt;/strong&gt;或可以在&lt;strong&gt;多项式时间内&lt;/strong&gt;求解。</target>
        </trans-unit>
        <trans-unit id="18d608bf5ee39a542ef2abc8b2c8aa9502e49075" translate="yes" xml:space="preserve">
          <source>Anyone who's read Programming Pearls or any other Computer Science
  books and doesn&amp;rsquo;t have a grounding in Mathematics will have hit a wall
  when they reached chapters that mention O(N log N) or other seemingly
  crazy syntax. Hopefully this article will help you gain an
  understanding of the basics of Big O and Logarithms.</source>
          <target state="translated">读过Programming Pearls或任何其他计算机科学书籍且没有数学基础的任何人，在到达提及O（N log N）或其他看似疯狂的语法的章节时都会碰壁。 希望本文能帮助您了解Big O和对数的基础。</target>
        </trans-unit>
        <trans-unit id="ca7668976286f5ad8d5eca2a7fadcc44aba0a83b" translate="yes" xml:space="preserve">
          <source>Anyway, that's it for my (hopefully plain English) explanation of Big O (revised).</source>
          <target state="translated">不管怎么说,我对大O的解释(希望是通俗易懂的英文)就到此为止(修订后的)。</target>
        </trans-unit>
        <trans-unit id="010115fea8e63b4e720d7c742f8033325bf02f8e" translate="yes" xml:space="preserve">
          <source>As &lt;em&gt;n&lt;/em&gt; gets arbitrarily large, focus on the terms that will grow the fastest as n gets large (think infinity) AKA &lt;strong&gt;asymptotic analysis&lt;/strong&gt;</source>
          <target state="translated">随着&lt;em&gt;n&lt;/em&gt;任意变大，关注随着n变大（认为无穷大）而逐渐增长最快的项AKA &lt;strong&gt;渐近分析&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="870ad13cbf6243c698d7d2bf03ab24ac0048aa57" translate="yes" xml:space="preserve">
          <source>As a programmer first and a mathematician second (or maybe third or
  fourth) I found the best way to understand Big O thoroughly was to
  produce some examples in code. So, below are some common orders of
  growth along with descriptions and examples where possible.</source>
          <target state="translated">作为一个程序员第一,数学家第二(或许是第三或第四),我发现要彻底理解大O,最好的方法就是用代码制作一些例子。所以,下面是一些常见的成长顺序,并尽可能地附上描述和例子。</target>
        </trans-unit>
        <trans-unit id="483f1c4417fdd5afc1f2915ce24ff5ba0f7520e8" translate="yes" xml:space="preserve">
          <source>As a purely mathematical construct, big-O notation is not limited to talking about processing time and memory. You can use it to discuss the asymptotics of anything where scaling is meaningful, such as:</source>
          <target state="translated">作为一个纯粹的数学构造,big-O的概念并不限于讨论处理时间和内存。你可以用它来讨论任何有意义的缩放的东西的近似性,比如说:</target>
        </trans-unit>
        <trans-unit id="d7f64f73685e6f247cbf73eed79f3d10cdb73567" translate="yes" xml:space="preserve">
          <source>As a result of all this unhelpful complexity, people try to describe the speed of software programs using the smallest and least complex (mathematical) expressions possible. These expressions are very very crude approximations: Although, with a bit of luck, they will capture the &quot;essence&quot; of whether a piece of software is fast or slow.</source>
          <target state="translated">由于所有这些无益的复杂性,人们试图用最小的、最不复杂的(数学)表达式来描述软件程序的速度。这些表达式都是非常粗糙的近似值。虽然,只要运气好一点,它们会抓住一个软件是快还是慢的 &quot;本质&quot;。</target>
        </trans-unit>
        <trans-unit id="7f8315a19f8a52da5d9ef1a40ab83006a844cfd3" translate="yes" xml:space="preserve">
          <source>As it happens, there are certain functions (think of them as &lt;em&gt;implementations&lt;/em&gt; of &lt;strong&gt;X(n)&lt;/strong&gt;) that tend to occur quite often. These are well known and easily compared (Examples: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Log N&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;N^2&lt;/code&gt;, &lt;code&gt;N!&lt;/code&gt;, etc..)</source>
          <target state="translated">碰巧的是，某些功能（将它们视为&lt;strong&gt;X（n）的实现&lt;/strong&gt; ）往往会经常发生。 这些是众所周知的，很容易比较（示例： &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;Log N&lt;/code&gt; ， &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;N^2&lt;/code&gt; ， &lt;code&gt;N!&lt;/code&gt; 等。）</target>
        </trans-unit>
        <trans-unit id="58635748eb80ad2370517e468a337e1bd88c9cc8" translate="yes" xml:space="preserve">
          <source>As the algorithm scales with n-&lt;em&gt;squared&lt;/em&gt;, this is &lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt; or &lt;strong&gt;quadratic complexity&lt;/strong&gt;. This is a good time to introduce another important concept:</source>
          <target state="translated">随着算法按n &lt;em&gt;平方&lt;/em&gt;缩放，这就是&lt;strong&gt;O（n &lt;sup&gt;2&lt;/sup&gt; ）&lt;/strong&gt;或&lt;strong&gt;二次复杂度&lt;/strong&gt; 。 现在是引入另一个重要概念的好时机：</target>
        </trans-unit>
        <trans-unit id="db509c6991e60440b1722a307f8ef3f99bc3043d" translate="yes" xml:space="preserve">
          <source>Assume we're talking about an algorithm &lt;strong&gt;A&lt;/strong&gt;, which should do something with a dataset of size &lt;strong&gt;n&lt;/strong&gt;.</source>
          <target state="translated">假设我们正在谈论算法&lt;strong&gt;A&lt;/strong&gt; ，该算法应该对大小为&lt;strong&gt;n&lt;/strong&gt;的数据集执行某些操作。</target>
        </trans-unit>
        <trans-unit id="5e269fc76f0e879e9586e4d2d5b07a5bf29feecd" translate="yes" xml:space="preserve">
          <source>Asymptotic notation is, at its core, quite separate from programming. Asymptotic notation is a mathematical framework for thinking about how things scale and can be used in many different fields. That said... this is how you &lt;em&gt;apply&lt;/em&gt; asymptotic notation to coding.</source>
          <target state="translated">渐进符号的本质与编程完全不同。 渐近符号是一种思考事物如何缩放并可以在许多不同领域中使用的数学框架。 就是说...这就是&lt;em&gt;将&lt;/em&gt;渐近符号应用于编码的方式。</target>
        </trans-unit>
        <trans-unit id="b1fcf30b1f3fc218decd89222f7ae2f077cdd616" translate="yes" xml:space="preserve">
          <source>At some point, at some time, there will be no swaps, and our sort of the deck would be done.  So much work!</source>
          <target state="translated">在某个时间点,在某个时间点上,会没有交换,而我们的排序就会完成。这么多的工作!</target>
        </trans-unit>
        <trans-unit id="bfb8cbb068a5baea44b500d50ed4ead05e487564" translate="yes" xml:space="preserve">
          <source>At some point, this loop (from Two to Three) will end.  It ends when both halves of this search meet at the splay card.  Then, we have just splayed the deck with the card you chose in step One.  Now, all the cards near the start are more low than the splay card; and the cards near the end are more high than the splay card.  Cool trick!</source>
          <target state="translated">在某个时候,这个循环(从二到三)将结束。当这个寻找的两半在Slay牌处相遇时,它就结束了。然后,我们刚刚用你在步骤一中选择的那张牌把这副牌放上了。现在,所有靠近起始点的牌都比SPLAY牌低;而靠近终点的牌都比SPLAY牌高。酷炫的技巧!</target>
        </trans-unit>
        <trans-unit id="6ad9a691d1120dce91af1178eb6b497f4f7e37f7" translate="yes" xml:space="preserve">
          <source>Average-case: We make some assumptions about our inputs; i.e. if our inputs have different probabilities, then our outputs/runtimes will have different probabilities (which we take the average of). Usually, we assume that our inputs are all equally likely (uniform probability), but if the real-world inputs don't fit our assumptions of &quot;average input&quot;, the average output/runtime calculations may be meaningless. If you anticipate uniformly random inputs though, this is useful to think about!</source>
          <target state="translated">平均情况。我们对我们的输入做了一些假设;也就是说,如果我们的输入有不同的概率,那么我们的输出运行时间就会有不同的概率(我们取平均值)。通常情况下,我们假设我们的输入都是同样的概率(均匀概率),但如果现实世界的输入不符合我们的 &quot;平均输入 &quot;假设,那么平均输出运行时间的计算可能就没有意义了。如果你预计到的是均匀随机的输入,那么这一点是很有用的,可以考虑一下!</target>
        </trans-unit>
        <trans-unit id="832a8d90127d5ca48f6556477abd38a77ce36f33" translate="yes" xml:space="preserve">
          <source>B &amp;rarr; A &amp;rarr; C</source>
          <target state="translated">B&amp;rarr;A&amp;rarr;C</target>
        </trans-unit>
        <trans-unit id="d813322c7a347a65c04fed32bbe445579ce7e1e8" translate="yes" xml:space="preserve">
          <source>B &amp;rarr; C &amp;rarr; A</source>
          <target state="translated">B&amp;rarr;C&amp;rarr;A</target>
        </trans-unit>
        <trans-unit id="cc07b18b222d704f4ad25abdb8dc152106fba5a0" translate="yes" xml:space="preserve">
          <source>Back to the telephone book.</source>
          <target state="translated">回到电话本上。</target>
        </trans-unit>
        <trans-unit id="56a13e8f97147d6679bf9d3baf62cda1ea3b33ca" translate="yes" xml:space="preserve">
          <source>Back up a bit: the number of handshakes is exactly n-choose-2 or &lt;code&gt;N*(N-1)/2&lt;/code&gt; (each of N people shakes the hands of N-1 other people, but this double-counts handshakes so divide by 2):</source>
          <target state="translated">备份一点：握手的次数恰好是n-choose-2或 &lt;code&gt;N*(N-1)/2&lt;/code&gt; （每N个人握手N-1个其他人的握手，但是这种双重计数握手除以2）：</target>
        </trans-unit>
        <trans-unit id="5120b09510b1d63d87c9c5faa58192336bbcb191" translate="yes" xml:space="preserve">
          <source>Based on the mathematical definition above, if you say your algorithm is a Big O of n, it means it is a function of n (number of input parameters) &lt;strong&gt;or faster&lt;/strong&gt;. If your algorithm is Big O of n, then it is also automatically the Big O of n square.</source>
          <target state="translated">根据上面的数学定义，如果您说算法是n的Big O，则表示它是n（输入参数的数量） &lt;strong&gt;或更快速&lt;/strong&gt;的函数。 如果您的算法是n的Big O，那么它也自动是n平方的BigO。</target>
        </trans-unit>
        <trans-unit id="db284bf74073477f62953e8e8e02b1401e213f94" translate="yes" xml:space="preserve">
          <source>Because they are approximations, we use the letter &quot;O&quot; (Big Oh) in the expression, as a convention to signal to the reader that we are making a gross oversimplification. (And to make sure that nobody mistakenly thinks that the expression is in any way accurate).</source>
          <target state="translated">因为它们是近似的,所以我们在表达式中使用字母 &quot;O&quot;(大哦),作为一种惯例,向读者表明我们在做一个严重的过度简化。而且为了确保没有人误以为这个表达方式是准确的)。</target>
        </trans-unit>
        <trans-unit id="ac9bfd81f5e9c61b91f03629f317cefc5ed3f40a" translate="yes" xml:space="preserve">
          <source>Best-Case: the key is the first item.</source>
          <target state="translated">最好的情况:关键是第一项。</target>
        </trans-unit>
        <trans-unit id="8871063a9de2c96323fce812e3e16047b1b9b0c8" translate="yes" xml:space="preserve">
          <source>Big O comes in and says: for a deck of n cards, to sort it this way will be done in O(N squared) time.</source>
          <target state="translated">大O走进来说:对于一副N张牌,要这样分类,要在O(N平方的时间内完成。</target>
        </trans-unit>
        <trans-unit id="e28ca34381715acfd2716526a419b0f386a39327" translate="yes" xml:space="preserve">
          <source>Big O complexity can be visualized with this graph:</source>
          <target state="translated">大O的复杂性,可以用这个图来直观的显示。</target>
        </trans-unit>
        <trans-unit id="01191d73dc858c84e96603e205ce6cf90b305595" translate="yes" xml:space="preserve">
          <source>Big O describes an upper limit on the growth behaviour of a function, for example the runtime of a program, when inputs become large.</source>
          <target state="translated">大O描述了一个函数的增长行为的上限,比如说程序的运行时间,当输入量变大的时候,程序的运行时间。</target>
        </trans-unit>
        <trans-unit id="6d6c6ee7d49379298994bf2d0373e24c46b6260e" translate="yes" xml:space="preserve">
          <source>Big O does not solve the work for us.  Big O tells us how hard the work is.</source>
          <target state="translated">大O并不为我们解决工作。大O告诉我们,工作有多难。</target>
        </trans-unit>
        <trans-unit id="067d8c2c09524ec3079760262aecc198a00b16eb" translate="yes" xml:space="preserve">
          <source>Big O ignores factors that do not contribute in a meaningful way to the growth curve of a function as the input size increases towards infinity. This means that constants that are added to or multiplied by the function are simply ignored.</source>
          <target state="translated">大O忽略了那些随着输入大小向无穷大增加而对函数的增长曲线没有意义的因素。这意味着被函数加到或乘以函数的常数被简单地忽略了。</target>
        </trans-unit>
        <trans-unit id="5ef0b065d98e11f17dc80d42a717ef47eb65fe1e" translate="yes" xml:space="preserve">
          <source>Big O is a measure of how much time/space an algorithm uses relative to the size of its input.</source>
          <target state="translated">大O是衡量一个算法使用的时间空间相对于其输入的大小而言有多大。</target>
        </trans-unit>
        <trans-unit id="7e04dd1651f885b1cee3374bf9f1eb929407c8c2" translate="yes" xml:space="preserve">
          <source>Big O is just a way to &quot;Express&quot; yourself in a common way, &quot;How much time / space does it take to run my code?&quot;.</source>
          <target state="translated">大O只是用通俗的方式来 &quot;表达 &quot;自己,&quot;运行我的代码需要多少时间空间?&quot;。</target>
        </trans-unit>
        <trans-unit id="615e13e08dc48881c60e9af49cb00312f337463a" translate="yes" xml:space="preserve">
          <source>Big O is useful to compare how well two algorithms will scale up as the number of inputs is increased.</source>
          <target state="translated">大O可以用来比较两种算法随着输入数量的增加而扩展的程度。</target>
        </trans-unit>
        <trans-unit id="d8cd4344a90d7e5c64b849cbdbe8173c868330b0" translate="yes" xml:space="preserve">
          <source>Big O is your friend and mine.  Big O helps us think on how much work we have to do, so we can plan.  And, if we are friends with big O, he can help us choose work that is not so hard!</source>
          <target state="translated">大O是你的朋友,也是我的朋友。大O可以帮助我们思考有多少工作要做,这样我们就可以做好计划。而且,如果我们和大O是朋友,他可以帮我们选择不那么辛苦的工作!</target>
        </trans-unit>
        <trans-unit id="63a54321034901fba163b3e5364e8adebdcce5cc" translate="yes" xml:space="preserve">
          <source>Big O notation also shines a spotlight directly on the most important principle of computer programming/engineering, the fact which inspires all good programmers to keep thinking and dreaming: the only way to achieve results beyond the slow forward march of technology is to &lt;em&gt;invent a better algorithm&lt;/em&gt;.</source>
          <target state="translated">Big O表示法也直接聚焦于计算机编程/工程学的最重要原理，这一事实激励着所有优秀的程序员继续思考和梦想：获得超越缓慢技术进步的结果的唯一方法是&lt;em&gt;发明更好的技术。算法&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a168ec8cf3b032681504a8e27d40ac24591c31bc" translate="yes" xml:space="preserve">
          <source>Big O notation is a way of describing how quickly an algorithm will run given an arbitrary number of input parameters, which we'll call &quot;n&quot;. It is useful in computer science because different machines operate at different speeds, and simply saying that an algorithm takes 5 seconds doesn't tell you much because while you may be running a system with a 4.5 Ghz octo-core processor, I may be running a 15 year old, 800 Mhz system, which could take longer regardless of the algorithm. So instead of specifying how fast an algorithm runs in terms of time, we say how fast it runs in terms of number of input parameters, or &quot;n&quot;. By describing algorithms in this way, we are able to compare the speeds of algorithms without having to take into account the speed of the computer itself.</source>
          <target state="translated">Big O记号是一种描述算法在给定一个任意数量的输入参数的情况下运行速度的方法,我们称之为 &quot;n&quot;。它在计算机科学中很有用,因为不同机器的运行速度不同,简单地说一个算法需要5秒并不能说明什么,因为你可能运行的系统是4.5Ghz八核处理器,而我可能运行的是15年的800Mhz系统,无论算法如何,都可能需要更长的时间。所以,我们不是用时间来指定一个算法的运行速度,而是用输入参数的数量,或者说 &quot;n &quot;来表示算法的运行速度。用这种方式描述算法,我们就可以比较算法的速度,而不需要考虑计算机本身的速度。</target>
        </trans-unit>
        <trans-unit id="4b0a116919ddeacd83d71ce31ad376da360a026c" translate="yes" xml:space="preserve">
          <source>Big O notation is a way of describing the upper bound of an algorithm in terms of space or running time.  The n is the number of elements in the the problem (i.e size of an array, number of nodes in a tree, etc.)  We are interested in describing the running time as n gets  big.</source>
          <target state="translated">大O符号是一种用空间或运行时间来描述算法的上界的方法。其中n是问题中的元素数(即数组的大小,树中的节点数等),我们感兴趣的是当n变大时,描述运行时间。</target>
        </trans-unit>
        <trans-unit id="4c8f74fc1bdc10685b2177c45ec160d36cadb907" translate="yes" xml:space="preserve">
          <source>Big O notation is most commonly used by programmers as an approximate measure of how long a computation (algorithm) will take to complete expressed as a function of the size of the input set.</source>
          <target state="translated">大O记号是程序员们最常用的一种近似度量方法,用来衡量一个计算(算法)需要多长时间才能完成,表示为输入集大小的函数。</target>
        </trans-unit>
        <trans-unit id="35d0c4e9b1c9e1dda535f62f93fc8e1e6b9b14c1" translate="yes" xml:space="preserve">
          <source>Big O notation is used in Computer Science to describe the performance
  or complexity of an algorithm. Big O specifically describes the
  worst-case scenario, and can be used to describe the execution time
  required or the space used (e.g. in memory or on disk) by an
  algorithm.</source>
          <target state="translated">在计算机科学中,大O符号用于描述算法的性能或复杂度。大O具体描述了最坏的情况,可以用来描述算法所需的执行时间或算法所占用的空间(如内存或磁盘上的空间)。</target>
        </trans-unit>
        <trans-unit id="029dd5426c412001fb487f1ee4fae8a55e3c8c3b" translate="yes" xml:space="preserve">
          <source>Big O notation simply tells how much time* an algorithm can run within,
  in terms of &lt;em&gt;only the amount of input data&lt;/em&gt;**.</source>
          <target state="translated">Big O表示法仅&lt;em&gt;根据输入数据的数量&lt;/em&gt; **告诉您算法可以在多少时间内运行。</target>
        </trans-unit>
        <trans-unit id="ac3a3f5b5b610616ecbb8b264905e5ee4de505c6" translate="yes" xml:space="preserve">
          <source>Big O notation tells you the cost of solving an infinitely large problem.</source>
          <target state="translated">大O记数法告诉你解决一个无限大的问题的成本。</target>
        </trans-unit>
        <trans-unit id="f4998d7a032917937335ae6425e4667cbea54bd2" translate="yes" xml:space="preserve">
          <source>Big O of n means my algorithm runs at least as fast as this. You cannot look at Big O notation of your algorithm and say its slow. You can only say its fast.</source>
          <target state="translated">n的大O意味着我的算法至少和这个算法一样快。你不能看着你的算法的大O符号就说它慢。你只能说它的速度快。</target>
        </trans-unit>
        <trans-unit id="2aabaf3aedb4e0aa46fb4d5ff8c2ab4e6073ca94" translate="yes" xml:space="preserve">
          <source>Big O points out this: as n gets big, when we sort cards, the job gets MUCH MUCH MORE HARD than the old just-add-these-things job.  How do we know this?</source>
          <target state="translated">大O指出:当我们把卡片分类时,随着N变得越来越大,工作就会变得比以前的 &quot;加点东西 &quot;的工作要难得多。我们是怎么知道的?</target>
        </trans-unit>
        <trans-unit id="93a1b436d9d2b6befbc854db9c969659b8e5b77f" translate="yes" xml:space="preserve">
          <source>Big O represents the worst possible time/space for that algorithm. The algorithm will never take more space/time above that limit. Big O represents time/space complexity in the extreme case.</source>
          <target state="translated">大O代表了该算法最坏的时间空间。该算法永远不会占用超过这个极限的时空。大O代表了极端情况下的时空复杂性。</target>
        </trans-unit>
        <trans-unit id="2897bc170748c75b1afb0452b1633a9f90eeaa23" translate="yes" xml:space="preserve">
          <source>Big O says: we must do six adds to solve this.  One add, for each thing from one to six.  Six small bits of work... each bit of work is one add.</source>
          <target state="translated">大O说:我们必须做六个加法来解决这个问题。一个加法,从1到6的每一件事都是一个加法。六个小位的工作,每一个小位的工作就是一个加法。</target>
        </trans-unit>
        <trans-unit id="01a1c3b9e0eae37b04b930c9e959423669d00b8b" translate="yes" xml:space="preserve">
          <source>Big O tells us that to sort things is more hard than to add things.  O(n squared) is more than O(n) for big n.  That means: if n gets real big, to sort a mixed deck of n things MUST take more time, than to just add n mixed things.</source>
          <target state="translated">大O告诉我们,对事物进行排序比对事物进行添加更难。O(n的平方)比O(n的平方)大,也就是说:如果n变大了,把n种东西混合在一起,要把n种东西排序,一定比只加n种混合的东西要花更多的时间。</target>
        </trans-unit>
        <trans-unit id="ff2337e8063fec003cbedd7750338ff7fc025f36" translate="yes" xml:space="preserve">
          <source>Big O, help me!</source>
          <target state="translated">大O,救我!</target>
        </trans-unit>
        <trans-unit id="f0939bd08a02841e66e2310a89ddfeb9c0a7055e" translate="yes" xml:space="preserve">
          <source>Big-&amp;Omega; (Big-Omega) notation (article) | Khan Academy</source>
          <target state="translated">大&amp;Omega;（大欧米茄）表示法（文章） 可汗学院</target>
        </trans-unit>
        <trans-unit id="9ffc7ec8bbe6223b3d70e4376f89b6eab1b1a639" translate="yes" xml:space="preserve">
          <source>Big-O notation (also called &quot;asymptotic growth&quot; notation) is &lt;em&gt;what functions &quot;look like&quot; when you ignore constant factors and stuff near the origin&lt;/em&gt;. We use it to talk about &lt;strong&gt;how thing scale&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;当您忽略恒定因素和原点附近的东西时，&lt;/em&gt; Big-O表示法（也称为&amp;ldquo;渐近增长&amp;rdquo;表示法）的作用是&lt;em&gt;&amp;ldquo;看起来像&amp;rdquo;&lt;/em&gt; 。 我们用它来谈论&lt;strong&gt;事物如何扩展&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="1769664f1e1ca72f099882bf25e7d2f39574cca3" translate="yes" xml:space="preserve">
          <source>Big-O, is &lt;strong&gt;rate of increase&lt;/strong&gt; of resource consumed by program, w.r.t. problem-instance-size</source>
          <target state="translated">Big-O，是程序消耗的资源&lt;strong&gt;的增加速率&lt;/strong&gt; ，问题实例大小</target>
        </trans-unit>
        <trans-unit id="a380e8c171aa6d7e586e8f15b66e52968c776a75" translate="yes" xml:space="preserve">
          <source>Binary search is a technique used to search sorted data sets. It works
  by selecting the middle element of the data set, essentially the
  median, and compares it against a target value. If the values match it
  will return success. If the target value is higher than the value of
  the probe element it will take the upper half of the data set and
  perform the same operation against it. Likewise, if the target value
  is lower than the value of the probe element it will perform the
  operation against the lower half. It will continue to halve the data
  set with each iteration until the value has been found or until it can
  no longer split the data set.</source>
          <target state="translated">二进制搜索是一种用于搜索排序数据集的技术。它的工作原理是选择数据集的中间元素,基本上是中位数,然后将其与目标值进行比较。如果值匹配,它将返回成功。如果目标值高于探针元素的值,它将取数据集的上半部分,并对其执行相同的操作。同样,如果目标值低于探针元素的值,它将对下半部分执行操作。每次迭代后,它将继续对数据集进行减半操作,直到找到该值或无法再分割数据集为止。</target>
        </trans-unit>
        <trans-unit id="84e2d5bd3333a554d3c328ae36cecdeea3f085c1" translate="yes" xml:space="preserve">
          <source>Both average-case and amortization are incredibly useful tools for thinking about and designing with scaling in mind.</source>
          <target state="translated">平均情况和摊销都是非常有用的工具,可以在思考和设计时考虑到缩放比例。</target>
        </trans-unit>
        <trans-unit id="81fa41afe9d47413eda0c47da5969d56124c07cf" translate="yes" xml:space="preserve">
          <source>But remember, Big O is just a way to experss yourself in the manner of time and space.</source>
          <target state="translated">但请记住,大O只是以时间和空间的方式来体验自己。</target>
        </trans-unit>
        <trans-unit id="3ddd3cf4c5b5b439921cdd63b830507cc2d92e01" translate="yes" xml:space="preserve">
          <source>But though we will not do the work now, we can guess how hard it would be, if we knew n.  We would have to add up n things, right?  Of course!</source>
          <target state="translated">不过,虽然我们现在不会做这个工作,但我们可以猜到,如果我们知道了N个,那会有多难,我们要把N个东西加起来,不是吗? 当然了,当然了!</target>
        </trans-unit>
        <trans-unit id="de004be9935e007a2aa4a8dd96ba9ccf3e285c6c" translate="yes" xml:space="preserve">
          <source>But, programmers don't think like this because eventually, algorithm intuition just becomes second nature. You will start to code something inefficient and immediately think &quot;am I doing something &lt;strong&gt;grossly inefficient?&lt;/strong&gt;&quot;. If the answer is &quot;yes&quot; AND you foresee it actually mattering, then you can take a step back and think of various tricks to make things run faster (the answer is almost always &quot;use a hashtable&quot;, rarely &quot;use a tree&quot;, and very rarely something a bit more complicated).</source>
          <target state="translated">但是，程序员并不这样认为，因为最终，算法直觉才成为第二自然。 您将开始编写效率低下的代码，然后立即想到&amp;ldquo;我在做&lt;strong&gt;效率低下的&lt;/strong&gt;事情&lt;strong&gt;吗？&lt;/strong&gt; &amp;rdquo;。 如果答案是&amp;ldquo;是&amp;rdquo;，并且您认为它实际上很重要，那么您可以退后一步，考虑各种使事情运行更快的技巧（答案几乎总是&amp;ldquo;使用哈希表&amp;rdquo;，很少使用&amp;ldquo;使用树&amp;rdquo;，而且很少有更复杂的东西）。</target>
        </trans-unit>
        <trans-unit id="0d8f8969e0785f14a21dfca5ea753a20c18775cc" translate="yes" xml:space="preserve">
          <source>By comparing these when talking about &lt;strong&gt;A&lt;/strong&gt; and other algorithms, it is easy to rank the algorithms according to the number of operations they &lt;em&gt;may&lt;/em&gt; (worst-case) require to complete.</source>
          <target state="translated">通过在讨论&lt;strong&gt;A&lt;/strong&gt;和其他算法时比较这些算法，可以轻松地根据算法&lt;em&gt;可能需要&lt;/em&gt; （最坏情况）完成的操作数对算法进行排名。</target>
        </trans-unit>
        <trans-unit id="0d58ba7567f14e061427da47056514f59b5370bc" translate="yes" xml:space="preserve">
          <source>By the way, here is for comparison the definition of small o.</source>
          <target state="translated">顺便说一下,这里是小O的定义,供大家比较。</target>
        </trans-unit>
        <trans-unit id="cbb489069914d301d52853c36730ee0f0e267708" translate="yes" xml:space="preserve">
          <source>C &amp;rarr; A &amp;rarr; B</source>
          <target state="translated">C&amp;rarr;A&amp;rarr;B</target>
        </trans-unit>
        <trans-unit id="6998b04e08785bbdf1c7af58eecf38c1a28d31da" translate="yes" xml:space="preserve">
          <source>C &amp;rarr; B &amp;rarr; A</source>
          <target state="translated">C&amp;rarr;B&amp;rarr;A</target>
        </trans-unit>
        <trans-unit id="6cbbd09b2268ff81c9d2447ddd6efd0ece964c0a" translate="yes" xml:space="preserve">
          <source>Calculate how much time (regarding input size) the worst case takes:</source>
          <target state="translated">计算出最坏的情况下需要多少时间(关于输入大小)。</target>
        </trans-unit>
        <trans-unit id="12668f37b6831ee2e32bd194cd1af2fa68690568" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;https://www.youtube.com/watch?v=V1xXmQkzkZI&amp;amp;index=13&amp;amp;list=PLZBP-86GmPTxpbvoFFzad0qYw5dKA8MV2&quot;&gt;this&lt;/a&gt; out for a video tutorial on Big O from UC Berkley. It's is actually a simple concept. If you hear professor Shewchuck (aka God level teacher) explaining it, you will say &quot;Oh that's all it is!&quot;.</source>
          <target state="translated">请查看&lt;a href=&quot;https://www.youtube.com/watch?v=V1xXmQkzkZI&amp;amp;index=13&amp;amp;list=PLZBP-86GmPTxpbvoFFzad0qYw5dKA8MV2&quot;&gt;此内容&lt;/a&gt; ，以获得来自UC Berkley的Big O视频教程。 这实际上是一个简单的概念。 如果您听到Shewchuck教授（又名神级老师）对此进行了解释，您会说：&amp;ldquo;哦，仅此而已！&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b4523b29b5c7ed6f8c2abc5e9a4c38da02d06afc" translate="yes" xml:space="preserve">
          <source>Come back and reread the above when you've read the rest.</source>
          <target state="translated">等你看完之后再来重读上面的内容。</target>
        </trans-unit>
        <trans-unit id="55a7f0d03a20d7e0d958646e51faf45416912637" translate="yes" xml:space="preserve">
          <source>Compare 1 and 6, which is biggest? Ok 6 is in the right position, moving forward!</source>
          <target state="translated">比较1和6,哪个最大?OK 6的位置是正确的,前进!</target>
        </trans-unit>
        <trans-unit id="1c5884fcffc252b00f765da994d3959a5bea1cc4" translate="yes" xml:space="preserve">
          <source>Compare 6 and 3, oh, 3 is less! Let's move that, Ok the list changed, we need to start from the begining now!</source>
          <target state="translated">对比一下6和3,哦,3少了! 让我们把这个移开,好了,单子变了,我们现在要从头开始!</target>
        </trans-unit>
        <trans-unit id="b5ae65887f49fb01b8aa1e42c87a37e72b0918ca" translate="yes" xml:space="preserve">
          <source>Compare &lt;em&gt;how quickly runtime grows&lt;/em&gt;&lt;strong&gt;NOT&lt;/strong&gt;&lt;em&gt;compare exact runtimes&lt;/em&gt; (depends on hardware)</source>
          <target state="translated">比较&lt;em&gt;运行时的增长速度&lt;/em&gt; &lt;strong&gt;不&lt;/strong&gt; &lt;em&gt;比较确切的运行时&lt;/em&gt; （取决于硬件）</target>
        </trans-unit>
        <trans-unit id="3d11d48dee34717db426c8a89bfdced368207e28" translate="yes" xml:space="preserve">
          <source>Comparison between average-case and amortized worst-case:</source>
          <target state="translated">平均情况和摊销后的最坏情况比较。</target>
        </trans-unit>
        <trans-unit id="ad8df7363e12666a15da250cd1535079ed8d98cb" translate="yes" xml:space="preserve">
          <source>Consider the canonical sorting example. Bubble-sort is O(n&lt;sup&gt;2&lt;/sup&gt;) while merge-sort is O(n log n). Let's say you have two sorting applications, application A which uses bubble-sort and application B which uses merge-sort, and let's say that for input sizes of around 30 elements application A is 1,000x faster than application B at sorting. If you never have to sort much more than 30 elements then it's obvious that you should prefer application A, as it is much faster at these input sizes. However, if you find that you may have to sort ten million items then what you'd expect is that application B actually ends up being thousands of times faster than application A in this case, entirely due to the way each algorithm scales.</source>
          <target state="translated">考虑规范的排序示例。 冒泡排序是O（n &lt;sup&gt;2&lt;/sup&gt; ），而合并排序是O（n log n）。 假设您有两个排序应用程序，使用气泡排序的应用程序A和使用合并排序的应用程序B，假设输入大小约为30个元素，则应用程序A在排序时比应用程序B快1000倍。 如果您不必排序多于30个元素，那么显然您应该首选应用程序A，因为在这些输入大小下它要快得多。 但是，如果您发现可能必须分类一千万个项目，那么您期望的是，在这种情况下，应用程序B实际比应用程序A快数千倍，这完全是由于每种算法的扩展方式所致。</target>
        </trans-unit>
        <trans-unit id="a7c2b8ba88bf46f0dfe0a0ff9f1b26cb00f3ba83" translate="yes" xml:space="preserve">
          <source>Consider the difference between a steam engine and a rocket. They are not merely different varieties of the same thing (as, say, a Prius engine vs. a Lamborghini engine) but they are dramatically different kinds of propulsion systems, at their core. A steam engine may be faster than a toy rocket, but no steam piston engine will be able to achieve the speeds of an orbital launch vehicle. This is because these systems have different scaling characteristics with regards to the relation of fuel required (&quot;resource usage&quot;) to reach a given speed (&quot;input size&quot;).</source>
          <target state="translated">考虑一下蒸汽机和火箭之间的区别。它们不仅仅是同一事物的不同品种(比如说,普锐斯发动机与兰博基尼发动机),而是它们的核心是不同的推进系统。蒸汽发动机可能比玩具火箭快,但任何蒸汽活塞发动机都无法达到轨道运载火箭的速度。这是因为这些系统在达到给定速度(&quot;输入大小&quot;)所需的燃料(&quot;资源使用量&quot;)的关系方面具有不同的比例特性。</target>
        </trans-unit>
        <trans-unit id="6a8cfee71662bf83fd7610d0447480c8f098dc3b" translate="yes" xml:space="preserve">
          <source>Constant factors are negligible</source>
          <target state="translated">常数因素可以忽略不计</target>
        </trans-unit>
        <trans-unit id="0da1286a9bca7edf66b07ff225ea54f102d5a653" translate="yes" xml:space="preserve">
          <source>Depending on N and X, your algorithm will require some operations, for example in the WORST case it's &lt;code&gt;3(N^2) + log(X)&lt;/code&gt; operations.</source>
          <target state="translated">根据N和X，您的算法将需要一些运算，例如，在最坏的情况下，它是 &lt;code&gt;3(N^2) + log(X)&lt;/code&gt; 运算。</target>
        </trans-unit>
        <trans-unit id="f8e74a3a562ba5774725315dfe1782d1a1275af0" translate="yes" xml:space="preserve">
          <source>Does not scale.  You have no hope of solving any non-trivially sized problem.  Useful for knowing what to avoid, and for experts to find approximate algorithms which are in &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt;.</source>
          <target state="translated">不缩放。 您没有解决任何重要问题的希望。 有助于了解要避免的情况，并有助于专家找到&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; &lt;sup&gt;k&lt;/sup&gt; ）中的&lt;/strong&gt;近似算法。</target>
        </trans-unit>
        <trans-unit id="c81313d6a9457c1a28868d8aaaff914cf1b3213c" translate="yes" xml:space="preserve">
          <source>Does this make a hashtable faster than an array for lookups? Not necessarily. If you've got a very small collection of entries, an array may well be faster &amp;mdash; you may be able to check all the strings in the time that it takes to just calculate the hashcode of the one you're looking at. As the data set grows larger, however, the hashtable will eventually beat the array.</source>
          <target state="translated">这会使哈希表比查找数组快吗？ 不必要。 如果条目的集合很小，则数组可能会更快&amp;mdash;您可以在计算所要查找的哈希码时花费所有时间检查所有字符串。 但是，随着数据集的增大，哈希表最终将击败该数组。</target>
        </trans-unit>
        <trans-unit id="38f6893266ac6c8513618653e41d6736baa03b7c" translate="yes" xml:space="preserve">
          <source>EDIT: Quick note, this is almost certainly confusing &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; (which is an upper bound) with Theta notation (which is both an upper and lower bound). In my experience this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</source>
          <target state="translated">编辑：快速说明，这几乎肯定会使&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O表示法&lt;/a&gt; （这是一个上限）与Theta表示法 （这是一个上下限）混淆。 以我的经验，这实际上是非学术场合中讨论的典型内容。 造成任何混乱，我们深表歉意。</target>
        </trans-unit>
        <trans-unit id="c8861868012e671e5ca7903151be427897869332" translate="yes" xml:space="preserve">
          <source>Each of these is an operation or a problem.  A method of solving these is called an &lt;strong&gt;algorithm&lt;/strong&gt;.</source>
          <target state="translated">这些都是操作或问题。 解决这些问题的方法称为&lt;strong&gt;算法&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b62541479f03733e3001473267dd14900d0760bc" translate="yes" xml:space="preserve">
          <source>Ergh.  That sounds like a lot of work!</source>
          <target state="translated">呃.....这听起来很费劲啊!</target>
        </trans-unit>
        <trans-unit id="b6dc6935629b7d3402db5c466e6d14aa566e6056" translate="yes" xml:space="preserve">
          <source>Estimates how many steps of the method your computer applies to accomplish a task.</source>
          <target state="translated">估计你的电脑适用于完成任务的方法有多少步骤。</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">例2:</target>
        </trans-unit>
        <trans-unit id="1d4166bf97179d81c42dccef3ab9d1594a5dec5d" translate="yes" xml:space="preserve">
          <source>Example 3:</source>
          <target state="translated">例3:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="184ce50741de2b5a2d508d5c7f7deb72ee16f548" translate="yes" xml:space="preserve">
          <source>Facilitate the process to compare with others in order to determine whether it's good or not?</source>
          <target state="translated">便于与他人进行比较,以确定好坏?</target>
        </trans-unit>
        <trans-unit id="8b846e7060b9a483588329ba98d3b24f7db5b0ed" translate="yes" xml:space="preserve">
          <source>For 1,000,000 it takes 20.</source>
          <target state="translated">100万就需要20。</target>
        </trans-unit>
        <trans-unit id="bfc4a756390564c98c0f9ee2960940b370613e43" translate="yes" xml:space="preserve">
          <source>For 15 it takes 4.</source>
          <target state="translated">15岁的人需要4个。</target>
        </trans-unit>
        <trans-unit id="c4dcc93d74ce33740712a8b30e5dfa1a16cc492d" translate="yes" xml:space="preserve">
          <source>For 7 it takes at most 3.</source>
          <target state="translated">7人最多需要3人。</target>
        </trans-unit>
        <trans-unit id="8387ae59db1ca9e3e2f91943f6392088dfd4aa1a" translate="yes" xml:space="preserve">
          <source>For a phone book of 3 names it takes 2 comparisons (at most).</source>
          <target state="translated">对于一个由3个名字组成的电话本,需要2次比较(最多)。</target>
        </trans-unit>
        <trans-unit id="5052922ba19448289d5da9158883ce125e05b963" translate="yes" xml:space="preserve">
          <source>For big n, n squared is more large than n.</source>
          <target state="translated">对于大n,n的平方比n大。</target>
        </trans-unit>
        <trans-unit id="e5054e967dbdba1361ba3fb55414b378a8efdbff" translate="yes" xml:space="preserve">
          <source>For completeness, the precise definition of big-O notation is as follows: &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; means that &quot;f is asymptotically upper-bounded by const*g&quot;: ignoring everything below some finite value of x, there exists a constant such that &lt;code&gt;|f(x)| &amp;le; const * |g(x)|&lt;/code&gt;. (The other symbols are as follows: just like &lt;code&gt;O&lt;/code&gt; means &amp;le;, &lt;code&gt;&amp;Omega;&lt;/code&gt; means &amp;ge;. There are lowercase variants: &lt;code&gt;o&lt;/code&gt; means &amp;lt;, and &lt;code&gt;&amp;omega;&lt;/code&gt; means &amp;gt;.) &lt;code&gt;f(x) &amp;isin; Ɵ(g(x))&lt;/code&gt; means both &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; and &lt;code&gt;f(x) &amp;isin; &amp;Omega;(g(x))&lt;/code&gt; (upper- and lower-bounded by g): there exists some constants such that f will always lie in the &quot;band&quot; between &lt;code&gt;const1*g(x)&lt;/code&gt; and &lt;code&gt;const2*g(x)&lt;/code&gt;. It is the strongest asymptotic statement you can make and roughly equivalent to &lt;code&gt;==&lt;/code&gt;. (Sorry, I elected to delay the mention of the absolute-value symbols until now, for clarity's sake; especially because I have never seen negative values come up in a computer science context.)</source>
          <target state="translated">为了完整起见，big-O表示法的精确定义如下： &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; 表示&amp;ldquo; f由const * g渐近上限&amp;rdquo;：忽略x某个有限值以下的所有内容，存在一个常数，使得 &lt;code&gt;|f(x)| &amp;le; const * |g(x)|&lt;/code&gt; &amp;le;const * | g（x）| 。 （其他符号如下：就像 &lt;code&gt;O&lt;/code&gt; 表示&amp;le;， &lt;code&gt;&amp;Omega;&lt;/code&gt; 表示&amp;ge;。有小写变体： &lt;code&gt;o&lt;/code&gt; 表示&amp;lt;， &lt;code&gt;&amp;omega;&lt;/code&gt; 表示&amp;gt;。） &lt;code&gt;f(x) &amp;isin; Ɵ(g(x))&lt;/code&gt; 表示两个 &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; 和 &lt;code&gt;f(x) &amp;isin; &amp;Omega;(g(x))&lt;/code&gt; （由g上下限）：存在一些常数，使得f始终位于 &lt;code&gt;const1*g(x)&lt;/code&gt; 之间的&amp;ldquo;带&amp;rdquo;中* g（x）和 &lt;code&gt;const2*g(x)&lt;/code&gt; 。 这是您可以做出的最强渐近陈述，大致等于 &lt;code&gt;==&lt;/code&gt; 。 （对不起，为清晰起见，我选择推迟到现在才提到绝对值符号；尤其是因为我从未见过在计算机科学环境中出现负值的情况。）</target>
        </trans-unit>
        <trans-unit id="49654e3774111fb16128651b4d224ad6b75c2b89" translate="yes" xml:space="preserve">
          <source>For example, say you had the latitude and longitude coordinates of millions of road segments and wanted to find all street intersections.</source>
          <target state="translated">例如,假设你有几百万个路段的经纬度坐标,想找到所有的街道交叉口。</target>
        </trans-unit>
        <trans-unit id="b3611110a9125b6ab52f37ddd431b3585818e9dd" translate="yes" xml:space="preserve">
          <source>For input of size &quot;n&quot; the program is growing at speed of &quot;n&quot; iterations in array. Hence Big-O is N expressed as  O(n)</source>
          <target state="translated">对于大小为 &quot;n &quot;的输入,程序在数组中以 &quot;n &quot;的迭代速度增长。因此,Big-O是N表示为O(n)</target>
        </trans-unit>
        <trans-unit id="09e7373f604bf7164bb0dca1297d67c519bcfba7" translate="yes" xml:space="preserve">
          <source>For input of size &quot;n&quot; the program is growing at speed of &quot;n*n&quot; iterations in array. Hence Big-O is N&lt;sup&gt;2&lt;/sup&gt; expressed as  O(n&lt;sup&gt;2&lt;/sup&gt;)</source>
          <target state="translated">对于大小为&amp;ldquo; n&amp;rdquo;的输入，程序以数组中&amp;ldquo; n * n&amp;rdquo;次迭代的速度增长。 因此，Big-O是表示为O（n &lt;sup&gt;2&lt;/sup&gt; ）的N &lt;sup&gt;2&lt;/sup&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a6ae78506dc4ee34684d9e0638c4281f35c545f" translate="yes" xml:space="preserve">
          <source>For online downloading, the download time is directly proportional to the movie file sizes (input). We call this &lt;strong&gt;O(n)&lt;/strong&gt;.</source>
          <target state="translated">对于在线下载，下载时间与电影文件大小（输入）成正比。 我们称其为&lt;strong&gt;O（n）&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="67cc9e8bfc7b47bffe767706a99579808a311dcc" translate="yes" xml:space="preserve">
          <source>For the handshake example above, everyone in a room shakes everyone else's hand. In that example, &lt;code&gt;#handshakes &amp;isin; Ɵ(N&amp;sup2;)&lt;/code&gt;. Why?</source>
          <target state="translated">对于上面的握手示例，房间中的每个人都与其他人握手。 在该示例中， &lt;code&gt;#handshakes &amp;isin; Ɵ(N&amp;sup2;)&lt;/code&gt; 。 为什么？</target>
        </trans-unit>
        <trans-unit id="c5e2547d0bc6ba3ff90e388af4f7fa819fdfb175" translate="yes" xml:space="preserve">
          <source>Four (and this is the fun part): I have two small decks now, one more low than the splay card, and one more high.  Now I go to step one, on each small deck!  That is to say, I start from step One on the first small deck, and when that work is done, I start from step One on the next small deck.</source>
          <target state="translated">四张(这也是最有意思的部分)。我现在有两张小牌,一张比SPLAY牌低,一张比SPLAY牌高。现在,我进入步骤一,在每张小牌组上! 就是说,我从步骤一开始,在第一副小牌上开始,当这个工作完成后,我从步骤一开始,在下一副小牌上开始。</target>
        </trans-unit>
        <trans-unit id="4a6b77756dd510894ce0e5f9cee853f3dfb273a0" translate="yes" xml:space="preserve">
          <source>From the experiments, we know that online shopping scales better than online downloading. It is very important to understand big O notation because it helps you to analyze the &lt;strong&gt;scalability&lt;/strong&gt; and &lt;strong&gt;efficiency&lt;/strong&gt; of algorithms.</source>
          <target state="translated">通过实验，我们知道在线购物的规模要比在线下载更好。 理解大的O符号非常重要，因为它可以帮助您分析算法的&lt;strong&gt;可伸缩性&lt;/strong&gt;和&lt;strong&gt;效率&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e19041281d0dd99d852a13a94e9ffca8398dc327" translate="yes" xml:space="preserve">
          <source>Grows as a square, where &lt;em&gt;n&lt;/em&gt; is the length of the side of a square.  This is the same growth rate as the &quot;network effect&quot;, where everyone in a network might know everyone else in the network.  Growth is expensive.  Most scalable solutions cannot use algorithms with this level of complexity without doing significant gymnastics.  This generally applies to all other polynomial complexities - &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; - as well.</source>
          <target state="translated">生长为正方形，其中&lt;em&gt;n&lt;/em&gt;是正方形边的长度。 这是与&amp;ldquo;网络效应&amp;rdquo;相同的增长率，网络中的每个人都可能认识网络中的其他每个人。 增长是昂贵的。 大多数可伸缩解决方案在不进行大量体操操作的情况下就无法使用具有这种复杂性级别的算法。 这通常也适用于所有其他多项式复杂度&lt;strong&gt;-O（ &lt;em&gt;n&lt;/em&gt; &lt;sup&gt;k&lt;/sup&gt; ）&lt;/strong&gt; -。</target>
        </trans-unit>
        <trans-unit id="36f6624b28e90d7b5439820ddf4b791141546e8a" translate="yes" xml:space="preserve">
          <source>Here comes big O, to tell us just how hard this math is.</source>
          <target state="translated">大O来了,告诉我们这道数学题有多难。</target>
        </trans-unit>
        <trans-unit id="5e58c431d0ce6f70610939ce98c97531f57d61cc" translate="yes" xml:space="preserve">
          <source>Here is another thing we can recognize visually:</source>
          <target state="translated">这里还有一件事,我们可以直观地认识到。</target>
        </trans-unit>
        <trans-unit id="4ab646045794b15182529717713fd6393652d11a" translate="yes" xml:space="preserve">
          <source>Here is the Wikipedia article: &lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;https://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;</source>
          <target state="translated">这是Wikipedia文章： &lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;https&lt;/a&gt; : //en.wikipedia.org/wiki/Big_O_notation</target>
        </trans-unit>
        <trans-unit id="001cff8786bd37eff234c46bb9b1b48e0988d759" translate="yes" xml:space="preserve">
          <source>Here is the plain English bestiary I tend to use when explaining the common varieties of Big-O</source>
          <target state="translated">以下是我在解释大O的常见品种时,经常使用的通俗的英文bestiary,我倾向于用它来解释。</target>
        </trans-unit>
        <trans-unit id="43e41c55f998f736fd0e01106d1006e4f8370dd7" translate="yes" xml:space="preserve">
          <source>Here's an example where we have N T-shirts which we want to dry. We'll &lt;em&gt;assume&lt;/em&gt; it's incredibly quick to get them in the drying position (i.e. the human interaction is negligible). That's not the case in real life, of course...</source>
          <target state="translated">这是一个示例，其中我们有N件T恤要干燥。 我们&lt;em&gt;假设&lt;/em&gt;将它们置于干燥位置非常快（即，与人的互动可以忽略不计）。 当然，现实生活中并非如此...</target>
        </trans-unit>
        <trans-unit id="c5af9b41639623efa7baf5be1ecd016aee231408" translate="yes" xml:space="preserve">
          <source>Here, the smallest recognizable outline you can draw is what matters; a triangle is a two dimensional shape (0.5 A^2), just like a square is a two-dimensional shape (A^2); the constant factor of two here remains in the asymptotic ratio between the two, however, we ignore it like all factors... (There are some unfortunate nuances to this technique I don't go into here; it can mislead you.)</source>
          <target state="translated">在这里,你能画出的最小可识别的轮廓才是最重要的;三角形是一个二维的形状(0.5 A^2),就像正方形是一个二维的形状(A^2)一样;这里的常数系数2仍然是二者之间的渐变比,然而,我们像所有的系数一样忽略它.........(这个技巧有一些不幸的细微差别,我在这里就不多说了,它可能会误导你。)</target>
        </trans-unit>
        <trans-unit id="1d2dc7900c252d720e30b05b14c6ffb4be0d882b" translate="yes" xml:space="preserve">
          <source>Hmmm.  There may be a rule in there, I think.  To make big tasks small, break them up.</source>
          <target state="translated">嗯。我想,这里面可能有一个规则。要想把大的任务做小,就把它们拆散。</target>
        </trans-unit>
        <trans-unit id="9c06c7ddd3fdd4ff139df20d27d2e5e8fe694d25" translate="yes" xml:space="preserve">
          <source>How can we sort this deck?  I have a plan.</source>
          <target state="translated">我们怎么才能把这副牌子分类呢?我有个计划。</target>
        </trans-unit>
        <trans-unit id="b80eb8a9b1ad872be834851527556c78aaff922e" translate="yes" xml:space="preserve">
          <source>How do I know Quick Sort is less work?  I know that O(n log n) is less than O(n squared).  The O's are more small, so Quick Sort is less work!</source>
          <target state="translated">我怎么知道Quick Sort的工作量少?我知道O(n log n)比O(n平方)小。O更小,所以Quick Sort的工作量更少!</target>
        </trans-unit>
        <trans-unit id="ce3005d8e3f4f0dd8dec37227d002f3f7de3b04c" translate="yes" xml:space="preserve">
          <source>How much more hard would it be?  How much more work would I have to do?  Do I need more or less steps?</source>
          <target state="translated">那会有多难?我需要做的工作会增加多少?我需要的步骤是多还是少?</target>
        </trans-unit>
        <trans-unit id="a4daa40555f4cdbc41aa891d89c4fbcc8ad0f51b" translate="yes" xml:space="preserve">
          <source>However, for very large numbers of people, the linear term &lt;code&gt;N&lt;/code&gt; is dwarfed and effectively contributes 0 to the ratio (in the chart: the fraction of empty boxes on the diagonal over total boxes gets smaller as the number of participants becomes larger). Therefore the scaling behavior is &lt;code&gt;order N&amp;sup2;&lt;/code&gt;, or the number of handshakes &quot;grows like N&amp;sup2;&quot;.</source>
          <target state="translated">但是，对于非常多的人，线性项 &lt;code&gt;N&lt;/code&gt; 相形见and，并且有效地使比率为0（在图表中：随着参与者数量的增加，对角线上的空框在总框上的比例会变小）。 因此，缩放行为为 &lt;code&gt;order N&amp;sup2;&lt;/code&gt; ，或者握手次数&amp;ldquo;像N&amp;sup2;一样增长&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9f6b7a8c3e101e7571405d26663a1a4d8aefb762" translate="yes" xml:space="preserve">
          <source>I break up the deck in parts, and sort each part, more small and more small, and at some time I have no more work to do.  Now this may seem slow, with all the rules.  But trust me, it is not slow at all.  It is much less work than the first way to sort things!</source>
          <target state="translated">我把牌子分成若干部分,每一部分都要分门别类,越分越小,到了一定的时候,我就没有什么事可做了。现在看来,这样做可能会显得很慢,有很多规则。但相信我,它一点也不慢。它比第一种分类方法要省事得多!</target>
        </trans-unit>
        <trans-unit id="819fcf72178711a5bc5e8d2f9d5dd724ea8d6e5e" translate="yes" xml:space="preserve">
          <source>I care lots for big O.  Why?  I do not like to work!  No one likes to work.  That is why we all love big O!  He tells us how fast we can work.  He helps us think of how hard work is.</source>
          <target state="translated">我很关心大O,为什么?因为我不喜欢工作!没有人喜欢工作 所以我们都喜欢大O!他告诉我们工作的速度有多快 他帮助我们思考工作有多辛苦。</target>
        </trans-unit>
        <trans-unit id="482a49f03db93f2d8f5d5daa020b481189471c57" translate="yes" xml:space="preserve">
          <source>I do not like to go to work.  I do not like to spend time at work.  If I had my way, I would like just to play, and do fun things.  Do you feel the same as I do?</source>
          <target state="translated">我不喜欢去上班。我不喜欢把时间花在工作上。如果我有办法的话,我只喜欢玩,做一些有趣的事情。你和我有同样的感受吗?</target>
        </trans-unit>
        <trans-unit id="ad52c5fb30262f15e8d3a80bd1081996754096a0" translate="yes" xml:space="preserve">
          <source>I do not want to add right now.  I just want to think on how hard it might be to add that much.  And, I hope, to play as soon as I can.</source>
          <target state="translated">我现在不想加,也不想加。我只是想,想一想,要加那么多可能有多难。而且,我希望,能尽快玩下去。</target>
        </trans-unit>
        <trans-unit id="a8b731da95dde2cc32a2a652b9321f54f34bd44a" translate="yes" xml:space="preserve">
          <source>I found a really great explanation about big O notation especially for a someone who's not much into mathematics.</source>
          <target state="translated">我发现一个关于大O记号法的解释非常好,特别是对于一个不怎么懂数学的人来说。</target>
        </trans-unit>
        <trans-unit id="dab9c64b9a46ec0457c94246c45926dfd570f6b3" translate="yes" xml:space="preserve">
          <source>I have a deck of cards.  I did sort them.  You helped.  Thanks.</source>
          <target state="translated">我有一副牌。我确实把它们分类了。你帮了我的忙 谢谢你的帮助</target>
        </trans-unit>
        <trans-unit id="3f1e4073256cafed9c07f32d545cc56213aba0e9" translate="yes" xml:space="preserve">
          <source>I have ten cards.  And, most of the time -- that is, if I don&amp;rsquo;t have lots of luck -- I must go through the whole deck up to ten times, with up to ten card swaps each time through the deck.</source>
          <target state="translated">我有十张卡。 而且，在大多数情况下（也就是说，如果我运气不佳），我必须经过整个卡座多达十次，每次通过卡座最多要交换十张卡。</target>
        </trans-unit>
        <trans-unit id="0ec03029a11a10972a0136154949cfcba5dbed69" translate="yes" xml:space="preserve">
          <source>I hope this is as simple as you want it.</source>
          <target state="translated">我希望这是你所希望的那样简单。</target>
        </trans-unit>
        <trans-unit id="53ae10c16d270153bdbf8c1a9e6f93c880d6182f" translate="yes" xml:space="preserve">
          <source>I will look at each pair of cards, pair by pair, through the deck, from first to last.  If the first card in one pair is big and the next card in that pair is small, I swap them.  Else, I go to the next pair, and so on and so on... and soon, the deck is done.</source>
          <target state="translated">我会把每一副牌从头到尾,逐对看一遍。如果这对牌中的第一张牌是大牌,而这对牌中的下一张牌是小牌,我就把它们换掉。否则,我就换到下一对,以此类推...........不一会儿,这副牌就完成了。</target>
        </trans-unit>
        <trans-unit id="b9d44117c5235dda1f72fad7eec883c624ba20a4" translate="yes" xml:space="preserve">
          <source>I'd prefer as little formal definition as possible and simple mathematics.</source>
          <target state="translated">我更希望尽可能少的正式定义和简单的数学。</target>
        </trans-unit>
        <trans-unit id="f6bbf69b7602636fdd09cc6e847b5d115ba9d058" translate="yes" xml:space="preserve">
          <source>I've more simpler way to understand the time complexity
he most common metric for calculating time complexity is Big O notation. This removes all constant factors so that the running time can be estimated in relation to N as N approaches infinity. In general you can think of it like this:</source>
          <target state="translated">我有一个更简单的方法来理解时间复杂度,他最常用的计算时间复杂度的度量是大O记号。这种方法去掉了所有的常数因素,这样当N接近无穷大时,运行时间就可以估算出与N的关系。一般来说,你可以这样想。</target>
        </trans-unit>
        <trans-unit id="3c93039db5b8dea862d7aba7ac7a736523f2e466" translate="yes" xml:space="preserve">
          <source>If an algorithm is O(n) then the time/space will increase at the same rate as its input.</source>
          <target state="translated">如果一个算法是O(n),那么时间空间将以与输入相同的速度增加。</target>
        </trans-unit>
        <trans-unit id="b93496435ccac02920ca75abbec4e210c6e1376f" translate="yes" xml:space="preserve">
          <source>If an algorithm is O(n&lt;sup&gt;2&lt;/sup&gt;) then the time/space increase at the rate of its input squared.</source>
          <target state="translated">如果算法为O（n &lt;sup&gt;2&lt;/sup&gt; ），则时间/空间将以其输入平方的速率增加。</target>
        </trans-unit>
        <trans-unit id="42bcc6138049b638ae7478e9aaa755e8a5fae576" translate="yes" xml:space="preserve">
          <source>If some values are effectively bounded due to some hidden fact (e.g. the average human name is softly bounded at perhaps 40 letters, and human age is softly bounded at around 150). You can also impose bounds on your input to effectively make terms constant.</source>
          <target state="translated">如果某些值由于一些隐藏的事实而被有效地约束了(例如,人类的平均姓名的软约束或许是40个字母,而人类的年龄是150左右的软约束)。你也可以对输入进行约束,以有效地使条款不变。</target>
        </trans-unit>
        <trans-unit id="eadacee139f919b0ca67cb2be538cca322087b44" translate="yes" xml:space="preserve">
          <source>If the above doesn't make sense, then you don't have a compatible intuitive notion of infinity in your head, and you should probably disregard all of the above; the only way I know to make these ideas rigorous, or to explain them if they aren't already intuitively useful, is to first teach you big O notation or something similar. (although, once you well understand big O notation in the future, it may be worthwhile to revisit these ideas)</source>
          <target state="translated">如果上面的内容没有意义,那么你的脑子里就没有一个与之相匹配的无穷大的直观概念,你可能应该无视上面的所有内容;我所知道的唯一能让这些想法变得严谨的方法,或者说,如果这些想法还没有直观上的作用,那么解释这些想法的唯一方法就是先教你大O记号法或者类似的东西。(虽然,一旦你将来很好地理解了大O记号法,这些想法可能值得你重新审视)</target>
        </trans-unit>
        <trans-unit id="fc0f303936e49cce64dec3515e323c65eb23edc5" translate="yes" xml:space="preserve">
          <source>If the loop has finished without finding the key, return False.</source>
          <target state="translated">如果循环结束后没有找到密钥,则返回False。</target>
        </trans-unit>
        <trans-unit id="1f90ef8cce8695b2d4c7c46d902314ff3d88ced2" translate="yes" xml:space="preserve">
          <source>If we do something slightly complicated, you might still be able to imagine visually what's going on:</source>
          <target state="translated">如果我们做一些稍微复杂的事情,你可能还能直观地想象出是怎么回事。</target>
        </trans-unit>
        <trans-unit id="498ad5ebf90abce6c7640e5178604bd12d2cb5dd" translate="yes" xml:space="preserve">
          <source>If we do something very complicated, such as with a recursive function or divide-and-conquer algorithm, &lt;strike&gt;you can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem&quot;&gt;Master Theorem&lt;/a&gt; (usually works), or in ridiculous cases the Akra-Bazzi Theorem (almost always works)&lt;/strike&gt; you look up the running time of your algorithm on Wikipedia.</source>
          <target state="translated">如果我们执行非常复杂的操作（例如使用递归函数或分治算法），则&lt;strike&gt;可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem&quot;&gt;主定理&lt;/a&gt; （通常有效），或者在荒谬的情况下，可以通过Akra-Bazzi定理（几乎总是有效）&lt;/strike&gt;来查找您的算法在Wikipedia上的运行时间。</target>
        </trans-unit>
        <trans-unit id="f340d38ad5275f65c3f3c98f00a52fd253da01b5" translate="yes" xml:space="preserve">
          <source>If we have two 100-digit numbers we need to do 10,000 multiplications and 200 adds.  For two one million digit numbers we need to do one trillion (10&lt;sup&gt;12&lt;/sup&gt;) multiplications and two million adds.</source>
          <target state="translated">如果我们有两个100位数字，则需要进行10,000次乘法和200次加法。 对于两个一百万个数字，我们需要进行一万亿（10 &lt;sup&gt;12&lt;/sup&gt; ）乘法和200万加法。</target>
        </trans-unit>
        <trans-unit id="7a7797f63ba1469547a1c7c05a0e4651c75d6f7f" translate="yes" xml:space="preserve">
          <source>If we use a simple structure called a hash table (an instant-speed lookup table, also known as a hashmap or dictionary), we pay a small cost by preprocessing everything in &lt;code&gt;O(N)&lt;/code&gt; time. Thereafter, it only takes constant time on average to look up something by its key (in this case, our key is the latitude and longitude coordinates, rounded into a grid; we search the adjacent gridspaces of which there are only 9, which is a constant).</source>
          <target state="translated">如果我们使用称为哈希表（即时速度查找表，也称为哈希图或字典）的简单结构，则通过在 &lt;code&gt;O(N)&lt;/code&gt; 时间内对所有内容进行预处理，我们将付出很小的代价。 此后，平均仅需花费固定时间即可通过其键查找内容（在这种情况下，我们的键是经度和纬度坐标，四舍五入为一个网格；我们搜索相邻网格空间中只有9个，这是一个不变）。</target>
        </trans-unit>
        <trans-unit id="532d60c07f8308239c74d78cfd8bd61382460fae" translate="yes" xml:space="preserve">
          <source>If you have 3 towns A, B and C with roads between all pairs then you could go:</source>
          <target state="translated">如果你有3个城镇A、B、C三个镇,中间都有路,那么你可以去。</target>
        </trans-unit>
        <trans-unit id="85e55a9c0f7521ee220edb5e820f851626c00f8e" translate="yes" xml:space="preserve">
          <source>If you have a suitable notion of infinity in your head, then there is a very brief description:</source>
          <target state="translated">如果你的脑子里有一个合适的无限的概念,那么有一个很简单的描述。</target>
        </trans-unit>
        <trans-unit id="a391595810bc224de5ec62db4d75a23a1dd6b419" translate="yes" xml:space="preserve">
          <source>If you have to sort a deck, what is the best way?  Well, you can do what you want, but I would choose Quick Sort.</source>
          <target state="translated">如果你要对一副牌子进行排序,最好的方法是什么?嗯,你可以按照你的想法来,但我会选择快速排序。</target>
        </trans-unit>
        <trans-unit id="c8f0c3e48ae6bc0a6ae30c3840b7e3d5da5a2114" translate="yes" xml:space="preserve">
          <source>If you only needed to do this once, it would not be a problem to have to do the naive method of &lt;code&gt;O(N)&lt;/code&gt; work only once, but if you want to do it many times (in this case, &lt;code&gt;N&lt;/code&gt; times, once for each segment), we'd have to do &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; work, or 1000000&amp;sup2;=1000000000000 operations. Not good (a modern computer can perform about a billion operations per second).</source>
          <target state="translated">如果只需要执行一次，那么只需要一次执行 &lt;code&gt;O(N)&lt;/code&gt; 的朴素方法就没问题了，但是如果您想执行多次（在这种情况下，可以执行 &lt;code&gt;N&lt;/code&gt; 次，那么每个段），我们必须做 &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; 工作，或1000000&amp;sup2;= 1000000000000运算。 不好（一台现代计算机每秒可以执行约十亿次操作）。</target>
        </trans-unit>
        <trans-unit id="b0ce2012a9d7c727364cedfce54d754ac83295bd" translate="yes" xml:space="preserve">
          <source>If you read the &quot;Oh&quot; as meaning &quot;on the order of&quot; or &quot;approximately&quot; you will not go too far wrong. (I think the choice of the Big-Oh might have been an attempt at humour).</source>
          <target state="translated">如果你把 &quot;哦 &quot;读成 &quot;差不多 &quot;或 &quot;大约 &quot;的意思,就不会错得太离谱。我想,选择 &quot;大Oh &quot;可能是一种幽默的尝试)。</target>
        </trans-unit>
        <trans-unit id="879d10b4ee33a790e641d1a246a7c4921f058217" translate="yes" xml:space="preserve">
          <source>If you upgrade to a computer that can run your algorithm twice as fast, big O notation won't notice that. Constant factor improvements are too small to even be noticed in the scale that big O notation works with. Note that this is an intentional part of the design of big O notation.</source>
          <target state="translated">如果你升级到可以运行两倍于你的算法的计算机上,大O记号就不会注意到这一点。恒定系数的改进太小了,甚至在大O记数法的工作范围内都不会被注意到。请注意,这是大O符号设计的一个有意的部分。</target>
        </trans-unit>
        <trans-unit id="4ca1f62a00fa89bcd7628fd712226caf431517e2" translate="yes" xml:space="preserve">
          <source>If you're sorting something like 5 elements, you don't want to use the speedy &lt;code&gt;O(N log(N))&lt;/code&gt; quicksort; you want to use insertion sort, which happens to perform well on small inputs. These situations often come up in divide-and-conquer algorithms, where you split up the problem into smaller and smaller subproblems, such as recursive sorting, fast Fourier transforms, or matrix multiplication.</source>
          <target state="translated">如果您要对5个元素进行排序，则不希望使用快速的 &lt;code&gt;O(N log(N))&lt;/code&gt; 快速排序。 您想使用插入排序，而插入排序恰好在较小的输入上表现良好。 这些情况通常出现在分治法中，您可以将问题分解为越来越小的子问题，例如递归排序，快速傅立叶变换或矩阵乘法。</target>
        </trans-unit>
        <trans-unit id="b1d27a710e5b2deff8083ff199e610d9f97f11b2" translate="yes" xml:space="preserve">
          <source>In Big-O terms this is &lt;strong&gt;O(log n)&lt;/strong&gt; or &lt;strong&gt;logarithmic complexity&lt;/strong&gt;.  Now the logarithm in question could be ln (base e), log&lt;sub&gt;10&lt;/sub&gt;, log&lt;sub&gt;2&lt;/sub&gt; or some other base.  It doesn't matter it's still O(log n) just like O(2n&lt;sup&gt;2&lt;/sup&gt;) and O(100n&lt;sup&gt;2&lt;/sup&gt;) are still both O(n&lt;sup&gt;2&lt;/sup&gt;).</source>
          <target state="translated">用Big-O术语来说，这是&lt;strong&gt;O（log n）&lt;/strong&gt;或&lt;strong&gt;对数复杂度&lt;/strong&gt; 。 现在所讨论的对数可以是ln（底数e），log &lt;sub&gt;10&lt;/sub&gt; ，log &lt;sub&gt;2&lt;/sub&gt;或其他一些底数。 就像O（2n &lt;sup&gt;2&lt;/sup&gt; ）和O（100n &lt;sup&gt;2&lt;/sup&gt; ）都是O（n &lt;sup&gt;2&lt;/sup&gt; ）一样，它仍然是O（log n）。</target>
        </trans-unit>
        <trans-unit id="88e50d90d1750553c39e16c7f8930e4119cfca57" translate="yes" xml:space="preserve">
          <source>In CS, the set of steps to accomplish a task is called algorithms.</source>
          <target state="translated">在CS中,完成一个任务的一系列步骤被称为算法。</target>
        </trans-unit>
        <trans-unit id="d95044d68f300f358a3a51cf89c9474f6f16e349" translate="yes" xml:space="preserve">
          <source>In Terminology, Big O notation is used to describe the performance or complexity of an algorithm.</source>
          <target state="translated">在Terminology中,大O符号用于描述算法的性能或复杂度。</target>
        </trans-unit>
        <trans-unit id="d65e5f9e362ebe36bedba5b57e018e3acbfc0c7b" translate="yes" xml:space="preserve">
          <source>In actuality there are 3 possibilities.</source>
          <target state="translated">实际上,实际上有3种可能。</target>
        </trans-unit>
        <trans-unit id="07046d757b1f2b48e849414a4e96d5ff13dade7a" translate="yes" xml:space="preserve">
          <source>In addition, Big O establishes the worst-case or measure the Upper-Bound steps.</source>
          <target state="translated">此外,大O确立了最坏的情况或衡量上界的步骤。</target>
        </trans-unit>
        <trans-unit id="baa93a55b3140739514a5c40f8e2cdd9810a3c85" translate="yes" xml:space="preserve">
          <source>In all cases, prefer algorithms higher up on the list to those lower on the list.  However, the cost of moving to a more expensive complexity class varies significantly.</source>
          <target state="translated">在所有情况下,优先选择列表中较高的算法,而不是列表中较低的算法。然而,转到复杂度较高的类别,其成本差异很大。</target>
        </trans-unit>
        <trans-unit id="30b960998b211299ef1c91dabf4d8dd22d39e434" translate="yes" xml:space="preserve">
          <source>In big O notation this is written as</source>
          <target state="translated">用大O记号法写成</target>
        </trans-unit>
        <trans-unit id="64aaef6ec6705e0f6426bbcc5b5fde04c862b7d5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;O(...)&lt;/code&gt; is the most useful one because we often care about worst-case behavior. If &lt;code&gt;f(x)&lt;/code&gt; represents something &quot;bad&quot; like the processor or memory usage, then &quot;&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt;&quot; means &quot;&lt;code&gt;upperbound&lt;/code&gt; is the worst-case scenario of processor/memory usage&quot;.</source>
          <target state="translated">通常， &lt;code&gt;O(...)&lt;/code&gt; 是最有用的一个，因为我们经常关心最坏的情况。 如果 &lt;code&gt;f(x)&lt;/code&gt; 代表处理器或内存使用情况等&amp;ldquo;坏&amp;rdquo;的情况，则&amp;ldquo; &lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; &amp;rdquo;表示&amp;ldquo; &lt;code&gt;upperbound&lt;/code&gt; 是处理器/内存使用情况的最坏情况&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e9fddaf6556848124995ffd1ed9ddc0b950170ab" translate="yes" xml:space="preserve">
          <source>In general, doing something with every item in one dimension is linear, doing something with every item in two dimensions is quadratic, and dividing the working area in half is logarithmic. There are other Big O measures such as cubic, exponential, and square root, but they're not nearly as common. Big O notation is described as O (  ) where  is the measure. The quicksort algorithm would be described as O ( N * log ( N ) ).</source>
          <target state="translated">一般情况下,用一维的每项做一维的东西是线性的,用二维的每项做一维的东西是二次元的,把工作面积分成两半是对数。还有其他的大O度量法,如立方体、指数法、平方根等,但都不太常见。大O的记数法被描述为O(),其中O()是度量衡。quicksort算法将被描述为O(N*log(N))。</target>
        </trans-unit>
        <trans-unit id="63a8eaf6bf07c1752a4bb48aa0c8cfc63edc138d" translate="yes" xml:space="preserve">
          <source>In general, our goal will be to find or structure an algorithm &lt;strong&gt;A&lt;/strong&gt; in such a way that it will have a function &lt;code&gt;X(n)&lt;/code&gt; that returns as low a number as possible.</source>
          <target state="translated">通常，我们的目标是找到或构造算法&lt;strong&gt;A&lt;/strong&gt; ，使其具有一个函数 &lt;code&gt;X(n)&lt;/code&gt; ，该函数返回尽可能少的数字。</target>
        </trans-unit>
        <trans-unit id="7de7cd6bc8a2b03ecb0a68fecd7a6051d0934bd9" translate="yes" xml:space="preserve">
          <source>In many cases the &quot;O&quot; of an algorithm will fall into one of the following cases:</source>
          <target state="translated">在很多情况下,算法的 &quot;O &quot;会属于以下情况之一。</target>
        </trans-unit>
        <trans-unit id="a763bcaebb1bc5faa9ba3036763e8474d16f2b73" translate="yes" xml:space="preserve">
          <source>In one sentence: As the size of your job goes up, how much longer does it take to complete it?</source>
          <target state="translated">用一句话来说。随着工作规模的扩大,你的工作要多久才能完成?</target>
        </trans-unit>
        <trans-unit id="4bfe8a12e0a2be2aee41e7617d2857524d177ee2" translate="yes" xml:space="preserve">
          <source>In other words where g(n) is the running time of your algorithm, we say that g(n) = O(f(n)) when g(n) &amp;lt;= c*f(n) when n &amp;gt; k, where c and k are some constants.</source>
          <target state="translated">换句话说，其中g（n）是算法的运行时间，我们说g（n）= O（f（n）），当g（n）&amp;lt;= c * f（n），当n&amp;gt; k时， c和k是一些常数。</target>
        </trans-unit>
        <trans-unit id="4e02f4f6e256066f1d4123d571431ca1ed48ec48" translate="yes" xml:space="preserve">
          <source>In other words, in plain English: &lt;em&gt;f&lt;/em&gt;(x) = O(&lt;em&gt;g&lt;/em&gt;(x)), x &amp;rarr; a, means that in a neighborhood of a, &lt;em&gt;f&lt;/em&gt; decomposes into the product of &lt;em&gt;g&lt;/em&gt; and some bounded function.</source>
          <target state="translated">换句话说，用简单的英语来说： &lt;em&gt;f&lt;/em&gt; （x）= O（ &lt;em&gt;g&lt;/em&gt; （x）），x&amp;rarr;a，表示在a的邻域中， &lt;em&gt;f&lt;/em&gt;分解为&lt;em&gt;g&lt;/em&gt;和某些有界函数的乘积。</target>
        </trans-unit>
        <trans-unit id="68079fad5ce0cb40c968faed5e24541715996023" translate="yes" xml:space="preserve">
          <source>In practice, even among algorithms which have the same or similar asymptotic performance, their relative merit may actually be driven by other things, such as: other performance factors (quicksort and mergesort are both &lt;code&gt;O(N log(N))&lt;/code&gt;, but quicksort takes advantage of CPU caches); non-performance considerations, like ease of implementation; whether a library is available, and how reputable and maintained the library is.</source>
          <target state="translated">实际上，即使在具有相同或相似渐近性能的算法中，它们的相对价值实际上也可能受其他因素驱动，例如：其他性能因素（quicksort和mergesort均为 &lt;code&gt;O(N log(N))&lt;/code&gt; ，但quicksort需要CPU缓存的优势）； 非性能方面的考虑，例如易于实施； 库是否可用以及库的信誉和维护程度。</target>
        </trans-unit>
        <trans-unit id="84ff32c19c195c6e0453458a4af8916d40d60004" translate="yes" xml:space="preserve">
          <source>In this new way to sort a deck, we do not check pairs of cards the way we did a while ago.  Here are your new rules to sort this deck:</source>
          <target state="translated">在这个新的排序方式中,我们不再像前段时间那样对牌组进行检查。下面是这副牌组的新规则。</target>
        </trans-unit>
        <trans-unit id="c9da7190c61b8b40d9ee9d7282639dd113f829a6" translate="yes" xml:space="preserve">
          <source>Is N * log ( N ). The running time consists of N loops (iterative or recursive) that are logarithmic, thus the algorithm is a combination of linear and logarithmic.</source>
          <target state="translated">是N*log(N )。运行时间由N个循环(迭代或递归)组成,这些循环都是对数,因此算法是线性和对数的组合。</target>
        </trans-unit>
        <trans-unit id="998b8dec061b127d4bd37309e498d87df1954ca7" translate="yes" xml:space="preserve">
          <source>Is constant. The running time of the statement will not change in relation to N</source>
          <target state="translated">是常数。语句的运行时间不会随着N的变化而变化。</target>
        </trans-unit>
        <trans-unit id="7c262ad477a4821f4fb1c7733312befe0c8fe05a" translate="yes" xml:space="preserve">
          <source>Is it more or less fast than the first sort?  Big O, please help!</source>
          <target state="translated">是比第一种快还是慢?大O,请帮帮忙!</target>
        </trans-unit>
        <trans-unit id="29e49e4fc142b2d0f2b1a400df6ab96e4a918158" translate="yes" xml:space="preserve">
          <source>Is linear. The running time of the loop is directly proportional to N. When N doubles, so does the running time.</source>
          <target state="translated">是线性的。循环的运行时间与N成正比,当N增加一倍时,循环的运行时间也会增加。</target>
        </trans-unit>
        <trans-unit id="0669d4a8187abfada364d0bb775de3933241efd7" translate="yes" xml:space="preserve">
          <source>Is logarithmic. The running time of the algorithm is proportional to the number of times N can be divided by 2. This is because the algorithm divides the working area in half with each iteration.</source>
          <target state="translated">是对数。算法的运行时间与N可除以2的次数成正比,这是因为算法每迭代一次就把工作面积分成两半。</target>
        </trans-unit>
        <trans-unit id="f9cef10a1858aa5a865ebf26c425725395a40d0a" translate="yes" xml:space="preserve">
          <source>Is quadratic. The running time of the two loops is proportional to the square of N. When N doubles, the running time increases by N * N.</source>
          <target state="translated">是二次方程。两个回路的运行时间与n的平方成正比,当n增加一倍时,运行时间增加n*n。</target>
        </trans-unit>
        <trans-unit id="1189cb04bbafbceb75864abdc92eb47236ec61c3" translate="yes" xml:space="preserve">
          <source>Is there a more fast way to sort the cards?  Can big O help us?</source>
          <target state="translated">有没有更快捷的分类卡的方法?大O能帮到我们吗?</target>
        </trans-unit>
        <trans-unit id="bdcb0de02955e320abf0c31ab2a8744682cbbe08" translate="yes" xml:space="preserve">
          <source>It is very difficult to measure the speed of software programs, and when we try, the answers can be very complex and filled with exceptions and special cases. This is a big problem, because all those exceptions and special cases are distracting and unhelpful when we want to compare two different programs with one another to find out which is &quot;fastest&quot;.</source>
          <target state="translated">衡量软件程序的速度是非常困难的,当我们尝试时,答案可能非常复杂,而且充满了异常和特殊情况。这是一个很大的问题,因为当我们想把两个不同的软件程序进行比较,看看哪一个是 &quot;最快的 &quot;时,所有这些例外和特殊情况都会让人分心,而且无济于事。</target>
        </trans-unit>
        <trans-unit id="52df2acf675e9663e6643a99463b7ca8b662796f" translate="yes" xml:space="preserve">
          <source>It shows how an algorithm scales based on input size.</source>
          <target state="translated">它显示了一个算法是如何根据输入的大小进行缩放的。</target>
        </trans-unit>
        <trans-unit id="293ad219691b62a126a8db817cbbea70a32b0c5f" translate="yes" xml:space="preserve">
          <source>It's as if the empty boxes on the diagonal of the chart (N*(N-1)/2 checkmarks) weren't even there (N&lt;sup&gt;2&lt;/sup&gt; checkmarks asymptotically).</source>
          <target state="translated">好像图表对角线上的空白框（N *（N-1）/ 2个复选标记）甚至没有（N &lt;sup&gt;2个复选&lt;/sup&gt;标记渐近）一样。</target>
        </trans-unit>
        <trans-unit id="ec70bfe19e1f4d33f015bf1ed0c0eb3f05117561" translate="yes" xml:space="preserve">
          <source>It's worthwhile at this point to explain that Big O can be used to determine three cases with an algorithm:</source>
          <target state="translated">在这一点上,值得说明的是,大O可以用一个算法来判断三种情况。</target>
        </trans-unit>
        <trans-unit id="29cba760a7e3ba133866ed85852ba33956337368" translate="yes" xml:space="preserve">
          <source>Iterating on each item in the list, if it's the key then return True,</source>
          <target state="translated">对列表中的每一个项目进行迭代,如果是密钥,则返回True。</target>
        </trans-unit>
        <trans-unit id="53da104c94a561d37e7b0bbeefcf47818dc3f2be" translate="yes" xml:space="preserve">
          <source>Keep in mind that big-O is not the whole story. You can drastically speed up some algorithms by using caching, making them cache-oblivious, avoiding bottlenecks by working with RAM instead of disk, using parallelization, or doing work ahead of time -- these techniques are often &lt;em&gt;independent&lt;/em&gt; of the order-of-growth &quot;big-O&quot; notation, though you will often see the number of cores in the big-O notation of parallel algorithms.</source>
          <target state="translated">请记住，大O并不是全部。 您可以通过使用缓存来大大加快某些算法的速度，使它们可以忽略缓存，通过使用RAM而不是磁盘，使用并行化或提前进行工作来避免瓶颈-这些技术通常与增长顺序&lt;em&gt;无关&lt;/em&gt; 。尽管您经常会在并行算法的big-O表示法中看到内核数，但是使用&amp;ldquo; big-O&amp;rdquo;表示法。</target>
        </trans-unit>
        <trans-unit id="bc8c7b0e9f3998b53c3c3a45f086e6279211fb80" translate="yes" xml:space="preserve">
          <source>Let's assume that the addition of these numbers is the most expensive operation in this algorithm. It stands to reason that to add these two numbers together we have to add together 6 digits (and possibly carry a 7th). If we add two 100 digit numbers together we have to do 100 additions.  If we add &lt;strong&gt;two&lt;/strong&gt; 10,000 digit numbers we have to do 10,000 additions.</source>
          <target state="translated">假设这些数字的加法是该算法中最昂贵的操作。 完全有理由将这两个数字相加，我们必须将6个数字相加（可能带有7位）。 如果我们将两个100位数相加，则必须相加100。 如果我们将&lt;strong&gt;两个&lt;/strong&gt; 10,000位数字相加，则必须进行10,000次加法。</target>
        </trans-unit>
        <trans-unit id="0e3d7a37946e8fa9bb0f4b9c5caa0b1e6214f02f" translate="yes" xml:space="preserve">
          <source>Let's say your algorithm dealing with the problem depends on some 'factors', for example let's make it N and X.</source>
          <target state="translated">假设你处理问题的算法取决于一些 &quot;因素&quot;,例如让我们把它变成N和X。</target>
        </trans-unit>
        <trans-unit id="e09ce0464689a88f3f8747581ffb2d480edd57b6" translate="yes" xml:space="preserve">
          <source>Logarithms</source>
          <target state="translated">Logarithms</target>
        </trans-unit>
        <trans-unit id="0f768f66724b1ab90c8b65c4b90be682a8ff30a2" translate="yes" xml:space="preserve">
          <source>Logarithms are slightly trickier to explain so I'll use a common
  example:</source>
          <target state="translated">对数的解释略显棘手,所以我用一个常见的例子来说明。</target>
        </trans-unit>
        <trans-unit id="818cd71ba05516b0c7d38db784302c45d9d62431" translate="yes" xml:space="preserve">
          <source>More precisely &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; is used to express the asymptotic behavior of a function. That means how the function behaves as it approaches infinity.</source>
          <target state="translated">更准确地说， &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O表示法&lt;/a&gt;用于表达函数的渐近行为。 这意味着函数在接近无穷大时的行为。</target>
        </trans-unit>
        <trans-unit id="53558434954a9542c40a6931db4c48fcfc391a05" translate="yes" xml:space="preserve">
          <source>Most of the time, people don't realize that there's more than one variable at work. For example, in a string-search algorithm, your algorithm may take time &lt;code&gt;O([length of text] + [length of query])&lt;/code&gt;, i.e. it is linear in two variables like &lt;code&gt;O(N+M)&lt;/code&gt;. Other more naive algorithms may be &lt;code&gt;O([length of text]*[length of query])&lt;/code&gt; or &lt;code&gt;O(N*M)&lt;/code&gt;. Ignoring multiple variables is one of the most common oversights I see in algorithm analysis, and can handicap you when designing an algorithm.</source>
          <target state="translated">大多数时候，人们不会意识到工作中存在多个变量。 例如，在字符串搜索算法中，您的算法可能需要时间 &lt;code&gt;O([length of text] + [length of query])&lt;/code&gt; ，即，它在两个变量（例如 &lt;code&gt;O(N+M)&lt;/code&gt; )中是线性的。 其他更幼稚的算法可能是 &lt;code&gt;O([length of text]*[length of query])&lt;/code&gt; 或 &lt;code&gt;O(N*M)&lt;/code&gt; 。 忽略多个变量是我在算法分析中看到的最常见的疏漏之一，在设计算法时可能会给您带来麻烦。</target>
        </trans-unit>
        <trans-unit id="046638077884a582146518106d52398b493200ef" translate="yes" xml:space="preserve">
          <source>Multiplication is different. You line the numbers up, take the first digit in the bottom number and multiply it in turn against each digit in the top number and so on through each digit. So to multiply our two 6 digit numbers we must do 36 multiplications. We may need to do as many as 10 or 11 column adds to get the end result too.</source>
          <target state="translated">而乘法则不同。你把数字排成一排,把底数中的第一位数与上位数中的每一位数依次相乘,以此类推,通过每一位数的乘法。所以,要把我们两个6位数的数字相乘,我们必须做36次乘法。我们可能需要做10个或11个列的加法,最后的结果也要做10个或11个列的加法。</target>
        </trans-unit>
        <trans-unit id="8b1b53f8f44ad3ed2592eb6c68dec183ea16ec21" translate="yes" xml:space="preserve">
          <source>My list</source>
          <target state="translated">我的名单</target>
        </trans-unit>
        <trans-unit id="f7535aeee1a8d7280cd70d9997d4349f35bb3d3e" translate="yes" xml:space="preserve">
          <source>Naive method: If you had the coordinates of a street intersection, and wanted to examine nearby streets, you would have to go through the millions of segments each time, and check each one for adjacency.</source>
          <target state="translated">天真的方法。如果你有了一个街道交叉口的坐标,想检查附近的街道,就必须每次都要翻阅几百万个街段,并逐一检查是否相邻。</target>
        </trans-unit>
        <trans-unit id="4d68869609a9235101b6bdb59cfad0ecf3bbe23e" translate="yes" xml:space="preserve">
          <source>No growth.  Regardless of how big as the problem is, you can solve it in the same amount of time.  This is somewhat analogous to broadcasting where it takes the same amount of energy to broadcast over a given distance, regardless of the number of people that lie within the broadcast range.</source>
          <target state="translated">没有增长。不管问题有多大,都可以在同样的时间内解决。这有点类似于广播,无论广播范围内有多少人,在一定距离内的广播需要同样的能量。</target>
        </trans-unit>
        <trans-unit id="fe33dcb0f45062333e4e71b8e3449ababa913575" translate="yes" xml:space="preserve">
          <source>Normally we don't care about the best case.  We're interested in the expected and worst case.  Sometimes one or the other of these will be more important.</source>
          <target state="translated">通常情况下,我们不关心最好的情况。我们关心的是预期的和最坏的情况。有时候,其中的一种或另一种情况会更重要。</target>
        </trans-unit>
        <trans-unit id="1a399a408e72ce4d50e1c555e9e14eb8f828e225" translate="yes" xml:space="preserve">
          <source>Not all algorithms run in the same amount of time, and can vary based on the number of items in the input, which we'll call &lt;em&gt;n&lt;/em&gt;. Based on this, we consider the worse case analysis, or an upper-bound of the run-time as &lt;em&gt;n&lt;/em&gt; get larger and larger. We must be aware of what &lt;em&gt;n&lt;/em&gt; is, because many of the Big O notations reference it.</source>
          <target state="translated">并非所有算法都在相同的时间内运行，并且可能会根据输入中的项数（我们称为&lt;em&gt;n）&lt;/em&gt;而有所不同。 基于此，我们考虑最坏情况的分析，或者当&lt;em&gt;n&lt;/em&gt;越来越大时，运行时的上限。 我们必须知道&lt;em&gt;n&lt;/em&gt;是什么，因为许多Big O符号都引用了n。</target>
        </trans-unit>
        <trans-unit id="9701d8a66e2332c79e3006b450aca766fa1d69b7" translate="yes" xml:space="preserve">
          <source>Not sure I'm further contributing to the subject but still thought I'd share: I once found &lt;a href=&quot;http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/&quot;&gt;this blog post&lt;/a&gt; to have some quite helpful (though very basic) explanations &amp;amp; examples on Big O:</source>
          <target state="translated">不确定我是否会进一步为该主题做出贡献，但仍想与我分享：我曾经发现&lt;a href=&quot;http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/&quot;&gt;此博客文章&lt;/a&gt;对Big O给出了一些非常有用的（虽然很基本的）解释和示例：</target>
        </trans-unit>
        <trans-unit id="ed45d6f0b33afd4fda7acc9a90c9a6ded141d1e6" translate="yes" xml:space="preserve">
          <source>Note: None of this has taken into account best, average, and worst case measures. Each would have its own Big O notation. Also note that this is a VERY simplistic explanation. Big O is the most common, but it's also more complex that I've shown. There are also other notations such as big omega, little o, and big theta. You probably won't encounter them outside of an algorithm analysis course.</source>
          <target state="translated">注:这些都没有考虑到最佳、平均和最坏的情况。每种情况都会有自己的大O记号。另外要注意的是,这是一个非常简单化的解释。大O是最常见的,但它也是比较复杂的,我已经展示了。还有其他的符号,如大O、小O、大θ等。在算法分析课程之外,你可能不会遇到它们。</target>
        </trans-unit>
        <trans-unit id="2238088b0eacca225a542e4f91ecc2965d263d59" translate="yes" xml:space="preserve">
          <source>Notice that the number of items increases by a factor of 10, but the time increases by a factor of 10&lt;sup&gt;2&lt;/sup&gt;. Basically, n=10 and so O(n&lt;sup&gt;2&lt;/sup&gt;) gives us the scaling factor n&lt;sup&gt;2&lt;/sup&gt; which is 10&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">请注意，项目数增加了10倍，但时间增加了10 &lt;sup&gt;2&lt;/sup&gt;倍。 基本上，n = 10，因此O（n &lt;sup&gt;2&lt;/sup&gt; ）给我们缩放因子n &lt;sup&gt;2&lt;/sup&gt; ，即10 &lt;sup&gt;2&lt;/sup&gt; 。</target>
        </trans-unit>
        <trans-unit id="257c3797269830bc9710d43ca3694a583cd402ae" translate="yes" xml:space="preserve">
          <source>Now I have some work.  I have this list: one, two, three, four, five, six.  I must add all things in this list.</source>
          <target state="translated">现在,我有一些工作。我有这个清单:一、二、三、四、五、六。我必须把这个清单上的东西都加进去。</target>
        </trans-unit>
        <trans-unit id="ce4444486678ac072c200b97ac0870621f89a826" translate="yes" xml:space="preserve">
          <source>Now at times, I do have to go to work.  It is sad, but true.  So, when I am at work, I have a rule: I try to do less work.  As near to no work as I can.  Then I go play!</source>
          <target state="translated">现在有时候,我确实要去上班了。虽然很难过,但也是事实。所以,当我在工作的时候,我有一个规则:尽量少做一些工作。尽可能的不工作。然后,我就去玩!</target>
        </trans-unit>
        <trans-unit id="4af2bcb5c492dc62ee7f7d5ed90f520c4c05c4e0" translate="yes" xml:space="preserve">
          <source>Now here comes big O, and he will tell us how hard this work is.  He says: to add all things from one to N, one by one, is O(n).  To add all these things, [I know I must add n times.][1]  That is big O!  He tells us how hard it is to do some type of work.</source>
          <target state="translated">现在大O来了,他要告诉我们这个工作有多难。他说:要把所有的东西从1加到n个,一个个加起来,就是o(n)。要把这些东西都加起来,[我知道我必须加n次。][1]这就是大O! 他告诉我们:做某种工作是多么困难的事情。</target>
        </trans-unit>
        <trans-unit id="6c34478c5f5b54c8853b19d59a2824aed411c88f" translate="yes" xml:space="preserve">
          <source>Now here is where big O is our friend.</source>
          <target state="translated">现在这里是大O是我们的朋友。</target>
        </trans-unit>
        <trans-unit id="110a534fc79ede4defb1ebec55d0413c614f421d" translate="yes" xml:space="preserve">
          <source>Now if you were instructing a computer to look up the phone number for &quot;John Smith&quot; in a telephone book that contains 1,000,000 names, what would you do?  Ignoring the fact that you could guess how far in the S's started (let's assume you can't), what would you do?</source>
          <target state="translated">现在,如果你指示计算机在一个包含了100万个名字的电话簿中查找 &quot;约翰-史密斯 &quot;的电话号码,你会怎么做?忽略了你能猜出 &quot;S &quot;开头的数字有多远(假设你猜不到),你会怎么做?</target>
        </trans-unit>
        <trans-unit id="9540b13ba056381a0510ad691215a7809e459df8" translate="yes" xml:space="preserve">
          <source>Now that work is done, let&amp;rsquo;s go play!</source>
          <target state="translated">现在工作完成了，让我们开始吧！</target>
        </trans-unit>
        <trans-unit id="d6eba09ebedd6f51a03a1027fa2fafcd89c71acb" translate="yes" xml:space="preserve">
          <source>Now they ask me to add from one to ten!  Why would I do that?  I did not want to add one to six.  To add from one to ten&amp;hellip; well&amp;hellip; that would be even more hard!</source>
          <target state="translated">现在他们要我加一到十！ 我为什么要这么做？ 我不想加一到六。 要从一增加到十&amp;hellip;&amp;hellip;好吧&amp;hellip;&amp;hellip;那将更加困难！</target>
        </trans-unit>
        <trans-unit id="00988e447c66a2cb48babcb9e00cb583a7ea2cdd" translate="yes" xml:space="preserve">
          <source>Now we must do new work.  Oh, no.  I don&amp;rsquo;t like this work thing at all.</source>
          <target state="translated">现在我们必须做新工作。 不好了。 我一点都不喜欢这个工作。</target>
        </trans-unit>
        <trans-unit id="2649fa4f7ace90e5e3a42578e0c5f2755906f188" translate="yes" xml:space="preserve">
          <source>Now when big O says it will take O(n squared) work, he does not mean n squared adds, on the nose.  It might be some small bit less, for some case.  But in the worst case, it will be near n squared steps of work to sort the deck.</source>
          <target state="translated">现在,当大O说要花O(n个平方)的工夫时,他并不是说n个平方的加法,在鼻子上。可能会少一点,对于某些情况下,可能会少一点。但在最坏的情况下,它将是近n个平方步数的工作来排序。</target>
        </trans-unit>
        <trans-unit id="08d4d2dadf777a65ea195b7215d064cef2cd8721" translate="yes" xml:space="preserve">
          <source>Now you know my friend, Big O.  He helps us do less work.  And if you know big O, you can do less work too!</source>
          <target state="translated">现在你知道我的朋友,大O,他帮我们少做一些工作。如果你认识大O,你也可以少做一些工作!</target>
        </trans-unit>
        <trans-unit id="05dc08a4c399781657ad8add0a8aafb1f260a439" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s you and me talk of work. Most of the time, I do not like work.  Do you like work?  It may be the case that you do, but I am sure I do not.</source>
          <target state="translated">现在，让您和我谈谈工作。 大多数时候，我不喜欢工作。 你喜欢工作吗？ 您可能会这样做，但我确定我不会。</target>
        </trans-unit>
        <trans-unit id="205e8cfdfc5930c2d0673af6524af6317388bfed" translate="yes" xml:space="preserve">
          <source>O and Ω are not symmetric (n = O(n&amp;sup2;), but n&amp;sup2; is not O(n)), but Ɵ is symmetric, and (since these relations are all transitive and reflexive) Ɵ, therefore, is symmetric and transitive and reflexive, and therefore partitions the set of all functions into &lt;em&gt;equivalence classes&lt;/em&gt;. An equivalence class is a set of things that we consider to be the same. That is to say, given any function you can think of, you can find a canonical/unique 'asymptotic representative' of the class (by generally taking the limit... I &lt;em&gt;think&lt;/em&gt;); just like you can group all integers into odds or evens, you can group all functions with Ɵ into x-ish, log(x)^2-ish, etc... by basically ignoring smaller terms (but sometimes you might be stuck with more complicated functions which are separate classes unto themselves).</source>
          <target state="translated">O和&amp;Omega;不对称（n = O（n&amp;sup2;），但n&amp;sup2;不是O（n）），但是Ɵ是对称的，并且（因为这些关系都是传递和自反的）Ɵ因此是对称的，传递和自反的，因此将所有函数的集合划分为&lt;em&gt;等效类&lt;/em&gt; 。 等效类是我们认为相同的一组事物。 也就是说，给定您可以想到的任何功能，您都可以找到该类的规范/唯一的&amp;ldquo;渐近代表&amp;rdquo;（通常采用极限值...我&lt;em&gt;认为&lt;/em&gt; ）； 就像您可以将所有整数分组为偶数或偶数一样，您可以将所有带有Ɵ的函数分组为x-ish，log（x）^ 2-ish等，通过基本忽略较小的项（但有时您可能会陷入困境）更复杂的功能，它们本身就是单独的类）。</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="98e642472708191e8a65ac2ab3cf6a96d7f6885e" translate="yes" xml:space="preserve">
          <source>O(1) = O(n) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin; (but not the other way around, the equality is &quot;fake&quot;),</source>
          <target state="translated">当n&amp;rarr;+&amp;infin;时，O（1）= O（n）= O（n &lt;sup&gt;2&lt;/sup&gt; ）（但反之，相等是&amp;ldquo;伪&amp;rdquo;），</target>
        </trans-unit>
        <trans-unit id="25c301e3f5329dedc950de0f1c38ac8d3d8286a2" translate="yes" xml:space="preserve">
          <source>O(1) describes an algorithm that will always execute in the same time
  (or space) regardless of the size of the input data set.</source>
          <target state="translated">O(1)描述了一种算法,无论输入数据集的大小,总是在相同的时间(或空间)内执行。</target>
        </trans-unit>
        <trans-unit id="1e77cb950a650cbda7e41c7e563dfc7d75184ce0" translate="yes" xml:space="preserve">
          <source>O(1), means your computer gets a task done with &lt;code&gt;1&lt;/code&gt; step, it's excellent, Ordered No.1</source>
          <target state="translated">O（1），表示您的计算机只需一步就可以完成一项任务，非常好，已订购第一</target>
        </trans-unit>
        <trans-unit id="8681bf4e62cb366ee6970996fa273715542e1c24" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;N&lt;/sup&gt;)</source>
          <target state="translated">O(2&lt;sup&gt;N&lt;/sup&gt;)</target>
        </trans-unit>
        <trans-unit id="e3d80bfb500c859c180f245124c30408ce843ee8" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;N&lt;/sup&gt;) denotes an algorithm whose growth doubles with each additon to
  the input data set. The growth curve of an O(2&lt;sup&gt;N&lt;/sup&gt;) function is
  exponential - starting off very shallow, then rising meteorically. An
  example of an O(2&lt;sup&gt;N&lt;/sup&gt;) function is the recursive calculation of Fibonacci
  numbers:</source>
          <target state="translated">O（2 &lt;sup&gt;N&lt;/sup&gt; ）表示一种算法，随着输入数据集的每增加一个元素，其增长都会加倍。 O（2 &lt;sup&gt;N&lt;/sup&gt; ）函数的增长曲线是指数的-从非常浅的位置开始，然后在气象上上升。 O（2 &lt;sup&gt;N&lt;/sup&gt; ）函数的一个示例是斐波那契数的递归计算：</target>
        </trans-unit>
        <trans-unit id="68bc7ad068f5c61d49e37e6fc72efd56e5f32c9c" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;n&lt;/sup&gt;): If the input size increases by one, the runtime doubles</source>
          <target state="translated">O（2 &lt;sup&gt;n&lt;/sup&gt; ）：如果输入大小增加一，则运行时会加倍</target>
        </trans-unit>
        <trans-unit id="63e9d8727f40f7ec9e8552148c03efe752771415" translate="yes" xml:space="preserve">
          <source>O(2^N),  get a task done with &lt;code&gt;2^N&lt;/code&gt; steps, it's horrible, Order No.6</source>
          <target state="translated">O（2 ^ N），以 &lt;code&gt;2^N&lt;/code&gt; 步骤完成任务，这太可怕了，第6号命令</target>
        </trans-unit>
        <trans-unit id="308b527a11caed66089316ea8a6e1067c1969f82" translate="yes" xml:space="preserve">
          <source>O(N!),  get a task done with &lt;code&gt;N!&lt;/code&gt; steps, it's terrible, Order No.7</source>
          <target state="translated">O（N！），用 &lt;code&gt;N!&lt;/code&gt; 完成任务！ 步骤，太糟糕了，第7号订单</target>
        </trans-unit>
        <trans-unit id="a257064879b3c5b994b0c4eb5698b028eb534479" translate="yes" xml:space="preserve">
          <source>O(N)</source>
          <target state="translated">O(N)</target>
        </trans-unit>
        <trans-unit id="c3f150e3661faff6df87ef3476136d42ffe76b00" translate="yes" xml:space="preserve">
          <source>O(N) describes an algorithm whose performance will grow linearly and
  in direct proportion to the size of the input data set. The example
  below also demonstrates how Big O favours the worst-case performance
  scenario; a matching string could be found during any iteration of the
  for loop and the function would return early, but Big O notation will
  always assume the upper limit where the algorithm will perform the
  maximum number of iterations.</source>
          <target state="translated">O(N)描述了一种算法,其性能将与输入数据集的大小成正比线性增长。下面的例子也展示了Big O如何偏向于最坏的性能情况;在for循环的任何迭代过程中,可以找到一个匹配的字符串,并且函数会提前返回,但Big O的记号总是会假设算法执行最大迭代次数的上限。</target>
        </trans-unit>
        <trans-unit id="50a60625d0c152951efa7ecdbe93cfe7f46beda6" translate="yes" xml:space="preserve">
          <source>O(N), finish a task with &lt;code&gt;N&lt;/code&gt; steps, its fair, Order No.3</source>
          <target state="translated">O（N），用 &lt;code&gt;N&lt;/code&gt; 个步骤完成任务，公平，第3号命令</target>
        </trans-unit>
        <trans-unit id="56b0b7dfdc166b52f3daf1b1c70a817924759e73" translate="yes" xml:space="preserve">
          <source>O(N&lt;sup&gt;2&lt;/sup&gt;)</source>
          <target state="translated">O(N&lt;sup&gt;2&lt;/sup&gt;)</target>
        </trans-unit>
        <trans-unit id="8c2b565c37a449cbce6a610382372bb9973c5a59" translate="yes" xml:space="preserve">
          <source>O(N&lt;sup&gt;2&lt;/sup&gt;) represents an algorithm whose performance is directly
  proportional to the square of the size of the input data set. This is
  common with algorithms that involve nested iterations over the data
  set. Deeper nested iterations will result in O(N&lt;sup&gt;3&lt;/sup&gt;), O(N&lt;sup&gt;4&lt;/sup&gt;) etc.</source>
          <target state="translated">O（N &lt;sup&gt;2&lt;/sup&gt; ）表示一种算法，其性能与输入数据集的大小的平方成正比。 这在涉及对数据集进行嵌套迭代的算法中很常见。 更深层的嵌套迭代将导致O（N &lt;sup&gt;3&lt;/sup&gt; ），O（N &lt;sup&gt;4&lt;/sup&gt; ）等。</target>
        </trans-unit>
        <trans-unit id="de99ca4237dd94527753ecf95f080066d3a66999" translate="yes" xml:space="preserve">
          <source>O(N^2),  get a task done with &lt;code&gt;N^2&lt;/code&gt; steps, it's bad, Order No.5</source>
          <target state="translated">O（N ^ 2），用 &lt;code&gt;N^2&lt;/code&gt; 步骤完成任务，很糟糕，第5号订单</target>
        </trans-unit>
        <trans-unit id="044f421fbafcb690927916033a456e1ccb0b67d2" translate="yes" xml:space="preserve">
          <source>O(NlogN), ends a task with &lt;code&gt;O(NlogN)&lt;/code&gt; steps, it's not good, Order No.4</source>
          <target state="translated">O（NlogN），以 &lt;code&gt;O(NlogN)&lt;/code&gt; 步骤结束任务，不好，第4号命令</target>
        </trans-unit>
        <trans-unit id="adcb5e72616abf45d10a5b515b2a078ad0f91adb" translate="yes" xml:space="preserve">
          <source>O(O(n&lt;sup&gt;2&lt;/sup&gt;)) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">当n&amp;rarr;+&amp;infin;时O（O（n &lt;sup&gt;2&lt;/sup&gt; ））= O（n &lt;sup&gt;2&lt;/sup&gt; ）</target>
        </trans-unit>
        <trans-unit id="ece6ebf71b235bbf6ca0d80731462a53a21f231d" translate="yes" xml:space="preserve">
          <source>O(log n): If the input size doubles the runtime increases by one</source>
          <target state="translated">O(log n)。如果输入大小增加一倍,则运行时间增加1</target>
        </trans-unit>
        <trans-unit id="7e25f642c5b31ae751d0fbe5acb56b926e9390ba" translate="yes" xml:space="preserve">
          <source>O(logN), means your computer complete a task with &lt;code&gt;logN&lt;/code&gt; steps, its good, Ordered No.2</source>
          <target state="translated">O（logN），表示您的计算机以 &lt;code&gt;logN&lt;/code&gt; 步骤完成任务，良好，已订购2号</target>
        </trans-unit>
        <trans-unit id="d09f9f7cdec58e339154e9a9c832d0991809a760" translate="yes" xml:space="preserve">
          <source>O(n) + O(n&lt;sup&gt;2&lt;/sup&gt;) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">当n&amp;rarr;+&amp;infin;时O（n）+ O（n &lt;sup&gt;2&lt;/sup&gt; ）= O（n &lt;sup&gt;2&lt;/sup&gt; ）</target>
        </trans-unit>
        <trans-unit id="97dd63fef8702296bf87a4c2e21f4bd48ff0b539" translate="yes" xml:space="preserve">
          <source>O(n) means Big O is n, and now you might think, &quot;What is n!?&quot; Well &quot;n&quot; is the amount of elements. Imaging you want to search for an Item in an Array. You would have to look on Each element and as &quot;Are you the correct element/item?&quot; in the worst case, the item is at the last index, which means that it took as much time as there are items in the list, so to be generic, we say &quot;oh hey, n is a fair given amount of values!&quot;.</source>
          <target state="translated">O(n)的意思是大O是n,现在你可能会想,&quot;什么是n!&quot;?那么 &quot;n &quot;就是元素的数量。想象一下,你想在一个数组中搜索一个项目。你将不得不在每个元素上寻找,并且在最坏的情况下,该项目是在最后一个索引,这意味着它花了尽可能多的时间,因为在列表中的项目,所以为了通用,我们说 &quot;哦,嘿嘿,n是一个公平的给定值的量!&quot;。</target>
        </trans-unit>
        <trans-unit id="d0849346fa8631d6b61d0173d101e04d26feaa94" translate="yes" xml:space="preserve">
          <source>O(n) ~ Linear</source>
          <target state="translated">O(n)~ 线性</target>
        </trans-unit>
        <trans-unit id="a5fa19f57aec98afc3fc69df842b447d2a094f4c" translate="yes" xml:space="preserve">
          <source>O(n), O(n&lt;sup&gt;2&lt;/sup&gt;) etc. are all polynomial time. Some problems cannot be solved in polynomial time. Certain things are used in the world because of this. &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;Public Key Cryptography&lt;/a&gt; is a prime example. It is computationally hard to find two prime factors of a very large number. If it wasn't, we couldn't use the public key systems we use.</source>
          <target state="translated">O（n），O（n &lt;sup&gt;2&lt;/sup&gt; ）等都是多项式时间。 一些问题无法在多项式时间内解决。 因此，世界上使用了某些东西。 &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;公钥密码术&lt;/a&gt;就是一个很好的例子。 在计算上很难找到数量很大的两个主要因素。 如果不是，我们将无法使用所使用的公钥系统。</target>
        </trans-unit>
        <trans-unit id="f995f059c281a355753f38679edd0e7f61f9dfcf" translate="yes" xml:space="preserve">
          <source>O(n): If I double the input size the runtime doubles</source>
          <target state="translated">O(n)。如果我把输入大小增加一倍,运行时间就会增加一倍。</target>
        </trans-unit>
        <trans-unit id="830c15d5357ce8008571a4bcc897c78270ce5607" translate="yes" xml:space="preserve">
          <source>O(n&lt;sup&gt;2&lt;/sup&gt;): If the input size doubles the runtime quadruples</source>
          <target state="translated">O（n &lt;sup&gt;2&lt;/sup&gt; ）：如果输入大小加倍运行时间四倍</target>
        </trans-unit>
        <trans-unit id="8639ae6910d96d5623a09688e0818a131fb8c50f" translate="yes" xml:space="preserve">
          <source>O(n&lt;sup&gt;2&lt;/sup&gt;)O(n&lt;sup&gt;3&lt;/sup&gt;) = O(n&lt;sup&gt;5&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">当n&amp;rarr;+&amp;infin;时O（n &lt;sup&gt;2&lt;/sup&gt; ）O（n &lt;sup&gt;3&lt;/sup&gt; ）= O（n &lt;sup&gt;5&lt;/sup&gt; ）</target>
        </trans-unit>
        <trans-unit id="ac18ee6983cc2eb537d0f2f25351e9df638a26bd" translate="yes" xml:space="preserve">
          <source>Obviously that's only using &quot;size&quot; as the input and &quot;time taken&quot; as the output &amp;mdash; the same idea applies if you want to talk about memory usage etc.</source>
          <target state="translated">显然，这仅使用&amp;ldquo;大小&amp;rdquo;作为输入，使用&amp;ldquo;花费的时间&amp;rdquo;作为输出，如果您要谈论内存使用情况等，则可以采用相同的想法。</target>
        </trans-unit>
        <trans-unit id="047235fd8fb4d12aece908a6c0ecf01e2c06606a" translate="yes" xml:space="preserve">
          <source>Of course this does not mean that loops and functions are bad; on the contrary, they are the building blocks of modern programming languages, and we love them. However, we can see that the way we weave loops and functions and conditionals together with our data (control flow, etc.) mimics the time and space usage of our program! If time and space usage becomes an issue, that is when we resort to cleverness and find an easy algorithm or data structure we hadn't considered, to reduce the order of growth somehow. Nevertheless, these visualization techniques (though they don't always work) can give you a naive guess at a worst-case running time.</source>
          <target state="translated">当然,这并不是说循环和函数不好,相反,它们是现代编程语言的构件,我们很喜欢它们。然而,我们可以看到,我们把循环和函数和条件符与我们的数据(控制流等)编织在一起的方式,会模仿我们的程序的时间和空间的使用情况!这时,我们就会发现,我们的程序的时间和空间的使用情况会变得很糟糕。如果时间和空间的使用成为一个问题,那就是当我们诉诸于聪明,找到一个我们没有考虑过的简单的算法或数据结构,以某种方式减少增长的顺序。尽管如此,这些可视化技术(尽管它们并不总是有效)可以给你一个最坏情况下的运行时间的天真的猜测。</target>
        </trans-unit>
        <trans-unit id="02eb439e917fc58abf025b96d214507c593cd917" translate="yes" xml:space="preserve">
          <source>Oh no, now I have more work.  Sheesh.  Who makes this kind of stuff?!</source>
          <target state="translated">哦,不,现在我有更多的工作。啧啧。谁会做这种东西?</target>
        </trans-unit>
        <trans-unit id="846bee0b9db59985faaa143bf6c6677865b72c7b" translate="yes" xml:space="preserve">
          <source>Ok, my 2cents.</source>
          <target state="translated">好吧,我的两分钱。</target>
        </trans-unit>
        <trans-unit id="4d41abb6d91ed8426b9c48d248c476619fafc156" translate="yes" xml:space="preserve">
          <source>Once I have found these two cards, I swap them, and go on to look for more cards to swap.  That is, I go back to step Two, and splay on the card you chose some more.</source>
          <target state="translated">找到这两张牌后,我就把它们交换,然后继续寻找更多的牌来交换。也就是说,我再回到第二步,在你选的那张牌上再撒一些。</target>
        </trans-unit>
        <trans-unit id="bbe0abb1706b2ab494f9baaf3f32394aa9b1d99e" translate="yes" xml:space="preserve">
          <source>One can notice that we've assumed the worst case scenario here. While multiplying 6 digit numbers, if one of them has 4 digits and the other one has 6 digits, then we only have 24 multiplications. Still, we calculate the worst case scenario for that 'n', i.e when both are 6 digit numbers. Hence Big-O notation is about the Worst-case scenario of an algorithm.</source>
          <target state="translated">人们可以注意到,我们在这里假设了最坏的情况。当乘以6位数的数字时,如果其中一位是4位数,另一位是6位数,那么我们只有24个乘法。但是,我们计算的是最坏的情况,也就是当两个都是6位数的时候。因此,Big-O符号是关于一个算法的最坏情况。</target>
        </trans-unit>
        <trans-unit id="aa31e9cc8ee30f1096d7841ca16202599811c4d7" translate="yes" xml:space="preserve">
          <source>One important aspect of &quot;big O&quot; notation is that it &lt;em&gt;doesn't&lt;/em&gt; say which algorithm will be faster for a given size. Take a hashtable (string key, integer value)  vs an array of pairs (string, integer). Is it faster to find a key in the hashtable or an element in the array, based on a string? (i.e. for the array, &quot;find the first element where the string part matches the given key.&quot;) Hashtables are generally amortised (~= &quot;on average&quot;) O(1) &amp;mdash; once they're set up, it should take about the same time to find an entry in a 100 entry table as in a 1,000,000 entry table. Finding an element in an array (based on content rather than index) is linear, i.e. O(N) &amp;mdash; on average, you're going to have to look at half the entries.</source>
          <target state="translated">&amp;ldquo;大O&amp;rdquo;表示法的一个重要方面是，它&lt;em&gt;并未&lt;/em&gt;说明哪种算法在给定大小下会更快。 拿一个哈希表（字符串键，整数值）与一个成对的数组（字符串，整数）。 根据字符串在哈希表中查找键或在数组中查找元素是否更快？ （即对于数组，&amp;ldquo;在字符串部分与给定键匹配的地方找到第一个元素。&amp;rdquo;）哈希表通常被摊销（〜=&amp;ldquo;平均&amp;rdquo;）O（1）&amp;mdash;一旦设置好，大约需要同时在100条目表中查找条目和在1,000,000条目表中查找条目的时间相同。 在数组中找到元素（基于内容而不是索引）是线性的，即O（N）-平均而言，您将不得不查看条目的一半。</target>
        </trans-unit>
        <trans-unit id="455ac552ede28e8384f4279d82396b29180d80b5" translate="yes" xml:space="preserve">
          <source>One plus two is three&amp;hellip; plus three is six... and four is... I don&amp;rsquo;t know.  I got lost.  It is too hard for me to do in my head.  I don&amp;rsquo;t much care for this kind of work.</source>
          <target state="translated">一加二等于三&amp;hellip;&amp;hellip;加三等于六&amp;hellip;&amp;hellip;而四等于&amp;hellip;&amp;hellip;我不知道。 我迷路了。 我脑子里很难做。 我不太喜欢这种工作。</target>
        </trans-unit>
        <trans-unit id="bc82ac3fdfa2c36fc2c53eae610e61a05eb3407a" translate="yes" xml:space="preserve">
          <source>One: I choose one card in the part of the deck we work on now.  You can choose one for me if you like.  (The first time we do this, &amp;ldquo;the part of the deck we work on now&amp;rdquo; is the whole deck, of course.)</source>
          <target state="translated">一：我在我们现在处理的套牌中选择一张牌。 如果愿意，可以为我选择一个。 （当然，这是我们第一次进行此操作，&amp;ldquo;现在我们正在处理的部分甲板&amp;rdquo;是整个甲板。）</target>
        </trans-unit>
        <trans-unit id="6f7dd336bd44297d43d1e2584ebc5605a1581c94" translate="yes" xml:space="preserve">
          <source>Only concerned with runtime grow relative to the input &lt;strong&gt;(n)&lt;/strong&gt;</source>
          <target state="translated">只关心运行时间相对于输入的增长&lt;strong&gt;（n）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e64c05fb1f7a3fd3c0cf63d3e43c979084e566b1" translate="yes" xml:space="preserve">
          <source>Or maybe you do log(N) passes of the data, for O(N*log(N)) total time:</source>
          <target state="translated">或者,也许你对数据进行log(N)传递,总时间为O(N*log(N))。</target>
        </trans-unit>
        <trans-unit id="03e6e7bc29b2694c5ad9d0d21e7d44ffe2e43e41" translate="yes" xml:space="preserve">
          <source>Our task went from an infeasible &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; to a manageable &lt;code&gt;O(N)&lt;/code&gt;, and all we had to do was pay a minor cost to make a hash table.</source>
          <target state="translated">我们的任务从无法实现的 &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; 变为可管理的 &lt;code&gt;O(N)&lt;/code&gt; ，而我们要做的就是花很少的钱来制作哈希表。</target>
        </trans-unit>
        <trans-unit id="0732d399cd128b93b16b9a0583b8df0ddb1d224b" translate="yes" xml:space="preserve">
          <source>People will often use &lt;code&gt;= O(...)&lt;/code&gt;, which is perhaps the more correct 'comp-sci' notation, and entirely legitimate to use; &quot;f = O(...)&quot; is read &quot;f is order ... / f is xxx-bounded by ...&quot; and is thought of as &quot;f is some expression whose asymptotics are ...&quot;. I was taught to use the more rigorous &lt;code&gt;&amp;isin; O(...)&lt;/code&gt;. &lt;code&gt;&amp;isin;&lt;/code&gt; means &quot;is an element of&quot; (still read as before). In this particular case, &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; contains elements like {&lt;code&gt;2 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;3 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;1/2 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;2 N&amp;sup2; + log(N)&lt;/code&gt;, &lt;code&gt;- N&amp;sup2; + N^1.9&lt;/code&gt;, ...} and is infinitely large, but it's still a set.</source>
          <target state="translated">人们通常会使用 &lt;code&gt;= O(...)&lt;/code&gt; ，这也许是更正确的&amp;ldquo; comp-sci&amp;rdquo;表示法，并且完全合法使用； 读为&amp;ldquo; f = O（...）&amp;rdquo;，&amp;ldquo; f是阶... / f由... xxx界定&amp;rdquo;，并且被认为是&amp;ldquo; f是渐近性为...的某些表达式&amp;rdquo;。 有人教我使用更严格的 &lt;code&gt;&amp;isin; O(...)&lt;/code&gt; 。 &lt;code&gt;&amp;isin;&lt;/code&gt; 表示&amp;ldquo;是&amp;hellip;&amp;hellip;的元素&amp;rdquo;（仍然如前所述）。 在这种情况下， &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; 包含{ &lt;code&gt;2 N&amp;sup2;&lt;/code&gt; ， &lt;code&gt;3 N&amp;sup2;&lt;/code&gt; ， &lt;code&gt;1/2 N&amp;sup2;&lt;/code&gt; ， &lt;code&gt;2 N&amp;sup2; + log(N)&lt;/code&gt; ， &lt;code&gt;- N&amp;sup2; + N^1.9&lt;/code&gt; ，...}之类的元素，并且无限大，但是还是一套。</target>
        </trans-unit>
        <trans-unit id="aff7f1ca724e63fb9ec4afc2e9f2dbdfa5bff1a0" translate="yes" xml:space="preserve">
          <source>Please note the order at line end, just for your better understanding.There's more than 7 notations if all possibilities considered.</source>
          <target state="translated">请注意行尾的顺序,只是为了让大家更好地理解。</target>
        </trans-unit>
        <trans-unit id="ff6f34b84d9b2e644758179e12f471c8957fb41f" translate="yes" xml:space="preserve">
          <source>Polynomial Time</source>
          <target state="translated">多ynomial Time</target>
        </trans-unit>
        <trans-unit id="c745366182e555ccc5603f9f335f3de2d95eae3a" translate="yes" xml:space="preserve">
          <source>Practically speaking, Big O analysis is &lt;em&gt;so useful and important&lt;/em&gt; because Big O puts the focus squarely on the algorithm's &lt;em&gt;own&lt;/em&gt; complexity and completely &lt;em&gt;ignores&lt;/em&gt; anything that is merely a proportionality constant&amp;mdash;like a JavaScript engine, the speed of a CPU, your Internet connection, and all those things which become quickly become as laughably outdated as a Model &lt;em&gt;T&lt;/em&gt;. Big O focuses on performance only in the way that matters equally as much to people living in the present or in the future.</source>
          <target state="translated">实际上，Big O分析是&lt;em&gt;如此有用且重要，&lt;/em&gt;因为Big O将焦点直接放在算法&lt;em&gt;自身的&lt;/em&gt;复杂度上，并且完全&lt;em&gt;忽略&lt;/em&gt;了仅仅是比例常数的任何内容，例如JavaScript引擎，CPU的速度，您的Internet连接以及所有这些很快变得像&lt;em&gt;T型车&lt;/em&gt;一样可笑的过时的东西。 Big O仅以对现在或未来人们同样重要的方式关注绩效。</target>
        </trans-unit>
        <trans-unit id="707ddefda8b9d501a1d63dad3fcb74d0cb28b51a" translate="yes" xml:space="preserve">
          <source>Preface</source>
          <target state="translated">Preface</target>
        </trans-unit>
        <trans-unit id="c96271fcfba3e64dd9236be70e3f3f5fc45c32c9" translate="yes" xml:space="preserve">
          <source>Programs will also run slower on a 500MHz computer vs 2GHz computer. We don't really consider this as part of the resource bounds, because we think of the scaling in terms of machine resources (e.g. per clock cycle), not per real second. However, there are similar things which can 'secretly' affect performance, such as whether you are running under emulation, or whether the compiler optimized code or not. These might make some basic operations take longer (even relative to each other), or even speed up or slow down some operations asymptotically (even relative to each other). The effect may be small or large between different implementation and/or environment. Do you switch languages or machines to eke out that little extra work? That depends on a hundred other reasons (necessity, skills, coworkers, programmer productivity, the monetary value of your time, familiarity, workarounds, why not assembly or GPU, etc...), which may be more important than performance.</source>
          <target state="translated">程序在500MHz的计算机上运行速度也会比2GHz的计算机慢。我们并没有把这看作是资源限制的一部分,因为我们考虑的是机器资源(例如每时钟周期)的缩放,而不是每实际秒的缩放。然而,还有一些类似的东西会 &quot;暗中 &quot;影响性能,比如你是否在仿真下运行,或者编译器是否对代码进行了优化。这些东西可能会使一些基本操作的时间变长(甚至是相对的),甚至会使一些操作的速度变快或变慢(甚至是相对的)。不同的实现和or环境之间的影响可能是小的,也可能是大的。你是否要切换语言或机器,以挤出那一点点额外的工作?这取决于其他一百个原因(必要性、技能、同事、程序员的工作效率、你的时间的金钱价值、熟悉程度、工作方法、为什么不使用汇编或GPU等等),这些原因可能比性能更重要。</target>
        </trans-unit>
        <trans-unit id="0d31501e03db9492d0d452e6624c95d2a7fc34fc" translate="yes" xml:space="preserve">
          <source>Put another way, it's all about the &lt;strong&gt;ratio&lt;/strong&gt; as you go to infinity. &lt;em&gt;If you divide the actual time it takes by the &lt;code&gt;O(...)&lt;/code&gt;, you will get a constant factor in the limit of large inputs.&lt;/em&gt; Intuitively this makes sense: functions &quot;scale like&quot; one another if you can multiply one to get the other. That is when we say...</source>
          <target state="translated">换句话说，当您达到无穷大时，这全都与&lt;strong&gt;比率&lt;/strong&gt;有关。 &lt;em&gt;如果将实际花费的时间除以 &lt;code&gt;O(...)&lt;/code&gt; ，则在大输入量的限制中将得到一个常数。&lt;/em&gt; 直观地讲，这是有道理的：如果您可以将一个函数相乘得到另一个函数，则函数会彼此&amp;ldquo;缩放&amp;rdquo;。 那是当我们说...</target>
        </trans-unit>
        <trans-unit id="b123240c4cc86a314f0b2ff2c7fcffe4a190bdd3" translate="yes" xml:space="preserve">
          <source>Putting everything in an airing cupboard: If we put everything in one big pile and just let general warmth do it, it will take a long time for the middle shirts to get dry. I wouldn't like to guess at the detail, but I suspect this is at least O(N^2) &amp;mdash; as you increase the wash load, the drying time increases faster.</source>
          <target state="translated">将所有物品放到通风的橱柜中：如果将所有物品放到一大堆中并让整体保暖，中衬衫要花很长时间才能变干。 我不想猜测细节，但我怀疑这至少是O（N ^ 2）-随着洗涤量的增加，干燥时间会增加。</target>
        </trans-unit>
        <trans-unit id="44d6998253d7ce7630dea94f49784bcc34a98b86" translate="yes" xml:space="preserve">
          <source>Quick Sort breaks up big decks in small ones.  That is to say, it breaks up big tasks in small ones.</source>
          <target state="translated">Quick Sort将大的任务分解成小的任务。也就是说,它把大任务分解成小任务。</target>
        </trans-unit>
        <trans-unit id="aafbf15c3d2cb24c90abf21327172d843932cd8c" translate="yes" xml:space="preserve">
          <source>Quick note, this is almost certainly confusing &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; (which is an upper bound) with Theta notation &quot;&amp;Theta;&quot; (which is a two-side bound). In my experience, this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</source>
          <target state="translated">快速说明，这几乎肯定会使&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O表示法&lt;/a&gt; （上限）与Theta表示法&amp;ldquo;&amp;Theta;&amp;rdquo;（两侧界线）混淆。 以我的经验，这实际上是非学术场合中讨论的典型内容。 造成任何混乱，我们深表歉意。</target>
        </trans-unit>
        <trans-unit id="78240c3b95a799ddc676899ee3f052157355ad48" translate="yes" xml:space="preserve">
          <source>Resource : Could be total-CPU time, could be maximum RAM space. By default refers to CPU time.</source>
          <target state="translated">资源:可以是总CPU时间,也可以是最大RAM空间。默认是指CPU时间。</target>
        </trans-unit>
        <trans-unit id="ac86f485121aebe3e0cdccd29ad1f58c3d7af9cc" translate="yes" xml:space="preserve">
          <source>Say the problem is &quot;Find the Combination&quot;,</source>
          <target state="translated">说问题是 &quot;找组合&quot;。</target>
        </trans-unit>
        <trans-unit id="a93e27c51787651f155cd14f8a574fade12b6fb2" translate="yes" xml:space="preserve">
          <source>Say the problem is &quot;Find the sum&quot;,</source>
          <target state="translated">说问题是 &quot;求和&quot;。</target>
        </trans-unit>
        <trans-unit id="a090d13ccede8e7fd94f3cd08042cf4d8572f583" translate="yes" xml:space="preserve">
          <source>Say you order Harry Potter: Complete 8-Film Collection [Blu-ray] from Amazon and download the same film collection online at the same time. You want to test which method is faster. The delivery takes almost a day to arrive and the download completed about 30 minutes earlier. Great! So it&amp;rsquo;s a tight race.</source>
          <target state="translated">假设您从亚马逊订购了《哈利&amp;middot;波特：完整的8电影集》 [Blu-ray]，并同时在线下载了同一部电影集。 您想测试哪种方法更快。 交付将花费几乎一天的时间，下载大约提前30分钟完成。 大！ 所以这是一场激烈的比赛。</target>
        </trans-unit>
        <trans-unit id="7c15a59b277cd7091e5fcf18a82064b3a5dd08e6" translate="yes" xml:space="preserve">
          <source>See more at: &lt;a href=&quot;http://proprogramming.org/2015/01/how-to-calculate-time-complexity-of.html#sthash.URrGFhqm.dpuf&quot;&gt;Here&lt;/a&gt;</source>
          <target state="translated">查看更多： &lt;a href=&quot;http://proprogramming.org/2015/01/how-to-calculate-time-complexity-of.html#sthash.URrGFhqm.dpuf&quot;&gt;这里&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1401abdd96246a6a7cc788610b57a7b896aa0b20" translate="yes" xml:space="preserve">
          <source>See the pattern?  The &lt;strong&gt;complexity&lt;/strong&gt; (being the number of operations) is directly proportional to the number of digits &lt;em&gt;n&lt;/em&gt; in the larger number.  We call this &lt;strong&gt;O(n)&lt;/strong&gt; or &lt;strong&gt;linear complexity&lt;/strong&gt;.</source>
          <target state="translated">看到图案了吗？ &lt;strong&gt;复杂度&lt;/strong&gt; （即操作数）与较大数字中的位数&lt;em&gt;n&lt;/em&gt;成正比。 我们称其为&lt;strong&gt;O（n）&lt;/strong&gt;或&lt;strong&gt;线性复杂度&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bb8c396c1b1d4188f90d674eebb67f47ab45d2b" translate="yes" xml:space="preserve">
          <source>Since Big-O doesn't care too much about constant factor (aka 3), the Big-O of your algorithm is &lt;code&gt;O(N^2 + log(X))&lt;/code&gt;. It basically translates 'the amount of operations your algorithm needs for the worst case scales with this'.</source>
          <target state="translated">由于Big-O不太关心常数因子（aka 3），因此算法的Big-O为 &lt;code&gt;O(N^2 + log(X))&lt;/code&gt; 。 它基本上可以翻译为&amp;ldquo;算法在最坏情况下所需的运算量&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="185fbeb7236225913f02d9ced51afffe91dadcbe" translate="yes" xml:space="preserve">
          <source>So here is the big news: the big O can help me not to do work!  I can play more of the time, if I know big O.  Less work, more play!  That is what big O helps me do.</source>
          <target state="translated">所以这里有一个重大的消息:大O可以帮我不做工作! 如果我认识大O,我就可以多玩一些,少做工作,多玩一些! 这就是大O帮我做的事情。</target>
        </trans-unit>
        <trans-unit id="f282cf5ef96e90a6a7f9b1e3944e8a0596d69aa5" translate="yes" xml:space="preserve">
          <source>So if you want to find a name in a phone book of a million names you can actually find any name by doing this at most 20 times.  In comparing search algorithms we decide that this comparison is our 'n'.</source>
          <target state="translated">所以,如果你想在一百万个名字的电话本中找到一个名字,实际上你最多做20次就能找到任何一个名字。在比较搜索算法时,我们决定这个比较是我们的 &quot;N&quot;。</target>
        </trans-unit>
        <trans-unit id="54d9d5007b7529ef62839a976a2c108028d8927a" translate="yes" xml:space="preserve">
          <source>So let's not do the work.  Let's you and me just think how hard it is.  How much work would I have to do, to add six numbers?</source>
          <target state="translated">所以,让我们不要去做这些工作。让你和我想想看,这有多难。我得做多少工作,才能把六个数字加起来?</target>
        </trans-unit>
        <trans-unit id="0f7963f5bf0d662a36fd7990d2218173d00f1e7f" translate="yes" xml:space="preserve">
          <source>So the Big-O of the Traveling Salesman problem is &lt;strong&gt;O(n!)&lt;/strong&gt; or &lt;strong&gt;factorial or combinatorial complexity&lt;/strong&gt;.</source>
          <target state="translated">因此，旅行推销员问题的Big-O是&lt;strong&gt;O（n！）&lt;/strong&gt;或&lt;strong&gt;阶乘或组合复杂度&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="31cbba1dd119c95cd531f79932736280f8bc1df4" translate="yes" xml:space="preserve">
          <source>So then you might understand what &quot;n&lt;sup&gt;2&lt;/sup&gt;&quot; means, but to be even more specific, play with the thought you have a simple, the simpliest of the sorting algorithms; bubblesort. This algorithm needs to look through the whole list, for each item.</source>
          <target state="translated">因此，您可能会理解&amp;ldquo; n &lt;sup&gt;2&lt;/sup&gt; &amp;rdquo;的含义，但更具体地讲，请您以为您拥有简单，最简单的排序算法； 泡泡糖 该算法需要查看每个项目的整个列表。</target>
        </trans-unit>
        <trans-unit id="f8d83ca9666fef6b181abee5dce4073e31010f19" translate="yes" xml:space="preserve">
          <source>So to find a name given the phone number (reverse lookup):</source>
          <target state="translated">所以要找一个名字给的电话号码(反向查询)。</target>
        </trans-unit>
        <trans-unit id="d9f1ae7f841915d3f4dd37e4ec3ed8f5c6a2d975" translate="yes" xml:space="preserve">
          <source>So to talk of big O, I will use words that have just one beat in them.  One sound per word.  Small words are quick.  You know these words, and so do I.  We will use words with one sound.  They are small.  I am sure you will know all of the words we will use!</source>
          <target state="translated">所以说起大O,我就用那些只有一个节拍的词来谈,那就是大O。每一个字一个音。小的词是快的。这些字你知道,我也知道,我们就用一拍一音的字。它们都是小字。相信大家一定会知道我们会用的字都是小字!</target>
        </trans-unit>
        <trans-unit id="1a6bae9cafba4af7ae15b7b23952da6ff1ac18ed" translate="yes" xml:space="preserve">
          <source>Some asymptotically superior algorithms (e.g. a non-comparison &lt;code&gt;O(N log(log(N)))&lt;/code&gt; sort) can have so large a constant factor (e.g. &lt;code&gt;100000*N log(log(N))&lt;/code&gt;), or overhead that is relatively large like &lt;code&gt;O(N log(log(N)))&lt;/code&gt; with a hidden &lt;code&gt;+ 100*N&lt;/code&gt;, that they are rarely worth using even on &quot;big data&quot;.</source>
          <target state="translated">一些渐近上乘的算法（例如，非比较 &lt;code&gt;O(N log(log(N)))&lt;/code&gt; 排序）可能具有如此大的常数因子（例如 &lt;code&gt;100000*N log(log(N))&lt;/code&gt; ），或者开销相对较大像 &lt;code&gt;O(N log(log(N)))&lt;/code&gt; 具有隐藏 &lt;code&gt;+ 100*N&lt;/code&gt; ，即使在&amp;ldquo;大数据&amp;rdquo;上，它们也很少值得使用。</target>
        </trans-unit>
        <trans-unit id="6c3a47a93192e21e7b8da9213efad49591e03019" translate="yes" xml:space="preserve">
          <source>Something to think about.</source>
          <target state="translated">有件事要考虑一下。</target>
        </trans-unit>
        <trans-unit id="4039fdaf71cb4809949b869888d7b88d6c807b40" translate="yes" xml:space="preserve">
          <source>Sounds simple?  Think again.</source>
          <target state="translated">听起来很简单?再想想看。</target>
        </trans-unit>
        <trans-unit id="3b9b41baa4e75cb4e6d6c6fd70132096551ccfd4" translate="yes" xml:space="preserve">
          <source>Subtraction is similar (except you may need to borrow instead of carry).</source>
          <target state="translated">减法是类似的(除了你可能需要借用而不是携带)。</target>
        </trans-unit>
        <trans-unit id="92cba8f42714e9e6f65905758a187f5dc1f81125" translate="yes" xml:space="preserve">
          <source>Such a beautifully simple and short question seems at least to deserve an equally short answer, like a student might receive during tutoring.</source>
          <target state="translated">这样一个漂亮简单而简短的问题,似乎至少应该得到一个同样简短的答案,就像学生在做家教时可能得到的那样。</target>
        </trans-unit>
        <trans-unit id="3c2db9ddb042cb95f6f3da33f58156282aae57f5" translate="yes" xml:space="preserve">
          <source>Suppose</source>
          <target state="translated">Suppose</target>
        </trans-unit>
        <trans-unit id="6497864fec97aa054dc0495fd9cf472b076841fc" translate="yes" xml:space="preserve">
          <source>Suppose you get notation &lt;code&gt;O(N^2)&lt;/code&gt;, not only you are clear the method takes N*N steps to accomplish a task, also you see that it's not good as &lt;code&gt;O(NlogN)&lt;/code&gt; from its ranking.</source>
          <target state="translated">假设您得到符号 &lt;code&gt;O(N^2)&lt;/code&gt; ，不仅您清楚该方法需要N * N个步骤来完成一项任务，而且从其排名来看，它还不如 &lt;code&gt;O(NlogN)&lt;/code&gt; 好。</target>
        </trans-unit>
        <trans-unit id="b05781eb417d58d8870e0c54b7d3d4450a3c5cf7" translate="yes" xml:space="preserve">
          <source>T(n)= The actual function that expresses the running time of the algorithm as a function of n</source>
          <target state="translated">T(n)=表示算法的运行时间为n的函数的实际函数</target>
        </trans-unit>
        <trans-unit id="223cc76142198af8e0fb0a088ef6eb8d1fdff9c7" translate="yes" xml:space="preserve">
          <source>Take this to 4 towns and you have (iirc) 12 possibilities.</source>
          <target state="translated">把它带到4个镇上,你就有(约)12种可能。</target>
        </trans-unit>
        <trans-unit id="6717a00806c940ae11e172679a7461df17fb3524" translate="yes" xml:space="preserve">
          <source>That is staggeringly good isn't it?</source>
          <target state="translated">这真是好得惊人,不是吗?</target>
        </trans-unit>
        <trans-unit id="2b3ca8fd4b8fd6b2746880e61409e1fcd178be5c" translate="yes" xml:space="preserve">
          <source>That's the gist of it. They reduce the maths down so it might not be exactly n&lt;sup&gt;2&lt;/sup&gt; or whatever they say it is, but that'll be the dominating factor in the scaling.</source>
          <target state="translated">这就是要旨。 他们降低了数学运算的精度，因此可能不是正好是n &lt;sup&gt;2&lt;/sup&gt;或他们所说的那样，但这将是缩放的主要因素。</target>
        </trans-unit>
        <trans-unit id="a335b2fdf194a4b123c6adefad53cd69da1191ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&lt;/code&gt; notation might be the more common one and is even used in papers by world-renowned computer scientists. Additionally, it is often the case that in a casual setting, people will say &lt;code&gt;O(...)&lt;/code&gt; when they mean &lt;code&gt;Ɵ(...)&lt;/code&gt;; this is technically true since the set of things &lt;code&gt;Ɵ(exactlyThis)&lt;/code&gt; is a subset of &lt;code&gt;O(noGreaterThanThis)&lt;/code&gt;... and it's easier to type. ;-)</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; 符号可能是更常见的符号，甚至被世界著名的计算机科学家在论文中使用。 另外，通常情况下，在随意的环境中，人们说mean &lt;code&gt;O(...)&lt;/code&gt; 时会说O &lt;code&gt;Ɵ(...)&lt;/code&gt; ； 从技术上讲这是正确的，因为事物集 &lt;code&gt;Ɵ(exactlyThis)&lt;/code&gt; 是 &lt;code&gt;O(noGreaterThanThis)&lt;/code&gt; 的子集...并且更容易键入。 ;-)</target>
        </trans-unit>
        <trans-unit id="aee94d96800326a2e37c8dd00dc11f09cbb047c7" translate="yes" xml:space="preserve">
          <source>The O in &quot;Big O&quot; refers to as &quot;Order&quot;(or precisely &quot;order of&quot;)</source>
          <target state="translated">大O &quot;中的 &quot;O &quot;指的是 &quot;秩序&quot;(或 &quot;秩序&quot;)。</target>
        </trans-unit>
        <trans-unit id="bc4389e9f64069d428331282297c6e278a98864d" translate="yes" xml:space="preserve">
          <source>The Telephone Book</source>
          <target state="translated">电话簿</target>
        </trans-unit>
        <trans-unit id="8cb03116d21f7000400f4bb7814a757a5f5a7de1" translate="yes" xml:space="preserve">
          <source>The Traveling Salesman</source>
          <target state="translated">旅行的推销员</target>
        </trans-unit>
        <trans-unit id="72a9a665cf2e8f84b6ab25450c58c79f3d3908aa" translate="yes" xml:space="preserve">
          <source>The above issues, like the effect of the choice of which programming language is used, are almost never considered as part of the constant factor (nor should they be); yet one should be aware of them because &lt;em&gt;sometimes&lt;/em&gt; (though rarely) they may affect things. For example in cpython, the native priority queue implementation is asymptotically non-optimal (&lt;code&gt;O(log(N))&lt;/code&gt; rather than &lt;code&gt;O(1)&lt;/code&gt; for your choice of insertion or find-min); do you use another implementation? Probably not, since the C implementation is probably faster, and there are probably other similar issues elsewhere. There are tradeoffs; sometimes they matter and sometimes they don't.</source>
          <target state="translated">上述问题，就像选择哪种编程语言的效果一样，几乎永远不会被视为恒定因素的一部分（也不应该）。 但是人们应该意识到它们，因为&lt;em&gt;有时&lt;/em&gt; （尽管很少）它们会影响事物。 例如，在cpython中，本机优先级队列实现不是渐近最优的（对于您选择插入还是find-min来说，是 &lt;code&gt;O(log(N))&lt;/code&gt; 而不是 &lt;code&gt;O(1)&lt;/code&gt; ）； 您是否使用其他实现？ 可能不是，因为C的实现可能更快，并且其他地方可能还有其他类似的问题。 需要权衡； 有时它们很重要，有时却不重要。</target>
        </trans-unit>
        <trans-unit id="a92aef1bcf2b613748cc674288c56712f50682e2" translate="yes" xml:space="preserve">
          <source>The above statement is a good start but not completely true.</source>
          <target state="translated">上述说法是一个好的开始,但并不完全正确。</target>
        </trans-unit>
        <trans-unit id="af10522e397a98644d31608e45e48cac65ff2486" translate="yes" xml:space="preserve">
          <source>The analogy for amortized analysis:</source>
          <target state="translated">摊销分析的比喻。</target>
        </trans-unit>
        <trans-unit id="fccd0576a93e2738b676fa9e76398601f6ab71b0" translate="yes" xml:space="preserve">
          <source>The astute may have realized that we could express the number of operations as: n&lt;sup&gt;2&lt;/sup&gt; + 2n.  But as you saw from our example with two numbers of a million digits apiece, the second term (2n) becomes insignificant (accounting for 0.0002% of the total operations by that stage).</source>
          <target state="translated">机敏的人可能已经意识到我们可以将操作数表示为：n &lt;sup&gt;2&lt;/sup&gt; + 2n。 但是，正如您从我们的示例中看到的那样，每个例子都有两个一百万个数字，第二项（2n）变得微不足道（占该阶段总操作数的0.0002％）。</target>
        </trans-unit>
        <trans-unit id="11fa8c026f804b110c22f62945ac720ce5e2b7ce" translate="yes" xml:space="preserve">
          <source>The bad:</source>
          <target state="translated">坏的是。</target>
        </trans-unit>
        <trans-unit id="8b80f48d4022e94ff91f1dba565c167cfe545120" translate="yes" xml:space="preserve">
          <source>The basics: Whenever we interact with every element in a collection of size A (such as an array, a set, all keys of a map, etc.), or perform A iterations of a loop, that is a multiplicative factor of size A. Why do I say &quot;a multiplicative factor&quot;?--because loops and functions (almost by definition) have multiplicative running time: the number of iterations, times work done in the loop (or for functions: the number of times you call the function, times work done in the function). (This holds if we don't do anything fancy, like skip loops or exit the loop early, or change control flow in the function based on arguments, which is very common.) Here are some examples of visualization techniques, with accompanying pseudocode.</source>
          <target state="translated">的基础知识。每当我们与一个大小为A的集合中的每一个元素(如数组、集、映射的所有键等)交互时,或者执行循环的A次迭代时,就是一个大小为A的乘法系数。(如果我们不做任何花哨的事情,比如跳过循环或提前退出循环,或者根据参数改变函数中的控制流,这一点是很常见的)。下面是一些可视化技术的例子,并附带了一些伪代码。</target>
        </trans-unit>
        <trans-unit id="1ed7c47cc1915e8456623ae236c31623cd7a6dd2" translate="yes" xml:space="preserve">
          <source>The best example of Big-O I can think of is doing arithmetic.  Take two numbers (123456 and 789012).  The basic arithmetic operations we learnt in school were:</source>
          <target state="translated">我能想到的大O最好的例子就是做算术。就拿两个数字(123456和789012)来说吧。我们在学校里学过的基本算术运算是。</target>
        </trans-unit>
        <trans-unit id="6ae878297661e38f79a2d80036a322346800b990" translate="yes" xml:space="preserve">
          <source>The cost of solving the problem is proportional to the size of the problem.  If your problem doubles in size, then the cost of the solution doubles.  Since most problems have to be scanned into the computer in some way, as data entry, disk reads, or network traffic, this is generally an affordable scaling factor.</source>
          <target state="translated">解决问题的成本与问题的大小成正比。如果你的问题大小增加一倍,那么解决问题的成本就会增加一倍。因为大多数问题都要以某种方式扫描到计算机中,如数据录入、磁盘读取或网络流量等,这一般是一个可以承受的缩放系数。</target>
        </trans-unit>
        <trans-unit id="edbb1eb4311e72da0d8581264edd414e194f9ea0" translate="yes" xml:space="preserve">
          <source>The equation is read as 
As n approaches infinity, T of n, is less than or equal to c times f of n.</source>
          <target state="translated">式中,当n接近无穷大时,n的T小于或等于n的c乘以f。</target>
        </trans-unit>
        <trans-unit id="7696e2ee0fe03e7287025d1b9b1e590710edef6e" translate="yes" xml:space="preserve">
          <source>The first sort was O(n squared).  But Quick Sort is O(n log n).  You know that n log n is less than n squared, for big n, right?  Well, that is how we know that Quick Sort is fast!</source>
          <target state="translated">第一个排序是O(n平方)。但快速排序是O(n log n)。你知道n对数n对数小于n的平方,对于大的n来说,你知道吗? 那么,我们就知道Quick Sort的速度很快!</target>
        </trans-unit>
        <trans-unit id="ef63c6ddf6e7a7898b093aa5fa501850b023edae" translate="yes" xml:space="preserve">
          <source>The flow here would be:</source>
          <target state="translated">这里的流程是:</target>
        </trans-unit>
        <trans-unit id="d7c2775507fbff85fd208fcd7a9eefd861c88ccd" translate="yes" xml:space="preserve">
          <source>The good:</source>
          <target state="translated">的好。</target>
        </trans-unit>
        <trans-unit id="40776bd664da80434dcafa973f539de3f9f745d5" translate="yes" xml:space="preserve">
          <source>The input size is usually the space in bits needed to represent the input.</source>
          <target state="translated">输入的大小通常是表示输入所需的比特空间。</target>
        </trans-unit>
        <trans-unit id="d1b781877a2eef3021049a9a0ec22cac469bc50c" translate="yes" xml:space="preserve">
          <source>The moral of the story: a data structure lets us speed up operations. Even more, advanced data structures can let you combine, delay, or even ignore operations in incredibly clever ways. Different problems would have different analogies, but they'd all involve organizing the data in a way that exploits some structure we care about, or which we've artificially imposed on it for bookkeeping. We do work ahead of time (basically planning and organizing), and now repeated tasks are much much easier!</source>
          <target state="translated">这个故事的寓意:数据结构可以让我们加快操作速度。更重要的是,高级的数据结构可以让你以非常巧妙的方式合并、延迟甚至忽略操作。不同的问题会有不同的类比,但它们都会涉及到以一种利用我们所关心的某种结构,或者说我们人为地强加给它做账的方式来组织数据。我们提前做工作(基本上是计划和组织),现在重复的任务就容易多了!</target>
        </trans-unit>
        <trans-unit id="431150559f3afdb40719059de8cafc2364a6f27a" translate="yes" xml:space="preserve">
          <source>The new work is: add all things from one to n.</source>
          <target state="translated">新的工作是:把所有的东西从1加到N。</target>
        </trans-unit>
        <trans-unit id="9734a1f2bb99a793e146aed547eba3d5bde616de" translate="yes" xml:space="preserve">
          <source>The next best example I can think of is the telephone book, normally called the White Pages or similar but it varies from country to country.  But I'm talking about the one that lists people by surname and then initials or first name, possibly address and then telephone numbers.</source>
          <target state="translated">我能想到的下一个最好的例子是电话簿,通常被称为白页或类似的电话簿,但每个国家的情况都不一样。但我说的是按姓氏,然后是首字母或名字,可能是地址,然后是电话号码。</target>
        </trans-unit>
        <trans-unit id="30a4b2c863fa4772ef38b8845a347878d2aa00fa" translate="yes" xml:space="preserve">
          <source>The number of computations is only increased by a log of the input value.  So in this case, assuming each computation takes 1 second, the log of the input &lt;code&gt;n&lt;/code&gt; is the time required, hence &lt;code&gt;log n&lt;/code&gt;.</source>
          <target state="translated">计算数量仅增加输入值的对数。 因此，在这种情况下，假设每次计算花费1秒，则输入 &lt;code&gt;n&lt;/code&gt; 的对数为所需时间，因此为 &lt;code&gt;log n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3aad895641cfd48567e63f48472fae12fcf69c0b" translate="yes" xml:space="preserve">
          <source>The number of items is still increasing by a factor of 10, but the scaling factor of O(1) is always 1.</source>
          <target state="translated">项数仍以10的倍数增加,但O(1)的缩放系数始终为1。</target>
        </trans-unit>
        <trans-unit id="4e86a40dc1403a10780f816da6e77341ee5ea1e5" translate="yes" xml:space="preserve">
          <source>The only thing that these &quot;Big-Oh&quot; expressions try to do is to describe how much the software slows down as we increase the amount of data that the software has to process. If we double the amount of data that needs to be processed, does the software need twice as long to finish it's work? Ten times as long? In practice, there are a very limited number of big-Oh expressions that you will encounter and need to worry about:</source>
          <target state="translated">而这些 &quot;大奥 &quot;的表达方式,只是在我们增加软件处理数据量的时候,软件的速度会减慢多少,这才是我们所要做的事情。如果我们把需要处理的数据量增加一倍,软件需要两倍的时间来完成工作吗?是十倍的时间?在实际工作中,你会遇到和需要担心的大Oh表达式是非常有限的。</target>
        </trans-unit>
        <trans-unit id="0c4ac6494f1b66e30eda83ca592154e03a3a8fc2" translate="yes" xml:space="preserve">
          <source>The same can be said for the &lt;strong&gt;very act of writing&lt;/strong&gt;. All algorithms which print out N things will take N time because the output is at least that long (e.g. printing out all permutations (ways to rearrange) a set of N playing cards is factorial: &lt;code&gt;O(N!)&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;写作的行为&lt;/strong&gt;也可以这样说。 所有输出N事物的算法都将花费N时间，因为输出至少需要那么长的时间（例如，输出一组N张扑克牌的所有排列（重新排列的方式）是阶乘： &lt;code&gt;O(N!)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cf763b5c77d1eaec2bb764fe4187dc0b86926fc4" translate="yes" xml:space="preserve">
          <source>The simplest definition I can give for Big-O notation is this:</source>
          <target state="translated">我可以给Big-O记号法下的最简单的定义是这样的。</target>
        </trans-unit>
        <trans-unit id="9316c2f2fa69e85df7f06354c94d1417cfb91787" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;O( &amp;lt;some expression X involving n&amp;gt; )&lt;/code&gt; means, in simple English:</source>
          <target state="translated">然后， &lt;code&gt;O( &amp;lt;some expression X involving n&amp;gt; )&lt;/code&gt; 意思是简单的英语：</target>
        </trans-unit>
        <trans-unit id="8d780e455cede763fea2fd15a77afe9241e0ac7a" translate="yes" xml:space="preserve">
          <source>Then as far as Big O is concerned, the approximation f(n) is considered good enough as long as the below condition is true.</source>
          <target state="translated">那么就大O而言,只要下面的条件为真,近似值f(n)就被认为是足够好的。</target>
        </trans-unit>
        <trans-unit id="ee898084770160432d4052d1b6366394874b74dc" translate="yes" xml:space="preserve">
          <source>There are many choices of constant; often the &quot;best&quot; choice is known as the &quot;constant factor&quot; of the algorithm... but we often ignore it like we ignore non-largest terms (see Constant Factors section for why they don't usually matter). You can also think of the above equation as a bound, saying &quot;&lt;em&gt;In the worst-case scenario, the time it takes will never be worse than roughly &lt;code&gt;N*log(N)&lt;/code&gt;, within a factor of 2.5 (a constant factor we don't care much about)&lt;/em&gt;&quot;.</source>
          <target state="translated">常量有很多选择。 通常，&amp;ldquo;最佳&amp;rdquo;选择被称为算法的&amp;ldquo;恒定因子&amp;rdquo;&amp;hellip;&amp;hellip;但是我们经常忽略它，就像我们忽略非最大的项（有关为什么它们通常无关紧要，请参见&amp;ldquo;恒定因子&amp;rdquo;部分）。 您还可以将上述等式视为一个边界，说：&amp;ldquo; &lt;em&gt;在最坏的情况下，所花费的时间永远不会比大约 &lt;code&gt;N*log(N)&lt;/code&gt; 差2.5倍以内（我们不愿不在乎）&lt;/em&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f3b28edc57f1a5b8e2ff6393649371701cff785f" translate="yes" xml:space="preserve">
          <source>There are some important and deliberately chosen words in that sentence:</source>
          <target state="translated">这句话里有一些重要的、刻意选择的词语。</target>
        </trans-unit>
        <trans-unit id="735800377cfb894185f412511981fdfbdcaa94c0" translate="yes" xml:space="preserve">
          <source>There is a lot of information that Big O does not tell you about a given algorithm. It cuts to the bone and gives only information about the scaling nature of an algorithm, specifically how the resource use (think time or memory) of an algorithm scales in response to the &quot;input size&quot;.</source>
          <target state="translated">有很多信息是大O没有告诉你关于一个给定算法的信息。它切中要害,只给出了关于算法的缩放性质的信息,具体来说,就是算法的资源使用(认为时间或内存)是如何随着 &quot;输入大小 &quot;的变化而缩放的。</target>
        </trans-unit>
        <trans-unit id="7dc156313731adb22242f60a31c42c25a7fac861" translate="yes" xml:space="preserve">
          <source>There is also the concept of &quot;amortized&quot; and/or &quot;average case&quot; (note that these are different).</source>
          <target state="translated">还有 &quot;摊余 &quot;和 &quot;平均情况 &quot;的概念(注意,这两个概念是不同的)。</target>
        </trans-unit>
        <trans-unit id="e29aa2b4c76e872003711e1f9ca7f22087d1cd30" translate="yes" xml:space="preserve">
          <source>These are the bread-and-butter orders of growth that programmers and applied computer scientists use as reference points. They see these all the time. (So while you could technically think &quot;Doubling the input makes an O(&amp;radic;N) algorithm 1.414 times slower,&quot; it's better to think of it as &quot;this is worse than logarithmic but better than linear&quot;.)</source>
          <target state="translated">这些是程序员和应用程序计算机科学家用作参考的增长的基础。 他们总是看到这些。 （因此，从技术上讲，您可能会认为&amp;ldquo;加倍输入会使O（&amp;radic;N）算法的速度降低1.414倍&amp;rdquo;，最好将其视为&amp;ldquo;这比对数差，但比线性差&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="337e7f754779241ba422c3ed16228e880e17fea7" translate="yes" xml:space="preserve">
          <source>They gave us a deck of ten cards.  They are all mixed up: seven, four, two, six&amp;hellip; not straight at all.  And now... our job is to sort them.</source>
          <target state="translated">他们给了我们十张纸牌。 他们混在一起：七个，四个，两个，六个&amp;hellip;&amp;hellip;根本不是直线。 现在...我们的工作是对它们进行排序。</target>
        </trans-unit>
        <trans-unit id="8a4cba2479bcff691f23bf7a823abac5f2bfc677" translate="yes" xml:space="preserve">
          <source>This algorithm search a list, item by item, looking for a key,</source>
          <target state="translated">这个算法逐项搜索一个列表,逐项搜索,寻找一个关键。</target>
        </trans-unit>
        <trans-unit id="b5ccab1dbe3c98b30c65b7179a45c56dcba85b06" translate="yes" xml:space="preserve">
          <source>This complexity is the same as &lt;strong&gt;O(1)&lt;/strong&gt; except that it's just a little bit worse.  For all practical purposes, you can consider this as a very large constant scaling.  The difference in work between processing 1 thousand and 1 billion items is only a factor six.</source>
          <target state="translated">这种复杂性与&lt;strong&gt;O（1）&lt;/strong&gt;相同，只是稍微更糟。 出于所有实际目的，您可以将其视为非常大的恒定比例。 处理1000个项目和10亿个项目之间的工作差异只有六分之一。</target>
        </trans-unit>
        <trans-unit id="a8f1f1c12dab816384a465eef99dc533c1871709" translate="yes" xml:space="preserve">
          <source>This complexity is very similar to &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt;.  For all practical purposes, the two are equivalent.  This level of complexity would generally still be considered scalable.  By tweaking assumptions some &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; algorithms can be transformed into &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; algorithms.  For example, bounding the size of keys reduces sorting from &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; to &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt;.</source>
          <target state="translated">这种复杂性与&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; ）&lt;/strong&gt;非常相似。 出于所有实际目的，两者是等效的。 这种复杂程度通常仍被认为是可扩展的。 通过调整假设，可以将某些&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; ）&lt;/strong&gt;算法转换为&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; ）&lt;/strong&gt;算法。 例如，限制键的大小可以减少从&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; ）&lt;/strong&gt;到&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; ）的&lt;/strong&gt;排序。</target>
        </trans-unit>
        <trans-unit id="c5691b3f2dea4e40f3c7e1067faf693cc2b99d29" translate="yes" xml:space="preserve">
          <source>This is O n&lt;sup&gt;2&lt;/sup&gt; because, you need to look at all items in the list there are &quot;n&quot; items. For each item, you look at all items once more, for comparing, this is also &quot;n&quot;, so for every item, you look &quot;n&quot; times meaning n*n = n&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">这是O n &lt;sup&gt;2，&lt;/sup&gt;因为您需要查看列表中所有包含&amp;ldquo; n&amp;rdquo;个项目的项目。 对于每个项目，您再次查看所有项目，以进行比较，这也是&amp;ldquo; n&amp;rdquo;，因此对于每个项目，您查看&amp;ldquo; n&amp;rdquo;次，这意味着n * n = n &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="653edd1e3ffbc6849cab3e84f2d2f1adb0553312" translate="yes" xml:space="preserve">
          <source>This is a function of a mathematical operation called a &lt;strong&gt;factorial&lt;/strong&gt;.  Basically:</source>
          <target state="translated">这是称为&lt;strong&gt;阶乘&lt;/strong&gt;的数学运算的函数。 基本上：</target>
        </trans-unit>
        <trans-unit id="68bbac89d75f8c9b12a85ecf9405e267e936bef2" translate="yes" xml:space="preserve">
          <source>This is a very simplified explanation, but I hope it covers most important details.</source>
          <target state="translated">这是一个非常简单的解释,但我希望它能涵盖最重要的细节。</target>
        </trans-unit>
        <trans-unit id="690e85c5f1f320cb604423824b8a84e4db475373" translate="yes" xml:space="preserve">
          <source>This is called a &lt;strong&gt;binary search&lt;/strong&gt; and is used every day in programming whether you realize it or not.</source>
          <target state="translated">这称为&lt;strong&gt;二进制搜索&lt;/strong&gt; ，无论您是否意识到，它每天都在编程中使用。</target>
        </trans-unit>
        <trans-unit id="903158538d58a924a96daad121dc96f748e16115" translate="yes" xml:space="preserve">
          <source>This is quite a famous problem in computer science and deserves a mention.  In this problem you have N towns. Each of those towns is linked to 1 or more other towns by a road of a certain distance. The Traveling Salesman problem is to find the shortest tour that visits every town.</source>
          <target state="translated">这在计算机科学中是一个相当著名的问题,值得一提的是。在这个问题中,你有N个城镇。每一个城镇通过一定距离的道路连接到1个或多个其他城镇。旅行推销员问题就是要找到访问每个城镇的最短的旅游路线。</target>
        </trans-unit>
        <trans-unit id="9d90c6f6b5d97d1a3566515111185bfdbbdad847" translate="yes" xml:space="preserve">
          <source>This is read as T of n is in big O of n.</source>
          <target state="translated">这读作n的T在大O的n中。</target>
        </trans-unit>
        <trans-unit id="581db2374f66d9fecedf4263af206b8b003578d9" translate="yes" xml:space="preserve">
          <source>This lets us make statements like...</source>
          <target state="translated">这让我们的声明像.....</target>
        </trans-unit>
        <trans-unit id="4f23f5a057b81398db00b66517d931e311e15ad5" translate="yes" xml:space="preserve">
          <source>This motivates the use of &lt;strong&gt;data structures&lt;/strong&gt;: a data structure requires reading the data only once (usually &lt;code&gt;O(N)&lt;/code&gt; time), plus some arbitrary amount of preprocessing (e.g. &lt;code&gt;O(N)&lt;/code&gt; or &lt;code&gt;O(N log(N))&lt;/code&gt; or &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt;) which we try to keep small. Thereafter, modifying the data structure (insertions/deletions/ etc.) and making queries on the data take very little time, such as &lt;code&gt;O(1)&lt;/code&gt; or &lt;code&gt;O(log(N))&lt;/code&gt;. You then proceed to make a large number of queries! In general, the more work you're willing to do ahead of time, the less work you'll have to do later on.</source>
          <target state="translated">这激发了&lt;strong&gt;数据结构&lt;/strong&gt;的使用：数据结构只需要读取一次数据（通常为 &lt;code&gt;O(N)&lt;/code&gt; 时间），再加上任意数量的预处理（例如 &lt;code&gt;O(N)&lt;/code&gt; 或 &lt;code&gt;O(N log(N))&lt;/code&gt; 或 &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; ），我们尽量保持较小。 之后，修改数据结构（插入/删除/等）并查询数据需要很少的时间，例如 &lt;code&gt;O(1)&lt;/code&gt; 或 &lt;code&gt;O(log(N))&lt;/code&gt; 。 然后，您继续进行大量查询！ 通常，您愿意提前完成的工作越多，以后要做的工作就越少。</target>
        </trans-unit>
        <trans-unit id="4d08321928b5477592d3f3be8d0fbf595ccedfeb" translate="yes" xml:space="preserve">
          <source>This sort is quite quick.  How quick?  Big O tells us: this sort needs O(n log n) work to be done, in the mean case.</source>
          <target state="translated">这类是相当快的。有多快?大O告诉我们:这种排序需要O(n log n)的工作,在平均数的情况下,。</target>
        </trans-unit>
        <trans-unit id="efa77e0837d728c026f108a7c6a880857648e39a" translate="yes" xml:space="preserve">
          <source>This time the number of items increases by a factor of 10, and so does the time. n=10 and so O(n)'s scaling factor is 10.</source>
          <target state="translated">这时项目的数量增加了10的系数,时间也增加了10,n=10,所以O(n)的缩放系数为10。</target>
        </trans-unit>
        <trans-unit id="e6a399976506e2d7ce3f3c1d1884c9c4671f0528" translate="yes" xml:space="preserve">
          <source>This type of algorithm is described as O(log N). The iterative halving
  of data sets described in the binary search example produces a growth
  curve that peaks at the beginning and slowly flattens out as the size
  of the data sets increase e.g. an input data set containing 10 items
  takes one second to complete, a data set containing 100 items takes
  two seconds, and a data set containing 1000 items will take three
  seconds. Doubling the size of the input data set has little effect on
  its growth as after a single iteration of the algorithm the data set
  will be halved and therefore on a par with an input data set half the
  size. This makes algorithms like binary search extremely efficient
  when dealing with large data sets.</source>
          <target state="translated">这种类型的算法被描述为O(log N)。二进制搜索示例中描述的数据集迭代减半产生了一条增长曲线,该曲线在开始时达到峰值,随着数据集大小的增加而慢慢变平,例如,一个包含10个项目的输入数据集需要1秒完成,一个包含100个项目的数据集需要2秒,而一个包含1000个项目的数据集需要3秒。将输入数据集的大小增加一倍,对数据集的增长影响不大,因为在算法的一次迭代后,数据集将减少一半,因此与输入数据集的一半大小相当。这使得像二进制搜索这样的算法在处理大数据集时效率极高。</target>
        </trans-unit>
        <trans-unit id="ff64700b92668ef5d8bf1eab2150e242d95be66f" translate="yes" xml:space="preserve">
          <source>Though, if you're &lt;a href=&quot;https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks&quot;&gt;reasonably worried&lt;/a&gt; about an attacker, there are many other algorithmic attack vectors to worry about besides amortization and average-case.)</source>
          <target state="translated">不过，如果您&lt;a href=&quot;https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks&quot;&gt;合理地担心&lt;/a&gt;攻击者，那么除摊销和平均情况外，还有许多其他算法攻击媒介值得担心。）</target>
        </trans-unit>
        <trans-unit id="7c6809222de67cf731ce03e2166eb7926bfb38c0" translate="yes" xml:space="preserve">
          <source>Three: I go from the end card up, and I look for a card that is more low than the splay card.</source>
          <target state="translated">三、三张。我从底牌开始往上走,我找的牌是比SPLAY牌低的牌。</target>
        </trans-unit>
        <trans-unit id="b5dad2a734641d4c6735ae21c27019cfea0c15e8" translate="yes" xml:space="preserve">
          <source>Time(Best-Case) = 4</source>
          <target state="translated">时间(最佳情况)=4</target>
        </trans-unit>
        <trans-unit id="2f997ae62ba9c69b3cf6edcf0d119e5ddad840f2" translate="yes" xml:space="preserve">
          <source>Time(Worst-Case) = 4n+1</source>
          <target state="translated">时间(最坏情况)=4n+1</target>
        </trans-unit>
        <trans-unit id="2b30e732d21d07f2640a46e069dde7480df7216e" translate="yes" xml:space="preserve">
          <source>Time: &amp;Omega;(4) = O(1) ~ Instant\Constant</source>
          <target state="translated">时间：&amp;Omega;（4）= O（1）〜瞬时\恒定</target>
        </trans-unit>
        <trans-unit id="8d4bf6a7efc118b94944a2fdcb4199b6b5436673" translate="yes" xml:space="preserve">
          <source>Time: O(4n+1) = O(n) | in Big-O, constants are neglected</source>
          <target state="translated">时间:O(4n+1)=O(n)</target>
        </trans-unit>
        <trans-unit id="78b1d548645a6f4313e845c0d6995f63dbc656ee" translate="yes" xml:space="preserve">
          <source>To add from one to six, that is some work.  But do you see, to add from one to ten, that is more work?</source>
          <target state="translated">从一加到六,那是要做一些工作的。但你看,从一加到十,那是更多的工作吗?</target>
        </trans-unit>
        <trans-unit id="2ee6a9060e778ab6f2fbe6d42d7bf3bf75ff7755" translate="yes" xml:space="preserve">
          <source>To me, I think of big O like a big, slow, boss man.  He thinks on work, but he does not do it.  He might say, &quot;That work is quick.&quot;  Or, he might say, &quot;That work is so slow and hard!&quot;  But he does not do the work.  He just looks at the work, and then he tells us how much time it might take.</source>
          <target state="translated">在我眼里,大O就像一个慢条斯理的老大爷。他想的是工作,但他不会去做。他可能会说:&quot;那工作真快啊!&quot; 或者,他可能会说,&quot;那工作好慢,好辛苦!&quot; 但是,他并没有去做工作。他只是看着工作,然后告诉我们可能需要多少时间。</target>
        </trans-unit>
        <trans-unit id="5580a107c59a84aea6247983205780ae9a93ffac" translate="yes" xml:space="preserve">
          <source>To say that binary search has a running time of O(logn) is to say that there exists some constant c which you can multiply log(n) by that will always be larger than the running time of binary search.  In this case you will always have some constant factor of log(n) comparisons.</source>
          <target state="translated">说二进制搜索的运行时间为O(logn),就是说存在一些常数c,你可以将其乘以log(n),这个常数总是大于二进制搜索的运行时间。在这种情况下,你总是会有一些log(n)比较的常数系数。</target>
        </trans-unit>
        <trans-unit id="b4476ee9defb91e4168e19a3dcd129163cca85a4" translate="yes" xml:space="preserve">
          <source>Two: I splay the deck on that card you chose.  What is this splay; how do I splay?  Well, I go from the start card down, one by one, and I look for a card that is more high than the splay card.</source>
          <target state="translated">二:我把牌组放上你选的那张牌。这个SPLAY是什么;我怎么SPLAY?嗯,我从起始牌开始,一张一张的往下走,我找一张比splay牌高的牌。</target>
        </trans-unit>
        <trans-unit id="7b569bf8286d4c929a479c4976f45922a580f422" translate="yes" xml:space="preserve">
          <source>Uh oh, more work.  Now, let&amp;rsquo;s not do the work.  But, let&amp;rsquo;s make a plan to do it, step by step.</source>
          <target state="translated">嗯，还有更多工作。 现在，让我们不做这项工作。 但是，让我们逐步制定一个计划。</target>
        </trans-unit>
        <trans-unit id="66ec3cb6bc2e6fcaea19ddeb58c0027ecdebce58" translate="yes" xml:space="preserve">
          <source>Unrelatedly but worth mentioning again: If we perform a hash (e.g. a dictionary/hashtable lookup), that is a factor of O(1). That's pretty fast.</source>
          <target state="translated">不相关,但值得再次提及。如果我们执行一个哈希(例如字典hashtable查找),那就是O(1)的系数。这是相当快的。</target>
        </trans-unit>
        <trans-unit id="ceb436949ce49c2aad7d40dd4b74113a2a9f4743" translate="yes" xml:space="preserve">
          <source>Using a tumble dryer: you put 10 shirts in each load, and then they're done an hour later. (Ignore the actual numbers here &amp;mdash; they're irrelevant.) So drying 50 shirts takes &lt;em&gt;about&lt;/em&gt; 5 times as long as drying 10 shirts.</source>
          <target state="translated">使用滚筒式干衣机：每次装载10件衬衫，一个小时后完成。 （忽略此处的实际数字-无关紧要。）因此，烘干50件衬衫所需的时间&lt;em&gt;大约&lt;/em&gt;是烘干10件衬衫所需时间的5倍。</target>
        </trans-unit>
        <trans-unit id="c1627c2d9bf38d1a8bf4e6c4db14ba36e137fed7" translate="yes" xml:space="preserve">
          <source>Using a washing line outside: assuming you have an infinitely large back yard, washing dries in O(1) time. However much you have of it, it'll get the same sun and fresh air, so the size doesn't affect the drying time.</source>
          <target state="translated">在室外使用洗涤线:假设你有一个无限大的后院,洗涤干燥时间为O(1)时间。无论你有多少,它都会得到同样的阳光和新鲜空气,所以大小不影响烘干时间。</target>
        </trans-unit>
        <trans-unit id="32fee750e2bced1ef4713977d7422997ac4d01b8" translate="yes" xml:space="preserve">
          <source>Usually, we don't care what the specific constant factors are, because they don't affect the way the function grows. For example, two algorithms may both take &lt;code&gt;O(N)&lt;/code&gt; time to complete, but one may be twice as slow as the other. We usually don't care too much unless the factor is very large since optimizing is tricky business ( &lt;a href=&quot;https://stackoverflow.com/questions/385506/when-is-optimisation-premature&quot;&gt;When is optimisation premature?&lt;/a&gt; ); also the mere act of picking an algorithm with a better big-O will often improve performance by orders of magnitude.</source>
          <target state="translated">通常，我们不在乎特定的常量因子是什么，因为它们不会影响函数的增长方式。 例如，两种算法可能都需要 &lt;code&gt;O(N)&lt;/code&gt; 时间才能完成，但是一种算法的速度可能是另一种算法的两倍。 我们通常不会太在乎，除非该因素非常大，因为优化是一项棘手的业务（ &lt;a href=&quot;https://stackoverflow.com/questions/385506/when-is-optimisation-premature&quot;&gt;优化何时过早？&lt;/a&gt; ）； 同样，仅选择具有更好的big-O的算法的动作通常也会将性能提高几个数量级。</target>
        </trans-unit>
        <trans-unit id="ec6a77a1f38d77785d38e6e7cc1d9af0e804cfa3" translate="yes" xml:space="preserve">
          <source>Very Quick Note:</source>
          <target state="translated">非常快速的说明。</target>
        </trans-unit>
        <trans-unit id="6d21f45bec9f10023aec098341e6f6c03c5b13c1" translate="yes" xml:space="preserve">
          <source>Via examples, this helped get the bare basics into my tortoiseshell-like skull, so I think it's a pretty descent 10-minute read to get you headed in the right direction.</source>
          <target state="translated">通过实例,这帮助我把最基本的基础知识了解到了玳瑁一样的头骨,所以我认为这是一个相当下流的10分钟的阅读,可以让你朝着正确的方向前进。</target>
        </trans-unit>
        <trans-unit id="6aab5f5e334f1c425e8cc5c3149d2485a2ab6b43" translate="yes" xml:space="preserve">
          <source>Wait!  What is n?  Did I miss that?  How can I add from one to n if you don&amp;rsquo;t tell me what n is?</source>
          <target state="translated">等待！ 什么是n？ 我想念吗？ 如果您不告诉我n是什么，我怎么能从n加到n？</target>
        </trans-unit>
        <trans-unit id="2f7ade3e8b4a45caea9bbfc55450f4d016746563" translate="yes" xml:space="preserve">
          <source>We are trying to see how the number of input parameters, affects the running time of an algorithm. If the running time of your application is proportional to the number of input parameters, then it is said to be in Big O of n.</source>
          <target state="translated">我们想看看输入参数的数量,是如何影响一个算法的运行时间的。如果你的应用程序的运行时间与输入参数的数量成正比,那么就可以说是在n的大O中。</target>
        </trans-unit>
        <trans-unit id="d3658b52f527a76c6421772c73ea4511ef27a0b9" translate="yes" xml:space="preserve">
          <source>We can just rearrange this and see it's O(N):</source>
          <target state="translated">我们只要重新排列一下,就可以看到它是O(N)。</target>
        </trans-unit>
        <trans-unit id="a081699494ed4f022754488ece9b2b843bf6728d" translate="yes" xml:space="preserve">
          <source>Well actually there's less than that because some of these are equivalent (A &amp;rarr; B &amp;rarr; C and C &amp;rarr; B &amp;rarr; A are equivalent, for example, because they use the same roads, just in reverse).</source>
          <target state="translated">好吧，实际上还不止这些，因为其中一些是等效的（例如，A&amp;rarr;B&amp;rarr;C和C&amp;rarr;B&amp;rarr;A是等效的，因为它们使用相同的道路，只是反向）。</target>
        </trans-unit>
        <trans-unit id="f33910e9a426fbc1a12d1f88603bfdd1d8ca337f" translate="yes" xml:space="preserve">
          <source>Well, I don&amp;rsquo;t know what n is.  I was not told.  Were you?  No?   Oh well.  So we can&amp;rsquo;t do the work.  Whew.</source>
          <target state="translated">好吧，我不知道n是什么。 没有告诉我。 是你吗 没有？ 那好吧。 所以我们不能做这项工作。 ew。</target>
        </trans-unit>
        <trans-unit id="4b2089e7aacf0c6fcb7cbbe9c09999beabffc5dd" translate="yes" xml:space="preserve">
          <source>Well, I guess I would have to do ten adds&amp;hellip; one for each thing from one to ten.  Ten is more than six.  I would have to work that much more to add from one to ten, than one to six!</source>
          <target state="translated">好吧，我想我将不得不做十个加法...每件事从一到十。 十等于六。 我必须付出更多的努力才能从一增加到十，而不是一到六个！</target>
        </trans-unit>
        <trans-unit id="448ecbc620762a34ee90c323b9d2af296de94e73" translate="yes" xml:space="preserve">
          <source>Well, I will not do the work to add them now.  But I know how hard it would be.  It would be six adds.</source>
          <target state="translated">好吧,我现在就不做添加他们的工作了。但我知道这有多难。这将是6个加法。</target>
        </trans-unit>
        <trans-unit id="e6092f44041d9afec7369ff2f52755377d43518f" translate="yes" xml:space="preserve">
          <source>Well, how much work would that be, to sort the cards with those rules?</source>
          <target state="translated">那么,用这些规则来分类卡片,那要多大的工作量?</target>
        </trans-unit>
        <trans-unit id="3a69be1de24839373d5d994ccbcc98a836e1d23b" translate="yes" xml:space="preserve">
          <source>Well, if n gets real big, we do not care what we might add to n or n squared.</source>
          <target state="translated">好吧,如果n真的变大了,我们不在乎n可能会加什么,也不在乎n的平方。</target>
        </trans-unit>
        <trans-unit id="2d9059fb09bbdcd3a55d09451a9fcb425e83ec53" translate="yes" xml:space="preserve">
          <source>Well, let&amp;rsquo;s see.  I must add one and two, and then add that to three, and then add that to four&amp;hellip; All in all, I count six adds.  I have to do six adds to solve this.</source>
          <target state="translated">好吧，走着瞧。 我必须添加一个和两个，然后将其添加到三个，然后将其添加到四个&amp;hellip;&amp;hellip;总共，我算出六个添加。 我必须做六个加法来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="329e7c685300ef2d2b4c47c92157c7ce7ca7c71a" translate="yes" xml:space="preserve">
          <source>Well, what's so wonderful about Big O notation if that's what it does?</source>
          <target state="translated">那么,如果这就是大O记号有什么了不起的地方?</target>
        </trans-unit>
        <trans-unit id="27f2ea453fa647e6745114288459cdbdc09377db" translate="yes" xml:space="preserve">
          <source>Well, you know n squared is n times n.  Now, I get it: n cards checked, up to what might be n times through the deck.  That is two loops, each with n steps.  That is n squared much work to be done.  A lot of work, for sure!</source>
          <target state="translated">好吧,你知道n的平方是n次n。 现在,我明白了:n张牌被检查过了,最多可能是n次。那就是两个循环,每个循环有n个步骤。这就是n个平方,有很多工作要做。很多工作,肯定要做。</target>
        </trans-unit>
        <trans-unit id="f37e46082d9d7fea2de0995ec35f0ebec2aa85b9" translate="yes" xml:space="preserve">
          <source>What if I order several Blu-ray movies like The Lord of the Rings, Twilight, The Dark Knight Trilogy, etc. and download all the movies online at the same time? This time, the delivery still take a day to complete, but the online download takes 3 days to finish.
For online shopping, the number of purchased item (input) doesn&amp;rsquo;t affect the delivery time. The output is constant. We call this &lt;strong&gt;O(1)&lt;/strong&gt;.</source>
          <target state="translated">如果我订购了几部蓝光电影，例如《指环王》，《暮光之城》，《黑暗骑士三部曲》等，并同时在线下载所有电影，该怎么办？ 这次，交付仍需要一天才能完成，但在线下载需要3天才能完成。 对于在线购物，购买物品（输入）的数量不影响交货时间。 输出是恒定的。 我们称其为&lt;strong&gt;O（1）&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ae3452404f7d023c914234c52fa39dc716c5a20" translate="yes" xml:space="preserve">
          <source>What if you have a phone number and want to find a name?  The police have a reverse phone book but such look-ups are denied to the general public.  Or are they?  Technically you can reverse look-up a number in an ordinary phone book.  How?</source>
          <target state="translated">有了电话号码,想找名字怎么办?警方有倒查电话簿,但这种查询方式对普通市民来说是不允许的。还是说是这样的?从技术上来说,你可以在普通电话簿上反向查询一个号码。怎么查?</target>
        </trans-unit>
        <trans-unit id="373e1d2a10f1cbeda45147e21f05a41927cb80df" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of &amp;ldquo;Big O&amp;rdquo; notation?</source>
          <target state="translated">英文对&amp;ldquo; Big O&amp;rdquo;符号的解释是什么？</target>
        </trans-unit>
        <trans-unit id="05e7612ca7f7ef6fa7a4103f167b120617cb813f" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of Big O? With as little formal definition as possible and simple mathematics.</source>
          <target state="translated">大O的通俗的英文解释是什么?用尽可能少的正式定义和简单的数学知识。</target>
        </trans-unit>
        <trans-unit id="f89a18eb1e0fc978c591793d435b46bfc0826855" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of “Big O” notation</source>
          <target state="translated">什么是 &quot;大O &quot;记号法的通俗英文解释</target>
        </trans-unit>
        <trans-unit id="2cc611dba256f3aa30150ddcf404bfb6a56af65d" translate="yes" xml:space="preserve">
          <source>What is this sort called?  It is called Quick Sort!  That sort was made by a man called &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;C. A. R. Hoare&lt;/a&gt; and he called it Quick Sort.  Now, Quick Sort gets used all the time!</source>
          <target state="translated">这种叫什么呢？ 这就是所谓的快速排序！ 这种排序是由一个叫&lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;CAR Hoare的人完成的&lt;/a&gt; ，他称它为Quick Sort。 现在，快速排序一直被使用！</target>
        </trans-unit>
        <trans-unit id="bf023f1a273e5e8e203698a520653800da906866" translate="yes" xml:space="preserve">
          <source>When interested in doing computations whose size is &quot;large&quot; enough to be considered as approximately infinity, then big O notation is approximately the cost of solving your problem.</source>
          <target state="translated">当有兴趣做大小 &quot;大 &quot;到可以认为是近似于无穷大的计算时,那么大O的记号就是近似于解决你的问题的成本。</target>
        </trans-unit>
        <trans-unit id="adc3d5b71af09ac58be8764be77408df12df041d" translate="yes" xml:space="preserve">
          <source>When the deck is done, I ask: did I swap cards in that pass?  If so, I must do it all once more, from the top.</source>
          <target state="translated">当卡组做完后,我问:我那一关有没有换牌?如果是,我必须从头再来一遍,从头再来一遍。</target>
        </trans-unit>
        <trans-unit id="9028c7b55a2b4ecb9c2a82958fa89f7a7fc1daa5" translate="yes" xml:space="preserve">
          <source>When we program, we are trying to solve a problem. What we code is called an algorithm. Big O notation allows us to compare the worse case performance of our algorithms in a standardized way. Hardware specs vary over time and improvements in hardware can reduce the time it takes an algorithms to run. But replacing the hardware does not mean our algorithm is any better or improved over time, as our algorithm is still the same. So in order to allow us to compare different algorithms, to determine if one is better or not, we use Big O notation.</source>
          <target state="translated">当我们编程的时候,我们是为了解决一个问题。我们所编码的东西叫做算法。大O记号可以让我们用标准化的方式来比较算法的恶劣情况下的性能。硬件的规格会随着时间的推移而变化,硬件的改进可以缩短算法的运行时间。但更换硬件并不意味着我们的算法随着时间的推移会更好,或者说改进,因为我们的算法还是一样的。所以,为了让我们能够对不同的算法进行比较,判断一个算法是否更好,我们用大O记号。</target>
        </trans-unit>
        <trans-unit id="54c2c9229bcd771be7710eabeb971bc3f8e0eb85" translate="yes" xml:space="preserve">
          <source>When we say some algorithm is O(f(n)) we are saying that the running time (or space required) by that algorithm is always lower than some constant times f(n).</source>
          <target state="translated">当我们说某些算法是O(f(n))时,我们说的是该算法的运行时间(或所需空间)总是低于某些常数倍f(n)。</target>
        </trans-unit>
        <trans-unit id="5d1cb020f38d2820c9eec88a25e1be3ef2a6c892" translate="yes" xml:space="preserve">
          <source>Why do I choose Quick Sort?  I do not like to work, of course!  I want work done as soon as I can get it done.</source>
          <target state="translated">我为什么要选择快速排序?当然,我不喜欢工作! 我想让工作尽快完成,只要能完成就好。</target>
        </trans-unit>
        <trans-unit id="ccaa8eba13667623c9638dcc1af96e87d1ce8695" translate="yes" xml:space="preserve">
          <source>Why does he say n squared?</source>
          <target state="translated">为什么他说N个平方?</target>
        </trans-unit>
        <trans-unit id="ed876af93299c7d2e7470f312b49d7963f03e745" translate="yes" xml:space="preserve">
          <source>Why is this so important? Because software deals with problems that may differ in size by factors up to a trillion. Consider that for a moment. The ratio between the speed necessary to travel to the Moon and human walking speed is less than 10,000:1, and that is absolutely tiny compared to the range in input sizes software may face. And because software may face an astronomical range in input sizes there is the potential for the Big O complexity of an algorithm, it's fundamental scaling nature, to trump any implementation details.</source>
          <target state="translated">为什么这个问题如此重要?因为软件所处理的问题,其大小可能相差达万亿倍。请考虑一下这个问题。前往月球所需的速度与人类行走速度的比值小于10000:1,与软件可能面临的输入大小范围相比,这绝对是很小的。而且因为软件可能面临着一个天文数字的输入大小范围,所以一个算法的大O复杂度,它的基本缩放性质,有可能超越任何实现细节。</target>
        </trans-unit>
        <trans-unit id="a693d58d361e39c4c6dfbf09d0fc6a088f14c901" translate="yes" xml:space="preserve">
          <source>Why would you want to ignore the smaller parts of the equation? Because they become completely dwarfed by the big parts of the equation as you consider larger and larger scales; their contribution becomes dwarfed and irrelevant. (See example section.)</source>
          <target state="translated">为什么你要忽略方程中较小的部分?因为当你考虑更大、更大的尺度时,它们会被方程中的大的部分完全相形见绌;它们的贡献变得相形见绌,不相干。(见示例部分)。</target>
        </trans-unit>
        <trans-unit id="b03cf50f7e5382fcef1451bd7a03322e40c6839f" translate="yes" xml:space="preserve">
          <source>With 5 it's 60.</source>
          <target state="translated">5个是60个</target>
        </trans-unit>
        <trans-unit id="19778bc5e290319ee50f4c5296b015273dc9262c" translate="yes" xml:space="preserve">
          <source>Worst-Case: the key doesn't exist in the list.</source>
          <target state="translated">最坏的情况是:在列表中不存在钥匙。</target>
        </trans-unit>
        <trans-unit id="5fabd786be014d83764164facee56b049790e363" translate="yes" xml:space="preserve">
          <source>Wow, I hate work.  But oh well, I have to do this.  So here I go.</source>
          <target state="translated">哇,我讨厌工作。但哦,好吧,我必须这样做。所以,在这里,我去。</target>
        </trans-unit>
        <trans-unit id="7c8c4cd8f5043686e05d837663d4022a92d73016" translate="yes" xml:space="preserve">
          <source>Yes, there is a more fast way!  It takes some time to learn, but it works... and it works quite fast.  You can try it too, but take your time with each step and do not lose your place.</source>
          <target state="translated">是的,有一个更快的方法! 它需要一些时间来学习,但它很有效......而且效果相当快。你也可以尝试一下,但每一步都要慢慢来,不要迷失方向。</target>
        </trans-unit>
        <trans-unit id="cfe414e40bd3874b327354ff113f428d54d21253" translate="yes" xml:space="preserve">
          <source>You could refer to Big-&amp;Omega; (Big-Omega) for best case.</source>
          <target state="translated">您可以参考Big-&amp;Omega;（Big-Omega）以获得最佳情况。</target>
        </trans-unit>
        <trans-unit id="7bfc8ee77cbab3d00050185496cbe7e412b4bf8a" translate="yes" xml:space="preserve">
          <source>You drive a car. Occasionally, you need to spend 10 minutes going to
  the gas station and then spend 1 minute refilling the tank with gas.
  If you did this every time you went anywhere with your car (spend 10
  minutes driving to the gas station, spend a few seconds filling up a
  fraction of a gallon), it would be very inefficient. But if you fill
  up the tank once every few days, the 11 minutes spent driving to the
  gas station is &quot;amortized&quot; over a sufficiently large number of trips,
  that you can ignore it and pretend all your trips were maybe 5% longer.</source>
          <target state="translated">你开的是汽车。偶尔,你需要花10分钟去加油站,然后花1分钟给油箱加满油。如果你每次开着车去任何地方都这样做(花10分钟开车去加油站,花几秒钟的时间加满一加仑的分量),效率会很低。但是,如果你每隔几天加一次油,那么开车去加油站的11分钟就会被 &quot;摊销 &quot;在足够多的行程中,你可以忽略不计,就当你所有的行程都是5%的时间。</target>
        </trans-unit>
        <trans-unit id="2c6bcba6f752f5cfdc961fb84683b404f55a2f21" translate="yes" xml:space="preserve">
          <source>You learned all that with me!  You are so smart!  Thank you so much!</source>
          <target state="translated">你跟我一起学的! 你太聪明了! 太谢谢你了!</target>
        </trans-unit>
        <trans-unit id="e8fd35a375e8ec51f2b6feca80545b2feec31781" translate="yes" xml:space="preserve">
          <source>You may often see O(n), O(n&lt;sup&gt;2&lt;/sup&gt;), O(nlogn) and so forth, all these are just ways to show; How does an algorithm change?</source>
          <target state="translated">您可能经常会看到O（n），O（n &lt;sup&gt;2&lt;/sup&gt; ），O（nlogn）等，所有这些都只是显示方式。 算法如何变化？</target>
        </trans-unit>
        <trans-unit id="f0c088b8e94d146df79970184c217c58b7b97083" translate="yes" xml:space="preserve">
          <source>You start at the first name and compare the number.  If it's a match, great, if not, you move on to the next.  You have to do it this way because the phone book is &lt;strong&gt;unordered&lt;/strong&gt; (by phone number anyway).</source>
          <target state="translated">您从名字开始，然后比较数字。 如果这是一场比赛，那很好，如果不是，那您就进入下一个。 您必须这样做，因为电话簿是&lt;strong&gt;无序的&lt;/strong&gt; （无论如何都按电话号码&lt;strong&gt;排序&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4784b5173ab05221f2b6abc84330bf0f13d31a7c" translate="yes" xml:space="preserve">
          <source>You want to know all there is to know of big O?  So do I.</source>
          <target state="translated">你想知道大O的一切吗?我也想知道。</target>
        </trans-unit>
        <trans-unit id="648ba0204f36666cba11a8e63d6db611dae8658b" translate="yes" xml:space="preserve">
          <source>[1]: There is a way to cheat and add all the things from one to n, all at one time.  Some kid named Gauss found this out when he was eight.  I am not that smart though, so &lt;a href=&quot;http://nzmaths.co.nz/gauss-trick-staff-seminar&quot;&gt;don't ask me how he did it&lt;/a&gt;.</source>
          <target state="translated">[1]：有一种方法可以一次性欺骗所有事物并将其从n添加到n。 一个叫高斯的孩子八岁时就发现了这一点。 我虽然不那么聪明，所以&lt;a href=&quot;http://nzmaths.co.nz/gauss-trick-staff-seminar&quot;&gt;不要问我他是怎么做到的&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="4229c03c35f915409c958fce305574599037d757" translate="yes" xml:space="preserve">
          <source>[for the mathematically inclined, you can mouse over the spoilers for minor sidenotes]</source>
          <target state="translated">[对于有数学倾向的人来说,你可以把鼠标移到破坏者上看一下小提示]</target>
        </trans-unit>
        <trans-unit id="320f1d7c3f87e62df035bd8c3fff9fceb851f278" translate="yes" xml:space="preserve">
          <source>addition;</source>
          <target state="translated">addition;</target>
        </trans-unit>
        <trans-unit id="cc72a00bf5f82a31e19586f8d5648eeb9609f807" translate="yes" xml:space="preserve">
          <source>and so on.</source>
          <target state="translated">诸如此类。</target>
        </trans-unit>
        <trans-unit id="41f2ef38a3521fb432c176bb3d6eec433f0e7d29" translate="yes" xml:space="preserve">
          <source>big-O notation doesn't care about constant factors: the function &lt;code&gt;9x&amp;sup2;&lt;/code&gt; is said to &quot;grow exactly like&quot; &lt;code&gt;10x&amp;sup2;&lt;/code&gt;. Neither does big-O &lt;em&gt;asymptotic&lt;/em&gt; notation care about &lt;em&gt;non-asymptotic&lt;/em&gt; stuff (&quot;stuff near the origin&quot; or &quot;what happens when the problem size is small&quot;): the function &lt;code&gt;10x&amp;sup2;&lt;/code&gt; is said to &quot;grow exactly like&quot; &lt;code&gt;10x&amp;sup2; - x + 2&lt;/code&gt;.</source>
          <target state="translated">big-O表示法不关心常量因子：函数 &lt;code&gt;9x&amp;sup2;&lt;/code&gt; 据说&amp;ldquo;完全像 &lt;code&gt;10x&amp;sup2;&lt;/code&gt; 一样增长&amp;rdquo;。 big-O &lt;em&gt;渐近&lt;/em&gt;符号也不关心&lt;em&gt;非渐近的&lt;/em&gt;东西（&amp;ldquo;原点附近的东西&amp;rdquo;或&amp;ldquo;问题大小较小时会发生什么&amp;rdquo;）：函数 &lt;code&gt;10x&amp;sup2;&lt;/code&gt; 被称为&amp;ldquo;完全像 &lt;code&gt;10x&amp;sup2; - x + 2&lt;/code&gt; 一样增长&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3fed40854ecbd633619a5d431600a671eeed9292" translate="yes" xml:space="preserve">
          <source>c= a constant</source>
          <target state="translated">c=一个常数</target>
        </trans-unit>
        <trans-unit id="e923389b125ffc7cdb2e423a899d4348e7439235" translate="yes" xml:space="preserve">
          <source>division.</source>
          <target state="translated">division.</target>
        </trans-unit>
        <trans-unit id="714de604846fa9d95f2b9fc4aaa27f67caadafd4" translate="yes" xml:space="preserve">
          <source>e.g. for x=1million, ratio #handshakes/x&amp;sup2;: 0.499999...</source>
          <target state="translated">例如，对于x = 1百万，比率＃握手/x&amp;sup2;：0.499999 ...</target>
        </trans-unit>
        <trans-unit id="f42454a2adeb8a0c26a29f629c55ab5dda69a64d" translate="yes" xml:space="preserve">
          <source>f(n)= An approximate function that expresses the running time of the algorithm as a function of n</source>
          <target state="translated">f(n)=表示算法的运行时间为n的函数的近似函数</target>
        </trans-unit>
        <trans-unit id="6b7dffac98fa2e9f18d9b09123953c56c601da05" translate="yes" xml:space="preserve">
          <source>how heat output scales on CPU dies as a function of transistor count, voltage, etc.</source>
          <target state="translated">晶体管数量、电压等在CPU芯片上的发热量是如何变化的?</target>
        </trans-unit>
        <trans-unit id="077a4887c6602aedfb17f44dd051822aa960da2d" translate="yes" xml:space="preserve">
          <source>how much space an algorithm needs to run, as a function of input size</source>
          <target state="translated">算法需要运行多少空间,作为输入大小的函数</target>
        </trans-unit>
        <trans-unit id="4d80174ea25f9828dcb069496071916d7c70255b" translate="yes" xml:space="preserve">
          <source>how much time an algorithm needs to run, as a function of input size</source>
          <target state="translated">算法需要运行多少时间,作为输入大小的函数</target>
        </trans-unit>
        <trans-unit id="f2dbea261a6334b636fcb8245379760585160604" translate="yes" xml:space="preserve">
          <source>how website latency scales with the number of processing units in a CPU or GPU or computer cluster</source>
          <target state="translated">网站延迟如何随着CPU或GPU或计算机集群中的处理单元数量的变化而变化</target>
        </trans-unit>
        <trans-unit id="5aa429e0444abdc08467c70c26cbff2d88e2345a" translate="yes" xml:space="preserve">
          <source>it's less than O(N&lt;sup&gt;1.000001&lt;/sup&gt;), which you might be willing to call basically linear</source>
          <target state="translated">它小于O（N &lt;sup&gt;1.000001&lt;/sup&gt; ），您可能愿意将其称为线性</target>
        </trans-unit>
        <trans-unit id="8e97d6456227b5a58913c9ed733df644f1e01e91" translate="yes" xml:space="preserve">
          <source>k is bounded in some neighborhood of a (if a = +&amp;infin;, this means that there are numbers N and M such that for every x &amp;gt; N, |&lt;em&gt;k&lt;/em&gt;(x)| &amp;lt; M).</source>
          <target state="translated">k限制在a的某个邻域内（如果a = +&amp;infin;，则意味着存在数字N和M，使得对于每个x&amp;gt; N，| &lt;em&gt;k&lt;/em&gt; （x）| &amp;lt;M）。</target>
        </trans-unit>
        <trans-unit id="6005c391c2f680a2452cd2577c2564dbcef8e9c9" translate="yes" xml:space="preserve">
          <source>ln(x) = o(x) = O(x) when x &amp;rarr; +&amp;infin;.</source>
          <target state="translated">当x&amp;rarr;+&amp;infin;时ln（x）= o（x）= O（x）</target>
        </trans-unit>
        <trans-unit id="273b9bcfed53ba997f70f8aa75c36bda6fde8958" translate="yes" xml:space="preserve">
          <source>multiplication; and</source>
          <target state="translated">乘法;以及</target>
        </trans-unit>
        <trans-unit id="a4393b9a14bdfd4f4c0eeaaf31bad2e0b9cfef0d" translate="yes" xml:space="preserve">
          <source>n=number of input parameters</source>
          <target state="translated">n=输入参数数</target>
        </trans-unit>
        <trans-unit id="463f52bc275366887f835ed5e5f95c1fe198e8af" translate="yes" xml:space="preserve">
          <source>or address it formally, &quot;Big O&quot; classifies the algorithms and standardize the comparison process.</source>
          <target state="translated">或从形式上解决,&quot;大O &quot;对算法进行分类,规范比对过程。</target>
        </trans-unit>
        <trans-unit id="27c0dba7b6e5e26123d57265908dfa7204907ffd" translate="yes" xml:space="preserve">
          <source>probabilistic expected number of people who have seen some viral marketing as a function of time</source>
          <target state="translated">概率性的预期人数与时间的关系</target>
        </trans-unit>
        <trans-unit id="0c2b90eddd63a783f5f290989f744b1bf85f87bd" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15,20,25}  ==&amp;gt; problem-instance-size = 5 iterations-in-loop = 5</source>
          <target state="translated">问题实例= {5,10,15,20,25} ==&amp;gt;问题实例大小= 5循环迭代= 5</target>
        </trans-unit>
        <trans-unit id="e4b7c82dda906533e8c2824c6df8639b2a23a367" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15,20,25}  ==&amp;gt; problem-instance-size = 5, total-iterations= 5*5 =25</source>
          <target state="translated">问题实例= {5,10,15,20,25} ==&amp;gt;问题实例大小= 5，总迭代次数= 5 * 5 = 25</target>
        </trans-unit>
        <trans-unit id="7b9571101e4cfebe964dd712258a749bb36005e9" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15}  ==&amp;gt; problem-instance-size = 3, iterations-in-loop= 3</source>
          <target state="translated">问题实例= {5,10,15} ==&amp;gt;问题实例大小= 3，循环迭代= 3</target>
        </trans-unit>
        <trans-unit id="41a7ac7c629f59f13ed8b74173f006eb424e46ac" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15}  ==&amp;gt; problem-instance-size = 3, total-iterations = 3*3 = 9</source>
          <target state="translated">问题实例= {5,10,15} ==&amp;gt;问题实例大小= 3，总迭代次数= 3 * 3 = 9</target>
        </trans-unit>
        <trans-unit id="6adf164f31eaa024e8cd62ab3a7db4601ada676a" translate="yes" xml:space="preserve">
          <source>sin x = O(1) when x &amp;rarr; +&amp;infin;,</source>
          <target state="translated">当x&amp;rarr;+&amp;infin;时，sin x = O（1），</target>
        </trans-unit>
        <trans-unit id="01a98a9d29b98d64c9b325ce600cfccdddb4209c" translate="yes" xml:space="preserve">
          <source>sin x = O(x) when x &amp;rarr; 0.</source>
          <target state="translated">当x&amp;rarr;0时sin x = O（x）</target>
        </trans-unit>
        <trans-unit id="0f7b476dccef1271c4d6a97311ca082c68f64f7e" translate="yes" xml:space="preserve">
          <source>so you could get its idea literally that it's used to order something to  compare them.</source>
          <target state="translated">因此,你可以得到它的想法,从字面上看,它是用来订购东西来比较他们。</target>
        </trans-unit>
        <trans-unit id="2411b10604909e08dc5dd9f0ef7bed5327f33858" translate="yes" xml:space="preserve">
          <source>subtraction;</source>
          <target state="translated">subtraction;</target>
        </trans-unit>
        <trans-unit id="1dfbbc899d7564b2c25e7c8e5668555967ef21c9" translate="yes" xml:space="preserve">
          <source>the number of possible handshakes among &lt;code&gt;N&lt;/code&gt; people at a party (&lt;code&gt;Ɵ(N&amp;sup2;)&lt;/code&gt;, specifically &lt;code&gt;N(N-1)/2&lt;/code&gt;, but what matters is that it &quot;scales like&quot; &lt;code&gt;N&amp;sup2;&lt;/code&gt;)</source>
          <target state="translated">参加聚会的 &lt;code&gt;N&lt;/code&gt; 个人之间可能握手的数量（ &lt;code&gt;Ɵ(N&amp;sup2;)&lt;/code&gt; ，特别是 &lt;code&gt;N(N-1)/2&lt;/code&gt; ，但重要的是它的缩放比例类似于 &lt;code&gt;N&amp;sup2;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a673eb6514c9181588ced3c270df39095e5c61da" translate="yes" xml:space="preserve">
          <source>x&lt;sup&gt;2&lt;/sup&gt; + x = O(x) when x &amp;rarr; 0,</source>
          <target state="translated">当x&amp;rarr;0时x &lt;sup&gt;2&lt;/sup&gt; + x = O（x）</target>
        </trans-unit>
        <trans-unit id="4588b59a6bc0b7081d698604a73689ff94c6669e" translate="yes" xml:space="preserve">
          <source>x&lt;sup&gt;2&lt;/sup&gt; + x = O(x&lt;sup&gt;2&lt;/sup&gt;) when x &amp;rarr; +&amp;infin;,</source>
          <target state="translated">当x&amp;rarr;+&amp;infin;时，x &lt;sup&gt;2&lt;/sup&gt; + x = O（x &lt;sup&gt;2&lt;/sup&gt; ）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
