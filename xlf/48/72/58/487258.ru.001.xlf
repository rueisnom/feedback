<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/487258">
    <body>
      <group id="487258">
        <trans-unit id="df498b6e1ddfb06035cc2f060b77dcae692ec7ef" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;What is a plain English explanation of Big O? With as little formal
  definition as possible and simple mathematics.&lt;/em&gt;&quot;</source>
          <target state="translated">&amp;laquo; &lt;em&gt;Что такое простое английское объяснение Big O? Как можно меньше формального определения и простой математики&lt;/em&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="743ffd5e6c073307e39f8ab64f2a620592932e7f" translate="yes" xml:space="preserve">
          <source>&quot;Big O&quot; describes the algorithm's performance and evaluates it.</source>
          <target state="translated">&quot;Большой О&quot; описывает работу алгоритма и оценивает ее.</target>
        </trans-unit>
        <trans-unit id="b462328e08f4909b285edec4ff0990d6976efaea" translate="yes" xml:space="preserve">
          <source>&quot;Big O' achieves the above two with standardized &lt;code&gt;Notations&lt;/code&gt;.</source>
          <target state="translated">&amp;laquo;Большой О&amp;raquo; достигает двух вышеупомянутых стандартов.</target>
        </trans-unit>
        <trans-unit id="13f9f8a3d4d7d94edeaf3b7b38263362fa788e6a" translate="yes" xml:space="preserve">
          <source>&quot;For large enough inputsize=N, no matter what the constant factor is, if I &lt;strong&gt;&lt;em&gt;double&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; the input size&lt;/em&gt;...</source>
          <target state="translated">&amp;laquo;Для достаточно большого входного размера = N, независимо от того, каков постоянный коэффициент, если я &lt;strong&gt;&lt;em&gt;удваиваю&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;входной размер&lt;/em&gt; ...</target>
        </trans-unit>
        <trans-unit id="839e4a2006b278a93c4dc0f1936567078302c3f3" translate="yes" xml:space="preserve">
          <source>&amp;hellip;</source>
          <target state="translated">&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="12f5efd72c115a3dfdb9aef75a93d8f6398d2f03" translate="yes" xml:space="preserve">
          <source>( *in a wonderful, &lt;em&gt;unit-free&lt;/em&gt; sense of time!)</source>
          <target state="translated">(* в прекрасном, &lt;em&gt;свободном&lt;/em&gt; от &lt;em&gt;единицы&lt;/em&gt; смысле времени!)</target>
        </trans-unit>
        <trans-unit id="5f85db481a01c4c068358bc082055af7e5738d77" translate="yes" xml:space="preserve">
          <source>(**which is what matters, because people will &lt;a href=&quot;http://www.youtube.com/watch?v=OnA3C9Af_oc&quot;&gt;&lt;em&gt;always&lt;/em&gt; want more&lt;/a&gt;, whether they live today or tomorrow)</source>
          <target state="translated">(** что имеет значение, потому что люди &lt;a href=&quot;http://www.youtube.com/watch?v=OnA3C9Af_oc&quot;&gt;&lt;em&gt;всегда&lt;/em&gt;&lt;/a&gt; будут хотеть большего , живут ли они сегодня или завтра)</target>
        </trans-unit>
        <trans-unit id="111ed31dcbac4c6bfe6846c61c61ca1b11df6d01" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;edit&lt;/em&gt;: The &quot;plain English&quot; explanation ends here.)</source>
          <target state="translated">( &lt;em&gt;редактировать&lt;/em&gt; : на этом &amp;laquo;простое английское&amp;raquo; объяснение заканчивается.)</target>
        </trans-unit>
        <trans-unit id="6ce684a7aaa9d4a76848668e020344c53ae2b9ae" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;https://stackoverflow.com/q/7333376/711085&quot;&gt;Difference between average case and amortized analysis&lt;/a&gt; if interested in this subtopic.)</source>
          <target state="translated">(См. &lt;a href=&quot;https://stackoverflow.com/q/7333376/711085&quot;&gt;Разница между средним случаем и амортизированным анализом,&lt;/a&gt; если интересует эта подтема.)</target>
        </trans-unit>
        <trans-unit id="acf9d80cf9dbb5bb7520ab6662ebded396c6f175" translate="yes" xml:space="preserve">
          <source>(here, the &lt;code&gt;x&lt;/code&gt;s represent constant-time units of work, processor instructions, interpreter opcodes, whatever)</source>
          <target state="translated">(здесь &lt;code&gt;x&lt;/code&gt; s представляют единицы работы постоянного времени, инструкции процессора, коды операций интерпретатора, что угодно)</target>
        </trans-unit>
        <trans-unit id="e095c7e86ea34ae9aa5df712384da64165e0768e" translate="yes" xml:space="preserve">
          <source>(technically the constant factor could maybe matter in some more esoteric examples, but I've phrased things above (e.g. in log(N)) such that it doesn't)</source>
          <target state="translated">(технически постоянный фактор может иметь значение в некоторых более эзотерических примерах,но я сформулировал вещи выше (например,в log(N))так,что это не так)</target>
        </trans-unit>
        <trans-unit id="06d7bf9932a7f33791291e583cc05892187c54d8" translate="yes" xml:space="preserve">
          <source>(temporary digression from &quot;plain English&quot;:) If you wanted to prove this to yourself, you could perform some simple algebra on the ratio to split it up into multiple terms (&lt;code&gt;lim&lt;/code&gt; means &quot;considered in the limit of&quot;, just ignore it if you haven't seen it, it's just notation for &quot;and N is really really big&quot;):</source>
          <target state="translated">(временное отступление от &amp;laquo;простого английского&amp;raquo; :) Если вы хотите доказать это себе, вы можете выполнить некоторую простую алгебру отношения, чтобы разделить его на несколько терминов ( &lt;code&gt;lim&lt;/code&gt; означает &amp;laquo;рассматривается в пределе&amp;raquo;, просто игнорируйте его, если Вы не видели этого, это просто обозначение для &amp;laquo;и N действительно очень большой&amp;raquo;):</target>
        </trans-unit>
        <trans-unit id="11b4e1bb86ac129d3782b8fb89778b82b4699643" translate="yes" xml:space="preserve">
          <source>(with credit to &lt;a href=&quot;https://stackoverflow.com/a/487292/711085&quot;&gt;https://stackoverflow.com/a/487292/711085&lt;/a&gt; )</source>
          <target state="translated">(с благодарностью за &lt;a href=&quot;https://stackoverflow.com/a/487292/711085&quot;&gt;https://stackoverflow.com/a/487292/711085&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7bedee6fc739cfe745b69e77230823ca7b506921" translate="yes" xml:space="preserve">
          <source>... I &quot;(basically) double&quot; the time an O(N log(N)) algorithm takes.&quot; &lt;em&gt;(fairly common)&lt;/em&gt;</source>
          <target state="translated">... Я &quot;(в основном) удваиваю&quot; время, которое занимает алгоритм O (N log (N)). &quot; &lt;em&gt;(Довольно часто)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c2cc664a183cfc04e1a64249ea8f7c45673b79cb" translate="yes" xml:space="preserve">
          <source>... I add a fixed amount to the time an O(log(N)) (&quot;logarithmic time&quot;) algorithm takes.&quot; &lt;em&gt;(cheap!)&lt;/em&gt;</source>
          <target state="translated">... Я добавляю фиксированное количество ко времени, которое занимает алгоритм O (log (N)) (&quot;логарифмическое время&quot;). &quot; &lt;em&gt;(Дешево!)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9288b2e9d99d26a40d9f6f5b3a3990d8e5204b8b" translate="yes" xml:space="preserve">
          <source>... I don't change the time an O(1) (&quot;constant time&quot;) algorithm takes.&quot; &lt;em&gt;(the cheapest!)&lt;/em&gt;</source>
          <target state="translated">... Я не изменяю время, которое занимает алгоритм O (1) (&quot;постоянное время&quot;). &quot; &lt;em&gt;(Самый дешевый!)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac3db673dfe1df5538b14e8981fdd7f64c253879" translate="yes" xml:space="preserve">
          <source>... I double the time an O(N) (&quot;linear time&quot;) algorithm takes.&quot;</source>
          <target state="translated">...Я удваиваю время,которое занимает алгоритм O(N)(&quot;линейное время&quot;)&quot;.</target>
        </trans-unit>
        <trans-unit id="a1e7e1ffe28ec1263008a387034b2aaa20a40664" translate="yes" xml:space="preserve">
          <source>... I double-cubed (octuple) the time an O(N&amp;sup3;) (&quot;cubic time&quot;) algorithm takes.&quot; &lt;em&gt;(e.g. a problem 100x as big takes 100&amp;sup3;=1000000x as long... very unsustainable)&lt;/em&gt;</source>
          <target state="translated">... Я дважды кубировал (восьмикратное) время, которое занимает алгоритм O (N&amp;sup3;) (&quot;кубическое время&quot;). &quot; &lt;em&gt;(Например, задача 100x как большая занимает 100&amp;sup3; = 1000000x как долго ... очень неустойчиво)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eab0d87ea3058c371ba99238d90dc25bc68910e0" translate="yes" xml:space="preserve">
          <source>... I double-squared (quadruple) the time an O(N&amp;sup2;) (&quot;quadratic time&quot;) algorithm takes.&quot; &lt;em&gt;(e.g. a problem 100x as big takes 100&amp;sup2;=10000x as long... possibly unsustainable)&lt;/em&gt;</source>
          <target state="translated">... Я удваиваю квадратичное (четырехкратное) время, затрачиваемое алгоритмом O (N&amp;sup2;) (&quot;квадратичное время&quot;). &quot; &lt;em&gt;(Например, задача 100x как большая занимает 100&amp;sup2; = 10000x как долго ... возможно, неустойчиво)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a87538c4cde56e0a42c94f671c99d158235fbb02" translate="yes" xml:space="preserve">
          <source>... I ridiculously increase the time a O(2&lt;sup&gt;N&lt;/sup&gt;) (&quot;exponential time&quot;) algorithm takes.&quot; &lt;em&gt;(you'd double (or triple, etc.) the time just by increasing the problem by a single unit)&lt;/em&gt;</source>
          <target state="translated">... Я смехотворно увеличиваю время, затрачиваемое алгоритмом O (2 &lt;sup&gt;N&lt;/sup&gt; ) (&quot;экспоненциальное время&quot;). &quot; &lt;em&gt;(Вы удвоите (или утроите и т. Д.) Время, просто увеличив проблему на единицу)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="758995d5c0c86f523c06ebeba129d83d2b577e5c" translate="yes" xml:space="preserve">
          <source>... and the ugly:</source>
          <target state="translated">...и уродливый:</target>
        </trans-unit>
        <trans-unit id="5f8dd699eca2f4c835f1d41e82c48c0ee2badc97" translate="yes" xml:space="preserve">
          <source>... this means that &lt;strong&gt;&lt;em&gt;for &quot;large enough&quot; problem sizes N&lt;/em&gt;&lt;/strong&gt; (if we ignore stuff near the origin), there exists some constant (e.g. 2.5, completely made up) such that:</source>
          <target state="translated">... это означает, что &lt;strong&gt;&lt;em&gt;для &quot;достаточно больших&quot; размеров задач N&lt;/em&gt;&lt;/strong&gt; (если мы игнорируем вещи около начала координат), существует некоторая постоянная (например, 2.5, полностью составленная) такая, что:</target>
        </trans-unit>
        <trans-unit id="02da7ab518ed35b63049ed24f5f7b780a03cf03c" translate="yes" xml:space="preserve">
          <source>1 item: 1 second</source>
          <target state="translated">1 пункт:1 секунда</target>
        </trans-unit>
        <trans-unit id="311ddef12fccab210777747c79f3b6e098829cf8" translate="yes" xml:space="preserve">
          <source>10 items: 1 second</source>
          <target state="translated">10 пунктов:1 секунда</target>
        </trans-unit>
        <trans-unit id="b0174046184ef586844edb37f738266a6b609bf9" translate="yes" xml:space="preserve">
          <source>10 items: 10 seconds</source>
          <target state="translated">10 пунктов:10 секунд</target>
        </trans-unit>
        <trans-unit id="689340b4e2631ad08bd04332ba871630466acec6" translate="yes" xml:space="preserve">
          <source>10 items: 100 seconds</source>
          <target state="translated">10 пунктов:100 секунд</target>
        </trans-unit>
        <trans-unit id="487a07e5ea7f045eaef47700eca5782bdc2698c0" translate="yes" xml:space="preserve">
          <source>10 items: 2 seconds</source>
          <target state="translated">10 пунктов:2 секунды</target>
        </trans-unit>
        <trans-unit id="e9339141f2aa5963a587e850388974cfe8b47716" translate="yes" xml:space="preserve">
          <source>100 items: 1 second</source>
          <target state="translated">100 штук:1 секунда</target>
        </trans-unit>
        <trans-unit id="f78d9065d61742cbe71ea04a50c760c0aad8e2f0" translate="yes" xml:space="preserve">
          <source>100 items: 100 seconds</source>
          <target state="translated">100 штук:100 секунд</target>
        </trans-unit>
        <trans-unit id="b9a9aeacdc04be6832d92a9113f361be8c4fe731" translate="yes" xml:space="preserve">
          <source>100 items: 10000 seconds</source>
          <target state="translated">100 штук:10000 секунд</target>
        </trans-unit>
        <trans-unit id="e626224265872fce291da52ed1c64e5aa6578829" translate="yes" xml:space="preserve">
          <source>100 items: 3 seconds</source>
          <target state="translated">100 штук:3 секунды</target>
        </trans-unit>
        <trans-unit id="4479af418a5535ecef4c1769fe04b3e262bd0ce2" translate="yes" xml:space="preserve">
          <source>1000 items: 4 seconds</source>
          <target state="translated">1000 штук:4 секунды</target>
        </trans-unit>
        <trans-unit id="59b0f1da90751fd2ff98593e8e90a885934dbe5d" translate="yes" xml:space="preserve">
          <source>10000 items: 5 seconds</source>
          <target state="translated">10000 штук:5 секунд</target>
        </trans-unit>
        <trans-unit id="085fdb777863ed85e33fb2c51dc325a0803c3300" translate="yes" xml:space="preserve">
          <source>25! = 25 &amp;times; 24 &amp;times; &amp;hellip; &amp;times; 2 &amp;times; 1 = 15,511,210,043,330,985,984,000,000</source>
          <target state="translated">25! = 25 &amp;times; 24 &amp;times;&amp;hellip; &amp;times; 2 &amp;times; 1 = 15,511,210,043,330,985,984,000,000</target>
        </trans-unit>
        <trans-unit id="1cf1a4fd3744013ce7ee0b7c1d54d91a24a35640" translate="yes" xml:space="preserve">
          <source>5! = 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 120</source>
          <target state="translated">5! = 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 120</target>
        </trans-unit>
        <trans-unit id="5ff18ebe3d87d9ac7b38e9bc7546904650421471" translate="yes" xml:space="preserve">
          <source>50! = 50 &amp;times; 49 &amp;times; &amp;hellip; &amp;times; 2 &amp;times; 1 = 3.04140932 &amp;times; 10&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">50! = 50 &amp;times; 49 &amp;times;&amp;hellip; &amp;times; 2 &amp;times; 1 = 3,04140932 &amp;times; 10 &lt;sup&gt;64&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="65decea121bc59733f31fb00d9968ddd605ec56d" translate="yes" xml:space="preserve">
          <source>6 becomes 360.</source>
          <target state="translated">6 становится 360.</target>
        </trans-unit>
        <trans-unit id="c649be492e31261bc490084ea0f4061c188e3cef" translate="yes" xml:space="preserve">
          <source>6! = 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 720</source>
          <target state="translated">6! = 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 720</target>
        </trans-unit>
        <trans-unit id="c8333818a5f4310605f53fef7090df38bab14cef" translate="yes" xml:space="preserve">
          <source>7! = 7 &amp;times; 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 5040</source>
          <target state="translated">7! = 7 &amp;times; 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 5040</target>
        </trans-unit>
        <trans-unit id="82d23a6f8035f1269cf4ccfacb8ebe4510c824fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(1)&lt;/code&gt;&lt;strong&gt;Constant&lt;/strong&gt;: The program takes the same time to run no matter how big the input is.</source>
          <target state="translated">&lt;code&gt;O(1)&lt;/code&gt; &lt;strong&gt;Constant&lt;/strong&gt; : программа запускается в одно и то же время, независимо от размера ввода.</target>
        </trans-unit>
        <trans-unit id="056a18f82b6af88dc008fbe3a7787f86b596f6a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(N)&lt;/code&gt; algorithms are in some sense the &quot;best&quot; algorithms if you need to read all your data. The &lt;strong&gt;very act of reading&lt;/strong&gt; a bunch of data is an &lt;code&gt;O(N)&lt;/code&gt; operation. Loading it into memory is usually &lt;code&gt;O(N)&lt;/code&gt; (or faster if you have hardware support, or no time at all if you've already read the data). However, if you touch or even &lt;em&gt;look&lt;/em&gt; at every piece of data (or even every other piece of data), your algorithm will take &lt;code&gt;O(N)&lt;/code&gt; time to perform this looking. No matter how long your actual algorithm takes, it will be at least &lt;code&gt;O(N)&lt;/code&gt; because it spent that time looking at all the data.</source>
          <target state="translated">&lt;code&gt;O(N)&lt;/code&gt; алгоритмы в некотором смысле являются &amp;laquo;лучшими&amp;raquo; алгоритмами, если вам нужно прочитать все ваши данные. Сам &lt;strong&gt;акт чтения&lt;/strong&gt; группы данных является операцией &lt;code&gt;O(N)&lt;/code&gt; . Загрузка его в память обычно занимает &lt;code&gt;O(N)&lt;/code&gt; (или быстрее, если у вас есть аппаратная поддержка, или совсем нет времени, если вы уже прочитали данные). Однако, если вы дотронетесь или даже &lt;em&gt;посмотрите&lt;/em&gt; на каждый фрагмент данных (или даже на любой другой фрагмент данных), вашему алгоритму потребуется &lt;code&gt;O(N)&lt;/code&gt; время, чтобы выполнить этот поиск. Независимо от того, сколько времени займет ваш фактический алгоритм, он будет по крайней мере &lt;code&gt;O(N)&lt;/code&gt; потому что он потратил это время на просмотр всех данных.</target>
        </trans-unit>
        <trans-unit id="b1e73910621a4a87a24289f5d1c6be72edc01699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(k^n)&lt;/code&gt;&lt;strong&gt;Exponential&lt;/strong&gt; The program run-time increases very quickly with even moderate increases in the size of the problem - it is only practical to process small data sets with exponential algorithms.</source>
          <target state="translated">&lt;code&gt;O(k^n)&lt;/code&gt; &lt;strong&gt;Экспоненциальное&lt;/strong&gt; Время выполнения программы очень быстро увеличивается даже при умеренном увеличении размера задачи - практично обрабатывать небольшие наборы данных с помощью экспоненциальных алгоритмов.</target>
        </trans-unit>
        <trans-unit id="dd8fc41eb8e642b8c7be077a43f8b40003fc551c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt;&lt;strong&gt;Logarithmic&lt;/strong&gt;: The program run-time increases only slowly, even with big increases in the size of the input.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;strong&gt;Logarithmic&lt;/strong&gt; : время выполнения программы увеличивается только медленно, даже при большом увеличении размера ввода.</target>
        </trans-unit>
        <trans-unit id="5537ff56d10d57079a34acd64955d17beb7d3a76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n!)&lt;/code&gt;&lt;strong&gt;Factorial&lt;/strong&gt; The program run-time will be longer than you can afford to wait for anything but the very smallest and most trivial-seeming datasets.</source>
          <target state="translated">&lt;code&gt;O(n!)&lt;/code&gt; &lt;strong&gt;Factorial&lt;/strong&gt; Время выполнения программы будет больше, чем вы можете позволить себе ждать чего угодно, кроме самых маленьких и самых банальных наборов данных.</target>
        </trans-unit>
        <trans-unit id="461878ff8b0db16418e81fc04a687228bdddb9cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n)&lt;/code&gt;&lt;strong&gt;Linear&lt;/strong&gt;: The program run-time increases proportionally to the size of the input.</source>
          <target state="translated">&lt;code&gt;O(n)&lt;/code&gt; &lt;strong&gt;Линейный&lt;/strong&gt; : время выполнения программы увеличивается пропорционально размеру ввода.</target>
        </trans-unit>
        <trans-unit id="c217eda9395d53638ead2adab477fe11bdcd7bed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n^k)&lt;/code&gt;&lt;strong&gt;Polynomial&lt;/strong&gt;: - Processing time grows faster and faster - as a polynomial function - as the size of the input increases.</source>
          <target state="translated">&lt;code&gt;O(n^k)&lt;/code&gt; &lt;strong&gt;Polynomial&lt;/strong&gt; : - Время обработки растет все быстрее и быстрее - как полиномиальная функция - с увеличением размера входных данных.</target>
        </trans-unit>
        <trans-unit id="487d91ff83198cfbc6a54c925fe5eb11d2aa1e78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; &amp;Omega;(lowerbound)&lt;/code&gt; means &lt;code&gt;f&lt;/code&gt; &quot;grows no slower than&quot; &lt;code&gt;lowerbound&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; &amp;Omega;(lowerbound)&lt;/code&gt; означает, что &lt;code&gt;f&lt;/code&gt; &quot;растет не медленнее, чем&quot; &lt;code&gt;lowerbound&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b822bda6e416f32092b9f10f8f055c41f8035dcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; means &lt;code&gt;f&lt;/code&gt; &quot;grows no faster than&quot; &lt;code&gt;upperbound&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; означает, что &lt;code&gt;f&lt;/code&gt; &quot;растет не быстрее, чем&quot; &lt;code&gt;upperbound&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5d65077f782632cf020f9dc10bb5515c203e5c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; Ɵ(justlikethis)&lt;/code&gt; mean &lt;code&gt;f&lt;/code&gt; &quot;grows exactly like&quot; &lt;code&gt;justlikethis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; Ɵ(justlikethis)&lt;/code&gt; означает, что &lt;code&gt;f&lt;/code&gt; &quot;растет точно так же, как&quot; &lt;code&gt;justlikethis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4961257cbe0182882cfdaf21754b651a2f9dd8e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Big-O notation represent the upper-bound on the Complexity (Time, Space, ..)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Обозначения Big-O представляют верхнюю границу сложности (время, пространство, ..)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b6ee9747fe724799f360b3f5740e340e9d6e0bc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Examples&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Examples&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dda2198e2a2e6a8edab7d156a0212aab2797c3a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Math addenda&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Математические приложения&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53c547884adc7e294b855c4c5480cbf77fa6513e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;More examples&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Больше примеров&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="16299135c5a827dc53d250d6ee80162f6e351d93" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;example:&lt;/em&gt; you and a friend are asked to create a function to sum the numbers from 0 to N. You come up with f(x) and your friend comes up with g(x). Both functions have the same result, but a different algorithm. In order to objectively compare the efficiency of the algorithms we use &lt;strong&gt;Big-O notation&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;пример:&lt;/em&gt; вас и друга просят создать функцию суммирования чисел от 0 до N. Вы получаете f (x), а ваш друг - g (x). Обе функции имеют одинаковый результат, но разные алгоритмы. Для объективного сравнения эффективности алгоритмов мы используем &lt;strong&gt;обозначение Big-O&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="62471f46793f8b6a5cc659e14e96cdc437a86276" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = &lt;em&gt;k&lt;/em&gt;(x)&lt;em&gt;g&lt;/em&gt;(x)</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; (x) = &lt;em&gt;k&lt;/em&gt; (x) &lt;em&gt;g&lt;/em&gt; (x)</target>
        </trans-unit>
        <trans-unit id="150577e3855332cfa9b847f25eb077da526cdf9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = O(&lt;em&gt;g&lt;/em&gt;(x)) when x goes to a (for example, a = +&amp;infin;) means that there is a function &lt;em&gt;k&lt;/em&gt; such that:</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; (x) = O ( &lt;em&gt;g&lt;/em&gt; (x)), когда x переходит к a (например, a = + &amp;infin;), означает, что существует функция &lt;em&gt;k&lt;/em&gt; такая, что:</target>
        </trans-unit>
        <trans-unit id="f39e0610bb58307821a0194948212519a3857fe0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = o(&lt;em&gt;g&lt;/em&gt;(x)) when x goes to a means that there is a function k such that:</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; (x) = o ( &lt;em&gt;g&lt;/em&gt; (x)), когда x означает, что существует функция k такая, что:</target>
        </trans-unit>
        <trans-unit id="60efe2817e6b6dc1067de924ce07bd71c241b66c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;k&lt;/em&gt;(x) goes to 0 when x goes to a.</source>
          <target state="translated">&lt;em&gt;k&lt;/em&gt; (x) переходит к 0, когда x переходит к a.</target>
        </trans-unit>
        <trans-unit id="df9a7b04d24a410a550a80633b5c46b22b5f4454" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;Big O&quot; does two things:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;Большой О&amp;raquo; делает две вещи:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1daaf609ea760d49121da39fad36df3d4c70428" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2&lt;sup&gt;2N&lt;/sup&gt; = (4&lt;sup&gt;N&lt;/sup&gt;)............put another way...... &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2&lt;sup&gt;N+1&lt;/sup&gt; = 2&lt;sup&gt;N&lt;/sup&gt;2&lt;sup&gt;1&lt;/sup&gt; = 2 &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2 &lt;sup&gt;2N&lt;/sup&gt; = (4 &lt;sup&gt;N&lt;/sup&gt; ) ............ другими словами ...... &lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2 &lt;sup&gt;N + 1&lt;/sup&gt; = 2 &lt;sup&gt;N&lt;/sup&gt; 2 &lt;sup&gt;1&lt;/sup&gt; = 2 &lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bafc82a1bb664838622cc7d1e8482db598079440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3 key takeaways:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3 ключевых выноса:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae00ba228fe3cdd0cfce107b955e3f34920862ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Plain English Explanation of &lt;em&gt;What&lt;/em&gt; Big O Notation is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Простое английское объяснение того, &lt;em&gt;что такое&lt;/em&gt; обозначение Big O:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="effebafa8908442aac2c8ca79cf7084917151477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Plain English Explanation of the &lt;em&gt;Need&lt;/em&gt; for Big-O Notation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Простое английское объяснение &lt;em&gt;необходимости&lt;/em&gt; обозначения Big-O:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dc1a218f6a731c6560f65be4a2784929627a928" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A more accurate explanation (mathematical)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Более точное объяснение (математическое)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73f82c5b1f0e86127e3020556cc882893d6cf6cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm description:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Описание алгоритма:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f5537eaa639ac5f94aa2c74841f5eaaa9254c7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm example (Java):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример алгоритма (Java):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8aab72c29f5ef095ba2621ef23e8bc30d58b5ec1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Amortized Worst-Case&lt;/strong&gt;: Some data structures may have a worst-case complexity that is large, but guarantee that if you do many of these operations, the average amount of work you do will be better than worst-case. For example, you may have a data structure that normally takes constant &lt;code&gt;O(1)&lt;/code&gt; time. However, occasionally it will 'hiccup' and take &lt;code&gt;O(N)&lt;/code&gt; time for one random operation, because maybe it needs to do some bookkeeping or garbage collection or something... but it promises you that if it does hiccup, it won't hiccup again for N more operations. The worst-case cost is still &lt;code&gt;O(N)&lt;/code&gt; per operation, but the amortized cost &lt;em&gt;over many runs&lt;/em&gt; is &lt;code&gt;O(N)/N&lt;/code&gt; = &lt;code&gt;O(1)&lt;/code&gt; per operation. Because the big operations are sufficiently rare, the massive amount of occasional work can be considered to blend in with the rest of the work as a constant factor. We say the work is &quot;amortized&quot; over a sufficiently large number of calls that it disappears asymptotically.</source>
          <target state="translated">&lt;strong&gt;Амортизированный наихудший случай&lt;/strong&gt; . Некоторые структуры данных могут иметь сложность в наихудшем случае, которая является большой, но гарантирует, что при выполнении многих из этих операций средний объем выполняемой вами работы будет лучше, чем в худшем случае. Например, у вас может быть структура данных, которая обычно занимает постоянное время &lt;code&gt;O(1)&lt;/code&gt; . Тем не менее, иногда он будет &amp;laquo;икать&amp;raquo; и потребует &lt;code&gt;O(N)&lt;/code&gt; времени для одной случайной операции, потому что, возможно, ему нужно будет провести какую-то бухгалтерию или сборку мусора или что-то в этом роде ... но он обещает вам, что если он икнет, он не будет Икнуть еще раз для N больше операций. В худшем случае стоимость по-прежнему составляет &lt;code&gt;O(N)&lt;/code&gt; на операцию, но амортизированная стоимость на &lt;em&gt;протяжении многих прогонов&lt;/em&gt; составляет &lt;code&gt;O(N)/N&lt;/code&gt; = &lt;code&gt;O(1)&lt;/code&gt; на операцию. Поскольку большие операции достаточно редки, можно считать, что огромное количество случайной работы сливается с остальной работой как постоянный фактор. Мы говорим, что работа &amp;laquo;амортизируется&amp;raquo; по достаточно большому количеству вызовов, что она исчезает асимптотически.</target>
        </trans-unit>
        <trans-unit id="bf7370e1d0177c50c4c0d7fb024561f2bab440cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Amortized and average-case complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Амортизированная и средняя сложность&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab4389896132cbec29ee3f0554d686383b2d60f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Applications&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Applications&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b3d5404d360c404fd2bf84459010109192eb8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Attention!&lt;/strong&gt; The notation with the equal sign &quot;=&quot; uses a &quot;fake equality&quot;: it is true that o(g(x)) = O(g(x)), but false that O(g(x)) = o(g(x)).  Similarly, it is ok to write &quot;ln(x) = o(x) when x &amp;rarr; +&amp;infin;&quot;, but the formula &quot;o(x) = ln(x)&quot; would make no sense.</source>
          <target state="translated">&lt;strong&gt;Внимание!&lt;/strong&gt; Обозначение со знаком равенства &amp;laquo;=&amp;raquo; использует &amp;laquo;поддельное равенство&amp;raquo;: верно, что o (g (x)) = O (g (x)), но неверно, что O (g (x)) = o (g (Икс)). Аналогично, можно написать &amp;laquo;ln (x) = o (x), когда x &amp;rarr; + &amp;infin;&amp;raquo;, но формула &amp;laquo;o (x) = ln (x)&amp;raquo; не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="34dd92c00819162397c366f49572746e28f5f1c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Average Case&lt;/strong&gt;: This is no more than using big-O notation for the expected value of a function, rather than the function itself. In the usual case where you consider all inputs to be equally likely, the average case is just the average of the running time. For example with quicksort, even though the worst-case is &lt;code&gt;O(N^2)&lt;/code&gt; for some really bad inputs, the average case is the usual &lt;code&gt;O(N log(N))&lt;/code&gt; (the really bad inputs are very small in number, so few that we don't notice them in the average case).</source>
          <target state="translated">&lt;strong&gt;Средний регистр&lt;/strong&gt; : это не более чем использование нотации big-O для ожидаемого значения функции, а не самой функции. В обычном случае, когда вы считаете, что все входные данные одинаково вероятны, средний случай - это просто среднее время выполнения. Например, для быстрой сортировки, даже если наихудший случай равен &lt;code&gt;O(N^2)&lt;/code&gt; для некоторых действительно плохих входных данных, средний случай - это обычный &lt;code&gt;O(N log(N))&lt;/code&gt; (действительно плохие входные данные очень малы, поэтому мало что мы их не замечаем в среднем случае).</target>
        </trans-unit>
        <trans-unit id="3220576162b61267d1a4a26767219ea6e4545c4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Back to English&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вернуться на английский&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0cac323801b8e9b2b0c915a6c542a3bbb241cb47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basics&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Basics&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deeb35e60114ce47ff18984e39930c946fc62ed4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Case:&lt;/strong&gt; In the telephone book search, the best case is that we find the name in one comparison.  This is &lt;strong&gt;O(1)&lt;/strong&gt; or &lt;strong&gt;constant complexity&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong&gt;Лучший случай:&lt;/strong&gt; в поиске по телефонной книге лучший случай - это то, что мы находим имя в одном сравнении. Это &lt;strong&gt;O (1)&lt;/strong&gt; или &lt;strong&gt;постоянная сложность&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="41bdf2eff0707b735977a7b17f99ea1599797803" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Case:&lt;/strong&gt; O(1);</source>
          <target state="translated">&lt;strong&gt;Лучший случай:&lt;/strong&gt; O (1);</target>
        </trans-unit>
        <trans-unit id="7914d10c281c86a759e82a40640c5f8d93756303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big O describes the fundamental scaling nature of an algorithm.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big O описывает фундаментальную масштабирующую природу алгоритма.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e271d8846f3715b1a024f21916128b7d4259417" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big O&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Большой О&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dd5e066b9eba73f69ac911aaff371d1d5517277" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big-O notation is a relative representation of the complexity of an algorithm.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Система обозначений Big-O является относительным представлением сложности алгоритма.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c911dd80e980898d8f2c1e27f8c346fb06ef9ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big-O notation:&lt;/strong&gt; describes &lt;em&gt;how quickly runtime will grow relative to the input as the input get arbitrarily large.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Обозначение Big-O:&lt;/strong&gt; описывает, &lt;em&gt;как быстро будет расти время выполнения относительно ввода, когда входное значение становится произвольно большим.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1070a59c780c49217b3d9ef6075f07036a4de4f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Building Intuition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Интуиция здания&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f587b858f8d6fe44a8225f82326a30f53c9d5650" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;By the time you get to 200 towns there isn't enough time left in the universe to solve the problem with traditional computers.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;К тому времени, как вы доберетесь до 200 городов, во вселенной не останется достаточно времени, чтобы решить проблему с традиционными компьютерами.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1d2d8d2f9c4e97fb709d00d85e5dfaceb74c57d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant factors&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Постоянные факторы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9efca8768fe35240139284fbd68b4fe07fc97b92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Case:&lt;/strong&gt; As discussed above this is O(log n); and</source>
          <target state="translated">&lt;strong&gt;Ожидаемый случай:&lt;/strong&gt; как обсуждалось выше, это O (log n); и</target>
        </trans-unit>
        <trans-unit id="9587614449d0127777f6fe21db3683733e748143" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Case:&lt;/strong&gt; O(n) (for 500,000); and</source>
          <target state="translated">&lt;strong&gt;Ожидаемый случай:&lt;/strong&gt; O (n) (для 500 000); и</target>
        </trans-unit>
        <trans-unit id="cdd089580422378d4ca18f0f8f5cf50cf6b830ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do analyze algorithms and how can we compare algorithms against each other?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как анализировать алгоритмы и как мы можем сравнивать алгоритмы друг с другом?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea84419042cce91d342892912299eab7b4c9fa1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you're unlucky when executing A, it might take as much as X(n) operations to
  complete.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Если вам не повезло при выполнении A, выполнение операций X (n) может занять столько же времени.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5f526b740d48e1e3fd49fd9918ce4ec61555a90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multidimensional big-O&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Многомерный биг-о&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6acc739d0b13f807318bf1624de37df1094994ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N&amp;sup2;&lt;/strong&gt; &amp;rarr; (2N)&amp;sup2; = 4(&lt;strong&gt;N&amp;sup2;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;N&amp;sup2;&lt;/strong&gt; &amp;rarr; (2N) &amp;sup2; = 4 ( &lt;strong&gt;N&amp;sup2;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="61702d5685c60ef63ef6fe3ad5ab08a71dd8a2d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N&lt;/strong&gt; &amp;rarr; (2N) = 2(&lt;strong&gt;N&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;N&lt;/strong&gt; &amp;rarr; (2N) = 2 ( &lt;strong&gt;N&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="21cce32ea86e14da51ca9a5664ed1f0ffeff0b0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Big O notation represents the &lt;strong&gt;worst-case scenario&lt;/strong&gt; of an algorithm. Let&amp;rsquo;s assume that &lt;strong&gt;O(1)&lt;/strong&gt; and &lt;strong&gt;O(n)&lt;/strong&gt; are the worst-case scenarios of the example above.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Обозначение Big O представляет &lt;strong&gt;наихудший сценарий&lt;/strong&gt; алгоритма. Предположим, что &lt;strong&gt;O (1)&lt;/strong&gt; и &lt;strong&gt;O (n)&lt;/strong&gt; являются сценариями наихудшего случая в приведенном выше примере.</target>
        </trans-unit>
        <trans-unit id="252fabf6945e589a9b0b19016a058e011afbcc3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(1):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68d75ca052377c566336069afee258c69b9aec6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1)&lt;/strong&gt; - Time to complete is the same regardless of the size of input set. An example is accessing an array element by index.</source>
          <target state="translated">&lt;strong&gt;O (1)&lt;/strong&gt; - время завершения одинаково, независимо от размера набора ввода. Примером является доступ к элементу массива по индексу.</target>
        </trans-unit>
        <trans-unit id="f9afcf401f691a7c75faeb32231d92fde83ecee4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1)&lt;/strong&gt;:  known as &lt;strong&gt;Constant complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (1)&lt;/strong&gt; : известный как &lt;strong&gt;постоянная сложность&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dd564fa0710bbf0a0a6d4f2c0d4f0f4442e00d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e72a614b62847ef5617dfe85cfaca13129fb5ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; ):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="635e753fee8296bf321ba6bb90e4518245442fc7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d4b1b888d0086c21997e7a8ecfa829f30374361" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22ac35f2cdc52d148b68da9ed9dd29461e980fe3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(Log N)&lt;/strong&gt; - Time to complete increases roughly in line with the log2(n). For example 1024 items takes roughly twice as long as 32 items, because Log2(1024) = 10 and Log2(32) = 5. An example is finding an item in a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;binary search tree&lt;/a&gt; (BST).</source>
          <target state="translated">&lt;strong&gt;O (Log N)&lt;/strong&gt; - Время до завершения увеличивается примерно в соответствии с log2 (n). Например, 1024 элемента занимают примерно вдвое больше времени, чем 32 элемента, потому что Log2 (1024) = 10 и Log2 (32) = 5. Примером является поиск элемента в &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;двоичном дереве поиска&lt;/a&gt; (BST).</target>
        </trans-unit>
        <trans-unit id="d26adbc9eb537a7d0d5f9ae0552e61b12d6c54bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N Log N)&lt;/strong&gt; - Time to complete increases by the number of items times the result of Log2(N). An example of this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap_sort&quot;&gt;heap sort&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Quick_sort&quot;&gt;quick sort&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O (N Log N)&lt;/strong&gt; - Время завершения увеличивается на количество элементов, умноженное на результат Log2 (N). Примером этого является &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap_sort&quot;&gt;кучная сортировка&lt;/a&gt; и &lt;a href=&quot;http://en.wikipedia.org/wiki/Quick_sort&quot;&gt;быстрая сортировка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd630f970ed12459c9538aee894e4fca49869a98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N!)&lt;/strong&gt; - Time to complete is the factorial of the input set. An example of this is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;traveling salesman problem brute-force solution&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O (N!)&lt;/strong&gt; - время до завершения является факториалом входного набора. Примером этого является решение &lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;проблемы грубой силы коммивояжера&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2e179b7e171e252effc28bae4e6ee136e75dba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N)&lt;/strong&gt; - Time to complete that scales linearly with the size of the input set. In other words if you double the number of items in the input set, the algorithm takes roughly twice as long. An example is counting the number of items in a linked list.</source>
          <target state="translated">&lt;strong&gt;O (N)&lt;/strong&gt; - время для завершения, которое масштабируется линейно с размером входного набора. Другими словами, если вы удвоите количество элементов во входном наборе, алгоритм займет примерно вдвое больше времени. Примером является подсчет количества элементов в связанном списке.</target>
        </trans-unit>
        <trans-unit id="4784dc4311f56c18cde15b50f60f2194c6df45fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N^2)&lt;/strong&gt; - Time to complete is roughly equal to the square of the number of items. An example of this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;bubble sort&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O (N ^ 2)&lt;/strong&gt; - Время для завершения примерно равно квадрату количества предметов. Примером этого является &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;пузырьковая сортировка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf8d37b23321b288f2b44644bc4c145c6315466f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log &lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (log &lt;em&gt;n&lt;/em&gt; ):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32f6df92bfa553861340db36e2f34e2204cc3856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log n)&lt;/strong&gt;:  known as &lt;strong&gt;Logarithmic complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (log n)&lt;/strong&gt; : известный как &lt;strong&gt;логарифмическая сложность&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9a156d671486ba42c9d6bc4f718b4ad56ae4429" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n)&lt;/strong&gt;:  known as &lt;strong&gt;Linear complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (n)&lt;/strong&gt; : известен как &lt;strong&gt;линейная сложность&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25021c74f1f7cc3f73ce24095087c41055c38051" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;:  known as &lt;strong&gt;Quadratic complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (n &lt;sup&gt;2&lt;/sup&gt; )&lt;/strong&gt; : известен как &lt;strong&gt;квадратичная сложность&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ad18baa396b629a872133cacda5df06a167689b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Practical example: visualizing orders of growth while coding&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Практический пример: визуализация порядка роста при кодировании&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee51f001b7ef2c276ec42b4e704f02dd05a4cccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt; : &lt;a href=&quot;http://carlcheo.com/compsci&quot;&gt;http://carlcheo.com/compsci&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Ссылка&lt;/strong&gt; : &lt;a href=&quot;http://carlcheo.com/compsci&quot;&gt;http://carlcheo.com/compsci&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63fd89842e817d63e08af214f7f5c992e4999387" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplest way to look at it (in plain English)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Самый простой способ взглянуть на это (простым английским языком)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f8b58e2bc4650ab1f5fd985238dd4f0a986d132" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Small o&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Маленький о&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff25f85074d21875430e07bd8801b858e31f7be6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Space complexity:&lt;/strong&gt; aside from time complexity, we also care about space complexity (how much memory/space an algorithm uses). Instead of checking the time of operations, we check the size of the allocation of memory.</source>
          <target state="translated">&lt;strong&gt;Сложность пространства:&lt;/strong&gt; кроме сложности времени, мы также заботимся о сложности пространства (сколько памяти / пространства использует алгоритм). Вместо того, чтобы проверять время операций, мы проверяем размер выделения памяти.</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aea48c460158f9801c2ff1547226bfcd94a4ab48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The whole story&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Полная история&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5841737d9f1f0f3920b87ca2d61ff0c8311a9f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are seven most used notations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Есть семь наиболее часто используемых обозначений&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="898a1558a3534794d5a58e6000c3473375b52eb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There's also Big-Omega, which represent complexity of the Best-Case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Есть также Big-Omega, которые представляют сложность Best-Case:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a11037fecab22049818b34474fe8e78b05b5b18c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To find The Big-O on Time Complexity:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Чтобы найти Big-O на сложности времени:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07f6120a26e2f3f8456ca56f2c44ce3f39c3119c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We only care about the most significant portion of complexity.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Мы заботимся только о самой значительной части сложности.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7974c46035c46b41ac44b7f0b9e92098bfa014df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why O(N) is sometimes the best you can do, i.e. why we need datastructures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Почему O (N) иногда является лучшим, что вы можете сделать, то есть, почему нам нужны структуры данных&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4207c81d75e6ff00a2ab700fd03b10c9d6ef7476" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst Case:&lt;/strong&gt; O(n) (for 1,000,000).</source>
          <target state="translated">&lt;strong&gt;В худшем случае:&lt;/strong&gt; O (n) (для 1 000 000).</target>
        </trans-unit>
        <trans-unit id="575be9f02c898b973aff9fb1bd5bd357e2752a80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst Case:&lt;/strong&gt; This is also O(log n).</source>
          <target state="translated">&lt;strong&gt;В худшем случае:&lt;/strong&gt; это тоже O (log n).</target>
        </trans-unit>
        <trans-unit id="8259671e56bc51a9fd25fab5b93ec32f6a9f6007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;algorithm&lt;/strong&gt;: procedure/formula for solving a problem</source>
          <target state="translated">&lt;strong&gt;алгоритм&lt;/strong&gt; : процедура / формула для решения задачи</target>
        </trans-unit>
        <trans-unit id="bf91eb2b18b1a94ff6bc8b8c14b3d1250c603cbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;analogy&lt;/strong&gt;: The analogy in this particular case is a jigsaw puzzle: We created a data structure that exploits some property of the data. If our road segments are like puzzle pieces, we group them by matching color and pattern. We then exploit this to avoid doing extra work later (comparing puzzle pieces of like color to each other, not to every other single puzzle piece).</source>
          <target state="translated">&lt;strong&gt;аналогия&lt;/strong&gt; : аналогия в данном конкретном случае - это головоломка: мы создали структуру данных, которая использует некоторое свойство данных. Если наши сегменты дороги похожи на кусочки головоломки, мы группируем их по цвету и рисунку. Затем мы используем это, чтобы избежать дополнительной работы позже (сравнивая кусочки головоломки одинакового цвета друг с другом, а не со всеми остальными кусочками головоломки).</target>
        </trans-unit>
        <trans-unit id="3fd5be370782e9eefda17f79f700c59070a53c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;c log(N)&lt;/strong&gt; &amp;rarr; c log(2N) = (c log(2))+(&lt;strong&gt;c log(N)&lt;/strong&gt;) = (fixed amount)+(&lt;strong&gt;c log(N)&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;c log (N)&lt;/strong&gt; &amp;rarr; c log (2N) = (c log (2)) + ( &lt;strong&gt;c log (N)&lt;/strong&gt; ) = (фиксированная сумма) + ( &lt;strong&gt;c log (N)&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="6bd6f3f7face459b8ad4a2440f178d8320099c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;c*1&lt;/strong&gt; &amp;rarr; &lt;strong&gt;c*1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;с * 1&lt;/strong&gt; &amp;rarr; &lt;strong&gt;с * 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae34a86dbd8e294559fb6de015a86203c6d6210c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; &amp;rarr; c(2N)&amp;sup3; = 8(&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; &amp;rarr; c (2N) &amp;sup3; = 8 ( &lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="27b5788854d51bd893ea7a5207a2a3c0a233aee4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;complexity:&lt;/strong&gt; if it takes me one second to sort 10,000 elements, how long will it take me to sort one million?  Complexity in this instance is a relative measure to something else.</source>
          <target state="translated">&lt;strong&gt;сложность:&lt;/strong&gt; если мне понадобится одна секунда, чтобы отсортировать 10000 элементов, сколько времени мне понадобится, чтобы отсортировать миллион? Сложность в этом случае является относительной мерой к чему-то другому.</target>
        </trans-unit>
        <trans-unit id="5457665c30d0585dc37a4fd244075c3a2b2ad61b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for &quot;sufficiently&quot; large inputs...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;для &quot;достаточно&quot; больших входов ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2acb65b1907221e1bdd5284f08ac1b0df4ea0231" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;relative:&lt;/strong&gt; you can only compare apples to apples.  You can't compare an algorithm to do arithmetic multiplication to an algorithm that sorts a list of integers.  But a comparison of two algorithms to do arithmetic operations (one multiplication, one addition) will tell you something meaningful;</source>
          <target state="translated">&lt;strong&gt;Относительно:&lt;/strong&gt; вы можете сравнить только яблоки с яблоками. Вы не можете сравнить алгоритм для выполнения арифметического умножения с алгоритмом, который сортирует список целых чисел. Но сравнение двух алгоритмов для выполнения арифметических операций (одно умножение, одно сложение) скажет вам что-то значимое;</target>
        </trans-unit>
        <trans-unit id="527b57aaeb37446d8c211474a094432da292f875" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;representation:&lt;/strong&gt; Big-O (in its simplest form) reduces the comparison between algorithms to a single variable.  That variable is chosen based on observations or assumptions.  For example, sorting algorithms are typically compared based on comparison operations (comparing two nodes to determine their relative ordering).  This assumes that comparison is expensive.  But what if comparison is cheap but swapping is expensive?  It changes the comparison; and</source>
          <target state="translated">&lt;strong&gt;представление:&lt;/strong&gt; Big-O (в простейшем виде) сводит сравнение между алгоритмами к одной переменной. Эта переменная выбирается на основе наблюдений или предположений. Например, алгоритмы сортировки обычно сравниваются на основе операций сравнения (сравнение двух узлов для определения их относительного порядка). Это предполагает, что сравнение стоит дорого. Но что, если сравнение дешево, а обмен дорог? Это меняет сравнение; и</target>
        </trans-unit>
        <trans-unit id="19518fd2e0a8446c92d07859c82f3fdb9396de2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr: The number of handshakes 'looks like' x&amp;sup2; so much for large values, that if we were to write down the ratio #handshakes/x&amp;sup2;, the fact that we don't need &lt;em&gt;exactly&lt;/em&gt; x&amp;sup2; handshakes wouldn't even show up in the decimal for an arbitrarily large while.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tl; dr: количество рукопожатий &amp;laquo;выглядит как&amp;raquo; x&amp;sup2; для больших значений настолько, что если бы мы записали соотношение # handshakes / x&amp;sup2;, тот факт, что нам не нужны &lt;em&gt;именно&lt;/em&gt; x&amp;sup2; рукопожатия, даже не обнаружился бы в десятичном виде для сколь угодно большого времени.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc58ee0a287cef32ca985382490b5ed483c76fc8" translate="yes" xml:space="preserve">
          <source>A &amp;rarr; B &amp;rarr; C</source>
          <target state="translated">A &amp;rarr; B &amp;rarr; C</target>
        </trans-unit>
        <trans-unit id="9814460aaaa82f895fab69aa1e7b80cc39fcf625" translate="yes" xml:space="preserve">
          <source>A &amp;rarr; C &amp;rarr; B</source>
          <target state="translated">A &amp;rarr; C &amp;rarr; B</target>
        </trans-unit>
        <trans-unit id="6fa316481ef216118bd579775f4816b14c18a0f7" translate="yes" xml:space="preserve">
          <source>A simple straightforward answer can be:</source>
          <target state="translated">Простой и понятный ответ может быть:</target>
        </trans-unit>
        <trans-unit id="2fa68420a293bc47b500623963e3f939ae51a473" translate="yes" xml:space="preserve">
          <source>A typical implementation might be to open up to the middle, take the 500,000&lt;sup&gt;th&lt;/sup&gt; and compare it to &quot;Smith&quot;. If it happens to be &quot;Smith, John&quot;, we just got real lucky.  Far more likely is that &quot;John Smith&quot; will be before or after that name.  If it's after we then divide the last half of the phone book in half and repeat.  If it's before then we divide the first half of the phone book in half and repeat.  And so on.</source>
          <target state="translated">Типичная реализация может состоять в том, чтобы открыть до середины, взять 500 000- &lt;sup&gt;й&lt;/sup&gt; и сравнить его со &amp;laquo;Смитом&amp;raquo;. Если это &amp;laquo;Смит, Джон&amp;raquo;, нам просто повезло. Гораздо более вероятно, что &amp;laquo;Джон Смит&amp;raquo; будет до или после этого имени. Если это после того, как мы разделим вторую половину телефонной книги пополам и повторите. Если это раньше, то мы разделяем первую половину телефонной книги пополам и повторяем. И так далее.</target>
        </trans-unit>
        <trans-unit id="b2eaa9e11c09c682e15e1f9214b1b8f85ad77873" translate="yes" xml:space="preserve">
          <source>Addition is the simplest.  You line the numbers up (to the right) and add the digits in a column writing the last number of that addition in the result.  The 'tens' part of that number is carried over to the next column.</source>
          <target state="translated">Добавление-самое простое.Вы выстраиваете цифры вверх (справа)и добавляете цифры в столбец,записывая последний номер этого сложения в результат.Десятки&quot; часть этого числа переносится в следующий столбец.</target>
        </trans-unit>
        <trans-unit id="06a8ddf90a58cac434d9dddb41eadc549d53c934" translate="yes" xml:space="preserve">
          <source>Also keep in mind that due to hidden constraints of your program, you might not really care about asymptotic behavior. You may be working with a bounded number of values, for example:</source>
          <target state="translated">Также имейте в виду,что из-за скрытых ограничений вашей программы,вас может не волновать асимптотическое поведение.Например,вы можете работать с ограниченным количеством значений:</target>
        </trans-unit>
        <trans-unit id="580cbd5744ce3d45f6d2b723b41c7344947edda0" translate="yes" xml:space="preserve">
          <source>Although anything &quot;larger&quot; than a constant factor can be detected, however.</source>
          <target state="translated">Однако,несмотря на то,что может быть обнаружено что-либо &quot;большее&quot;,чем постоянный фактор.</target>
        </trans-unit>
        <trans-unit id="f5bfda3d2781b7d70658d5d11b9d005ba3e1398e" translate="yes" xml:space="preserve">
          <source>Amortized worst-case: If you use an amortized worst-case data structure, the performance is guaranteed to be within the amortized worst-case... eventually (even if the inputs are chosen by an evil demon who knows everything and is trying to screw you over). Usually, we use this to analyze algorithms that may be very 'choppy' in performance with unexpected large hiccups, but over time perform just as well as other algorithms. (However unless your data structure has upper limits for much outstanding work it is willing to procrastinate on, an evil attacker could perhaps force you to catch up on the maximum amount of procrastinated work all-at-once.</source>
          <target state="translated">Амортизированный худший случай:Если вы используете амортизированную структуру данных в худшем случае,производительность гарантированно будет в пределах амортизированного худшего случая...в конечном счете (даже если входные данные выбраны злым демоном,который знает все и пытается обмануть вас).Обычно мы используем это для анализа алгоритмов,которые могут быть очень &quot;нестабильными&quot; в производительности при неожиданной большой икоте,но со временем работают так же хорошо,как и другие алгоритмы.(Однако,если в структуре Ваших данных нет верхних пределов для столь выдающейся работы,которую он готов потянуть,злой злоумышленник,возможно,заставит Вас наверстать максимальный объем прокручиваемой работы.</target>
        </trans-unit>
        <trans-unit id="c08025d0af34b0e733dff69c38b8140014e0dcfb" translate="yes" xml:space="preserve">
          <source>And furthermore</source>
          <target state="translated">Кроме того.</target>
        </trans-unit>
        <trans-unit id="6896d57deefe7dcce6486c33a6e908bb66a0f2d5" translate="yes" xml:space="preserve">
          <source>Another point I wanted to make quick mention of is that any algorithm that has a complexity of &lt;strong&gt;O(n&lt;sup&gt;a&lt;/sup&gt;)&lt;/strong&gt; is said to have &lt;strong&gt;polynomial complexity&lt;/strong&gt; or is solvable in &lt;strong&gt;polynomial time&lt;/strong&gt;.</source>
          <target state="translated">Еще один момент, о котором я хотел бы кратко упомянуть, заключается в том, что любой алгоритм со сложностью &lt;strong&gt;O (n &lt;sup&gt;a&lt;/sup&gt; )&lt;/strong&gt; называется &lt;strong&gt;полиномиальной сложностью&lt;/strong&gt; или разрешим в &lt;strong&gt;полиномиальное время&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="18d608bf5ee39a542ef2abc8b2c8aa9502e49075" translate="yes" xml:space="preserve">
          <source>Anyone who's read Programming Pearls or any other Computer Science
  books and doesn&amp;rsquo;t have a grounding in Mathematics will have hit a wall
  when they reached chapters that mention O(N log N) or other seemingly
  crazy syntax. Hopefully this article will help you gain an
  understanding of the basics of Big O and Logarithms.</source>
          <target state="translated">Любой, кто читает &amp;laquo;Программирование жемчужин&amp;raquo; или любые другие книги по информатике и не имеет оснований по математике, попадет в стену, когда достигнет глав, в которых упоминается O (N log N) или другой, казалось бы, сумасшедший синтаксис. Надеюсь, эта статья поможет вам понять основы Big O и логарифмов.</target>
        </trans-unit>
        <trans-unit id="ca7668976286f5ad8d5eca2a7fadcc44aba0a83b" translate="yes" xml:space="preserve">
          <source>Anyway, that's it for my (hopefully plain English) explanation of Big O (revised).</source>
          <target state="translated">В любом случае,это все для моего (надеюсь,простого английского)объяснения Big O (пересмотрено).</target>
        </trans-unit>
        <trans-unit id="010115fea8e63b4e720d7c742f8033325bf02f8e" translate="yes" xml:space="preserve">
          <source>As &lt;em&gt;n&lt;/em&gt; gets arbitrarily large, focus on the terms that will grow the fastest as n gets large (think infinity) AKA &lt;strong&gt;asymptotic analysis&lt;/strong&gt;</source>
          <target state="translated">Поскольку &lt;em&gt;n&lt;/em&gt; становится произвольно большим, сфокусируйтесь на терминах, которые будут расти быстрее всего, когда n становится большим (думаю, бесконечность) АКА- &lt;strong&gt;асимптотический анализ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="870ad13cbf6243c698d7d2bf03ab24ac0048aa57" translate="yes" xml:space="preserve">
          <source>As a programmer first and a mathematician second (or maybe third or
  fourth) I found the best way to understand Big O thoroughly was to
  produce some examples in code. So, below are some common orders of
  growth along with descriptions and examples where possible.</source>
          <target state="translated">Как программист-первый и математик-второе (а может быть,и третье или четвертое),я нашел лучший способ досконально разобраться в Big O-это привести несколько примеров в коде.Итак,ниже приведены некоторые общие порядки роста вместе с описаниями и примерами,где это возможно.</target>
        </trans-unit>
        <trans-unit id="483f1c4417fdd5afc1f2915ce24ff5ba0f7520e8" translate="yes" xml:space="preserve">
          <source>As a purely mathematical construct, big-O notation is not limited to talking about processing time and memory. You can use it to discuss the asymptotics of anything where scaling is meaningful, such as:</source>
          <target state="translated">Как чисто математическая конструкция,нотация big-O не ограничивается разговорами о времени обработки и памяти.С ее помощью можно обсуждать асимптотику всего,где масштабирование имеет смысл,например:</target>
        </trans-unit>
        <trans-unit id="d7f64f73685e6f247cbf73eed79f3d10cdb73567" translate="yes" xml:space="preserve">
          <source>As a result of all this unhelpful complexity, people try to describe the speed of software programs using the smallest and least complex (mathematical) expressions possible. These expressions are very very crude approximations: Although, with a bit of luck, they will capture the &quot;essence&quot; of whether a piece of software is fast or slow.</source>
          <target state="translated">В результате всей этой бесполезной сложности,люди пытаются описать скорость работы программ,используя самые маленькие и наименее сложные (математические)выражения.Эти выражения являются очень грубыми приближениями:Хотя,если повезет,они улавливают &quot;суть&quot; того,является ли программное обеспечение быстрым или медленным.</target>
        </trans-unit>
        <trans-unit id="7f8315a19f8a52da5d9ef1a40ab83006a844cfd3" translate="yes" xml:space="preserve">
          <source>As it happens, there are certain functions (think of them as &lt;em&gt;implementations&lt;/em&gt; of &lt;strong&gt;X(n)&lt;/strong&gt;) that tend to occur quite often. These are well known and easily compared (Examples: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Log N&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;N^2&lt;/code&gt;, &lt;code&gt;N!&lt;/code&gt;, etc..)</source>
          <target state="translated">Как это бывает, есть определенные функции (представьте их как &lt;em&gt;реализации&lt;/em&gt; &lt;strong&gt;X (n)&lt;/strong&gt; ), которые имеют тенденцию появляться довольно часто. Они хорошо известны и их легко сравнивать (Примеры: &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;Log N&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;N^2&lt;/code&gt; , &lt;code&gt;N!&lt;/code&gt; И т. Д.)</target>
        </trans-unit>
        <trans-unit id="58635748eb80ad2370517e468a337e1bd88c9cc8" translate="yes" xml:space="preserve">
          <source>As the algorithm scales with n-&lt;em&gt;squared&lt;/em&gt;, this is &lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt; or &lt;strong&gt;quadratic complexity&lt;/strong&gt;. This is a good time to introduce another important concept:</source>
          <target state="translated">Поскольку алгоритм масштабируется с n- &lt;em&gt;квадратом&lt;/em&gt; , это &lt;strong&gt;O (n &lt;sup&gt;2&lt;/sup&gt; )&lt;/strong&gt; или &lt;strong&gt;квадратичная сложность&lt;/strong&gt; . Самое время представить еще одну важную концепцию:</target>
        </trans-unit>
        <trans-unit id="db509c6991e60440b1722a307f8ef3f99bc3043d" translate="yes" xml:space="preserve">
          <source>Assume we're talking about an algorithm &lt;strong&gt;A&lt;/strong&gt;, which should do something with a dataset of size &lt;strong&gt;n&lt;/strong&gt;.</source>
          <target state="translated">Предположим, мы говорим об алгоритме &lt;strong&gt;A&lt;/strong&gt; , который должен что-то делать с набором данных размером &lt;strong&gt;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5e269fc76f0e879e9586e4d2d5b07a5bf29feecd" translate="yes" xml:space="preserve">
          <source>Asymptotic notation is, at its core, quite separate from programming. Asymptotic notation is a mathematical framework for thinking about how things scale and can be used in many different fields. That said... this is how you &lt;em&gt;apply&lt;/em&gt; asymptotic notation to coding.</source>
          <target state="translated">Асимптотическая запись по своей сути совершенно отделена от программирования. Асимптотическая нотация - это математическая основа для размышлений о масштабировании вещей, которая может использоваться во многих различных областях. Тем не менее ... это то, как вы &lt;em&gt;применяете&lt;/em&gt; асимптотические обозначения для кодирования.</target>
        </trans-unit>
        <trans-unit id="b1fcf30b1f3fc218decd89222f7ae2f077cdd616" translate="yes" xml:space="preserve">
          <source>At some point, at some time, there will be no swaps, and our sort of the deck would be done.  So much work!</source>
          <target state="translated">В какой-то момент,в какой-то момент,не будет никаких обменов,и наш тип палубы будет сделан.Столько работы!</target>
        </trans-unit>
        <trans-unit id="bfb8cbb068a5baea44b500d50ed4ead05e487564" translate="yes" xml:space="preserve">
          <source>At some point, this loop (from Two to Three) will end.  It ends when both halves of this search meet at the splay card.  Then, we have just splayed the deck with the card you chose in step One.  Now, all the cards near the start are more low than the splay card; and the cards near the end are more high than the splay card.  Cool trick!</source>
          <target state="translated">В какой-то момент этот цикл (от двух до трех)закончится.Он заканчивается,когда обе половинки этого поиска встречаются на карте сплеев.Затем,мы только что расплескали колоду с картой,которую вы выбрали на первом шаге.Теперь все карты,находящиеся рядом с началом цикла,имеют более низкую высоту,чем игральная карта;а карты,находящиеся рядом с концом цикла,имеют более высокую высоту,чем игральная карта.Классный трюк!</target>
        </trans-unit>
        <trans-unit id="6ad9a691d1120dce91af1178eb6b497f4f7e37f7" translate="yes" xml:space="preserve">
          <source>Average-case: We make some assumptions about our inputs; i.e. if our inputs have different probabilities, then our outputs/runtimes will have different probabilities (which we take the average of). Usually, we assume that our inputs are all equally likely (uniform probability), but if the real-world inputs don't fit our assumptions of &quot;average input&quot;, the average output/runtime calculations may be meaningless. If you anticipate uniformly random inputs though, this is useful to think about!</source>
          <target state="translated">Средний случай:Мы делаем некоторые предположения о наших входных данных;т.е.если наши входные данные имеют различные вероятности,то наши выходные данные будут иметь различные вероятности (которые мы берем среднее значение).Обычно мы предполагаем,что все наши входы одинаково вероятны (равная вероятность),но если реальные входы не соответствуют нашим предположениям о &quot;среднем входе&quot;,то вычисления среднего выходного времени могут быть бессмысленны.Однако,если Вы предполагаете,что входы будут равномерно случайными,то об этом полезно подумать!</target>
        </trans-unit>
        <trans-unit id="832a8d90127d5ca48f6556477abd38a77ce36f33" translate="yes" xml:space="preserve">
          <source>B &amp;rarr; A &amp;rarr; C</source>
          <target state="translated">B &amp;rarr; A &amp;rarr; C</target>
        </trans-unit>
        <trans-unit id="d813322c7a347a65c04fed32bbe445579ce7e1e8" translate="yes" xml:space="preserve">
          <source>B &amp;rarr; C &amp;rarr; A</source>
          <target state="translated">B &amp;rarr; C &amp;rarr; A</target>
        </trans-unit>
        <trans-unit id="cc07b18b222d704f4ad25abdb8dc152106fba5a0" translate="yes" xml:space="preserve">
          <source>Back to the telephone book.</source>
          <target state="translated">Вернемся к телефонной книге.</target>
        </trans-unit>
        <trans-unit id="56a13e8f97147d6679bf9d3baf62cda1ea3b33ca" translate="yes" xml:space="preserve">
          <source>Back up a bit: the number of handshakes is exactly n-choose-2 or &lt;code&gt;N*(N-1)/2&lt;/code&gt; (each of N people shakes the hands of N-1 other people, but this double-counts handshakes so divide by 2):</source>
          <target state="translated">Немного подкрепимся: количество рукопожатий в точности равно n-выбирать-2 или &lt;code&gt;N*(N-1)/2&lt;/code&gt; (каждый из N человек пожимает руки другим людям по N-1, но это удваивает количество рукопожатий, поэтому разделите на 2):</target>
        </trans-unit>
        <trans-unit id="5120b09510b1d63d87c9c5faa58192336bbcb191" translate="yes" xml:space="preserve">
          <source>Based on the mathematical definition above, if you say your algorithm is a Big O of n, it means it is a function of n (number of input parameters) &lt;strong&gt;or faster&lt;/strong&gt;. If your algorithm is Big O of n, then it is also automatically the Big O of n square.</source>
          <target state="translated">Исходя из приведенного выше математического определения, если вы говорите, что ваш алгоритм представляет собой Big O из n, это означает, что он является функцией от n (числа входных параметров) &lt;strong&gt;или быстрее&lt;/strong&gt; . Если ваш алгоритм Big O из n, то он также автоматически является квадратом Big O из n.</target>
        </trans-unit>
        <trans-unit id="db284bf74073477f62953e8e8e02b1401e213f94" translate="yes" xml:space="preserve">
          <source>Because they are approximations, we use the letter &quot;O&quot; (Big Oh) in the expression, as a convention to signal to the reader that we are making a gross oversimplification. (And to make sure that nobody mistakenly thinks that the expression is in any way accurate).</source>
          <target state="translated">Поскольку они являются аппроксимациями,мы используем букву &quot;О&quot; (Big Oh)в выражении,как условное обозначение,чтобы сигнализировать читателю о том,что мы делаем грубое чрезмерное упрощение.(И чтобы убедиться,что никто ошибочно не думает,что это выражение является в какой-то степени точным).</target>
        </trans-unit>
        <trans-unit id="ac9bfd81f5e9c61b91f03629f317cefc5ed3f40a" translate="yes" xml:space="preserve">
          <source>Best-Case: the key is the first item.</source>
          <target state="translated">Лучший случай:ключ-это первый пункт.</target>
        </trans-unit>
        <trans-unit id="8871063a9de2c96323fce812e3e16047b1b9b0c8" translate="yes" xml:space="preserve">
          <source>Big O comes in and says: for a deck of n cards, to sort it this way will be done in O(N squared) time.</source>
          <target state="translated">Большой О приходит и говорит:для колоды из n карт,чтобы отсортировать его таким образом,будет сделано в O(N квадратного)времени.</target>
        </trans-unit>
        <trans-unit id="e28ca34381715acfd2716526a419b0f386a39327" translate="yes" xml:space="preserve">
          <source>Big O complexity can be visualized with this graph:</source>
          <target state="translated">С помощью этого графика можно визуализировать большую сложность О:</target>
        </trans-unit>
        <trans-unit id="01191d73dc858c84e96603e205ce6cf90b305595" translate="yes" xml:space="preserve">
          <source>Big O describes an upper limit on the growth behaviour of a function, for example the runtime of a program, when inputs become large.</source>
          <target state="translated">Большой О описывает верхний предел роста поведения функции,например,время выполнения программы,когда входы становятся большими.</target>
        </trans-unit>
        <trans-unit id="6d6c6ee7d49379298994bf2d0373e24c46b6260e" translate="yes" xml:space="preserve">
          <source>Big O does not solve the work for us.  Big O tells us how hard the work is.</source>
          <target state="translated">Большой О не решает работу за нас.Большой О говорит нам,как тяжело работать.</target>
        </trans-unit>
        <trans-unit id="067d8c2c09524ec3079760262aecc198a00b16eb" translate="yes" xml:space="preserve">
          <source>Big O ignores factors that do not contribute in a meaningful way to the growth curve of a function as the input size increases towards infinity. This means that constants that are added to or multiplied by the function are simply ignored.</source>
          <target state="translated">Большой О игнорирует факторы,которые не вносят значимого вклада в кривую роста функции по мере того,как размер входного сигнала увеличивается до бесконечности.Это означает,что константы,которые добавляются к функции или умножаются ею,просто игнорируются.</target>
        </trans-unit>
        <trans-unit id="5ef0b065d98e11f17dc80d42a717ef47eb65fe1e" translate="yes" xml:space="preserve">
          <source>Big O is a measure of how much time/space an algorithm uses relative to the size of its input.</source>
          <target state="translated">Большой О-это мера того,сколько времени алгоритм использует по отношению к размеру своего входа.</target>
        </trans-unit>
        <trans-unit id="7e04dd1651f885b1cee3374bf9f1eb929407c8c2" translate="yes" xml:space="preserve">
          <source>Big O is just a way to &quot;Express&quot; yourself in a common way, &quot;How much time / space does it take to run my code?&quot;.</source>
          <target state="translated">Большой О-это просто способ &quot;выразить&quot; себя обычным способом:&quot;Сколько времени нужно,чтобы запустить мой код?&quot;.</target>
        </trans-unit>
        <trans-unit id="615e13e08dc48881c60e9af49cb00312f337463a" translate="yes" xml:space="preserve">
          <source>Big O is useful to compare how well two algorithms will scale up as the number of inputs is increased.</source>
          <target state="translated">Большой О полезен для сравнения того,насколько хорошо два алгоритма будут масштабироваться по мере увеличения количества входов.</target>
        </trans-unit>
        <trans-unit id="d8cd4344a90d7e5c64b849cbdbe8173c868330b0" translate="yes" xml:space="preserve">
          <source>Big O is your friend and mine.  Big O helps us think on how much work we have to do, so we can plan.  And, if we are friends with big O, he can help us choose work that is not so hard!</source>
          <target state="translated">Большой О-твой друг и мой.Большой О помогает нам думать о том,сколько работы мы должны сделать,чтобы мы могли планировать.И,если мы дружим с большим О,он может помочь нам выбрать работу,которая не так уж и сложна!</target>
        </trans-unit>
        <trans-unit id="63a54321034901fba163b3e5364e8adebdcce5cc" translate="yes" xml:space="preserve">
          <source>Big O notation also shines a spotlight directly on the most important principle of computer programming/engineering, the fact which inspires all good programmers to keep thinking and dreaming: the only way to achieve results beyond the slow forward march of technology is to &lt;em&gt;invent a better algorithm&lt;/em&gt;.</source>
          <target state="translated">Система обозначений Big O также освещает наиболее важный принцип компьютерного программирования / инжиниринга, тот факт, что все хорошие программисты вдохновляют всех думать и мечтать: единственный способ достичь результатов, выходящих за рамки медленного продвижения вперед, состоит в том, чтобы &lt;em&gt;изобрести лучший алгоритм&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a168ec8cf3b032681504a8e27d40ac24591c31bc" translate="yes" xml:space="preserve">
          <source>Big O notation is a way of describing how quickly an algorithm will run given an arbitrary number of input parameters, which we'll call &quot;n&quot;. It is useful in computer science because different machines operate at different speeds, and simply saying that an algorithm takes 5 seconds doesn't tell you much because while you may be running a system with a 4.5 Ghz octo-core processor, I may be running a 15 year old, 800 Mhz system, which could take longer regardless of the algorithm. So instead of specifying how fast an algorithm runs in terms of time, we say how fast it runs in terms of number of input parameters, or &quot;n&quot;. By describing algorithms in this way, we are able to compare the speeds of algorithms without having to take into account the speed of the computer itself.</source>
          <target state="translated">Нотация Big O-это способ описания того,как быстро будет запущен алгоритм при произвольном количестве входных параметров,которое мы назовем &quot;n&quot;.Это полезно в вычислительной технике,потому что разные машины работают с разной скоростью,и просто сказать,что алгоритм занимает 5 секунд,не говорит о многом,потому что в то время как вы,возможно,работаете на системе с октоядерным процессором 4.5 ГГц,я,возможно,работаю на 15-летней системе с частотой 800 МГц,что может занять больше времени вне зависимости от алгоритма.Поэтому вместо того,чтобы указать,как быстро алгоритм работает по времени,мы говорим,как быстро он работает по количеству входных параметров,или &quot;n&quot;.Описывая алгоритмы таким образом,мы можем сравнить скорости работы алгоритмов без учета скорости работы самого компьютера.</target>
        </trans-unit>
        <trans-unit id="4b0a116919ddeacd83d71ce31ad376da360a026c" translate="yes" xml:space="preserve">
          <source>Big O notation is a way of describing the upper bound of an algorithm in terms of space or running time.  The n is the number of elements in the the problem (i.e size of an array, number of nodes in a tree, etc.)  We are interested in describing the running time as n gets  big.</source>
          <target state="translated">Большая нотация O-это способ описания верхней границы алгоритма в плане пространства или времени работы.n-это количество элементов в задаче (т.е.размер массива,количество узлов в дереве и т.д.)Нам интересно описать время выполнения,когда n становится большим.</target>
        </trans-unit>
        <trans-unit id="4c8f74fc1bdc10685b2177c45ec160d36cadb907" translate="yes" xml:space="preserve">
          <source>Big O notation is most commonly used by programmers as an approximate measure of how long a computation (algorithm) will take to complete expressed as a function of the size of the input set.</source>
          <target state="translated">Большая нотация O чаще всего используется программистами как примерная мера того,сколько времени займет вычисление (алгоритм),выраженная как функция от размера входного набора.</target>
        </trans-unit>
        <trans-unit id="35d0c4e9b1c9e1dda535f62f93fc8e1e6b9b14c1" translate="yes" xml:space="preserve">
          <source>Big O notation is used in Computer Science to describe the performance
  or complexity of an algorithm. Big O specifically describes the
  worst-case scenario, and can be used to describe the execution time
  required or the space used (e.g. in memory or on disk) by an
  algorithm.</source>
          <target state="translated">Большая нотация О используется в информатике для описания производительности или сложности алгоритма.Большая нотация О конкретно описывает наихудший сценарий и может быть использована для описания требуемого времени выполнения или используемого алгоритмом пространства (например,в памяти или на диске).</target>
        </trans-unit>
        <trans-unit id="029dd5426c412001fb487f1ee4fae8a55e3c8c3b" translate="yes" xml:space="preserve">
          <source>Big O notation simply tells how much time* an algorithm can run within,
  in terms of &lt;em&gt;only the amount of input data&lt;/em&gt;**.</source>
          <target state="translated">Обозначение Big O просто указывает, сколько времени * алгоритм может работать в пределах &lt;em&gt;только количества входных данных&lt;/em&gt; **.</target>
        </trans-unit>
        <trans-unit id="ac3a3f5b5b610616ecbb8b264905e5ee4de505c6" translate="yes" xml:space="preserve">
          <source>Big O notation tells you the cost of solving an infinitely large problem.</source>
          <target state="translated">Большая нотация О говорит о стоимости решения бесконечно большой проблемы.</target>
        </trans-unit>
        <trans-unit id="f4998d7a032917937335ae6425e4667cbea54bd2" translate="yes" xml:space="preserve">
          <source>Big O of n means my algorithm runs at least as fast as this. You cannot look at Big O notation of your algorithm and say its slow. You can only say its fast.</source>
          <target state="translated">Большое O из n означает,что мой алгоритм работает,по крайней мере,так же быстро,как и этот.Вы не можете смотреть на нотацию Big O вашего алгоритма и говорить,что он работает медленно.Ты можешь только сказать,что он работает быстро.</target>
        </trans-unit>
        <trans-unit id="2aabaf3aedb4e0aa46fb4d5ff8c2ab4e6073ca94" translate="yes" xml:space="preserve">
          <source>Big O points out this: as n gets big, when we sort cards, the job gets MUCH MUCH MORE HARD than the old just-add-these-things job.  How do we know this?</source>
          <target state="translated">Большой О указывает на то,что когда n становится большим,когда мы сортируем карты,работа становится более жесткой,чем старая работа &quot;просто добавь-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все-все.Откуда мы это знаем?</target>
        </trans-unit>
        <trans-unit id="93a1b436d9d2b6befbc854db9c969659b8e5b77f" translate="yes" xml:space="preserve">
          <source>Big O represents the worst possible time/space for that algorithm. The algorithm will never take more space/time above that limit. Big O represents time/space complexity in the extreme case.</source>
          <target state="translated">Большой О представляет наихудшее возможное временное пространство для этого алгоритма.Алгоритм никогда не будет занимать больше пространства выше этого предела.Большой О представляет сложность временного пространства в экстремальном случае.</target>
        </trans-unit>
        <trans-unit id="2897bc170748c75b1afb0452b1633a9f90eeaa23" translate="yes" xml:space="preserve">
          <source>Big O says: we must do six adds to solve this.  One add, for each thing from one to six.  Six small bits of work... each bit of work is one add.</source>
          <target state="translated">Большой О говорит:мы должны сделать шесть добавок,чтобы решить эту проблему.Одно добавление,на каждую вещь от одного до шести.Шесть маленьких кусочков работы...каждый кусочек работы-это одно добавление.</target>
        </trans-unit>
        <trans-unit id="01a1c3b9e0eae37b04b930c9e959423669d00b8b" translate="yes" xml:space="preserve">
          <source>Big O tells us that to sort things is more hard than to add things.  O(n squared) is more than O(n) for big n.  That means: if n gets real big, to sort a mixed deck of n things MUST take more time, than to just add n mixed things.</source>
          <target state="translated">Большой О говорит нам,что сортировать вещи сложнее,чем добавлять.O(n в квадрате)больше,чем O(n)для большого n.Это означает:если n становится действительно большим,сортировка смешанной колоды n вещей ДОЛЖНА занять больше времени,чем простое добавление n смешанных вещей.</target>
        </trans-unit>
        <trans-unit id="ff2337e8063fec003cbedd7750338ff7fc025f36" translate="yes" xml:space="preserve">
          <source>Big O, help me!</source>
          <target state="translated">Большой О,помоги мне!</target>
        </trans-unit>
        <trans-unit id="f0939bd08a02841e66e2310a89ddfeb9c0a7055e" translate="yes" xml:space="preserve">
          <source>Big-&amp;Omega; (Big-Omega) notation (article) | Khan Academy</source>
          <target state="translated">Биг-Ом (Биг-Омега) нотация (статья) | Ханская академия</target>
        </trans-unit>
        <trans-unit id="9ffc7ec8bbe6223b3d70e4376f89b6eab1b1a639" translate="yes" xml:space="preserve">
          <source>Big-O notation (also called &quot;asymptotic growth&quot; notation) is &lt;em&gt;what functions &quot;look like&quot; when you ignore constant factors and stuff near the origin&lt;/em&gt;. We use it to talk about &lt;strong&gt;how thing scale&lt;/strong&gt;.</source>
          <target state="translated">Нотация Big-O (также называемая нотацией &amp;laquo;асимптотического роста&amp;raquo;) - это &lt;em&gt;то, на что &amp;laquo;похожи&amp;raquo; функции, когда вы игнорируете постоянные множители и прочее около начала координат&lt;/em&gt; . Мы используем это, чтобы говорить о &lt;strong&gt;том, как вещи масштабируются&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1769664f1e1ca72f099882bf25e7d2f39574cca3" translate="yes" xml:space="preserve">
          <source>Big-O, is &lt;strong&gt;rate of increase&lt;/strong&gt; of resource consumed by program, w.r.t. problem-instance-size</source>
          <target state="translated">Big-O - &lt;strong&gt;скорость увеличения&lt;/strong&gt; ресурсов, потребляемых программой, &lt;strong&gt;по сравнению&lt;/strong&gt; с размером экземпляра</target>
        </trans-unit>
        <trans-unit id="a380e8c171aa6d7e586e8f15b66e52968c776a75" translate="yes" xml:space="preserve">
          <source>Binary search is a technique used to search sorted data sets. It works
  by selecting the middle element of the data set, essentially the
  median, and compares it against a target value. If the values match it
  will return success. If the target value is higher than the value of
  the probe element it will take the upper half of the data set and
  perform the same operation against it. Likewise, if the target value
  is lower than the value of the probe element it will perform the
  operation against the lower half. It will continue to halve the data
  set with each iteration until the value has been found or until it can
  no longer split the data set.</source>
          <target state="translated">Двоичный поиск-это метод,используемый для поиска отсортированных наборов данных.Он работает путем выбора среднего элемента массива данных,по сути медианы,и сравнивает его с целевым значением.Если значения совпадают,это возвращает успех.Если заданное значение больше,чем значение элемента зонда,он возьмет верхнюю половину массива данных и выполнит против него такую же операцию.Аналогично,если заданное значение меньше,чем значение зондового элемента,то выполняется операция с нижней половиной.При каждой итерации он будет продолжать уменьшать набор данных наполовину до тех пор,пока значение не будет найдено или пока он больше не сможет разбивать набор данных.</target>
        </trans-unit>
        <trans-unit id="84e2d5bd3333a554d3c328ae36cecdeea3f085c1" translate="yes" xml:space="preserve">
          <source>Both average-case and amortization are incredibly useful tools for thinking about and designing with scaling in mind.</source>
          <target state="translated">Как средний случай,так и амортизация являются невероятно полезными инструментами для размышлений и проектирования с учетом масштабирования.</target>
        </trans-unit>
        <trans-unit id="81fa41afe9d47413eda0c47da5969d56124c07cf" translate="yes" xml:space="preserve">
          <source>But remember, Big O is just a way to experss yourself in the manner of time and space.</source>
          <target state="translated">Но помните,что Большой О-это всего лишь способ экспериментировать с образом времени и пространства.</target>
        </trans-unit>
        <trans-unit id="3ddd3cf4c5b5b439921cdd63b830507cc2d92e01" translate="yes" xml:space="preserve">
          <source>But though we will not do the work now, we can guess how hard it would be, if we knew n.  We would have to add up n things, right?  Of course!</source>
          <target state="translated">Но,хотя мы не будем делать работу сейчас,мы можем догадаться,как тяжело было бы,если бы мы знали n.Мы должны были бы сложить n вещей,не так ли? Конечно!</target>
        </trans-unit>
        <trans-unit id="de004be9935e007a2aa4a8dd96ba9ccf3e285c6c" translate="yes" xml:space="preserve">
          <source>But, programmers don't think like this because eventually, algorithm intuition just becomes second nature. You will start to code something inefficient and immediately think &quot;am I doing something &lt;strong&gt;grossly inefficient?&lt;/strong&gt;&quot;. If the answer is &quot;yes&quot; AND you foresee it actually mattering, then you can take a step back and think of various tricks to make things run faster (the answer is almost always &quot;use a hashtable&quot;, rarely &quot;use a tree&quot;, and very rarely something a bit more complicated).</source>
          <target state="translated">Но программисты так не думают, потому что в конечном итоге интуиция алгоритма становится второй натурой. Вы начнете кодировать что-то неэффективное и сразу же подумаете: &amp;laquo;Я делаю что-то &lt;strong&gt;крайне неэффективное?&lt;/strong&gt; &amp;raquo;. Если ответ &amp;laquo;да&amp;raquo;, и вы предвидите, что это действительно имеет значение, тогда вы можете сделать шаг назад и подумать о различных хитростях, чтобы заставить вещи работать быстрее (ответ почти всегда &amp;laquo;использовать хеш-таблицу&amp;raquo;, редко &amp;laquo;использовать дерево&amp;raquo;, и очень редко что-то более сложное).</target>
        </trans-unit>
        <trans-unit id="0d8f8969e0785f14a21dfca5ea753a20c18775cc" translate="yes" xml:space="preserve">
          <source>By comparing these when talking about &lt;strong&gt;A&lt;/strong&gt; and other algorithms, it is easy to rank the algorithms according to the number of operations they &lt;em&gt;may&lt;/em&gt; (worst-case) require to complete.</source>
          <target state="translated">Сравнивая их, когда речь идет об &lt;strong&gt;А&lt;/strong&gt; и других алгоритмах, легко ранжировать алгоритмы в соответствии с количеством операций, которые они &lt;em&gt;могут&lt;/em&gt; (в худшем случае) выполнить.</target>
        </trans-unit>
        <trans-unit id="0d58ba7567f14e061427da47056514f59b5370bc" translate="yes" xml:space="preserve">
          <source>By the way, here is for comparison the definition of small o.</source>
          <target state="translated">Кстати,вот для сравнения определение малого О.</target>
        </trans-unit>
        <trans-unit id="cbb489069914d301d52853c36730ee0f0e267708" translate="yes" xml:space="preserve">
          <source>C &amp;rarr; A &amp;rarr; B</source>
          <target state="translated">C &amp;rarr; A &amp;rarr; B</target>
        </trans-unit>
        <trans-unit id="6998b04e08785bbdf1c7af58eecf38c1a28d31da" translate="yes" xml:space="preserve">
          <source>C &amp;rarr; B &amp;rarr; A</source>
          <target state="translated">C &amp;rarr; B &amp;rarr; A</target>
        </trans-unit>
        <trans-unit id="6cbbd09b2268ff81c9d2447ddd6efd0ece964c0a" translate="yes" xml:space="preserve">
          <source>Calculate how much time (regarding input size) the worst case takes:</source>
          <target state="translated">Вычислите,сколько времени (по отношению к размеру входного сигнала)занимает наихудший случай:</target>
        </trans-unit>
        <trans-unit id="12668f37b6831ee2e32bd194cd1af2fa68690568" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;https://www.youtube.com/watch?v=V1xXmQkzkZI&amp;amp;index=13&amp;amp;list=PLZBP-86GmPTxpbvoFFzad0qYw5dKA8MV2&quot;&gt;this&lt;/a&gt; out for a video tutorial on Big O from UC Berkley. It's is actually a simple concept. If you hear professor Shewchuck (aka God level teacher) explaining it, you will say &quot;Oh that's all it is!&quot;.</source>
          <target state="translated">Проверьте &lt;a href=&quot;https://www.youtube.com/watch?v=V1xXmQkzkZI&amp;amp;index=13&amp;amp;list=PLZBP-86GmPTxpbvoFFzad0qYw5dKA8MV2&quot;&gt;это&lt;/a&gt; для видео-учебника по Big O от Калифорнийского университета в Беркли. На самом деле это простая концепция. Если вы услышите, как профессор Шевчук (он же учитель уровня Бога) объясняет это, вы скажете: &amp;laquo;О, вот и все!&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b4523b29b5c7ed6f8c2abc5e9a4c38da02d06afc" translate="yes" xml:space="preserve">
          <source>Come back and reread the above when you've read the rest.</source>
          <target state="translated">Возвращайся и перечитай все вышеперечисленное,когда прочитаешь остальное.</target>
        </trans-unit>
        <trans-unit id="55a7f0d03a20d7e0d958646e51faf45416912637" translate="yes" xml:space="preserve">
          <source>Compare 1 and 6, which is biggest? Ok 6 is in the right position, moving forward!</source>
          <target state="translated">Сравнить 1 и 6,что больше? Ок 6 в правильном положении,двигаемся вперед!</target>
        </trans-unit>
        <trans-unit id="1c5884fcffc252b00f765da994d3959a5bea1cc4" translate="yes" xml:space="preserve">
          <source>Compare 6 and 3, oh, 3 is less! Let's move that, Ok the list changed, we need to start from the begining now!</source>
          <target state="translated">Сравните 6 и 3,о,3 меньше! Давайте передвинем это,Хорошо,список изменился,надо начинать с самого начала!</target>
        </trans-unit>
        <trans-unit id="b5ae65887f49fb01b8aa1e42c87a37e72b0918ca" translate="yes" xml:space="preserve">
          <source>Compare &lt;em&gt;how quickly runtime grows&lt;/em&gt;&lt;strong&gt;NOT&lt;/strong&gt;&lt;em&gt;compare exact runtimes&lt;/em&gt; (depends on hardware)</source>
          <target state="translated">Сравните, &lt;em&gt;насколько быстро растет время выполнения,&lt;/em&gt; &lt;strong&gt;НЕ&lt;/strong&gt; &lt;em&gt;сравнивайте точное время выполнения&lt;/em&gt; (зависит от аппаратного обеспечения).</target>
        </trans-unit>
        <trans-unit id="3d11d48dee34717db426c8a89bfdced368207e28" translate="yes" xml:space="preserve">
          <source>Comparison between average-case and amortized worst-case:</source>
          <target state="translated">Сравнение между среднестатистическим и амортизированным наихудшим случаями:</target>
        </trans-unit>
        <trans-unit id="ad8df7363e12666a15da250cd1535079ed8d98cb" translate="yes" xml:space="preserve">
          <source>Consider the canonical sorting example. Bubble-sort is O(n&lt;sup&gt;2&lt;/sup&gt;) while merge-sort is O(n log n). Let's say you have two sorting applications, application A which uses bubble-sort and application B which uses merge-sort, and let's say that for input sizes of around 30 elements application A is 1,000x faster than application B at sorting. If you never have to sort much more than 30 elements then it's obvious that you should prefer application A, as it is much faster at these input sizes. However, if you find that you may have to sort ten million items then what you'd expect is that application B actually ends up being thousands of times faster than application A in this case, entirely due to the way each algorithm scales.</source>
          <target state="translated">Рассмотрим пример канонической сортировки. Bubble-sort - это O (n &lt;sup&gt;2&lt;/sup&gt; ), а merge-sort - O (n log n). Допустим, у вас есть два приложения сортировки: приложение A, которое использует пузырьковую сортировку, и приложение B, которое использует сортировку слиянием, и предположим, что при входных размерах около 30 элементов приложение A в 1000 раз быстрее, чем приложение B при сортировке. Если вам никогда не придется сортировать более 30 элементов, тогда очевидно, что вы должны предпочесть приложение A, поскольку оно намного быстрее при таких размерах ввода. Однако, если вы обнаружите, что вам, возможно, придется отсортировать десять миллионов элементов, то вы ожидаете, что приложение B на самом деле окажется в тысячи раз быстрее, чем приложение A в этом случае, полностью из-за способа масштабирования каждого алгоритма.</target>
        </trans-unit>
        <trans-unit id="a7c2b8ba88bf46f0dfe0a0ff9f1b26cb00f3ba83" translate="yes" xml:space="preserve">
          <source>Consider the difference between a steam engine and a rocket. They are not merely different varieties of the same thing (as, say, a Prius engine vs. a Lamborghini engine) but they are dramatically different kinds of propulsion systems, at their core. A steam engine may be faster than a toy rocket, but no steam piston engine will be able to achieve the speeds of an orbital launch vehicle. This is because these systems have different scaling characteristics with regards to the relation of fuel required (&quot;resource usage&quot;) to reach a given speed (&quot;input size&quot;).</source>
          <target state="translated">Рассмотрим разницу между паровым двигателем и ракетой.Это не просто разные разновидности одной и той же вещи (как,скажем,двигатель Prius против двигателя Lamborghini),а кардинально разные виды двигательных установок,в их основе.Паровой двигатель может быть быстрее игрушечной ракеты,но ни один паровой поршневой двигатель не сможет достичь скорости орбитальной ракеты-носителя.Это объясняется тем,что эти системы имеют различные масштабные характеристики по отношению к соотношению количества топлива,необходимого (&quot;расход ресурсов&quot;)для достижения заданной скорости (&quot;входной размер&quot;).</target>
        </trans-unit>
        <trans-unit id="6a8cfee71662bf83fd7610d0447480c8f098dc3b" translate="yes" xml:space="preserve">
          <source>Constant factors are negligible</source>
          <target state="translated">Постоянные факторы ничтожно малы</target>
        </trans-unit>
        <trans-unit id="0da1286a9bca7edf66b07ff225ea54f102d5a653" translate="yes" xml:space="preserve">
          <source>Depending on N and X, your algorithm will require some operations, for example in the WORST case it's &lt;code&gt;3(N^2) + log(X)&lt;/code&gt; operations.</source>
          <target state="translated">В зависимости от N и X вашему алгоритму потребуются некоторые операции, например, в худшем случае это &lt;code&gt;3(N^2) + log(X)&lt;/code&gt; операции.</target>
        </trans-unit>
        <trans-unit id="f8e74a3a562ba5774725315dfe1782d1a1275af0" translate="yes" xml:space="preserve">
          <source>Does not scale.  You have no hope of solving any non-trivially sized problem.  Useful for knowing what to avoid, and for experts to find approximate algorithms which are in &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt;.</source>
          <target state="translated">Не масштабируется. У вас нет надежды на решение любой нетривиальной задачи. Полезно для того, чтобы знать, чего следует избегать, и для экспертов, чтобы найти приблизительные алгоритмы, которые находятся в &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; &lt;sup&gt;k&lt;/sup&gt; )&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c81313d6a9457c1a28868d8aaaff914cf1b3213c" translate="yes" xml:space="preserve">
          <source>Does this make a hashtable faster than an array for lookups? Not necessarily. If you've got a very small collection of entries, an array may well be faster &amp;mdash; you may be able to check all the strings in the time that it takes to just calculate the hashcode of the one you're looking at. As the data set grows larger, however, the hashtable will eventually beat the array.</source>
          <target state="translated">Делает ли это хеш-таблицу быстрее, чем массив для поиска? Не обязательно. Если у вас очень небольшая коллекция записей, массив может быть быстрее - вы можете проверить все строки за то время, которое требуется для вычисления хеш-кода той, которую вы просматриваете. Однако по мере увеличения набора данных хеш-таблица в итоге превзойдет массив.</target>
        </trans-unit>
        <trans-unit id="38f6893266ac6c8513618653e41d6736baa03b7c" translate="yes" xml:space="preserve">
          <source>EDIT: Quick note, this is almost certainly confusing &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; (which is an upper bound) with Theta notation (which is both an upper and lower bound). In my experience this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</source>
          <target state="translated">РЕДАКТИРОВАТЬ: Быстрое примечание, это почти наверняка путает &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;нотацию Big O&lt;/a&gt; (которая является верхней границей) с нотацией Theta (которая является верхней и нижней границами). По моему опыту, это на самом деле типично для дискуссий в неакадемических условиях. Извиняюсь за путаницу.</target>
        </trans-unit>
        <trans-unit id="c8861868012e671e5ca7903151be427897869332" translate="yes" xml:space="preserve">
          <source>Each of these is an operation or a problem.  A method of solving these is called an &lt;strong&gt;algorithm&lt;/strong&gt;.</source>
          <target state="translated">Каждый из них является операцией или проблемой. Метод решения этих проблем называется &lt;strong&gt;алгоритмом&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b62541479f03733e3001473267dd14900d0760bc" translate="yes" xml:space="preserve">
          <source>Ergh.  That sounds like a lot of work!</source>
          <target state="translated">Эээ...Похоже,много работы!</target>
        </trans-unit>
        <trans-unit id="b6dc6935629b7d3402db5c466e6d14aa566e6056" translate="yes" xml:space="preserve">
          <source>Estimates how many steps of the method your computer applies to accomplish a task.</source>
          <target state="translated">Оценивает,сколько этапов метод,применяемый вашим компьютером для выполнения задачи.</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">Пример 2:</target>
        </trans-unit>
        <trans-unit id="1d4166bf97179d81c42dccef3ab9d1594a5dec5d" translate="yes" xml:space="preserve">
          <source>Example 3:</source>
          <target state="translated">Пример 3:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="184ce50741de2b5a2d508d5c7f7deb72ee16f548" translate="yes" xml:space="preserve">
          <source>Facilitate the process to compare with others in order to determine whether it's good or not?</source>
          <target state="translated">Облегчить процесс сравнения с другими,чтобы определить,хорошо это или плохо?</target>
        </trans-unit>
        <trans-unit id="8b846e7060b9a483588329ba98d3b24f7db5b0ed" translate="yes" xml:space="preserve">
          <source>For 1,000,000 it takes 20.</source>
          <target state="translated">За 1,000,000 нужно 20.</target>
        </trans-unit>
        <trans-unit id="bfc4a756390564c98c0f9ee2960940b370613e43" translate="yes" xml:space="preserve">
          <source>For 15 it takes 4.</source>
          <target state="translated">На 15 нужно 4.</target>
        </trans-unit>
        <trans-unit id="c4dcc93d74ce33740712a8b30e5dfa1a16cc492d" translate="yes" xml:space="preserve">
          <source>For 7 it takes at most 3.</source>
          <target state="translated">На 7 требуется максимум 3.</target>
        </trans-unit>
        <trans-unit id="8387ae59db1ca9e3e2f91943f6392088dfd4aa1a" translate="yes" xml:space="preserve">
          <source>For a phone book of 3 names it takes 2 comparisons (at most).</source>
          <target state="translated">Для телефонной книги из 3-х наименований требуется 2 сравнения (максимум).</target>
        </trans-unit>
        <trans-unit id="5052922ba19448289d5da9158883ce125e05b963" translate="yes" xml:space="preserve">
          <source>For big n, n squared is more large than n.</source>
          <target state="translated">Для большого n,n в квадрате больше,чем n.</target>
        </trans-unit>
        <trans-unit id="e5054e967dbdba1361ba3fb55414b378a8efdbff" translate="yes" xml:space="preserve">
          <source>For completeness, the precise definition of big-O notation is as follows: &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; means that &quot;f is asymptotically upper-bounded by const*g&quot;: ignoring everything below some finite value of x, there exists a constant such that &lt;code&gt;|f(x)| &amp;le; const * |g(x)|&lt;/code&gt;. (The other symbols are as follows: just like &lt;code&gt;O&lt;/code&gt; means &amp;le;, &lt;code&gt;&amp;Omega;&lt;/code&gt; means &amp;ge;. There are lowercase variants: &lt;code&gt;o&lt;/code&gt; means &amp;lt;, and &lt;code&gt;&amp;omega;&lt;/code&gt; means &amp;gt;.) &lt;code&gt;f(x) &amp;isin; Ɵ(g(x))&lt;/code&gt; means both &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; and &lt;code&gt;f(x) &amp;isin; &amp;Omega;(g(x))&lt;/code&gt; (upper- and lower-bounded by g): there exists some constants such that f will always lie in the &quot;band&quot; between &lt;code&gt;const1*g(x)&lt;/code&gt; and &lt;code&gt;const2*g(x)&lt;/code&gt;. It is the strongest asymptotic statement you can make and roughly equivalent to &lt;code&gt;==&lt;/code&gt;. (Sorry, I elected to delay the mention of the absolute-value symbols until now, for clarity's sake; especially because I have never seen negative values come up in a computer science context.)</source>
          <target state="translated">Для полноты точное определение записи big-O выглядит следующим образом: &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; означает, что &amp;laquo;f асимптотически ограничена сверху const * g&amp;raquo;: игнорируя все, что ниже некоторого конечного значения x существует константа такая, что &lt;code&gt;|f(x)| &amp;le; const * |g(x)|&lt;/code&gt; &amp;le; const * | g (x) | , (Другие символы следующие: точно так же, как &lt;code&gt;O&lt;/code&gt; означает &amp;le;, &lt;code&gt;&amp;Omega;&lt;/code&gt; означает &amp;ge;. Существуют строчные варианты: &lt;code&gt;o&lt;/code&gt; означает &amp;lt;, а &lt;code&gt;&amp;omega;&lt;/code&gt; означает&amp;gt;.) &lt;code&gt;f(x) &amp;isin; Ɵ(g(x))&lt;/code&gt; означает оба &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; и &lt;code&gt;f(x) &amp;isin; &amp;Omega;(g(x))&lt;/code&gt; (ограниченные сверху и снизу g): существуют некоторые постоянные, такие что f всегда будет лежать в &amp;laquo;зоне&amp;raquo; между &lt;code&gt;const1*g(x)&lt;/code&gt; и &lt;code&gt;const2*g(x)&lt;/code&gt; . Это самое сильное асимптотическое утверждение, которое вы можете сделать и примерно эквивалентное &lt;code&gt;==&lt;/code&gt; . (Извините, я решил отложить упоминание символов абсолютного значения до сих пор, для ясности; особенно потому, что я никогда не видел, чтобы отрицательные значения возникали в контексте информатики.)</target>
        </trans-unit>
        <trans-unit id="49654e3774111fb16128651b4d224ad6b75c2b89" translate="yes" xml:space="preserve">
          <source>For example, say you had the latitude and longitude coordinates of millions of road segments and wanted to find all street intersections.</source>
          <target state="translated">Например,скажем,у вас были координаты широты и долготы миллионов участков дороги,и вы хотели найти все перекрестки.</target>
        </trans-unit>
        <trans-unit id="b3611110a9125b6ab52f37ddd431b3585818e9dd" translate="yes" xml:space="preserve">
          <source>For input of size &quot;n&quot; the program is growing at speed of &quot;n&quot; iterations in array. Hence Big-O is N expressed as  O(n)</source>
          <target state="translated">Для ввода размера &quot;n&quot; программа растет со скоростью &quot;n&quot; итераций в массиве.Следовательно,Big-O-это N,выраженный в виде O(n).</target>
        </trans-unit>
        <trans-unit id="09e7373f604bf7164bb0dca1297d67c519bcfba7" translate="yes" xml:space="preserve">
          <source>For input of size &quot;n&quot; the program is growing at speed of &quot;n*n&quot; iterations in array. Hence Big-O is N&lt;sup&gt;2&lt;/sup&gt; expressed as  O(n&lt;sup&gt;2&lt;/sup&gt;)</source>
          <target state="translated">Для ввода размера &amp;laquo;n&amp;raquo; программа растет со скоростью &amp;laquo;n * n&amp;raquo; итераций в массиве. Следовательно, Big-O - это N &lt;sup&gt;2,&lt;/sup&gt; выраженное как O (n &lt;sup&gt;2&lt;/sup&gt; )</target>
        </trans-unit>
        <trans-unit id="8a6ae78506dc4ee34684d9e0638c4281f35c545f" translate="yes" xml:space="preserve">
          <source>For online downloading, the download time is directly proportional to the movie file sizes (input). We call this &lt;strong&gt;O(n)&lt;/strong&gt;.</source>
          <target state="translated">Для онлайн-загрузки время загрузки прямо пропорционально размеру файла фильма (входной). Мы называем это &lt;strong&gt;O (n)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="67cc9e8bfc7b47bffe767706a99579808a311dcc" translate="yes" xml:space="preserve">
          <source>For the handshake example above, everyone in a room shakes everyone else's hand. In that example, &lt;code&gt;#handshakes &amp;isin; Ɵ(N&amp;sup2;)&lt;/code&gt;. Why?</source>
          <target state="translated">Для приведенного выше примера рукопожатия все в комнате пожимают друг другу руки. В этом примере &lt;code&gt;#handshakes &amp;isin; Ɵ(N&amp;sup2;)&lt;/code&gt; . Почему?</target>
        </trans-unit>
        <trans-unit id="c5e2547d0bc6ba3ff90e388af4f7fa819fdfb175" translate="yes" xml:space="preserve">
          <source>Four (and this is the fun part): I have two small decks now, one more low than the splay card, and one more high.  Now I go to step one, on each small deck!  That is to say, I start from step One on the first small deck, and when that work is done, I start from step One on the next small deck.</source>
          <target state="translated">Четыре (и это самое интересное):У меня теперь две маленькие колоды,одна ниже карты сплей,а другая выше.Теперь я иду на шаг один,на каждую маленькую колоду! То есть я начинаю с первого шага на первой маленькой колоде,а когда эта работа закончена,я начинаю с первого шага на следующей маленькой колоде.</target>
        </trans-unit>
        <trans-unit id="4a6b77756dd510894ce0e5f9cee853f3dfb273a0" translate="yes" xml:space="preserve">
          <source>From the experiments, we know that online shopping scales better than online downloading. It is very important to understand big O notation because it helps you to analyze the &lt;strong&gt;scalability&lt;/strong&gt; and &lt;strong&gt;efficiency&lt;/strong&gt; of algorithms.</source>
          <target state="translated">Из экспериментов мы знаем, что онлайн-магазины масштабируются лучше, чем онлайн-загрузка. Очень важно понимать большие обозначения O, потому что это помогает вам анализировать &lt;strong&gt;масштабируемость&lt;/strong&gt; и &lt;strong&gt;эффективность&lt;/strong&gt; алгоритмов.</target>
        </trans-unit>
        <trans-unit id="e19041281d0dd99d852a13a94e9ffca8398dc327" translate="yes" xml:space="preserve">
          <source>Grows as a square, where &lt;em&gt;n&lt;/em&gt; is the length of the side of a square.  This is the same growth rate as the &quot;network effect&quot;, where everyone in a network might know everyone else in the network.  Growth is expensive.  Most scalable solutions cannot use algorithms with this level of complexity without doing significant gymnastics.  This generally applies to all other polynomial complexities - &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; - as well.</source>
          <target state="translated">Растет как квадрат, где &lt;em&gt;n&lt;/em&gt; - длина стороны квадрата. Это такой же темп роста, как и &amp;laquo;сетевой эффект&amp;raquo;, при котором каждый в сети может знать всех остальных в сети. Рост дорогой. Большинство масштабируемых решений не могут использовать алгоритмы с таким уровнем сложности, не выполняя значительную гимнастику. Это обычно относится ко всем другим полиномиальным сложностям - &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; &lt;sup&gt;k&lt;/sup&gt; )&lt;/strong&gt; - также.</target>
        </trans-unit>
        <trans-unit id="36f6624b28e90d7b5439820ddf4b791141546e8a" translate="yes" xml:space="preserve">
          <source>Here comes big O, to tell us just how hard this math is.</source>
          <target state="translated">А вот и Большой О,чтобы сказать нам,как сложна эта математика.</target>
        </trans-unit>
        <trans-unit id="5e58c431d0ce6f70610939ce98c97531f57d61cc" translate="yes" xml:space="preserve">
          <source>Here is another thing we can recognize visually:</source>
          <target state="translated">Вот еще одна вещь,которую мы можем распознать визуально:</target>
        </trans-unit>
        <trans-unit id="4ab646045794b15182529717713fd6393652d11a" translate="yes" xml:space="preserve">
          <source>Here is the Wikipedia article: &lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;https://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;</source>
          <target state="translated">Вот статья в Википедии: &lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;https://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="001cff8786bd37eff234c46bb9b1b48e0988d759" translate="yes" xml:space="preserve">
          <source>Here is the plain English bestiary I tend to use when explaining the common varieties of Big-O</source>
          <target state="translated">Вот простой английский бестиарий,который я обычно использую при объяснении распространенных разновидностей Big-O.</target>
        </trans-unit>
        <trans-unit id="43e41c55f998f736fd0e01106d1006e4f8370dd7" translate="yes" xml:space="preserve">
          <source>Here's an example where we have N T-shirts which we want to dry. We'll &lt;em&gt;assume&lt;/em&gt; it's incredibly quick to get them in the drying position (i.e. the human interaction is negligible). That's not the case in real life, of course...</source>
          <target state="translated">Вот пример, где у нас есть N футболок, которые мы хотим высушить. Мы &lt;em&gt;предположим,&lt;/em&gt; что это невероятно быстро, чтобы получить их в положении сушки (т.е. взаимодействие человека незначительно). Конечно, это не так в реальной жизни ...</target>
        </trans-unit>
        <trans-unit id="c5af9b41639623efa7baf5be1ecd016aee231408" translate="yes" xml:space="preserve">
          <source>Here, the smallest recognizable outline you can draw is what matters; a triangle is a two dimensional shape (0.5 A^2), just like a square is a two-dimensional shape (A^2); the constant factor of two here remains in the asymptotic ratio between the two, however, we ignore it like all factors... (There are some unfortunate nuances to this technique I don't go into here; it can mislead you.)</source>
          <target state="translated">Здесь наименьший узнаваемый контур,который можно нарисовать-это то,что имеет значение;треугольник-это двухмерная форма (0.5 A^2),так же как и квадрат-это двумерная форма (A^2);постоянный фактор два здесь остается в асимптотическом соотношении между ними,однако мы игнорируем его,как и все факторы...(Есть некоторые неудачные нюансы в этой технике,в которую я не вдаюсь;она может ввести вас в заблуждение).</target>
        </trans-unit>
        <trans-unit id="1d2dc7900c252d720e30b05b14c6ffb4be0d882b" translate="yes" xml:space="preserve">
          <source>Hmmm.  There may be a rule in there, I think.  To make big tasks small, break them up.</source>
          <target state="translated">Хммм.Там может быть правило,я думаю.Делать большие задачи маленькими,разбивать их.</target>
        </trans-unit>
        <trans-unit id="9c06c7ddd3fdd4ff139df20d27d2e5e8fe694d25" translate="yes" xml:space="preserve">
          <source>How can we sort this deck?  I have a plan.</source>
          <target state="translated">Как мы можем отсортировать эту палубу? У меня есть план.</target>
        </trans-unit>
        <trans-unit id="b80eb8a9b1ad872be834851527556c78aaff922e" translate="yes" xml:space="preserve">
          <source>How do I know Quick Sort is less work?  I know that O(n log n) is less than O(n squared).  The O's are more small, so Quick Sort is less work!</source>
          <target state="translated">Откуда мне знать,что Quick Sort-это меньше работы? Я знаю,что O(n log n)меньше,чем O(n squared).O's более маленькие,так что Quick Sort-это меньше работы!</target>
        </trans-unit>
        <trans-unit id="ce3005d8e3f4f0dd8dec37227d002f3f7de3b04c" translate="yes" xml:space="preserve">
          <source>How much more hard would it be?  How much more work would I have to do?  Do I need more or less steps?</source>
          <target state="translated">Насколько это будет труднее? Сколько еще работы мне придется сделать? Нужно ли мне делать больше или меньше шагов?</target>
        </trans-unit>
        <trans-unit id="a4daa40555f4cdbc41aa891d89c4fbcc8ad0f51b" translate="yes" xml:space="preserve">
          <source>However, for very large numbers of people, the linear term &lt;code&gt;N&lt;/code&gt; is dwarfed and effectively contributes 0 to the ratio (in the chart: the fraction of empty boxes on the diagonal over total boxes gets smaller as the number of participants becomes larger). Therefore the scaling behavior is &lt;code&gt;order N&amp;sup2;&lt;/code&gt;, or the number of handshakes &quot;grows like N&amp;sup2;&quot;.</source>
          <target state="translated">Тем не менее, для очень большого числа людей линейный член &lt;code&gt;N&lt;/code&gt; является карликовым и эффективно добавляет 0 к отношению (на диаграмме: доля пустых блоков по диагонали по отношению к общему количеству блоков уменьшается по мере увеличения числа участников). Таким образом, масштабирование &lt;code&gt;order N&amp;sup2;&lt;/code&gt; , или количество рукопожатий &quot;растет как N&amp;sup2;&quot;.</target>
        </trans-unit>
        <trans-unit id="9f6b7a8c3e101e7571405d26663a1a4d8aefb762" translate="yes" xml:space="preserve">
          <source>I break up the deck in parts, and sort each part, more small and more small, and at some time I have no more work to do.  Now this may seem slow, with all the rules.  But trust me, it is not slow at all.  It is much less work than the first way to sort things!</source>
          <target state="translated">Я разбиваю палубу на части и сортирую каждую часть,более мелкую и более мелкую,и в какой-то момент мне больше нечем заняться.Теперь это может показаться медленным,со всеми правилами.Но поверьте,это совсем не медленно.Это гораздо меньше работы,чем первый способ сортировки!</target>
        </trans-unit>
        <trans-unit id="819fcf72178711a5bc5e8d2f9d5dd724ea8d6e5e" translate="yes" xml:space="preserve">
          <source>I care lots for big O.  Why?  I do not like to work!  No one likes to work.  That is why we all love big O!  He tells us how fast we can work.  He helps us think of how hard work is.</source>
          <target state="translated">Я забочусь о большом &quot;О&quot;.Почему? Я не люблю работать! Никто не любит работать.Вот почему мы все любим большую О! Он говорит нам,как быстро мы можем работать.Он помогает нам думать о том,как тяжело работать.</target>
        </trans-unit>
        <trans-unit id="482a49f03db93f2d8f5d5daa020b481189471c57" translate="yes" xml:space="preserve">
          <source>I do not like to go to work.  I do not like to spend time at work.  If I had my way, I would like just to play, and do fun things.  Do you feel the same as I do?</source>
          <target state="translated">Я не люблю ходить на работу.Не люблю проводить время на работе.Если бы у меня был свой путь,я бы хотел просто играть и делать веселые вещи.Ты чувствуешь то же,что и я?</target>
        </trans-unit>
        <trans-unit id="ad52c5fb30262f15e8d3a80bd1081996754096a0" translate="yes" xml:space="preserve">
          <source>I do not want to add right now.  I just want to think on how hard it might be to add that much.  And, I hope, to play as soon as I can.</source>
          <target state="translated">Я не хочу сейчас добавлять.Я просто хочу подумать о том,как трудно будет добавить столько.И,надеюсь,играть,как только смогу.</target>
        </trans-unit>
        <trans-unit id="a8b731da95dde2cc32a2a652b9321f54f34bd44a" translate="yes" xml:space="preserve">
          <source>I found a really great explanation about big O notation especially for a someone who's not much into mathematics.</source>
          <target state="translated">Я нашел отличное объяснение большой нотации О,особенно для того,кто не очень увлекается математикой.</target>
        </trans-unit>
        <trans-unit id="dab9c64b9a46ec0457c94246c45926dfd570f6b3" translate="yes" xml:space="preserve">
          <source>I have a deck of cards.  I did sort them.  You helped.  Thanks.</source>
          <target state="translated">У меня есть колода карт.Я их сортировал.Ты помог.Спасибо.</target>
        </trans-unit>
        <trans-unit id="3f1e4073256cafed9c07f32d545cc56213aba0e9" translate="yes" xml:space="preserve">
          <source>I have ten cards.  And, most of the time -- that is, if I don&amp;rsquo;t have lots of luck -- I must go through the whole deck up to ten times, with up to ten card swaps each time through the deck.</source>
          <target state="translated">У меня есть десять карт. И большую часть времени - то есть, если мне не везет - я должен пройти всю колоду до десяти раз, с помощью до десяти обменов карт каждый раз через колоду.</target>
        </trans-unit>
        <trans-unit id="0ec03029a11a10972a0136154949cfcba5dbed69" translate="yes" xml:space="preserve">
          <source>I hope this is as simple as you want it.</source>
          <target state="translated">Надеюсь,это так просто,как ты хочешь.</target>
        </trans-unit>
        <trans-unit id="53ae10c16d270153bdbf8c1a9e6f93c880d6182f" translate="yes" xml:space="preserve">
          <source>I will look at each pair of cards, pair by pair, through the deck, from first to last.  If the first card in one pair is big and the next card in that pair is small, I swap them.  Else, I go to the next pair, and so on and so on... and soon, the deck is done.</source>
          <target state="translated">Я буду смотреть на каждую пару карт,пару за парой,через колоду,от первого до последнего.Если первая карта в одной паре большая,а следующая в этой паре маленькая,я поменяю их.Иначе,я иду к следующей паре,и так далее,и так далее...и вскоре колода закончена.</target>
        </trans-unit>
        <trans-unit id="b9d44117c5235dda1f72fad7eec883c624ba20a4" translate="yes" xml:space="preserve">
          <source>I'd prefer as little formal definition as possible and simple mathematics.</source>
          <target state="translated">Я бы предпочел как можно меньше формальных определений и простую математику.</target>
        </trans-unit>
        <trans-unit id="f6bbf69b7602636fdd09cc6e847b5d115ba9d058" translate="yes" xml:space="preserve">
          <source>I've more simpler way to understand the time complexity
he most common metric for calculating time complexity is Big O notation. This removes all constant factors so that the running time can be estimated in relation to N as N approaches infinity. In general you can think of it like this:</source>
          <target state="translated">У меня есть более простой способ понять временную сложность,которую он чаще всего использует для вычисления временной сложности-это нотация Big O.Это устраняет все постоянные факторы,так что время выполнения можно оценить по отношению к N по мере приближения N к бесконечности.В общем,об этом можно думать следующим образом:</target>
        </trans-unit>
        <trans-unit id="3c93039db5b8dea862d7aba7ac7a736523f2e466" translate="yes" xml:space="preserve">
          <source>If an algorithm is O(n) then the time/space will increase at the same rate as its input.</source>
          <target state="translated">Если алгоритм O(n),то временное пространство будет увеличиваться с той же скоростью,что и его вход.</target>
        </trans-unit>
        <trans-unit id="b93496435ccac02920ca75abbec4e210c6e1376f" translate="yes" xml:space="preserve">
          <source>If an algorithm is O(n&lt;sup&gt;2&lt;/sup&gt;) then the time/space increase at the rate of its input squared.</source>
          <target state="translated">Если алгоритм равен O (n &lt;sup&gt;2&lt;/sup&gt; ), тогда время / пространство увеличиваются со скоростью его входного квадрата.</target>
        </trans-unit>
        <trans-unit id="42bcc6138049b638ae7478e9aaa755e8a5fae576" translate="yes" xml:space="preserve">
          <source>If some values are effectively bounded due to some hidden fact (e.g. the average human name is softly bounded at perhaps 40 letters, and human age is softly bounded at around 150). You can also impose bounds on your input to effectively make terms constant.</source>
          <target state="translated">Если некоторые ценности фактически ограничены из-за какого-то скрытого факта (например,среднее имя человека мягко ограничено примерно 40 буквами,а возраст человека мягко ограничен примерно 150 годами).Вы также можете наложить ограничения на входные данные,чтобы эффективно сделать термины постоянными.</target>
        </trans-unit>
        <trans-unit id="eadacee139f919b0ca67cb2be538cca322087b44" translate="yes" xml:space="preserve">
          <source>If the above doesn't make sense, then you don't have a compatible intuitive notion of infinity in your head, and you should probably disregard all of the above; the only way I know to make these ideas rigorous, or to explain them if they aren't already intuitively useful, is to first teach you big O notation or something similar. (although, once you well understand big O notation in the future, it may be worthwhile to revisit these ideas)</source>
          <target state="translated">Если вышеизложенное не имеет смысла,то у вас нет совместимого интуитивного представления о бесконечности в вашей голове,и вы,вероятно,должны пренебречь всем вышеизложенным;единственный способ,который я знаю,чтобы сделать эти идеи строгими,или объяснить их,если они еще не интуитивно полезны,-это сначала научить вас большой нотации О или чему-то подобному.(хотя,как только вы хорошо поймете большую нотацию О в будущем,возможно,стоит вернуться к этим идеям).</target>
        </trans-unit>
        <trans-unit id="fc0f303936e49cce64dec3515e323c65eb23edc5" translate="yes" xml:space="preserve">
          <source>If the loop has finished without finding the key, return False.</source>
          <target state="translated">Если цикл завершился без нахождения ключа,верните False.</target>
        </trans-unit>
        <trans-unit id="1f90ef8cce8695b2d4c7c46d902314ff3d88ced2" translate="yes" xml:space="preserve">
          <source>If we do something slightly complicated, you might still be able to imagine visually what's going on:</source>
          <target state="translated">Если мы сделаем что-нибудь немного сложное,вы все равно сможете визуально представить,что происходит:</target>
        </trans-unit>
        <trans-unit id="498ad5ebf90abce6c7640e5178604bd12d2cb5dd" translate="yes" xml:space="preserve">
          <source>If we do something very complicated, such as with a recursive function or divide-and-conquer algorithm, &lt;strike&gt;you can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem&quot;&gt;Master Theorem&lt;/a&gt; (usually works), or in ridiculous cases the Akra-Bazzi Theorem (almost always works)&lt;/strike&gt; you look up the running time of your algorithm on Wikipedia.</source>
          <target state="translated">Если мы делаем что-то очень сложное, например, с помощью рекурсивной функции или алгоритма &amp;laquo;разделяй и властвуй&amp;raquo;, &lt;strike&gt;вы можете использовать &lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem&quot;&gt;основную теорему&lt;/a&gt; (обычно работает) или, в смешных случаях, теорему Акра-Бацци (почти всегда работает),&lt;/strike&gt; вы ищите время выполнения вашего алгоритма в Википедии.</target>
        </trans-unit>
        <trans-unit id="f340d38ad5275f65c3f3c98f00a52fd253da01b5" translate="yes" xml:space="preserve">
          <source>If we have two 100-digit numbers we need to do 10,000 multiplications and 200 adds.  For two one million digit numbers we need to do one trillion (10&lt;sup&gt;12&lt;/sup&gt;) multiplications and two million adds.</source>
          <target state="translated">Если у нас есть два 100-значных числа, нам нужно сделать 10 000 умножений и 200 сложений. Для двух миллионных чисел нам нужно сделать триллион (10 &lt;sup&gt;12&lt;/sup&gt; ) умножений и два миллиона сложений.</target>
        </trans-unit>
        <trans-unit id="7a7797f63ba1469547a1c7c05a0e4651c75d6f7f" translate="yes" xml:space="preserve">
          <source>If we use a simple structure called a hash table (an instant-speed lookup table, also known as a hashmap or dictionary), we pay a small cost by preprocessing everything in &lt;code&gt;O(N)&lt;/code&gt; time. Thereafter, it only takes constant time on average to look up something by its key (in this case, our key is the latitude and longitude coordinates, rounded into a grid; we search the adjacent gridspaces of which there are only 9, which is a constant).</source>
          <target state="translated">Если мы используем простую структуру, называемую хеш-таблицей (справочная таблица с мгновенной скоростью, также известная как хэш-карта или словарь), мы платим небольшую цену, предварительно обрабатывая все за &lt;code&gt;O(N)&lt;/code&gt; . После этого в среднем требуется только постоянное время, чтобы найти что-то по его ключу (в этом случае наш ключ - это координаты широты и долготы, округленные в сетку; мы ищем соседние сеточные пространства, которых всего 9, что является константа).</target>
        </trans-unit>
        <trans-unit id="532d60c07f8308239c74d78cfd8bd61382460fae" translate="yes" xml:space="preserve">
          <source>If you have 3 towns A, B and C with roads between all pairs then you could go:</source>
          <target state="translated">Если у вас есть 3 города A,B и C с дорогами между всеми парами,то вы можете ехать:</target>
        </trans-unit>
        <trans-unit id="85e55a9c0f7521ee220edb5e820f851626c00f8e" translate="yes" xml:space="preserve">
          <source>If you have a suitable notion of infinity in your head, then there is a very brief description:</source>
          <target state="translated">Если у вас есть подходящее понятие бесконечности в голове,то есть очень краткое описание:</target>
        </trans-unit>
        <trans-unit id="a391595810bc224de5ec62db4d75a23a1dd6b419" translate="yes" xml:space="preserve">
          <source>If you have to sort a deck, what is the best way?  Well, you can do what you want, but I would choose Quick Sort.</source>
          <target state="translated">Если тебе нужно отсортировать колоду,какой способ лучше? Ну,ты можешь делать,что хочешь,но я бы выбрал &quot;Быструю сортировку&quot;.</target>
        </trans-unit>
        <trans-unit id="c8f0c3e48ae6bc0a6ae30c3840b7e3d5da5a2114" translate="yes" xml:space="preserve">
          <source>If you only needed to do this once, it would not be a problem to have to do the naive method of &lt;code&gt;O(N)&lt;/code&gt; work only once, but if you want to do it many times (in this case, &lt;code&gt;N&lt;/code&gt; times, once for each segment), we'd have to do &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; work, or 1000000&amp;sup2;=1000000000000 operations. Not good (a modern computer can perform about a billion operations per second).</source>
          <target state="translated">Если вам нужно было сделать это только один раз, не было бы проблемой, если бы наивный метод &lt;code&gt;O(N)&lt;/code&gt; работал только один раз, но если вы хотите сделать это много раз (в данном случае, &lt;code&gt;N&lt;/code&gt; раз, один раз для каждый сегмент), мы должны были бы выполнить работу &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; или 1000000&amp;sup2; = 1000000000000 операций. Не хорошо (современный компьютер может выполнять около миллиарда операций в секунду).</target>
        </trans-unit>
        <trans-unit id="b0ce2012a9d7c727364cedfce54d754ac83295bd" translate="yes" xml:space="preserve">
          <source>If you read the &quot;Oh&quot; as meaning &quot;on the order of&quot; or &quot;approximately&quot; you will not go too far wrong. (I think the choice of the Big-Oh might have been an attempt at humour).</source>
          <target state="translated">Если вы прочитаете &quot;О&quot; как &quot;по порядку&quot; или &quot;приблизительно&quot;,вы не зайдёте слишком далеко.(Я думаю,что выбор &quot;Большого О&quot; мог быть попыткой юмора).</target>
        </trans-unit>
        <trans-unit id="879d10b4ee33a790e641d1a246a7c4921f058217" translate="yes" xml:space="preserve">
          <source>If you upgrade to a computer that can run your algorithm twice as fast, big O notation won't notice that. Constant factor improvements are too small to even be noticed in the scale that big O notation works with. Note that this is an intentional part of the design of big O notation.</source>
          <target state="translated">Если вы перейдете на компьютер,который может работать с вашим алгоритмом в два раза быстрее,большая нотация O не заметит этого.Постоянные улучшения факторов слишком малы,чтобы их можно было заметить даже в том масштабе,с которым работает большая нотация O.Обратите внимание,что это преднамеренная часть дизайна большой нотации O.</target>
        </trans-unit>
        <trans-unit id="4ca1f62a00fa89bcd7628fd712226caf431517e2" translate="yes" xml:space="preserve">
          <source>If you're sorting something like 5 elements, you don't want to use the speedy &lt;code&gt;O(N log(N))&lt;/code&gt; quicksort; you want to use insertion sort, which happens to perform well on small inputs. These situations often come up in divide-and-conquer algorithms, where you split up the problem into smaller and smaller subproblems, such as recursive sorting, fast Fourier transforms, or matrix multiplication.</source>
          <target state="translated">Если вы сортируете что-то вроде 5 элементов, вы не хотите использовать быструю &lt;code&gt;O(N log(N))&lt;/code&gt; быструю сортировку; Вы хотите использовать сортировку вставкой, которая хорошо работает на небольших входах. Эти ситуации часто встречаются в алгоритмах &amp;laquo;разделяй и властвуй&amp;raquo;, где вы разбиваете задачу на все более мелкие подзадачи, такие как рекурсивная сортировка, быстрые преобразования Фурье или умножение матриц.</target>
        </trans-unit>
        <trans-unit id="b1d27a710e5b2deff8083ff199e610d9f97f11b2" translate="yes" xml:space="preserve">
          <source>In Big-O terms this is &lt;strong&gt;O(log n)&lt;/strong&gt; or &lt;strong&gt;logarithmic complexity&lt;/strong&gt;.  Now the logarithm in question could be ln (base e), log&lt;sub&gt;10&lt;/sub&gt;, log&lt;sub&gt;2&lt;/sub&gt; or some other base.  It doesn't matter it's still O(log n) just like O(2n&lt;sup&gt;2&lt;/sup&gt;) and O(100n&lt;sup&gt;2&lt;/sup&gt;) are still both O(n&lt;sup&gt;2&lt;/sup&gt;).</source>
          <target state="translated">В терминах Big-O это &lt;strong&gt;O (log n)&lt;/strong&gt; или &lt;strong&gt;логарифмическая сложность&lt;/strong&gt; . Теперь рассматриваемый логарифм может быть ln (база e), log &lt;sub&gt;10&lt;/sub&gt; , log &lt;sub&gt;2&lt;/sub&gt; или какая-то другая база. Неважно, что это все еще O (log n), точно так же, как O (2n &lt;sup&gt;2&lt;/sup&gt; ) и O (100n &lt;sup&gt;2&lt;/sup&gt; ) все еще оба O (n &lt;sup&gt;2&lt;/sup&gt; ).</target>
        </trans-unit>
        <trans-unit id="88e50d90d1750553c39e16c7f8930e4119cfca57" translate="yes" xml:space="preserve">
          <source>In CS, the set of steps to accomplish a task is called algorithms.</source>
          <target state="translated">В CS набор шагов для выполнения задачи называется алгоритмами.</target>
        </trans-unit>
        <trans-unit id="d95044d68f300f358a3a51cf89c9474f6f16e349" translate="yes" xml:space="preserve">
          <source>In Terminology, Big O notation is used to describe the performance or complexity of an algorithm.</source>
          <target state="translated">В терминологии нотация Big O используется для описания производительности или сложности алгоритма.</target>
        </trans-unit>
        <trans-unit id="d65e5f9e362ebe36bedba5b57e018e3acbfc0c7b" translate="yes" xml:space="preserve">
          <source>In actuality there are 3 possibilities.</source>
          <target state="translated">На самом деле существует 3 возможности.</target>
        </trans-unit>
        <trans-unit id="07046d757b1f2b48e849414a4e96d5ff13dade7a" translate="yes" xml:space="preserve">
          <source>In addition, Big O establishes the worst-case or measure the Upper-Bound steps.</source>
          <target state="translated">Кроме того,Большой О устанавливает наихудший случай или измеряет верхние ступени.</target>
        </trans-unit>
        <trans-unit id="baa93a55b3140739514a5c40f8e2cdd9810a3c85" translate="yes" xml:space="preserve">
          <source>In all cases, prefer algorithms higher up on the list to those lower on the list.  However, the cost of moving to a more expensive complexity class varies significantly.</source>
          <target state="translated">Во всех случаях предпочитайте алгоритмы выше в списке,чем ниже в списке.Однако стоимость перехода на более дорогой класс сложности существенно варьируется.</target>
        </trans-unit>
        <trans-unit id="30b960998b211299ef1c91dabf4d8dd22d39e434" translate="yes" xml:space="preserve">
          <source>In big O notation this is written as</source>
          <target state="translated">В большой нотации О это написано как</target>
        </trans-unit>
        <trans-unit id="64aaef6ec6705e0f6426bbcc5b5fde04c862b7d5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;O(...)&lt;/code&gt; is the most useful one because we often care about worst-case behavior. If &lt;code&gt;f(x)&lt;/code&gt; represents something &quot;bad&quot; like the processor or memory usage, then &quot;&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt;&quot; means &quot;&lt;code&gt;upperbound&lt;/code&gt; is the worst-case scenario of processor/memory usage&quot;.</source>
          <target state="translated">В общем, &lt;code&gt;O(...)&lt;/code&gt; является наиболее полезным, потому что мы часто заботимся о поведении в худшем случае. Если &lt;code&gt;f(x)&lt;/code&gt; представляет что-то &amp;laquo;плохое&amp;raquo;, такое как использование процессора или памяти, то &amp;laquo; &lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; &amp;raquo; означает &amp;laquo; &lt;code&gt;upperbound&lt;/code&gt; - наихудший сценарий использования процессора / памяти&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e9fddaf6556848124995ffd1ed9ddc0b950170ab" translate="yes" xml:space="preserve">
          <source>In general, doing something with every item in one dimension is linear, doing something with every item in two dimensions is quadratic, and dividing the working area in half is logarithmic. There are other Big O measures such as cubic, exponential, and square root, but they're not nearly as common. Big O notation is described as O (  ) where  is the measure. The quicksort algorithm would be described as O ( N * log ( N ) ).</source>
          <target state="translated">В общем,делать что-то с каждым элементом в одном измерении линейно,делать что-то с каждым элементом в двух измерениях-квадратично,а делить рабочую область пополам логарифмически.Существуют и другие измерения Большой О,такие как кубический,экспоненциальный и квадратный корень,но они не так распространены.Нотация Большого О описывается как О(),где находится мера.Алгоритм quicksort будет описан как O(N*log(N)).</target>
        </trans-unit>
        <trans-unit id="63a8eaf6bf07c1752a4bb48aa0c8cfc63edc138d" translate="yes" xml:space="preserve">
          <source>In general, our goal will be to find or structure an algorithm &lt;strong&gt;A&lt;/strong&gt; in such a way that it will have a function &lt;code&gt;X(n)&lt;/code&gt; that returns as low a number as possible.</source>
          <target state="translated">В целом, нашей целью будет найти или структурировать алгоритм &lt;strong&gt;A&lt;/strong&gt; таким образом, чтобы он имел функцию &lt;code&gt;X(n)&lt;/code&gt; которая возвращает как можно меньшее число.</target>
        </trans-unit>
        <trans-unit id="7de7cd6bc8a2b03ecb0a68fecd7a6051d0934bd9" translate="yes" xml:space="preserve">
          <source>In many cases the &quot;O&quot; of an algorithm will fall into one of the following cases:</source>
          <target state="translated">Во многих случаях &quot;О&quot; алгоритма попадает в один из следующих случаев:</target>
        </trans-unit>
        <trans-unit id="a763bcaebb1bc5faa9ba3036763e8474d16f2b73" translate="yes" xml:space="preserve">
          <source>In one sentence: As the size of your job goes up, how much longer does it take to complete it?</source>
          <target state="translated">В одном предложении:По мере того,как размер вашей работы увеличивается,сколько времени занимает ее выполнение?</target>
        </trans-unit>
        <trans-unit id="4bfe8a12e0a2be2aee41e7617d2857524d177ee2" translate="yes" xml:space="preserve">
          <source>In other words where g(n) is the running time of your algorithm, we say that g(n) = O(f(n)) when g(n) &amp;lt;= c*f(n) when n &amp;gt; k, where c and k are some constants.</source>
          <target state="translated">Другими словами, где g (n) - время выполнения вашего алгоритма, мы говорим, что g (n) = O (f (n)), когда g (n) &amp;lt;= c * f (n), когда n&amp;gt; k, где с и к некоторые константы.</target>
        </trans-unit>
        <trans-unit id="4e02f4f6e256066f1d4123d571431ca1ed48ec48" translate="yes" xml:space="preserve">
          <source>In other words, in plain English: &lt;em&gt;f&lt;/em&gt;(x) = O(&lt;em&gt;g&lt;/em&gt;(x)), x &amp;rarr; a, means that in a neighborhood of a, &lt;em&gt;f&lt;/em&gt; decomposes into the product of &lt;em&gt;g&lt;/em&gt; and some bounded function.</source>
          <target state="translated">Другими словами, в простом английском языке: &lt;em&gt;f&lt;/em&gt; (x) = O ( &lt;em&gt;g&lt;/em&gt; (x)), x &amp;rarr; a, означает, что в окрестности a &lt;em&gt;f&lt;/em&gt; разлагается в произведение &lt;em&gt;g&lt;/em&gt; и некоторую ограниченную функцию.</target>
        </trans-unit>
        <trans-unit id="68079fad5ce0cb40c968faed5e24541715996023" translate="yes" xml:space="preserve">
          <source>In practice, even among algorithms which have the same or similar asymptotic performance, their relative merit may actually be driven by other things, such as: other performance factors (quicksort and mergesort are both &lt;code&gt;O(N log(N))&lt;/code&gt;, but quicksort takes advantage of CPU caches); non-performance considerations, like ease of implementation; whether a library is available, and how reputable and maintained the library is.</source>
          <target state="translated">На практике, даже среди алгоритмов, которые имеют одинаковую или сходную асимптотическую производительность, их относительные достоинства могут фактически зависеть от других факторов, таких как: другие факторы производительности (и быстрая сортировка, и слияние - это &lt;code&gt;O(N log(N))&lt;/code&gt; , но быстрая сортировка требует преимущество процессорных кешей); соображения неэффективности, такие как простота реализации; доступна ли библиотека, и насколько авторитетна и поддерживается библиотека.</target>
        </trans-unit>
        <trans-unit id="84ff32c19c195c6e0453458a4af8916d40d60004" translate="yes" xml:space="preserve">
          <source>In this new way to sort a deck, we do not check pairs of cards the way we did a while ago.  Here are your new rules to sort this deck:</source>
          <target state="translated">В этом новом способе сортировки колоды мы не проверяем пары карт так,как это делали некоторое время назад.Вот ваши новые правила сортировки колоды:</target>
        </trans-unit>
        <trans-unit id="c9da7190c61b8b40d9ee9d7282639dd113f829a6" translate="yes" xml:space="preserve">
          <source>Is N * log ( N ). The running time consists of N loops (iterative or recursive) that are logarithmic, thus the algorithm is a combination of linear and logarithmic.</source>
          <target state="translated">Это N*журнал (N).Время выполнения состоит из N циклов (итерационных или рекурсивных),которые являются логарифмическими,поэтому алгоритм представляет собой комбинацию линейного и логарифмического.</target>
        </trans-unit>
        <trans-unit id="998b8dec061b127d4bd37309e498d87df1954ca7" translate="yes" xml:space="preserve">
          <source>Is constant. The running time of the statement will not change in relation to N</source>
          <target state="translated">постоянная.Время выполнения заявления не изменится по отношению к N</target>
        </trans-unit>
        <trans-unit id="7c262ad477a4821f4fb1c7733312befe0c8fe05a" translate="yes" xml:space="preserve">
          <source>Is it more or less fast than the first sort?  Big O, please help!</source>
          <target state="translated">Он более или менее быстрый,чем первый сорт? Большой О,пожалуйста,помогите!</target>
        </trans-unit>
        <trans-unit id="29e49e4fc142b2d0f2b1a400df6ab96e4a918158" translate="yes" xml:space="preserve">
          <source>Is linear. The running time of the loop is directly proportional to N. When N doubles, so does the running time.</source>
          <target state="translated">Линейный.Время работы петли прямо пропорционально N.Когда N удваивается,то и время работы тоже.</target>
        </trans-unit>
        <trans-unit id="0669d4a8187abfada364d0bb775de3933241efd7" translate="yes" xml:space="preserve">
          <source>Is logarithmic. The running time of the algorithm is proportional to the number of times N can be divided by 2. This is because the algorithm divides the working area in half with each iteration.</source>
          <target state="translated">логарифмический.Время работы алгоритма пропорционально количеству раз,которое N можно разделить на 2.Это связано с тем,что при каждой итерации алгоритм делит рабочую область пополам.</target>
        </trans-unit>
        <trans-unit id="f9cef10a1858aa5a865ebf26c425725395a40d0a" translate="yes" xml:space="preserve">
          <source>Is quadratic. The running time of the two loops is proportional to the square of N. When N doubles, the running time increases by N * N.</source>
          <target state="translated">Это квадратично.Время выполнения двух циклов пропорционально квадрату N.Когда N удваивается,время выполнения увеличивается на N*N.</target>
        </trans-unit>
        <trans-unit id="1189cb04bbafbceb75864abdc92eb47236ec61c3" translate="yes" xml:space="preserve">
          <source>Is there a more fast way to sort the cards?  Can big O help us?</source>
          <target state="translated">Есть ли более быстрый способ сортировать карты? Большая О может нам помочь?</target>
        </trans-unit>
        <trans-unit id="bdcb0de02955e320abf0c31ab2a8744682cbbe08" translate="yes" xml:space="preserve">
          <source>It is very difficult to measure the speed of software programs, and when we try, the answers can be very complex and filled with exceptions and special cases. This is a big problem, because all those exceptions and special cases are distracting and unhelpful when we want to compare two different programs with one another to find out which is &quot;fastest&quot;.</source>
          <target state="translated">Очень трудно измерить скорость работы программ,и когда мы пытаемся,ответы могут быть очень сложными и наполненными исключениями и особыми случаями.Это большая проблема,потому что все эти исключения и особые случаи отвлекают и бесполезны,когда мы хотим сравнить две разные программы друг с другом,чтобы выяснить,какая из них &quot;самая быстрая&quot;.</target>
        </trans-unit>
        <trans-unit id="52df2acf675e9663e6643a99463b7ca8b662796f" translate="yes" xml:space="preserve">
          <source>It shows how an algorithm scales based on input size.</source>
          <target state="translated">Он показывает,как алгоритм масштабируется в зависимости от входного размера.</target>
        </trans-unit>
        <trans-unit id="293ad219691b62a126a8db817cbbea70a32b0c5f" translate="yes" xml:space="preserve">
          <source>It's as if the empty boxes on the diagonal of the chart (N*(N-1)/2 checkmarks) weren't even there (N&lt;sup&gt;2&lt;/sup&gt; checkmarks asymptotically).</source>
          <target state="translated">Это как если бы пустых полей на диагонали диаграммы (N * (N-1) / 2 галочки) даже не было (асимптотически N &lt;sup&gt;2&lt;/sup&gt; галочки).</target>
        </trans-unit>
        <trans-unit id="ec70bfe19e1f4d33f015bf1ed0c0eb3f05117561" translate="yes" xml:space="preserve">
          <source>It's worthwhile at this point to explain that Big O can be used to determine three cases with an algorithm:</source>
          <target state="translated">На данном этапе стоит объяснить,что Большой О может быть использован для определения трех случаев с помощью алгоритма:</target>
        </trans-unit>
        <trans-unit id="29cba760a7e3ba133866ed85852ba33956337368" translate="yes" xml:space="preserve">
          <source>Iterating on each item in the list, if it's the key then return True,</source>
          <target state="translated">Итерация по каждому пункту в списке,если это ключ,то верните True,</target>
        </trans-unit>
        <trans-unit id="53da104c94a561d37e7b0bbeefcf47818dc3f2be" translate="yes" xml:space="preserve">
          <source>Keep in mind that big-O is not the whole story. You can drastically speed up some algorithms by using caching, making them cache-oblivious, avoiding bottlenecks by working with RAM instead of disk, using parallelization, or doing work ahead of time -- these techniques are often &lt;em&gt;independent&lt;/em&gt; of the order-of-growth &quot;big-O&quot; notation, though you will often see the number of cores in the big-O notation of parallel algorithms.</source>
          <target state="translated">Имейте в виду, что big-O - это еще не все. Вы можете значительно ускорить некоторые алгоритмы, используя кеширование, делая их не обращающими внимания на кеш, избегая узких мест, работая с оперативной памятью вместо диска, используя распараллеливание или опережая работу - эти методы часто не &lt;em&gt;зависят&lt;/em&gt; от порядка роста нотация big-O, хотя вы часто будете видеть количество ядер в нотации big-O параллельных алгоритмов.</target>
        </trans-unit>
        <trans-unit id="bc8c7b0e9f3998b53c3c3a45f086e6279211fb80" translate="yes" xml:space="preserve">
          <source>Let's assume that the addition of these numbers is the most expensive operation in this algorithm. It stands to reason that to add these two numbers together we have to add together 6 digits (and possibly carry a 7th). If we add two 100 digit numbers together we have to do 100 additions.  If we add &lt;strong&gt;two&lt;/strong&gt; 10,000 digit numbers we have to do 10,000 additions.</source>
          <target state="translated">Давайте предположим, что сложение этих чисел является самой дорогой операцией в этом алгоритме. Само собой разумеется, что для сложения этих двух чисел мы должны сложить вместе 6 цифр (и, возможно, 7). Если мы добавим два 100-значных числа вместе, мы должны сделать 100 добавлений. Если мы добавим &lt;strong&gt;два&lt;/strong&gt; числа из 10 000 цифр, мы должны сделать 10 000 дополнений.</target>
        </trans-unit>
        <trans-unit id="0e3d7a37946e8fa9bb0f4b9c5caa0b1e6214f02f" translate="yes" xml:space="preserve">
          <source>Let's say your algorithm dealing with the problem depends on some 'factors', for example let's make it N and X.</source>
          <target state="translated">Допустим,Ваш алгоритм решения проблемы зависит от некоторых &quot;факторов&quot;,например,давайте сделаем его N и X.</target>
        </trans-unit>
        <trans-unit id="e09ce0464689a88f3f8747581ffb2d480edd57b6" translate="yes" xml:space="preserve">
          <source>Logarithms</source>
          <target state="translated">Logarithms</target>
        </trans-unit>
        <trans-unit id="0f768f66724b1ab90c8b65c4b90be682a8ff30a2" translate="yes" xml:space="preserve">
          <source>Logarithms are slightly trickier to explain so I'll use a common
  example:</source>
          <target state="translated">Логарифмы немного сложнее объяснить,поэтому я использую общий пример:</target>
        </trans-unit>
        <trans-unit id="818cd71ba05516b0c7d38db784302c45d9d62431" translate="yes" xml:space="preserve">
          <source>More precisely &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; is used to express the asymptotic behavior of a function. That means how the function behaves as it approaches infinity.</source>
          <target state="translated">Точнее, &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;обозначение Big O&lt;/a&gt; используется для выражения асимптотического поведения функции. Это означает, как функция ведет себя, приближаясь к бесконечности.</target>
        </trans-unit>
        <trans-unit id="53558434954a9542c40a6931db4c48fcfc391a05" translate="yes" xml:space="preserve">
          <source>Most of the time, people don't realize that there's more than one variable at work. For example, in a string-search algorithm, your algorithm may take time &lt;code&gt;O([length of text] + [length of query])&lt;/code&gt;, i.e. it is linear in two variables like &lt;code&gt;O(N+M)&lt;/code&gt;. Other more naive algorithms may be &lt;code&gt;O([length of text]*[length of query])&lt;/code&gt; or &lt;code&gt;O(N*M)&lt;/code&gt;. Ignoring multiple variables is one of the most common oversights I see in algorithm analysis, and can handicap you when designing an algorithm.</source>
          <target state="translated">В большинстве случаев люди не понимают, что на работе более одной переменной. Например, в алгоритме поиска строк ваш алгоритм может занять время &lt;code&gt;O([length of text] + [length of query])&lt;/code&gt; , то есть он является линейным по двум переменным, таким как &lt;code&gt;O(N+M)&lt;/code&gt; . Другими более наивными алгоритмами могут быть &lt;code&gt;O([length of text]*[length of query])&lt;/code&gt; или &lt;code&gt;O(N*M)&lt;/code&gt; . Игнорирование нескольких переменных является одним из наиболее распространенных недостатков, которые я вижу при анализе алгоритмов, и может помешать вам при разработке алгоритма.</target>
        </trans-unit>
        <trans-unit id="046638077884a582146518106d52398b493200ef" translate="yes" xml:space="preserve">
          <source>Multiplication is different. You line the numbers up, take the first digit in the bottom number and multiply it in turn against each digit in the top number and so on through each digit. So to multiply our two 6 digit numbers we must do 36 multiplications. We may need to do as many as 10 or 11 column adds to get the end result too.</source>
          <target state="translated">Умножение-это другое.Вы выстраиваете числа вверх,берете первую цифру в нижнем числе и по очереди умножаете ее против каждой цифры в верхнем числе и так далее через каждую цифру.Таким образом,чтобы умножить наши два 6-значных числа,мы должны сделать 36 умножений.Для получения конечного результата нам также может потребоваться сделать 10 или 11 столбцов сложений.</target>
        </trans-unit>
        <trans-unit id="8b1b53f8f44ad3ed2592eb6c68dec183ea16ec21" translate="yes" xml:space="preserve">
          <source>My list</source>
          <target state="translated">Мой список</target>
        </trans-unit>
        <trans-unit id="f7535aeee1a8d7280cd70d9997d4349f35bb3d3e" translate="yes" xml:space="preserve">
          <source>Naive method: If you had the coordinates of a street intersection, and wanted to examine nearby streets, you would have to go through the millions of segments each time, and check each one for adjacency.</source>
          <target state="translated">Наивный метод:Если бы у вас были координаты перекрестка улиц,и вы хотели бы исследовать близлежащие улицы,вы должны были бы пройти через миллионы сегментов каждый раз,и проверить каждый из них на соответствие.</target>
        </trans-unit>
        <trans-unit id="4d68869609a9235101b6bdb59cfad0ecf3bbe23e" translate="yes" xml:space="preserve">
          <source>No growth.  Regardless of how big as the problem is, you can solve it in the same amount of time.  This is somewhat analogous to broadcasting where it takes the same amount of energy to broadcast over a given distance, regardless of the number of people that lie within the broadcast range.</source>
          <target state="translated">Нет роста.Независимо от того,насколько велика проблема,вы можете решить ее за то же время.Это несколько похоже на вещание,где требуется такое же количество энергии,чтобы вещать на заданном расстоянии,независимо от количества людей,которые находятся в радиусе действия.</target>
        </trans-unit>
        <trans-unit id="fe33dcb0f45062333e4e71b8e3449ababa913575" translate="yes" xml:space="preserve">
          <source>Normally we don't care about the best case.  We're interested in the expected and worst case.  Sometimes one or the other of these will be more important.</source>
          <target state="translated">Обычно нас не волнует лучшее дело.Нас интересует ожидаемый и худший случай.Иногда тот или иной из них будет важнее.</target>
        </trans-unit>
        <trans-unit id="1a399a408e72ce4d50e1c555e9e14eb8f828e225" translate="yes" xml:space="preserve">
          <source>Not all algorithms run in the same amount of time, and can vary based on the number of items in the input, which we'll call &lt;em&gt;n&lt;/em&gt;. Based on this, we consider the worse case analysis, or an upper-bound of the run-time as &lt;em&gt;n&lt;/em&gt; get larger and larger. We must be aware of what &lt;em&gt;n&lt;/em&gt; is, because many of the Big O notations reference it.</source>
          <target state="translated">Не все алгоритмы работают за одинаковое количество времени и могут варьироваться в зависимости от количества элементов на входе, которое мы назовем &lt;em&gt;n&lt;/em&gt; . Исходя из этого, мы рассматриваем худший анализ случая или верхнюю границу времени выполнения, когда &lt;em&gt;n&lt;/em&gt; становится все больше и больше. Мы должны знать, что такое &lt;em&gt;n&lt;/em&gt; , потому что многие из обозначений Big O ссылаются на него.</target>
        </trans-unit>
        <trans-unit id="9701d8a66e2332c79e3006b450aca766fa1d69b7" translate="yes" xml:space="preserve">
          <source>Not sure I'm further contributing to the subject but still thought I'd share: I once found &lt;a href=&quot;http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/&quot;&gt;this blog post&lt;/a&gt; to have some quite helpful (though very basic) explanations &amp;amp; examples on Big O:</source>
          <target state="translated">Не уверен, что я продолжаю вносить свой вклад в эту тему, но все же думал, что поделюсь: однажды я обнаружил, что в &lt;a href=&quot;http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/&quot;&gt;этом блоге&lt;/a&gt; есть несколько весьма полезных (хотя и очень простых) объяснений и примеров по Big O:</target>
        </trans-unit>
        <trans-unit id="ed45d6f0b33afd4fda7acc9a90c9a6ded141d1e6" translate="yes" xml:space="preserve">
          <source>Note: None of this has taken into account best, average, and worst case measures. Each would have its own Big O notation. Also note that this is a VERY simplistic explanation. Big O is the most common, but it's also more complex that I've shown. There are also other notations such as big omega, little o, and big theta. You probably won't encounter them outside of an algorithm analysis course.</source>
          <target state="translated">Примечание:Ни одна из этих мер не учитывала лучшие,средние и наихудшие показатели.Каждая из них имеет свою собственную нотацию Big O.Также обратите внимание,что это ОЧЕНЬ упрощенное объяснение.Большая О-самая распространенная,но и более сложная из тех,что я показывал.Есть и другие нотации,такие как большая омега,маленькая о и большая тета.Скорее всего,вы не столкнетесь с ними вне курса алгоритмического анализа.</target>
        </trans-unit>
        <trans-unit id="2238088b0eacca225a542e4f91ecc2965d263d59" translate="yes" xml:space="preserve">
          <source>Notice that the number of items increases by a factor of 10, but the time increases by a factor of 10&lt;sup&gt;2&lt;/sup&gt;. Basically, n=10 and so O(n&lt;sup&gt;2&lt;/sup&gt;) gives us the scaling factor n&lt;sup&gt;2&lt;/sup&gt; which is 10&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">Обратите внимание, что количество предметов увеличивается в 10 раз, но время увеличивается в 10 &lt;sup&gt;2&lt;/sup&gt; раза. В основном, n = 10, и поэтому O (n &lt;sup&gt;2&lt;/sup&gt; ) дает нам коэффициент масштабирования n &lt;sup&gt;2,&lt;/sup&gt; который равен 10 &lt;sup&gt;2&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="257c3797269830bc9710d43ca3694a583cd402ae" translate="yes" xml:space="preserve">
          <source>Now I have some work.  I have this list: one, two, three, four, five, six.  I must add all things in this list.</source>
          <target state="translated">Теперь у меня есть кое-какая работа.У меня есть список:раз,два,три,четыре,пять,шесть.Я должен добавить все вещи из этого списка.</target>
        </trans-unit>
        <trans-unit id="ce4444486678ac072c200b97ac0870621f89a826" translate="yes" xml:space="preserve">
          <source>Now at times, I do have to go to work.  It is sad, but true.  So, when I am at work, I have a rule: I try to do less work.  As near to no work as I can.  Then I go play!</source>
          <target state="translated">Иногда мне приходится идти на работу.Это грустно,но это правда.Поэтому,когда я на работе,у меня есть правило:я стараюсь делать меньше работы.Как можно меньше работы.Тогда я иду играть!</target>
        </trans-unit>
        <trans-unit id="4af2bcb5c492dc62ee7f7d5ed90f520c4c05c4e0" translate="yes" xml:space="preserve">
          <source>Now here comes big O, and he will tell us how hard this work is.  He says: to add all things from one to N, one by one, is O(n).  To add all these things, [I know I must add n times.][1]  That is big O!  He tells us how hard it is to do some type of work.</source>
          <target state="translated">А вот и Большой О,и он расскажет нам,как это тяжело.Он говорит:добавлять все вещи от одного к N,один за другим-это O(n).Чтобы добавить все эти вещи,[я знаю,что должен добавить n раз.][1]Это большое О! Он говорит нам,как трудно сделать какую-то работу.</target>
        </trans-unit>
        <trans-unit id="6c34478c5f5b54c8853b19d59a2824aed411c88f" translate="yes" xml:space="preserve">
          <source>Now here is where big O is our friend.</source>
          <target state="translated">А теперь вот где большая &quot;О&quot;-наш друг.</target>
        </trans-unit>
        <trans-unit id="110a534fc79ede4defb1ebec55d0413c614f421d" translate="yes" xml:space="preserve">
          <source>Now if you were instructing a computer to look up the phone number for &quot;John Smith&quot; in a telephone book that contains 1,000,000 names, what would you do?  Ignoring the fact that you could guess how far in the S's started (let's assume you can't), what would you do?</source>
          <target state="translated">Теперь,если бы Вы инструктировали компьютер искать телефонный номер &quot;Джона Смита&quot; в телефонной книге,которая содержит 1 000 000 имен,что бы Вы сделали? Игнорируя тот факт,что вы могли бы угадать,как далеко начались буквы &quot;С&quot; (предположим,что вы не можете),что бы вы сделали?</target>
        </trans-unit>
        <trans-unit id="9540b13ba056381a0510ad691215a7809e459df8" translate="yes" xml:space="preserve">
          <source>Now that work is done, let&amp;rsquo;s go play!</source>
          <target state="translated">Теперь, когда работа сделана, поехали играть!</target>
        </trans-unit>
        <trans-unit id="d6eba09ebedd6f51a03a1027fa2fafcd89c71acb" translate="yes" xml:space="preserve">
          <source>Now they ask me to add from one to ten!  Why would I do that?  I did not want to add one to six.  To add from one to ten&amp;hellip; well&amp;hellip; that would be even more hard!</source>
          <target state="translated">Теперь они просят меня прибавить от одного до десяти! Зачем мне это делать? Я не хотел добавлять один к шести. Добавить от одного до десяти ... ну ... это было бы еще сложнее!</target>
        </trans-unit>
        <trans-unit id="00988e447c66a2cb48babcb9e00cb583a7ea2cdd" translate="yes" xml:space="preserve">
          <source>Now we must do new work.  Oh, no.  I don&amp;rsquo;t like this work thing at all.</source>
          <target state="translated">Теперь мы должны сделать новую работу. О нет. Мне вообще не нравится эта работа.</target>
        </trans-unit>
        <trans-unit id="2649fa4f7ace90e5e3a42578e0c5f2755906f188" translate="yes" xml:space="preserve">
          <source>Now when big O says it will take O(n squared) work, he does not mean n squared adds, on the nose.  It might be some small bit less, for some case.  But in the worst case, it will be near n squared steps of work to sort the deck.</source>
          <target state="translated">Теперь,когда большой O говорит,что это займет O(n в квадрате)работы,он не означает,что n в квадрате добавляет,на носу.Это может быть немного меньше,для некоторых случаев.Но в худшем случае для сортировки колоды потребуется около n квадратных шагов работы.</target>
        </trans-unit>
        <trans-unit id="08d4d2dadf777a65ea195b7215d064cef2cd8721" translate="yes" xml:space="preserve">
          <source>Now you know my friend, Big O.  He helps us do less work.  And if you know big O, you can do less work too!</source>
          <target state="translated">Теперь ты знаешь моего друга,Большого О.Он помогает нам делать меньше работы.И если ты знаешь Большого О,ты тоже можешь делать меньше работы!</target>
        </trans-unit>
        <trans-unit id="05dc08a4c399781657ad8add0a8aafb1f260a439" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s you and me talk of work. Most of the time, I do not like work.  Do you like work?  It may be the case that you do, but I am sure I do not.</source>
          <target state="translated">Теперь давайте поговорим о работе. Большую часть времени я не люблю работать. Тебе нравится работать? Это может быть случай, который вы делаете, но я уверен, что нет.</target>
        </trans-unit>
        <trans-unit id="205e8cfdfc5930c2d0673af6524af6317388bfed" translate="yes" xml:space="preserve">
          <source>O and Ω are not symmetric (n = O(n&amp;sup2;), but n&amp;sup2; is not O(n)), but Ɵ is symmetric, and (since these relations are all transitive and reflexive) Ɵ, therefore, is symmetric and transitive and reflexive, and therefore partitions the set of all functions into &lt;em&gt;equivalence classes&lt;/em&gt;. An equivalence class is a set of things that we consider to be the same. That is to say, given any function you can think of, you can find a canonical/unique 'asymptotic representative' of the class (by generally taking the limit... I &lt;em&gt;think&lt;/em&gt;); just like you can group all integers into odds or evens, you can group all functions with Ɵ into x-ish, log(x)^2-ish, etc... by basically ignoring smaller terms (but sometimes you might be stuck with more complicated functions which are separate classes unto themselves).</source>
          <target state="translated">O и &amp;Omega; не являются симметричными (n = O (n&amp;sup2;), но n&amp;sup2; не является O (n)), но Ɵ симметрична и (поскольку все эти отношения транзитивны и рефлексивны) therefore, следовательно, симметрична, транзитивна и рефлексивна и, следовательно, разбивает множество всех функций на &lt;em&gt;классы эквивалентности&lt;/em&gt; . Класс эквивалентности - это набор вещей, которые мы считаем одинаковыми. Иными словами, для любой функции, которую вы можете придумать, вы можете найти канонического / уникального &amp;laquo;асимптотического представителя&amp;raquo; класса (обычно беря предел ... я &lt;em&gt;думаю&lt;/em&gt; ); точно так же, как вы можете сгруппировать все целые числа в шансы или четности, вы можете сгруппировать все функции с помощью Ɵ в x-ish, log (x) ^ 2-ish и т. д., в основном игнорируя более мелкие термины (но иногда вы можете застрять с более сложные функции, которые являются отдельными классами для себя).</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="98e642472708191e8a65ac2ab3cf6a96d7f6885e" translate="yes" xml:space="preserve">
          <source>O(1) = O(n) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin; (but not the other way around, the equality is &quot;fake&quot;),</source>
          <target state="translated">O (1) = O (n) = O (n &lt;sup&gt;2&lt;/sup&gt; ), когда n &amp;rarr; + &amp;infin; (но не наоборот, равенство &amp;laquo;фальшивое&amp;raquo;),</target>
        </trans-unit>
        <trans-unit id="25c301e3f5329dedc950de0f1c38ac8d3d8286a2" translate="yes" xml:space="preserve">
          <source>O(1) describes an algorithm that will always execute in the same time
  (or space) regardless of the size of the input data set.</source>
          <target state="translated">O(1)описывает алгоритм,который всегда будет выполняться в одно и то же время (или пространство)независимо от размера входного набора данных.</target>
        </trans-unit>
        <trans-unit id="1e77cb950a650cbda7e41c7e563dfc7d75184ce0" translate="yes" xml:space="preserve">
          <source>O(1), means your computer gets a task done with &lt;code&gt;1&lt;/code&gt; step, it's excellent, Ordered No.1</source>
          <target state="translated">O (1), означает, что ваш компьютер выполняет задачу за &lt;code&gt;1&lt;/code&gt; шаг, это отлично, Заказ № 1</target>
        </trans-unit>
        <trans-unit id="8681bf4e62cb366ee6970996fa273715542e1c24" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;N&lt;/sup&gt;)</source>
          <target state="translated">O(2&lt;sup&gt;N&lt;/sup&gt;)</target>
        </trans-unit>
        <trans-unit id="e3d80bfb500c859c180f245124c30408ce843ee8" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;N&lt;/sup&gt;) denotes an algorithm whose growth doubles with each additon to
  the input data set. The growth curve of an O(2&lt;sup&gt;N&lt;/sup&gt;) function is
  exponential - starting off very shallow, then rising meteorically. An
  example of an O(2&lt;sup&gt;N&lt;/sup&gt;) function is the recursive calculation of Fibonacci
  numbers:</source>
          <target state="translated">O (2 &lt;sup&gt;N&lt;/sup&gt; ) обозначает алгоритм, рост которого удваивается с каждым добавлением к набору входных данных. Кривая роста функции O (2 &lt;sup&gt;N&lt;/sup&gt; ) имеет экспоненциальный характер: она начинается очень неглубоко, а затем возрастает метеоритно. Примером функции O (2 &lt;sup&gt;N&lt;/sup&gt; ) является рекурсивный расчет чисел Фибоначчи:</target>
        </trans-unit>
        <trans-unit id="68bc7ad068f5c61d49e37e6fc72efd56e5f32c9c" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;n&lt;/sup&gt;): If the input size increases by one, the runtime doubles</source>
          <target state="translated">O (2 &lt;sup&gt;n&lt;/sup&gt; ): если размер ввода увеличивается на единицу, время выполнения удваивается</target>
        </trans-unit>
        <trans-unit id="63e9d8727f40f7ec9e8552148c03efe752771415" translate="yes" xml:space="preserve">
          <source>O(2^N),  get a task done with &lt;code&gt;2^N&lt;/code&gt; steps, it's horrible, Order No.6</source>
          <target state="translated">O (2 ^ N), выполни задачу за &lt;code&gt;2^N&lt;/code&gt; шагов, это ужасно, Приказ № 6</target>
        </trans-unit>
        <trans-unit id="308b527a11caed66089316ea8a6e1067c1969f82" translate="yes" xml:space="preserve">
          <source>O(N!),  get a task done with &lt;code&gt;N!&lt;/code&gt; steps, it's terrible, Order No.7</source>
          <target state="translated">O (N!), Выполни задачу с &lt;code&gt;N!&lt;/code&gt; шаги, это ужасно, Приказ № 7</target>
        </trans-unit>
        <trans-unit id="a257064879b3c5b994b0c4eb5698b028eb534479" translate="yes" xml:space="preserve">
          <source>O(N)</source>
          <target state="translated">O(N)</target>
        </trans-unit>
        <trans-unit id="c3f150e3661faff6df87ef3476136d42ffe76b00" translate="yes" xml:space="preserve">
          <source>O(N) describes an algorithm whose performance will grow linearly and
  in direct proportion to the size of the input data set. The example
  below also demonstrates how Big O favours the worst-case performance
  scenario; a matching string could be found during any iteration of the
  for loop and the function would return early, but Big O notation will
  always assume the upper limit where the algorithm will perform the
  maximum number of iterations.</source>
          <target state="translated">O(N)описывает алгоритм,производительность которого будет расти линейно и прямо пропорционально размеру входного набора данных.Приведенный ниже пример также демонстрирует,как Big O предпочитает наихудший сценарий производительности;соответствующая строка может быть найдена во время любой итерации цикла for,и функция вернется раньше,но нотация Big O всегда будет предполагать верхний предел,в котором алгоритм будет выполнять максимальное количество итераций.</target>
        </trans-unit>
        <trans-unit id="50a60625d0c152951efa7ecdbe93cfe7f46beda6" translate="yes" xml:space="preserve">
          <source>O(N), finish a task with &lt;code&gt;N&lt;/code&gt; steps, its fair, Order No.3</source>
          <target state="translated">O (N), завершить задачу за &lt;code&gt;N&lt;/code&gt; шагов, это справедливо, Заказ № 3</target>
        </trans-unit>
        <trans-unit id="56b0b7dfdc166b52f3daf1b1c70a817924759e73" translate="yes" xml:space="preserve">
          <source>O(N&lt;sup&gt;2&lt;/sup&gt;)</source>
          <target state="translated">O(N&lt;sup&gt;2&lt;/sup&gt;)</target>
        </trans-unit>
        <trans-unit id="8c2b565c37a449cbce6a610382372bb9973c5a59" translate="yes" xml:space="preserve">
          <source>O(N&lt;sup&gt;2&lt;/sup&gt;) represents an algorithm whose performance is directly
  proportional to the square of the size of the input data set. This is
  common with algorithms that involve nested iterations over the data
  set. Deeper nested iterations will result in O(N&lt;sup&gt;3&lt;/sup&gt;), O(N&lt;sup&gt;4&lt;/sup&gt;) etc.</source>
          <target state="translated">O (N &lt;sup&gt;2&lt;/sup&gt; ) представляет алгоритм, производительность которого прямо пропорциональна квадрату размера входного набора данных. Это распространено в алгоритмах, которые включают вложенные итерации по набору данных. Более глубокие вложенные итерации приведут к O (N &lt;sup&gt;3&lt;/sup&gt; ), O (N &lt;sup&gt;4&lt;/sup&gt; ) и т. Д.</target>
        </trans-unit>
        <trans-unit id="de99ca4237dd94527753ecf95f080066d3a66999" translate="yes" xml:space="preserve">
          <source>O(N^2),  get a task done with &lt;code&gt;N^2&lt;/code&gt; steps, it's bad, Order No.5</source>
          <target state="translated">O (N ^ 2), выполни задачу с &lt;code&gt;N^2&lt;/code&gt; шагами, это плохо, Приказ № 5</target>
        </trans-unit>
        <trans-unit id="044f421fbafcb690927916033a456e1ccb0b67d2" translate="yes" xml:space="preserve">
          <source>O(NlogN), ends a task with &lt;code&gt;O(NlogN)&lt;/code&gt; steps, it's not good, Order No.4</source>
          <target state="translated">O (NlogN), завершает задачу с &lt;code&gt;O(NlogN)&lt;/code&gt; шагами, это не хорошо, Приказ № 4</target>
        </trans-unit>
        <trans-unit id="adcb5e72616abf45d10a5b515b2a078ad0f91adb" translate="yes" xml:space="preserve">
          <source>O(O(n&lt;sup&gt;2&lt;/sup&gt;)) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">O (O (n &lt;sup&gt;2&lt;/sup&gt; )) = O (n &lt;sup&gt;2&lt;/sup&gt; ) при n &amp;rarr; + &amp;infin;</target>
        </trans-unit>
        <trans-unit id="ece6ebf71b235bbf6ca0d80731462a53a21f231d" translate="yes" xml:space="preserve">
          <source>O(log n): If the input size doubles the runtime increases by one</source>
          <target state="translated">O(log n):Если размер входного сигнала удваивается,то время выполнения увеличивается на единицу.</target>
        </trans-unit>
        <trans-unit id="7e25f642c5b31ae751d0fbe5acb56b926e9390ba" translate="yes" xml:space="preserve">
          <source>O(logN), means your computer complete a task with &lt;code&gt;logN&lt;/code&gt; steps, its good, Ordered No.2</source>
          <target state="translated">O (logN), означает, что ваш компьютер завершил задачу с шагами &lt;code&gt;logN&lt;/code&gt; , это хорошо, Заказ № 2</target>
        </trans-unit>
        <trans-unit id="d09f9f7cdec58e339154e9a9c832d0991809a760" translate="yes" xml:space="preserve">
          <source>O(n) + O(n&lt;sup&gt;2&lt;/sup&gt;) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">O (n) + O (n &lt;sup&gt;2&lt;/sup&gt; ) = O (n &lt;sup&gt;2&lt;/sup&gt; ) при n &amp;rarr; + &amp;infin;</target>
        </trans-unit>
        <trans-unit id="97dd63fef8702296bf87a4c2e21f4bd48ff0b539" translate="yes" xml:space="preserve">
          <source>O(n) means Big O is n, and now you might think, &quot;What is n!?&quot; Well &quot;n&quot; is the amount of elements. Imaging you want to search for an Item in an Array. You would have to look on Each element and as &quot;Are you the correct element/item?&quot; in the worst case, the item is at the last index, which means that it took as much time as there are items in the list, so to be generic, we say &quot;oh hey, n is a fair given amount of values!&quot;.</source>
          <target state="translated">O(n)означает Big O is n,а теперь ты можешь подумать:&quot;Что такое n!?&quot; Ну,&quot;n&quot;-это количество элементов.Изображение,которое вы хотите найти в массиве.Вы должны будете посмотреть на каждый элемент,и как &quot;Вы правильный элементам?&quot; в худшем случае элемент находится в последнем индексе,что означает,что это заняло столько же времени,сколько и элементов в списке,поэтому,чтобы быть общими,мы говорим:&quot;О,эй,n-это справедливое заданное количество значений!&quot;.</target>
        </trans-unit>
        <trans-unit id="d0849346fa8631d6b61d0173d101e04d26feaa94" translate="yes" xml:space="preserve">
          <source>O(n) ~ Linear</source>
          <target state="translated">O(n)~ Линейный</target>
        </trans-unit>
        <trans-unit id="a5fa19f57aec98afc3fc69df842b447d2a094f4c" translate="yes" xml:space="preserve">
          <source>O(n), O(n&lt;sup&gt;2&lt;/sup&gt;) etc. are all polynomial time. Some problems cannot be solved in polynomial time. Certain things are used in the world because of this. &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;Public Key Cryptography&lt;/a&gt; is a prime example. It is computationally hard to find two prime factors of a very large number. If it wasn't, we couldn't use the public key systems we use.</source>
          <target state="translated">O (n), O (n &lt;sup&gt;2&lt;/sup&gt; ) и т. Д. - все полиномиальное время. Некоторые проблемы не могут быть решены за полиномиальное время. Из-за этого в мире используются определенные вещи. &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;Криптография с открытым ключом&lt;/a&gt; является ярким примером. В вычислительном отношении трудно найти два простых фактора очень большого числа. Если это не так, мы не могли бы использовать системы открытых ключей, которые мы используем.</target>
        </trans-unit>
        <trans-unit id="f995f059c281a355753f38679edd0e7f61f9dfcf" translate="yes" xml:space="preserve">
          <source>O(n): If I double the input size the runtime doubles</source>
          <target state="translated">O(n):Если я удвою размер ввода,время выполнения удвоится.</target>
        </trans-unit>
        <trans-unit id="830c15d5357ce8008571a4bcc897c78270ce5607" translate="yes" xml:space="preserve">
          <source>O(n&lt;sup&gt;2&lt;/sup&gt;): If the input size doubles the runtime quadruples</source>
          <target state="translated">O (n &lt;sup&gt;2&lt;/sup&gt; ): если размер ввода удваивается, время выполнения увеличивается в четыре раза</target>
        </trans-unit>
        <trans-unit id="8639ae6910d96d5623a09688e0818a131fb8c50f" translate="yes" xml:space="preserve">
          <source>O(n&lt;sup&gt;2&lt;/sup&gt;)O(n&lt;sup&gt;3&lt;/sup&gt;) = O(n&lt;sup&gt;5&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">O (n &lt;sup&gt;2&lt;/sup&gt; ) O (n &lt;sup&gt;3&lt;/sup&gt; ) = O (n &lt;sup&gt;5&lt;/sup&gt; ) при n &amp;rarr; + &amp;infin;</target>
        </trans-unit>
        <trans-unit id="ac18ee6983cc2eb537d0f2f25351e9df638a26bd" translate="yes" xml:space="preserve">
          <source>Obviously that's only using &quot;size&quot; as the input and &quot;time taken&quot; as the output &amp;mdash; the same idea applies if you want to talk about memory usage etc.</source>
          <target state="translated">Очевидно, что это только использование &amp;laquo;размера&amp;raquo; в качестве входных данных и &amp;laquo;затраченного времени&amp;raquo; в качестве выходных данных - та же идея применима, если вы хотите поговорить об использовании памяти и т. Д.</target>
        </trans-unit>
        <trans-unit id="047235fd8fb4d12aece908a6c0ecf01e2c06606a" translate="yes" xml:space="preserve">
          <source>Of course this does not mean that loops and functions are bad; on the contrary, they are the building blocks of modern programming languages, and we love them. However, we can see that the way we weave loops and functions and conditionals together with our data (control flow, etc.) mimics the time and space usage of our program! If time and space usage becomes an issue, that is when we resort to cleverness and find an easy algorithm or data structure we hadn't considered, to reduce the order of growth somehow. Nevertheless, these visualization techniques (though they don't always work) can give you a naive guess at a worst-case running time.</source>
          <target state="translated">Конечно,это не значит,что циклы и функции плохие,наоборот,они являются строительными блоками современных языков программирования,и мы их любим.Однако,мы видим,что то,как мы переплетаем циклы,функции и кондиционеры вместе с нашими данными (потоком управления и т.д.),имитирует использование времени и пространства нашей программы! Если использование времени и пространства становится проблемой,то есть мы прибегаем к хитрости и находим простой алгоритм или структуру данных,которую мы не рассматривали,чтобы как-то уменьшить порядок роста.Тем не менее,эти приемы визуализации (хотя и не всегда работают)могут дать наивное предположение в худшем случае.</target>
        </trans-unit>
        <trans-unit id="02eb439e917fc58abf025b96d214507c593cd917" translate="yes" xml:space="preserve">
          <source>Oh no, now I have more work.  Sheesh.  Who makes this kind of stuff?!</source>
          <target state="translated">О нет,теперь у меня больше работы.Тьфу.Кто делает такие вещи?!</target>
        </trans-unit>
        <trans-unit id="846bee0b9db59985faaa143bf6c6677865b72c7b" translate="yes" xml:space="preserve">
          <source>Ok, my 2cents.</source>
          <target state="translated">Хорошо,мои 2 цента.</target>
        </trans-unit>
        <trans-unit id="4d41abb6d91ed8426b9c48d248c476619fafc156" translate="yes" xml:space="preserve">
          <source>Once I have found these two cards, I swap them, and go on to look for more cards to swap.  That is, I go back to step Two, and splay on the card you chose some more.</source>
          <target state="translated">Как только я нашел эти две карты,я меняю их,и иду дальше искать еще карты,чтобы поменяться.То есть,я возвращаюсь ко второму шагу,и брызгаю на карту,которую ты выбрал еще.</target>
        </trans-unit>
        <trans-unit id="bbe0abb1706b2ab494f9baaf3f32394aa9b1d99e" translate="yes" xml:space="preserve">
          <source>One can notice that we've assumed the worst case scenario here. While multiplying 6 digit numbers, if one of them has 4 digits and the other one has 6 digits, then we only have 24 multiplications. Still, we calculate the worst case scenario for that 'n', i.e when both are 6 digit numbers. Hence Big-O notation is about the Worst-case scenario of an algorithm.</source>
          <target state="translated">Можно заметить,что мы предположили худший сценарий.Умножая 6-значные числа,если одно из них имеет 4 цифры,а другое-6,то мы имеем только 24 умножения.Тем не менее,мы вычислили наихудший сценарий для этого 'n',т.е.когда и то,и другое-6-значные числа.Следовательно,нотация Big-O-это худший сценарий алгоритма.</target>
        </trans-unit>
        <trans-unit id="aa31e9cc8ee30f1096d7841ca16202599811c4d7" translate="yes" xml:space="preserve">
          <source>One important aspect of &quot;big O&quot; notation is that it &lt;em&gt;doesn't&lt;/em&gt; say which algorithm will be faster for a given size. Take a hashtable (string key, integer value)  vs an array of pairs (string, integer). Is it faster to find a key in the hashtable or an element in the array, based on a string? (i.e. for the array, &quot;find the first element where the string part matches the given key.&quot;) Hashtables are generally amortised (~= &quot;on average&quot;) O(1) &amp;mdash; once they're set up, it should take about the same time to find an entry in a 100 entry table as in a 1,000,000 entry table. Finding an element in an array (based on content rather than index) is linear, i.e. O(N) &amp;mdash; on average, you're going to have to look at half the entries.</source>
          <target state="translated">Одним из важных аспектов нотации &amp;laquo;большой О&amp;raquo; является то, что он &lt;em&gt;не&lt;/em&gt; говорит, какой алгоритм будет быстрее для данного размера. Возьмите хеш-таблицу (строковый ключ, целочисленное значение) против массива пар (строка, целое число). Быстрее найти ключ в хеш-таблице или элемент массива на основе строки? (т. е. для массива: &amp;laquo;найдите первый элемент, в котором строковая часть соответствует заданному ключу.&amp;raquo;) Хеш-таблицы обычно амортизируются (в среднем ~ = &amp;laquo;)&amp;raquo; O (1) - после того, как они настроены, это должно занять около в то же время, чтобы найти запись в таблице 100 записей, как и в таблице записей 1,000,000. Поиск элемента в массиве (на основе содержимого, а не индекса) является линейным, т. Е. O (N) - в среднем вам придется просматривать половину записей.</target>
        </trans-unit>
        <trans-unit id="455ac552ede28e8384f4279d82396b29180d80b5" translate="yes" xml:space="preserve">
          <source>One plus two is three&amp;hellip; plus three is six... and four is... I don&amp;rsquo;t know.  I got lost.  It is too hard for me to do in my head.  I don&amp;rsquo;t much care for this kind of work.</source>
          <target state="translated">Один плюс два - это три ... плюс три - это шесть ... а четыре - это ... я не знаю. Я потерялся. Это слишком сложно для меня сделать в моей голове. Меня не очень волнует такая работа.</target>
        </trans-unit>
        <trans-unit id="bc82ac3fdfa2c36fc2c53eae610e61a05eb3407a" translate="yes" xml:space="preserve">
          <source>One: I choose one card in the part of the deck we work on now.  You can choose one for me if you like.  (The first time we do this, &amp;ldquo;the part of the deck we work on now&amp;rdquo; is the whole deck, of course.)</source>
          <target state="translated">Первый: я выбираю одну карту в той части колоды, над которой мы сейчас работаем. Вы можете выбрать один для меня, если хотите. (В первый раз, когда мы делаем это, &amp;laquo;часть колоды, над которой мы сейчас работаем&amp;raquo;, это, конечно, вся колода.)</target>
        </trans-unit>
        <trans-unit id="6f7dd336bd44297d43d1e2584ebc5605a1581c94" translate="yes" xml:space="preserve">
          <source>Only concerned with runtime grow relative to the input &lt;strong&gt;(n)&lt;/strong&gt;</source>
          <target state="translated">Относится только к росту времени выполнения относительно ввода &lt;strong&gt;(n)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e64c05fb1f7a3fd3c0cf63d3e43c979084e566b1" translate="yes" xml:space="preserve">
          <source>Or maybe you do log(N) passes of the data, for O(N*log(N)) total time:</source>
          <target state="translated">Или,может быть,вы делаете log(N)передачи данных,для O(N*log(N))общего времени:</target>
        </trans-unit>
        <trans-unit id="03e6e7bc29b2694c5ad9d0d21e7d44ffe2e43e41" translate="yes" xml:space="preserve">
          <source>Our task went from an infeasible &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; to a manageable &lt;code&gt;O(N)&lt;/code&gt;, and all we had to do was pay a minor cost to make a hash table.</source>
          <target state="translated">Наша задача перешла от неосуществимого &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; к управляемому &lt;code&gt;O(N)&lt;/code&gt; , и все, что нам нужно было сделать, это заплатить небольшую плату за создание хэш-таблицы.</target>
        </trans-unit>
        <trans-unit id="0732d399cd128b93b16b9a0583b8df0ddb1d224b" translate="yes" xml:space="preserve">
          <source>People will often use &lt;code&gt;= O(...)&lt;/code&gt;, which is perhaps the more correct 'comp-sci' notation, and entirely legitimate to use; &quot;f = O(...)&quot; is read &quot;f is order ... / f is xxx-bounded by ...&quot; and is thought of as &quot;f is some expression whose asymptotics are ...&quot;. I was taught to use the more rigorous &lt;code&gt;&amp;isin; O(...)&lt;/code&gt;. &lt;code&gt;&amp;isin;&lt;/code&gt; means &quot;is an element of&quot; (still read as before). In this particular case, &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; contains elements like {&lt;code&gt;2 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;3 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;1/2 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;2 N&amp;sup2; + log(N)&lt;/code&gt;, &lt;code&gt;- N&amp;sup2; + N^1.9&lt;/code&gt;, ...} and is infinitely large, but it's still a set.</source>
          <target state="translated">Люди часто будут использовать &lt;code&gt;= O(...)&lt;/code&gt; , что, возможно, является более правильной нотацией &amp;laquo;comp-sci&amp;raquo; и совершенно законно для использования; &amp;laquo;f = O (...)&amp;raquo; читается как &amp;laquo;f - порядок ... / f ограничен ххх ...&amp;raquo; и рассматривается как &amp;laquo;f - некоторое выражение, асимптотика которого ...&amp;raquo;. Меня учили пользоваться более строгим &lt;code&gt;&amp;isin; O(...)&lt;/code&gt; . &lt;code&gt;&amp;isin;&lt;/code&gt; означает &amp;laquo;является элементом&amp;raquo; (все еще читается как прежде). В данном конкретном случае &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; содержит такие элементы, как { &lt;code&gt;2 N&amp;sup2;&lt;/code&gt; , &lt;code&gt;3 N&amp;sup2;&lt;/code&gt; , &lt;code&gt;1/2 N&amp;sup2;&lt;/code&gt; , &lt;code&gt;2 N&amp;sup2; + log(N)&lt;/code&gt; , &lt;code&gt;- N&amp;sup2; + N^1.9&lt;/code&gt; , ...} и бесконечно велико, но оно еще набор.</target>
        </trans-unit>
        <trans-unit id="aff7f1ca724e63fb9ec4afc2e9f2dbdfa5bff1a0" translate="yes" xml:space="preserve">
          <source>Please note the order at line end, just for your better understanding.There's more than 7 notations if all possibilities considered.</source>
          <target state="translated">Пожалуйста,обратите внимание на порядок в конце строки,просто для вашего лучшего понимания.Есть более 7 записей,если все возможности рассмотрены.</target>
        </trans-unit>
        <trans-unit id="ff6f34b84d9b2e644758179e12f471c8957fb41f" translate="yes" xml:space="preserve">
          <source>Polynomial Time</source>
          <target state="translated">полиномиальное время</target>
        </trans-unit>
        <trans-unit id="c745366182e555ccc5603f9f335f3de2d95eae3a" translate="yes" xml:space="preserve">
          <source>Practically speaking, Big O analysis is &lt;em&gt;so useful and important&lt;/em&gt; because Big O puts the focus squarely on the algorithm's &lt;em&gt;own&lt;/em&gt; complexity and completely &lt;em&gt;ignores&lt;/em&gt; anything that is merely a proportionality constant&amp;mdash;like a JavaScript engine, the speed of a CPU, your Internet connection, and all those things which become quickly become as laughably outdated as a Model &lt;em&gt;T&lt;/em&gt;. Big O focuses on performance only in the way that matters equally as much to people living in the present or in the future.</source>
          <target state="translated">Практически говоря, анализ Big O является &lt;em&gt;настолько полезным и важным,&lt;/em&gt; потому что Big O прямо фокусируется на &lt;em&gt;собственной&lt;/em&gt; сложности алгоритма и полностью &lt;em&gt;игнорирует&lt;/em&gt; все, что является просто константой пропорциональности - например, движок JavaScript, скорость процессора, ваше интернет-соединение и все те вещи, которые быстро становятся такими же смехотворно устаревшими, как модель &lt;em&gt;Т.&lt;/em&gt; Big O фокусируется на производительности только таким образом, который одинаково важен для людей, живущих в настоящем или в будущем.</target>
        </trans-unit>
        <trans-unit id="707ddefda8b9d501a1d63dad3fcb74d0cb28b51a" translate="yes" xml:space="preserve">
          <source>Preface</source>
          <target state="translated">Preface</target>
        </trans-unit>
        <trans-unit id="c96271fcfba3e64dd9236be70e3f3f5fc45c32c9" translate="yes" xml:space="preserve">
          <source>Programs will also run slower on a 500MHz computer vs 2GHz computer. We don't really consider this as part of the resource bounds, because we think of the scaling in terms of machine resources (e.g. per clock cycle), not per real second. However, there are similar things which can 'secretly' affect performance, such as whether you are running under emulation, or whether the compiler optimized code or not. These might make some basic operations take longer (even relative to each other), or even speed up or slow down some operations asymptotically (even relative to each other). The effect may be small or large between different implementation and/or environment. Do you switch languages or machines to eke out that little extra work? That depends on a hundred other reasons (necessity, skills, coworkers, programmer productivity, the monetary value of your time, familiarity, workarounds, why not assembly or GPU, etc...), which may be more important than performance.</source>
          <target state="translated">Программы также будут работать медленнее на компьютере с частотой 500 МГц по сравнению с 2 ГГц.На самом деле мы не рассматриваем это как часть ограничений по ресурсам,потому что мы думаем о масштабировании с точки зрения машинных ресурсов (например,за тактовый цикл),а не за реальную секунду.Однако есть подобные вещи,которые могут &quot;втайне&quot; влиять на производительность,например,работаете ли вы под эмуляцией,или компилятор оптимизировал код или нет.Это может заставить некоторые базовые операции занять больше времени (даже относительно друг друга),или даже ускорить или замедлить некоторые операции асимптотически (даже относительно друг друга).Эффект может быть как малым,так и большим между разными средами реализации и окружением.Переключаете ли вы языки или машины для выполнения такой небольшой дополнительной работы? Это зависит от сотни других причин (необходимость,навыки,коллеги,производительность программиста,денежная стоимость вашего времени,знакомство,обходные пути,почему бы не собрать или GPU и т.д....),которые могут быть более важными,чем производительность.</target>
        </trans-unit>
        <trans-unit id="0d31501e03db9492d0d452e6624c95d2a7fc34fc" translate="yes" xml:space="preserve">
          <source>Put another way, it's all about the &lt;strong&gt;ratio&lt;/strong&gt; as you go to infinity. &lt;em&gt;If you divide the actual time it takes by the &lt;code&gt;O(...)&lt;/code&gt;, you will get a constant factor in the limit of large inputs.&lt;/em&gt; Intuitively this makes sense: functions &quot;scale like&quot; one another if you can multiply one to get the other. That is when we say...</source>
          <target state="translated">Другими словами, все зависит от &lt;strong&gt;отношения&lt;/strong&gt; к бесконечности. &lt;em&gt;Если вы разделите фактическое время, которое требуется на &lt;code&gt;O(...)&lt;/code&gt; , вы получите постоянный коэффициент в пределе больших входов.&lt;/em&gt; Интуитивно это имеет смысл: функции &amp;laquo;масштабируются как&amp;raquo; друг друга, если вы можете умножить одну, чтобы получить другую. Вот когда мы говорим ...</target>
        </trans-unit>
        <trans-unit id="b123240c4cc86a314f0b2ff2c7fcffe4a190bdd3" translate="yes" xml:space="preserve">
          <source>Putting everything in an airing cupboard: If we put everything in one big pile and just let general warmth do it, it will take a long time for the middle shirts to get dry. I wouldn't like to guess at the detail, but I suspect this is at least O(N^2) &amp;mdash; as you increase the wash load, the drying time increases faster.</source>
          <target state="translated">Помещение всего в сушильный шкаф: если мы сложим все в одну большую кучу и просто позволим общему теплу сделать это, то для средних рубашек потребуется много времени, чтобы высохнуть. Я не хотел бы угадывать детали, но я подозреваю, что это по крайней мере O (N ^ 2) - когда вы увеличиваете загрузку, время сушки увеличивается быстрее.</target>
        </trans-unit>
        <trans-unit id="44d6998253d7ce7630dea94f49784bcc34a98b86" translate="yes" xml:space="preserve">
          <source>Quick Sort breaks up big decks in small ones.  That is to say, it breaks up big tasks in small ones.</source>
          <target state="translated">Quick Sort разбивает большие палубы на маленькие.То есть,разбивает большие задачи на маленькие.</target>
        </trans-unit>
        <trans-unit id="aafbf15c3d2cb24c90abf21327172d843932cd8c" translate="yes" xml:space="preserve">
          <source>Quick note, this is almost certainly confusing &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; (which is an upper bound) with Theta notation &quot;&amp;Theta;&quot; (which is a two-side bound). In my experience, this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</source>
          <target state="translated">Быстрое замечание, это почти наверняка путает &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;нотацию Большого О&lt;/a&gt; (которая является верхней границей) с нотацией Тета &quot;&amp;Theta;&quot; (которая является двухсторонней границей). По моему опыту, это на самом деле типично для дискуссий в неакадемических условиях. Извиняюсь за путаницу.</target>
        </trans-unit>
        <trans-unit id="78240c3b95a799ddc676899ee3f052157355ad48" translate="yes" xml:space="preserve">
          <source>Resource : Could be total-CPU time, could be maximum RAM space. By default refers to CPU time.</source>
          <target state="translated">Ресурс:Может быть общее время КПУ,может быть максимальное пространство оперативной памяти.По умолчанию относится к процессорному времени.</target>
        </trans-unit>
        <trans-unit id="ac86f485121aebe3e0cdccd29ad1f58c3d7af9cc" translate="yes" xml:space="preserve">
          <source>Say the problem is &quot;Find the Combination&quot;,</source>
          <target state="translated">Скажите,что проблема в &quot;Найти комбинацию&quot;,</target>
        </trans-unit>
        <trans-unit id="a93e27c51787651f155cd14f8a574fade12b6fb2" translate="yes" xml:space="preserve">
          <source>Say the problem is &quot;Find the sum&quot;,</source>
          <target state="translated">Скажем,проблема в &quot;Найти сумму&quot;,</target>
        </trans-unit>
        <trans-unit id="a090d13ccede8e7fd94f3cd08042cf4d8572f583" translate="yes" xml:space="preserve">
          <source>Say you order Harry Potter: Complete 8-Film Collection [Blu-ray] from Amazon and download the same film collection online at the same time. You want to test which method is faster. The delivery takes almost a day to arrive and the download completed about 30 minutes earlier. Great! So it&amp;rsquo;s a tight race.</source>
          <target state="translated">Скажем, вы заказываете &amp;laquo;Гарри Поттер: полная коллекция из 8 фильмов [Blu-ray]&amp;raquo; от Amazon и одновременно скачиваете ту же коллекцию фильмов онлайн. Вы хотите проверить, какой метод быстрее. Доставка занимает почти день, а загрузка завершена примерно на 30 минут раньше. Большой! Так что это жесткая гонка.</target>
        </trans-unit>
        <trans-unit id="7c15a59b277cd7091e5fcf18a82064b3a5dd08e6" translate="yes" xml:space="preserve">
          <source>See more at: &lt;a href=&quot;http://proprogramming.org/2015/01/how-to-calculate-time-complexity-of.html#sthash.URrGFhqm.dpuf&quot;&gt;Here&lt;/a&gt;</source>
          <target state="translated">Смотрите больше на: &lt;a href=&quot;http://proprogramming.org/2015/01/how-to-calculate-time-complexity-of.html#sthash.URrGFhqm.dpuf&quot;&gt;Здесь&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1401abdd96246a6a7cc788610b57a7b896aa0b20" translate="yes" xml:space="preserve">
          <source>See the pattern?  The &lt;strong&gt;complexity&lt;/strong&gt; (being the number of operations) is directly proportional to the number of digits &lt;em&gt;n&lt;/em&gt; in the larger number.  We call this &lt;strong&gt;O(n)&lt;/strong&gt; or &lt;strong&gt;linear complexity&lt;/strong&gt;.</source>
          <target state="translated">Видишь шаблон? &lt;strong&gt;Сложность&lt;/strong&gt; (количество операций) прямо пропорциональна количеству цифр &lt;em&gt;n&lt;/em&gt; в большем числе. Мы называем это &lt;strong&gt;O (n)&lt;/strong&gt; или &lt;strong&gt;линейной сложностью&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7bb8c396c1b1d4188f90d674eebb67f47ab45d2b" translate="yes" xml:space="preserve">
          <source>Since Big-O doesn't care too much about constant factor (aka 3), the Big-O of your algorithm is &lt;code&gt;O(N^2 + log(X))&lt;/code&gt;. It basically translates 'the amount of operations your algorithm needs for the worst case scales with this'.</source>
          <target state="translated">Поскольку Big-O не слишком заботится о постоянном множителе (он же 3), Big-O вашего алгоритма - это &lt;code&gt;O(N^2 + log(X))&lt;/code&gt; . Это в основном переводит &amp;laquo;количество операций, которое требуется вашему алгоритму для наихудшего случая, масштабируемого этим&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="185fbeb7236225913f02d9ced51afffe91dadcbe" translate="yes" xml:space="preserve">
          <source>So here is the big news: the big O can help me not to do work!  I can play more of the time, if I know big O.  Less work, more play!  That is what big O helps me do.</source>
          <target state="translated">Итак,вот главная новость:большой О может помочь мне не делать работу! Я могу играть больше времени,если знаю большого О.Меньше работы,больше игры! Вот что большое О помогает мне делать.</target>
        </trans-unit>
        <trans-unit id="f282cf5ef96e90a6a7f9b1e3944e8a0596d69aa5" translate="yes" xml:space="preserve">
          <source>So if you want to find a name in a phone book of a million names you can actually find any name by doing this at most 20 times.  In comparing search algorithms we decide that this comparison is our 'n'.</source>
          <target state="translated">Таким образом,если вы хотите найти имя в телефонной книге с миллионом имен,вы можете найти любое имя,сделав это максимум 20 раз.Сравнивая алгоритмы поиска,мы решаем,что это сравнение-наше 'n'.</target>
        </trans-unit>
        <trans-unit id="54d9d5007b7529ef62839a976a2c108028d8927a" translate="yes" xml:space="preserve">
          <source>So let's not do the work.  Let's you and me just think how hard it is.  How much work would I have to do, to add six numbers?</source>
          <target state="translated">Так что давай не будем работать.Давай просто подумаем,как это тяжело.Сколько работы мне придется сделать,чтобы добавить шесть чисел?</target>
        </trans-unit>
        <trans-unit id="0f7963f5bf0d662a36fd7990d2218173d00f1e7f" translate="yes" xml:space="preserve">
          <source>So the Big-O of the Traveling Salesman problem is &lt;strong&gt;O(n!)&lt;/strong&gt; or &lt;strong&gt;factorial or combinatorial complexity&lt;/strong&gt;.</source>
          <target state="translated">Таким образом, главная проблема задачи коммивояжера - это &lt;strong&gt;O (n!)&lt;/strong&gt; Или &lt;strong&gt;факторная или комбинаторная сложность&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="31cbba1dd119c95cd531f79932736280f8bc1df4" translate="yes" xml:space="preserve">
          <source>So then you might understand what &quot;n&lt;sup&gt;2&lt;/sup&gt;&quot; means, but to be even more specific, play with the thought you have a simple, the simpliest of the sorting algorithms; bubblesort. This algorithm needs to look through the whole list, for each item.</source>
          <target state="translated">Таким образом, вы можете понять, что означает &amp;laquo;n &lt;sup&gt;2&lt;/sup&gt; &amp;raquo;, но чтобы быть еще более конкретным, поиграйте с мыслью, что у вас есть простой, самый простой из алгоритмов сортировки; BubbleSort. Этот алгоритм должен просматривать весь список для каждого элемента.</target>
        </trans-unit>
        <trans-unit id="f8d83ca9666fef6b181abee5dce4073e31010f19" translate="yes" xml:space="preserve">
          <source>So to find a name given the phone number (reverse lookup):</source>
          <target state="translated">Итак,чтобы найти имя с указанием номера телефона (обратный поиск):</target>
        </trans-unit>
        <trans-unit id="d9f1ae7f841915d3f4dd37e4ec3ed8f5c6a2d975" translate="yes" xml:space="preserve">
          <source>So to talk of big O, I will use words that have just one beat in them.  One sound per word.  Small words are quick.  You know these words, and so do I.  We will use words with one sound.  They are small.  I am sure you will know all of the words we will use!</source>
          <target state="translated">Так что,чтобы поговорить о большой &quot;О&quot;,я буду использовать слова,в которых есть только один удар.Один звук на слово.Маленькие слова-это быстро.Ты знаешь эти слова,и я тоже.Мы будем использовать слова с одним звуком.Они маленькие.Я уверен,что ты знаешь все слова,которые мы будем использовать!</target>
        </trans-unit>
        <trans-unit id="1a6bae9cafba4af7ae15b7b23952da6ff1ac18ed" translate="yes" xml:space="preserve">
          <source>Some asymptotically superior algorithms (e.g. a non-comparison &lt;code&gt;O(N log(log(N)))&lt;/code&gt; sort) can have so large a constant factor (e.g. &lt;code&gt;100000*N log(log(N))&lt;/code&gt;), or overhead that is relatively large like &lt;code&gt;O(N log(log(N)))&lt;/code&gt; with a hidden &lt;code&gt;+ 100*N&lt;/code&gt;, that they are rarely worth using even on &quot;big data&quot;.</source>
          <target state="translated">Некоторые асимптотически превосходящие алгоритмы (например, сортировка без сравнения &lt;code&gt;O(N log(log(N)))&lt;/code&gt; ) могут иметь такой большой постоянный коэффициент (например, &lt;code&gt;100000*N log(log(N))&lt;/code&gt; ) или относительно большие издержки как &lt;code&gt;O(N log(log(N)))&lt;/code&gt; со скрытыми &lt;code&gt;+ 100*N&lt;/code&gt; , которые их редко стоит использовать даже для &amp;laquo;больших данных&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="6c3a47a93192e21e7b8da9213efad49591e03019" translate="yes" xml:space="preserve">
          <source>Something to think about.</source>
          <target state="translated">Есть о чем подумать.</target>
        </trans-unit>
        <trans-unit id="4039fdaf71cb4809949b869888d7b88d6c807b40" translate="yes" xml:space="preserve">
          <source>Sounds simple?  Think again.</source>
          <target state="translated">Звучит просто? Подумай еще раз.</target>
        </trans-unit>
        <trans-unit id="3b9b41baa4e75cb4e6d6c6fd70132096551ccfd4" translate="yes" xml:space="preserve">
          <source>Subtraction is similar (except you may need to borrow instead of carry).</source>
          <target state="translated">Вычитание аналогично (за исключением того,что вам может понадобиться одолжить вместо того,чтобы носить с собой).</target>
        </trans-unit>
        <trans-unit id="92cba8f42714e9e6f65905758a187f5dc1f81125" translate="yes" xml:space="preserve">
          <source>Such a beautifully simple and short question seems at least to deserve an equally short answer, like a student might receive during tutoring.</source>
          <target state="translated">Такой красиво простой и короткий вопрос кажется,по крайней мере,заслуживает такого же короткого ответа,как и вопрос,который может быть получен студентом во время репетиторства.</target>
        </trans-unit>
        <trans-unit id="3c2db9ddb042cb95f6f3da33f58156282aae57f5" translate="yes" xml:space="preserve">
          <source>Suppose</source>
          <target state="translated">Suppose</target>
        </trans-unit>
        <trans-unit id="6497864fec97aa054dc0495fd9cf472b076841fc" translate="yes" xml:space="preserve">
          <source>Suppose you get notation &lt;code&gt;O(N^2)&lt;/code&gt;, not only you are clear the method takes N*N steps to accomplish a task, also you see that it's not good as &lt;code&gt;O(NlogN)&lt;/code&gt; from its ranking.</source>
          <target state="translated">Предположим, вы получили обозначение &lt;code&gt;O(N^2)&lt;/code&gt; , не только вы уверены, что метод выполняет N * N шагов для выполнения задачи, но также вы видите, что он не так хорош, как &lt;code&gt;O(NlogN)&lt;/code&gt; из своего ранжирования.</target>
        </trans-unit>
        <trans-unit id="b05781eb417d58d8870e0c54b7d3d4450a3c5cf7" translate="yes" xml:space="preserve">
          <source>T(n)= The actual function that expresses the running time of the algorithm as a function of n</source>
          <target state="translated">T(n)=Фактическая функция,которая выражает время работы алгоритма как функцию n</target>
        </trans-unit>
        <trans-unit id="223cc76142198af8e0fb0a088ef6eb8d1fdff9c7" translate="yes" xml:space="preserve">
          <source>Take this to 4 towns and you have (iirc) 12 possibilities.</source>
          <target state="translated">Отнесите это в 4 города и у вас будет (iirc)12 возможностей.</target>
        </trans-unit>
        <trans-unit id="6717a00806c940ae11e172679a7461df17fb3524" translate="yes" xml:space="preserve">
          <source>That is staggeringly good isn't it?</source>
          <target state="translated">Это ошеломляюще хорошо,не так ли?</target>
        </trans-unit>
        <trans-unit id="2b3ca8fd4b8fd6b2746880e61409e1fcd178be5c" translate="yes" xml:space="preserve">
          <source>That's the gist of it. They reduce the maths down so it might not be exactly n&lt;sup&gt;2&lt;/sup&gt; or whatever they say it is, but that'll be the dominating factor in the scaling.</source>
          <target state="translated">Это суть этого. Они уменьшают математику, так что это может быть не ровно n &lt;sup&gt;2&lt;/sup&gt; или что они там говорят, но это будет доминирующим фактором в масштабировании.</target>
        </trans-unit>
        <trans-unit id="a335b2fdf194a4b123c6adefad53cd69da1191ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&lt;/code&gt; notation might be the more common one and is even used in papers by world-renowned computer scientists. Additionally, it is often the case that in a casual setting, people will say &lt;code&gt;O(...)&lt;/code&gt; when they mean &lt;code&gt;Ɵ(...)&lt;/code&gt;; this is technically true since the set of things &lt;code&gt;Ɵ(exactlyThis)&lt;/code&gt; is a subset of &lt;code&gt;O(noGreaterThanThis)&lt;/code&gt;... and it's easier to type. ;-)</source>
          <target state="translated">Обозначение &lt;code&gt;=&lt;/code&gt; может быть более распространенным и даже используется в работах всемирно известных компьютерных ученых. Кроме того, часто случается, что в случайной обстановке люди говорят &lt;code&gt;O(...)&lt;/code&gt; когда они имеют в виду &lt;code&gt;Ɵ(...)&lt;/code&gt; ; это технически верно, поскольку множество вещей &lt;code&gt;Ɵ(exactlyThis)&lt;/code&gt; является подмножеством &lt;code&gt;O(noGreaterThanThis)&lt;/code&gt; ... и его легче набирать. ;-)</target>
        </trans-unit>
        <trans-unit id="aee94d96800326a2e37c8dd00dc11f09cbb047c7" translate="yes" xml:space="preserve">
          <source>The O in &quot;Big O&quot; refers to as &quot;Order&quot;(or precisely &quot;order of&quot;)</source>
          <target state="translated">О в &quot;Большой О&quot; означает &quot;Порядок&quot; (или точно &quot;порядок&quot;).</target>
        </trans-unit>
        <trans-unit id="bc4389e9f64069d428331282297c6e278a98864d" translate="yes" xml:space="preserve">
          <source>The Telephone Book</source>
          <target state="translated">Телефонная книга</target>
        </trans-unit>
        <trans-unit id="8cb03116d21f7000400f4bb7814a757a5f5a7de1" translate="yes" xml:space="preserve">
          <source>The Traveling Salesman</source>
          <target state="translated">Путешествующий продавец</target>
        </trans-unit>
        <trans-unit id="72a9a665cf2e8f84b6ab25450c58c79f3d3908aa" translate="yes" xml:space="preserve">
          <source>The above issues, like the effect of the choice of which programming language is used, are almost never considered as part of the constant factor (nor should they be); yet one should be aware of them because &lt;em&gt;sometimes&lt;/em&gt; (though rarely) they may affect things. For example in cpython, the native priority queue implementation is asymptotically non-optimal (&lt;code&gt;O(log(N))&lt;/code&gt; rather than &lt;code&gt;O(1)&lt;/code&gt; for your choice of insertion or find-min); do you use another implementation? Probably not, since the C implementation is probably faster, and there are probably other similar issues elsewhere. There are tradeoffs; sometimes they matter and sometimes they don't.</source>
          <target state="translated">Вышеуказанные проблемы, такие как влияние выбора языка программирования, почти никогда не рассматриваются как часть постоянного фактора (и не должны); все же нужно знать о них, потому что &lt;em&gt;иногда&lt;/em&gt; (хотя редко) они могут влиять на вещи. Например, в cpython реализация очереди с собственным приоритетом асимптотически неоптимальна ( &lt;code&gt;O(log(N))&lt;/code&gt; а не &lt;code&gt;O(1)&lt;/code&gt; для выбора вставки или find-min); Вы используете другую реализацию? Вероятно, нет, так как реализация C, вероятно, быстрее, и, возможно, есть другие подобные проблемы в других местах. Есть компромиссы; иногда они имеют значение, а иногда нет.</target>
        </trans-unit>
        <trans-unit id="a92aef1bcf2b613748cc674288c56712f50682e2" translate="yes" xml:space="preserve">
          <source>The above statement is a good start but not completely true.</source>
          <target state="translated">Вышеприведенное утверждение является хорошим началом,но не совсем верно.</target>
        </trans-unit>
        <trans-unit id="af10522e397a98644d31608e45e48cac65ff2486" translate="yes" xml:space="preserve">
          <source>The analogy for amortized analysis:</source>
          <target state="translated">Аналогия для анализа амортизации:</target>
        </trans-unit>
        <trans-unit id="fccd0576a93e2738b676fa9e76398601f6ab71b0" translate="yes" xml:space="preserve">
          <source>The astute may have realized that we could express the number of operations as: n&lt;sup&gt;2&lt;/sup&gt; + 2n.  But as you saw from our example with two numbers of a million digits apiece, the second term (2n) becomes insignificant (accounting for 0.0002% of the total operations by that stage).</source>
          <target state="translated">Проницательный, возможно, понял, что мы могли бы выразить количество операций как: n &lt;sup&gt;2&lt;/sup&gt; + 2n. Но, как вы видели из нашего примера с двумя числами в миллион цифр за штуку, второе слагаемое (2n) становится незначительным (составляя 0,0002% от общего числа операций на этом этапе).</target>
        </trans-unit>
        <trans-unit id="11fa8c026f804b110c22f62945ac720ce5e2b7ce" translate="yes" xml:space="preserve">
          <source>The bad:</source>
          <target state="translated">Плохие:</target>
        </trans-unit>
        <trans-unit id="8b80f48d4022e94ff91f1dba565c167cfe545120" translate="yes" xml:space="preserve">
          <source>The basics: Whenever we interact with every element in a collection of size A (such as an array, a set, all keys of a map, etc.), or perform A iterations of a loop, that is a multiplicative factor of size A. Why do I say &quot;a multiplicative factor&quot;?--because loops and functions (almost by definition) have multiplicative running time: the number of iterations, times work done in the loop (or for functions: the number of times you call the function, times work done in the function). (This holds if we don't do anything fancy, like skip loops or exit the loop early, or change control flow in the function based on arguments, which is very common.) Here are some examples of visualization techniques, with accompanying pseudocode.</source>
          <target state="translated">Основы:Всякий раз,когда мы взаимодействуем с каждым элементом коллекции размера A (таким как массив,набор,все ключи карты и т.д.),или выполняем A итераций цикла,то есть мультипликативный фактор размера A.Почему я говорю &quot;мультипликативный фактор&quot;,потому что циклы и функции (почти по определению)имеют мультипликативное время выполнения:количество итераций,время выполнения в цикле (или для функций:количество вызовов функции,время выполнения в функции).(Это происходит,если мы не делаем ничего причудливого,например,пропускаем циклы или выходим из них раньше,или изменяем поток управления в функции на основе аргументов,что очень часто встречается).Вот несколько примеров техник визуализации с сопутствующим псевдокодом.</target>
        </trans-unit>
        <trans-unit id="1ed7c47cc1915e8456623ae236c31623cd7a6dd2" translate="yes" xml:space="preserve">
          <source>The best example of Big-O I can think of is doing arithmetic.  Take two numbers (123456 and 789012).  The basic arithmetic operations we learnt in school were:</source>
          <target state="translated">Лучший пример Большого О,о котором я могу подумать,это арифметика.Возьмите два числа (123456 и 789012).Основные арифметические операции,которым мы научились в школе:</target>
        </trans-unit>
        <trans-unit id="6ae878297661e38f79a2d80036a322346800b990" translate="yes" xml:space="preserve">
          <source>The cost of solving the problem is proportional to the size of the problem.  If your problem doubles in size, then the cost of the solution doubles.  Since most problems have to be scanned into the computer in some way, as data entry, disk reads, or network traffic, this is generally an affordable scaling factor.</source>
          <target state="translated">Стоимость решения задачи пропорциональна ее размеру.Если Ваша задача удваивается,то стоимость решения удваивается.Поскольку большинство проблем нужно каким-то образом сканировать в компьютере,как ввод данных,чтение с диска или сетевой трафик,это,как правило,доступный коэффициент масштабирования.</target>
        </trans-unit>
        <trans-unit id="edbb1eb4311e72da0d8581264edd414e194f9ea0" translate="yes" xml:space="preserve">
          <source>The equation is read as 
As n approaches infinity, T of n, is less than or equal to c times f of n.</source>
          <target state="translated">Уравнение читается так,как n приближается к бесконечности,T из n,меньше или равно c умножить на f из n.</target>
        </trans-unit>
        <trans-unit id="7696e2ee0fe03e7287025d1b9b1e590710edef6e" translate="yes" xml:space="preserve">
          <source>The first sort was O(n squared).  But Quick Sort is O(n log n).  You know that n log n is less than n squared, for big n, right?  Well, that is how we know that Quick Sort is fast!</source>
          <target state="translated">Первый сорт был O(n в квадрате).Но Quick Sort-это O(n log n).Вы ведь знаете,что n log n меньше,чем n в квадрате,для большого n,верно? Вот откуда мы знаем,что быстрая сортировка быстрая!</target>
        </trans-unit>
        <trans-unit id="ef63c6ddf6e7a7898b093aa5fa501850b023edae" translate="yes" xml:space="preserve">
          <source>The flow here would be:</source>
          <target state="translated">Поток здесь был бы:</target>
        </trans-unit>
        <trans-unit id="d7c2775507fbff85fd208fcd7a9eefd861c88ccd" translate="yes" xml:space="preserve">
          <source>The good:</source>
          <target state="translated">Хорошо:</target>
        </trans-unit>
        <trans-unit id="40776bd664da80434dcafa973f539de3f9f745d5" translate="yes" xml:space="preserve">
          <source>The input size is usually the space in bits needed to represent the input.</source>
          <target state="translated">Размер входного сигнала обычно представляет собой пространство в битах,необходимое для представления входного сигнала.</target>
        </trans-unit>
        <trans-unit id="d1b781877a2eef3021049a9a0ec22cac469bc50c" translate="yes" xml:space="preserve">
          <source>The moral of the story: a data structure lets us speed up operations. Even more, advanced data structures can let you combine, delay, or even ignore operations in incredibly clever ways. Different problems would have different analogies, but they'd all involve organizing the data in a way that exploits some structure we care about, or which we've artificially imposed on it for bookkeeping. We do work ahead of time (basically planning and organizing), and now repeated tasks are much much easier!</source>
          <target state="translated">Мораль истории:структура данных позволяет ускорить операции.Более того,усовершенствованные структуры данных позволяют комбинировать,задерживать или даже игнорировать операции невероятно умными способами.Различные проблемы будут иметь разные аналогии,но все они будут связаны с организацией данных таким образом,чтобы эксплуатировать какую-то структуру,которая нам небезразлична,или которую мы искусственно навязываем для ведения бухгалтерского учета.Мы делаем работу на опережение (в основном планирование и организация),и теперь повторяющиеся задачи намного проще!</target>
        </trans-unit>
        <trans-unit id="431150559f3afdb40719059de8cafc2364a6f27a" translate="yes" xml:space="preserve">
          <source>The new work is: add all things from one to n.</source>
          <target state="translated">Новая работа:добавить все вещи от одного до n.</target>
        </trans-unit>
        <trans-unit id="9734a1f2bb99a793e146aed547eba3d5bde616de" translate="yes" xml:space="preserve">
          <source>The next best example I can think of is the telephone book, normally called the White Pages or similar but it varies from country to country.  But I'm talking about the one that lists people by surname and then initials or first name, possibly address and then telephone numbers.</source>
          <target state="translated">Следующий лучший пример,который я могу придумать,это телефонная книга,обычно называемая &quot;Белые страницы&quot; или что-то в этом роде,но она отличается от страны к стране.Но я говорю о том,который содержит список людей по фамилии,а затем инициалы или имя,возможно,адрес,а затем телефонные номера.</target>
        </trans-unit>
        <trans-unit id="30a4b2c863fa4772ef38b8845a347878d2aa00fa" translate="yes" xml:space="preserve">
          <source>The number of computations is only increased by a log of the input value.  So in this case, assuming each computation takes 1 second, the log of the input &lt;code&gt;n&lt;/code&gt; is the time required, hence &lt;code&gt;log n&lt;/code&gt;.</source>
          <target state="translated">Количество вычислений увеличивается только путем записи входного значения. Таким образом, в этом случае, предполагая, что каждое вычисление занимает 1 секунду, журнал ввода &lt;code&gt;n&lt;/code&gt; - это требуемое время, следовательно, &lt;code&gt;log n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3aad895641cfd48567e63f48472fae12fcf69c0b" translate="yes" xml:space="preserve">
          <source>The number of items is still increasing by a factor of 10, but the scaling factor of O(1) is always 1.</source>
          <target state="translated">Количество элементов все еще увеличивается в 10 раз,но масштабный коэффициент O(1)всегда равен 1.</target>
        </trans-unit>
        <trans-unit id="4e86a40dc1403a10780f816da6e77341ee5ea1e5" translate="yes" xml:space="preserve">
          <source>The only thing that these &quot;Big-Oh&quot; expressions try to do is to describe how much the software slows down as we increase the amount of data that the software has to process. If we double the amount of data that needs to be processed, does the software need twice as long to finish it's work? Ten times as long? In practice, there are a very limited number of big-Oh expressions that you will encounter and need to worry about:</source>
          <target state="translated">Единственное,что пытаются сделать эти выражения &quot;Big-Oh&quot;,это описать,как сильно программное обеспечение замедляется по мере того,как мы увеличиваем объем данных,которые программное обеспечение должно обрабатывать.Если мы удвоим объем данных,которые должны быть обработаны,нужно ли программе вдвое больше времени,чтобы закончить свою работу? В десять раз дольше? На практике существует очень ограниченное количество больших-Ох выражений,с которыми вы столкнетесь и о которых вам придется беспокоиться:</target>
        </trans-unit>
        <trans-unit id="0c4ac6494f1b66e30eda83ca592154e03a3a8fc2" translate="yes" xml:space="preserve">
          <source>The same can be said for the &lt;strong&gt;very act of writing&lt;/strong&gt;. All algorithms which print out N things will take N time because the output is at least that long (e.g. printing out all permutations (ways to rearrange) a set of N playing cards is factorial: &lt;code&gt;O(N!)&lt;/code&gt;).</source>
          <target state="translated">То же самое можно сказать и о &lt;strong&gt;самом акте письма&lt;/strong&gt; . Все алгоритмы, которые распечатывают N вещей, будут занимать N времени, потому что выходной результат, по крайней мере, такой длинный (например, распечатка всех перестановок (способов перестановки) набора из N игральных карт является факториальной: &lt;code&gt;O(N!)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf763b5c77d1eaec2bb764fe4187dc0b86926fc4" translate="yes" xml:space="preserve">
          <source>The simplest definition I can give for Big-O notation is this:</source>
          <target state="translated">Самое простое определение,которое я могу дать для нотации Big-O,это следующее:</target>
        </trans-unit>
        <trans-unit id="9316c2f2fa69e85df7f06354c94d1417cfb91787" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;O( &amp;lt;some expression X involving n&amp;gt; )&lt;/code&gt; means, in simple English:</source>
          <target state="translated">Тогда &lt;code&gt;O( &amp;lt;some expression X involving n&amp;gt; )&lt;/code&gt; означает на простом английском языке:</target>
        </trans-unit>
        <trans-unit id="8d780e455cede763fea2fd15a77afe9241e0ac7a" translate="yes" xml:space="preserve">
          <source>Then as far as Big O is concerned, the approximation f(n) is considered good enough as long as the below condition is true.</source>
          <target state="translated">Тогда,что касается Большого О,приближение f(n)считается достаточно хорошим,если нижеприведенное условие верно.</target>
        </trans-unit>
        <trans-unit id="ee898084770160432d4052d1b6366394874b74dc" translate="yes" xml:space="preserve">
          <source>There are many choices of constant; often the &quot;best&quot; choice is known as the &quot;constant factor&quot; of the algorithm... but we often ignore it like we ignore non-largest terms (see Constant Factors section for why they don't usually matter). You can also think of the above equation as a bound, saying &quot;&lt;em&gt;In the worst-case scenario, the time it takes will never be worse than roughly &lt;code&gt;N*log(N)&lt;/code&gt;, within a factor of 2.5 (a constant factor we don't care much about)&lt;/em&gt;&quot;.</source>
          <target state="translated">Есть много вариантов констант; часто &amp;laquo;лучший&amp;raquo; выбор известен как &amp;laquo;постоянный фактор&amp;raquo; алгоритма ... но мы часто игнорируем его, как игнорируем не самые большие термины (см. раздел &amp;laquo;Постоянные факторы&amp;raquo;, почему они обычно не имеют значения). Вы также можете думать о приведенном выше уравнении как о границе, говоря: &amp;laquo; &lt;em&gt;В худшем случае время, которое оно занимает, никогда не будет хуже, чем примерно &lt;code&gt;N*log(N)&lt;/code&gt; , с коэффициентом 2,5 (постоянный фактор, который мы не не волнует)&lt;/em&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="f3b28edc57f1a5b8e2ff6393649371701cff785f" translate="yes" xml:space="preserve">
          <source>There are some important and deliberately chosen words in that sentence:</source>
          <target state="translated">В этом предложении есть несколько важных и намеренно выбранных слов:</target>
        </trans-unit>
        <trans-unit id="735800377cfb894185f412511981fdfbdcaa94c0" translate="yes" xml:space="preserve">
          <source>There is a lot of information that Big O does not tell you about a given algorithm. It cuts to the bone and gives only information about the scaling nature of an algorithm, specifically how the resource use (think time or memory) of an algorithm scales in response to the &quot;input size&quot;.</source>
          <target state="translated">Есть много информации,которую Большой О не рассказывает о данном алгоритме.Он режет до костей и дает только информацию о масштабирующем характере алгоритма,а именно о том,как масштабируется использование ресурса (думаю,времени или памяти)алгоритма в ответ на &quot;входной размер&quot;.</target>
        </trans-unit>
        <trans-unit id="7dc156313731adb22242f60a31c42c25a7fac861" translate="yes" xml:space="preserve">
          <source>There is also the concept of &quot;amortized&quot; and/or &quot;average case&quot; (note that these are different).</source>
          <target state="translated">Существует также понятие &quot;амортизированный&quot; или &quot;средний случай&quot; (обратите внимание,что они разные).</target>
        </trans-unit>
        <trans-unit id="e29aa2b4c76e872003711e1f9ca7f22087d1cd30" translate="yes" xml:space="preserve">
          <source>These are the bread-and-butter orders of growth that programmers and applied computer scientists use as reference points. They see these all the time. (So while you could technically think &quot;Doubling the input makes an O(&amp;radic;N) algorithm 1.414 times slower,&quot; it's better to think of it as &quot;this is worse than logarithmic but better than linear&quot;.)</source>
          <target state="translated">Это все те порядки роста, которые программисты и прикладные компьютерные ученые используют в качестве ориентиров. Они видят это все время. (Таким образом, хотя вы могли бы технически подумать: &amp;laquo;Удвоение ввода делает алгоритм O (&amp;radic;N) в 1,414 раз медленнее&amp;raquo;, лучше думать об этом как &amp;laquo;это хуже, чем логарифмический, но лучше, чем линейный&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="337e7f754779241ba422c3ed16228e880e17fea7" translate="yes" xml:space="preserve">
          <source>They gave us a deck of ten cards.  They are all mixed up: seven, four, two, six&amp;hellip; not straight at all.  And now... our job is to sort them.</source>
          <target state="translated">Они дали нам колоду из десяти карт. Они все перепутаны: семь, четыре, два, шесть&amp;hellip; совсем не прямые. А теперь ... наша работа - сортировать их.</target>
        </trans-unit>
        <trans-unit id="8a4cba2479bcff691f23bf7a823abac5f2bfc677" translate="yes" xml:space="preserve">
          <source>This algorithm search a list, item by item, looking for a key,</source>
          <target state="translated">Этот алгоритм выполняет поиск по списку,пункт за пунктом,поиск ключа,</target>
        </trans-unit>
        <trans-unit id="b5ccab1dbe3c98b30c65b7179a45c56dcba85b06" translate="yes" xml:space="preserve">
          <source>This complexity is the same as &lt;strong&gt;O(1)&lt;/strong&gt; except that it's just a little bit worse.  For all practical purposes, you can consider this as a very large constant scaling.  The difference in work between processing 1 thousand and 1 billion items is only a factor six.</source>
          <target state="translated">Эта сложность такая же, как &lt;strong&gt;O (1),&lt;/strong&gt; за исключением того, что она немного хуже. Для всех практических целей вы можете рассматривать это как очень большое постоянное масштабирование. Разница в работе между обработкой 1 тыс. И 1 млрд. Единиц составляет всего шесть раз.</target>
        </trans-unit>
        <trans-unit id="a8f1f1c12dab816384a465eef99dc533c1871709" translate="yes" xml:space="preserve">
          <source>This complexity is very similar to &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt;.  For all practical purposes, the two are equivalent.  This level of complexity would generally still be considered scalable.  By tweaking assumptions some &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; algorithms can be transformed into &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; algorithms.  For example, bounding the size of keys reduces sorting from &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; to &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt;.</source>
          <target state="translated">Эта сложность очень похожа на &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; . Для всех практических целей, оба являются эквивалентными. Этот уровень сложности обычно считается масштабируемым. Путем изменения предположений некоторые алгоритмы &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; могут быть преобразованы в алгоритмы &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; . Например, ограничение размера ключей уменьшает сортировку с &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; до &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c5691b3f2dea4e40f3c7e1067faf693cc2b99d29" translate="yes" xml:space="preserve">
          <source>This is O n&lt;sup&gt;2&lt;/sup&gt; because, you need to look at all items in the list there are &quot;n&quot; items. For each item, you look at all items once more, for comparing, this is also &quot;n&quot;, so for every item, you look &quot;n&quot; times meaning n*n = n&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">Это O n &lt;sup&gt;2,&lt;/sup&gt; потому что вам нужно просмотреть все элементы в списке, которые содержат &amp;laquo;n&amp;raquo; элементов. Для каждого элемента вы просматриваете все элементы еще раз, для сравнения, это также &amp;laquo;n&amp;raquo;, поэтому для каждого элемента вы смотрите &amp;laquo;n&amp;raquo; раз, означая n * n = n &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="653edd1e3ffbc6849cab3e84f2d2f1adb0553312" translate="yes" xml:space="preserve">
          <source>This is a function of a mathematical operation called a &lt;strong&gt;factorial&lt;/strong&gt;.  Basically:</source>
          <target state="translated">Это функция математической операции, называемой &lt;strong&gt;факториалом&lt;/strong&gt; . В принципе:</target>
        </trans-unit>
        <trans-unit id="68bbac89d75f8c9b12a85ecf9405e267e936bef2" translate="yes" xml:space="preserve">
          <source>This is a very simplified explanation, but I hope it covers most important details.</source>
          <target state="translated">Это очень простое объяснение,но я надеюсь,что оно охватывает самые важные детали.</target>
        </trans-unit>
        <trans-unit id="690e85c5f1f320cb604423824b8a84e4db475373" translate="yes" xml:space="preserve">
          <source>This is called a &lt;strong&gt;binary search&lt;/strong&gt; and is used every day in programming whether you realize it or not.</source>
          <target state="translated">Это называется &lt;strong&gt;бинарным поиском&lt;/strong&gt; и используется каждый день в программировании, понимаете ли вы это или нет.</target>
        </trans-unit>
        <trans-unit id="903158538d58a924a96daad121dc96f748e16115" translate="yes" xml:space="preserve">
          <source>This is quite a famous problem in computer science and deserves a mention.  In this problem you have N towns. Each of those towns is linked to 1 or more other towns by a road of a certain distance. The Traveling Salesman problem is to find the shortest tour that visits every town.</source>
          <target state="translated">Это довольно известная проблема в компьютерной науке и заслуживает упоминания.В этой проблеме у вас N городов.Каждый из этих городов связан с 1 или несколькими другими городами дорогой определенного расстояния.Проблема Путешествия продавца является найти кратчайший тур,который посещает каждый город.</target>
        </trans-unit>
        <trans-unit id="9d90c6f6b5d97d1a3566515111185bfdbbdad847" translate="yes" xml:space="preserve">
          <source>This is read as T of n is in big O of n.</source>
          <target state="translated">Считается,что T из n находится в большой O из n.</target>
        </trans-unit>
        <trans-unit id="581db2374f66d9fecedf4263af206b8b003578d9" translate="yes" xml:space="preserve">
          <source>This lets us make statements like...</source>
          <target state="translated">Это позволяет нам делать такие заявления,как...</target>
        </trans-unit>
        <trans-unit id="4f23f5a057b81398db00b66517d931e311e15ad5" translate="yes" xml:space="preserve">
          <source>This motivates the use of &lt;strong&gt;data structures&lt;/strong&gt;: a data structure requires reading the data only once (usually &lt;code&gt;O(N)&lt;/code&gt; time), plus some arbitrary amount of preprocessing (e.g. &lt;code&gt;O(N)&lt;/code&gt; or &lt;code&gt;O(N log(N))&lt;/code&gt; or &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt;) which we try to keep small. Thereafter, modifying the data structure (insertions/deletions/ etc.) and making queries on the data take very little time, such as &lt;code&gt;O(1)&lt;/code&gt; or &lt;code&gt;O(log(N))&lt;/code&gt;. You then proceed to make a large number of queries! In general, the more work you're willing to do ahead of time, the less work you'll have to do later on.</source>
          <target state="translated">Это мотивирует использование &lt;strong&gt;структур данных&lt;/strong&gt; : &lt;strong&gt;структура&lt;/strong&gt; данных требует считывания данных только один раз (обычно &lt;code&gt;O(N)&lt;/code&gt; время), плюс некоторое произвольное количество предварительной обработки (например, &lt;code&gt;O(N)&lt;/code&gt; или &lt;code&gt;O(N log(N))&lt;/code&gt; или &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; ) которую мы стараемся держать маленьким. После этого изменение структуры данных (вставки / удаления / и т. Д.) И выполнение запросов к данным занимают очень мало времени, например &lt;code&gt;O(1)&lt;/code&gt; или &lt;code&gt;O(log(N))&lt;/code&gt; . Затем вы приступаете к выполнению большого количества запросов! В целом, чем больше работы вы готовы выполнить раньше времени, тем меньше работы вам придется выполнять позже.</target>
        </trans-unit>
        <trans-unit id="4d08321928b5477592d3f3be8d0fbf595ccedfeb" translate="yes" xml:space="preserve">
          <source>This sort is quite quick.  How quick?  Big O tells us: this sort needs O(n log n) work to be done, in the mean case.</source>
          <target state="translated">Это довольно быстро.Насколько быстро? Большой О говорит нам:этот сорт нуждается в O(n log n)работе,в среднем.</target>
        </trans-unit>
        <trans-unit id="efa77e0837d728c026f108a7c6a880857648e39a" translate="yes" xml:space="preserve">
          <source>This time the number of items increases by a factor of 10, and so does the time. n=10 and so O(n)'s scaling factor is 10.</source>
          <target state="translated">На этот раз количество элементов увеличивается в 10 раз,так же как и время.n=10,так что масштабный коэффициент O(n)равен 10.</target>
        </trans-unit>
        <trans-unit id="e6a399976506e2d7ce3f3c1d1884c9c4671f0528" translate="yes" xml:space="preserve">
          <source>This type of algorithm is described as O(log N). The iterative halving
  of data sets described in the binary search example produces a growth
  curve that peaks at the beginning and slowly flattens out as the size
  of the data sets increase e.g. an input data set containing 10 items
  takes one second to complete, a data set containing 100 items takes
  two seconds, and a data set containing 1000 items will take three
  seconds. Doubling the size of the input data set has little effect on
  its growth as after a single iteration of the algorithm the data set
  will be halved and therefore on a par with an input data set half the
  size. This makes algorithms like binary search extremely efficient
  when dealing with large data sets.</source>
          <target state="translated">Этот тип алгоритма описан как O(log N).При итеративном половинном сокращении наборов данных,описанном в примере двоичного поиска,получается кривая роста,которая достигает пика в начале и медленно сглаживается по мере увеличения размера наборов данных,например,набор входных данных,содержащий 10 элементов,занимает одну секунду,набор данных,содержащий 100 элементов,-две секунды,а набор данных,содержащий 1000 элементов,-три секунды.Удвоение размера входного набора данных мало влияет на его рост,так как после одной итерации алгоритма набор данных будет уменьшен вдвое и,следовательно,наравне с набором входных данных-наполовину.Это делает такие алгоритмы,как двоичный поиск,чрезвычайно эффективными при работе с большими наборами данных.</target>
        </trans-unit>
        <trans-unit id="ff64700b92668ef5d8bf1eab2150e242d95be66f" translate="yes" xml:space="preserve">
          <source>Though, if you're &lt;a href=&quot;https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks&quot;&gt;reasonably worried&lt;/a&gt; about an attacker, there are many other algorithmic attack vectors to worry about besides amortization and average-case.)</source>
          <target state="translated">Хотя, если вы &lt;a href=&quot;https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks&quot;&gt;разумно беспокоитесь&lt;/a&gt; о злоумышленнике, есть много других алгоритмических векторов атаки, о которых следует беспокоиться, кроме амортизации и среднего случая.)</target>
        </trans-unit>
        <trans-unit id="7c6809222de67cf731ce03e2166eb7926bfb38c0" translate="yes" xml:space="preserve">
          <source>Three: I go from the end card up, and I look for a card that is more low than the splay card.</source>
          <target state="translated">Три:Я иду от конечной карты,и я ищу карту,которая ниже,чем карта шлейфа.</target>
        </trans-unit>
        <trans-unit id="b5dad2a734641d4c6735ae21c27019cfea0c15e8" translate="yes" xml:space="preserve">
          <source>Time(Best-Case) = 4</source>
          <target state="translated">Время (лучший случай)=4</target>
        </trans-unit>
        <trans-unit id="2f997ae62ba9c69b3cf6edcf0d119e5ddad840f2" translate="yes" xml:space="preserve">
          <source>Time(Worst-Case) = 4n+1</source>
          <target state="translated">Время (в худшем случае)=4n+1</target>
        </trans-unit>
        <trans-unit id="2b30e732d21d07f2640a46e069dde7480df7216e" translate="yes" xml:space="preserve">
          <source>Time: &amp;Omega;(4) = O(1) ~ Instant\Constant</source>
          <target state="translated">Время: &amp;Omega; (4) = O (1) ~ Мгновенное \ Постоянное</target>
        </trans-unit>
        <trans-unit id="8d4bf6a7efc118b94944a2fdcb4199b6b5436673" translate="yes" xml:space="preserve">
          <source>Time: O(4n+1) = O(n) | in Big-O, constants are neglected</source>
          <target state="translated">Время:O(4n+1)=O(n)</target>
        </trans-unit>
        <trans-unit id="78b1d548645a6f4313e845c0d6995f63dbc656ee" translate="yes" xml:space="preserve">
          <source>To add from one to six, that is some work.  But do you see, to add from one to ten, that is more work?</source>
          <target state="translated">Добавить от одного до шести-вот это работа.Но видишь ли ты,добавить от одного до десяти-это больше работы?</target>
        </trans-unit>
        <trans-unit id="2ee6a9060e778ab6f2fbe6d42d7bf3bf75ff7755" translate="yes" xml:space="preserve">
          <source>To me, I think of big O like a big, slow, boss man.  He thinks on work, but he does not do it.  He might say, &quot;That work is quick.&quot;  Or, he might say, &quot;That work is so slow and hard!&quot;  But he does not do the work.  He just looks at the work, and then he tells us how much time it might take.</source>
          <target state="translated">Для меня,я думаю о большом &quot;О&quot;,как о большом,медленном,боссе.Он думает о работе,но не делает этого.Он может сказать:&quot;Эта работа быстрая&quot;.Или он может сказать:&quot;Эта работа такая медленная и тяжелая!&quot; Но он не делает работу.Он просто смотрит на работу,а потом говорит нам,сколько времени это может занять.</target>
        </trans-unit>
        <trans-unit id="5580a107c59a84aea6247983205780ae9a93ffac" translate="yes" xml:space="preserve">
          <source>To say that binary search has a running time of O(logn) is to say that there exists some constant c which you can multiply log(n) by that will always be larger than the running time of binary search.  In this case you will always have some constant factor of log(n) comparisons.</source>
          <target state="translated">Сказать,что двоичный поиск имеет время выполнения O(logn)-это сказать,что существует некоторая константа c,на которую вы можете умножить log(n),что всегда будет больше времени выполнения двоичного поиска.В этом случае у Вас всегда будет некоторый постоянный фактор сравнения log(n).</target>
        </trans-unit>
        <trans-unit id="b4476ee9defb91e4168e19a3dcd129163cca85a4" translate="yes" xml:space="preserve">
          <source>Two: I splay the deck on that card you chose.  What is this splay; how do I splay?  Well, I go from the start card down, one by one, and I look for a card that is more high than the splay card.</source>
          <target state="translated">Второе:я размазываю колоду по карте,которую ты выбрал.Что это за шлейф,как мне шлейфовать? Ну,я иду от стартовой карты вниз,одну за другой,и я ищу карту,которая выше,чем карта-сплей.</target>
        </trans-unit>
        <trans-unit id="7b569bf8286d4c929a479c4976f45922a580f422" translate="yes" xml:space="preserve">
          <source>Uh oh, more work.  Now, let&amp;rsquo;s not do the work.  But, let&amp;rsquo;s make a plan to do it, step by step.</source>
          <target state="translated">О, больше работы. Теперь давайте не будем делать работу. Но давайте составим план, шаг за шагом.</target>
        </trans-unit>
        <trans-unit id="66ec3cb6bc2e6fcaea19ddeb58c0027ecdebce58" translate="yes" xml:space="preserve">
          <source>Unrelatedly but worth mentioning again: If we perform a hash (e.g. a dictionary/hashtable lookup), that is a factor of O(1). That's pretty fast.</source>
          <target state="translated">Не связанная с этим,но заслуживающая повторного упоминания:Если мы выполняем хэш (например,поиск по словарю),то это фактор O(1).Это довольно быстро.</target>
        </trans-unit>
        <trans-unit id="ceb436949ce49c2aad7d40dd4b74113a2a9f4743" translate="yes" xml:space="preserve">
          <source>Using a tumble dryer: you put 10 shirts in each load, and then they're done an hour later. (Ignore the actual numbers here &amp;mdash; they're irrelevant.) So drying 50 shirts takes &lt;em&gt;about&lt;/em&gt; 5 times as long as drying 10 shirts.</source>
          <target state="translated">Использование сушилки для белья: вы кладете по 10 рубашек в каждую загрузку, а затем они заканчиваются через час. (Игнорируйте действительные цифры здесь - они не имеют значения.) Таким образом, сушка 50 рубашек занимает &lt;em&gt;примерно в&lt;/em&gt; 5 раз больше времени, чем сушка 10 рубашек.</target>
        </trans-unit>
        <trans-unit id="c1627c2d9bf38d1a8bf4e6c4db14ba36e137fed7" translate="yes" xml:space="preserve">
          <source>Using a washing line outside: assuming you have an infinitely large back yard, washing dries in O(1) time. However much you have of it, it'll get the same sun and fresh air, so the size doesn't affect the drying time.</source>
          <target state="translated">Использование линии стирки снаружи:если предположить,что у вас бесконечно большой задний двор,стирка высыхает за O(1)время.Сколько бы у вас его ни было,оно будет получать одно и то же солнце и свежий воздух,поэтому размер не влияет на время сушки.</target>
        </trans-unit>
        <trans-unit id="32fee750e2bced1ef4713977d7422997ac4d01b8" translate="yes" xml:space="preserve">
          <source>Usually, we don't care what the specific constant factors are, because they don't affect the way the function grows. For example, two algorithms may both take &lt;code&gt;O(N)&lt;/code&gt; time to complete, but one may be twice as slow as the other. We usually don't care too much unless the factor is very large since optimizing is tricky business ( &lt;a href=&quot;https://stackoverflow.com/questions/385506/when-is-optimisation-premature&quot;&gt;When is optimisation premature?&lt;/a&gt; ); also the mere act of picking an algorithm with a better big-O will often improve performance by orders of magnitude.</source>
          <target state="translated">Обычно нас не волнуют конкретные константные факторы, потому что они не влияют на рост функции. Например, два алгоритма могут занять &lt;code&gt;O(N)&lt;/code&gt; время для завершения, но один может быть в два раза медленнее, чем другой. Мы обычно не слишком заботимся, если фактор не очень велик, так как оптимизация - сложная &lt;a href=&quot;https://stackoverflow.com/questions/385506/when-is-optimisation-premature&quot;&gt;задача&lt;/a&gt; ( когда оптимизация преждевременна? ); Кроме того, простое действие выбора алгоритма с лучшим big-O часто повышает производительность на порядки.</target>
        </trans-unit>
        <trans-unit id="ec6a77a1f38d77785d38e6e7cc1d9af0e804cfa3" translate="yes" xml:space="preserve">
          <source>Very Quick Note:</source>
          <target state="translated">Очень быстро:</target>
        </trans-unit>
        <trans-unit id="6d21f45bec9f10023aec098341e6f6c03c5b13c1" translate="yes" xml:space="preserve">
          <source>Via examples, this helped get the bare basics into my tortoiseshell-like skull, so I think it's a pretty descent 10-minute read to get you headed in the right direction.</source>
          <target state="translated">На примерах,это помогло вбить голые основы в мой череп,похожий на черепашную раковину,так что я думаю,что это довольно 10 минутное чтение,чтобы направить тебя в правильном направлении.</target>
        </trans-unit>
        <trans-unit id="6aab5f5e334f1c425e8cc5c3149d2485a2ab6b43" translate="yes" xml:space="preserve">
          <source>Wait!  What is n?  Did I miss that?  How can I add from one to n if you don&amp;rsquo;t tell me what n is?</source>
          <target state="translated">Подождите! Что это? Я пропустил это? Как я могу добавить от одного к п, если вы не говорите мне, что п?</target>
        </trans-unit>
        <trans-unit id="2f7ade3e8b4a45caea9bbfc55450f4d016746563" translate="yes" xml:space="preserve">
          <source>We are trying to see how the number of input parameters, affects the running time of an algorithm. If the running time of your application is proportional to the number of input parameters, then it is said to be in Big O of n.</source>
          <target state="translated">Мы пытаемся увидеть,как количество входных параметров,влияет на время работы алгоритма.Если время работы вашего приложения пропорционально количеству входных параметров,то говорят,что оно в Big O из n.</target>
        </trans-unit>
        <trans-unit id="d3658b52f527a76c6421772c73ea4511ef27a0b9" translate="yes" xml:space="preserve">
          <source>We can just rearrange this and see it's O(N):</source>
          <target state="translated">Мы можем просто переставить это и увидеть,что это O(N):</target>
        </trans-unit>
        <trans-unit id="a081699494ed4f022754488ece9b2b843bf6728d" translate="yes" xml:space="preserve">
          <source>Well actually there's less than that because some of these are equivalent (A &amp;rarr; B &amp;rarr; C and C &amp;rarr; B &amp;rarr; A are equivalent, for example, because they use the same roads, just in reverse).</source>
          <target state="translated">Ну, на самом деле, это меньше, потому что некоторые из них эквивалентны (A &amp;rarr; B &amp;rarr; C и C &amp;rarr; B &amp;rarr; A эквивалентны, например, потому что они используют одни и те же дороги, только наоборот).</target>
        </trans-unit>
        <trans-unit id="f33910e9a426fbc1a12d1f88603bfdd1d8ca337f" translate="yes" xml:space="preserve">
          <source>Well, I don&amp;rsquo;t know what n is.  I was not told.  Were you?  No?   Oh well.  So we can&amp;rsquo;t do the work.  Whew.</source>
          <target state="translated">Ну, я не знаю, что это такое. Мне не сказали. Были ли вы? Нет? Ну что ж. Поэтому мы не можем делать работу. Уф.</target>
        </trans-unit>
        <trans-unit id="4b2089e7aacf0c6fcb7cbbe9c09999beabffc5dd" translate="yes" xml:space="preserve">
          <source>Well, I guess I would have to do ten adds&amp;hellip; one for each thing from one to ten.  Ten is more than six.  I would have to work that much more to add from one to ten, than one to six!</source>
          <target state="translated">Ну, я думаю, мне нужно сделать десять добавлений ... по одному на каждую вещь от одного до десяти. Десять больше шести. Мне пришлось бы работать намного больше, чтобы добавить от одного до десяти, чем от одного до шести!</target>
        </trans-unit>
        <trans-unit id="448ecbc620762a34ee90c323b9d2af296de94e73" translate="yes" xml:space="preserve">
          <source>Well, I will not do the work to add them now.  But I know how hard it would be.  It would be six adds.</source>
          <target state="translated">Ну,я не буду делать работу,чтобы добавить их сейчас.Но я знаю,как это будет тяжело.Это было бы шесть добавок.</target>
        </trans-unit>
        <trans-unit id="e6092f44041d9afec7369ff2f52755377d43518f" translate="yes" xml:space="preserve">
          <source>Well, how much work would that be, to sort the cards with those rules?</source>
          <target state="translated">Ну,и сколько это будет работы,чтобы сортировать карты по этим правилам?</target>
        </trans-unit>
        <trans-unit id="3a69be1de24839373d5d994ccbcc98a836e1d23b" translate="yes" xml:space="preserve">
          <source>Well, if n gets real big, we do not care what we might add to n or n squared.</source>
          <target state="translated">Ну,если n станет по-настоящему большим,нас не волнует,что мы можем добавить к n или n в квадрате.</target>
        </trans-unit>
        <trans-unit id="2d9059fb09bbdcd3a55d09451a9fcb425e83ec53" translate="yes" xml:space="preserve">
          <source>Well, let&amp;rsquo;s see.  I must add one and two, and then add that to three, and then add that to four&amp;hellip; All in all, I count six adds.  I have to do six adds to solve this.</source>
          <target state="translated">Ну что ж, посмотрим. Я должен добавить один и два, а затем добавить это к трем, а затем добавить это к четырем ... В общем, я считаю шесть добавлений. Я должен сделать шесть добавок, чтобы решить это.</target>
        </trans-unit>
        <trans-unit id="329e7c685300ef2d2b4c47c92157c7ce7ca7c71a" translate="yes" xml:space="preserve">
          <source>Well, what's so wonderful about Big O notation if that's what it does?</source>
          <target state="translated">Ну,что такого чудесного в нотации Big O,если это то,что она делает?</target>
        </trans-unit>
        <trans-unit id="27f2ea453fa647e6745114288459cdbdc09377db" translate="yes" xml:space="preserve">
          <source>Well, you know n squared is n times n.  Now, I get it: n cards checked, up to what might be n times through the deck.  That is two loops, each with n steps.  That is n squared much work to be done.  A lot of work, for sure!</source>
          <target state="translated">Ну,ты знаешь,что n в квадрате-это n раз n.Теперь я понял:n карт проверено,вплоть до того,что может быть n раз в колоде.Это две петли,каждая с n шагами.Это n в квадрате-много работы,которую нужно сделать.Много работы,конечно!</target>
        </trans-unit>
        <trans-unit id="f37e46082d9d7fea2de0995ec35f0ebec2aa85b9" translate="yes" xml:space="preserve">
          <source>What if I order several Blu-ray movies like The Lord of the Rings, Twilight, The Dark Knight Trilogy, etc. and download all the movies online at the same time? This time, the delivery still take a day to complete, but the online download takes 3 days to finish.
For online shopping, the number of purchased item (input) doesn&amp;rsquo;t affect the delivery time. The output is constant. We call this &lt;strong&gt;O(1)&lt;/strong&gt;.</source>
          <target state="translated">Что если я закажу несколько фильмов Blu-ray, таких как &amp;laquo;Властелин колец&amp;raquo;, &amp;laquo;Сумерки&amp;raquo;, &amp;laquo;Трилогия Темного рыцаря&amp;raquo; и т. Д., И загружу все фильмы онлайн одновременно? На этот раз доставка все еще занимает один день, но онлайн-загрузка занимает 3 дня. Для покупок в Интернете количество купленного товара (входной) не влияет на время доставки. Выход постоянный. Мы называем это &lt;strong&gt;O (1)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae3452404f7d023c914234c52fa39dc716c5a20" translate="yes" xml:space="preserve">
          <source>What if you have a phone number and want to find a name?  The police have a reverse phone book but such look-ups are denied to the general public.  Or are they?  Technically you can reverse look-up a number in an ordinary phone book.  How?</source>
          <target state="translated">Что,если у тебя есть номер телефона и ты хочешь найти имя? У полиции есть обратная телефонная книга,но такие поиски запрещены для широкой публики.Или это так? Технически,вы можете найти номер в обычном телефонном справочнике.Как?</target>
        </trans-unit>
        <trans-unit id="373e1d2a10f1cbeda45147e21f05a41927cb80df" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of &amp;ldquo;Big O&amp;rdquo; notation?</source>
          <target state="translated">Что такое простое английское объяснение обозначения &amp;laquo;Big O&amp;raquo;?</target>
        </trans-unit>
        <trans-unit id="05e7612ca7f7ef6fa7a4103f167b120617cb813f" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of Big O? With as little formal definition as possible and simple mathematics.</source>
          <target state="translated">Что такое простое английское объяснение Большой О? С минимально возможным формальным определением и простой математикой.</target>
        </trans-unit>
        <trans-unit id="f89a18eb1e0fc978c591793d435b46bfc0826855" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of “Big O” notation</source>
          <target state="translated">Что такое простое английское объяснение нотации &quot;Большой О&quot;...</target>
        </trans-unit>
        <trans-unit id="2cc611dba256f3aa30150ddcf404bfb6a56af65d" translate="yes" xml:space="preserve">
          <source>What is this sort called?  It is called Quick Sort!  That sort was made by a man called &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;C. A. R. Hoare&lt;/a&gt; and he called it Quick Sort.  Now, Quick Sort gets used all the time!</source>
          <target state="translated">Как называется этот вид? Это называется Быстрая сортировка! Этот вид был сделан человеком по имени &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;CAR Hoare,&lt;/a&gt; и он назвал это Quick Sort. Быстрая сортировка привыкает все время!</target>
        </trans-unit>
        <trans-unit id="bf023f1a273e5e8e203698a520653800da906866" translate="yes" xml:space="preserve">
          <source>When interested in doing computations whose size is &quot;large&quot; enough to be considered as approximately infinity, then big O notation is approximately the cost of solving your problem.</source>
          <target state="translated">Если Вы заинтересованы в выполнении вычислений,размер которых &quot;достаточно велик&quot;,чтобы считаться примерно бесконечным,то большая O-нотация-это примерно стоимость решения Вашей задачи.</target>
        </trans-unit>
        <trans-unit id="adc3d5b71af09ac58be8764be77408df12df041d" translate="yes" xml:space="preserve">
          <source>When the deck is done, I ask: did I swap cards in that pass?  If so, I must do it all once more, from the top.</source>
          <target state="translated">Когда колода закончится,я спрошу:я поменялся картами в этом пропуске? Если да,то я должен сделать это еще раз,сверху.</target>
        </trans-unit>
        <trans-unit id="9028c7b55a2b4ecb9c2a82958fa89f7a7fc1daa5" translate="yes" xml:space="preserve">
          <source>When we program, we are trying to solve a problem. What we code is called an algorithm. Big O notation allows us to compare the worse case performance of our algorithms in a standardized way. Hardware specs vary over time and improvements in hardware can reduce the time it takes an algorithms to run. But replacing the hardware does not mean our algorithm is any better or improved over time, as our algorithm is still the same. So in order to allow us to compare different algorithms, to determine if one is better or not, we use Big O notation.</source>
          <target state="translated">Когда мы программируем,мы пытаемся решить проблему.То,что мы кодируем,называется алгоритмом.Большая нотация O позволяет стандартизованно сравнивать худшие случаи производительности наших алгоритмов.Спецификация аппаратного обеспечения со временем меняется,и усовершенствование аппаратного обеспечения может сократить время работы алгоритмов.Но замена аппаратного обеспечения не означает,что наш алгоритм лучше или лучше со временем,так как наш алгоритм все тот же.Поэтому для того,чтобы мы могли сравнить различные алгоритмы,определить,лучше это или нет,мы используем нотацию Big O.</target>
        </trans-unit>
        <trans-unit id="54c2c9229bcd771be7710eabeb971bc3f8e0eb85" translate="yes" xml:space="preserve">
          <source>When we say some algorithm is O(f(n)) we are saying that the running time (or space required) by that algorithm is always lower than some constant times f(n).</source>
          <target state="translated">Когда мы говорим,что какой-то алгоритм является O(f(n)),мы говорим,что время работы (или требуемое пространство)этого алгоритма всегда меньше,чем некоторые постоянные времена f(n).</target>
        </trans-unit>
        <trans-unit id="5d1cb020f38d2820c9eec88a25e1be3ef2a6c892" translate="yes" xml:space="preserve">
          <source>Why do I choose Quick Sort?  I do not like to work, of course!  I want work done as soon as I can get it done.</source>
          <target state="translated">Почему я выбираю Quick Sort? Я,конечно,не люблю работать! Я хочу,чтобы работа была сделана как можно быстрее.</target>
        </trans-unit>
        <trans-unit id="ccaa8eba13667623c9638dcc1af96e87d1ce8695" translate="yes" xml:space="preserve">
          <source>Why does he say n squared?</source>
          <target state="translated">Почему он говорит &quot;в квадрате&quot;?</target>
        </trans-unit>
        <trans-unit id="ed876af93299c7d2e7470f312b49d7963f03e745" translate="yes" xml:space="preserve">
          <source>Why is this so important? Because software deals with problems that may differ in size by factors up to a trillion. Consider that for a moment. The ratio between the speed necessary to travel to the Moon and human walking speed is less than 10,000:1, and that is absolutely tiny compared to the range in input sizes software may face. And because software may face an astronomical range in input sizes there is the potential for the Big O complexity of an algorithm, it's fundamental scaling nature, to trump any implementation details.</source>
          <target state="translated">Почему это так важно? Потому что программное обеспечение решает проблемы,которые могут различаться по размеру в триллион раз.Подумайте об этом на мгновение.Соотношение между скоростью,необходимой для путешествия на Луну,и скоростью ходьбы человека составляет менее 10 000:1,и это абсолютно крошечное по сравнению с диапазоном входных размеров,с которым может столкнуться программное обеспечение.А поскольку программное обеспечение может столкнуться с астрономическим диапазоном входных размеров,есть потенциал для Большой O сложности алгоритма,это фундаментальная масштабирующая природа,чтобы превзойти любые детали реализации.</target>
        </trans-unit>
        <trans-unit id="a693d58d361e39c4c6dfbf09d0fc6a088f14c901" translate="yes" xml:space="preserve">
          <source>Why would you want to ignore the smaller parts of the equation? Because they become completely dwarfed by the big parts of the equation as you consider larger and larger scales; their contribution becomes dwarfed and irrelevant. (See example section.)</source>
          <target state="translated">Почему вы хотите проигнорировать меньшие части уравнения? Потому что они становятся полностью карликовыми из-за больших частей уравнения при рассмотрении больших и больших масштабов;их вклад становится карликовым и неактуальным.(См.пример в разделе).</target>
        </trans-unit>
        <trans-unit id="b03cf50f7e5382fcef1451bd7a03322e40c6839f" translate="yes" xml:space="preserve">
          <source>With 5 it's 60.</source>
          <target state="translated">С 5 это 60.</target>
        </trans-unit>
        <trans-unit id="19778bc5e290319ee50f4c5296b015273dc9262c" translate="yes" xml:space="preserve">
          <source>Worst-Case: the key doesn't exist in the list.</source>
          <target state="translated">Худший случай:ключа в списке нет.</target>
        </trans-unit>
        <trans-unit id="5fabd786be014d83764164facee56b049790e363" translate="yes" xml:space="preserve">
          <source>Wow, I hate work.  But oh well, I have to do this.  So here I go.</source>
          <target state="translated">Ух ты,ненавижу работу.Но я должен это сделать.Ну вот,я пошла.</target>
        </trans-unit>
        <trans-unit id="7c8c4cd8f5043686e05d837663d4022a92d73016" translate="yes" xml:space="preserve">
          <source>Yes, there is a more fast way!  It takes some time to learn, but it works... and it works quite fast.  You can try it too, but take your time with each step and do not lose your place.</source>
          <target state="translated">Да,есть более быстрый путь! Нужно время,чтобы научиться,но он работает...и работает довольно быстро.Вы тоже можете попробовать,но не торопитесь с каждым шагом и не теряйте своего места.</target>
        </trans-unit>
        <trans-unit id="cfe414e40bd3874b327354ff113f428d54d21253" translate="yes" xml:space="preserve">
          <source>You could refer to Big-&amp;Omega; (Big-Omega) for best case.</source>
          <target state="translated">Вы можете обратиться к Big-&amp;Omega; (Big-Omega) для лучшего случая.</target>
        </trans-unit>
        <trans-unit id="7bfc8ee77cbab3d00050185496cbe7e412b4bf8a" translate="yes" xml:space="preserve">
          <source>You drive a car. Occasionally, you need to spend 10 minutes going to
  the gas station and then spend 1 minute refilling the tank with gas.
  If you did this every time you went anywhere with your car (spend 10
  minutes driving to the gas station, spend a few seconds filling up a
  fraction of a gallon), it would be very inefficient. But if you fill
  up the tank once every few days, the 11 minutes spent driving to the
  gas station is &quot;amortized&quot; over a sufficiently large number of trips,
  that you can ignore it and pretend all your trips were maybe 5% longer.</source>
          <target state="translated">Ты водишь машину.Иногда нужно потратить 10 минут на то,чтобы доехать до АЗС,а затем потратить 1 минуту на заправку бака.Если бы вы делали это каждый раз,когда едете куда-нибудь с автомобилем (тратите 10 минут на дорогу до АЗС,несколько секунд тратите на заправку доли галлона),это было бы очень неэффективно.Но если заправлять бак раз в несколько дней,то 11 минут,потраченные на езду на заправку,&quot;амортизируются&quot; за достаточно большое количество поездок,что можно не обращать на это внимание и делать вид,что все ваши поездки были на 5% длиннее.</target>
        </trans-unit>
        <trans-unit id="2c6bcba6f752f5cfdc961fb84683b404f55a2f21" translate="yes" xml:space="preserve">
          <source>You learned all that with me!  You are so smart!  Thank you so much!</source>
          <target state="translated">Ты научился всему этому со мной! Ты такой умный! Огромное спасибо!</target>
        </trans-unit>
        <trans-unit id="e8fd35a375e8ec51f2b6feca80545b2feec31781" translate="yes" xml:space="preserve">
          <source>You may often see O(n), O(n&lt;sup&gt;2&lt;/sup&gt;), O(nlogn) and so forth, all these are just ways to show; How does an algorithm change?</source>
          <target state="translated">Вы можете часто видеть O (n), O (n &lt;sup&gt;2&lt;/sup&gt; ), O (nlogn) и так далее, все это просто способы показать; Как меняется алгоритм?</target>
        </trans-unit>
        <trans-unit id="f0c088b8e94d146df79970184c217c58b7b97083" translate="yes" xml:space="preserve">
          <source>You start at the first name and compare the number.  If it's a match, great, if not, you move on to the next.  You have to do it this way because the phone book is &lt;strong&gt;unordered&lt;/strong&gt; (by phone number anyway).</source>
          <target state="translated">Вы начинаете с первого имени и сравниваете число. Если это совпадение, отлично, если нет, переходите к следующему. Вы должны сделать это таким образом, потому что телефонная книга &lt;strong&gt;неупорядочена&lt;/strong&gt; (в любом случае по номеру телефона).</target>
        </trans-unit>
        <trans-unit id="4784b5173ab05221f2b6abc84330bf0f13d31a7c" translate="yes" xml:space="preserve">
          <source>You want to know all there is to know of big O?  So do I.</source>
          <target state="translated">Хочешь знать все,что можно знать о большой О? Я тоже.</target>
        </trans-unit>
        <trans-unit id="648ba0204f36666cba11a8e63d6db611dae8658b" translate="yes" xml:space="preserve">
          <source>[1]: There is a way to cheat and add all the things from one to n, all at one time.  Some kid named Gauss found this out when he was eight.  I am not that smart though, so &lt;a href=&quot;http://nzmaths.co.nz/gauss-trick-staff-seminar&quot;&gt;don't ask me how he did it&lt;/a&gt;.</source>
          <target state="translated">[1]: Есть способ обмануть и добавить все вещи от одного до n, все за один раз. Какой-то ребенок по имени Гаусс узнал об этом, когда ему было восемь лет. Я не такой умный, поэтому &lt;a href=&quot;http://nzmaths.co.nz/gauss-trick-staff-seminar&quot;&gt;не спрашивайте меня, как он это сделал&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4229c03c35f915409c958fce305574599037d757" translate="yes" xml:space="preserve">
          <source>[for the mathematically inclined, you can mouse over the spoilers for minor sidenotes]</source>
          <target state="translated">[для математически наклонных,вы можете навести курсор на спойлеры для мелких боковых примечаний]</target>
        </trans-unit>
        <trans-unit id="320f1d7c3f87e62df035bd8c3fff9fceb851f278" translate="yes" xml:space="preserve">
          <source>addition;</source>
          <target state="translated">addition;</target>
        </trans-unit>
        <trans-unit id="cc72a00bf5f82a31e19586f8d5648eeb9609f807" translate="yes" xml:space="preserve">
          <source>and so on.</source>
          <target state="translated">и так далее.</target>
        </trans-unit>
        <trans-unit id="41f2ef38a3521fb432c176bb3d6eec433f0e7d29" translate="yes" xml:space="preserve">
          <source>big-O notation doesn't care about constant factors: the function &lt;code&gt;9x&amp;sup2;&lt;/code&gt; is said to &quot;grow exactly like&quot; &lt;code&gt;10x&amp;sup2;&lt;/code&gt;. Neither does big-O &lt;em&gt;asymptotic&lt;/em&gt; notation care about &lt;em&gt;non-asymptotic&lt;/em&gt; stuff (&quot;stuff near the origin&quot; or &quot;what happens when the problem size is small&quot;): the function &lt;code&gt;10x&amp;sup2;&lt;/code&gt; is said to &quot;grow exactly like&quot; &lt;code&gt;10x&amp;sup2; - x + 2&lt;/code&gt;.</source>
          <target state="translated">нотация big-O не заботится о постоянных факторах: &lt;code&gt;9x&amp;sup2;&lt;/code&gt; что функция 9x&amp;sup2; &amp;laquo;растет точно так же, как&amp;raquo; &lt;code&gt;10x&amp;sup2;&lt;/code&gt; . &lt;em&gt;Асимптотическая система&lt;/em&gt; обозначений big-O также не заботится о &lt;em&gt;неасимптотических&lt;/em&gt; вещах (&amp;laquo;вещи рядом с источником&amp;raquo; или &amp;laquo;что происходит, когда размер задачи мал&amp;raquo;): &lt;code&gt;10x&amp;sup2;&lt;/code&gt; что функция 10x&amp;sup2; &amp;laquo;растет точно так же, как&amp;raquo; &lt;code&gt;10x&amp;sup2; - x + 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fed40854ecbd633619a5d431600a671eeed9292" translate="yes" xml:space="preserve">
          <source>c= a constant</source>
          <target state="translated">c=константа</target>
        </trans-unit>
        <trans-unit id="e923389b125ffc7cdb2e423a899d4348e7439235" translate="yes" xml:space="preserve">
          <source>division.</source>
          <target state="translated">division.</target>
        </trans-unit>
        <trans-unit id="714de604846fa9d95f2b9fc4aaa27f67caadafd4" translate="yes" xml:space="preserve">
          <source>e.g. for x=1million, ratio #handshakes/x&amp;sup2;: 0.499999...</source>
          <target state="translated">например, для x = 1 миллион, отношение # рукопожатия / x&amp;sup2;: 0,499999 ...</target>
        </trans-unit>
        <trans-unit id="f42454a2adeb8a0c26a29f629c55ab5dda69a64d" translate="yes" xml:space="preserve">
          <source>f(n)= An approximate function that expresses the running time of the algorithm as a function of n</source>
          <target state="translated">f(n)=приблизительная функция,выражающая время работы алгоритма как функцию n</target>
        </trans-unit>
        <trans-unit id="6b7dffac98fa2e9f18d9b09123953c56c601da05" translate="yes" xml:space="preserve">
          <source>how heat output scales on CPU dies as a function of transistor count, voltage, etc.</source>
          <target state="translated">как шкала тепловой мощности на процессоре умирает в зависимости от количества транзисторов,напряжения и т.д.</target>
        </trans-unit>
        <trans-unit id="077a4887c6602aedfb17f44dd051822aa960da2d" translate="yes" xml:space="preserve">
          <source>how much space an algorithm needs to run, as a function of input size</source>
          <target state="translated">сколько места должно занимать алгоритм,в зависимости от размера входного сигнала.</target>
        </trans-unit>
        <trans-unit id="4d80174ea25f9828dcb069496071916d7c70255b" translate="yes" xml:space="preserve">
          <source>how much time an algorithm needs to run, as a function of input size</source>
          <target state="translated">сколько времени алгоритм должен быть запущен,в зависимости от размера входного сигнала.</target>
        </trans-unit>
        <trans-unit id="f2dbea261a6334b636fcb8245379760585160604" translate="yes" xml:space="preserve">
          <source>how website latency scales with the number of processing units in a CPU or GPU or computer cluster</source>
          <target state="translated">как масштабируется задержка сайта с количеством процессоров в CPU,GPU или компьютерном кластере</target>
        </trans-unit>
        <trans-unit id="5aa429e0444abdc08467c70c26cbff2d88e2345a" translate="yes" xml:space="preserve">
          <source>it's less than O(N&lt;sup&gt;1.000001&lt;/sup&gt;), which you might be willing to call basically linear</source>
          <target state="translated">это меньше, чем O (N &lt;sup&gt;1.000001&lt;/sup&gt; ), который вы могли бы назвать в основном линейным</target>
        </trans-unit>
        <trans-unit id="8e97d6456227b5a58913c9ed733df644f1e01e91" translate="yes" xml:space="preserve">
          <source>k is bounded in some neighborhood of a (if a = +&amp;infin;, this means that there are numbers N and M such that for every x &amp;gt; N, |&lt;em&gt;k&lt;/em&gt;(x)| &amp;lt; M).</source>
          <target state="translated">k ограничено в некоторой окрестности a (если a = + &amp;infin;, это означает, что существуют числа N и M такие, что для каждого x&amp;gt; N, | &lt;em&gt;k&lt;/em&gt; (x) | &amp;lt;M).</target>
        </trans-unit>
        <trans-unit id="6005c391c2f680a2452cd2577c2564dbcef8e9c9" translate="yes" xml:space="preserve">
          <source>ln(x) = o(x) = O(x) when x &amp;rarr; +&amp;infin;.</source>
          <target state="translated">ln (x) = o (x) = O (x), когда x &amp;rarr; + &amp;infin;.</target>
        </trans-unit>
        <trans-unit id="273b9bcfed53ba997f70f8aa75c36bda6fde8958" translate="yes" xml:space="preserve">
          <source>multiplication; and</source>
          <target state="translated">умножение;и</target>
        </trans-unit>
        <trans-unit id="a4393b9a14bdfd4f4c0eeaaf31bad2e0b9cfef0d" translate="yes" xml:space="preserve">
          <source>n=number of input parameters</source>
          <target state="translated">n=количество входных параметров</target>
        </trans-unit>
        <trans-unit id="463f52bc275366887f835ed5e5f95c1fe198e8af" translate="yes" xml:space="preserve">
          <source>or address it formally, &quot;Big O&quot; classifies the algorithms and standardize the comparison process.</source>
          <target state="translated">или обратиться к нему формально,&quot;Большая О&quot; классифицирует алгоритмы и стандартизирует процесс сравнения.</target>
        </trans-unit>
        <trans-unit id="27c0dba7b6e5e26123d57265908dfa7204907ffd" translate="yes" xml:space="preserve">
          <source>probabilistic expected number of people who have seen some viral marketing as a function of time</source>
          <target state="translated">вероятностное ожидаемое количество людей,которые рассматривают вирусный маркетинг как функцию времени.</target>
        </trans-unit>
        <trans-unit id="0c2b90eddd63a783f5f290989f744b1bf85f87bd" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15,20,25}  ==&amp;gt; problem-instance-size = 5 iterations-in-loop = 5</source>
          <target state="translated">задача-экземпляр = {5,10,15,20,25} ==&amp;gt; проблема-экземпляр-размер = 5 итераций в цикле = 5</target>
        </trans-unit>
        <trans-unit id="e4b7c82dda906533e8c2824c6df8639b2a23a367" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15,20,25}  ==&amp;gt; problem-instance-size = 5, total-iterations= 5*5 =25</source>
          <target state="translated">задача-экземпляр = {5,10,15,20,25} ==&amp;gt; проблема-экземпляр-размер = 5, всего итераций = 5 * 5 = 25</target>
        </trans-unit>
        <trans-unit id="7b9571101e4cfebe964dd712258a749bb36005e9" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15}  ==&amp;gt; problem-instance-size = 3, iterations-in-loop= 3</source>
          <target state="translated">задача-экземпляр = {5,10,15} ==&amp;gt; проблема-экземпляр-размер = 3, итерации в цикле = 3</target>
        </trans-unit>
        <trans-unit id="41a7ac7c629f59f13ed8b74173f006eb424e46ac" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15}  ==&amp;gt; problem-instance-size = 3, total-iterations = 3*3 = 9</source>
          <target state="translated">задача-экземпляр = {5,10,15} ==&amp;gt; проблема-экземпляр-размер = 3, всего итераций = 3 * 3 = 9</target>
        </trans-unit>
        <trans-unit id="6adf164f31eaa024e8cd62ab3a7db4601ada676a" translate="yes" xml:space="preserve">
          <source>sin x = O(1) when x &amp;rarr; +&amp;infin;,</source>
          <target state="translated">sin x = O (1), когда x &amp;rarr; + &amp;infin;,</target>
        </trans-unit>
        <trans-unit id="01a98a9d29b98d64c9b325ce600cfccdddb4209c" translate="yes" xml:space="preserve">
          <source>sin x = O(x) when x &amp;rarr; 0.</source>
          <target state="translated">sin x = O (x), когда x &amp;rarr; 0.</target>
        </trans-unit>
        <trans-unit id="0f7b476dccef1271c4d6a97311ca082c68f64f7e" translate="yes" xml:space="preserve">
          <source>so you could get its idea literally that it's used to order something to  compare them.</source>
          <target state="translated">так что ты можешь получить его идею буквально,что он привык заказывать что-то,чтобы сравнить их.</target>
        </trans-unit>
        <trans-unit id="2411b10604909e08dc5dd9f0ef7bed5327f33858" translate="yes" xml:space="preserve">
          <source>subtraction;</source>
          <target state="translated">subtraction;</target>
        </trans-unit>
        <trans-unit id="1dfbbc899d7564b2c25e7c8e5668555967ef21c9" translate="yes" xml:space="preserve">
          <source>the number of possible handshakes among &lt;code&gt;N&lt;/code&gt; people at a party (&lt;code&gt;Ɵ(N&amp;sup2;)&lt;/code&gt;, specifically &lt;code&gt;N(N-1)/2&lt;/code&gt;, but what matters is that it &quot;scales like&quot; &lt;code&gt;N&amp;sup2;&lt;/code&gt;)</source>
          <target state="translated">количество возможных рукопожатий среди &lt;code&gt;N&lt;/code&gt; человек на вечеринке ( &lt;code&gt;Ɵ(N&amp;sup2;)&lt;/code&gt; , в частности &lt;code&gt;N(N-1)/2&lt;/code&gt; , но важно то, что оно &amp;laquo;масштабируется как&amp;raquo; &lt;code&gt;N&amp;sup2;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a673eb6514c9181588ced3c270df39095e5c61da" translate="yes" xml:space="preserve">
          <source>x&lt;sup&gt;2&lt;/sup&gt; + x = O(x) when x &amp;rarr; 0,</source>
          <target state="translated">x &lt;sup&gt;2&lt;/sup&gt; + x = O (x), когда x &amp;rarr; 0,</target>
        </trans-unit>
        <trans-unit id="4588b59a6bc0b7081d698604a73689ff94c6669e" translate="yes" xml:space="preserve">
          <source>x&lt;sup&gt;2&lt;/sup&gt; + x = O(x&lt;sup&gt;2&lt;/sup&gt;) when x &amp;rarr; +&amp;infin;,</source>
          <target state="translated">x &lt;sup&gt;2&lt;/sup&gt; + x = O (x &lt;sup&gt;2&lt;/sup&gt; ), когда x &amp;rarr; + &amp;infin;,</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
