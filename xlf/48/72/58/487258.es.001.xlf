<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/487258">
    <body>
      <group id="487258">
        <trans-unit id="df498b6e1ddfb06035cc2f060b77dcae692ec7ef" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;What is a plain English explanation of Big O? With as little formal
  definition as possible and simple mathematics.&lt;/em&gt;&quot;</source>
          <target state="translated">&quot; &lt;em&gt;&amp;iquest;Cu&amp;aacute;l es una explicaci&amp;oacute;n sencilla en ingl&amp;eacute;s de Big O? Con la menor definici&amp;oacute;n formal posible y matem&amp;aacute;tica simple&lt;/em&gt; &quot; &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="743ffd5e6c073307e39f8ab64f2a620592932e7f" translate="yes" xml:space="preserve">
          <source>&quot;Big O&quot; describes the algorithm's performance and evaluates it.</source>
          <target state="translated">&quot;Big O&quot; describe el rendimiento del algoritmo y lo evalúa.</target>
        </trans-unit>
        <trans-unit id="b462328e08f4909b285edec4ff0990d6976efaea" translate="yes" xml:space="preserve">
          <source>&quot;Big O' achieves the above two with standardized &lt;code&gt;Notations&lt;/code&gt;.</source>
          <target state="translated">&quot;Big O 'logra los dos anteriores con &lt;code&gt;Notations&lt;/code&gt; estandarizadas.</target>
        </trans-unit>
        <trans-unit id="13f9f8a3d4d7d94edeaf3b7b38263362fa788e6a" translate="yes" xml:space="preserve">
          <source>&quot;For large enough inputsize=N, no matter what the constant factor is, if I &lt;strong&gt;&lt;em&gt;double&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; the input size&lt;/em&gt;...</source>
          <target state="translated">&quot;Para un tama&amp;ntilde;o de entrada suficientemente grande = N, no importa cu&amp;aacute;l sea el factor constante, si &lt;strong&gt;&lt;em&gt;doblo&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;el tama&amp;ntilde;o de entrada&lt;/em&gt; ...</target>
        </trans-unit>
        <trans-unit id="839e4a2006b278a93c4dc0f1936567078302c3f3" translate="yes" xml:space="preserve">
          <source>&amp;hellip;</source>
          <target state="translated">&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="12f5efd72c115a3dfdb9aef75a93d8f6398d2f03" translate="yes" xml:space="preserve">
          <source>( *in a wonderful, &lt;em&gt;unit-free&lt;/em&gt; sense of time!)</source>
          <target state="translated">(* en un maravilloso sentido del tiempo &lt;em&gt;sin unidad&lt;/em&gt; !)</target>
        </trans-unit>
        <trans-unit id="5f85db481a01c4c068358bc082055af7e5738d77" translate="yes" xml:space="preserve">
          <source>(**which is what matters, because people will &lt;a href=&quot;http://www.youtube.com/watch?v=OnA3C9Af_oc&quot;&gt;&lt;em&gt;always&lt;/em&gt; want more&lt;/a&gt;, whether they live today or tomorrow)</source>
          <target state="translated">(** que es lo que importa, porque las personas &lt;a href=&quot;http://www.youtube.com/watch?v=OnA3C9Af_oc&quot;&gt;&lt;em&gt;siempre&lt;/em&gt; querr&amp;aacute;n m&amp;aacute;s&lt;/a&gt; , ya sea que vivan hoy o ma&amp;ntilde;ana)</target>
        </trans-unit>
        <trans-unit id="111ed31dcbac4c6bfe6846c61c61ca1b11df6d01" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;edit&lt;/em&gt;: The &quot;plain English&quot; explanation ends here.)</source>
          <target state="translated">( &lt;em&gt;editar&lt;/em&gt; : la explicaci&amp;oacute;n del &quot;ingl&amp;eacute;s simple&quot; termina aqu&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="6ce684a7aaa9d4a76848668e020344c53ae2b9ae" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;https://stackoverflow.com/q/7333376/711085&quot;&gt;Difference between average case and amortized analysis&lt;/a&gt; if interested in this subtopic.)</source>
          <target state="translated">(Consulte la &lt;a href=&quot;https://stackoverflow.com/q/7333376/711085&quot;&gt;Diferencia entre el caso promedio y el an&amp;aacute;lisis amortizado&lt;/a&gt; si est&amp;aacute; interesado en este subtema).</target>
        </trans-unit>
        <trans-unit id="acf9d80cf9dbb5bb7520ab6662ebded396c6f175" translate="yes" xml:space="preserve">
          <source>(here, the &lt;code&gt;x&lt;/code&gt;s represent constant-time units of work, processor instructions, interpreter opcodes, whatever)</source>
          <target state="translated">(aqu&amp;iacute;, las &lt;code&gt;x&lt;/code&gt; s representan unidades de trabajo de tiempo constante, instrucciones del procesador, c&amp;oacute;digos de operaci&amp;oacute;n del int&amp;eacute;rprete, lo que sea)</target>
        </trans-unit>
        <trans-unit id="e095c7e86ea34ae9aa5df712384da64165e0768e" translate="yes" xml:space="preserve">
          <source>(technically the constant factor could maybe matter in some more esoteric examples, but I've phrased things above (e.g. in log(N)) such that it doesn't)</source>
          <target state="translated">(técnicamente el factor constante podría importar en algunos ejemplos más esotéricos,pero he expresado las cosas arriba (por ejemplo,en log(N))de tal manera que no lo hace)</target>
        </trans-unit>
        <trans-unit id="06d7bf9932a7f33791291e583cc05892187c54d8" translate="yes" xml:space="preserve">
          <source>(temporary digression from &quot;plain English&quot;:) If you wanted to prove this to yourself, you could perform some simple algebra on the ratio to split it up into multiple terms (&lt;code&gt;lim&lt;/code&gt; means &quot;considered in the limit of&quot;, just ignore it if you haven't seen it, it's just notation for &quot;and N is really really big&quot;):</source>
          <target state="translated">(digresi&amp;oacute;n temporal del &quot;ingl&amp;eacute;s simple&quot; :) Si quisieras probar esto a ti mismo, podr&amp;iacute;as realizar un poco de &amp;aacute;lgebra simple en la proporci&amp;oacute;n para dividirlo en varios t&amp;eacute;rminos ( &lt;code&gt;lim&lt;/code&gt; significa &quot;considerado en el l&amp;iacute;mite de&quot;, simplemente ign&amp;oacute;ralo si no lo has visto, es solo una notaci&amp;oacute;n para &quot;y N es realmente muy grande&quot;):</target>
        </trans-unit>
        <trans-unit id="11b4e1bb86ac129d3782b8fb89778b82b4699643" translate="yes" xml:space="preserve">
          <source>(with credit to &lt;a href=&quot;https://stackoverflow.com/a/487292/711085&quot;&gt;https://stackoverflow.com/a/487292/711085&lt;/a&gt; )</source>
          <target state="translated">(con cr&amp;eacute;dito a &lt;a href=&quot;https://stackoverflow.com/a/487292/711085&quot;&gt;https://stackoverflow.com/a/487292/711085&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7bedee6fc739cfe745b69e77230823ca7b506921" translate="yes" xml:space="preserve">
          <source>... I &quot;(basically) double&quot; the time an O(N log(N)) algorithm takes.&quot; &lt;em&gt;(fairly common)&lt;/em&gt;</source>
          <target state="translated">... &quot;(b&amp;aacute;sicamente) doblo&quot; el tiempo que tarda un algoritmo O (N log (N)) &quot; &lt;em&gt;(bastante com&amp;uacute;n)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c2cc664a183cfc04e1a64249ea8f7c45673b79cb" translate="yes" xml:space="preserve">
          <source>... I add a fixed amount to the time an O(log(N)) (&quot;logarithmic time&quot;) algorithm takes.&quot; &lt;em&gt;(cheap!)&lt;/em&gt;</source>
          <target state="translated">... Agrego una cantidad fija al tiempo que tarda un algoritmo O (log (N)) (&quot;tiempo logar&amp;iacute;tmico&quot;) &quot;. &lt;em&gt;(&amp;iexcl;Barato!)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9288b2e9d99d26a40d9f6f5b3a3990d8e5204b8b" translate="yes" xml:space="preserve">
          <source>... I don't change the time an O(1) (&quot;constant time&quot;) algorithm takes.&quot; &lt;em&gt;(the cheapest!)&lt;/em&gt;</source>
          <target state="translated">... no cambio el tiempo que tarda un algoritmo O (1) (&quot;tiempo constante&quot;) &quot; &lt;em&gt;(&amp;iexcl;el m&amp;aacute;s barato!)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac3db673dfe1df5538b14e8981fdd7f64c253879" translate="yes" xml:space="preserve">
          <source>... I double the time an O(N) (&quot;linear time&quot;) algorithm takes.&quot;</source>
          <target state="translated">...doblo el tiempo que tarda un algoritmo O(N)(&quot;tiempo lineal&quot;)&quot;.</target>
        </trans-unit>
        <trans-unit id="a1e7e1ffe28ec1263008a387034b2aaa20a40664" translate="yes" xml:space="preserve">
          <source>... I double-cubed (octuple) the time an O(N&amp;sup3;) (&quot;cubic time&quot;) algorithm takes.&quot; &lt;em&gt;(e.g. a problem 100x as big takes 100&amp;sup3;=1000000x as long... very unsustainable)&lt;/em&gt;</source>
          <target state="translated">... Dobl&amp;eacute; en cubos (octuple) el tiempo que tarda un algoritmo O (N&amp;sup3;) (&quot;tiempo c&amp;uacute;bico&quot;) &quot; &lt;em&gt;(p&lt;/em&gt; . &lt;em&gt;Ej., Un problema 100x tan grande toma 100&amp;sup3; = 1000000x tanto tiempo ... muy insostenible)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eab0d87ea3058c371ba99238d90dc25bc68910e0" translate="yes" xml:space="preserve">
          <source>... I double-squared (quadruple) the time an O(N&amp;sup2;) (&quot;quadratic time&quot;) algorithm takes.&quot; &lt;em&gt;(e.g. a problem 100x as big takes 100&amp;sup2;=10000x as long... possibly unsustainable)&lt;/em&gt;</source>
          <target state="translated">... I doble cuadrado (cu&amp;aacute;druple) el tiempo que tarda un algoritmo O (N&amp;sup2;) (&quot;tiempo cuadr&amp;aacute;tico&quot;) &quot; &lt;em&gt;(por ejemplo, un problema 100x tan grande toma 100&amp;sup2; = 10000x tanto tiempo ... posiblemente insostenible)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a87538c4cde56e0a42c94f671c99d158235fbb02" translate="yes" xml:space="preserve">
          <source>... I ridiculously increase the time a O(2&lt;sup&gt;N&lt;/sup&gt;) (&quot;exponential time&quot;) algorithm takes.&quot; &lt;em&gt;(you'd double (or triple, etc.) the time just by increasing the problem by a single unit)&lt;/em&gt;</source>
          <target state="translated">... Aumento rid&amp;iacute;culamente el tiempo que tarda un algoritmo O (2 &lt;sup&gt;N&lt;/sup&gt; ) (&quot;tiempo exponencial&quot;) &quot; &lt;em&gt;(duplicar&amp;iacute;a (o triplicar&amp;iacute;a, etc.) el tiempo simplemente aumentando el problema en una sola unidad)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="758995d5c0c86f523c06ebeba129d83d2b577e5c" translate="yes" xml:space="preserve">
          <source>... and the ugly:</source>
          <target state="translated">...y los feos:</target>
        </trans-unit>
        <trans-unit id="5f8dd699eca2f4c835f1d41e82c48c0ee2badc97" translate="yes" xml:space="preserve">
          <source>... this means that &lt;strong&gt;&lt;em&gt;for &quot;large enough&quot; problem sizes N&lt;/em&gt;&lt;/strong&gt; (if we ignore stuff near the origin), there exists some constant (e.g. 2.5, completely made up) such that:</source>
          <target state="translated">... esto significa que &lt;strong&gt;&lt;em&gt;para los tama&amp;ntilde;os de problema &quot;suficientemente grandes&quot; N&lt;/em&gt;&lt;/strong&gt; (si ignoramos cosas cerca del origen), existe alguna constante (por ejemplo, 2.5, completamente inventada) tal que:</target>
        </trans-unit>
        <trans-unit id="02da7ab518ed35b63049ed24f5f7b780a03cf03c" translate="yes" xml:space="preserve">
          <source>1 item: 1 second</source>
          <target state="translated">Un artículo:1 segundo</target>
        </trans-unit>
        <trans-unit id="311ddef12fccab210777747c79f3b6e098829cf8" translate="yes" xml:space="preserve">
          <source>10 items: 1 second</source>
          <target state="translated">10 artículos:1 segundo</target>
        </trans-unit>
        <trans-unit id="b0174046184ef586844edb37f738266a6b609bf9" translate="yes" xml:space="preserve">
          <source>10 items: 10 seconds</source>
          <target state="translated">10 artículos:10 segundos</target>
        </trans-unit>
        <trans-unit id="689340b4e2631ad08bd04332ba871630466acec6" translate="yes" xml:space="preserve">
          <source>10 items: 100 seconds</source>
          <target state="translated">10 artículos:100 segundos</target>
        </trans-unit>
        <trans-unit id="487a07e5ea7f045eaef47700eca5782bdc2698c0" translate="yes" xml:space="preserve">
          <source>10 items: 2 seconds</source>
          <target state="translated">10 artículos:2 segundos</target>
        </trans-unit>
        <trans-unit id="e9339141f2aa5963a587e850388974cfe8b47716" translate="yes" xml:space="preserve">
          <source>100 items: 1 second</source>
          <target state="translated">100 artículos:1 segundo</target>
        </trans-unit>
        <trans-unit id="f78d9065d61742cbe71ea04a50c760c0aad8e2f0" translate="yes" xml:space="preserve">
          <source>100 items: 100 seconds</source>
          <target state="translated">100 artículos:100 segundos</target>
        </trans-unit>
        <trans-unit id="b9a9aeacdc04be6832d92a9113f361be8c4fe731" translate="yes" xml:space="preserve">
          <source>100 items: 10000 seconds</source>
          <target state="translated">100 artículos:10000 segundos</target>
        </trans-unit>
        <trans-unit id="e626224265872fce291da52ed1c64e5aa6578829" translate="yes" xml:space="preserve">
          <source>100 items: 3 seconds</source>
          <target state="translated">100 artículos:3 segundos</target>
        </trans-unit>
        <trans-unit id="4479af418a5535ecef4c1769fe04b3e262bd0ce2" translate="yes" xml:space="preserve">
          <source>1000 items: 4 seconds</source>
          <target state="translated">1000 artículos:4 segundos</target>
        </trans-unit>
        <trans-unit id="59b0f1da90751fd2ff98593e8e90a885934dbe5d" translate="yes" xml:space="preserve">
          <source>10000 items: 5 seconds</source>
          <target state="translated">10000 artículos:5 segundos</target>
        </trans-unit>
        <trans-unit id="085fdb777863ed85e33fb2c51dc325a0803c3300" translate="yes" xml:space="preserve">
          <source>25! = 25 &amp;times; 24 &amp;times; &amp;hellip; &amp;times; 2 &amp;times; 1 = 15,511,210,043,330,985,984,000,000</source>
          <target state="translated">25! = 25 &amp;times; 24 &amp;times;&amp;hellip; &amp;times; 2 &amp;times; 1 = 15,511,210,043,330,985,984,000,000</target>
        </trans-unit>
        <trans-unit id="1cf1a4fd3744013ce7ee0b7c1d54d91a24a35640" translate="yes" xml:space="preserve">
          <source>5! = 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 120</source>
          <target state="translated">5! = 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 120</target>
        </trans-unit>
        <trans-unit id="5ff18ebe3d87d9ac7b38e9bc7546904650421471" translate="yes" xml:space="preserve">
          <source>50! = 50 &amp;times; 49 &amp;times; &amp;hellip; &amp;times; 2 &amp;times; 1 = 3.04140932 &amp;times; 10&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">50! = 50 &amp;times; 49 &amp;times;&amp;hellip; &amp;times; 2 &amp;times; 1 = 3.04140932 &amp;times; 10 &lt;sup&gt;64&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="65decea121bc59733f31fb00d9968ddd605ec56d" translate="yes" xml:space="preserve">
          <source>6 becomes 360.</source>
          <target state="translated">6 se convierte en 360.</target>
        </trans-unit>
        <trans-unit id="c649be492e31261bc490084ea0f4061c188e3cef" translate="yes" xml:space="preserve">
          <source>6! = 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 720</source>
          <target state="translated">6! = 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 720</target>
        </trans-unit>
        <trans-unit id="c8333818a5f4310605f53fef7090df38bab14cef" translate="yes" xml:space="preserve">
          <source>7! = 7 &amp;times; 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 5040</source>
          <target state="translated">7! = 7 &amp;times; 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 5040</target>
        </trans-unit>
        <trans-unit id="82d23a6f8035f1269cf4ccfacb8ebe4510c824fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(1)&lt;/code&gt;&lt;strong&gt;Constant&lt;/strong&gt;: The program takes the same time to run no matter how big the input is.</source>
          <target state="translated">&lt;code&gt;O(1)&lt;/code&gt; &lt;strong&gt;Constante&lt;/strong&gt; : el programa tarda el mismo tiempo en ejecutarse sin importar cu&amp;aacute;n grande sea la entrada.</target>
        </trans-unit>
        <trans-unit id="056a18f82b6af88dc008fbe3a7787f86b596f6a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(N)&lt;/code&gt; algorithms are in some sense the &quot;best&quot; algorithms if you need to read all your data. The &lt;strong&gt;very act of reading&lt;/strong&gt; a bunch of data is an &lt;code&gt;O(N)&lt;/code&gt; operation. Loading it into memory is usually &lt;code&gt;O(N)&lt;/code&gt; (or faster if you have hardware support, or no time at all if you've already read the data). However, if you touch or even &lt;em&gt;look&lt;/em&gt; at every piece of data (or even every other piece of data), your algorithm will take &lt;code&gt;O(N)&lt;/code&gt; time to perform this looking. No matter how long your actual algorithm takes, it will be at least &lt;code&gt;O(N)&lt;/code&gt; because it spent that time looking at all the data.</source>
          <target state="translated">&lt;code&gt;O(N)&lt;/code&gt; algoritmos O (N) son, en cierto sentido, los &quot;mejores&quot; algoritmos si necesita leer todos sus datos. El &lt;strong&gt;acto mismo de leer&lt;/strong&gt; un mont&amp;oacute;n de datos es una operaci&amp;oacute;n &lt;code&gt;O(N)&lt;/code&gt; . Cargarlo en la memoria suele ser &lt;code&gt;O(N)&lt;/code&gt; (o m&amp;aacute;s r&amp;aacute;pido si tiene soporte de hardware, o no tiene tiempo si ya ha le&amp;iacute;do los datos). Sin embargo, si toca o incluso &lt;em&gt;mira&lt;/em&gt; cada dato (o incluso cualquier otro dato), su algoritmo tomar&amp;aacute; tiempo &lt;code&gt;O(N)&lt;/code&gt; para realizar este examen. No importa cu&amp;aacute;nto tiempo tome su algoritmo real, ser&amp;aacute; al menos &lt;code&gt;O(N)&lt;/code&gt; porque pas&amp;oacute; ese tiempo mirando todos los datos.</target>
        </trans-unit>
        <trans-unit id="b1e73910621a4a87a24289f5d1c6be72edc01699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(k^n)&lt;/code&gt;&lt;strong&gt;Exponential&lt;/strong&gt; The program run-time increases very quickly with even moderate increases in the size of the problem - it is only practical to process small data sets with exponential algorithms.</source>
          <target state="translated">&lt;code&gt;O(k^n)&lt;/code&gt; &lt;strong&gt;Exponencial&lt;/strong&gt; El tiempo de ejecuci&amp;oacute;n del programa aumenta muy r&amp;aacute;pidamente, incluso con aumentos moderados en el tama&amp;ntilde;o del problema; solo es pr&amp;aacute;ctico procesar peque&amp;ntilde;os conjuntos de datos con algoritmos exponenciales.</target>
        </trans-unit>
        <trans-unit id="dd8fc41eb8e642b8c7be077a43f8b40003fc551c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt;&lt;strong&gt;Logarithmic&lt;/strong&gt;: The program run-time increases only slowly, even with big increases in the size of the input.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;strong&gt;Logar&amp;iacute;tmico&lt;/strong&gt; : el tiempo de ejecuci&amp;oacute;n del programa aumenta solo lentamente, incluso con grandes aumentos en el tama&amp;ntilde;o de la entrada.</target>
        </trans-unit>
        <trans-unit id="5537ff56d10d57079a34acd64955d17beb7d3a76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n!)&lt;/code&gt;&lt;strong&gt;Factorial&lt;/strong&gt; The program run-time will be longer than you can afford to wait for anything but the very smallest and most trivial-seeming datasets.</source>
          <target state="translated">&lt;code&gt;O(n!)&lt;/code&gt; &lt;strong&gt;Factorial&lt;/strong&gt; El tiempo de ejecuci&amp;oacute;n del programa ser&amp;aacute; m&amp;aacute;s largo de lo que puede permitirse esperar cualquier cosa excepto los conjuntos de datos m&amp;aacute;s peque&amp;ntilde;os y aparentemente triviales.</target>
        </trans-unit>
        <trans-unit id="461878ff8b0db16418e81fc04a687228bdddb9cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n)&lt;/code&gt;&lt;strong&gt;Linear&lt;/strong&gt;: The program run-time increases proportionally to the size of the input.</source>
          <target state="translated">&lt;code&gt;O(n)&lt;/code&gt; &lt;strong&gt;Lineal&lt;/strong&gt; : el tiempo de ejecuci&amp;oacute;n del programa aumenta proporcionalmente al tama&amp;ntilde;o de la entrada.</target>
        </trans-unit>
        <trans-unit id="c217eda9395d53638ead2adab477fe11bdcd7bed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n^k)&lt;/code&gt;&lt;strong&gt;Polynomial&lt;/strong&gt;: - Processing time grows faster and faster - as a polynomial function - as the size of the input increases.</source>
          <target state="translated">&lt;code&gt;O(n^k)&lt;/code&gt; &lt;strong&gt;Polinomio&lt;/strong&gt; : - El tiempo de procesamiento crece cada vez m&amp;aacute;s r&amp;aacute;pido, como una funci&amp;oacute;n polin&amp;oacute;mica, a medida que aumenta el tama&amp;ntilde;o de la entrada.</target>
        </trans-unit>
        <trans-unit id="487d91ff83198cfbc6a54c925fe5eb11d2aa1e78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; &amp;Omega;(lowerbound)&lt;/code&gt; means &lt;code&gt;f&lt;/code&gt; &quot;grows no slower than&quot; &lt;code&gt;lowerbound&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; &amp;Omega;(lowerbound)&lt;/code&gt; significa que &lt;code&gt;f&lt;/code&gt; &quot;no crece m&amp;aacute;s lento que&quot; &lt;code&gt;lowerbound&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b822bda6e416f32092b9f10f8f055c41f8035dcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; means &lt;code&gt;f&lt;/code&gt; &quot;grows no faster than&quot; &lt;code&gt;upperbound&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; significa que &lt;code&gt;f&lt;/code&gt; &quot;no crece m&amp;aacute;s r&amp;aacute;pido que&quot; &lt;code&gt;upperbound&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b5d65077f782632cf020f9dc10bb5515c203e5c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; Ɵ(justlikethis)&lt;/code&gt; mean &lt;code&gt;f&lt;/code&gt; &quot;grows exactly like&quot; &lt;code&gt;justlikethis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; Ɵ(justlikethis)&lt;/code&gt; significa que &lt;code&gt;f&lt;/code&gt; &quot;crece exactamente como&quot; al igual que &lt;code&gt;justlikethis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4961257cbe0182882cfdaf21754b651a2f9dd8e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Big-O notation represent the upper-bound on the Complexity (Time, Space, ..)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;La notaci&amp;oacute;n Big-O representa el l&amp;iacute;mite superior de la Complejidad (Tiempo, Espacio, ..)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b6ee9747fe724799f360b3f5740e340e9d6e0bc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Examples&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Examples&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dda2198e2a2e6a8edab7d156a0212aab2797c3a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Math addenda&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Ap&amp;eacute;ndices matem&amp;aacute;ticos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53c547884adc7e294b855c4c5480cbf77fa6513e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;More examples&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M&amp;aacute;s ejemplos&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="16299135c5a827dc53d250d6ee80162f6e351d93" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;example:&lt;/em&gt; you and a friend are asked to create a function to sum the numbers from 0 to N. You come up with f(x) and your friend comes up with g(x). Both functions have the same result, but a different algorithm. In order to objectively compare the efficiency of the algorithms we use &lt;strong&gt;Big-O notation&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;ejemplo:&lt;/em&gt; se le pide a usted y a un amigo que creen una funci&amp;oacute;n para sumar los n&amp;uacute;meros del 0 al N. Se le ocurre f (x) y su amigo aparece con g (x). Ambas funciones tienen el mismo resultado, pero un algoritmo diferente. Para comparar objetivamente la eficiencia de los algoritmos, usamos la &lt;strong&gt;notaci&amp;oacute;n Big-O&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="62471f46793f8b6a5cc659e14e96cdc437a86276" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = &lt;em&gt;k&lt;/em&gt;(x)&lt;em&gt;g&lt;/em&gt;(x)</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; (x) = &lt;em&gt;k&lt;/em&gt; (x) &lt;em&gt;g&lt;/em&gt; (x)</target>
        </trans-unit>
        <trans-unit id="150577e3855332cfa9b847f25eb077da526cdf9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = O(&lt;em&gt;g&lt;/em&gt;(x)) when x goes to a (for example, a = +&amp;infin;) means that there is a function &lt;em&gt;k&lt;/em&gt; such that:</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; (x) = O ( &lt;em&gt;g&lt;/em&gt; (x)) cuando x va a a (por ejemplo, a = + &amp;infin;) significa que hay una funci&amp;oacute;n &lt;em&gt;k&lt;/em&gt; tal que:</target>
        </trans-unit>
        <trans-unit id="f39e0610bb58307821a0194948212519a3857fe0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = o(&lt;em&gt;g&lt;/em&gt;(x)) when x goes to a means that there is a function k such that:</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; (x) = o ( &lt;em&gt;g&lt;/em&gt; (x)) cuando x va a un medio que hay una funci&amp;oacute;n k tal que:</target>
        </trans-unit>
        <trans-unit id="60efe2817e6b6dc1067de924ce07bd71c241b66c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;k&lt;/em&gt;(x) goes to 0 when x goes to a.</source>
          <target state="translated">&lt;em&gt;k&lt;/em&gt; (x) va a 0 cuando x va a a.</target>
        </trans-unit>
        <trans-unit id="df9a7b04d24a410a550a80633b5c46b22b5f4454" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;Big O&quot; does two things:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&quot;Big O&quot; hace dos cosas:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1daaf609ea760d49121da39fad36df3d4c70428" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2&lt;sup&gt;2N&lt;/sup&gt; = (4&lt;sup&gt;N&lt;/sup&gt;)............put another way...... &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2&lt;sup&gt;N+1&lt;/sup&gt; = 2&lt;sup&gt;N&lt;/sup&gt;2&lt;sup&gt;1&lt;/sup&gt; = 2 &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2 &lt;sup&gt;2N&lt;/sup&gt; = (4 &lt;sup&gt;N&lt;/sup&gt; ) ............ dicho de otra manera ...... &lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2 &lt;sup&gt;N + 1&lt;/sup&gt; = 2 &lt;sup&gt;N&lt;/sup&gt; 2 &lt;sup&gt;1&lt;/sup&gt; = 2 &lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bafc82a1bb664838622cc7d1e8482db598079440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3 key takeaways:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3 puntos clave:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae00ba228fe3cdd0cfce107b955e3f34920862ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Plain English Explanation of &lt;em&gt;What&lt;/em&gt; Big O Notation is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Una explicaci&amp;oacute;n en ingl&amp;eacute;s simple de &lt;em&gt;lo que&lt;/em&gt; es la notaci&amp;oacute;n Big O:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="effebafa8908442aac2c8ca79cf7084917151477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Plain English Explanation of the &lt;em&gt;Need&lt;/em&gt; for Big-O Notation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Una explicaci&amp;oacute;n sencilla en ingl&amp;eacute;s de la &lt;em&gt;necesidad&lt;/em&gt; de notaci&amp;oacute;n Big-O:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dc1a218f6a731c6560f65be4a2784929627a928" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A more accurate explanation (mathematical)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Una explicaci&amp;oacute;n m&amp;aacute;s precisa (matem&amp;aacute;tica)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73f82c5b1f0e86127e3020556cc882893d6cf6cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm description:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Descripci&amp;oacute;n del algoritmo:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f5537eaa639ac5f94aa2c74841f5eaaa9254c7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm example (Java):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ejemplo de algoritmo (Java):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8aab72c29f5ef095ba2621ef23e8bc30d58b5ec1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Amortized Worst-Case&lt;/strong&gt;: Some data structures may have a worst-case complexity that is large, but guarantee that if you do many of these operations, the average amount of work you do will be better than worst-case. For example, you may have a data structure that normally takes constant &lt;code&gt;O(1)&lt;/code&gt; time. However, occasionally it will 'hiccup' and take &lt;code&gt;O(N)&lt;/code&gt; time for one random operation, because maybe it needs to do some bookkeeping or garbage collection or something... but it promises you that if it does hiccup, it won't hiccup again for N more operations. The worst-case cost is still &lt;code&gt;O(N)&lt;/code&gt; per operation, but the amortized cost &lt;em&gt;over many runs&lt;/em&gt; is &lt;code&gt;O(N)/N&lt;/code&gt; = &lt;code&gt;O(1)&lt;/code&gt; per operation. Because the big operations are sufficiently rare, the massive amount of occasional work can be considered to blend in with the rest of the work as a constant factor. We say the work is &quot;amortized&quot; over a sufficiently large number of calls that it disappears asymptotically.</source>
          <target state="translated">&lt;strong&gt;El peor de los casos amortizados&lt;/strong&gt; : algunas estructuras de datos pueden tener una complejidad en el peor de los casos que es grande, pero garantizan que si realiza muchas de estas operaciones, la cantidad promedio de trabajo que realiza ser&amp;aacute; mejor que el peor de los casos. Por ejemplo, puede tener una estructura de datos que normalmente requiere un tiempo &lt;code&gt;O(1)&lt;/code&gt; constante. Sin embargo, ocasionalmente 'hipo' y tomar&amp;aacute; tiempo &lt;code&gt;O(N)&lt;/code&gt; para una operaci&amp;oacute;n aleatoria, porque tal vez necesite hacer algo de contabilidad o recolecci&amp;oacute;n de basura o algo as&amp;iacute; ... pero le promete que si tiene hipo, no lo har&amp;aacute;. hipo nuevamente para N m&amp;aacute;s operaciones. El costo en el peor de los casos sigue siendo &lt;code&gt;O(N)&lt;/code&gt; por operaci&amp;oacute;n, pero el costo amortizado &lt;em&gt;en muchas ejecuciones&lt;/em&gt; es &lt;code&gt;O(N)/N&lt;/code&gt; = &lt;code&gt;O(1)&lt;/code&gt; por operaci&amp;oacute;n. Debido a que las grandes operaciones son lo suficientemente raras, se puede considerar que la gran cantidad de trabajo ocasional se combina con el resto del trabajo como un factor constante. Decimos que el trabajo se &quot;amortiza&quot; en un n&amp;uacute;mero suficientemente grande de llamadas que desaparece asint&amp;oacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="bf7370e1d0177c50c4c0d7fb024561f2bab440cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Amortized and average-case complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Complejidad de casos amortizados y promedio&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab4389896132cbec29ee3f0554d686383b2d60f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Applications&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Applications&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b3d5404d360c404fd2bf84459010109192eb8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Attention!&lt;/strong&gt; The notation with the equal sign &quot;=&quot; uses a &quot;fake equality&quot;: it is true that o(g(x)) = O(g(x)), but false that O(g(x)) = o(g(x)).  Similarly, it is ok to write &quot;ln(x) = o(x) when x &amp;rarr; +&amp;infin;&quot;, but the formula &quot;o(x) = ln(x)&quot; would make no sense.</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;Atenci&amp;oacute;n!&lt;/strong&gt; La notaci&amp;oacute;n con el signo igual &quot;=&quot; usa una &quot;igualdad falsa&quot;: es cierto que o (g (x)) = O (g (x)), pero falso que O (g (x)) = o (g (X)). Del mismo modo, est&amp;aacute; bien escribir &quot;ln (x) = o (x) cuando x &amp;rarr; + &amp;infin;&quot;, pero la f&amp;oacute;rmula &quot;o (x) = ln (x)&quot; no tendr&amp;iacute;a sentido.</target>
        </trans-unit>
        <trans-unit id="34dd92c00819162397c366f49572746e28f5f1c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Average Case&lt;/strong&gt;: This is no more than using big-O notation for the expected value of a function, rather than the function itself. In the usual case where you consider all inputs to be equally likely, the average case is just the average of the running time. For example with quicksort, even though the worst-case is &lt;code&gt;O(N^2)&lt;/code&gt; for some really bad inputs, the average case is the usual &lt;code&gt;O(N log(N))&lt;/code&gt; (the really bad inputs are very small in number, so few that we don't notice them in the average case).</source>
          <target state="translated">&lt;strong&gt;Caso promedio&lt;/strong&gt; : esto no es m&amp;aacute;s que usar la notaci&amp;oacute;n big-O para el valor esperado de una funci&amp;oacute;n, en lugar de la funci&amp;oacute;n en s&amp;iacute;. En el caso habitual en el que considera que todas las entradas son igualmente probables, el caso promedio es solo el promedio del tiempo de ejecuci&amp;oacute;n. Por ejemplo, con quicksort, aunque el peor de los casos es &lt;code&gt;O(N^2)&lt;/code&gt; para algunas entradas realmente malas, el caso promedio es el &lt;code&gt;O(N log(N))&lt;/code&gt; habitual (N log (N)) (las entradas realmente malas son muy peque&amp;ntilde;as en n&amp;uacute;mero, por lo que pocos que no los notamos en el caso promedio).</target>
        </trans-unit>
        <trans-unit id="3220576162b61267d1a4a26767219ea6e4545c4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Back to English&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Volver al ingles&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0cac323801b8e9b2b0c915a6c542a3bbb241cb47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basics&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Basics&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deeb35e60114ce47ff18984e39930c946fc62ed4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Case:&lt;/strong&gt; In the telephone book search, the best case is that we find the name in one comparison.  This is &lt;strong&gt;O(1)&lt;/strong&gt; or &lt;strong&gt;constant complexity&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong&gt;Mejor caso:&lt;/strong&gt; en la b&amp;uacute;squeda de la gu&amp;iacute;a telef&amp;oacute;nica, el mejor caso es que encontremos el nombre en una comparaci&amp;oacute;n. Esto es &lt;strong&gt;O (1)&lt;/strong&gt; o &lt;strong&gt;complejidad constante&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="41bdf2eff0707b735977a7b17f99ea1599797803" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Case:&lt;/strong&gt; O(1);</source>
          <target state="translated">&lt;strong&gt;Mejor caso:&lt;/strong&gt; O (1);</target>
        </trans-unit>
        <trans-unit id="7914d10c281c86a759e82a40640c5f8d93756303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big O describes the fundamental scaling nature of an algorithm.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big O describe la naturaleza fundamental de escala de un algoritmo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e271d8846f3715b1a024f21916128b7d4259417" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big O&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big O&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dd5e066b9eba73f69ac911aaff371d1d5517277" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big-O notation is a relative representation of the complexity of an algorithm.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La notaci&amp;oacute;n Big-O es una representaci&amp;oacute;n relativa de la complejidad de un algoritmo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c911dd80e980898d8f2c1e27f8c346fb06ef9ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big-O notation:&lt;/strong&gt; describes &lt;em&gt;how quickly runtime will grow relative to the input as the input get arbitrarily large.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Notaci&amp;oacute;n Big-O:&lt;/strong&gt; describe &lt;em&gt;qu&amp;eacute; tan r&amp;aacute;pido crecer&amp;aacute; el tiempo de ejecuci&amp;oacute;n en relaci&amp;oacute;n con la entrada a medida que la entrada se vuelve arbitrariamente grande.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1070a59c780c49217b3d9ef6075f07036a4de4f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Building Intuition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Construyendo Intuici&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f587b858f8d6fe44a8225f82326a30f53c9d5650" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;By the time you get to 200 towns there isn't enough time left in the universe to solve the problem with traditional computers.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cuando llegas a 200 ciudades, no hay suficiente tiempo en el universo para resolver el problema con las computadoras tradicionales.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1d2d8d2f9c4e97fb709d00d85e5dfaceb74c57d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant factors&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Factores constantes&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9efca8768fe35240139284fbd68b4fe07fc97b92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Case:&lt;/strong&gt; As discussed above this is O(log n); and</source>
          <target state="translated">&lt;strong&gt;Caso esperado:&lt;/strong&gt; Como se discuti&amp;oacute; anteriormente, esto es O (log n); y</target>
        </trans-unit>
        <trans-unit id="9587614449d0127777f6fe21db3683733e748143" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Case:&lt;/strong&gt; O(n) (for 500,000); and</source>
          <target state="translated">&lt;strong&gt;Caso esperado:&lt;/strong&gt; O (n) (por 500,000); y</target>
        </trans-unit>
        <trans-unit id="cdd089580422378d4ca18f0f8f5cf50cf6b830ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do analyze algorithms and how can we compare algorithms against each other?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;C&amp;oacute;mo analizamos algoritmos y c&amp;oacute;mo podemos comparar algoritmos entre s&amp;iacute;?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea84419042cce91d342892912299eab7b4c9fa1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you're unlucky when executing A, it might take as much as X(n) operations to
  complete.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Si tiene mala suerte al ejecutar A, puede tomar hasta X (n) operaciones para completar.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5f526b740d48e1e3fd49fd9918ce4ec61555a90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multidimensional big-O&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big-O multidimensional&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6acc739d0b13f807318bf1624de37df1094994ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N&amp;sup2;&lt;/strong&gt; &amp;rarr; (2N)&amp;sup2; = 4(&lt;strong&gt;N&amp;sup2;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;N&amp;sup2;&lt;/strong&gt; &amp;rarr; (2N) &amp;sup2; = 4 ( &lt;strong&gt;N&amp;sup2;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="61702d5685c60ef63ef6fe3ad5ab08a71dd8a2d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N&lt;/strong&gt; &amp;rarr; (2N) = 2(&lt;strong&gt;N&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;N&lt;/strong&gt; &amp;rarr; (2N) = 2 ( &lt;strong&gt;N&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="21cce32ea86e14da51ca9a5664ed1f0ffeff0b0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Big O notation represents the &lt;strong&gt;worst-case scenario&lt;/strong&gt; of an algorithm. Let&amp;rsquo;s assume that &lt;strong&gt;O(1)&lt;/strong&gt; and &lt;strong&gt;O(n)&lt;/strong&gt; are the worst-case scenarios of the example above.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; La notaci&amp;oacute;n Big O representa el &lt;strong&gt;peor de los casos&lt;/strong&gt; de un algoritmo. Supongamos que &lt;strong&gt;O (1)&lt;/strong&gt; y &lt;strong&gt;O (n)&lt;/strong&gt; son los peores escenarios del ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="252fabf6945e589a9b0b19016a058e011afbcc3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(1):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68d75ca052377c566336069afee258c69b9aec6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1)&lt;/strong&gt; - Time to complete is the same regardless of the size of input set. An example is accessing an array element by index.</source>
          <target state="translated">&lt;strong&gt;O (1)&lt;/strong&gt; : el tiempo de finalizaci&amp;oacute;n es el mismo independientemente del tama&amp;ntilde;o del conjunto de entrada. Un ejemplo es acceder a un elemento de matriz por &amp;iacute;ndice.</target>
        </trans-unit>
        <trans-unit id="f9afcf401f691a7c75faeb32231d92fde83ecee4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1)&lt;/strong&gt;:  known as &lt;strong&gt;Constant complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (1)&lt;/strong&gt; : conocido como &lt;strong&gt;Complejidad constante&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dd564fa0710bbf0a0a6d4f2c0d4f0f4442e00d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e72a614b62847ef5617dfe85cfaca13129fb5ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; ):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="635e753fee8296bf321ba6bb90e4518245442fc7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d4b1b888d0086c21997e7a8ecfa829f30374361" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22ac35f2cdc52d148b68da9ed9dd29461e980fe3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(Log N)&lt;/strong&gt; - Time to complete increases roughly in line with the log2(n). For example 1024 items takes roughly twice as long as 32 items, because Log2(1024) = 10 and Log2(32) = 5. An example is finding an item in a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;binary search tree&lt;/a&gt; (BST).</source>
          <target state="translated">&lt;strong&gt;O (Log N)&lt;/strong&gt; : el tiempo para completar aumenta aproximadamente en l&amp;iacute;nea con el log2 (n). Por ejemplo, 1024 elementos requieren aproximadamente el doble de 32 elementos, porque Log2 (1024) = 10 y Log2 (32) = 5. Un ejemplo es encontrar un elemento en un &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;&amp;aacute;rbol de b&amp;uacute;squeda binario&lt;/a&gt; (BST).</target>
        </trans-unit>
        <trans-unit id="d26adbc9eb537a7d0d5f9ae0552e61b12d6c54bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N Log N)&lt;/strong&gt; - Time to complete increases by the number of items times the result of Log2(N). An example of this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap_sort&quot;&gt;heap sort&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Quick_sort&quot;&gt;quick sort&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O (N Log N)&lt;/strong&gt; : el tiempo para completar aumenta en el n&amp;uacute;mero de elementos multiplicado por el resultado de Log2 (N). Un ejemplo de esto es la &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap_sort&quot;&gt;ordenaci&amp;oacute;n en mont&amp;oacute;n&lt;/a&gt; y &lt;a href=&quot;http://en.wikipedia.org/wiki/Quick_sort&quot;&gt;la ordenaci&amp;oacute;n r&amp;aacute;pida&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd630f970ed12459c9538aee894e4fca49869a98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N!)&lt;/strong&gt; - Time to complete is the factorial of the input set. An example of this is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;traveling salesman problem brute-force solution&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O (N!)&lt;/strong&gt; : El tiempo para completar es el factorial del conjunto de entrada. Un ejemplo de esto es la &lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;soluci&amp;oacute;n de fuerza bruta del problema del vendedor ambulante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2e179b7e171e252effc28bae4e6ee136e75dba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N)&lt;/strong&gt; - Time to complete that scales linearly with the size of the input set. In other words if you double the number of items in the input set, the algorithm takes roughly twice as long. An example is counting the number of items in a linked list.</source>
          <target state="translated">&lt;strong&gt;O (N)&lt;/strong&gt; : tiempo para completar que se escala linealmente con el tama&amp;ntilde;o del conjunto de entrada. En otras palabras, si duplica el n&amp;uacute;mero de elementos en el conjunto de entrada, el algoritmo dura aproximadamente el doble. Un ejemplo es contar el n&amp;uacute;mero de elementos en una lista vinculada.</target>
        </trans-unit>
        <trans-unit id="4784dc4311f56c18cde15b50f60f2194c6df45fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N^2)&lt;/strong&gt; - Time to complete is roughly equal to the square of the number of items. An example of this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;bubble sort&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O (N ^ 2)&lt;/strong&gt; : el tiempo para completar es aproximadamente igual al cuadrado del n&amp;uacute;mero de elementos. Un ejemplo de esto es &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;el tipo de burbuja&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf8d37b23321b288f2b44644bc4c145c6315466f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log &lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (log &lt;em&gt;n&lt;/em&gt; ):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32f6df92bfa553861340db36e2f34e2204cc3856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log n)&lt;/strong&gt;:  known as &lt;strong&gt;Logarithmic complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (log n)&lt;/strong&gt; : conocido como &lt;strong&gt;complejidad logar&amp;iacute;tmica&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9a156d671486ba42c9d6bc4f718b4ad56ae4429" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n)&lt;/strong&gt;:  known as &lt;strong&gt;Linear complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (n)&lt;/strong&gt; : conocido como &lt;strong&gt;complejidad lineal&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25021c74f1f7cc3f73ce24095087c41055c38051" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;:  known as &lt;strong&gt;Quadratic complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O (n &lt;sup&gt;2&lt;/sup&gt; )&lt;/strong&gt; : conocida como &lt;strong&gt;complejidad cuadr&amp;aacute;tica&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ad18baa396b629a872133cacda5df06a167689b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Practical example: visualizing orders of growth while coding&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ejemplo pr&amp;aacute;ctico: visualizar &amp;oacute;rdenes de crecimiento mientras se codifica&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee51f001b7ef2c276ec42b4e704f02dd05a4cccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt; : &lt;a href=&quot;http://carlcheo.com/compsci&quot;&gt;http://carlcheo.com/compsci&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;Referencia&lt;/strong&gt; : &lt;a href=&quot;http://carlcheo.com/compsci&quot;&gt;http://carlcheo.com/compsci&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63fd89842e817d63e08af214f7f5c992e4999387" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplest way to look at it (in plain English)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La forma m&amp;aacute;s simple de verlo (en ingl&amp;eacute;s simple)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f8b58e2bc4650ab1f5fd985238dd4f0a986d132" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Small o&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Peque&amp;ntilde;o o&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff25f85074d21875430e07bd8801b858e31f7be6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Space complexity:&lt;/strong&gt; aside from time complexity, we also care about space complexity (how much memory/space an algorithm uses). Instead of checking the time of operations, we check the size of the allocation of memory.</source>
          <target state="translated">&lt;strong&gt;Complejidad del espacio:&lt;/strong&gt; adem&amp;aacute;s de la complejidad del tiempo, tambi&amp;eacute;n nos importa la complejidad del espacio (cu&amp;aacute;nta memoria / espacio utiliza un algoritmo). En lugar de verificar el tiempo de las operaciones, verificamos el tama&amp;ntilde;o de la asignaci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aea48c460158f9801c2ff1547226bfcd94a4ab48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The whole story&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;La historia completa&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5841737d9f1f0f3920b87ca2d61ff0c8311a9f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are seven most used notations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hay siete anotaciones m&amp;aacute;s utilizadas&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="898a1558a3534794d5a58e6000c3473375b52eb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There's also Big-Omega, which represent complexity of the Best-Case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tambi&amp;eacute;n est&amp;aacute; Big-Omega, que representa la complejidad del Mejor Caso:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a11037fecab22049818b34474fe8e78b05b5b18c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To find The Big-O on Time Complexity:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Para encontrar la complejidad de Big-O on Time:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07f6120a26e2f3f8456ca56f2c44ce3f39c3119c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We only care about the most significant portion of complexity.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Solo nos importa la parte m&amp;aacute;s significativa de la complejidad.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7974c46035c46b41ac44b7f0b9e92098bfa014df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why O(N) is sometimes the best you can do, i.e. why we need datastructures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Por qu&amp;eacute; O (N) es a veces lo mejor que puede hacer, es decir, por qu&amp;eacute; necesitamos estructuras de datos&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4207c81d75e6ff00a2ab700fd03b10c9d6ef7476" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst Case:&lt;/strong&gt; O(n) (for 1,000,000).</source>
          <target state="translated">&lt;strong&gt;Peor caso:&lt;/strong&gt; O (n) (por 1,000,000).</target>
        </trans-unit>
        <trans-unit id="575be9f02c898b973aff9fb1bd5bd357e2752a80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst Case:&lt;/strong&gt; This is also O(log n).</source>
          <target state="translated">&lt;strong&gt;Peor caso:&lt;/strong&gt; esto tambi&amp;eacute;n es O (log n).</target>
        </trans-unit>
        <trans-unit id="8259671e56bc51a9fd25fab5b93ec32f6a9f6007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;algorithm&lt;/strong&gt;: procedure/formula for solving a problem</source>
          <target state="translated">&lt;strong&gt;algoritmo&lt;/strong&gt; : procedimiento / f&amp;oacute;rmula para resolver un problema</target>
        </trans-unit>
        <trans-unit id="bf91eb2b18b1a94ff6bc8b8c14b3d1250c603cbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;analogy&lt;/strong&gt;: The analogy in this particular case is a jigsaw puzzle: We created a data structure that exploits some property of the data. If our road segments are like puzzle pieces, we group them by matching color and pattern. We then exploit this to avoid doing extra work later (comparing puzzle pieces of like color to each other, not to every other single puzzle piece).</source>
          <target state="translated">&lt;strong&gt;analog&amp;iacute;a&lt;/strong&gt; : la analog&amp;iacute;a en este caso particular es un rompecabezas: creamos una estructura de datos que explota algunas propiedades de los datos. Si nuestros segmentos de camino son como piezas de rompecabezas, los agrupamos combinando el color y el patr&amp;oacute;n. Luego explotamos esto para evitar hacer un trabajo adicional m&amp;aacute;s tarde (comparar piezas de rompecabezas de un color similar entre s&amp;iacute;, no con cada otra pieza del rompecabezas).</target>
        </trans-unit>
        <trans-unit id="3fd5be370782e9eefda17f79f700c59070a53c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;c log(N)&lt;/strong&gt; &amp;rarr; c log(2N) = (c log(2))+(&lt;strong&gt;c log(N)&lt;/strong&gt;) = (fixed amount)+(&lt;strong&gt;c log(N)&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;c log (N)&lt;/strong&gt; &amp;rarr; c log (2N) = (c log (2)) + ( &lt;strong&gt;c log (N)&lt;/strong&gt; ) = (cantidad fija) + ( &lt;strong&gt;c log (N)&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="6bd6f3f7face459b8ad4a2440f178d8320099c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;c*1&lt;/strong&gt; &amp;rarr; &lt;strong&gt;c*1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;c * 1&lt;/strong&gt; &amp;rarr; &lt;strong&gt;c * 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae34a86dbd8e294559fb6de015a86203c6d6210c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; &amp;rarr; c(2N)&amp;sup3; = 8(&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; &amp;rarr; c (2N) &amp;sup3; = 8 ( &lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="27b5788854d51bd893ea7a5207a2a3c0a233aee4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;complexity:&lt;/strong&gt; if it takes me one second to sort 10,000 elements, how long will it take me to sort one million?  Complexity in this instance is a relative measure to something else.</source>
          <target state="translated">&lt;strong&gt;complejidad:&lt;/strong&gt; si me lleva un segundo ordenar 10.000 elementos, &amp;iquest;cu&amp;aacute;nto tiempo me llevar&amp;aacute; ordenar un mill&amp;oacute;n? La complejidad en este caso es una medida relativa a otra cosa.</target>
        </trans-unit>
        <trans-unit id="5457665c30d0585dc37a4fd244075c3a2b2ad61b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for &quot;sufficiently&quot; large inputs...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;para entradas &quot;suficientemente&quot; grandes ...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2acb65b1907221e1bdd5284f08ac1b0df4ea0231" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;relative:&lt;/strong&gt; you can only compare apples to apples.  You can't compare an algorithm to do arithmetic multiplication to an algorithm that sorts a list of integers.  But a comparison of two algorithms to do arithmetic operations (one multiplication, one addition) will tell you something meaningful;</source>
          <target state="translated">&lt;strong&gt;pariente:&lt;/strong&gt; solo puedes comparar manzanas con manzanas. No puede comparar un algoritmo para hacer multiplicaci&amp;oacute;n aritm&amp;eacute;tica con un algoritmo que ordena una lista de enteros. Pero una comparaci&amp;oacute;n de dos algoritmos para realizar operaciones aritm&amp;eacute;ticas (una multiplicaci&amp;oacute;n, una suma) le dar&amp;aacute; algo significativo;</target>
        </trans-unit>
        <trans-unit id="527b57aaeb37446d8c211474a094432da292f875" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;representation:&lt;/strong&gt; Big-O (in its simplest form) reduces the comparison between algorithms to a single variable.  That variable is chosen based on observations or assumptions.  For example, sorting algorithms are typically compared based on comparison operations (comparing two nodes to determine their relative ordering).  This assumes that comparison is expensive.  But what if comparison is cheap but swapping is expensive?  It changes the comparison; and</source>
          <target state="translated">&lt;strong&gt;representaci&amp;oacute;n:&lt;/strong&gt; Big-O (en su forma m&amp;aacute;s simple) reduce la comparaci&amp;oacute;n entre algoritmos a una sola variable. Esa variable se elige en base a observaciones o suposiciones. Por ejemplo, los algoritmos de clasificaci&amp;oacute;n generalmente se comparan en funci&amp;oacute;n de las operaciones de comparaci&amp;oacute;n (comparar dos nodos para determinar su orden relativo). Esto supone que la comparaci&amp;oacute;n es cara. Pero, &amp;iquest;qu&amp;eacute; pasa si la comparaci&amp;oacute;n es barata pero el intercambio es costoso? Cambia la comparaci&amp;oacute;n; y</target>
        </trans-unit>
        <trans-unit id="19518fd2e0a8446c92d07859c82f3fdb9396de2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr: The number of handshakes 'looks like' x&amp;sup2; so much for large values, that if we were to write down the ratio #handshakes/x&amp;sup2;, the fact that we don't need &lt;em&gt;exactly&lt;/em&gt; x&amp;sup2; handshakes wouldn't even show up in the decimal for an arbitrarily large while.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tl; dr: El n&amp;uacute;mero de apretones de manos 'parece' x&amp;sup2; tanto para valores grandes, que si escribi&amp;eacute;ramos la proporci&amp;oacute;n # handshakes / x&amp;sup2;, el hecho de que no necesitamos &lt;em&gt;exactamente&lt;/em&gt; apretones de manos x&amp;sup2; ni siquiera aparecer&amp;iacute;a en el decimal por un tiempo arbitrariamente grande.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc58ee0a287cef32ca985382490b5ed483c76fc8" translate="yes" xml:space="preserve">
          <source>A &amp;rarr; B &amp;rarr; C</source>
          <target state="translated">A &amp;rarr; B &amp;rarr; C</target>
        </trans-unit>
        <trans-unit id="9814460aaaa82f895fab69aa1e7b80cc39fcf625" translate="yes" xml:space="preserve">
          <source>A &amp;rarr; C &amp;rarr; B</source>
          <target state="translated">A &amp;rarr; C &amp;rarr; B</target>
        </trans-unit>
        <trans-unit id="6fa316481ef216118bd579775f4816b14c18a0f7" translate="yes" xml:space="preserve">
          <source>A simple straightforward answer can be:</source>
          <target state="translated">Una respuesta simple y directa puede ser:</target>
        </trans-unit>
        <trans-unit id="2fa68420a293bc47b500623963e3f939ae51a473" translate="yes" xml:space="preserve">
          <source>A typical implementation might be to open up to the middle, take the 500,000&lt;sup&gt;th&lt;/sup&gt; and compare it to &quot;Smith&quot;. If it happens to be &quot;Smith, John&quot;, we just got real lucky.  Far more likely is that &quot;John Smith&quot; will be before or after that name.  If it's after we then divide the last half of the phone book in half and repeat.  If it's before then we divide the first half of the phone book in half and repeat.  And so on.</source>
          <target state="translated">Una implementaci&amp;oacute;n t&amp;iacute;pica podr&amp;iacute;a ser abrirse al medio, tomar el 500,000 y compararlo con &quot;Smith&quot;. Si resulta ser &quot;Smith, John&quot;, tenemos mucha suerte. Mucho m&amp;aacute;s probable es que &quot;John Smith&quot; aparezca antes o despu&amp;eacute;s de ese nombre. Si es despu&amp;eacute;s, dividimos la &amp;uacute;ltima mitad de la gu&amp;iacute;a telef&amp;oacute;nica a la mitad y repetimos. Si es antes, dividimos la primera mitad de la gu&amp;iacute;a telef&amp;oacute;nica a la mitad y repetimos. Y as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="b2eaa9e11c09c682e15e1f9214b1b8f85ad77873" translate="yes" xml:space="preserve">
          <source>Addition is the simplest.  You line the numbers up (to the right) and add the digits in a column writing the last number of that addition in the result.  The 'tens' part of that number is carried over to the next column.</source>
          <target state="translated">La adición es la más simple.Se alinean los números (a la derecha)y se suman los dígitos en una columna escribiendo el último número de esa suma en el resultado.La parte de las &quot;decenas&quot; de ese número se pasa a la siguiente columna.</target>
        </trans-unit>
        <trans-unit id="06a8ddf90a58cac434d9dddb41eadc549d53c934" translate="yes" xml:space="preserve">
          <source>Also keep in mind that due to hidden constraints of your program, you might not really care about asymptotic behavior. You may be working with a bounded number of values, for example:</source>
          <target state="translated">También tenga en cuenta que debido a las restricciones ocultas de su programa,puede que no le importe realmente el comportamiento asintótico.Puede que estés trabajando con un número limitado de valores,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="580cbd5744ce3d45f6d2b723b41c7344947edda0" translate="yes" xml:space="preserve">
          <source>Although anything &quot;larger&quot; than a constant factor can be detected, however.</source>
          <target state="translated">Aunque se puede detectar cualquier cosa &quot;más grande&quot; que un factor constante,sin embargo.</target>
        </trans-unit>
        <trans-unit id="f5bfda3d2781b7d70658d5d11b9d005ba3e1398e" translate="yes" xml:space="preserve">
          <source>Amortized worst-case: If you use an amortized worst-case data structure, the performance is guaranteed to be within the amortized worst-case... eventually (even if the inputs are chosen by an evil demon who knows everything and is trying to screw you over). Usually, we use this to analyze algorithms that may be very 'choppy' in performance with unexpected large hiccups, but over time perform just as well as other algorithms. (However unless your data structure has upper limits for much outstanding work it is willing to procrastinate on, an evil attacker could perhaps force you to catch up on the maximum amount of procrastinated work all-at-once.</source>
          <target state="translated">El peor caso amortizado:Si utilizas una estructura de datos del peor de los casos amortizados,se garantiza que el rendimiento estará dentro del peor de los casos amortizados...eventualmente (incluso si las entradas son elegidas por un demonio malvado que lo sabe todo y está tratando de fastidiarte).Normalmente,usamos esto para analizar algoritmos que pueden ser muy &quot;entrecortados&quot; en su rendimiento con grandes hipo inesperados,pero con el tiempo funcionan tan bien como otros algoritmos.(Sin embargo,a menos que su estructura de datos tenga límites superiores para mucho trabajo sobresaliente que esté dispuesto a postergar,un malvado atacante podría quizás forzarlo a ponerse al día con la máxima cantidad de trabajo postergado de una sola vez.</target>
        </trans-unit>
        <trans-unit id="c08025d0af34b0e733dff69c38b8140014e0dcfb" translate="yes" xml:space="preserve">
          <source>And furthermore</source>
          <target state="translated">Y además</target>
        </trans-unit>
        <trans-unit id="6896d57deefe7dcce6486c33a6e908bb66a0f2d5" translate="yes" xml:space="preserve">
          <source>Another point I wanted to make quick mention of is that any algorithm that has a complexity of &lt;strong&gt;O(n&lt;sup&gt;a&lt;/sup&gt;)&lt;/strong&gt; is said to have &lt;strong&gt;polynomial complexity&lt;/strong&gt; or is solvable in &lt;strong&gt;polynomial time&lt;/strong&gt;.</source>
          <target state="translated">Otro punto del que quer&amp;iacute;a hacer una menci&amp;oacute;n r&amp;aacute;pida es que cualquier algoritmo que tenga una complejidad de &lt;strong&gt;O (n &lt;sup&gt;a&lt;/sup&gt; )&lt;/strong&gt; se dice que tiene una &lt;strong&gt;complejidad polin&amp;oacute;mica&lt;/strong&gt; o que se puede resolver en el &lt;strong&gt;tiempo polin&amp;oacute;mico&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="18d608bf5ee39a542ef2abc8b2c8aa9502e49075" translate="yes" xml:space="preserve">
          <source>Anyone who's read Programming Pearls or any other Computer Science
  books and doesn&amp;rsquo;t have a grounding in Mathematics will have hit a wall
  when they reached chapters that mention O(N log N) or other seemingly
  crazy syntax. Hopefully this article will help you gain an
  understanding of the basics of Big O and Logarithms.</source>
          <target state="translated">Cualquiera que haya le&amp;iacute;do Programming Pearls o cualquier otro libro de Ciencias de la Computaci&amp;oacute;n y no tenga una base en Matem&amp;aacute;ticas se habr&amp;aacute; topado con una pared cuando llegue a cap&amp;iacute;tulos que mencionan O (N log N) u otra sintaxis aparentemente loca. Esperemos que este art&amp;iacute;culo lo ayude a comprender los conceptos b&amp;aacute;sicos de Big O y Logarithms.</target>
        </trans-unit>
        <trans-unit id="ca7668976286f5ad8d5eca2a7fadcc44aba0a83b" translate="yes" xml:space="preserve">
          <source>Anyway, that's it for my (hopefully plain English) explanation of Big O (revised).</source>
          <target state="translated">De todos modos,eso es todo para mi (esperemos que en inglés)explicación de Big O (revisada).</target>
        </trans-unit>
        <trans-unit id="010115fea8e63b4e720d7c742f8033325bf02f8e" translate="yes" xml:space="preserve">
          <source>As &lt;em&gt;n&lt;/em&gt; gets arbitrarily large, focus on the terms that will grow the fastest as n gets large (think infinity) AKA &lt;strong&gt;asymptotic analysis&lt;/strong&gt;</source>
          <target state="translated">A medida que &lt;em&gt;n se&lt;/em&gt; hace arbitrariamente grande, conc&amp;eacute;ntrese en los t&amp;eacute;rminos que crecer&amp;aacute;n m&amp;aacute;s r&amp;aacute;pido a medida que n se hace grande (piense en el infinito), tambi&amp;eacute;n conocido como &lt;strong&gt;an&amp;aacute;lisis asint&amp;oacute;tico.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="870ad13cbf6243c698d7d2bf03ab24ac0048aa57" translate="yes" xml:space="preserve">
          <source>As a programmer first and a mathematician second (or maybe third or
  fourth) I found the best way to understand Big O thoroughly was to
  produce some examples in code. So, below are some common orders of
  growth along with descriptions and examples where possible.</source>
          <target state="translated">Como programador primero y matemático segundo (o tal vez tercero o cuarto)encontré que la mejor manera de entender a fondo el Big O era producir algunos ejemplos en código.Así que,a continuación hay algunos órdenes comunes de crecimiento junto con descripciones y ejemplos cuando sea posible.</target>
        </trans-unit>
        <trans-unit id="483f1c4417fdd5afc1f2915ce24ff5ba0f7520e8" translate="yes" xml:space="preserve">
          <source>As a purely mathematical construct, big-O notation is not limited to talking about processing time and memory. You can use it to discuss the asymptotics of anything where scaling is meaningful, such as:</source>
          <target state="translated">Como una construcción puramente matemática,la notación big-O no se limita a hablar del tiempo de procesamiento y la memoria.Se puede usar para hablar de la asintótica de cualquier cosa en la que la escalada sea significativa,como:</target>
        </trans-unit>
        <trans-unit id="d7f64f73685e6f247cbf73eed79f3d10cdb73567" translate="yes" xml:space="preserve">
          <source>As a result of all this unhelpful complexity, people try to describe the speed of software programs using the smallest and least complex (mathematical) expressions possible. These expressions are very very crude approximations: Although, with a bit of luck, they will capture the &quot;essence&quot; of whether a piece of software is fast or slow.</source>
          <target state="translated">Como resultado de toda esta complejidad inútil,la gente trata de describir la velocidad de los programas de software usando las expresiones (matemáticas)más pequeñas y menos complejas posibles.Estas expresiones son aproximaciones muy,muy crudas:Aunque,con un poco de suerte,capturarán la &quot;esencia&quot; de si un software es rápido o lento.</target>
        </trans-unit>
        <trans-unit id="7f8315a19f8a52da5d9ef1a40ab83006a844cfd3" translate="yes" xml:space="preserve">
          <source>As it happens, there are certain functions (think of them as &lt;em&gt;implementations&lt;/em&gt; of &lt;strong&gt;X(n)&lt;/strong&gt;) that tend to occur quite often. These are well known and easily compared (Examples: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Log N&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;N^2&lt;/code&gt;, &lt;code&gt;N!&lt;/code&gt;, etc..)</source>
          <target state="translated">Como sucede, hay ciertas funciones (piense en ellas como &lt;em&gt;implementaciones&lt;/em&gt; de &lt;strong&gt;X (n)&lt;/strong&gt; ) que tienden a ocurrir con bastante frecuencia. Estos son bien conocidos y f&amp;aacute;ciles de comparar (Ejemplos: &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;Log N&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;N^2&lt;/code&gt; , &lt;code&gt;N!&lt;/code&gt; , Etc.)</target>
        </trans-unit>
        <trans-unit id="58635748eb80ad2370517e468a337e1bd88c9cc8" translate="yes" xml:space="preserve">
          <source>As the algorithm scales with n-&lt;em&gt;squared&lt;/em&gt;, this is &lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt; or &lt;strong&gt;quadratic complexity&lt;/strong&gt;. This is a good time to introduce another important concept:</source>
          <target state="translated">A medida que el algoritmo se escala con n &lt;em&gt;cuadrado&lt;/em&gt; , esto es &lt;strong&gt;O (n &lt;sup&gt;2&lt;/sup&gt; )&lt;/strong&gt; o &lt;strong&gt;complejidad cuadr&amp;aacute;tica&lt;/strong&gt; . Este es un buen momento para presentar otro concepto importante:</target>
        </trans-unit>
        <trans-unit id="db509c6991e60440b1722a307f8ef3f99bc3043d" translate="yes" xml:space="preserve">
          <source>Assume we're talking about an algorithm &lt;strong&gt;A&lt;/strong&gt;, which should do something with a dataset of size &lt;strong&gt;n&lt;/strong&gt;.</source>
          <target state="translated">Supongamos que estamos hablando de un algoritmo &lt;strong&gt;A&lt;/strong&gt; , que deber&amp;iacute;a hacer algo con un conjunto de datos de tama&amp;ntilde;o &lt;strong&gt;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5e269fc76f0e879e9586e4d2d5b07a5bf29feecd" translate="yes" xml:space="preserve">
          <source>Asymptotic notation is, at its core, quite separate from programming. Asymptotic notation is a mathematical framework for thinking about how things scale and can be used in many different fields. That said... this is how you &lt;em&gt;apply&lt;/em&gt; asymptotic notation to coding.</source>
          <target state="translated">La notaci&amp;oacute;n asint&amp;oacute;tica est&amp;aacute;, en esencia, bastante separada de la programaci&amp;oacute;n. La notaci&amp;oacute;n asint&amp;oacute;tica es un marco matem&amp;aacute;tico para pensar c&amp;oacute;mo las cosas se escalan y se pueden usar en muchos campos diferentes. Dicho esto ... as&amp;iacute; es como se &lt;em&gt;aplica&lt;/em&gt; la notaci&amp;oacute;n asint&amp;oacute;tica a la codificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b1fcf30b1f3fc218decd89222f7ae2f077cdd616" translate="yes" xml:space="preserve">
          <source>At some point, at some time, there will be no swaps, and our sort of the deck would be done.  So much work!</source>
          <target state="translated">En algún momento,en algún momento,no habrá intercambios,y nuestra especie de cubierta estará terminada.¡Tanto trabajo!</target>
        </trans-unit>
        <trans-unit id="bfb8cbb068a5baea44b500d50ed4ead05e487564" translate="yes" xml:space="preserve">
          <source>At some point, this loop (from Two to Three) will end.  It ends when both halves of this search meet at the splay card.  Then, we have just splayed the deck with the card you chose in step One.  Now, all the cards near the start are more low than the splay card; and the cards near the end are more high than the splay card.  Cool trick!</source>
          <target state="translated">En algún momento,este bucle (de dos a tres)terminará.Termina cuando las dos mitades de esta búsqueda se encuentran en la tarjeta de juego.Entonces,acabamos de separar la baraja con la carta que elegiste en el paso uno.Ahora,todas las cartas cercanas al inicio son más bajas que la carta de juego;y las cartas cercanas al final son más altas que la carta de juego.Un truco genial!</target>
        </trans-unit>
        <trans-unit id="6ad9a691d1120dce91af1178eb6b497f4f7e37f7" translate="yes" xml:space="preserve">
          <source>Average-case: We make some assumptions about our inputs; i.e. if our inputs have different probabilities, then our outputs/runtimes will have different probabilities (which we take the average of). Usually, we assume that our inputs are all equally likely (uniform probability), but if the real-world inputs don't fit our assumptions of &quot;average input&quot;, the average output/runtime calculations may be meaningless. If you anticipate uniformly random inputs though, this is useful to think about!</source>
          <target state="translated">Un caso promedio:Hacemos algunas suposiciones sobre nuestras entradas;es decir,si nuestras entradas tienen diferentes probabilidades,entonces nuestras salidas tendrán diferentes probabilidades (de las cuales tomamos el promedio).Normalmente,suponemos que nuestras entradas tienen todas la misma probabilidad (probabilidad uniforme),pero si las entradas del mundo real no se ajustan a nuestras suposiciones de &quot;entrada media&quot;,los cálculos del tiempo de salida medio pueden carecer de sentido.Sin embargo,si se anticipan entradas uniformemente aleatorias,¡es útil pensar en esto!</target>
        </trans-unit>
        <trans-unit id="832a8d90127d5ca48f6556477abd38a77ce36f33" translate="yes" xml:space="preserve">
          <source>B &amp;rarr; A &amp;rarr; C</source>
          <target state="translated">B &amp;rarr; A &amp;rarr; C</target>
        </trans-unit>
        <trans-unit id="d813322c7a347a65c04fed32bbe445579ce7e1e8" translate="yes" xml:space="preserve">
          <source>B &amp;rarr; C &amp;rarr; A</source>
          <target state="translated">B &amp;rarr; C &amp;rarr; A</target>
        </trans-unit>
        <trans-unit id="cc07b18b222d704f4ad25abdb8dc152106fba5a0" translate="yes" xml:space="preserve">
          <source>Back to the telephone book.</source>
          <target state="translated">Volvamos a la guía telefónica.</target>
        </trans-unit>
        <trans-unit id="56a13e8f97147d6679bf9d3baf62cda1ea3b33ca" translate="yes" xml:space="preserve">
          <source>Back up a bit: the number of handshakes is exactly n-choose-2 or &lt;code&gt;N*(N-1)/2&lt;/code&gt; (each of N people shakes the hands of N-1 other people, but this double-counts handshakes so divide by 2):</source>
          <target state="translated">Retroceda un poco: la cantidad de apretones de manos es exactamente n-choose-2 o &lt;code&gt;N*(N-1)/2&lt;/code&gt; (cada una de las N personas le da la mano a N-1 a otras personas, pero esta doble cuenta de apretones de manos, as&amp;iacute; que div&amp;iacute;dala por 2):</target>
        </trans-unit>
        <trans-unit id="5120b09510b1d63d87c9c5faa58192336bbcb191" translate="yes" xml:space="preserve">
          <source>Based on the mathematical definition above, if you say your algorithm is a Big O of n, it means it is a function of n (number of input parameters) &lt;strong&gt;or faster&lt;/strong&gt;. If your algorithm is Big O of n, then it is also automatically the Big O of n square.</source>
          <target state="translated">Seg&amp;uacute;n la definici&amp;oacute;n matem&amp;aacute;tica anterior, si dice que su algoritmo es un Big O de n, significa que es una funci&amp;oacute;n de n (n&amp;uacute;mero de par&amp;aacute;metros de entrada) &lt;strong&gt;o m&amp;aacute;s r&amp;aacute;pido&lt;/strong&gt; . Si su algoritmo es Big O de n, entonces tambi&amp;eacute;n es autom&amp;aacute;ticamente el Big O de n cuadrado.</target>
        </trans-unit>
        <trans-unit id="db284bf74073477f62953e8e8e02b1401e213f94" translate="yes" xml:space="preserve">
          <source>Because they are approximations, we use the letter &quot;O&quot; (Big Oh) in the expression, as a convention to signal to the reader that we are making a gross oversimplification. (And to make sure that nobody mistakenly thinks that the expression is in any way accurate).</source>
          <target state="translated">Debido a que son aproximaciones,usamos la letra &quot;O&quot; (Gran Oh)en la expresión,como una convención para señalar al lector que estamos haciendo una gran simplificación.(Y para asegurarnos de que nadie piense erróneamente que la expresión es de alguna manera exacta).</target>
        </trans-unit>
        <trans-unit id="ac9bfd81f5e9c61b91f03629f317cefc5ed3f40a" translate="yes" xml:space="preserve">
          <source>Best-Case: the key is the first item.</source>
          <target state="translated">En el mejor de los casos:la llave es el primer elemento.</target>
        </trans-unit>
        <trans-unit id="8871063a9de2c96323fce812e3e16047b1b9b0c8" translate="yes" xml:space="preserve">
          <source>Big O comes in and says: for a deck of n cards, to sort it this way will be done in O(N squared) time.</source>
          <target state="translated">Big O entra y dice:para una baraja de n cartas,ordenarla de esta manera se hará en tiempo de O(N al cuadrado).</target>
        </trans-unit>
        <trans-unit id="e28ca34381715acfd2716526a419b0f386a39327" translate="yes" xml:space="preserve">
          <source>Big O complexity can be visualized with this graph:</source>
          <target state="translated">La complejidad de Big O puede ser visualizada con este gráfico:</target>
        </trans-unit>
        <trans-unit id="01191d73dc858c84e96603e205ce6cf90b305595" translate="yes" xml:space="preserve">
          <source>Big O describes an upper limit on the growth behaviour of a function, for example the runtime of a program, when inputs become large.</source>
          <target state="translated">Big O describe un límite superior en el comportamiento de crecimiento de una función,por ejemplo el tiempo de ejecución de un programa,cuando las entradas se vuelven grandes.</target>
        </trans-unit>
        <trans-unit id="6d6c6ee7d49379298994bf2d0373e24c46b6260e" translate="yes" xml:space="preserve">
          <source>Big O does not solve the work for us.  Big O tells us how hard the work is.</source>
          <target state="translated">Big O no resuelve el trabajo por nosotros.Big O nos dice lo duro que es el trabajo.</target>
        </trans-unit>
        <trans-unit id="067d8c2c09524ec3079760262aecc198a00b16eb" translate="yes" xml:space="preserve">
          <source>Big O ignores factors that do not contribute in a meaningful way to the growth curve of a function as the input size increases towards infinity. This means that constants that are added to or multiplied by the function are simply ignored.</source>
          <target state="translated">Big O ignora los factores que no contribuyen de manera significativa a la curva de crecimiento de una función a medida que el tamaño de la entrada aumenta hacia el infinito.Esto significa que las constantes que se añaden o multiplican por la función son simplemente ignoradas.</target>
        </trans-unit>
        <trans-unit id="5ef0b065d98e11f17dc80d42a717ef47eb65fe1e" translate="yes" xml:space="preserve">
          <source>Big O is a measure of how much time/space an algorithm uses relative to the size of its input.</source>
          <target state="translated">La gran O es una medida de la cantidad de espacio temporal que utiliza un algoritmo en relación con el tamaño de su entrada.</target>
        </trans-unit>
        <trans-unit id="7e04dd1651f885b1cee3374bf9f1eb929407c8c2" translate="yes" xml:space="preserve">
          <source>Big O is just a way to &quot;Express&quot; yourself in a common way, &quot;How much time / space does it take to run my code?&quot;.</source>
          <target state="translated">Big O es sólo una forma de &quot;Expresarse&quot; de una manera común,&quot;¿Cuánto espacio de tiempo se necesita para ejecutar mi código?&quot;.</target>
        </trans-unit>
        <trans-unit id="615e13e08dc48881c60e9af49cb00312f337463a" translate="yes" xml:space="preserve">
          <source>Big O is useful to compare how well two algorithms will scale up as the number of inputs is increased.</source>
          <target state="translated">Big O es útil para comparar lo bien que dos algoritmos se escalan al aumentar el número de entradas.</target>
        </trans-unit>
        <trans-unit id="d8cd4344a90d7e5c64b849cbdbe8173c868330b0" translate="yes" xml:space="preserve">
          <source>Big O is your friend and mine.  Big O helps us think on how much work we have to do, so we can plan.  And, if we are friends with big O, he can help us choose work that is not so hard!</source>
          <target state="translated">Big O es tu amigo y el mío.Big O nos ayuda a pensar en cuánto trabajo tenemos que hacer,para poder planear.Y,si somos amigos de Big O,él puede ayudarnos a elegir un trabajo que no sea tan difícil.</target>
        </trans-unit>
        <trans-unit id="63a54321034901fba163b3e5364e8adebdcce5cc" translate="yes" xml:space="preserve">
          <source>Big O notation also shines a spotlight directly on the most important principle of computer programming/engineering, the fact which inspires all good programmers to keep thinking and dreaming: the only way to achieve results beyond the slow forward march of technology is to &lt;em&gt;invent a better algorithm&lt;/em&gt;.</source>
          <target state="translated">La notaci&amp;oacute;n Big O tambi&amp;eacute;n destaca directamente el principio m&amp;aacute;s importante de la programaci&amp;oacute;n / ingenier&amp;iacute;a de computadoras, el hecho que inspira a todos los buenos programadores a seguir pensando y so&amp;ntilde;ando: la &amp;uacute;nica forma de lograr resultados m&amp;aacute;s all&amp;aacute; del lento avance de la tecnolog&amp;iacute;a es &lt;em&gt;inventar un algoritmo&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a168ec8cf3b032681504a8e27d40ac24591c31bc" translate="yes" xml:space="preserve">
          <source>Big O notation is a way of describing how quickly an algorithm will run given an arbitrary number of input parameters, which we'll call &quot;n&quot;. It is useful in computer science because different machines operate at different speeds, and simply saying that an algorithm takes 5 seconds doesn't tell you much because while you may be running a system with a 4.5 Ghz octo-core processor, I may be running a 15 year old, 800 Mhz system, which could take longer regardless of the algorithm. So instead of specifying how fast an algorithm runs in terms of time, we say how fast it runs in terms of number of input parameters, or &quot;n&quot;. By describing algorithms in this way, we are able to compare the speeds of algorithms without having to take into account the speed of the computer itself.</source>
          <target state="translated">La notación Big O es una forma de describir la rapidez con la que se ejecutará un algoritmo dado un número arbitrario de parámetros de entrada,que llamaremos &quot;n&quot;.Es útil en la informática porque diferentes máquinas operan a diferentes velocidades,y simplemente decir que un algoritmo tarda 5 segundos no te dice mucho porque mientras que tú puedes estar ejecutando un sistema con un procesador de octo-núcleo de 4,5 Ghz,yo puedo estar ejecutando un sistema de 15 años,de 800 Mhz,que podría tardar más tiempo independientemente del algoritmo.Así que en lugar de especificar cuán rápido corre un algoritmo en términos de tiempo,decimos cuán rápido corre en términos de número de parámetros de entrada,o &quot;n&quot;.Describiendo los algoritmos de esta manera,podemos comparar las velocidades de los algoritmos sin tener en cuenta la velocidad de la propia computadora.</target>
        </trans-unit>
        <trans-unit id="4b0a116919ddeacd83d71ce31ad376da360a026c" translate="yes" xml:space="preserve">
          <source>Big O notation is a way of describing the upper bound of an algorithm in terms of space or running time.  The n is the number of elements in the the problem (i.e size of an array, number of nodes in a tree, etc.)  We are interested in describing the running time as n gets  big.</source>
          <target state="translated">La notación Big O es una forma de describir el límite superior de un algoritmo en términos de espacio o tiempo de ejecución.La n es el número de elementos en el problema (es decir,el tamaño de una matriz,el número de nodos en un árbol,etc.)Nos interesa describir el tiempo de ejecución a medida que n se hace grande.</target>
        </trans-unit>
        <trans-unit id="4c8f74fc1bdc10685b2177c45ec160d36cadb907" translate="yes" xml:space="preserve">
          <source>Big O notation is most commonly used by programmers as an approximate measure of how long a computation (algorithm) will take to complete expressed as a function of the size of the input set.</source>
          <target state="translated">La notación Big O es la más comúnmente utilizada por los programadores como una medida aproximada de cuánto tiempo tardará en completarse un cálculo (algoritmo)expresado en función del tamaño del conjunto de entradas.</target>
        </trans-unit>
        <trans-unit id="35d0c4e9b1c9e1dda535f62f93fc8e1e6b9b14c1" translate="yes" xml:space="preserve">
          <source>Big O notation is used in Computer Science to describe the performance
  or complexity of an algorithm. Big O specifically describes the
  worst-case scenario, and can be used to describe the execution time
  required or the space used (e.g. in memory or on disk) by an
  algorithm.</source>
          <target state="translated">La notación Big O se utiliza en la informática para describir el rendimiento o la complejidad de un algoritmo.Big O describe específicamente el peor de los casos,y puede utilizarse para describir el tiempo de ejecución requerido o el espacio utilizado (por ejemplo,en la memoria o en el disco)por un algoritmo.</target>
        </trans-unit>
        <trans-unit id="029dd5426c412001fb487f1ee4fae8a55e3c8c3b" translate="yes" xml:space="preserve">
          <source>Big O notation simply tells how much time* an algorithm can run within,
  in terms of &lt;em&gt;only the amount of input data&lt;/em&gt;**.</source>
          <target state="translated">La notaci&amp;oacute;n Big O simplemente indica cu&amp;aacute;nto tiempo * puede ejecutarse un algoritmo, en t&amp;eacute;rminos de &lt;em&gt;solo la cantidad de datos de entrada&lt;/em&gt; **.</target>
        </trans-unit>
        <trans-unit id="ac3a3f5b5b610616ecbb8b264905e5ee4de505c6" translate="yes" xml:space="preserve">
          <source>Big O notation tells you the cost of solving an infinitely large problem.</source>
          <target state="translated">La notación de la gran O te dice el costo de resolver un problema infinitamente grande.</target>
        </trans-unit>
        <trans-unit id="f4998d7a032917937335ae6425e4667cbea54bd2" translate="yes" xml:space="preserve">
          <source>Big O of n means my algorithm runs at least as fast as this. You cannot look at Big O notation of your algorithm and say its slow. You can only say its fast.</source>
          <target state="translated">La gran O de n significa que mi algoritmo funciona al menos tan rápido como esto.No puedes mirar la notación Big O de tu algoritmo y decir que es lento.Sólo puedes decir que es rápido.</target>
        </trans-unit>
        <trans-unit id="2aabaf3aedb4e0aa46fb4d5ff8c2ab4e6073ca94" translate="yes" xml:space="preserve">
          <source>Big O points out this: as n gets big, when we sort cards, the job gets MUCH MUCH MORE HARD than the old just-add-these-things job.  How do we know this?</source>
          <target state="translated">Big O señala esto:a medida que n se hace grande,cuando clasificamos las cartas,el trabajo se hace MUCHO MÁS DURO que el viejo trabajo de sólo añadir estas cosas.¿Cómo sabemos esto?</target>
        </trans-unit>
        <trans-unit id="93a1b436d9d2b6befbc854db9c969659b8e5b77f" translate="yes" xml:space="preserve">
          <source>Big O represents the worst possible time/space for that algorithm. The algorithm will never take more space/time above that limit. Big O represents time/space complexity in the extreme case.</source>
          <target state="translated">La gran O representa el peor espacio temporal posible para ese algoritmo.El algoritmo nunca tomará más espacio tiempo por encima de ese límite.La Gran O representa la complejidad del espacio temporal en el caso extremo.</target>
        </trans-unit>
        <trans-unit id="2897bc170748c75b1afb0452b1633a9f90eeaa23" translate="yes" xml:space="preserve">
          <source>Big O says: we must do six adds to solve this.  One add, for each thing from one to six.  Six small bits of work... each bit of work is one add.</source>
          <target state="translated">Big O dice:debemos hacer seis sumas para resolver esto.Una suma,para cada cosa del uno al seis.Seis pequeños trozos de trabajo...cada trozo de trabajo es una suma.</target>
        </trans-unit>
        <trans-unit id="01a1c3b9e0eae37b04b930c9e959423669d00b8b" translate="yes" xml:space="preserve">
          <source>Big O tells us that to sort things is more hard than to add things.  O(n squared) is more than O(n) for big n.  That means: if n gets real big, to sort a mixed deck of n things MUST take more time, than to just add n mixed things.</source>
          <target state="translated">Big O nos dice que ordenar las cosas es más difícil que añadirlas.O(n al cuadrado)es más que O(n)para el gran n.Eso significa:si n se hace muy grande,ordenar un mazo mixto de n cosas DEBE tomar más tiempo,que sólo añadir n cosas mixtas.</target>
        </trans-unit>
        <trans-unit id="ff2337e8063fec003cbedd7750338ff7fc025f36" translate="yes" xml:space="preserve">
          <source>Big O, help me!</source>
          <target state="translated">¡Big O,ayúdame!</target>
        </trans-unit>
        <trans-unit id="f0939bd08a02841e66e2310a89ddfeb9c0a7055e" translate="yes" xml:space="preserve">
          <source>Big-&amp;Omega; (Big-Omega) notation (article) | Khan Academy</source>
          <target state="translated">Notaci&amp;oacute;n Big-&amp;Omega; (Big-Omega) (art&amp;iacute;culo) | academia Khan</target>
        </trans-unit>
        <trans-unit id="9ffc7ec8bbe6223b3d70e4376f89b6eab1b1a639" translate="yes" xml:space="preserve">
          <source>Big-O notation (also called &quot;asymptotic growth&quot; notation) is &lt;em&gt;what functions &quot;look like&quot; when you ignore constant factors and stuff near the origin&lt;/em&gt;. We use it to talk about &lt;strong&gt;how thing scale&lt;/strong&gt;.</source>
          <target state="translated">La notaci&amp;oacute;n Big-O (tambi&amp;eacute;n llamada notaci&amp;oacute;n de &quot;crecimiento asint&amp;oacute;tico&quot;) es &lt;em&gt;lo que las funciones &quot;parecen&quot; cuando ignora factores constantes y cosas cerca del origen&lt;/em&gt; . Lo usamos para hablar sobre &lt;strong&gt;c&amp;oacute;mo escala la cosa&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1769664f1e1ca72f099882bf25e7d2f39574cca3" translate="yes" xml:space="preserve">
          <source>Big-O, is &lt;strong&gt;rate of increase&lt;/strong&gt; of resource consumed by program, w.r.t. problem-instance-size</source>
          <target state="translated">Big-O, es la &lt;strong&gt;tasa de aumento&lt;/strong&gt; de los recursos consumidos por el programa, wrt problem-instance-size</target>
        </trans-unit>
        <trans-unit id="a380e8c171aa6d7e586e8f15b66e52968c776a75" translate="yes" xml:space="preserve">
          <source>Binary search is a technique used to search sorted data sets. It works
  by selecting the middle element of the data set, essentially the
  median, and compares it against a target value. If the values match it
  will return success. If the target value is higher than the value of
  the probe element it will take the upper half of the data set and
  perform the same operation against it. Likewise, if the target value
  is lower than the value of the probe element it will perform the
  operation against the lower half. It will continue to halve the data
  set with each iteration until the value has been found or until it can
  no longer split the data set.</source>
          <target state="translated">La búsqueda binaria es una técnica utilizada para buscar conjuntos de datos ordenados.Funciona seleccionando el elemento medio del conjunto de datos,esencialmente la mediana,y lo compara con un valor objetivo.Si los valores coinciden,se obtendrá el éxito.Si el valor objetivo es mayor que el valor del elemento de la sonda,tomará la mitad superior del conjunto de datos y realizará la misma operación contra él.Del mismo modo,si el valor objetivo es inferior al valor del elemento de la sonda,realizará la operación contra la mitad inferior.Continuará dividiendo el conjunto de datos a la mitad en cada iteración hasta que se encuentre el valor o hasta que ya no pueda dividir el conjunto de datos.</target>
        </trans-unit>
        <trans-unit id="84e2d5bd3333a554d3c328ae36cecdeea3f085c1" translate="yes" xml:space="preserve">
          <source>Both average-case and amortization are incredibly useful tools for thinking about and designing with scaling in mind.</source>
          <target state="translated">Tanto el caso promedio como la amortización son herramientas increíblemente útiles para pensar y diseñar con la escala en mente.</target>
        </trans-unit>
        <trans-unit id="81fa41afe9d47413eda0c47da5969d56124c07cf" translate="yes" xml:space="preserve">
          <source>But remember, Big O is just a way to experss yourself in the manner of time and space.</source>
          <target state="translated">Pero recuerden,Big O es sólo una forma de experimentar en el tiempo y el espacio.</target>
        </trans-unit>
        <trans-unit id="3ddd3cf4c5b5b439921cdd63b830507cc2d92e01" translate="yes" xml:space="preserve">
          <source>But though we will not do the work now, we can guess how hard it would be, if we knew n.  We would have to add up n things, right?  Of course!</source>
          <target state="translated">Pero aunque no haremos el trabajo ahora,podemos adivinar lo difícil que sería,si supiéramos n.Tendríamos que sumar n cosas,¿verdad? ¡Claro!</target>
        </trans-unit>
        <trans-unit id="de004be9935e007a2aa4a8dd96ba9ccf3e285c6c" translate="yes" xml:space="preserve">
          <source>But, programmers don't think like this because eventually, algorithm intuition just becomes second nature. You will start to code something inefficient and immediately think &quot;am I doing something &lt;strong&gt;grossly inefficient?&lt;/strong&gt;&quot;. If the answer is &quot;yes&quot; AND you foresee it actually mattering, then you can take a step back and think of various tricks to make things run faster (the answer is almost always &quot;use a hashtable&quot;, rarely &quot;use a tree&quot;, and very rarely something a bit more complicated).</source>
          <target state="translated">Pero los programadores no piensan as&amp;iacute; porque, con el tiempo, la intuici&amp;oacute;n del algoritmo se convierte en una segunda naturaleza. Comenzar&amp;aacute; a codificar algo ineficiente e inmediatamente pensar&amp;aacute; &quot;&amp;iquest;Estoy haciendo algo &lt;strong&gt;extremadamente ineficiente?&lt;/strong&gt; &quot;. Si la respuesta es &quot;s&amp;iacute;&quot; Y usted prev&amp;eacute; que realmente importa, entonces puede dar un paso atr&amp;aacute;s y pensar en varios trucos para que las cosas funcionen m&amp;aacute;s r&amp;aacute;pido (la respuesta es casi siempre &quot;usar una tabla hash&quot;, rara vez &quot;usar un &amp;aacute;rbol&quot;, y muy raramente algo un poco m&amp;aacute;s complicado).</target>
        </trans-unit>
        <trans-unit id="0d8f8969e0785f14a21dfca5ea753a20c18775cc" translate="yes" xml:space="preserve">
          <source>By comparing these when talking about &lt;strong&gt;A&lt;/strong&gt; and other algorithms, it is easy to rank the algorithms according to the number of operations they &lt;em&gt;may&lt;/em&gt; (worst-case) require to complete.</source>
          <target state="translated">Al compararlos cuando se habla de &lt;strong&gt;A&lt;/strong&gt; y otros algoritmos, es f&amp;aacute;cil clasificar los algoritmos de acuerdo con el n&amp;uacute;mero de operaciones que &lt;em&gt;pueden&lt;/em&gt; requerir (en el peor de los casos) para completar.</target>
        </trans-unit>
        <trans-unit id="0d58ba7567f14e061427da47056514f59b5370bc" translate="yes" xml:space="preserve">
          <source>By the way, here is for comparison the definition of small o.</source>
          <target state="translated">Por cierto,aquí está para la comparación la definición de pequeño o.</target>
        </trans-unit>
        <trans-unit id="cbb489069914d301d52853c36730ee0f0e267708" translate="yes" xml:space="preserve">
          <source>C &amp;rarr; A &amp;rarr; B</source>
          <target state="translated">C &amp;rarr; A &amp;rarr; B</target>
        </trans-unit>
        <trans-unit id="6998b04e08785bbdf1c7af58eecf38c1a28d31da" translate="yes" xml:space="preserve">
          <source>C &amp;rarr; B &amp;rarr; A</source>
          <target state="translated">C &amp;rarr; B &amp;rarr; A</target>
        </trans-unit>
        <trans-unit id="6cbbd09b2268ff81c9d2447ddd6efd0ece964c0a" translate="yes" xml:space="preserve">
          <source>Calculate how much time (regarding input size) the worst case takes:</source>
          <target state="translated">Calcular cuánto tiempo (en cuanto al tamaño de la entrada)toma el peor de los casos:</target>
        </trans-unit>
        <trans-unit id="12668f37b6831ee2e32bd194cd1af2fa68690568" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;https://www.youtube.com/watch?v=V1xXmQkzkZI&amp;amp;index=13&amp;amp;list=PLZBP-86GmPTxpbvoFFzad0qYw5dKA8MV2&quot;&gt;this&lt;/a&gt; out for a video tutorial on Big O from UC Berkley. It's is actually a simple concept. If you hear professor Shewchuck (aka God level teacher) explaining it, you will say &quot;Oh that's all it is!&quot;.</source>
          <target state="translated">Mira &lt;a href=&quot;https://www.youtube.com/watch?v=V1xXmQkzkZI&amp;amp;index=13&amp;amp;list=PLZBP-86GmPTxpbvoFFzad0qYw5dKA8MV2&quot;&gt;esto&lt;/a&gt; para ver un video tutorial sobre Big O de UC Berkley. Es en realidad un concepto simple. Si escuchas que el profesor Shewchuck (tambi&amp;eacute;n conocido como maestro de nivel de Dios) lo explica, dir&amp;aacute;s &quot;&amp;iexcl;Oh, eso es todo!&quot;.</target>
        </trans-unit>
        <trans-unit id="b4523b29b5c7ed6f8c2abc5e9a4c38da02d06afc" translate="yes" xml:space="preserve">
          <source>Come back and reread the above when you've read the rest.</source>
          <target state="translated">Vuelva y relea lo anterior cuando haya leído el resto.</target>
        </trans-unit>
        <trans-unit id="55a7f0d03a20d7e0d958646e51faf45416912637" translate="yes" xml:space="preserve">
          <source>Compare 1 and 6, which is biggest? Ok 6 is in the right position, moving forward!</source>
          <target state="translated">Compara el 1 y el 6,¿cuál es el más grande? Ok 6 está en la posición correcta,¡avanzando!</target>
        </trans-unit>
        <trans-unit id="1c5884fcffc252b00f765da994d3959a5bea1cc4" translate="yes" xml:space="preserve">
          <source>Compare 6 and 3, oh, 3 is less! Let's move that, Ok the list changed, we need to start from the begining now!</source>
          <target state="translated">Compara 6 y 3,¡oh,3 es menos! Vamos a mover eso,Ok la lista cambió,tenemos que empezar desde el principio ahora!</target>
        </trans-unit>
        <trans-unit id="b5ae65887f49fb01b8aa1e42c87a37e72b0918ca" translate="yes" xml:space="preserve">
          <source>Compare &lt;em&gt;how quickly runtime grows&lt;/em&gt;&lt;strong&gt;NOT&lt;/strong&gt;&lt;em&gt;compare exact runtimes&lt;/em&gt; (depends on hardware)</source>
          <target state="translated">Compare &lt;em&gt;qu&amp;eacute; tan r&amp;aacute;pido crece el tiempo de ejecuci&amp;oacute;n&lt;/em&gt; &lt;strong&gt;NO&lt;/strong&gt; &lt;em&gt;compare los tiempos de ejecuci&amp;oacute;n exactos&lt;/em&gt; (depende del hardware)</target>
        </trans-unit>
        <trans-unit id="3d11d48dee34717db426c8a89bfdced368207e28" translate="yes" xml:space="preserve">
          <source>Comparison between average-case and amortized worst-case:</source>
          <target state="translated">Comparación entre el caso promedio y el peor caso amortizado:</target>
        </trans-unit>
        <trans-unit id="ad8df7363e12666a15da250cd1535079ed8d98cb" translate="yes" xml:space="preserve">
          <source>Consider the canonical sorting example. Bubble-sort is O(n&lt;sup&gt;2&lt;/sup&gt;) while merge-sort is O(n log n). Let's say you have two sorting applications, application A which uses bubble-sort and application B which uses merge-sort, and let's say that for input sizes of around 30 elements application A is 1,000x faster than application B at sorting. If you never have to sort much more than 30 elements then it's obvious that you should prefer application A, as it is much faster at these input sizes. However, if you find that you may have to sort ten million items then what you'd expect is that application B actually ends up being thousands of times faster than application A in this case, entirely due to the way each algorithm scales.</source>
          <target state="translated">Considere el ejemplo de clasificaci&amp;oacute;n can&amp;oacute;nica. Bubble-sort es O (n &lt;sup&gt;2&lt;/sup&gt; ) mientras que merge-sort es O (n log n). Supongamos que tiene dos aplicaciones de clasificaci&amp;oacute;n, la aplicaci&amp;oacute;n A que utiliza la clasificaci&amp;oacute;n de burbujas y la aplicaci&amp;oacute;n B que utiliza la clasificaci&amp;oacute;n de fusi&amp;oacute;n, y digamos que para tama&amp;ntilde;os de entrada de alrededor de 30 elementos, la aplicaci&amp;oacute;n A es 1,000 veces m&amp;aacute;s r&amp;aacute;pida que la aplicaci&amp;oacute;n B en la clasificaci&amp;oacute;n. Si nunca tiene que ordenar m&amp;aacute;s de 30 elementos, entonces es obvio que deber&amp;iacute;a preferir la aplicaci&amp;oacute;n A, ya que es mucho m&amp;aacute;s r&amp;aacute;pido en estos tama&amp;ntilde;os de entrada. Sin embargo, si descubre que es posible que tenga que clasificar diez millones de elementos, entonces lo que esperar&amp;iacute;a es que la aplicaci&amp;oacute;n B en realidad termine siendo miles de veces m&amp;aacute;s r&amp;aacute;pida que la aplicaci&amp;oacute;n A en este caso, debido completamente a la escala de cada algoritmo.</target>
        </trans-unit>
        <trans-unit id="a7c2b8ba88bf46f0dfe0a0ff9f1b26cb00f3ba83" translate="yes" xml:space="preserve">
          <source>Consider the difference between a steam engine and a rocket. They are not merely different varieties of the same thing (as, say, a Prius engine vs. a Lamborghini engine) but they are dramatically different kinds of propulsion systems, at their core. A steam engine may be faster than a toy rocket, but no steam piston engine will be able to achieve the speeds of an orbital launch vehicle. This is because these systems have different scaling characteristics with regards to the relation of fuel required (&quot;resource usage&quot;) to reach a given speed (&quot;input size&quot;).</source>
          <target state="translated">Considere la diferencia entre una máquina de vapor y un cohete.No son simplemente diferentes variedades de la misma cosa (como,por ejemplo,un motor Prius vs.un motor Lamborghini),sino que son dramáticamente diferentes tipos de sistemas de propulsión,en su núcleo.Un motor de vapor puede ser más rápido que un cohete de juguete,pero ningún motor de pistón de vapor será capaz de alcanzar las velocidades de un vehículo de lanzamiento orbital.Ello se debe a que estos sistemas tienen diferentes características de escalado en lo que respecta a la relación de combustible necesario (&quot;uso de recursos&quot;)para alcanzar una velocidad determinada (&quot;tamaño de entrada&quot;).</target>
        </trans-unit>
        <trans-unit id="6a8cfee71662bf83fd7610d0447480c8f098dc3b" translate="yes" xml:space="preserve">
          <source>Constant factors are negligible</source>
          <target state="translated">Los factores constantes son insignificantes</target>
        </trans-unit>
        <trans-unit id="0da1286a9bca7edf66b07ff225ea54f102d5a653" translate="yes" xml:space="preserve">
          <source>Depending on N and X, your algorithm will require some operations, for example in the WORST case it's &lt;code&gt;3(N^2) + log(X)&lt;/code&gt; operations.</source>
          <target state="translated">Dependiendo de N y X, su algoritmo requerir&amp;aacute; algunas operaciones, por ejemplo, en el PEOR caso, son &lt;code&gt;3(N^2) + log(X)&lt;/code&gt; operaciones log (X) .</target>
        </trans-unit>
        <trans-unit id="f8e74a3a562ba5774725315dfe1782d1a1275af0" translate="yes" xml:space="preserve">
          <source>Does not scale.  You have no hope of solving any non-trivially sized problem.  Useful for knowing what to avoid, and for experts to find approximate algorithms which are in &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt;.</source>
          <target state="translated">No escala No tiene esperanza de resolver ning&amp;uacute;n problema de tama&amp;ntilde;o no trivial. &amp;Uacute;til para saber qu&amp;eacute; evitar y para que los expertos encuentren algoritmos aproximados que est&amp;aacute;n en &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; &lt;sup&gt;k&lt;/sup&gt; )&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c81313d6a9457c1a28868d8aaaff914cf1b3213c" translate="yes" xml:space="preserve">
          <source>Does this make a hashtable faster than an array for lookups? Not necessarily. If you've got a very small collection of entries, an array may well be faster &amp;mdash; you may be able to check all the strings in the time that it takes to just calculate the hashcode of the one you're looking at. As the data set grows larger, however, the hashtable will eventually beat the array.</source>
          <target state="translated">&amp;iquest;Esto hace que una tabla hash sea m&amp;aacute;s r&amp;aacute;pida que una matriz para b&amp;uacute;squedas? No necesariamente. Si tiene una colecci&amp;oacute;n muy peque&amp;ntilde;a de entradas, una matriz puede ser m&amp;aacute;s r&amp;aacute;pida: es posible que pueda verificar todas las cadenas en el tiempo necesario para calcular el c&amp;oacute;digo hash de la que est&amp;aacute; viendo. Sin embargo, a medida que el conjunto de datos crece, la tabla hash eventualmente vencer&amp;aacute; a la matriz.</target>
        </trans-unit>
        <trans-unit id="38f6893266ac6c8513618653e41d6736baa03b7c" translate="yes" xml:space="preserve">
          <source>EDIT: Quick note, this is almost certainly confusing &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; (which is an upper bound) with Theta notation (which is both an upper and lower bound). In my experience this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</source>
          <target state="translated">EDITAR: Nota r&amp;aacute;pida, esto es casi seguro que confunde la &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;notaci&amp;oacute;n Big O&lt;/a&gt; (que es un l&amp;iacute;mite superior) con la notaci&amp;oacute;n Theta (que es un l&amp;iacute;mite superior e inferior). En mi experiencia, esto es realmente t&amp;iacute;pico de las discusiones en entornos no acad&amp;eacute;micos. Disculpas por cualquier confusi&amp;oacute;n causada.</target>
        </trans-unit>
        <trans-unit id="c8861868012e671e5ca7903151be427897869332" translate="yes" xml:space="preserve">
          <source>Each of these is an operation or a problem.  A method of solving these is called an &lt;strong&gt;algorithm&lt;/strong&gt;.</source>
          <target state="translated">Cada uno de estos es una operaci&amp;oacute;n o un problema. Un m&amp;eacute;todo para resolverlos se llama &lt;strong&gt;algoritmo&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b62541479f03733e3001473267dd14900d0760bc" translate="yes" xml:space="preserve">
          <source>Ergh.  That sounds like a lot of work!</source>
          <target state="translated">Ergh.¡Eso suena a mucho trabajo!</target>
        </trans-unit>
        <trans-unit id="b6dc6935629b7d3402db5c466e6d14aa566e6056" translate="yes" xml:space="preserve">
          <source>Estimates how many steps of the method your computer applies to accomplish a task.</source>
          <target state="translated">Estima cuántos pasos del método que su ordenador aplica para realizar una tarea.</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">Ejemplo 2:</target>
        </trans-unit>
        <trans-unit id="1d4166bf97179d81c42dccef3ab9d1594a5dec5d" translate="yes" xml:space="preserve">
          <source>Example 3:</source>
          <target state="translated">Ejemplo 3:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="184ce50741de2b5a2d508d5c7f7deb72ee16f548" translate="yes" xml:space="preserve">
          <source>Facilitate the process to compare with others in order to determine whether it's good or not?</source>
          <target state="translated">¿Facilitar el proceso de comparación con otros para determinar si es bueno o no?</target>
        </trans-unit>
        <trans-unit id="8b846e7060b9a483588329ba98d3b24f7db5b0ed" translate="yes" xml:space="preserve">
          <source>For 1,000,000 it takes 20.</source>
          <target state="translated">Por 1.000.000 se necesitan 20.</target>
        </trans-unit>
        <trans-unit id="bfc4a756390564c98c0f9ee2960940b370613e43" translate="yes" xml:space="preserve">
          <source>For 15 it takes 4.</source>
          <target state="translated">Por 15 se necesitan 4.</target>
        </trans-unit>
        <trans-unit id="c4dcc93d74ce33740712a8b30e5dfa1a16cc492d" translate="yes" xml:space="preserve">
          <source>For 7 it takes at most 3.</source>
          <target state="translated">Para 7 se necesitan como máximo 3.</target>
        </trans-unit>
        <trans-unit id="8387ae59db1ca9e3e2f91943f6392088dfd4aa1a" translate="yes" xml:space="preserve">
          <source>For a phone book of 3 names it takes 2 comparisons (at most).</source>
          <target state="translated">Para una guía telefónica de 3 nombres se necesitan 2 comparaciones (como máximo).</target>
        </trans-unit>
        <trans-unit id="5052922ba19448289d5da9158883ce125e05b963" translate="yes" xml:space="preserve">
          <source>For big n, n squared is more large than n.</source>
          <target state="translated">Para la gran n,n al cuadrado es más grande que n.</target>
        </trans-unit>
        <trans-unit id="e5054e967dbdba1361ba3fb55414b378a8efdbff" translate="yes" xml:space="preserve">
          <source>For completeness, the precise definition of big-O notation is as follows: &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; means that &quot;f is asymptotically upper-bounded by const*g&quot;: ignoring everything below some finite value of x, there exists a constant such that &lt;code&gt;|f(x)| &amp;le; const * |g(x)|&lt;/code&gt;. (The other symbols are as follows: just like &lt;code&gt;O&lt;/code&gt; means &amp;le;, &lt;code&gt;&amp;Omega;&lt;/code&gt; means &amp;ge;. There are lowercase variants: &lt;code&gt;o&lt;/code&gt; means &amp;lt;, and &lt;code&gt;&amp;omega;&lt;/code&gt; means &amp;gt;.) &lt;code&gt;f(x) &amp;isin; Ɵ(g(x))&lt;/code&gt; means both &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; and &lt;code&gt;f(x) &amp;isin; &amp;Omega;(g(x))&lt;/code&gt; (upper- and lower-bounded by g): there exists some constants such that f will always lie in the &quot;band&quot; between &lt;code&gt;const1*g(x)&lt;/code&gt; and &lt;code&gt;const2*g(x)&lt;/code&gt;. It is the strongest asymptotic statement you can make and roughly equivalent to &lt;code&gt;==&lt;/code&gt;. (Sorry, I elected to delay the mention of the absolute-value symbols until now, for clarity's sake; especially because I have never seen negative values come up in a computer science context.)</source>
          <target state="translated">Para completar, la definici&amp;oacute;n precisa de notaci&amp;oacute;n big-O es la siguiente: &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; significa que &quot;f est&amp;aacute; asint&amp;oacute;ticamente limitado por const * g&quot;: ignorando todo lo que est&amp;aacute; debajo de un valor finito de x , existe una constante tal que &lt;code&gt;|f(x)| &amp;le; const * |g(x)|&lt;/code&gt; &amp;le; const * | g (x) | . (Los otros s&amp;iacute;mbolos son los siguientes: al igual que &lt;code&gt;O&lt;/code&gt; significa &amp;le;, &lt;code&gt;&amp;Omega;&lt;/code&gt; significa &amp;ge;. Hay variantes en min&amp;uacute;sculas: &lt;code&gt;o&lt;/code&gt; significa &amp;lt;y &lt;code&gt;&amp;omega;&lt;/code&gt; significa&amp;gt;.) &lt;code&gt;f(x) &amp;isin; Ɵ(g(x))&lt;/code&gt; significa ambos &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; &lt;code&gt;f(x) &amp;isin; &amp;Omega;(g(x))&lt;/code&gt; (superior e inferior limitado por g): existen algunas constantes tales que f siempre estar&amp;aacute; en la &quot;banda&quot; entre &lt;code&gt;const1*g(x)&lt;/code&gt; y &lt;code&gt;const2*g(x)&lt;/code&gt; . Es la declaraci&amp;oacute;n asint&amp;oacute;tica m&amp;aacute;s fuerte que puede hacer y aproximadamente equivalente a &lt;code&gt;==&lt;/code&gt; . (Lo siento, eleg&amp;iacute; retrasar la menci&amp;oacute;n de los s&amp;iacute;mbolos de valor absoluto hasta ahora, por razones de claridad; especialmente porque nunca he visto valores negativos aparecer en un contexto inform&amp;aacute;tico).</target>
        </trans-unit>
        <trans-unit id="49654e3774111fb16128651b4d224ad6b75c2b89" translate="yes" xml:space="preserve">
          <source>For example, say you had the latitude and longitude coordinates of millions of road segments and wanted to find all street intersections.</source>
          <target state="translated">Por ejemplo,digamos que tienes las coordenadas de latitud y longitud de millones de segmentos de carreteras y quieres encontrar todas las intersecciones de calles.</target>
        </trans-unit>
        <trans-unit id="b3611110a9125b6ab52f37ddd431b3585818e9dd" translate="yes" xml:space="preserve">
          <source>For input of size &quot;n&quot; the program is growing at speed of &quot;n&quot; iterations in array. Hence Big-O is N expressed as  O(n)</source>
          <target state="translated">Para la entrada de tamaño &quot;n&quot; el programa está creciendo a una velocidad de &quot;n&quot; iteraciones en serie.Por lo tanto Big-O es N expresado como O(n)</target>
        </trans-unit>
        <trans-unit id="09e7373f604bf7164bb0dca1297d67c519bcfba7" translate="yes" xml:space="preserve">
          <source>For input of size &quot;n&quot; the program is growing at speed of &quot;n*n&quot; iterations in array. Hence Big-O is N&lt;sup&gt;2&lt;/sup&gt; expressed as  O(n&lt;sup&gt;2&lt;/sup&gt;)</source>
          <target state="translated">Para la entrada de tama&amp;ntilde;o &quot;n&quot;, el programa est&amp;aacute; creciendo a la velocidad de las iteraciones &quot;n * n&quot; en la matriz. Por lo tanto, Big-O es N &lt;sup&gt;2&lt;/sup&gt; expresado como O (n &lt;sup&gt;2&lt;/sup&gt; )</target>
        </trans-unit>
        <trans-unit id="8a6ae78506dc4ee34684d9e0638c4281f35c545f" translate="yes" xml:space="preserve">
          <source>For online downloading, the download time is directly proportional to the movie file sizes (input). We call this &lt;strong&gt;O(n)&lt;/strong&gt;.</source>
          <target state="translated">Para la descarga en l&amp;iacute;nea, el tiempo de descarga es directamente proporcional a los tama&amp;ntilde;os de archivo de pel&amp;iacute;cula (entrada). Llamamos a esto &lt;strong&gt;O (n)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="67cc9e8bfc7b47bffe767706a99579808a311dcc" translate="yes" xml:space="preserve">
          <source>For the handshake example above, everyone in a room shakes everyone else's hand. In that example, &lt;code&gt;#handshakes &amp;isin; Ɵ(N&amp;sup2;)&lt;/code&gt;. Why?</source>
          <target state="translated">Para el ejemplo de apret&amp;oacute;n de manos anterior, todos en una habitaci&amp;oacute;n dan la mano a todos los dem&amp;aacute;s. En ese ejemplo, &lt;code&gt;#handshakes &amp;isin; Ɵ(N&amp;sup2;)&lt;/code&gt; . &amp;iquest;Por qu&amp;eacute;?</target>
        </trans-unit>
        <trans-unit id="c5e2547d0bc6ba3ff90e388af4f7fa819fdfb175" translate="yes" xml:space="preserve">
          <source>Four (and this is the fun part): I have two small decks now, one more low than the splay card, and one more high.  Now I go to step one, on each small deck!  That is to say, I start from step One on the first small deck, and when that work is done, I start from step One on the next small deck.</source>
          <target state="translated">Cuatro (y esta es la parte divertida):Tengo dos barajas pequeñas ahora,una más baja que la carta de juego,y una más alta.Ahora voy al paso uno,¡en cada pequeño mazo! Es decir,comienzo desde el paso uno en el primer mazo pequeño,y cuando ese trabajo está hecho,comienzo desde el paso uno en el siguiente mazo pequeño.</target>
        </trans-unit>
        <trans-unit id="4a6b77756dd510894ce0e5f9cee853f3dfb273a0" translate="yes" xml:space="preserve">
          <source>From the experiments, we know that online shopping scales better than online downloading. It is very important to understand big O notation because it helps you to analyze the &lt;strong&gt;scalability&lt;/strong&gt; and &lt;strong&gt;efficiency&lt;/strong&gt; of algorithms.</source>
          <target state="translated">A partir de los experimentos, sabemos que las compras en l&amp;iacute;nea escalan mejor que las descargas en l&amp;iacute;nea. Es muy importante comprender la notaci&amp;oacute;n O grande porque le ayuda a analizar la &lt;strong&gt;escalabilidad&lt;/strong&gt; y la &lt;strong&gt;eficiencia&lt;/strong&gt; de los algoritmos.</target>
        </trans-unit>
        <trans-unit id="e19041281d0dd99d852a13a94e9ffca8398dc327" translate="yes" xml:space="preserve">
          <source>Grows as a square, where &lt;em&gt;n&lt;/em&gt; is the length of the side of a square.  This is the same growth rate as the &quot;network effect&quot;, where everyone in a network might know everyone else in the network.  Growth is expensive.  Most scalable solutions cannot use algorithms with this level of complexity without doing significant gymnastics.  This generally applies to all other polynomial complexities - &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; - as well.</source>
          <target state="translated">Crece como un cuadrado, donde &lt;em&gt;n&lt;/em&gt; es la longitud del lado de un cuadrado. Esta es la misma tasa de crecimiento que el &quot;efecto de red&quot;, donde todos en una red pueden conocer a todos los dem&amp;aacute;s en la red. El crecimiento es costoso. La mayor&amp;iacute;a de las soluciones escalables no pueden usar algoritmos con este nivel de complejidad sin hacer gimnasia significativa. Esto generalmente se aplica a todas las dem&amp;aacute;s complejidades polin&amp;oacute;micas - &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; &lt;sup&gt;k&lt;/sup&gt; )&lt;/strong&gt; - tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="36f6624b28e90d7b5439820ddf4b791141546e8a" translate="yes" xml:space="preserve">
          <source>Here comes big O, to tell us just how hard this math is.</source>
          <target state="translated">Aquí viene el gran O,para decirnos cuán difícil es esta matemática.</target>
        </trans-unit>
        <trans-unit id="5e58c431d0ce6f70610939ce98c97531f57d61cc" translate="yes" xml:space="preserve">
          <source>Here is another thing we can recognize visually:</source>
          <target state="translated">Aquí hay otra cosa que podemos reconocer visualmente:</target>
        </trans-unit>
        <trans-unit id="4ab646045794b15182529717713fd6393652d11a" translate="yes" xml:space="preserve">
          <source>Here is the Wikipedia article: &lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;https://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el art&amp;iacute;culo de Wikipedia: &lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;https://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="001cff8786bd37eff234c46bb9b1b48e0988d759" translate="yes" xml:space="preserve">
          <source>Here is the plain English bestiary I tend to use when explaining the common varieties of Big-O</source>
          <target state="translated">Este es el bestiario inglés que suelo usar para explicar las variedades comunes de Big-O</target>
        </trans-unit>
        <trans-unit id="43e41c55f998f736fd0e01106d1006e4f8370dd7" translate="yes" xml:space="preserve">
          <source>Here's an example where we have N T-shirts which we want to dry. We'll &lt;em&gt;assume&lt;/em&gt; it's incredibly quick to get them in the drying position (i.e. the human interaction is negligible). That's not the case in real life, of course...</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo donde tenemos N camisetas que queremos secar. &lt;em&gt;Asumiremos&lt;/em&gt; que es incre&amp;iacute;blemente r&amp;aacute;pido ponerlos en la posici&amp;oacute;n de secado (es decir, la interacci&amp;oacute;n humana es insignificante). Ese no es el caso en la vida real, por supuesto ...</target>
        </trans-unit>
        <trans-unit id="c5af9b41639623efa7baf5be1ecd016aee231408" translate="yes" xml:space="preserve">
          <source>Here, the smallest recognizable outline you can draw is what matters; a triangle is a two dimensional shape (0.5 A^2), just like a square is a two-dimensional shape (A^2); the constant factor of two here remains in the asymptotic ratio between the two, however, we ignore it like all factors... (There are some unfortunate nuances to this technique I don't go into here; it can mislead you.)</source>
          <target state="translated">Aquí,el contorno más pequeño reconocible que se puede dibujar es lo que importa;un triángulo es una forma bidimensional (0,5 A^2),al igual que un cuadrado es una forma bidimensional (A^2);el factor constante de dos aquí permanece en la relación asintótica entre los dos,sin embargo,lo ignoramos como todos los factores...(Hay algunos matices desafortunados en esta técnica que no entro aquí;puede confundirte.)</target>
        </trans-unit>
        <trans-unit id="1d2dc7900c252d720e30b05b14c6ffb4be0d882b" translate="yes" xml:space="preserve">
          <source>Hmmm.  There may be a rule in there, I think.  To make big tasks small, break them up.</source>
          <target state="translated">Hmmm.Puede haber una regla ahí,creo.Para hacer pequeñas las grandes tareas,sepáralas.</target>
        </trans-unit>
        <trans-unit id="9c06c7ddd3fdd4ff139df20d27d2e5e8fe694d25" translate="yes" xml:space="preserve">
          <source>How can we sort this deck?  I have a plan.</source>
          <target state="translated">¿Cómo podemos ordenar esta cubierta? Tengo un plan.</target>
        </trans-unit>
        <trans-unit id="b80eb8a9b1ad872be834851527556c78aaff922e" translate="yes" xml:space="preserve">
          <source>How do I know Quick Sort is less work?  I know that O(n log n) is less than O(n squared).  The O's are more small, so Quick Sort is less work!</source>
          <target state="translated">¿Cómo sé que Quick Sort es menos trabajo? Sé que O(n log n)es menos que O(n al cuadrado).Las O son más pequeñas,por lo que Quick Sort es menos trabajo.</target>
        </trans-unit>
        <trans-unit id="ce3005d8e3f4f0dd8dec37227d002f3f7de3b04c" translate="yes" xml:space="preserve">
          <source>How much more hard would it be?  How much more work would I have to do?  Do I need more or less steps?</source>
          <target state="translated">¿Cuánto más difícil sería? ¿Cuánto más trabajo tendría que hacer? ¿Necesito más o menos pasos?</target>
        </trans-unit>
        <trans-unit id="a4daa40555f4cdbc41aa891d89c4fbcc8ad0f51b" translate="yes" xml:space="preserve">
          <source>However, for very large numbers of people, the linear term &lt;code&gt;N&lt;/code&gt; is dwarfed and effectively contributes 0 to the ratio (in the chart: the fraction of empty boxes on the diagonal over total boxes gets smaller as the number of participants becomes larger). Therefore the scaling behavior is &lt;code&gt;order N&amp;sup2;&lt;/code&gt;, or the number of handshakes &quot;grows like N&amp;sup2;&quot;.</source>
          <target state="translated">Sin embargo, para un gran n&amp;uacute;mero de personas, el t&amp;eacute;rmino lineal &lt;code&gt;N&lt;/code&gt; es enano y efectivamente contribuye 0 a la relaci&amp;oacute;n (en la tabla: la fracci&amp;oacute;n de cuadros vac&amp;iacute;os en la diagonal sobre los cuadros totales se reduce a medida que aumenta el n&amp;uacute;mero de participantes). Por lo tanto, el comportamiento de escala es de &lt;code&gt;order N&amp;sup2;&lt;/code&gt; , o el n&amp;uacute;mero de apretones de manos &quot;crece como N&amp;sup2;&quot;.</target>
        </trans-unit>
        <trans-unit id="9f6b7a8c3e101e7571405d26663a1a4d8aefb762" translate="yes" xml:space="preserve">
          <source>I break up the deck in parts, and sort each part, more small and more small, and at some time I have no more work to do.  Now this may seem slow, with all the rules.  But trust me, it is not slow at all.  It is much less work than the first way to sort things!</source>
          <target state="translated">Rompo la cubierta en partes,y clasifico cada parte,cada vez más pequeña,y en algún momento no tengo más trabajo que hacer.Ahora esto puede parecer lento,con todas las reglas.Pero créame,no es lento en absoluto.¡Es mucho menos trabajo que la primera forma de ordenar las cosas!</target>
        </trans-unit>
        <trans-unit id="819fcf72178711a5bc5e8d2f9d5dd724ea8d6e5e" translate="yes" xml:space="preserve">
          <source>I care lots for big O.  Why?  I do not like to work!  No one likes to work.  That is why we all love big O!  He tells us how fast we can work.  He helps us think of how hard work is.</source>
          <target state="translated">Me importa mucho el gran O.¿Por qué? ¡No me gusta trabajar! A nadie le gusta trabajar.Por eso todos amamos al gran O! Él nos dice lo rápido que podemos trabajar.Nos ayuda a pensar en lo duro que es el trabajo.</target>
        </trans-unit>
        <trans-unit id="482a49f03db93f2d8f5d5daa020b481189471c57" translate="yes" xml:space="preserve">
          <source>I do not like to go to work.  I do not like to spend time at work.  If I had my way, I would like just to play, and do fun things.  Do you feel the same as I do?</source>
          <target state="translated">No me gusta ir a trabajar.No me gusta pasar tiempo en el trabajo.Si pudiera,me gustaría jugar y hacer cosas divertidas.¿Sientes lo mismo que yo?</target>
        </trans-unit>
        <trans-unit id="ad52c5fb30262f15e8d3a80bd1081996754096a0" translate="yes" xml:space="preserve">
          <source>I do not want to add right now.  I just want to think on how hard it might be to add that much.  And, I hope, to play as soon as I can.</source>
          <target state="translated">No quiero añadir nada ahora mismo.Sólo quiero pensar en lo difícil que puede ser añadir tanto.Y,espero,jugar tan pronto como pueda.</target>
        </trans-unit>
        <trans-unit id="a8b731da95dde2cc32a2a652b9321f54f34bd44a" translate="yes" xml:space="preserve">
          <source>I found a really great explanation about big O notation especially for a someone who's not much into mathematics.</source>
          <target state="translated">Encontré una gran explicación sobre la gran notación O,especialmente para alguien a quien no le gustan mucho las matemáticas.</target>
        </trans-unit>
        <trans-unit id="dab9c64b9a46ec0457c94246c45926dfd570f6b3" translate="yes" xml:space="preserve">
          <source>I have a deck of cards.  I did sort them.  You helped.  Thanks.</source>
          <target state="translated">Tengo una baraja de cartas.Las he clasificado.Ayudaste.Gracias.</target>
        </trans-unit>
        <trans-unit id="3f1e4073256cafed9c07f32d545cc56213aba0e9" translate="yes" xml:space="preserve">
          <source>I have ten cards.  And, most of the time -- that is, if I don&amp;rsquo;t have lots of luck -- I must go through the whole deck up to ten times, with up to ten card swaps each time through the deck.</source>
          <target state="translated">Tengo diez cartas Y, la mayor&amp;iacute;a de las veces, es decir, si no tengo mucha suerte, debo pasar por todo el mazo hasta diez veces, con hasta diez intercambios de cartas cada vez a trav&amp;eacute;s del mazo.</target>
        </trans-unit>
        <trans-unit id="0ec03029a11a10972a0136154949cfcba5dbed69" translate="yes" xml:space="preserve">
          <source>I hope this is as simple as you want it.</source>
          <target state="translated">Espero que esto sea tan simple como usted lo quiere.</target>
        </trans-unit>
        <trans-unit id="53ae10c16d270153bdbf8c1a9e6f93c880d6182f" translate="yes" xml:space="preserve">
          <source>I will look at each pair of cards, pair by pair, through the deck, from first to last.  If the first card in one pair is big and the next card in that pair is small, I swap them.  Else, I go to the next pair, and so on and so on... and soon, the deck is done.</source>
          <target state="translated">Miraré cada par de cartas,par por par,a través de la baraja,del primero al último.Si la primera carta de un par es grande y la siguiente carta de ese par es pequeña,las cambio.Si no,paso a la siguiente pareja,y así sucesivamente...y pronto,la baraja está lista.</target>
        </trans-unit>
        <trans-unit id="b9d44117c5235dda1f72fad7eec883c624ba20a4" translate="yes" xml:space="preserve">
          <source>I'd prefer as little formal definition as possible and simple mathematics.</source>
          <target state="translated">Preferiría la menor definición formal posible y matemáticas simples.</target>
        </trans-unit>
        <trans-unit id="f6bbf69b7602636fdd09cc6e847b5d115ba9d058" translate="yes" xml:space="preserve">
          <source>I've more simpler way to understand the time complexity
he most common metric for calculating time complexity is Big O notation. This removes all constant factors so that the running time can be estimated in relation to N as N approaches infinity. In general you can think of it like this:</source>
          <target state="translated">Tengo una forma más simple de entender la complejidad del tiempo.La métrica más común para calcular la complejidad del tiempo es la notación Big O.Esto elimina todos los factores constantes para que el tiempo de ejecución pueda ser estimado en relación a N a medida que N se acerca al infinito.En general,se puede pensar de esta manera:</target>
        </trans-unit>
        <trans-unit id="3c93039db5b8dea862d7aba7ac7a736523f2e466" translate="yes" xml:space="preserve">
          <source>If an algorithm is O(n) then the time/space will increase at the same rate as its input.</source>
          <target state="translated">Si un algoritmo es O(n)entonces el espacio de tiempo aumentará a la misma velocidad que su entrada.</target>
        </trans-unit>
        <trans-unit id="b93496435ccac02920ca75abbec4e210c6e1376f" translate="yes" xml:space="preserve">
          <source>If an algorithm is O(n&lt;sup&gt;2&lt;/sup&gt;) then the time/space increase at the rate of its input squared.</source>
          <target state="translated">Si un algoritmo es O (n &lt;sup&gt;2&lt;/sup&gt; ), entonces el tiempo / espacio aumenta a la velocidad de su entrada al cuadrado.</target>
        </trans-unit>
        <trans-unit id="42bcc6138049b638ae7478e9aaa755e8a5fae576" translate="yes" xml:space="preserve">
          <source>If some values are effectively bounded due to some hidden fact (e.g. the average human name is softly bounded at perhaps 40 letters, and human age is softly bounded at around 150). You can also impose bounds on your input to effectively make terms constant.</source>
          <target state="translated">Si algunos valores están efectivamente delimitados debido a algún hecho oculto (por ejemplo,el nombre humano promedio está suavemente delimitado en quizás 40 letras,y la edad humana está suavemente delimitada en alrededor de 150).También se pueden imponer límites a su entrada para hacer efectivamente constantes los términos.</target>
        </trans-unit>
        <trans-unit id="eadacee139f919b0ca67cb2be538cca322087b44" translate="yes" xml:space="preserve">
          <source>If the above doesn't make sense, then you don't have a compatible intuitive notion of infinity in your head, and you should probably disregard all of the above; the only way I know to make these ideas rigorous, or to explain them if they aren't already intuitively useful, is to first teach you big O notation or something similar. (although, once you well understand big O notation in the future, it may be worthwhile to revisit these ideas)</source>
          <target state="translated">Si lo anterior no tiene sentido,entonces no tienes una noción intuitiva compatible de infinito en tu cabeza,y probablemente deberías ignorar todo lo anterior;la única manera que conozco de hacer estas ideas rigurosas,o de explicarlas si no son ya intuitivamente útiles,es enseñarte primero la notación de O grande o algo similar.(aunque,una vez que entiendas bien la notación de O grande en el futuro,puede que valga la pena volver a examinar estas ideas)</target>
        </trans-unit>
        <trans-unit id="fc0f303936e49cce64dec3515e323c65eb23edc5" translate="yes" xml:space="preserve">
          <source>If the loop has finished without finding the key, return False.</source>
          <target state="translated">Si el bucle se ha terminado sin encontrar la llave,devuelva False.</target>
        </trans-unit>
        <trans-unit id="1f90ef8cce8695b2d4c7c46d902314ff3d88ced2" translate="yes" xml:space="preserve">
          <source>If we do something slightly complicated, you might still be able to imagine visually what's going on:</source>
          <target state="translated">Si hacemos algo ligeramente complicado,puede que aún sea capaz de imaginar visualmente lo que está pasando:</target>
        </trans-unit>
        <trans-unit id="498ad5ebf90abce6c7640e5178604bd12d2cb5dd" translate="yes" xml:space="preserve">
          <source>If we do something very complicated, such as with a recursive function or divide-and-conquer algorithm, &lt;strike&gt;you can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem&quot;&gt;Master Theorem&lt;/a&gt; (usually works), or in ridiculous cases the Akra-Bazzi Theorem (almost always works)&lt;/strike&gt; you look up the running time of your algorithm on Wikipedia.</source>
          <target state="translated">Si hacemos algo muy complicado, como con una funci&amp;oacute;n recursiva o un algoritmo de divide y vencer&amp;aacute;s, &lt;strike&gt;puedes usar el &lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem&quot;&gt;Teorema Maestro&lt;/a&gt; (generalmente funciona), o en casos rid&amp;iacute;culos el Teorema de Akra-Bazzi (casi siempre funciona)&lt;/strike&gt; , busca el tiempo de ejecuci&amp;oacute;n de su algoritmo en Wikipedia.</target>
        </trans-unit>
        <trans-unit id="f340d38ad5275f65c3f3c98f00a52fd253da01b5" translate="yes" xml:space="preserve">
          <source>If we have two 100-digit numbers we need to do 10,000 multiplications and 200 adds.  For two one million digit numbers we need to do one trillion (10&lt;sup&gt;12&lt;/sup&gt;) multiplications and two million adds.</source>
          <target state="translated">Si tenemos dos n&amp;uacute;meros de 100 d&amp;iacute;gitos, necesitamos hacer 10,000 multiplicaciones y 200 sumas. Para dos n&amp;uacute;meros de un mill&amp;oacute;n de d&amp;iacute;gitos necesitamos hacer un bill&amp;oacute;n (10 &lt;sup&gt;12&lt;/sup&gt; ) de multiplicaciones y dos millones de sumas.</target>
        </trans-unit>
        <trans-unit id="7a7797f63ba1469547a1c7c05a0e4651c75d6f7f" translate="yes" xml:space="preserve">
          <source>If we use a simple structure called a hash table (an instant-speed lookup table, also known as a hashmap or dictionary), we pay a small cost by preprocessing everything in &lt;code&gt;O(N)&lt;/code&gt; time. Thereafter, it only takes constant time on average to look up something by its key (in this case, our key is the latitude and longitude coordinates, rounded into a grid; we search the adjacent gridspaces of which there are only 9, which is a constant).</source>
          <target state="translated">Si usamos una estructura simple llamada tabla hash (una tabla de b&amp;uacute;squeda de velocidad instant&amp;aacute;nea, tambi&amp;eacute;n conocida como mapa hash o diccionario), pagamos un peque&amp;ntilde;o costo al preprocesar todo en tiempo &lt;code&gt;O(N)&lt;/code&gt; . A partir de entonces, solo toma un tiempo constante en promedio para buscar algo por su clave (en este caso, nuestra clave son las coordenadas de latitud y longitud, redondeadas en una cuadr&amp;iacute;cula; buscamos los espacios de cuadr&amp;iacute;culas adyacentes de los cuales solo hay 9, que es un constante).</target>
        </trans-unit>
        <trans-unit id="532d60c07f8308239c74d78cfd8bd61382460fae" translate="yes" xml:space="preserve">
          <source>If you have 3 towns A, B and C with roads between all pairs then you could go:</source>
          <target state="translated">Si tienes 3 ciudades A,B y C con caminos entre todos los pares,entonces podrías ir:</target>
        </trans-unit>
        <trans-unit id="85e55a9c0f7521ee220edb5e820f851626c00f8e" translate="yes" xml:space="preserve">
          <source>If you have a suitable notion of infinity in your head, then there is a very brief description:</source>
          <target state="translated">Si tienes una noción adecuada del infinito en tu cabeza,entonces hay una descripción muy breve:</target>
        </trans-unit>
        <trans-unit id="a391595810bc224de5ec62db4d75a23a1dd6b419" translate="yes" xml:space="preserve">
          <source>If you have to sort a deck, what is the best way?  Well, you can do what you want, but I would choose Quick Sort.</source>
          <target state="translated">Si tienes que ordenar una cubierta,¿cuál es la mejor manera? Bueno,puedes hacer lo que quieras,pero yo elegiría la clasificación rápida.</target>
        </trans-unit>
        <trans-unit id="c8f0c3e48ae6bc0a6ae30c3840b7e3d5da5a2114" translate="yes" xml:space="preserve">
          <source>If you only needed to do this once, it would not be a problem to have to do the naive method of &lt;code&gt;O(N)&lt;/code&gt; work only once, but if you want to do it many times (in this case, &lt;code&gt;N&lt;/code&gt; times, once for each segment), we'd have to do &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; work, or 1000000&amp;sup2;=1000000000000 operations. Not good (a modern computer can perform about a billion operations per second).</source>
          <target state="translated">Si solo necesitara hacer esto una vez, no ser&amp;iacute;a un problema tener que hacer que el m&amp;eacute;todo ingenuo de &lt;code&gt;O(N)&lt;/code&gt; funcione solo una vez, pero si desea hacerlo muchas veces (en este caso, &lt;code&gt;N&lt;/code&gt; veces, una vez por cada segmento), tendr&amp;iacute;amos que hacer el trabajo &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; , o 1000000&amp;sup2; = 1000000000000 operaciones. No es bueno (una computadora moderna puede realizar alrededor de mil millones de operaciones por segundo).</target>
        </trans-unit>
        <trans-unit id="b0ce2012a9d7c727364cedfce54d754ac83295bd" translate="yes" xml:space="preserve">
          <source>If you read the &quot;Oh&quot; as meaning &quot;on the order of&quot; or &quot;approximately&quot; you will not go too far wrong. (I think the choice of the Big-Oh might have been an attempt at humour).</source>
          <target state="translated">Si lees el &quot;Oh&quot; como &quot;en el orden de&quot; o &quot;aproximadamente&quot; no te equivocarás demasiado.(Creo que la elección del &quot;Big-Oh&quot; podría haber sido un intento de humor).</target>
        </trans-unit>
        <trans-unit id="879d10b4ee33a790e641d1a246a7c4921f058217" translate="yes" xml:space="preserve">
          <source>If you upgrade to a computer that can run your algorithm twice as fast, big O notation won't notice that. Constant factor improvements are too small to even be noticed in the scale that big O notation works with. Note that this is an intentional part of the design of big O notation.</source>
          <target state="translated">Si te actualizas a un ordenador que puede ejecutar tu algoritmo el doble de rápido,la gran notación O no se dará cuenta de eso.Las mejoras constantes de los factores son demasiado pequeñas para ser notadas en la escala con la que trabaja la gran notación O.Note que esta es una parte intencional del diseño de la gran notación O.</target>
        </trans-unit>
        <trans-unit id="4ca1f62a00fa89bcd7628fd712226caf431517e2" translate="yes" xml:space="preserve">
          <source>If you're sorting something like 5 elements, you don't want to use the speedy &lt;code&gt;O(N log(N))&lt;/code&gt; quicksort; you want to use insertion sort, which happens to perform well on small inputs. These situations often come up in divide-and-conquer algorithms, where you split up the problem into smaller and smaller subproblems, such as recursive sorting, fast Fourier transforms, or matrix multiplication.</source>
          <target state="translated">Si est&amp;aacute; ordenando algo as&amp;iacute; como 5 elementos, no desea utilizar el r&amp;aacute;pido quicksort &lt;code&gt;O(N log(N))&lt;/code&gt; ; desea utilizar el tipo de inserci&amp;oacute;n, que funciona bien en entradas peque&amp;ntilde;as. Estas situaciones a menudo surgen en algoritmos de divide y vencer&amp;aacute;s, donde divides el problema en subproblemas cada vez m&amp;aacute;s peque&amp;ntilde;os, como la clasificaci&amp;oacute;n recursiva, las transformaciones r&amp;aacute;pidas de Fourier o la multiplicaci&amp;oacute;n de matrices.</target>
        </trans-unit>
        <trans-unit id="b1d27a710e5b2deff8083ff199e610d9f97f11b2" translate="yes" xml:space="preserve">
          <source>In Big-O terms this is &lt;strong&gt;O(log n)&lt;/strong&gt; or &lt;strong&gt;logarithmic complexity&lt;/strong&gt;.  Now the logarithm in question could be ln (base e), log&lt;sub&gt;10&lt;/sub&gt;, log&lt;sub&gt;2&lt;/sub&gt; or some other base.  It doesn't matter it's still O(log n) just like O(2n&lt;sup&gt;2&lt;/sup&gt;) and O(100n&lt;sup&gt;2&lt;/sup&gt;) are still both O(n&lt;sup&gt;2&lt;/sup&gt;).</source>
          <target state="translated">En t&amp;eacute;rminos de Big-O, esto es &lt;strong&gt;O (log n)&lt;/strong&gt; o &lt;strong&gt;complejidad logar&amp;iacute;tmica&lt;/strong&gt; . Ahora el logaritmo en cuesti&amp;oacute;n podr&amp;iacute;a ser ln (base e), log &lt;sub&gt;10&lt;/sub&gt; , log &lt;sub&gt;2&lt;/sub&gt; o alguna otra base. No importa que siga siendo O (log n) al igual que O (2n &lt;sup&gt;2&lt;/sup&gt; ) y O (100n &lt;sup&gt;2&lt;/sup&gt; ) siguen siendo O (n &lt;sup&gt;2&lt;/sup&gt; ).</target>
        </trans-unit>
        <trans-unit id="88e50d90d1750553c39e16c7f8930e4119cfca57" translate="yes" xml:space="preserve">
          <source>In CS, the set of steps to accomplish a task is called algorithms.</source>
          <target state="translated">En CS,el conjunto de pasos para realizar una tarea se llama algoritmo.</target>
        </trans-unit>
        <trans-unit id="d95044d68f300f358a3a51cf89c9474f6f16e349" translate="yes" xml:space="preserve">
          <source>In Terminology, Big O notation is used to describe the performance or complexity of an algorithm.</source>
          <target state="translated">En terminología,la notación Big O se utiliza para describir el rendimiento o la complejidad de un algoritmo.</target>
        </trans-unit>
        <trans-unit id="d65e5f9e362ebe36bedba5b57e018e3acbfc0c7b" translate="yes" xml:space="preserve">
          <source>In actuality there are 3 possibilities.</source>
          <target state="translated">En realidad hay 3 posibilidades.</target>
        </trans-unit>
        <trans-unit id="07046d757b1f2b48e849414a4e96d5ff13dade7a" translate="yes" xml:space="preserve">
          <source>In addition, Big O establishes the worst-case or measure the Upper-Bound steps.</source>
          <target state="translated">Además,Big O establece el peor caso o mide los pasos del límite superior.</target>
        </trans-unit>
        <trans-unit id="baa93a55b3140739514a5c40f8e2cdd9810a3c85" translate="yes" xml:space="preserve">
          <source>In all cases, prefer algorithms higher up on the list to those lower on the list.  However, the cost of moving to a more expensive complexity class varies significantly.</source>
          <target state="translated">En todos los casos,prefiera los algoritmos que están más arriba en la lista a los que están más abajo.Sin embargo,el costo de pasar a una clase de complejidad más costosa varía significativamente.</target>
        </trans-unit>
        <trans-unit id="30b960998b211299ef1c91dabf4d8dd22d39e434" translate="yes" xml:space="preserve">
          <source>In big O notation this is written as</source>
          <target state="translated">En la gran notación O esto se escribe como</target>
        </trans-unit>
        <trans-unit id="64aaef6ec6705e0f6426bbcc5b5fde04c862b7d5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;O(...)&lt;/code&gt; is the most useful one because we often care about worst-case behavior. If &lt;code&gt;f(x)&lt;/code&gt; represents something &quot;bad&quot; like the processor or memory usage, then &quot;&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt;&quot; means &quot;&lt;code&gt;upperbound&lt;/code&gt; is the worst-case scenario of processor/memory usage&quot;.</source>
          <target state="translated">En general, &lt;code&gt;O(...)&lt;/code&gt; es el m&amp;aacute;s &amp;uacute;til porque a menudo nos preocupa el comportamiento en el peor de los casos. Si &lt;code&gt;f(x)&lt;/code&gt; representa algo &quot;malo&quot; como el uso del procesador o la memoria, entonces &quot; &lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; &quot; significa que el &lt;code&gt;upperbound&lt;/code&gt; es el peor de los casos del uso del procesador / memoria &quot;.</target>
        </trans-unit>
        <trans-unit id="e9fddaf6556848124995ffd1ed9ddc0b950170ab" translate="yes" xml:space="preserve">
          <source>In general, doing something with every item in one dimension is linear, doing something with every item in two dimensions is quadratic, and dividing the working area in half is logarithmic. There are other Big O measures such as cubic, exponential, and square root, but they're not nearly as common. Big O notation is described as O (  ) where  is the measure. The quicksort algorithm would be described as O ( N * log ( N ) ).</source>
          <target state="translated">En general,hacer algo con cada elemento en una dimensión es lineal,hacer algo con cada elemento en dos dimensiones es cuadrático,y dividir el área de trabajo por la mitad es logarítmico.Hay otras medidas de Big O como la cúbica,la exponencial y la raíz cuadrada,pero no son tan comunes.La notación de Big O se describe como O()donde está la medida.El algoritmo quicksort se describiría como O(N*log(N)).</target>
        </trans-unit>
        <trans-unit id="63a8eaf6bf07c1752a4bb48aa0c8cfc63edc138d" translate="yes" xml:space="preserve">
          <source>In general, our goal will be to find or structure an algorithm &lt;strong&gt;A&lt;/strong&gt; in such a way that it will have a function &lt;code&gt;X(n)&lt;/code&gt; that returns as low a number as possible.</source>
          <target state="translated">En general, nuestro objetivo ser&amp;aacute; encontrar o estructurar un algoritmo &lt;strong&gt;A&lt;/strong&gt; de tal manera que tenga una funci&amp;oacute;n &lt;code&gt;X(n)&lt;/code&gt; que devuelva el n&amp;uacute;mero m&amp;aacute;s bajo posible.</target>
        </trans-unit>
        <trans-unit id="7de7cd6bc8a2b03ecb0a68fecd7a6051d0934bd9" translate="yes" xml:space="preserve">
          <source>In many cases the &quot;O&quot; of an algorithm will fall into one of the following cases:</source>
          <target state="translated">En muchos casos la &quot;O&quot; de un algoritmo caerá en uno de los siguientes casos:</target>
        </trans-unit>
        <trans-unit id="a763bcaebb1bc5faa9ba3036763e8474d16f2b73" translate="yes" xml:space="preserve">
          <source>In one sentence: As the size of your job goes up, how much longer does it take to complete it?</source>
          <target state="translated">En una frase:A medida que el tamaño de su trabajo aumenta,¿cuánto tiempo más se necesita para completarlo?</target>
        </trans-unit>
        <trans-unit id="4bfe8a12e0a2be2aee41e7617d2857524d177ee2" translate="yes" xml:space="preserve">
          <source>In other words where g(n) is the running time of your algorithm, we say that g(n) = O(f(n)) when g(n) &amp;lt;= c*f(n) when n &amp;gt; k, where c and k are some constants.</source>
          <target state="translated">En otras palabras, donde g (n) es el tiempo de ejecuci&amp;oacute;n de su algoritmo, decimos que g (n) = O (f (n)) cuando g (n) &amp;lt;= c * f (n) cuando n&amp;gt; k, donde c y k son algunas constantes.</target>
        </trans-unit>
        <trans-unit id="4e02f4f6e256066f1d4123d571431ca1ed48ec48" translate="yes" xml:space="preserve">
          <source>In other words, in plain English: &lt;em&gt;f&lt;/em&gt;(x) = O(&lt;em&gt;g&lt;/em&gt;(x)), x &amp;rarr; a, means that in a neighborhood of a, &lt;em&gt;f&lt;/em&gt; decomposes into the product of &lt;em&gt;g&lt;/em&gt; and some bounded function.</source>
          <target state="translated">En otras palabras, en ingl&amp;eacute;s simple: &lt;em&gt;f&lt;/em&gt; (x) = O ( &lt;em&gt;g&lt;/em&gt; (x)), x &amp;rarr; a, significa que en una vecindad de a, &lt;em&gt;f se&lt;/em&gt; descompone en el producto de &lt;em&gt;gy&lt;/em&gt; alguna funci&amp;oacute;n acotada.</target>
        </trans-unit>
        <trans-unit id="68079fad5ce0cb40c968faed5e24541715996023" translate="yes" xml:space="preserve">
          <source>In practice, even among algorithms which have the same or similar asymptotic performance, their relative merit may actually be driven by other things, such as: other performance factors (quicksort and mergesort are both &lt;code&gt;O(N log(N))&lt;/code&gt;, but quicksort takes advantage of CPU caches); non-performance considerations, like ease of implementation; whether a library is available, and how reputable and maintained the library is.</source>
          <target state="translated">En la pr&amp;aacute;ctica, incluso entre los algoritmos que tienen el mismo rendimiento asint&amp;oacute;tico o similar, su m&amp;eacute;rito relativo en realidad puede estar impulsado por otras cosas, tales como: otros factores de rendimiento (quicksort y mergesort son ambos &lt;code&gt;O(N log(N))&lt;/code&gt; , pero quicksort toma ventaja de cach&amp;eacute;s de CPU); consideraciones de no rendimiento, como la facilidad de implementaci&amp;oacute;n; si hay una biblioteca disponible y qu&amp;eacute; tan confiable y mantenida es la biblioteca.</target>
        </trans-unit>
        <trans-unit id="84ff32c19c195c6e0453458a4af8916d40d60004" translate="yes" xml:space="preserve">
          <source>In this new way to sort a deck, we do not check pairs of cards the way we did a while ago.  Here are your new rules to sort this deck:</source>
          <target state="translated">En esta nueva forma de ordenar una baraja,no revisamos los pares de cartas como lo hacíamos hace un tiempo.Aquí están sus nuevas reglas para ordenar esta baraja:</target>
        </trans-unit>
        <trans-unit id="c9da7190c61b8b40d9ee9d7282639dd113f829a6" translate="yes" xml:space="preserve">
          <source>Is N * log ( N ). The running time consists of N loops (iterative or recursive) that are logarithmic, thus the algorithm is a combination of linear and logarithmic.</source>
          <target state="translated">Es N*log(N ).El tiempo de funcionamiento consiste en N bucles (iterativos o recursivos)que son logarítmicos,por lo que el algoritmo es una combinación de lineal y logarítmico.</target>
        </trans-unit>
        <trans-unit id="998b8dec061b127d4bd37309e498d87df1954ca7" translate="yes" xml:space="preserve">
          <source>Is constant. The running time of the statement will not change in relation to N</source>
          <target state="translated">Es constante.El tiempo de ejecución de la declaración no cambiará en relación con N</target>
        </trans-unit>
        <trans-unit id="7c262ad477a4821f4fb1c7733312befe0c8fe05a" translate="yes" xml:space="preserve">
          <source>Is it more or less fast than the first sort?  Big O, please help!</source>
          <target state="translated">¿Es más o menos rápido que el primer tipo? ¡Big O,por favor,ayuda!</target>
        </trans-unit>
        <trans-unit id="29e49e4fc142b2d0f2b1a400df6ab96e4a918158" translate="yes" xml:space="preserve">
          <source>Is linear. The running time of the loop is directly proportional to N. When N doubles, so does the running time.</source>
          <target state="translated">Es lineal.El tiempo de funcionamiento del bucle es directamente proporcional a N.Cuando N se duplica,también lo hace el tiempo de funcionamiento.</target>
        </trans-unit>
        <trans-unit id="0669d4a8187abfada364d0bb775de3933241efd7" translate="yes" xml:space="preserve">
          <source>Is logarithmic. The running time of the algorithm is proportional to the number of times N can be divided by 2. This is because the algorithm divides the working area in half with each iteration.</source>
          <target state="translated">Es logarítmico.El tiempo de funcionamiento del algoritmo es proporcional al número de veces que N puede ser dividido por 2.Esto se debe a que el algoritmo divide el área de trabajo por la mitad con cada iteración.</target>
        </trans-unit>
        <trans-unit id="f9cef10a1858aa5a865ebf26c425725395a40d0a" translate="yes" xml:space="preserve">
          <source>Is quadratic. The running time of the two loops is proportional to the square of N. When N doubles, the running time increases by N * N.</source>
          <target state="translated">Es cuadrático.El tiempo de funcionamiento de los dos bucles es proporcional al cuadrado de N.Cuando N se duplica,el tiempo de funcionamiento aumenta en N*N.</target>
        </trans-unit>
        <trans-unit id="1189cb04bbafbceb75864abdc92eb47236ec61c3" translate="yes" xml:space="preserve">
          <source>Is there a more fast way to sort the cards?  Can big O help us?</source>
          <target state="translated">¿Hay una forma más rápida de ordenar las cartas? ¿Puede ayudarnos el gran O?</target>
        </trans-unit>
        <trans-unit id="bdcb0de02955e320abf0c31ab2a8744682cbbe08" translate="yes" xml:space="preserve">
          <source>It is very difficult to measure the speed of software programs, and when we try, the answers can be very complex and filled with exceptions and special cases. This is a big problem, because all those exceptions and special cases are distracting and unhelpful when we want to compare two different programs with one another to find out which is &quot;fastest&quot;.</source>
          <target state="translated">Es muy difícil medir la velocidad de los programas de software,y cuando lo intentamos,las respuestas pueden ser muy complejas y llenas de excepciones y casos especiales.Esto es un gran problema,porque todas esas excepciones y casos especiales nos distraen y no nos ayudan cuando queremos comparar dos programas diferentes entre sí para averiguar cuál es el más &quot;rápido&quot;.</target>
        </trans-unit>
        <trans-unit id="52df2acf675e9663e6643a99463b7ca8b662796f" translate="yes" xml:space="preserve">
          <source>It shows how an algorithm scales based on input size.</source>
          <target state="translated">Muestra cómo un algoritmo escala basado en el tamaño de la entrada.</target>
        </trans-unit>
        <trans-unit id="293ad219691b62a126a8db817cbbea70a32b0c5f" translate="yes" xml:space="preserve">
          <source>It's as if the empty boxes on the diagonal of the chart (N*(N-1)/2 checkmarks) weren't even there (N&lt;sup&gt;2&lt;/sup&gt; checkmarks asymptotically).</source>
          <target state="translated">Es como si las casillas vac&amp;iacute;as en la diagonal del gr&amp;aacute;fico (N * (N-1) / 2 marcas de verificaci&amp;oacute;n) ni siquiera estuvieran all&amp;iacute; (N &lt;sup&gt;2&lt;/sup&gt; marcas &lt;sup&gt;de&lt;/sup&gt; verificaci&amp;oacute;n asint&amp;oacute;ticamente).</target>
        </trans-unit>
        <trans-unit id="ec70bfe19e1f4d33f015bf1ed0c0eb3f05117561" translate="yes" xml:space="preserve">
          <source>It's worthwhile at this point to explain that Big O can be used to determine three cases with an algorithm:</source>
          <target state="translated">En este punto vale la pena explicar que Big O puede ser usado para determinar tres casos con un algoritmo:</target>
        </trans-unit>
        <trans-unit id="29cba760a7e3ba133866ed85852ba33956337368" translate="yes" xml:space="preserve">
          <source>Iterating on each item in the list, if it's the key then return True,</source>
          <target state="translated">Iterando en cada elemento de la lista,si es la clave,entonces devuelve Verdadero,</target>
        </trans-unit>
        <trans-unit id="53da104c94a561d37e7b0bbeefcf47818dc3f2be" translate="yes" xml:space="preserve">
          <source>Keep in mind that big-O is not the whole story. You can drastically speed up some algorithms by using caching, making them cache-oblivious, avoiding bottlenecks by working with RAM instead of disk, using parallelization, or doing work ahead of time -- these techniques are often &lt;em&gt;independent&lt;/em&gt; of the order-of-growth &quot;big-O&quot; notation, though you will often see the number of cores in the big-O notation of parallel algorithms.</source>
          <target state="translated">Tenga en cuenta que big-O no es toda la historia. Puede acelerar dr&amp;aacute;sticamente algunos algoritmos utilizando el almacenamiento en cach&amp;eacute;, haci&amp;eacute;ndolos ajenos a la memoria cach&amp;eacute;, evitando cuellos de botella al trabajar con RAM en lugar de disco, utilizando paralelizaci&amp;oacute;n o trabajando con anticipaci&amp;oacute;n: estas t&amp;eacute;cnicas a menudo son &lt;em&gt;independientes&lt;/em&gt; del orden de crecimiento notaci&amp;oacute;n &quot;big-O&quot;, aunque a menudo ver&amp;aacute; el n&amp;uacute;mero de n&amp;uacute;cleos en la notaci&amp;oacute;n big-O de algoritmos paralelos.</target>
        </trans-unit>
        <trans-unit id="bc8c7b0e9f3998b53c3c3a45f086e6279211fb80" translate="yes" xml:space="preserve">
          <source>Let's assume that the addition of these numbers is the most expensive operation in this algorithm. It stands to reason that to add these two numbers together we have to add together 6 digits (and possibly carry a 7th). If we add two 100 digit numbers together we have to do 100 additions.  If we add &lt;strong&gt;two&lt;/strong&gt; 10,000 digit numbers we have to do 10,000 additions.</source>
          <target state="translated">Supongamos que la suma de estos n&amp;uacute;meros es la operaci&amp;oacute;n m&amp;aacute;s costosa en este algoritmo. Es l&amp;oacute;gico que para sumar estos dos n&amp;uacute;meros juntos tengamos que sumar 6 d&amp;iacute;gitos (y posiblemente llevar un s&amp;eacute;ptimo). Si sumamos dos n&amp;uacute;meros de 100 d&amp;iacute;gitos, tenemos que hacer 100 sumas. Si agregamos &lt;strong&gt;dos&lt;/strong&gt; n&amp;uacute;meros de 10,000 d&amp;iacute;gitos, tenemos que hacer 10,000 sumas.</target>
        </trans-unit>
        <trans-unit id="0e3d7a37946e8fa9bb0f4b9c5caa0b1e6214f02f" translate="yes" xml:space="preserve">
          <source>Let's say your algorithm dealing with the problem depends on some 'factors', for example let's make it N and X.</source>
          <target state="translated">Digamos que el algoritmo que se ocupa del problema depende de algunos &quot;factores&quot;,por ejemplo,que sea N y X.</target>
        </trans-unit>
        <trans-unit id="e09ce0464689a88f3f8747581ffb2d480edd57b6" translate="yes" xml:space="preserve">
          <source>Logarithms</source>
          <target state="translated">Logarithms</target>
        </trans-unit>
        <trans-unit id="0f768f66724b1ab90c8b65c4b90be682a8ff30a2" translate="yes" xml:space="preserve">
          <source>Logarithms are slightly trickier to explain so I'll use a common
  example:</source>
          <target state="translated">Los logaritmos son un poco más difíciles de explicar,así que usaré un ejemplo común:</target>
        </trans-unit>
        <trans-unit id="818cd71ba05516b0c7d38db784302c45d9d62431" translate="yes" xml:space="preserve">
          <source>More precisely &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; is used to express the asymptotic behavior of a function. That means how the function behaves as it approaches infinity.</source>
          <target state="translated">M&amp;aacute;s precisamente, la &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;notaci&amp;oacute;n Big O&lt;/a&gt; se usa para expresar el comportamiento asint&amp;oacute;tico de una funci&amp;oacute;n. Eso significa c&amp;oacute;mo se comporta la funci&amp;oacute;n a medida que se acerca al infinito.</target>
        </trans-unit>
        <trans-unit id="53558434954a9542c40a6931db4c48fcfc391a05" translate="yes" xml:space="preserve">
          <source>Most of the time, people don't realize that there's more than one variable at work. For example, in a string-search algorithm, your algorithm may take time &lt;code&gt;O([length of text] + [length of query])&lt;/code&gt;, i.e. it is linear in two variables like &lt;code&gt;O(N+M)&lt;/code&gt;. Other more naive algorithms may be &lt;code&gt;O([length of text]*[length of query])&lt;/code&gt; or &lt;code&gt;O(N*M)&lt;/code&gt;. Ignoring multiple variables is one of the most common oversights I see in algorithm analysis, and can handicap you when designing an algorithm.</source>
          <target state="translated">La mayor&amp;iacute;a de las veces, las personas no se dan cuenta de que hay m&amp;aacute;s de una variable en el trabajo. Por ejemplo, en un algoritmo de b&amp;uacute;squeda de cadenas, su algoritmo puede llevar tiempo &lt;code&gt;O([length of text] + [length of query])&lt;/code&gt; , es decir, es lineal en dos variables como &lt;code&gt;O(N+M)&lt;/code&gt; . Otros algoritmos m&amp;aacute;s ingenuos pueden ser &lt;code&gt;O([length of text]*[length of query])&lt;/code&gt; u &lt;code&gt;O(N*M)&lt;/code&gt; . Ignorar m&amp;uacute;ltiples variables es una de las descuidas m&amp;aacute;s comunes que veo en el an&amp;aacute;lisis de algoritmos, y puede perjudicarlo al dise&amp;ntilde;ar un algoritmo.</target>
        </trans-unit>
        <trans-unit id="046638077884a582146518106d52398b493200ef" translate="yes" xml:space="preserve">
          <source>Multiplication is different. You line the numbers up, take the first digit in the bottom number and multiply it in turn against each digit in the top number and so on through each digit. So to multiply our two 6 digit numbers we must do 36 multiplications. We may need to do as many as 10 or 11 column adds to get the end result too.</source>
          <target state="translated">La multiplicación es diferente.Se alinean los números,se toma el primer dígito del número inferior y se multiplica a su vez contra cada dígito del número superior y así sucesivamente a través de cada dígito.Así que para multiplicar nuestros dos números de 6 dígitos debemos hacer 36 multiplicaciones.Puede que necesitemos hacer tantas sumas de 10 u 11 columnas para obtener el resultado final también.</target>
        </trans-unit>
        <trans-unit id="8b1b53f8f44ad3ed2592eb6c68dec183ea16ec21" translate="yes" xml:space="preserve">
          <source>My list</source>
          <target state="translated">Mi lista</target>
        </trans-unit>
        <trans-unit id="f7535aeee1a8d7280cd70d9997d4349f35bb3d3e" translate="yes" xml:space="preserve">
          <source>Naive method: If you had the coordinates of a street intersection, and wanted to examine nearby streets, you would have to go through the millions of segments each time, and check each one for adjacency.</source>
          <target state="translated">Un método ingenuo:Si tuvieras las coordenadas de una intersección de calles,y quisieras examinar las calles cercanas,tendrías que pasar por los millones de segmentos cada vez,y comprobar la adyacencia de cada uno de ellos.</target>
        </trans-unit>
        <trans-unit id="4d68869609a9235101b6bdb59cfad0ecf3bbe23e" translate="yes" xml:space="preserve">
          <source>No growth.  Regardless of how big as the problem is, you can solve it in the same amount of time.  This is somewhat analogous to broadcasting where it takes the same amount of energy to broadcast over a given distance, regardless of the number of people that lie within the broadcast range.</source>
          <target state="translated">No hay crecimiento.Independientemente de lo grande que sea el problema,puedes resolverlo en el mismo tiempo.Esto es algo análogo a la radiodifusión donde se necesita la misma cantidad de energía para emitir a una distancia determinada,independientemente del número de personas que se encuentren dentro del rango de emisión.</target>
        </trans-unit>
        <trans-unit id="fe33dcb0f45062333e4e71b8e3449ababa913575" translate="yes" xml:space="preserve">
          <source>Normally we don't care about the best case.  We're interested in the expected and worst case.  Sometimes one or the other of these will be more important.</source>
          <target state="translated">Normalmente no nos importa el mejor caso.Nos interesa el esperado y el peor caso.A veces uno u otro de estos será más importante.</target>
        </trans-unit>
        <trans-unit id="1a399a408e72ce4d50e1c555e9e14eb8f828e225" translate="yes" xml:space="preserve">
          <source>Not all algorithms run in the same amount of time, and can vary based on the number of items in the input, which we'll call &lt;em&gt;n&lt;/em&gt;. Based on this, we consider the worse case analysis, or an upper-bound of the run-time as &lt;em&gt;n&lt;/em&gt; get larger and larger. We must be aware of what &lt;em&gt;n&lt;/em&gt; is, because many of the Big O notations reference it.</source>
          <target state="translated">No todos los algoritmos se ejecutan en la misma cantidad de tiempo y pueden variar seg&amp;uacute;n la cantidad de elementos en la entrada, que llamaremos &lt;em&gt;n&lt;/em&gt; . En base a esto, consideramos el peor an&amp;aacute;lisis de caso, o un l&amp;iacute;mite superior del tiempo de ejecuci&amp;oacute;n a medida que &lt;em&gt;n&lt;/em&gt; se hace m&amp;aacute;s y m&amp;aacute;s grande. Debemos ser conscientes de lo que es &lt;em&gt;n&lt;/em&gt; , porque muchas de las notaciones Big O hacen referencia a &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="9701d8a66e2332c79e3006b450aca766fa1d69b7" translate="yes" xml:space="preserve">
          <source>Not sure I'm further contributing to the subject but still thought I'd share: I once found &lt;a href=&quot;http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/&quot;&gt;this blog post&lt;/a&gt; to have some quite helpful (though very basic) explanations &amp;amp; examples on Big O:</source>
          <target state="translated">No estoy seguro de seguir contribuyendo al tema, pero a&amp;uacute;n as&amp;iacute; pens&amp;eacute; en compartir: una vez encontr&amp;eacute; que &lt;a href=&quot;http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/&quot;&gt;esta publicaci&amp;oacute;n de blog&lt;/a&gt; ten&amp;iacute;a algunas explicaciones y ejemplos bastante &amp;uacute;tiles (aunque muy b&amp;aacute;sicos) sobre Big O:</target>
        </trans-unit>
        <trans-unit id="ed45d6f0b33afd4fda7acc9a90c9a6ded141d1e6" translate="yes" xml:space="preserve">
          <source>Note: None of this has taken into account best, average, and worst case measures. Each would have its own Big O notation. Also note that this is a VERY simplistic explanation. Big O is the most common, but it's also more complex that I've shown. There are also other notations such as big omega, little o, and big theta. You probably won't encounter them outside of an algorithm analysis course.</source>
          <target state="translated">Nota:En nada de esto se han tenido en cuenta las medidas del mejor,el promedio y el peor de los casos.Cada una tendría su propia notación de Big O.También tenga en cuenta que esta es una explicación MUY simplista.Big O es la más común,pero también es más compleja de las que he mostrado.También hay otras notaciones como &quot;big omega&quot;,&quot;little o&quot; y &quot;big theta&quot;.Probablemente no las encontrarás fuera de un curso de análisis de algoritmos.</target>
        </trans-unit>
        <trans-unit id="2238088b0eacca225a542e4f91ecc2965d263d59" translate="yes" xml:space="preserve">
          <source>Notice that the number of items increases by a factor of 10, but the time increases by a factor of 10&lt;sup&gt;2&lt;/sup&gt;. Basically, n=10 and so O(n&lt;sup&gt;2&lt;/sup&gt;) gives us the scaling factor n&lt;sup&gt;2&lt;/sup&gt; which is 10&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">Observe que el n&amp;uacute;mero de elementos aumenta en un factor de 10, pero el tiempo aumenta en un factor de 10 &lt;sup&gt;2&lt;/sup&gt; . B&amp;aacute;sicamente, n = 10 y entonces O (n &lt;sup&gt;2&lt;/sup&gt; ) nos da el factor de escala n &lt;sup&gt;2&lt;/sup&gt; que es 10 &lt;sup&gt;2&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="257c3797269830bc9710d43ca3694a583cd402ae" translate="yes" xml:space="preserve">
          <source>Now I have some work.  I have this list: one, two, three, four, five, six.  I must add all things in this list.</source>
          <target state="translated">Ahora tengo algo de trabajo.Tengo esta lista:uno,dos,tres,cuatro,cinco,seis.Debo añadir todas las cosas de esta lista.</target>
        </trans-unit>
        <trans-unit id="ce4444486678ac072c200b97ac0870621f89a826" translate="yes" xml:space="preserve">
          <source>Now at times, I do have to go to work.  It is sad, but true.  So, when I am at work, I have a rule: I try to do less work.  As near to no work as I can.  Then I go play!</source>
          <target state="translated">Ahora,a veces,tengo que ir a trabajar.Es triste,pero cierto.Así que,cuando estoy en el trabajo,tengo una regla:trato de trabajar menos.Tan cerca de no trabajar como pueda.¡Entonces voy a jugar!</target>
        </trans-unit>
        <trans-unit id="4af2bcb5c492dc62ee7f7d5ed90f520c4c05c4e0" translate="yes" xml:space="preserve">
          <source>Now here comes big O, and he will tell us how hard this work is.  He says: to add all things from one to N, one by one, is O(n).  To add all these things, [I know I must add n times.][1]  That is big O!  He tells us how hard it is to do some type of work.</source>
          <target state="translated">Ahora viene el gran O,y nos dirá lo duro que es este trabajo.Dice:sumar todas las cosas de una en N,una por una,es O(n).Para añadir todas estas cosas,[Sé que debo añadir n veces.][1]Eso es el gran O! Nos dice lo difícil que es hacer algún tipo de trabajo.</target>
        </trans-unit>
        <trans-unit id="6c34478c5f5b54c8853b19d59a2824aed411c88f" translate="yes" xml:space="preserve">
          <source>Now here is where big O is our friend.</source>
          <target state="translated">Aquí es donde el gran O es nuestro amigo.</target>
        </trans-unit>
        <trans-unit id="110a534fc79ede4defb1ebec55d0413c614f421d" translate="yes" xml:space="preserve">
          <source>Now if you were instructing a computer to look up the phone number for &quot;John Smith&quot; in a telephone book that contains 1,000,000 names, what would you do?  Ignoring the fact that you could guess how far in the S's started (let's assume you can't), what would you do?</source>
          <target state="translated">Ahora,si le dijera a una computadora que busque el número de teléfono de &quot;John Smith&quot; en una guía telefónica que contiene 1.000.000 de nombres,¿qué haría? Ignorando el hecho de que podrías adivinar hasta qué punto comenzó la S (asumamos que no puedes),¿qué harías?</target>
        </trans-unit>
        <trans-unit id="9540b13ba056381a0510ad691215a7809e459df8" translate="yes" xml:space="preserve">
          <source>Now that work is done, let&amp;rsquo;s go play!</source>
          <target state="translated">Ahora que el trabajo est&amp;aacute; hecho, &amp;iexcl;vamos a jugar!</target>
        </trans-unit>
        <trans-unit id="d6eba09ebedd6f51a03a1027fa2fafcd89c71acb" translate="yes" xml:space="preserve">
          <source>Now they ask me to add from one to ten!  Why would I do that?  I did not want to add one to six.  To add from one to ten&amp;hellip; well&amp;hellip; that would be even more hard!</source>
          <target state="translated">&amp;iexcl;Ahora me piden que agregue del uno al diez! &amp;iquest;Por qu&amp;eacute; habr&amp;iacute;a de hacer eso? No quer&amp;iacute;a agregar uno a seis. Agregar de uno a diez ... bueno ... &amp;iexcl;eso ser&amp;iacute;a a&amp;uacute;n m&amp;aacute;s dif&amp;iacute;cil!</target>
        </trans-unit>
        <trans-unit id="00988e447c66a2cb48babcb9e00cb583a7ea2cdd" translate="yes" xml:space="preserve">
          <source>Now we must do new work.  Oh, no.  I don&amp;rsquo;t like this work thing at all.</source>
          <target state="translated">Ahora debemos hacer un nuevo trabajo. Oh no. No me gusta este trabajo en absoluto.</target>
        </trans-unit>
        <trans-unit id="2649fa4f7ace90e5e3a42578e0c5f2755906f188" translate="yes" xml:space="preserve">
          <source>Now when big O says it will take O(n squared) work, he does not mean n squared adds, on the nose.  It might be some small bit less, for some case.  But in the worst case, it will be near n squared steps of work to sort the deck.</source>
          <target state="translated">Ahora,cuando el gran O dice que tomará el trabajo de O(n al cuadrado),no quiere decir que n al cuadrado agregue,en la nariz.Puede ser un poco menos,para algún caso.Pero en el peor de los casos,será cerca de n pasos de trabajo al cuadrado para ordenar la cubierta.</target>
        </trans-unit>
        <trans-unit id="08d4d2dadf777a65ea195b7215d064cef2cd8721" translate="yes" xml:space="preserve">
          <source>Now you know my friend, Big O.  He helps us do less work.  And if you know big O, you can do less work too!</source>
          <target state="translated">Ahora conoces a mi amigo,Big O.Él nos ayuda a trabajar menos.Y si conoces a Big O,¡también puedes trabajar menos!</target>
        </trans-unit>
        <trans-unit id="05dc08a4c399781657ad8add0a8aafb1f260a439" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s you and me talk of work. Most of the time, I do not like work.  Do you like work?  It may be the case that you do, but I am sure I do not.</source>
          <target state="translated">Ahora, hablemos t&amp;uacute; y yo del trabajo. La mayor&amp;iacute;a de las veces, no me gusta el trabajo. Te gusta el trabajo Puede ser que lo hagas, pero estoy seguro de que no.</target>
        </trans-unit>
        <trans-unit id="205e8cfdfc5930c2d0673af6524af6317388bfed" translate="yes" xml:space="preserve">
          <source>O and Ω are not symmetric (n = O(n&amp;sup2;), but n&amp;sup2; is not O(n)), but Ɵ is symmetric, and (since these relations are all transitive and reflexive) Ɵ, therefore, is symmetric and transitive and reflexive, and therefore partitions the set of all functions into &lt;em&gt;equivalence classes&lt;/em&gt;. An equivalence class is a set of things that we consider to be the same. That is to say, given any function you can think of, you can find a canonical/unique 'asymptotic representative' of the class (by generally taking the limit... I &lt;em&gt;think&lt;/em&gt;); just like you can group all integers into odds or evens, you can group all functions with Ɵ into x-ish, log(x)^2-ish, etc... by basically ignoring smaller terms (but sometimes you might be stuck with more complicated functions which are separate classes unto themselves).</source>
          <target state="translated">O y &amp;Omega; no son sim&amp;eacute;tricos (n = O (n&amp;sup2;), pero n&amp;sup2; no es O (n)), pero Ɵ es sim&amp;eacute;trico y (dado que estas relaciones son todas transitivas y reflexivas) Ɵ, por lo tanto, es sim&amp;eacute;trico y transitivo y reflexivo y, por lo tanto, divide el conjunto de todas las funciones en &lt;em&gt;clases de equivalencia&lt;/em&gt; . Una clase de equivalencia es un conjunto de cosas que consideramos iguales. Es decir, dada cualquier funci&amp;oacute;n que se te ocurra, puedes encontrar un 'representante asint&amp;oacute;tico' can&amp;oacute;nico / &amp;uacute;nico de la clase (generalmente tomando el l&amp;iacute;mite ... &lt;em&gt;creo&lt;/em&gt; ); al igual que puede agrupar todos los enteros en probabilidades o pares, puede agrupar todas las funciones con Ɵ en x-ish, log (x) ^ 2-ish, etc ... ignorando b&amp;aacute;sicamente los t&amp;eacute;rminos m&amp;aacute;s peque&amp;ntilde;os (pero a veces puede estar atascado con funciones m&amp;aacute;s complicadas que son clases separadas en s&amp;iacute; mismas).</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="98e642472708191e8a65ac2ab3cf6a96d7f6885e" translate="yes" xml:space="preserve">
          <source>O(1) = O(n) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin; (but not the other way around, the equality is &quot;fake&quot;),</source>
          <target state="translated">O (1) = O (n) = O (n &lt;sup&gt;2&lt;/sup&gt; ) cuando n &amp;rarr; + &amp;infin; (pero no al rev&amp;eacute;s, la igualdad es &quot;falsa&quot;),</target>
        </trans-unit>
        <trans-unit id="25c301e3f5329dedc950de0f1c38ac8d3d8286a2" translate="yes" xml:space="preserve">
          <source>O(1) describes an algorithm that will always execute in the same time
  (or space) regardless of the size of the input data set.</source>
          <target state="translated">O(1)describe un algoritmo que siempre se ejecutará en el mismo tiempo (o espacio)independientemente del tamaño del conjunto de datos de entrada.</target>
        </trans-unit>
        <trans-unit id="1e77cb950a650cbda7e41c7e563dfc7d75184ce0" translate="yes" xml:space="preserve">
          <source>O(1), means your computer gets a task done with &lt;code&gt;1&lt;/code&gt; step, it's excellent, Ordered No.1</source>
          <target state="translated">O (1), significa que su computadora realiza una tarea con &lt;code&gt;1&lt;/code&gt; paso, es excelente, orden&amp;oacute; No.1</target>
        </trans-unit>
        <trans-unit id="8681bf4e62cb366ee6970996fa273715542e1c24" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;N&lt;/sup&gt;)</source>
          <target state="translated">O(2&lt;sup&gt;N&lt;/sup&gt;)</target>
        </trans-unit>
        <trans-unit id="e3d80bfb500c859c180f245124c30408ce843ee8" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;N&lt;/sup&gt;) denotes an algorithm whose growth doubles with each additon to
  the input data set. The growth curve of an O(2&lt;sup&gt;N&lt;/sup&gt;) function is
  exponential - starting off very shallow, then rising meteorically. An
  example of an O(2&lt;sup&gt;N&lt;/sup&gt;) function is the recursive calculation of Fibonacci
  numbers:</source>
          <target state="translated">O (2 &lt;sup&gt;N&lt;/sup&gt; ) denota un algoritmo cuyo crecimiento se duplica con cada adici&amp;oacute;n al conjunto de datos de entrada. La curva de crecimiento de una funci&amp;oacute;n O (2 &lt;sup&gt;N&lt;/sup&gt; ) es exponencial: comienza muy poco profunda y luego sube mete&amp;oacute;ricamente. Un ejemplo de una funci&amp;oacute;n O (2 &lt;sup&gt;N&lt;/sup&gt; ) es el c&amp;aacute;lculo recursivo de n&amp;uacute;meros de Fibonacci:</target>
        </trans-unit>
        <trans-unit id="68bc7ad068f5c61d49e37e6fc72efd56e5f32c9c" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;n&lt;/sup&gt;): If the input size increases by one, the runtime doubles</source>
          <target state="translated">O (2 &lt;sup&gt;n&lt;/sup&gt; ): si el tama&amp;ntilde;o de entrada aumenta en uno, el tiempo de ejecuci&amp;oacute;n se duplica</target>
        </trans-unit>
        <trans-unit id="63e9d8727f40f7ec9e8552148c03efe752771415" translate="yes" xml:space="preserve">
          <source>O(2^N),  get a task done with &lt;code&gt;2^N&lt;/code&gt; steps, it's horrible, Order No.6</source>
          <target state="translated">O (2 ^ N), realiza una tarea con &lt;code&gt;2^N&lt;/code&gt; pasos, es horrible, Orden No.6</target>
        </trans-unit>
        <trans-unit id="308b527a11caed66089316ea8a6e1067c1969f82" translate="yes" xml:space="preserve">
          <source>O(N!),  get a task done with &lt;code&gt;N!&lt;/code&gt; steps, it's terrible, Order No.7</source>
          <target state="translated">O (N!), Haz una tarea con &lt;code&gt;N!&lt;/code&gt; pasos, es terrible, Orden No.7</target>
        </trans-unit>
        <trans-unit id="a257064879b3c5b994b0c4eb5698b028eb534479" translate="yes" xml:space="preserve">
          <source>O(N)</source>
          <target state="translated">O(N)</target>
        </trans-unit>
        <trans-unit id="c3f150e3661faff6df87ef3476136d42ffe76b00" translate="yes" xml:space="preserve">
          <source>O(N) describes an algorithm whose performance will grow linearly and
  in direct proportion to the size of the input data set. The example
  below also demonstrates how Big O favours the worst-case performance
  scenario; a matching string could be found during any iteration of the
  for loop and the function would return early, but Big O notation will
  always assume the upper limit where the algorithm will perform the
  maximum number of iterations.</source>
          <target state="translated">O(N)describe un algoritmo cuyo rendimiento crecerá linealmente y en proporción directa al tamaño del conjunto de datos de entrada.El ejemplo que figura a continuación también demuestra cómo Big O favorece el peor de los casos de rendimiento;se podría encontrar una cadena de coincidencia durante cualquier iteración del bucle for y la función volvería antes,pero la notación Big O siempre asumirá el límite superior en el que el algoritmo realizará el máximo número de iteraciones.</target>
        </trans-unit>
        <trans-unit id="50a60625d0c152951efa7ecdbe93cfe7f46beda6" translate="yes" xml:space="preserve">
          <source>O(N), finish a task with &lt;code&gt;N&lt;/code&gt; steps, its fair, Order No.3</source>
          <target state="translated">O (N), termine una tarea con &lt;code&gt;N&lt;/code&gt; pasos, es justo, Orden No.3</target>
        </trans-unit>
        <trans-unit id="56b0b7dfdc166b52f3daf1b1c70a817924759e73" translate="yes" xml:space="preserve">
          <source>O(N&lt;sup&gt;2&lt;/sup&gt;)</source>
          <target state="translated">O(N&lt;sup&gt;2&lt;/sup&gt;)</target>
        </trans-unit>
        <trans-unit id="8c2b565c37a449cbce6a610382372bb9973c5a59" translate="yes" xml:space="preserve">
          <source>O(N&lt;sup&gt;2&lt;/sup&gt;) represents an algorithm whose performance is directly
  proportional to the square of the size of the input data set. This is
  common with algorithms that involve nested iterations over the data
  set. Deeper nested iterations will result in O(N&lt;sup&gt;3&lt;/sup&gt;), O(N&lt;sup&gt;4&lt;/sup&gt;) etc.</source>
          <target state="translated">O (N &lt;sup&gt;2&lt;/sup&gt; ) representa un algoritmo cuyo rendimiento es directamente proporcional al cuadrado del tama&amp;ntilde;o del conjunto de datos de entrada. Esto es com&amp;uacute;n con algoritmos que involucran iteraciones anidadas sobre el conjunto de datos. Las iteraciones anidadas m&amp;aacute;s profundas dar&amp;aacute;n como resultado O (N &lt;sup&gt;3&lt;/sup&gt; ), O (N &lt;sup&gt;4&lt;/sup&gt; ), etc.</target>
        </trans-unit>
        <trans-unit id="de99ca4237dd94527753ecf95f080066d3a66999" translate="yes" xml:space="preserve">
          <source>O(N^2),  get a task done with &lt;code&gt;N^2&lt;/code&gt; steps, it's bad, Order No.5</source>
          <target state="translated">O (N ^ 2), realice una tarea con &lt;code&gt;N^2&lt;/code&gt; pasos, es malo, Orden No.5</target>
        </trans-unit>
        <trans-unit id="044f421fbafcb690927916033a456e1ccb0b67d2" translate="yes" xml:space="preserve">
          <source>O(NlogN), ends a task with &lt;code&gt;O(NlogN)&lt;/code&gt; steps, it's not good, Order No.4</source>
          <target state="translated">O (NlogN), finaliza una tarea con pasos &lt;code&gt;O(NlogN)&lt;/code&gt; , no es bueno, Orden No.4</target>
        </trans-unit>
        <trans-unit id="adcb5e72616abf45d10a5b515b2a078ad0f91adb" translate="yes" xml:space="preserve">
          <source>O(O(n&lt;sup&gt;2&lt;/sup&gt;)) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">O (O (n &lt;sup&gt;2&lt;/sup&gt; )) = O (n &lt;sup&gt;2&lt;/sup&gt; ) cuando n &amp;rarr; + &amp;infin;</target>
        </trans-unit>
        <trans-unit id="ece6ebf71b235bbf6ca0d80731462a53a21f231d" translate="yes" xml:space="preserve">
          <source>O(log n): If the input size doubles the runtime increases by one</source>
          <target state="translated">O(log n):Si el tamaño de la entrada se duplica,el tiempo de ejecución aumenta en uno</target>
        </trans-unit>
        <trans-unit id="7e25f642c5b31ae751d0fbe5acb56b926e9390ba" translate="yes" xml:space="preserve">
          <source>O(logN), means your computer complete a task with &lt;code&gt;logN&lt;/code&gt; steps, its good, Ordered No.2</source>
          <target state="translated">O (logN), significa que su computadora completa una tarea con pasos &lt;code&gt;logN&lt;/code&gt; , es bueno, No.2 ordenado</target>
        </trans-unit>
        <trans-unit id="d09f9f7cdec58e339154e9a9c832d0991809a760" translate="yes" xml:space="preserve">
          <source>O(n) + O(n&lt;sup&gt;2&lt;/sup&gt;) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">O (n) + O (n &lt;sup&gt;2&lt;/sup&gt; ) = O (n &lt;sup&gt;2&lt;/sup&gt; ) cuando n &amp;rarr; + &amp;infin;</target>
        </trans-unit>
        <trans-unit id="97dd63fef8702296bf87a4c2e21f4bd48ff0b539" translate="yes" xml:space="preserve">
          <source>O(n) means Big O is n, and now you might think, &quot;What is n!?&quot; Well &quot;n&quot; is the amount of elements. Imaging you want to search for an Item in an Array. You would have to look on Each element and as &quot;Are you the correct element/item?&quot; in the worst case, the item is at the last index, which means that it took as much time as there are items in the list, so to be generic, we say &quot;oh hey, n is a fair given amount of values!&quot;.</source>
          <target state="translated">O(n)significa Gran O es n,y ahora podrías pensar,&quot;¿Qué es n?&quot; Bueno &quot;n&quot; es la cantidad de elementos.Imaginando que quieres buscar un elemento en una matriz.Tendrías que mirar en cada elemento y como &quot;¿Eres el elemento correcto?&quot; en el peor de los casos,el elemento está en el último índice,lo que significa que tomó tanto tiempo como hay elementos en la lista,así que para ser genéricos,decimos &quot;¡oh hey,n es una cantidad justa dada de valores!&quot;.</target>
        </trans-unit>
        <trans-unit id="d0849346fa8631d6b61d0173d101e04d26feaa94" translate="yes" xml:space="preserve">
          <source>O(n) ~ Linear</source>
          <target state="translated">O(n)~ Lineal</target>
        </trans-unit>
        <trans-unit id="a5fa19f57aec98afc3fc69df842b447d2a094f4c" translate="yes" xml:space="preserve">
          <source>O(n), O(n&lt;sup&gt;2&lt;/sup&gt;) etc. are all polynomial time. Some problems cannot be solved in polynomial time. Certain things are used in the world because of this. &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;Public Key Cryptography&lt;/a&gt; is a prime example. It is computationally hard to find two prime factors of a very large number. If it wasn't, we couldn't use the public key systems we use.</source>
          <target state="translated">O (n), O (n &lt;sup&gt;2&lt;/sup&gt; ) etc. son todos tiempo polinomial. Algunos problemas no pueden resolverse en tiempo polin&amp;oacute;mico. Ciertas cosas se usan en el mundo debido a esto. &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;La criptograf&amp;iacute;a de clave p&amp;uacute;blica&lt;/a&gt; es un excelente ejemplo. Es computacionalmente dif&amp;iacute;cil encontrar dos factores primos de un n&amp;uacute;mero muy grande. Si no fuera as&amp;iacute;, no podr&amp;iacute;amos utilizar los sistemas de clave p&amp;uacute;blica que utilizamos.</target>
        </trans-unit>
        <trans-unit id="f995f059c281a355753f38679edd0e7f61f9dfcf" translate="yes" xml:space="preserve">
          <source>O(n): If I double the input size the runtime doubles</source>
          <target state="translated">O(n):Si doblo el tamaño de la entrada el tiempo de ejecución se duplica</target>
        </trans-unit>
        <trans-unit id="830c15d5357ce8008571a4bcc897c78270ce5607" translate="yes" xml:space="preserve">
          <source>O(n&lt;sup&gt;2&lt;/sup&gt;): If the input size doubles the runtime quadruples</source>
          <target state="translated">O (n &lt;sup&gt;2&lt;/sup&gt; ): si el tama&amp;ntilde;o de entrada se duplica, el tiempo de ejecuci&amp;oacute;n se cuadruplica</target>
        </trans-unit>
        <trans-unit id="8639ae6910d96d5623a09688e0818a131fb8c50f" translate="yes" xml:space="preserve">
          <source>O(n&lt;sup&gt;2&lt;/sup&gt;)O(n&lt;sup&gt;3&lt;/sup&gt;) = O(n&lt;sup&gt;5&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">O (n &lt;sup&gt;2&lt;/sup&gt; ) O (n &lt;sup&gt;3&lt;/sup&gt; ) = O (n &lt;sup&gt;5&lt;/sup&gt; ) cuando n &amp;rarr; + &amp;infin;</target>
        </trans-unit>
        <trans-unit id="ac18ee6983cc2eb537d0f2f25351e9df638a26bd" translate="yes" xml:space="preserve">
          <source>Obviously that's only using &quot;size&quot; as the input and &quot;time taken&quot; as the output &amp;mdash; the same idea applies if you want to talk about memory usage etc.</source>
          <target state="translated">Obviamente, eso solo usa &quot;tama&amp;ntilde;o&quot; como entrada y &quot;tiempo empleado&quot; como salida; la misma idea se aplica si desea hablar sobre el uso de la memoria, etc.</target>
        </trans-unit>
        <trans-unit id="047235fd8fb4d12aece908a6c0ecf01e2c06606a" translate="yes" xml:space="preserve">
          <source>Of course this does not mean that loops and functions are bad; on the contrary, they are the building blocks of modern programming languages, and we love them. However, we can see that the way we weave loops and functions and conditionals together with our data (control flow, etc.) mimics the time and space usage of our program! If time and space usage becomes an issue, that is when we resort to cleverness and find an easy algorithm or data structure we hadn't considered, to reduce the order of growth somehow. Nevertheless, these visualization techniques (though they don't always work) can give you a naive guess at a worst-case running time.</source>
          <target state="translated">Por supuesto esto no significa que los bucles y las funciones sean malos;al contrario,son los bloques de construcción de los lenguajes de programación modernos,y nos encantan.Sin embargo,podemos ver que la forma en que tejemos los bucles y las funciones y los condicionales junto con nuestros datos (flujo de control,etc.)¡imita el uso del tiempo y el espacio de nuestro programa! Si el uso del tiempo y el espacio se convierte en un problema,es cuando recurrimos a la inteligencia y encontramos un algoritmo fácil o una estructura de datos que no habíamos considerado,para reducir el orden de crecimiento de alguna manera.Sin embargo,estas técnicas de visualización (aunque no siempre funcionan)pueden dar una idea ingenua del peor de los casos.</target>
        </trans-unit>
        <trans-unit id="02eb439e917fc58abf025b96d214507c593cd917" translate="yes" xml:space="preserve">
          <source>Oh no, now I have more work.  Sheesh.  Who makes this kind of stuff?!</source>
          <target state="translated">Oh no,ahora tengo más trabajo.Caramba.¡¿Quién hace este tipo de cosas?!</target>
        </trans-unit>
        <trans-unit id="846bee0b9db59985faaa143bf6c6677865b72c7b" translate="yes" xml:space="preserve">
          <source>Ok, my 2cents.</source>
          <target state="translated">Ok,mis 2 centavos.</target>
        </trans-unit>
        <trans-unit id="4d41abb6d91ed8426b9c48d248c476619fafc156" translate="yes" xml:space="preserve">
          <source>Once I have found these two cards, I swap them, and go on to look for more cards to swap.  That is, I go back to step Two, and splay on the card you chose some more.</source>
          <target state="translated">Una vez que encuentro estas dos cartas,las intercambio,y sigo buscando más cartas para intercambiar.Es decir,vuelvo al paso dos,y juego con la carta que elegiste un poco más.</target>
        </trans-unit>
        <trans-unit id="bbe0abb1706b2ab494f9baaf3f32394aa9b1d99e" translate="yes" xml:space="preserve">
          <source>One can notice that we've assumed the worst case scenario here. While multiplying 6 digit numbers, if one of them has 4 digits and the other one has 6 digits, then we only have 24 multiplications. Still, we calculate the worst case scenario for that 'n', i.e when both are 6 digit numbers. Hence Big-O notation is about the Worst-case scenario of an algorithm.</source>
          <target state="translated">Uno puede notar que hemos asumido el peor escenario posible aquí.Al multiplicar números de 6 dígitos,si uno de ellos tiene 4 dígitos y el otro tiene 6 dígitos,entonces sólo tenemos 24 multiplicaciones.Aún así,calculamos el peor escenario para esa 'n',es decir,cuando ambos son números de 6 dígitos.Por lo tanto,la notación Big-O se refiere al peor escenario de un algoritmo.</target>
        </trans-unit>
        <trans-unit id="aa31e9cc8ee30f1096d7841ca16202599811c4d7" translate="yes" xml:space="preserve">
          <source>One important aspect of &quot;big O&quot; notation is that it &lt;em&gt;doesn't&lt;/em&gt; say which algorithm will be faster for a given size. Take a hashtable (string key, integer value)  vs an array of pairs (string, integer). Is it faster to find a key in the hashtable or an element in the array, based on a string? (i.e. for the array, &quot;find the first element where the string part matches the given key.&quot;) Hashtables are generally amortised (~= &quot;on average&quot;) O(1) &amp;mdash; once they're set up, it should take about the same time to find an entry in a 100 entry table as in a 1,000,000 entry table. Finding an element in an array (based on content rather than index) is linear, i.e. O(N) &amp;mdash; on average, you're going to have to look at half the entries.</source>
          <target state="translated">Un aspecto importante de la notaci&amp;oacute;n &quot;O grande&quot; es que &lt;em&gt;no&lt;/em&gt; dice qu&amp;eacute; algoritmo ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pido para un tama&amp;ntilde;o determinado. Tome una tabla hash (clave de cadena, valor entero) frente a una matriz de pares (cadena, entero). &amp;iquest;Es m&amp;aacute;s r&amp;aacute;pido encontrar una clave en la tabla hash o un elemento en la matriz, basado en una cadena? (es decir, para la matriz, &quot;encuentre el primer elemento donde la parte de la cadena coincida con la clave dada&quot;). Las tablas hash generalmente se amortizan (~ = &quot;en promedio&quot;) O (1): una vez que se configuran, deber&amp;iacute;a tomar aproximadamente al mismo tiempo para encontrar una entrada en una tabla de 100 entradas que en una tabla de 1,000,000 de entradas. Encontrar un elemento en una matriz (basado en contenido en lugar de &amp;iacute;ndice) es lineal, es decir, O (N): en promedio, tendr&amp;aacute; que mirar la mitad de las entradas.</target>
        </trans-unit>
        <trans-unit id="455ac552ede28e8384f4279d82396b29180d80b5" translate="yes" xml:space="preserve">
          <source>One plus two is three&amp;hellip; plus three is six... and four is... I don&amp;rsquo;t know.  I got lost.  It is too hard for me to do in my head.  I don&amp;rsquo;t much care for this kind of work.</source>
          <target state="translated">Uno m&amp;aacute;s dos son tres ... m&amp;aacute;s tres son seis ... y cuatro es ... No lo s&amp;eacute;. Me perd&amp;iacute;. Es muy dif&amp;iacute;cil para m&amp;iacute; hacerlo en mi cabeza. No me importa mucho este tipo de trabajo.</target>
        </trans-unit>
        <trans-unit id="bc82ac3fdfa2c36fc2c53eae610e61a05eb3407a" translate="yes" xml:space="preserve">
          <source>One: I choose one card in the part of the deck we work on now.  You can choose one for me if you like.  (The first time we do this, &amp;ldquo;the part of the deck we work on now&amp;rdquo; is the whole deck, of course.)</source>
          <target state="translated">Uno: elijo una carta en la parte de la baraja en la que trabajamos ahora. Puedes elegir uno para m&amp;iacute; si quieres. (La primera vez que hacemos esto, &quot;la parte del mazo en la que trabajamos ahora&quot; es todo el mazo, por supuesto).</target>
        </trans-unit>
        <trans-unit id="6f7dd336bd44297d43d1e2584ebc5605a1581c94" translate="yes" xml:space="preserve">
          <source>Only concerned with runtime grow relative to the input &lt;strong&gt;(n)&lt;/strong&gt;</source>
          <target state="translated">Solo preocupado por el tiempo de ejecuci&amp;oacute;n crece en relaci&amp;oacute;n con la entrada &lt;strong&gt;(n)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e64c05fb1f7a3fd3c0cf63d3e43c979084e566b1" translate="yes" xml:space="preserve">
          <source>Or maybe you do log(N) passes of the data, for O(N*log(N)) total time:</source>
          <target state="translated">O tal vez haces log(N)pases de datos,para O(N*log(N))tiempo total:</target>
        </trans-unit>
        <trans-unit id="03e6e7bc29b2694c5ad9d0d21e7d44ffe2e43e41" translate="yes" xml:space="preserve">
          <source>Our task went from an infeasible &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; to a manageable &lt;code&gt;O(N)&lt;/code&gt;, and all we had to do was pay a minor cost to make a hash table.</source>
          <target state="translated">Nuestra tarea pas&amp;oacute; de un &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; inviable a un &lt;code&gt;O(N)&lt;/code&gt; manejable, y todo lo que tuvimos que hacer fue pagar un costo menor para hacer una tabla hash.</target>
        </trans-unit>
        <trans-unit id="0732d399cd128b93b16b9a0583b8df0ddb1d224b" translate="yes" xml:space="preserve">
          <source>People will often use &lt;code&gt;= O(...)&lt;/code&gt;, which is perhaps the more correct 'comp-sci' notation, and entirely legitimate to use; &quot;f = O(...)&quot; is read &quot;f is order ... / f is xxx-bounded by ...&quot; and is thought of as &quot;f is some expression whose asymptotics are ...&quot;. I was taught to use the more rigorous &lt;code&gt;&amp;isin; O(...)&lt;/code&gt;. &lt;code&gt;&amp;isin;&lt;/code&gt; means &quot;is an element of&quot; (still read as before). In this particular case, &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; contains elements like {&lt;code&gt;2 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;3 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;1/2 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;2 N&amp;sup2; + log(N)&lt;/code&gt;, &lt;code&gt;- N&amp;sup2; + N^1.9&lt;/code&gt;, ...} and is infinitely large, but it's still a set.</source>
          <target state="translated">La gente a menudo usar&amp;aacute; &lt;code&gt;= O(...)&lt;/code&gt; , que es quiz&amp;aacute;s la notaci&amp;oacute;n 'comp-sci' m&amp;aacute;s correcta y totalmente leg&amp;iacute;tima de usar; &quot;f = O (...)&quot; se lee &quot;f es orden ... / f est&amp;aacute; delimitado por xxx por ...&quot; y se considera como &quot;f es alguna expresi&amp;oacute;n cuyos asint&amp;oacute;ticos son ...&quot;. Me ense&amp;ntilde;aron a usar el m&amp;aacute;s riguroso &lt;code&gt;&amp;isin; O(...)&lt;/code&gt; . &lt;code&gt;&amp;isin;&lt;/code&gt; significa &quot;es un elemento de&quot; (a&amp;uacute;n le&amp;iacute;do como antes). En este caso particular, &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; contiene elementos como { &lt;code&gt;2 N&amp;sup2;&lt;/code&gt; , &lt;code&gt;3 N&amp;sup2;&lt;/code&gt; , &lt;code&gt;1/2 N&amp;sup2;&lt;/code&gt; , &lt;code&gt;2 N&amp;sup2; + log(N)&lt;/code&gt; , &lt;code&gt;- N&amp;sup2; + N^1.9&lt;/code&gt; , ...} y es infinitamente grande, pero es Sigue siendo un conjunto.</target>
        </trans-unit>
        <trans-unit id="aff7f1ca724e63fb9ec4afc2e9f2dbdfa5bff1a0" translate="yes" xml:space="preserve">
          <source>Please note the order at line end, just for your better understanding.There's more than 7 notations if all possibilities considered.</source>
          <target state="translated">Por favor,anote el orden al final de la línea,sólo para su mejor comprensión.Hay más de 7 anotaciones si se consideran todas las posibilidades.</target>
        </trans-unit>
        <trans-unit id="ff6f34b84d9b2e644758179e12f471c8957fb41f" translate="yes" xml:space="preserve">
          <source>Polynomial Time</source>
          <target state="translated">Tiempo de polinomios</target>
        </trans-unit>
        <trans-unit id="c745366182e555ccc5603f9f335f3de2d95eae3a" translate="yes" xml:space="preserve">
          <source>Practically speaking, Big O analysis is &lt;em&gt;so useful and important&lt;/em&gt; because Big O puts the focus squarely on the algorithm's &lt;em&gt;own&lt;/em&gt; complexity and completely &lt;em&gt;ignores&lt;/em&gt; anything that is merely a proportionality constant&amp;mdash;like a JavaScript engine, the speed of a CPU, your Internet connection, and all those things which become quickly become as laughably outdated as a Model &lt;em&gt;T&lt;/em&gt;. Big O focuses on performance only in the way that matters equally as much to people living in the present or in the future.</source>
          <target state="translated">Hablando en t&amp;eacute;rminos pr&amp;aacute;cticos, el an&amp;aacute;lisis de Big O es &lt;em&gt;muy &amp;uacute;til e importante&lt;/em&gt; porque Big O se enfoca directamente en la &lt;em&gt;propia&lt;/em&gt; complejidad del algoritmo e &lt;em&gt;ignora por&lt;/em&gt; completo cualquier cosa que sea simplemente una constante de proporcionalidad, como un motor JavaScript, la velocidad de una CPU, su conexi&amp;oacute;n a Internet y Todas esas cosas que se vuelven r&amp;aacute;pidamente se vuelven tan rid&amp;iacute;culamente desactualizadas como un Modelo &lt;em&gt;T.&lt;/em&gt; Big O se enfoca en el rendimiento solo de la misma manera que importa tanto para las personas que viven en el presente como en el futuro.</target>
        </trans-unit>
        <trans-unit id="707ddefda8b9d501a1d63dad3fcb74d0cb28b51a" translate="yes" xml:space="preserve">
          <source>Preface</source>
          <target state="translated">Preface</target>
        </trans-unit>
        <trans-unit id="c96271fcfba3e64dd9236be70e3f3f5fc45c32c9" translate="yes" xml:space="preserve">
          <source>Programs will also run slower on a 500MHz computer vs 2GHz computer. We don't really consider this as part of the resource bounds, because we think of the scaling in terms of machine resources (e.g. per clock cycle), not per real second. However, there are similar things which can 'secretly' affect performance, such as whether you are running under emulation, or whether the compiler optimized code or not. These might make some basic operations take longer (even relative to each other), or even speed up or slow down some operations asymptotically (even relative to each other). The effect may be small or large between different implementation and/or environment. Do you switch languages or machines to eke out that little extra work? That depends on a hundred other reasons (necessity, skills, coworkers, programmer productivity, the monetary value of your time, familiarity, workarounds, why not assembly or GPU, etc...), which may be more important than performance.</source>
          <target state="translated">Los programas también se ejecutarán más lentamente en un ordenador de 500MHz frente a uno de 2GHz.En realidad no consideramos esto como parte de los límites de los recursos,porque pensamos en el escalado en términos de recursos de la máquina (por ejemplo,por ciclo de reloj),no por segundo real.Sin embargo,hay cosas similares que pueden afectar &quot;secretamente&quot; al rendimiento,como si se está ejecutando bajo emulación,o si el compilador optimizó el código o no.Esto puede hacer que algunas operaciones básicas lleven más tiempo (incluso en relación con las demás),o incluso que se aceleren o ralenticen algunas operaciones de forma asintótica (incluso en relación con las demás).El efecto puede ser pequeño o grande entre las diferentes implementaciones o entornos.¿Cambian de idioma o de máquina para realizar ese pequeño trabajo extra? Eso depende de un centenar de otras razones (necesidad,habilidades,compañeros de trabajo,productividad del programador,el valor monetario de su tiempo,la familiaridad,las soluciones alternativas,por qué no el ensamblado o la GPU,etc...),que pueden ser más importantes que el rendimiento.</target>
        </trans-unit>
        <trans-unit id="0d31501e03db9492d0d452e6624c95d2a7fc34fc" translate="yes" xml:space="preserve">
          <source>Put another way, it's all about the &lt;strong&gt;ratio&lt;/strong&gt; as you go to infinity. &lt;em&gt;If you divide the actual time it takes by the &lt;code&gt;O(...)&lt;/code&gt;, you will get a constant factor in the limit of large inputs.&lt;/em&gt; Intuitively this makes sense: functions &quot;scale like&quot; one another if you can multiply one to get the other. That is when we say...</source>
          <target state="translated">Dicho de otra manera, se trata de la &lt;strong&gt;relaci&amp;oacute;n a&lt;/strong&gt; medida que avanza hasta el infinito. &lt;em&gt;Si divide el tiempo real que tarda entre &lt;code&gt;O(...)&lt;/code&gt; , obtendr&amp;aacute; un factor constante en el l&amp;iacute;mite de entradas grandes.&lt;/em&gt; Intuitivamente, esto tiene sentido: las funciones se &quot;escalan&quot; entre s&amp;iacute; si se puede multiplicar una para obtener la otra. Entonces es cuando decimos ...</target>
        </trans-unit>
        <trans-unit id="b123240c4cc86a314f0b2ff2c7fcffe4a190bdd3" translate="yes" xml:space="preserve">
          <source>Putting everything in an airing cupboard: If we put everything in one big pile and just let general warmth do it, it will take a long time for the middle shirts to get dry. I wouldn't like to guess at the detail, but I suspect this is at least O(N^2) &amp;mdash; as you increase the wash load, the drying time increases faster.</source>
          <target state="translated">Poner todo en un armario ventilado: si ponemos todo en una gran pila y simplemente dejamos que el calor general lo haga, las camisas del medio tardar&amp;aacute;n mucho en secarse. No me gustar&amp;iacute;a adivinar los detalles, pero sospecho que esto es al menos O (N ^ 2): a medida que aumenta la carga de lavado, el tiempo de secado aumenta m&amp;aacute;s r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="44d6998253d7ce7630dea94f49784bcc34a98b86" translate="yes" xml:space="preserve">
          <source>Quick Sort breaks up big decks in small ones.  That is to say, it breaks up big tasks in small ones.</source>
          <target state="translated">Quick Sort rompe las grandes cubiertas en las pequeñas.Es decir,divide las grandes tareas en pequeñas.</target>
        </trans-unit>
        <trans-unit id="aafbf15c3d2cb24c90abf21327172d843932cd8c" translate="yes" xml:space="preserve">
          <source>Quick note, this is almost certainly confusing &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; (which is an upper bound) with Theta notation &quot;&amp;Theta;&quot; (which is a two-side bound). In my experience, this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</source>
          <target state="translated">Nota r&amp;aacute;pida, es casi seguro que confunde la &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;notaci&amp;oacute;n Big O&lt;/a&gt; (que es un l&amp;iacute;mite superior) con la notaci&amp;oacute;n Theta &quot;&amp;Theta;&quot; (que es un l&amp;iacute;mite de dos lados). En mi experiencia, esto es realmente t&amp;iacute;pico de las discusiones en entornos no acad&amp;eacute;micos. Disculpas por cualquier confusi&amp;oacute;n causada.</target>
        </trans-unit>
        <trans-unit id="78240c3b95a799ddc676899ee3f052157355ad48" translate="yes" xml:space="preserve">
          <source>Resource : Could be total-CPU time, could be maximum RAM space. By default refers to CPU time.</source>
          <target state="translated">Recurso:Podría ser el tiempo total de la CPU,podría ser el espacio máximo de la RAM.Por defecto se refiere al tiempo de CPU.</target>
        </trans-unit>
        <trans-unit id="ac86f485121aebe3e0cdccd29ad1f58c3d7af9cc" translate="yes" xml:space="preserve">
          <source>Say the problem is &quot;Find the Combination&quot;,</source>
          <target state="translated">Digamos que el problema es &quot;Encontrar la combinación&quot;,</target>
        </trans-unit>
        <trans-unit id="a93e27c51787651f155cd14f8a574fade12b6fb2" translate="yes" xml:space="preserve">
          <source>Say the problem is &quot;Find the sum&quot;,</source>
          <target state="translated">Digamos que el problema es &quot;Encontrar la suma&quot;,</target>
        </trans-unit>
        <trans-unit id="a090d13ccede8e7fd94f3cd08042cf4d8572f583" translate="yes" xml:space="preserve">
          <source>Say you order Harry Potter: Complete 8-Film Collection [Blu-ray] from Amazon and download the same film collection online at the same time. You want to test which method is faster. The delivery takes almost a day to arrive and the download completed about 30 minutes earlier. Great! So it&amp;rsquo;s a tight race.</source>
          <target state="translated">Digamos que usted ordena Harry Potter: Complete 8-Film Collection [Blu-ray] de Amazon y descargue la misma colecci&amp;oacute;n de pel&amp;iacute;culas en l&amp;iacute;nea al mismo tiempo. Desea probar qu&amp;eacute; m&amp;eacute;todo es m&amp;aacute;s r&amp;aacute;pido. La entrega tarda casi un d&amp;iacute;a en llegar y la descarga se complet&amp;oacute; unos 30 minutos antes. &amp;iexcl;Excelente! Entonces es una carrera apretada.</target>
        </trans-unit>
        <trans-unit id="7c15a59b277cd7091e5fcf18a82064b3a5dd08e6" translate="yes" xml:space="preserve">
          <source>See more at: &lt;a href=&quot;http://proprogramming.org/2015/01/how-to-calculate-time-complexity-of.html#sthash.URrGFhqm.dpuf&quot;&gt;Here&lt;/a&gt;</source>
          <target state="translated">Ver m&amp;aacute;s en: &lt;a href=&quot;http://proprogramming.org/2015/01/how-to-calculate-time-complexity-of.html#sthash.URrGFhqm.dpuf&quot;&gt;Aqu&amp;iacute;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1401abdd96246a6a7cc788610b57a7b896aa0b20" translate="yes" xml:space="preserve">
          <source>See the pattern?  The &lt;strong&gt;complexity&lt;/strong&gt; (being the number of operations) is directly proportional to the number of digits &lt;em&gt;n&lt;/em&gt; in the larger number.  We call this &lt;strong&gt;O(n)&lt;/strong&gt; or &lt;strong&gt;linear complexity&lt;/strong&gt;.</source>
          <target state="translated">&amp;iquest;Ves el patr&amp;oacute;n? La &lt;strong&gt;complejidad&lt;/strong&gt; (que es el n&amp;uacute;mero de operaciones) es directamente proporcional al n&amp;uacute;mero de d&amp;iacute;gitos &lt;em&gt;n&lt;/em&gt; en el n&amp;uacute;mero mayor. Llamamos a esto &lt;strong&gt;O (n)&lt;/strong&gt; o &lt;strong&gt;complejidad lineal&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7bb8c396c1b1d4188f90d674eebb67f47ab45d2b" translate="yes" xml:space="preserve">
          <source>Since Big-O doesn't care too much about constant factor (aka 3), the Big-O of your algorithm is &lt;code&gt;O(N^2 + log(X))&lt;/code&gt;. It basically translates 'the amount of operations your algorithm needs for the worst case scales with this'.</source>
          <target state="translated">Dado que Big-O no se preocupa demasiado por el factor constante (tambi&amp;eacute;n conocido como 3), el Big-O de su algoritmo es &lt;code&gt;O(N^2 + log(X))&lt;/code&gt; . B&amp;aacute;sicamente traduce 'la cantidad de operaciones que su algoritmo necesita para las peores escalas de casos con esto'.</target>
        </trans-unit>
        <trans-unit id="185fbeb7236225913f02d9ced51afffe91dadcbe" translate="yes" xml:space="preserve">
          <source>So here is the big news: the big O can help me not to do work!  I can play more of the time, if I know big O.  Less work, more play!  That is what big O helps me do.</source>
          <target state="translated">Así que aquí está la gran noticia:¡la gran O puede ayudarme a no hacer el trabajo! Puedo jugar más tiempo,si conozco al gran O.¡Menos trabajo,más juego! Eso es lo que el gran O me ayuda a hacer.</target>
        </trans-unit>
        <trans-unit id="f282cf5ef96e90a6a7f9b1e3944e8a0596d69aa5" translate="yes" xml:space="preserve">
          <source>So if you want to find a name in a phone book of a million names you can actually find any name by doing this at most 20 times.  In comparing search algorithms we decide that this comparison is our 'n'.</source>
          <target state="translated">Así que si quieres encontrar un nombre en una guía telefónica de un millón de nombres,puedes encontrar cualquier nombre haciendo esto como mucho 20 veces.Al comparar los algoritmos de búsqueda decidimos que esta comparación es nuestra 'n'.</target>
        </trans-unit>
        <trans-unit id="54d9d5007b7529ef62839a976a2c108028d8927a" translate="yes" xml:space="preserve">
          <source>So let's not do the work.  Let's you and me just think how hard it is.  How much work would I have to do, to add six numbers?</source>
          <target state="translated">Así que no hagamos el trabajo.Pensemos tú y yo en lo difícil que es.¿Cuánto trabajo tendría que hacer para sumar seis números?</target>
        </trans-unit>
        <trans-unit id="0f7963f5bf0d662a36fd7990d2218173d00f1e7f" translate="yes" xml:space="preserve">
          <source>So the Big-O of the Traveling Salesman problem is &lt;strong&gt;O(n!)&lt;/strong&gt; or &lt;strong&gt;factorial or combinatorial complexity&lt;/strong&gt;.</source>
          <target state="translated">Entonces, el gran problema del vendedor ambulante es &lt;strong&gt;O (n!)&lt;/strong&gt; O &lt;strong&gt;complejidad factorial o combinatoria&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="31cbba1dd119c95cd531f79932736280f8bc1df4" translate="yes" xml:space="preserve">
          <source>So then you might understand what &quot;n&lt;sup&gt;2&lt;/sup&gt;&quot; means, but to be even more specific, play with the thought you have a simple, the simpliest of the sorting algorithms; bubblesort. This algorithm needs to look through the whole list, for each item.</source>
          <target state="translated">Entonces, quiz&amp;aacute;s entiendas lo que significa &quot;n &lt;sup&gt;2&lt;/sup&gt; &quot;, pero para ser a&amp;uacute;n m&amp;aacute;s espec&amp;iacute;fico, juega con el pensamiento de que tienes un algoritmo de clasificaci&amp;oacute;n simple y simple; ordenamiento de burbuja. Este algoritmo necesita revisar toda la lista, para cada elemento.</target>
        </trans-unit>
        <trans-unit id="f8d83ca9666fef6b181abee5dce4073e31010f19" translate="yes" xml:space="preserve">
          <source>So to find a name given the phone number (reverse lookup):</source>
          <target state="translated">Así que para encontrar un nombre dado el número de teléfono (búsqueda inversa):</target>
        </trans-unit>
        <trans-unit id="d9f1ae7f841915d3f4dd37e4ec3ed8f5c6a2d975" translate="yes" xml:space="preserve">
          <source>So to talk of big O, I will use words that have just one beat in them.  One sound per word.  Small words are quick.  You know these words, and so do I.  We will use words with one sound.  They are small.  I am sure you will know all of the words we will use!</source>
          <target state="translated">Así que para hablar del gran O,usaré palabras que tengan un solo ritmo.Un sonido por palabra.Las palabras pequeñas son rápidas.Tú conoces estas palabras,y yo también.Usaremos palabras con un solo sonido.Son pequeñas.¡Estoy seguro de que conocerás todas las palabras que usaremos!</target>
        </trans-unit>
        <trans-unit id="1a6bae9cafba4af7ae15b7b23952da6ff1ac18ed" translate="yes" xml:space="preserve">
          <source>Some asymptotically superior algorithms (e.g. a non-comparison &lt;code&gt;O(N log(log(N)))&lt;/code&gt; sort) can have so large a constant factor (e.g. &lt;code&gt;100000*N log(log(N))&lt;/code&gt;), or overhead that is relatively large like &lt;code&gt;O(N log(log(N)))&lt;/code&gt; with a hidden &lt;code&gt;+ 100*N&lt;/code&gt;, that they are rarely worth using even on &quot;big data&quot;.</source>
          <target state="translated">Algunos algoritmos asint&amp;oacute;ticamente superiores (p. Ej., Un tipo de &lt;code&gt;O(N log(log(N)))&lt;/code&gt; no comparativo) pueden tener un factor constante tan grande (p. Ej. &lt;code&gt;100000*N log(log(N))&lt;/code&gt; ), o una sobrecarga que es relativamente grande como &lt;code&gt;O(N log(log(N)))&lt;/code&gt; con un oculto &lt;code&gt;+ 100*N&lt;/code&gt; , que rara vez vale la pena usar incluso en &quot;big data&quot;.</target>
        </trans-unit>
        <trans-unit id="6c3a47a93192e21e7b8da9213efad49591e03019" translate="yes" xml:space="preserve">
          <source>Something to think about.</source>
          <target state="translated">Algo en lo que pensar.</target>
        </trans-unit>
        <trans-unit id="4039fdaf71cb4809949b869888d7b88d6c807b40" translate="yes" xml:space="preserve">
          <source>Sounds simple?  Think again.</source>
          <target state="translated">¿Suena simple? Piénsalo de nuevo.</target>
        </trans-unit>
        <trans-unit id="3b9b41baa4e75cb4e6d6c6fd70132096551ccfd4" translate="yes" xml:space="preserve">
          <source>Subtraction is similar (except you may need to borrow instead of carry).</source>
          <target state="translated">La sustracción es similar (excepto que puede ser necesario pedir prestado en lugar de llevar).</target>
        </trans-unit>
        <trans-unit id="92cba8f42714e9e6f65905758a187f5dc1f81125" translate="yes" xml:space="preserve">
          <source>Such a beautifully simple and short question seems at least to deserve an equally short answer, like a student might receive during tutoring.</source>
          <target state="translated">Una pregunta tan maravillosamente simple y corta parece merecer al menos una respuesta igualmente corta,como la que un estudiante podría recibir durante la tutoría.</target>
        </trans-unit>
        <trans-unit id="3c2db9ddb042cb95f6f3da33f58156282aae57f5" translate="yes" xml:space="preserve">
          <source>Suppose</source>
          <target state="translated">Suppose</target>
        </trans-unit>
        <trans-unit id="6497864fec97aa054dc0495fd9cf472b076841fc" translate="yes" xml:space="preserve">
          <source>Suppose you get notation &lt;code&gt;O(N^2)&lt;/code&gt;, not only you are clear the method takes N*N steps to accomplish a task, also you see that it's not good as &lt;code&gt;O(NlogN)&lt;/code&gt; from its ranking.</source>
          <target state="translated">Suponga que obtiene la notaci&amp;oacute;n &lt;code&gt;O(N^2)&lt;/code&gt; , no solo est&amp;aacute; claro que el m&amp;eacute;todo toma N * N pasos para realizar una tarea, tambi&amp;eacute;n ve que no es bueno como &lt;code&gt;O(NlogN)&lt;/code&gt; en su clasificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b05781eb417d58d8870e0c54b7d3d4450a3c5cf7" translate="yes" xml:space="preserve">
          <source>T(n)= The actual function that expresses the running time of the algorithm as a function of n</source>
          <target state="translated">T(n)=La función real que expresa el tiempo de funcionamiento del algoritmo en función de n</target>
        </trans-unit>
        <trans-unit id="223cc76142198af8e0fb0a088ef6eb8d1fdff9c7" translate="yes" xml:space="preserve">
          <source>Take this to 4 towns and you have (iirc) 12 possibilities.</source>
          <target state="translated">Lleva esto a 4 pueblos y tienes (iirc)12 posibilidades.</target>
        </trans-unit>
        <trans-unit id="6717a00806c940ae11e172679a7461df17fb3524" translate="yes" xml:space="preserve">
          <source>That is staggeringly good isn't it?</source>
          <target state="translated">Eso es asombrosamente bueno,¿no?</target>
        </trans-unit>
        <trans-unit id="2b3ca8fd4b8fd6b2746880e61409e1fcd178be5c" translate="yes" xml:space="preserve">
          <source>That's the gist of it. They reduce the maths down so it might not be exactly n&lt;sup&gt;2&lt;/sup&gt; or whatever they say it is, but that'll be the dominating factor in the scaling.</source>
          <target state="translated">Esa es la esencia de esto. Reducen las matem&amp;aacute;ticas hacia abajo, por lo que puede que no sea exactamente n &lt;sup&gt;2&lt;/sup&gt; o lo que sea que digan, pero ese ser&amp;aacute; el factor dominante en la escala.</target>
        </trans-unit>
        <trans-unit id="a335b2fdf194a4b123c6adefad53cd69da1191ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&lt;/code&gt; notation might be the more common one and is even used in papers by world-renowned computer scientists. Additionally, it is often the case that in a casual setting, people will say &lt;code&gt;O(...)&lt;/code&gt; when they mean &lt;code&gt;Ɵ(...)&lt;/code&gt;; this is technically true since the set of things &lt;code&gt;Ɵ(exactlyThis)&lt;/code&gt; is a subset of &lt;code&gt;O(noGreaterThanThis)&lt;/code&gt;... and it's easier to type. ;-)</source>
          <target state="translated">La notaci&amp;oacute;n &lt;code&gt;=&lt;/code&gt; podr&amp;iacute;a ser la m&amp;aacute;s com&amp;uacute;n e incluso es utilizada en documentos por cient&amp;iacute;ficos inform&amp;aacute;ticos de renombre mundial. Adem&amp;aacute;s, a menudo ocurre que en un entorno informal, las personas dir&amp;aacute;n &lt;code&gt;O(...)&lt;/code&gt; cuando &lt;code&gt;Ɵ(...)&lt;/code&gt; decir they (...) ; Esto es t&amp;eacute;cnicamente cierto ya que el conjunto de cosas &lt;code&gt;Ɵ(exactlyThis)&lt;/code&gt; es un subconjunto de &lt;code&gt;O(noGreaterThanThis)&lt;/code&gt; ... y es m&amp;aacute;s f&amp;aacute;cil de escribir. ;-)</target>
        </trans-unit>
        <trans-unit id="aee94d96800326a2e37c8dd00dc11f09cbb047c7" translate="yes" xml:space="preserve">
          <source>The O in &quot;Big O&quot; refers to as &quot;Order&quot;(or precisely &quot;order of&quot;)</source>
          <target state="translated">La O en &quot;Big O&quot; se refiere a &quot;Orden&quot; (o precisamente &quot;orden de&quot;)</target>
        </trans-unit>
        <trans-unit id="bc4389e9f64069d428331282297c6e278a98864d" translate="yes" xml:space="preserve">
          <source>The Telephone Book</source>
          <target state="translated">La guía telefónica</target>
        </trans-unit>
        <trans-unit id="8cb03116d21f7000400f4bb7814a757a5f5a7de1" translate="yes" xml:space="preserve">
          <source>The Traveling Salesman</source>
          <target state="translated">El vendedor viajero</target>
        </trans-unit>
        <trans-unit id="72a9a665cf2e8f84b6ab25450c58c79f3d3908aa" translate="yes" xml:space="preserve">
          <source>The above issues, like the effect of the choice of which programming language is used, are almost never considered as part of the constant factor (nor should they be); yet one should be aware of them because &lt;em&gt;sometimes&lt;/em&gt; (though rarely) they may affect things. For example in cpython, the native priority queue implementation is asymptotically non-optimal (&lt;code&gt;O(log(N))&lt;/code&gt; rather than &lt;code&gt;O(1)&lt;/code&gt; for your choice of insertion or find-min); do you use another implementation? Probably not, since the C implementation is probably faster, and there are probably other similar issues elsewhere. There are tradeoffs; sometimes they matter and sometimes they don't.</source>
          <target state="translated">Los problemas anteriores, como el efecto de la elecci&amp;oacute;n de qu&amp;eacute; lenguaje de programaci&amp;oacute;n se utiliza, casi nunca se consideran parte del factor constante (ni deber&amp;iacute;an serlo); Sin embargo, uno debe ser consciente de ellos porque a &lt;em&gt;veces&lt;/em&gt; (aunque rara vez) pueden afectar las cosas. Por ejemplo, en cpython, la implementaci&amp;oacute;n de la cola de prioridad nativa es asint&amp;oacute;ticamente no &amp;oacute;ptima ( &lt;code&gt;O(log(N))&lt;/code&gt; lugar de &lt;code&gt;O(1)&lt;/code&gt; para su elecci&amp;oacute;n de inserci&amp;oacute;n o find-min); &amp;iquest;Utilizas otra implementaci&amp;oacute;n? Probablemente no, ya que la implementaci&amp;oacute;n de C es probablemente m&amp;aacute;s r&amp;aacute;pida, y probablemente haya otros problemas similares en otros lugares. Hay compensaciones; a veces importan y a veces no.</target>
        </trans-unit>
        <trans-unit id="a92aef1bcf2b613748cc674288c56712f50682e2" translate="yes" xml:space="preserve">
          <source>The above statement is a good start but not completely true.</source>
          <target state="translated">La declaración anterior es un buen comienzo pero no es completamente cierta.</target>
        </trans-unit>
        <trans-unit id="af10522e397a98644d31608e45e48cac65ff2486" translate="yes" xml:space="preserve">
          <source>The analogy for amortized analysis:</source>
          <target state="translated">La analogía para el análisis amortizado:</target>
        </trans-unit>
        <trans-unit id="fccd0576a93e2738b676fa9e76398601f6ab71b0" translate="yes" xml:space="preserve">
          <source>The astute may have realized that we could express the number of operations as: n&lt;sup&gt;2&lt;/sup&gt; + 2n.  But as you saw from our example with two numbers of a million digits apiece, the second term (2n) becomes insignificant (accounting for 0.0002% of the total operations by that stage).</source>
          <target state="translated">El astuto puede haberse dado cuenta de que podr&amp;iacute;amos expresar el n&amp;uacute;mero de operaciones como: n &lt;sup&gt;2&lt;/sup&gt; + 2n. Pero como viste en nuestro ejemplo con dos n&amp;uacute;meros de un mill&amp;oacute;n de d&amp;iacute;gitos cada uno, el segundo t&amp;eacute;rmino (2n) se vuelve insignificante (representa el 0.0002% del total de operaciones en esa etapa).</target>
        </trans-unit>
        <trans-unit id="11fa8c026f804b110c22f62945ac720ce5e2b7ce" translate="yes" xml:space="preserve">
          <source>The bad:</source>
          <target state="translated">El malo:</target>
        </trans-unit>
        <trans-unit id="8b80f48d4022e94ff91f1dba565c167cfe545120" translate="yes" xml:space="preserve">
          <source>The basics: Whenever we interact with every element in a collection of size A (such as an array, a set, all keys of a map, etc.), or perform A iterations of a loop, that is a multiplicative factor of size A. Why do I say &quot;a multiplicative factor&quot;?--because loops and functions (almost by definition) have multiplicative running time: the number of iterations, times work done in the loop (or for functions: the number of times you call the function, times work done in the function). (This holds if we don't do anything fancy, like skip loops or exit the loop early, or change control flow in the function based on arguments, which is very common.) Here are some examples of visualization techniques, with accompanying pseudocode.</source>
          <target state="translated">Lo básico:Cada vez que interactuamos con cada elemento de una colección de tamaño A (como una matriz,un conjunto,todas las teclas de un mapa,etc.),o realizamos iteraciones A de un bucle,eso es un factor multiplicativo de tamaño A.¿Por qué digo &quot;un factor multiplicativo&quot;? Porque los bucles y las funciones (casi por definición)tienen un tiempo de ejecución multiplicativo:el número de iteraciones,las veces que se trabaja en el bucle (o para las funciones:el número de veces que se llama la función,las veces que se trabaja en la función).(Esto se mantiene si no hacemos nada extravagante,como saltarse los bucles o salir del bucle antes de tiempo,o cambiar el flujo de control en la función en base a argumentos,lo cual es muy común).Aquí hay algunos ejemplos de técnicas de visualización,con el pseudocódigo que las acompaña.</target>
        </trans-unit>
        <trans-unit id="1ed7c47cc1915e8456623ae236c31623cd7a6dd2" translate="yes" xml:space="preserve">
          <source>The best example of Big-O I can think of is doing arithmetic.  Take two numbers (123456 and 789012).  The basic arithmetic operations we learnt in school were:</source>
          <target state="translated">El mejor ejemplo de Big-O que se me ocurre es hacer aritmética.Toma dos números (123456 y 789012).Las operaciones aritméticas básicas que aprendimos en la escuela fueron:</target>
        </trans-unit>
        <trans-unit id="6ae878297661e38f79a2d80036a322346800b990" translate="yes" xml:space="preserve">
          <source>The cost of solving the problem is proportional to the size of the problem.  If your problem doubles in size, then the cost of the solution doubles.  Since most problems have to be scanned into the computer in some way, as data entry, disk reads, or network traffic, this is generally an affordable scaling factor.</source>
          <target state="translated">El costo de resolver el problema es proporcional al tamaño del problema.Si el problema duplica su tamaño,entonces el costo de la solución se duplica.Dado que la mayoría de los problemas tienen que ser escaneados en la computadora de alguna manera,como la entrada de datos,la lectura del disco o el tráfico de la red,este es generalmente un factor de escala asequible.</target>
        </trans-unit>
        <trans-unit id="edbb1eb4311e72da0d8581264edd414e194f9ea0" translate="yes" xml:space="preserve">
          <source>The equation is read as 
As n approaches infinity, T of n, is less than or equal to c times f of n.</source>
          <target state="translated">La ecuación se lee como Como n se acerca al infinito,T de n,es menor o igual a c veces f de n.</target>
        </trans-unit>
        <trans-unit id="7696e2ee0fe03e7287025d1b9b1e590710edef6e" translate="yes" xml:space="preserve">
          <source>The first sort was O(n squared).  But Quick Sort is O(n log n).  You know that n log n is less than n squared, for big n, right?  Well, that is how we know that Quick Sort is fast!</source>
          <target state="translated">El primer tipo fue O(n)al cuadrado.Pero la clasificación rápida es O(n log n).Sabes que n logaritmo n es menos que n al cuadrado,para el gran n,¿verdad? Bueno,así es como sabemos que Quick Sort es rápido!</target>
        </trans-unit>
        <trans-unit id="ef63c6ddf6e7a7898b093aa5fa501850b023edae" translate="yes" xml:space="preserve">
          <source>The flow here would be:</source>
          <target state="translated">El flujo aquí sería:</target>
        </trans-unit>
        <trans-unit id="d7c2775507fbff85fd208fcd7a9eefd861c88ccd" translate="yes" xml:space="preserve">
          <source>The good:</source>
          <target state="translated">El bien:</target>
        </trans-unit>
        <trans-unit id="40776bd664da80434dcafa973f539de3f9f745d5" translate="yes" xml:space="preserve">
          <source>The input size is usually the space in bits needed to represent the input.</source>
          <target state="translated">El tamaño de la entrada suele ser el espacio en bits necesario para representar la entrada.</target>
        </trans-unit>
        <trans-unit id="d1b781877a2eef3021049a9a0ec22cac469bc50c" translate="yes" xml:space="preserve">
          <source>The moral of the story: a data structure lets us speed up operations. Even more, advanced data structures can let you combine, delay, or even ignore operations in incredibly clever ways. Different problems would have different analogies, but they'd all involve organizing the data in a way that exploits some structure we care about, or which we've artificially imposed on it for bookkeeping. We do work ahead of time (basically planning and organizing), and now repeated tasks are much much easier!</source>
          <target state="translated">La moraleja de la historia:una estructura de datos nos permite acelerar las operaciones.Aún más,las estructuras de datos avanzadas pueden permitir combinar,retrasar o incluso ignorar las operaciones de forma increíblemente inteligente.Diferentes problemas tendrían diferentes analogías,pero todos implicarían organizar los datos de una manera que explote alguna estructura que nos importe,o que le hayamos impuesto artificialmente para la contabilidad.Trabajamos con antelación (básicamente planificando y organizando),y ahora las tareas repetidas son mucho más fáciles!</target>
        </trans-unit>
        <trans-unit id="431150559f3afdb40719059de8cafc2364a6f27a" translate="yes" xml:space="preserve">
          <source>The new work is: add all things from one to n.</source>
          <target state="translated">El nuevo trabajo es:sumar todas las cosas de uno a n.</target>
        </trans-unit>
        <trans-unit id="9734a1f2bb99a793e146aed547eba3d5bde616de" translate="yes" xml:space="preserve">
          <source>The next best example I can think of is the telephone book, normally called the White Pages or similar but it varies from country to country.  But I'm talking about the one that lists people by surname and then initials or first name, possibly address and then telephone numbers.</source>
          <target state="translated">El siguiente mejor ejemplo que se me ocurre es la guía telefónica,normalmente llamada las Páginas Blancas o similar,pero varía de un país a otro.Pero me refiero a la que enumera a las personas por apellido y luego las iniciales o el nombre,posiblemente la dirección y luego los números de teléfono.</target>
        </trans-unit>
        <trans-unit id="30a4b2c863fa4772ef38b8845a347878d2aa00fa" translate="yes" xml:space="preserve">
          <source>The number of computations is only increased by a log of the input value.  So in this case, assuming each computation takes 1 second, the log of the input &lt;code&gt;n&lt;/code&gt; is the time required, hence &lt;code&gt;log n&lt;/code&gt;.</source>
          <target state="translated">El n&amp;uacute;mero de c&amp;aacute;lculos solo se incrementa mediante un registro del valor de entrada. Entonces, en este caso, suponiendo que cada c&amp;aacute;lculo tome 1 segundo, el registro de la entrada &lt;code&gt;n&lt;/code&gt; es el tiempo requerido, por lo tanto, &lt;code&gt;log n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3aad895641cfd48567e63f48472fae12fcf69c0b" translate="yes" xml:space="preserve">
          <source>The number of items is still increasing by a factor of 10, but the scaling factor of O(1) is always 1.</source>
          <target state="translated">El número de elementos sigue aumentando en un factor de 10,pero el factor de escala de O(1)es siempre 1.</target>
        </trans-unit>
        <trans-unit id="4e86a40dc1403a10780f816da6e77341ee5ea1e5" translate="yes" xml:space="preserve">
          <source>The only thing that these &quot;Big-Oh&quot; expressions try to do is to describe how much the software slows down as we increase the amount of data that the software has to process. If we double the amount of data that needs to be processed, does the software need twice as long to finish it's work? Ten times as long? In practice, there are a very limited number of big-Oh expressions that you will encounter and need to worry about:</source>
          <target state="translated">La única cosa que estas expresiones &quot;Big-Oh&quot; intentan hacer es describir cuánto se ralentiza el software a medida que aumenta la cantidad de datos que el software tiene que procesar.Si duplicamos la cantidad de datos que tiene que procesar,¿necesita el software el doble de tiempo para terminar su trabajo? ¿Diez veces más tiempo? En la práctica,hay un número muy limitado de expresiones de big-Oh que se encontrarán y de las que hay que preocuparse:</target>
        </trans-unit>
        <trans-unit id="0c4ac6494f1b66e30eda83ca592154e03a3a8fc2" translate="yes" xml:space="preserve">
          <source>The same can be said for the &lt;strong&gt;very act of writing&lt;/strong&gt;. All algorithms which print out N things will take N time because the output is at least that long (e.g. printing out all permutations (ways to rearrange) a set of N playing cards is factorial: &lt;code&gt;O(N!)&lt;/code&gt;).</source>
          <target state="translated">Lo mismo puede decirse del &lt;strong&gt;acto mismo de escribir&lt;/strong&gt; . Todos los algoritmos que imprimen N cosas tomar&amp;aacute;n N tiempo porque la salida es al menos tan larga (por ejemplo, imprimir todas las permutaciones (formas de reorganizar) un conjunto de N cartas es factorial: &lt;code&gt;O(N!)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf763b5c77d1eaec2bb764fe4187dc0b86926fc4" translate="yes" xml:space="preserve">
          <source>The simplest definition I can give for Big-O notation is this:</source>
          <target state="translated">La definición más simple que puedo dar de la anotación de Big-O es esta:</target>
        </trans-unit>
        <trans-unit id="9316c2f2fa69e85df7f06354c94d1417cfb91787" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;O( &amp;lt;some expression X involving n&amp;gt; )&lt;/code&gt; means, in simple English:</source>
          <target state="translated">Entonces &lt;code&gt;O( &amp;lt;some expression X involving n&amp;gt; )&lt;/code&gt; significa, en ingl&amp;eacute;s simple:</target>
        </trans-unit>
        <trans-unit id="8d780e455cede763fea2fd15a77afe9241e0ac7a" translate="yes" xml:space="preserve">
          <source>Then as far as Big O is concerned, the approximation f(n) is considered good enough as long as the below condition is true.</source>
          <target state="translated">Entonces,en lo que respecta a Big O,la aproximación f(n)se considera lo suficientemente buena siempre y cuando la condición de abajo sea cierta.</target>
        </trans-unit>
        <trans-unit id="ee898084770160432d4052d1b6366394874b74dc" translate="yes" xml:space="preserve">
          <source>There are many choices of constant; often the &quot;best&quot; choice is known as the &quot;constant factor&quot; of the algorithm... but we often ignore it like we ignore non-largest terms (see Constant Factors section for why they don't usually matter). You can also think of the above equation as a bound, saying &quot;&lt;em&gt;In the worst-case scenario, the time it takes will never be worse than roughly &lt;code&gt;N*log(N)&lt;/code&gt;, within a factor of 2.5 (a constant factor we don't care much about)&lt;/em&gt;&quot;.</source>
          <target state="translated">Hay muchas opciones de constante; a menudo la &quot;mejor&quot; opci&amp;oacute;n se conoce como el &quot;factor constante&quot; del algoritmo ... pero a menudo lo ignoramos como si ignoramos los t&amp;eacute;rminos que no son m&amp;aacute;s grandes (consulte la secci&amp;oacute;n Factores constantes para saber por qu&amp;eacute; no suelen importar). Tambi&amp;eacute;n puede pensar en la ecuaci&amp;oacute;n anterior como un l&amp;iacute;mite, diciendo &quot; &lt;em&gt;En el peor de los casos, el tiempo que lleva nunca ser&amp;aacute; peor que aproximadamente &lt;code&gt;N*log(N)&lt;/code&gt; , dentro de un factor de 2.5 (un factor constante que no&quot; no me importa mucho)&lt;/em&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="f3b28edc57f1a5b8e2ff6393649371701cff785f" translate="yes" xml:space="preserve">
          <source>There are some important and deliberately chosen words in that sentence:</source>
          <target state="translated">Hay algunas palabras importantes y deliberadamente elegidas en esa frase:</target>
        </trans-unit>
        <trans-unit id="735800377cfb894185f412511981fdfbdcaa94c0" translate="yes" xml:space="preserve">
          <source>There is a lot of information that Big O does not tell you about a given algorithm. It cuts to the bone and gives only information about the scaling nature of an algorithm, specifically how the resource use (think time or memory) of an algorithm scales in response to the &quot;input size&quot;.</source>
          <target state="translated">Hay mucha información que Big O no te dice sobre un algoritmo dado.Corta hasta el hueso y sólo da información sobre la naturaleza de la escalada de un algoritmo,específicamente cómo el uso de recursos (piensa en el tiempo o la memoria)de un algoritmo se escala en respuesta al &quot;tamaño de entrada&quot;.</target>
        </trans-unit>
        <trans-unit id="7dc156313731adb22242f60a31c42c25a7fac861" translate="yes" xml:space="preserve">
          <source>There is also the concept of &quot;amortized&quot; and/or &quot;average case&quot; (note that these are different).</source>
          <target state="translated">También existe el concepto de &quot;amortizado&quot; o de &quot;caso promedio&quot; (nótese que son diferentes).</target>
        </trans-unit>
        <trans-unit id="e29aa2b4c76e872003711e1f9ca7f22087d1cd30" translate="yes" xml:space="preserve">
          <source>These are the bread-and-butter orders of growth that programmers and applied computer scientists use as reference points. They see these all the time. (So while you could technically think &quot;Doubling the input makes an O(&amp;radic;N) algorithm 1.414 times slower,&quot; it's better to think of it as &quot;this is worse than logarithmic but better than linear&quot;.)</source>
          <target state="translated">Estos son los &amp;oacute;rdenes de crecimiento b&amp;aacute;sicos que los programadores y los inform&amp;aacute;ticos aplicados usan como puntos de referencia. Los ven todo el tiempo. (Por lo tanto, aunque t&amp;eacute;cnicamente podr&amp;iacute;a pensar &quot;Duplicar la entrada hace que un algoritmo O (&amp;radic;N) sea 1.414 veces m&amp;aacute;s lento&quot;, es mejor pensar que &quot;esto es peor que logar&amp;iacute;tmico pero mejor que lineal&quot;).</target>
        </trans-unit>
        <trans-unit id="337e7f754779241ba422c3ed16228e880e17fea7" translate="yes" xml:space="preserve">
          <source>They gave us a deck of ten cards.  They are all mixed up: seven, four, two, six&amp;hellip; not straight at all.  And now... our job is to sort them.</source>
          <target state="translated">Nos dieron una baraja de diez cartas. Todos est&amp;aacute;n mezclados: siete, cuatro, dos, seis ... nada rectos. Y ahora ... nuestro trabajo es ordenarlos.</target>
        </trans-unit>
        <trans-unit id="8a4cba2479bcff691f23bf7a823abac5f2bfc677" translate="yes" xml:space="preserve">
          <source>This algorithm search a list, item by item, looking for a key,</source>
          <target state="translated">Este algoritmo busca en una lista,elemento por elemento,buscando una clave,</target>
        </trans-unit>
        <trans-unit id="b5ccab1dbe3c98b30c65b7179a45c56dcba85b06" translate="yes" xml:space="preserve">
          <source>This complexity is the same as &lt;strong&gt;O(1)&lt;/strong&gt; except that it's just a little bit worse.  For all practical purposes, you can consider this as a very large constant scaling.  The difference in work between processing 1 thousand and 1 billion items is only a factor six.</source>
          <target state="translated">Esta complejidad es la misma que &lt;strong&gt;O (1),&lt;/strong&gt; excepto que es un poco peor. Para todos los fines pr&amp;aacute;cticos, puede considerar esto como una escala constante muy grande. La diferencia en el trabajo entre procesar mil y mil millones de art&amp;iacute;culos es solo un factor seis.</target>
        </trans-unit>
        <trans-unit id="a8f1f1c12dab816384a465eef99dc533c1871709" translate="yes" xml:space="preserve">
          <source>This complexity is very similar to &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt;.  For all practical purposes, the two are equivalent.  This level of complexity would generally still be considered scalable.  By tweaking assumptions some &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; algorithms can be transformed into &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; algorithms.  For example, bounding the size of keys reduces sorting from &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; to &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt;.</source>
          <target state="translated">Esta complejidad es muy similar a &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; . A todos los efectos pr&amp;aacute;cticos, los dos son equivalentes. Este nivel de complejidad generalmente todav&amp;iacute;a se considerar&amp;iacute;a escalable. Al ajustar las suposiciones, algunos algoritmos &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; pueden transformarse en algoritmos &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; . Por ejemplo, delimitar el tama&amp;ntilde;o de las claves reduce la clasificaci&amp;oacute;n de &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; a &lt;strong&gt;O ( &lt;em&gt;n&lt;/em&gt; )&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c5691b3f2dea4e40f3c7e1067faf693cc2b99d29" translate="yes" xml:space="preserve">
          <source>This is O n&lt;sup&gt;2&lt;/sup&gt; because, you need to look at all items in the list there are &quot;n&quot; items. For each item, you look at all items once more, for comparing, this is also &quot;n&quot;, so for every item, you look &quot;n&quot; times meaning n*n = n&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">Esto es O n &lt;sup&gt;2&lt;/sup&gt; porque, debe mirar todos los elementos de la lista, hay elementos &quot;n&quot;. Para cada elemento, mira todos los elementos una vez m&amp;aacute;s, para comparar, esto tambi&amp;eacute;n es &quot;n&quot;, por lo que para cada elemento, mira &quot;n&quot; veces, lo que significa n * n = n &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="653edd1e3ffbc6849cab3e84f2d2f1adb0553312" translate="yes" xml:space="preserve">
          <source>This is a function of a mathematical operation called a &lt;strong&gt;factorial&lt;/strong&gt;.  Basically:</source>
          <target state="translated">Esta es una funci&amp;oacute;n de una operaci&amp;oacute;n matem&amp;aacute;tica llamada &lt;strong&gt;factorial&lt;/strong&gt; . B&amp;aacute;sicamente:</target>
        </trans-unit>
        <trans-unit id="68bbac89d75f8c9b12a85ecf9405e267e936bef2" translate="yes" xml:space="preserve">
          <source>This is a very simplified explanation, but I hope it covers most important details.</source>
          <target state="translated">Esta es una explicación muy simplificada,pero espero que cubra los detalles más importantes.</target>
        </trans-unit>
        <trans-unit id="690e85c5f1f320cb604423824b8a84e4db475373" translate="yes" xml:space="preserve">
          <source>This is called a &lt;strong&gt;binary search&lt;/strong&gt; and is used every day in programming whether you realize it or not.</source>
          <target state="translated">Esto se llama &lt;strong&gt;b&amp;uacute;squeda binaria&lt;/strong&gt; y se usa todos los d&amp;iacute;as en la programaci&amp;oacute;n, ya sea que se d&amp;eacute; cuenta o no.</target>
        </trans-unit>
        <trans-unit id="903158538d58a924a96daad121dc96f748e16115" translate="yes" xml:space="preserve">
          <source>This is quite a famous problem in computer science and deserves a mention.  In this problem you have N towns. Each of those towns is linked to 1 or more other towns by a road of a certain distance. The Traveling Salesman problem is to find the shortest tour that visits every town.</source>
          <target state="translated">Este es un problema bastante famoso en la informática y merece una mención.En este problema tienes N ciudades.Cada una de esas ciudades está unida a una o más ciudades por una carretera de cierta distancia.El problema de los vendedores ambulantes es encontrar el recorrido más corto que visite cada ciudad.</target>
        </trans-unit>
        <trans-unit id="9d90c6f6b5d97d1a3566515111185bfdbbdad847" translate="yes" xml:space="preserve">
          <source>This is read as T of n is in big O of n.</source>
          <target state="translated">Esto se lee como T de n está en la gran O de n.</target>
        </trans-unit>
        <trans-unit id="581db2374f66d9fecedf4263af206b8b003578d9" translate="yes" xml:space="preserve">
          <source>This lets us make statements like...</source>
          <target state="translated">Esto nos permite hacer declaraciones como...</target>
        </trans-unit>
        <trans-unit id="4f23f5a057b81398db00b66517d931e311e15ad5" translate="yes" xml:space="preserve">
          <source>This motivates the use of &lt;strong&gt;data structures&lt;/strong&gt;: a data structure requires reading the data only once (usually &lt;code&gt;O(N)&lt;/code&gt; time), plus some arbitrary amount of preprocessing (e.g. &lt;code&gt;O(N)&lt;/code&gt; or &lt;code&gt;O(N log(N))&lt;/code&gt; or &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt;) which we try to keep small. Thereafter, modifying the data structure (insertions/deletions/ etc.) and making queries on the data take very little time, such as &lt;code&gt;O(1)&lt;/code&gt; or &lt;code&gt;O(log(N))&lt;/code&gt;. You then proceed to make a large number of queries! In general, the more work you're willing to do ahead of time, the less work you'll have to do later on.</source>
          <target state="translated">Esto motiva el uso de &lt;strong&gt;estructuras&lt;/strong&gt; de &lt;strong&gt;datos&lt;/strong&gt; : una estructura de datos requiere leer los datos solo una vez (generalmente tiempo &lt;code&gt;O(N)&lt;/code&gt; ), m&amp;aacute;s una cantidad arbitraria de preprocesamiento (por ejemplo, &lt;code&gt;O(N)&lt;/code&gt; u &lt;code&gt;O(N log(N))&lt;/code&gt; u &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; ) que intentamos mantener peque&amp;ntilde;o. Posteriormente, modificar la estructura de datos (inserciones / eliminaciones / etc.) y realizar consultas sobre los datos lleva muy poco tiempo, como &lt;code&gt;O(1)&lt;/code&gt; u &lt;code&gt;O(log(N))&lt;/code&gt; . &amp;iexcl;Luego procedes a hacer una gran cantidad de consultas! En general, cuanto m&amp;aacute;s trabajo est&amp;eacute; dispuesto a hacer con anticipaci&amp;oacute;n, menos trabajo tendr&amp;aacute; que hacer m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="4d08321928b5477592d3f3be8d0fbf595ccedfeb" translate="yes" xml:space="preserve">
          <source>This sort is quite quick.  How quick?  Big O tells us: this sort needs O(n log n) work to be done, in the mean case.</source>
          <target state="translated">Este tipo es bastante rápido.¿Cómo de rápido? Big O nos dice:este tipo necesita que se haga el trabajo de O(n log n),en el caso medio.</target>
        </trans-unit>
        <trans-unit id="efa77e0837d728c026f108a7c6a880857648e39a" translate="yes" xml:space="preserve">
          <source>This time the number of items increases by a factor of 10, and so does the time. n=10 and so O(n)'s scaling factor is 10.</source>
          <target state="translated">Esta vez el número de elementos aumenta en un factor de 10,y también el tiempo.n=10 y así el factor de escala de O(n)es 10.</target>
        </trans-unit>
        <trans-unit id="e6a399976506e2d7ce3f3c1d1884c9c4671f0528" translate="yes" xml:space="preserve">
          <source>This type of algorithm is described as O(log N). The iterative halving
  of data sets described in the binary search example produces a growth
  curve that peaks at the beginning and slowly flattens out as the size
  of the data sets increase e.g. an input data set containing 10 items
  takes one second to complete, a data set containing 100 items takes
  two seconds, and a data set containing 1000 items will take three
  seconds. Doubling the size of the input data set has little effect on
  its growth as after a single iteration of the algorithm the data set
  will be halved and therefore on a par with an input data set half the
  size. This makes algorithms like binary search extremely efficient
  when dealing with large data sets.</source>
          <target state="translated">Este tipo de algoritmo se describe como O(log N).La reducción iterativa a la mitad de los conjuntos de datos descritos en el ejemplo de búsqueda binaria produce una curva de crecimiento que alcanza su punto máximo al principio y se aplana lentamente a medida que aumenta el tamaño de los conjuntos de datos;por ejemplo,un conjunto de datos de entrada que contiene 10 elementos tarda un segundo en completarse,un conjunto de datos que contiene 100 elementos tarda dos segundos y un conjunto de datos que contiene 1000 elementos tardará tres segundos.Duplicar el tamaño del conjunto de datos de entrada tiene poco efecto en su crecimiento,ya que después de una sola iteración del algoritmo el conjunto de datos se reducirá a la mitad y,por lo tanto,a la par con un conjunto de datos de entrada de la mitad del tamaño.Esto hace que los algoritmos como la búsqueda binaria sean extremadamente eficientes cuando se trata de grandes conjuntos de datos.</target>
        </trans-unit>
        <trans-unit id="ff64700b92668ef5d8bf1eab2150e242d95be66f" translate="yes" xml:space="preserve">
          <source>Though, if you're &lt;a href=&quot;https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks&quot;&gt;reasonably worried&lt;/a&gt; about an attacker, there are many other algorithmic attack vectors to worry about besides amortization and average-case.)</source>
          <target state="translated">Sin embargo, si est&amp;aacute; &lt;a href=&quot;https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks&quot;&gt;razonablemente preocupado&lt;/a&gt; por un atacante, hay muchos otros vectores de ataque algor&amp;iacute;tmicos de los que preocuparse adem&amp;aacute;s de la amortizaci&amp;oacute;n y el caso promedio).</target>
        </trans-unit>
        <trans-unit id="7c6809222de67cf731ce03e2166eb7926bfb38c0" translate="yes" xml:space="preserve">
          <source>Three: I go from the end card up, and I look for a card that is more low than the splay card.</source>
          <target state="translated">Tres:Voy de la carta del final hacia arriba,y busco una carta que sea más baja que la carta de la jugada.</target>
        </trans-unit>
        <trans-unit id="b5dad2a734641d4c6735ae21c27019cfea0c15e8" translate="yes" xml:space="preserve">
          <source>Time(Best-Case) = 4</source>
          <target state="translated">Tiempo (en el mejor de los casos)=4</target>
        </trans-unit>
        <trans-unit id="2f997ae62ba9c69b3cf6edcf0d119e5ddad840f2" translate="yes" xml:space="preserve">
          <source>Time(Worst-Case) = 4n+1</source>
          <target state="translated">Tiempo (en el peor de los casos)=4n+1</target>
        </trans-unit>
        <trans-unit id="2b30e732d21d07f2640a46e069dde7480df7216e" translate="yes" xml:space="preserve">
          <source>Time: &amp;Omega;(4) = O(1) ~ Instant\Constant</source>
          <target state="translated">Tiempo: &amp;Omega; (4) = O (1) ~ Instant&amp;aacute;neo \ Constante</target>
        </trans-unit>
        <trans-unit id="8d4bf6a7efc118b94944a2fdcb4199b6b5436673" translate="yes" xml:space="preserve">
          <source>Time: O(4n+1) = O(n) | in Big-O, constants are neglected</source>
          <target state="translated">Tiempo:O(4n+1)=O(n)</target>
        </trans-unit>
        <trans-unit id="78b1d548645a6f4313e845c0d6995f63dbc656ee" translate="yes" xml:space="preserve">
          <source>To add from one to six, that is some work.  But do you see, to add from one to ten, that is more work?</source>
          <target state="translated">Para sumar del uno al seis,eso es un gran trabajo.Pero,¿ves?,añadir de uno a diez,eso es más trabajo.</target>
        </trans-unit>
        <trans-unit id="2ee6a9060e778ab6f2fbe6d42d7bf3bf75ff7755" translate="yes" xml:space="preserve">
          <source>To me, I think of big O like a big, slow, boss man.  He thinks on work, but he does not do it.  He might say, &quot;That work is quick.&quot;  Or, he might say, &quot;That work is so slow and hard!&quot;  But he does not do the work.  He just looks at the work, and then he tells us how much time it might take.</source>
          <target state="translated">Para mí,pienso en el gran O como un gran y lento jefe.Piensa en el trabajo,pero no lo hace.Podría decir:&quot;Ese trabajo es rápido&quot;.O podría decir,&quot;¡Ese trabajo es tan lento y duro!&quot; Pero no hace el trabajo.Sólo mira el trabajo,y luego nos dice cuánto tiempo puede tomar.</target>
        </trans-unit>
        <trans-unit id="5580a107c59a84aea6247983205780ae9a93ffac" translate="yes" xml:space="preserve">
          <source>To say that binary search has a running time of O(logn) is to say that there exists some constant c which you can multiply log(n) by that will always be larger than the running time of binary search.  In this case you will always have some constant factor of log(n) comparisons.</source>
          <target state="translated">Decir que la búsqueda binaria tiene un tiempo de ejecución de O(logn)es decir que existe alguna constante c que se puede multiplicar log(n)por que siempre será mayor que el tiempo de ejecución de la búsqueda binaria.En este caso siempre tendrás algún factor constante de comparaciones log(n).</target>
        </trans-unit>
        <trans-unit id="b4476ee9defb91e4168e19a3dcd129163cca85a4" translate="yes" xml:space="preserve">
          <source>Two: I splay the deck on that card you chose.  What is this splay; how do I splay?  Well, I go from the start card down, one by one, and I look for a card that is more high than the splay card.</source>
          <target state="translated">Dos:juego la baraja con la carta que elegiste.¿Qué es esta jugada? ¿Cómo la juego? Bueno,voy desde la carta inicial hacia abajo,una por una,y busco una carta que sea más alta que la del juego.</target>
        </trans-unit>
        <trans-unit id="7b569bf8286d4c929a479c4976f45922a580f422" translate="yes" xml:space="preserve">
          <source>Uh oh, more work.  Now, let&amp;rsquo;s not do the work.  But, let&amp;rsquo;s make a plan to do it, step by step.</source>
          <target state="translated">Uh oh, m&amp;aacute;s trabajo. Ahora, no hagamos el trabajo. Pero, hagamos un plan para hacerlo, paso a paso.</target>
        </trans-unit>
        <trans-unit id="66ec3cb6bc2e6fcaea19ddeb58c0027ecdebce58" translate="yes" xml:space="preserve">
          <source>Unrelatedly but worth mentioning again: If we perform a hash (e.g. a dictionary/hashtable lookup), that is a factor of O(1). That's pretty fast.</source>
          <target state="translated">Sin relación,pero vale la pena mencionarlo de nuevo:Si realizamos un hash (por ejemplo,una búsqueda en el diccionario),eso es un factor de O(1).Eso es bastante rápido.</target>
        </trans-unit>
        <trans-unit id="ceb436949ce49c2aad7d40dd4b74113a2a9f4743" translate="yes" xml:space="preserve">
          <source>Using a tumble dryer: you put 10 shirts in each load, and then they're done an hour later. (Ignore the actual numbers here &amp;mdash; they're irrelevant.) So drying 50 shirts takes &lt;em&gt;about&lt;/em&gt; 5 times as long as drying 10 shirts.</source>
          <target state="translated">Usando una secadora: pones 10 camisas en cada carga, y luego se hacen una hora m&amp;aacute;s tarde. (Ignore los n&amp;uacute;meros reales aqu&amp;iacute;, son irrelevantes). Por lo tanto, secar 50 camisas toma &lt;em&gt;aproximadamente&lt;/em&gt; 5 veces m&amp;aacute;s que secar 10 camisas.</target>
        </trans-unit>
        <trans-unit id="c1627c2d9bf38d1a8bf4e6c4db14ba36e137fed7" translate="yes" xml:space="preserve">
          <source>Using a washing line outside: assuming you have an infinitely large back yard, washing dries in O(1) time. However much you have of it, it'll get the same sun and fresh air, so the size doesn't affect the drying time.</source>
          <target state="translated">Usando una línea de lavado en el exterior:asumiendo que tienes un patio trasero infinitamente grande,el lavado se seca en O(1)tiempo.Por mucho que tengas,recibirá el mismo sol y aire fresco,así que el tamaño no afecta el tiempo de secado.</target>
        </trans-unit>
        <trans-unit id="32fee750e2bced1ef4713977d7422997ac4d01b8" translate="yes" xml:space="preserve">
          <source>Usually, we don't care what the specific constant factors are, because they don't affect the way the function grows. For example, two algorithms may both take &lt;code&gt;O(N)&lt;/code&gt; time to complete, but one may be twice as slow as the other. We usually don't care too much unless the factor is very large since optimizing is tricky business ( &lt;a href=&quot;https://stackoverflow.com/questions/385506/when-is-optimisation-premature&quot;&gt;When is optimisation premature?&lt;/a&gt; ); also the mere act of picking an algorithm with a better big-O will often improve performance by orders of magnitude.</source>
          <target state="translated">Por lo general, no nos importa cu&amp;aacute;les son los factores constantes espec&amp;iacute;ficos, porque no afectan la forma en que crece la funci&amp;oacute;n. Por ejemplo, dos algoritmos pueden tardar tanto &lt;code&gt;O(N)&lt;/code&gt; en completarse, pero uno puede ser el doble de lento que el otro. Por lo general, no nos importa demasiado a menos que el factor sea muy grande ya que la optimizaci&amp;oacute;n es un negocio complicado (&amp;iquest; &lt;a href=&quot;https://stackoverflow.com/questions/385506/when-is-optimisation-premature&quot;&gt;Cu&amp;aacute;ndo es prematura la optimizaci&amp;oacute;n?&lt;/a&gt; ); Adem&amp;aacute;s, el simple hecho de elegir un algoritmo con un mejor Big-O a menudo mejorar&amp;aacute; el rendimiento en &amp;oacute;rdenes de magnitud.</target>
        </trans-unit>
        <trans-unit id="ec6a77a1f38d77785d38e6e7cc1d9af0e804cfa3" translate="yes" xml:space="preserve">
          <source>Very Quick Note:</source>
          <target state="translated">Nota muy rápida:</target>
        </trans-unit>
        <trans-unit id="6d21f45bec9f10023aec098341e6f6c03c5b13c1" translate="yes" xml:space="preserve">
          <source>Via examples, this helped get the bare basics into my tortoiseshell-like skull, so I think it's a pretty descent 10-minute read to get you headed in the right direction.</source>
          <target state="translated">A través de ejemplos,esto ayudó a meter lo básico en mi cráneo parecido al de una tortuga,así que creo que es una bonita lectura de 10 minutos de descenso para que te dirijas en la dirección correcta.</target>
        </trans-unit>
        <trans-unit id="6aab5f5e334f1c425e8cc5c3149d2485a2ab6b43" translate="yes" xml:space="preserve">
          <source>Wait!  What is n?  Did I miss that?  How can I add from one to n if you don&amp;rsquo;t tell me what n is?</source>
          <target state="translated">&amp;iexcl;Espere! &amp;iquest;Qu&amp;eacute; es n? &amp;iquest;Extra&amp;ntilde;&amp;eacute; eso? &amp;iquest;C&amp;oacute;mo puedo agregar de uno a n si no me dices qu&amp;eacute; es n?</target>
        </trans-unit>
        <trans-unit id="2f7ade3e8b4a45caea9bbfc55450f4d016746563" translate="yes" xml:space="preserve">
          <source>We are trying to see how the number of input parameters, affects the running time of an algorithm. If the running time of your application is proportional to the number of input parameters, then it is said to be in Big O of n.</source>
          <target state="translated">Estamos tratando de ver cómo el número de parámetros de entrada,afecta el tiempo de funcionamiento de un algoritmo.Si el tiempo de ejecución de su aplicación es proporcional al número de parámetros de entrada,entonces se dice que está en la Gran O de n.</target>
        </trans-unit>
        <trans-unit id="d3658b52f527a76c6421772c73ea4511ef27a0b9" translate="yes" xml:space="preserve">
          <source>We can just rearrange this and see it's O(N):</source>
          <target state="translated">Podemos reacomodar esto y ver que es O(N):</target>
        </trans-unit>
        <trans-unit id="a081699494ed4f022754488ece9b2b843bf6728d" translate="yes" xml:space="preserve">
          <source>Well actually there's less than that because some of these are equivalent (A &amp;rarr; B &amp;rarr; C and C &amp;rarr; B &amp;rarr; A are equivalent, for example, because they use the same roads, just in reverse).</source>
          <target state="translated">Bueno, en realidad hay menos que eso porque algunos de estos son equivalentes (A &amp;rarr; B &amp;rarr; C y C &amp;rarr; B &amp;rarr; A son equivalentes, por ejemplo, porque usan los mismos caminos, justo al rev&amp;eacute;s).</target>
        </trans-unit>
        <trans-unit id="f33910e9a426fbc1a12d1f88603bfdd1d8ca337f" translate="yes" xml:space="preserve">
          <source>Well, I don&amp;rsquo;t know what n is.  I was not told.  Were you?  No?   Oh well.  So we can&amp;rsquo;t do the work.  Whew.</source>
          <target state="translated">Bueno, no s&amp;eacute; qu&amp;eacute; es n. No me lo dijeron. &amp;iquest;Eras t&amp;uacute;? &amp;iquest;No? Oh bien. Entonces no podemos hacer el trabajo. Uf.</target>
        </trans-unit>
        <trans-unit id="4b2089e7aacf0c6fcb7cbbe9c09999beabffc5dd" translate="yes" xml:space="preserve">
          <source>Well, I guess I would have to do ten adds&amp;hellip; one for each thing from one to ten.  Ten is more than six.  I would have to work that much more to add from one to ten, than one to six!</source>
          <target state="translated">Bueno, supongo que tendr&amp;iacute;a que hacer diez sumas ... una para cada cosa, de una a diez. Diez es m&amp;aacute;s que seis. &amp;iexcl;Tendr&amp;iacute;a que trabajar mucho m&amp;aacute;s para agregar de uno a diez, que de uno a seis!</target>
        </trans-unit>
        <trans-unit id="448ecbc620762a34ee90c323b9d2af296de94e73" translate="yes" xml:space="preserve">
          <source>Well, I will not do the work to add them now.  But I know how hard it would be.  It would be six adds.</source>
          <target state="translated">Bueno,no haré el trabajo de añadirlos ahora.Pero sé lo difícil que sería.Serían seis adiciones.</target>
        </trans-unit>
        <trans-unit id="e6092f44041d9afec7369ff2f52755377d43518f" translate="yes" xml:space="preserve">
          <source>Well, how much work would that be, to sort the cards with those rules?</source>
          <target state="translated">Bueno,¿cuánto trabajo sería eso,ordenar las cartas con esas reglas?</target>
        </trans-unit>
        <trans-unit id="3a69be1de24839373d5d994ccbcc98a836e1d23b" translate="yes" xml:space="preserve">
          <source>Well, if n gets real big, we do not care what we might add to n or n squared.</source>
          <target state="translated">Bueno,si n se hace muy grande,no nos importa lo que podamos añadir a n o n al cuadrado.</target>
        </trans-unit>
        <trans-unit id="2d9059fb09bbdcd3a55d09451a9fcb425e83ec53" translate="yes" xml:space="preserve">
          <source>Well, let&amp;rsquo;s see.  I must add one and two, and then add that to three, and then add that to four&amp;hellip; All in all, I count six adds.  I have to do six adds to solve this.</source>
          <target state="translated">Bien, veamos. Debo agregar uno y dos, y luego agregar eso a tres, y luego agregar eso a cuatro ... En total, cuento seis agregados. Tengo que hacer seis adiciones para resolver esto.</target>
        </trans-unit>
        <trans-unit id="329e7c685300ef2d2b4c47c92157c7ce7ca7c71a" translate="yes" xml:space="preserve">
          <source>Well, what's so wonderful about Big O notation if that's what it does?</source>
          <target state="translated">Bueno,¿qué tiene de maravilloso la notación de Big O si eso es lo que hace?</target>
        </trans-unit>
        <trans-unit id="27f2ea453fa647e6745114288459cdbdc09377db" translate="yes" xml:space="preserve">
          <source>Well, you know n squared is n times n.  Now, I get it: n cards checked, up to what might be n times through the deck.  That is two loops, each with n steps.  That is n squared much work to be done.  A lot of work, for sure!</source>
          <target state="translated">Bueno,ya sabes que n al cuadrado es n veces n.Ahora,lo entiendo:n cartas revisadas,hasta lo que podría ser n veces a través de la baraja.Son dos bucles,cada uno con n pasos.Eso es n al cuadrado mucho trabajo por hacer.¡Mucho trabajo,seguro!</target>
        </trans-unit>
        <trans-unit id="f37e46082d9d7fea2de0995ec35f0ebec2aa85b9" translate="yes" xml:space="preserve">
          <source>What if I order several Blu-ray movies like The Lord of the Rings, Twilight, The Dark Knight Trilogy, etc. and download all the movies online at the same time? This time, the delivery still take a day to complete, but the online download takes 3 days to finish.
For online shopping, the number of purchased item (input) doesn&amp;rsquo;t affect the delivery time. The output is constant. We call this &lt;strong&gt;O(1)&lt;/strong&gt;.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; sucede si ordeno varias pel&amp;iacute;culas de Blu-ray como The Lord of the Rings, Twilight, The Dark Knight Trilogy, etc. y descargo todas las pel&amp;iacute;culas en l&amp;iacute;nea al mismo tiempo? Esta vez, la entrega a&amp;uacute;n tarda un d&amp;iacute;a en completarse, pero la descarga en l&amp;iacute;nea tarda 3 d&amp;iacute;as en finalizar. Para las compras en l&amp;iacute;nea, la cantidad de art&amp;iacute;culos comprados (entrada) no afecta el tiempo de entrega. La salida es constante. Llamamos a esto &lt;strong&gt;O (1)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae3452404f7d023c914234c52fa39dc716c5a20" translate="yes" xml:space="preserve">
          <source>What if you have a phone number and want to find a name?  The police have a reverse phone book but such look-ups are denied to the general public.  Or are they?  Technically you can reverse look-up a number in an ordinary phone book.  How?</source>
          <target state="translated">¿Y si tienes un número de teléfono y quieres encontrar un nombre? La policía tiene una guía telefónica al revés,pero tales búsquedas son negadas al público en general.¿O no? Técnicamente puedes buscar un número en una guía telefónica ordinaria.¿Cómo?</target>
        </trans-unit>
        <trans-unit id="373e1d2a10f1cbeda45147e21f05a41927cb80df" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of &amp;ldquo;Big O&amp;rdquo; notation?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es una explicaci&amp;oacute;n sencilla en ingl&amp;eacute;s de la notaci&amp;oacute;n &quot;Big O&quot;?</target>
        </trans-unit>
        <trans-unit id="05e7612ca7f7ef6fa7a4103f167b120617cb813f" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of Big O? With as little formal definition as possible and simple mathematics.</source>
          <target state="translated">¿Cuál es la explicación de Big O en inglés? Con la menor definición formal posible y matemáticas simples.</target>
        </trans-unit>
        <trans-unit id="f89a18eb1e0fc978c591793d435b46bfc0826855" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of “Big O” notation</source>
          <target state="translated">¿Cuál es la explicación de la notación &quot;Big O&quot; en inglés?</target>
        </trans-unit>
        <trans-unit id="2cc611dba256f3aa30150ddcf404bfb6a56af65d" translate="yes" xml:space="preserve">
          <source>What is this sort called?  It is called Quick Sort!  That sort was made by a man called &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;C. A. R. Hoare&lt;/a&gt; and he called it Quick Sort.  Now, Quick Sort gets used all the time!</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo se llama este tipo? Se llama Quick Sort! Ese tipo fue hecho por un hombre llamado &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;CAR Hoare&lt;/a&gt; y lo llam&amp;oacute; Quick Sort. &amp;iexcl;Ahora, Quick Sort se acostumbra todo el tiempo!</target>
        </trans-unit>
        <trans-unit id="bf023f1a273e5e8e203698a520653800da906866" translate="yes" xml:space="preserve">
          <source>When interested in doing computations whose size is &quot;large&quot; enough to be considered as approximately infinity, then big O notation is approximately the cost of solving your problem.</source>
          <target state="translated">Cuando se está interesado en hacer cálculos cuyo tamaño es lo suficientemente &quot;grande&quot; como para ser considerado como aproximadamente infinito,entonces la notación de O grande es aproximadamente el costo de resolver su problema.</target>
        </trans-unit>
        <trans-unit id="adc3d5b71af09ac58be8764be77408df12df041d" translate="yes" xml:space="preserve">
          <source>When the deck is done, I ask: did I swap cards in that pass?  If so, I must do it all once more, from the top.</source>
          <target state="translated">Cuando la baraja está lista,pregunto:¿intercambié las cartas en ese pase? Si es así,debo hacerlo todo una vez más,desde el principio.</target>
        </trans-unit>
        <trans-unit id="9028c7b55a2b4ecb9c2a82958fa89f7a7fc1daa5" translate="yes" xml:space="preserve">
          <source>When we program, we are trying to solve a problem. What we code is called an algorithm. Big O notation allows us to compare the worse case performance of our algorithms in a standardized way. Hardware specs vary over time and improvements in hardware can reduce the time it takes an algorithms to run. But replacing the hardware does not mean our algorithm is any better or improved over time, as our algorithm is still the same. So in order to allow us to compare different algorithms, to determine if one is better or not, we use Big O notation.</source>
          <target state="translated">Cuando programamos,estamos tratando de resolver un problema.Lo que codificamos se llama algoritmo.La notación Big O nos permite comparar el peor caso de rendimiento de nuestros algoritmos de una manera estandarizada.Las especificaciones del hardware varían con el tiempo y las mejoras en el hardware pueden reducir el tiempo de ejecución de los algoritmos.Pero reemplazar el hardware no significa que nuestro algoritmo sea mejor o haya mejorado con el tiempo,ya que nuestro algoritmo sigue siendo el mismo.Así que para permitirnos comparar diferentes algoritmos,para determinar si uno es mejor o no,usamos la notación Big O.</target>
        </trans-unit>
        <trans-unit id="54c2c9229bcd771be7710eabeb971bc3f8e0eb85" translate="yes" xml:space="preserve">
          <source>When we say some algorithm is O(f(n)) we are saying that the running time (or space required) by that algorithm is always lower than some constant times f(n).</source>
          <target state="translated">Cuando decimos que algún algoritmo es O(f(n))estamos diciendo que el tiempo de funcionamiento (o el espacio requerido)por ese algoritmo es siempre menor que algunos tiempos constantes f(n).</target>
        </trans-unit>
        <trans-unit id="5d1cb020f38d2820c9eec88a25e1be3ef2a6c892" translate="yes" xml:space="preserve">
          <source>Why do I choose Quick Sort?  I do not like to work, of course!  I want work done as soon as I can get it done.</source>
          <target state="translated">¿Por qué elijo Quick Sort? ¡No me gusta trabajar,por supuesto! Quiero trabajar tan pronto como pueda hacerlo.</target>
        </trans-unit>
        <trans-unit id="ccaa8eba13667623c9638dcc1af96e87d1ce8695" translate="yes" xml:space="preserve">
          <source>Why does he say n squared?</source>
          <target state="translated">¿Por qué dice n al cuadrado?</target>
        </trans-unit>
        <trans-unit id="ed876af93299c7d2e7470f312b49d7963f03e745" translate="yes" xml:space="preserve">
          <source>Why is this so important? Because software deals with problems that may differ in size by factors up to a trillion. Consider that for a moment. The ratio between the speed necessary to travel to the Moon and human walking speed is less than 10,000:1, and that is absolutely tiny compared to the range in input sizes software may face. And because software may face an astronomical range in input sizes there is the potential for the Big O complexity of an algorithm, it's fundamental scaling nature, to trump any implementation details.</source>
          <target state="translated">¿Por qué es tan importante? Porque el software se ocupa de problemas que pueden diferir en tamaño por factores de hasta un billón.Considere eso por un momento.La relación entre la velocidad necesaria para viajar a la Luna y la velocidad de la marcha humana es inferior a 10.000:1,y eso es absolutamente minúsculo comparado con el rango de tamaños de entrada que el software puede enfrentar.Y debido a que el software puede enfrentarse a un rango astronómico en los tamaños de entrada,existe el potencial para la complejidad de un algoritmo Big O,es la naturaleza de escalamiento fundamental,para superar cualquier detalle de implementación.</target>
        </trans-unit>
        <trans-unit id="a693d58d361e39c4c6dfbf09d0fc6a088f14c901" translate="yes" xml:space="preserve">
          <source>Why would you want to ignore the smaller parts of the equation? Because they become completely dwarfed by the big parts of the equation as you consider larger and larger scales; their contribution becomes dwarfed and irrelevant. (See example section.)</source>
          <target state="translated">¿Por qué querrías ignorar las partes más pequeñas de la ecuación? Porque quedan completamente empequeñecidas por las grandes partes de la ecuación,ya que se consideran a escalas cada vez más grandes;su contribución queda empequeñecida e irrelevante.(Véase la sección de ejemplos).</target>
        </trans-unit>
        <trans-unit id="b03cf50f7e5382fcef1451bd7a03322e40c6839f" translate="yes" xml:space="preserve">
          <source>With 5 it's 60.</source>
          <target state="translated">Con 5 son 60.</target>
        </trans-unit>
        <trans-unit id="19778bc5e290319ee50f4c5296b015273dc9262c" translate="yes" xml:space="preserve">
          <source>Worst-Case: the key doesn't exist in the list.</source>
          <target state="translated">En el peor de los casos:la clave no existe en la lista.</target>
        </trans-unit>
        <trans-unit id="5fabd786be014d83764164facee56b049790e363" translate="yes" xml:space="preserve">
          <source>Wow, I hate work.  But oh well, I have to do this.  So here I go.</source>
          <target state="translated">Vaya,odio el trabajo.Pero,bueno,tengo que hacer esto.Así que aquí voy.</target>
        </trans-unit>
        <trans-unit id="7c8c4cd8f5043686e05d837663d4022a92d73016" translate="yes" xml:space="preserve">
          <source>Yes, there is a more fast way!  It takes some time to learn, but it works... and it works quite fast.  You can try it too, but take your time with each step and do not lose your place.</source>
          <target state="translated">Sí,hay un camino más rápido.Lleva un tiempo aprenderlo,pero funciona...y funciona bastante rápido.Tú también puedes intentarlo,pero tómate tu tiempo con cada paso y no pierdas tu lugar.</target>
        </trans-unit>
        <trans-unit id="cfe414e40bd3874b327354ff113f428d54d21253" translate="yes" xml:space="preserve">
          <source>You could refer to Big-&amp;Omega; (Big-Omega) for best case.</source>
          <target state="translated">Puede referirse a Big-&amp;Omega; (Big-Omega) para el mejor caso.</target>
        </trans-unit>
        <trans-unit id="7bfc8ee77cbab3d00050185496cbe7e412b4bf8a" translate="yes" xml:space="preserve">
          <source>You drive a car. Occasionally, you need to spend 10 minutes going to
  the gas station and then spend 1 minute refilling the tank with gas.
  If you did this every time you went anywhere with your car (spend 10
  minutes driving to the gas station, spend a few seconds filling up a
  fraction of a gallon), it would be very inefficient. But if you fill
  up the tank once every few days, the 11 minutes spent driving to the
  gas station is &quot;amortized&quot; over a sufficiently large number of trips,
  that you can ignore it and pretend all your trips were maybe 5% longer.</source>
          <target state="translated">Conduces un coche.Ocasionalmente,necesitas pasar 10 minutos yendo a la gasolinera y luego pasar 1 minuto llenando el tanque con gasolina.Si hicieras esto cada vez que fueras a cualquier parte con tu coche (pasar 10 minutos conduciendo a la gasolinera,pasar unos segundos llenando una fracción de galón),sería muy ineficiente.Pero si llenas el tanque una vez cada pocos días,los 11 minutos que pasas conduciendo a la gasolinera se &quot;amortizan&quot; en un número de viajes lo suficientemente grande,como para que puedas ignorarlo y pretender que todos tus viajes fueron tal vez un 5% más largos.</target>
        </trans-unit>
        <trans-unit id="2c6bcba6f752f5cfdc961fb84683b404f55a2f21" translate="yes" xml:space="preserve">
          <source>You learned all that with me!  You are so smart!  Thank you so much!</source>
          <target state="translated">¡Aprendiste todo eso conmigo! ¡Eres tan inteligente! ¡Muchas gracias!</target>
        </trans-unit>
        <trans-unit id="e8fd35a375e8ec51f2b6feca80545b2feec31781" translate="yes" xml:space="preserve">
          <source>You may often see O(n), O(n&lt;sup&gt;2&lt;/sup&gt;), O(nlogn) and so forth, all these are just ways to show; How does an algorithm change?</source>
          <target state="translated">A menudo puede ver O (n), O (n &lt;sup&gt;2&lt;/sup&gt; ), O (nlogn), etc., todas estas son solo formas de mostrar; &amp;iquest;C&amp;oacute;mo cambia un algoritmo?</target>
        </trans-unit>
        <trans-unit id="f0c088b8e94d146df79970184c217c58b7b97083" translate="yes" xml:space="preserve">
          <source>You start at the first name and compare the number.  If it's a match, great, if not, you move on to the next.  You have to do it this way because the phone book is &lt;strong&gt;unordered&lt;/strong&gt; (by phone number anyway).</source>
          <target state="translated">Empiezas con el primer nombre y compara el n&amp;uacute;mero. Si es un partido, genial, si no, pasas al siguiente. Debe hacerlo de esta manera porque la gu&amp;iacute;a telef&amp;oacute;nica &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute; &lt;strong&gt;ordenada&lt;/strong&gt; (de todos modos, por n&amp;uacute;mero de tel&amp;eacute;fono).</target>
        </trans-unit>
        <trans-unit id="4784b5173ab05221f2b6abc84330bf0f13d31a7c" translate="yes" xml:space="preserve">
          <source>You want to know all there is to know of big O?  So do I.</source>
          <target state="translated">¿Quieres saber todo lo que hay que saber del gran O? Yo también.</target>
        </trans-unit>
        <trans-unit id="648ba0204f36666cba11a8e63d6db611dae8658b" translate="yes" xml:space="preserve">
          <source>[1]: There is a way to cheat and add all the things from one to n, all at one time.  Some kid named Gauss found this out when he was eight.  I am not that smart though, so &lt;a href=&quot;http://nzmaths.co.nz/gauss-trick-staff-seminar&quot;&gt;don't ask me how he did it&lt;/a&gt;.</source>
          <target state="translated">[1]: Hay una manera de hacer trampa y agregar todas las cosas de uno a n, todo a la vez. Un ni&amp;ntilde;o llamado Gauss descubri&amp;oacute; esto cuando ten&amp;iacute;a ocho a&amp;ntilde;os. Sin embargo, no soy tan inteligente, as&amp;iacute; &lt;a href=&quot;http://nzmaths.co.nz/gauss-trick-staff-seminar&quot;&gt;que no me preguntes c&amp;oacute;mo lo hizo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4229c03c35f915409c958fce305574599037d757" translate="yes" xml:space="preserve">
          <source>[for the mathematically inclined, you can mouse over the spoilers for minor sidenotes]</source>
          <target state="translated">[para los matemáticamente inclinados,puedes pasar el ratón por encima de los alerones para los sidenotes menores]</target>
        </trans-unit>
        <trans-unit id="320f1d7c3f87e62df035bd8c3fff9fceb851f278" translate="yes" xml:space="preserve">
          <source>addition;</source>
          <target state="translated">addition;</target>
        </trans-unit>
        <trans-unit id="cc72a00bf5f82a31e19586f8d5648eeb9609f807" translate="yes" xml:space="preserve">
          <source>and so on.</source>
          <target state="translated">y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="41f2ef38a3521fb432c176bb3d6eec433f0e7d29" translate="yes" xml:space="preserve">
          <source>big-O notation doesn't care about constant factors: the function &lt;code&gt;9x&amp;sup2;&lt;/code&gt; is said to &quot;grow exactly like&quot; &lt;code&gt;10x&amp;sup2;&lt;/code&gt;. Neither does big-O &lt;em&gt;asymptotic&lt;/em&gt; notation care about &lt;em&gt;non-asymptotic&lt;/em&gt; stuff (&quot;stuff near the origin&quot; or &quot;what happens when the problem size is small&quot;): the function &lt;code&gt;10x&amp;sup2;&lt;/code&gt; is said to &quot;grow exactly like&quot; &lt;code&gt;10x&amp;sup2; - x + 2&lt;/code&gt;.</source>
          <target state="translated">La notaci&amp;oacute;n big-O no se preocupa por los factores constantes: se dice que la funci&amp;oacute;n &lt;code&gt;9x&amp;sup2;&lt;/code&gt; &quot;crece exactamente como&quot; &lt;code&gt;10x&amp;sup2;&lt;/code&gt; . A &lt;em&gt;la&lt;/em&gt; notaci&amp;oacute;n &lt;em&gt;asint&amp;oacute;tica&lt;/em&gt; big-O tampoco le importan las cosas &lt;em&gt;no asint&amp;oacute;ticas&lt;/em&gt; (&quot;cosas cerca del origen&quot; o &quot;lo que sucede cuando el tama&amp;ntilde;o del problema es peque&amp;ntilde;o&quot;): se dice que la funci&amp;oacute;n &lt;code&gt;10x&amp;sup2;&lt;/code&gt; &quot;crece exactamente como&quot; &lt;code&gt;10x&amp;sup2; - x + 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fed40854ecbd633619a5d431600a671eeed9292" translate="yes" xml:space="preserve">
          <source>c= a constant</source>
          <target state="translated">c=una constante</target>
        </trans-unit>
        <trans-unit id="e923389b125ffc7cdb2e423a899d4348e7439235" translate="yes" xml:space="preserve">
          <source>division.</source>
          <target state="translated">division.</target>
        </trans-unit>
        <trans-unit id="714de604846fa9d95f2b9fc4aaa27f67caadafd4" translate="yes" xml:space="preserve">
          <source>e.g. for x=1million, ratio #handshakes/x&amp;sup2;: 0.499999...</source>
          <target state="translated">por ejemplo, para x = 1 mill&amp;oacute;n, relaci&amp;oacute;n # apretones de manos / x&amp;sup2;: 0.499999 ...</target>
        </trans-unit>
        <trans-unit id="f42454a2adeb8a0c26a29f629c55ab5dda69a64d" translate="yes" xml:space="preserve">
          <source>f(n)= An approximate function that expresses the running time of the algorithm as a function of n</source>
          <target state="translated">f(n)=Una función aproximada que expresa el tiempo de funcionamiento del algoritmo en función de n</target>
        </trans-unit>
        <trans-unit id="6b7dffac98fa2e9f18d9b09123953c56c601da05" translate="yes" xml:space="preserve">
          <source>how heat output scales on CPU dies as a function of transistor count, voltage, etc.</source>
          <target state="translated">cómo las escalas de salida de calor en la CPU mueren en función del recuento de transistores,el voltaje,etc.</target>
        </trans-unit>
        <trans-unit id="077a4887c6602aedfb17f44dd051822aa960da2d" translate="yes" xml:space="preserve">
          <source>how much space an algorithm needs to run, as a function of input size</source>
          <target state="translated">cuánto espacio necesita un algoritmo para funcionar,en función del tamaño de la entrada</target>
        </trans-unit>
        <trans-unit id="4d80174ea25f9828dcb069496071916d7c70255b" translate="yes" xml:space="preserve">
          <source>how much time an algorithm needs to run, as a function of input size</source>
          <target state="translated">cuánto tiempo necesita un algoritmo para funcionar,en función del tamaño de la entrada</target>
        </trans-unit>
        <trans-unit id="f2dbea261a6334b636fcb8245379760585160604" translate="yes" xml:space="preserve">
          <source>how website latency scales with the number of processing units in a CPU or GPU or computer cluster</source>
          <target state="translated">cómo la latencia del sitio web escala con el número de unidades de procesamiento en un CPU o GPU o un clúster de computadora</target>
        </trans-unit>
        <trans-unit id="5aa429e0444abdc08467c70c26cbff2d88e2345a" translate="yes" xml:space="preserve">
          <source>it's less than O(N&lt;sup&gt;1.000001&lt;/sup&gt;), which you might be willing to call basically linear</source>
          <target state="translated">es menor que O (N &lt;sup&gt;1.000001&lt;/sup&gt; ), que podr&amp;iacute;a estar dispuesto a llamar b&amp;aacute;sicamente lineal</target>
        </trans-unit>
        <trans-unit id="8e97d6456227b5a58913c9ed733df644f1e01e91" translate="yes" xml:space="preserve">
          <source>k is bounded in some neighborhood of a (if a = +&amp;infin;, this means that there are numbers N and M such that for every x &amp;gt; N, |&lt;em&gt;k&lt;/em&gt;(x)| &amp;lt; M).</source>
          <target state="translated">k est&amp;aacute; acotado en alg&amp;uacute;n vecindario de a (si a = + &amp;infin;, esto significa que hay n&amp;uacute;meros N y M tales que para cada x&amp;gt; N, | &lt;em&gt;k&lt;/em&gt; (x) | &amp;lt;M).</target>
        </trans-unit>
        <trans-unit id="6005c391c2f680a2452cd2577c2564dbcef8e9c9" translate="yes" xml:space="preserve">
          <source>ln(x) = o(x) = O(x) when x &amp;rarr; +&amp;infin;.</source>
          <target state="translated">ln (x) = o (x) = O (x) cuando x &amp;rarr; + &amp;infin;.</target>
        </trans-unit>
        <trans-unit id="273b9bcfed53ba997f70f8aa75c36bda6fde8958" translate="yes" xml:space="preserve">
          <source>multiplication; and</source>
          <target state="translated">multiplicación;y</target>
        </trans-unit>
        <trans-unit id="a4393b9a14bdfd4f4c0eeaaf31bad2e0b9cfef0d" translate="yes" xml:space="preserve">
          <source>n=number of input parameters</source>
          <target state="translated">n=número de parámetros de entrada</target>
        </trans-unit>
        <trans-unit id="463f52bc275366887f835ed5e5f95c1fe198e8af" translate="yes" xml:space="preserve">
          <source>or address it formally, &quot;Big O&quot; classifies the algorithms and standardize the comparison process.</source>
          <target state="translated">o abordarlo formalmente,&quot;Big O&quot; clasifica los algoritmos y estandariza el proceso de comparación.</target>
        </trans-unit>
        <trans-unit id="27c0dba7b6e5e26123d57265908dfa7204907ffd" translate="yes" xml:space="preserve">
          <source>probabilistic expected number of people who have seen some viral marketing as a function of time</source>
          <target state="translated">Probable número esperado de personas que han visto algún tipo de comercialización viral en función del tiempo</target>
        </trans-unit>
        <trans-unit id="0c2b90eddd63a783f5f290989f744b1bf85f87bd" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15,20,25}  ==&amp;gt; problem-instance-size = 5 iterations-in-loop = 5</source>
          <target state="translated">problem-instance = {5,10,15,20,25} ==&amp;gt; problem-instance-size = 5 iteraciones en bucle = 5</target>
        </trans-unit>
        <trans-unit id="e4b7c82dda906533e8c2824c6df8639b2a23a367" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15,20,25}  ==&amp;gt; problem-instance-size = 5, total-iterations= 5*5 =25</source>
          <target state="translated">problema-instancia = {5,10,15,20,25} ==&amp;gt; problema-instancia-tama&amp;ntilde;o = 5, iteraciones totales = 5 * 5 = 25</target>
        </trans-unit>
        <trans-unit id="7b9571101e4cfebe964dd712258a749bb36005e9" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15}  ==&amp;gt; problem-instance-size = 3, iterations-in-loop= 3</source>
          <target state="translated">problema-instancia = {5,10,15} ==&amp;gt; problema-instancia-tama&amp;ntilde;o = 3, iteraciones en bucle = 3</target>
        </trans-unit>
        <trans-unit id="41a7ac7c629f59f13ed8b74173f006eb424e46ac" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15}  ==&amp;gt; problem-instance-size = 3, total-iterations = 3*3 = 9</source>
          <target state="translated">problema-instancia = {5,10,15} ==&amp;gt; problema-instancia-tama&amp;ntilde;o = 3, iteraciones totales = 3 * 3 = 9</target>
        </trans-unit>
        <trans-unit id="6adf164f31eaa024e8cd62ab3a7db4601ada676a" translate="yes" xml:space="preserve">
          <source>sin x = O(1) when x &amp;rarr; +&amp;infin;,</source>
          <target state="translated">sen x = O (1) cuando x &amp;rarr; + &amp;infin;,</target>
        </trans-unit>
        <trans-unit id="01a98a9d29b98d64c9b325ce600cfccdddb4209c" translate="yes" xml:space="preserve">
          <source>sin x = O(x) when x &amp;rarr; 0.</source>
          <target state="translated">sen x = O (x) cuando x &amp;rarr; 0.</target>
        </trans-unit>
        <trans-unit id="0f7b476dccef1271c4d6a97311ca082c68f64f7e" translate="yes" xml:space="preserve">
          <source>so you could get its idea literally that it's used to order something to  compare them.</source>
          <target state="translated">así que podrías tener su idea literalmente de que se usa para ordenar algo para compararlos.</target>
        </trans-unit>
        <trans-unit id="2411b10604909e08dc5dd9f0ef7bed5327f33858" translate="yes" xml:space="preserve">
          <source>subtraction;</source>
          <target state="translated">subtraction;</target>
        </trans-unit>
        <trans-unit id="1dfbbc899d7564b2c25e7c8e5668555967ef21c9" translate="yes" xml:space="preserve">
          <source>the number of possible handshakes among &lt;code&gt;N&lt;/code&gt; people at a party (&lt;code&gt;Ɵ(N&amp;sup2;)&lt;/code&gt;, specifically &lt;code&gt;N(N-1)/2&lt;/code&gt;, but what matters is that it &quot;scales like&quot; &lt;code&gt;N&amp;sup2;&lt;/code&gt;)</source>
          <target state="translated">el n&amp;uacute;mero de posibles apretones de manos entre &lt;code&gt;N&lt;/code&gt; personas en una fiesta ( &lt;code&gt;Ɵ(N&amp;sup2;)&lt;/code&gt; , espec&amp;iacute;ficamente &lt;code&gt;N(N-1)/2&lt;/code&gt; , pero lo que importa es que &quot;escala&quot; como &lt;code&gt;N&amp;sup2;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a673eb6514c9181588ced3c270df39095e5c61da" translate="yes" xml:space="preserve">
          <source>x&lt;sup&gt;2&lt;/sup&gt; + x = O(x) when x &amp;rarr; 0,</source>
          <target state="translated">x &lt;sup&gt;2&lt;/sup&gt; + x = O (x) cuando x &amp;rarr; 0,</target>
        </trans-unit>
        <trans-unit id="4588b59a6bc0b7081d698604a73689ff94c6669e" translate="yes" xml:space="preserve">
          <source>x&lt;sup&gt;2&lt;/sup&gt; + x = O(x&lt;sup&gt;2&lt;/sup&gt;) when x &amp;rarr; +&amp;infin;,</source>
          <target state="translated">x &lt;sup&gt;2&lt;/sup&gt; + x = O (x &lt;sup&gt;2&lt;/sup&gt; ) cuando x &amp;rarr; + &amp;infin;,</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
