<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/487258">
    <body>
      <group id="487258">
        <trans-unit id="df498b6e1ddfb06035cc2f060b77dcae692ec7ef" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;What is a plain English explanation of Big O? With as little formal
  definition as possible and simple mathematics.&lt;/em&gt;&quot;</source>
          <target state="translated">「 &lt;em&gt;Big Oのわかりやすい英語の説明とは何ですか？可能な限り形式的な定義を少なくし、単純な数学を使用してください。&lt;/em&gt; 」</target>
        </trans-unit>
        <trans-unit id="743ffd5e6c073307e39f8ab64f2a620592932e7f" translate="yes" xml:space="preserve">
          <source>&quot;Big O&quot; describes the algorithm's performance and evaluates it.</source>
          <target state="translated">&quot;Big O &quot;は、アルゴリズムの性能を記述し、それを評価します。</target>
        </trans-unit>
        <trans-unit id="b462328e08f4909b285edec4ff0990d6976efaea" translate="yes" xml:space="preserve">
          <source>&quot;Big O' achieves the above two with standardized &lt;code&gt;Notations&lt;/code&gt;.</source>
          <target state="translated">「Big O 'は上記の2つを標準化された &lt;code&gt;Notations&lt;/code&gt; 実現しています。</target>
        </trans-unit>
        <trans-unit id="13f9f8a3d4d7d94edeaf3b7b38263362fa788e6a" translate="yes" xml:space="preserve">
          <source>&quot;For large enough inputsize=N, no matter what the constant factor is, if I &lt;strong&gt;&lt;em&gt;double&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; the input size&lt;/em&gt;...</source>
          <target state="translated">「十分な大きさのinputsize = Nの場合、定数係数が何であっても&lt;em&gt;、入力サイズ&lt;/em&gt;を&lt;strong&gt;&lt;em&gt;2倍に&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;すると&lt;/em&gt; ...</target>
        </trans-unit>
        <trans-unit id="839e4a2006b278a93c4dc0f1936567078302c3f3" translate="yes" xml:space="preserve">
          <source>&amp;hellip;</source>
          <target state="translated">&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="12f5efd72c115a3dfdb9aef75a93d8f6398d2f03" translate="yes" xml:space="preserve">
          <source>( *in a wonderful, &lt;em&gt;unit-free&lt;/em&gt; sense of time!)</source>
          <target state="translated">（* &lt;em&gt;単位のない&lt;/em&gt;素晴らしい時間感覚で！）</target>
        </trans-unit>
        <trans-unit id="5f85db481a01c4c068358bc082055af7e5738d77" translate="yes" xml:space="preserve">
          <source>(**which is what matters, because people will &lt;a href=&quot;http://www.youtube.com/watch?v=OnA3C9Af_oc&quot;&gt;&lt;em&gt;always&lt;/em&gt; want more&lt;/a&gt;, whether they live today or tomorrow)</source>
          <target state="translated">（**これは重要なことです。なぜなら、今日または明日を生きるかどうかにかかわらず、人々は&lt;a href=&quot;http://www.youtube.com/watch?v=OnA3C9Af_oc&quot;&gt;&lt;em&gt;常に&lt;/em&gt;より多く&lt;em&gt;を&lt;/em&gt;望んでいる&lt;/a&gt;からです ）</target>
        </trans-unit>
        <trans-unit id="111ed31dcbac4c6bfe6846c61c61ca1b11df6d01" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;edit&lt;/em&gt;: The &quot;plain English&quot; explanation ends here.)</source>
          <target state="translated">（ &lt;em&gt;編集&lt;/em&gt; ：「わかりやすい英語」の説明はここで終わります。）</target>
        </trans-unit>
        <trans-unit id="6ce684a7aaa9d4a76848668e020344c53ae2b9ae" translate="yes" xml:space="preserve">
          <source>(See &lt;a href=&quot;https://stackoverflow.com/q/7333376/711085&quot;&gt;Difference between average case and amortized analysis&lt;/a&gt; if interested in this subtopic.)</source>
          <target state="translated">（このサブトピックに関心がある&lt;a href=&quot;https://stackoverflow.com/q/7333376/711085&quot;&gt;場合は、平均ケースと償却分析の違いを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="acf9d80cf9dbb5bb7520ab6662ebded396c6f175" translate="yes" xml:space="preserve">
          <source>(here, the &lt;code&gt;x&lt;/code&gt;s represent constant-time units of work, processor instructions, interpreter opcodes, whatever)</source>
          <target state="translated">（ここで、 &lt;code&gt;x&lt;/code&gt; sは一定時間の作業単位、プロセッサーの命令、インタープリターのオペコードなどを表します）</target>
        </trans-unit>
        <trans-unit id="e095c7e86ea34ae9aa5df712384da64165e0768e" translate="yes" xml:space="preserve">
          <source>(technically the constant factor could maybe matter in some more esoteric examples, but I've phrased things above (e.g. in log(N)) such that it doesn't)</source>
          <target state="translated">(技術的には、より難解な例では定数係数が問題になるかもしれませんが、私はそうならないように上記のように表現しました(例えばlog(N)で)</target>
        </trans-unit>
        <trans-unit id="06d7bf9932a7f33791291e583cc05892187c54d8" translate="yes" xml:space="preserve">
          <source>(temporary digression from &quot;plain English&quot;:) If you wanted to prove this to yourself, you could perform some simple algebra on the ratio to split it up into multiple terms (&lt;code&gt;lim&lt;/code&gt; means &quot;considered in the limit of&quot;, just ignore it if you haven't seen it, it's just notation for &quot;and N is really really big&quot;):</source>
          <target state="translated">（「平易な英語」からの一時的な脱線:)これを自分で証明したい場合は、単純な代数を実行して比率を複数の項に分割することができます（ &lt;code&gt;lim&lt;/code&gt; は「範囲内で検討」されていることを意味します。あなたはそれを見たことがありません、それは単に「そしてNは本当に本当に大きい」という表記です）：</target>
        </trans-unit>
        <trans-unit id="11b4e1bb86ac129d3782b8fb89778b82b4699643" translate="yes" xml:space="preserve">
          <source>(with credit to &lt;a href=&quot;https://stackoverflow.com/a/487292/711085&quot;&gt;https://stackoverflow.com/a/487292/711085&lt;/a&gt; )</source>
          <target state="translated">（ &lt;a href=&quot;https://stackoverflow.com/a/487292/711085&quot;&gt;https://stackoverflow.com/a/487292/711085&lt;/a&gt;へのクレジット付き）</target>
        </trans-unit>
        <trans-unit id="7bedee6fc739cfe745b69e77230823ca7b506921" translate="yes" xml:space="preserve">
          <source>... I &quot;(basically) double&quot; the time an O(N log(N)) algorithm takes.&quot; &lt;em&gt;(fairly common)&lt;/em&gt;</source>
          <target state="translated">... O（N log（N））アルゴリズムにかかる時間を「（基本的に）2倍にする」 &lt;em&gt;（かなり一般的）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c2cc664a183cfc04e1a64249ea8f7c45673b79cb" translate="yes" xml:space="preserve">
          <source>... I add a fixed amount to the time an O(log(N)) (&quot;logarithmic time&quot;) algorithm takes.&quot; &lt;em&gt;(cheap!)&lt;/em&gt;</source>
          <target state="translated">... O（log（N））（ &quot;logarithmic time&quot;）アルゴリズムにかかる時間に固定量を追加します。 &lt;em&gt;（安い！）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9288b2e9d99d26a40d9f6f5b3a3990d8e5204b8b" translate="yes" xml:space="preserve">
          <source>... I don't change the time an O(1) (&quot;constant time&quot;) algorithm takes.&quot; &lt;em&gt;(the cheapest!)&lt;/em&gt;</source>
          <target state="translated">... O（1）（「一定時間」）アルゴリズムにかかる時間は変更しません。」 &lt;em&gt;（最も安い！）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac3db673dfe1df5538b14e8981fdd7f64c253879" translate="yes" xml:space="preserve">
          <source>... I double the time an O(N) (&quot;linear time&quot;) algorithm takes.&quot;</source>
          <target state="translated">...私は、O(N)(「線形時間」)アルゴリズムにかかる時間を2倍にする。&quot;</target>
        </trans-unit>
        <trans-unit id="a1e7e1ffe28ec1263008a387034b2aaa20a40664" translate="yes" xml:space="preserve">
          <source>... I double-cubed (octuple) the time an O(N&amp;sup3;) (&quot;cubic time&quot;) algorithm takes.&quot; &lt;em&gt;(e.g. a problem 100x as big takes 100&amp;sup3;=1000000x as long... very unsustainable)&lt;/em&gt;</source>
          <target state="translated">... O（N&amp;sup3;）（ &quot;三次時間&quot;）アルゴリズムにかかる時間を2倍（8倍）します。 &quot; &lt;em&gt;（たとえば、100倍の大きさの問題は100&amp;sup3;= 1000000倍の時間がかかる...非常に持続不可能）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eab0d87ea3058c371ba99238d90dc25bc68910e0" translate="yes" xml:space="preserve">
          <source>... I double-squared (quadruple) the time an O(N&amp;sup2;) (&quot;quadratic time&quot;) algorithm takes.&quot; &lt;em&gt;(e.g. a problem 100x as big takes 100&amp;sup2;=10000x as long... possibly unsustainable)&lt;/em&gt;</source>
          <target state="translated">... O（N&amp;sup2;）（ &quot;quadratic time&quot;）アルゴリズムにかかる時間を2乗（4倍）します。 &quot; &lt;em&gt;（たとえば、100倍の大きさの問題は100&amp;sup2;= 10000倍の時間を要する...おそらく持続不可能）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a87538c4cde56e0a42c94f671c99d158235fbb02" translate="yes" xml:space="preserve">
          <source>... I ridiculously increase the time a O(2&lt;sup&gt;N&lt;/sup&gt;) (&quot;exponential time&quot;) algorithm takes.&quot; &lt;em&gt;(you'd double (or triple, etc.) the time just by increasing the problem by a single unit)&lt;/em&gt;</source>
          <target state="translated">... O（2 &lt;sup&gt;N&lt;/sup&gt; ）（ &quot;指数時間&quot;）アルゴリズムにかかる時間を途方もなく増やします。 &lt;em&gt;（問題を1つの単位で増やすだけで、時間は2倍（または3倍など）になります）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="758995d5c0c86f523c06ebeba129d83d2b577e5c" translate="yes" xml:space="preserve">
          <source>... and the ugly:</source>
          <target state="translated">...そして醜い</target>
        </trans-unit>
        <trans-unit id="5f8dd699eca2f4c835f1d41e82c48c0ee2badc97" translate="yes" xml:space="preserve">
          <source>... this means that &lt;strong&gt;&lt;em&gt;for &quot;large enough&quot; problem sizes N&lt;/em&gt;&lt;/strong&gt; (if we ignore stuff near the origin), there exists some constant (e.g. 2.5, completely made up) such that:</source>
          <target state="translated">...これは、 &lt;strong&gt;&lt;em&gt;「十分に大きい」問題サイズN&lt;/em&gt;&lt;/strong&gt; （原点付近のものを無視する場合）には、次のような定数（たとえば、2.5、完全に構成されている）が存在することを意味します。</target>
        </trans-unit>
        <trans-unit id="02da7ab518ed35b63049ed24f5f7b780a03cf03c" translate="yes" xml:space="preserve">
          <source>1 item: 1 second</source>
          <target state="translated">1アイテム 1秒</target>
        </trans-unit>
        <trans-unit id="311ddef12fccab210777747c79f3b6e098829cf8" translate="yes" xml:space="preserve">
          <source>10 items: 1 second</source>
          <target state="translated">10個のアイテムを使用しています。1秒</target>
        </trans-unit>
        <trans-unit id="b0174046184ef586844edb37f738266a6b609bf9" translate="yes" xml:space="preserve">
          <source>10 items: 10 seconds</source>
          <target state="translated">10個のアイテムを 10秒</target>
        </trans-unit>
        <trans-unit id="689340b4e2631ad08bd04332ba871630466acec6" translate="yes" xml:space="preserve">
          <source>10 items: 100 seconds</source>
          <target state="translated">10個のアイテムを 100秒</target>
        </trans-unit>
        <trans-unit id="487a07e5ea7f045eaef47700eca5782bdc2698c0" translate="yes" xml:space="preserve">
          <source>10 items: 2 seconds</source>
          <target state="translated">10個のアイテムを 2秒</target>
        </trans-unit>
        <trans-unit id="e9339141f2aa5963a587e850388974cfe8b47716" translate="yes" xml:space="preserve">
          <source>100 items: 1 second</source>
          <target state="translated">100個のアイテムを使用しています。1秒</target>
        </trans-unit>
        <trans-unit id="f78d9065d61742cbe71ea04a50c760c0aad8e2f0" translate="yes" xml:space="preserve">
          <source>100 items: 100 seconds</source>
          <target state="translated">100個のアイテムを 100秒</target>
        </trans-unit>
        <trans-unit id="b9a9aeacdc04be6832d92a9113f361be8c4fe731" translate="yes" xml:space="preserve">
          <source>100 items: 10000 seconds</source>
          <target state="translated">100個のアイテムを 10000秒</target>
        </trans-unit>
        <trans-unit id="e626224265872fce291da52ed1c64e5aa6578829" translate="yes" xml:space="preserve">
          <source>100 items: 3 seconds</source>
          <target state="translated">100個のアイテムを使用しています。3秒</target>
        </trans-unit>
        <trans-unit id="4479af418a5535ecef4c1769fe04b3e262bd0ce2" translate="yes" xml:space="preserve">
          <source>1000 items: 4 seconds</source>
          <target state="translated">1000アイテム。4秒</target>
        </trans-unit>
        <trans-unit id="59b0f1da90751fd2ff98593e8e90a885934dbe5d" translate="yes" xml:space="preserve">
          <source>10000 items: 5 seconds</source>
          <target state="translated">10000アイテム。5秒</target>
        </trans-unit>
        <trans-unit id="085fdb777863ed85e33fb2c51dc325a0803c3300" translate="yes" xml:space="preserve">
          <source>25! = 25 &amp;times; 24 &amp;times; &amp;hellip; &amp;times; 2 &amp;times; 1 = 15,511,210,043,330,985,984,000,000</source>
          <target state="translated">25！ = 25&amp;times;24&amp;times;&amp;hellip;&amp;times;2&amp;times;1 = 15,511,210,043,330,985,984,000,000</target>
        </trans-unit>
        <trans-unit id="1cf1a4fd3744013ce7ee0b7c1d54d91a24a35640" translate="yes" xml:space="preserve">
          <source>5! = 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 120</source>
          <target state="translated">５！ = 5&amp;times;4&amp;times;3&amp;times;2&amp;times;1 = 120</target>
        </trans-unit>
        <trans-unit id="5ff18ebe3d87d9ac7b38e9bc7546904650421471" translate="yes" xml:space="preserve">
          <source>50! = 50 &amp;times; 49 &amp;times; &amp;hellip; &amp;times; 2 &amp;times; 1 = 3.04140932 &amp;times; 10&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">50！ = 50&amp;times;49&amp;times;&amp;hellip;&amp;times;2&amp;times;1 = 3.04140932&amp;times;10 &lt;sup&gt;64&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="65decea121bc59733f31fb00d9968ddd605ec56d" translate="yes" xml:space="preserve">
          <source>6 becomes 360.</source>
          <target state="translated">6は360になる。</target>
        </trans-unit>
        <trans-unit id="c649be492e31261bc490084ea0f4061c188e3cef" translate="yes" xml:space="preserve">
          <source>6! = 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 720</source>
          <target state="translated">６！ = 6&amp;times;5&amp;times;4&amp;times;3&amp;times;2&amp;times;1 = 720</target>
        </trans-unit>
        <trans-unit id="c8333818a5f4310605f53fef7090df38bab14cef" translate="yes" xml:space="preserve">
          <source>7! = 7 &amp;times; 6 &amp;times; 5 &amp;times; 4 &amp;times; 3 &amp;times; 2 &amp;times; 1 = 5040</source>
          <target state="translated">7！ = 7&amp;times;6&amp;times;5&amp;times;4&amp;times;3&amp;times;2&amp;times;1 = 5040</target>
        </trans-unit>
        <trans-unit id="82d23a6f8035f1269cf4ccfacb8ebe4510c824fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(1)&lt;/code&gt;&lt;strong&gt;Constant&lt;/strong&gt;: The program takes the same time to run no matter how big the input is.</source>
          <target state="translated">&lt;code&gt;O(1)&lt;/code&gt; &lt;strong&gt;定数&lt;/strong&gt; ：入力の大きさに関係なく、プログラムの実行には同じ時間がかかります。</target>
        </trans-unit>
        <trans-unit id="056a18f82b6af88dc008fbe3a7787f86b596f6a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(N)&lt;/code&gt; algorithms are in some sense the &quot;best&quot; algorithms if you need to read all your data. The &lt;strong&gt;very act of reading&lt;/strong&gt; a bunch of data is an &lt;code&gt;O(N)&lt;/code&gt; operation. Loading it into memory is usually &lt;code&gt;O(N)&lt;/code&gt; (or faster if you have hardware support, or no time at all if you've already read the data). However, if you touch or even &lt;em&gt;look&lt;/em&gt; at every piece of data (or even every other piece of data), your algorithm will take &lt;code&gt;O(N)&lt;/code&gt; time to perform this looking. No matter how long your actual algorithm takes, it will be at least &lt;code&gt;O(N)&lt;/code&gt; because it spent that time looking at all the data.</source>
          <target state="translated">すべてのデータを読み取る必要がある場合、 &lt;code&gt;O(N)&lt;/code&gt; アルゴリズムはある意味で「最良の」アルゴリズムです。 一連のデータ&lt;strong&gt;を読み取るまさにその行為は&lt;/strong&gt; &lt;code&gt;O(N)&lt;/code&gt; 操作です。 通常、メモリへのロードは &lt;code&gt;O(N)&lt;/code&gt; です （ハードウェアサポートがある場合は高速ですが、すでにデータを読み取っている場合はまったく時間がありません）。 ただし、すべてのデータ（または他のすべてのデータ）を触ったり、 &lt;em&gt;見&lt;/em&gt;たりした場合、アルゴリズムは &lt;code&gt;O(N)&lt;/code&gt; 時間をかけてこのルックアップを実行します。 実際のアルゴリズムにどれだけ時間がかかっても、すべてのデータを調べるのにその時間を費やしたため、少なくとも &lt;code&gt;O(N)&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="b1e73910621a4a87a24289f5d1c6be72edc01699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(k^n)&lt;/code&gt;&lt;strong&gt;Exponential&lt;/strong&gt; The program run-time increases very quickly with even moderate increases in the size of the problem - it is only practical to process small data sets with exponential algorithms.</source>
          <target state="translated">&lt;code&gt;O(k^n)&lt;/code&gt; &lt;strong&gt;指数関数&lt;/strong&gt;プログラムの実行時間は、問題のサイズが適度に大きくなっても非常に速く増加します-指数アルゴリズムを使用して小さなデータセットを処理することのみが現実的です。</target>
        </trans-unit>
        <trans-unit id="dd8fc41eb8e642b8c7be077a43f8b40003fc551c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt;&lt;strong&gt;Logarithmic&lt;/strong&gt;: The program run-time increases only slowly, even with big increases in the size of the input.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;strong&gt;対数&lt;/strong&gt; ：入力のサイズが大きく増加しても、プログラムの実行時間はゆっくりと増加します。</target>
        </trans-unit>
        <trans-unit id="5537ff56d10d57079a34acd64955d17beb7d3a76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n!)&lt;/code&gt;&lt;strong&gt;Factorial&lt;/strong&gt; The program run-time will be longer than you can afford to wait for anything but the very smallest and most trivial-seeming datasets.</source>
          <target state="translated">&lt;code&gt;O(n!)&lt;/code&gt; &lt;strong&gt;階乗&lt;/strong&gt;プログラムの実行時間は、非常に小さく、最も簡単なように見えるデータセット以外を待つだけの余裕がない場合より長くなります。</target>
        </trans-unit>
        <trans-unit id="461878ff8b0db16418e81fc04a687228bdddb9cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n)&lt;/code&gt;&lt;strong&gt;Linear&lt;/strong&gt;: The program run-time increases proportionally to the size of the input.</source>
          <target state="translated">&lt;code&gt;O(n)&lt;/code&gt; &lt;strong&gt;線形&lt;/strong&gt; ：プログラムの実行時間は、入力のサイズに比例して増加します。</target>
        </trans-unit>
        <trans-unit id="c217eda9395d53638ead2adab477fe11bdcd7bed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n^k)&lt;/code&gt;&lt;strong&gt;Polynomial&lt;/strong&gt;: - Processing time grows faster and faster - as a polynomial function - as the size of the input increases.</source>
          <target state="translated">&lt;code&gt;O(n^k)&lt;/code&gt; &lt;strong&gt;多項式&lt;/strong&gt; ：-入力のサイズが大きくなるにつれて、処理時間がますます速くなります-多項式関数として。</target>
        </trans-unit>
        <trans-unit id="487d91ff83198cfbc6a54c925fe5eb11d2aa1e78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; &amp;Omega;(lowerbound)&lt;/code&gt; means &lt;code&gt;f&lt;/code&gt; &quot;grows no slower than&quot; &lt;code&gt;lowerbound&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; &amp;Omega;(lowerbound)&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; が &lt;code&gt;lowerbound&lt;/code&gt; より「遅くならない」ことを意味します</target>
        </trans-unit>
        <trans-unit id="b822bda6e416f32092b9f10f8f055c41f8035dcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; means &lt;code&gt;f&lt;/code&gt; &quot;grows no faster than&quot; &lt;code&gt;upperbound&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; が &lt;code&gt;upperbound&lt;/code&gt; より速く成長しないことを意味します</target>
        </trans-unit>
        <trans-unit id="b5d65077f782632cf020f9dc10bb5515c203e5c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f(x) &amp;isin; Ɵ(justlikethis)&lt;/code&gt; mean &lt;code&gt;f&lt;/code&gt; &quot;grows exactly like&quot; &lt;code&gt;justlikethis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f(x) &amp;isin; Ɵ(justlikethis)&lt;/code&gt; は、 &lt;code&gt;f&lt;/code&gt; が 「まったく同じように成長する」ことを意味する &lt;code&gt;justlikethis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e4961257cbe0182882cfdaf21754b651a2f9dd8e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Big-O notation represent the upper-bound on the Complexity (Time, Space, ..)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Big-O表記は、複雑さの上限（時間、空間など）を表します&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b6ee9747fe724799f360b3f5740e340e9d6e0bc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Examples&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Examples&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dda2198e2a2e6a8edab7d156a0212aab2797c3a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Math addenda&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;数学の補遺&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53c547884adc7e294b855c4c5480cbf77fa6513e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;More examples&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;その他の例&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="16299135c5a827dc53d250d6ee80162f6e351d93" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;example:&lt;/em&gt; you and a friend are asked to create a function to sum the numbers from 0 to N. You come up with f(x) and your friend comes up with g(x). Both functions have the same result, but a different algorithm. In order to objectively compare the efficiency of the algorithms we use &lt;strong&gt;Big-O notation&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;例：&lt;/em&gt;あなたと友人は、0からNまでの数を合計する関数を作成するよう求められます。あなたはf（x）を思い付き、あなたの友人はg（x）を思い付きます。 両方の関数の結果は同じですが、アルゴリズムが異なります。 アルゴリズムの効率を客観的に比較するために、 &lt;strong&gt;Big-O表記法&lt;/strong&gt;を使用しています。</target>
        </trans-unit>
        <trans-unit id="62471f46793f8b6a5cc659e14e96cdc437a86276" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = &lt;em&gt;k&lt;/em&gt;(x)&lt;em&gt;g&lt;/em&gt;(x)</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; （x）= &lt;em&gt;k&lt;/em&gt; （x） &lt;em&gt;g&lt;/em&gt; （x）</target>
        </trans-unit>
        <trans-unit id="150577e3855332cfa9b847f25eb077da526cdf9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = O(&lt;em&gt;g&lt;/em&gt;(x)) when x goes to a (for example, a = +&amp;infin;) means that there is a function &lt;em&gt;k&lt;/em&gt; such that:</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; （x）= O（ &lt;em&gt;g&lt;/em&gt; （x））は、xがa（たとえば、a = +&amp;infin;）になるとき、次のような関数&lt;em&gt;k&lt;/em&gt;があることを意味します。</target>
        </trans-unit>
        <trans-unit id="f39e0610bb58307821a0194948212519a3857fe0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;f&lt;/em&gt;(x) = o(&lt;em&gt;g&lt;/em&gt;(x)) when x goes to a means that there is a function k such that:</source>
          <target state="translated">&lt;em&gt;f&lt;/em&gt; （x）= o（ &lt;em&gt;g&lt;/em&gt; （x））は、xがaになるとき、次のような関数kがあることを意味します。</target>
        </trans-unit>
        <trans-unit id="60efe2817e6b6dc1067de924ce07bd71c241b66c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;k&lt;/em&gt;(x) goes to 0 when x goes to a.</source>
          <target state="translated">xがaになると、 &lt;em&gt;k&lt;/em&gt; （x）は0になります。</target>
        </trans-unit>
        <trans-unit id="df9a7b04d24a410a550a80633b5c46b22b5f4454" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;Big O&quot; does two things:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;「Big O」は2つのことを行います。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1daaf609ea760d49121da39fad36df3d4c70428" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2&lt;sup&gt;2N&lt;/sup&gt; = (4&lt;sup&gt;N&lt;/sup&gt;)............put another way...... &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr; 2&lt;sup&gt;N+1&lt;/sup&gt; = 2&lt;sup&gt;N&lt;/sup&gt;2&lt;sup&gt;1&lt;/sup&gt; = 2 &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr;2 &lt;sup&gt;2N&lt;/sup&gt; =（4 &lt;sup&gt;N&lt;/sup&gt; ）............別の言い方をすると...... &lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt; &amp;rarr;2 &lt;sup&gt;N + 1&lt;/sup&gt; = 2 &lt;sup&gt;N&lt;/sup&gt; 2 &lt;sup&gt;1&lt;/sup&gt; = 2 &lt;strong&gt;2 &lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bafc82a1bb664838622cc7d1e8482db598079440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3 key takeaways:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3つの重要なポイント：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae00ba228fe3cdd0cfce107b955e3f34920862ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Plain English Explanation of &lt;em&gt;What&lt;/em&gt; Big O Notation is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big O表記とは&lt;em&gt;何か&lt;/em&gt;についてのわかりやすい英語の説明：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="effebafa8908442aac2c8ca79cf7084917151477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Plain English Explanation of the &lt;em&gt;Need&lt;/em&gt; for Big-O Notation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big-O表記法の&lt;em&gt;必要性&lt;/em&gt;に関する&lt;em&gt;簡単な&lt;/em&gt;英語の説明：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dc1a218f6a731c6560f65be4a2784929627a928" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A more accurate explanation (mathematical)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;より正確な説明（数学）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="73f82c5b1f0e86127e3020556cc882893d6cf6cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm description:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アルゴリズムの説明：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f5537eaa639ac5f94aa2c74841f5eaaa9254c7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm example (Java):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アルゴリズムの例（Java）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8aab72c29f5ef095ba2621ef23e8bc30d58b5ec1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Amortized Worst-Case&lt;/strong&gt;: Some data structures may have a worst-case complexity that is large, but guarantee that if you do many of these operations, the average amount of work you do will be better than worst-case. For example, you may have a data structure that normally takes constant &lt;code&gt;O(1)&lt;/code&gt; time. However, occasionally it will 'hiccup' and take &lt;code&gt;O(N)&lt;/code&gt; time for one random operation, because maybe it needs to do some bookkeeping or garbage collection or something... but it promises you that if it does hiccup, it won't hiccup again for N more operations. The worst-case cost is still &lt;code&gt;O(N)&lt;/code&gt; per operation, but the amortized cost &lt;em&gt;over many runs&lt;/em&gt; is &lt;code&gt;O(N)/N&lt;/code&gt; = &lt;code&gt;O(1)&lt;/code&gt; per operation. Because the big operations are sufficiently rare, the massive amount of occasional work can be considered to blend in with the rest of the work as a constant factor. We say the work is &quot;amortized&quot; over a sufficiently large number of calls that it disappears asymptotically.</source>
          <target state="translated">&lt;strong&gt;償却された最悪のケース&lt;/strong&gt; ：一部のデータ構造は、最悪の場合の複雑さが大きくなる可能性がありますが、これらの操作の多くを実行すると、実行する作業の平均量が最悪の場合よりも優れていることが保証されます。 たとえば、通常一定の &lt;code&gt;O(1)&lt;/code&gt; 時間かかるデータ構造があるとします。 ただし、場合によっては、簿記やガベージコレクションなどを実行する必要があるため、ランダムな操作1つに対して「しゃっくり」して &lt;code&gt;O(N)&lt;/code&gt; 時間かかることがあります。しかし、しゃっくりが発生しても、失敗しないことを約束します。さらにN回の操作のために再びしゃっくり。 最悪の場合のコストは依然としてオペレーションあたり &lt;code&gt;O(N)&lt;/code&gt; ですが、 &lt;em&gt;多くの実行での&lt;/em&gt;償却コストはオペレーションあたり &lt;code&gt;O(N)/N&lt;/code&gt; = &lt;code&gt;O(1)&lt;/code&gt; です。 大きな操作は非常にまれであるため、大量の偶発的な作業は、残りの作業と一定の要因として調和すると見なすことができます。 作品は、それが漸近的に消えるのに十分な数の呼び出しにわたって「償却」されると言います。</target>
        </trans-unit>
        <trans-unit id="bf7370e1d0177c50c4c0d7fb024561f2bab440cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Amortized and average-case complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;償却および平均ケースの複雑さ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ab4389896132cbec29ee3f0554d686383b2d60f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Applications&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Applications&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5b3d5404d360c404fd2bf84459010109192eb8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Attention!&lt;/strong&gt; The notation with the equal sign &quot;=&quot; uses a &quot;fake equality&quot;: it is true that o(g(x)) = O(g(x)), but false that O(g(x)) = o(g(x)).  Similarly, it is ok to write &quot;ln(x) = o(x) when x &amp;rarr; +&amp;infin;&quot;, but the formula &quot;o(x) = ln(x)&quot; would make no sense.</source>
          <target state="translated">&lt;strong&gt;注意！&lt;/strong&gt; 等号「=」の表記は「偽の等価性」を使用します。o（g（x））= O（g（x））であることが真ですが、O（g（x））= o（gであると偽です（バツ））。 同様に、「ln（x）= o（x）when x&amp;rarr;+&amp;infin;」と書いても問題ありませんが、「o（x）= ln（x）」という式は意味がありません。</target>
        </trans-unit>
        <trans-unit id="34dd92c00819162397c366f49572746e28f5f1c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Average Case&lt;/strong&gt;: This is no more than using big-O notation for the expected value of a function, rather than the function itself. In the usual case where you consider all inputs to be equally likely, the average case is just the average of the running time. For example with quicksort, even though the worst-case is &lt;code&gt;O(N^2)&lt;/code&gt; for some really bad inputs, the average case is the usual &lt;code&gt;O(N log(N))&lt;/code&gt; (the really bad inputs are very small in number, so few that we don't notice them in the average case).</source>
          <target state="translated">&lt;strong&gt;平均的なケース&lt;/strong&gt; ：これは、関数自体ではなく、関数の期待値にbig-O表記を使用することにすぎません。 すべての入力が等しく可能性があると考える通常のケースでは、平均ケースは実行時間の平均にすぎません。 たとえばクイックソートの場合、一部の本当に悪い入力のワーストケースは &lt;code&gt;O(N^2)&lt;/code&gt; ですが、平均的なケースは通常の &lt;code&gt;O(N log(N))&lt;/code&gt; です （本当に悪い入力は非常に少ないため、平均的なケースでは気づかないものもいくつかあります）。</target>
        </trans-unit>
        <trans-unit id="3220576162b61267d1a4a26767219ea6e4545c4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Back to English&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;英語に戻る&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0cac323801b8e9b2b0c915a6c542a3bbb241cb47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basics&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Basics&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deeb35e60114ce47ff18984e39930c946fc62ed4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Case:&lt;/strong&gt; In the telephone book search, the best case is that we find the name in one comparison.  This is &lt;strong&gt;O(1)&lt;/strong&gt; or &lt;strong&gt;constant complexity&lt;/strong&gt;;</source>
          <target state="translated">&lt;strong&gt;最良のケース：&lt;/strong&gt;電話帳検索での最良のケースは、1つの比較で名前を見つけることです。 これは&lt;strong&gt;O（1）&lt;/strong&gt;または&lt;strong&gt;一定の複雑さ&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="41bdf2eff0707b735977a7b17f99ea1599797803" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Best Case:&lt;/strong&gt; O(1);</source>
          <target state="translated">&lt;strong&gt;最良のケース：&lt;/strong&gt; O（1）;</target>
        </trans-unit>
        <trans-unit id="7914d10c281c86a759e82a40640c5f8d93756303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big O describes the fundamental scaling nature of an algorithm.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big Oは、アルゴリズムの基本的なスケーリングの性質を表します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e271d8846f3715b1a024f21916128b7d4259417" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big O&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ビッグオー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5dd5e066b9eba73f69ac911aaff371d1d5517277" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big-O notation is a relative representation of the complexity of an algorithm.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Big-O表記は、アルゴリズムの複雑さの相対的な表現です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c911dd80e980898d8f2c1e27f8c346fb06ef9ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Big-O notation:&lt;/strong&gt; describes &lt;em&gt;how quickly runtime will grow relative to the input as the input get arbitrarily large.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Big-O表記：&lt;/strong&gt; &lt;em&gt;入力が任意に大きくなると、実行時間が入力に比べてどれだけ速く増加するかを示します。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1070a59c780c49217b3d9ef6075f07036a4de4f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Building Intuition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;直感の構築&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f587b858f8d6fe44a8225f82326a30f53c9d5650" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;By the time you get to 200 towns there isn't enough time left in the universe to solve the problem with traditional computers.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;200の町にたどり着くまでに、従来のコンピューターの問題を解決するのに十分な時間が宇宙に残っていません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1d2d8d2f9c4e97fb709d00d85e5dfaceb74c57d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant factors&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;一定の要因&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9efca8768fe35240139284fbd68b4fe07fc97b92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Case:&lt;/strong&gt; As discussed above this is O(log n); and</source>
          <target state="translated">&lt;strong&gt;予想されるケース：&lt;/strong&gt;上で説明したように、これはO（log n）です。 そして</target>
        </trans-unit>
        <trans-unit id="9587614449d0127777f6fe21db3683733e748143" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expected Case:&lt;/strong&gt; O(n) (for 500,000); and</source>
          <target state="translated">&lt;strong&gt;予想されるケース：&lt;/strong&gt; O（n）（500,000の場合）; そして</target>
        </trans-unit>
        <trans-unit id="cdd089580422378d4ca18f0f8f5cf50cf6b830ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How do analyze algorithms and how can we compare algorithms against each other?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;アルゴリズムをどのように分析し、アルゴリズムを相互に比較することができますか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea84419042cce91d342892912299eab7b4c9fa1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you're unlucky when executing A, it might take as much as X(n) operations to
  complete.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Aの実行時に運が悪ければ、完了するまでにX（n）回の演算が必要になる可能性があります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5f526b740d48e1e3fd49fd9918ce4ec61555a90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multidimensional big-O&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;多次元ビッグオー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6acc739d0b13f807318bf1624de37df1094994ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N&amp;sup2;&lt;/strong&gt; &amp;rarr; (2N)&amp;sup2; = 4(&lt;strong&gt;N&amp;sup2;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;N&amp;sup2;&lt;/strong&gt; &amp;rarr;（2N）&amp;sup2;= 4（ &lt;strong&gt;N&amp;sup2;&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="61702d5685c60ef63ef6fe3ad5ab08a71dd8a2d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N&lt;/strong&gt; &amp;rarr; (2N) = 2(&lt;strong&gt;N&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;N&lt;/strong&gt; &amp;rarr;（2N）= 2（ &lt;strong&gt;N&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="21cce32ea86e14da51ca9a5664ed1f0ffeff0b0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Big O notation represents the &lt;strong&gt;worst-case scenario&lt;/strong&gt; of an algorithm. Let&amp;rsquo;s assume that &lt;strong&gt;O(1)&lt;/strong&gt; and &lt;strong&gt;O(n)&lt;/strong&gt; are the worst-case scenarios of the example above.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; Big O表記は、アルゴリズムの&lt;strong&gt;最悪のシナリオ&lt;/strong&gt;を表しています。 &lt;strong&gt;O（1）&lt;/strong&gt;と&lt;strong&gt;O（n）&lt;/strong&gt;が上記の例の最悪のシナリオであると仮定しましょう。</target>
        </trans-unit>
        <trans-unit id="252fabf6945e589a9b0b19016a058e011afbcc3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(1):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="68d75ca052377c566336069afee258c69b9aec6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1)&lt;/strong&gt; - Time to complete is the same regardless of the size of input set. An example is accessing an array element by index.</source>
          <target state="translated">&lt;strong&gt;O（1）&lt;/strong&gt; -入力セットのサイズに関係なく、完了するまでの時間は同じです。 例は、インデックスによって配列要素にアクセスすることです。</target>
        </trans-unit>
        <trans-unit id="f9afcf401f691a7c75faeb32231d92fde83ecee4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1)&lt;/strong&gt;:  known as &lt;strong&gt;Constant complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（1）&lt;/strong&gt; ： &lt;strong&gt;一定の複雑さ&lt;/strong&gt;として知られてい&lt;strong&gt;ます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dd564fa0710bbf0a0a6d4f2c0d4f0f4442e00d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e72a614b62847ef5617dfe85cfaca13129fb5ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; ）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="635e753fee8296bf321ba6bb90e4518245442fc7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d4b1b888d0086c21997e7a8ecfa829f30374361" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="22ac35f2cdc52d148b68da9ed9dd29461e980fe3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(Log N)&lt;/strong&gt; - Time to complete increases roughly in line with the log2(n). For example 1024 items takes roughly twice as long as 32 items, because Log2(1024) = 10 and Log2(32) = 5. An example is finding an item in a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;binary search tree&lt;/a&gt; (BST).</source>
          <target state="translated">&lt;strong&gt;O（Log N）&lt;/strong&gt; -完了までの時間は、log2（n）とほぼ同じように増加します。 たとえば、Log2（1024）= 10およびLog2（32）= 5であるため、1024アイテムは32アイテムの約2倍の時間がかかります。例として、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;バイナリ検索ツリー&lt;/a&gt; （BST）でアイテムを検索しています 。</target>
        </trans-unit>
        <trans-unit id="d26adbc9eb537a7d0d5f9ae0552e61b12d6c54bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N Log N)&lt;/strong&gt; - Time to complete increases by the number of items times the result of Log2(N). An example of this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap_sort&quot;&gt;heap sort&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Quick_sort&quot;&gt;quick sort&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O（N Log N）&lt;/strong&gt; -完了するまでの時間は、アイテム数にLog2（N）の結果を掛けた分だけ増加します。 この例として、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Heap_sort&quot;&gt;ヒープソート&lt;/a&gt;と&lt;a href=&quot;http://en.wikipedia.org/wiki/Quick_sort&quot;&gt;クイックソートがあります&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd630f970ed12459c9538aee894e4fca49869a98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N!)&lt;/strong&gt; - Time to complete is the factorial of the input set. An example of this is the &lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;traveling salesman problem brute-force solution&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O（N！）&lt;/strong&gt; -完了までの時間は、入力セットの階乗です。 この例は、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Travelling_salesman_problem&quot;&gt;巡回セールスマン問題のブルートフォースソリューション&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="9c2e179b7e171e252effc28bae4e6ee136e75dba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N)&lt;/strong&gt; - Time to complete that scales linearly with the size of the input set. In other words if you double the number of items in the input set, the algorithm takes roughly twice as long. An example is counting the number of items in a linked list.</source>
          <target state="translated">&lt;strong&gt;O（N）&lt;/strong&gt; -入力セットのサイズに比例してスケーリングする完了時間。 つまり、入力セットの項目数を2倍にすると、アルゴリズムの所要時間は約2倍になります。 例は、リンクされたリスト内のアイテムの数を数えることです。</target>
        </trans-unit>
        <trans-unit id="4784dc4311f56c18cde15b50f60f2194c6df45fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(N^2)&lt;/strong&gt; - Time to complete is roughly equal to the square of the number of items. An example of this is &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;bubble sort&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;O（N ^ 2）&lt;/strong&gt; -完了までの時間は、アイテム数の2乗にほぼ等しい。 この例は、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;バブルソート&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="bf8d37b23321b288f2b44644bc4c145c6315466f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log &lt;em&gt;n&lt;/em&gt;):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（log &lt;em&gt;n&lt;/em&gt; ）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32f6df92bfa553861340db36e2f34e2204cc3856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log n)&lt;/strong&gt;:  known as &lt;strong&gt;Logarithmic complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（log n）&lt;/strong&gt; ： &lt;strong&gt;対数複雑度&lt;/strong&gt;として知られてい&lt;strong&gt;ます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9a156d671486ba42c9d6bc4f718b4ad56ae4429" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n)&lt;/strong&gt;:  known as &lt;strong&gt;Linear complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（n）&lt;/strong&gt; ： &lt;strong&gt;線形複雑度&lt;/strong&gt;として知られてい&lt;strong&gt;ます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="25021c74f1f7cc3f73ce24095087c41055c38051" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;:  known as &lt;strong&gt;Quadratic complexity&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;O（n &lt;sup&gt;2&lt;/sup&gt; ）&lt;/strong&gt; ： &lt;strong&gt;二次複雑度&lt;/strong&gt;として知られてい&lt;strong&gt;ます&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ad18baa396b629a872133cacda5df06a167689b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Practical example: visualizing orders of growth while coding&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;実用例：コーディング中に成長の順序を視覚化する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee51f001b7ef2c276ec42b4e704f02dd05a4cccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reference&lt;/strong&gt; : &lt;a href=&quot;http://carlcheo.com/compsci&quot;&gt;http://carlcheo.com/compsci&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;リファレンス&lt;/strong&gt; ： &lt;a href=&quot;http://carlcheo.com/compsci&quot;&gt;http&lt;/a&gt; : //carlcheo.com/compsci</target>
        </trans-unit>
        <trans-unit id="63fd89842e817d63e08af214f7f5c992e4999387" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplest way to look at it (in plain English)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;それを見る最も簡単な方法（英語で）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f8b58e2bc4650ab1f5fd985238dd4f0a986d132" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Small o&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;小さいo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ff25f85074d21875430e07bd8801b858e31f7be6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Space complexity:&lt;/strong&gt; aside from time complexity, we also care about space complexity (how much memory/space an algorithm uses). Instead of checking the time of operations, we check the size of the allocation of memory.</source>
          <target state="translated">&lt;strong&gt;スペースの複雑さ：&lt;/strong&gt;時間の複雑さの他に、スペースの複雑さ（アルゴリズムが使用するメモリ/スペースの量）も考慮します。 操作時間をチェックする代わりに、メモリ割り当てのサイズをチェックします。</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aea48c460158f9801c2ff1547226bfcd94a4ab48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The whole story&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;一部始終&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5841737d9f1f0f3920b87ca2d61ff0c8311a9f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There are seven most used notations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最もよく使用される表記は7つあります&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="898a1558a3534794d5a58e6000c3473375b52eb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;There's also Big-Omega, which represent complexity of the Best-Case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Best-Caseの複雑さを表すBig-Omegaもあります。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a11037fecab22049818b34474fe8e78b05b5b18c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To find The Big-O on Time Complexity:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;The Big-O on Time Complexityを見つけるには：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07f6120a26e2f3f8456ca56f2c44ce3f39c3119c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We only care about the most significant portion of complexity.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;複雑さの最も重要な部分のみを考慮します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7974c46035c46b41ac44b7f0b9e92098bfa014df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why O(N) is sometimes the best you can do, i.e. why we need datastructures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;なぜO（N）が時々あなたができるベストなのか、つまりなぜデータ構造が必要なのか&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4207c81d75e6ff00a2ab700fd03b10c9d6ef7476" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst Case:&lt;/strong&gt; O(n) (for 1,000,000).</source>
          <target state="translated">&lt;strong&gt;最悪の場合：&lt;/strong&gt; O（n）（1,000,000の場合）。</target>
        </trans-unit>
        <trans-unit id="575be9f02c898b973aff9fb1bd5bd357e2752a80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Worst Case:&lt;/strong&gt; This is also O(log n).</source>
          <target state="translated">&lt;strong&gt;最悪の場合：&lt;/strong&gt;これもO（log n）です。</target>
        </trans-unit>
        <trans-unit id="8259671e56bc51a9fd25fab5b93ec32f6a9f6007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;algorithm&lt;/strong&gt;: procedure/formula for solving a problem</source>
          <target state="translated">&lt;strong&gt;アルゴリズム&lt;/strong&gt; ：問題を解決するための手順/式</target>
        </trans-unit>
        <trans-unit id="bf91eb2b18b1a94ff6bc8b8c14b3d1250c603cbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;analogy&lt;/strong&gt;: The analogy in this particular case is a jigsaw puzzle: We created a data structure that exploits some property of the data. If our road segments are like puzzle pieces, we group them by matching color and pattern. We then exploit this to avoid doing extra work later (comparing puzzle pieces of like color to each other, not to every other single puzzle piece).</source>
          <target state="translated">&lt;strong&gt;アナロジー&lt;/strong&gt; ：この特定のケースでのアナロジーはジグソーパズルです。データのいくつかのプロパティを利用するデータ構造を作成しました。 道路セグメントがパズルのピースのようなものである場合、色とパターンを一致させることによってそれらをグループ化します。 次に、これを利用して、後で余分な作業を行わないようにします（同じ色のパズルのピースを他のすべてのパズルのピースと比較するのではなく）。</target>
        </trans-unit>
        <trans-unit id="3fd5be370782e9eefda17f79f700c59070a53c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;c log(N)&lt;/strong&gt; &amp;rarr; c log(2N) = (c log(2))+(&lt;strong&gt;c log(N)&lt;/strong&gt;) = (fixed amount)+(&lt;strong&gt;c log(N)&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;c log（N）&lt;/strong&gt; &amp;rarr;c log（2N）=（c log（2））+（ &lt;strong&gt;c log（N）&lt;/strong&gt; ）=（固定量）+（ &lt;strong&gt;c log（N）&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="6bd6f3f7face459b8ad4a2440f178d8320099c60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;c*1&lt;/strong&gt; &amp;rarr; &lt;strong&gt;c*1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;c * 1&lt;/strong&gt; &amp;rarr; &lt;strong&gt;c * 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae34a86dbd8e294559fb6de015a86203c6d6210c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; &amp;rarr; c(2N)&amp;sup3; = 8(&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; &amp;rarr;c（2N）&amp;sup3;= 8（ &lt;strong&gt;cN&amp;sup3;&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="27b5788854d51bd893ea7a5207a2a3c0a233aee4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;complexity:&lt;/strong&gt; if it takes me one second to sort 10,000 elements, how long will it take me to sort one million?  Complexity in this instance is a relative measure to something else.</source>
          <target state="translated">&lt;strong&gt;複雑さ：&lt;/strong&gt; 10,000の要素を並べ替えるのに1秒かかる場合、100万の要素を並べ替えるのにどのくらい時間がかかりますか？ この場合の複雑さは、他のものに対する相対的な尺度です。</target>
        </trans-unit>
        <trans-unit id="5457665c30d0585dc37a4fd244075c3a2b2ad61b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;for &quot;sufficiently&quot; large inputs...&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;「十分に」大きな入力の場合...&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2acb65b1907221e1bdd5284f08ac1b0df4ea0231" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;relative:&lt;/strong&gt; you can only compare apples to apples.  You can't compare an algorithm to do arithmetic multiplication to an algorithm that sorts a list of integers.  But a comparison of two algorithms to do arithmetic operations (one multiplication, one addition) will tell you something meaningful;</source>
          <target state="translated">&lt;strong&gt;相対：&lt;/strong&gt;リンゴとリンゴのみを比較できます。 算術乗算を行うアルゴリズムを、整数のリストをソートするアルゴリズムと比較することはできません。 しかし、算術演算（1つの乗算、1つの加算）を実行する2つのアルゴリズムを比較すると、意味のあることがわかります。</target>
        </trans-unit>
        <trans-unit id="527b57aaeb37446d8c211474a094432da292f875" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;representation:&lt;/strong&gt; Big-O (in its simplest form) reduces the comparison between algorithms to a single variable.  That variable is chosen based on observations or assumptions.  For example, sorting algorithms are typically compared based on comparison operations (comparing two nodes to determine their relative ordering).  This assumes that comparison is expensive.  But what if comparison is cheap but swapping is expensive?  It changes the comparison; and</source>
          <target state="translated">&lt;strong&gt;表現：&lt;/strong&gt; Big-O（最も単純な形式）は、アルゴリズム間の比較を1つの変数に減らします。 その変数は、観察または仮定に基づいて選択されます。 たとえば、並べ替えアルゴリズムは通常、比較演算（2つのノードを比較して相対的な順序を決定する）に基づいて比較されます。 これは、比較にコストがかかることを前提としています。 しかし、比較は安価だがスワッピングが高価な場合はどうでしょうか？ 比較を変更します。 そして</target>
        </trans-unit>
        <trans-unit id="19518fd2e0a8446c92d07859c82f3fdb9396de2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr: The number of handshakes 'looks like' x&amp;sup2; so much for large values, that if we were to write down the ratio #handshakes/x&amp;sup2;, the fact that we don't need &lt;em&gt;exactly&lt;/em&gt; x&amp;sup2; handshakes wouldn't even show up in the decimal for an arbitrarily large while.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tl; dr：大きな値の場合、ハンドシェイクの数はx&amp;sup2;に非常に似ているため、比率＃handshakes /x&amp;sup2;を書き留めると、 &lt;em&gt;正確に&lt;/em&gt; x&amp;sup2;ハンドシェイクが必要ないという事実は表示されません。 10進数で任意の長い間。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc58ee0a287cef32ca985382490b5ed483c76fc8" translate="yes" xml:space="preserve">
          <source>A &amp;rarr; B &amp;rarr; C</source>
          <target state="translated">A&amp;rarr;B&amp;rarr;C</target>
        </trans-unit>
        <trans-unit id="9814460aaaa82f895fab69aa1e7b80cc39fcf625" translate="yes" xml:space="preserve">
          <source>A &amp;rarr; C &amp;rarr; B</source>
          <target state="translated">A&amp;rarr;C&amp;rarr;B</target>
        </trans-unit>
        <trans-unit id="6fa316481ef216118bd579775f4816b14c18a0f7" translate="yes" xml:space="preserve">
          <source>A simple straightforward answer can be:</source>
          <target state="translated">単純明快な答えを言えば</target>
        </trans-unit>
        <trans-unit id="2fa68420a293bc47b500623963e3f939ae51a473" translate="yes" xml:space="preserve">
          <source>A typical implementation might be to open up to the middle, take the 500,000&lt;sup&gt;th&lt;/sup&gt; and compare it to &quot;Smith&quot;. If it happens to be &quot;Smith, John&quot;, we just got real lucky.  Far more likely is that &quot;John Smith&quot; will be before or after that name.  If it's after we then divide the last half of the phone book in half and repeat.  If it's before then we divide the first half of the phone book in half and repeat.  And so on.</source>
          <target state="translated">典型的な実装は、真ん中まで開いて、50万分の&lt;sup&gt;1&lt;/sup&gt;を取り、それを「スミス」と比較することです。 たまたまそれが「スミス、ジョン」だったら、本当にラッキーだった。 「ジョン・スミス」はその名前の前または後に来る可能性がはるかに高い。 それが後である場合は、電話帳の後半を半分に分けて繰り返します。 それが前であれば、電話帳の前半を半分に分けて繰り返します。 等々。</target>
        </trans-unit>
        <trans-unit id="b2eaa9e11c09c682e15e1f9214b1b8f85ad77873" translate="yes" xml:space="preserve">
          <source>Addition is the simplest.  You line the numbers up (to the right) and add the digits in a column writing the last number of that addition in the result.  The 'tens' part of that number is carried over to the next column.</source>
          <target state="translated">足し算は最も簡単です。数字を(右に)並べて、列の中の数字を足して、その足し算の最後の数字を結果に書きます。その数字の「数十」の部分が次の列に繰り越されます。</target>
        </trans-unit>
        <trans-unit id="06a8ddf90a58cac434d9dddb41eadc549d53c934" translate="yes" xml:space="preserve">
          <source>Also keep in mind that due to hidden constraints of your program, you might not really care about asymptotic behavior. You may be working with a bounded number of values, for example:</source>
          <target state="translated">また、プログラムの隠れた制約のために、漸近的な振る舞いはあまり気にしないかもしれないことも覚えておいてください。例えば、制限された数の値を使って作業をしているかもしれません。</target>
        </trans-unit>
        <trans-unit id="580cbd5744ce3d45f6d2b723b41c7344947edda0" translate="yes" xml:space="preserve">
          <source>Although anything &quot;larger&quot; than a constant factor can be detected, however.</source>
          <target state="translated">しかし、一定の要因よりも「大きい」ものは何でも検出されます。</target>
        </trans-unit>
        <trans-unit id="f5bfda3d2781b7d70658d5d11b9d005ba3e1398e" translate="yes" xml:space="preserve">
          <source>Amortized worst-case: If you use an amortized worst-case data structure, the performance is guaranteed to be within the amortized worst-case... eventually (even if the inputs are chosen by an evil demon who knows everything and is trying to screw you over). Usually, we use this to analyze algorithms that may be very 'choppy' in performance with unexpected large hiccups, but over time perform just as well as other algorithms. (However unless your data structure has upper limits for much outstanding work it is willing to procrastinate on, an evil attacker could perhaps force you to catch up on the maximum amount of procrastinated work all-at-once.</source>
          <target state="translated">償却されたワーストケース。償却されたワーストケースのデータ構造を使用した場合、性能は償却されたワーストケース内に収まることが保証されます...最終的には(たとえ入力がすべてを知っていて、あなたを騙そうとする邪悪な悪魔によって選択されたとしても)。通常、私たちはこれを使って、予期せぬ大きなヒックアップを伴う非常に「ぎこちない」性能のアルゴリズムを分析しますが、時間が経つにつれて他のアルゴリズムと同様の性能を発揮することがあります。(ただし、あなたのデータ構造が先延ばしにしても構わないほどの優れた作業の上限を持っていない限り、悪意のある攻撃者は、先延ばしにした作業の最大量を一気に追いつめるように強制することができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="c08025d0af34b0e733dff69c38b8140014e0dcfb" translate="yes" xml:space="preserve">
          <source>And furthermore</source>
          <target state="translated">さらには</target>
        </trans-unit>
        <trans-unit id="6896d57deefe7dcce6486c33a6e908bb66a0f2d5" translate="yes" xml:space="preserve">
          <source>Another point I wanted to make quick mention of is that any algorithm that has a complexity of &lt;strong&gt;O(n&lt;sup&gt;a&lt;/sup&gt;)&lt;/strong&gt; is said to have &lt;strong&gt;polynomial complexity&lt;/strong&gt; or is solvable in &lt;strong&gt;polynomial time&lt;/strong&gt;.</source>
          <target state="translated">もう1つ触れておきたいのは、 &lt;strong&gt;O（n &lt;sup&gt;a&lt;/sup&gt; ）の&lt;/strong&gt;複雑さをもつアルゴリズムは、 &lt;strong&gt;多項式の複雑さ&lt;/strong&gt;を持っていると言われるか、 &lt;strong&gt;多項式時間で&lt;/strong&gt;解けるということです。</target>
        </trans-unit>
        <trans-unit id="18d608bf5ee39a542ef2abc8b2c8aa9502e49075" translate="yes" xml:space="preserve">
          <source>Anyone who's read Programming Pearls or any other Computer Science
  books and doesn&amp;rsquo;t have a grounding in Mathematics will have hit a wall
  when they reached chapters that mention O(N log N) or other seemingly
  crazy syntax. Hopefully this article will help you gain an
  understanding of the basics of Big O and Logarithms.</source>
          <target state="translated">プログラミングパールやその他のコンピュータサイエンスの本を読んでいて、数学の基礎がない人は、O（N log N）やその他の奇妙な構文に言及している章に達したときに壁にぶつかるでしょう。 この記事がBig Oと対数の基本を理解するのに役立つことを願っています。</target>
        </trans-unit>
        <trans-unit id="ca7668976286f5ad8d5eca2a7fadcc44aba0a83b" translate="yes" xml:space="preserve">
          <source>Anyway, that's it for my (hopefully plain English) explanation of Big O (revised).</source>
          <target state="translated">とにかく、私の(できれば平易な英語で)ビッグ・オーの説明は以上です(改訂版)。</target>
        </trans-unit>
        <trans-unit id="010115fea8e63b4e720d7c742f8033325bf02f8e" translate="yes" xml:space="preserve">
          <source>As &lt;em&gt;n&lt;/em&gt; gets arbitrarily large, focus on the terms that will grow the fastest as n gets large (think infinity) AKA &lt;strong&gt;asymptotic analysis&lt;/strong&gt;</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt;が任意に大きくなるとき、nが大きくなると最も速く成長する項に焦点を合わせます（無限大と考えてください）AKA &lt;strong&gt;漸近分析&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="870ad13cbf6243c698d7d2bf03ab24ac0048aa57" translate="yes" xml:space="preserve">
          <source>As a programmer first and a mathematician second (or maybe third or
  fourth) I found the best way to understand Big O thoroughly was to
  produce some examples in code. So, below are some common orders of
  growth along with descriptions and examples where possible.</source>
          <target state="translated">プログラマーであり、数学者である私は、ビッグ・オーを徹底的に理解する最良の方法は、コードの中でいくつかの例を作ることだと考えていました。そこで、以下に一般的な成長の順序を、可能な限り説明と例とともに紹介します。</target>
        </trans-unit>
        <trans-unit id="483f1c4417fdd5afc1f2915ce24ff5ba0f7520e8" translate="yes" xml:space="preserve">
          <source>As a purely mathematical construct, big-O notation is not limited to talking about processing time and memory. You can use it to discuss the asymptotics of anything where scaling is meaningful, such as:</source>
          <target state="translated">純粋に数学的な構成要素として、big-O記法は処理時間やメモリの話に限定されません。スケーリングが意味を持つあらゆるものの漸近性を議論するために使うことができます。</target>
        </trans-unit>
        <trans-unit id="d7f64f73685e6f247cbf73eed79f3d10cdb73567" translate="yes" xml:space="preserve">
          <source>As a result of all this unhelpful complexity, people try to describe the speed of software programs using the smallest and least complex (mathematical) expressions possible. These expressions are very very crude approximations: Although, with a bit of luck, they will capture the &quot;essence&quot; of whether a piece of software is fast or slow.</source>
          <target state="translated">このような役に立たない複雑さの結果として、人々はソフトウェアプログラムの速度を、可能な限り小さくて最も複雑な(数学的な)表現を使って表現しようとします。これらの式は非常に粗雑な近似です。少し運が良ければ、ソフトウェアの一部が速いか遅いかの「本質」を捉えられるでしょう。</target>
        </trans-unit>
        <trans-unit id="7f8315a19f8a52da5d9ef1a40ab83006a844cfd3" translate="yes" xml:space="preserve">
          <source>As it happens, there are certain functions (think of them as &lt;em&gt;implementations&lt;/em&gt; of &lt;strong&gt;X(n)&lt;/strong&gt;) that tend to occur quite often. These are well known and easily compared (Examples: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Log N&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;N^2&lt;/code&gt;, &lt;code&gt;N!&lt;/code&gt;, etc..)</source>
          <target state="translated">偶然にも、非常に頻繁に発生する傾向がある特定の関数（ &lt;strong&gt;X（n）の&lt;/strong&gt; &lt;em&gt;実装&lt;/em&gt;と&lt;strong&gt;見なす&lt;/strong&gt; ）があります。 これらはよく知られており、簡単に比較できます（例： &lt;code&gt;1&lt;/code&gt; 、 &lt;code&gt;Log N&lt;/code&gt; 、 &lt;code&gt;N&lt;/code&gt; 、 &lt;code&gt;N^2&lt;/code&gt; 、 &lt;code&gt;N!&lt;/code&gt; など）。</target>
        </trans-unit>
        <trans-unit id="58635748eb80ad2370517e468a337e1bd88c9cc8" translate="yes" xml:space="preserve">
          <source>As the algorithm scales with n-&lt;em&gt;squared&lt;/em&gt;, this is &lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt; or &lt;strong&gt;quadratic complexity&lt;/strong&gt;. This is a good time to introduce another important concept:</source>
          <target state="translated">アルゴリズムはn- &lt;em&gt;2乗&lt;/em&gt;でスケーリングするため、これは&lt;strong&gt;O（n &lt;sup&gt;2&lt;/sup&gt; ）&lt;/strong&gt;または&lt;strong&gt;2次の複雑度&lt;/strong&gt;です。 これは、別の重要な概念を紹介する良い機会です。</target>
        </trans-unit>
        <trans-unit id="db509c6991e60440b1722a307f8ef3f99bc3043d" translate="yes" xml:space="preserve">
          <source>Assume we're talking about an algorithm &lt;strong&gt;A&lt;/strong&gt;, which should do something with a dataset of size &lt;strong&gt;n&lt;/strong&gt;.</source>
          <target state="translated">サイズ&lt;strong&gt;nの&lt;/strong&gt;データセットで何かを行うアルゴリズム&lt;strong&gt;A&lt;/strong&gt;について話していると仮定します。</target>
        </trans-unit>
        <trans-unit id="5e269fc76f0e879e9586e4d2d5b07a5bf29feecd" translate="yes" xml:space="preserve">
          <source>Asymptotic notation is, at its core, quite separate from programming. Asymptotic notation is a mathematical framework for thinking about how things scale and can be used in many different fields. That said... this is how you &lt;em&gt;apply&lt;/em&gt; asymptotic notation to coding.</source>
          <target state="translated">漸近記法は、その中心において、プログラミングとはまったく別のものです。 漸近記法は、物事がどのようにスケーリングし、多くの異なる分野で使用できるかを考えるための数学的なフレームワークです。 つまり、これは、コーディングに漸近表記を&lt;em&gt;適用する&lt;/em&gt;方法です。</target>
        </trans-unit>
        <trans-unit id="b1fcf30b1f3fc218decd89222f7ae2f077cdd616" translate="yes" xml:space="preserve">
          <source>At some point, at some time, there will be no swaps, and our sort of the deck would be done.  So much work!</source>
          <target state="translated">どこかの時点で、どこかの時点で、スワップはなく、私たちのデッキのソートは完了するでしょう。大変な作業だ!</target>
        </trans-unit>
        <trans-unit id="bfb8cbb068a5baea44b500d50ed4ead05e487564" translate="yes" xml:space="preserve">
          <source>At some point, this loop (from Two to Three) will end.  It ends when both halves of this search meet at the splay card.  Then, we have just splayed the deck with the card you chose in step One.  Now, all the cards near the start are more low than the splay card; and the cards near the end are more high than the splay card.  Cool trick!</source>
          <target state="translated">ある時点で、このループ(TwoからThreeまで)は終了します。この探索の両半分がスプレイカードのところで合流した時点で終了します。そして、ステップ1で選んだカードで山札をスプレイしたところです。これで,最初に近いカードはスプレイカードよりも低く,最後に近いカードはスプレイカードよりも高くなります.クールなトリックです。</target>
        </trans-unit>
        <trans-unit id="6ad9a691d1120dce91af1178eb6b497f4f7e37f7" translate="yes" xml:space="preserve">
          <source>Average-case: We make some assumptions about our inputs; i.e. if our inputs have different probabilities, then our outputs/runtimes will have different probabilities (which we take the average of). Usually, we assume that our inputs are all equally likely (uniform probability), but if the real-world inputs don't fit our assumptions of &quot;average input&quot;, the average output/runtime calculations may be meaningless. If you anticipate uniformly random inputs though, this is useful to think about!</source>
          <target state="translated">平均ケース。つまり、入力が異なる確率を持つ場合、出力ランタイムは異なる確率を持つことになります(その平均を取る)。通常は、入力がすべて同じ確率(一様な確率)であると仮定しますが、実世界の入力が「平均的な入力」という仮定に合わない場合、出力ランタイムの平均計算は無意味なものになる可能性があります。しかし、一様にランダムな入力を想定している場合、これは考えるのに役立ちます!</target>
        </trans-unit>
        <trans-unit id="832a8d90127d5ca48f6556477abd38a77ce36f33" translate="yes" xml:space="preserve">
          <source>B &amp;rarr; A &amp;rarr; C</source>
          <target state="translated">B&amp;rarr;A&amp;rarr;C</target>
        </trans-unit>
        <trans-unit id="d813322c7a347a65c04fed32bbe445579ce7e1e8" translate="yes" xml:space="preserve">
          <source>B &amp;rarr; C &amp;rarr; A</source>
          <target state="translated">B&amp;rarr;C&amp;rarr;A</target>
        </trans-unit>
        <trans-unit id="cc07b18b222d704f4ad25abdb8dc152106fba5a0" translate="yes" xml:space="preserve">
          <source>Back to the telephone book.</source>
          <target state="translated">電話帳に戻る。</target>
        </trans-unit>
        <trans-unit id="56a13e8f97147d6679bf9d3baf62cda1ea3b33ca" translate="yes" xml:space="preserve">
          <source>Back up a bit: the number of handshakes is exactly n-choose-2 or &lt;code&gt;N*(N-1)/2&lt;/code&gt; (each of N people shakes the hands of N-1 other people, but this double-counts handshakes so divide by 2):</source>
          <target state="translated">少しバックアップ：ハンドシェイクの数は、n-choose-2または &lt;code&gt;N*(N-1)/2&lt;/code&gt; （N人はそれぞれ、N-1人の他の人と握手しますが、これはダブルシェイクハンドシェイクなので、 2）：</target>
        </trans-unit>
        <trans-unit id="5120b09510b1d63d87c9c5faa58192336bbcb191" translate="yes" xml:space="preserve">
          <source>Based on the mathematical definition above, if you say your algorithm is a Big O of n, it means it is a function of n (number of input parameters) &lt;strong&gt;or faster&lt;/strong&gt;. If your algorithm is Big O of n, then it is also automatically the Big O of n square.</source>
          <target state="translated">上記の数学的な定義に基づいて、アルゴリズムがnのBig Oであると言う場合、それはn（入力パラメーターの数） &lt;strong&gt;以上の&lt;/strong&gt;関数であることを意味します。 アルゴリズムがnのBig Oである場合、それは自動的にnのBig Oの正方形にもなります。</target>
        </trans-unit>
        <trans-unit id="db284bf74073477f62953e8e8e02b1401e213f94" translate="yes" xml:space="preserve">
          <source>Because they are approximations, we use the letter &quot;O&quot; (Big Oh) in the expression, as a convention to signal to the reader that we are making a gross oversimplification. (And to make sure that nobody mistakenly thinks that the expression is in any way accurate).</source>
          <target state="translated">これらは近似値であるため、我々は、我々が粗雑な単純化をしていることを読者に合図するための慣例として、式の中で &quot;O&quot;(ビッグ・オー)という文字を使用しています(そして、誰もこの式が正確であると誤解する人がいないことを確認してください)。(そして、この式が正確であると誤解している人がいないことを確認するためです)。</target>
        </trans-unit>
        <trans-unit id="ac9bfd81f5e9c61b91f03629f317cefc5ed3f40a" translate="yes" xml:space="preserve">
          <source>Best-Case: the key is the first item.</source>
          <target state="translated">ベストケース:鍵は最初の項目です。</target>
        </trans-unit>
        <trans-unit id="8871063a9de2c96323fce812e3e16047b1b9b0c8" translate="yes" xml:space="preserve">
          <source>Big O comes in and says: for a deck of n cards, to sort it this way will be done in O(N squared) time.</source>
          <target state="translated">ビッグ・オーが入ってきて、次のように言っています:n枚のカードの山を、このように並べ替えるのは、O(N乗)の時間で行われます。</target>
        </trans-unit>
        <trans-unit id="e28ca34381715acfd2716526a419b0f386a39327" translate="yes" xml:space="preserve">
          <source>Big O complexity can be visualized with this graph:</source>
          <target state="translated">ビッグ・オーの複雑さは、このグラフで可視化することができます。</target>
        </trans-unit>
        <trans-unit id="01191d73dc858c84e96603e205ce6cf90b305595" translate="yes" xml:space="preserve">
          <source>Big O describes an upper limit on the growth behaviour of a function, for example the runtime of a program, when inputs become large.</source>
          <target state="translated">Big Oは、入力が大きくなったときの関数の成長挙動、例えばプログラムの実行時間の上限を記述しています。</target>
        </trans-unit>
        <trans-unit id="6d6c6ee7d49379298994bf2d0373e24c46b6260e" translate="yes" xml:space="preserve">
          <source>Big O does not solve the work for us.  Big O tells us how hard the work is.</source>
          <target state="translated">ビッグオーが仕事を解決してくれるわけではありません。ビッグオーは仕事の大変さを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="067d8c2c09524ec3079760262aecc198a00b16eb" translate="yes" xml:space="preserve">
          <source>Big O ignores factors that do not contribute in a meaningful way to the growth curve of a function as the input size increases towards infinity. This means that constants that are added to or multiplied by the function are simply ignored.</source>
          <target state="translated">Big O は、入力サイズが無限大に向かって大きくなるにつれて、関数の成長曲線に意味のある形で寄与しない要因を無視します。これは、関数に追加されたり、関数によって乗算されたりする定数は単純に無視されることを意味します。</target>
        </trans-unit>
        <trans-unit id="5ef0b065d98e11f17dc80d42a717ef47eb65fe1e" translate="yes" xml:space="preserve">
          <source>Big O is a measure of how much time/space an algorithm uses relative to the size of its input.</source>
          <target state="translated">Big O は、アルゴリズムが入力のサイズに対してどのくらいのタイムスペースを使用しているかを示す指標です。</target>
        </trans-unit>
        <trans-unit id="7e04dd1651f885b1cee3374bf9f1eb929407c8c2" translate="yes" xml:space="preserve">
          <source>Big O is just a way to &quot;Express&quot; yourself in a common way, &quot;How much time / space does it take to run my code?&quot;.</source>
          <target state="translated">ビッグオーは、「自分のコードを実行するのにどれだけの時間空間が必要か」という、ありきたりな方法で自分を「表現」するためのものに過ぎません。</target>
        </trans-unit>
        <trans-unit id="615e13e08dc48881c60e9af49cb00312f337463a" translate="yes" xml:space="preserve">
          <source>Big O is useful to compare how well two algorithms will scale up as the number of inputs is increased.</source>
          <target state="translated">ビッグオーは、2つのアルゴリズムが入力数を増やすとどれだけスケールアップするかを比較するのに便利です。</target>
        </trans-unit>
        <trans-unit id="d8cd4344a90d7e5c64b849cbdbe8173c868330b0" translate="yes" xml:space="preserve">
          <source>Big O is your friend and mine.  Big O helps us think on how much work we have to do, so we can plan.  And, if we are friends with big O, he can help us choose work that is not so hard!</source>
          <target state="translated">ビッグ・オーはあなたの友人であり、私の友人でもあります。ビッグ・オーは、どのくらいの仕事をしなければならないのかを考えてくれるので、計画を立てることができます。また、ビッグ・オーと友達になれば、それほど大変ではない仕事を選んでくれるようになります</target>
        </trans-unit>
        <trans-unit id="63a54321034901fba163b3e5364e8adebdcce5cc" translate="yes" xml:space="preserve">
          <source>Big O notation also shines a spotlight directly on the most important principle of computer programming/engineering, the fact which inspires all good programmers to keep thinking and dreaming: the only way to achieve results beyond the slow forward march of technology is to &lt;em&gt;invent a better algorithm&lt;/em&gt;.</source>
          <target state="translated">Big O表記はまた、コンピュータープログラミング/エンジニアリングの最も重要な原則に直接スポットライトを当てています。この事実は、優れたプログラマー全員が考え、夢を持ち続けるように促します。テクノロジーの進歩を遅らせて結果を達成する唯一の方法は&lt;em&gt;、より優れたもの&lt;/em&gt;を&lt;em&gt;発明することです。アルゴリズム&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a168ec8cf3b032681504a8e27d40ac24591c31bc" translate="yes" xml:space="preserve">
          <source>Big O notation is a way of describing how quickly an algorithm will run given an arbitrary number of input parameters, which we'll call &quot;n&quot;. It is useful in computer science because different machines operate at different speeds, and simply saying that an algorithm takes 5 seconds doesn't tell you much because while you may be running a system with a 4.5 Ghz octo-core processor, I may be running a 15 year old, 800 Mhz system, which could take longer regardless of the algorithm. So instead of specifying how fast an algorithm runs in terms of time, we say how fast it runs in terms of number of input parameters, or &quot;n&quot;. By describing algorithms in this way, we are able to compare the speeds of algorithms without having to take into account the speed of the computer itself.</source>
          <target state="translated">Big O 記法は、任意の数の入力パラメータ(ここでは「n」と呼ぶ)を与えられたときに、アルゴリズムがどれだけ速く実行されるかを記述する方法です。これは、異なるマシンが異なる速度で動作するため、コンピュータサイエンスにおいて有用です。あなたが4.5 Ghzのオクトコアプロセッサを搭載したシステムを実行していても、私が15年前の800 Mhzのシステムを実行していても、アルゴリズムに関係なく時間がかかる可能性があるからです。そこで、アルゴリズムがどれだけ速く動くかを時間で指定するのではなく、入力パラメータの数、つまり &quot;n &quot;でどれだけ速く動くかを表現しています。このようにアルゴリズムを記述することで、コンピュータ自体の速度を考慮することなく、アルゴリズムの速度を比較することができます。</target>
        </trans-unit>
        <trans-unit id="4b0a116919ddeacd83d71ce31ad376da360a026c" translate="yes" xml:space="preserve">
          <source>Big O notation is a way of describing the upper bound of an algorithm in terms of space or running time.  The n is the number of elements in the the problem (i.e size of an array, number of nodes in a tree, etc.)  We are interested in describing the running time as n gets  big.</source>
          <target state="translated">ビッグオー表記法は、アルゴリズムの上限を空間または実行時間で記述する方法です。n は問題の要素数(配列のサイズや木のノード数など)です。</target>
        </trans-unit>
        <trans-unit id="4c8f74fc1bdc10685b2177c45ec160d36cadb907" translate="yes" xml:space="preserve">
          <source>Big O notation is most commonly used by programmers as an approximate measure of how long a computation (algorithm) will take to complete expressed as a function of the size of the input set.</source>
          <target state="translated">Big O 記法は、入力集合のサイズの関数として表現され、計算(アルゴリズム)が完了するまでにどれくらいの時間がかかるかの近似的な尺度として、プログラマーによって最も一般的に使用されています。</target>
        </trans-unit>
        <trans-unit id="35d0c4e9b1c9e1dda535f62f93fc8e1e6b9b14c1" translate="yes" xml:space="preserve">
          <source>Big O notation is used in Computer Science to describe the performance
  or complexity of an algorithm. Big O specifically describes the
  worst-case scenario, and can be used to describe the execution time
  required or the space used (e.g. in memory or on disk) by an
  algorithm.</source>
          <target state="translated">コンピュータサイエンスでは、アルゴリズムの性能や複雑さを表現するためにビッグオー表記法が使用されています。ビッグ・オーは、特に最悪のケースのシナリオを記述するもので、アルゴリズムが必要とする実行時間や使用するスペース(メモリやディスク上など)を記述するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="029dd5426c412001fb487f1ee4fae8a55e3c8c3b" translate="yes" xml:space="preserve">
          <source>Big O notation simply tells how much time* an algorithm can run within,
  in terms of &lt;em&gt;only the amount of input data&lt;/em&gt;**.</source>
          <target state="translated">Big O表記&lt;em&gt;は、入力データの量のみの&lt;/em&gt;観点から、アルゴリズムが実行できる時間*を単純に伝えます。</target>
        </trans-unit>
        <trans-unit id="ac3a3f5b5b610616ecbb8b264905e5ee4de505c6" translate="yes" xml:space="preserve">
          <source>Big O notation tells you the cost of solving an infinitely large problem.</source>
          <target state="translated">ビッグオー記法は、無限に大きな問題を解くためのコストを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="f4998d7a032917937335ae6425e4667cbea54bd2" translate="yes" xml:space="preserve">
          <source>Big O of n means my algorithm runs at least as fast as this. You cannot look at Big O notation of your algorithm and say its slow. You can only say its fast.</source>
          <target state="translated">nのBig Oは、私のアルゴリズムが少なくともこれと同じくらい速く実行されることを意味します。あなたのアルゴリズムの Big O 記法を見て、そのアルゴリズムが遅いと言うことはできません。速いと言うことができるだけです</target>
        </trans-unit>
        <trans-unit id="2aabaf3aedb4e0aa46fb4d5ff8c2ab4e6073ca94" translate="yes" xml:space="preserve">
          <source>Big O points out this: as n gets big, when we sort cards, the job gets MUCH MUCH MORE HARD than the old just-add-these-things job.  How do we know this?</source>
          <target state="translated">Big Oはこれを指摘している:nが大きくなるにつれて、我々はカードをソートするとき、ジョブは昔のちょうど追加するだけのものの仕事よりもはるかに多くのハードを取得します。どのように我々はこれを知っていますか?</target>
        </trans-unit>
        <trans-unit id="93a1b436d9d2b6befbc854db9c969659b8e5b77f" translate="yes" xml:space="preserve">
          <source>Big O represents the worst possible time/space for that algorithm. The algorithm will never take more space/time above that limit. Big O represents time/space complexity in the extreme case.</source>
          <target state="translated">ビッグ・オーは、そのアルゴリズムにとって最悪の時空を表しています。このアルゴリズムは、その限界を超える時空を取ることはありません。Big Oは、極端な場合の時空の複雑さを表しています。</target>
        </trans-unit>
        <trans-unit id="2897bc170748c75b1afb0452b1633a9f90eeaa23" translate="yes" xml:space="preserve">
          <source>Big O says: we must do six adds to solve this.  One add, for each thing from one to six.  Six small bits of work... each bit of work is one add.</source>
          <target state="translated">ビッグ・オーは言う:この問題を解くには6つの足し算をしなければならない。1から6までのそれぞれのものに 1つの足し算をします 6つの小さな作業...それぞれの作業のビットは1つの足し算です。</target>
        </trans-unit>
        <trans-unit id="01a1c3b9e0eae37b04b930c9e959423669d00b8b" translate="yes" xml:space="preserve">
          <source>Big O tells us that to sort things is more hard than to add things.  O(n squared) is more than O(n) for big n.  That means: if n gets real big, to sort a mixed deck of n things MUST take more time, than to just add n mixed things.</source>
          <target state="translated">Oの大きさは、物事を並べ替えるのは、物事を加えるよりも難しいことを教えてくれます。つまり、もしnが本当に大きくなったら、n個のものが混ざったデッキを並べ替えるのは、n個のものを足すよりも時間がかかるということです。</target>
        </trans-unit>
        <trans-unit id="ff2337e8063fec003cbedd7750338ff7fc025f36" translate="yes" xml:space="preserve">
          <source>Big O, help me!</source>
          <target state="translated">ビッグ・オー 助けて!</target>
        </trans-unit>
        <trans-unit id="f0939bd08a02841e66e2310a89ddfeb9c0a7055e" translate="yes" xml:space="preserve">
          <source>Big-&amp;Omega; (Big-Omega) notation (article) | Khan Academy</source>
          <target state="translated">Big-&amp;Omega;（Big-Omega）表記（記事）| カーンアカデミー</target>
        </trans-unit>
        <trans-unit id="9ffc7ec8bbe6223b3d70e4376f89b6eab1b1a639" translate="yes" xml:space="preserve">
          <source>Big-O notation (also called &quot;asymptotic growth&quot; notation) is &lt;em&gt;what functions &quot;look like&quot; when you ignore constant factors and stuff near the origin&lt;/em&gt;. We use it to talk about &lt;strong&gt;how thing scale&lt;/strong&gt;.</source>
          <target state="translated">Big-O表記法（「漸近的成長」表記法とも呼ばれ&lt;em&gt;ます&lt;/em&gt; ）は&lt;em&gt;、原点付近の一定の要因やものを無視した場合に機能する「外観」です&lt;/em&gt; 。 &lt;strong&gt;どのようにスケールするかを説明&lt;/strong&gt;するために使用します。</target>
        </trans-unit>
        <trans-unit id="1769664f1e1ca72f099882bf25e7d2f39574cca3" translate="yes" xml:space="preserve">
          <source>Big-O, is &lt;strong&gt;rate of increase&lt;/strong&gt; of resource consumed by program, w.r.t. problem-instance-size</source>
          <target state="translated">Big-Oは、プログラムによって消費されるリソース&lt;strong&gt;の増加率です&lt;/strong&gt; 。wrtproblem-instance-size</target>
        </trans-unit>
        <trans-unit id="a380e8c171aa6d7e586e8f15b66e52968c776a75" translate="yes" xml:space="preserve">
          <source>Binary search is a technique used to search sorted data sets. It works
  by selecting the middle element of the data set, essentially the
  median, and compares it against a target value. If the values match it
  will return success. If the target value is higher than the value of
  the probe element it will take the upper half of the data set and
  perform the same operation against it. Likewise, if the target value
  is lower than the value of the probe element it will perform the
  operation against the lower half. It will continue to halve the data
  set with each iteration until the value has been found or until it can
  no longer split the data set.</source>
          <target state="translated">バイナリ検索は、ソートされたデータセットを検索するために使用される手法です。これは、データセットの真ん中の要素、本質的に中央値を選択し、目標値と比較することで動作します。値が一致すれば成功を返します。目標値がプローブ要素の値よりも高い場合は、データセットの上半分の要素を選択し、それに対して同じ操作を行います。同様に、ターゲット値がプローブ要素の値よりも低い場合は、下半分のデータに対して操作を実行します。値が見つかるまで、またはデータセットを分割できなくなるまで、反復するたびにデータセットを半分に分割し続けます。</target>
        </trans-unit>
        <trans-unit id="84e2d5bd3333a554d3c328ae36cecdeea3f085c1" translate="yes" xml:space="preserve">
          <source>Both average-case and amortization are incredibly useful tools for thinking about and designing with scaling in mind.</source>
          <target state="translated">アベレージケースも償却も、スケーリングを念頭に置いて考えたり、設計したりするための非常に便利なツールです。</target>
        </trans-unit>
        <trans-unit id="81fa41afe9d47413eda0c47da5969d56124c07cf" translate="yes" xml:space="preserve">
          <source>But remember, Big O is just a way to experss yourself in the manner of time and space.</source>
          <target state="translated">しかし、ビッグオーは、時間と空間の方法で自分自身をexperssするだけの方法であることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="3ddd3cf4c5b5b439921cdd63b830507cc2d92e01" translate="yes" xml:space="preserve">
          <source>But though we will not do the work now, we can guess how hard it would be, if we knew n.  We would have to add up n things, right?  Of course!</source>
          <target state="translated">でも、今はやらないけど、nを知っていれば、どれだけ大変なことか想像がつきます。そうだよね。</target>
        </trans-unit>
        <trans-unit id="de004be9935e007a2aa4a8dd96ba9ccf3e285c6c" translate="yes" xml:space="preserve">
          <source>But, programmers don't think like this because eventually, algorithm intuition just becomes second nature. You will start to code something inefficient and immediately think &quot;am I doing something &lt;strong&gt;grossly inefficient?&lt;/strong&gt;&quot;. If the answer is &quot;yes&quot; AND you foresee it actually mattering, then you can take a step back and think of various tricks to make things run faster (the answer is almost always &quot;use a hashtable&quot;, rarely &quot;use a tree&quot;, and very rarely something a bit more complicated).</source>
          <target state="translated">しかし、プログラマーはこのように考えません。結局のところ、アルゴリズムの直観は、まさに第二の性質になるからです。 あなたは非効率的なものをコーディングし始め、すぐに「私は何か&lt;strong&gt;非常に非効率的な&lt;/strong&gt;ことをしてい&lt;strong&gt;ますか？&lt;/strong&gt; 」と考えます。 答えが「はい」であり、それが実際に重要であると思われる場合は、一歩下がってさまざまなトリックを考え、処理を高速化できます（ほとんどの場合、答えは「ハッシュテーブルを使用する」、まれに「ツリーを使用する」、非常にまれに、もう少し複雑なもの）。</target>
        </trans-unit>
        <trans-unit id="0d8f8969e0785f14a21dfca5ea753a20c18775cc" translate="yes" xml:space="preserve">
          <source>By comparing these when talking about &lt;strong&gt;A&lt;/strong&gt; and other algorithms, it is easy to rank the algorithms according to the number of operations they &lt;em&gt;may&lt;/em&gt; (worst-case) require to complete.</source>
          <target state="translated">&lt;strong&gt;A&lt;/strong&gt;および他のアルゴリズムについて話すときにこれらを比較することにより、（最悪の場合）完了する必要のある操作の数に従ってアルゴリズムをランク付けするのは簡単です。</target>
        </trans-unit>
        <trans-unit id="0d58ba7567f14e061427da47056514f59b5370bc" translate="yes" xml:space="preserve">
          <source>By the way, here is for comparison the definition of small o.</source>
          <target state="translated">ところで、ここでは、比較のために小さなOの定義です。</target>
        </trans-unit>
        <trans-unit id="cbb489069914d301d52853c36730ee0f0e267708" translate="yes" xml:space="preserve">
          <source>C &amp;rarr; A &amp;rarr; B</source>
          <target state="translated">C&amp;rarr;A&amp;rarr;B</target>
        </trans-unit>
        <trans-unit id="6998b04e08785bbdf1c7af58eecf38c1a28d31da" translate="yes" xml:space="preserve">
          <source>C &amp;rarr; B &amp;rarr; A</source>
          <target state="translated">C&amp;rarr;B&amp;rarr;A</target>
        </trans-unit>
        <trans-unit id="6cbbd09b2268ff81c9d2447ddd6efd0ece964c0a" translate="yes" xml:space="preserve">
          <source>Calculate how much time (regarding input size) the worst case takes:</source>
          <target state="translated">最悪の場合にどれくらいの時間がかかるか(入力サイズに関して)を計算します。</target>
        </trans-unit>
        <trans-unit id="12668f37b6831ee2e32bd194cd1af2fa68690568" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;https://www.youtube.com/watch?v=V1xXmQkzkZI&amp;amp;index=13&amp;amp;list=PLZBP-86GmPTxpbvoFFzad0qYw5dKA8MV2&quot;&gt;this&lt;/a&gt; out for a video tutorial on Big O from UC Berkley. It's is actually a simple concept. If you hear professor Shewchuck (aka God level teacher) explaining it, you will say &quot;Oh that's all it is!&quot;.</source>
          <target state="translated">カリフォルニア大学バークレー校のBig Oに関するビデオチュートリアルについては、 &lt;a href=&quot;https://www.youtube.com/watch?v=V1xXmQkzkZI&amp;amp;index=13&amp;amp;list=PLZBP-86GmPTxpbvoFFzad0qYw5dKA8MV2&quot;&gt;こちらを&lt;/a&gt;ご覧ください。 それは実際には単純な概念です。 Shewchuck教授（別名神レベルの教師）が説明しているのを聞くと、「ああ、それだけです！」と言うでしょう。</target>
        </trans-unit>
        <trans-unit id="b4523b29b5c7ed6f8c2abc5e9a4c38da02d06afc" translate="yes" xml:space="preserve">
          <source>Come back and reread the above when you've read the rest.</source>
          <target state="translated">続きを読んだらまた来てください。</target>
        </trans-unit>
        <trans-unit id="55a7f0d03a20d7e0d958646e51faf45416912637" translate="yes" xml:space="preserve">
          <source>Compare 1 and 6, which is biggest? Ok 6 is in the right position, moving forward!</source>
          <target state="translated">1と6を比較して、どちらが大きい?OK 6は正しい位置にある 前進!</target>
        </trans-unit>
        <trans-unit id="1c5884fcffc252b00f765da994d3959a5bea1cc4" translate="yes" xml:space="preserve">
          <source>Compare 6 and 3, oh, 3 is less! Let's move that, Ok the list changed, we need to start from the begining now!</source>
          <target state="translated">6と3を比較して、ああ、3は少ないです!それを移動させましょう、リストが変更されました、私たちは今、初心者から始める必要があります!</target>
        </trans-unit>
        <trans-unit id="b5ae65887f49fb01b8aa1e42c87a37e72b0918ca" translate="yes" xml:space="preserve">
          <source>Compare &lt;em&gt;how quickly runtime grows&lt;/em&gt;&lt;strong&gt;NOT&lt;/strong&gt;&lt;em&gt;compare exact runtimes&lt;/em&gt; (depends on hardware)</source>
          <target state="translated">&lt;em&gt;ランタイムの成長&lt;/em&gt; &lt;strong&gt;速度を&lt;/strong&gt; &lt;em&gt;比較し、正確なランタイムを比較し&lt;/em&gt; &lt;strong&gt;ない&lt;/strong&gt; （ハードウェアに依存）</target>
        </trans-unit>
        <trans-unit id="3d11d48dee34717db426c8a89bfdced368207e28" translate="yes" xml:space="preserve">
          <source>Comparison between average-case and amortized worst-case:</source>
          <target state="translated">平均ケースと償却ワーストケースの比較。</target>
        </trans-unit>
        <trans-unit id="ad8df7363e12666a15da250cd1535079ed8d98cb" translate="yes" xml:space="preserve">
          <source>Consider the canonical sorting example. Bubble-sort is O(n&lt;sup&gt;2&lt;/sup&gt;) while merge-sort is O(n log n). Let's say you have two sorting applications, application A which uses bubble-sort and application B which uses merge-sort, and let's say that for input sizes of around 30 elements application A is 1,000x faster than application B at sorting. If you never have to sort much more than 30 elements then it's obvious that you should prefer application A, as it is much faster at these input sizes. However, if you find that you may have to sort ten million items then what you'd expect is that application B actually ends up being thousands of times faster than application A in this case, entirely due to the way each algorithm scales.</source>
          <target state="translated">正規のソートの例を考えてみましょう。 バブルソートはO（n &lt;sup&gt;2&lt;/sup&gt; ）で、マージソートはO（n log n）です。 たとえば、バブルソートを使用するアプリケーションAとマージソートを使用するアプリケーションBの2つの並べ替えアプリケーションがあり、約30要素の入力サイズの場合、アプリケーションAはアプリケーションBよりも並べ替えで1,000倍高速であるとします。 30を超える要素を並べ替える必要がない場合は、アプリケーションAを選択する必要があります。これは、これらの入力サイズではるかに高速であるためです。 ただし、1,000万個のアイテムを並べ替える必要がある場合は、各アルゴリズムのスケーリング方法が原因で、アプリケーションBが実際にはアプリケーションAより数千倍高速になることが予想されます。</target>
        </trans-unit>
        <trans-unit id="a7c2b8ba88bf46f0dfe0a0ff9f1b26cb00f3ba83" translate="yes" xml:space="preserve">
          <source>Consider the difference between a steam engine and a rocket. They are not merely different varieties of the same thing (as, say, a Prius engine vs. a Lamborghini engine) but they are dramatically different kinds of propulsion systems, at their core. A steam engine may be faster than a toy rocket, but no steam piston engine will be able to achieve the speeds of an orbital launch vehicle. This is because these systems have different scaling characteristics with regards to the relation of fuel required (&quot;resource usage&quot;) to reach a given speed (&quot;input size&quot;).</source>
          <target state="translated">蒸気機関とロケットの違いを考えてみましょう。これらのエンジンは、単に同じものの異なる品種(例えば、プリウスのエンジンとランボルギーニのエンジンのように)ではなく、その中核をなす推進システムの劇的に異なる種類のものです。蒸気エンジンはおもちゃのロケットより速いかもしれませんが、軌道上のロケットの速度を達成できる蒸気ピストンエンジンはありません。なぜなら、これらのシステムは、ある速度に到達するために必要な燃料(「資源の使用量」)の関係(「入力サイズ」)に関して、異なるスケーリング特性を持っているからです。</target>
        </trans-unit>
        <trans-unit id="6a8cfee71662bf83fd7610d0447480c8f098dc3b" translate="yes" xml:space="preserve">
          <source>Constant factors are negligible</source>
          <target state="translated">定数要因は無視できる</target>
        </trans-unit>
        <trans-unit id="0da1286a9bca7edf66b07ff225ea54f102d5a653" translate="yes" xml:space="preserve">
          <source>Depending on N and X, your algorithm will require some operations, for example in the WORST case it's &lt;code&gt;3(N^2) + log(X)&lt;/code&gt; operations.</source>
          <target state="translated">NとXに応じて、アルゴリズムにはいくつかの演算が必要になります。たとえば、WORSTの場合、 &lt;code&gt;3(N^2) + log(X)&lt;/code&gt; 演算になります。</target>
        </trans-unit>
        <trans-unit id="f8e74a3a562ba5774725315dfe1782d1a1275af0" translate="yes" xml:space="preserve">
          <source>Does not scale.  You have no hope of solving any non-trivially sized problem.  Useful for knowing what to avoid, and for experts to find approximate algorithms which are in &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt;.</source>
          <target state="translated">スケーリングしません。 重要なサイズの問題を解決することはできません。 何を避けるべきかを知るのに、そして専門家が&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; &lt;sup&gt;k&lt;/sup&gt; ）に&lt;/strong&gt;ある近似アルゴリズムを見つけるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c81313d6a9457c1a28868d8aaaff914cf1b3213c" translate="yes" xml:space="preserve">
          <source>Does this make a hashtable faster than an array for lookups? Not necessarily. If you've got a very small collection of entries, an array may well be faster &amp;mdash; you may be able to check all the strings in the time that it takes to just calculate the hashcode of the one you're looking at. As the data set grows larger, however, the hashtable will eventually beat the array.</source>
          <target state="translated">これにより、ハッシュテーブルが配列のルックアップよりも速くなりますか？ 必ずしも。 エントリのコレクションが非常に少ない場合は、配列の方がはるかに高速です。見ているもののハッシュコードを計算するのにかかる時間ですべての文字列を確認できる場合があります。 ただし、データセットが大きくなるにつれて、ハッシュテーブルは最終的に配列を上回ります。</target>
        </trans-unit>
        <trans-unit id="38f6893266ac6c8513618653e41d6736baa03b7c" translate="yes" xml:space="preserve">
          <source>EDIT: Quick note, this is almost certainly confusing &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; (which is an upper bound) with Theta notation (which is both an upper and lower bound). In my experience this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</source>
          <target state="translated">編集：クイックノート、これはほぼ確実に&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O表記&lt;/a&gt; （上限）とTheta表記（上限と下限の両方）を混同しています。 私の経験では、これは実際には非学術的な設定での議論の典型です。 混乱を招きましたことをお詫び申し上げます。</target>
        </trans-unit>
        <trans-unit id="c8861868012e671e5ca7903151be427897869332" translate="yes" xml:space="preserve">
          <source>Each of these is an operation or a problem.  A method of solving these is called an &lt;strong&gt;algorithm&lt;/strong&gt;.</source>
          <target state="translated">これらはそれぞれ操作または問題です。 これらを解く方法を&lt;strong&gt;アルゴリズム&lt;/strong&gt;といい&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="b62541479f03733e3001473267dd14900d0760bc" translate="yes" xml:space="preserve">
          <source>Ergh.  That sounds like a lot of work!</source>
          <target state="translated">えー。大変そうだな!</target>
        </trans-unit>
        <trans-unit id="b6dc6935629b7d3402db5c466e6d14aa566e6056" translate="yes" xml:space="preserve">
          <source>Estimates how many steps of the method your computer applies to accomplish a task.</source>
          <target state="translated">コンピュータがタスクを達成するために適用する方法のステップ数を推定します。</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">例2.</target>
        </trans-unit>
        <trans-unit id="1d4166bf97179d81c42dccef3ab9d1594a5dec5d" translate="yes" xml:space="preserve">
          <source>Example 3:</source>
          <target state="translated">例3.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="184ce50741de2b5a2d508d5c7f7deb72ee16f548" translate="yes" xml:space="preserve">
          <source>Facilitate the process to compare with others in order to determine whether it's good or not?</source>
          <target state="translated">良いか悪いかを判断するために他の人と比較するプロセスを促進する?</target>
        </trans-unit>
        <trans-unit id="8b846e7060b9a483588329ba98d3b24f7db5b0ed" translate="yes" xml:space="preserve">
          <source>For 1,000,000 it takes 20.</source>
          <target state="translated">100万の場合は20が必要です。</target>
        </trans-unit>
        <trans-unit id="bfc4a756390564c98c0f9ee2960940b370613e43" translate="yes" xml:space="preserve">
          <source>For 15 it takes 4.</source>
          <target state="translated">15の場合は4が必要です。</target>
        </trans-unit>
        <trans-unit id="c4dcc93d74ce33740712a8b30e5dfa1a16cc492d" translate="yes" xml:space="preserve">
          <source>For 7 it takes at most 3.</source>
          <target state="translated">7の場合はせいぜい3が必要です。</target>
        </trans-unit>
        <trans-unit id="8387ae59db1ca9e3e2f91943f6392088dfd4aa1a" translate="yes" xml:space="preserve">
          <source>For a phone book of 3 names it takes 2 comparisons (at most).</source>
          <target state="translated">3つの名前の電話帳の場合は、2つの比較が必要です(多くても)。</target>
        </trans-unit>
        <trans-unit id="5052922ba19448289d5da9158883ce125e05b963" translate="yes" xml:space="preserve">
          <source>For big n, n squared is more large than n.</source>
          <target state="translated">大きなnの場合は、nの2乗がnよりも大きい。</target>
        </trans-unit>
        <trans-unit id="e5054e967dbdba1361ba3fb55414b378a8efdbff" translate="yes" xml:space="preserve">
          <source>For completeness, the precise definition of big-O notation is as follows: &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; means that &quot;f is asymptotically upper-bounded by const*g&quot;: ignoring everything below some finite value of x, there exists a constant such that &lt;code&gt;|f(x)| &amp;le; const * |g(x)|&lt;/code&gt;. (The other symbols are as follows: just like &lt;code&gt;O&lt;/code&gt; means &amp;le;, &lt;code&gt;&amp;Omega;&lt;/code&gt; means &amp;ge;. There are lowercase variants: &lt;code&gt;o&lt;/code&gt; means &amp;lt;, and &lt;code&gt;&amp;omega;&lt;/code&gt; means &amp;gt;.) &lt;code&gt;f(x) &amp;isin; Ɵ(g(x))&lt;/code&gt; means both &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; and &lt;code&gt;f(x) &amp;isin; &amp;Omega;(g(x))&lt;/code&gt; (upper- and lower-bounded by g): there exists some constants such that f will always lie in the &quot;band&quot; between &lt;code&gt;const1*g(x)&lt;/code&gt; and &lt;code&gt;const2*g(x)&lt;/code&gt;. It is the strongest asymptotic statement you can make and roughly equivalent to &lt;code&gt;==&lt;/code&gt;. (Sorry, I elected to delay the mention of the absolute-value symbols until now, for clarity's sake; especially because I have never seen negative values come up in a computer science context.)</source>
          <target state="translated">完全を期すため、big-O表記の正確な定義は次のとおりです &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; は、「fはconst * gによって漸近的に上限がある」ことを意味します：xの有限値より下のすべてを無視します、 &lt;code&gt;|f(x)| &amp;le; const * |g(x)|&lt;/code&gt; ような定数が存在します &amp;le;const * | g（x）| 。 （他の記号は次のとおりです： &lt;code&gt;O&lt;/code&gt; が &amp;le;を意味するように、 &lt;code&gt;&amp;Omega;&lt;/code&gt; は&amp;ge;を意味します。小文字のバリエーションがあります： &lt;code&gt;o&lt;/code&gt; は&amp;lt;を意味し、 &lt;code&gt;&amp;omega;&lt;/code&gt; は&amp;gt;を意味します。） &lt;code&gt;f(x) &amp;isin; Ɵ(g(x))&lt;/code&gt; は両方の &lt;code&gt;f(x) &amp;isin; O(g(x))&lt;/code&gt; および &lt;code&gt;f(x) &amp;isin; &amp;Omega;(g(x))&lt;/code&gt; 上限と下限）：fが常に &lt;code&gt;const1*g(x)&lt;/code&gt; 間の「バンド」にあるような定数が存在します* g（x）および &lt;code&gt;const2*g(x)&lt;/code&gt; 。 これは、作成できる最強の漸近ステートメントであり、おおよそ &lt;code&gt;==&lt;/code&gt; と同等です。 （申し訳ありませんが、明確にするために、絶対値記号の説明をこれまで延期することを選択しました。特に、コンピューターサイエンスのコンテキストで負の値が表示されるのを見たことがないためです。）</target>
        </trans-unit>
        <trans-unit id="49654e3774111fb16128651b4d224ad6b75c2b89" translate="yes" xml:space="preserve">
          <source>For example, say you had the latitude and longitude coordinates of millions of road segments and wanted to find all street intersections.</source>
          <target state="translated">例えば、何百万もの道路セグメントの緯度経度座標を持っていて、すべての道路の交差点を見つけたいとします。</target>
        </trans-unit>
        <trans-unit id="b3611110a9125b6ab52f37ddd431b3585818e9dd" translate="yes" xml:space="preserve">
          <source>For input of size &quot;n&quot; the program is growing at speed of &quot;n&quot; iterations in array. Hence Big-O is N expressed as  O(n)</source>
          <target state="translated">サイズ &quot;n &quot;の入力に対して、プログラムは配列の中で &quot;n &quot;の反復の速度で成長しています。したがって、Big-OはO(n)で表されるNである。</target>
        </trans-unit>
        <trans-unit id="09e7373f604bf7164bb0dca1297d67c519bcfba7" translate="yes" xml:space="preserve">
          <source>For input of size &quot;n&quot; the program is growing at speed of &quot;n*n&quot; iterations in array. Hence Big-O is N&lt;sup&gt;2&lt;/sup&gt; expressed as  O(n&lt;sup&gt;2&lt;/sup&gt;)</source>
          <target state="translated">サイズ「n」の入力の場合、プログラムは配列内で「n * n」回の反復の速度で成長しています。 したがってBig-OはO（n &lt;sup&gt;2&lt;/sup&gt; ）として表されるN &lt;sup&gt;2です。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8a6ae78506dc4ee34684d9e0638c4281f35c545f" translate="yes" xml:space="preserve">
          <source>For online downloading, the download time is directly proportional to the movie file sizes (input). We call this &lt;strong&gt;O(n)&lt;/strong&gt;.</source>
          <target state="translated">オンラインダウンロードの場合、ダウンロード時間は映画のファイルサイズ（入力）に正比例します。 これを&lt;strong&gt;O（n）&lt;/strong&gt;と呼びます。</target>
        </trans-unit>
        <trans-unit id="67cc9e8bfc7b47bffe767706a99579808a311dcc" translate="yes" xml:space="preserve">
          <source>For the handshake example above, everyone in a room shakes everyone else's hand. In that example, &lt;code&gt;#handshakes &amp;isin; Ɵ(N&amp;sup2;)&lt;/code&gt;. Why?</source>
          <target state="translated">上記のハンドシェイクの例では、部屋の全員が他の全員の手を振っています。 その例では、 &lt;code&gt;#handshakes &amp;isin; Ɵ(N&amp;sup2;)&lt;/code&gt; です。 どうして？</target>
        </trans-unit>
        <trans-unit id="c5e2547d0bc6ba3ff90e388af4f7fa819fdfb175" translate="yes" xml:space="preserve">
          <source>Four (and this is the fun part): I have two small decks now, one more low than the splay card, and one more high.  Now I go to step one, on each small deck!  That is to say, I start from step One on the first small deck, and when that work is done, I start from step One on the next small deck.</source>
          <target state="translated">4枚(そしてここが面白い)。私は今2枚の小さなデッキを持っています。1枚はスプレイカードよりも低く、もう1枚は高くなっています。ここで私はそれぞれのスモールデックのステップ1に進みます.つまり,最初のスモールデックのステップ1から始め,それが終わったら次のスモールデックのステップ1から始めます.</target>
        </trans-unit>
        <trans-unit id="4a6b77756dd510894ce0e5f9cee853f3dfb273a0" translate="yes" xml:space="preserve">
          <source>From the experiments, we know that online shopping scales better than online downloading. It is very important to understand big O notation because it helps you to analyze the &lt;strong&gt;scalability&lt;/strong&gt; and &lt;strong&gt;efficiency&lt;/strong&gt; of algorithms.</source>
          <target state="translated">実験から、オンラインショッピングはオンラインダウンロードよりも優れていることがわかります。 ビッグO表記法は、アルゴリズムの&lt;strong&gt;スケーラビリティ&lt;/strong&gt;と&lt;strong&gt;効率&lt;/strong&gt;を分析するのに役立つため、理解することは非常に重要です。</target>
        </trans-unit>
        <trans-unit id="e19041281d0dd99d852a13a94e9ffca8398dc327" translate="yes" xml:space="preserve">
          <source>Grows as a square, where &lt;em&gt;n&lt;/em&gt; is the length of the side of a square.  This is the same growth rate as the &quot;network effect&quot;, where everyone in a network might know everyone else in the network.  Growth is expensive.  Most scalable solutions cannot use algorithms with this level of complexity without doing significant gymnastics.  This generally applies to all other polynomial complexities - &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;&lt;sup&gt;k&lt;/sup&gt;)&lt;/strong&gt; - as well.</source>
          <target state="translated">正方形として成長します&lt;em&gt;。n&lt;/em&gt;は正方形の1辺の長さです。 これは「ネットワーク効果」と同じ成長率であり、ネットワーク内の誰もがネットワーク内の他のすべての人を知っている可能性があります。 成長は高価です。 ほとんどのスケーラブルなソリューションでは、重要な体操を行わずにこのレベルの複雑さのアルゴリズムを使用することはできません。 これは通常、他のすべての多項式の複雑さ&lt;strong&gt;-O（ &lt;em&gt;n&lt;/em&gt; &lt;sup&gt;k&lt;/sup&gt; ）&lt;/strong&gt; -にも適用されます。</target>
        </trans-unit>
        <trans-unit id="36f6624b28e90d7b5439820ddf4b791141546e8a" translate="yes" xml:space="preserve">
          <source>Here comes big O, to tell us just how hard this math is.</source>
          <target state="translated">この計算がどれだけ難しいかを教えてくれるビッグ・オーの登場です。</target>
        </trans-unit>
        <trans-unit id="5e58c431d0ce6f70610939ce98c97531f57d61cc" translate="yes" xml:space="preserve">
          <source>Here is another thing we can recognize visually:</source>
          <target state="translated">ここにも視覚的に認識できるものがあります。</target>
        </trans-unit>
        <trans-unit id="4ab646045794b15182529717713fd6393652d11a" translate="yes" xml:space="preserve">
          <source>Here is the Wikipedia article: &lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;https://en.wikipedia.org/wiki/Big_O_notation&lt;/a&gt;</source>
          <target state="translated">ウィキペディアの記事は次のとおりです&lt;a href=&quot;https://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;。https&lt;/a&gt; ： //en.wikipedia.org/wiki/Big_O_notation</target>
        </trans-unit>
        <trans-unit id="001cff8786bd37eff234c46bb9b1b48e0988d759" translate="yes" xml:space="preserve">
          <source>Here is the plain English bestiary I tend to use when explaining the common varieties of Big-O</source>
          <target state="translated">ここでは、Big-Oの一般的な品種を説明する際に、私がよく使う平易な英語の解説書を紹介します。</target>
        </trans-unit>
        <trans-unit id="43e41c55f998f736fd0e01106d1006e4f8370dd7" translate="yes" xml:space="preserve">
          <source>Here's an example where we have N T-shirts which we want to dry. We'll &lt;em&gt;assume&lt;/em&gt; it's incredibly quick to get them in the drying position (i.e. the human interaction is negligible). That's not the case in real life, of course...</source>
          <target state="translated">これは、乾燥させたいN枚のTシャツの例です。 それらを乾燥位置に置くのは信じられないほど迅速である&lt;em&gt;と想定&lt;/em&gt;します（つまり、人間の相互作用は無視できます）。 もちろん、実際にはそうではありません...</target>
        </trans-unit>
        <trans-unit id="c5af9b41639623efa7baf5be1ecd016aee231408" translate="yes" xml:space="preserve">
          <source>Here, the smallest recognizable outline you can draw is what matters; a triangle is a two dimensional shape (0.5 A^2), just like a square is a two-dimensional shape (A^2); the constant factor of two here remains in the asymptotic ratio between the two, however, we ignore it like all factors... (There are some unfortunate nuances to this technique I don't go into here; it can mislead you.)</source>
          <target state="translated">ここでは、あなたが描くことができる最小の認識可能なアウトラインが重要です。三角形は二次元の形状(0.5 A^2)であり、正方形が二次元の形状(A^2)であるのと同じように、ここでは二の定数係数は二の間の漸近比に残りますが、すべての係数のように無視します...(このテクニックにはいくつかの不幸なニュアンスがありますので、ここでは触れません。</target>
        </trans-unit>
        <trans-unit id="1d2dc7900c252d720e30b05b14c6ffb4be0d882b" translate="yes" xml:space="preserve">
          <source>Hmmm.  There may be a rule in there, I think.  To make big tasks small, break them up.</source>
          <target state="translated">うーん。そこにルールがあるのかもしれませんね。大きなタスクを小さくするには、分割する。</target>
        </trans-unit>
        <trans-unit id="9c06c7ddd3fdd4ff139df20d27d2e5e8fe694d25" translate="yes" xml:space="preserve">
          <source>How can we sort this deck?  I have a plan.</source>
          <target state="translated">どうやってこのデッキを整理するの?考えがある</target>
        </trans-unit>
        <trans-unit id="b80eb8a9b1ad872be834851527556c78aaff922e" translate="yes" xml:space="preserve">
          <source>How do I know Quick Sort is less work?  I know that O(n log n) is less than O(n squared).  The O's are more small, so Quick Sort is less work!</source>
          <target state="translated">クイックソートの方が作業量が少ないことを知るには?O(n log n)がO(n乗)よりも小さいことは知っています。Oの方が小さいので、Quick Sortの方が作業量が少ないのです。</target>
        </trans-unit>
        <trans-unit id="ce3005d8e3f4f0dd8dec37227d002f3f7de3b04c" translate="yes" xml:space="preserve">
          <source>How much more hard would it be?  How much more work would I have to do?  Do I need more or less steps?</source>
          <target state="translated">どれだけ大変なことになるのか?あとどのくらいの作業が必要か?ステップ数は多いほうがいいのか、少ないほうがいいのか?</target>
        </trans-unit>
        <trans-unit id="a4daa40555f4cdbc41aa891d89c4fbcc8ad0f51b" translate="yes" xml:space="preserve">
          <source>However, for very large numbers of people, the linear term &lt;code&gt;N&lt;/code&gt; is dwarfed and effectively contributes 0 to the ratio (in the chart: the fraction of empty boxes on the diagonal over total boxes gets smaller as the number of participants becomes larger). Therefore the scaling behavior is &lt;code&gt;order N&amp;sup2;&lt;/code&gt;, or the number of handshakes &quot;grows like N&amp;sup2;&quot;.</source>
          <target state="translated">ただし、人数が非常に多い場合、線形項 &lt;code&gt;N&lt;/code&gt; は小さくなり、比率に実質的に0を与えます（グラフでは、参加者の数が増えるにつれて、ボックス全体に対する対角線上の空のボックスの割合が小さくなります）。 したがって、スケーリング動作は &lt;code&gt;order N&amp;sup2;&lt;/code&gt; 、または「N&amp;sup2;のように大きくなる」ハンドシェイクの数です。</target>
        </trans-unit>
        <trans-unit id="9f6b7a8c3e101e7571405d26663a1a4d8aefb762" translate="yes" xml:space="preserve">
          <source>I break up the deck in parts, and sort each part, more small and more small, and at some time I have no more work to do.  Now this may seem slow, with all the rules.  But trust me, it is not slow at all.  It is much less work than the first way to sort things!</source>
          <target state="translated">デッキをパーツごとに分解して、パーツごとに並べ替えて、もっと小さく、もっと小さくと、ある時にはもうやることがなくなってしまいました。今では、これはすべてのルールで、遅いように見えるかもしれません。しかし、私を信じてください、全く遅くはありません。最初の並べ替えの方法よりもはるかに少ない作業である.</target>
        </trans-unit>
        <trans-unit id="819fcf72178711a5bc5e8d2f9d5dd724ea8d6e5e" translate="yes" xml:space="preserve">
          <source>I care lots for big O.  Why?  I do not like to work!  No one likes to work.  That is why we all love big O!  He tells us how fast we can work.  He helps us think of how hard work is.</source>
          <target state="translated">私はビッグ・オーのことが大好きなのですが、なぜですか?働きたくないからです 働きたくない人はいません。だからみんなビッグ・オーが大好きなんだ!彼は私たちに仕事の速さを教えてくれます。仕事の大変さを考えさせてくれます。</target>
        </trans-unit>
        <trans-unit id="482a49f03db93f2d8f5d5daa020b481189471c57" translate="yes" xml:space="preserve">
          <source>I do not like to go to work.  I do not like to spend time at work.  If I had my way, I would like just to play, and do fun things.  Do you feel the same as I do?</source>
          <target state="translated">仕事に行くのが好きではありません。仕事で時間を過ごすのが好きではありません。自分のやり方があれば、ただ遊んだり、楽しいことをしたりしたいと思います。あなたは私と同じように感じますか?</target>
        </trans-unit>
        <trans-unit id="ad52c5fb30262f15e8d3a80bd1081996754096a0" translate="yes" xml:space="preserve">
          <source>I do not want to add right now.  I just want to think on how hard it might be to add that much.  And, I hope, to play as soon as I can.</source>
          <target state="translated">今すぐにでも追加したいわけではありません。ただ、それだけ追加するのがどれだけ大変なのかを考えてみたい。そして、出来るだけ早くプレイしたい。</target>
        </trans-unit>
        <trans-unit id="a8b731da95dde2cc32a2a652b9321f54f34bd44a" translate="yes" xml:space="preserve">
          <source>I found a really great explanation about big O notation especially for a someone who's not much into mathematics.</source>
          <target state="translated">特に数学にあまり興味がない人のために、大きなOの表記法についての説明がとても素晴らしいものを見つけました。</target>
        </trans-unit>
        <trans-unit id="dab9c64b9a46ec0457c94246c45926dfd570f6b3" translate="yes" xml:space="preserve">
          <source>I have a deck of cards.  I did sort them.  You helped.  Thanks.</source>
          <target state="translated">カードの山を持っています。分類したんだ 手伝ってくれたのね。ありがとう</target>
        </trans-unit>
        <trans-unit id="3f1e4073256cafed9c07f32d545cc56213aba0e9" translate="yes" xml:space="preserve">
          <source>I have ten cards.  And, most of the time -- that is, if I don&amp;rsquo;t have lots of luck -- I must go through the whole deck up to ten times, with up to ten card swaps each time through the deck.</source>
          <target state="translated">私は10枚のカードを持っています。 そして、ほとんどの場合、つまり、運が悪い場合は、デッキ全体を最大10回通過しなければならず、毎回最大10枚のカードを交換する必要があります。</target>
        </trans-unit>
        <trans-unit id="0ec03029a11a10972a0136154949cfcba5dbed69" translate="yes" xml:space="preserve">
          <source>I hope this is as simple as you want it.</source>
          <target state="translated">望み通りのシンプルなものになるといいですね。</target>
        </trans-unit>
        <trans-unit id="53ae10c16d270153bdbf8c1a9e6f93c880d6182f" translate="yes" xml:space="preserve">
          <source>I will look at each pair of cards, pair by pair, through the deck, from first to last.  If the first card in one pair is big and the next card in that pair is small, I swap them.  Else, I go to the next pair, and so on and so on... and soon, the deck is done.</source>
          <target state="translated">デッキの中のカードを一組ずつ見ていきます。ペアの最初のカードが大きくて次のカードが小さければ,そのペアを入れ替えます.そうでなければ、次のペアに移動します。</target>
        </trans-unit>
        <trans-unit id="b9d44117c5235dda1f72fad7eec883c624ba20a4" translate="yes" xml:space="preserve">
          <source>I'd prefer as little formal definition as possible and simple mathematics.</source>
          <target state="translated">なるべく形式的な定義は少なく、簡単な数学がいいですね。</target>
        </trans-unit>
        <trans-unit id="f6bbf69b7602636fdd09cc6e847b5d115ba9d058" translate="yes" xml:space="preserve">
          <source>I've more simpler way to understand the time complexity
he most common metric for calculating time complexity is Big O notation. This removes all constant factors so that the running time can be estimated in relation to N as N approaches infinity. In general you can think of it like this:</source>
          <target state="translated">私は時間の複雑さを理解するためのよりシンプルな方法を持っている彼は、時間の複雑さを計算するための最も一般的なメトリックは、ビッグO記法です。これは、Nが無限大に近づくにつれて、実行時間がNとの関係で推定できるように、すべての定数要因を取り除きます。一般的には、このように考えることができます。</target>
        </trans-unit>
        <trans-unit id="3c93039db5b8dea862d7aba7ac7a736523f2e466" translate="yes" xml:space="preserve">
          <source>If an algorithm is O(n) then the time/space will increase at the same rate as its input.</source>
          <target state="translated">アルゴリズムがO(n)であれば、時間空間は入力と同じ速度で増加します。</target>
        </trans-unit>
        <trans-unit id="b93496435ccac02920ca75abbec4e210c6e1376f" translate="yes" xml:space="preserve">
          <source>If an algorithm is O(n&lt;sup&gt;2&lt;/sup&gt;) then the time/space increase at the rate of its input squared.</source>
          <target state="translated">アルゴリズムがO（n &lt;sup&gt;2&lt;/sup&gt; ）の場合、入力/平方のレートで時間/空間が増加します。</target>
        </trans-unit>
        <trans-unit id="42bcc6138049b638ae7478e9aaa755e8a5fae576" translate="yes" xml:space="preserve">
          <source>If some values are effectively bounded due to some hidden fact (e.g. the average human name is softly bounded at perhaps 40 letters, and human age is softly bounded at around 150). You can also impose bounds on your input to effectively make terms constant.</source>
          <target state="translated">いくつかの値が隠された事実のために効果的に制限されている場合 (例えば、平均的な人間の名前は40文字程度でソフトに制限され、人間の年齢は150歳程度でソフトに制限されます)。また、入力に境界線を課すこともできます。</target>
        </trans-unit>
        <trans-unit id="eadacee139f919b0ca67cb2be538cca322087b44" translate="yes" xml:space="preserve">
          <source>If the above doesn't make sense, then you don't have a compatible intuitive notion of infinity in your head, and you should probably disregard all of the above; the only way I know to make these ideas rigorous, or to explain them if they aren't already intuitively useful, is to first teach you big O notation or something similar. (although, once you well understand big O notation in the future, it may be worthwhile to revisit these ideas)</source>
          <target state="translated">もし上記のことが意味をなさないのであれば、あなたの頭の中には無限大の直感的な概念がないので、上記のことは無視した方がいいでしょう。(とはいえ、将来的にビッグオー記法を十分に理解したら、これらのアイデアを再検討する価値はあるかもしれませんが)</target>
        </trans-unit>
        <trans-unit id="fc0f303936e49cce64dec3515e323c65eb23edc5" translate="yes" xml:space="preserve">
          <source>If the loop has finished without finding the key, return False.</source>
          <target state="translated">キーを見つけられずにループが終了した場合は、Falseを返します。</target>
        </trans-unit>
        <trans-unit id="1f90ef8cce8695b2d4c7c46d902314ff3d88ced2" translate="yes" xml:space="preserve">
          <source>If we do something slightly complicated, you might still be able to imagine visually what's going on:</source>
          <target state="translated">ちょっと複雑なことをしても、何が起こっているのか視覚的にイメージできるかもしれません。</target>
        </trans-unit>
        <trans-unit id="498ad5ebf90abce6c7640e5178604bd12d2cb5dd" translate="yes" xml:space="preserve">
          <source>If we do something very complicated, such as with a recursive function or divide-and-conquer algorithm, &lt;strike&gt;you can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem&quot;&gt;Master Theorem&lt;/a&gt; (usually works), or in ridiculous cases the Akra-Bazzi Theorem (almost always works)&lt;/strike&gt; you look up the running time of your algorithm on Wikipedia.</source>
          <target state="translated">再帰関数や分割統治アルゴリズムなど、非常に複雑な処理を行う場合は&lt;strike&gt;、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Master_theorem&quot;&gt;マスター定理&lt;/a&gt; （通常は機能します）を使用できます。&lt;/strike&gt;ウィキペディアでのアルゴリズムの実行時間。</target>
        </trans-unit>
        <trans-unit id="f340d38ad5275f65c3f3c98f00a52fd253da01b5" translate="yes" xml:space="preserve">
          <source>If we have two 100-digit numbers we need to do 10,000 multiplications and 200 adds.  For two one million digit numbers we need to do one trillion (10&lt;sup&gt;12&lt;/sup&gt;) multiplications and two million adds.</source>
          <target state="translated">2つの100桁の数値がある場合、10,000の乗算と200の加算を行う必要があります。 200万桁の数字の場合、1兆（10 &lt;sup&gt;12&lt;/sup&gt; ）の乗算と200万の加算を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="7a7797f63ba1469547a1c7c05a0e4651c75d6f7f" translate="yes" xml:space="preserve">
          <source>If we use a simple structure called a hash table (an instant-speed lookup table, also known as a hashmap or dictionary), we pay a small cost by preprocessing everything in &lt;code&gt;O(N)&lt;/code&gt; time. Thereafter, it only takes constant time on average to look up something by its key (in this case, our key is the latitude and longitude coordinates, rounded into a grid; we search the adjacent gridspaces of which there are only 9, which is a constant).</source>
          <target state="translated">ハッシュテーブル（インスタントルックアップテーブル、ハッシュマップまたはディクショナリとも呼ばれます）と呼ばれる単純な構造を使用する場合、すべてを &lt;code&gt;O(N)&lt;/code&gt; 時間で前処理することにより、わずかなコストを支払います。 その後、そのキーで何かを検索するのに平均して一定の時間しかかかりません（この場合、キーは緯度と経度の座標であり、グリッドに丸められます。隣接するグリッドスペースは9つしかなく、絶え間ない）。</target>
        </trans-unit>
        <trans-unit id="532d60c07f8308239c74d78cfd8bd61382460fae" translate="yes" xml:space="preserve">
          <source>If you have 3 towns A, B and C with roads between all pairs then you could go:</source>
          <target state="translated">A,B,Cの3つの町があって、すべてのペアの間に道路がある場合、あなたは行くことができます。</target>
        </trans-unit>
        <trans-unit id="85e55a9c0f7521ee220edb5e820f851626c00f8e" translate="yes" xml:space="preserve">
          <source>If you have a suitable notion of infinity in your head, then there is a very brief description:</source>
          <target state="translated">頭の中に無限大という適切な概念があるのであれば、非常に簡単な説明があります。</target>
        </trans-unit>
        <trans-unit id="a391595810bc224de5ec62db4d75a23a1dd6b419" translate="yes" xml:space="preserve">
          <source>If you have to sort a deck, what is the best way?  Well, you can do what you want, but I would choose Quick Sort.</source>
          <target state="translated">デッキをソートしなければならない場合、どのような方法が良いでしょうか?まあ、好きなようにすればいいのですが、私はクイックソートを選びます。</target>
        </trans-unit>
        <trans-unit id="c8f0c3e48ae6bc0a6ae30c3840b7e3d5da5a2114" translate="yes" xml:space="preserve">
          <source>If you only needed to do this once, it would not be a problem to have to do the naive method of &lt;code&gt;O(N)&lt;/code&gt; work only once, but if you want to do it many times (in this case, &lt;code&gt;N&lt;/code&gt; times, once for each segment), we'd have to do &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; work, or 1000000&amp;sup2;=1000000000000 operations. Not good (a modern computer can perform about a billion operations per second).</source>
          <target state="translated">これを1回だけ実行する必要がある場合、 &lt;code&gt;O(N)&lt;/code&gt; の単純な方法を1回だけ実行する必要は問題ありませんが、何度も実行する場合（この場合は &lt;code&gt;N&lt;/code&gt; 回、1回のみ）各セグメント）、 &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; 作業、または1000000&amp;sup2;= 1000000000000演算を実行する必要があります。 良くない（最近のコンピューターは1秒あたり約10億の操作を実行できる）。</target>
        </trans-unit>
        <trans-unit id="b0ce2012a9d7c727364cedfce54d754ac83295bd" translate="yes" xml:space="preserve">
          <source>If you read the &quot;Oh&quot; as meaning &quot;on the order of&quot; or &quot;approximately&quot; you will not go too far wrong. (I think the choice of the Big-Oh might have been an attempt at humour).</source>
          <target state="translated">おう」の意味を「順番に」とか「だいたい」と読めば、あまり間違えることはないでしょう。(Big-Ohの選択はユーモアの試みだったのではないかと思います)。</target>
        </trans-unit>
        <trans-unit id="879d10b4ee33a790e641d1a246a7c4921f058217" translate="yes" xml:space="preserve">
          <source>If you upgrade to a computer that can run your algorithm twice as fast, big O notation won't notice that. Constant factor improvements are too small to even be noticed in the scale that big O notation works with. Note that this is an intentional part of the design of big O notation.</source>
          <target state="translated">アルゴリズムを2倍の速さで実行できるコンピュータにアップグレードしても、ビッグオー記法はそれに気づかないでしょう。定数因子の改善は、ビッグオー記法が動作する規模では気づかれないほど小さいものです。これは、ビッグオー記法の設計の意図的な部分であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4ca1f62a00fa89bcd7628fd712226caf431517e2" translate="yes" xml:space="preserve">
          <source>If you're sorting something like 5 elements, you don't want to use the speedy &lt;code&gt;O(N log(N))&lt;/code&gt; quicksort; you want to use insertion sort, which happens to perform well on small inputs. These situations often come up in divide-and-conquer algorithms, where you split up the problem into smaller and smaller subproblems, such as recursive sorting, fast Fourier transforms, or matrix multiplication.</source>
          <target state="translated">5つの要素のようなものを並べ替える場合、高速な &lt;code&gt;O(N log(N))&lt;/code&gt; クイックソートを使用する必要はありません。 挿入ソートを使用したい場合、これはたまたま小さな入力でうまく機能します。 これらの状況は、多くの場合、分割統治アルゴリズムで発生します。このアルゴリズムでは、再帰的な並べ替え、高速フーリエ変換、行列の乗算など、問題をより小さな副問題に分割します。</target>
        </trans-unit>
        <trans-unit id="b1d27a710e5b2deff8083ff199e610d9f97f11b2" translate="yes" xml:space="preserve">
          <source>In Big-O terms this is &lt;strong&gt;O(log n)&lt;/strong&gt; or &lt;strong&gt;logarithmic complexity&lt;/strong&gt;.  Now the logarithm in question could be ln (base e), log&lt;sub&gt;10&lt;/sub&gt;, log&lt;sub&gt;2&lt;/sub&gt; or some other base.  It doesn't matter it's still O(log n) just like O(2n&lt;sup&gt;2&lt;/sup&gt;) and O(100n&lt;sup&gt;2&lt;/sup&gt;) are still both O(n&lt;sup&gt;2&lt;/sup&gt;).</source>
          <target state="translated">Big-O用語では、これは&lt;strong&gt;O（log n）&lt;/strong&gt;または&lt;strong&gt;対数複雑度&lt;/strong&gt;です。 ここで、問題の対数は、ln（eを底とする）、log &lt;sub&gt;10&lt;/sub&gt; 、log &lt;sub&gt;2、&lt;/sub&gt;またはその他の底になります。 O（2n &lt;sup&gt;2&lt;/sup&gt; ）とO（100n &lt;sup&gt;2&lt;/sup&gt; ）が両方ともO（n &lt;sup&gt;2&lt;/sup&gt; ）であるのと同じように、それがまだO（log n）であるかどうかは関係ありません。</target>
        </trans-unit>
        <trans-unit id="88e50d90d1750553c39e16c7f8930e4119cfca57" translate="yes" xml:space="preserve">
          <source>In CS, the set of steps to accomplish a task is called algorithms.</source>
          <target state="translated">CSでは、タスクを達成するための一連のステップをアルゴリズムと呼ぶ。</target>
        </trans-unit>
        <trans-unit id="d95044d68f300f358a3a51cf89c9474f6f16e349" translate="yes" xml:space="preserve">
          <source>In Terminology, Big O notation is used to describe the performance or complexity of an algorithm.</source>
          <target state="translated">用語集では、アルゴリズムの性能や複雑さを表現するためにビッグオー表記を使用しています。</target>
        </trans-unit>
        <trans-unit id="d65e5f9e362ebe36bedba5b57e018e3acbfc0c7b" translate="yes" xml:space="preserve">
          <source>In actuality there are 3 possibilities.</source>
          <target state="translated">実際には3つの可能性があります。</target>
        </trans-unit>
        <trans-unit id="07046d757b1f2b48e849414a4e96d5ff13dade7a" translate="yes" xml:space="preserve">
          <source>In addition, Big O establishes the worst-case or measure the Upper-Bound steps.</source>
          <target state="translated">さらに、ビッグオーは、最悪のケースを設定したり、アッパーバウンドのステップを測定したりします。</target>
        </trans-unit>
        <trans-unit id="baa93a55b3140739514a5c40f8e2cdd9810a3c85" translate="yes" xml:space="preserve">
          <source>In all cases, prefer algorithms higher up on the list to those lower on the list.  However, the cost of moving to a more expensive complexity class varies significantly.</source>
          <target state="translated">すべての場合において、リストの上位のアルゴリズムを、リストの下位のアルゴリズムよりも優先してください。しかし、より高価な複雑性クラスに移行するためのコストは大きく異なります。</target>
        </trans-unit>
        <trans-unit id="30b960998b211299ef1c91dabf4d8dd22d39e434" translate="yes" xml:space="preserve">
          <source>In big O notation this is written as</source>
          <target state="translated">ビッグO表記では、これは次のように書かれています。</target>
        </trans-unit>
        <trans-unit id="64aaef6ec6705e0f6426bbcc5b5fde04c862b7d5" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;O(...)&lt;/code&gt; is the most useful one because we often care about worst-case behavior. If &lt;code&gt;f(x)&lt;/code&gt; represents something &quot;bad&quot; like the processor or memory usage, then &quot;&lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt;&quot; means &quot;&lt;code&gt;upperbound&lt;/code&gt; is the worst-case scenario of processor/memory usage&quot;.</source>
          <target state="translated">一般的に、 &lt;code&gt;O(...)&lt;/code&gt; は、ワーストケースの振る舞いを気にすることが多いため、最も有用なものです。 &lt;code&gt;f(x)&lt;/code&gt; がプロセッサまたはメモリ使用量のような「悪い」ものを表す場合、「 &lt;code&gt;f(x) &amp;isin; O(upperbound)&lt;/code&gt; 」は「 &lt;code&gt;upperbound&lt;/code&gt; がプロセッサ/メモリ使用量の最悪のシナリオ」であることを意味します。</target>
        </trans-unit>
        <trans-unit id="e9fddaf6556848124995ffd1ed9ddc0b950170ab" translate="yes" xml:space="preserve">
          <source>In general, doing something with every item in one dimension is linear, doing something with every item in two dimensions is quadratic, and dividing the working area in half is logarithmic. There are other Big O measures such as cubic, exponential, and square root, but they're not nearly as common. Big O notation is described as O (  ) where  is the measure. The quicksort algorithm would be described as O ( N * log ( N ) ).</source>
          <target state="translated">一般的に、1 次元のすべての項目で何かをするのは線形で、2 次元のすべての項目で何かをするのは二次で、作業領域を半分に割るのは対数です。他にも、3 次関数、指数関数、平方根などの Big O のメジャーがありますが、それらはほとんど一般的ではありません。Big O記法はO()として記述され、ここではメジャーです。クイックソートアルゴリズムは、O(N*log(N))として記述されます。</target>
        </trans-unit>
        <trans-unit id="63a8eaf6bf07c1752a4bb48aa0c8cfc63edc138d" translate="yes" xml:space="preserve">
          <source>In general, our goal will be to find or structure an algorithm &lt;strong&gt;A&lt;/strong&gt; in such a way that it will have a function &lt;code&gt;X(n)&lt;/code&gt; that returns as low a number as possible.</source>
          <target state="translated">一般に、私たちの目標は、可能な限り低い数を返す関数 &lt;code&gt;X(n)&lt;/code&gt; を持つような方法でアルゴリズム&lt;strong&gt;A&lt;/strong&gt;を検索または構造化することです。</target>
        </trans-unit>
        <trans-unit id="7de7cd6bc8a2b03ecb0a68fecd7a6051d0934bd9" translate="yes" xml:space="preserve">
          <source>In many cases the &quot;O&quot; of an algorithm will fall into one of the following cases:</source>
          <target state="translated">多くの場合、アルゴリズムの「O」は以下のいずれかのケースに該当します。</target>
        </trans-unit>
        <trans-unit id="a763bcaebb1bc5faa9ba3036763e8474d16f2b73" translate="yes" xml:space="preserve">
          <source>In one sentence: As the size of your job goes up, how much longer does it take to complete it?</source>
          <target state="translated">一文で言うと 仕事の規模が大きくなってくると、それが完了するまでにどれくらいの時間がかかりますか?</target>
        </trans-unit>
        <trans-unit id="4bfe8a12e0a2be2aee41e7617d2857524d177ee2" translate="yes" xml:space="preserve">
          <source>In other words where g(n) is the running time of your algorithm, we say that g(n) = O(f(n)) when g(n) &amp;lt;= c*f(n) when n &amp;gt; k, where c and k are some constants.</source>
          <target state="translated">つまり、g（n）がアルゴリズムの実行時間である場合、g（n）&amp;lt;= c * f（n）の場合、g（n）= O（f（n））となります。n&amp;gt; kの場合、 cとkは定数です。</target>
        </trans-unit>
        <trans-unit id="4e02f4f6e256066f1d4123d571431ca1ed48ec48" translate="yes" xml:space="preserve">
          <source>In other words, in plain English: &lt;em&gt;f&lt;/em&gt;(x) = O(&lt;em&gt;g&lt;/em&gt;(x)), x &amp;rarr; a, means that in a neighborhood of a, &lt;em&gt;f&lt;/em&gt; decomposes into the product of &lt;em&gt;g&lt;/em&gt; and some bounded function.</source>
          <target state="translated">つまり、単純な英語では、 &lt;em&gt;f&lt;/em&gt; （x）= O（ &lt;em&gt;g&lt;/em&gt; （x））、x&amp;rarr;aは、aの近傍で、 &lt;em&gt;f&lt;/em&gt;が&lt;em&gt;g&lt;/em&gt;といくつかの有界関数の積に分解されることを意味します。</target>
        </trans-unit>
        <trans-unit id="68079fad5ce0cb40c968faed5e24541715996023" translate="yes" xml:space="preserve">
          <source>In practice, even among algorithms which have the same or similar asymptotic performance, their relative merit may actually be driven by other things, such as: other performance factors (quicksort and mergesort are both &lt;code&gt;O(N log(N))&lt;/code&gt;, but quicksort takes advantage of CPU caches); non-performance considerations, like ease of implementation; whether a library is available, and how reputable and maintained the library is.</source>
          <target state="translated">実際には、漸近的パフォーマンスが同じまたは類似しているアルゴリズムの間でも、それらの相対的なメリットは実際には次のような他の要因によって駆動される可能性があります。他のパフォーマンス要因（クイックソートとマージソートは両方とも &lt;code&gt;O(N log(N))&lt;/code&gt; ですが、クイックソートにはCPUキャッシュの利点）; 実装の容易さなど、パフォーマンスに関する考慮事項。 ライブラリが利用可能かどうか、およびライブラリの信頼性と維持管理の程度。</target>
        </trans-unit>
        <trans-unit id="84ff32c19c195c6e0453458a4af8916d40d60004" translate="yes" xml:space="preserve">
          <source>In this new way to sort a deck, we do not check pairs of cards the way we did a while ago.  Here are your new rules to sort this deck:</source>
          <target state="translated">この新しい山札の並べ方では、先ほどのようにペアのカードをチェックすることはありません。このデッキをソートするための新しいルールは以下の通りです.</target>
        </trans-unit>
        <trans-unit id="c9da7190c61b8b40d9ee9d7282639dd113f829a6" translate="yes" xml:space="preserve">
          <source>Is N * log ( N ). The running time consists of N loops (iterative or recursive) that are logarithmic, thus the algorithm is a combination of linear and logarithmic.</source>
          <target state="translated">は N*log(N)です。実行時間は対数的なN個のループ(反復的または再帰的)で構成されているため、アルゴリズムは線形と対数の組み合わせです。</target>
        </trans-unit>
        <trans-unit id="998b8dec061b127d4bd37309e498d87df1954ca7" translate="yes" xml:space="preserve">
          <source>Is constant. The running time of the statement will not change in relation to N</source>
          <target state="translated">は一定である。文の実行時間は、N</target>
        </trans-unit>
        <trans-unit id="7c262ad477a4821f4fb1c7733312befe0c8fe05a" translate="yes" xml:space="preserve">
          <source>Is it more or less fast than the first sort?  Big O, please help!</source>
          <target state="translated">最初のソートよりも速いかどうか?ビッグオーさん、よろしくお願いします。</target>
        </trans-unit>
        <trans-unit id="29e49e4fc142b2d0f2b1a400df6ab96e4a918158" translate="yes" xml:space="preserve">
          <source>Is linear. The running time of the loop is directly proportional to N. When N doubles, so does the running time.</source>
          <target state="translated">は線形です。ループの実行時間はNに正比例します。Nが2倍になると実行時間も増加します。</target>
        </trans-unit>
        <trans-unit id="0669d4a8187abfada364d0bb775de3933241efd7" translate="yes" xml:space="preserve">
          <source>Is logarithmic. The running time of the algorithm is proportional to the number of times N can be divided by 2. This is because the algorithm divides the working area in half with each iteration.</source>
          <target state="translated">は対数である。アルゴリズムの実行時間は、Nを2で割ることができる回数に比例します。 これは、アルゴリズムが各反復で作業領域を半分に割るからです。</target>
        </trans-unit>
        <trans-unit id="f9cef10a1858aa5a865ebf26c425725395a40d0a" translate="yes" xml:space="preserve">
          <source>Is quadratic. The running time of the two loops is proportional to the square of N. When N doubles, the running time increases by N * N.</source>
          <target state="translated">は二次関数である。2つのループの実行時間はNの2乗に比例します。Nが2倍になると、実行時間はN*Nだけ増加します。</target>
        </trans-unit>
        <trans-unit id="1189cb04bbafbceb75864abdc92eb47236ec61c3" translate="yes" xml:space="preserve">
          <source>Is there a more fast way to sort the cards?  Can big O help us?</source>
          <target state="translated">もっと早くカードを並べ替える方法はありますか?ビッグオーは助けてくれますか?</target>
        </trans-unit>
        <trans-unit id="bdcb0de02955e320abf0c31ab2a8744682cbbe08" translate="yes" xml:space="preserve">
          <source>It is very difficult to measure the speed of software programs, and when we try, the answers can be very complex and filled with exceptions and special cases. This is a big problem, because all those exceptions and special cases are distracting and unhelpful when we want to compare two different programs with one another to find out which is &quot;fastest&quot;.</source>
          <target state="translated">ソフトウェアプログラムの速度を測るのは非常に難しく、いざやってみると答えが非常に複雑で、例外や特殊なケースで埋め尽くされてしまうことがあります。これは大きな問題で、2つの異なるプログラムを比較してどちらが「速い」のかを知りたいときに、これらの例外や特殊なケースはすべて気が散ってしまい、役に立たないからです。</target>
        </trans-unit>
        <trans-unit id="52df2acf675e9663e6643a99463b7ca8b662796f" translate="yes" xml:space="preserve">
          <source>It shows how an algorithm scales based on input size.</source>
          <target state="translated">アルゴリズムが入力サイズに基づいてどのようにスケーリングするかを示しています。</target>
        </trans-unit>
        <trans-unit id="293ad219691b62a126a8db817cbbea70a32b0c5f" translate="yes" xml:space="preserve">
          <source>It's as if the empty boxes on the diagonal of the chart (N*(N-1)/2 checkmarks) weren't even there (N&lt;sup&gt;2&lt;/sup&gt; checkmarks asymptotically).</source>
          <target state="translated">これは、グラフの対角線上の空のボックス（N *（N-1）/ 2チェックマーク）がそこにもなかったかのようです（N &lt;sup&gt;2&lt;/sup&gt;チェックマークは漸近的に）。</target>
        </trans-unit>
        <trans-unit id="ec70bfe19e1f4d33f015bf1ed0c0eb3f05117561" translate="yes" xml:space="preserve">
          <source>It's worthwhile at this point to explain that Big O can be used to determine three cases with an algorithm:</source>
          <target state="translated">この時点で、ビッグオーは3つのケースをアルゴリズムで判断できることを説明する価値があります。</target>
        </trans-unit>
        <trans-unit id="29cba760a7e3ba133866ed85852ba33956337368" translate="yes" xml:space="preserve">
          <source>Iterating on each item in the list, if it's the key then return True,</source>
          <target state="translated">リスト内の各項目を繰り返し処理し、それがキーであればTrueを返します。</target>
        </trans-unit>
        <trans-unit id="53da104c94a561d37e7b0bbeefcf47818dc3f2be" translate="yes" xml:space="preserve">
          <source>Keep in mind that big-O is not the whole story. You can drastically speed up some algorithms by using caching, making them cache-oblivious, avoiding bottlenecks by working with RAM instead of disk, using parallelization, or doing work ahead of time -- these techniques are often &lt;em&gt;independent&lt;/em&gt; of the order-of-growth &quot;big-O&quot; notation, though you will often see the number of cores in the big-O notation of parallel algorithms.</source>
          <target state="translated">big-Oがすべてではないことに注意してください。 キャッシュを使用して一部のアルゴリズムを大幅に高速化し、それらをキャッシュに気づかなくする、ディスクの代わりにRAMを使用する、並列化を使用する、または事前に作業を行うことでボトルネックを回避する-これらの手法は、多くの場合、成長の順序とは&lt;em&gt;無関係&lt;/em&gt;です「big-O」表記。ただし、並列アルゴリズムのbig-O表記ではコアの数がよく表示されます。</target>
        </trans-unit>
        <trans-unit id="bc8c7b0e9f3998b53c3c3a45f086e6279211fb80" translate="yes" xml:space="preserve">
          <source>Let's assume that the addition of these numbers is the most expensive operation in this algorithm. It stands to reason that to add these two numbers together we have to add together 6 digits (and possibly carry a 7th). If we add two 100 digit numbers together we have to do 100 additions.  If we add &lt;strong&gt;two&lt;/strong&gt; 10,000 digit numbers we have to do 10,000 additions.</source>
          <target state="translated">これらの数値の加算が、このアルゴリズムで最もコストのかかる操作であると想定しましょう。 これらの2つの数値を加算するには、6桁を加算する必要がある（そしておそらく7桁を運ぶ）ことは当然のことです。 2つの100桁の数値を一緒に追加する場合、100を追加する必要があります。 &lt;strong&gt;2つの&lt;/strong&gt; 10,000桁の数字を追加する場合、10,000を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="0e3d7a37946e8fa9bb0f4b9c5caa0b1e6214f02f" translate="yes" xml:space="preserve">
          <source>Let's say your algorithm dealing with the problem depends on some 'factors', for example let's make it N and X.</source>
          <target state="translated">問題を扱うアルゴリズムがいくつかの「要因」に依存しているとしましょう。</target>
        </trans-unit>
        <trans-unit id="e09ce0464689a88f3f8747581ffb2d480edd57b6" translate="yes" xml:space="preserve">
          <source>Logarithms</source>
          <target state="translated">Logarithms</target>
        </trans-unit>
        <trans-unit id="0f768f66724b1ab90c8b65c4b90be682a8ff30a2" translate="yes" xml:space="preserve">
          <source>Logarithms are slightly trickier to explain so I'll use a common
  example:</source>
          <target state="translated">対数は少し説明が難しいので、よくある例を使って説明します。</target>
        </trans-unit>
        <trans-unit id="818cd71ba05516b0c7d38db784302c45d9d62431" translate="yes" xml:space="preserve">
          <source>More precisely &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; is used to express the asymptotic behavior of a function. That means how the function behaves as it approaches infinity.</source>
          <target state="translated">より正確には、関数の漸近的な振る舞いを表すために&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O表記&lt;/a&gt;が使用されます。 これは、関数が無限大に近づいたときの動作を意味します。</target>
        </trans-unit>
        <trans-unit id="53558434954a9542c40a6931db4c48fcfc391a05" translate="yes" xml:space="preserve">
          <source>Most of the time, people don't realize that there's more than one variable at work. For example, in a string-search algorithm, your algorithm may take time &lt;code&gt;O([length of text] + [length of query])&lt;/code&gt;, i.e. it is linear in two variables like &lt;code&gt;O(N+M)&lt;/code&gt;. Other more naive algorithms may be &lt;code&gt;O([length of text]*[length of query])&lt;/code&gt; or &lt;code&gt;O(N*M)&lt;/code&gt;. Ignoring multiple variables is one of the most common oversights I see in algorithm analysis, and can handicap you when designing an algorithm.</source>
          <target state="translated">ほとんどの場合、人々は複数の変数が機能していることを認識していません。 たとえば、文字列検索アルゴリズムでは、アルゴリズムに時間がかかる場合があります &lt;code&gt;O([length of text] + [length of query])&lt;/code&gt; つまり、 &lt;code&gt;O(N+M)&lt;/code&gt; のような2つの変数で線形です。 他のより単純なアルゴリズムは &lt;code&gt;O([length of text]*[length of query])&lt;/code&gt; または &lt;code&gt;O(N*M)&lt;/code&gt; です。 複数の変数を無視することは、アルゴリズム分析で見られる最も一般的な見落としの1つであり、アルゴリズムを設計するときに不利になることがあります。</target>
        </trans-unit>
        <trans-unit id="046638077884a582146518106d52398b493200ef" translate="yes" xml:space="preserve">
          <source>Multiplication is different. You line the numbers up, take the first digit in the bottom number and multiply it in turn against each digit in the top number and so on through each digit. So to multiply our two 6 digit numbers we must do 36 multiplications. We may need to do as many as 10 or 11 column adds to get the end result too.</source>
          <target state="translated">掛け算は違います。数字を並べて、下の数字の最初の桁を取り、上の数字の各桁と順番に掛けていきます。ですから、2つの6桁の数字を乗算するには、36回の乗算をしなければなりません。最終的な結果を得るためには、10列または11列の足し算をする必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="8b1b53f8f44ad3ed2592eb6c68dec183ea16ec21" translate="yes" xml:space="preserve">
          <source>My list</source>
          <target state="translated">マイリスト</target>
        </trans-unit>
        <trans-unit id="f7535aeee1a8d7280cd70d9997d4349f35bb3d3e" translate="yes" xml:space="preserve">
          <source>Naive method: If you had the coordinates of a street intersection, and wanted to examine nearby streets, you would have to go through the millions of segments each time, and check each one for adjacency.</source>
          <target state="translated">ナイーブな方法。通りの交差点の座標を持っていて、近くの通りを調べようとすると、何百万ものセグメントをその都度調べて、それぞれのセグメントが隣接しているかどうかをチェックしなければなりません。</target>
        </trans-unit>
        <trans-unit id="4d68869609a9235101b6bdb59cfad0ecf3bbe23e" translate="yes" xml:space="preserve">
          <source>No growth.  Regardless of how big as the problem is, you can solve it in the same amount of time.  This is somewhat analogous to broadcasting where it takes the same amount of energy to broadcast over a given distance, regardless of the number of people that lie within the broadcast range.</source>
          <target state="translated">成長はありません。問題の大きさに関係なく、同じ時間で解くことができます。これは、放送の範囲内にいる人の数に関係なく、与えられた距離を放送するのに同じ量のエネルギーを必要とする放送にやや類推されます。</target>
        </trans-unit>
        <trans-unit id="fe33dcb0f45062333e4e71b8e3449ababa913575" translate="yes" xml:space="preserve">
          <source>Normally we don't care about the best case.  We're interested in the expected and worst case.  Sometimes one or the other of these will be more important.</source>
          <target state="translated">通常、私たちはベストケースには関心がありません。私たちは予想されるケースと最悪のケースに興味があります。時にはどちらか一方が重要になることもあります。</target>
        </trans-unit>
        <trans-unit id="1a399a408e72ce4d50e1c555e9e14eb8f828e225" translate="yes" xml:space="preserve">
          <source>Not all algorithms run in the same amount of time, and can vary based on the number of items in the input, which we'll call &lt;em&gt;n&lt;/em&gt;. Based on this, we consider the worse case analysis, or an upper-bound of the run-time as &lt;em&gt;n&lt;/em&gt; get larger and larger. We must be aware of what &lt;em&gt;n&lt;/em&gt; is, because many of the Big O notations reference it.</source>
          <target state="translated">すべてのアルゴリズムが同じ時間で実行されるわけではなく、入力の項目数に基づいて変化する可能性があります。これを&lt;em&gt;n&lt;/em&gt;と呼びます。 これに基づいて、最悪のケース分析、または&lt;em&gt;n&lt;/em&gt;が次第に大きくなるときのランタイムの上限を検討します。 Big O表記の多くはそれを参照しているため、 &lt;em&gt;n&lt;/em&gt;が何であるかを認識する必要があります。</target>
        </trans-unit>
        <trans-unit id="9701d8a66e2332c79e3006b450aca766fa1d69b7" translate="yes" xml:space="preserve">
          <source>Not sure I'm further contributing to the subject but still thought I'd share: I once found &lt;a href=&quot;http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/&quot;&gt;this blog post&lt;/a&gt; to have some quite helpful (though very basic) explanations &amp;amp; examples on Big O:</source>
          <target state="translated">このテーマにさらに貢献しているのかわかりませんが、共有したいと思っていました。 &lt;a href=&quot;http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/&quot;&gt;このブログの投稿&lt;/a&gt;には、Big Oに関する非常に役立つ（非常に基本的ではありますが）説明と例があることがわかりました。</target>
        </trans-unit>
        <trans-unit id="ed45d6f0b33afd4fda7acc9a90c9a6ded141d1e6" translate="yes" xml:space="preserve">
          <source>Note: None of this has taken into account best, average, and worst case measures. Each would have its own Big O notation. Also note that this is a VERY simplistic explanation. Big O is the most common, but it's also more complex that I've shown. There are also other notations such as big omega, little o, and big theta. You probably won't encounter them outside of an algorithm analysis course.</source>
          <target state="translated">注:これはいずれもベストケース、アベレージケース、ワーストケースを考慮に入れていない。それぞれが独自のビッグ・オーの表記法を持っているでしょう。また、これは非常に単純化された説明であることにも注意してください。ビッグ・オーは最も一般的な表記法ですが、私が示したより複雑な表記法でもあります。他にも、ビッグオメガ、リトルオー、ビッグシータなどの表記法があります。おそらくアルゴリズム解析のコース以外では、これらの表記に出会うことはないでしょう。</target>
        </trans-unit>
        <trans-unit id="2238088b0eacca225a542e4f91ecc2965d263d59" translate="yes" xml:space="preserve">
          <source>Notice that the number of items increases by a factor of 10, but the time increases by a factor of 10&lt;sup&gt;2&lt;/sup&gt;. Basically, n=10 and so O(n&lt;sup&gt;2&lt;/sup&gt;) gives us the scaling factor n&lt;sup&gt;2&lt;/sup&gt; which is 10&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">アイテムの数は10倍に増加しますが、時間は10 &lt;sup&gt;2&lt;/sup&gt;倍に増加します。 基本的に、n = 10なので、O（n &lt;sup&gt;2&lt;/sup&gt; ）は、スケーリング係数n &lt;sup&gt;2&lt;/sup&gt;である10 &lt;sup&gt;2を提供し&lt;/sup&gt;ます。</target>
        </trans-unit>
        <trans-unit id="257c3797269830bc9710d43ca3694a583cd402ae" translate="yes" xml:space="preserve">
          <source>Now I have some work.  I have this list: one, two, three, four, five, six.  I must add all things in this list.</source>
          <target state="translated">今、私はいくつかの仕事を持っています。私はこのリストを持っている 1,2,3,4,5,6.私はこのリストのすべてのものを追加しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ce4444486678ac072c200b97ac0870621f89a826" translate="yes" xml:space="preserve">
          <source>Now at times, I do have to go to work.  It is sad, but true.  So, when I am at work, I have a rule: I try to do less work.  As near to no work as I can.  Then I go play!</source>
          <target state="translated">今では、仕事に行かなければならない時があります。それは悲しいことですが、本当です。だから、仕事をしているときは、できるだけ仕事をしないようにするというルールを決めています。できるだけ仕事をしないようにします。それから遊びに行きます。</target>
        </trans-unit>
        <trans-unit id="4af2bcb5c492dc62ee7f7d5ed90f520c4c05c4e0" translate="yes" xml:space="preserve">
          <source>Now here comes big O, and he will tell us how hard this work is.  He says: to add all things from one to N, one by one, is O(n).  To add all these things, [I know I must add n times.][1]  That is big O!  He tells us how hard it is to do some type of work.</source>
          <target state="translated">ここで大きなOが来て,この仕事がどれほど大変かを教えてくれます.彼は言う:すべてのものを1からNまで一つずつ足していくのは、O(n)である。これらすべてのものを足すには,[私はn回足さなければならないことを知っています][1]これは大きなOです! ある種の仕事をするのがどれだけ大変かを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="6c34478c5f5b54c8853b19d59a2824aed411c88f" translate="yes" xml:space="preserve">
          <source>Now here is where big O is our friend.</source>
          <target state="translated">さて、ここでビッグ・オーが私たちの友人であることがわかりました。</target>
        </trans-unit>
        <trans-unit id="110a534fc79ede4defb1ebec55d0413c614f421d" translate="yes" xml:space="preserve">
          <source>Now if you were instructing a computer to look up the phone number for &quot;John Smith&quot; in a telephone book that contains 1,000,000 names, what would you do?  Ignoring the fact that you could guess how far in the S's started (let's assume you can't), what would you do?</source>
          <target state="translated">さて、もしあなたが100万人分の名前が載っている電話帳の中の「ジョン・スミス」の電話番号を調べるようにコンピュータに指示していたとしたら、あなたならどうしますか?Sが何番目から始まっているか推測できるという事実を無視して(推測できないと仮定して)、あなたならどうしますか?</target>
        </trans-unit>
        <trans-unit id="9540b13ba056381a0510ad691215a7809e459df8" translate="yes" xml:space="preserve">
          <source>Now that work is done, let&amp;rsquo;s go play!</source>
          <target state="translated">これで作業は完了です。遊びに行きましょう！</target>
        </trans-unit>
        <trans-unit id="d6eba09ebedd6f51a03a1027fa2fafcd89c71acb" translate="yes" xml:space="preserve">
          <source>Now they ask me to add from one to ten!  Why would I do that?  I did not want to add one to six.  To add from one to ten&amp;hellip; well&amp;hellip; that would be even more hard!</source>
          <target state="translated">今、彼らは私に1から10まで加えるように頼みます！ なぜそれをするのですか？ 1から6を追加したくありませんでした。 1から10に追加する&amp;hellip;ええと&amp;hellip;それはさらに難しいでしょう！</target>
        </trans-unit>
        <trans-unit id="00988e447c66a2cb48babcb9e00cb583a7ea2cdd" translate="yes" xml:space="preserve">
          <source>Now we must do new work.  Oh, no.  I don&amp;rsquo;t like this work thing at all.</source>
          <target state="translated">今、私たちは新しい仕事をしなければなりません。 大野。 この作品は全然嫌いです。</target>
        </trans-unit>
        <trans-unit id="2649fa4f7ace90e5e3a42578e0c5f2755906f188" translate="yes" xml:space="preserve">
          <source>Now when big O says it will take O(n squared) work, he does not mean n squared adds, on the nose.  It might be some small bit less, for some case.  But in the worst case, it will be near n squared steps of work to sort the deck.</source>
          <target state="translated">さて、ビッグ・オーがO(n乗)の仕事がかかると言ったとき、彼はn乗の足し算のことを言っているのではありません。場合によっては、もう少し少ないかもしれません。しかし、最悪の場合には、n乗に近い作業量になります。</target>
        </trans-unit>
        <trans-unit id="08d4d2dadf777a65ea195b7215d064cef2cd8721" translate="yes" xml:space="preserve">
          <source>Now you know my friend, Big O.  He helps us do less work.  And if you know big O, you can do less work too!</source>
          <target state="translated">これでビッグ・オーを知ったな 彼は仕事を減らしてくれる ビッグ・オーを知っていれば、あなたも仕事を減らすことができます!</target>
        </trans-unit>
        <trans-unit id="05dc08a4c399781657ad8add0a8aafb1f260a439" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s you and me talk of work. Most of the time, I do not like work.  Do you like work?  It may be the case that you do, but I am sure I do not.</source>
          <target state="translated">さて、あなたと私が仕事について話しましょう。 ほとんどの場合、私は仕事が好きではありません。 あなたは仕事が好きですか？ あなたがそうしているのかもしれませんが、私はそうしていないと確信しています。</target>
        </trans-unit>
        <trans-unit id="205e8cfdfc5930c2d0673af6524af6317388bfed" translate="yes" xml:space="preserve">
          <source>O and Ω are not symmetric (n = O(n&amp;sup2;), but n&amp;sup2; is not O(n)), but Ɵ is symmetric, and (since these relations are all transitive and reflexive) Ɵ, therefore, is symmetric and transitive and reflexive, and therefore partitions the set of all functions into &lt;em&gt;equivalence classes&lt;/em&gt;. An equivalence class is a set of things that we consider to be the same. That is to say, given any function you can think of, you can find a canonical/unique 'asymptotic representative' of the class (by generally taking the limit... I &lt;em&gt;think&lt;/em&gt;); just like you can group all integers into odds or evens, you can group all functions with Ɵ into x-ish, log(x)^2-ish, etc... by basically ignoring smaller terms (but sometimes you might be stuck with more complicated functions which are separate classes unto themselves).</source>
          <target state="translated">Oと&amp;Omega;は対称ではありません（n = O（n&amp;sup2;）ですが、n&amp;sup2;はO（n）ではありません）が、Ɵは対称であり、（これらの関係はすべて推移的かつ再帰的であるため）thereforeしたがって、対称的で推移的かつ再帰的です、したがって、すべての関数のセットを&lt;em&gt;等価クラスに&lt;/em&gt;分割し&lt;em&gt;ます&lt;/em&gt; 。 同等クラスとは、私たちが同じと考えるもののセットです。 つまり、考えることができる関数があれば、クラスの標準的/一意の「漸近的代表」を見つけることができます（一般的には制限を設けることで...と&lt;em&gt;思います&lt;/em&gt; ）。 すべての整数をオッズまたは偶数にグループ化できるのと同じように、Ɵを使用してすべての関数をx-ish、log（x）^ 2-ishなどにグループ化できます。基本的に、小さい項を無視します（ただし、より複雑な関数であり、クラス自体は別のものです）。</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="98e642472708191e8a65ac2ab3cf6a96d7f6885e" translate="yes" xml:space="preserve">
          <source>O(1) = O(n) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin; (but not the other way around, the equality is &quot;fake&quot;),</source>
          <target state="translated">O（1）= O（n）= O（n &lt;sup&gt;2&lt;/sup&gt; ）（n&amp;rarr;+&amp;infin;の場合（ただし、その逆ではない）、等式は「偽」）、</target>
        </trans-unit>
        <trans-unit id="25c301e3f5329dedc950de0f1c38ac8d3d8286a2" translate="yes" xml:space="preserve">
          <source>O(1) describes an algorithm that will always execute in the same time
  (or space) regardless of the size of the input data set.</source>
          <target state="translated">O(1)は、入力データセットのサイズに関係なく、常に同じ時間(または空間)で実行されるアルゴリズムを記述しています。</target>
        </trans-unit>
        <trans-unit id="1e77cb950a650cbda7e41c7e563dfc7d75184ce0" translate="yes" xml:space="preserve">
          <source>O(1), means your computer gets a task done with &lt;code&gt;1&lt;/code&gt; step, it's excellent, Ordered No.1</source>
          <target state="translated">O（1）は、コンピューターが &lt;code&gt;1&lt;/code&gt; つのステップでタスクを完了することを意味します。これは優れています。注文番号1です。</target>
        </trans-unit>
        <trans-unit id="8681bf4e62cb366ee6970996fa273715542e1c24" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;N&lt;/sup&gt;)</source>
          <target state="translated">O(2&lt;sup&gt;N&lt;/sup&gt;)</target>
        </trans-unit>
        <trans-unit id="e3d80bfb500c859c180f245124c30408ce843ee8" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;N&lt;/sup&gt;) denotes an algorithm whose growth doubles with each additon to
  the input data set. The growth curve of an O(2&lt;sup&gt;N&lt;/sup&gt;) function is
  exponential - starting off very shallow, then rising meteorically. An
  example of an O(2&lt;sup&gt;N&lt;/sup&gt;) function is the recursive calculation of Fibonacci
  numbers:</source>
          <target state="translated">O（2 &lt;sup&gt;N&lt;/sup&gt; ）は、入力データセットへの各追加で成長が倍になるアルゴリズムを示します。 O（2 &lt;sup&gt;N&lt;/sup&gt; ）関数の成長曲線は指数関数的です-非常に浅いところから始まり、その後は気象的に上昇しています。 O（2 &lt;sup&gt;N&lt;/sup&gt; ）関数の例は、フィボナッチ数列の再帰的な計算です。</target>
        </trans-unit>
        <trans-unit id="68bc7ad068f5c61d49e37e6fc72efd56e5f32c9c" translate="yes" xml:space="preserve">
          <source>O(2&lt;sup&gt;n&lt;/sup&gt;): If the input size increases by one, the runtime doubles</source>
          <target state="translated">O（2 &lt;sup&gt;n&lt;/sup&gt; ）：入力サイズが1増えると、ランタイムは2倍になります</target>
        </trans-unit>
        <trans-unit id="63e9d8727f40f7ec9e8552148c03efe752771415" translate="yes" xml:space="preserve">
          <source>O(2^N),  get a task done with &lt;code&gt;2^N&lt;/code&gt; steps, it's horrible, Order No.6</source>
          <target state="translated">O（2 ^ N）、 &lt;code&gt;2^N&lt;/code&gt; ステップでタスクを完了する、それは恐ろしい、注文番号 6</target>
        </trans-unit>
        <trans-unit id="308b527a11caed66089316ea8a6e1067c1969f82" translate="yes" xml:space="preserve">
          <source>O(N!),  get a task done with &lt;code&gt;N!&lt;/code&gt; steps, it's terrible, Order No.7</source>
          <target state="translated">O（N！）、 &lt;code&gt;N!&lt;/code&gt; ステップ、ひどい、注文番号7</target>
        </trans-unit>
        <trans-unit id="a257064879b3c5b994b0c4eb5698b028eb534479" translate="yes" xml:space="preserve">
          <source>O(N)</source>
          <target state="translated">O(N)</target>
        </trans-unit>
        <trans-unit id="c3f150e3661faff6df87ef3476136d42ffe76b00" translate="yes" xml:space="preserve">
          <source>O(N) describes an algorithm whose performance will grow linearly and
  in direct proportion to the size of the input data set. The example
  below also demonstrates how Big O favours the worst-case performance
  scenario; a matching string could be found during any iteration of the
  for loop and the function would return early, but Big O notation will
  always assume the upper limit where the algorithm will perform the
  maximum number of iterations.</source>
          <target state="translated">O(N)は、入力データセットのサイズに比例して性能が直線的に成長するアルゴリズムを記述します。以下の例では、Big O がどのようにワーストケースの性能シナリオに有利であるかを示しています。for ループのどの反復処理でも一致する文字列が見つかり、関数は早期に戻ってきますが、Big O 記法は常にアルゴリズムが最大反復回数を実行する上限を想定しています。</target>
        </trans-unit>
        <trans-unit id="50a60625d0c152951efa7ecdbe93cfe7f46beda6" translate="yes" xml:space="preserve">
          <source>O(N), finish a task with &lt;code&gt;N&lt;/code&gt; steps, its fair, Order No.3</source>
          <target state="translated">O（N）、 &lt;code&gt;N&lt;/code&gt; ステップでタスクを完了する、そのフェア、注文番号 3</target>
        </trans-unit>
        <trans-unit id="56b0b7dfdc166b52f3daf1b1c70a817924759e73" translate="yes" xml:space="preserve">
          <source>O(N&lt;sup&gt;2&lt;/sup&gt;)</source>
          <target state="translated">O(N&lt;sup&gt;2&lt;/sup&gt;)</target>
        </trans-unit>
        <trans-unit id="8c2b565c37a449cbce6a610382372bb9973c5a59" translate="yes" xml:space="preserve">
          <source>O(N&lt;sup&gt;2&lt;/sup&gt;) represents an algorithm whose performance is directly
  proportional to the square of the size of the input data set. This is
  common with algorithms that involve nested iterations over the data
  set. Deeper nested iterations will result in O(N&lt;sup&gt;3&lt;/sup&gt;), O(N&lt;sup&gt;4&lt;/sup&gt;) etc.</source>
          <target state="translated">O（N &lt;sup&gt;2&lt;/sup&gt; ）は、パフォーマンスが入力データセットのサイズの2乗に正比例するアルゴリズムを表します。 これは、データセットのネストされた反復を含むアルゴリズムで一般的です。 より深くネストされた反復はO（N &lt;sup&gt;3&lt;/sup&gt; ）、O（N &lt;sup&gt;4&lt;/sup&gt; ）などになります。</target>
        </trans-unit>
        <trans-unit id="de99ca4237dd94527753ecf95f080066d3a66999" translate="yes" xml:space="preserve">
          <source>O(N^2),  get a task done with &lt;code&gt;N^2&lt;/code&gt; steps, it's bad, Order No.5</source>
          <target state="translated">O（N ^ 2）、 &lt;code&gt;N^2&lt;/code&gt; ステップでタスクを実行する、それは悪い、注文番号 5</target>
        </trans-unit>
        <trans-unit id="044f421fbafcb690927916033a456e1ccb0b67d2" translate="yes" xml:space="preserve">
          <source>O(NlogN), ends a task with &lt;code&gt;O(NlogN)&lt;/code&gt; steps, it's not good, Order No.4</source>
          <target state="translated">O（NlogN）、 &lt;code&gt;O(NlogN)&lt;/code&gt; ステップでタスクを終了します、それは良くありません、注文番号 4</target>
        </trans-unit>
        <trans-unit id="adcb5e72616abf45d10a5b515b2a078ad0f91adb" translate="yes" xml:space="preserve">
          <source>O(O(n&lt;sup&gt;2&lt;/sup&gt;)) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">O（O（n &lt;sup&gt;2&lt;/sup&gt; ））= O（n &lt;sup&gt;2&lt;/sup&gt; ）（n&amp;rarr;+&amp;infin;の場合）</target>
        </trans-unit>
        <trans-unit id="ece6ebf71b235bbf6ca0d80731462a53a21f231d" translate="yes" xml:space="preserve">
          <source>O(log n): If the input size doubles the runtime increases by one</source>
          <target state="translated">O(log n)である。入力サイズが2倍になると、実行時間は1倍になります。</target>
        </trans-unit>
        <trans-unit id="7e25f642c5b31ae751d0fbe5acb56b926e9390ba" translate="yes" xml:space="preserve">
          <source>O(logN), means your computer complete a task with &lt;code&gt;logN&lt;/code&gt; steps, its good, Ordered No.2</source>
          <target state="translated">O（logN）は、コンピューターが &lt;code&gt;logN&lt;/code&gt; ステップでタスクを完了することを意味します。</target>
        </trans-unit>
        <trans-unit id="d09f9f7cdec58e339154e9a9c832d0991809a760" translate="yes" xml:space="preserve">
          <source>O(n) + O(n&lt;sup&gt;2&lt;/sup&gt;) = O(n&lt;sup&gt;2&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">O（n）+ O（n &lt;sup&gt;2&lt;/sup&gt; ）= O（n &lt;sup&gt;2&lt;/sup&gt; ）（n&amp;rarr;+&amp;infin;の場合）</target>
        </trans-unit>
        <trans-unit id="97dd63fef8702296bf87a4c2e21f4bd48ff0b539" translate="yes" xml:space="preserve">
          <source>O(n) means Big O is n, and now you might think, &quot;What is n!?&quot; Well &quot;n&quot; is the amount of elements. Imaging you want to search for an Item in an Array. You would have to look on Each element and as &quot;Are you the correct element/item?&quot; in the worst case, the item is at the last index, which means that it took as much time as there are items in the list, so to be generic, we say &quot;oh hey, n is a fair given amount of values!&quot;.</source>
          <target state="translated">O(n)は Big O が n であることを意味しますが、&quot;n とは何か!&quot;と思うかもしれません。と思うかもしれませんが、&quot;n &quot;は要素の量です。配列の中のアイテムを検索したいと想像してみてください。あなたは、各要素を見て、&quot;あなたは正しいelementitemですか?&quot;として、最悪の場合、項目は、リスト内の項目があるのと同じくらいの時間がかかったことを意味する最後のインデックスにありますので、一般的であるために、我々は &quot;ああ、おい、nは値の公正な与えられた量です!&quot;と言います。</target>
        </trans-unit>
        <trans-unit id="d0849346fa8631d6b61d0173d101e04d26feaa94" translate="yes" xml:space="preserve">
          <source>O(n) ~ Linear</source>
          <target state="translated">O(n)~ 線形</target>
        </trans-unit>
        <trans-unit id="a5fa19f57aec98afc3fc69df842b447d2a094f4c" translate="yes" xml:space="preserve">
          <source>O(n), O(n&lt;sup&gt;2&lt;/sup&gt;) etc. are all polynomial time. Some problems cannot be solved in polynomial time. Certain things are used in the world because of this. &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;Public Key Cryptography&lt;/a&gt; is a prime example. It is computationally hard to find two prime factors of a very large number. If it wasn't, we couldn't use the public key systems we use.</source>
          <target state="translated">O（n）、O（n &lt;sup&gt;2&lt;/sup&gt; ）などはすべて多項式時間です。 一部の問題は多項式時間では解決できません。 そのため、世の中にはある物が使われています。 &lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;公開鍵暗号化&lt;/a&gt;はその代表的な例です。 非常に大きな数の2つの素因数を見つけることは計算上困難です。 そうでなければ、私たちが使用している公開鍵システムは使用できません。</target>
        </trans-unit>
        <trans-unit id="f995f059c281a355753f38679edd0e7f61f9dfcf" translate="yes" xml:space="preserve">
          <source>O(n): If I double the input size the runtime doubles</source>
          <target state="translated">O(n)。入力サイズを2倍にすると実行時間が2倍になる</target>
        </trans-unit>
        <trans-unit id="830c15d5357ce8008571a4bcc897c78270ce5607" translate="yes" xml:space="preserve">
          <source>O(n&lt;sup&gt;2&lt;/sup&gt;): If the input size doubles the runtime quadruples</source>
          <target state="translated">O（n &lt;sup&gt;2&lt;/sup&gt; ）：入力サイズがランタイムの4倍になる場合</target>
        </trans-unit>
        <trans-unit id="8639ae6910d96d5623a09688e0818a131fb8c50f" translate="yes" xml:space="preserve">
          <source>O(n&lt;sup&gt;2&lt;/sup&gt;)O(n&lt;sup&gt;3&lt;/sup&gt;) = O(n&lt;sup&gt;5&lt;/sup&gt;) when n &amp;rarr; +&amp;infin;</source>
          <target state="translated">O（n &lt;sup&gt;2&lt;/sup&gt; ）O（n &lt;sup&gt;3&lt;/sup&gt; ）= O（n &lt;sup&gt;5&lt;/sup&gt; ）（n&amp;rarr;+&amp;infin;の場合）</target>
        </trans-unit>
        <trans-unit id="ac18ee6983cc2eb537d0f2f25351e9df638a26bd" translate="yes" xml:space="preserve">
          <source>Obviously that's only using &quot;size&quot; as the input and &quot;time taken&quot; as the output &amp;mdash; the same idea applies if you want to talk about memory usage etc.</source>
          <target state="translated">明らかに、これは入力として「サイズ」を使用し、出力として「所要時間」を使用しているだけです。メモリ使用量などについて話したい場合も同じ考え方が当てはまります。</target>
        </trans-unit>
        <trans-unit id="047235fd8fb4d12aece908a6c0ecf01e2c06606a" translate="yes" xml:space="preserve">
          <source>Of course this does not mean that loops and functions are bad; on the contrary, they are the building blocks of modern programming languages, and we love them. However, we can see that the way we weave loops and functions and conditionals together with our data (control flow, etc.) mimics the time and space usage of our program! If time and space usage becomes an issue, that is when we resort to cleverness and find an easy algorithm or data structure we hadn't considered, to reduce the order of growth somehow. Nevertheless, these visualization techniques (though they don't always work) can give you a naive guess at a worst-case running time.</source>
          <target state="translated">もちろん、これはループや関数が悪いという意味ではなく、逆に、それらは現代のプログラミング言語の構成要素であり、私たちはそれらを愛しています。しかし、ループや関数、条件式をデータ(制御フローなど)と一緒に組み立てる方法は、プログラムの時間と空間の使い方を真似していることがわかります。時間と空間の使用量が問題になった場合、それは私たちが賢さに頼って、私たちが考えもしなかった簡単なアルゴリズムやデータ構造を見つけて、どうにかして成長の順序を減らすことができるようにするときです。それでも、これらの可視化技術は(必ずしもうまくいくとは限りませんが)、最悪の場合の実行時間を簡単に推測することができます。</target>
        </trans-unit>
        <trans-unit id="02eb439e917fc58abf025b96d214507c593cd917" translate="yes" xml:space="preserve">
          <source>Oh no, now I have more work.  Sheesh.  Who makes this kind of stuff?!</source>
          <target state="translated">やばい、仕事が増えた。しまった 誰がこんなものを作ってるんだ!</target>
        </trans-unit>
        <trans-unit id="846bee0b9db59985faaa143bf6c6677865b72c7b" translate="yes" xml:space="preserve">
          <source>Ok, my 2cents.</source>
          <target state="translated">よし、俺の2セントだ</target>
        </trans-unit>
        <trans-unit id="4d41abb6d91ed8426b9c48d248c476619fafc156" translate="yes" xml:space="preserve">
          <source>Once I have found these two cards, I swap them, and go on to look for more cards to swap.  That is, I go back to step Two, and splay on the card you chose some more.</source>
          <target state="translated">この2枚のカードを見つけたら、その2枚を交換し、さらに交換するカードを探しに行きます。つまり、私はステップ2に戻り、あなたが選んだカードの上にいくつかの詳細をスプレイします。</target>
        </trans-unit>
        <trans-unit id="bbe0abb1706b2ab494f9baaf3f32394aa9b1d99e" translate="yes" xml:space="preserve">
          <source>One can notice that we've assumed the worst case scenario here. While multiplying 6 digit numbers, if one of them has 4 digits and the other one has 6 digits, then we only have 24 multiplications. Still, we calculate the worst case scenario for that 'n', i.e when both are 6 digit numbers. Hence Big-O notation is about the Worst-case scenario of an algorithm.</source>
          <target state="translated">ここでは最悪のケースを想定していることに気づくことができます。6桁の数字を掛け合わせているときに、片方が4桁でもう片方が6桁の場合は、24回の掛け算しかできません。それでも、我々は、その 'n' の最悪のシナリオ、すなわち両方が 6 桁の数字である場合を計算します。したがって、Big-O記法は、アルゴリズムの最悪のシナリオについてのものです。</target>
        </trans-unit>
        <trans-unit id="aa31e9cc8ee30f1096d7841ca16202599811c4d7" translate="yes" xml:space="preserve">
          <source>One important aspect of &quot;big O&quot; notation is that it &lt;em&gt;doesn't&lt;/em&gt; say which algorithm will be faster for a given size. Take a hashtable (string key, integer value)  vs an array of pairs (string, integer). Is it faster to find a key in the hashtable or an element in the array, based on a string? (i.e. for the array, &quot;find the first element where the string part matches the given key.&quot;) Hashtables are generally amortised (~= &quot;on average&quot;) O(1) &amp;mdash; once they're set up, it should take about the same time to find an entry in a 100 entry table as in a 1,000,000 entry table. Finding an element in an array (based on content rather than index) is linear, i.e. O(N) &amp;mdash; on average, you're going to have to look at half the entries.</source>
          <target state="translated">「ビッグO」表記法の重要な側面の1つは、指定されたサイズに対してどのアルゴリズムがより高速になるか&lt;em&gt;が示さ&lt;/em&gt;れて&lt;em&gt;いない&lt;/em&gt;ことです。 ハッシュテーブル（文字列キー、整数値）とペアの配列（文字列、整数）を取ります。 文字列に基づいて、ハッシュテーブルのキーまたは配列の要素を見つける方が高速ですか？ （つまり、配列の場合、「文字列部分が指定されたキーと一致する最初の要素を見つけます。」）ハッシュテーブルは通常、償却されます（〜=「平均して」）O（1）&amp;mdash;一度設定すると、約かかります。 100エントリテーブルと1,000,000エントリテーブルのエントリを同時に検索します。 （インデックスではなくコンテンツに基づいて）配列内の要素を見つけることは線形です。つまり、O（N）&amp;mdash;平均すると、エントリの半分を調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="455ac552ede28e8384f4279d82396b29180d80b5" translate="yes" xml:space="preserve">
          <source>One plus two is three&amp;hellip; plus three is six... and four is... I don&amp;rsquo;t know.  I got lost.  It is too hard for me to do in my head.  I don&amp;rsquo;t much care for this kind of work.</source>
          <target state="translated">1プラス2は3です&amp;hellip;プラス3は6 ...そして4は...わかりません。 道に迷った。 頭の中で行うのは難しい。 私はこの種の仕事をあまり気にしません。</target>
        </trans-unit>
        <trans-unit id="bc82ac3fdfa2c36fc2c53eae610e61a05eb3407a" translate="yes" xml:space="preserve">
          <source>One: I choose one card in the part of the deck we work on now.  You can choose one for me if you like.  (The first time we do this, &amp;ldquo;the part of the deck we work on now&amp;rdquo; is the whole deck, of course.)</source>
          <target state="translated">１：今取り組んでいるデッキの部分で１枚のカードを選びます。 必要に応じて、1つを選択できます。 （これを初めて行うときは、「現在取り組んでいるデッキの一部」はもちろん、デッキ全体です。）</target>
        </trans-unit>
        <trans-unit id="6f7dd336bd44297d43d1e2584ebc5605a1581c94" translate="yes" xml:space="preserve">
          <source>Only concerned with runtime grow relative to the input &lt;strong&gt;(n)&lt;/strong&gt;</source>
          <target state="translated">ランタイムにのみ関連して、入力&lt;strong&gt;（n）に&lt;/strong&gt;比例して増加します。</target>
        </trans-unit>
        <trans-unit id="e64c05fb1f7a3fd3c0cf63d3e43c979084e566b1" translate="yes" xml:space="preserve">
          <source>Or maybe you do log(N) passes of the data, for O(N*log(N)) total time:</source>
          <target state="translated">あるいは、データのlog(N)パスを、O(N*log(N)の合計時間で実行しているのかもしれません。</target>
        </trans-unit>
        <trans-unit id="03e6e7bc29b2694c5ad9d0d21e7d44ffe2e43e41" translate="yes" xml:space="preserve">
          <source>Our task went from an infeasible &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; to a manageable &lt;code&gt;O(N)&lt;/code&gt;, and all we had to do was pay a minor cost to make a hash table.</source>
          <target state="translated">私たちの仕事は、実行不可能な &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; から扱いやすい &lt;code&gt;O(N)&lt;/code&gt; になり、ハッシュテーブルを作成するためにわずかなコストを支払うだけで済みました。</target>
        </trans-unit>
        <trans-unit id="0732d399cd128b93b16b9a0583b8df0ddb1d224b" translate="yes" xml:space="preserve">
          <source>People will often use &lt;code&gt;= O(...)&lt;/code&gt;, which is perhaps the more correct 'comp-sci' notation, and entirely legitimate to use; &quot;f = O(...)&quot; is read &quot;f is order ... / f is xxx-bounded by ...&quot; and is thought of as &quot;f is some expression whose asymptotics are ...&quot;. I was taught to use the more rigorous &lt;code&gt;&amp;isin; O(...)&lt;/code&gt;. &lt;code&gt;&amp;isin;&lt;/code&gt; means &quot;is an element of&quot; (still read as before). In this particular case, &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; contains elements like {&lt;code&gt;2 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;3 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;1/2 N&amp;sup2;&lt;/code&gt;, &lt;code&gt;2 N&amp;sup2; + log(N)&lt;/code&gt;, &lt;code&gt;- N&amp;sup2; + N^1.9&lt;/code&gt;, ...} and is infinitely large, but it's still a set.</source>
          <target state="translated">人々はしばしば &lt;code&gt;= O(...)&lt;/code&gt; を使用します。これはおそらく、より正確な 'comp-sci'表記であり、使用することは完全に正当です。 &quot;f = O（...）&quot;は &quot;f is order ... / f is xxx-bounded by ...&quot;と読み、 &quot;fは漸近性が...であるいくつかの式である&quot;と考えられます。 より厳格な &lt;code&gt;&amp;isin; O(...)&lt;/code&gt; を使用するように教えられました。 は「の要素」であることを意味します（以前と同じように読みます） この特定のケースでは、 &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; は{ &lt;code&gt;2 N&amp;sup2;&lt;/code&gt; 、 &lt;code&gt;3 N&amp;sup2;&lt;/code&gt; 、 &lt;code&gt;1/2 N&amp;sup2;&lt;/code&gt; 、 &lt;code&gt;2 N&amp;sup2; + log(N)&lt;/code&gt; 、 &lt;code&gt;- N&amp;sup2; + N^1.9&lt;/code&gt; 、...}のような要素を含み、無限に大きいですが、まだセット。</target>
        </trans-unit>
        <trans-unit id="aff7f1ca724e63fb9ec4afc2e9f2dbdfa5bff1a0" translate="yes" xml:space="preserve">
          <source>Please note the order at line end, just for your better understanding.There's more than 7 notations if all possibilities considered.</source>
          <target state="translated">行末の順番に注意してください。</target>
        </trans-unit>
        <trans-unit id="ff6f34b84d9b2e644758179e12f471c8957fb41f" translate="yes" xml:space="preserve">
          <source>Polynomial Time</source>
          <target state="translated">多項式時間</target>
        </trans-unit>
        <trans-unit id="c745366182e555ccc5603f9f335f3de2d95eae3a" translate="yes" xml:space="preserve">
          <source>Practically speaking, Big O analysis is &lt;em&gt;so useful and important&lt;/em&gt; because Big O puts the focus squarely on the algorithm's &lt;em&gt;own&lt;/em&gt; complexity and completely &lt;em&gt;ignores&lt;/em&gt; anything that is merely a proportionality constant&amp;mdash;like a JavaScript engine, the speed of a CPU, your Internet connection, and all those things which become quickly become as laughably outdated as a Model &lt;em&gt;T&lt;/em&gt;. Big O focuses on performance only in the way that matters equally as much to people living in the present or in the future.</source>
          <target state="translated">実用的に言えば、Big Oはアルゴリズム&lt;em&gt;自体の&lt;/em&gt;複雑さに真っ向から焦点を当て、JavaScriptエンジン、CPUの速度、インターネット接続など、単なる比例定数であるものを完全に&lt;em&gt;無視する&lt;/em&gt; &lt;em&gt;ため&lt;/em&gt; 、Big O分析は&lt;em&gt;非常に有用で重要です。&lt;/em&gt;モデルの&lt;em&gt;Tの&lt;/em&gt;ようにすぐに笑えるようになってしまうすべてのもの。 Big Oは、現在または未来に住んでいる人々と同じくらい重要な方法でのみパフォーマンスに焦点を当てています。</target>
        </trans-unit>
        <trans-unit id="707ddefda8b9d501a1d63dad3fcb74d0cb28b51a" translate="yes" xml:space="preserve">
          <source>Preface</source>
          <target state="translated">Preface</target>
        </trans-unit>
        <trans-unit id="c96271fcfba3e64dd9236be70e3f3f5fc45c32c9" translate="yes" xml:space="preserve">
          <source>Programs will also run slower on a 500MHz computer vs 2GHz computer. We don't really consider this as part of the resource bounds, because we think of the scaling in terms of machine resources (e.g. per clock cycle), not per real second. However, there are similar things which can 'secretly' affect performance, such as whether you are running under emulation, or whether the compiler optimized code or not. These might make some basic operations take longer (even relative to each other), or even speed up or slow down some operations asymptotically (even relative to each other). The effect may be small or large between different implementation and/or environment. Do you switch languages or machines to eke out that little extra work? That depends on a hundred other reasons (necessity, skills, coworkers, programmer productivity, the monetary value of your time, familiarity, workarounds, why not assembly or GPU, etc...), which may be more important than performance.</source>
          <target state="translated">また、500MHz コンピュータと 2GHz コンピュータでは、プログラムの実行も遅くなります。これはリソース境界の一部とは考えていません。なぜなら、スケーリングは実秒あたりではなく、マシンリソース(例えばクロックサイクルあたり)で考えているからです。しかし、エミュレーションを実行しているかどうか、コンパイラがコードを最適化しているかどうかなど、「ひそかに」パフォーマンスに影響を与える可能性のある同様のことがあります。これらのことが原因で、いくつかの基本的な処理に時間がかかったり(相対的にも)、漸近的に(相対的にも)処理が速くなったり遅くなったりすることがあります。この影響は、異なる実装や環境の間では小さいかもしれないし、大きいかもしれません。ちょっとした余分な作業を処理するために、言語やマシンを切り替えることはありますか?それは他の百の理由(必要性、スキル、同僚、プログラマーの生産性、時間の金銭的価値、親しみやすさ、回避策、なぜアセンブリやGPUではないのか、など)に依存するが、それらはパフォーマンスよりも重要かもしれない。</target>
        </trans-unit>
        <trans-unit id="0d31501e03db9492d0d452e6624c95d2a7fc34fc" translate="yes" xml:space="preserve">
          <source>Put another way, it's all about the &lt;strong&gt;ratio&lt;/strong&gt; as you go to infinity. &lt;em&gt;If you divide the actual time it takes by the &lt;code&gt;O(...)&lt;/code&gt;, you will get a constant factor in the limit of large inputs.&lt;/em&gt; Intuitively this makes sense: functions &quot;scale like&quot; one another if you can multiply one to get the other. That is when we say...</source>
          <target state="translated">別の言い方をすれば、無限大に行くときの&lt;strong&gt;比率が&lt;/strong&gt;すべてです。 &lt;em&gt;実際にかかる時間を &lt;code&gt;O(...)&lt;/code&gt; で除算すると、大きな入力の制限で一定の係数が得られます。&lt;/em&gt; 直感的にこれは理にかなっています。一方を乗算してもう一方を取得できる場合、関数は互いに「同じようにスケーリング」します。 それは私たちが言うとき...</target>
        </trans-unit>
        <trans-unit id="b123240c4cc86a314f0b2ff2c7fcffe4a190bdd3" translate="yes" xml:space="preserve">
          <source>Putting everything in an airing cupboard: If we put everything in one big pile and just let general warmth do it, it will take a long time for the middle shirts to get dry. I wouldn't like to guess at the detail, but I suspect this is at least O(N^2) &amp;mdash; as you increase the wash load, the drying time increases faster.</source>
          <target state="translated">すべてを通気性のある食器棚に入れる：すべてを1つの大きな山に入れて、一般的な暖かさだけをさせると、真ん中のシャツが乾くまでに長い時間がかかります。 詳細については推測したくありませんが、これは少なくともO（N ^ 2）だと思います。洗浄負荷を増やすと、乾燥時間が速くなります。</target>
        </trans-unit>
        <trans-unit id="44d6998253d7ce7630dea94f49784bcc34a98b86" translate="yes" xml:space="preserve">
          <source>Quick Sort breaks up big decks in small ones.  That is to say, it breaks up big tasks in small ones.</source>
          <target state="translated">Quick Sortは大きなデッキを小さなものに分割します。つまり、大きなタスクを小さなものに分割します。</target>
        </trans-unit>
        <trans-unit id="aafbf15c3d2cb24c90abf21327172d843932cd8c" translate="yes" xml:space="preserve">
          <source>Quick note, this is almost certainly confusing &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt; (which is an upper bound) with Theta notation &quot;&amp;Theta;&quot; (which is a two-side bound). In my experience, this is actually typical of discussions in non-academic settings. Apologies for any confusion caused.</source>
          <target state="translated">簡単に言うと、これはほぼ確実に&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O表記&lt;/a&gt; （上限）とTheta表記「&amp;Theta;」（両側の上限）を混同しています。 私の経験では、これは実際には非学術的な設定での議論の典型です。 混乱を招きましたことをお詫び申し上げます。</target>
        </trans-unit>
        <trans-unit id="78240c3b95a799ddc676899ee3f052157355ad48" translate="yes" xml:space="preserve">
          <source>Resource : Could be total-CPU time, could be maximum RAM space. By default refers to CPU time.</source>
          <target state="translated">Resource:CPUの合計時間、RAMの最大容量を指定することができます。デフォルトではCPU時間を指します。</target>
        </trans-unit>
        <trans-unit id="ac86f485121aebe3e0cdccd29ad1f58c3d7af9cc" translate="yes" xml:space="preserve">
          <source>Say the problem is &quot;Find the Combination&quot;,</source>
          <target state="translated">問題は「組み合わせを探す」とします。</target>
        </trans-unit>
        <trans-unit id="a93e27c51787651f155cd14f8a574fade12b6fb2" translate="yes" xml:space="preserve">
          <source>Say the problem is &quot;Find the sum&quot;,</source>
          <target state="translated">問題を「和を求める」とします。</target>
        </trans-unit>
        <trans-unit id="a090d13ccede8e7fd94f3cd08042cf4d8572f583" translate="yes" xml:space="preserve">
          <source>Say you order Harry Potter: Complete 8-Film Collection [Blu-ray] from Amazon and download the same film collection online at the same time. You want to test which method is faster. The delivery takes almost a day to arrive and the download completed about 30 minutes earlier. Great! So it&amp;rsquo;s a tight race.</source>
          <target state="translated">たとえば、ハリーポッター：アマゾンから完全な8フィルムコレクション[ブルーレイ]を注文し、同じフィルムコレクションをオンラインで同時にダウンロードするとします。 どちらの方法が速いかをテストしたいとします。 配信が到着するまでに約1日かかり、ダウンロードは約30分早く完了しました。 すごい！ ですからタイトなレースです。</target>
        </trans-unit>
        <trans-unit id="7c15a59b277cd7091e5fcf18a82064b3a5dd08e6" translate="yes" xml:space="preserve">
          <source>See more at: &lt;a href=&quot;http://proprogramming.org/2015/01/how-to-calculate-time-complexity-of.html#sthash.URrGFhqm.dpuf&quot;&gt;Here&lt;/a&gt;</source>
          <target state="translated">詳しくはこちらをご覧ください</target>
        </trans-unit>
        <trans-unit id="1401abdd96246a6a7cc788610b57a7b896aa0b20" translate="yes" xml:space="preserve">
          <source>See the pattern?  The &lt;strong&gt;complexity&lt;/strong&gt; (being the number of operations) is directly proportional to the number of digits &lt;em&gt;n&lt;/em&gt; in the larger number.  We call this &lt;strong&gt;O(n)&lt;/strong&gt; or &lt;strong&gt;linear complexity&lt;/strong&gt;.</source>
          <target state="translated">パターンがわかりますか？ &lt;strong&gt;複雑さ&lt;/strong&gt; （操作の数）は、大きい方の桁数&lt;em&gt;n&lt;/em&gt;に正比例します。 これを&lt;strong&gt;O（n）&lt;/strong&gt;または&lt;strong&gt;線形複雑度&lt;/strong&gt;と呼び&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bb8c396c1b1d4188f90d674eebb67f47ab45d2b" translate="yes" xml:space="preserve">
          <source>Since Big-O doesn't care too much about constant factor (aka 3), the Big-O of your algorithm is &lt;code&gt;O(N^2 + log(X))&lt;/code&gt;. It basically translates 'the amount of operations your algorithm needs for the worst case scales with this'.</source>
          <target state="translated">Big-Oは定数係数（別名3）をあまり気にしないので、アルゴリズムのBig-Oは &lt;code&gt;O(N^2 + log(X))&lt;/code&gt; です。 これは基本的に「最悪の場合にアルゴリズムが必要とする演算量をこれでスケーリングする」と解釈されます。</target>
        </trans-unit>
        <trans-unit id="185fbeb7236225913f02d9ced51afffe91dadcbe" translate="yes" xml:space="preserve">
          <source>So here is the big news: the big O can help me not to do work!  I can play more of the time, if I know big O.  Less work, more play!  That is what big O helps me do.</source>
          <target state="translated">ビッグ・オーは仕事をしなくてもいいようにしてくれます。ビッグ・オーを知っていれば、より多くの時間を遊ぶことができる。それがビッグ・オーのお陰です。</target>
        </trans-unit>
        <trans-unit id="f282cf5ef96e90a6a7f9b1e3944e8a0596d69aa5" translate="yes" xml:space="preserve">
          <source>So if you want to find a name in a phone book of a million names you can actually find any name by doing this at most 20 times.  In comparing search algorithms we decide that this comparison is our 'n'.</source>
          <target state="translated">ですから、100万人の名前の電話帳の中から名前を見つけたい場合は、これを最大20回行うことで、実際にはどのような名前でも見つけることができます。検索アルゴリズムを比較する際には、この比較が私たちの「n」であると判断します。</target>
        </trans-unit>
        <trans-unit id="54d9d5007b7529ef62839a976a2c108028d8927a" translate="yes" xml:space="preserve">
          <source>So let's not do the work.  Let's you and me just think how hard it is.  How much work would I have to do, to add six numbers?</source>
          <target state="translated">だから、仕事はやめよう。どれだけ大変か考えよう 6つの数字を足すのがどれだけ大変か?</target>
        </trans-unit>
        <trans-unit id="0f7963f5bf0d662a36fd7990d2218173d00f1e7f" translate="yes" xml:space="preserve">
          <source>So the Big-O of the Traveling Salesman problem is &lt;strong&gt;O(n!)&lt;/strong&gt; or &lt;strong&gt;factorial or combinatorial complexity&lt;/strong&gt;.</source>
          <target state="translated">したがって、巡回セールスマン問題のBig-Oは&lt;strong&gt;O（n！）&lt;/strong&gt;または&lt;strong&gt;階乗または組み合わせの複雑さ&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="31cbba1dd119c95cd531f79932736280f8bc1df4" translate="yes" xml:space="preserve">
          <source>So then you might understand what &quot;n&lt;sup&gt;2&lt;/sup&gt;&quot; means, but to be even more specific, play with the thought you have a simple, the simpliest of the sorting algorithms; bubblesort. This algorithm needs to look through the whole list, for each item.</source>
          <target state="translated">したがって、「n &lt;sup&gt;2&lt;/sup&gt; 」の意味を理解するかもしれませんが、さらに具体的に言うと、並べ替えアルゴリズムの最も単純な、単純な考えを試してください。 バブルソート。 このアルゴリズムでは、アイテムごとにリスト全体を調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="f8d83ca9666fef6b181abee5dce4073e31010f19" translate="yes" xml:space="preserve">
          <source>So to find a name given the phone number (reverse lookup):</source>
          <target state="translated">だから、電話番号を与えられた名前を見つけるために(逆引き)。</target>
        </trans-unit>
        <trans-unit id="d9f1ae7f841915d3f4dd37e4ec3ed8f5c6a2d975" translate="yes" xml:space="preserve">
          <source>So to talk of big O, I will use words that have just one beat in them.  One sound per word.  Small words are quick.  You know these words, and so do I.  We will use words with one sound.  They are small.  I am sure you will know all of the words we will use!</source>
          <target state="translated">そこで、ビッグオーの話をするために、一拍だけ入っている単語を使います。一語に一音。小さい言葉は早いです。あなたも知っていると思いますが 私も知っています 1つの音だけの単語を使います それらは小さいです。私たちが使う単語はすべて知っているでしょう!」と言っていました。</target>
        </trans-unit>
        <trans-unit id="1a6bae9cafba4af7ae15b7b23952da6ff1ac18ed" translate="yes" xml:space="preserve">
          <source>Some asymptotically superior algorithms (e.g. a non-comparison &lt;code&gt;O(N log(log(N)))&lt;/code&gt; sort) can have so large a constant factor (e.g. &lt;code&gt;100000*N log(log(N))&lt;/code&gt;), or overhead that is relatively large like &lt;code&gt;O(N log(log(N)))&lt;/code&gt; with a hidden &lt;code&gt;+ 100*N&lt;/code&gt;, that they are rarely worth using even on &quot;big data&quot;.</source>
          <target state="translated">一部の漸近的に優れたアルゴリズム（例：非比較 &lt;code&gt;O(N log(log(N)))&lt;/code&gt; ソート）には、非常に大きな定数係数（例： &lt;code&gt;100000*N log(log(N))&lt;/code&gt; ）、または比較的大きなオーバーヘッドがあります。非表示 &lt;code&gt;+ 100*N&lt;/code&gt; &lt;code&gt;O(N log(log(N)))&lt;/code&gt; のように、「ビッグデータ」でも使用する価値はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="6c3a47a93192e21e7b8da9213efad49591e03019" translate="yes" xml:space="preserve">
          <source>Something to think about.</source>
          <target state="translated">何か考えることがある。</target>
        </trans-unit>
        <trans-unit id="4039fdaf71cb4809949b869888d7b88d6c807b40" translate="yes" xml:space="preserve">
          <source>Sounds simple?  Think again.</source>
          <target state="translated">簡単そうだな?もう一度考えてみてください。</target>
        </trans-unit>
        <trans-unit id="3b9b41baa4e75cb4e6d6c6fd70132096551ccfd4" translate="yes" xml:space="preserve">
          <source>Subtraction is similar (except you may need to borrow instead of carry).</source>
          <target state="translated">引き算は似ています(キャリーの代わりに借りる必要があるかもしれませんが)。</target>
        </trans-unit>
        <trans-unit id="92cba8f42714e9e6f65905758a187f5dc1f81125" translate="yes" xml:space="preserve">
          <source>Such a beautifully simple and short question seems at least to deserve an equally short answer, like a student might receive during tutoring.</source>
          <target state="translated">このような美しくシンプルで短い質問は、少なくとも、生徒が家庭教師の間に受け取るかもしれないような、同じように短い答えに値するように思えます。</target>
        </trans-unit>
        <trans-unit id="3c2db9ddb042cb95f6f3da33f58156282aae57f5" translate="yes" xml:space="preserve">
          <source>Suppose</source>
          <target state="translated">Suppose</target>
        </trans-unit>
        <trans-unit id="6497864fec97aa054dc0495fd9cf472b076841fc" translate="yes" xml:space="preserve">
          <source>Suppose you get notation &lt;code&gt;O(N^2)&lt;/code&gt;, not only you are clear the method takes N*N steps to accomplish a task, also you see that it's not good as &lt;code&gt;O(NlogN)&lt;/code&gt; from its ranking.</source>
          <target state="translated">表記 &lt;code&gt;O(N^2)&lt;/code&gt; を取得するとします。メソッドがタスクを実行するためにN * Nステップを実行することが明らかであるだけでなく、ランキングから &lt;code&gt;O(NlogN)&lt;/code&gt; としても良くないことがわかります。</target>
        </trans-unit>
        <trans-unit id="b05781eb417d58d8870e0c54b7d3d4450a3c5cf7" translate="yes" xml:space="preserve">
          <source>T(n)= The actual function that expresses the running time of the algorithm as a function of n</source>
          <target state="translated">T(n)=アルゴリズムの実行時間をnの関数として表す実際の関数</target>
        </trans-unit>
        <trans-unit id="223cc76142198af8e0fb0a088ef6eb8d1fdff9c7" translate="yes" xml:space="preserve">
          <source>Take this to 4 towns and you have (iirc) 12 possibilities.</source>
          <target state="translated">これを4つの町に持っていくと、12の可能性があります。</target>
        </trans-unit>
        <trans-unit id="6717a00806c940ae11e172679a7461df17fb3524" translate="yes" xml:space="preserve">
          <source>That is staggeringly good isn't it?</source>
          <target state="translated">驚異的に良いですよね。</target>
        </trans-unit>
        <trans-unit id="2b3ca8fd4b8fd6b2746880e61409e1fcd178be5c" translate="yes" xml:space="preserve">
          <source>That's the gist of it. They reduce the maths down so it might not be exactly n&lt;sup&gt;2&lt;/sup&gt; or whatever they say it is, but that'll be the dominating factor in the scaling.</source>
          <target state="translated">それはそれの要点です。 彼らは数学を削減するので、それは正確にn &lt;sup&gt;2&lt;/sup&gt;または彼らがそう言っているものではないかもしれませんが、それがスケーリングの支配的な要因になります。</target>
        </trans-unit>
        <trans-unit id="a335b2fdf194a4b123c6adefad53cd69da1191ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&lt;/code&gt; notation might be the more common one and is even used in papers by world-renowned computer scientists. Additionally, it is often the case that in a casual setting, people will say &lt;code&gt;O(...)&lt;/code&gt; when they mean &lt;code&gt;Ɵ(...)&lt;/code&gt;; this is technically true since the set of things &lt;code&gt;Ɵ(exactlyThis)&lt;/code&gt; is a subset of &lt;code&gt;O(noGreaterThanThis)&lt;/code&gt;... and it's easier to type. ;-)</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; 表記がより一般的な表記である可能性があり、世界的に有名なコンピューター科学者による論文でも使用されています。 さらに、カジュアルな設定では、 &lt;code&gt;Ɵ(...)&lt;/code&gt; を意味するときに &lt;code&gt;O(...)&lt;/code&gt; と言うことがよくあります。 &lt;code&gt;Ɵ(exactlyThis)&lt;/code&gt; のセットは &lt;code&gt;O(noGreaterThanThis)&lt;/code&gt; のサブセットなので、これは技術的に当てはまります。 ;-)</target>
        </trans-unit>
        <trans-unit id="aee94d96800326a2e37c8dd00dc11f09cbb047c7" translate="yes" xml:space="preserve">
          <source>The O in &quot;Big O&quot; refers to as &quot;Order&quot;(or precisely &quot;order of&quot;)</source>
          <target state="translated">Big O」のOは「Order」(正確には「order of」)のことを指します。</target>
        </trans-unit>
        <trans-unit id="bc4389e9f64069d428331282297c6e278a98864d" translate="yes" xml:space="preserve">
          <source>The Telephone Book</source>
          <target state="translated">電話帳</target>
        </trans-unit>
        <trans-unit id="8cb03116d21f7000400f4bb7814a757a5f5a7de1" translate="yes" xml:space="preserve">
          <source>The Traveling Salesman</source>
          <target state="translated">旅するセールスマン</target>
        </trans-unit>
        <trans-unit id="72a9a665cf2e8f84b6ab25450c58c79f3d3908aa" translate="yes" xml:space="preserve">
          <source>The above issues, like the effect of the choice of which programming language is used, are almost never considered as part of the constant factor (nor should they be); yet one should be aware of them because &lt;em&gt;sometimes&lt;/em&gt; (though rarely) they may affect things. For example in cpython, the native priority queue implementation is asymptotically non-optimal (&lt;code&gt;O(log(N))&lt;/code&gt; rather than &lt;code&gt;O(1)&lt;/code&gt; for your choice of insertion or find-min); do you use another implementation? Probably not, since the C implementation is probably faster, and there are probably other similar issues elsewhere. There are tradeoffs; sometimes they matter and sometimes they don't.</source>
          <target state="translated">上記の問題は、どのプログラミング言語を使用するかの選択の影響と同様に、定数要素の一部と見なされることはほとんどありません（そうである必要もありません）。 しかし、 &lt;em&gt;時には&lt;/em&gt; （まれにですが）物事に影響を与える可能性があるため、それらに注意する必要があります。 たとえばcpythonの場合、ネイティブの優先度キューの実装は漸近的に最適ではありません（挿入またはfind-minを選択すると、 &lt;code&gt;O(1)&lt;/code&gt; ではなく &lt;code&gt;O(log(N))&lt;/code&gt; ）。 別の実装を使用していますか？ おそらくそうではありません。Cの実装はおそらくより高速であり、おそらく他の場所にも同様の問題があるでしょう。 トレードオフがあります。 時には彼らは重要であり、時にはそうではありません。</target>
        </trans-unit>
        <trans-unit id="a92aef1bcf2b613748cc674288c56712f50682e2" translate="yes" xml:space="preserve">
          <source>The above statement is a good start but not completely true.</source>
          <target state="translated">上の発言は、スタートとしては良いのですが、完全に真実ではありません。</target>
        </trans-unit>
        <trans-unit id="af10522e397a98644d31608e45e48cac65ff2486" translate="yes" xml:space="preserve">
          <source>The analogy for amortized analysis:</source>
          <target state="translated">償却分析のアナロジー。</target>
        </trans-unit>
        <trans-unit id="fccd0576a93e2738b676fa9e76398601f6ab71b0" translate="yes" xml:space="preserve">
          <source>The astute may have realized that we could express the number of operations as: n&lt;sup&gt;2&lt;/sup&gt; + 2n.  But as you saw from our example with two numbers of a million digits apiece, the second term (2n) becomes insignificant (accounting for 0.0002% of the total operations by that stage).</source>
          <target state="translated">賢明なことに、操作の数をn &lt;sup&gt;2&lt;/sup&gt; + 2nと表現できることに気づいたかもしれません。 しかし、100万桁の数値が2つある例からわかるように、2番目の項（2n）は重要ではなくなります（その段階での総演算の0.0002％を占めます）。</target>
        </trans-unit>
        <trans-unit id="11fa8c026f804b110c22f62945ac720ce5e2b7ce" translate="yes" xml:space="preserve">
          <source>The bad:</source>
          <target state="translated">悪いのは</target>
        </trans-unit>
        <trans-unit id="8b80f48d4022e94ff91f1dba565c167cfe545120" translate="yes" xml:space="preserve">
          <source>The basics: Whenever we interact with every element in a collection of size A (such as an array, a set, all keys of a map, etc.), or perform A iterations of a loop, that is a multiplicative factor of size A. Why do I say &quot;a multiplicative factor&quot;?--because loops and functions (almost by definition) have multiplicative running time: the number of iterations, times work done in the loop (or for functions: the number of times you call the function, times work done in the function). (This holds if we don't do anything fancy, like skip loops or exit the loop early, or change control flow in the function based on arguments, which is very common.) Here are some examples of visualization techniques, with accompanying pseudocode.</source>
          <target state="translated">基本的なことです。サイズAのコレクション(配列、集合、マップのすべてのキーなど)のすべての要素と対話したり、ループのA回の反復を実行したりするときはいつでも、サイズAの乗算要素です。なぜ「乗算要素」と言ったかというと、ループや関数は(ほぼ定義上)乗算的な実行時間を持っているからです:反復の回数、ループ内で行われた作業の回数(関数の場合は、関数を呼び出した回数、関数内で行われた作業の回数)。(ループをスキップしたり、ループを早期に終了したり、引数に基づいて関数内の制御フローを変更したりなど、何も奇抜なことをしなければ、これは保持されますが、これは非常に一般的です)。以下に可視化技術のいくつかの例と、それに付随する疑似コードを示します。</target>
        </trans-unit>
        <trans-unit id="1ed7c47cc1915e8456623ae236c31623cd7a6dd2" translate="yes" xml:space="preserve">
          <source>The best example of Big-O I can think of is doing arithmetic.  Take two numbers (123456 and 789012).  The basic arithmetic operations we learnt in school were:</source>
          <target state="translated">私が思いつくBIG-Oの最も良い例は算数です。2つの数字(123456と789012)を考えてみましょう。学校で習った基本的な算数は</target>
        </trans-unit>
        <trans-unit id="6ae878297661e38f79a2d80036a322346800b990" translate="yes" xml:space="preserve">
          <source>The cost of solving the problem is proportional to the size of the problem.  If your problem doubles in size, then the cost of the solution doubles.  Since most problems have to be scanned into the computer in some way, as data entry, disk reads, or network traffic, this is generally an affordable scaling factor.</source>
          <target state="translated">問題を解くコストは問題の大きさに比例します。問題のサイズが2倍になると、解答のコストも2倍になります。ほとんどの問題は、データ入力、ディスク読み取り、ネットワークトラフィックなど、何らかの方法でコンピュータにスキャンされなければならないので、一般的には手頃なスケーリングファクターです。</target>
        </trans-unit>
        <trans-unit id="edbb1eb4311e72da0d8581264edd414e194f9ea0" translate="yes" xml:space="preserve">
          <source>The equation is read as 
As n approaches infinity, T of n, is less than or equal to c times f of n.</source>
          <target state="translated">この式は、nが無限大に近づくにつれて、nのTは、nのc倍f以下になります。</target>
        </trans-unit>
        <trans-unit id="7696e2ee0fe03e7287025d1b9b1e590710edef6e" translate="yes" xml:space="preserve">
          <source>The first sort was O(n squared).  But Quick Sort is O(n log n).  You know that n log n is less than n squared, for big n, right?  Well, that is how we know that Quick Sort is fast!</source>
          <target state="translated">最初のソートはO(n乗)でした。しかし、クイックソートはO(n log n)です。大きなnの場合、n log nはn乗よりも小さいことを知っていますよね?まあ、これがQuick Sortが速いということを知っている理由なんだけどね。</target>
        </trans-unit>
        <trans-unit id="ef63c6ddf6e7a7898b093aa5fa501850b023edae" translate="yes" xml:space="preserve">
          <source>The flow here would be:</source>
          <target state="translated">ここでの流れは</target>
        </trans-unit>
        <trans-unit id="d7c2775507fbff85fd208fcd7a9eefd861c88ccd" translate="yes" xml:space="preserve">
          <source>The good:</source>
          <target state="translated">良いことだ</target>
        </trans-unit>
        <trans-unit id="40776bd664da80434dcafa973f539de3f9f745d5" translate="yes" xml:space="preserve">
          <source>The input size is usually the space in bits needed to represent the input.</source>
          <target state="translated">入力サイズは通常、入力を表現するのに必要なビット数の空間です。</target>
        </trans-unit>
        <trans-unit id="d1b781877a2eef3021049a9a0ec22cac469bc50c" translate="yes" xml:space="preserve">
          <source>The moral of the story: a data structure lets us speed up operations. Even more, advanced data structures can let you combine, delay, or even ignore operations in incredibly clever ways. Different problems would have different analogies, but they'd all involve organizing the data in a way that exploits some structure we care about, or which we've artificially imposed on it for bookkeeping. We do work ahead of time (basically planning and organizing), and now repeated tasks are much much easier!</source>
          <target state="translated">この話の教訓:データ構造を使うと、処理を高速化することができます。さらに、高度なデータ構造は、信じられないほど巧妙な方法で操作を組み合わせたり、遅延させたり、無視したりすることさえ可能にしてくれます。問題によって例えは異なりますが、すべての問題には、私たちが気にしている構造を利用したり、簿記のために人為的に課した構造を利用してデータを整理することが関係しています。私たちは先回りして仕事をしています(基本的には計画を立てて整理しています)が、今では繰り返しの作業がはるかに楽になりました</target>
        </trans-unit>
        <trans-unit id="431150559f3afdb40719059de8cafc2364a6f27a" translate="yes" xml:space="preserve">
          <source>The new work is: add all things from one to n.</source>
          <target state="translated">新作は:1からNまですべてのものを足していく。</target>
        </trans-unit>
        <trans-unit id="9734a1f2bb99a793e146aed547eba3d5bde616de" translate="yes" xml:space="preserve">
          <source>The next best example I can think of is the telephone book, normally called the White Pages or similar but it varies from country to country.  But I'm talking about the one that lists people by surname and then initials or first name, possibly address and then telephone numbers.</source>
          <target state="translated">次に思いつく最良の例は電話帳で、通常はホワイトページと呼ばれているか、それに似たようなものですが、国によって違いがあります。しかし、私が話しているのは、苗字の次にイニシャルかファーストネーム、おそらく住所、そして電話番号で人をリストアップしているものです。</target>
        </trans-unit>
        <trans-unit id="30a4b2c863fa4772ef38b8845a347878d2aa00fa" translate="yes" xml:space="preserve">
          <source>The number of computations is only increased by a log of the input value.  So in this case, assuming each computation takes 1 second, the log of the input &lt;code&gt;n&lt;/code&gt; is the time required, hence &lt;code&gt;log n&lt;/code&gt;.</source>
          <target state="translated">計算回数は、入力値のログによってのみ増加します。 したがって、この場合、各計算に1秒かかると仮定すると、入力 &lt;code&gt;n&lt;/code&gt; の対数は必要な時間、つまり &lt;code&gt;log n&lt;/code&gt; になります 。</target>
        </trans-unit>
        <trans-unit id="3aad895641cfd48567e63f48472fae12fcf69c0b" translate="yes" xml:space="preserve">
          <source>The number of items is still increasing by a factor of 10, but the scaling factor of O(1) is always 1.</source>
          <target state="translated">項目数は相変わらず10倍に増えていますが、O(1)のスケーリング係数は常に1になっています。</target>
        </trans-unit>
        <trans-unit id="4e86a40dc1403a10780f816da6e77341ee5ea1e5" translate="yes" xml:space="preserve">
          <source>The only thing that these &quot;Big-Oh&quot; expressions try to do is to describe how much the software slows down as we increase the amount of data that the software has to process. If we double the amount of data that needs to be processed, does the software need twice as long to finish it's work? Ten times as long? In practice, there are a very limited number of big-Oh expressions that you will encounter and need to worry about:</source>
          <target state="translated">これらの「大王」表現がやろうとしていることは、ソフトウェアが処理しなければならないデータの量を増やすと、ソフトウェアがどれだけ遅くなるかを表現しているだけです。処理する必要のあるデータ量が2倍になった場合、ソフトウェアは2倍の時間が必要になるのでしょうか?10倍の時間が必要でしょうか?実際には、大王の表現に遭遇し、悩む必要があるのはごく限られた数だけです。</target>
        </trans-unit>
        <trans-unit id="0c4ac6494f1b66e30eda83ca592154e03a3a8fc2" translate="yes" xml:space="preserve">
          <source>The same can be said for the &lt;strong&gt;very act of writing&lt;/strong&gt;. All algorithms which print out N things will take N time because the output is at least that long (e.g. printing out all permutations (ways to rearrange) a set of N playing cards is factorial: &lt;code&gt;O(N!)&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;書くこと自体&lt;/strong&gt;も同じです。 Nのものを出力するすべてのアルゴリズムは、出力が少なくともそれだけ長いため、N時間かかります（たとえば、N枚のトランプのセットを並べ替えて（再配置するために）出力することは階乗です： &lt;code&gt;O(N!)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cf763b5c77d1eaec2bb764fe4187dc0b86926fc4" translate="yes" xml:space="preserve">
          <source>The simplest definition I can give for Big-O notation is this:</source>
          <target state="translated">私がBig-O記法に与えることができる最も簡単な定義は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9316c2f2fa69e85df7f06354c94d1417cfb91787" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;O( &amp;lt;some expression X involving n&amp;gt; )&lt;/code&gt; means, in simple English:</source>
          <target state="translated">次に、 &lt;code&gt;O( &amp;lt;some expression X involving n&amp;gt; )&lt;/code&gt; は、簡単な英語で意味します。</target>
        </trans-unit>
        <trans-unit id="8d780e455cede763fea2fd15a77afe9241e0ac7a" translate="yes" xml:space="preserve">
          <source>Then as far as Big O is concerned, the approximation f(n) is considered good enough as long as the below condition is true.</source>
          <target state="translated">そうすると、Big Oに関しては、以下の条件が成り立つ限り、近似値f(n)は十分に良いと考えられます。</target>
        </trans-unit>
        <trans-unit id="ee898084770160432d4052d1b6366394874b74dc" translate="yes" xml:space="preserve">
          <source>There are many choices of constant; often the &quot;best&quot; choice is known as the &quot;constant factor&quot; of the algorithm... but we often ignore it like we ignore non-largest terms (see Constant Factors section for why they don't usually matter). You can also think of the above equation as a bound, saying &quot;&lt;em&gt;In the worst-case scenario, the time it takes will never be worse than roughly &lt;code&gt;N*log(N)&lt;/code&gt;, within a factor of 2.5 (a constant factor we don't care much about)&lt;/em&gt;&quot;.</source>
          <target state="translated">定数には多くの選択肢があります。 多くの場合、「最良の」選択はアルゴリズムの「定数係数」として知られています...しかし、最大でない項を無視するように、しばしばそれを無視します（それらが通常問題にならない理由については、定数係数のセクションを参照してください）。 また、上記の方程式を限界と考えることもできます。「 &lt;em&gt;最悪のシナリオでは、所要時間は、およそ &lt;code&gt;N*log(N)&lt;/code&gt; よりも悪くなることはありません。 tについて大いに気にする）&lt;/em&gt; &quot;。</target>
        </trans-unit>
        <trans-unit id="f3b28edc57f1a5b8e2ff6393649371701cff785f" translate="yes" xml:space="preserve">
          <source>There are some important and deliberately chosen words in that sentence:</source>
          <target state="translated">その文章の中には、重要で意図的に選ばれた言葉があります。</target>
        </trans-unit>
        <trans-unit id="735800377cfb894185f412511981fdfbdcaa94c0" translate="yes" xml:space="preserve">
          <source>There is a lot of information that Big O does not tell you about a given algorithm. It cuts to the bone and gives only information about the scaling nature of an algorithm, specifically how the resource use (think time or memory) of an algorithm scales in response to the &quot;input size&quot;.</source>
          <target state="translated">Big O が与えられたアルゴリズムについて教えてくれない情報がたくさんあります。それは、アルゴリズムのスケーリングの性質、具体的にはアルゴリズムのリソース使用量(時間やメモリを考えてください)が「入力サイズ」に応じてどのようにスケーリングするかについての情報だけを提供しています。</target>
        </trans-unit>
        <trans-unit id="7dc156313731adb22242f60a31c42c25a7fac861" translate="yes" xml:space="preserve">
          <source>There is also the concept of &quot;amortized&quot; and/or &quot;average case&quot; (note that these are different).</source>
          <target state="translated">また、「償却済み」や「平均的なケース」という概念もあります(これらは異なることに注意してください)。</target>
        </trans-unit>
        <trans-unit id="e29aa2b4c76e872003711e1f9ca7f22087d1cd30" translate="yes" xml:space="preserve">
          <source>These are the bread-and-butter orders of growth that programmers and applied computer scientists use as reference points. They see these all the time. (So while you could technically think &quot;Doubling the input makes an O(&amp;radic;N) algorithm 1.414 times slower,&quot; it's better to think of it as &quot;this is worse than logarithmic but better than linear&quot;.)</source>
          <target state="translated">これらは、プログラマーと応用コンピューター科学者が参照ポイントとして使用する、成長の大まかな順序です。 彼らはいつもこれらを見ています。 （つまり、「入力を2倍にすると、O（&amp;radic;N）アルゴリズムは1.414倍遅くなる」と技術的に考えることはできますが、「これは対数よりも悪いが、線形よりも優れている」と考えるのが良いでしょう。）</target>
        </trans-unit>
        <trans-unit id="337e7f754779241ba422c3ed16228e880e17fea7" translate="yes" xml:space="preserve">
          <source>They gave us a deck of ten cards.  They are all mixed up: seven, four, two, six&amp;hellip; not straight at all.  And now... our job is to sort them.</source>
          <target state="translated">彼らは私たちに10枚のカードのデッキを与えました。 それらはすべて混同されています：7、4、2、6&amp;hellip;まったくまっすぐではありません。 そして今...私たちの仕事はそれらを分類することです。</target>
        </trans-unit>
        <trans-unit id="8a4cba2479bcff691f23bf7a823abac5f2bfc677" translate="yes" xml:space="preserve">
          <source>This algorithm search a list, item by item, looking for a key,</source>
          <target state="translated">このアルゴリズムは、リストを項目ごとに検索し、キーを探します。</target>
        </trans-unit>
        <trans-unit id="b5ccab1dbe3c98b30c65b7179a45c56dcba85b06" translate="yes" xml:space="preserve">
          <source>This complexity is the same as &lt;strong&gt;O(1)&lt;/strong&gt; except that it's just a little bit worse.  For all practical purposes, you can consider this as a very large constant scaling.  The difference in work between processing 1 thousand and 1 billion items is only a factor six.</source>
          <target state="translated">この複雑さは&lt;strong&gt;O（1）&lt;/strong&gt;と同じですが、少し悪いだけです。 すべての実用的な目的で、これは非常に大きな一定のスケーリングと考えることができます。 1000アイテムと10億アイテムを処理する作業の違いは、ファクター6にすぎません。</target>
        </trans-unit>
        <trans-unit id="a8f1f1c12dab816384a465eef99dc533c1871709" translate="yes" xml:space="preserve">
          <source>This complexity is very similar to &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt;.  For all practical purposes, the two are equivalent.  This level of complexity would generally still be considered scalable.  By tweaking assumptions some &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; algorithms can be transformed into &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; algorithms.  For example, bounding the size of keys reduces sorting from &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt; to &lt;strong&gt;O(&lt;em&gt;n&lt;/em&gt;)&lt;/strong&gt;.</source>
          <target state="translated">この複雑さは&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; ）&lt;/strong&gt;とよく似ています。 実際には、この2つは同等です。 このレベルの複雑さは、一般にスケーラブルと見なされます。 仮定を微調整することにより、一部の&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; ）&lt;/strong&gt;アルゴリズムを&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; ）&lt;/strong&gt;アルゴリズムに変換できます。 たとえば、キーのサイズを制限すると、ソートが&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt; ）&lt;/strong&gt;から&lt;strong&gt;O（ &lt;em&gt;n&lt;/em&gt; ）に&lt;/strong&gt;減少し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5691b3f2dea4e40f3c7e1067faf693cc2b99d29" translate="yes" xml:space="preserve">
          <source>This is O n&lt;sup&gt;2&lt;/sup&gt; because, you need to look at all items in the list there are &quot;n&quot; items. For each item, you look at all items once more, for comparing, this is also &quot;n&quot;, so for every item, you look &quot;n&quot; times meaning n*n = n&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">これはO n &lt;sup&gt;2&lt;/sup&gt;です。「n」個のアイテムがあるリストのすべてのアイテムを見る必要があるためです。 各項目について、すべての項目をもう一度見て、比較のために、これも「n」なので、すべての項目について、「n」回見て、n * n = n &lt;sup&gt;2を&lt;/sup&gt;意味します。</target>
        </trans-unit>
        <trans-unit id="653edd1e3ffbc6849cab3e84f2d2f1adb0553312" translate="yes" xml:space="preserve">
          <source>This is a function of a mathematical operation called a &lt;strong&gt;factorial&lt;/strong&gt;.  Basically:</source>
          <target state="translated">これは、 &lt;strong&gt;階乗&lt;/strong&gt;と呼ばれる数学演算の関数です。 基本的に：</target>
        </trans-unit>
        <trans-unit id="68bbac89d75f8c9b12a85ecf9405e267e936bef2" translate="yes" xml:space="preserve">
          <source>This is a very simplified explanation, but I hope it covers most important details.</source>
          <target state="translated">非常に簡略化された説明になってしまいましたが、最も重要な部分が網羅されているといいですね。</target>
        </trans-unit>
        <trans-unit id="690e85c5f1f320cb604423824b8a84e4db475373" translate="yes" xml:space="preserve">
          <source>This is called a &lt;strong&gt;binary search&lt;/strong&gt; and is used every day in programming whether you realize it or not.</source>
          <target state="translated">これは&lt;strong&gt;バイナリサーチ&lt;/strong&gt;と呼ばれ、気づいているかどうかにかかわらず、プログラミングで毎日使用されます。</target>
        </trans-unit>
        <trans-unit id="903158538d58a924a96daad121dc96f748e16115" translate="yes" xml:space="preserve">
          <source>This is quite a famous problem in computer science and deserves a mention.  In this problem you have N towns. Each of those towns is linked to 1 or more other towns by a road of a certain distance. The Traveling Salesman problem is to find the shortest tour that visits every town.</source>
          <target state="translated">これはコンピュータサイエンスではかなり有名な問題であり、言及に値するものです。この問題では、N個の町があります。それぞれの町は,ある距離の道路によって1つ以上の町と結ばれている.旅するセールスマンの問題は,すべての町を訪れる最短のツアーを見つけることです.</target>
        </trans-unit>
        <trans-unit id="9d90c6f6b5d97d1a3566515111185bfdbbdad847" translate="yes" xml:space="preserve">
          <source>This is read as T of n is in big O of n.</source>
          <target state="translated">これは、nのTがnのbig Oにあると読みます。</target>
        </trans-unit>
        <trans-unit id="581db2374f66d9fecedf4263af206b8b003578d9" translate="yes" xml:space="preserve">
          <source>This lets us make statements like...</source>
          <target state="translated">これで、次のような発言ができるようになりました...</target>
        </trans-unit>
        <trans-unit id="4f23f5a057b81398db00b66517d931e311e15ad5" translate="yes" xml:space="preserve">
          <source>This motivates the use of &lt;strong&gt;data structures&lt;/strong&gt;: a data structure requires reading the data only once (usually &lt;code&gt;O(N)&lt;/code&gt; time), plus some arbitrary amount of preprocessing (e.g. &lt;code&gt;O(N)&lt;/code&gt; or &lt;code&gt;O(N log(N))&lt;/code&gt; or &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt;) which we try to keep small. Thereafter, modifying the data structure (insertions/deletions/ etc.) and making queries on the data take very little time, such as &lt;code&gt;O(1)&lt;/code&gt; or &lt;code&gt;O(log(N))&lt;/code&gt;. You then proceed to make a large number of queries! In general, the more work you're willing to do ahead of time, the less work you'll have to do later on.</source>
          <target state="translated">これにより、 &lt;strong&gt;データ構造&lt;/strong&gt;の使用が促進されます。データ構造では、データを1回（通常は &lt;code&gt;O(N)&lt;/code&gt; 時間）読み取るだけでなく、任意の量の前処理（ &lt;code&gt;O(N)&lt;/code&gt; または &lt;code&gt;O(N log(N))&lt;/code&gt; または &lt;code&gt;O(N&amp;sup2;)&lt;/code&gt; ）小さく保つようにします。 その後、データ構造（挿入/削除など）を変更し、データに対してクエリを実行すると、 &lt;code&gt;O(1)&lt;/code&gt; や &lt;code&gt;O(log(N))&lt;/code&gt; などの時間はほとんどかかりません。 次に、多数のクエリを作成します。 一般に、事前に実行する作業が多いほど、後で実行する必要のある作業が少なくなります。</target>
        </trans-unit>
        <trans-unit id="4d08321928b5477592d3f3be8d0fbf595ccedfeb" translate="yes" xml:space="preserve">
          <source>This sort is quite quick.  How quick?  Big O tells us: this sort needs O(n log n) work to be done, in the mean case.</source>
          <target state="translated">この種はかなり早い。どのくらい速いのでしょうか?Big Oが教えてくれます:このソートは平均的なケースではO(n log n)の作業が必要です。</target>
        </trans-unit>
        <trans-unit id="efa77e0837d728c026f108a7c6a880857648e39a" translate="yes" xml:space="preserve">
          <source>This time the number of items increases by a factor of 10, and so does the time. n=10 and so O(n)'s scaling factor is 10.</source>
          <target state="translated">今回は項目数が10倍になり、時間も10倍になります。 n=10なのでO(n)のスケーリング係数は10です。</target>
        </trans-unit>
        <trans-unit id="e6a399976506e2d7ce3f3c1d1884c9c4671f0528" translate="yes" xml:space="preserve">
          <source>This type of algorithm is described as O(log N). The iterative halving
  of data sets described in the binary search example produces a growth
  curve that peaks at the beginning and slowly flattens out as the size
  of the data sets increase e.g. an input data set containing 10 items
  takes one second to complete, a data set containing 100 items takes
  two seconds, and a data set containing 1000 items will take three
  seconds. Doubling the size of the input data set has little effect on
  its growth as after a single iteration of the algorithm the data set
  will be halved and therefore on a par with an input data set half the
  size. This makes algorithms like binary search extremely efficient
  when dealing with large data sets.</source>
          <target state="translated">このタイプのアルゴリズムは、O(log N)として記述されます。バイナリ検索の例で説明したデータセットの反復的な半減は、データセットのサイズが大きくなるにつれて、最初にピークを迎え、ゆっくりと平らになる成長曲線を生成します。入力データセットのサイズを2倍にしても、アルゴリズムの1回の繰り返しでデータセットは半分になり、その結果、サイズが半分の入力データセットと同等になるため、データセットの成長にはほとんど影響がありません。これにより、バイナリ検索のようなアルゴリズムは、大規模なデータセットを扱う際に非常に効率的になります。</target>
        </trans-unit>
        <trans-unit id="ff64700b92668ef5d8bf1eab2150e242d95be66f" translate="yes" xml:space="preserve">
          <source>Though, if you're &lt;a href=&quot;https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks&quot;&gt;reasonably worried&lt;/a&gt; about an attacker, there are many other algorithmic attack vectors to worry about besides amortization and average-case.)</source>
          <target state="translated">ただし、攻撃者について&lt;a href=&quot;https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks&quot;&gt;合理的に心配し&lt;/a&gt;ている場合は、償却や平均ケースの他に、心配する必要のある他の多くのアルゴリズム攻撃ベクトルがあります。）</target>
        </trans-unit>
        <trans-unit id="7c6809222de67cf731ce03e2166eb7926bfb38c0" translate="yes" xml:space="preserve">
          <source>Three: I go from the end card up, and I look for a card that is more low than the splay card.</source>
          <target state="translated">3枚です。エンドカードから上に行き、スプレイカードよりも低いカードを探します。</target>
        </trans-unit>
        <trans-unit id="b5dad2a734641d4c6735ae21c27019cfea0c15e8" translate="yes" xml:space="preserve">
          <source>Time(Best-Case) = 4</source>
          <target state="translated">時間(ベストケース)=4</target>
        </trans-unit>
        <trans-unit id="2f997ae62ba9c69b3cf6edcf0d119e5ddad840f2" translate="yes" xml:space="preserve">
          <source>Time(Worst-Case) = 4n+1</source>
          <target state="translated">時間(ワーストケース)=4n+1</target>
        </trans-unit>
        <trans-unit id="2b30e732d21d07f2640a46e069dde7480df7216e" translate="yes" xml:space="preserve">
          <source>Time: &amp;Omega;(4) = O(1) ~ Instant\Constant</source>
          <target state="translated">時間：&amp;Omega;（4）= O（1）〜Instant \ Constant</target>
        </trans-unit>
        <trans-unit id="8d4bf6a7efc118b94944a2fdcb4199b6b5436673" translate="yes" xml:space="preserve">
          <source>Time: O(4n+1) = O(n) | in Big-O, constants are neglected</source>
          <target state="translated">in Big-O,constants are neglected O(4n+1)=O(n)</target>
        </trans-unit>
        <trans-unit id="78b1d548645a6f4313e845c0d6995f63dbc656ee" translate="yes" xml:space="preserve">
          <source>To add from one to six, that is some work.  But do you see, to add from one to ten, that is more work?</source>
          <target state="translated">1から6に足すのは、それはいくつかの仕事です。しかし、あなたは、1から10に追加するには、それがより多くの仕事であることがわかりますか?</target>
        </trans-unit>
        <trans-unit id="2ee6a9060e778ab6f2fbe6d42d7bf3bf75ff7755" translate="yes" xml:space="preserve">
          <source>To me, I think of big O like a big, slow, boss man.  He thinks on work, but he does not do it.  He might say, &quot;That work is quick.&quot;  Or, he might say, &quot;That work is so slow and hard!&quot;  But he does not do the work.  He just looks at the work, and then he tells us how much time it might take.</source>
          <target state="translated">私にとってビッグ・オーは、大らかでスローな上司のような男だと思う。仕事のことは考えていても、仕事はしない。&quot;あの仕事は早い &quot;と言うかもしれないし &quot;あの仕事は早くて早い &quot;とか &quot;あの仕事は遅くて大変だ &quot;とか。でも、仕事はしない。ただ仕事を見て、どれくらいの時間がかかるかを教えてくれるのです。</target>
        </trans-unit>
        <trans-unit id="5580a107c59a84aea6247983205780ae9a93ffac" translate="yes" xml:space="preserve">
          <source>To say that binary search has a running time of O(logn) is to say that there exists some constant c which you can multiply log(n) by that will always be larger than the running time of binary search.  In this case you will always have some constant factor of log(n) comparisons.</source>
          <target state="translated">バイナリ探索の実行時間がO(logn)であると言うことは、log(n)を掛けることができる定数cが存在し、それは常にバイナリ探索の実行時間よりも大きくなることを意味します。この場合、log(n)の比較の定数が常に存在します。</target>
        </trans-unit>
        <trans-unit id="b4476ee9defb91e4168e19a3dcd129163cca85a4" translate="yes" xml:space="preserve">
          <source>Two: I splay the deck on that card you chose.  What is this splay; how do I splay?  Well, I go from the start card down, one by one, and I look for a card that is more high than the splay card.</source>
          <target state="translated">つ:あなたが選んだカードの上に山札をスプレイします。スプレイとは何ですか?そうですね、スタートのカードから1枚ずつ下に行って、スプレイのカードよりも高いカードを探します。</target>
        </trans-unit>
        <trans-unit id="7b569bf8286d4c929a479c4976f45922a580f422" translate="yes" xml:space="preserve">
          <source>Uh oh, more work.  Now, let&amp;rsquo;s not do the work.  But, let&amp;rsquo;s make a plan to do it, step by step.</source>
          <target state="translated">ああ、もっと仕事。 さあ、仕事をしましょう。 しかし、それを段階的に行う計画を立てましょう。</target>
        </trans-unit>
        <trans-unit id="66ec3cb6bc2e6fcaea19ddeb58c0027ecdebce58" translate="yes" xml:space="preserve">
          <source>Unrelatedly but worth mentioning again: If we perform a hash (e.g. a dictionary/hashtable lookup), that is a factor of O(1). That's pretty fast.</source>
          <target state="translated">無関係ですが、再度言及する価値はあります。我々がハッシュ(例えば辞書ハッシュテーブルの検索)を実行する場合、それはO(1)の係数です。これはかなり速いです。</target>
        </trans-unit>
        <trans-unit id="ceb436949ce49c2aad7d40dd4b74113a2a9f4743" translate="yes" xml:space="preserve">
          <source>Using a tumble dryer: you put 10 shirts in each load, and then they're done an hour later. (Ignore the actual numbers here &amp;mdash; they're irrelevant.) So drying 50 shirts takes &lt;em&gt;about&lt;/em&gt; 5 times as long as drying 10 shirts.</source>
          <target state="translated">タンブル乾燥機を使用する場合：1回の積載に10枚のシャツを入れ、1時間後に完成させます。 （ここの実際の数は無視してください&amp;mdash;それらは無関係です。）したがって、50枚のシャツを乾燥させると、10枚のシャツを乾燥させる場合の&lt;em&gt;約&lt;/em&gt; 5倍の時間がかかります。</target>
        </trans-unit>
        <trans-unit id="c1627c2d9bf38d1a8bf4e6c4db14ba36e137fed7" translate="yes" xml:space="preserve">
          <source>Using a washing line outside: assuming you have an infinitely large back yard, washing dries in O(1) time. However much you have of it, it'll get the same sun and fresh air, so the size doesn't affect the drying time.</source>
          <target state="translated">外で洗濯機を使う:無限に広いバックヤードがあると仮定すると、洗濯物はO(1)の時間で乾きます。どれだけ持っていても、同じ太陽と新鮮な空気を得ることができるので、大きさは乾燥時間に影響しません。</target>
        </trans-unit>
        <trans-unit id="32fee750e2bced1ef4713977d7422997ac4d01b8" translate="yes" xml:space="preserve">
          <source>Usually, we don't care what the specific constant factors are, because they don't affect the way the function grows. For example, two algorithms may both take &lt;code&gt;O(N)&lt;/code&gt; time to complete, but one may be twice as slow as the other. We usually don't care too much unless the factor is very large since optimizing is tricky business ( &lt;a href=&quot;https://stackoverflow.com/questions/385506/when-is-optimisation-premature&quot;&gt;When is optimisation premature?&lt;/a&gt; ); also the mere act of picking an algorithm with a better big-O will often improve performance by orders of magnitude.</source>
          <target state="translated">通常、特定の定数因子が何であるかは関係ありません。これらは関数の成長に影響を与えないためです。 たとえば、2つのアルゴリズムは両方とも完了するまでに &lt;code&gt;O(N)&lt;/code&gt; 時間かかる場合がありますが、一方が他方の2倍遅くなる場合があります。 最適化はトリッキーなビジネスであるため、通常、要素が非常に大きくない限り、あまり気にしません（ &lt;a href=&quot;https://stackoverflow.com/questions/385506/when-is-optimisation-premature&quot;&gt;最適化は時期尚早ですか？&lt;/a&gt; ）。 また、big-Oがより高いアルゴリズムを選択するだけでも、パフォーマンスが桁違いに向上することがよくあります。</target>
        </trans-unit>
        <trans-unit id="ec6a77a1f38d77785d38e6e7cc1d9af0e804cfa3" translate="yes" xml:space="preserve">
          <source>Very Quick Note:</source>
          <target state="translated">非常に迅速なメモ。</target>
        </trans-unit>
        <trans-unit id="6d21f45bec9f10023aec098341e6f6c03c5b13c1" translate="yes" xml:space="preserve">
          <source>Via examples, this helped get the bare basics into my tortoiseshell-like skull, so I think it's a pretty descent 10-minute read to get you headed in the right direction.</source>
          <target state="translated">例を介して、これは私のべっ甲のような頭蓋骨に裸の基本を取得するのに役立ちましたので、それはあなたが正しい方向に向かって取得するために、かなり下降10分間の読書だと思います。</target>
        </trans-unit>
        <trans-unit id="6aab5f5e334f1c425e8cc5c3149d2485a2ab6b43" translate="yes" xml:space="preserve">
          <source>Wait!  What is n?  Did I miss that?  How can I add from one to n if you don&amp;rsquo;t tell me what n is?</source>
          <target state="translated">待つ！ nとは何ですか？ 見逃しましたか？ nが何であるかを教えてくれない場合、どうすれば1からnに追加できますか？</target>
        </trans-unit>
        <trans-unit id="2f7ade3e8b4a45caea9bbfc55450f4d016746563" translate="yes" xml:space="preserve">
          <source>We are trying to see how the number of input parameters, affects the running time of an algorithm. If the running time of your application is proportional to the number of input parameters, then it is said to be in Big O of n.</source>
          <target state="translated">私たちは、入力パラメータの数がアルゴリズムの実行時間にどのように影響するかを見ようとしています。もしアプリケーションの実行時間が入力パラメータの数に比例しているならば、それはnのビッグOにあると言われています。</target>
        </trans-unit>
        <trans-unit id="d3658b52f527a76c6421772c73ea4511ef27a0b9" translate="yes" xml:space="preserve">
          <source>We can just rearrange this and see it's O(N):</source>
          <target state="translated">これを並べ替えてみると、O(N)だとわかります。</target>
        </trans-unit>
        <trans-unit id="a081699494ed4f022754488ece9b2b843bf6728d" translate="yes" xml:space="preserve">
          <source>Well actually there's less than that because some of these are equivalent (A &amp;rarr; B &amp;rarr; C and C &amp;rarr; B &amp;rarr; A are equivalent, for example, because they use the same roads, just in reverse).</source>
          <target state="translated">これらのいくつかは同等であるため、実際にはそれよりも少なくなります（たとえば、A&amp;rarr;B&amp;rarr;CおよびC&amp;rarr;B&amp;rarr;Aは、同じ道路を逆に使用しているため、同等です）。</target>
        </trans-unit>
        <trans-unit id="f33910e9a426fbc1a12d1f88603bfdd1d8ca337f" translate="yes" xml:space="preserve">
          <source>Well, I don&amp;rsquo;t know what n is.  I was not told.  Were you?  No?   Oh well.  So we can&amp;rsquo;t do the work.  Whew.</source>
          <target state="translated">さて、私はnが何であるかわかりません。 言われなかった。 あなたでしたか？ 番号？ しかたがない。 だから私たちは仕事をすることができません。 ふew。</target>
        </trans-unit>
        <trans-unit id="4b2089e7aacf0c6fcb7cbbe9c09999beabffc5dd" translate="yes" xml:space="preserve">
          <source>Well, I guess I would have to do ten adds&amp;hellip; one for each thing from one to ten.  Ten is more than six.  I would have to work that much more to add from one to ten, than one to six!</source>
          <target state="translated">ええと、私は10の加算を行う必要があると思います... 1から10まで、それぞれに1つずつ。 十は六以上です。 1から6を追加するよりも、1から10を追加するほうがはるかに多くの作業が必要になります。</target>
        </trans-unit>
        <trans-unit id="448ecbc620762a34ee90c323b9d2af296de94e73" translate="yes" xml:space="preserve">
          <source>Well, I will not do the work to add them now.  But I know how hard it would be.  It would be six adds.</source>
          <target state="translated">まあ、今は追加する作業はしません。しかし、私はそれがどれほど難しいかを知っています。それは6つの追加になるだろう。</target>
        </trans-unit>
        <trans-unit id="e6092f44041d9afec7369ff2f52755377d43518f" translate="yes" xml:space="preserve">
          <source>Well, how much work would that be, to sort the cards with those rules?</source>
          <target state="translated">そのルールでカードを並べ替えるのって、どれだけ大変なんだろう?</target>
        </trans-unit>
        <trans-unit id="3a69be1de24839373d5d994ccbcc98a836e1d23b" translate="yes" xml:space="preserve">
          <source>Well, if n gets real big, we do not care what we might add to n or n squared.</source>
          <target state="translated">まあ、nが本当に大きくなったら、nに何を足そうが、nの2乗にしようが気にしません。</target>
        </trans-unit>
        <trans-unit id="2d9059fb09bbdcd3a55d09451a9fcb425e83ec53" translate="yes" xml:space="preserve">
          <source>Well, let&amp;rsquo;s see.  I must add one and two, and then add that to three, and then add that to four&amp;hellip; All in all, I count six adds.  I have to do six adds to solve this.</source>
          <target state="translated">さて、見てみましょう。 1と2を追加し、それを3に追加してから、4に追加する必要があります。全体で、6つの追加を数えます。 これを解決するには、6つの追加を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="329e7c685300ef2d2b4c47c92157c7ce7ca7c71a" translate="yes" xml:space="preserve">
          <source>Well, what's so wonderful about Big O notation if that's what it does?</source>
          <target state="translated">まあ、ビッグオーの表記がそうだとしたら、何がそんなに素晴らしいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="27f2ea453fa647e6745114288459cdbdc09377db" translate="yes" xml:space="preserve">
          <source>Well, you know n squared is n times n.  Now, I get it: n cards checked, up to what might be n times through the deck.  That is two loops, each with n steps.  That is n squared much work to be done.  A lot of work, for sure!</source>
          <target state="translated">さて、n乗はn回のn倍ですね。これは2つのループで、それぞれにn個のステップがある。これはnの2乗に相当する。確かに大変な作業だ</target>
        </trans-unit>
        <trans-unit id="f37e46082d9d7fea2de0995ec35f0ebec2aa85b9" translate="yes" xml:space="preserve">
          <source>What if I order several Blu-ray movies like The Lord of the Rings, Twilight, The Dark Knight Trilogy, etc. and download all the movies online at the same time? This time, the delivery still take a day to complete, but the online download takes 3 days to finish.
For online shopping, the number of purchased item (input) doesn&amp;rsquo;t affect the delivery time. The output is constant. We call this &lt;strong&gt;O(1)&lt;/strong&gt;.</source>
          <target state="translated">ロードオブザリング、トワイライト、ダークナイトトリロジーなどのブルーレイ映画を注文し、すべての映画を同時にオンラインでダウンロードするとどうなりますか？ 今回は、配信が完了するまでに1日かかりますが、オンラインダウンロードが完了するまでに3日かかります。 オンラインショッピングの場合、購入数（投入数）は配達時間に影響しません。 出力は一定です。 これを&lt;strong&gt;O（1）&lt;/strong&gt;と呼びます。</target>
        </trans-unit>
        <trans-unit id="7ae3452404f7d023c914234c52fa39dc716c5a20" translate="yes" xml:space="preserve">
          <source>What if you have a phone number and want to find a name?  The police have a reverse phone book but such look-ups are denied to the general public.  Or are they?  Technically you can reverse look-up a number in an ordinary phone book.  How?</source>
          <target state="translated">電話番号を持っていて、名前を調べたい場合はどうすればいいのでしょうか?警察には逆引き電話帳がありますが、そのような調べ方は一般人には否定されています。それともそうなのでしょうか?技術的には普通の電話帳の番号を逆引きすることができます。どうやって?</target>
        </trans-unit>
        <trans-unit id="373e1d2a10f1cbeda45147e21f05a41927cb80df" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of &amp;ldquo;Big O&amp;rdquo; notation?</source>
          <target state="translated">「Big O」表記のわかりやすい英語の説明とは何ですか？</target>
        </trans-unit>
        <trans-unit id="05e7612ca7f7ef6fa7a4103f167b120617cb813f" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of Big O? With as little formal definition as possible and simple mathematics.</source>
          <target state="translated">ビッグオーの平易な英語説明とは?できるだけ形式的な定義を少なくして、簡単な数学で。</target>
        </trans-unit>
        <trans-unit id="f89a18eb1e0fc978c591793d435b46bfc0826855" translate="yes" xml:space="preserve">
          <source>What is a plain English explanation of “Big O” notation</source>
          <target state="translated">ビッグオー」表記の平易な英語説明とは</target>
        </trans-unit>
        <trans-unit id="2cc611dba256f3aa30150ddcf404bfb6a56af65d" translate="yes" xml:space="preserve">
          <source>What is this sort called?  It is called Quick Sort!  That sort was made by a man called &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;C. A. R. Hoare&lt;/a&gt; and he called it Quick Sort.  Now, Quick Sort gets used all the time!</source>
          <target state="translated">この種の名前は何ですか？ クイックソートと呼ばれています！ その並べ替えは&lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;CAR Hoare&lt;/a&gt;と呼ばれる男によって行われ、彼はそれをQuick Sortと呼びました。 現在、クイックソートは常に使用されています。</target>
        </trans-unit>
        <trans-unit id="bf023f1a273e5e8e203698a520653800da906866" translate="yes" xml:space="preserve">
          <source>When interested in doing computations whose size is &quot;large&quot; enough to be considered as approximately infinity, then big O notation is approximately the cost of solving your problem.</source>
          <target state="translated">サイズが約無限大と考えられるほど &quot;大きい &quot;計算をすることに興味があるときは、大きなOの表記は、問題を解くためのコストのおおよそのものです。</target>
        </trans-unit>
        <trans-unit id="adc3d5b71af09ac58be8764be77408df12df041d" translate="yes" xml:space="preserve">
          <source>When the deck is done, I ask: did I swap cards in that pass?  If so, I must do it all once more, from the top.</source>
          <target state="translated">デッキが完成したら、私は次のように尋ねます:そのパスでカードを入れ替えましたか?もしそうであれば、もう一度最初からやり直します。</target>
        </trans-unit>
        <trans-unit id="9028c7b55a2b4ecb9c2a82958fa89f7a7fc1daa5" translate="yes" xml:space="preserve">
          <source>When we program, we are trying to solve a problem. What we code is called an algorithm. Big O notation allows us to compare the worse case performance of our algorithms in a standardized way. Hardware specs vary over time and improvements in hardware can reduce the time it takes an algorithms to run. But replacing the hardware does not mean our algorithm is any better or improved over time, as our algorithm is still the same. So in order to allow us to compare different algorithms, to determine if one is better or not, we use Big O notation.</source>
          <target state="translated">私たちがプログラミングをするとき、私たちは問題を解決しようとしています。私たちがコード化したものはアルゴリズムと呼ばれます。Big O記法では、標準化された方法でアルゴリズムの最悪のケースの性能を比較することができます。ハードウェアの仕様は時間の経過とともに変化し、ハードウェアの改良はアルゴリズムの実行にかかる時間を短縮することができます。しかし、ハードウェアを交換したからといって、私たちのアルゴリズムがより良くなったわけでも、時間の経過とともに改善されたわけでもありません。そこで、異なるアルゴリズムを比較して、あるアルゴリズムが優れているかどうかを判断できるようにするために、私たちはBig O記法を使用しています。</target>
        </trans-unit>
        <trans-unit id="54c2c9229bcd771be7710eabeb971bc3f8e0eb85" translate="yes" xml:space="preserve">
          <source>When we say some algorithm is O(f(n)) we are saying that the running time (or space required) by that algorithm is always lower than some constant times f(n).</source>
          <target state="translated">あるアルゴリズムがO(f(n)であると言うとき、そのアルゴリズムによる実行時間(または必要なスペース)は常に一定の時間f(n)よりも小さいことを言っているのです。)</target>
        </trans-unit>
        <trans-unit id="5d1cb020f38d2820c9eec88a25e1be3ef2a6c892" translate="yes" xml:space="preserve">
          <source>Why do I choose Quick Sort?  I do not like to work, of course!  I want work done as soon as I can get it done.</source>
          <target state="translated">クイックソートを選ぶ理由 私は仕事が好きではありません、もちろん! 仕事はできるだけ早く終わらせたい。</target>
        </trans-unit>
        <trans-unit id="ccaa8eba13667623c9638dcc1af96e87d1ce8695" translate="yes" xml:space="preserve">
          <source>Why does he say n squared?</source>
          <target state="translated">なぜ彼はNの二乗と言うのか?</target>
        </trans-unit>
        <trans-unit id="ed876af93299c7d2e7470f312b49d7963f03e745" translate="yes" xml:space="preserve">
          <source>Why is this so important? Because software deals with problems that may differ in size by factors up to a trillion. Consider that for a moment. The ratio between the speed necessary to travel to the Moon and human walking speed is less than 10,000:1, and that is absolutely tiny compared to the range in input sizes software may face. And because software may face an astronomical range in input sizes there is the potential for the Big O complexity of an algorithm, it's fundamental scaling nature, to trump any implementation details.</source>
          <target state="translated">なぜこれが重要なのでしょうか?それはソフトウェアが扱う問題の大きさが1兆倍にもなるような問題を扱うからです ちょっと考えてみてください。月への移動に必要な速度と人間の歩行速度の比は10,000:1以下であり、ソフトウェアが直面する可能性のある入力サイズの範囲に比べれば、絶対的に小さいものです。ソフトウェアが直面する入力サイズの範囲は天文学的なものになる可能性があるため、アルゴリズムのビッグオーの複雑さ、つまり基本的なスケーリングの性質が、実装の詳細に取って代わられる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a693d58d361e39c4c6dfbf09d0fc6a088f14c901" translate="yes" xml:space="preserve">
          <source>Why would you want to ignore the smaller parts of the equation? Because they become completely dwarfed by the big parts of the equation as you consider larger and larger scales; their contribution becomes dwarfed and irrelevant. (See example section.)</source>
          <target state="translated">なぜ方程式の小さな部分を無視したいのでしょうか?それは、より大きなスケールで考えると、方程式の大きな部分によって完全に矮小化されてしまうからです;彼らの貢献は矮小化されて無関係になります。(例のセクションを参照してください。)</target>
        </trans-unit>
        <trans-unit id="b03cf50f7e5382fcef1451bd7a03322e40c6839f" translate="yes" xml:space="preserve">
          <source>With 5 it's 60.</source>
          <target state="translated">5だと60だ</target>
        </trans-unit>
        <trans-unit id="19778bc5e290319ee50f4c5296b015273dc9262c" translate="yes" xml:space="preserve">
          <source>Worst-Case: the key doesn't exist in the list.</source>
          <target state="translated">最悪の場合:そのキーはリストに存在しません。</target>
        </trans-unit>
        <trans-unit id="5fabd786be014d83764164facee56b049790e363" translate="yes" xml:space="preserve">
          <source>Wow, I hate work.  But oh well, I have to do this.  So here I go.</source>
          <target state="translated">うわー、仕事が嫌になってきた。でも、まあ、これはやらないと。だから、行くわよ。</target>
        </trans-unit>
        <trans-unit id="7c8c4cd8f5043686e05d837663d4022a92d73016" translate="yes" xml:space="preserve">
          <source>Yes, there is a more fast way!  It takes some time to learn, but it works... and it works quite fast.  You can try it too, but take your time with each step and do not lose your place.</source>
          <target state="translated">はい、もっと速い方法があります それは学ぶのに時間がかかりますが、それは動作します...そしてそれはかなり速く動作します。あなたもそれを試みることができますが、各ステップとあなたの場所を失わないようにあなたの時間を取る。</target>
        </trans-unit>
        <trans-unit id="cfe414e40bd3874b327354ff113f428d54d21253" translate="yes" xml:space="preserve">
          <source>You could refer to Big-&amp;Omega; (Big-Omega) for best case.</source>
          <target state="translated">最良のケースについては、Big-&amp;Omega;（Big-Omega）を参照してください。</target>
        </trans-unit>
        <trans-unit id="7bfc8ee77cbab3d00050185496cbe7e412b4bf8a" translate="yes" xml:space="preserve">
          <source>You drive a car. Occasionally, you need to spend 10 minutes going to
  the gas station and then spend 1 minute refilling the tank with gas.
  If you did this every time you went anywhere with your car (spend 10
  minutes driving to the gas station, spend a few seconds filling up a
  fraction of a gallon), it would be very inefficient. But if you fill
  up the tank once every few days, the 11 minutes spent driving to the
  gas station is &quot;amortized&quot; over a sufficiently large number of trips,
  that you can ignore it and pretend all your trips were maybe 5% longer.</source>
          <target state="translated">あなたは車を運転しています。たまに、10分かけてガソリンスタンドに行き、1分かけてガソリンを補充する必要があります。もしあなたが車でどこかに行くたびにこれをしていたら(ガソリンスタンドに行くのに10分かけて運転し、数秒かけて1ガロンの何分の1かを満タンにする)、非常に効率が悪いでしょう。しかし、数日に一度でもタンクを満タンにすると、ガソリンスタンドへの運転に費やした11分は、十分に多くの旅行に渡って「償却」されるので、それを無視して、すべての旅行がたぶん5%長くなったふりをすることができます。</target>
        </trans-unit>
        <trans-unit id="2c6bcba6f752f5cfdc961fb84683b404f55a2f21" translate="yes" xml:space="preserve">
          <source>You learned all that with me!  You are so smart!  Thank you so much!</source>
          <target state="translated">私と一緒に学んだのね! お利口さんですね! 本当にありがとうございました!</target>
        </trans-unit>
        <trans-unit id="e8fd35a375e8ec51f2b6feca80545b2feec31781" translate="yes" xml:space="preserve">
          <source>You may often see O(n), O(n&lt;sup&gt;2&lt;/sup&gt;), O(nlogn) and so forth, all these are just ways to show; How does an algorithm change?</source>
          <target state="translated">O（n）、O（n &lt;sup&gt;2&lt;/sup&gt; ）、O（nlogn）などがよく表示されますが、これらはすべて表示する方法にすぎません。 アルゴリズムはどのように変化しますか？</target>
        </trans-unit>
        <trans-unit id="f0c088b8e94d146df79970184c217c58b7b97083" translate="yes" xml:space="preserve">
          <source>You start at the first name and compare the number.  If it's a match, great, if not, you move on to the next.  You have to do it this way because the phone book is &lt;strong&gt;unordered&lt;/strong&gt; (by phone number anyway).</source>
          <target state="translated">名から始めて、番号を比較します。 マッチした場合は、そうでない場合は、次に進みます。 電話帳は（とにかく電話番号で） &lt;strong&gt;順序付け&lt;/strong&gt;されてい&lt;strong&gt;ない&lt;/strong&gt;ため、この方法で行う必要があります。</target>
        </trans-unit>
        <trans-unit id="4784b5173ab05221f2b6abc84330bf0f13d31a7c" translate="yes" xml:space="preserve">
          <source>You want to know all there is to know of big O?  So do I.</source>
          <target state="translated">ビッグ・オーの全てを知りたいか?私もよ</target>
        </trans-unit>
        <trans-unit id="648ba0204f36666cba11a8e63d6db611dae8658b" translate="yes" xml:space="preserve">
          <source>[1]: There is a way to cheat and add all the things from one to n, all at one time.  Some kid named Gauss found this out when he was eight.  I am not that smart though, so &lt;a href=&quot;http://nzmaths.co.nz/gauss-trick-staff-seminar&quot;&gt;don't ask me how he did it&lt;/a&gt;.</source>
          <target state="translated">[1]：1からnまでのすべてのものを一度にすべてカンニングして追加する方法があります。 ガウスという名前の子供は、8歳のときにこれを見つけました。 私はそれほど賢くないので、 &lt;a href=&quot;http://nzmaths.co.nz/gauss-trick-staff-seminar&quot;&gt;彼がどうやってそれをしたのか私に尋ねないでください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="4229c03c35f915409c958fce305574599037d757" translate="yes" xml:space="preserve">
          <source>[for the mathematically inclined, you can mouse over the spoilers for minor sidenotes]</source>
          <target state="translated">[数学的に考えれば、ネタバレの上にマウスを置くことができます。]</target>
        </trans-unit>
        <trans-unit id="320f1d7c3f87e62df035bd8c3fff9fceb851f278" translate="yes" xml:space="preserve">
          <source>addition;</source>
          <target state="translated">addition;</target>
        </trans-unit>
        <trans-unit id="cc72a00bf5f82a31e19586f8d5648eeb9609f807" translate="yes" xml:space="preserve">
          <source>and so on.</source>
          <target state="translated">といったようなことを言っています。</target>
        </trans-unit>
        <trans-unit id="41f2ef38a3521fb432c176bb3d6eec433f0e7d29" translate="yes" xml:space="preserve">
          <source>big-O notation doesn't care about constant factors: the function &lt;code&gt;9x&amp;sup2;&lt;/code&gt; is said to &quot;grow exactly like&quot; &lt;code&gt;10x&amp;sup2;&lt;/code&gt;. Neither does big-O &lt;em&gt;asymptotic&lt;/em&gt; notation care about &lt;em&gt;non-asymptotic&lt;/em&gt; stuff (&quot;stuff near the origin&quot; or &quot;what happens when the problem size is small&quot;): the function &lt;code&gt;10x&amp;sup2;&lt;/code&gt; is said to &quot;grow exactly like&quot; &lt;code&gt;10x&amp;sup2; - x + 2&lt;/code&gt;.</source>
          <target state="translated">big-O表記では定数要素は考慮されません。関数 &lt;code&gt;9x&amp;sup2;&lt;/code&gt; は10x&amp;sup2;とまったく同じように成長すると言われています。 また、big-O &lt;em&gt;漸近&lt;/em&gt;記法は&lt;em&gt;非漸近的な&lt;/em&gt;もの（「原点に近いもの」または「問題のサイズが小さい場合に何が起こるか」）を &lt;code&gt;10x&amp;sup2;&lt;/code&gt; 。関数10x&amp;sup2;は、「 &lt;code&gt;10x&amp;sup2; - x + 2&lt;/code&gt; ように成長する」と言われています。</target>
        </trans-unit>
        <trans-unit id="3fed40854ecbd633619a5d431600a671eeed9292" translate="yes" xml:space="preserve">
          <source>c= a constant</source>
          <target state="translated">c=定数</target>
        </trans-unit>
        <trans-unit id="e923389b125ffc7cdb2e423a899d4348e7439235" translate="yes" xml:space="preserve">
          <source>division.</source>
          <target state="translated">division.</target>
        </trans-unit>
        <trans-unit id="714de604846fa9d95f2b9fc4aaa27f67caadafd4" translate="yes" xml:space="preserve">
          <source>e.g. for x=1million, ratio #handshakes/x&amp;sup2;: 0.499999...</source>
          <target state="translated">たとえば、x = 1millionの場合、比率＃handshakes /x&amp;sup2;：0.499999 ...</target>
        </trans-unit>
        <trans-unit id="f42454a2adeb8a0c26a29f629c55ab5dda69a64d" translate="yes" xml:space="preserve">
          <source>f(n)= An approximate function that expresses the running time of the algorithm as a function of n</source>
          <target state="translated">f(n)=アルゴリズムの実行時間を n の関数として表現する近似関数</target>
        </trans-unit>
        <trans-unit id="6b7dffac98fa2e9f18d9b09123953c56c601da05" translate="yes" xml:space="preserve">
          <source>how heat output scales on CPU dies as a function of transistor count, voltage, etc.</source>
          <target state="translated">トランジスタ数、電圧などの関数として、CPUダイの熱出力がどのようにスケーリングするか</target>
        </trans-unit>
        <trans-unit id="077a4887c6602aedfb17f44dd051822aa960da2d" translate="yes" xml:space="preserve">
          <source>how much space an algorithm needs to run, as a function of input size</source>
          <target state="translated">アルゴリズムを実行するのに必要なスペース量、入力サイズの関数として</target>
        </trans-unit>
        <trans-unit id="4d80174ea25f9828dcb069496071916d7c70255b" translate="yes" xml:space="preserve">
          <source>how much time an algorithm needs to run, as a function of input size</source>
          <target state="translated">アルゴリズムの実行にどれくらいの時間が必要か、入力サイズの関数として</target>
        </trans-unit>
        <trans-unit id="f2dbea261a6334b636fcb8245379760585160604" translate="yes" xml:space="preserve">
          <source>how website latency scales with the number of processing units in a CPU or GPU or computer cluster</source>
          <target state="translated">ウェブサイトのレイテンシがCPUやGPU、コンピュータクラスタの処理ユニット数に応じてどのように変化するか</target>
        </trans-unit>
        <trans-unit id="5aa429e0444abdc08467c70c26cbff2d88e2345a" translate="yes" xml:space="preserve">
          <source>it's less than O(N&lt;sup&gt;1.000001&lt;/sup&gt;), which you might be willing to call basically linear</source>
          <target state="translated">O（N &lt;sup&gt;1.000001&lt;/sup&gt; ）未満です。これは基本的に線形と呼んでもかまいません。</target>
        </trans-unit>
        <trans-unit id="8e97d6456227b5a58913c9ed733df644f1e01e91" translate="yes" xml:space="preserve">
          <source>k is bounded in some neighborhood of a (if a = +&amp;infin;, this means that there are numbers N and M such that for every x &amp;gt; N, |&lt;em&gt;k&lt;/em&gt;(x)| &amp;lt; M).</source>
          <target state="translated">kはaのある近傍に限定されます（a = +&amp;infin;の場合、これは、すべてのx&amp;gt; Nに対して| &lt;em&gt;k&lt;/em&gt; （x）| &amp;lt;MになるようなNおよびMの数があることを意味します）。</target>
        </trans-unit>
        <trans-unit id="6005c391c2f680a2452cd2577c2564dbcef8e9c9" translate="yes" xml:space="preserve">
          <source>ln(x) = o(x) = O(x) when x &amp;rarr; +&amp;infin;.</source>
          <target state="translated">ln（x）= o（x）= O（x）（x&amp;rarr;+&amp;infin;の場合）。</target>
        </trans-unit>
        <trans-unit id="273b9bcfed53ba997f70f8aa75c36bda6fde8958" translate="yes" xml:space="preserve">
          <source>multiplication; and</source>
          <target state="translated">乗算;および</target>
        </trans-unit>
        <trans-unit id="a4393b9a14bdfd4f4c0eeaaf31bad2e0b9cfef0d" translate="yes" xml:space="preserve">
          <source>n=number of input parameters</source>
          <target state="translated">n=入力パラメータの数</target>
        </trans-unit>
        <trans-unit id="463f52bc275366887f835ed5e5f95c1fe198e8af" translate="yes" xml:space="preserve">
          <source>or address it formally, &quot;Big O&quot; classifies the algorithms and standardize the comparison process.</source>
          <target state="translated">または正式には「ビッグ・オー」がアルゴリズムを分類し、比較処理を標準化しています。</target>
        </trans-unit>
        <trans-unit id="27c0dba7b6e5e26123d57265908dfa7204907ffd" translate="yes" xml:space="preserve">
          <source>probabilistic expected number of people who have seen some viral marketing as a function of time</source>
          <target state="translated">時間の関数としてのバイラルマーケティングを見たことがある人の確率的な期待数</target>
        </trans-unit>
        <trans-unit id="0c2b90eddd63a783f5f290989f744b1bf85f87bd" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15,20,25}  ==&amp;gt; problem-instance-size = 5 iterations-in-loop = 5</source>
          <target state="translated">problem-instance = {5,10,15,20,25} ==&amp;gt; problem-instance-size = 5ループ内の反復= 5</target>
        </trans-unit>
        <trans-unit id="e4b7c82dda906533e8c2824c6df8639b2a23a367" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15,20,25}  ==&amp;gt; problem-instance-size = 5, total-iterations= 5*5 =25</source>
          <target state="translated">problem-instance = {5,10,15,20,25} ==&amp;gt; problem-instance-size = 5、total-iterations = 5 * 5 = 25</target>
        </trans-unit>
        <trans-unit id="7b9571101e4cfebe964dd712258a749bb36005e9" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15}  ==&amp;gt; problem-instance-size = 3, iterations-in-loop= 3</source>
          <target state="translated">problem-instance = {5,10,15} ==&amp;gt; problem-instance-size = 3、iterations-in-loop = 3</target>
        </trans-unit>
        <trans-unit id="41a7ac7c629f59f13ed8b74173f006eb424e46ac" translate="yes" xml:space="preserve">
          <source>problem-instance= {5,10,15}  ==&amp;gt; problem-instance-size = 3, total-iterations = 3*3 = 9</source>
          <target state="translated">problem-instance = {5,10,15} ==&amp;gt; problem-instance-size = 3、total-iterations = 3 * 3 = 9</target>
        </trans-unit>
        <trans-unit id="6adf164f31eaa024e8cd62ab3a7db4601ada676a" translate="yes" xml:space="preserve">
          <source>sin x = O(1) when x &amp;rarr; +&amp;infin;,</source>
          <target state="translated">sin x = O（1）（x&amp;rarr;+&amp;infin;の場合）</target>
        </trans-unit>
        <trans-unit id="01a98a9d29b98d64c9b325ce600cfccdddb4209c" translate="yes" xml:space="preserve">
          <source>sin x = O(x) when x &amp;rarr; 0.</source>
          <target state="translated">x&amp;rarr;0の場合、sin x = O（x）。</target>
        </trans-unit>
        <trans-unit id="0f7b476dccef1271c4d6a97311ca082c68f64f7e" translate="yes" xml:space="preserve">
          <source>so you could get its idea literally that it's used to order something to  compare them.</source>
          <target state="translated">だから、あなたはそれがそれらを比較するために何かを注文するために使用されていることを文字通りそのアイデアを得ることができます。</target>
        </trans-unit>
        <trans-unit id="2411b10604909e08dc5dd9f0ef7bed5327f33858" translate="yes" xml:space="preserve">
          <source>subtraction;</source>
          <target state="translated">subtraction;</target>
        </trans-unit>
        <trans-unit id="1dfbbc899d7564b2c25e7c8e5668555967ef21c9" translate="yes" xml:space="preserve">
          <source>the number of possible handshakes among &lt;code&gt;N&lt;/code&gt; people at a party (&lt;code&gt;Ɵ(N&amp;sup2;)&lt;/code&gt;, specifically &lt;code&gt;N(N-1)/2&lt;/code&gt;, but what matters is that it &quot;scales like&quot; &lt;code&gt;N&amp;sup2;&lt;/code&gt;)</source>
          <target state="translated">パーティーで &lt;code&gt;N&lt;/code&gt; 人の間で可能なハンドシェイクの数（ &lt;code&gt;Ɵ(N&amp;sup2;)&lt;/code&gt; 、具体的には &lt;code&gt;N(N-1)/2&lt;/code&gt; ですが、重要なのは、それが &quot; &lt;code&gt;N&amp;sup2;&lt;/code&gt; のようにスケールする&quot;ことです）</target>
        </trans-unit>
        <trans-unit id="a673eb6514c9181588ced3c270df39095e5c61da" translate="yes" xml:space="preserve">
          <source>x&lt;sup&gt;2&lt;/sup&gt; + x = O(x) when x &amp;rarr; 0,</source>
          <target state="translated">x &lt;sup&gt;2&lt;/sup&gt; + x = O（x）、x&amp;rarr;0の場合、</target>
        </trans-unit>
        <trans-unit id="4588b59a6bc0b7081d698604a73689ff94c6669e" translate="yes" xml:space="preserve">
          <source>x&lt;sup&gt;2&lt;/sup&gt; + x = O(x&lt;sup&gt;2&lt;/sup&gt;) when x &amp;rarr; +&amp;infin;,</source>
          <target state="translated">x &lt;sup&gt;2&lt;/sup&gt; + x = O（x &lt;sup&gt;2&lt;/sup&gt; ）x&amp;rarr;+&amp;infin;の場合、</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
