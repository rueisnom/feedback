<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4810664">
    <body>
      <group id="4810664">
        <trans-unit id="d04e79de260ba2b52b7b4be3155464cf946b0af5" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but this fails when &lt;code&gt;Collection&lt;/code&gt; is not a raw array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;hellip;但是当&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不是原始数组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时，这将失败&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0612f3b5a654cd50db291e826efe5c34a0b6cc25" translate="yes" xml:space="preserve">
          <source>&amp;hellip; declarations for an array object can specify array types that
  differ by the presence or absence of a major array bound (8.3.4).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;hellip;数组对象的声明可以指定因主要数组绑定（8.3.4）是否存在而不同的数组类型。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0e4678381c395fca109fb1a7ab2963eb52ccdf85" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;⋮</source>
          <target state="translated">&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;⋮</target>
        </trans-unit>
        <trans-unit id="eaace149c48e3954770834bb04a3463bc80ecf38" translate="yes" xml:space="preserve">
          <source>(None of the above is specific to arrays. These rules apply equally well to other kinds of static objects.)</source>
          <target state="translated">(以上的规则都不是专门针对数组的。这些规则同样适用于其他类型的静态对象。)</target>
        </trans-unit>
        <trans-unit id="9bf1213a32eac75ae4baa950dd194049601cf63c" translate="yes" xml:space="preserve">
          <source>(Note that the implicitly generated pointer has no name, so I wrote &lt;code&gt;x+0&lt;/code&gt; in order to identify it.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（请注意，隐式生成的指针没有名称，所以我写了&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x+0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来识别它。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38adde0b67b061a1ec171d70e52bc519f4a9e0b7" translate="yes" xml:space="preserve">
          <source>(Note that variables at namespace scope are implicitly static. Adding the &lt;code&gt;static&lt;/code&gt; keyword to their definition has a &lt;a href=&quot;https://stackoverflow.com/questions/3891325/&quot;&gt;completely different, deprecated meaning&lt;/a&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（请注意，名称空间范围内的变量是隐式静态的。将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;static&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;添加&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到其定义中具有&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3891325/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全不同的不赞成使用的含义&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="231510dccd89918e53895d32efe43a1984323116" translate="yes" xml:space="preserve">
          <source>(Note the trailing pair of parenthesis right before the semicolon.) Again, C++0x simplifies the rules and allows specifying initial values for anonymous arrays thanks to uniform initialization:</source>
          <target state="translated">(注意分号前的小括号后面的小括号。)再次,C++0x简化了规则,并且由于统一的初始化,允许指定匿名数组的初始值。</target>
        </trans-unit>
        <trans-unit id="90aa3f8dd54d913a20bcd4352992625debef9147" translate="yes" xml:space="preserve">
          <source>1 elements.</source>
          <target state="translated">1要素:</target>
        </trans-unit>
        <trans-unit id="a651c751b5b91bd381394f65645d3e91f1f89c2d" translate="yes" xml:space="preserve">
          <source>5. Common pitfalls when using arrays.</source>
          <target state="translated">5.使用数组时的常见误区。</target>
        </trans-unit>
        <trans-unit id="19ec1826e2fdf1b52e478a2704cb8d0d8615d9bc" translate="yes" xml:space="preserve">
          <source>5.1 Pitfall: Trusting type-unsafe linking.</source>
          <target state="translated">5.1 陷阱。信任型的不安全链接。</target>
        </trans-unit>
        <trans-unit id="1796594de79af31df71419271109d6b84d26c8a2" translate="yes" xml:space="preserve">
          <source>5.2 Pitfall: Doing premature optimization (&lt;code&gt;memset&lt;/code&gt; &amp;amp; friends).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5.2陷阱：进行过早优化（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;memset&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和朋友）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0a0e496ecd16a8c73f36baed69bdc51bfc3031a" translate="yes" xml:space="preserve">
          <source>5.3 Pitfall: Using the C idiom to get number of elements.</source>
          <target state="translated">5.3 陷阱。用C项成语来获取元素数量。</target>
        </trans-unit>
        <trans-unit id="2479875ffe2b4aa5f8ac73d86a4c378dc2349229" translate="yes" xml:space="preserve">
          <source>5.4 C++11 &amp;amp; C++14 pitfall: Using a &lt;code&gt;constexpr&lt;/code&gt; array size function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5.4 C ++ 11和C ++ 14陷阱：使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组大小函数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5390b67f62a37f1c341c198ae984410b96914b51" translate="yes" xml:space="preserve">
          <source>7 elements, calling display...</source>
          <target state="translated">7个元素,调用显示.....</target>
        </trans-unit>
        <trans-unit id="f9de6fbff782960fefcc3095a3bc24ddfce1b643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;N_ITEMS&lt;/code&gt; is therefore invoked with a pointer.</source>
          <target state="translated">&lt;code&gt;N_ITEMS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，使用指针调用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;N_ITEMS&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="74212934fe8368a399b0d98b0a4d9b7243ba5e1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int(*)[8]&lt;/code&gt; is a pointer to an array of 8 integers.</source>
          <target state="translated">&lt;code&gt;int(*)[8]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是指向8个整数的数组的指针。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a32d2b9fd0ba41aa42e8651c7bf0b911729c9d10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int*[8]&lt;/code&gt; is an array of 8 pointers, each element of type &lt;code&gt;int*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;int*[8]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是8个指针的数组，每个元素的类型都是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="96eb00bc6e8065436e33e4a99e47570293b66488" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof(*array)&lt;/code&gt; is equivalent to &lt;code&gt;sizeof(int)&lt;/code&gt;, which for a 32-bit executable is also 4.</source>
          <target state="translated">&lt;code&gt;sizeof(*array)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等效于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof(int)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，对于32位可执行文件，它也为4。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3903fae2b05023ec89b2d2cc770d69f2c57d737" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Not written yet&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还没写&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8586c6494c198dbc6f2f6317d094faf70f2ea3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;[N3290 &amp;sect;3.5/10]&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[N3290&amp;sect;3.5/ 10]&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="620ae72342c6c376f4c4a1a08f78905e1878296d" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;(Note: This is meant to be an entry to &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow's C++ FAQ&lt;/a&gt;. If you want to critique the idea of providing an FAQ in this form, then &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;the posting on meta that started all this&lt;/a&gt; would be the place to do that. Answers to that question are monitored in the &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C++ chatroom&lt;/a&gt;, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;（注意：这本来是&lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow的C ++ FAQ&lt;/a&gt;的条目。如果您想批评以这种形式提供FAQ的想法，那么&lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;在所有这些&lt;/a&gt;都开始的meta上的张贴将是这样做的地方。该问题在&lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C ++聊天室&lt;/a&gt;中进行监控，该问题最初是从FAQ想法开始的，所以提出这个想法的人很可能会读懂您的答案。）&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a7380dfe067e661e6c28af642fc12e65ff35a367" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;conditional-expression&lt;/em&gt;&lt;code&gt;e&lt;/code&gt; is a &lt;em&gt;core constant expression&lt;/em&gt; unless the evaluation
  of &lt;code&gt;e&lt;/code&gt;, following the rules of the abstract machine (1.9), would evaluate one of the
  following expressions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;甲&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;条件表达式&lt;/font&gt;&lt;/font&gt;&lt;/em&gt; &lt;code&gt;e&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;核心常量表达式&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除非的评价&lt;/font&gt;&lt;/font&gt; &lt;code&gt;e&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，以下抽象机（1.9），将评估下面的表达式中的一个的规则：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6ec1049f6c023e311e56e84c953aa4c9fe27c95a" translate="yes" xml:space="preserve">
          <source>A violation of this rule on type identity does not require a diagnostic.</source>
          <target state="translated">违反了这个关于类型识别的规则,不需要诊断。</target>
        </trans-unit>
        <trans-unit id="0cd6ad0e54ee6246cea808ee63fd05eddfc872e5" translate="yes" xml:space="preserve">
          <source>About the choice of return type for &lt;code&gt;static_n_items&lt;/code&gt;: this code doesn't use &lt;code&gt;std::integral_constant&lt;/code&gt;
because with &lt;code&gt;std::integral_constant&lt;/code&gt; the result is represented
directly as a &lt;code&gt;constexpr&lt;/code&gt; value, reintroducing the original problem. Instead
of a &lt;code&gt;Size_carrier&lt;/code&gt; class one can let the function directly return a
reference to an array. However, not everybody is familiar with that syntax.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;static_n_items&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回类型的选择&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：此代码不使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::integral_constant&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 因为使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::integral_constant&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，结果直接表示为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值，从而重新引入了原始问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以使函数直接返回对数组的引用，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Size_carrier&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，并不是每个人都熟悉该语法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b959c28ecb4dde919a516a1c1b3188124c5c2f89" translate="yes" xml:space="preserve">
          <source>About the naming: part of this solution to the &lt;code&gt;constexpr&lt;/code&gt;-invalid-due-to-reference
problem is to make the choice of compile time constant explicit.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关于命名：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -invalid-due-to-reference问题&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的这种解决方案的一部分&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是使编译时间常数的选择明确。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26a01f7a3f29b95a2006e044a16488cdb32ba200" translate="yes" xml:space="preserve">
          <source>Accessing elements</source>
          <target state="translated">访问元素</target>
        </trans-unit>
        <trans-unit id="8d39c2f6a75768a2092994233c9a0daa3c70b9d6" translate="yes" xml:space="preserve">
          <source>Also note that you could simply provide &lt;code&gt;x&lt;/code&gt; as the first argument. That is a little too terse for my taste, and it also makes template argument deduction a bit harder for the compiler, because in that case the first argument is an array but the second argument is a pointer. (Again, array-to-pointer decay kicks in.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还要注意，您可以简单地将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为第一个参数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这对我来说有点太简洁了，这也使模板参数的推导对编译器来说有点困难，因为在这种情况下，第一个参数是数组，而第二个参数是指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（再次，阵列到指针的衰减开始。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18999a9d2d7e1f9e2ca1c736ffbc5c4469b40a2e" translate="yes" xml:space="preserve">
          <source>Alternatively, the initial values can be explicitly specified in the &lt;em&gt;array initializer&lt;/em&gt;, a comma-separated list surrounded by curly brackets:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或者，可以在&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始值设定项中显式指定初始值，该初始值是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用大括号括起来的逗号分隔列表：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13bd6a28072658c138cb224a1d27229ba67fa990" translate="yes" xml:space="preserve">
          <source>Alternatively, you can define an automatic array in the constructor body and copy the elements over:</source>
          <target state="translated">另外,你也可以在构造体中定义一个自动数组,然后将元素复制过来。</target>
        </trans-unit>
        <trans-unit id="b08a5a490469c21ff382823b10dd32277b29eff4" translate="yes" xml:space="preserve">
          <source>Although you cannot assign arrays directly, you &lt;em&gt;can&lt;/em&gt; assign structs and classes which &lt;em&gt;contain&lt;/em&gt; array members. That is because &lt;a href=&quot;https://stackoverflow.com/questions/4164279/&quot;&gt;array members are copied memberwise&lt;/a&gt; by the assignment operator which is provided as a default by the compiler. If you define the assignment operator manually for your own struct or class types, you must fall back to manual copying for the array members.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尽管不能直接分配数组，但是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分配&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包含&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组成员的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;结构和类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是因为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4164279/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组成员是&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由赋值运算符按&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成员复制&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的，赋值运算符是编译器默认提供的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您为自己的结构或类类型手动定义赋值运算符，则必须退回到阵列成员的手动复制。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="686c9976fce3ef9968836df6eec6c84549086e98" translate="yes" xml:space="preserve">
          <source>An array of type &lt;code&gt;T[n]&lt;/code&gt; has &lt;code&gt;n&lt;/code&gt; elements, indexed from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;; there is no element &lt;code&gt;n&lt;/code&gt;. And yet, to support half-open ranges (where the beginning is &lt;em&gt;inclusive&lt;/em&gt; and the end is &lt;em&gt;exclusive&lt;/em&gt;), C++ allows the computation of a pointer to the (non-existent) n-th element, but it is illegal to dereference that pointer:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T[n]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的数组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; 个&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元素，索引从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n-1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有元素&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，为了支持半开范围（开始是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包含端点&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，结束是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;排斥&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;端点&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），C ++允许计算指向第n个元素（不存在）的指针，但是取消引用该指针是非法的：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42456e1dacb6621675d5ac2e2413c58c4322f39d" translate="yes" xml:space="preserve">
          <source>An array type is denoted as &lt;code&gt;T[n]&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the &lt;em&gt;element type&lt;/em&gt; and &lt;code&gt;n&lt;/code&gt; is a positive &lt;em&gt;size&lt;/em&gt;, the number of elements in the array. The array type is a product type of the element type and the size. If one or both of those ingredients differ, you get a distinct type:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组类型被表示为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T[n]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元素类型&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是正&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大小&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，阵列中元件的数量。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组类型是元素类型和大小的乘积类型。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果这些成分中的一种或两种不同，则会得到不同的类型：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e9e7db807e1364a1e5c48cc0f20413a61a41902" translate="yes" xml:space="preserve">
          <source>And here is how it looks like in memory:</source>
          <target state="translated">下面是记忆中的样子。</target>
        </trans-unit>
        <trans-unit id="eac77d06b46f4d096b1aad128c8a1a33836938e7" translate="yes" xml:space="preserve">
          <source>Anonymous arrays of pointers</source>
          <target state="translated">匿名的指针数组</target>
        </trans-unit>
        <trans-unit id="647cdf988737cc9ccd2df7b3b704cfd1c6bb74a8" translate="yes" xml:space="preserve">
          <source>Anonymous multidimensional arrays</source>
          <target state="translated">匿名多维数组</target>
        </trans-unit>
        <trans-unit id="1343cf5171221fe816c93d6f2a075c26f5b24b07" translate="yes" xml:space="preserve">
          <source>Array creation and initialization</source>
          <target state="translated">阵列的创建和初始化</target>
        </trans-unit>
        <trans-unit id="399f9928701629470c3f9405ace42415e4409175" translate="yes" xml:space="preserve">
          <source>Array data members</source>
          <target state="translated">阵列数据成员</target>
        </trans-unit>
        <trans-unit id="24b8804b7e356d42cd7f09e1eb85af586ae43524" translate="yes" xml:space="preserve">
          <source>Array data members are created when their owning object is created. Unfortunately, C++03 provides no means to initialize arrays in the &lt;a href=&quot;https://stackoverflow.com/questions/1711990/&quot;&gt;member initializer list&lt;/a&gt;, so initialization must be faked with assignments:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组数据成员是在创建其拥有的对象时创建的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不幸的是，C ++ 03没有提供初始化&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1711990/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成员初始值设定项列表&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的数组的方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此必须使用赋值伪造初始化：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e8874168e3c1df960a01e93b0e01fe86fb6ae2dc" translate="yes" xml:space="preserve">
          <source>Array-to-pointer decay</source>
          <target state="translated">阵列到指针的衰变</target>
        </trans-unit>
        <trans-unit id="1ac5bd4e173a92bcb04c137f8efe28804ea718a6" translate="yes" xml:space="preserve">
          <source>Array-to-pointer decay naturally extends to arrays of arrays and arrays of pointers:</source>
          <target state="translated">阵列到指针的衰减自然延伸到数组和指针的数组。</target>
        </trans-unit>
        <trans-unit id="6e40493abcaecb122cbcf832dab790b8d29fdd9f" translate="yes" xml:space="preserve">
          <source>Arrays are not pointers</source>
          <target state="translated">数组不是指针</target>
        </trans-unit>
        <trans-unit id="f7a03c30a551a2c39c3c9fc257600a5d16f43aaf" translate="yes" xml:space="preserve">
          <source>Arrays can also be passed by reference:</source>
          <target state="translated">也可以通过引用传递数组。</target>
        </trans-unit>
        <trans-unit id="2bf47475c7967f15061d931504841dd6198c3b0f" translate="yes" xml:space="preserve">
          <source>Arrays cannot be passed by value. You can either pass them by pointer or by reference.</source>
          <target state="translated">数组不能通过值传递。你可以通过指针或引用传递,也可以通过指针传递。</target>
        </trans-unit>
        <trans-unit id="0d3931969794470ea65ef6c4ed1f5814ad89e104" translate="yes" xml:space="preserve">
          <source>Arrays of pointers</source>
          <target state="translated">指向器的数组</target>
        </trans-unit>
        <trans-unit id="7b85b17ab780077809da01b26286144e5377b12f" translate="yes" xml:space="preserve">
          <source>Arrays on the type level</source>
          <target state="translated">类型层上的数组</target>
        </trans-unit>
        <trans-unit id="9195cd8f84277c2a066f9b3969eb7b482e709897" translate="yes" xml:space="preserve">
          <source>As a syntactic alternative, you can also declare parameters as &lt;code&gt;T p[]&lt;/code&gt;, and it means the exact same thing as &lt;code&gt;T* p&lt;/code&gt;&lt;strong&gt;in the context of parameter lists only&lt;/strong&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为语法选择，您还可以将参数声明为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T p[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这意味着&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅在参数列表的上下文中&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T* p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全相同&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7b591505e594b531518f3338ddc699030668ab81" translate="yes" xml:space="preserve">
          <source>As with any other kind of C++ object, arrays can be stored either directly in named variables (then the size must be a compile-time constant; &lt;a href=&quot;https://stackoverflow.com/questions/1887097/&quot;&gt;C++ does not support VLAs&lt;/a&gt;), or they can be stored anonymously on the heap and accessed indirectly via pointers (only then can the size be computed at runtime).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与任何其他类型的C ++对象一样，可以将数组直接存储在命名变量中（然后，大小必须是编译时常量；&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1887097/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++不支持VLA&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），也可以将它们匿名存储在堆上并通过间接访问指针（只有这样才能在运行时计算大小）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ba05dcd6a6016a8619c5531920406c9d627e7d45" translate="yes" xml:space="preserve">
          <source>Assertion failed: ( &quot;N_ITEMS requires an actual array as argument&quot;, typeid( a ) != typeid( &amp;amp;*a ) ), file runtime_detect
  ion.cpp, line 16</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;断言失败：（&amp;ldquo; N_ITEMS需要一个实际的数组作为参数&amp;rdquo;，typeid（a）！= typeid（＆* a）），文件runtime_detect ion.cpp，第16行&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="40f5291aa65f0d251ce748666c38a331190c5ced" translate="yes" xml:space="preserve">
          <source>Automatic arrays</source>
          <target state="translated">自动数组</target>
        </trans-unit>
        <trans-unit id="e1d37e408deb2e78b4ca48daeb81d9bd4471d3ae" translate="yes" xml:space="preserve">
          <source>Automatic arrays (arrays living &quot;on the stack&quot;) are created each time the flow of control passes through the definition of a non-static local array variable:</source>
          <target state="translated">每当控制流通过定义一个非静态本地数组变量时,就会自动创建一个自动数组(数组生活在 &quot;堆栈 &quot;上)。</target>
        </trans-unit>
        <trans-unit id="f636bb95872b824ff74a6c4034eaba0370183449" translate="yes" xml:space="preserve">
          <source>But consider this code using the &lt;code&gt;constexpr&lt;/code&gt; version:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是请考虑使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;版本的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下代码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="de28acb7f2a0a27ea202dbc568fb44f90656e5d6" translate="yes" xml:space="preserve">
          <source>C++ inherited arrays from C where they are used virtually everywhere. C++ provides abstractions that are easier to use and less error-prone (&lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; since C++98 and &lt;a href=&quot;http://en.cppreference.com/w/cpp/container/array&quot;&gt;&lt;code&gt;std::array&amp;lt;T, n&amp;gt;&lt;/code&gt;&lt;/a&gt; since &lt;a href=&quot;https://en.wikipedia.org/wiki/C++11&quot;&gt;C++11&lt;/a&gt;), so the need for arrays does not arise quite as often as it does in C. However, when you read legacy code or interact with a library written in C, you should have a firm grasp on how arrays work.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++从C继承了数组，几乎可以在任何地方使用它们。 C ++提供了更易于使用且不易出错的抽象（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自C ++ 98起为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/container/array&quot;&gt; &lt;code&gt;std::array&amp;lt;T, n&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/C++11&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;起为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;std :: array &amp;lt;T，n&amp;gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），因此不需要数组出现的频率与C语言相同。但是，当您阅读旧代码或与用C语言编写的库进行交互时，您应该对数组的工作原理有把握。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="372b375c077d1592b504d6ea862fc8b660d07ce4" translate="yes" xml:space="preserve">
          <source>C++ provides two syntactic variations to access individual elements of an array.
Neither of them is superior to the other, and you should familiarize yourself with both.</source>
          <target state="translated">C++提供了两种语法变化来访问数组中的单个元素。两者都没有优于另一种,你应该熟悉这两种方法。</target>
        </trans-unit>
        <trans-unit id="e9ee5228e62855edd689fcf1ee439ad1835186a8" translate="yes" xml:space="preserve">
          <source>C++11 C++14 $5.19/2 nine&lt;sup&gt;&lt;i&gt;th&lt;/i&gt;&lt;/sup&gt; dash</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11 C ++ 14 $ 5.19 / 2 9 &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;i&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;个&lt;/font&gt;&lt;/font&gt;&lt;/i&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;短划线&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="451cf0fb180276f6104c195abd9824bc51889070" translate="yes" xml:space="preserve">
          <source>Compiling this definition substituted into the first complete program, with g++,
I got &amp;hellip;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用g ++将这个定义编译成第一个完整的程序，我得到了&amp;hellip;&amp;hellip;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edd1068f47092445e2ade712a957ef28258872b7" translate="yes" xml:space="preserve">
          <source>Concerning default values for elements, anonymous arrays behave similar to automatic arrays.
Normally, anonymous POD arrays are not initialized, but there is a &lt;a href=&quot;https://stackoverflow.com/questions/620137/&quot;&gt;special syntax&lt;/a&gt; that triggers value-initialization:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关于元素的默认值，匿名数组的行为类似于自动数组。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常，匿名POD数组不会初始化，但是有一种&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/620137/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特殊的语法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可触发值初始化：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b08eaadf77cfdba7944ddcaf69eee5a983b74af3" translate="yes" xml:space="preserve">
          <source>Conversions</source>
          <target state="translated">Conversions</target>
        </trans-unit>
        <trans-unit id="e8e9bf39de7b205510d34a98df2a540f29880a3d" translate="yes" xml:space="preserve">
          <source>Due to the fact that addition is commutative, the following code does exactly the same:</source>
          <target state="translated">由于加法是换向的,所以下面的代码做得完全一样。</target>
        </trans-unit>
        <trans-unit id="7d44854713dee942aa855be9529ca9049d1f51a4" translate="yes" xml:space="preserve">
          <source>Dynamic arrays</source>
          <target state="translated">动态数组</target>
        </trans-unit>
        <trans-unit id="fa79fb6c19ebe9065a4f0b664015743660924a69" translate="yes" xml:space="preserve">
          <source>Dynamic arrays have no names, hence the only means of accessing them is via pointers. Because they have no names, I will refer to them as &quot;anonymous arrays&quot; from now on.</source>
          <target state="translated">动态数组没有名字,因此唯一的访问方法就是通过指针来访问它们。因为它们没有名字,所以从现在开始我将把它们称为 &quot;匿名数组&quot;。</target>
        </trans-unit>
        <trans-unit id="1ad437396251bede18ff480da4a2fb5768a40959" translate="yes" xml:space="preserve">
          <source>For a 32-bit executable &lt;code&gt;sizeof(array)&lt;/code&gt; (size of a pointer) is then 4.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于32位可执行文件，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof(array)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（指针的大小）为4。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccf9fc11e30342ada49e22699adfb1eee920ea13" translate="yes" xml:space="preserve">
          <source>For example, if you want to sort an array, both of the following would work equally well:</source>
          <target state="translated">比如说,如果你想对一个数组进行排序,下面这两个方法同样有效。</target>
        </trans-unit>
        <trans-unit id="df57dc8940ddba3bf21d9400ea8d2ff132094b4b" translate="yes" xml:space="preserve">
          <source>For example, in contrast to the C++03 function, such a compile time constant
can be used to declare an array of the same size as another:</source>
          <target state="translated">例如,与C++03函数相反,这样的编译时间常数可以用来声明一个与另一个相同大小的数组。</target>
        </trans-unit>
        <trans-unit id="c60990da60348b38b26e24567aa5449142642c6b" translate="yes" xml:space="preserve">
          <source>For no particular reason, arrays cannot be assigned to one another. Use &lt;code&gt;std::copy&lt;/code&gt; instead:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出于特殊原因，不能将数组彼此分配。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::copy&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代替：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c72639e3e48ee10535ffefafd0e659f4a2e46be9" translate="yes" xml:space="preserve">
          <source>Given a pointer &lt;code&gt;p&lt;/code&gt; to the first element of an array, the expression &lt;code&gt;p+i&lt;/code&gt; yields a pointer to the i-th element of the array. By dereferencing that pointer afterwards, one can access individual elements:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给定一个指向&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组第一个元素的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指针&lt;/font&gt;&lt;/font&gt; &lt;code&gt;p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;p+i&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;产生一个指向数组第i个元素的指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之后，通过取消引用该指针，可以访问各个元素：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="55b8034a1c4de8546af371fad141ee844edc1ceb" translate="yes" xml:space="preserve">
          <source>Here is a named array of five pointers which are initialized with anonymous arrays of different lengths:</source>
          <target state="translated">这里是一个由五个指针组成的命名数组,它们是用不同长度的匿名数组初始化的。</target>
        </trans-unit>
        <trans-unit id="c076f328745f37debceee5f1f2ed902d4a78f344" translate="yes" xml:space="preserve">
          <source>Here is an anonymous array of 5 (or any other number of) pointers which are initialized with anonymous arrays of different lengths:</source>
          <target state="translated">这里是一个由5个(或任何其他数量的)指针组成的匿名数组,这些指针是用不同长度的匿名数组初始化的。</target>
        </trans-unit>
        <trans-unit id="23dac17f7c85db33e32efee228cc1206d13ce8f2" translate="yes" xml:space="preserve">
          <source>Here is how static arrays behave differently from automatic arrays:</source>
          <target state="translated">以下是静态数组与自动数组的不同之处。</target>
        </trans-unit>
        <trans-unit id="29b93b685e9f34727b707a03a54e84c221d810d0" translate="yes" xml:space="preserve">
          <source>Hopefully the oops-there-was-a-reference-involved-in-your-&lt;code&gt;constexpr&lt;/code&gt; issue will be fixed with
C++17, but until then a macro like the &lt;code&gt;STATIC_N_ITEMS&lt;/code&gt; above yields portability,
e.g. to the clang and Visual C++ compilers, retaining type safety.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;希望oops在您的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;涉及到引用，该&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;问题将在C ++ 17中得到解决，但在此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;STATIC_N_ITEMS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上面&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;STATIC_N_ITEMS之&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类的宏&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以移植，例如到clang和Visual C ++编译器，保持类型安全。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="12890f5a4d79b3a152da01cd5f87ddd2cfb5f4eb" translate="yes" xml:space="preserve">
          <source>How do I use arrays in C++</source>
          <target state="translated">如何在C++中使用数组</target>
        </trans-unit>
        <trans-unit id="de3060ce19f3a3bb1c4391b3ddd3d0001e575313" translate="yes" xml:space="preserve">
          <source>How it works: the array is passed &lt;em&gt;by reference&lt;/em&gt; to &lt;code&gt;n_items&lt;/code&gt;, and so it does
not decay to pointer to first element, and the function can just return the
number of elements specified by the type.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它是如何工作的：该数组是通过&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对&lt;/font&gt; &lt;code&gt;n_items&lt;/code&gt; &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的引用&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;传递&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此它不会衰减到指向第一个元素的指针，并且该函数可以返回该类型指定的元素数。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="71ce2f00f67820d9da8ad53a668481248e234bc0" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;&amp;amp;x[0]&lt;/code&gt; is generally &lt;em&gt;not&lt;/em&gt; equivalent to &lt;code&gt;x&lt;/code&gt;. The former is a pointer, the latter an array. Only when the context triggers array-to-pointer decay can &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;&amp;amp;x[0]&lt;/code&gt; be used interchangeably. For example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;x[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;前者是指针，后者是数组。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅当上下文触发数组到指针的衰减时，才能将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;x[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;互换使用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50831c9c02e63682913c1ef6afbaea938a24ca91" translate="yes" xml:space="preserve">
          <source>However, there is no implicit conversion from &lt;code&gt;T[h][w]&lt;/code&gt; to &lt;code&gt;T**&lt;/code&gt;. If such an implicit conversion did exist, the result would be a pointer to the first element of an array of &lt;code&gt;h&lt;/code&gt; pointers to &lt;code&gt;T&lt;/code&gt; (each pointing to the first element of a line in the original 2D array), but that pointer array does not exist anywhere in memory yet. If you want such a conversion, you must create and fill the required pointer array manually:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，没有从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T[h][w]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T**&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;隐式转换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果确实存在这样的隐式转换，则结果将是指向&lt;/font&gt;&lt;/font&gt; &lt;code&gt;h&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指针&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组的第一个元素的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指针&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（每个指向原始2D数组中一行的第一个元素），但是该指针数组不存在内存中的任何地方。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果要进行这种转换，则必须手动创建并填充所需的指针数组：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6325f458cb378a4b64ec12cd194cb25703a0a7a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;https://stackoverflow.com/questions/146589/&quot;&gt;POD&lt;/a&gt; (like &lt;code&gt;int&lt;/code&gt; in the above example), no initialization takes place.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/146589/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;POD&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（如&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上述示例中的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），则不会进行初始化。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16e6c04649f4d9ae6d831611c9b9eff3d05641fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; provides no accessible default-constructor, the program does not compile.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有提供可访问的默认构造函数，则该程序不会编译。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eb41e3d981a1357a114e1a3e78f40d975727427d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; denotes an &lt;em&gt;array&lt;/em&gt;, then array-to-pointer decay will kick in, because adding an array and an integer is meaningless (there is no plus operation on arrays), but adding a pointer and an integer makes sense:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示一个&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;array&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，那么数组到指针的衰减将开始，因为添加一个数组和一个整数是没有意义的（在数组上没有加操作），但是添加一个指针和一个整数是有意义的：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d91f0db788d31e3ba270714f7e149455d1be1520" translate="yes" xml:space="preserve">
          <source>If you are done using an anonymous array, you have to release it back to the system:</source>
          <target state="translated">如果你用完了匿名数组,你必须把它放回系统。</target>
        </trans-unit>
        <trans-unit id="e9be23246f4db6859f24f143fdfa68db6666d4e3" translate="yes" xml:space="preserve">
          <source>If you are unfamiliar with the C declarator syntax, the parenthesis in the type &lt;code&gt;int(*)[8]&lt;/code&gt; are essential:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您不熟悉C声明符语法，则&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int(*)[8]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型中的括号&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是必不可少的：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="14c24b9c0b2d0257aaceb7cde0555b7a4f3c1769" translate="yes" xml:space="preserve">
          <source>If you feel something important is missing in this FAQ, write an answer and link it here as an additional part.</source>
          <target state="translated">如果您觉得本常见问题中缺少什么重要的内容,请写出答案,并将其作为补充部分链接到这里。</target>
        </trans-unit>
        <trans-unit id="d5bcb303a25ffde92cc0974fd617bffe13104ab4" translate="yes" xml:space="preserve">
          <source>If, on the other hand, &lt;code&gt;x&lt;/code&gt; denotes a &lt;em&gt;pointer&lt;/em&gt; to the first (or any other) element of an array, then array-to-pointer decay is not necessary, because the pointer on which &lt;code&gt;i&lt;/code&gt; is going to be added already exists:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一方面，如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指向&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组的第一个（或任何其他）元素的指针，则不必进行数组到指针的衰减，因为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要添加&lt;/font&gt;&lt;/font&gt; &lt;code&gt;i&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的指针&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;已经存在：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ec50dff9162ea0c55c63f2ee2fedc58220b5d3c" translate="yes" xml:space="preserve">
          <source>In C++0x, arrays &lt;em&gt;can&lt;/em&gt; be initialized in the member initializer list thanks to &lt;a href=&quot;http://www.youtube.com/watch?v=uEqknlxXJfg&quot;&gt;uniform initialization&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++ 0x中，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于&lt;/font&gt;&lt;a href=&quot;http://www.youtube.com/watch?v=uEqknlxXJfg&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;统一初始化&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在成员初始化器列表中初始化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2c1bdd707612ae097771a2db46f18f20e841ba75" translate="yes" xml:space="preserve">
          <source>In C, anonymous arrays are created via &lt;code&gt;malloc&lt;/code&gt; and friends. In C++, anonymous arrays are created using the &lt;code&gt;new T[size]&lt;/code&gt; syntax which returns a pointer to the first element of an anonymous array:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C语言中，匿名数组是通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;malloc&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和friends &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++中，匿名数组是使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;new T[size]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建的，该&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语法返回一个指向匿名数组第一个元素的指针：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="41b1d1fe662d24559c66cf35d58d5d091bc62661" translate="yes" xml:space="preserve">
          <source>In Windows 7 this compiles and links fine with both MinGW g++ 4.4.1 and
Visual C++ 10.0.</source>
          <target state="translated">在Windows 7中,这款软件在MinGW g++4.4.1和Visual C++10.0中的编译和链接都很好。</target>
        </trans-unit>
        <trans-unit id="437c03d1c28955b95b16ec11169a5605bc02a59a" translate="yes" xml:space="preserve">
          <source>In order to detect this error at run time you can do &amp;hellip;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了在运行时检测到此错误，您可以&amp;hellip;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26eee36cf964126ee4dcb59852fa30dc17bf56fe" translate="yes" xml:space="preserve">
          <source>In that case, the remaining elements are &lt;a href=&quot;https://stackoverflow.com/questions/1613383/&quot;&gt;zero-initialized&lt;/a&gt;. Note that C++ allows an empty array initializer (all elements are zero-initialized), whereas C89 does not (at least one value is required). Also note that array initializers can only be used to &lt;em&gt;initialize&lt;/em&gt; arrays; they cannot later be used in assignments.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，其余元素将被&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1613383/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;零初始化&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，C ++允许使用空数组初始化器（所有元素都初始化为零），而C89不允许（至少需要一个值）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还要注意，数组初始化器只能用于&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始化&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它们以后不能在作业中使用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7d28f9a6d6ed85ab85596615272616028e68b524" translate="yes" xml:space="preserve">
          <source>In the following text, &quot;array&quot; means &quot;C array&quot;, not the class template &lt;code&gt;std::array&lt;/code&gt;. Basic knowledge of the C declarator syntax is assumed. Note that the manual usage of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; as demonstrated below is extremely dangerous in the face of exceptions, but that is the topic of &lt;a href=&quot;https://stackoverflow.com/questions/712639/&quot;&gt;another FAQ&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在以下文本中，&amp;ldquo;数组&amp;rdquo;表示&amp;ldquo; C数组&amp;rdquo;，而不是类模板&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::array&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假定具备C声明符语法的基本知识。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;面对异常，如下&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所述手动使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;new&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;delete&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;极其危险，但这是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/712639/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一个FAQ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的主题&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2a5dcb9a46d4b13c3f0a33e51d890dc93adbc865" translate="yes" xml:space="preserve">
          <source>In this case, the array size is significant. Since writing a function that only accepts arrays of exactly 8 elements is of little use, programmers usually write such functions as templates:</source>
          <target state="translated">在这种情况下,数组的大小是很重要的。由于编写一个只接受恰好是8个元素的数组的函数没有什么用处,所以程序员通常会把这样的函数写成模板。</target>
        </trans-unit>
        <trans-unit id="890a35e657b26ee90956dc55f869c0acaf541ebb" translate="yes" xml:space="preserve">
          <source>In-practice explanation: in &lt;code&gt;main.cpp&lt;/code&gt; the array is treated as a pointer, placed
at the same address as the array. For 32-bit executable this means that the first
&lt;code&gt;int&lt;/code&gt; value in the array, is treated as a pointer. I.e., in &lt;code&gt;main.cpp&lt;/code&gt; the
&lt;code&gt;numbers&lt;/code&gt; variable contains, or appears to contain, &lt;code&gt;(int*)1&lt;/code&gt;. This causes the
program to access memory down at very bottom of the address space, which is
conventionally reserved and trap-causing. Result: you get a crash.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实践中的解释：在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main.cpp&lt;/code&gt; 中,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将数组视为指针，与数组位于同一地址。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于32位可执行文件，这意味着&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将数组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的第一个 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;int&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值视为一个指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即，在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;main.cpp&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;， &lt;/font&gt;&lt;/font&gt; &lt;code&gt;numbers&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量包含或似乎包含&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(int*)1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这导致程序在地址空间的最底端向下访问内存，而该地址空间通常是保留的并导致陷阱。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;结果：您崩溃了。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="070fe92341683cf9d092141bd709fad70875176e" translate="yes" xml:space="preserve">
          <source>In-the-formal explanation: the program has Undefined Behavior (UB), and instead
of crashing it can therefore just hang, or perhaps do nothing, or it
can send threating e-mails to the presidents of the USA, Russia, India,
China and Switzerland, and make Nasal Daemons fly out of your nose.</source>
          <target state="translated">在形式上的解释:程序有Undefined Behavior(UB),因此,它可以因此而直接挂掉,或许什么都不做,也可以向美国、俄罗斯、印度、中国、瑞士等国总统发送威胁性的电子邮件,让鼻涕虫从你的鼻子里飞出来。</target>
        </trans-unit>
        <trans-unit id="c97bad7c68964c91e199c52d4f2f4a2d7be3c3fe" translate="yes" xml:space="preserve">
          <source>Indexing operator</source>
          <target state="translated">索引操作员</target>
        </trans-unit>
        <trans-unit id="608d106aeaf49a5d6d2d18e72fbb2975527e39df" translate="yes" xml:space="preserve">
          <source>Initialization is performed in ascending order. Note that the initial values depend on the element type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始化以升序执行。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，初始值取决于元素类型&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a1ce46f618ab33d9bc54dcc4675dfdfc40bbc7b" translate="yes" xml:space="preserve">
          <source>It is also possible to specify the size and provide a shorter array initializer:</source>
          <target state="translated">也可以指定大小,并提供一个较短的数组初始化器。</target>
        </trans-unit>
        <trans-unit id="3d2fd5d37362f6b75096f1913050f5033ca3aaba" translate="yes" xml:space="preserve">
          <source>M:\count&amp;gt; _</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;M：\ count&amp;gt; _&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cdd64d56a86a26a498d6bbef6d3c1868cc754771" translate="yes" xml:space="preserve">
          <source>M:\count&amp;gt; g++ compile_time_detection.cpp</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;M：\ count&amp;gt; g ++ compile_time_detection.cpp&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf9d1f82d43843cd09374cb46c7a3dcbd8fbc7d5" translate="yes" xml:space="preserve">
          <source>Main pitfall: the C idiom is not typesafe. For example, the code
&amp;hellip;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;主要陷阱：C习惯用法不是类型安全的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，代码...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef5472faf1452242241b190fbf2f97ecd84ba6ea" translate="yes" xml:space="preserve">
          <source>Most programmers are familiar with named multidimensional arrays, but many are unaware of the fact that multidimensional array can also be created anonymously. Multidimensional arrays are often referred to as &quot;arrays of arrays&quot; or &quot;&lt;em&gt;true&lt;/em&gt; multidimensional arrays&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大多数程序员都熟悉命名多维数组，但是许多程序员并不知道多维数组也可以匿名创建的事实。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多维数组通常称为&amp;ldquo;数组数组&amp;rdquo;或&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;真正的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多维数组&amp;rdquo;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="00762e90f2d0e1fc656e0809cb403c7716fbb355" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays</source>
          <target state="translated">多维数组</target>
        </trans-unit>
        <trans-unit id="ad847916fde2cd7cb8d9547c74c3fccb05986bb9" translate="yes" xml:space="preserve">
          <source>Named arrays of pointers</source>
          <target state="translated">命名的指针数组</target>
        </trans-unit>
        <trans-unit id="5d38b7a1ca47e08bdd5d13e7b55118d97017de16" translate="yes" xml:space="preserve">
          <source>Named multidimensional arrays</source>
          <target state="translated">已命名的多维数组</target>
        </trans-unit>
        <trans-unit id="eee6419b689f5d4600b5eb44117945feff22b904" translate="yes" xml:space="preserve">
          <source>Note how the pointer to the first element only points to a single integer (depicted as a small box), whereas the pointer to the entire array points to an array of 8 integers (depicted as a large box).</source>
          <target state="translated">请注意,指向第一个元素的指针只指向一个整数组(用小方框表示),而指向整个数组的指针则指向8个整数组(用大方框表示)。</target>
        </trans-unit>
        <trans-unit id="23ba020b1bef6697ee28252a1170fead955b8b56" translate="yes" xml:space="preserve">
          <source>Note that 2D grids such as the above are merely helpful visualizations. From the point of view of C++, memory is a &quot;flat&quot; sequence of bytes. The elements of a multidimensional array are stored in row-major order. That is, &lt;code&gt;connect_four[0][6]&lt;/code&gt; and &lt;code&gt;connect_four[1][0]&lt;/code&gt; are neighbors in memory. In fact, &lt;code&gt;connect_four[0][7]&lt;/code&gt; and &lt;code&gt;connect_four[1][0]&lt;/code&gt; denote the same element! This means that you can take multi-dimensional arrays and treat them as large, one-dimensional arrays:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，诸如上述的2D网格仅仅是有用的可视化。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从C ++的角度来看，内存是字节的&amp;ldquo;平坦&amp;rdquo;序列。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;多维数组的元素以行优先顺序存储。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也就是说，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;connect_four[0][6]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;connect_four[1][0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是内存中的邻居。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;connect_four[0][7]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;connect_four[1][0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示相同的元素！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这意味着您可以采用多维数组并将其视为大型的一维数组：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7186b877025b5d08bccafccf8a0b9683541aa2f2" translate="yes" xml:space="preserve">
          <source>Note that in the depicted case, &lt;code&gt;x&lt;/code&gt; is a pointer &lt;em&gt;variable&lt;/em&gt; (discernible by the small box next to &lt;code&gt;x&lt;/code&gt;), but it could just as well be the result of a function returning a pointer (or any other expression of type &lt;code&gt;T*&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，在所示的情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个指针&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（可以通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;旁边的小框来区分&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），但是它也可能是函数返回指针（或任何其他&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型的表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）的结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e01e8bdf0e314ca975d17798f6f9fac1c741d43" translate="yes" xml:space="preserve">
          <source>Note that it is illegal to provide &lt;code&gt;&amp;amp;x[n]&lt;/code&gt; as the second argument since this is equivalent to &lt;code&gt;&amp;amp;*(x+n)&lt;/code&gt;, and the sub-expression &lt;code&gt;*(x+n)&lt;/code&gt; technically invokes &lt;a href=&quot;https://stackoverflow.com/questions/3144904/&quot;&gt;undefined behavior&lt;/a&gt; in C++ (but not in C99).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，提供&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;x[n]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为第二个参数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是非法的，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为它等效于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;*(x+n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且子表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(x+n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;技术上&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C ++中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3144904/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;未定义的行为&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（但在C99中不是） ）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4a783e015ec501739631e705c9f21aff6b055fac" translate="yes" xml:space="preserve">
          <source>Note that the array itself is still allocated as a single block in memory.</source>
          <target state="translated">注意,数组本身在内存中仍然是作为单个块分配的。</target>
        </trans-unit>
        <trans-unit id="554d5b1a6dcb70e7921afec83e4b4971c2df9586" translate="yes" xml:space="preserve">
          <source>Note that the size is part of the type, that is, array types of different size are incompatible types that have absolutely nothing to do with each other. &lt;code&gt;sizeof(T[n])&lt;/code&gt; is equivalent to &lt;code&gt;n * sizeof(T)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，大小是类型的一部分，也就是说，大小不同的数组类型是不兼容的类型，它们彼此之间完全没有关系。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof(T[n])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等效于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n * sizeof(T)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4de64b4a294e1e1f832bbe75edd6afa90d315d2" translate="yes" xml:space="preserve">
          <source>Note that there is &lt;em&gt;no&lt;/em&gt; array-to-pointer decay going on here. Although evaluating &lt;code&gt;new int[size]&lt;/code&gt; does in fact create an &lt;em&gt;array&lt;/em&gt; of integers, the result of the expression &lt;code&gt;new int[size]&lt;/code&gt; is &lt;em&gt;already&lt;/em&gt; a pointer to a single integer (the first element), &lt;em&gt;not&lt;/em&gt; an array of integers or a pointer to an array of integers of unknown size. That would be impossible, because the static type system requires array sizes to be compile-time constants. (Hence, I did not annotate the anonymous array with static type information in the picture.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意，这里&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有发生&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组到指针的衰减。尽管评估&lt;/font&gt;&lt;/font&gt; &lt;code&gt;new int[size]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上确实创建了一个&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;整数&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;new int[size]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的结果&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;已经&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是指向单个整数（第一个元素）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的指针&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而不是&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;整数数组或指向a的指针。未知大小的整数数组。这将是不可能的，因为静态类型系统要求数组大小为编译时常量。 （因此，我没有在图片中用静态类型信息注释匿名数组。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa3802c18f9d7df661ece56023d81fd4a5c43ad8" translate="yes" xml:space="preserve">
          <source>Note that this generates a view of the original multidimensional array. If you need a copy instead, you must create extra arrays and copy the data yourself:</source>
          <target state="translated">注意,这将生成一个原始多维数组的视图。如果你需要一个副本,你必须创建额外的数组,并自己复制数据。</target>
        </trans-unit>
        <trans-unit id="731accb3850c583ab5dab43550cbdd5a71aa446b" translate="yes" xml:space="preserve">
          <source>Note that you can only call such a function template with an actual array of integers, not with a pointer to an integer. The size of the array is automatically inferred, and for every size &lt;code&gt;n&lt;/code&gt;, a different function is instantiated from the template. You can also write &lt;a href=&quot;https://stackoverflow.com/questions/4759078/&quot;&gt;quite useful&lt;/a&gt; function templates that abstract from both the element type and from the size.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，您只能使用实际的整数数组而不是使用指向整数的指针来调用此类函数模板。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组的大小是自动推断的，对于每个大小&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，都会从模板实例化一个不同的函数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您还可以编写&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4759078/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非常有用的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数模板，这些模板可以从元素类型和大小中抽象出来。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="85d63e980e7422c247f8647e79d77a52c6d97e7f" translate="yes" xml:space="preserve">
          <source>OK, you&amp;rsquo;ve been told, or have found out yourself, that globals (namespace
scope variables that can be accessed outside the translation unit) are
Evil&amp;trade;. But did you know how truly Evil&amp;trade; they are? Consider the
program below, consisting of two files [main.cpp] and [numbers.cpp]:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好吧，您已经被告知或发现自己，全局变量（可以在翻译单元外部访问的命名空间范围变量）是Evil&amp;trade;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是您知道它们到底有多邪恶吗？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;考虑下面的程序，它由两个文件[main.cpp]和[numbers.cpp]组成：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="53bde04906550009556f993b7806f8d76b8c6d5f" translate="yes" xml:space="preserve">
          <source>Obviously, anonymous arrays require more memory than named arrays due to the extra pointer that must be stored separately. (There is also some additional overhead on the free store.)</source>
          <target state="translated">很明显,匿名数组比命名数组需要更多的内存,因为必须单独存储额外的指针。(在自由存储上也会有一些额外的开销)。</target>
        </trans-unit>
        <trans-unit id="63fb417f29bfd9f2405ad6c79a04190fdd2d712c" translate="yes" xml:space="preserve">
          <source>On the first line, the compiler detects an assignment from a pointer to a pointer, which trivially succeeds. On the second line, it detects an assignment from an &lt;em&gt;array&lt;/em&gt; to a pointer. Since this is meaningless (but &lt;em&gt;pointer&lt;/em&gt; to pointer assignment makes sense), array-to-pointer decay kicks in as usual.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第一行，编译器检测到从一个指针到一个指针的分配，这很容易成功。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第二行，它检测从&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到指针&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的分配&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于这是没有意义的（但&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指向&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指针分配的指针是有意义的），所以数组到指针的衰减照常开始。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c3b30f736895ab3c14d15df82c8709f3aa1fb3ea" translate="yes" xml:space="preserve">
          <source>One can always write the more verbose</source>
          <target state="translated">可以写出更多的文字</target>
        </trans-unit>
        <trans-unit id="c4685ee8261138ace07d8fb78c91b3a94b27dd88" translate="yes" xml:space="preserve">
          <source>One important context in which an array does &lt;em&gt;not&lt;/em&gt; decay into a pointer to its first element is when the &lt;code&gt;&amp;amp;&lt;/code&gt; operator is applied to it. In that case, the &lt;code&gt;&amp;amp;&lt;/code&gt; operator yields a pointer to the &lt;em&gt;entire&lt;/em&gt; array, not just a pointer to its first element. Although in that case the &lt;em&gt;values&lt;/em&gt; (the addresses) are the same, a pointer to the first element of an array and a pointer to the entire array are completely distinct types:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在其中一个阵列并一个重要方面&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当衰变到一个指向它的第一个元素是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符应用于它。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符会产生指向&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;整个&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组的指针，而不仅仅是指向其第一个元素的指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尽管在这种情况下，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（地址）相同，但是指向数组第一个元素的指针和指向整个数组的指针是完全不同的类型：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="41e3330ec09c505432c9bd89998da5f0ce62c087" translate="yes" xml:space="preserve">
          <source>Otherwise, the default-constructor of &lt;code&gt;T&lt;/code&gt; initializes all the elements.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;否则，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的默认构造函数将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始化所有元素。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1dd1f36b3d11a080ec32ab7967d3c72b1acb694" translate="yes" xml:space="preserve">
          <source>Parameter passing</source>
          <target state="translated">参数传递</target>
        </trans-unit>
        <trans-unit id="dd57df0504585da5013127cd2c481cb9a4d98a15" translate="yes" xml:space="preserve">
          <source>Pass by pointer</source>
          <target state="translated">指针传递</target>
        </trans-unit>
        <trans-unit id="a428f2745394276b3ef22fe8ce93840f03d517fe" translate="yes" xml:space="preserve">
          <source>Pass by reference</source>
          <target state="translated">参考资料</target>
        </trans-unit>
        <trans-unit id="c5015408faa4e590c7a33664c84fb50fb239cff6" translate="yes" xml:space="preserve">
          <source>Please contact the application's support team for more information.</source>
          <target state="translated">请联系申请者的支持团队了解更多信息。</target>
        </trans-unit>
        <trans-unit id="886d0e716745d04046260e2fd4e01fbcdb9fbe82" translate="yes" xml:space="preserve">
          <source>Pointer arithmetic</source>
          <target state="translated">指针算术</target>
        </trans-unit>
        <trans-unit id="27319e98c440e9f7e0dae34adba8c3b67a414d93" translate="yes" xml:space="preserve">
          <source>Programmers often confuse multidimensional arrays with arrays of pointers.</source>
          <target state="translated">程序员经常将多维数组与指针数组混淆。</target>
        </trans-unit>
        <trans-unit id="0d5fda95e3940bc09dc1ccc22666813c0b54f73d" translate="yes" xml:space="preserve">
          <source>Ranges</source>
          <target state="translated">Ranges</target>
        </trans-unit>
        <trans-unit id="7976ce91c52fe87631d0a3d9dd7e9ac38cb29122" translate="yes" xml:space="preserve">
          <source>Related: macros do not respect scopes, so to avoid name collisions it can be a
good idea to use a name prefix, e.g. &lt;code&gt;MYLIB_STATIC_N_ITEMS&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相关：宏不遵守范围，因此为了避免名称冲突，最好使用名称前缀，例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;MYLIB_STATIC_N_ITEMS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="845580eed354c30eedf70a4e23705439efbc345d" translate="yes" xml:space="preserve">
          <source>Since an &lt;code&gt;array&lt;/code&gt; decays to pointer to first element where needed, the
expression &lt;code&gt;sizeof(a)/sizeof(a[0])&lt;/code&gt; can also be written as
&lt;code&gt;sizeof(a)/sizeof(*a)&lt;/code&gt;. It means the same, and no matter how it&amp;rsquo;s
written it is the &lt;strong&gt;C idiom&lt;/strong&gt; for finding the number elements of array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;array&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在需要时会衰减到指向第一个元素的指针，因此表达式&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof(a)/sizeof(a[0])&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也可以写成 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof(a)/sizeof(*a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它的含义相同，无论如何编写，都是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;查找数组的数字元素&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C语言&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdd3bf58590a288a7255f35b31aa883fdb12ea5a" translate="yes" xml:space="preserve">
          <source>Since arrays themselves cannot be passed by value, usually a pointer to their first element is passed by value instead. This is often called &quot;pass by pointer&quot;. Since the size of the array is not retrievable via that pointer, you have to pass a second parameter indicating the size of the array (the classic C solution) or a second pointer pointing after the last element of the array (the C++ iterator solution):</source>
          <target state="translated">因为数组本身不能通过值传递,所以通常情况下,通常会用一个指向第一个元素的指针来代替值传递。这通常被称为 &quot;通过指针传递&quot;。由于数组的大小不能通过这个指针来检索,所以你必须传递一个表示数组大小的第二个参数(经典的C语言解决方案),或者是指向数组最后一个元素之后的第二个指针(C++迭代器解决方案)。</target>
        </trans-unit>
        <trans-unit id="b44febfd34ec6b3b83a2f3ed4ef55e29031984dc" translate="yes" xml:space="preserve">
          <source>Since each line is allocated individually now, viewing 2D arrays as 1D arrays does not work anymore.</source>
          <target state="translated">因为现在每一行都是单独分配的,所以将二维数组看成一维数组就不行了。</target>
        </trans-unit>
        <trans-unit id="2f0cf1c959967562a9ea9857497386e60eb8610f" translate="yes" xml:space="preserve">
          <source>Since in this case the number of elements in the array initializer is equal to the size of the array, specifying the size manually is redundant. It can automatically be deduced by the compiler:</source>
          <target state="translated">因为在这种情况下,数组初始化器中的元素数量等于数组的大小,所以手动指定大小是多余的。它可以由编译器自动推导出来。</target>
        </trans-unit>
        <trans-unit id="76da052225a0e136a9e4e987d8dabb6143458717" translate="yes" xml:space="preserve">
          <source>Since the syntax &lt;code&gt;*(x+i)&lt;/code&gt; is a bit clumsy, C++ provides the alternative syntax &lt;code&gt;x[i]&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于语法&lt;/font&gt;&lt;/font&gt; &lt;code&gt;*(x+i)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有点笨拙，因此C ++提供了替代语法&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x[i]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e02a2730b214f5417ece2b04ba144915d409379b" translate="yes" xml:space="preserve">
          <source>Since the types don't match, the program crashes when you run it.</source>
          <target state="translated">由于类型不匹配,当你运行程序时,程序会崩溃。</target>
        </trans-unit>
        <trans-unit id="8441d3938f1ecea2e057daaaa95958eeb1304ca0" translate="yes" xml:space="preserve">
          <source>Static POD arrays are initialized &lt;em&gt;exactly once&lt;/em&gt;, and the initial values are &lt;em&gt;typically&lt;/em&gt; baked into the executable, in which case there is no initialization cost at runtime. This is not always the most space-efficient solution, however, and it is not required by the standard.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;静态POD数组仅初始化&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一次&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将初始值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;烘焙到可执行文件中，在这种情况下，运行时没有初始化成本。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，这并不总是最节省空间的解决方案，并且不是标准要求的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5fc6d78bfd1b3cbec3f64c6df4199384d6e606cb" translate="yes" xml:space="preserve">
          <source>Static arrays</source>
          <target state="translated">静态阵列</target>
        </trans-unit>
        <trans-unit id="a0600c54cb97b541cf9c0e780ec5c24bde3f13bd" translate="yes" xml:space="preserve">
          <source>Static arrays (arrays living &quot;in the data segment&quot;) are local array variables defined with the &lt;code&gt;static&lt;/code&gt; keyword and array variables at namespace scope (&quot;global variables&quot;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;静态数组（存在于&amp;ldquo;数据段中&amp;rdquo;的数组）是使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;static&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关键字&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;定义的局部数组变量，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以及在命名空间范围内的数组变量（&amp;ldquo;全局变量&amp;rdquo;）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="774c4e05a928152894fd8eee023448f0bd571034" translate="yes" xml:space="preserve">
          <source>Static arrays without an array initializer are zero-initialized prior to any further potential initialization.</source>
          <target state="translated">没有数组初始化器的静态数组在进一步的潜在初始化之前,会被零初始化。</target>
        </trans-unit>
        <trans-unit id="d719c3b1e68cccdda79bb9c4f8e7142667d5e8af" translate="yes" xml:space="preserve">
          <source>Static non-POD arrays are initialized the &lt;em&gt;first time&lt;/em&gt; the flow of control passes through their definition. In the case of local static arrays, that may never happen if the function is never called.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;静态非POD数组在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;控制流&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一次&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过其定义&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行初始化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于局部静态数组，如果从未调用函数，则可能永远不会发生。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dc398be3b099870d82f0233260c92cd7fe247e52" translate="yes" xml:space="preserve">
          <source>The compiler rewrites &lt;code&gt;int const a[7]&lt;/code&gt; to just &lt;code&gt;int const a[]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译器将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int const a[7]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重写&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int const a[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b4182f7f5ae56ba8db00f357997716a8374d56d" translate="yes" xml:space="preserve">
          <source>The compiler rewrites &lt;code&gt;int const a[]&lt;/code&gt; to &lt;code&gt;int const* a&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译器将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int const a[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重写&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;int const* a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="686df3b8d217ab698b2df0c1fd71552a18fd8b54" translate="yes" xml:space="preserve">
          <source>The compiler will silently generate a pointer to the first element of an array whenever it is deemed useful, that is, whenever an operation would fail on an array but succeed on a pointer. This conversion from array to pointer is trivial, since the resulting pointer &lt;em&gt;value&lt;/em&gt; is simply the address of the array. Note that the pointer is &lt;em&gt;not&lt;/em&gt; stored as part of the array itself (or anywhere else in memory). &lt;strong&gt;An array is not a pointer.&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只要认为有用，即每当操作将在数组上失败但在指针上成功时，编译器就会自动生成指向数组第一个元素的指针。从数组到指针的这种转换是微不足道的，因为所得的指针&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是数组的地址。请注意，指针&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并不&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;存储为数组本身的一部分（或存储在内存中的其他任何位置）。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数组不是指针。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5270e2af134e0442ff7692e26dd083472328919" translate="yes" xml:space="preserve">
          <source>The compilers are fully within their rights to not diagnose this error,
because C++11 &amp;sect;3.5/10 says, about the requirement of compatible types
for the declarations,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于C ++ 11&amp;sect;3.5/ 10指出，对于声明的兼容类型的要求，编译器完全有权不诊断此错误。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b3c4bbf6e6b3262be7b6e0ac48d15ee8ea7abffa" translate="yes" xml:space="preserve">
          <source>The definition of the indexing operator leads to the following interesting equivalence:</source>
          <target state="translated">从分度算子的定义中可以得出以下有趣的等价关系。</target>
        </trans-unit>
        <trans-unit id="8f0c75d53a53f4088924e02576b1ea2942b86f60" translate="yes" xml:space="preserve">
          <source>The following ASCII art depicts the memory layout if the size is computed as 8 at runtime:</source>
          <target state="translated">下面的ASCII艺术描述了在运行时,如果大小被计算为8的内存布局。</target>
        </trans-unit>
        <trans-unit id="554e227d03dda0191d05be5936967bfe2f42dec4" translate="yes" xml:space="preserve">
          <source>The following ASCII art explains this distinction:</source>
          <target state="translated">下面的ASCII艺术解释了这种区别。</target>
        </trans-unit>
        <trans-unit id="b9ad5ce162146034fe3468d816b1762bdc3db4ef" translate="yes" xml:space="preserve">
          <source>The only &quot;connection&quot; between &lt;code&gt;T[n]&lt;/code&gt; and &lt;code&gt;T[m]&lt;/code&gt; is that both types can implicitly be &lt;em&gt;converted&lt;/em&gt; to &lt;code&gt;T*&lt;/code&gt;, and the result of this conversion is a pointer to the first element of the array. That is, anywhere a &lt;code&gt;T*&lt;/code&gt; is required, you can provide a &lt;code&gt;T[n]&lt;/code&gt;, and the compiler will silently provide that pointer:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;T[n]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T[m]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之间唯一的&amp;ldquo;连接&amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是两种类型都可以隐式&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转换&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且转换的结果是指向数组第一个元素的指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也就是说，在需要&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何地方&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您都可以提供&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T[n]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，编译器将以静默方式提供该指针：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4900a0a1149898ae253be24f75d402af0b30da85" translate="yes" xml:space="preserve">
          <source>The pitfall: as of July 2015 the above compiles with MinGW-64 5.1.0 with
&lt;code&gt;-pedantic-errors&lt;/code&gt;, and,
testing with the online compilers at &lt;a href=&quot;http://gcc.godbolt.org/&quot;&gt;gcc.godbolt.org/&lt;/a&gt;, also with clang 3.0
and clang 3.2, but not with clang 3.3, 3.4.1, 3.5.0, 3.5.1, 3.6 (rc1) or
3.7 (experimental). And important for the Windows platform, it does not compile
with Visual C++ 2015. The reason is a C++11/C++14 statement about use of
references in &lt;code&gt;constexpr&lt;/code&gt; expressions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;陷阱：截至2015年7月，上述代码可使用带有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-pedantic-errors&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; MinGW-64 5.1.0进行编译&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;gcc.godbolt.org/&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的在线编译器进行&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://gcc.godbolt.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;测试&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，也可以使用clang 3.0和clang 3.2，但不能使用clang 3.3、3.4.1、3.5.0、3.5.1、3.6（rc1）或3.7（实验性）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于Windows平台而言很重要，它不能与Visual C ++ 2015一起编译。原因是有关在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表达式中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用引用的C ++ 11 / C ++ 14语句&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f45126b06ef23df5ffbfdd6efaae59b432607f7f" translate="yes" xml:space="preserve">
          <source>The runtime error detection is better than no detection, but it wastes a little
processor time, and perhaps much more programmer time. Better with detection at
compile time! And if you're happy to not support arrays of local types with C++98,
then you can do that:</source>
          <target state="translated">运行时的错误检测比不检测要好,但它浪费了一点处理器时间,可能会浪费更多的程序员时间。有了编译时的检测就更好了! 而如果你愿意用C++98不支持本地类型的数组,那么你也可以这样做。</target>
        </trans-unit>
        <trans-unit id="a649050a2be06c8e39adac5d67332961492c1c85" translate="yes" xml:space="preserve">
          <source>The same paragraph details the variation that is allowed:</source>
          <target state="translated">同款详述了允许的变化。</target>
        </trans-unit>
        <trans-unit id="8fdd2f0bef4d6e460fb6f1f2ec6ebe3c770034da" translate="yes" xml:space="preserve">
          <source>The same situation arises in classes and is maybe more obvious. A pointer to an object and a pointer to its first data member have the same &lt;em&gt;value&lt;/em&gt; (the same address), yet they are completely distinct types.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在课堂上也会出现同样的情况，并且可能更加明显。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指向对象的指针和指向其第一个数据成员的指针具有相同的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（相同的地址），但是它们是完全不同的类型。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7540274c5dbcf87fc080dd7cc42e01b3035b4fe" translate="yes" xml:space="preserve">
          <source>This FAQ is split into five parts:</source>
          <target state="translated">本常见问题分为五个部分。</target>
        </trans-unit>
        <trans-unit id="75cbb85f170e4859016dc81df1a331401263eebc" translate="yes" xml:space="preserve">
          <source>This allowed variation does not include declaring a name as an array in one
translation unit, and as a pointer in another translation unit.</source>
          <target state="translated">这种允许的变化不包括在一个翻译单元中以数组的形式声明名称,而在另一个翻译单元中以指针的形式声明名称。</target>
        </trans-unit>
        <trans-unit id="c3cbef9e71473e0b651623890cdcceb97160ae6b" translate="yes" xml:space="preserve">
          <source>This application has requested the Runtime to terminate it in an unusual way.</source>
          <target state="translated">该应用程序要求以不寻常的方式终止Runtime。</target>
        </trans-unit>
        <trans-unit id="77a8211a815c79e630f954b14acfcbbff4945d7c" translate="yes" xml:space="preserve">
          <source>This conversion is known as &quot;array-to-pointer decay&quot;, and it is a major source of confusion. The size of the array is lost in this process, since it is no longer part of the type (&lt;code&gt;T*&lt;/code&gt;). Pro: Forgetting the size of an array on the type level allows a pointer to point to the first element of an array of &lt;em&gt;any&lt;/em&gt; size. Con: Given a pointer to the first (or any other) element of an array, there is no way to detect how large that array is or where exactly the pointer points to relative to the bounds of the array. &lt;a href=&quot;https://stackoverflow.com/questions/4261074/&quot;&gt;Pointers are extremely stupid&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这种转换称为&amp;ldquo;数组到指针的衰减&amp;rdquo;，它是造成混淆的主要原因。在此过程中，数组的大小丢失了，因为它不再是类型（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）的一部分。优点：在类型级别上忘记数组的大小可以使指针指向&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大小&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的数组的第一个元素&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。缺点：给定指向数组第一个（或任何其他）元素的指针，无法检测到数组的大小或指针相对于数组边界的确切位置。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/4261074/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指针非常愚蠢&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4348c73ecd32e24327bad7c0bda07f2fded0659" translate="yes" xml:space="preserve">
          <source>This is how a named multidimensional array looks like in memory:</source>
          <target state="translated">这就是一个命名的多维数组在内存中的样子。</target>
        </trans-unit>
        <trans-unit id="fdfc624bf57b66e2918a46588b9dcca5300477c3" translate="yes" xml:space="preserve">
          <source>This is how an anonymous multidimensional array looks like in memory:</source>
          <target state="translated">这就是内存中的匿名多维数组的样子。</target>
        </trans-unit>
        <trans-unit id="ede415bd1cfcb19839ab828b1f1b520817e906b1" translate="yes" xml:space="preserve">
          <source>This is more flexible than what true array assignment could provide because it is possible to copy slices of larger arrays into smaller arrays.
&lt;code&gt;std::copy&lt;/code&gt; is usually specialized for primitive types to give maximum performance. It is unlikely that &lt;code&gt;std::memcpy&lt;/code&gt; performs better. If in doubt, measure.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这比真正的数组分配可以提供的灵活性更大，因为可以将较大数组的切片复制到较小数组中。 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::copy&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常专用于基本类型，以提供最佳性能。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;std::memcpy&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不太可能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表现更好。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如有疑问，请测量。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a81aa85761c51a0de5661013b69548fe3e215386" translate="yes" xml:space="preserve">
          <source>This is the only solution that works with element types that have no default constructor.</source>
          <target state="translated">这是唯一的解决方案,适用于没有默认构造函数的元素类型。</target>
        </trans-unit>
        <trans-unit id="f883fd467cbb1529780034400816e1198b388651" translate="yes" xml:space="preserve">
          <source>To deal with collections that can be non-arrays one needs the overloadability of an
&lt;code&gt;n_items&lt;/code&gt; function, but also, for compile time use one needs a compile time
representation of the array size. And the classic C++03 solution, which works fine
also in C++11 and C++14, is to let the function report its result not as a value
but via its function result &lt;em&gt;type&lt;/em&gt;. For example like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了处理可能是非数组的集合，需要&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n_items&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的可重载 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;性，但是，对于编译时的使用，则需要数组大小的编译时表示。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而经典的C ++ 03解决方案（该函数在C ++ 11和C ++ 14中也能正常工作）是让该函数不是通过值报告其结果，而是通过其函数结果&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型来报告&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如这样：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="86ccc751b475ca0db70475e824206e924ea35910" translate="yes" xml:space="preserve">
          <source>Unfortunately, you can also provide a size in an array parameter which is silently ignored by the compiler. That is, the following three signatures are exactly equivalent, as indicated by the compiler errors:</source>
          <target state="translated">不幸的是,你也可以在数组参数中提供一个大小,而这个参数会被编译器默默地忽略。也就是说,下面这三个签名完全等同于编译器的错误表示。</target>
        </trans-unit>
        <trans-unit id="987ac6859eb610ba381637e374a761e25c6a0958" translate="yes" xml:space="preserve">
          <source>When using named multidimensional arrays, &lt;em&gt;all&lt;/em&gt; dimensions must be known at compile time:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用命名多维数组时，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须在编译时知道&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;维：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="037941813c24acca926890ecb0bb3d7c1d72ad7b" translate="yes" xml:space="preserve">
          <source>With C++11 and later it's natural, but as you'll see dangerous!, to
replace the C++03 function</source>
          <target state="translated">在C++11和更高的版本中,替换C++03函数是很自然的,但你会看到很危险的!在C++11和更高的版本中,替换C++03函数</target>
        </trans-unit>
        <trans-unit id="89f756335068da1d48636a9fe82e0a3f5bd23361" translate="yes" xml:space="preserve">
          <source>With C++11 you can use this also for arrays of local type, and it's the type safe
&lt;strong&gt;C++ idiom&lt;/strong&gt; for finding the number of elements of an array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用C ++ 11，您还可以将其用于局部类型的数组，这是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用于查找数组元素数量&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的类型安全的 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++习惯用法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18a241c5629454bfac48aee554b037322204406c" translate="yes" xml:space="preserve">
          <source>With anonymous multidimensional arrays, all dimensions &lt;em&gt;except the first&lt;/em&gt; must be known at compile time:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于匿名多维数组，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须在编译时知道&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除第一个&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;维&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以外的&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有维&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0e6bf7cf1415d98e09ee516a0a8f2f1e3d5ef8f" translate="yes" xml:space="preserve">
          <source>With deep C experience it&amp;rsquo;s natural to write &amp;hellip;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有深厚的C经验，自然会写&amp;hellip;&amp;hellip;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0903eff36ec8b3650ef143d2b41f698fea3c7cd9" translate="yes" xml:space="preserve">
          <source>You can overcome the restriction of fixed width by introducing another level of indirection.</source>
          <target state="translated">你可以克服固定宽度的限制,通过引入另一个层次的隐约化来实现。</target>
        </trans-unit>
        <trans-unit id="9cbd8f05852ef038c494a761f689310e77a9157b" translate="yes" xml:space="preserve">
          <source>You can think of the compiler as rewriting &lt;code&gt;T p[]&lt;/code&gt; to &lt;code&gt;T *p&lt;/code&gt;&lt;strong&gt;in the context of parameter lists only&lt;/strong&gt;. This special rule is partly responsible for the whole confusion about arrays and pointers. In every other context, declaring something as an array or as a pointer makes a &lt;em&gt;huge&lt;/em&gt; difference.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以认为编译器&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅在参数列表的上下文&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T p[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重写&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;T *p&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此特殊规则部分负责有关数组和指针的整个混乱。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在其他所有上下文中，将某物声明为数组或指针都会产生&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;巨大的&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;差异。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1aece31962ca91ece9ad614074408dff8ca56f74" translate="yes" xml:space="preserve">
          <source>You must release each anonymous array exactly once and then never touch it again afterwards. Not releasing it at all results in a memory leak (or more generally, depending on the element type, a resource leak), and trying to release it multiple times results in undefined behavior. Using the non-array form &lt;code&gt;delete&lt;/code&gt; (or &lt;code&gt;free&lt;/code&gt;) instead of &lt;code&gt;delete[]&lt;/code&gt; to release the array is also &lt;a href=&quot;https://stackoverflow.com/questions/1612031/&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您必须只释放一次每个匿名数组，然后再也不要触摸它。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全不释放它会导致内存泄漏（或更普遍地，取决于元素类型，是资源泄漏），而尝试多次释放它会导致未定义的行为。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用非数组形式的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;delete&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;free&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）代替&lt;/font&gt;&lt;/font&gt; &lt;code&gt;delete[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;释放数组也是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1612031/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;未定义的行为&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7cf4dca388e375295b617def54235d06f1f18486" translate="yes" xml:space="preserve">
          <source>an &lt;em&gt;id-expression&lt;/em&gt; that refers to a variable or data member of reference type
  unless the reference has a preceding initialization and either</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引用引用类型的变量或数据成员&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;id表达式&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，除非引用具有先前的初始化且&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ee5a0cb7c4a9d8e5aaef6186e3dca85b7a1c4c63" translate="yes" xml:space="preserve">
          <source>array creation and initialization</source>
          <target state="translated">阵列的创建和初始化</target>
        </trans-unit>
        <trans-unit id="6915828ba027c236180d6e8c4ba69d8413c5d95d" translate="yes" xml:space="preserve">
          <source>arrays on the type level and accessing elements</source>
          <target state="translated">类型层上的数组,并访问元素</target>
        </trans-unit>
        <trans-unit id="aed12379aa394fd233ce8de1dde42fadfbb8dae3" translate="yes" xml:space="preserve">
          <source>assignment and parameter passing</source>
          <target state="translated">分配和参数传递</target>
        </trans-unit>
        <trans-unit id="5e37194a585e4aee6d98b0399a5f22fd2cc761e0" translate="yes" xml:space="preserve">
          <source>common pitfalls when using arrays</source>
          <target state="translated">使用数组时的常见误区</target>
        </trans-unit>
        <trans-unit id="69b28d8d2e333e97a73be6ac4484ceb918b4ce92" translate="yes" xml:space="preserve">
          <source>compile_time_detection.cpp: In function 'void display(const int*)':</source>
          <target state="translated">compile_time_detection.cpp:在函数'void display(const int*)'中。</target>
        </trans-unit>
        <trans-unit id="ba91b6f0adec5d5575c2f50a5f21d1e358484f3c" translate="yes" xml:space="preserve">
          <source>compile_time_detection.cpp:14: error: no matching function for call to 'n_items(const int*&amp;amp;)'</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;compile_time_detection.cpp：14：错误：没有匹配的函数可以调用'n_items（const int *＆）'&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c4d482013cc4cc18e80a64e5984427c90c12ed9" translate="yes" xml:space="preserve">
          <source>it is a non-static data member of an object whose lifetime began within
  the evaluation of e;</source>
          <target state="translated">它是一个对象的非静态数据成员,其生命周期开始于e的评价中。</target>
        </trans-unit>
        <trans-unit id="6bb2ba899277df8e9c8abaec677046b9e7febe4c" translate="yes" xml:space="preserve">
          <source>it is initialized with a constant expression or</source>
          <target state="translated">用常量表达式初始化或</target>
        </trans-unit>
        <trans-unit id="aa0a88b7d54288b7f66de4f7d51b7f248e1c3534" translate="yes" xml:space="preserve">
          <source>multidimensional arrays and arrays of pointers</source>
          <target state="translated">多维数组和指针数组</target>
        </trans-unit>
        <trans-unit id="8b843815899353680e28463b8efa687d68cc8a4f" translate="yes" xml:space="preserve">
          <source>passes a pointer to &lt;code&gt;N_ITEMS&lt;/code&gt;, and therefore most likely produces a wrong
result. Compiled as a 32-bit executable in Windows 7 it produces &amp;hellip;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将指针传递给&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N_ITEMS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此很可能产生错误的结果。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在Windows 7中被编译为32位可执行文件，它产生&amp;hellip;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c30d6576bbcad8a1d310c146ea6af4cf8cc8fd26" translate="yes" xml:space="preserve">
          <source>where the significant change is the use of &lt;code&gt;constexpr&lt;/code&gt;, which allows
this function to produce a &lt;strong&gt;compile time constant&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重大改变是使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它使此函数可以产生&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译时间常数&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
