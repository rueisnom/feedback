<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/610245">
    <body>
      <group id="610245">
        <trans-unit id="81a4752786ca04ed1a7662da3ad6fd89d03fdd33" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;Can I just stick &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; in front of any name? I don't want to worry about the context in which they appear...&lt;/em&gt;&quot; - &lt;code&gt;Some C++ Developer&lt;/code&gt;</source>
          <target state="translated">&quot; &lt;em&gt;&amp;iquest;Puedo pegar el &lt;code&gt;typename&lt;/code&gt; y la &lt;code&gt;template&lt;/code&gt; delante de cualquier nombre? No quiero preocuparme por el contexto en el que aparecen ...&lt;/em&gt; &quot; - &lt;code&gt;Some C++ Developer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da314107a76c971fe9203b881ca2d5dc651b90a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; however, is different in this regard, since there's no way of coming to a conclusion such as; &lt;em&gt;&quot;oh, this is a template, then this other thing must also be a template&quot;&lt;/em&gt;. This means that we apply &lt;code&gt;template&lt;/code&gt; directly in front of any &lt;em&gt;name&lt;/em&gt; that we'd like to treat as such.</source>
          <target state="translated">Sin embargo, la &lt;code&gt;template&lt;/code&gt; es diferente a este respecto, ya que no hay forma de llegar a una conclusi&amp;oacute;n como; &lt;em&gt;&quot;oh, esta es una plantilla, entonces esta otra cosa tambi&amp;eacute;n debe ser una plantilla&quot;&lt;/em&gt; . Esto significa que aplicamos la &lt;code&gt;template&lt;/code&gt; directamente delante de cualquier &lt;em&gt;nombre&lt;/em&gt; que nos gustar&amp;iacute;a tratar como tal.</target>
        </trans-unit>
        <trans-unit id="3e6c4b85701f35fe30fbc34931dc03cfd7dda142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are usable in circumstances other than when declaring a template.</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; y &lt;code&gt;template&lt;/code&gt; son utilizables en circunstancias que no sean al declarar una plantilla.</target>
        </trans-unit>
        <trans-unit id="7ca671f7a7070e1849b27be2dac38cb84d41ab25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Let's wait until the user instantiates the template, and then later find out the real meaning of &lt;code&gt;t::x * f;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Esperemos hasta que el usuario cree una instancia de la plantilla y luego descubra el significado real de &lt;code&gt;t::x * f;&lt;/code&gt; &lt;/em&gt; &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c04d03f78f58040504cd81e4dc96e86c59640a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The syntax allows &lt;code&gt;typename&lt;/code&gt; only before qualified names&lt;/em&gt; - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.</source>
          <target state="translated">&lt;em&gt;La sintaxis permite &lt;code&gt;typename&lt;/code&gt; solo antes de los nombres calificados&lt;/em&gt; ; por lo tanto, se da por sentado que los nombres no calificados siempre se refieren a tipos si lo hacen.</target>
        </trans-unit>
        <trans-unit id="e2ecf05f2de6fcde4001af850840dca6978b6c81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;NestedTrait&quot;&lt;/strong&gt;, which is a &lt;em&gt;template-id&lt;/em&gt;, depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;</source>
          <target state="translated">&lt;strong&gt;&quot;NestedTrait&quot;&lt;/strong&gt; , que es un &lt;em&gt;id de plantilla&lt;/em&gt; , depende de &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; y;</target>
        </trans-unit>
        <trans-unit id="7c3fd61616ef25b7bad12ae0f45164811952b743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;data&quot;&lt;/strong&gt;, which looks like a &lt;em&gt;member-function template&lt;/em&gt;, is indirectly a &lt;em&gt;dependent-name&lt;/em&gt; since the type of &lt;em&gt;foo&lt;/em&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;&quot;data&quot;&lt;/strong&gt; , que se parece a una &lt;em&gt;plantilla de funci&amp;oacute;n miembro&lt;/em&gt; , es indirectamente un &lt;em&gt;nombre dependiente&lt;/em&gt; ya que el tipo de &lt;em&gt;foo&lt;/em&gt; depende de la instanciaci&amp;oacute;n de &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edbe9c0a9a43ae825a9c6f8aaaf224b3d281ad41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; at the end of (&lt;em&gt;F&lt;/em&gt;) depends on &lt;em&gt;NestedTrait&lt;/em&gt;, which depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;</source>
          <target state="translated">&lt;strong&gt;&quot;tipo&quot;&lt;/strong&gt; al final de ( &lt;em&gt;F&lt;/em&gt; ) depende de &lt;em&gt;NestedTrait&lt;/em&gt; , que depende de &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; , y;</target>
        </trans-unit>
        <trans-unit id="8f60a89f51a419f36ed14856c476a0174be4ff9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, which include &lt;code&gt;T&lt;/code&gt;, and;</source>
          <target state="translated">&lt;strong&gt;&quot;tipo&quot;&lt;/strong&gt; depende de la instanciaci&amp;oacute;n de &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; , que incluye &lt;code&gt;T&lt;/code&gt; , y;</target>
        </trans-unit>
        <trans-unit id="6f469f6e1084fdb25863f628728d09a97794a167" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;E&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="42bb91b7ab5f09937d85eff1c421efa46f42ab8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;F&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;F&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="5d6b157f6a08ec9e0c665dc0de45a07bc5ee1a60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;G&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;G&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="82ccd28c2dcf130545ef823fe89eddf360a2a00f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PREFACE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PREFACE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23803dbe26e6085fd2fa0883c19d0f2f27666b33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The two different scenarios&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Los dos escenarios diferentes&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e811163b854bd2669c245ceb717edce8e12a537f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When specifying the bases of which a class inherits&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Al especificar las bases de las que hereda una clase&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="330d5ed944055f18e28c9497441117f20c14e6e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When the &lt;em&gt;template-id&lt;/em&gt; is the one being referred to in a derived class's &lt;em&gt;using-directive&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cuando el &lt;em&gt;id de plantilla&lt;/em&gt; es el que se menciona en la &lt;em&gt;directiva&lt;/em&gt; de &lt;em&gt;uso de&lt;/em&gt; una clase derivada&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="52b5f115a82e14ac063f13915cc23e1f11a5ebe8" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;This answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go &lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;Esta respuesta est&amp;aacute; destinada a ser bastante breve y dulce para responder (parte de) la pregunta titulada.&lt;/em&gt;&lt;/sub&gt; &lt;sub&gt;&lt;em&gt;Si desea una respuesta con m&amp;aacute;s detalles que explique por qu&amp;eacute; tiene que ponerlas all&amp;iacute;, vaya &lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="1bfe14eb10ca361b9d4ba80c600e5e0629d33b7b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;Note&lt;/strong&gt;: Applying &lt;code&gt;typename&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt; in a context where it is not required is not considered good practice; just because you can do something, doesn't mean that you should.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;Nota&lt;/strong&gt; : Aplicar &lt;code&gt;typename&lt;/code&gt; o &lt;code&gt;template&lt;/code&gt; en un contexto donde no es obligatorio no se considera una buena pr&amp;aacute;ctica;&lt;/sup&gt; &lt;sup&gt;solo porque puedes hacer algo, no significa que debas hacerlo.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d3e3594e08ca6cc46a536e175af0955c908fe709" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dependent-name&lt;/em&gt; is &lt;strong&gt;any&lt;/strong&gt; name that directly, or indirectly, depends on a &lt;em&gt;template-parameter&lt;/em&gt;.</source>
          <target state="translated">Un &lt;em&gt;nombre dependiente&lt;/em&gt; es &lt;strong&gt;cualquier&lt;/strong&gt; nombre que depende directa o indirectamente de un &lt;em&gt;par&amp;aacute;metro de plantilla&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="167311c32569b35652bc2a3316fd061fd6dd2919" translate="yes" xml:space="preserve">
          <source>A SNIPPET SAYS MORE THAN 1000 WORDS</source>
          <target state="translated">UN RECORTE DICE MÁS DE 1000 PALABRAS</target>
        </trans-unit>
        <trans-unit id="83157225247456f23e8d3702295867eda13efdd9" translate="yes" xml:space="preserve">
          <source>A compiler is required to catch the error when instantiating &lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt;. So you get the best of the two worlds: &quot;Delayed&quot; lookup protecting you if you could get in trouble with dependent base classes, and also &quot;Immediate&quot; lookup that frees you from &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">Se requiere un compilador para detectar el error al instanciar &lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt; . Entonces obtienes lo mejor de los dos mundos: la b&amp;uacute;squeda &quot;retrasada&quot; que te protege si pudieras tener problemas con las clases base dependientes, y tambi&amp;eacute;n la b&amp;uacute;squeda &quot;Inmediata&quot; que te libera del &lt;code&gt;typename&lt;/code&gt; de tipo y la &lt;code&gt;template&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c035f4cd7ec02fdb2cd82af3dcd6cec12757cd6b" translate="yes" xml:space="preserve">
          <source>A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)</source>
          <target state="translated">Un nombre es la utilización de un identificador (2.11),un identificador de función del operador (13.5),un identificador de función de conversión (12.3.2)o un identificador de plantilla (14.2)que denota una entidad o etiqueta (6.6.4,6.1).</target>
        </trans-unit>
        <trans-unit id="23519716491bc53d4e57fd893f7debfe498cf6c9" translate="yes" xml:space="preserve">
          <source>A name used in a template declaration or definition and that is dependent on a template-parameter is
  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified
  by the keyword typename.</source>
          <target state="translated">Se supone que un nombre utilizado en una declaración o definición de plantilla y que depende de un parámetro de plantilla no da nombre a un tipo,a menos que la búsqueda de nombres aplicable encuentre un nombre de tipo o que el nombre esté calificado por la palabra clave typename.</target>
        </trans-unit>
        <trans-unit id="1ad1d6ae245142dbfde495564ae1bd48307233e1" translate="yes" xml:space="preserve">
          <source>A similar gotcha exists for names that denote templates, as hinted at by the introductory text.</source>
          <target state="translated">Existe un &quot;gotcha&quot; similar para los nombres que denotan plantillas,como se sugiere en el texto introductorio.</target>
        </trans-unit>
        <trans-unit id="2f4d2698ac7315f563034d04e68543b3fea1b1a3" translate="yes" xml:space="preserve">
          <source>A value dependent expression &lt;code&gt;1 + N&lt;/code&gt; is not a name, but &lt;code&gt;N&lt;/code&gt; is. The subset of all dependent constructs that are names is called &lt;em&gt;dependent name&lt;/em&gt;. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule.</source>
          <target state="translated">Una expresi&amp;oacute;n dependiente del valor &lt;code&gt;1 + N&lt;/code&gt; no es un nombre, pero &lt;code&gt;N&lt;/code&gt; s&amp;iacute; . El subconjunto de todas las construcciones dependientes que son nombres se denomina &lt;em&gt;nombre dependiente&lt;/em&gt; . Los nombres de funciones, sin embargo, pueden tener un significado diferente en diferentes instancias de una plantilla, pero desafortunadamente no son atrapados por esta regla general.</target>
        </trans-unit>
        <trans-unit id="d79f149012b5db95c6057f7219f9674ae527d19b" translate="yes" xml:space="preserve">
          <source>Additional notes and examples</source>
          <target state="translated">Notas adicionales y ejemplos</target>
        </trans-unit>
        <trans-unit id="d4dd3f21f569a21f8954d6bcd851637c10de00d5" translate="yes" xml:space="preserve">
          <source>Additionally there are contexts where &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are &lt;strong&gt;explicitly&lt;/strong&gt; disallowed:</source>
          <target state="translated">Adem&amp;aacute;s, hay contextos donde el &lt;code&gt;typename&lt;/code&gt; y la &lt;code&gt;template&lt;/code&gt; est&amp;aacute;n &lt;strong&gt;expl&amp;iacute;citamente&lt;/strong&gt; prohibidos:</target>
        </trans-unit>
        <trans-unit id="c219dd2dca62ca1f2584c5024fdf659813719f8e" translate="yes" xml:space="preserve">
          <source>After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &amp;lt;, the &amp;lt; is
  always taken as the beginning of a template-argument-list and never as a name followed by the less-than
  operator.</source>
          <target state="translated">Despu&amp;eacute;s de que la b&amp;uacute;squeda de nombres (3.4) encuentra que un nombre es un nombre de plantilla, si a este nombre le sigue un &amp;lt;, el &amp;lt;siempre se toma como el comienzo de una lista de argumentos de plantilla y nunca como un nombre seguido por el menor- que el operador</target>
        </trans-unit>
        <trans-unit id="b108398247f2fde4538343d83b5bd97b8ad56a6f" translate="yes" xml:space="preserve">
          <source>An identifier is just a plain sequence of characters / digits, while the next two are the &lt;code&gt;operator +&lt;/code&gt; and &lt;code&gt;operator type&lt;/code&gt; form. The last form is &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt;. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.</source>
          <target state="translated">Un identificador es solo una secuencia simple de caracteres / d&amp;iacute;gitos, mientras que los siguientes dos son el &lt;code&gt;operator +&lt;/code&gt; y el &lt;code&gt;operator type&lt;/code&gt; . La &amp;uacute;ltima forma es &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt; . Todos estos son nombres, y por uso convencional en el Est&amp;aacute;ndar, un nombre tambi&amp;eacute;n puede incluir calificadores que dicen en qu&amp;eacute; espacio de nombre o clase se debe buscar un nombre.</target>
        </trans-unit>
        <trans-unit id="81c49b052d928be1082ab24b20ce2665f9580dc8" translate="yes" xml:space="preserve">
          <source>As can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that &lt;code&gt;A::result_type&lt;/code&gt; can only be &lt;code&gt;int&lt;/code&gt; (and is hence a type), and &lt;code&gt;this-&amp;gt;g&lt;/code&gt; can only be the member template &lt;code&gt;g&lt;/code&gt; declared later (even if &lt;code&gt;A&lt;/code&gt; is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of &lt;code&gt;A&lt;/code&gt;!).</source>
          <target state="translated">Como se puede ver, necesitamos la palabra clave de desambiguaci&amp;oacute;n incluso si el compilador podr&amp;iacute;a descubrir perfectamente que &lt;code&gt;A::result_type&lt;/code&gt; solo puede ser &lt;code&gt;int&lt;/code&gt; (y, por lo tanto, es un tipo), y &lt;code&gt;this-&amp;gt;g&lt;/code&gt; solo puede ser la plantilla miembro &lt;code&gt;g&lt;/code&gt; declarada m&amp;aacute;s tarde (incluso si &lt;code&gt;A&lt;/code&gt; est&amp;aacute; expl&amp;iacute;citamente especializado en alguna parte, eso no afectar&amp;iacute;a el c&amp;oacute;digo dentro de esa plantilla, por lo que su significado no puede verse afectado por una especializaci&amp;oacute;n posterior de &lt;code&gt;A&lt;/code&gt; !).</target>
        </trans-unit>
        <trans-unit id="79ce6d8e6b3913b7a546df762dbeaed29ea26d47" translate="yes" xml:space="preserve">
          <source>Attempting to access &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; from inside the function will result in an error:</source>
          <target state="translated">Intentar acceder a &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; desde dentro de la funci&amp;oacute;n dar&amp;aacute; como resultado un error:</target>
        </trans-unit>
        <trans-unit id="81a893e4a9fabef8c12fe3918ba674192fd36862" translate="yes" xml:space="preserve">
          <source>Based on this notion, the language says that &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; (such as &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt;) are all &lt;em&gt;member of the current instantiation&lt;/em&gt;&lt;strong&gt;if&lt;/strong&gt; they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately).</source>
          <target state="translated">En base a esta noci&amp;oacute;n, el lenguaje dice que &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt; , &lt;code&gt;Foo&lt;/code&gt; y &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; (como &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt; ) son todos &lt;em&gt;miembros de la instanciaci&amp;oacute;n actual&lt;/em&gt; &lt;strong&gt;si&lt;/strong&gt; se descubre que son miembros de un clase que es la instanciaci&amp;oacute;n actual o una de sus clases base no dependientes (simplemente haciendo la b&amp;uacute;squeda de nombre inmediatamente).</target>
        </trans-unit>
        <trans-unit id="aa182f32a2b889bab8bb654d1c6efd34ac494dd1" translate="yes" xml:space="preserve">
          <source>C++11</source>
          <target state="translated">C++11</target>
        </trans-unit>
        <trans-unit id="7ec9396ea07c3217ea09c65fdc1877acc2f3a1f2" translate="yes" xml:space="preserve">
          <source>CAN I JUST STICK THE &lt;em&gt;KEYWORDS&lt;/em&gt; IN FRONT OF ANY NAME?</source>
          <target state="translated">&amp;iquest;PUEDO PEGAR LAS &lt;em&gt;PALABRAS CLAVE&lt;/em&gt; DELANTE DE CUALQUIER NOMBRE?</target>
        </trans-unit>
        <trans-unit id="7938dcdba09fa9194d35fd38e5e702630c956dfa" translate="yes" xml:space="preserve">
          <source>Current instantiation</source>
          <target state="translated">Instanciación actual</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="864f4fdedd9126fb15ad913ea1c7d58bd7e1d941" translate="yes" xml:space="preserve">
          <source>Dependent function names</source>
          <target state="translated">Nombres de funciones dependientes</target>
        </trans-unit>
        <trans-unit id="3f049d4603c79ebaec4e70cfb62ab63cfc6422b2" translate="yes" xml:space="preserve">
          <source>Dependent names</source>
          <target state="translated">Nombres dependientes</target>
        </trans-unit>
        <trans-unit id="80e115f1bc8f5f6dc0f1430fb858a5daba5e52c8" translate="yes" xml:space="preserve">
          <source>Dependent types (e.g: a type template parameter &lt;code&gt;T&lt;/code&gt;)</source>
          <target state="translated">Tipos dependientes (p. Ej .: un par&amp;aacute;metro de plantilla de tipo &lt;code&gt;T&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8a421fb1c98aa08853006608fca450d4e2f3b469" translate="yes" xml:space="preserve">
          <source>Different &lt;code&gt;T&lt;/code&gt;s can drastically change the semantics involved.</source>
          <target state="translated">Diferentes &lt;code&gt;T&lt;/code&gt; s pueden cambiar dr&amp;aacute;sticamente la sem&amp;aacute;ntica involucrada.</target>
        </trans-unit>
        <trans-unit id="f6504f0366c5e84396e1494226e00641b0cd0668" translate="yes" xml:space="preserve">
          <source>During the first phase, the parser needs to know if a dependant name is the name of a type or the name of a non-type. By default, a dependant name is assumed to be the name of a non-type. The typename keyword before a dependant name specifies that it is the name of a type.</source>
          <target state="translated">Durante la primera fase,el analizador necesita saber si el nombre de un dependiente es el nombre de un tipo o el nombre de un no-tipo.Por defecto,se supone que un nombre dependiente es el nombre de un no-tipo.La palabra clave de nombre de tipo que precede al nombre de una persona a cargo especifica que es el nombre de un tipo.</target>
        </trans-unit>
        <trans-unit id="26e6a98595822c3428f17426deccc9b966757d5a" translate="yes" xml:space="preserve">
          <source>Every name written in a derived class's &lt;em&gt;base-specifier-list&lt;/em&gt; is already treated as a &lt;em&gt;type-name&lt;/em&gt;, explicitly specifying &lt;code&gt;typename&lt;/code&gt; is both ill-formed, and redundant.</source>
          <target state="translated">Cada nombre escrito en la &lt;em&gt;lista de especificador base de&lt;/em&gt; una clase derivada ya se trata como un &lt;em&gt;nombre de tipo&lt;/em&gt; , especificando expl&amp;iacute;citamente que &lt;code&gt;typename&lt;/code&gt; est&amp;aacute; mal formado y es redundante.</target>
        </trans-unit>
        <trans-unit id="9f84d1c16d0d0893c80abb26baf74107ad6ba732" translate="yes" xml:space="preserve">
          <source>Every time a &lt;em&gt;name&lt;/em&gt; denotes a type, &lt;strong&gt;all&lt;/strong&gt;&lt;em&gt;names&lt;/em&gt; involved must be either &lt;em&gt;type-names&lt;/em&gt; or &lt;em&gt;namespaces&lt;/em&gt;, with this in mind it's quite easy to see that we apply &lt;code&gt;typename&lt;/code&gt; at the beginning of our fully &lt;em&gt;qualified name&lt;/em&gt;.</source>
          <target state="translated">Cada vez que un &lt;em&gt;nombre&lt;/em&gt; denota un tipo, &lt;strong&gt;todos los&lt;/strong&gt; &lt;em&gt;nombres&lt;/em&gt; involucrados deben ser &lt;em&gt;nombres de tipo&lt;/em&gt; o &lt;em&gt;espacios de nombres&lt;/em&gt; , teniendo esto en cuenta, es bastante f&amp;aacute;cil ver que aplicamos &lt;code&gt;typename&lt;/code&gt; al comienzo de nuestro &lt;em&gt;nombre&lt;/em&gt; completo.</target>
        </trans-unit>
        <trans-unit id="47adaec317f0a9d2c7134ea1f923781d1c12aa2f" translate="yes" xml:space="preserve">
          <source>Examples and trivia</source>
          <target state="translated">Ejemplos y trivialidades</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="499e8a71311f5b45ef7b0868a6f17f4d3544aaaf" translate="yes" xml:space="preserve">
          <source>For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I'll talk a bit about how this is specified in the Standard.</source>
          <target state="translated">Para la gente que tiene libros gruesos de Standardese en su estante y que quieren saber de qué exactamente estaba hablando,hablaré un poco de cómo esto se especifica en el Standard.</target>
        </trans-unit>
        <trans-unit id="f6354646d0660057dd162dd60312a9d32319c52e" translate="yes" xml:space="preserve">
          <source>Given this struct and function:</source>
          <target state="translated">Dada esta estructura y función:</target>
        </trans-unit>
        <trans-unit id="71ddfb234bd60ba03d2e2d6677b4bbff9c588208" translate="yes" xml:space="preserve">
          <source>HOW TO HANDLE &lt;em&gt;DEPENDENT NAMES&lt;/em&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;Oacute;MO MANEJAR LOS &lt;em&gt;NOMBRES DEPENDIENTES&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="3b8fb374b67841bad50ca4fcb74ac158a7ee5ef1" translate="yes" xml:space="preserve">
          <source>How should this be parsed? For many languages a compiler doesn't need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what &lt;code&gt;t&lt;/code&gt; means. If it's a type, then it will be a declaration of a pointer &lt;code&gt;f&lt;/code&gt;. However if it's not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo se debe analizar esto? Para muchos idiomas, un compilador no necesita saber el significado de un nombre para analizar y, b&amp;aacute;sicamente, saber qu&amp;eacute; acci&amp;oacute;n hace una l&amp;iacute;nea de c&amp;oacute;digo. Sin embargo, en C ++, lo anterior puede producir interpretaciones muy diferentes dependiendo de lo que significa &lt;code&gt;t&lt;/code&gt; . Si es un tipo, ser&amp;aacute; una declaraci&amp;oacute;n de un puntero &lt;code&gt;f&lt;/code&gt; . Sin embargo, si no es un tipo, ser&amp;aacute; una multiplicaci&amp;oacute;n. Entonces, el Est&amp;aacute;ndar C ++ dice en el p&amp;aacute;rrafo (3/7):</target>
        </trans-unit>
        <trans-unit id="82496a0ea3b6f2d8e59d952d53e9a80c47b69040" translate="yes" xml:space="preserve">
          <source>How will the compiler find out what a name &lt;code&gt;t::x&lt;/code&gt; refers to, if &lt;code&gt;t&lt;/code&gt; refers to a template type parameter? &lt;code&gt;x&lt;/code&gt; could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. If a name has this property - that it can't be looked up until the actual template arguments are known - then it's called a &lt;em&gt;dependent name&lt;/em&gt; (it &quot;depends&quot; on the template parameters).</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo descubrir&amp;aacute; el compilador a qu&amp;eacute; se refiere un nombre &lt;code&gt;t::x&lt;/code&gt; , si &lt;code&gt;t&lt;/code&gt; se refiere a un par&amp;aacute;metro de tipo de plantilla? &lt;code&gt;x&lt;/code&gt; podr&amp;iacute;a ser un miembro de datos int est&amp;aacute;tico que podr&amp;iacute;a multiplicarse o igualmente podr&amp;iacute;a ser una clase anidada o typedef que podr&amp;iacute;a dar lugar a una declaraci&amp;oacute;n. Si un nombre tiene esta propiedad, que no se puede buscar hasta que se conozcan los argumentos reales de la plantilla, se llama un &lt;em&gt;nombre dependiente&lt;/em&gt; (&quot;depende&quot; de los par&amp;aacute;metros de la plantilla).</target>
        </trans-unit>
        <trans-unit id="80310f20942c0583891a7f45d0eb6646c9e2f39b" translate="yes" xml:space="preserve">
          <source>However, I'm not sure you're implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the &quot;fail&quot; tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.</source>
          <target state="translated">Sin embargo,no estoy seguro de que su implementación de inUnion sea correcta.Si entiendo correctamente,esta clase no se supone que sea instanciada,por lo tanto la pestaña de &quot;fallar&quot; nunca fallará avtualmente.Tal vez sería mejor indicar si el tipo está en la unión o no con un simple valor booleano.</target>
        </trans-unit>
        <trans-unit id="ffcbdb8addba9bcaec3d37e740ec726d7b74fdad" translate="yes" xml:space="preserve">
          <source>I am placing JLBorges's excellent &lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot;&gt;response&lt;/a&gt; to a similar question verbatim from cplusplus.com, as it is the most succinct explanation I've read on the subject.</source>
          <target state="translated">Estoy colocando la excelente &lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot;&gt;respuesta de&lt;/a&gt; JLBorges a una pregunta similar textualmente de cplusplus.com, ya que es la explicaci&amp;oacute;n m&amp;aacute;s sucinta que he le&amp;iacute;do sobre el tema.</target>
        </trans-unit>
        <trans-unit id="9afbd33d83b082c42724dd2a0954b2a5084a9c0e" translate="yes" xml:space="preserve">
          <source>If nothing is stated, the &lt;em&gt;dependent-name&lt;/em&gt; will be considered to be either a variable, or a function.</source>
          <target state="translated">Si no se indica nada, el &lt;em&gt;nombre dependiente&lt;/em&gt; se considerar&amp;aacute; como una variable o una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="248aa3b12203e10552b3af6c402294330055100c" translate="yes" xml:space="preserve">
          <source>If this was a Hollywood film, &lt;em&gt;dependent-names&lt;/em&gt; would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.</source>
          <target state="translated">Si se tratara de una pel&amp;iacute;cula de Hollywood, &lt;em&gt;los nombres dependientes&lt;/em&gt; ser&amp;iacute;an la enfermedad que se propaga a trav&amp;eacute;s del contacto corporal, afecta instant&amp;aacute;neamente a su anfitri&amp;oacute;n para confundirlo. Confusi&amp;oacute;n que podr&amp;iacute;a, posiblemente, conducir a un programa perso-, erhm .. mal formado.</target>
        </trans-unit>
        <trans-unit id="0bd90018a85e97f771d15515f6a3373c341702f0" translate="yes" xml:space="preserve">
          <source>If we instantiate the function-template with type &lt;em&gt;X&lt;/em&gt;, as in (&lt;em&gt;C&lt;/em&gt;), we will have a declaration of a &lt;em&gt;pointer-to int&lt;/em&gt; named &lt;em&gt;x&lt;/em&gt;, but;</source>
          <target state="translated">Si instanciamos la plantilla de funci&amp;oacute;n con el tipo &lt;em&gt;X&lt;/em&gt; , como en ( &lt;em&gt;C&lt;/em&gt; ), tendremos una declaraci&amp;oacute;n de un &lt;em&gt;puntero a int&lt;/em&gt; llamado &lt;em&gt;x&lt;/em&gt; , pero;</target>
        </trans-unit>
        <trans-unit id="ef47c5e71f44563ae042e5301468f27ca3a50614" translate="yes" xml:space="preserve">
          <source>Imagine what happens if we had a member function &lt;code&gt;h&lt;/code&gt; within the above defined &lt;code&gt;A&lt;/code&gt; class template</source>
          <target state="translated">Imagine lo que sucede si tuvi&amp;eacute;ramos una funci&amp;oacute;n miembro &lt;code&gt;h&lt;/code&gt; dentro de la plantilla de clase &lt;code&gt;A&lt;/code&gt; definida anteriormente</target>
        </trans-unit>
        <trans-unit id="231bd1ef6bfd0592631e7e9517ce774ad2be57d2" translate="yes" xml:space="preserve">
          <source>In C++03, the language allowed to catch this error because there could never be a valid way to instantiate &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; (whatever argument you give to &lt;code&gt;T&lt;/code&gt;). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since &lt;code&gt;A&lt;/code&gt; has no dependent base classes, and &lt;code&gt;A&lt;/code&gt; declares no member &lt;code&gt;questionable_type&lt;/code&gt;, the name &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; is &lt;em&gt;neither&lt;/em&gt; a member of the current instantiation &lt;em&gt;nor&lt;/em&gt; a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).</source>
          <target state="translated">En C ++ 03, el lenguaje permiti&amp;oacute; detectar este error porque nunca podr&amp;iacute;a haber una forma v&amp;aacute;lida de instanciar &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; (cualquier argumento que le des a &lt;code&gt;T&lt;/code&gt; ). En C ++ 11, el lenguaje ahora tiene una verificaci&amp;oacute;n adicional para dar m&amp;aacute;s razones para que los compiladores implementen esta regla. Como &lt;code&gt;A&lt;/code&gt; no tiene clases base dependientes y &lt;code&gt;A&lt;/code&gt; no declara ning&amp;uacute;n miembro &lt;code&gt;questionable_type&lt;/code&gt; , el nombre &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; &lt;em&gt;no&lt;/em&gt; es miembro de la instanciaci&amp;oacute;n actual &lt;em&gt;ni&lt;/em&gt; miembro de una especializaci&amp;oacute;n desconocida. En ese caso, no deber&amp;iacute;a haber forma de que ese c&amp;oacute;digo pueda compilarse v&amp;aacute;lidamente en el momento de la instanciaci&amp;oacute;n, por lo que el lenguaje proh&amp;iacute;be que un nombre donde el calificador sea la instanciaci&amp;oacute;n actual no sea miembro de una especializaci&amp;oacute;n desconocida ni miembro de la instanciaci&amp;oacute;n actual (sin embargo , esta violaci&amp;oacute;n a&amp;uacute;n no se requiere para ser diagnosticada).</target>
        </trans-unit>
        <trans-unit id="0883b2e93b7c95f02702247700ebd9bfd0ecb687" translate="yes" xml:space="preserve">
          <source>In a template that we write, there are two kinds of names that could be used - dependant names and non- dependant names. A dependant name is a name that depends on a template parameter; a non-dependant name has the same meaning irrespective of what the template parameters are.</source>
          <target state="translated">En una plantilla que escribimos,hay dos tipos de nombres que podrían ser utilizados-nombres de dependientes y nombres de no dependientes.Un nombre dependiente es un nombre que depende de un parámetro de la plantilla;un nombre no dependiente tiene el mismo significado independientemente de cuáles sean los parámetros de la plantilla.</target>
        </trans-unit>
        <trans-unit id="55037dd35e4322e33ec43f44ef797ca6cfa06004" translate="yes" xml:space="preserve">
          <source>In enough cases we need both of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;. Your code should look like the following</source>
          <target state="translated">En suficientes casos, necesitamos tanto &lt;code&gt;typename&lt;/code&gt; como &lt;code&gt;template&lt;/code&gt; . Su c&amp;oacute;digo debe verse como el siguiente</target>
        </trans-unit>
        <trans-unit id="e25768be4a82668492653e98728599e15bc1b3b6" translate="yes" xml:space="preserve">
          <source>In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:</source>
          <target state="translated">Para analizar un programa de C++,el compilador necesita saber si ciertos nombres son tipos o no.El siguiente ejemplo lo demuestra:</target>
        </trans-unit>
        <trans-unit id="723e24157fedb66459b8cb1e919fabf2d210f132" translate="yes" xml:space="preserve">
          <source>In some cases, the keywords are forbidden, as detailed below</source>
          <target state="translated">En algunos casos,las palabras clave están prohibidas,como se detalla a continuación</target>
        </trans-unit>
        <trans-unit id="6ff2869a81645404d269012800fd47e944df1110" translate="yes" xml:space="preserve">
          <source>In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to &lt;em&gt;depend&lt;/em&gt; on template parameters.</source>
          <target state="translated">En las declaraciones de plantilla, algunas construcciones tienen diferentes significados seg&amp;uacute;n los argumentos de plantilla que use para crear una instancia de la plantilla: las expresiones pueden tener diferentes tipos o valores, las variables pueden tener diferentes tipos o las llamadas a funciones pueden terminar llamando a diferentes funciones. Dichas construcciones generalmente se dice que &lt;em&gt;dependen&lt;/em&gt; de par&amp;aacute;metros de plantilla.</target>
        </trans-unit>
        <trans-unit id="607a8c1883367af22aab7a8e02fcba22f562537c" translate="yes" xml:space="preserve">
          <source>In templates, where and why do I have to put &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; on dependent names? What exactly are dependent names anyway? I have the following code:</source>
          <target state="translated">En plantillas, &amp;iquest;d&amp;oacute;nde y por qu&amp;eacute; tengo que poner &lt;code&gt;typename&lt;/code&gt; y &lt;code&gt;template&lt;/code&gt; en nombres dependientes? &amp;iquest;Qu&amp;eacute; son exactamente los nombres dependientes de todos modos? Tengo el siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="f50b1a4caa717e4ce30b40c50fdb5ffda75c32a7" translate="yes" xml:space="preserve">
          <source>In the code of &lt;code&gt;D&lt;/code&gt;, the name &lt;code&gt;typename D::questionable_type&lt;/code&gt; is not a member of the current instantiation. Instead the language marks it as a &lt;em&gt;member of an unknown specialization&lt;/em&gt;. In particular, this is always the case when you are doing &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; or &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; and either the dependent type is &lt;em&gt;not&lt;/em&gt; the current instantiation (in which case the compiler can give up and say &quot;we will look later what &lt;code&gt;Foo&lt;/code&gt; is) or it &lt;em&gt;is&lt;/em&gt; the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes.</source>
          <target state="translated">En el c&amp;oacute;digo de &lt;code&gt;D&lt;/code&gt; , el nombre &lt;code&gt;typename D::questionable_type&lt;/code&gt; no es miembro de la instanciaci&amp;oacute;n actual. En cambio, el lenguaje lo marca como &lt;em&gt;miembro de una especializaci&amp;oacute;n desconocida&lt;/em&gt; . En particular, este es siempre el caso cuando est&amp;aacute;s haciendo &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; o &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; y el tipo dependiente &lt;em&gt;no&lt;/em&gt; es la instancia actual (en cuyo caso el compilador puede darse por vencido y decir &quot;veremos m&amp;aacute;s tarde qu&amp;eacute; es &lt;code&gt;Foo&lt;/code&gt; ) o &lt;em&gt;es&lt;/em&gt; la instancia actual y el nombre no se encontr&amp;oacute; en ella o en sus clases base no dependientes y tambi&amp;eacute;n hay clases base dependientes.</target>
        </trans-unit>
        <trans-unit id="a7ada29808422dbb9e24960c66d91349f17c4800" translate="yes" xml:space="preserve">
          <source>In using-declarations it's not possible to use &lt;code&gt;template&lt;/code&gt; after the last &lt;code&gt;::&lt;/code&gt;, and the C++ committee &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot;&gt;said&lt;/a&gt; not to work on a solution.</source>
          <target state="translated">Al usar declaraciones no es posible usar la &lt;code&gt;template&lt;/code&gt; despu&amp;eacute;s del &amp;uacute;ltimo &lt;code&gt;::&lt;/code&gt; , y el comit&amp;eacute; de C ++ &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot;&gt;dijo que&lt;/a&gt; no funcionara en una soluci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8421611d7923291b6537ffa9a5516e093fd2bf26" translate="yes" xml:space="preserve">
          <source>It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of &lt;code&gt;boost::function&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">Puede parecer obvio para un lector humano. No es as&amp;iacute; para el compilador. Imagine la siguiente definici&amp;oacute;n arbitraria de &lt;code&gt;boost::function&lt;/code&gt; &lt;code&gt;f&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ef82f45cfb61fb4fecf8d59ce0e78f98cd2cc2f4" translate="yes" xml:space="preserve">
          <source>It might not be as easy as one thinks, more specifically the result of evaluating (&lt;em&gt;A&lt;/em&gt;) heavily &lt;em&gt;depends&lt;/em&gt; on the definition of the type passed as template-parameter &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Puede que no sea tan f&amp;aacute;cil como se piensa, m&amp;aacute;s espec&amp;iacute;ficamente el resultado de evaluar ( &lt;em&gt;A&lt;/em&gt; ) &lt;em&gt;depende&lt;/em&gt; en gran &lt;em&gt;medida&lt;/em&gt; de la definici&amp;oacute;n del tipo que se pasa como par&amp;aacute;metro de plantilla &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73f2eedcc9728afac38f277e768bc709f16765a2" translate="yes" xml:space="preserve">
          <source>Most of the rules are intuitive and are built up recursively: For example, a type constructed as &lt;code&gt;T[N]&lt;/code&gt; is a dependent type if &lt;code&gt;N&lt;/code&gt; is a value-dependent expression or &lt;code&gt;T&lt;/code&gt; is a dependent type. The details of this can be read in section &lt;code&gt;(14.6.2/1&lt;/code&gt;) for dependent types, &lt;code&gt;(14.6.2.2)&lt;/code&gt; for type-dependent expressions and &lt;code&gt;(14.6.2.3)&lt;/code&gt; for value-dependent expressions.</source>
          <target state="translated">La mayor&amp;iacute;a de las reglas son intuitivas y se desarrollan de forma recursiva: por ejemplo, un tipo construido como &lt;code&gt;T[N]&lt;/code&gt; es un tipo dependiente si &lt;code&gt;N&lt;/code&gt; es una expresi&amp;oacute;n dependiente del valor o &lt;code&gt;T&lt;/code&gt; es un tipo dependiente. Los detalles de esto se pueden leer en la secci&amp;oacute;n &lt;code&gt;(14.6.2/1&lt;/code&gt; ) para tipos dependientes, &lt;code&gt;(14.6.2.2)&lt;/code&gt; para expresiones dependientes de tipo y &lt;code&gt;(14.6.2.3)&lt;/code&gt; para expresiones dependientes de valor.</target>
        </trans-unit>
        <trans-unit id="d33e5e8480f354dad4b6ad9367f25a40c9f9bdaa" translate="yes" xml:space="preserve">
          <source>Neither of statement (&lt;em&gt;E&lt;/em&gt;), (&lt;em&gt;F&lt;/em&gt;) or (&lt;em&gt;G&lt;/em&gt;) is valid if the compiler would interpret the &lt;em&gt;dependent-names&lt;/em&gt; as variables/functions (which as stated earlier is what happens if we don't explicitly say otherwise).</source>
          <target state="translated">Ninguna de las afirmaciones ( &lt;em&gt;E&lt;/em&gt; ), ( &lt;em&gt;F&lt;/em&gt; ) o ( &lt;em&gt;G&lt;/em&gt; ) es v&amp;aacute;lida si el compilador interpretar&amp;iacute;a los &lt;em&gt;nombres dependientes&lt;/em&gt; como variables / funciones (lo que, como se indic&amp;oacute; anteriormente, es lo que sucede si no decimos expl&amp;iacute;citamente lo contrario).</target>
        </trans-unit>
        <trans-unit id="d32a29935d2bd59d7cfd39a6135dbe57c5e8fc66" translate="yes" xml:space="preserve">
          <source>Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example &lt;code&gt;f((T)0)&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt; is a dependent name. In the Standard, this is specified at &lt;code&gt;(14.6.2/1)&lt;/code&gt;.</source>
          <target state="translated">No es principalmente una preocupaci&amp;oacute;n de este art&amp;iacute;culo, pero vale la pena mencionarlo: los nombres de las funciones son una excepci&amp;oacute;n que se manejan por separado. El nombre de una funci&amp;oacute;n de identificador depende no solo, sino de las expresiones de argumento dependientes del tipo utilizadas en una llamada. En el ejemplo &lt;code&gt;f((T)0)&lt;/code&gt; , &lt;code&gt;f&lt;/code&gt; es un nombre dependiente. En la Norma, esto se especifica en &lt;code&gt;(14.6.2/1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c3acfb0745ac40f78ce00a50115e3da33af5010" translate="yes" xml:space="preserve">
          <source>Note that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don't have to specify &lt;code&gt;typename&lt;/code&gt;, for example:</source>
          <target state="translated">Tenga en cuenta que esto tambi&amp;eacute;n se aplica a las metafunciones o cosas que tambi&amp;eacute;n toman par&amp;aacute;metros gen&amp;eacute;ricos de plantilla. Sin embargo, si el par&amp;aacute;metro de plantilla proporcionado es un tipo expl&amp;iacute;cito, entonces no tiene que especificar &lt;code&gt;typename&lt;/code&gt; , por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4a8107ce35efcfc3379410e30c887b0716e8c000" translate="yes" xml:space="preserve">
          <source>Now we are back to the same problem as with &lt;code&gt;typename&lt;/code&gt;. What if we can't know yet whether the name is a template when parsing the code? We will need to insert &lt;code&gt;template&lt;/code&gt; immediately before the template name, as specified by &lt;code&gt;14.2/4&lt;/code&gt;. This looks like:</source>
          <target state="translated">Ahora volvemos al mismo problema que con &lt;code&gt;typename&lt;/code&gt; . &amp;iquest;Qu&amp;eacute; sucede si todav&amp;iacute;a no podemos saber si el nombre es una plantilla al analizar el c&amp;oacute;digo? Tendremos que insertar la &lt;code&gt;template&lt;/code&gt; inmediatamente antes del nombre de la plantilla, como se especifica en &lt;code&gt;14.2/4&lt;/code&gt; . Esto se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="247f001f459a71cf2ba6a5da92513d6caf7363e0" translate="yes" xml:space="preserve">
          <source>On the name of a dependent base class you are not allowed to write &lt;code&gt;typename&lt;/code&gt;. It's assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</source>
          <target state="translated">En el nombre de una clase base dependiente no puede escribir &lt;code&gt;typename&lt;/code&gt; . Se supone que el nombre dado es un nombre de tipo de clase. Esto es cierto para ambos nombres en la lista de clase base y la lista de inicializador del constructor:</target>
        </trans-unit>
        <trans-unit id="a512f0af9594fedb9079383ef813cc685035c26f" translate="yes" xml:space="preserve">
          <source>PS2: Have a look at &lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot;&gt;typelists&lt;/a&gt;, notably in Andrei Alexandrescu's book: Modern C++ Design</source>
          <target state="translated">PS2: Echa un vistazo a las &lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot;&gt;listas&lt;/a&gt; de tipos , especialmente en el libro de Andrei Alexandrescu: Modern C ++ Design</target>
        </trans-unit>
        <trans-unit id="bdbe5508b19afff8cb57579196c6516007ea9aae" translate="yes" xml:space="preserve">
          <source>PS: Have a look at &lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot;&gt;Boost::Variant&lt;/a&gt;</source>
          <target state="translated">PD: Echa un vistazo a &lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot;&gt;Boost :: Variant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="3df155aafc1a199cca8ef6beb1b1d48c331e2365" translate="yes" xml:space="preserve">
          <source>Remember the initial quote above and how the Standard requires special handling for templates as well? Let's take the following innocent-looking example:</source>
          <target state="translated">¿Recuerda la cita inicial de arriba y cómo el Estándar requiere un manejo especial para las plantillas también? Tomemos el siguiente ejemplo de aspecto inocente:</target>
        </trans-unit>
        <trans-unit id="6ba008a6093affa2d41cdad9748159bc5cb6d20a" translate="yes" xml:space="preserve">
          <source>So there has to be a way to tell the compiler that certain names are types and that certain names aren't.</source>
          <target state="translated">Así que tiene que haber una forma de decirle al compilador que ciertos nombres son tipos y que ciertos nombres no lo son.</target>
        </trans-unit>
        <trans-unit id="660674432116072d61b4a75c7efcf588fe3e6c94" translate="yes" xml:space="preserve">
          <source>Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.</source>
          <target state="translated">Algunos nombres denotan tipos o plantillas.En general,siempre que se encuentra un nombre es necesario determinar si ese nombre denota una de estas entidades antes de continuar analizando el programa que lo contiene.El proceso que determina esto se llama búsqueda de nombres.</target>
        </trans-unit>
        <trans-unit id="8d79f76b53e088ead8ed9ed664f087d2b54ea07d" translate="yes" xml:space="preserve">
          <source>THE RATIONALE</source>
          <target state="translated">LA RAZÓN</target>
        </trans-unit>
        <trans-unit id="1e7bff13be2789a80f543841f8ca934baeda8abf" translate="yes" xml:space="preserve">
          <source>THE SOLUTION</source>
          <target state="translated">LA SOLUCIÓN</target>
        </trans-unit>
        <trans-unit id="7d4bf11f65a833a43805734fc518cd4aba4e3ae0" translate="yes" xml:space="preserve">
          <source>Template names can not only occur after a &lt;code&gt;::&lt;/code&gt; but also after a &lt;code&gt;-&amp;gt;&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; in a class member access. You need to insert the keyword there too:</source>
          <target state="translated">Los nombres de plantilla no solo pueden aparecer despu&amp;eacute;s de un &lt;code&gt;::&lt;/code&gt; sino tambi&amp;eacute;n despu&amp;eacute;s de un &lt;code&gt;-&amp;gt;&lt;/code&gt; o &lt;code&gt;.&lt;/code&gt; en un acceso de miembro de clase. Tambi&amp;eacute;n debe insertar la palabra clave all&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7e2e37676af9900b6b7d7b80a6d076dd3efe6361" translate="yes" xml:space="preserve">
          <source>That way the compiler will parse this properly rather than &lt;code&gt;t.get &amp;lt; int&lt;/code&gt;.</source>
          <target state="translated">De esta forma, el compilador analizar&amp;aacute; esto correctamente en lugar de &lt;code&gt;t.get &amp;lt; int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="836511d1cb4791ee6d0d13c95ea85a78fe3910de" translate="yes" xml:space="preserve">
          <source>That's actually a valid &lt;em&gt;expression&lt;/em&gt;! It uses the less-than operator to compare &lt;code&gt;boost::function&lt;/code&gt; against zero (&lt;code&gt;int()&lt;/code&gt;), and then uses the greater-than operator to compare the resulting &lt;code&gt;bool&lt;/code&gt; against &lt;code&gt;f&lt;/code&gt;. However as you might well know, &lt;code&gt;boost::function&lt;/code&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot;&gt;in real life&lt;/a&gt; is a template, so the compiler knows (14.2/3):</source>
          <target state="translated">Esa es en realidad una &lt;em&gt;expresi&amp;oacute;n&lt;/em&gt; v&amp;aacute;lida! Utiliza el operador menor que para comparar &lt;code&gt;boost::function&lt;/code&gt; contra cero ( &lt;code&gt;int()&lt;/code&gt; ), y luego usa el operador mayor que para comparar el &lt;code&gt;bool&lt;/code&gt; resultante con &lt;code&gt;f&lt;/code&gt; . Sin embargo, como bien sabr&amp;aacute;n, &lt;code&gt;boost::function&lt;/code&gt; &lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot;&gt;en la vida real&lt;/a&gt; es una plantilla, por lo que el compilador sabe (14.2 / 3):</target>
        </trans-unit>
        <trans-unit id="f35b88a4738b3645c1aef372f59ad3047b158b13" translate="yes" xml:space="preserve">
          <source>That's impressive, but can we do better? The language even goes further and &lt;em&gt;requires&lt;/em&gt; that an implementation again looks up &lt;code&gt;D::result_type&lt;/code&gt; when instantiating &lt;code&gt;D::f&lt;/code&gt; (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined &lt;code&gt;C&lt;/code&gt; like this</source>
          <target state="translated">Eso es impresionante, pero &amp;iquest;podemos hacerlo mejor? El lenguaje incluso va m&amp;aacute;s all&amp;aacute; y &lt;em&gt;requiere&lt;/em&gt; que una implementaci&amp;oacute;n vuelva a buscar &lt;code&gt;D::result_type&lt;/code&gt; al instanciar &lt;code&gt;D::f&lt;/code&gt; (incluso si ya encontr&amp;oacute; su significado en el momento de la definici&amp;oacute;n). Cuando ahora el resultado de la b&amp;uacute;squeda difiere o resulta en ambig&amp;uuml;edad, el programa est&amp;aacute; mal formado y se debe dar un diagn&amp;oacute;stico. Imagina lo que sucede si definimos &lt;code&gt;C&lt;/code&gt; as&amp;iacute;</target>
        </trans-unit>
        <trans-unit id="397b3aa358a31ed91afc3c84c5752f5669f499b0" translate="yes" xml:space="preserve">
          <source>The &quot;template&quot; keyword</source>
          <target state="translated">La palabra clave &quot;plantilla&quot;</target>
        </trans-unit>
        <trans-unit id="ab32972d5ca051abc115a7572997071871b757ac" translate="yes" xml:space="preserve">
          <source>The &quot;typename&quot; keyword</source>
          <target state="translated">La palabra clave &quot;nombre de pila&quot;</target>
        </trans-unit>
        <trans-unit id="059c8dc482f6fcec095abfac5e21cf05f38aaecd" translate="yes" xml:space="preserve">
          <source>The C++ Standard cares about our safety and well-being, at least in this case.</source>
          <target state="translated">La norma C++se preocupa por nuestra seguridad y bienestar,al menos en este caso.</target>
        </trans-unit>
        <trans-unit id="75d71f350625c9208a970a84d0f2647c18d12e3d" translate="yes" xml:space="preserve">
          <source>The C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)</source>
          <target state="translated">Las reglas de C++11 hacen que el siguiente código C++03 válido esté mal formado (lo cual no era la intención del comité de C++,pero probablemente no será arreglado)</target>
        </trans-unit>
        <trans-unit id="d678b7bdd1a0680bb6cb738cb7515a1010d81457" translate="yes" xml:space="preserve">
          <source>The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:</source>
          <target state="translated">La Norma define con precisión las reglas en función de si una construcción es dependiente o no.Las separa en grupos lógicamente diferentes:Uno atrapa los tipos,otro atrapa las expresiones.Las expresiones pueden depender de su valor o de su tipo.Así que tenemos,con ejemplos típicos adjuntos:</target>
        </trans-unit>
        <trans-unit id="9cfd62de43ae793e4b5c0bbaea489055b29010a9" translate="yes" xml:space="preserve">
          <source>The Standard is a bit unclear about what &lt;em&gt;exactly&lt;/em&gt; is a &lt;em&gt;dependent name&lt;/em&gt;. On a simple read (you know, the principle of least surprise), all it defines as a &lt;em&gt;dependent name&lt;/em&gt; is the special case for function names below. But since clearly &lt;code&gt;T::x&lt;/code&gt; also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition).</source>
          <target state="translated">El est&amp;aacute;ndar no es claro sobre qu&amp;eacute; es &lt;em&gt;exactamente&lt;/em&gt; un &lt;em&gt;nombre dependiente&lt;/em&gt; . En una lectura simple (ya sabes, el principio de menor sorpresa), todo lo que define como un &lt;em&gt;nombre dependiente&lt;/em&gt; es el caso especial para los nombres de funciones a continuaci&amp;oacute;n. Pero dado que claramente &lt;code&gt;T::x&lt;/code&gt; tambi&amp;eacute;n debe buscarse en el contexto de creaci&amp;oacute;n de instancias, tambi&amp;eacute;n debe ser un nombre dependiente (afortunadamente, a partir de mediados de C ++ 14, el comit&amp;eacute; ha comenzado a estudiar c&amp;oacute;mo solucionar esta definici&amp;oacute;n confusa) .</target>
        </trans-unit>
        <trans-unit id="eaeb296948f681fa8c069b722bff11d7272cc610" translate="yes" xml:space="preserve">
          <source>The answer is: &lt;em&gt;We&lt;/em&gt; decide how the compiler should parse this. If &lt;code&gt;t::x&lt;/code&gt; is a dependent name, then we need to prefix it by &lt;code&gt;typename&lt;/code&gt; to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):</source>
          <target state="translated">La respuesta es: &lt;em&gt;Decidimos&lt;/em&gt; c&amp;oacute;mo el compilador debe analizar esto. Si &lt;code&gt;t::x&lt;/code&gt; es un nombre dependiente, entonces necesitamos prefijarlo por &lt;code&gt;typename&lt;/code&gt; para decirle al compilador que lo analice de cierta manera. La Norma dice en (14.6 / 2):</target>
        </trans-unit>
        <trans-unit id="e839e7bc0fb3047c1bdf6c7dbb6e9ae237507034" translate="yes" xml:space="preserve">
          <source>The general rule for putting the &lt;code&gt;typename&lt;/code&gt; keyword is mostly when you're using a template parameter and you want to access a nested &lt;code&gt;typedef&lt;/code&gt; or using-alias, for example:</source>
          <target state="translated">La regla general para poner la palabra clave &lt;code&gt;typename&lt;/code&gt; es principalmente cuando est&amp;aacute; usando un par&amp;aacute;metro de plantilla y desea acceder a un &lt;code&gt;typedef&lt;/code&gt; anidado o alias, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="cfc3f7e0b4137c99807273a259f51ca22659ff99" translate="yes" xml:space="preserve">
          <source>The general rules for adding the &lt;code&gt;template&lt;/code&gt; qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:</source>
          <target state="translated">Las reglas generales para agregar el calificador de &lt;code&gt;template&lt;/code&gt; son en su mayor&amp;iacute;a similares, excepto que generalmente involucran funciones miembro con plantilla (est&amp;aacute;ticas o de otro tipo) de una estructura / clase que en s&amp;iacute; misma tiene plantilla, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="83fdb65b86514ecc3d94eb5034b2904b19fc4647" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; doesn't always have to appear in the last part of a name. It can appear in the middle before a class name that's used as a scope, like in the following example</source>
          <target state="translated">La &lt;code&gt;template&lt;/code&gt; palabras clave no siempre tiene que aparecer en la &amp;uacute;ltima parte de un nombre. Puede aparecer en el medio antes de un nombre de clase que se usa como &amp;aacute;mbito, como en el siguiente ejemplo</target>
        </trans-unit>
        <trans-unit id="ea5c129366ce9cd9ab21f5cd93e125ca28bbc280" translate="yes" xml:space="preserve">
          <source>The keywords &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;em&gt;still&lt;/em&gt; a type-dependent name (after all &lt;code&gt;T&lt;/code&gt; is also type dependent). But &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; is known to be a type - the compiler will &quot;magically&quot; look into this kind of dependent types to figure this out.</source>
          <target state="translated">Las palabras clave &lt;code&gt;typename&lt;/code&gt; y &lt;code&gt;template&lt;/code&gt; ya no son necesarias si el calificador es miembro de la instanciaci&amp;oacute;n actual. Un punto clave aqu&amp;iacute; para recordar es que &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; sigue &lt;em&gt;siendo&lt;/em&gt; un nombre dependiente del tipo (despu&amp;eacute;s de todo, &lt;code&gt;T&lt;/code&gt; tambi&amp;eacute;n depende del tipo). Pero se sabe que &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; es un tipo: el compilador buscar&amp;aacute; &quot;m&amp;aacute;gicamente&quot; en este tipo de tipos dependientes para resolver esto.</target>
        </trans-unit>
        <trans-unit id="077f4f3cb3b45d6c4da04d629251c33c46d6451d" translate="yes" xml:space="preserve">
          <source>The problem I have is in the &lt;code&gt;typedef Tail::inUnion&amp;lt;U&amp;gt; dummy&lt;/code&gt; line. I'm fairly certain that &lt;code&gt;inUnion&lt;/code&gt; is a dependent name, and VC++ is quite right in choking on it. I also know that I should be able to add &lt;code&gt;template&lt;/code&gt; somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. &lt;code&gt;inUnion&amp;lt;U&amp;gt;&lt;/code&gt; names a type and not a function?</source>
          <target state="translated">El problema que tengo est&amp;aacute; en la l&amp;iacute;nea &lt;code&gt;typedef Tail::inUnion&amp;lt;U&amp;gt; dummy&lt;/code&gt; . Estoy bastante seguro de que &lt;code&gt;inUnion&lt;/code&gt; es un nombre dependiente, y VC ++ tiene raz&amp;oacute;n al ahogarse. Tambi&amp;eacute;n s&amp;eacute; que deber&amp;iacute;a poder agregar una &lt;code&gt;template&lt;/code&gt; alg&amp;uacute;n lugar para decirle al compilador que inUnion es un id de plantilla. &amp;iquest;Pero d&amp;oacute;nde exactamente? &amp;iquest;Y deber&amp;iacute;a suponer que inUnion es una plantilla de clase, es decir, &lt;code&gt;inUnion&amp;lt;U&amp;gt;&lt;/code&gt; nombra un tipo y no una funci&amp;oacute;n?</target>
        </trans-unit>
        <trans-unit id="f1c7bae603744472346dadfc7ea4dedeef3d82c9" translate="yes" xml:space="preserve">
          <source>The rules in the Standard states that you may apply the keywords as long as you are dealing with a &lt;em&gt;qualified-name&lt;/em&gt; (&lt;em&gt;K&lt;/em&gt;), but if the name isn't &lt;em&gt;qualified&lt;/em&gt; the application is ill-formed (&lt;em&gt;L&lt;/em&gt;).</source>
          <target state="translated">Las reglas en el Est&amp;aacute;ndar establecen que puede aplicar las palabras clave siempre que se trate de un &lt;em&gt;nombre calificado&lt;/em&gt; ( &lt;em&gt;K&lt;/em&gt; ), pero si el nombre no est&amp;aacute; &lt;em&gt;calificado,&lt;/em&gt; la aplicaci&amp;oacute;n est&amp;aacute; mal formada ( &lt;em&gt;L&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="2bd5a78638dcace559982a14bbcc8b023fd7f274" translate="yes" xml:space="preserve">
          <source>The underlying purpose is the same; an explanation to &quot;When?&quot; and &quot;Why?&quot; &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; must be applied.</source>
          <target state="translated">El prop&amp;oacute;sito subyacente es el mismo; Una explicaci&amp;oacute;n de &quot;&amp;iquest;Cu&amp;aacute;ndo?&quot; &amp;iquest;y por qu&amp;eacute;?&quot; &lt;code&gt;typename&lt;/code&gt; y &lt;code&gt;template&lt;/code&gt; deben ser aplicados.</target>
        </trans-unit>
        <trans-unit id="10f33cad8fd8a2837a1e5c87042e16251d5742a6" translate="yes" xml:space="preserve">
          <source>There are certain contexts in &lt;em&gt;C++&lt;/em&gt; where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one &lt;em&gt;template-parameter&lt;/em&gt;.</source>
          <target state="translated">Hay ciertos contextos en &lt;em&gt;C ++&lt;/em&gt; donde se debe decir expl&amp;iacute;citamente al compilador c&amp;oacute;mo tratar un nombre, y todos estos contextos tienen una cosa en com&amp;uacute;n; dependen de al menos un &lt;em&gt;par&amp;aacute;metro de plantilla&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a4b3c376a5c02c3331f13cc34e60d67e0eda12a9" translate="yes" xml:space="preserve">
          <source>There are many names for which &lt;code&gt;typename&lt;/code&gt; is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with &lt;code&gt;T *f;&lt;/code&gt;, when &lt;code&gt;T&lt;/code&gt; is a type template parameter. But for &lt;code&gt;t::x * f;&lt;/code&gt; to be a declaration, it must be written as &lt;code&gt;typename t::x *f;&lt;/code&gt;. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:</source>
          <target state="translated">Hay muchos nombres para los que &lt;code&gt;typename&lt;/code&gt; no es necesario, porque el compilador puede, con la b&amp;uacute;squeda de nombre aplicable en la definici&amp;oacute;n de plantilla, descubrir c&amp;oacute;mo analizar una construcci&amp;oacute;n en s&amp;iacute; misma, por ejemplo con &lt;code&gt;T *f;&lt;/code&gt; , cuando &lt;code&gt;T&lt;/code&gt; es un par&amp;aacute;metro de plantilla de tipo. Pero para &lt;code&gt;t::x * f;&lt;/code&gt; para ser una declaraci&amp;oacute;n, debe escribirse como &lt;code&gt;typename t::x *f;&lt;/code&gt; . Si omite la palabra clave y se considera que el nombre no es de tipo, pero cuando la instanciaci&amp;oacute;n lo encuentra denota un tipo, el compilador emite los mensajes de error habituales. A veces, el error se da en consecuencia en el momento de la definici&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="193f977dcab6c47bd2d6b8470ad6dcab7bd03b03" translate="yes" xml:space="preserve">
          <source>This post is meant to be an &lt;em&gt;easy-to-read&lt;/em&gt; alternative to &lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;litb's post&lt;/a&gt;.</source>
          <target state="translated">Esta publicaci&amp;oacute;n est&amp;aacute; destinada a ser una alternativa &lt;em&gt;f&amp;aacute;cil de leer&lt;/em&gt; a la &lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;publicaci&amp;oacute;n de litb&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a4896926029b3eb852f0d6a106ca34a09f5713" translate="yes" xml:space="preserve">
          <source>This post will offer an explanation to the relationship between &lt;em&gt;dependent-names&lt;/em&gt;, and the two keywords.</source>
          <target state="translated">Esta publicaci&amp;oacute;n ofrecer&amp;aacute; una explicaci&amp;oacute;n de la relaci&amp;oacute;n entre &lt;em&gt;los nombres dependientes&lt;/em&gt; y las dos palabras clave.</target>
        </trans-unit>
        <trans-unit id="8d3949e28211d7534133207cc300ac1efaad60d9" translate="yes" xml:space="preserve">
          <source>This valid C++03 code would bind &lt;code&gt;this-&amp;gt;f&lt;/code&gt; to &lt;code&gt;A::f&lt;/code&gt; at instantiation time and everything is fine. C++11 however immediately binds it to &lt;code&gt;B::f&lt;/code&gt; and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt;, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot;&gt;Dominance Rule&lt;/a&gt; applies and lookup will find &lt;code&gt;A::f&lt;/code&gt; instead.</source>
          <target state="translated">Este c&amp;oacute;digo v&amp;aacute;lido de C ++ 03 vincular&amp;iacute;a &lt;code&gt;this-&amp;gt;f&lt;/code&gt; a &lt;code&gt;A::f&lt;/code&gt; en el momento de la instanciaci&amp;oacute;n y todo est&amp;aacute; bien. Sin embargo, C ++ 11 lo vincula inmediatamente a &lt;code&gt;B::f&lt;/code&gt; y requiere una doble verificaci&amp;oacute;n al crear instancias, verificando si la b&amp;uacute;squeda a&amp;uacute;n coincide. Sin embargo, al crear instancias de &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt; , se aplica la &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot;&gt;Regla de Dominancia&lt;/a&gt; y la b&amp;uacute;squeda encontrar&amp;aacute; &lt;code&gt;A::f&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="a29f6a4158f73a5ee76b40bdb5725dddd2048562" translate="yes" xml:space="preserve">
          <source>This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template's text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template's users (poor colleagues!) with errors made by a template's author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place.</source>
          <target state="translated">Esto funcionará y de hecho está permitido por la Norma como un posible enfoque de aplicación.Estos compiladores básicamente copian el texto de la plantilla en un buffer interno,y sólo cuando se necesita una instanciación,analizan la plantilla y posiblemente detectan errores en la definición.Pero en lugar de molestar a los usuarios de la plantilla (¡pobres colegas!)con errores cometidos por el autor de la plantilla,otras implementaciones optan por comprobar las plantillas desde el principio y dar errores en la definición tan pronto como sea posible,incluso antes de que se produzca una instanciación.</target>
        </trans-unit>
        <trans-unit id="ddec0732ccbb4210a2b6b99783ad2631b52a9cc7" translate="yes" xml:space="preserve">
          <source>Thus in this context you would need the &lt;code&gt;template&lt;/code&gt; keyword beforehand and call it like so:</source>
          <target state="translated">Por lo tanto, en este contexto, necesitar&amp;iacute;a la palabra clave de &lt;code&gt;template&lt;/code&gt; antemano y llamarla as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="3090538eec535ec4cf723c65f5b6a6ba58cdbe5b" translate="yes" xml:space="preserve">
          <source>To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore &quot;dependent names&quot;. A name can take different forms - the Standard says:</source>
          <target state="translated">Para evitar este problema,he recurrido a una simple interpretación del texto estándar.De todas las construcciones que denotan tipos o expresiones dependientes,un subconjunto de ellas representa nombres.Esos nombres son,por lo tanto,&quot;nombres dependientes&quot;.Un nombre puede tomar diferentes formas-dice el Estándar:</target>
        </trans-unit>
        <trans-unit id="7698fca51994ddc6c138471b88e06e7c83afdd2d" translate="yes" xml:space="preserve">
          <source>To improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt;). A type referenced by such a name is known to be  the &lt;em&gt;current instantiation&lt;/em&gt;. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, &lt;code&gt;A::NestedClass&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are both current instantiations).</source>
          <target state="translated">Para mejorar la situaci&amp;oacute;n, en C ++ 11 el lenguaje rastrea cuando un tipo se refiere a la plantilla adjunta. Para saberlo, el tipo debe haberse formado utilizando una determinada forma de nombre, que es su propio nombre (en lo anterior, &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt; ). Se sabe que un tipo referenciado por dicho nombre es la &lt;em&gt;instanciaci&amp;oacute;n actual&lt;/em&gt; . Puede haber varios tipos que son todas las instancias actuales si el tipo del que se forma el nombre es una clase miembro / anidada (entonces, &lt;code&gt;A::NestedClass&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; son ambas instancias actuales).</target>
        </trans-unit>
        <trans-unit id="f8b8473f52f5d48a53b82b2e364a8ed8725c5fd0" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;g_tmpl&lt;/code&gt; have a valid definition we must explicitly tell the compiler that we expect a type in (&lt;em&gt;E&lt;/em&gt;), a &lt;em&gt;template-id&lt;/em&gt; and a &lt;em&gt;type&lt;/em&gt; in (&lt;em&gt;F&lt;/em&gt;), and a &lt;em&gt;template-id&lt;/em&gt; in (&lt;em&gt;G&lt;/em&gt;).</source>
          <target state="translated">Para que &lt;code&gt;g_tmpl&lt;/code&gt; tenga una definici&amp;oacute;n v&amp;aacute;lida, debemos decirle expl&amp;iacute;citamente al compilador que esperamos un tipo en ( &lt;em&gt;E&lt;/em&gt; ), una &lt;em&gt;plantilla-id&lt;/em&gt; y un &lt;em&gt;tipo&lt;/em&gt; en ( &lt;em&gt;F&lt;/em&gt; ), y una &lt;em&gt;plantilla-id&lt;/em&gt; en ( &lt;em&gt;G&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="af6ebf3891ffb2ee30f2bf8858408c64c95c34f1" translate="yes" xml:space="preserve">
          <source>To prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a &lt;em&gt;dependent-name&lt;/em&gt; by &lt;em&gt;explicitly&lt;/em&gt; stating the intent anywhere we'd like to treat the name as either a &lt;em&gt;type-name&lt;/em&gt;, or a &lt;em&gt;template-id&lt;/em&gt;.</source>
          <target state="translated">Para evitar que una implementaci&amp;oacute;n sufra sorpresas desagradables, el Est&amp;aacute;ndar exige que resolvamos la ambig&amp;uuml;edad de un &lt;em&gt;nombre dependiente&lt;/em&gt; al establecer &lt;em&gt;expl&amp;iacute;citamente&lt;/em&gt; la intenci&amp;oacute;n en cualquier lugar donde nos gustar&amp;iacute;a tratar el nombre como un &lt;em&gt;nombre de tipo&lt;/em&gt; o una &lt;em&gt;plantilla. id&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="29862938e768a917aab1960c6bbb6ae497b193e9" translate="yes" xml:space="preserve">
          <source>Try to explain what is going on in the following &lt;em&gt;function-template&lt;/em&gt;, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (&lt;em&gt;A&lt;/em&gt;)?</source>
          <target state="translated">Trate de explicar lo que est&amp;aacute; sucediendo en la siguiente &lt;em&gt;plantilla de funci&amp;oacute;n&lt;/em&gt; , ya sea para usted, un amigo o quiz&amp;aacute;s su gato; &amp;iquest;Qu&amp;eacute; est&amp;aacute; sucediendo en la declaraci&amp;oacute;n marcada ( &lt;em&gt;A&lt;/em&gt; )?</target>
        </trans-unit>
        <trans-unit id="87061df8bae25712e416ad7d53765e98b6719bd8" translate="yes" xml:space="preserve">
          <source>Type-dependent expressions (e.g: a cast to a type template parameter &lt;code&gt;(T)0&lt;/code&gt;)</source>
          <target state="translated">Expresiones dependientes del tipo (p. Ej .: conversi&amp;oacute;n a un par&amp;aacute;metro de plantilla de tipo &lt;code&gt;(T)0&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="689c51725b427087666b6048cec59bcb29fcbece" translate="yes" xml:space="preserve">
          <source>Unknown specializations</source>
          <target state="translated">Especializaciones desconocidas</target>
        </trans-unit>
        <trans-unit id="6026daccdfec39543979697858424c64ff4ef007" translate="yes" xml:space="preserve">
          <source>Use the keyword typename only in template declarations and definitions provided you have a qualified name that refers to a type and depends on a template parameter.</source>
          <target state="translated">Utilice la palabra clave &quot;nombre de tipo&quot; sólo en las declaraciones y definiciones de plantillas siempre que tenga un nombre calificado que se refiera a un tipo y dependa de un parámetro de la plantilla.</target>
        </trans-unit>
        <trans-unit id="763d8d416b60f842f2c2cc144e23011113e885a1" translate="yes" xml:space="preserve">
          <source>Value-dependent expressions (e.g: a non-type template parameter &lt;code&gt;N&lt;/code&gt;)</source>
          <target state="translated">Expresiones dependientes del valor (por ejemplo: un par&amp;aacute;metro de plantilla no tipo &lt;code&gt;N&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ceaafeab5b0bb21207a924ae3fb0e737282cd5e7" translate="yes" xml:space="preserve">
          <source>We have four &lt;em&gt;dependent&lt;/em&gt; names in the above snippet:</source>
          <target state="translated">Tenemos cuatro nombres &lt;em&gt;dependientes&lt;/em&gt; en el fragmento anterior:</target>
        </trans-unit>
        <trans-unit id="526f7334186e1b9227cf705c33b09999cd0d98e8" translate="yes" xml:space="preserve">
          <source>We refer to such names, where there can be an ambiguity in interpretation, as; &quot;&lt;em&gt;dependent names&lt;/em&gt;&quot;.</source>
          <target state="translated">Nos referimos a tales nombres, donde puede haber una ambig&amp;uuml;edad en la interpretaci&amp;oacute;n, como; &quot; &lt;em&gt;nombres dependientes&lt;/em&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="bbecf5660dbaf8d8ded1b52887f0ecd3180d34c3" translate="yes" xml:space="preserve">
          <source>What a dependant name refers to could be something different for each different instantiation of the template. As a consequence, C++ templates are subject to &quot;two-phase name lookup&quot;. When a template is initially parsed (before any instantiation takes place) the compiler looks up the non-dependent names. When a particular instantiation of the template takes place, the template parameters are known by then, and the compiler looks up dependent names.</source>
          <target state="translated">Lo que el nombre de un dependiente se refiere podría ser algo diferente para cada diferente instanciación de la plantilla.Como consecuencia,las plantillas de C++están sujetas a la &quot;búsqueda de nombres en dos fases&quot;.Cuando una plantilla es analizada inicialmente (antes de que se produzca cualquier instanciación)el compilador busca los nombres no dependientes.Cuando tiene lugar una instanciación particular de la plantilla,los parámetros de la plantilla se conocen para entonces,y el compilador busca los nombres dependientes.</target>
        </trans-unit>
        <trans-unit id="b8f6499ca71be3c23ce33c1b2a9f5b83685a4750" translate="yes" xml:space="preserve">
          <source>What's the purpose of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es el prop&amp;oacute;sito de &lt;code&gt;typename&lt;/code&gt; y &lt;code&gt;template&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="bc52aff94964c77dc3a3b4fa138bce704fae73f4" translate="yes" xml:space="preserve">
          <source>Where and why do I have to put the “template” and “typename” keywords</source>
          <target state="translated">¿Dónde y por qué tengo que poner las palabras clave &quot;plantilla&quot; y &quot;nombre de pila&quot;</target>
        </trans-unit>
        <trans-unit id="552a23a5cb320222a24f1cb81b66e05f546ad95e" translate="yes" xml:space="preserve">
          <source>While the rules in C++03 about when you need &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are largely reasonable, there is one annoying disadvantage of its formulation</source>
          <target state="translated">Si bien las reglas en C ++ 03 sobre cu&amp;aacute;ndo necesita el &lt;code&gt;typename&lt;/code&gt; y la &lt;code&gt;template&lt;/code&gt; son en gran medida razonables, hay una desventaja molesta de su formulaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="7b6897d54406a3105e58e6dc3fc5b5863dff0daa" translate="yes" xml:space="preserve">
          <source>You can try this knowledge on &lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;this answer&lt;/a&gt; and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).</source>
          <target state="translated">Puede probar este conocimiento en &lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;esta respuesta&lt;/a&gt; y ver si las definiciones anteriores tienen sentido para usted en un ejemplo del mundo real (se repiten un poco menos detalladas en esa respuesta).</target>
        </trans-unit>
        <trans-unit id="2efba1c1c4d9757ca6d366d4029d83dcd0b82fca" translate="yes" xml:space="preserve">
          <source>You might recommend to just wait till the user instantiates the template:</source>
          <target state="translated">Se recomienda esperar a que el usuario instale la plantilla:</target>
        </trans-unit>
        <trans-unit id="e48b0fa9b66fcdab66a1db676dd26515d8b3d55f" translate="yes" xml:space="preserve">
          <source>if we instantiate the template with type &lt;em&gt;Y&lt;/em&gt;, as in (&lt;em&gt;D&lt;/em&gt;), (&lt;em&gt;A&lt;/em&gt;) would instead consist of an expression that calculates the product of &lt;em&gt;123&lt;/em&gt; multiplied with some already declared variable &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">si instanciamos la plantilla con el tipo &lt;em&gt;Y&lt;/em&gt; , como en ( &lt;em&gt;D&lt;/em&gt; ), ( &lt;em&gt;A&lt;/em&gt; ) consistir&amp;iacute;a en una expresi&amp;oacute;n que calcula el producto de &lt;em&gt;123&lt;/em&gt; multiplicado por alguna variable ya declarada &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
