<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/610245">
    <body>
      <group id="610245">
        <trans-unit id="81a4752786ca04ed1a7662da3ad6fd89d03fdd33" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;Can I just stick &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; in front of any name? I don't want to worry about the context in which they appear...&lt;/em&gt;&quot; - &lt;code&gt;Some C++ Developer&lt;/code&gt;</source>
          <target state="translated">「 &lt;em&gt;名前の前に &lt;code&gt;typename&lt;/code&gt; と &lt;code&gt;template&lt;/code&gt; を貼り付けることはできますか？それらが表示されるコンテキストについて心配したくありません...&lt;/em&gt; 」- &lt;code&gt;Some C++ Developer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da314107a76c971fe9203b881ca2d5dc651b90a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; however, is different in this regard, since there's no way of coming to a conclusion such as; &lt;em&gt;&quot;oh, this is a template, then this other thing must also be a template&quot;&lt;/em&gt;. This means that we apply &lt;code&gt;template&lt;/code&gt; directly in front of any &lt;em&gt;name&lt;/em&gt; that we'd like to treat as such.</source>
          <target state="translated">ただし、 &lt;code&gt;template&lt;/code&gt; はこの点で異なります。たとえば、次のような結論に至る方法がないためです。 &lt;em&gt;「ああ、これはテンプレートです。それから、これもテンプレートでなければなりません」&lt;/em&gt; つまり、そのように扱いたい&lt;em&gt;名前の&lt;/em&gt;前に直接 &lt;code&gt;template&lt;/code&gt; を適用します。</target>
        </trans-unit>
        <trans-unit id="3e6c4b85701f35fe30fbc34931dc03cfd7dda142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are usable in circumstances other than when declaring a template.</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; と &lt;code&gt;template&lt;/code&gt; は、テンプレートを宣言するとき以外の状況でも使用できます。</target>
        </trans-unit>
        <trans-unit id="7ca671f7a7070e1849b27be2dac38cb84d41ab25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Let's wait until the user instantiates the template, and then later find out the real meaning of &lt;code&gt;t::x * f;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ユーザーがテンプレートをインスタンス化するまで待ってから、後で &lt;code&gt;t::x * f;&lt;/code&gt; 実際の意味を見つけましょう。&lt;/em&gt; &lt;em&gt;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c04d03f78f58040504cd81e4dc96e86c59640a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The syntax allows &lt;code&gt;typename&lt;/code&gt; only before qualified names&lt;/em&gt; - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.</source>
          <target state="translated">&lt;em&gt;構文では、 &lt;code&gt;typename&lt;/code&gt; は修飾名の前にのみ&lt;/em&gt;許可され&lt;em&gt;ます&lt;/em&gt; -そのため、修飾されていない名前が常に型を参照することがわかっている場合は、そのように解釈されます。</target>
        </trans-unit>
        <trans-unit id="e2ecf05f2de6fcde4001af850840dca6978b6c81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;NestedTrait&quot;&lt;/strong&gt;, which is a &lt;em&gt;template-id&lt;/em&gt;, depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;</source>
          <target state="translated">&lt;em&gt;テンプレートID&lt;/em&gt;である&lt;strong&gt;「NestedTrait」&lt;/strong&gt;は、 &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; 依存します。</target>
        </trans-unit>
        <trans-unit id="7c3fd61616ef25b7bad12ae0f45164811952b743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;data&quot;&lt;/strong&gt;, which looks like a &lt;em&gt;member-function template&lt;/em&gt;, is indirectly a &lt;em&gt;dependent-name&lt;/em&gt; since the type of &lt;em&gt;foo&lt;/em&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;&quot;data&quot;&lt;/strong&gt;は、 &lt;em&gt;メンバー関数テンプレートの&lt;/em&gt;ように見えますが、 &lt;em&gt;foo&lt;/em&gt;のタイプは &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; インスタンス化に依存するため、間接的に&lt;em&gt;依存名&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="edbe9c0a9a43ae825a9c6f8aaaf224b3d281ad41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; at the end of (&lt;em&gt;F&lt;/em&gt;) depends on &lt;em&gt;NestedTrait&lt;/em&gt;, which depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;</source>
          <target state="translated">（ &lt;em&gt;F&lt;/em&gt; ）の最後の&lt;strong&gt;「タイプ」&lt;/strong&gt;は、 &lt;em&gt;NestedTrait&lt;/em&gt;に依存し&lt;em&gt;ます&lt;/em&gt; 。これは、 &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; 依存します。</target>
        </trans-unit>
        <trans-unit id="8f60a89f51a419f36ed14856c476a0174be4ff9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, which include &lt;code&gt;T&lt;/code&gt;, and;</source>
          <target state="translated">&lt;strong&gt;「タイプ」&lt;/strong&gt;は、 &lt;code&gt;T&lt;/code&gt; を含む &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; インスタンス化に依存します。</target>
        </trans-unit>
        <trans-unit id="6f469f6e1084fdb25863f628728d09a97794a167" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;E&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="42bb91b7ab5f09937d85eff1c421efa46f42ab8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;F&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;F&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="5d6b157f6a08ec9e0c665dc0de45a07bc5ee1a60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;G&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;G&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="82ccd28c2dcf130545ef823fe89eddf360a2a00f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PREFACE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PREFACE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23803dbe26e6085fd2fa0883c19d0f2f27666b33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The two different scenarios&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;2つの異なるシナリオ&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="e811163b854bd2669c245ceb717edce8e12a537f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When specifying the bases of which a class inherits&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;クラスが継承するベースを指定する場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="330d5ed944055f18e28c9497441117f20c14e6e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When the &lt;em&gt;template-id&lt;/em&gt; is the one being referred to in a derived class's &lt;em&gt;using-directive&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;template-id&lt;/em&gt;が派生クラスの&lt;em&gt;usingディレクティブ&lt;/em&gt;で参照されている場合&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="52b5f115a82e14ac063f13915cc23e1f11a5ebe8" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;This answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go &lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;この答えは、タイトルの質問（の一部）に答えるには、かなり短くて甘いものであることを意味します。&lt;/em&gt;&lt;/sub&gt; &lt;sub&gt;&lt;em&gt;あなたがそれらをそこに置く必要がある理由を説明するより詳細な答えが必要な場合は、こちらにアクセスして&lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;ください&lt;/a&gt; 。&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="1bfe14eb10ca361b9d4ba80c600e5e0629d33b7b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;Note&lt;/strong&gt;: Applying &lt;code&gt;typename&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt; in a context where it is not required is not considered good practice; just because you can do something, doesn't mean that you should.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;注&lt;/strong&gt; ： &lt;code&gt;typename&lt;/code&gt; または &lt;code&gt;template&lt;/code&gt; を必要としないコンテキストで適用することは、良い習慣とは見なされません。&lt;/sup&gt; &lt;sup&gt;あなたが何かをすることができるからといって、あなたがするべきだという意味ではありません。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d3e3594e08ca6cc46a536e175af0955c908fe709" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dependent-name&lt;/em&gt; is &lt;strong&gt;any&lt;/strong&gt; name that directly, or indirectly, depends on a &lt;em&gt;template-parameter&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;従属名&lt;/em&gt;は、直接的または間接的に&lt;em&gt;template-parameterに&lt;/em&gt;依存する名前です。</target>
        </trans-unit>
        <trans-unit id="167311c32569b35652bc2a3316fd061fd6dd2919" translate="yes" xml:space="preserve">
          <source>A SNIPPET SAYS MORE THAN 1000 WORDS</source>
          <target state="translated">スニペットには1000語以上の言葉がある</target>
        </trans-unit>
        <trans-unit id="83157225247456f23e8d3702295867eda13efdd9" translate="yes" xml:space="preserve">
          <source>A compiler is required to catch the error when instantiating &lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt;. So you get the best of the two worlds: &quot;Delayed&quot; lookup protecting you if you could get in trouble with dependent base classes, and also &quot;Immediate&quot; lookup that frees you from &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt; インスタンス化するときにエラーをキャッチするには、コンパイラが必要です。 したがって、依存する基本クラスで問題が発生した場合に保護する「遅延」ルックアップと、 &lt;code&gt;typename&lt;/code&gt; と &lt;code&gt;template&lt;/code&gt; から解放される「即時」ルックアップという2つの世界のベストを手に入れることができます。</target>
        </trans-unit>
        <trans-unit id="c035f4cd7ec02fdb2cd82af3dcd6cec12757cd6b" translate="yes" xml:space="preserve">
          <source>A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)</source>
          <target state="translated">名前は,実体又はラベルを表す識別子(2.11),演算子-機能-ID(13.5),変換機能-ID(12.3.2),又はテンプレート-ID(14.2)の使用である(6.6.4,6.1)。</target>
        </trans-unit>
        <trans-unit id="23519716491bc53d4e57fd893f7debfe498cf6c9" translate="yes" xml:space="preserve">
          <source>A name used in a template declaration or definition and that is dependent on a template-parameter is
  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified
  by the keyword typename.</source>
          <target state="translated">テンプレート宣言または定義で使用される名前で、テンプレート・パラメータに依存しているものは、名前検索で型名が見つかるか、キーワード typename で修飾されている場合を除き、型名を付けないものと見なされます。</target>
        </trans-unit>
        <trans-unit id="1ad1d6ae245142dbfde495564ae1bd48307233e1" translate="yes" xml:space="preserve">
          <source>A similar gotcha exists for names that denote templates, as hinted at by the introductory text.</source>
          <target state="translated">テンプレートを意味する名前にも同様のガチャがありますが、これは紹介文にヒントがあります。</target>
        </trans-unit>
        <trans-unit id="2f4d2698ac7315f563034d04e68543b3fea1b1a3" translate="yes" xml:space="preserve">
          <source>A value dependent expression &lt;code&gt;1 + N&lt;/code&gt; is not a name, but &lt;code&gt;N&lt;/code&gt; is. The subset of all dependent constructs that are names is called &lt;em&gt;dependent name&lt;/em&gt;. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule.</source>
          <target state="translated">値に依存する式 &lt;code&gt;1 + N&lt;/code&gt; は名前ではありませんが、 &lt;code&gt;N&lt;/code&gt; は名前です。 名前であるすべての従属構成要素のサブセットは、従属名と呼ばれます。 ただし、関数名はテンプレートの異なるインスタンス化では異なる意味を持つ可能性がありますが、残念ながらこの一般的なルールには当てはまりません。</target>
        </trans-unit>
        <trans-unit id="d79f149012b5db95c6057f7219f9674ae527d19b" translate="yes" xml:space="preserve">
          <source>Additional notes and examples</source>
          <target state="translated">追加の注意点と例</target>
        </trans-unit>
        <trans-unit id="d4dd3f21f569a21f8954d6bcd851637c10de00d5" translate="yes" xml:space="preserve">
          <source>Additionally there are contexts where &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are &lt;strong&gt;explicitly&lt;/strong&gt; disallowed:</source>
          <target state="translated">さらに、 &lt;code&gt;typename&lt;/code&gt; と &lt;code&gt;template&lt;/code&gt; が&lt;strong&gt;明示的に&lt;/strong&gt;禁止されているコンテキストがあります。</target>
        </trans-unit>
        <trans-unit id="c219dd2dca62ca1f2584c5024fdf659813719f8e" translate="yes" xml:space="preserve">
          <source>After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &amp;lt;, the &amp;lt; is
  always taken as the beginning of a template-argument-list and never as a name followed by the less-than
  operator.</source>
          <target state="translated">名前検索（3.4）が名前がテンプレート名であることを検出した後、この名前の後に&amp;lt;が続く場合、&amp;lt;は常にテンプレート引数リストの先頭と見なされ、名前の後に続く演算子より。</target>
        </trans-unit>
        <trans-unit id="b108398247f2fde4538343d83b5bd97b8ad56a6f" translate="yes" xml:space="preserve">
          <source>An identifier is just a plain sequence of characters / digits, while the next two are the &lt;code&gt;operator +&lt;/code&gt; and &lt;code&gt;operator type&lt;/code&gt; form. The last form is &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt;. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.</source>
          <target state="translated">識別子は単なる文字/数字のシーケンスですが、次の2つは &lt;code&gt;operator +&lt;/code&gt; と &lt;code&gt;operator type&lt;/code&gt; 形式です。 最後の形式は &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt; です。 これらはすべて名前であり、標準での慣習的な使用により、名前には、名前空間またはクラスを検索する必要があることを示す修飾子を含めることもできます。</target>
        </trans-unit>
        <trans-unit id="81c49b052d928be1082ab24b20ce2665f9580dc8" translate="yes" xml:space="preserve">
          <source>As can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that &lt;code&gt;A::result_type&lt;/code&gt; can only be &lt;code&gt;int&lt;/code&gt; (and is hence a type), and &lt;code&gt;this-&amp;gt;g&lt;/code&gt; can only be the member template &lt;code&gt;g&lt;/code&gt; declared later (even if &lt;code&gt;A&lt;/code&gt; is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of &lt;code&gt;A&lt;/code&gt;!).</source>
          <target state="translated">ご覧のように、コンパイラが &lt;code&gt;A::result_type&lt;/code&gt; は &lt;code&gt;int&lt;/code&gt; （したがって型）のみであり、 &lt;code&gt;this-&amp;gt;g&lt;/code&gt; &lt;code&gt;g&lt;/code&gt; は後で宣言されるメンバーテンプレートgのみであると完全に理解できたとしても、曖昧性除去キーワードが必要です。 （ &lt;code&gt;A&lt;/code&gt; がどこかで明示的に特殊化されている場合でも、そのテンプレート内のコードには影響しないため、その意味は後の &lt;code&gt;A&lt;/code&gt; の特殊化によって影響を受けることはありません。）</target>
        </trans-unit>
        <trans-unit id="79ce6d8e6b3913b7a546df762dbeaed29ea26d47" translate="yes" xml:space="preserve">
          <source>Attempting to access &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; from inside the function will result in an error:</source>
          <target state="translated">関数内から &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; にアクセスしようとすると、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="81a893e4a9fabef8c12fe3918ba674192fd36862" translate="yes" xml:space="preserve">
          <source>Based on this notion, the language says that &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; (such as &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt;) are all &lt;em&gt;member of the current instantiation&lt;/em&gt;&lt;strong&gt;if&lt;/strong&gt; they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately).</source>
          <target state="translated">この概念に基づいて、言語は &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt; 、 &lt;code&gt;Foo&lt;/code&gt; および &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; （ &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt; ）がaの &lt;em&gt;メンバーである&lt;/em&gt;ことが判明した&lt;strong&gt;場合&lt;/strong&gt; &lt;em&gt;、&lt;/em&gt;すべて&lt;em&gt;現在のインスタンス化の&lt;/em&gt;メンバーであると述べています現在のインスタンス化またはその非依存基本クラスの1つであるクラス（名前の検索をすぐに実行する）。</target>
        </trans-unit>
        <trans-unit id="aa182f32a2b889bab8bb654d1c6efd34ac494dd1" translate="yes" xml:space="preserve">
          <source>C++11</source>
          <target state="translated">C++11</target>
        </trans-unit>
        <trans-unit id="7ec9396ea07c3217ea09c65fdc1877acc2f3a1f2" translate="yes" xml:space="preserve">
          <source>CAN I JUST STICK THE &lt;em&gt;KEYWORDS&lt;/em&gt; IN FRONT OF ANY NAME?</source>
          <target state="translated">名前の前に&lt;em&gt;キーワードを貼り付けることはでき&lt;/em&gt;ますか？</target>
        </trans-unit>
        <trans-unit id="7938dcdba09fa9194d35fd38e5e702630c956dfa" translate="yes" xml:space="preserve">
          <source>Current instantiation</source>
          <target state="translated">現在のインスタンス化</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="864f4fdedd9126fb15ad913ea1c7d58bd7e1d941" translate="yes" xml:space="preserve">
          <source>Dependent function names</source>
          <target state="translated">従属関数名</target>
        </trans-unit>
        <trans-unit id="3f049d4603c79ebaec4e70cfb62ab63cfc6422b2" translate="yes" xml:space="preserve">
          <source>Dependent names</source>
          <target state="translated">従属名</target>
        </trans-unit>
        <trans-unit id="80e115f1bc8f5f6dc0f1430fb858a5daba5e52c8" translate="yes" xml:space="preserve">
          <source>Dependent types (e.g: a type template parameter &lt;code&gt;T&lt;/code&gt;)</source>
          <target state="translated">依存型（例：タイプテンプレートパラメータ &lt;code&gt;T&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8a421fb1c98aa08853006608fca450d4e2f3b469" translate="yes" xml:space="preserve">
          <source>Different &lt;code&gt;T&lt;/code&gt;s can drastically change the semantics involved.</source>
          <target state="translated">異なる &lt;code&gt;T&lt;/code&gt; は、関連するセマンティクスを大幅に変更する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f6504f0366c5e84396e1494226e00641b0cd0668" translate="yes" xml:space="preserve">
          <source>During the first phase, the parser needs to know if a dependant name is the name of a type or the name of a non-type. By default, a dependant name is assumed to be the name of a non-type. The typename keyword before a dependant name specifies that it is the name of a type.</source>
          <target state="translated">最初のフェーズでは、パーサは依存名が型の名前なのか非型の名前なのかを知る必要があります。デフォルトでは、依存名は非タイプの名前であると見なされます。このキーワードを使用すると、このように、他のクラスでも使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="26e6a98595822c3428f17426deccc9b966757d5a" translate="yes" xml:space="preserve">
          <source>Every name written in a derived class's &lt;em&gt;base-specifier-list&lt;/em&gt; is already treated as a &lt;em&gt;type-name&lt;/em&gt;, explicitly specifying &lt;code&gt;typename&lt;/code&gt; is both ill-formed, and redundant.</source>
          <target state="translated">派生クラスの&lt;em&gt;base-specifier-listに&lt;/em&gt;記述されているすべての名前は、既に&lt;em&gt;type-name&lt;/em&gt;として扱われてい&lt;em&gt;ます&lt;/em&gt; &lt;code&gt;typename&lt;/code&gt; 明示的に指定することは、 &lt;em&gt;形式が&lt;/em&gt; 正しくなく 、冗長です。</target>
        </trans-unit>
        <trans-unit id="9f84d1c16d0d0893c80abb26baf74107ad6ba732" translate="yes" xml:space="preserve">
          <source>Every time a &lt;em&gt;name&lt;/em&gt; denotes a type, &lt;strong&gt;all&lt;/strong&gt;&lt;em&gt;names&lt;/em&gt; involved must be either &lt;em&gt;type-names&lt;/em&gt; or &lt;em&gt;namespaces&lt;/em&gt;, with this in mind it's quite easy to see that we apply &lt;code&gt;typename&lt;/code&gt; at the beginning of our fully &lt;em&gt;qualified name&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;名前&lt;/em&gt;が型を表すときは&lt;strong&gt;常に&lt;/strong&gt; 、関係する&lt;strong&gt;すべての&lt;/strong&gt; &lt;em&gt;名前&lt;/em&gt;は&lt;em&gt;type-names&lt;/em&gt;または&lt;em&gt;namespaces&lt;/em&gt;でなければなりません。これを考慮すると、完全&lt;em&gt;修飾名の&lt;/em&gt;先頭に &lt;code&gt;typename&lt;/code&gt; を適用することは非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="47adaec317f0a9d2c7134ea1f923781d1c12aa2f" translate="yes" xml:space="preserve">
          <source>Examples and trivia</source>
          <target state="translated">事例と豆知識</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="499e8a71311f5b45ef7b0868a6f17f4d3544aaaf" translate="yes" xml:space="preserve">
          <source>For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I'll talk a bit about how this is specified in the Standard.</source>
          <target state="translated">分厚いスタンダード系の本が棚に並んでいて、具体的に何の話をしていたのか知りたいという人のために、これがスタンダードでどのように規定されているのかを少しだけお話しします。</target>
        </trans-unit>
        <trans-unit id="f6354646d0660057dd162dd60312a9d32319c52e" translate="yes" xml:space="preserve">
          <source>Given this struct and function:</source>
          <target state="translated">この構造体と関数を考えると</target>
        </trans-unit>
        <trans-unit id="71ddfb234bd60ba03d2e2d6677b4bbff9c588208" translate="yes" xml:space="preserve">
          <source>HOW TO HANDLE &lt;em&gt;DEPENDENT NAMES&lt;/em&gt;?</source>
          <target state="translated">従属名を処理する&lt;em&gt;方法は&lt;/em&gt; ？</target>
        </trans-unit>
        <trans-unit id="3b8fb374b67841bad50ca4fcb74ac158a7ee5ef1" translate="yes" xml:space="preserve">
          <source>How should this be parsed? For many languages a compiler doesn't need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what &lt;code&gt;t&lt;/code&gt; means. If it's a type, then it will be a declaration of a pointer &lt;code&gt;f&lt;/code&gt;. However if it's not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):</source>
          <target state="translated">これはどのように解析する必要がありますか？ 多くの言語では、コンパイラーは解析するために名前の意味を知る必要がなく、基本的にコード行が実行するアクションを知る必要はありません。 ただし、C ++では、上記の意味は &lt;code&gt;t&lt;/code&gt; の意味によって大きく異なります。 型の場合は、ポインタ &lt;code&gt;f&lt;/code&gt; の宣言になります。 ただし、それが型でない場合は、乗算になります。 したがって、C ++標準は段落（3/7）で次のように述べています。</target>
        </trans-unit>
        <trans-unit id="82496a0ea3b6f2d8e59d952d53e9a80c47b69040" translate="yes" xml:space="preserve">
          <source>How will the compiler find out what a name &lt;code&gt;t::x&lt;/code&gt; refers to, if &lt;code&gt;t&lt;/code&gt; refers to a template type parameter? &lt;code&gt;x&lt;/code&gt; could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. If a name has this property - that it can't be looked up until the actual template arguments are known - then it's called a &lt;em&gt;dependent name&lt;/em&gt; (it &quot;depends&quot; on the template parameters).</source>
          <target state="translated">コンパイラーは、 &lt;code&gt;t&lt;/code&gt; がテンプレート型パラメーターを参照している場合、 &lt;code&gt;t::x&lt;/code&gt; 参照している名前をどのようにして見つけますか？ &lt;code&gt;x&lt;/code&gt; は、乗算が可能な静的intデータメンバーであるか、または同様に、宣言を生成できるネストされたクラスまたはtypedefである可能性があります。 名前にこのプロパティがある場合（実際のテンプレート引数がわかるまで検索できない）、 &lt;em&gt;依存名&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt; （テンプレートパラメータに「依存」します）。</target>
        </trans-unit>
        <trans-unit id="80310f20942c0583891a7f45d0eb6646c9e2f39b" translate="yes" xml:space="preserve">
          <source>However, I'm not sure you're implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the &quot;fail&quot; tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.</source>
          <target state="translated">しかし、inUnionの実装が正しいとは思えません。私の理解が正しければ、このクラスはインスタンス化されないことになっています。型がユニオンに入っているかどうかを単純なブール値で示す方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="ffcbdb8addba9bcaec3d37e740ec726d7b74fdad" translate="yes" xml:space="preserve">
          <source>I am placing JLBorges's excellent &lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot;&gt;response&lt;/a&gt; to a similar question verbatim from cplusplus.com, as it is the most succinct explanation I've read on the subject.</source>
          <target state="translated">これは、このテーマについて読んだ最も簡潔な説明であるため、cplusplus.comからの同様の質問にJLBorgesの優れた&lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot;&gt;回答&lt;/a&gt;を逐語的に示しています。</target>
        </trans-unit>
        <trans-unit id="9afbd33d83b082c42724dd2a0954b2a5084a9c0e" translate="yes" xml:space="preserve">
          <source>If nothing is stated, the &lt;em&gt;dependent-name&lt;/em&gt; will be considered to be either a variable, or a function.</source>
          <target state="translated">何も指定されていない場合、 &lt;em&gt;dependent-name&lt;/em&gt;は変数または関数のいずれかと見なされます。</target>
        </trans-unit>
        <trans-unit id="248aa3b12203e10552b3af6c402294330055100c" translate="yes" xml:space="preserve">
          <source>If this was a Hollywood film, &lt;em&gt;dependent-names&lt;/em&gt; would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.</source>
          <target state="translated">これがハリウッド映画である場合、 &lt;em&gt;扶養家族の名前&lt;/em&gt;は身体との接触を通じて広がる病気であり、即座にホストに影響を与えて混乱させます。 混乱を招く可能性があり、形式が正しくない、erhm ..プログラムにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="0bd90018a85e97f771d15515f6a3373c341702f0" translate="yes" xml:space="preserve">
          <source>If we instantiate the function-template with type &lt;em&gt;X&lt;/em&gt;, as in (&lt;em&gt;C&lt;/em&gt;), we will have a declaration of a &lt;em&gt;pointer-to int&lt;/em&gt; named &lt;em&gt;x&lt;/em&gt;, but;</source>
          <target state="translated">（ &lt;em&gt;C&lt;/em&gt; ）のように、関数テンプレートを&lt;em&gt;X&lt;/em&gt;型でインスタンス化すると、 &lt;em&gt;x&lt;/em&gt;という名前の&lt;em&gt;intへのポインターが&lt;/em&gt;宣言され&lt;em&gt;ます&lt;/em&gt;が、</target>
        </trans-unit>
        <trans-unit id="ef47c5e71f44563ae042e5301468f27ca3a50614" translate="yes" xml:space="preserve">
          <source>Imagine what happens if we had a member function &lt;code&gt;h&lt;/code&gt; within the above defined &lt;code&gt;A&lt;/code&gt; class template</source>
          <target state="translated">上記で定義された &lt;code&gt;A&lt;/code&gt; クラステンプレート内にメンバー関数 &lt;code&gt;h&lt;/code&gt; があるとどうなるか想像してみてください</target>
        </trans-unit>
        <trans-unit id="231bd1ef6bfd0592631e7e9517ce774ad2be57d2" translate="yes" xml:space="preserve">
          <source>In C++03, the language allowed to catch this error because there could never be a valid way to instantiate &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; (whatever argument you give to &lt;code&gt;T&lt;/code&gt;). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since &lt;code&gt;A&lt;/code&gt; has no dependent base classes, and &lt;code&gt;A&lt;/code&gt; declares no member &lt;code&gt;questionable_type&lt;/code&gt;, the name &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; is &lt;em&gt;neither&lt;/em&gt; a member of the current instantiation &lt;em&gt;nor&lt;/em&gt; a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).</source>
          <target state="translated">C ++ 03では、 &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; をインスタンス化する有効な方法がないため（ Tにどの引数を指定しても）、言語はこのエラーをキャッチできました。 C ++ 11では、コンパイラーがこの規則を実装する理由を増やすために、言語にさらにチェックが追加されました。 &lt;code&gt;A&lt;/code&gt; には依存基本クラスがなく、 Aは &lt;code&gt;questionable_type&lt;/code&gt; メンバーを宣言していないため、名前 &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; は現在のインスタンス化のメンバーでも不明な特殊化のメンバーで&lt;em&gt;もありません&lt;/em&gt; 。 その場合、インスタンス化時にそのコードが有効にコンパイルされる方法はないはずです。そのため、言語は、修飾子が現在のインスタンス化である名前が、不明な特殊化のメンバーでも現在のインスタンス化のメンバーでもないことを禁止しています（ただし、 、この違反はまだ診断する必要はありません）。</target>
        </trans-unit>
        <trans-unit id="0883b2e93b7c95f02702247700ebd9bfd0ecb687" translate="yes" xml:space="preserve">
          <source>In a template that we write, there are two kinds of names that could be used - dependant names and non- dependant names. A dependant name is a name that depends on a template parameter; a non-dependant name has the same meaning irrespective of what the template parameters are.</source>
          <target state="translated">テンプレートを作成する際には、依存名と非依存名の2種類の名前を使用することができます。依存名とはテンプレートパラメータに依存する名前のことで、非依存名はテンプレートパラメータに関係なく同じ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="55037dd35e4322e33ec43f44ef797ca6cfa06004" translate="yes" xml:space="preserve">
          <source>In enough cases we need both of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;. Your code should look like the following</source>
          <target state="translated">十分な場合には、 &lt;code&gt;typename&lt;/code&gt; と &lt;code&gt;template&lt;/code&gt; の両方が必要です。 コードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e25768be4a82668492653e98728599e15bc1b3b6" translate="yes" xml:space="preserve">
          <source>In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:</source>
          <target state="translated">C++プログラムを解析するには、コンパイラは特定の名前が型であるかどうかを知る必要があります。次の例はそれを示しています。</target>
        </trans-unit>
        <trans-unit id="723e24157fedb66459b8cb1e919fabf2d210f132" translate="yes" xml:space="preserve">
          <source>In some cases, the keywords are forbidden, as detailed below</source>
          <target state="translated">以下のように、禁止されているキーワードがある場合もあります。</target>
        </trans-unit>
        <trans-unit id="6ff2869a81645404d269012800fd47e944df1110" translate="yes" xml:space="preserve">
          <source>In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to &lt;em&gt;depend&lt;/em&gt; on template parameters.</source>
          <target state="translated">テンプレート宣言では、テンプレートをインスタンス化するために使用するテンプレート引数に応じて、一部の構成要素の意味が異なります。式の型または値が異なる場合や、変数の型が異なる場合や、関数呼び出しが異なる関数を呼び出す場合があります。 このような構成は、一般にテンプレートパラメータに&lt;em&gt;依存する&lt;/em&gt;と言われています。</target>
        </trans-unit>
        <trans-unit id="607a8c1883367af22aab7a8e02fcba22f562537c" translate="yes" xml:space="preserve">
          <source>In templates, where and why do I have to put &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; on dependent names? What exactly are dependent names anyway? I have the following code:</source>
          <target state="translated">テンプレートでは、依存名に &lt;code&gt;typename&lt;/code&gt; 名と &lt;code&gt;template&lt;/code&gt; を配置する必要があるのはなぜですか？ とにかく依存名は正確には何ですか？ 私は次のコードを持っています：</target>
        </trans-unit>
        <trans-unit id="f50b1a4caa717e4ce30b40c50fdb5ffda75c32a7" translate="yes" xml:space="preserve">
          <source>In the code of &lt;code&gt;D&lt;/code&gt;, the name &lt;code&gt;typename D::questionable_type&lt;/code&gt; is not a member of the current instantiation. Instead the language marks it as a &lt;em&gt;member of an unknown specialization&lt;/em&gt;. In particular, this is always the case when you are doing &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; or &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; and either the dependent type is &lt;em&gt;not&lt;/em&gt; the current instantiation (in which case the compiler can give up and say &quot;we will look later what &lt;code&gt;Foo&lt;/code&gt; is) or it &lt;em&gt;is&lt;/em&gt; the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes.</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; のコードでは、名前 &lt;code&gt;typename D::questionable_type&lt;/code&gt; は現在のインスタンス化のメンバーではありません。 その代わり、言語はそれを&lt;em&gt;未知の専門分野のメンバー&lt;/em&gt;としてマークします。 特に、これは、 &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; または &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; を実行していて、依存型が現在のインスタンス化では&lt;em&gt;ない&lt;/em&gt;場合に常に当てはまります（この場合、コンパイラはあきらめて、「 &lt;code&gt;Foo&lt;/code&gt; の内容を後で調べます」 ）または、それ&lt;em&gt;が&lt;/em&gt;現在のインスタンス化であり、その名前がそのインスタンスまたはその非依存基本クラスで見つからず、依存基本クラスもある</target>
        </trans-unit>
        <trans-unit id="a7ada29808422dbb9e24960c66d91349f17c4800" translate="yes" xml:space="preserve">
          <source>In using-declarations it's not possible to use &lt;code&gt;template&lt;/code&gt; after the last &lt;code&gt;::&lt;/code&gt;, and the C++ committee &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot;&gt;said&lt;/a&gt; not to work on a solution.</source>
          <target state="translated">宣言を使用する場合、最後の &lt;code&gt;::&lt;/code&gt; の後に &lt;code&gt;template&lt;/code&gt; を使用することはできません。C++委員会&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot;&gt;は&lt;/a&gt; 、解決策に取り組んでいないと述べました。</target>
        </trans-unit>
        <trans-unit id="8421611d7923291b6537ffa9a5516e093fd2bf26" translate="yes" xml:space="preserve">
          <source>It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of &lt;code&gt;boost::function&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">それは人間の読者には明白に見えるかもしれません。 コンパイラはそうではありません。 次の &lt;code&gt;boost::function&lt;/code&gt; および &lt;code&gt;f&lt;/code&gt; の任意の定義を想像してください。</target>
        </trans-unit>
        <trans-unit id="ef82f45cfb61fb4fecf8d59ce0e78f98cd2cc2f4" translate="yes" xml:space="preserve">
          <source>It might not be as easy as one thinks, more specifically the result of evaluating (&lt;em&gt;A&lt;/em&gt;) heavily &lt;em&gt;depends&lt;/em&gt; on the definition of the type passed as template-parameter &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">それは人が考えるほど簡単ではないかもしれません。より具体的には、（ &lt;em&gt;A&lt;/em&gt; ）を評価した結果は、テンプレートパラメーター &lt;code&gt;T&lt;/code&gt; として渡される型の定義に大きく&lt;em&gt;依存&lt;/em&gt;します。</target>
        </trans-unit>
        <trans-unit id="73f2eedcc9728afac38f277e768bc709f16765a2" translate="yes" xml:space="preserve">
          <source>Most of the rules are intuitive and are built up recursively: For example, a type constructed as &lt;code&gt;T[N]&lt;/code&gt; is a dependent type if &lt;code&gt;N&lt;/code&gt; is a value-dependent expression or &lt;code&gt;T&lt;/code&gt; is a dependent type. The details of this can be read in section &lt;code&gt;(14.6.2/1&lt;/code&gt;) for dependent types, &lt;code&gt;(14.6.2.2)&lt;/code&gt; for type-dependent expressions and &lt;code&gt;(14.6.2.3)&lt;/code&gt; for value-dependent expressions.</source>
          <target state="translated">ほとんどのルールは直感的で、再帰的に構築されます。たとえば、 &lt;code&gt;N&lt;/code&gt; が値依存の式であるか &lt;code&gt;T&lt;/code&gt; が依存型である場合、 &lt;code&gt;T[N]&lt;/code&gt; として構築された型は依存型です。 この詳細は、依存型についてはセクション &lt;code&gt;(14.6.2/1&lt;/code&gt; &lt;code&gt;(14.6.2.2)&lt;/code&gt; 、型依存式については &lt;code&gt;(14.6.2.3)&lt;/code&gt; 、値依存式については（14.6.2.3）で読むことができます。</target>
        </trans-unit>
        <trans-unit id="d33e5e8480f354dad4b6ad9367f25a40c9f9bdaa" translate="yes" xml:space="preserve">
          <source>Neither of statement (&lt;em&gt;E&lt;/em&gt;), (&lt;em&gt;F&lt;/em&gt;) or (&lt;em&gt;G&lt;/em&gt;) is valid if the compiler would interpret the &lt;em&gt;dependent-names&lt;/em&gt; as variables/functions (which as stated earlier is what happens if we don't explicitly say otherwise).</source>
          <target state="translated">コンパイラーが&lt;em&gt;従属名&lt;/em&gt;を変数/関数として解釈する場合、ステートメント（ &lt;em&gt;E&lt;/em&gt; ）、（ &lt;em&gt;F&lt;/em&gt; ）、または（ &lt;em&gt;G&lt;/em&gt; ）のいずれも無効です（前に述べたように、明示的に別段の指定がない場合に起こります）。</target>
        </trans-unit>
        <trans-unit id="d32a29935d2bd59d7cfd39a6135dbe57c5e8fc66" translate="yes" xml:space="preserve">
          <source>Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example &lt;code&gt;f((T)0)&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt; is a dependent name. In the Standard, this is specified at &lt;code&gt;(14.6.2/1)&lt;/code&gt;.</source>
          <target state="translated">主にこの記事の問題ではありませんが、言及する価値があります。関数名は、個別に処理される例外です。 識別子関数名はそれ自体ではなく、呼び出しで使用される型依存の引数式に依存します。 例 &lt;code&gt;f((T)0)&lt;/code&gt; では、 &lt;code&gt;f&lt;/code&gt; は依存名です。 規格では、これは &lt;code&gt;(14.6.2/1)&lt;/code&gt; で指定されています。</target>
        </trans-unit>
        <trans-unit id="7c3acfb0745ac40f78ce00a50115e3da33af5010" translate="yes" xml:space="preserve">
          <source>Note that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don't have to specify &lt;code&gt;typename&lt;/code&gt;, for example:</source>
          <target state="translated">これは、メタ関数や、一般的なテンプレートパラメータを取るものにも適用されることに注意してください。 ただし、提供されたテンプレートパラメータが明示的なタイプである場合は、たとえば &lt;code&gt;typename&lt;/code&gt; を指定する必要はありません。</target>
        </trans-unit>
        <trans-unit id="4a8107ce35efcfc3379410e30c887b0716e8c000" translate="yes" xml:space="preserve">
          <source>Now we are back to the same problem as with &lt;code&gt;typename&lt;/code&gt;. What if we can't know yet whether the name is a template when parsing the code? We will need to insert &lt;code&gt;template&lt;/code&gt; immediately before the template name, as specified by &lt;code&gt;14.2/4&lt;/code&gt;. This looks like:</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; と同じ問題に戻ります。 コードを解析するときに、名前がテンプレートであるかどうかまだわからない場合はどうなりますか？ &lt;code&gt;14.2/4&lt;/code&gt; で指定されているように、テンプレート名の直前に &lt;code&gt;template&lt;/code&gt; を挿入する必要があります。 これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="247f001f459a71cf2ba6a5da92513d6caf7363e0" translate="yes" xml:space="preserve">
          <source>On the name of a dependent base class you are not allowed to write &lt;code&gt;typename&lt;/code&gt;. It's assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</source>
          <target state="translated">依存基本クラスの名前では、 &lt;code&gt;typename&lt;/code&gt; を書き込むことはできません。 指定された名前はクラス型名であると想定されています。 これは、基本クラスリストの名前とコンストラクタ初期化リストの両方に当てはまります。</target>
        </trans-unit>
        <trans-unit id="a512f0af9594fedb9079383ef813cc685035c26f" translate="yes" xml:space="preserve">
          <source>PS2: Have a look at &lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot;&gt;typelists&lt;/a&gt;, notably in Andrei Alexandrescu's book: Modern C++ Design</source>
          <target state="translated">PS2：特にAndrei Alexandrescuの本「Modern C ++ Design」で&lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot;&gt;タイプリストを&lt;/a&gt;見てください</target>
        </trans-unit>
        <trans-unit id="bdbe5508b19afff8cb57579196c6516007ea9aae" translate="yes" xml:space="preserve">
          <source>PS: Have a look at &lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot;&gt;Boost::Variant&lt;/a&gt;</source>
          <target state="translated">PS： &lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot;&gt;Boost :: Variantをご覧ください&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="3df155aafc1a199cca8ef6beb1b1d48c331e2365" translate="yes" xml:space="preserve">
          <source>Remember the initial quote above and how the Standard requires special handling for templates as well? Let's take the following innocent-looking example:</source>
          <target state="translated">上の最初の引用文で、スタンダードではテンプレートに対しても特別な処理が必要とされていることを覚えていますか?次の無邪気な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="6ba008a6093affa2d41cdad9748159bc5cb6d20a" translate="yes" xml:space="preserve">
          <source>So there has to be a way to tell the compiler that certain names are types and that certain names aren't.</source>
          <target state="translated">だから、コンパイラに特定の名前が型で、特定の名前が型でないことを伝える方法が必要です。</target>
        </trans-unit>
        <trans-unit id="660674432116072d61b4a75c7efcf588fe3e6c94" translate="yes" xml:space="preserve">
          <source>Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.</source>
          <target state="translated">名前の中には、型やテンプレートを表すものもあります。一般的に、名前に遭遇したときはいつでも、その名前がこれらのエンティティのいずれかを表しているかどうかを判断してから、その名前を含むプログラムの解析を続行する必要があります。これを決定する処理を名前検索と呼びます。</target>
        </trans-unit>
        <trans-unit id="8d79f76b53e088ead8ed9ed664f087d2b54ea07d" translate="yes" xml:space="preserve">
          <source>THE RATIONALE</source>
          <target state="translated">ラショナル</target>
        </trans-unit>
        <trans-unit id="1e7bff13be2789a80f543841f8ca934baeda8abf" translate="yes" xml:space="preserve">
          <source>THE SOLUTION</source>
          <target state="translated">解決策</target>
        </trans-unit>
        <trans-unit id="7d4bf11f65a833a43805734fc518cd4aba4e3ae0" translate="yes" xml:space="preserve">
          <source>Template names can not only occur after a &lt;code&gt;::&lt;/code&gt; but also after a &lt;code&gt;-&amp;gt;&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; in a class member access. You need to insert the keyword there too:</source>
          <target state="translated">テンプレート名は、 &lt;code&gt;::&lt;/code&gt; の後だけでなく、 &lt;code&gt;-&amp;gt;&lt;/code&gt; または &lt;code&gt;.&lt;/code&gt; 後にも使用できます。 クラスメンバーアクセス。 そこにもキーワードを挿入する必要があります：</target>
        </trans-unit>
        <trans-unit id="7e2e37676af9900b6b7d7b80a6d076dd3efe6361" translate="yes" xml:space="preserve">
          <source>That way the compiler will parse this properly rather than &lt;code&gt;t.get &amp;lt; int&lt;/code&gt;.</source>
          <target state="translated">これにより、コンパイラーは &lt;code&gt;t.get &amp;lt; int&lt;/code&gt; ではなく、これを適切に解析します。</target>
        </trans-unit>
        <trans-unit id="836511d1cb4791ee6d0d13c95ea85a78fe3910de" translate="yes" xml:space="preserve">
          <source>That's actually a valid &lt;em&gt;expression&lt;/em&gt;! It uses the less-than operator to compare &lt;code&gt;boost::function&lt;/code&gt; against zero (&lt;code&gt;int()&lt;/code&gt;), and then uses the greater-than operator to compare the resulting &lt;code&gt;bool&lt;/code&gt; against &lt;code&gt;f&lt;/code&gt;. However as you might well know, &lt;code&gt;boost::function&lt;/code&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot;&gt;in real life&lt;/a&gt; is a template, so the compiler knows (14.2/3):</source>
          <target state="translated">それは実際には有効な&lt;em&gt;式&lt;/em&gt;です！ 小なり演算子を使用して &lt;code&gt;boost::function&lt;/code&gt; とゼロ（ &lt;code&gt;int()&lt;/code&gt; ）を比較し、大なり演算子を使用して結果の &lt;code&gt;bool&lt;/code&gt; を &lt;code&gt;f&lt;/code&gt; と比較します。 ただし、ご存知かもしれませんが&lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot;&gt;、実際の&lt;/a&gt; &lt;code&gt;boost::function&lt;/code&gt; はテンプレートであるため、コンパイラーは（14.2 / 3）を認識します。</target>
        </trans-unit>
        <trans-unit id="f35b88a4738b3645c1aef372f59ad3047b158b13" translate="yes" xml:space="preserve">
          <source>That's impressive, but can we do better? The language even goes further and &lt;em&gt;requires&lt;/em&gt; that an implementation again looks up &lt;code&gt;D::result_type&lt;/code&gt; when instantiating &lt;code&gt;D::f&lt;/code&gt; (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined &lt;code&gt;C&lt;/code&gt; like this</source>
          <target state="translated">それは印象的ですが、もっとうまくできるでしょうか？ 言語はさらに進んで、 &lt;code&gt;D::f&lt;/code&gt; インスタンス化するときに、実装が再度 &lt;code&gt;D::result_type&lt;/code&gt; 検索&lt;em&gt;する&lt;/em&gt;ことを&lt;em&gt;要求&lt;/em&gt;します（定義時にすでにその意味が見つかった場合でも）。 ルックアップ結果が異なる場合やあいまいな結果になった場合、プログラムの形式が正しくなく、診断を行う必要があります。 このように &lt;code&gt;C&lt;/code&gt; を定義するとどうなるか想像してみてください</target>
        </trans-unit>
        <trans-unit id="397b3aa358a31ed91afc3c84c5752f5669f499b0" translate="yes" xml:space="preserve">
          <source>The &quot;template&quot; keyword</source>
          <target state="translated">テンプレート」というキーワード</target>
        </trans-unit>
        <trans-unit id="ab32972d5ca051abc115a7572997071871b757ac" translate="yes" xml:space="preserve">
          <source>The &quot;typename&quot; keyword</source>
          <target state="translated">タイプネーム」キーワード</target>
        </trans-unit>
        <trans-unit id="059c8dc482f6fcec095abfac5e21cf05f38aaecd" translate="yes" xml:space="preserve">
          <source>The C++ Standard cares about our safety and well-being, at least in this case.</source>
          <target state="translated">C++規格は、少なくともこの場合、私たちの安全と幸福を気にかけています。</target>
        </trans-unit>
        <trans-unit id="75d71f350625c9208a970a84d0f2647c18d12e3d" translate="yes" xml:space="preserve">
          <source>The C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)</source>
          <target state="translated">C++11 の規則では、以下の有効な C++03 コードが不定形になっています(これは C++委員会が意図したものではありませんが、おそらく修正されることはないでしょう)。</target>
        </trans-unit>
        <trans-unit id="d678b7bdd1a0680bb6cb738cb7515a1010d81457" translate="yes" xml:space="preserve">
          <source>The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:</source>
          <target state="translated">標準は、構成要素が依存しているかどうかというルールを正確に定義しています。それを論理的に異なるグループに分けています。1つは型を、もう1つは式をキャッチします。式は、値や型によって依存することがあります。そのため、典型的な例が追加されています。</target>
        </trans-unit>
        <trans-unit id="9cfd62de43ae793e4b5c0bbaea489055b29010a9" translate="yes" xml:space="preserve">
          <source>The Standard is a bit unclear about what &lt;em&gt;exactly&lt;/em&gt; is a &lt;em&gt;dependent name&lt;/em&gt;. On a simple read (you know, the principle of least surprise), all it defines as a &lt;em&gt;dependent name&lt;/em&gt; is the special case for function names below. But since clearly &lt;code&gt;T::x&lt;/code&gt; also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition).</source>
          <target state="translated">標準は、 &lt;em&gt;依存名&lt;/em&gt;とは&lt;em&gt;正確に&lt;/em&gt;は何について明確ではあり&lt;em&gt;ません&lt;/em&gt; 。 単純な読み取り（ご存知のとおり、最小の驚きの原則）では、 &lt;em&gt;依存名&lt;/em&gt;として定義されているのは、以下の関数名の特殊なケースです。 しかし、明らかに &lt;code&gt;T::x&lt;/code&gt; もインスタンス化のコンテキストで検索する必要があるため、依存名にする必要もあります（幸い、C ++ 14の半ばから、委員会はこの紛らわしい定義を修正する方法を検討し始めました）。 。</target>
        </trans-unit>
        <trans-unit id="eaeb296948f681fa8c069b722bff11d7272cc610" translate="yes" xml:space="preserve">
          <source>The answer is: &lt;em&gt;We&lt;/em&gt; decide how the compiler should parse this. If &lt;code&gt;t::x&lt;/code&gt; is a dependent name, then we need to prefix it by &lt;code&gt;typename&lt;/code&gt; to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):</source>
          <target state="translated">答えは、コンパイラがこれをどのように解析するか&lt;em&gt;を&lt;/em&gt;決定することです。 &lt;code&gt;t::x&lt;/code&gt; が依存名である場合、コンパイラーに特定の方法で解析するように指示するには、 &lt;code&gt;typename&lt;/code&gt; を前に付ける必要があります。 標準は（14.6 / 2）で述べています：</target>
        </trans-unit>
        <trans-unit id="e839e7bc0fb3047c1bdf6c7dbb6e9ae237507034" translate="yes" xml:space="preserve">
          <source>The general rule for putting the &lt;code&gt;typename&lt;/code&gt; keyword is mostly when you're using a template parameter and you want to access a nested &lt;code&gt;typedef&lt;/code&gt; or using-alias, for example:</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; キーワードを配置するための一般的なルールは、主にテンプレートパラメータを使用していて、ネストされた &lt;code&gt;typedef&lt;/code&gt; またはusing-aliasにアクセスする場合です。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="cfc3f7e0b4137c99807273a259f51ca22659ff99" translate="yes" xml:space="preserve">
          <source>The general rules for adding the &lt;code&gt;template&lt;/code&gt; qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 修飾子を追加するための一般的なルールは、それ自体がテンプレート化された構造体/クラスのテンプレート化されたメンバー関数（静的またはその他）を通常含むことを除いて、ほとんど同じです。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="83fdb65b86514ecc3d94eb5034b2904b19fc4647" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; doesn't always have to appear in the last part of a name. It can appear in the middle before a class name that's used as a scope, like in the following example</source>
          <target state="translated">キーワード &lt;code&gt;template&lt;/code&gt; は、必ずしも名前の最後の部分に表示される必要はありません。 次の例のように、スコープとして使用されるクラス名の前の中央に表示できます</target>
        </trans-unit>
        <trans-unit id="ea5c129366ce9cd9ab21f5cd93e125ca28bbc280" translate="yes" xml:space="preserve">
          <source>The keywords &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;em&gt;still&lt;/em&gt; a type-dependent name (after all &lt;code&gt;T&lt;/code&gt; is also type dependent). But &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; is known to be a type - the compiler will &quot;magically&quot; look into this kind of dependent types to figure this out.</source>
          <target state="translated">修飾子が現在のインスタンス化のメンバーである場合、キーワード &lt;code&gt;typename&lt;/code&gt; および &lt;code&gt;template&lt;/code&gt; は不要になりました。 ここで覚えておくべき重要な点は、 &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; は&lt;em&gt;まだ&lt;/em&gt;タイプ依存の名前であることです（すべての &lt;code&gt;T&lt;/code&gt; もタイプ依存です）。 ただし、 &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; は型であることがわかっています。コンパイラは、この種類の依存型を「魔法のように」調べて、これを理解します。</target>
        </trans-unit>
        <trans-unit id="077f4f3cb3b45d6c4da04d629251c33c46d6451d" translate="yes" xml:space="preserve">
          <source>The problem I have is in the &lt;code&gt;typedef Tail::inUnion&amp;lt;U&amp;gt; dummy&lt;/code&gt; line. I'm fairly certain that &lt;code&gt;inUnion&lt;/code&gt; is a dependent name, and VC++ is quite right in choking on it. I also know that I should be able to add &lt;code&gt;template&lt;/code&gt; somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. &lt;code&gt;inUnion&amp;lt;U&amp;gt;&lt;/code&gt; names a type and not a function?</source>
          <target state="translated">私が持っている問題は、 &lt;code&gt;typedef Tail::inUnion&amp;lt;U&amp;gt; dummy&lt;/code&gt; 行にあります。 私は &lt;code&gt;inUnion&lt;/code&gt; が依存名であることをかなり確信しています。VC ++はそれを窒息させるのに非常に適切です。 また、 &lt;code&gt;template&lt;/code&gt; どこかに追加して、コンパイラーにinUnionがテンプレートIDであることを伝えることができるはずです。 しかし、正確にはどこですか？ そして、それは、inUnionがクラステンプレートであると想定する必要があります。つまり、 &lt;code&gt;inUnion&amp;lt;U&amp;gt;&lt;/code&gt; は関数ではなく型を指定しますか？</target>
        </trans-unit>
        <trans-unit id="f1c7bae603744472346dadfc7ea4dedeef3d82c9" translate="yes" xml:space="preserve">
          <source>The rules in the Standard states that you may apply the keywords as long as you are dealing with a &lt;em&gt;qualified-name&lt;/em&gt; (&lt;em&gt;K&lt;/em&gt;), but if the name isn't &lt;em&gt;qualified&lt;/em&gt; the application is ill-formed (&lt;em&gt;L&lt;/em&gt;).</source>
          <target state="translated">規格の規則では、 &lt;em&gt;修飾名&lt;/em&gt; （ &lt;em&gt;K&lt;/em&gt; ）を扱っている限り、キーワードを適用することができますが、名前が&lt;em&gt;修飾され&lt;/em&gt;ていない場合、アプリケーションの形式は正しくありません（ &lt;em&gt;L&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2bd5a78638dcace559982a14bbcc8b023fd7f274" translate="yes" xml:space="preserve">
          <source>The underlying purpose is the same; an explanation to &quot;When?&quot; and &quot;Why?&quot; &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; must be applied.</source>
          <target state="translated">基本的な目的は同じです。 「いつ？」への説明 なぜ？&quot; &lt;code&gt;typename&lt;/code&gt; と &lt;code&gt;template&lt;/code&gt; 適用する必要があります。</target>
        </trans-unit>
        <trans-unit id="10f33cad8fd8a2837a1e5c87042e16251d5742a6" translate="yes" xml:space="preserve">
          <source>There are certain contexts in &lt;em&gt;C++&lt;/em&gt; where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one &lt;em&gt;template-parameter&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;C ++&lt;/em&gt;には、名前の処理方法をコンパイラーに明示的に通知する必要がある特定のコンテキストがあり、これらのコンテキストにはすべて1つの共通点があります。 それらは少なくとも1つの&lt;em&gt;template-parameter&lt;/em&gt;に依存し&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4b3c376a5c02c3331f13cc34e60d67e0eda12a9" translate="yes" xml:space="preserve">
          <source>There are many names for which &lt;code&gt;typename&lt;/code&gt; is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with &lt;code&gt;T *f;&lt;/code&gt;, when &lt;code&gt;T&lt;/code&gt; is a type template parameter. But for &lt;code&gt;t::x * f;&lt;/code&gt; to be a declaration, it must be written as &lt;code&gt;typename t::x *f;&lt;/code&gt;. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:</source>
          <target state="translated">コンパイラーは、テンプレート定義で適切な名前を検索することで、たとえば &lt;code&gt;T *f;&lt;/code&gt; を使用して構文自体を解析する方法を理解できるため、 &lt;code&gt;typename&lt;/code&gt; が不要な多くの名前があります。 、 &lt;code&gt;T&lt;/code&gt; がタイプテンプレートパラメータの場合。 しかし、 &lt;code&gt;t::x * f;&lt;/code&gt; 宣言であるためには、 &lt;code&gt;typename t::x *f;&lt;/code&gt; として記述する必要があります。 。 キーワードを省略し、名前が非タイプであると解釈されたが、インスタンス化によってタイプが示されていることが検出されると、通常のエラーメッセージがコンパイラによって出力されます。 場合によっては、結果的に定義時にエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="193f977dcab6c47bd2d6b8470ad6dcab7bd03b03" translate="yes" xml:space="preserve">
          <source>This post is meant to be an &lt;em&gt;easy-to-read&lt;/em&gt; alternative to &lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;litb's post&lt;/a&gt;.</source>
          <target state="translated">この投稿は、 &lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;litbの投稿の&lt;/a&gt; &lt;em&gt;読みやすい&lt;/em&gt;代替になることを目的としています。</target>
        </trans-unit>
        <trans-unit id="f5a4896926029b3eb852f0d6a106ca34a09f5713" translate="yes" xml:space="preserve">
          <source>This post will offer an explanation to the relationship between &lt;em&gt;dependent-names&lt;/em&gt;, and the two keywords.</source>
          <target state="translated">この投稿では、 &lt;em&gt;dependent-names&lt;/em&gt;と2つのキーワードの関係について説明します。</target>
        </trans-unit>
        <trans-unit id="8d3949e28211d7534133207cc300ac1efaad60d9" translate="yes" xml:space="preserve">
          <source>This valid C++03 code would bind &lt;code&gt;this-&amp;gt;f&lt;/code&gt; to &lt;code&gt;A::f&lt;/code&gt; at instantiation time and everything is fine. C++11 however immediately binds it to &lt;code&gt;B::f&lt;/code&gt; and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt;, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot;&gt;Dominance Rule&lt;/a&gt; applies and lookup will find &lt;code&gt;A::f&lt;/code&gt; instead.</source>
          <target state="translated">この有効なC ++ 03コードは、インスタンス化時に &lt;code&gt;this-&amp;gt;f&lt;/code&gt; を &lt;code&gt;A::f&lt;/code&gt; バインドし、すべて正常です。 ただし、C ++ 11はそれをすぐに &lt;code&gt;B::f&lt;/code&gt; にバインドし、インスタンス化するときに、ルックアップがまだ一致するかどうかを確認するためのダブルチェックを必要とします。 ただし、 &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt; インスタンス化すると、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot;&gt;支配ルールが&lt;/a&gt;適用され、代わりに &lt;code&gt;A::f&lt;/code&gt; が検索されます。</target>
        </trans-unit>
        <trans-unit id="a29f6a4158f73a5ee76b40bdb5725dddd2048562" translate="yes" xml:space="preserve">
          <source>This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template's text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template's users (poor colleagues!) with errors made by a template's author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place.</source>
          <target state="translated">これは動作し、実際に実装アプローチとして標準で認められています。これらのコンパイラは基本的にテンプレートのテキストを内部バッファにコピーし、インスタンス化が必要なときだけテンプレートを解析し、おそらく定義のエラーを検出します。しかし、テンプレートの作成者によるエラーでテンプレートのユーザ(かわいそうな同僚!)を悩ませる代わりに、他の実装では、早い段階でテンプレートをチェックし、インスタンス化が行われる前に、できるだけ早く定義のエラーを与えることを選択しています。</target>
        </trans-unit>
        <trans-unit id="ddec0732ccbb4210a2b6b99783ad2631b52a9cc7" translate="yes" xml:space="preserve">
          <source>Thus in this context you would need the &lt;code&gt;template&lt;/code&gt; keyword beforehand and call it like so:</source>
          <target state="translated">したがって、このコンテキストでは、事前に &lt;code&gt;template&lt;/code&gt; キーワードが必要であり、次のように呼び出します。</target>
        </trans-unit>
        <trans-unit id="3090538eec535ec4cf723c65f5b6a6ba58cdbe5b" translate="yes" xml:space="preserve">
          <source>To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore &quot;dependent names&quot;. A name can take different forms - the Standard says:</source>
          <target state="translated">この問題を避けるために、私は標準テキストの単純な解釈に頼っています。従属型や式を表すすべての構成要素のうち、それらのサブセットは名前を表します。したがって、それらの名前は &quot;従属名 &quot;となります。名前はさまざまな形をとることができます。</target>
        </trans-unit>
        <trans-unit id="7698fca51994ddc6c138471b88e06e7c83afdd2d" translate="yes" xml:space="preserve">
          <source>To improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt;). A type referenced by such a name is known to be  the &lt;em&gt;current instantiation&lt;/em&gt;. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, &lt;code&gt;A::NestedClass&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are both current instantiations).</source>
          <target state="translated">状況を改善するために、C ++ 11では、型が外側のテンプレートを参照するときに言語が追跡されます。 それを知るために、型はそれ自体の名前である特定の形式の名前を使用して形成されている必要があります（上記では、 &lt;code&gt;A&lt;/code&gt; 、 &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; 、 &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt; ）。 そのような名前で参照される型は、 &lt;em&gt;現在のインスタンス化である&lt;/em&gt;ことがわかってい&lt;em&gt;ます&lt;/em&gt; 。 名前の形成元のタイプがメンバー/ネストされたクラスである場合（ &lt;code&gt;A::NestedClass&lt;/code&gt; と &lt;code&gt;A&lt;/code&gt; は両方とも現在のインスタンス化である）、すべてが現在のインスタンス化である複数のタイプがある場合があります。</target>
        </trans-unit>
        <trans-unit id="f8b8473f52f5d48a53b82b2e364a8ed8725c5fd0" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;g_tmpl&lt;/code&gt; have a valid definition we must explicitly tell the compiler that we expect a type in (&lt;em&gt;E&lt;/em&gt;), a &lt;em&gt;template-id&lt;/em&gt; and a &lt;em&gt;type&lt;/em&gt; in (&lt;em&gt;F&lt;/em&gt;), and a &lt;em&gt;template-id&lt;/em&gt; in (&lt;em&gt;G&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;g_tmpl&lt;/code&gt; に有効な定義を持たせるには、型（ &lt;em&gt;E&lt;/em&gt; ）、 &lt;em&gt;テンプレートID&lt;/em&gt;と&lt;em&gt;型&lt;/em&gt; &lt;em&gt;F&lt;/em&gt; （ &lt;em&gt;F&lt;/em&gt; ）、および&lt;em&gt;テンプレートID&lt;/em&gt; （ &lt;em&gt;G&lt;/em&gt; ）が必要であることをコンパイラに明示的に通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="af6ebf3891ffb2ee30f2bf8858408c64c95c34f1" translate="yes" xml:space="preserve">
          <source>To prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a &lt;em&gt;dependent-name&lt;/em&gt; by &lt;em&gt;explicitly&lt;/em&gt; stating the intent anywhere we'd like to treat the name as either a &lt;em&gt;type-name&lt;/em&gt;, or a &lt;em&gt;template-id&lt;/em&gt;.</source>
          <target state="translated">実装が厄介な驚きに見舞われる可能性を防ぐために、標準では、名前を&lt;em&gt;type-name&lt;/em&gt;または&lt;em&gt;テンプレートの&lt;/em&gt;いずれかとして扱いたい場所に意図を&lt;em&gt;明示的に&lt;/em&gt;示すことにより、 &lt;em&gt;依存名の&lt;/em&gt;あいまいさを整理することを義務付けています&lt;em&gt;id&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="29862938e768a917aab1960c6bbb6ae497b193e9" translate="yes" xml:space="preserve">
          <source>Try to explain what is going on in the following &lt;em&gt;function-template&lt;/em&gt;, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (&lt;em&gt;A&lt;/em&gt;)?</source>
          <target state="translated">次の&lt;em&gt;function-template&lt;/em&gt;で何が起こっているかを、自分自身、友人、またはおそらく猫に説明してみてください。 （ &lt;em&gt;A&lt;/em&gt; ）とマークされたステートメントで何が起こっていますか？</target>
        </trans-unit>
        <trans-unit id="87061df8bae25712e416ad7d53765e98b6719bd8" translate="yes" xml:space="preserve">
          <source>Type-dependent expressions (e.g: a cast to a type template parameter &lt;code&gt;(T)0&lt;/code&gt;)</source>
          <target state="translated">型に依存する式（例：型テンプレートパラメーター &lt;code&gt;(T)0&lt;/code&gt; へのキャスト）</target>
        </trans-unit>
        <trans-unit id="689c51725b427087666b6048cec59bcb29fcbece" translate="yes" xml:space="preserve">
          <source>Unknown specializations</source>
          <target state="translated">不明な専門分野</target>
        </trans-unit>
        <trans-unit id="6026daccdfec39543979697858424c64ff4ef007" translate="yes" xml:space="preserve">
          <source>Use the keyword typename only in template declarations and definitions provided you have a qualified name that refers to a type and depends on a template parameter.</source>
          <target state="translated">この機能を使用するには、以下の手順に従います。</target>
        </trans-unit>
        <trans-unit id="763d8d416b60f842f2c2cc144e23011113e885a1" translate="yes" xml:space="preserve">
          <source>Value-dependent expressions (e.g: a non-type template parameter &lt;code&gt;N&lt;/code&gt;)</source>
          <target state="translated">値に依存する式（例：非タイプテンプレートパラメータ &lt;code&gt;N&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ceaafeab5b0bb21207a924ae3fb0e737282cd5e7" translate="yes" xml:space="preserve">
          <source>We have four &lt;em&gt;dependent&lt;/em&gt; names in the above snippet:</source>
          <target state="translated">上記のスニペットには、4つの&lt;em&gt;依存&lt;/em&gt;名があります。</target>
        </trans-unit>
        <trans-unit id="526f7334186e1b9227cf705c33b09999cd0d98e8" translate="yes" xml:space="preserve">
          <source>We refer to such names, where there can be an ambiguity in interpretation, as; &quot;&lt;em&gt;dependent names&lt;/em&gt;&quot;.</source>
          <target state="translated">このような名前は、解釈が曖昧になる可能性がある場合、次のように参照します。 「 &lt;em&gt;依存名&lt;/em&gt; 」。</target>
        </trans-unit>
        <trans-unit id="bbecf5660dbaf8d8ded1b52887f0ecd3180d34c3" translate="yes" xml:space="preserve">
          <source>What a dependant name refers to could be something different for each different instantiation of the template. As a consequence, C++ templates are subject to &quot;two-phase name lookup&quot;. When a template is initially parsed (before any instantiation takes place) the compiler looks up the non-dependent names. When a particular instantiation of the template takes place, the template parameters are known by then, and the compiler looks up dependent names.</source>
          <target state="translated">このような場合は、「C++テンプレート」を使用して、テンプレートを作成してください。その結果、C++テンプレートは「2 段階の名前検索」の対象となります。テンプレートが最初に解析されるとき(インスタンス化が行われる前)、コンパイラは非依存名を検索します。テンプレートの特定のインスタンス化が行われると、テンプレート・パラメータはそれまでに判明しており、コンパイラは従属名を検索します。</target>
        </trans-unit>
        <trans-unit id="b8f6499ca71be3c23ce33c1b2a9f5b83685a4750" translate="yes" xml:space="preserve">
          <source>What's the purpose of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; と &lt;code&gt;template&lt;/code&gt; 目的は何ですか？</target>
        </trans-unit>
        <trans-unit id="bc52aff94964c77dc3a3b4fa138bce704fae73f4" translate="yes" xml:space="preserve">
          <source>Where and why do I have to put the “template” and “typename” keywords</source>
          <target state="translated">template &quot;と &quot;typename &quot;のキーワードはどこに、なぜ入れなければならないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="552a23a5cb320222a24f1cb81b66e05f546ad95e" translate="yes" xml:space="preserve">
          <source>While the rules in C++03 about when you need &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are largely reasonable, there is one annoying disadvantage of its formulation</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; と &lt;code&gt;template&lt;/code&gt; が必要な場合に関するC ++ 03のルールはほぼ妥当ですが、その定式化には1つの厄介な欠点があります。</target>
        </trans-unit>
        <trans-unit id="7b6897d54406a3105e58e6dc3fc5b5863dff0daa" translate="yes" xml:space="preserve">
          <source>You can try this knowledge on &lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;this answer&lt;/a&gt; and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).</source>
          <target state="translated">あなたは&lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;この答えで&lt;/a&gt;この知識を試し、上記の定義が実際の例であなたにとって意味があるかどうかを確認できます（それらはその答えで少し詳細が繰り返されています）。</target>
        </trans-unit>
        <trans-unit id="2efba1c1c4d9757ca6d366d4029d83dcd0b82fca" translate="yes" xml:space="preserve">
          <source>You might recommend to just wait till the user instantiates the template:</source>
          <target state="translated">ユーザーがテンプレートをインスタンス化するまで待つことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e48b0fa9b66fcdab66a1db676dd26515d8b3d55f" translate="yes" xml:space="preserve">
          <source>if we instantiate the template with type &lt;em&gt;Y&lt;/em&gt;, as in (&lt;em&gt;D&lt;/em&gt;), (&lt;em&gt;A&lt;/em&gt;) would instead consist of an expression that calculates the product of &lt;em&gt;123&lt;/em&gt; multiplied with some already declared variable &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">（ &lt;em&gt;D&lt;/em&gt; ）のようにタイプ&lt;em&gt;Y&lt;/em&gt;でテンプレートをインスタンス化する場合、（ &lt;em&gt;A&lt;/em&gt; ）は代わりに、 &lt;em&gt;123&lt;/em&gt;と既に宣言された変数&lt;em&gt;x&lt;/em&gt;の積を計算する式で構成されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
