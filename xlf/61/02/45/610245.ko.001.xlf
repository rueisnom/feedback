<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/610245">
    <body>
      <group id="610245">
        <trans-unit id="81a4752786ca04ed1a7662da3ad6fd89d03fdd33" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;Can I just stick &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; in front of any name? I don't want to worry about the context in which they appear...&lt;/em&gt;&quot; - &lt;code&gt;Some C++ Developer&lt;/code&gt;</source>
          <target state="translated">&quot; &lt;em&gt;어떤 이름 앞에도 형식 이름과 &lt;code&gt;template&lt;/code&gt; 을 붙일 수 있습니까? 문맥에 대해 걱정하고 싶지 않습니다 ...&lt;/em&gt; &quot;- &lt;code&gt;Some C++ Developer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da314107a76c971fe9203b881ca2d5dc651b90a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; however, is different in this regard, since there's no way of coming to a conclusion such as; &lt;em&gt;&quot;oh, this is a template, then this other thing must also be a template&quot;&lt;/em&gt;. This means that we apply &lt;code&gt;template&lt;/code&gt; directly in front of any &lt;em&gt;name&lt;/em&gt; that we'd like to treat as such.</source>
          <target state="translated">그러나 다음과 같은 결론을 내릴 방법이 없기 때문에 &lt;code&gt;template&lt;/code&gt; 은 이와 관련하여 다릅니다. &lt;em&gt;&quot;오, 이것은 템플릿이고,이 다른 것 또한 템플릿이어야합니다&quot;&lt;/em&gt; . 즉, 처리하려는 &lt;em&gt;이름&lt;/em&gt; 앞에 &lt;code&gt;template&lt;/code&gt; 직접 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3e6c4b85701f35fe30fbc34931dc03cfd7dda142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are usable in circumstances other than when declaring a template.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 선언 할 때가 아닌 다른 상황에서는 &lt;code&gt;typename&lt;/code&gt; 및 템플릿 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ca671f7a7070e1849b27be2dac38cb84d41ab25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Let's wait until the user instantiates the template, and then later find out the real meaning of &lt;code&gt;t::x * f;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;사용자가 템플릿을 인스턴스화 할 때까지 기다렸다가 나중에 &lt;code&gt;t::x * f;&lt;/code&gt; 의 실제 의미를 찾으십시오. : x * f;&lt;/em&gt; &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c04d03f78f58040504cd81e4dc96e86c59640a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The syntax allows &lt;code&gt;typename&lt;/code&gt; only before qualified names&lt;/em&gt; - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.</source>
          <target state="translated">&lt;em&gt;구문은 규정 된 이름 &lt;code&gt;typename&lt;/code&gt; &lt;/em&gt; 을 허용합니다. 규정되지 않은 이름은 항상 유형을 참조하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2ecf05f2de6fcde4001af850840dca6978b6c81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;NestedTrait&quot;&lt;/strong&gt;, which is a &lt;em&gt;template-id&lt;/em&gt;, depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;</source>
          <target state="translated">&lt;em&gt;template-id&lt;/em&gt; 인 &lt;strong&gt;&quot;NestedTrait&quot;&lt;/strong&gt; 은 &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; 에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="7c3fd61616ef25b7bad12ae0f45164811952b743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;data&quot;&lt;/strong&gt;, which looks like a &lt;em&gt;member-function template&lt;/em&gt;, is indirectly a &lt;em&gt;dependent-name&lt;/em&gt; since the type of &lt;em&gt;foo&lt;/em&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;foo&lt;/em&gt; 유형이 &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; 의 인스턴스화에 의존하기 때문에 &lt;em&gt;멤버 함수 템플리트&lt;/em&gt; 처럼 보이는 &lt;strong&gt;&quot;data&quot;&lt;/strong&gt; 는 간접적으로 &lt;em&gt;종속 이름&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="edbe9c0a9a43ae825a9c6f8aaaf224b3d281ad41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; at the end of (&lt;em&gt;F&lt;/em&gt;) depends on &lt;em&gt;NestedTrait&lt;/em&gt;, which depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;</source>
          <target state="translated">( &lt;em&gt;F&lt;/em&gt; ) 끝의 &lt;strong&gt;&quot;type&quot;&lt;/strong&gt; 은 &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; 에 의존하는 NestedTrait에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="8f60a89f51a419f36ed14856c476a0174be4ff9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, which include &lt;code&gt;T&lt;/code&gt;, and;</source>
          <target state="translated">&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; 은 &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; 를 포함하는 SomeTrait &amp;lt;T&amp;gt; 의 인스턴스화에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="6f469f6e1084fdb25863f628728d09a97794a167" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;E&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="42bb91b7ab5f09937d85eff1c421efa46f42ab8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;F&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;F&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="5d6b157f6a08ec9e0c665dc0de45a07bc5ee1a60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;G&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;G&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="82ccd28c2dcf130545ef823fe89eddf360a2a00f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PREFACE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PREFACE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23803dbe26e6085fd2fa0883c19d0f2f27666b33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The two different scenarios&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;두 가지 시나리오&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e811163b854bd2669c245ceb717edce8e12a537f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When specifying the bases of which a class inherits&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;클래스가 상속 할 기본을 지정할 때&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="330d5ed944055f18e28c9497441117f20c14e6e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When the &lt;em&gt;template-id&lt;/em&gt; is the one being referred to in a derived class's &lt;em&gt;using-directive&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;template-id&lt;/em&gt; 가 파생 클래스의 &lt;em&gt;using-directive에서 참조되는 경우&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="52b5f115a82e14ac063f13915cc23e1f11a5ebe8" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;This answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go &lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;이 답변은 제목이 지정된 질문에 (일부) 대답하기에 다소 짧고 달콤한 답변입니다.&lt;/em&gt;&lt;/sub&gt; &lt;sub&gt;&lt;em&gt;왜 거기에 배치해야하는지 설명하는 자세한 답변을 원하면 &lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;여기&lt;/a&gt; 로 이동 하십시오 .&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="1bfe14eb10ca361b9d4ba80c600e5e0629d33b7b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;Note&lt;/strong&gt;: Applying &lt;code&gt;typename&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt; in a context where it is not required is not considered good practice; just because you can do something, doesn't mean that you should.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;참고&lt;/strong&gt; : 형식 이름이나 &lt;code&gt;template&lt;/code&gt; 을 필요하지 않은 컨텍스트에 적용하는 것은 좋은 방법으로 간주되지 않습니다.&lt;/sup&gt; &lt;sup&gt;무언가를 할 수 있다고해서 꼭해야한다는 의미는 아닙니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d3e3594e08ca6cc46a536e175af0955c908fe709" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dependent-name&lt;/em&gt; is &lt;strong&gt;any&lt;/strong&gt; name that directly, or indirectly, depends on a &lt;em&gt;template-parameter&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;종속 이름&lt;/em&gt; 은 &lt;em&gt;template-parameter&lt;/em&gt; 에 직접 또는 간접적으로 의존 &lt;strong&gt;하는&lt;/strong&gt; 이름입니다.</target>
        </trans-unit>
        <trans-unit id="167311c32569b35652bc2a3316fd061fd6dd2919" translate="yes" xml:space="preserve">
          <source>A SNIPPET SAYS MORE THAN 1000 WORDS</source>
          <target state="translated">스 니펫은 1000 단어 이상을 말합니다</target>
        </trans-unit>
        <trans-unit id="83157225247456f23e8d3702295867eda13efdd9" translate="yes" xml:space="preserve">
          <source>A compiler is required to catch the error when instantiating &lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt;. So you get the best of the two worlds: &quot;Delayed&quot; lookup protecting you if you could get in trouble with dependent base classes, and also &quot;Immediate&quot; lookup that frees you from &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt; 인스턴스화 할 때 오류를 포착하려면 컴파일러가 필요합니다. 따라서 종속 된 기본 클래스에 문제가 생길 경우 보호하는 &quot;지연된&quot;조회와 &lt;code&gt;typename&lt;/code&gt; 및 &lt;code&gt;template&lt;/code&gt; 에서 벗어날 수있는 &quot;즉시&quot;조회가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c035f4cd7ec02fdb2cd82af3dcd6cec12757cd6b" translate="yes" xml:space="preserve">
          <source>A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)</source>
          <target state="translated">이름은 엔터티 또는 레이블 (6.6.4)을 나타내는 식별자 (2.11), operator-function-id (13.5), conversion-function-id (12.3.2) 또는 template-id (14.2)를 사용하는 것입니다. 6.1)</target>
        </trans-unit>
        <trans-unit id="23519716491bc53d4e57fd893f7debfe498cf6c9" translate="yes" xml:space="preserve">
          <source>A name used in a template declaration or definition and that is dependent on a template-parameter is
  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified
  by the keyword typename.</source>
          <target state="translated">템플리트 선언 또는 정의에 사용되며 템플리트 매개 변수에 종속 된 이름은 적용 가능한 이름 검색에서 유형 이름을 찾거나 이름이 키워드 typename에 의해 규정되지 않는 한 유형의 이름을 지정하지 않는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1ad1d6ae245142dbfde495564ae1bd48307233e1" translate="yes" xml:space="preserve">
          <source>A similar gotcha exists for names that denote templates, as hinted at by the introductory text.</source>
          <target state="translated">소개 텍스트에서 알 수 있듯이 템플릿을 나타내는 이름에 대해서도 비슷한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f4d2698ac7315f563034d04e68543b3fea1b1a3" translate="yes" xml:space="preserve">
          <source>A value dependent expression &lt;code&gt;1 + N&lt;/code&gt; is not a name, but &lt;code&gt;N&lt;/code&gt; is. The subset of all dependent constructs that are names is called &lt;em&gt;dependent name&lt;/em&gt;. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule.</source>
          <target state="translated">값 종속 표현식 &lt;code&gt;1 + N&lt;/code&gt; 은 이름이 아니지만 &lt;code&gt;N&lt;/code&gt; 은 이름입니다. 이름 인 모든 종속 구성의 서브 세트를 &lt;em&gt;종속 이름&lt;/em&gt; 이라고합니다. 그러나 함수 이름은 템플릿의 다른 인스턴스화에서 다른 의미를 가질 수 있지만 불행히도이 일반적인 규칙에 따라 잡히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d79f149012b5db95c6057f7219f9674ae527d19b" translate="yes" xml:space="preserve">
          <source>Additional notes and examples</source>
          <target state="translated">추가 메모 및 예</target>
        </trans-unit>
        <trans-unit id="d4dd3f21f569a21f8954d6bcd851637c10de00d5" translate="yes" xml:space="preserve">
          <source>Additionally there are contexts where &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are &lt;strong&gt;explicitly&lt;/strong&gt; disallowed:</source>
          <target state="translated">또한 &lt;code&gt;typename&lt;/code&gt; 및 &lt;code&gt;template&lt;/code&gt; 이 &lt;strong&gt;명시 적으로&lt;/strong&gt; 허용되지 않는 컨텍스트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c219dd2dca62ca1f2584c5024fdf659813719f8e" translate="yes" xml:space="preserve">
          <source>After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &amp;lt;, the &amp;lt; is
  always taken as the beginning of a template-argument-list and never as a name followed by the less-than
  operator.</source>
          <target state="translated">이름 조회 (3.4)에서 이름이 템플릿 이름임을 확인한 후이 이름 뒤에 &amp;lt;가 오는 경우 &amp;lt;는 항상 템플릿 인수 목록의 시작으로 간주되고 이름 뒤에는 연산자보다.</target>
        </trans-unit>
        <trans-unit id="b108398247f2fde4538343d83b5bd97b8ad56a6f" translate="yes" xml:space="preserve">
          <source>An identifier is just a plain sequence of characters / digits, while the next two are the &lt;code&gt;operator +&lt;/code&gt; and &lt;code&gt;operator type&lt;/code&gt; form. The last form is &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt;. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.</source>
          <target state="translated">식별자는 문자 / 숫자의 일반적인 순서이며 다음 두 개는 &lt;code&gt;operator +&lt;/code&gt; 및 &lt;code&gt;operator type&lt;/code&gt; 입니다. 마지막 형식은 &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt; 입니다. 이러한 이름은 모두 이름이며 표준에서 일반적으로 사용하면 이름을 찾아야하는 네임 스페이스 또는 클래스를 말하는 한정자를 포함 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="81c49b052d928be1082ab24b20ce2665f9580dc8" translate="yes" xml:space="preserve">
          <source>As can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that &lt;code&gt;A::result_type&lt;/code&gt; can only be &lt;code&gt;int&lt;/code&gt; (and is hence a type), and &lt;code&gt;this-&amp;gt;g&lt;/code&gt; can only be the member template &lt;code&gt;g&lt;/code&gt; declared later (even if &lt;code&gt;A&lt;/code&gt; is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of &lt;code&gt;A&lt;/code&gt;!).</source>
          <target state="translated">알 수 있듯이 컴파일러가 &lt;code&gt;A::result_type&lt;/code&gt; 은 &lt;code&gt;int&lt;/code&gt; (따라서 유형) 일 수 있으며 &lt;code&gt;this-&amp;gt;g&lt;/code&gt; &lt;code&gt;g&lt;/code&gt; 는 나중에 선언 된 멤버 템플릿 만 될 수 있음을 완벽하게 파악할 수 있지만 명확성 키워드가 필요합니다. ( &lt;code&gt;A&lt;/code&gt; 가 명시 적으로 어딘가에 특수화되어 있어도 템플릿 내의 코드에는 영향을 미치지 않으므로 그 의미는 나중에 &lt;code&gt;A&lt;/code&gt; 전문화에 영향을받을 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="79ce6d8e6b3913b7a546df762dbeaed29ea26d47" translate="yes" xml:space="preserve">
          <source>Attempting to access &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; from inside the function will result in an error:</source>
          <target state="translated">함수 내부에서 &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; 에 액세스하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81a893e4a9fabef8c12fe3918ba674192fd36862" translate="yes" xml:space="preserve">
          <source>Based on this notion, the language says that &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; (such as &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt;) are all &lt;em&gt;member of the current instantiation&lt;/em&gt;&lt;strong&gt;if&lt;/strong&gt; they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately).</source>
          <target state="translated">이 개념에 따르면, 언어는 &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt; , &lt;code&gt;Foo&lt;/code&gt; 및 &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; (예 : &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt; )는 &lt;em&gt;현재 인스턴스화의&lt;/em&gt; 멤버 인 경우 현재 인스턴스화 또는 비 종속 기본 클래스 중 하나 인 클래스 (이름 검색을 즉시 수행).</target>
        </trans-unit>
        <trans-unit id="aa182f32a2b889bab8bb654d1c6efd34ac494dd1" translate="yes" xml:space="preserve">
          <source>C++11</source>
          <target state="translated">C++11</target>
        </trans-unit>
        <trans-unit id="7ec9396ea07c3217ea09c65fdc1877acc2f3a1f2" translate="yes" xml:space="preserve">
          <source>CAN I JUST STICK THE &lt;em&gt;KEYWORDS&lt;/em&gt; IN FRONT OF ANY NAME?</source>
          <target state="translated">모든 이름 &lt;em&gt;앞에 키워드를 붙일 수&lt;/em&gt; 있습니까?</target>
        </trans-unit>
        <trans-unit id="7938dcdba09fa9194d35fd38e5e702630c956dfa" translate="yes" xml:space="preserve">
          <source>Current instantiation</source>
          <target state="translated">현재 인스턴스화</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="864f4fdedd9126fb15ad913ea1c7d58bd7e1d941" translate="yes" xml:space="preserve">
          <source>Dependent function names</source>
          <target state="translated">종속 함수 이름</target>
        </trans-unit>
        <trans-unit id="3f049d4603c79ebaec4e70cfb62ab63cfc6422b2" translate="yes" xml:space="preserve">
          <source>Dependent names</source>
          <target state="translated">종속 이름</target>
        </trans-unit>
        <trans-unit id="80e115f1bc8f5f6dc0f1430fb858a5daba5e52c8" translate="yes" xml:space="preserve">
          <source>Dependent types (e.g: a type template parameter &lt;code&gt;T&lt;/code&gt;)</source>
          <target state="translated">종속 유형 (예 : 유형 템플리트 매개 변수 &lt;code&gt;T&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8a421fb1c98aa08853006608fca450d4e2f3b469" translate="yes" xml:space="preserve">
          <source>Different &lt;code&gt;T&lt;/code&gt;s can drastically change the semantics involved.</source>
          <target state="translated">다른 &lt;code&gt;T&lt;/code&gt; 는 관련된 의미를 크게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6504f0366c5e84396e1494226e00641b0cd0668" translate="yes" xml:space="preserve">
          <source>During the first phase, the parser needs to know if a dependant name is the name of a type or the name of a non-type. By default, a dependant name is assumed to be the name of a non-type. The typename keyword before a dependant name specifies that it is the name of a type.</source>
          <target state="translated">첫 번째 단계에서 구문 분석기는 종속 이름이 유형의 이름인지 또는 비 유형의 이름인지 알아야합니다. 기본적으로 종속 이름은 유형이 아닌 이름으로 간주됩니다. 종속 이름 앞의 typename 키워드는 그것이 키워드의 이름임을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="26e6a98595822c3428f17426deccc9b966757d5a" translate="yes" xml:space="preserve">
          <source>Every name written in a derived class's &lt;em&gt;base-specifier-list&lt;/em&gt; is already treated as a &lt;em&gt;type-name&lt;/em&gt;, explicitly specifying &lt;code&gt;typename&lt;/code&gt; is both ill-formed, and redundant.</source>
          <target state="translated">파생 클래스의 &lt;em&gt;base-specifier-list에&lt;/em&gt; 작성된 모든 이름은 이미 &lt;em&gt;type-name&lt;/em&gt; 으로 취급되며 &lt;code&gt;typename&lt;/code&gt; 을 명시 적으로 지정하면 &lt;em&gt;형식&lt;/em&gt; 이 잘못되고 중복됩니다.</target>
        </trans-unit>
        <trans-unit id="9f84d1c16d0d0893c80abb26baf74107ad6ba732" translate="yes" xml:space="preserve">
          <source>Every time a &lt;em&gt;name&lt;/em&gt; denotes a type, &lt;strong&gt;all&lt;/strong&gt;&lt;em&gt;names&lt;/em&gt; involved must be either &lt;em&gt;type-names&lt;/em&gt; or &lt;em&gt;namespaces&lt;/em&gt;, with this in mind it's quite easy to see that we apply &lt;code&gt;typename&lt;/code&gt; at the beginning of our fully &lt;em&gt;qualified name&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 이 유형을 나타낼 때마다 관련된 &lt;strong&gt;모든&lt;/strong&gt; &lt;em&gt;이름&lt;/em&gt; 은 &lt;em&gt;유형 이름&lt;/em&gt; 또는 &lt;em&gt;네임 스페이스&lt;/em&gt; 여야합니다.이를 염두에두고 &lt;em&gt;정규화 된 이름&lt;/em&gt; 의 시작 부분에 &lt;em&gt;유형 이름&lt;/em&gt; 을 적용한다는 것을 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47adaec317f0a9d2c7134ea1f923781d1c12aa2f" translate="yes" xml:space="preserve">
          <source>Examples and trivia</source>
          <target state="translated">예와 상식</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="499e8a71311f5b45ef7b0868a6f17f4d3544aaaf" translate="yes" xml:space="preserve">
          <source>For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I'll talk a bit about how this is specified in the Standard.</source>
          <target state="translated">선반에 두꺼운 Standardese 책이 있고 내가 정확히 무슨 말을하는지 알고 싶은 사람들을 위해, 나는 이것이 Standard에서 어떻게 지정되는지에 대해 조금 이야기 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6354646d0660057dd162dd60312a9d32319c52e" translate="yes" xml:space="preserve">
          <source>Given this struct and function:</source>
          <target state="translated">이 구조체와 기능이 주어지면 :</target>
        </trans-unit>
        <trans-unit id="71ddfb234bd60ba03d2e2d6677b4bbff9c588208" translate="yes" xml:space="preserve">
          <source>HOW TO HANDLE &lt;em&gt;DEPENDENT NAMES&lt;/em&gt;?</source>
          <target state="translated">&lt;em&gt;상대방 이름을 처리하는&lt;/em&gt; 방법?</target>
        </trans-unit>
        <trans-unit id="3b8fb374b67841bad50ca4fcb74ac158a7ee5ef1" translate="yes" xml:space="preserve">
          <source>How should this be parsed? For many languages a compiler doesn't need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what &lt;code&gt;t&lt;/code&gt; means. If it's a type, then it will be a declaration of a pointer &lt;code&gt;f&lt;/code&gt;. However if it's not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):</source>
          <target state="translated">이것을 어떻게 파싱해야합니까? 많은 언어에서 컴파일러는 코드 행을 구문 분석하고 기본적으로 수행하는 작업을 이해하기 위해 이름의 의미를 알 필요가 없습니다. 그러나 C ++에서 위의 내용은 &lt;code&gt;t&lt;/code&gt; 의 의미에 따라 크게 다른 해석을 산출 할 수 있습니다. 타입이라면, 포인터 &lt;code&gt;f&lt;/code&gt; 의 선언이 될 것입니다. 그러나 유형이 아닌 경우 곱셈이됩니다. 따라서 C ++ 표준은 (3/7) 단락에서 말합니다.</target>
        </trans-unit>
        <trans-unit id="82496a0ea3b6f2d8e59d952d53e9a80c47b69040" translate="yes" xml:space="preserve">
          <source>How will the compiler find out what a name &lt;code&gt;t::x&lt;/code&gt; refers to, if &lt;code&gt;t&lt;/code&gt; refers to a template type parameter? &lt;code&gt;x&lt;/code&gt; could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. If a name has this property - that it can't be looked up until the actual template arguments are known - then it's called a &lt;em&gt;dependent name&lt;/em&gt; (it &quot;depends&quot; on the template parameters).</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 가 템플릿 유형 매개 변수를 참조하는 경우 t &lt;code&gt;t::x&lt;/code&gt; 라는 이름이 무엇인지 컴파일러는 어떻게 알 수 있습니까? &lt;code&gt;x&lt;/code&gt; 는 곱할 수있는 정적 int 데이터 멤버 일 수도 있고 선언을 생성 할 수있는 중첩 클래스 또는 typedef 일 수도 있습니다. 이름에이 속성이있는 경우 실제 템플릿 인수를 알 때까지 조회 할 수없는 경우 해당 이름을 &lt;em&gt;종속 이름&lt;/em&gt; 이라고합니다 (템플릿 매개 변수에 &quot;의존&quot;).</target>
        </trans-unit>
        <trans-unit id="80310f20942c0583891a7f45d0eb6646c9e2f39b" translate="yes" xml:space="preserve">
          <source>However, I'm not sure you're implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the &quot;fail&quot; tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.</source>
          <target state="translated">그러나 inUnion의 구현이 올바른지 확실하지 않습니다. 올바르게 이해하면이 클래스를 인스턴스화하지 않아야하므로 &quot;실패&quot;탭이 절대로 실패하지 않습니다. 어쩌면 유형이 단순한 부울 값과 결합인지 아닌지를 나타내는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ffcbdb8addba9bcaec3d37e740ec726d7b74fdad" translate="yes" xml:space="preserve">
          <source>I am placing JLBorges's excellent &lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot;&gt;response&lt;/a&gt; to a similar question verbatim from cplusplus.com, as it is the most succinct explanation I've read on the subject.</source>
          <target state="translated">필자는 주제에 대해 읽은 가장 간결한 설명이므로 cplusplus.com의 유사한 질문에 &lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot;&gt;대해&lt;/a&gt; JLBorges의 탁월한 답변 을 제시하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9afbd33d83b082c42724dd2a0954b2a5084a9c0e" translate="yes" xml:space="preserve">
          <source>If nothing is stated, the &lt;em&gt;dependent-name&lt;/em&gt; will be considered to be either a variable, or a function.</source>
          <target state="translated">아무 것도 언급하지 않으면, &lt;em&gt;dependent-name&lt;/em&gt; 은 변수 또는 함수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="248aa3b12203e10552b3af6c402294330055100c" translate="yes" xml:space="preserve">
          <source>If this was a Hollywood film, &lt;em&gt;dependent-names&lt;/em&gt; would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.</source>
          <target state="translated">이 영화가 할리우드 영화인 경우, &lt;em&gt;부양 가족&lt;/em&gt; 은 신체 접촉을 통해 퍼지는 질병이되며 즉시 호스트에게 영향을 미쳐 혼란스러워합니다. 아마도 잘못된 형식의 erhm .. 프로그램으로 이어질 수있는 혼란.</target>
        </trans-unit>
        <trans-unit id="0bd90018a85e97f771d15515f6a3373c341702f0" translate="yes" xml:space="preserve">
          <source>If we instantiate the function-template with type &lt;em&gt;X&lt;/em&gt;, as in (&lt;em&gt;C&lt;/em&gt;), we will have a declaration of a &lt;em&gt;pointer-to int&lt;/em&gt; named &lt;em&gt;x&lt;/em&gt;, but;</source>
          <target state="translated">( &lt;em&gt;C&lt;/em&gt; )에서와 같이 함수 템플릿을 &lt;em&gt;X&lt;/em&gt; 유형으로 인스턴스화하면 &lt;em&gt;x&lt;/em&gt; 라는 이름의 &lt;em&gt;포인터에&lt;/em&gt; 대한 선언이 있지만;</target>
        </trans-unit>
        <trans-unit id="ef47c5e71f44563ae042e5301468f27ca3a50614" translate="yes" xml:space="preserve">
          <source>Imagine what happens if we had a member function &lt;code&gt;h&lt;/code&gt; within the above defined &lt;code&gt;A&lt;/code&gt; class template</source>
          <target state="translated">위에서 정의한 &lt;code&gt;A&lt;/code&gt; 클래스 템플릿 내에 멤버 함수 &lt;code&gt;h&lt;/code&gt; 가 있으면 어떻게 될지 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="231bd1ef6bfd0592631e7e9517ce774ad2be57d2" translate="yes" xml:space="preserve">
          <source>In C++03, the language allowed to catch this error because there could never be a valid way to instantiate &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; (whatever argument you give to &lt;code&gt;T&lt;/code&gt;). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since &lt;code&gt;A&lt;/code&gt; has no dependent base classes, and &lt;code&gt;A&lt;/code&gt; declares no member &lt;code&gt;questionable_type&lt;/code&gt;, the name &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; is &lt;em&gt;neither&lt;/em&gt; a member of the current instantiation &lt;em&gt;nor&lt;/em&gt; a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).</source>
          <target state="translated">C ++ 03에서 언어는 &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; 를 인스턴스화하는 유효한 방법이 없기 때문에이 오류를 포착 할 수있었습니다 ( T에 부여한 인수). C ++ 11에서 언어는 이제 컴파일러가이 규칙을 구현해야하는 더 많은 이유를 제공하기 위해 추가 검사를 수행합니다. &lt;code&gt;A&lt;/code&gt; 에는 종속 기본 클래스가없고 A 는 &lt;code&gt;questionable_type&lt;/code&gt; 멤버를 선언하지 않으므로 &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; 이름은 현재 인스턴스화의 멤버 &lt;em&gt;이거나&lt;/em&gt; 알 수없는 전문화의 멤버가 &lt;em&gt;아닙니다&lt;/em&gt; . 이 경우 해당 코드가 인스턴스화 시점에 올바르게 컴파일 될 수있는 방법이 없어야하므로 언어는 한정자가 현재 인스턴스화 인 이름을 알 수없는 전문화 영역의 멤버 나 현재 인스턴스화의 멤버가 아닌 이름을 금지합니다. 이 위반은 여전히 ​​진단 할 필요가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="0883b2e93b7c95f02702247700ebd9bfd0ecb687" translate="yes" xml:space="preserve">
          <source>In a template that we write, there are two kinds of names that could be used - dependant names and non- dependant names. A dependant name is a name that depends on a template parameter; a non-dependant name has the same meaning irrespective of what the template parameters are.</source>
          <target state="translated">우리가 작성하는 템플릿에는 종속 이름과 비 종속 이름의 두 가지 이름이 있습니다. 종속 이름은 템플릿 매개 변수에 의존하는 이름입니다. 비 의존적 이름은 템플릿 매개 변수가 무엇이든 관계없이 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="55037dd35e4322e33ec43f44ef797ca6cfa06004" translate="yes" xml:space="preserve">
          <source>In enough cases we need both of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;. Your code should look like the following</source>
          <target state="translated">충분한 경우 &lt;code&gt;typename&lt;/code&gt; 과 &lt;code&gt;template&lt;/code&gt; 이 모두 필요합니다. 코드는 다음과 같아야합니다</target>
        </trans-unit>
        <trans-unit id="e25768be4a82668492653e98728599e15bc1b3b6" translate="yes" xml:space="preserve">
          <source>In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:</source>
          <target state="translated">C ++ 프로그램을 구문 분석하려면 컴파일러는 특정 이름이 유형인지 여부를 알아야합니다. 다음 예제는이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="723e24157fedb66459b8cb1e919fabf2d210f132" translate="yes" xml:space="preserve">
          <source>In some cases, the keywords are forbidden, as detailed below</source>
          <target state="translated">경우에 따라 아래에 설명 된대로 키워드가 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="6ff2869a81645404d269012800fd47e944df1110" translate="yes" xml:space="preserve">
          <source>In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to &lt;em&gt;depend&lt;/em&gt; on template parameters.</source>
          <target state="translated">템플릿 선언에서 일부 구문은 템플릿을 인스턴스화하는 데 사용하는 템플릿 인수에 따라 다른 의미를 갖습니다. 표현식에는 유형이나 값이 다르거 나 변수에 유형이 다르거 나 함수 호출에 따라 서로 다른 함수가 호출 될 수 있습니다. 이러한 구성은 일반적으로 템플릿 매개 변수에 &lt;em&gt;의존&lt;/em&gt; 한다고합니다.</target>
        </trans-unit>
        <trans-unit id="607a8c1883367af22aab7a8e02fcba22f562537c" translate="yes" xml:space="preserve">
          <source>In templates, where and why do I have to put &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; on dependent names? What exactly are dependent names anyway? I have the following code:</source>
          <target state="translated">템플릿에서 &lt;code&gt;typename&lt;/code&gt; 과 &lt;code&gt;template&lt;/code&gt; 을 종속 이름에 어디에 그리고 왜 넣어야합니까? 어쨌든 종속 이름은 정확히 무엇입니까? 다음 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f50b1a4caa717e4ce30b40c50fdb5ffda75c32a7" translate="yes" xml:space="preserve">
          <source>In the code of &lt;code&gt;D&lt;/code&gt;, the name &lt;code&gt;typename D::questionable_type&lt;/code&gt; is not a member of the current instantiation. Instead the language marks it as a &lt;em&gt;member of an unknown specialization&lt;/em&gt;. In particular, this is always the case when you are doing &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; or &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; and either the dependent type is &lt;em&gt;not&lt;/em&gt; the current instantiation (in which case the compiler can give up and say &quot;we will look later what &lt;code&gt;Foo&lt;/code&gt; is) or it &lt;em&gt;is&lt;/em&gt; the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes.</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; 코드에서 &lt;code&gt;typename D::questionable_type&lt;/code&gt; 이름은 현재 인스턴스화의 멤버가 아닙니다. 그 대신 언어는 그것을 &lt;em&gt;알 수없는 전문화&lt;/em&gt; 의 &lt;em&gt;일원으로&lt;/em&gt; 표시합니다. 특히 이는 &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; 또는 &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; 를 수행 할 때 항상 발생하며 종속 유형이 현재 인스턴스화가 &lt;em&gt;아닙니다&lt;/em&gt; (이 경우 컴파일러가 포기하고 &quot; &lt;code&gt;Foo&lt;/code&gt; 가 무엇인지 나중에 볼 것입니다&quot;라고 말할 수 있음) ) 또는 현재 인스턴스화이고 이름이 해당 클래스 또는 비 종속 기본 클래스에없고 종속 기본 클래스도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7ada29808422dbb9e24960c66d91349f17c4800" translate="yes" xml:space="preserve">
          <source>In using-declarations it's not possible to use &lt;code&gt;template&lt;/code&gt; after the last &lt;code&gt;::&lt;/code&gt;, and the C++ committee &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot;&gt;said&lt;/a&gt; not to work on a solution.</source>
          <target state="translated">선언을 사용하면 마지막 &lt;code&gt;::&lt;/code&gt; 후에 &lt;code&gt;template&lt;/code&gt; 을 사용할 수 없으며 C ++위원회 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot;&gt;는&lt;/a&gt; 솔루션에서 작동하지 않는다고 말했습니다 .</target>
        </trans-unit>
        <trans-unit id="8421611d7923291b6537ffa9a5516e093fd2bf26" translate="yes" xml:space="preserve">
          <source>It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of &lt;code&gt;boost::function&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">인간에게는 분명해 보일 수 있습니다. 컴파일러에게는 그렇지 않습니다. &lt;code&gt;boost::function&lt;/code&gt; 및 &lt;code&gt;f&lt;/code&gt; 의 다음과 같은 임의의 정의를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="ef82f45cfb61fb4fecf8d59ce0e78f98cd2cc2f4" translate="yes" xml:space="preserve">
          <source>It might not be as easy as one thinks, more specifically the result of evaluating (&lt;em&gt;A&lt;/em&gt;) heavily &lt;em&gt;depends&lt;/em&gt; on the definition of the type passed as template-parameter &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">생각하는 것처럼 쉽지 않을 수 있습니다.보다 구체적으로 ( &lt;em&gt;A&lt;/em&gt; )를 평가 한 결과는 템플릿 매개 변수 &lt;code&gt;T&lt;/code&gt; 로 전달 된 유형의 정의에 크게 &lt;em&gt;좌우&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="73f2eedcc9728afac38f277e768bc709f16765a2" translate="yes" xml:space="preserve">
          <source>Most of the rules are intuitive and are built up recursively: For example, a type constructed as &lt;code&gt;T[N]&lt;/code&gt; is a dependent type if &lt;code&gt;N&lt;/code&gt; is a value-dependent expression or &lt;code&gt;T&lt;/code&gt; is a dependent type. The details of this can be read in section &lt;code&gt;(14.6.2/1&lt;/code&gt;) for dependent types, &lt;code&gt;(14.6.2.2)&lt;/code&gt; for type-dependent expressions and &lt;code&gt;(14.6.2.3)&lt;/code&gt; for value-dependent expressions.</source>
          <target state="translated">대부분의 규칙은 직관적이며 재귀 적으로 구성됩니다. 예를 들어, &lt;code&gt;N&lt;/code&gt; 이 값 종속 표현식이거나 &lt;code&gt;T&lt;/code&gt; 가 종속 유형 인 경우 &lt;code&gt;T[N]&lt;/code&gt; 으로 구성된 유형은 종속 유형입니다. 이에 대한 자세한 내용은 종속 유형에 대해서는 &lt;code&gt;(14.6.2/1&lt;/code&gt; ), 유형 종속 표현식에 대해서는 &lt;code&gt;(14.6.2.3)&lt;/code&gt; , 값 종속 표현식에 대해서는 (14.6.2.3) 에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d33e5e8480f354dad4b6ad9367f25a40c9f9bdaa" translate="yes" xml:space="preserve">
          <source>Neither of statement (&lt;em&gt;E&lt;/em&gt;), (&lt;em&gt;F&lt;/em&gt;) or (&lt;em&gt;G&lt;/em&gt;) is valid if the compiler would interpret the &lt;em&gt;dependent-names&lt;/em&gt; as variables/functions (which as stated earlier is what happens if we don't explicitly say otherwise).</source>
          <target state="translated">컴파일러가 &lt;em&gt;종속 이름&lt;/em&gt; 을 변수 / 함수로 해석하면 명령문 ( &lt;em&gt;E&lt;/em&gt; ), ( &lt;em&gt;F&lt;/em&gt; ) 또는 ( &lt;em&gt;G&lt;/em&gt; ) 중 어느 것도 유효하지 않습니다 (앞서 언급했듯이 명시 적으로 다르게 말하지 않으면 발생 함).</target>
        </trans-unit>
        <trans-unit id="d32a29935d2bd59d7cfd39a6135dbe57c5e8fc66" translate="yes" xml:space="preserve">
          <source>Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example &lt;code&gt;f((T)0)&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt; is a dependent name. In the Standard, this is specified at &lt;code&gt;(14.6.2/1)&lt;/code&gt;.</source>
          <target state="translated">이 기사의 주요 관심사는 아니지만 여전히 언급 할 가치가 있습니다. 함수 이름은 별도로 처리되는 예외입니다. 식별자 함수 이름은 그 자체가 아니라 호출에 사용되는 형식 종속 인수 표현식에 따라 다릅니다. 예제 &lt;code&gt;f((T)0)&lt;/code&gt; 에서 &lt;code&gt;f&lt;/code&gt; 는 종속 이름입니다. 표준에서 이는 &lt;code&gt;(14.6.2/1)&lt;/code&gt; 에 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c3acfb0745ac40f78ce00a50115e3da33af5010" translate="yes" xml:space="preserve">
          <source>Note that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don't have to specify &lt;code&gt;typename&lt;/code&gt;, for example:</source>
          <target state="translated">이는 메타 함수 또는 일반 템플릿 매개 변수를 사용하는 항목에도 적용됩니다. 그러나 제공된 템플리트 매개 변수가 명시 적 유형이면 &lt;code&gt;typename&lt;/code&gt; 을 지정할 필요가 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a8107ce35efcfc3379410e30c887b0716e8c000" translate="yes" xml:space="preserve">
          <source>Now we are back to the same problem as with &lt;code&gt;typename&lt;/code&gt;. What if we can't know yet whether the name is a template when parsing the code? We will need to insert &lt;code&gt;template&lt;/code&gt; immediately before the template name, as specified by &lt;code&gt;14.2/4&lt;/code&gt;. This looks like:</source>
          <target state="translated">이제 &lt;code&gt;typename&lt;/code&gt; 과 동일한 문제로 돌아 왔습니다. 코드를 구문 분석 할 때 이름이 템플릿인지 여부를 아직 알 수 없으면 어떻게합니까? &lt;code&gt;14.2/4&lt;/code&gt; 에 지정된대로 템플릿 이름 바로 앞에 &lt;code&gt;template&lt;/code&gt; 을 삽입해야합니다. 이것은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="247f001f459a71cf2ba6a5da92513d6caf7363e0" translate="yes" xml:space="preserve">
          <source>On the name of a dependent base class you are not allowed to write &lt;code&gt;typename&lt;/code&gt;. It's assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</source>
          <target state="translated">종속 기본 클래스의 이름에는 &lt;code&gt;typename&lt;/code&gt; 을 쓸 수 없습니다. 주어진 이름은 클래스 타입 이름이라고 가정합니다. 기본 클래스 목록과 생성자 이니셜 라이저 목록의 이름 모두에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="a512f0af9594fedb9079383ef813cc685035c26f" translate="yes" xml:space="preserve">
          <source>PS2: Have a look at &lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot;&gt;typelists&lt;/a&gt;, notably in Andrei Alexandrescu's book: Modern C++ Design</source>
          <target state="translated">PS2 : 특히 Andrei Alexandrescu의 책 : Modern C ++ Design에서 &lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot;&gt;typelists를&lt;/a&gt; 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="bdbe5508b19afff8cb57579196c6516007ea9aae" translate="yes" xml:space="preserve">
          <source>PS: Have a look at &lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot;&gt;Boost::Variant&lt;/a&gt;</source>
          <target state="translated">PS : &lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot;&gt;Boost :: Variant&lt;/a&gt; 살펴보기</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="3df155aafc1a199cca8ef6beb1b1d48c331e2365" translate="yes" xml:space="preserve">
          <source>Remember the initial quote above and how the Standard requires special handling for templates as well? Let's take the following innocent-looking example:</source>
          <target state="translated">위의 초기 인용문과 표준에 템플릿을 어떻게 처리해야하는지 기억하십니까? 다음과 같은 순진한 예를 보자.</target>
        </trans-unit>
        <trans-unit id="6ba008a6093affa2d41cdad9748159bc5cb6d20a" translate="yes" xml:space="preserve">
          <source>So there has to be a way to tell the compiler that certain names are types and that certain names aren't.</source>
          <target state="translated">따라서 컴파일러에게 특정 이름은 유형이고 특정 이름은 그렇지 않다고 알려주는 방법이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="660674432116072d61b4a75c7efcf588fe3e6c94" translate="yes" xml:space="preserve">
          <source>Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.</source>
          <target state="translated">일부 이름은 유형 또는 템플릿을 나타냅니다. 일반적으로 이름이 발견 될 때마다 해당 이름이 포함 된 프로그램을 계속 구문 분석하기 전에 해당 이름이 이러한 엔티티 중 하나를 나타내는 지 여부를 판별해야합니다. 이를 결정하는 프로세스를 이름 조회라고합니다.</target>
        </trans-unit>
        <trans-unit id="8d79f76b53e088ead8ed9ed664f087d2b54ea07d" translate="yes" xml:space="preserve">
          <source>THE RATIONALE</source>
          <target state="translated">근거</target>
        </trans-unit>
        <trans-unit id="1e7bff13be2789a80f543841f8ca934baeda8abf" translate="yes" xml:space="preserve">
          <source>THE SOLUTION</source>
          <target state="translated">해결책</target>
        </trans-unit>
        <trans-unit id="7d4bf11f65a833a43805734fc518cd4aba4e3ae0" translate="yes" xml:space="preserve">
          <source>Template names can not only occur after a &lt;code&gt;::&lt;/code&gt; but also after a &lt;code&gt;-&amp;gt;&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; in a class member access. You need to insert the keyword there too:</source>
          <target state="translated">템플릿 이름은 &lt;code&gt;::&lt;/code&gt; 다음 뿐만 아니라 &lt;code&gt;-&amp;gt;&lt;/code&gt; 또는 다음에도 나타날 수 있습니다 &lt;code&gt;.&lt;/code&gt; 반원 액세스. 키워드도 여기에 삽입해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e2e37676af9900b6b7d7b80a6d076dd3efe6361" translate="yes" xml:space="preserve">
          <source>That way the compiler will parse this properly rather than &lt;code&gt;t.get &amp;lt; int&lt;/code&gt;.</source>
          <target state="translated">그렇게하면 컴파일러는 &lt;code&gt;t.get &amp;lt; int&lt;/code&gt; 대신 이것을 올바르게 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="836511d1cb4791ee6d0d13c95ea85a78fe3910de" translate="yes" xml:space="preserve">
          <source>That's actually a valid &lt;em&gt;expression&lt;/em&gt;! It uses the less-than operator to compare &lt;code&gt;boost::function&lt;/code&gt; against zero (&lt;code&gt;int()&lt;/code&gt;), and then uses the greater-than operator to compare the resulting &lt;code&gt;bool&lt;/code&gt; against &lt;code&gt;f&lt;/code&gt;. However as you might well know, &lt;code&gt;boost::function&lt;/code&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot;&gt;in real life&lt;/a&gt; is a template, so the compiler knows (14.2/3):</source>
          <target state="translated">실제로 유효한 &lt;em&gt;표현입니다&lt;/em&gt; ! 보다 작음 연산자를 사용하여 &lt;code&gt;boost::function&lt;/code&gt; 과 zero ( &lt;code&gt;int()&lt;/code&gt; )를 비교 한 다음보다 큼 연산자를 사용하여 결과 &lt;code&gt;bool&lt;/code&gt; 과 &lt;code&gt;f&lt;/code&gt; 를 비교합니다. 그러나 잘 아시다시피 &lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot;&gt;실제 생활에서&lt;/a&gt; &lt;code&gt;boost::function&lt;/code&gt; 은 템플릿이므로 컴파일러는 (14.2 / 3)을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35b88a4738b3645c1aef372f59ad3047b158b13" translate="yes" xml:space="preserve">
          <source>That's impressive, but can we do better? The language even goes further and &lt;em&gt;requires&lt;/em&gt; that an implementation again looks up &lt;code&gt;D::result_type&lt;/code&gt; when instantiating &lt;code&gt;D::f&lt;/code&gt; (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined &lt;code&gt;C&lt;/code&gt; like this</source>
          <target state="translated">인상적이지만 더 잘할 수 있습니까? 언어는 더 나아가서 &lt;code&gt;D::f&lt;/code&gt; 인스턴스화 할 때 구현이 &lt;code&gt;D::result_type&lt;/code&gt; 다시 찾아야합니다 (정의시 이미 의미를 찾았더라도). 이제 조회 결과가 다르거 나 모호한 결과가 생기면 프로그램이 잘못 구성되고 진단이 제공되어야합니다. &lt;code&gt;C&lt;/code&gt; 를 이렇게 정의하면 어떻게 될지 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="397b3aa358a31ed91afc3c84c5752f5669f499b0" translate="yes" xml:space="preserve">
          <source>The &quot;template&quot; keyword</source>
          <target state="translated">&quot;템플릿&quot;키워드</target>
        </trans-unit>
        <trans-unit id="ab32972d5ca051abc115a7572997071871b757ac" translate="yes" xml:space="preserve">
          <source>The &quot;typename&quot; keyword</source>
          <target state="translated">&quot;typename&quot;키워드</target>
        </trans-unit>
        <trans-unit id="059c8dc482f6fcec095abfac5e21cf05f38aaecd" translate="yes" xml:space="preserve">
          <source>The C++ Standard cares about our safety and well-being, at least in this case.</source>
          <target state="translated">C ++ 표준은 적어도이 경우에 우리의 안전과 안녕에 관심을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="75d71f350625c9208a970a84d0f2647c18d12e3d" translate="yes" xml:space="preserve">
          <source>The C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)</source>
          <target state="translated">C ++ 11 규칙은 다음과 같은 유효한 C ++ 03 코드를 잘못 구성합니다 (C ++위원회가 의도하지 않았지만 수정되지는 않음).</target>
        </trans-unit>
        <trans-unit id="d678b7bdd1a0680bb6cb738cb7515a1010d81457" translate="yes" xml:space="preserve">
          <source>The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:</source>
          <target state="translated">표준은 구조가 종속적인지 여부에 따라 정확하게 규칙을 정의합니다. 논리적으로 다른 그룹으로 구분합니다. 하나는 유형을, 다른 하나는 표현식을 포착합니다. 표현은 그 가치 및 / 또는 유형에 따라 달라질 수 있습니다. 따라서 일반적인 예제가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="9cfd62de43ae793e4b5c0bbaea489055b29010a9" translate="yes" xml:space="preserve">
          <source>The Standard is a bit unclear about what &lt;em&gt;exactly&lt;/em&gt; is a &lt;em&gt;dependent name&lt;/em&gt;. On a simple read (you know, the principle of least surprise), all it defines as a &lt;em&gt;dependent name&lt;/em&gt; is the special case for function names below. But since clearly &lt;code&gt;T::x&lt;/code&gt; also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition).</source>
          <target state="translated">표준은 &lt;em&gt;정확히&lt;/em&gt; &lt;em&gt;종속 이름&lt;/em&gt; 이 무엇인지에 대해 조금 불분명합니다. 간단한 읽기 (최소한의 놀람의 원리)에서 &lt;em&gt;종속 이름으로&lt;/em&gt; 정의되는 모든 것은 아래의 함수 이름에 대한 특별한 경우입니다. 그러나 명확하게 &lt;code&gt;T::x&lt;/code&gt; 도 인스턴스화 컨텍스트에서 조회해야하므로 종속 이름이어야합니다 (다행히도 C ++ 14 중반부터위원회는 혼란스러운 정의를 수정하는 방법을 조사하기 시작했습니다) .</target>
        </trans-unit>
        <trans-unit id="eaeb296948f681fa8c069b722bff11d7272cc610" translate="yes" xml:space="preserve">
          <source>The answer is: &lt;em&gt;We&lt;/em&gt; decide how the compiler should parse this. If &lt;code&gt;t::x&lt;/code&gt; is a dependent name, then we need to prefix it by &lt;code&gt;typename&lt;/code&gt; to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):</source>
          <target state="translated">답은 : &lt;em&gt;우리&lt;/em&gt; 는 컴파일러가 이것을 어떻게 파싱해야하는지 결정합니다. &lt;code&gt;t::x&lt;/code&gt; 가 종속적 인 이름 인 경우 컴파일러에게 특정 방식으로 구문 분석하도록 지시하려면 &lt;code&gt;typename&lt;/code&gt; 을 접두어로 붙여야합니다. 표준은 (14.6 / 2)에서 말합니다.</target>
        </trans-unit>
        <trans-unit id="e839e7bc0fb3047c1bdf6c7dbb6e9ae237507034" translate="yes" xml:space="preserve">
          <source>The general rule for putting the &lt;code&gt;typename&lt;/code&gt; keyword is mostly when you're using a template parameter and you want to access a nested &lt;code&gt;typedef&lt;/code&gt; or using-alias, for example:</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; 키워드를 넣는 일반적인 규칙은 주로 템플릿 매개 변수를 사용하고 중첩 된 &lt;code&gt;typedef&lt;/code&gt; 또는 별칭을 사용하려는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="cfc3f7e0b4137c99807273a259f51ca22659ff99" translate="yes" xml:space="preserve">
          <source>The general rules for adding the &lt;code&gt;template&lt;/code&gt; qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 한정자를 추가하는 일반적인 규칙은 일반적으로 템플릿으로 작성된 구조체 / 클래스의 템플릿 멤버 함수 (정적 또는 기타)를 포함한다는 점을 제외하면 대부분 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="83fdb65b86514ecc3d94eb5034b2904b19fc4647" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; doesn't always have to appear in the last part of a name. It can appear in the middle before a class name that's used as a scope, like in the following example</source>
          <target state="translated">키워드 &lt;code&gt;template&lt;/code&gt; 이 이름의 마지막 부분에 항상 나타나는 것은 아닙니다. 다음 예제와 같이 범위로 사용되는 클래스 이름 앞에 중간에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea5c129366ce9cd9ab21f5cd93e125ca28bbc280" translate="yes" xml:space="preserve">
          <source>The keywords &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;em&gt;still&lt;/em&gt; a type-dependent name (after all &lt;code&gt;T&lt;/code&gt; is also type dependent). But &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; is known to be a type - the compiler will &quot;magically&quot; look into this kind of dependent types to figure this out.</source>
          <target state="translated">한정자가 현재 인스턴스화의 멤버 인 경우 키워드 &lt;code&gt;typename&lt;/code&gt; 및 &lt;code&gt;template&lt;/code&gt; 은 더 이상 필요하지 않습니다. 여기서 기억해야 할 핵심 사항은 &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; 는 &lt;em&gt;여전히&lt;/em&gt; 유형에 따른 이름이라는 것입니다 (모든 &lt;code&gt;T&lt;/code&gt; 도 유형에 따라 달라짐). 그러나 &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; 은 유형으로 알려져 있습니다. 컴파일러는이를 알아 내기 위해 이러한 종류의 종속 유형을 &quot;마 법적으로&quot;조사합니다.</target>
        </trans-unit>
        <trans-unit id="077f4f3cb3b45d6c4da04d629251c33c46d6451d" translate="yes" xml:space="preserve">
          <source>The problem I have is in the &lt;code&gt;typedef Tail::inUnion&amp;lt;U&amp;gt; dummy&lt;/code&gt; line. I'm fairly certain that &lt;code&gt;inUnion&lt;/code&gt; is a dependent name, and VC++ is quite right in choking on it. I also know that I should be able to add &lt;code&gt;template&lt;/code&gt; somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. &lt;code&gt;inUnion&amp;lt;U&amp;gt;&lt;/code&gt; names a type and not a function?</source>
          <target state="translated">내가 가진 문제는 &lt;code&gt;typedef Tail::inUnion&amp;lt;U&amp;gt; dummy&lt;/code&gt; 라인에 있습니다. &lt;code&gt;inUnion&lt;/code&gt; 이 종속 이름이며 VC ++이 질식하는 데 상당히 적합합니다. 또한 컴파일러에 inUnion이 템플릿 ID임을 알리기 위해 &lt;code&gt;template&lt;/code&gt; 어딘가에 추가 할 수 있어야한다는 것을 알고 있습니다. 그러나 정확히 어디에? 그런 다음 inUnion이 클래스 템플릿이라고 가정해야합니다. 즉 &lt;code&gt;inUnion&amp;lt;U&amp;gt;&lt;/code&gt; 는 함수가 아닌 유형의 이름을 지정합니까?</target>
        </trans-unit>
        <trans-unit id="f1c7bae603744472346dadfc7ea4dedeef3d82c9" translate="yes" xml:space="preserve">
          <source>The rules in the Standard states that you may apply the keywords as long as you are dealing with a &lt;em&gt;qualified-name&lt;/em&gt; (&lt;em&gt;K&lt;/em&gt;), but if the name isn't &lt;em&gt;qualified&lt;/em&gt; the application is ill-formed (&lt;em&gt;L&lt;/em&gt;).</source>
          <target state="translated">표준의 규칙에 따르면 &lt;em&gt;규정 된 이름&lt;/em&gt; ( &lt;em&gt;K&lt;/em&gt; )을 처리하는 한 키워드를 적용 할 수 있지만 &lt;em&gt;규정&lt;/em&gt; 되지 않은 경우 응용 프로그램의 형식이 잘못 ( &lt;em&gt;L&lt;/em&gt; )됩니다.</target>
        </trans-unit>
        <trans-unit id="2bd5a78638dcace559982a14bbcc8b023fd7f274" translate="yes" xml:space="preserve">
          <source>The underlying purpose is the same; an explanation to &quot;When?&quot; and &quot;Why?&quot; &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; must be applied.</source>
          <target state="translated">기본 목적은 동일합니다. &quot;언제?&quot; 그리고 왜?&quot; &lt;code&gt;typename&lt;/code&gt; 과 &lt;code&gt;template&lt;/code&gt; 을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="10f33cad8fd8a2837a1e5c87042e16251d5742a6" translate="yes" xml:space="preserve">
          <source>There are certain contexts in &lt;em&gt;C++&lt;/em&gt; where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one &lt;em&gt;template-parameter&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;C ++&lt;/em&gt; 에는 컴파일러가 이름을 다루는 방법을 명시 적으로 알려 주어야하는 특정 컨텍스트가 있으며 이러한 모든 컨텍스트에는 공통점이 있습니다. 그것들은 적어도 하나의 &lt;em&gt;template-parameter&lt;/em&gt; 에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="a4b3c376a5c02c3331f13cc34e60d67e0eda12a9" translate="yes" xml:space="preserve">
          <source>There are many names for which &lt;code&gt;typename&lt;/code&gt; is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with &lt;code&gt;T *f;&lt;/code&gt;, when &lt;code&gt;T&lt;/code&gt; is a type template parameter. But for &lt;code&gt;t::x * f;&lt;/code&gt; to be a declaration, it must be written as &lt;code&gt;typename t::x *f;&lt;/code&gt;. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:</source>
          <target state="translated">컴파일러에서 템플릿 정의의 해당 이름 조회를 사용하여 구문 자체를 구문 분석하는 방법 (예 : &lt;code&gt;T *f;&lt;/code&gt; 알아낼 수 있기 때문에 &lt;code&gt;typename&lt;/code&gt; 이 필요하지 않은 이름이 많이 있습니다 . &lt;code&gt;T&lt;/code&gt; 가 유형 템플릿 매개 변수 인 경우 그러나 &lt;code&gt;t::x * f;&lt;/code&gt; 선언하려면 &lt;code&gt;typename t::x *f;&lt;/code&gt; 로 작성해야합니다 . . 키워드를 생략하고 이름을 유형이 아닌 것으로 간주하지만 인스턴스화가 발견되면 유형을 나타내는 경우 일반적인 오류 메시지가 컴파일러에서 생성됩니다. 때때로 정의 시간에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="193f977dcab6c47bd2d6b8470ad6dcab7bd03b03" translate="yes" xml:space="preserve">
          <source>This post is meant to be an &lt;em&gt;easy-to-read&lt;/em&gt; alternative to &lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;litb's post&lt;/a&gt;.</source>
          <target state="translated">이 게시물은 &lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;litb의 게시물에 대한&lt;/a&gt; &lt;em&gt;읽기 쉬운&lt;/em&gt; 대안이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5a4896926029b3eb852f0d6a106ca34a09f5713" translate="yes" xml:space="preserve">
          <source>This post will offer an explanation to the relationship between &lt;em&gt;dependent-names&lt;/em&gt;, and the two keywords.</source>
          <target state="translated">이 게시물은 &lt;em&gt;dependent-names&lt;/em&gt; 과 두 키워드의 관계에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8d3949e28211d7534133207cc300ac1efaad60d9" translate="yes" xml:space="preserve">
          <source>This valid C++03 code would bind &lt;code&gt;this-&amp;gt;f&lt;/code&gt; to &lt;code&gt;A::f&lt;/code&gt; at instantiation time and everything is fine. C++11 however immediately binds it to &lt;code&gt;B::f&lt;/code&gt; and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt;, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot;&gt;Dominance Rule&lt;/a&gt; applies and lookup will find &lt;code&gt;A::f&lt;/code&gt; instead.</source>
          <target state="translated">이 유효한 C ++ 03 코드는 인스턴스화시 &lt;code&gt;this-&amp;gt;f&lt;/code&gt; 를 &lt;code&gt;A::f&lt;/code&gt; 에 바인딩하고 모든 것이 정상입니다. 그러나 C ++ 11은이를 즉시 &lt;code&gt;B::f&lt;/code&gt; 바인딩하며 인스턴스화 할 때 조회가 여전히 일치하는지 확인하는 이중 검사가 필요합니다. 그러나 &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt; 인스턴스화 할 때 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot;&gt;Dominance Rule이&lt;/a&gt; 적용되고 대신 조회에서 &lt;code&gt;A::f&lt;/code&gt; 를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a29f6a4158f73a5ee76b40bdb5725dddd2048562" translate="yes" xml:space="preserve">
          <source>This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template's text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template's users (poor colleagues!) with errors made by a template's author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place.</source>
          <target state="translated">이것은 작동하며 실제로 표준에서 가능한 구현 방식으로 허용됩니다. 이 컴파일러는 기본적으로 템플릿의 텍스트를 내부 버퍼에 복사하며 인스턴스화가 필요한 경우에만 템플릿을 구문 분석하고 정의에서 오류를 감지합니다. 그러나 템플릿 제작자가 만든 오류로 템플릿 사용자 (가난한 동료)를 괴롭히는 대신, 다른 구현에서는 인스턴스화가 발생하기 전에 템플릿을 조기에 확인하고 가능한 한 빨리 정의에 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ddec0732ccbb4210a2b6b99783ad2631b52a9cc7" translate="yes" xml:space="preserve">
          <source>Thus in this context you would need the &lt;code&gt;template&lt;/code&gt; keyword beforehand and call it like so:</source>
          <target state="translated">따라서이 맥락에서 미리 &lt;code&gt;template&lt;/code&gt; 키워드가 필요하며 다음과 같이 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="3090538eec535ec4cf723c65f5b6a6ba58cdbe5b" translate="yes" xml:space="preserve">
          <source>To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore &quot;dependent names&quot;. A name can take different forms - the Standard says:</source>
          <target state="translated">이 문제를 피하기 위해 표준 텍스트를 간단히 해석했습니다. 종속 유형 또는 표현식을 나타내는 모든 구성 중에서 이들 중 일부는 이름을 나타냅니다. 따라서 이러한 이름은 &quot;종속적 인 이름&quot;입니다. 이름은 다른 형태를 취할 수 있습니다-표준은 말합니다 :</target>
        </trans-unit>
        <trans-unit id="7698fca51994ddc6c138471b88e06e7c83afdd2d" translate="yes" xml:space="preserve">
          <source>To improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt;). A type referenced by such a name is known to be  the &lt;em&gt;current instantiation&lt;/em&gt;. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, &lt;code&gt;A::NestedClass&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are both current instantiations).</source>
          <target state="translated">상황을 개선하기 위해 C ++ 11에서는 유형이 둘러싸는 템플리트를 참조 할 때 언어가 추적합니다. 이를 알기 위해서는 형식이 고유 한 이름 인 특정 형식의 이름 (위에서 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt; )을 사용하여 형식을 구성해야합니다. 이러한 이름으로 참조되는 유형은 &lt;em&gt;현재 인스턴스화로&lt;/em&gt; 알려져 있습니다. 이름이 형성되는 유형이 멤버 / 중첩 된 클래스 인 경우 (현재 &lt;code&gt;A::NestedClass&lt;/code&gt; 및 &lt;code&gt;A&lt;/code&gt; 는 모두 현재 인스턴스화 인 경우) 모두 현재 인스턴스화 인 여러 유형이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8b8473f52f5d48a53b82b2e364a8ed8725c5fd0" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;g_tmpl&lt;/code&gt; have a valid definition we must explicitly tell the compiler that we expect a type in (&lt;em&gt;E&lt;/em&gt;), a &lt;em&gt;template-id&lt;/em&gt; and a &lt;em&gt;type&lt;/em&gt; in (&lt;em&gt;F&lt;/em&gt;), and a &lt;em&gt;template-id&lt;/em&gt; in (&lt;em&gt;G&lt;/em&gt;).</source>
          <target state="translated">&lt;code&gt;g_tmpl&lt;/code&gt; 을 유효한 정의로 만들려면 컴파일러에게 유형 ( &lt;em&gt;E&lt;/em&gt; ), &lt;em&gt;템플릿 ID&lt;/em&gt; 및 &lt;em&gt;유형&lt;/em&gt; ( &lt;em&gt;F&lt;/em&gt; ) 및 &lt;em&gt;템플릿 ID&lt;/em&gt; ( &lt;em&gt;G&lt;/em&gt; )를 기대한다고 명시 적으로 알려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="af6ebf3891ffb2ee30f2bf8858408c64c95c34f1" translate="yes" xml:space="preserve">
          <source>To prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a &lt;em&gt;dependent-name&lt;/em&gt; by &lt;em&gt;explicitly&lt;/em&gt; stating the intent anywhere we'd like to treat the name as either a &lt;em&gt;type-name&lt;/em&gt;, or a &lt;em&gt;template-id&lt;/em&gt;.</source>
          <target state="translated">구현체가 불쾌한 놀라움으로 인해 어려움을 겪지 않도록 표준은 우리가 이름을 &lt;em&gt;type-name&lt;/em&gt; 또는 &lt;em&gt;template-&lt;/em&gt; 으로 취급하고자하는 곳 어디에서나 의도를 &lt;em&gt;명시 적으로 명시&lt;/em&gt; 함으로써 &lt;em&gt;종속 이름&lt;/em&gt; 의 모호성을 분류 할 것을 요구합니다. &lt;em&gt;id&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29862938e768a917aab1960c6bbb6ae497b193e9" translate="yes" xml:space="preserve">
          <source>Try to explain what is going on in the following &lt;em&gt;function-template&lt;/em&gt;, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (&lt;em&gt;A&lt;/em&gt;)?</source>
          <target state="translated">다음의 &lt;em&gt;기능 템플릿&lt;/em&gt; 에서 자신, 친구 또는 고양이에게 무슨 일이 일어나고 있는지 설명하려고 노력하십시오. ( &lt;em&gt;A&lt;/em&gt; )로 표시된 명세서에서 무슨 일이 있습니까?</target>
        </trans-unit>
        <trans-unit id="87061df8bae25712e416ad7d53765e98b6719bd8" translate="yes" xml:space="preserve">
          <source>Type-dependent expressions (e.g: a cast to a type template parameter &lt;code&gt;(T)0&lt;/code&gt;)</source>
          <target state="translated">유형 종속 표현식 (예 : 유형 템플리트 매개 변수로 캐스트 &lt;code&gt;(T)0&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="689c51725b427087666b6048cec59bcb29fcbece" translate="yes" xml:space="preserve">
          <source>Unknown specializations</source>
          <target state="translated">알 수없는 전문화</target>
        </trans-unit>
        <trans-unit id="6026daccdfec39543979697858424c64ff4ef007" translate="yes" xml:space="preserve">
          <source>Use the keyword typename only in template declarations and definitions provided you have a qualified name that refers to a type and depends on a template parameter.</source>
          <target state="translated">유형을 참조하고 템플리트 매개 변수에 의존하는 규정 된 이름이있는 경우 템플리트 선언 및 정의에서만 키워드 typename을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="763d8d416b60f842f2c2cc144e23011113e885a1" translate="yes" xml:space="preserve">
          <source>Value-dependent expressions (e.g: a non-type template parameter &lt;code&gt;N&lt;/code&gt;)</source>
          <target state="translated">값 종속 표현식 (예 : 비 타입 템플릿 매개 변수 &lt;code&gt;N&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ceaafeab5b0bb21207a924ae3fb0e737282cd5e7" translate="yes" xml:space="preserve">
          <source>We have four &lt;em&gt;dependent&lt;/em&gt; names in the above snippet:</source>
          <target state="translated">위의 스 니펫에는 네 개의 &lt;em&gt;종속&lt;/em&gt; 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="526f7334186e1b9227cf705c33b09999cd0d98e8" translate="yes" xml:space="preserve">
          <source>We refer to such names, where there can be an ambiguity in interpretation, as; &quot;&lt;em&gt;dependent names&lt;/em&gt;&quot;.</source>
          <target state="translated">우리는 해석상 모호한 부분이있을 수있는 그러한 이름을 언급한다. &quot; &lt;em&gt;종속 이름&lt;/em&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="bbecf5660dbaf8d8ded1b52887f0ecd3180d34c3" translate="yes" xml:space="preserve">
          <source>What a dependant name refers to could be something different for each different instantiation of the template. As a consequence, C++ templates are subject to &quot;two-phase name lookup&quot;. When a template is initially parsed (before any instantiation takes place) the compiler looks up the non-dependent names. When a particular instantiation of the template takes place, the template parameters are known by then, and the compiler looks up dependent names.</source>
          <target state="translated">종속 이름이 말하는 것은 템플릿의 각 인스턴스화마다 다를 수 있습니다. 결과적으로 C ++ 템플릿은 &quot;2 단계 이름 조회&quot;를 따릅니다. 템플릿이 처음 구문 분석 될 때 (인스턴스화가 발생하기 전에) 컴파일러는 비 종속적 이름을 찾습니다. 템플릿의 특정 인스턴스화가 발생하면 템플릿 매개 변수를 알고 컴파일러가 종속 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="b8f6499ca71be3c23ce33c1b2a9f5b83685a4750" translate="yes" xml:space="preserve">
          <source>What's the purpose of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; 과 &lt;code&gt;template&lt;/code&gt; 의 목적은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="bc52aff94964c77dc3a3b4fa138bce704fae73f4" translate="yes" xml:space="preserve">
          <source>Where and why do I have to put the “template” and “typename” keywords</source>
          <target state="translated">&quot;템플릿&quot;및 &quot;typename&quot;키워드를 어디에 그리고 왜 넣어야합니까</target>
        </trans-unit>
        <trans-unit id="552a23a5cb320222a24f1cb81b66e05f546ad95e" translate="yes" xml:space="preserve">
          <source>While the rules in C++03 about when you need &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are largely reasonable, there is one annoying disadvantage of its formulation</source>
          <target state="translated">형식 이름과 &lt;code&gt;template&lt;/code&gt; 이 필요한시기에 대한 C ++ 03의 규칙은 대체로 합리적이지만 공식화에는 한 가지 성가신 단점이 있습니다</target>
        </trans-unit>
        <trans-unit id="7b6897d54406a3105e58e6dc3fc5b5863dff0daa" translate="yes" xml:space="preserve">
          <source>You can try this knowledge on &lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;this answer&lt;/a&gt; and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;이 답변&lt;/a&gt; 에 대해이 지식을 시험해 볼 수 있으며 위의 정의가 실제 예에서 적합한 지 여부를 확인할 수 있습니다 (해당 답변에서 약간 덜 상세하게 반복됩니다).</target>
        </trans-unit>
        <trans-unit id="2efba1c1c4d9757ca6d366d4029d83dcd0b82fca" translate="yes" xml:space="preserve">
          <source>You might recommend to just wait till the user instantiates the template:</source>
          <target state="translated">사용자가 템플릿을 인스턴스화 할 때까지 기다리는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e48b0fa9b66fcdab66a1db676dd26515d8b3d55f" translate="yes" xml:space="preserve">
          <source>if we instantiate the template with type &lt;em&gt;Y&lt;/em&gt;, as in (&lt;em&gt;D&lt;/em&gt;), (&lt;em&gt;A&lt;/em&gt;) would instead consist of an expression that calculates the product of &lt;em&gt;123&lt;/em&gt; multiplied with some already declared variable &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">( &lt;em&gt;D&lt;/em&gt; )에서와 같이 유형 &lt;em&gt;Y로&lt;/em&gt; 템플릿을 인스턴스화하면 ( &lt;em&gt;A&lt;/em&gt; )는 &lt;em&gt;123의&lt;/em&gt; 곱에 이미 선언 된 변수 &lt;em&gt;x를&lt;/em&gt; 곱한 값을 계산하는 표현식으로 구성됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
