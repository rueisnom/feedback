<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/610245">
    <body>
      <group id="610245">
        <trans-unit id="81a4752786ca04ed1a7662da3ad6fd89d03fdd33" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;Can I just stick &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; in front of any name? I don't want to worry about the context in which they appear...&lt;/em&gt;&quot; - &lt;code&gt;Some C++ Developer&lt;/code&gt;</source>
          <target state="translated">&amp;ldquo; &lt;em&gt;我可以只将 &lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; 放在任何名称的前面吗？我不想担心它们出现的上下文...&lt;/em&gt; &amp;rdquo;- &lt;code&gt;Some C++ Developer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da314107a76c971fe9203b881ca2d5dc651b90a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; however, is different in this regard, since there's no way of coming to a conclusion such as; &lt;em&gt;&quot;oh, this is a template, then this other thing must also be a template&quot;&lt;/em&gt;. This means that we apply &lt;code&gt;template&lt;/code&gt; directly in front of any &lt;em&gt;name&lt;/em&gt; that we'd like to treat as such.</source>
          <target state="translated">但是， &lt;code&gt;template&lt;/code&gt; 在这方面是不同的，因为无法得出这样的结论： &lt;em&gt;&amp;ldquo;哦，这是模板，那么另一件事也必须是模板&amp;rdquo;&lt;/em&gt; 。 这意味着我们将 &lt;code&gt;template&lt;/code&gt; 直接应用在我们想要这样对待的任何&lt;em&gt;名称的&lt;/em&gt;前面。</target>
        </trans-unit>
        <trans-unit id="3e6c4b85701f35fe30fbc34931dc03cfd7dda142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are usable in circumstances other than when declaring a template.</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; 在声明模板以外的其他情况下可用。</target>
        </trans-unit>
        <trans-unit id="7ca671f7a7070e1849b27be2dac38cb84d41ab25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Let's wait until the user instantiates the template, and then later find out the real meaning of &lt;code&gt;t::x * f;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;让我们等到用户实例化模板，然后再找出 &lt;code&gt;t::x * f;&lt;/code&gt; 的真实含义。&lt;/em&gt; &lt;em&gt;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c04d03f78f58040504cd81e4dc96e86c59640a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The syntax allows &lt;code&gt;typename&lt;/code&gt; only before qualified names&lt;/em&gt; - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.</source>
          <target state="translated">&lt;em&gt;该语法仅允许在合格名称之前使用类型名&lt;/em&gt; -因此，可以理解的是，如果总是使用不合格名称，则通常会引用类型。</target>
        </trans-unit>
        <trans-unit id="e2ecf05f2de6fcde4001af850840dca6978b6c81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;NestedTrait&quot;&lt;/strong&gt;, which is a &lt;em&gt;template-id&lt;/em&gt;, depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;</source>
          <target state="translated">&lt;strong&gt;&amp;ldquo; NestedTrait&amp;rdquo;&lt;/strong&gt;是一个&lt;em&gt;模板ID&lt;/em&gt; ，取决于 &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; ；并且;</target>
        </trans-unit>
        <trans-unit id="7c3fd61616ef25b7bad12ae0f45164811952b743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;data&quot;&lt;/strong&gt;, which looks like a &lt;em&gt;member-function template&lt;/em&gt;, is indirectly a &lt;em&gt;dependent-name&lt;/em&gt; since the type of &lt;em&gt;foo&lt;/em&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">看起来像&lt;em&gt;成员函数模板的&lt;/em&gt; &lt;strong&gt;&amp;ldquo;数据&amp;rdquo;&lt;/strong&gt;间接地是一个&lt;em&gt;依赖名称，&lt;/em&gt;因为&lt;em&gt;foo&lt;/em&gt;的类型取决于 &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; 的实例化。</target>
        </trans-unit>
        <trans-unit id="edbe9c0a9a43ae825a9c6f8aaaf224b3d281ad41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; at the end of (&lt;em&gt;F&lt;/em&gt;) depends on &lt;em&gt;NestedTrait&lt;/em&gt;, which depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;</source>
          <target state="translated">（ &lt;em&gt;F&lt;/em&gt; ）末尾的&lt;strong&gt;&amp;ldquo;类型&amp;rdquo;&lt;/strong&gt;取决于&lt;em&gt;NestedTrait&lt;/em&gt; ，后者取决于 &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; ；并且;</target>
        </trans-unit>
        <trans-unit id="8f60a89f51a419f36ed14856c476a0174be4ff9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, which include &lt;code&gt;T&lt;/code&gt;, and;</source>
          <target state="translated">&lt;strong&gt;&amp;ldquo;类型&amp;rdquo;&lt;/strong&gt;取决于 &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; 的实例化，其中包括 &lt;code&gt;T&lt;/code&gt; 和；</target>
        </trans-unit>
        <trans-unit id="6f469f6e1084fdb25863f628728d09a97794a167" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;E&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="42bb91b7ab5f09937d85eff1c421efa46f42ab8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;F&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;F&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="5d6b157f6a08ec9e0c665dc0de45a07bc5ee1a60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;G&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;G&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="82ccd28c2dcf130545ef823fe89eddf360a2a00f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PREFACE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PREFACE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23803dbe26e6085fd2fa0883c19d0f2f27666b33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The two different scenarios&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;两种不同的情况&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="e811163b854bd2669c245ceb717edce8e12a537f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When specifying the bases of which a class inherits&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;指定类继承的基础时&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="330d5ed944055f18e28c9497441117f20c14e6e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When the &lt;em&gt;template-id&lt;/em&gt; is the one being referred to in a derived class's &lt;em&gt;using-directive&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;当&lt;em&gt;template-id&lt;/em&gt;是派生类的&lt;em&gt;using-directive中&lt;/em&gt;所引用&lt;em&gt;的ID&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="52b5f115a82e14ac063f13915cc23e1f11a5ebe8" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;This answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go &lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;这个答案的意思是回答标题问题（一部分）的简短而甜美的回答。&lt;/em&gt;&lt;/sub&gt; &lt;sub&gt;&lt;em&gt;如果您想获得更详细的答案以说明为什么必须将其放在此处，请转到&lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;此处&lt;/a&gt; 。&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="1bfe14eb10ca361b9d4ba80c600e5e0629d33b7b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;Note&lt;/strong&gt;: Applying &lt;code&gt;typename&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt; in a context where it is not required is not considered good practice; just because you can do something, doesn't mean that you should.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;注意&lt;/strong&gt; ：在不需要的情况下应用 &lt;code&gt;typename&lt;/code&gt; 或 &lt;code&gt;template&lt;/code&gt; 不被认为是一种好习惯；&lt;/sup&gt; &lt;sup&gt;仅仅因为您可以做某事，并不意味着您应该做。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d3e3594e08ca6cc46a536e175af0955c908fe709" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dependent-name&lt;/em&gt; is &lt;strong&gt;any&lt;/strong&gt; name that directly, or indirectly, depends on a &lt;em&gt;template-parameter&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;从属名称&lt;/em&gt;是直接或间接取决于&lt;em&gt;template-parameter的&lt;/em&gt; &lt;strong&gt;任何&lt;/strong&gt;名称。</target>
        </trans-unit>
        <trans-unit id="167311c32569b35652bc2a3316fd061fd6dd2919" translate="yes" xml:space="preserve">
          <source>A SNIPPET SAYS MORE THAN 1000 WORDS</source>
          <target state="translated">一语道破千言万语</target>
        </trans-unit>
        <trans-unit id="83157225247456f23e8d3702295867eda13efdd9" translate="yes" xml:space="preserve">
          <source>A compiler is required to catch the error when instantiating &lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt;. So you get the best of the two worlds: &quot;Delayed&quot; lookup protecting you if you could get in trouble with dependent base classes, and also &quot;Immediate&quot; lookup that frees you from &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">实例化 &lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt; 时，需要编译器来捕获错误。 因此，您可以充分利用这两个世界的优势：&amp;ldquo;延迟&amp;rdquo;查找（如果您可能会遇到依赖基类的麻烦）可以保护您，还可以通过&amp;ldquo;立即&amp;rdquo;查找将您从 &lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; 中解放出来。</target>
        </trans-unit>
        <trans-unit id="c035f4cd7ec02fdb2cd82af3dcd6cec12757cd6b" translate="yes" xml:space="preserve">
          <source>A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)</source>
          <target state="translated">名称是指使用标识符(2.11)、操作者-功能-ID(13.5)、转换-功能-ID(12.3.2)或模板-ID(14.2)表示实体或标签(6.6.4、6.1)的标识符的使用</target>
        </trans-unit>
        <trans-unit id="23519716491bc53d4e57fd893f7debfe498cf6c9" translate="yes" xml:space="preserve">
          <source>A name used in a template declaration or definition and that is dependent on a template-parameter is
  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified
  by the keyword typename.</source>
          <target state="translated">在模板声明或定义中使用的、依赖于模板参数的名称被认为不会命名一个类型,除非适用的名称查询找到了一个类型名称,或者该名称被关键字typename限定。</target>
        </trans-unit>
        <trans-unit id="1ad1d6ae245142dbfde495564ae1bd48307233e1" translate="yes" xml:space="preserve">
          <source>A similar gotcha exists for names that denote templates, as hinted at by the introductory text.</source>
          <target state="translated">正如导言中所暗示的那样,对于表示模板的名称也有类似的问题。</target>
        </trans-unit>
        <trans-unit id="2f4d2698ac7315f563034d04e68543b3fea1b1a3" translate="yes" xml:space="preserve">
          <source>A value dependent expression &lt;code&gt;1 + N&lt;/code&gt; is not a name, but &lt;code&gt;N&lt;/code&gt; is. The subset of all dependent constructs that are names is called &lt;em&gt;dependent name&lt;/em&gt;. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule.</source>
          <target state="translated">值相关表达式 &lt;code&gt;1 + N&lt;/code&gt; 不是名称，而 &lt;code&gt;N&lt;/code&gt; 是。 名称的所有相关构造的子集称为&lt;em&gt;相关名称&lt;/em&gt; 。 但是，函数名称在模板的不同实例中可能具有不同的含义，但不幸的是，该通用规则并未捕获它们。</target>
        </trans-unit>
        <trans-unit id="d79f149012b5db95c6057f7219f9674ae527d19b" translate="yes" xml:space="preserve">
          <source>Additional notes and examples</source>
          <target state="translated">补充说明和实例</target>
        </trans-unit>
        <trans-unit id="d4dd3f21f569a21f8954d6bcd851637c10de00d5" translate="yes" xml:space="preserve">
          <source>Additionally there are contexts where &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are &lt;strong&gt;explicitly&lt;/strong&gt; disallowed:</source>
          <target state="translated">另外，在某些上下文中&lt;strong&gt;明确&lt;/strong&gt;禁止了 &lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c219dd2dca62ca1f2584c5024fdf659813719f8e" translate="yes" xml:space="preserve">
          <source>After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &amp;lt;, the &amp;lt; is
  always taken as the beginning of a template-argument-list and never as a name followed by the less-than
  operator.</source>
          <target state="translated">在名称查找（3.4）发现名称是模板名称之后，如果此名称后跟&amp;lt;，则始终将&amp;lt;视为模板参数列表的开头，而永远不要将其作为名称，然后再输入-比运算符。</target>
        </trans-unit>
        <trans-unit id="b108398247f2fde4538343d83b5bd97b8ad56a6f" translate="yes" xml:space="preserve">
          <source>An identifier is just a plain sequence of characters / digits, while the next two are the &lt;code&gt;operator +&lt;/code&gt; and &lt;code&gt;operator type&lt;/code&gt; form. The last form is &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt;. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.</source>
          <target state="translated">标识符只是一个简单的字符/数字序列，而接下来的两个是 &lt;code&gt;operator +&lt;/code&gt; 和 &lt;code&gt;operator type&lt;/code&gt; 形式。 最后一种形式是 &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt; 。 所有这些都是名称，按照标准中的常规用法，名称还可以包含限定词，该限定词表示应查找名称的名称空间或类。</target>
        </trans-unit>
        <trans-unit id="81c49b052d928be1082ab24b20ce2665f9580dc8" translate="yes" xml:space="preserve">
          <source>As can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that &lt;code&gt;A::result_type&lt;/code&gt; can only be &lt;code&gt;int&lt;/code&gt; (and is hence a type), and &lt;code&gt;this-&amp;gt;g&lt;/code&gt; can only be the member template &lt;code&gt;g&lt;/code&gt; declared later (even if &lt;code&gt;A&lt;/code&gt; is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of &lt;code&gt;A&lt;/code&gt;!).</source>
          <target state="translated">可以看出，即使编译器可以完美地指出 &lt;code&gt;A::result_type&lt;/code&gt; 只能是 &lt;code&gt;int&lt;/code&gt; （因此是类型），我们也需要dis歧义关键字，并且 &lt;code&gt;this-&amp;gt;g&lt;/code&gt; 只能是稍后声明的成员模板 &lt;code&gt;g&lt;/code&gt; （即使 &lt;code&gt;A&lt;/code&gt; 在某处显式地专门化，也不会影响该模板中的代码，因此其含义不会受到以后对 &lt;code&gt;A&lt;/code&gt; ！的专门化的影响）。</target>
        </trans-unit>
        <trans-unit id="79ce6d8e6b3913b7a546df762dbeaed29ea26d47" translate="yes" xml:space="preserve">
          <source>Attempting to access &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; from inside the function will result in an error:</source>
          <target state="translated">尝试从函数内部访问 &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; 将导致错误：</target>
        </trans-unit>
        <trans-unit id="81a893e4a9fabef8c12fe3918ba674192fd36862" translate="yes" xml:space="preserve">
          <source>Based on this notion, the language says that &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; (such as &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt;) are all &lt;em&gt;member of the current instantiation&lt;/em&gt;&lt;strong&gt;if&lt;/strong&gt; they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately).</source>
          <target state="translated">基于此概念，该语言表示 &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt; ， &lt;code&gt;Foo&lt;/code&gt; 和 &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; （例如 &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt; ）都是&lt;em&gt;当前实例的成员（&lt;/em&gt; &lt;strong&gt;如果&lt;/strong&gt;发现它们是a的成员）是当前实例的类，或者是其非依赖基类之一（只需立即执行名称查找）。</target>
        </trans-unit>
        <trans-unit id="aa182f32a2b889bab8bb654d1c6efd34ac494dd1" translate="yes" xml:space="preserve">
          <source>C++11</source>
          <target state="translated">C++11</target>
        </trans-unit>
        <trans-unit id="7ec9396ea07c3217ea09c65fdc1877acc2f3a1f2" translate="yes" xml:space="preserve">
          <source>CAN I JUST STICK THE &lt;em&gt;KEYWORDS&lt;/em&gt; IN FRONT OF ANY NAME?</source>
          <target state="translated">我可以在任何名字的前面加上&lt;em&gt;关键词&lt;/em&gt;吗？</target>
        </trans-unit>
        <trans-unit id="7938dcdba09fa9194d35fd38e5e702630c956dfa" translate="yes" xml:space="preserve">
          <source>Current instantiation</source>
          <target state="translated">当前实例化</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="864f4fdedd9126fb15ad913ea1c7d58bd7e1d941" translate="yes" xml:space="preserve">
          <source>Dependent function names</source>
          <target state="translated">从属函数名称</target>
        </trans-unit>
        <trans-unit id="3f049d4603c79ebaec4e70cfb62ab63cfc6422b2" translate="yes" xml:space="preserve">
          <source>Dependent names</source>
          <target state="translated">从属名称</target>
        </trans-unit>
        <trans-unit id="80e115f1bc8f5f6dc0f1430fb858a5daba5e52c8" translate="yes" xml:space="preserve">
          <source>Dependent types (e.g: a type template parameter &lt;code&gt;T&lt;/code&gt;)</source>
          <target state="translated">从属类型（例如：类型模板参数 &lt;code&gt;T&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8a421fb1c98aa08853006608fca450d4e2f3b469" translate="yes" xml:space="preserve">
          <source>Different &lt;code&gt;T&lt;/code&gt;s can drastically change the semantics involved.</source>
          <target state="translated">不同的 &lt;code&gt;T&lt;/code&gt; 可以大大改变所涉及的语义。</target>
        </trans-unit>
        <trans-unit id="f6504f0366c5e84396e1494226e00641b0cd0668" translate="yes" xml:space="preserve">
          <source>During the first phase, the parser needs to know if a dependant name is the name of a type or the name of a non-type. By default, a dependant name is assumed to be the name of a non-type. The typename keyword before a dependant name specifies that it is the name of a type.</source>
          <target state="translated">在第一阶段,解析器需要知道一个依赖名是类型的名称还是非类型的名称。默认情况下,从属名被假定为非类型的名称。依附名称前的 typename 关键字表示它是类型的名称。</target>
        </trans-unit>
        <trans-unit id="26e6a98595822c3428f17426deccc9b966757d5a" translate="yes" xml:space="preserve">
          <source>Every name written in a derived class's &lt;em&gt;base-specifier-list&lt;/em&gt; is already treated as a &lt;em&gt;type-name&lt;/em&gt;, explicitly specifying &lt;code&gt;typename&lt;/code&gt; is both ill-formed, and redundant.</source>
          <target state="translated">派生类的&lt;em&gt;base-specifier-list中&lt;/em&gt;写入的每个名称都已被视为&lt;em&gt;type-name&lt;/em&gt; ，显式指定 &lt;code&gt;typename&lt;/code&gt; 既是格式错误的也是多余的。</target>
        </trans-unit>
        <trans-unit id="9f84d1c16d0d0893c80abb26baf74107ad6ba732" translate="yes" xml:space="preserve">
          <source>Every time a &lt;em&gt;name&lt;/em&gt; denotes a type, &lt;strong&gt;all&lt;/strong&gt;&lt;em&gt;names&lt;/em&gt; involved must be either &lt;em&gt;type-names&lt;/em&gt; or &lt;em&gt;namespaces&lt;/em&gt;, with this in mind it's quite easy to see that we apply &lt;code&gt;typename&lt;/code&gt; at the beginning of our fully &lt;em&gt;qualified name&lt;/em&gt;.</source>
          <target state="translated">每次&lt;em&gt;名称&lt;/em&gt;表示一种类型时，涉及的&lt;strong&gt;所有&lt;/strong&gt; &lt;em&gt;名称&lt;/em&gt;都必须是&lt;em&gt;类型名称&lt;/em&gt;或&lt;em&gt;名称空间&lt;/em&gt; ，考虑到这一点，很容易看出我们在完全&lt;em&gt;限定名称&lt;/em&gt;的开头应用了 &lt;code&gt;typename&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47adaec317f0a9d2c7134ea1f923781d1c12aa2f" translate="yes" xml:space="preserve">
          <source>Examples and trivia</source>
          <target state="translated">例子和琐事</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="499e8a71311f5b45ef7b0868a6f17f4d3544aaaf" translate="yes" xml:space="preserve">
          <source>For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I'll talk a bit about how this is specified in the Standard.</source>
          <target state="translated">对于那些书架上有厚厚的标准书的人,想知道我说的到底是什么的人,我就说一说《标准》是怎么规定的。</target>
        </trans-unit>
        <trans-unit id="f6354646d0660057dd162dd60312a9d32319c52e" translate="yes" xml:space="preserve">
          <source>Given this struct and function:</source>
          <target state="translated">鉴于这个结构和功能:</target>
        </trans-unit>
        <trans-unit id="71ddfb234bd60ba03d2e2d6677b4bbff9c588208" translate="yes" xml:space="preserve">
          <source>HOW TO HANDLE &lt;em&gt;DEPENDENT NAMES&lt;/em&gt;?</source>
          <target state="translated">如何处理&lt;em&gt;相关名称&lt;/em&gt; ？</target>
        </trans-unit>
        <trans-unit id="3b8fb374b67841bad50ca4fcb74ac158a7ee5ef1" translate="yes" xml:space="preserve">
          <source>How should this be parsed? For many languages a compiler doesn't need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what &lt;code&gt;t&lt;/code&gt; means. If it's a type, then it will be a declaration of a pointer &lt;code&gt;f&lt;/code&gt;. However if it's not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):</source>
          <target state="translated">应该如何解析？ 对于许多语言，编译器不需要知道名称的含义就可以进行分析，并且基本上不需要知道一行代码会执行什么操作。 然而，在C ++中，根据 &lt;code&gt;t&lt;/code&gt; 的含义，以上内容可能会产生截然不同的解释。 如果是类型，则它将是指针 &lt;code&gt;f&lt;/code&gt; 的声明。 但是，如果不是类型，它将是一个乘法。 因此，C ++标准在第（3/7）段中说：</target>
        </trans-unit>
        <trans-unit id="82496a0ea3b6f2d8e59d952d53e9a80c47b69040" translate="yes" xml:space="preserve">
          <source>How will the compiler find out what a name &lt;code&gt;t::x&lt;/code&gt; refers to, if &lt;code&gt;t&lt;/code&gt; refers to a template type parameter? &lt;code&gt;x&lt;/code&gt; could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. If a name has this property - that it can't be looked up until the actual template arguments are known - then it's called a &lt;em&gt;dependent name&lt;/em&gt; (it &quot;depends&quot; on the template parameters).</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 引用模板类型参数，编译器将如何找出名称 &lt;code&gt;t::x&lt;/code&gt; 所指？ &lt;code&gt;x&lt;/code&gt; 可以是可以乘以的静态int数据成员，也可以是可以产生声明的嵌套类或typedef。 如果名称具有此属性-在知道实际的模板参数之前不能查找它-那么它称为&lt;em&gt;从属名称&lt;/em&gt; （它&amp;ldquo;取决于&amp;rdquo;模板参数）。</target>
        </trans-unit>
        <trans-unit id="80310f20942c0583891a7f45d0eb6646c9e2f39b" translate="yes" xml:space="preserve">
          <source>However, I'm not sure you're implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the &quot;fail&quot; tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.</source>
          <target state="translated">但是,我不确定你对inUnion的实现是否正确。如果我没有理解错的话,这个类不应该被实例化,因此 &quot;失败 &quot;选项卡最终不会失败。也许用一个简单的布尔值来表示类型是否在inUnion中会更好。</target>
        </trans-unit>
        <trans-unit id="ffcbdb8addba9bcaec3d37e740ec726d7b74fdad" translate="yes" xml:space="preserve">
          <source>I am placing JLBorges's excellent &lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot;&gt;response&lt;/a&gt; to a similar question verbatim from cplusplus.com, as it is the most succinct explanation I've read on the subject.</source>
          <target state="translated">对于来自cplusplus.com的类似问题，我将JLBorges的出色&lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot;&gt;回答&lt;/a&gt;置于最佳位置，因为这是我在该主题上读到的最简洁的解释。</target>
        </trans-unit>
        <trans-unit id="9afbd33d83b082c42724dd2a0954b2a5084a9c0e" translate="yes" xml:space="preserve">
          <source>If nothing is stated, the &lt;em&gt;dependent-name&lt;/em&gt; will be considered to be either a variable, or a function.</source>
          <target state="translated">如果未指定任何内容，则&lt;em&gt;从属名称&lt;/em&gt;将被视为变量或函数。</target>
        </trans-unit>
        <trans-unit id="248aa3b12203e10552b3af6c402294330055100c" translate="yes" xml:space="preserve">
          <source>If this was a Hollywood film, &lt;em&gt;dependent-names&lt;/em&gt; would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.</source>
          <target state="translated">如果这是一部好莱坞电影， &lt;em&gt;依赖人的名字&lt;/em&gt;就是通过身体接触传播的疾病，立即影响其主人，使之困惑。 混乱可能会导致格式错误的pers.-erhm ..程序。</target>
        </trans-unit>
        <trans-unit id="0bd90018a85e97f771d15515f6a3373c341702f0" translate="yes" xml:space="preserve">
          <source>If we instantiate the function-template with type &lt;em&gt;X&lt;/em&gt;, as in (&lt;em&gt;C&lt;/em&gt;), we will have a declaration of a &lt;em&gt;pointer-to int&lt;/em&gt; named &lt;em&gt;x&lt;/em&gt;, but;</source>
          <target state="translated">如果像（ &lt;em&gt;C&lt;/em&gt; ）中那样用类型&lt;em&gt;X&lt;/em&gt;实例化函数模板，我们将有一个名为&lt;em&gt;x&lt;/em&gt;的&lt;em&gt;指向int&lt;/em&gt;的&lt;em&gt;指针&lt;/em&gt;的声明，但是；</target>
        </trans-unit>
        <trans-unit id="ef47c5e71f44563ae042e5301468f27ca3a50614" translate="yes" xml:space="preserve">
          <source>Imagine what happens if we had a member function &lt;code&gt;h&lt;/code&gt; within the above defined &lt;code&gt;A&lt;/code&gt; class template</source>
          <target state="translated">想象一下，如果我们在上面定义的 &lt;code&gt;A&lt;/code&gt; 类模板中有一个成员函数 &lt;code&gt;h&lt;/code&gt; ，会发生什么</target>
        </trans-unit>
        <trans-unit id="231bd1ef6bfd0592631e7e9517ce774ad2be57d2" translate="yes" xml:space="preserve">
          <source>In C++03, the language allowed to catch this error because there could never be a valid way to instantiate &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; (whatever argument you give to &lt;code&gt;T&lt;/code&gt;). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since &lt;code&gt;A&lt;/code&gt; has no dependent base classes, and &lt;code&gt;A&lt;/code&gt; declares no member &lt;code&gt;questionable_type&lt;/code&gt;, the name &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; is &lt;em&gt;neither&lt;/em&gt; a member of the current instantiation &lt;em&gt;nor&lt;/em&gt; a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).</source>
          <target state="translated">在C ++ 03中，该语言允许捕获此错误，因为永远不可能有一种有效的方法来实例化 &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; （无论您给 &lt;code&gt;T&lt;/code&gt; 提供什么参数）。 在C ++ 11中，现在对该语言进行了进一步检查，以使编译器有更多理由实施此规则。 由于 &lt;code&gt;A&lt;/code&gt; 没有依赖的基类，并且 &lt;code&gt;A&lt;/code&gt; 没有声明成员 &lt;code&gt;questionable_type&lt;/code&gt; ，因此名称 &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; &lt;em&gt;既不&lt;/em&gt;是当前实例的成员， &lt;em&gt;也不&lt;/em&gt;是未知专业化的成员。 在这种情况下，该代码就不可能在实例化时有效地编译，因此该语言禁止使用限定符作为当前实例化的名称，该名称既不是未知专业化的成员也不是当前实例化的成员（但是，仍然不需要诊断是否违反此规定）。</target>
        </trans-unit>
        <trans-unit id="0883b2e93b7c95f02702247700ebd9bfd0ecb687" translate="yes" xml:space="preserve">
          <source>In a template that we write, there are two kinds of names that could be used - dependant names and non- dependant names. A dependant name is a name that depends on a template parameter; a non-dependant name has the same meaning irrespective of what the template parameters are.</source>
          <target state="translated">在我们编写的模板中,有两种名称可以使用--依赖性名称和非依赖性名称。依赖名是指依赖于模板参数的名称;非依赖名无论模板参数是什么,其含义都是一样的。</target>
        </trans-unit>
        <trans-unit id="55037dd35e4322e33ec43f44ef797ca6cfa06004" translate="yes" xml:space="preserve">
          <source>In enough cases we need both of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;. Your code should look like the following</source>
          <target state="translated">在足够的情况下，我们需要 &lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; 。 您的代码应如下所示</target>
        </trans-unit>
        <trans-unit id="e25768be4a82668492653e98728599e15bc1b3b6" translate="yes" xml:space="preserve">
          <source>In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:</source>
          <target state="translated">为了解析一个C++程序,编译器需要知道某些名称是否是类型。下面的例子证明了这一点。</target>
        </trans-unit>
        <trans-unit id="723e24157fedb66459b8cb1e919fabf2d210f132" translate="yes" xml:space="preserve">
          <source>In some cases, the keywords are forbidden, as detailed below</source>
          <target state="translated">在某些情况下,禁止使用关键词,详情如下</target>
        </trans-unit>
        <trans-unit id="6ff2869a81645404d269012800fd47e944df1110" translate="yes" xml:space="preserve">
          <source>In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to &lt;em&gt;depend&lt;/em&gt; on template parameters.</source>
          <target state="translated">在模板声明中，某些构造具有不同的含义，具体取决于用于实例化模板的模板参数：表达式可能具有不同的类型或值，变量可能具有不同的类型，或者函数调用最终可能会调用不同的函数。 通常说这样的构建体&lt;em&gt;取决于&lt;/em&gt;模板参数。</target>
        </trans-unit>
        <trans-unit id="607a8c1883367af22aab7a8e02fcba22f562537c" translate="yes" xml:space="preserve">
          <source>In templates, where and why do I have to put &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; on dependent names? What exactly are dependent names anyway? I have the following code:</source>
          <target state="translated">在模板中，为什么必须在哪里以及为什么要在依赖名称上放置 &lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; ？ 无论如何，相关名称到底是什么？ 我有以下代码：</target>
        </trans-unit>
        <trans-unit id="f50b1a4caa717e4ce30b40c50fdb5ffda75c32a7" translate="yes" xml:space="preserve">
          <source>In the code of &lt;code&gt;D&lt;/code&gt;, the name &lt;code&gt;typename D::questionable_type&lt;/code&gt; is not a member of the current instantiation. Instead the language marks it as a &lt;em&gt;member of an unknown specialization&lt;/em&gt;. In particular, this is always the case when you are doing &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; or &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; and either the dependent type is &lt;em&gt;not&lt;/em&gt; the current instantiation (in which case the compiler can give up and say &quot;we will look later what &lt;code&gt;Foo&lt;/code&gt; is) or it &lt;em&gt;is&lt;/em&gt; the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes.</source>
          <target state="translated">在 &lt;code&gt;D&lt;/code&gt; 的代码中，名称类型名 &lt;code&gt;typename D::questionable_type&lt;/code&gt; 不是当前实例的成员。 相反，该语言将其标记为&lt;em&gt;未知专业化&lt;/em&gt;的&lt;em&gt;成员&lt;/em&gt; 。 特别是，在执行 &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; 或 &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; 时，总是这种情况，并且其中一个依赖类型&lt;em&gt;都不&lt;/em&gt;是当前实例化（在这种情况下，编译器可以放弃并说&amp;ldquo;我们稍后将看一下 &lt;code&gt;Foo&lt;/code&gt; 是什么） ），或者它&lt;em&gt;是&lt;/em&gt;当前实例化，并且在其或其非依赖基类中找不到名称，并且还存在依赖基类。</target>
        </trans-unit>
        <trans-unit id="a7ada29808422dbb9e24960c66d91349f17c4800" translate="yes" xml:space="preserve">
          <source>In using-declarations it's not possible to use &lt;code&gt;template&lt;/code&gt; after the last &lt;code&gt;::&lt;/code&gt;, and the C++ committee &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot;&gt;said&lt;/a&gt; not to work on a solution.</source>
          <target state="translated">在using-declaration中，不可能在最后一个 &lt;code&gt;::&lt;/code&gt; 之后使用 &lt;code&gt;template&lt;/code&gt; ，并且C ++委员会&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot;&gt;表示&lt;/a&gt;不使用解决方案。</target>
        </trans-unit>
        <trans-unit id="8421611d7923291b6537ffa9a5516e093fd2bf26" translate="yes" xml:space="preserve">
          <source>It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of &lt;code&gt;boost::function&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">对于人类读者来说，这似乎很明显。 对于编译器则不是这样。 想象以下 &lt;code&gt;boost::function&lt;/code&gt; 和 &lt;code&gt;f&lt;/code&gt; 的任意定义：</target>
        </trans-unit>
        <trans-unit id="ef82f45cfb61fb4fecf8d59ce0e78f98cd2cc2f4" translate="yes" xml:space="preserve">
          <source>It might not be as easy as one thinks, more specifically the result of evaluating (&lt;em&gt;A&lt;/em&gt;) heavily &lt;em&gt;depends&lt;/em&gt; on the definition of the type passed as template-parameter &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">这可能并不像人们想象的那么容易，更具体地说，评估（ &lt;em&gt;A&lt;/em&gt; ）的结果在很大程度上&lt;em&gt;取决于&lt;/em&gt;作为模板参数 &lt;code&gt;T&lt;/code&gt; 传递的类型的定义。</target>
        </trans-unit>
        <trans-unit id="73f2eedcc9728afac38f277e768bc709f16765a2" translate="yes" xml:space="preserve">
          <source>Most of the rules are intuitive and are built up recursively: For example, a type constructed as &lt;code&gt;T[N]&lt;/code&gt; is a dependent type if &lt;code&gt;N&lt;/code&gt; is a value-dependent expression or &lt;code&gt;T&lt;/code&gt; is a dependent type. The details of this can be read in section &lt;code&gt;(14.6.2/1&lt;/code&gt;) for dependent types, &lt;code&gt;(14.6.2.2)&lt;/code&gt; for type-dependent expressions and &lt;code&gt;(14.6.2.3)&lt;/code&gt; for value-dependent expressions.</source>
          <target state="translated">大多数规则是直观的，并且是递归建立的：例如，如果 &lt;code&gt;N&lt;/code&gt; 是一个值相关的表达式或 &lt;code&gt;T&lt;/code&gt; 是一个依赖类型，则构造为 &lt;code&gt;T[N]&lt;/code&gt; 的类型是一个依赖类型。 有关详细信息，请参阅 &lt;code&gt;(14.6.2/1&lt;/code&gt; ）部分中的相关类型， &lt;code&gt;(14.6.2.2)&lt;/code&gt; 部分中的类型相关表达式，以及 &lt;code&gt;(14.6.2.3)&lt;/code&gt; 部分中的值相关表达式。</target>
        </trans-unit>
        <trans-unit id="d33e5e8480f354dad4b6ad9367f25a40c9f9bdaa" translate="yes" xml:space="preserve">
          <source>Neither of statement (&lt;em&gt;E&lt;/em&gt;), (&lt;em&gt;F&lt;/em&gt;) or (&lt;em&gt;G&lt;/em&gt;) is valid if the compiler would interpret the &lt;em&gt;dependent-names&lt;/em&gt; as variables/functions (which as stated earlier is what happens if we don't explicitly say otherwise).</source>
          <target state="translated">如果编译器将&lt;em&gt;从属名称&lt;/em&gt;解释为变量/函数，则语句（ &lt;em&gt;E&lt;/em&gt; ），（ &lt;em&gt;F&lt;/em&gt; ）或（ &lt;em&gt;G&lt;/em&gt; ）均无效（如前所述，如果我们没有明确说明，则会发生这种情况）。</target>
        </trans-unit>
        <trans-unit id="d32a29935d2bd59d7cfd39a6135dbe57c5e8fc66" translate="yes" xml:space="preserve">
          <source>Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example &lt;code&gt;f((T)0)&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt; is a dependent name. In the Standard, this is specified at &lt;code&gt;(14.6.2/1)&lt;/code&gt;.</source>
          <target state="translated">本文并不是主要关注的问题，但仍然值得一提：函数名称是一个单独处理的异常。 标识符函数名称不依赖于自身，而是依赖于调用中使用的依赖于类型的参数表达式。 在示例 &lt;code&gt;f((T)0)&lt;/code&gt; 中 ， &lt;code&gt;f&lt;/code&gt; 是从属名称。 在标准中，这在 &lt;code&gt;(14.6.2/1)&lt;/code&gt; 中指定。</target>
        </trans-unit>
        <trans-unit id="7c3acfb0745ac40f78ce00a50115e3da33af5010" translate="yes" xml:space="preserve">
          <source>Note that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don't have to specify &lt;code&gt;typename&lt;/code&gt;, for example:</source>
          <target state="translated">请注意，这也适用于元函数或带有通用模板参数的事物。 但是，如果提供的template参数是显式类型，则不必指定 &lt;code&gt;typename&lt;/code&gt; ，例如：</target>
        </trans-unit>
        <trans-unit id="4a8107ce35efcfc3379410e30c887b0716e8c000" translate="yes" xml:space="preserve">
          <source>Now we are back to the same problem as with &lt;code&gt;typename&lt;/code&gt;. What if we can't know yet whether the name is a template when parsing the code? We will need to insert &lt;code&gt;template&lt;/code&gt; immediately before the template name, as specified by &lt;code&gt;14.2/4&lt;/code&gt;. This looks like:</source>
          <target state="translated">现在我们回到与 &lt;code&gt;typename&lt;/code&gt; 相同的问题。 如果在解析代码时我们还不知道名称是否是模板怎么办？ 根据 &lt;code&gt;14.2/4&lt;/code&gt; 的指定，我们需要在模板名称之前插入 &lt;code&gt;template&lt;/code&gt; 。 看起来像：</target>
        </trans-unit>
        <trans-unit id="247f001f459a71cf2ba6a5da92513d6caf7363e0" translate="yes" xml:space="preserve">
          <source>On the name of a dependent base class you are not allowed to write &lt;code&gt;typename&lt;/code&gt;. It's assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</source>
          <target state="translated">在从属基类的名称上，不允许您写 &lt;code&gt;typename&lt;/code&gt; 。 假定给定的名称是类类型名称。 对于基类列表和构造函数初始化器列表中的名称都是如此：</target>
        </trans-unit>
        <trans-unit id="a512f0af9594fedb9079383ef813cc685035c26f" translate="yes" xml:space="preserve">
          <source>PS2: Have a look at &lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot;&gt;typelists&lt;/a&gt;, notably in Andrei Alexandrescu's book: Modern C++ Design</source>
          <target state="translated">PS2：查看&lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot;&gt;类型列表&lt;/a&gt; ，特别是在Andrei Alexandrescu的书：Modern C ++ Design中</target>
        </trans-unit>
        <trans-unit id="bdbe5508b19afff8cb57579196c6516007ea9aae" translate="yes" xml:space="preserve">
          <source>PS: Have a look at &lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot;&gt;Boost::Variant&lt;/a&gt;</source>
          <target state="translated">PS：看看&lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot;&gt;Boost :: Variant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="3df155aafc1a199cca8ef6beb1b1d48c331e2365" translate="yes" xml:space="preserve">
          <source>Remember the initial quote above and how the Standard requires special handling for templates as well? Let's take the following innocent-looking example:</source>
          <target state="translated">还记得上面最初的那句话吗,还记得《标准》对模板也有特殊的处理要求吗?让我们以下面这个看起来很天真的例子为例。</target>
        </trans-unit>
        <trans-unit id="6ba008a6093affa2d41cdad9748159bc5cb6d20a" translate="yes" xml:space="preserve">
          <source>So there has to be a way to tell the compiler that certain names are types and that certain names aren't.</source>
          <target state="translated">所以必须有一种方法来告诉编译器,某些名字是类型,而某些名字不是。</target>
        </trans-unit>
        <trans-unit id="660674432116072d61b4a75c7efcf588fe3e6c94" translate="yes" xml:space="preserve">
          <source>Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.</source>
          <target state="translated">有些名称表示类型或模板。一般来说,每当遇到一个名称时,在继续解析包含该名称的程序之前,有必要确定该名称是否表示这些实体之一。确定这一点的过程被称为名称查找。</target>
        </trans-unit>
        <trans-unit id="8d79f76b53e088ead8ed9ed664f087d2b54ea07d" translate="yes" xml:space="preserve">
          <source>THE RATIONALE</source>
          <target state="translated">理由</target>
        </trans-unit>
        <trans-unit id="1e7bff13be2789a80f543841f8ca934baeda8abf" translate="yes" xml:space="preserve">
          <source>THE SOLUTION</source>
          <target state="translated">解决方法</target>
        </trans-unit>
        <trans-unit id="7d4bf11f65a833a43805734fc518cd4aba4e3ae0" translate="yes" xml:space="preserve">
          <source>Template names can not only occur after a &lt;code&gt;::&lt;/code&gt; but also after a &lt;code&gt;-&amp;gt;&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; in a class member access. You need to insert the keyword there too:</source>
          <target state="translated">模板名称不仅可以出现在 &lt;code&gt;::&lt;/code&gt; 之后,而且可以出现在 &lt;code&gt;-&amp;gt;&lt;/code&gt; 或之后 &lt;code&gt;.&lt;/code&gt; 在班级成员访问中。 您也需要在其中插入关键字：</target>
        </trans-unit>
        <trans-unit id="7e2e37676af9900b6b7d7b80a6d076dd3efe6361" translate="yes" xml:space="preserve">
          <source>That way the compiler will parse this properly rather than &lt;code&gt;t.get &amp;lt; int&lt;/code&gt;.</source>
          <target state="translated">这样，编译器将正确解析此内容，而不是 &lt;code&gt;t.get &amp;lt; int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="836511d1cb4791ee6d0d13c95ea85a78fe3910de" translate="yes" xml:space="preserve">
          <source>That's actually a valid &lt;em&gt;expression&lt;/em&gt;! It uses the less-than operator to compare &lt;code&gt;boost::function&lt;/code&gt; against zero (&lt;code&gt;int()&lt;/code&gt;), and then uses the greater-than operator to compare the resulting &lt;code&gt;bool&lt;/code&gt; against &lt;code&gt;f&lt;/code&gt;. However as you might well know, &lt;code&gt;boost::function&lt;/code&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot;&gt;in real life&lt;/a&gt; is a template, so the compiler knows (14.2/3):</source>
          <target state="translated">这实际上是一个有效的&lt;em&gt;表达式&lt;/em&gt; ！ 它使用小于运算符比较 &lt;code&gt;boost::function&lt;/code&gt; 与零（ &lt;code&gt;int()&lt;/code&gt; ），然后使用大于运算符比较生成的 &lt;code&gt;bool&lt;/code&gt; 与 &lt;code&gt;f&lt;/code&gt; 。 但是，您可能知道， &lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot;&gt;现实生活&lt;/a&gt;中的 &lt;code&gt;boost::function&lt;/code&gt; 是一个模板，因此编译器知道（14.2 / 3）：</target>
        </trans-unit>
        <trans-unit id="f35b88a4738b3645c1aef372f59ad3047b158b13" translate="yes" xml:space="preserve">
          <source>That's impressive, but can we do better? The language even goes further and &lt;em&gt;requires&lt;/em&gt; that an implementation again looks up &lt;code&gt;D::result_type&lt;/code&gt; when instantiating &lt;code&gt;D::f&lt;/code&gt; (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined &lt;code&gt;C&lt;/code&gt; like this</source>
          <target state="translated">令人印象深刻，但是我们可以做得更好吗？ 该语言甚至走得更远，并且&lt;em&gt;要求&lt;/em&gt;实现在实例化 &lt;code&gt;D::f&lt;/code&gt; 时再次查找 &lt;code&gt;D::result_type&lt;/code&gt; （即使它已在定义时发现其含义）。 当现在查找结果不同或导致歧义时，程序格式错误，必须给出诊断。 想象一下，如果我们这样定义 &lt;code&gt;C&lt;/code&gt; 会发生什么</target>
        </trans-unit>
        <trans-unit id="397b3aa358a31ed91afc3c84c5752f5669f499b0" translate="yes" xml:space="preserve">
          <source>The &quot;template&quot; keyword</source>
          <target state="translated">&quot;模板 &quot;关键词</target>
        </trans-unit>
        <trans-unit id="ab32972d5ca051abc115a7572997071871b757ac" translate="yes" xml:space="preserve">
          <source>The &quot;typename&quot; keyword</source>
          <target state="translated">&quot;类型名称 &quot;关键字</target>
        </trans-unit>
        <trans-unit id="059c8dc482f6fcec095abfac5e21cf05f38aaecd" translate="yes" xml:space="preserve">
          <source>The C++ Standard cares about our safety and well-being, at least in this case.</source>
          <target state="translated">C++标准关心我们的安全和福祉,至少在这种情况下是这样。</target>
        </trans-unit>
        <trans-unit id="75d71f350625c9208a970a84d0f2647c18d12e3d" translate="yes" xml:space="preserve">
          <source>The C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)</source>
          <target state="translated">C++11的规则使以下有效的C++03代码变得不规范(这不是C++委员会的本意,但很可能不会被修复)。</target>
        </trans-unit>
        <trans-unit id="d678b7bdd1a0680bb6cb738cb7515a1010d81457" translate="yes" xml:space="preserve">
          <source>The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:</source>
          <target state="translated">标准》精确地定义了一个构造是否是依赖性的规则。它把它们分成了逻辑上不同的组。一组抓类型,另一组抓表达式。表达式可以根据其值和类型来决定是否依赖。所以我们有了,并附上了典型的例子。</target>
        </trans-unit>
        <trans-unit id="9cfd62de43ae793e4b5c0bbaea489055b29010a9" translate="yes" xml:space="preserve">
          <source>The Standard is a bit unclear about what &lt;em&gt;exactly&lt;/em&gt; is a &lt;em&gt;dependent name&lt;/em&gt;. On a simple read (you know, the principle of least surprise), all it defines as a &lt;em&gt;dependent name&lt;/em&gt; is the special case for function names below. But since clearly &lt;code&gt;T::x&lt;/code&gt; also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition).</source>
          <target state="translated">该标准对于&lt;em&gt;确切&lt;/em&gt;的&lt;em&gt;从属名称&lt;/em&gt;尚不清楚。 简单阅读（您知道，最少惊奇的原理）后，它定义为&lt;em&gt;从属名称的全部&lt;/em&gt;就是下面函数名称的特例。 但由于显然也需要在实例化上下文中查找 &lt;code&gt;T::x&lt;/code&gt; ，因此它也必须是从属名称（很幸运，自C ++ 14中期开始，委员会已开始研究如何解决此令人困惑的定义） 。</target>
        </trans-unit>
        <trans-unit id="eaeb296948f681fa8c069b722bff11d7272cc610" translate="yes" xml:space="preserve">
          <source>The answer is: &lt;em&gt;We&lt;/em&gt; decide how the compiler should parse this. If &lt;code&gt;t::x&lt;/code&gt; is a dependent name, then we need to prefix it by &lt;code&gt;typename&lt;/code&gt; to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):</source>
          <target state="translated">答案是： &lt;em&gt;我们&lt;/em&gt;决定编译器应如何解析它。 如果 &lt;code&gt;t::x&lt;/code&gt; 是从属名称，则我们需要在其 &lt;code&gt;typename&lt;/code&gt; 加上类型名，以告知编译器以某种方式对其进行解析。 标准在（14.6 / 2）中说：</target>
        </trans-unit>
        <trans-unit id="e839e7bc0fb3047c1bdf6c7dbb6e9ae237507034" translate="yes" xml:space="preserve">
          <source>The general rule for putting the &lt;code&gt;typename&lt;/code&gt; keyword is mostly when you're using a template parameter and you want to access a nested &lt;code&gt;typedef&lt;/code&gt; or using-alias, for example:</source>
          <target state="translated">放置 &lt;code&gt;typename&lt;/code&gt; 关键字的一般规则通常是在使用模板参数并且要访问嵌套的 &lt;code&gt;typedef&lt;/code&gt; 或using-alias时进行，例​​如：</target>
        </trans-unit>
        <trans-unit id="cfc3f7e0b4137c99807273a259f51ca22659ff99" translate="yes" xml:space="preserve">
          <source>The general rules for adding the &lt;code&gt;template&lt;/code&gt; qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:</source>
          <target state="translated">添加 &lt;code&gt;template&lt;/code&gt; 限定符的一般规则大部分相似，不同之处在于它们通常涉及本身是模板化的struct / class的模板化成员函数（静态或其他），例如：</target>
        </trans-unit>
        <trans-unit id="83fdb65b86514ecc3d94eb5034b2904b19fc4647" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; doesn't always have to appear in the last part of a name. It can appear in the middle before a class name that's used as a scope, like in the following example</source>
          <target state="translated">关键字 &lt;code&gt;template&lt;/code&gt; 并不一定总是出现在名称的最后部分。 它可以出现在用作范围的类名的中间，如以下示例所示</target>
        </trans-unit>
        <trans-unit id="ea5c129366ce9cd9ab21f5cd93e125ca28bbc280" translate="yes" xml:space="preserve">
          <source>The keywords &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;em&gt;still&lt;/em&gt; a type-dependent name (after all &lt;code&gt;T&lt;/code&gt; is also type dependent). But &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; is known to be a type - the compiler will &quot;magically&quot; look into this kind of dependent types to figure this out.</source>
          <target state="translated">如果限定符是当前实例的成员，则现在不再需要关键字 &lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; 。 这里要记住的一个关键点是 &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; &lt;em&gt;仍然&lt;/em&gt;是类型相关的名称（毕竟 &lt;code&gt;T&lt;/code&gt; 也是类型相关的）。 但是已知 &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; 是一种类型-编译器将&amp;ldquo;神奇地&amp;rdquo;研究这种依赖类型以弄清楚这一点。</target>
        </trans-unit>
        <trans-unit id="077f4f3cb3b45d6c4da04d629251c33c46d6451d" translate="yes" xml:space="preserve">
          <source>The problem I have is in the &lt;code&gt;typedef Tail::inUnion&amp;lt;U&amp;gt; dummy&lt;/code&gt; line. I'm fairly certain that &lt;code&gt;inUnion&lt;/code&gt; is a dependent name, and VC++ is quite right in choking on it. I also know that I should be able to add &lt;code&gt;template&lt;/code&gt; somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. &lt;code&gt;inUnion&amp;lt;U&amp;gt;&lt;/code&gt; names a type and not a function?</source>
          <target state="translated">我 &lt;code&gt;typedef Tail::inUnion&amp;lt;U&amp;gt; dummy&lt;/code&gt; 的问题是在typedef Tail :: inUnion &amp;lt;U&amp;gt;虚拟行中。 我相当确定 &lt;code&gt;inUnion&lt;/code&gt; 是一个从属名称，而VC ++ 恰好可以使它窒息。 我也知道我应该能够在某个地方添加 &lt;code&gt;template&lt;/code&gt; ，以告诉编译器inUnion是模板ID。 但是到底在哪里？ 然后是否应该假设inUnion是一个类模板，即 &lt;code&gt;inUnion&amp;lt;U&amp;gt;&lt;/code&gt; 是一个类型而不是一个函数？</target>
        </trans-unit>
        <trans-unit id="f1c7bae603744472346dadfc7ea4dedeef3d82c9" translate="yes" xml:space="preserve">
          <source>The rules in the Standard states that you may apply the keywords as long as you are dealing with a &lt;em&gt;qualified-name&lt;/em&gt; (&lt;em&gt;K&lt;/em&gt;), but if the name isn't &lt;em&gt;qualified&lt;/em&gt; the application is ill-formed (&lt;em&gt;L&lt;/em&gt;).</source>
          <target state="translated">标准中的规则规定，只要您处理的是&lt;em&gt;限定名&lt;/em&gt; （ &lt;em&gt;K&lt;/em&gt; ），就可以应用关键字，但是如果名称&lt;em&gt;不合格，&lt;/em&gt;则应用程序格式不正确（ &lt;em&gt;L&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2bd5a78638dcace559982a14bbcc8b023fd7f274" translate="yes" xml:space="preserve">
          <source>The underlying purpose is the same; an explanation to &quot;When?&quot; and &quot;Why?&quot; &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; must be applied.</source>
          <target state="translated">基本目的是相同的； 对&amp;ldquo;何时？&amp;rdquo;的解释 和&amp;ldquo;为什么？&amp;rdquo; 必须使用 &lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10f33cad8fd8a2837a1e5c87042e16251d5742a6" translate="yes" xml:space="preserve">
          <source>There are certain contexts in &lt;em&gt;C++&lt;/em&gt; where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one &lt;em&gt;template-parameter&lt;/em&gt;.</source>
          <target state="translated">在&lt;em&gt;C ++&lt;/em&gt;中有某些上下文，必须明确告知编译器如何处理名称，并且所有这些上下文都有一个共同点；即，在某些情况下，编译器将被视为不正确。 它们至少取决于一个&lt;em&gt;模板参数&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4b3c376a5c02c3331f13cc34e60d67e0eda12a9" translate="yes" xml:space="preserve">
          <source>There are many names for which &lt;code&gt;typename&lt;/code&gt; is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with &lt;code&gt;T *f;&lt;/code&gt;, when &lt;code&gt;T&lt;/code&gt; is a type template parameter. But for &lt;code&gt;t::x * f;&lt;/code&gt; to be a declaration, it must be written as &lt;code&gt;typename t::x *f;&lt;/code&gt;. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:</source>
          <target state="translated">有许多名称不需要使用 &lt;code&gt;typename&lt;/code&gt; ，因为编译器可以通过模板定义中的适用名称查找来弄清楚如何解析结构本身-例如，使用 &lt;code&gt;T *f;&lt;/code&gt; ，当 &lt;code&gt;T&lt;/code&gt; 是类型模板参数时。 但是对于 &lt;code&gt;t::x * f;&lt;/code&gt; 要成为声明，必须将其写为 &lt;code&gt;typename t::x *f;&lt;/code&gt; 。 如果省略关键字，并且名称被视为非类型，但是在实例化发现它表示类型时，编译器会发出通常的错误消息。 有时，错误因此在定义时给出：</target>
        </trans-unit>
        <trans-unit id="193f977dcab6c47bd2d6b8470ad6dcab7bd03b03" translate="yes" xml:space="preserve">
          <source>This post is meant to be an &lt;em&gt;easy-to-read&lt;/em&gt; alternative to &lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;litb's post&lt;/a&gt;.</source>
          <target state="translated">该帖子旨在代替&lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;litb的帖子&lt;/a&gt; &lt;em&gt;易于阅读&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5a4896926029b3eb852f0d6a106ca34a09f5713" translate="yes" xml:space="preserve">
          <source>This post will offer an explanation to the relationship between &lt;em&gt;dependent-names&lt;/em&gt;, and the two keywords.</source>
          <target state="translated">这篇文章将解释&lt;em&gt;从属名称&lt;/em&gt;和这两个关键字之间的关系。</target>
        </trans-unit>
        <trans-unit id="8d3949e28211d7534133207cc300ac1efaad60d9" translate="yes" xml:space="preserve">
          <source>This valid C++03 code would bind &lt;code&gt;this-&amp;gt;f&lt;/code&gt; to &lt;code&gt;A::f&lt;/code&gt; at instantiation time and everything is fine. C++11 however immediately binds it to &lt;code&gt;B::f&lt;/code&gt; and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt;, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot;&gt;Dominance Rule&lt;/a&gt; applies and lookup will find &lt;code&gt;A::f&lt;/code&gt; instead.</source>
          <target state="translated">这个有效的C ++ 03代码将在实例化时将 &lt;code&gt;this-&amp;gt;f&lt;/code&gt; 绑定到 &lt;code&gt;A::f&lt;/code&gt; ，一切都很好。 但是，C ++ 11立即将其绑定到 &lt;code&gt;B::f&lt;/code&gt; 并在实例化时需要仔细检查，以检查查找是否仍然匹配。 但是，当实例化 &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt; ，将应用&amp;ldquo; &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot;&gt;优势规则&amp;rdquo;，&lt;/a&gt;并且查找将改为找到 &lt;code&gt;A::f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a29f6a4158f73a5ee76b40bdb5725dddd2048562" translate="yes" xml:space="preserve">
          <source>This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template's text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template's users (poor colleagues!) with errors made by a template's author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place.</source>
          <target state="translated">这种方法可以实现,实际上也是标准允许的一种可能的实现方式。这些编译器基本上会将模板的文本复制到内部缓冲区,只有在需要实例化的时候,才会解析模板,并可能检测到定义中的错误。但是,其他的实现者并没有因为模板作者的错误而打扰到模板的用户(可怜的同事!),而是选择在实例化之前就尽早检查模板,并在定义中给出错误,甚至在实例化之前就给出错误。</target>
        </trans-unit>
        <trans-unit id="ddec0732ccbb4210a2b6b99783ad2631b52a9cc7" translate="yes" xml:space="preserve">
          <source>Thus in this context you would need the &lt;code&gt;template&lt;/code&gt; keyword beforehand and call it like so:</source>
          <target state="translated">因此，在这种情况下，您需要事先使用 &lt;code&gt;template&lt;/code&gt; 关键字并按如下方式调用它：</target>
        </trans-unit>
        <trans-unit id="3090538eec535ec4cf723c65f5b6a6ba58cdbe5b" translate="yes" xml:space="preserve">
          <source>To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore &quot;dependent names&quot;. A name can take different forms - the Standard says:</source>
          <target state="translated">为了避免这个问题,我采用了对标准文本的简单解释。在所有表示从属类型或表达式的构造中,其中有一个子集表示名称。因此,这些名称就是 &quot;从属名称&quot;。一个名字可以有不同的形式----《标准》说:</target>
        </trans-unit>
        <trans-unit id="7698fca51994ddc6c138471b88e06e7c83afdd2d" translate="yes" xml:space="preserve">
          <source>To improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt;). A type referenced by such a name is known to be  the &lt;em&gt;current instantiation&lt;/em&gt;. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, &lt;code&gt;A::NestedClass&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are both current instantiations).</source>
          <target state="translated">为了改善这种情况，在C ++ 11中，该语言会跟踪类型引用封闭模板的时间。 要知道，该类型必须通过使用某种形式的名称来形成，该名称是其自己的名称（在上面， &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; ， &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt; ）。 此类名称引用的类型被称为&lt;em&gt;当前实例&lt;/em&gt; 。 如果形成名称的类型是成员/嵌套类（那么 &lt;code&gt;A::NestedClass&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 都是当前实例），则可能有多种类型都是当前实例。</target>
        </trans-unit>
        <trans-unit id="f8b8473f52f5d48a53b82b2e364a8ed8725c5fd0" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;g_tmpl&lt;/code&gt; have a valid definition we must explicitly tell the compiler that we expect a type in (&lt;em&gt;E&lt;/em&gt;), a &lt;em&gt;template-id&lt;/em&gt; and a &lt;em&gt;type&lt;/em&gt; in (&lt;em&gt;F&lt;/em&gt;), and a &lt;em&gt;template-id&lt;/em&gt; in (&lt;em&gt;G&lt;/em&gt;).</source>
          <target state="translated">为了使 &lt;code&gt;g_tmpl&lt;/code&gt; 具有有效的定义，我们必须明确地告诉编译器，我们期望（ &lt;em&gt;E&lt;/em&gt; ）中的&lt;em&gt;类型，&lt;/em&gt;在（ &lt;em&gt;F&lt;/em&gt; ）中的&lt;em&gt;模板ID&lt;/em&gt;和&lt;em&gt;类型&lt;/em&gt;以及在（ &lt;em&gt;G&lt;/em&gt; ）中的&lt;em&gt;模板ID&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="af6ebf3891ffb2ee30f2bf8858408c64c95c34f1" translate="yes" xml:space="preserve">
          <source>To prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a &lt;em&gt;dependent-name&lt;/em&gt; by &lt;em&gt;explicitly&lt;/em&gt; stating the intent anywhere we'd like to treat the name as either a &lt;em&gt;type-name&lt;/em&gt;, or a &lt;em&gt;template-id&lt;/em&gt;.</source>
          <target state="translated">为了防止实现可能遭受令人讨厌的意外，标准要求我们通过&lt;em&gt;明确地&lt;/em&gt;在意图将名称视为&lt;em&gt;type-name&lt;/em&gt;或&lt;em&gt;template-的&lt;/em&gt;任何地方&lt;em&gt;明确&lt;/em&gt;说明意图，来理清&lt;em&gt;依赖名称&lt;/em&gt;的歧义。 &lt;em&gt;id&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="29862938e768a917aab1960c6bbb6ae497b193e9" translate="yes" xml:space="preserve">
          <source>Try to explain what is going on in the following &lt;em&gt;function-template&lt;/em&gt;, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (&lt;em&gt;A&lt;/em&gt;)?</source>
          <target state="translated">尝试向自己，朋友或猫咪解释以下&lt;em&gt;功能模板&lt;/em&gt;中发生的事情； 标有（ &lt;em&gt;A&lt;/em&gt; ）的语句中发生了什么？</target>
        </trans-unit>
        <trans-unit id="87061df8bae25712e416ad7d53765e98b6719bd8" translate="yes" xml:space="preserve">
          <source>Type-dependent expressions (e.g: a cast to a type template parameter &lt;code&gt;(T)0&lt;/code&gt;)</source>
          <target state="translated">类型相关的表达式（例如：转换为类型模板参数 &lt;code&gt;(T)0&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="689c51725b427087666b6048cec59bcb29fcbece" translate="yes" xml:space="preserve">
          <source>Unknown specializations</source>
          <target state="translated">未知专业</target>
        </trans-unit>
        <trans-unit id="6026daccdfec39543979697858424c64ff4ef007" translate="yes" xml:space="preserve">
          <source>Use the keyword typename only in template declarations and definitions provided you have a qualified name that refers to a type and depends on a template parameter.</source>
          <target state="translated">只在模板声明和定义中使用关键字 typename,条件是你有一个限定的名称,它是指一个类型,并依赖于模板参数。</target>
        </trans-unit>
        <trans-unit id="763d8d416b60f842f2c2cc144e23011113e885a1" translate="yes" xml:space="preserve">
          <source>Value-dependent expressions (e.g: a non-type template parameter &lt;code&gt;N&lt;/code&gt;)</source>
          <target state="translated">依赖于值的表达式（例如：非类型模板参数 &lt;code&gt;N&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ceaafeab5b0bb21207a924ae3fb0e737282cd5e7" translate="yes" xml:space="preserve">
          <source>We have four &lt;em&gt;dependent&lt;/em&gt; names in the above snippet:</source>
          <target state="translated">上面的代码段中有四个&lt;em&gt;从属&lt;/em&gt;名称：</target>
        </trans-unit>
        <trans-unit id="526f7334186e1b9227cf705c33b09999cd0d98e8" translate="yes" xml:space="preserve">
          <source>We refer to such names, where there can be an ambiguity in interpretation, as; &quot;&lt;em&gt;dependent names&lt;/em&gt;&quot;.</source>
          <target state="translated">我们将这样的名称称为： &amp;ldquo; &lt;em&gt;从属名称&lt;/em&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="bbecf5660dbaf8d8ded1b52887f0ecd3180d34c3" translate="yes" xml:space="preserve">
          <source>What a dependant name refers to could be something different for each different instantiation of the template. As a consequence, C++ templates are subject to &quot;two-phase name lookup&quot;. When a template is initially parsed (before any instantiation takes place) the compiler looks up the non-dependent names. When a particular instantiation of the template takes place, the template parameters are known by then, and the compiler looks up dependent names.</source>
          <target state="translated">对于模板的每一个不同的实例化,依赖名所指的东西可能是不同的。因此,C++模板会受到 &quot;两阶段名称查找 &quot;的影响。当一个模板最初被解析时(在任何实例化之前),编译器会查找非依赖名。当模板的一个特定实例化发生时,模板参数已经知道了,编译器会查找依赖名。</target>
        </trans-unit>
        <trans-unit id="b8f6499ca71be3c23ce33c1b2a9f5b83685a4750" translate="yes" xml:space="preserve">
          <source>What's the purpose of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; 的目的是什么？</target>
        </trans-unit>
        <trans-unit id="bc52aff94964c77dc3a3b4fa138bce704fae73f4" translate="yes" xml:space="preserve">
          <source>Where and why do I have to put the “template” and “typename” keywords</source>
          <target state="translated">我为什么要把 &quot;模板 &quot;和 &quot;类型名称 &quot;关键字放在哪里,为什么要放在 &quot;模板 &quot;和 &quot;类型名称 &quot;关键字上?</target>
        </trans-unit>
        <trans-unit id="552a23a5cb320222a24f1cb81b66e05f546ad95e" translate="yes" xml:space="preserve">
          <source>While the rules in C++03 about when you need &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are largely reasonable, there is one annoying disadvantage of its formulation</source>
          <target state="translated">虽然C ++ 03中有关何时需要 &lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; 的规则在很大程度上是合理的，但其制定存在一个令人讨厌的缺点</target>
        </trans-unit>
        <trans-unit id="7b6897d54406a3105e58e6dc3fc5b5863dff0daa" translate="yes" xml:space="preserve">
          <source>You can try this knowledge on &lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;this answer&lt;/a&gt; and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).</source>
          <target state="translated">您可以在&lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;此答案&lt;/a&gt;上尝试这些知识，并在实际示例中查看上面的定义是否对您有意义（在该答案中重复的内容稍稍详细）。</target>
        </trans-unit>
        <trans-unit id="2efba1c1c4d9757ca6d366d4029d83dcd0b82fca" translate="yes" xml:space="preserve">
          <source>You might recommend to just wait till the user instantiates the template:</source>
          <target state="translated">你可能建议等用户实例化模板后再做。</target>
        </trans-unit>
        <trans-unit id="e48b0fa9b66fcdab66a1db676dd26515d8b3d55f" translate="yes" xml:space="preserve">
          <source>if we instantiate the template with type &lt;em&gt;Y&lt;/em&gt;, as in (&lt;em&gt;D&lt;/em&gt;), (&lt;em&gt;A&lt;/em&gt;) would instead consist of an expression that calculates the product of &lt;em&gt;123&lt;/em&gt; multiplied with some already declared variable &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">如果我们用（ &lt;em&gt;D&lt;/em&gt; ）实例化类型为&lt;em&gt;Y&lt;/em&gt;的模板，则（ &lt;em&gt;A&lt;/em&gt; ）将由一个表达式组成，该表达式计算&lt;em&gt;123&lt;/em&gt;乘以一些已经声明的变量&lt;em&gt;x的&lt;/em&gt;乘积。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
