<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/610245">
    <body>
      <group id="610245">
        <trans-unit id="81a4752786ca04ed1a7662da3ad6fd89d03fdd33" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;Can I just stick &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; in front of any name? I don't want to worry about the context in which they appear...&lt;/em&gt;&quot; - &lt;code&gt;Some C++ Developer&lt;/code&gt;</source>
          <target state="translated">&amp;laquo; &lt;em&gt;Могу ли я просто прикрепить &lt;code&gt;typename&lt;/code&gt; и &lt;code&gt;template&lt;/code&gt; к любому имени? Я не хочу беспокоиться о контексте, в котором они появляются ...&lt;/em&gt; &amp;raquo; - &lt;code&gt;Some C++ Developer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da314107a76c971fe9203b881ca2d5dc651b90a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;template&lt;/code&gt; however, is different in this regard, since there's no way of coming to a conclusion such as; &lt;em&gt;&quot;oh, this is a template, then this other thing must also be a template&quot;&lt;/em&gt;. This means that we apply &lt;code&gt;template&lt;/code&gt; directly in front of any &lt;em&gt;name&lt;/em&gt; that we'd like to treat as such.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; однако, отличается в этом отношении, так как нет никакого способа прийти к такому выводу, как; &lt;em&gt;&amp;laquo;О, это шаблон, тогда эта другая вещь также должна быть шаблоном&amp;raquo;&lt;/em&gt; . Это означает, что мы применяем &lt;code&gt;template&lt;/code&gt; непосредственно перед любым &lt;em&gt;именем,&lt;/em&gt; которое мы хотели бы рассматривать как таковое.</target>
        </trans-unit>
        <trans-unit id="3e6c4b85701f35fe30fbc34931dc03cfd7dda142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are usable in circumstances other than when declaring a template.</source>
          <target state="translated">&lt;code&gt;typename&lt;/code&gt; и &lt;code&gt;template&lt;/code&gt; могут использоваться при других обстоятельствах, чем при объявлении шаблона.</target>
        </trans-unit>
        <trans-unit id="7ca671f7a7070e1849b27be2dac38cb84d41ab25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Let's wait until the user instantiates the template, and then later find out the real meaning of &lt;code&gt;t::x * f;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Давайте подождем, пока пользователь не создаст экземпляр шаблона, а затем выясним реальное значение &lt;code&gt;t::x * f;&lt;/code&gt; &lt;/em&gt; &lt;em&gt;,&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c04d03f78f58040504cd81e4dc96e86c59640a8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The syntax allows &lt;code&gt;typename&lt;/code&gt; only before qualified names&lt;/em&gt; - it is therefor taken as granted that unqualified names are always known to refer to types if they do so.</source>
          <target state="translated">&lt;em&gt;Синтаксис разрешает использовать &lt;code&gt;typename&lt;/code&gt; только перед полными именами&lt;/em&gt; - поэтому считается, что неквалифицированные имена, как известно, всегда ссылаются на типы, если они это делают.</target>
        </trans-unit>
        <trans-unit id="e2ecf05f2de6fcde4001af850840dca6978b6c81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;NestedTrait&quot;&lt;/strong&gt;, which is a &lt;em&gt;template-id&lt;/em&gt;, depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;NestedTrait&amp;raquo;&lt;/strong&gt; , который является &lt;em&gt;идентификатором шаблона&lt;/em&gt; , зависит от &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; , и;</target>
        </trans-unit>
        <trans-unit id="7c3fd61616ef25b7bad12ae0f45164811952b743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;data&quot;&lt;/strong&gt;, which looks like a &lt;em&gt;member-function template&lt;/em&gt;, is indirectly a &lt;em&gt;dependent-name&lt;/em&gt; since the type of &lt;em&gt;foo&lt;/em&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;data&amp;raquo;&lt;/strong&gt; , который выглядит как &lt;em&gt;шаблон функции-члена&lt;/em&gt; , косвенно является &lt;em&gt;зависимым именем,&lt;/em&gt; поскольку тип &lt;em&gt;foo&lt;/em&gt; зависит от реализации &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edbe9c0a9a43ae825a9c6f8aaaf224b3d281ad41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; at the end of (&lt;em&gt;F&lt;/em&gt;) depends on &lt;em&gt;NestedTrait&lt;/em&gt;, which depends on &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, and;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;тип&amp;raquo;&lt;/strong&gt; в конце ( &lt;em&gt;F&lt;/em&gt; ) зависит от &lt;em&gt;NestedTrait&lt;/em&gt; , который зависит от &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; , и;</target>
        </trans-unit>
        <trans-unit id="8f60a89f51a419f36ed14856c476a0174be4ff9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&quot;type&quot;&lt;/strong&gt; depends on the instantiation of &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt;, which include &lt;code&gt;T&lt;/code&gt;, and;</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;тип&amp;raquo;&lt;/strong&gt; зависит от экземпляра &lt;code&gt;SomeTrait&amp;lt;T&amp;gt;&lt;/code&gt; , который включает &lt;code&gt;T&lt;/code&gt; , и;</target>
        </trans-unit>
        <trans-unit id="6f469f6e1084fdb25863f628728d09a97794a167" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;E&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="42bb91b7ab5f09937d85eff1c421efa46f42ab8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;F&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;F&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="5d6b157f6a08ec9e0c665dc0de45a07bc5ee1a60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;G&lt;/strong&gt;)</source>
          <target state="translated">&lt;strong&gt;G&lt;/strong&gt;)</target>
        </trans-unit>
        <trans-unit id="82ccd28c2dcf130545ef823fe89eddf360a2a00f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PREFACE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PREFACE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23803dbe26e6085fd2fa0883c19d0f2f27666b33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The two different scenarios&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Два разных сценария&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e811163b854bd2669c245ceb717edce8e12a537f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When specifying the bases of which a class inherits&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;При указании оснований, которые наследует класс&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="330d5ed944055f18e28c9497441117f20c14e6e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When the &lt;em&gt;template-id&lt;/em&gt; is the one being referred to in a derived class's &lt;em&gt;using-directive&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Когда &lt;em&gt;идентификатор шаблона&lt;/em&gt; ссылается в &lt;em&gt;директиве using&lt;/em&gt; производного класса&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="52b5f115a82e14ac063f13915cc23e1f11a5ebe8" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;This answer is meant to be a rather short and sweet one to answer (part of) the titled question. If you want an answer with more detail that explains why you have to put them there, please go &lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;Этот ответ должен быть довольно коротким и приятным, чтобы ответить (частично) на названный вопрос.&lt;/em&gt;&lt;/sub&gt; &lt;sub&gt;&lt;em&gt;Если вы хотите получить более подробный ответ, объясняющий, почему вы должны поместить его туда, перейдите &lt;a href=&quot;https://stackoverflow.com/a/613132/1381108&quot;&gt;сюда&lt;/a&gt; .&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="1bfe14eb10ca361b9d4ba80c600e5e0629d33b7b" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;Note&lt;/strong&gt;: Applying &lt;code&gt;typename&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt; in a context where it is not required is not considered good practice; just because you can do something, doesn't mean that you should.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;Примечание&lt;/strong&gt; : применение &lt;code&gt;typename&lt;/code&gt; или &lt;code&gt;template&lt;/code&gt; в контексте, где это не требуется, не считается хорошей практикой;&lt;/sup&gt; &lt;sup&gt;только то, что ты можешь что-то сделать, не означает, что ты должен это делать.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d3e3594e08ca6cc46a536e175af0955c908fe709" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dependent-name&lt;/em&gt; is &lt;strong&gt;any&lt;/strong&gt; name that directly, or indirectly, depends on a &lt;em&gt;template-parameter&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Зависимое имя&lt;/em&gt; - это &lt;strong&gt;любое&lt;/strong&gt; имя, которое прямо или косвенно зависит от &lt;em&gt;параметра шаблона&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="167311c32569b35652bc2a3316fd061fd6dd2919" translate="yes" xml:space="preserve">
          <source>A SNIPPET SAYS MORE THAN 1000 WORDS</source>
          <target state="translated">ФРАГМЕНТ ГОВОРИТ БОЛЕЕ 1000 СЛОВ.</target>
        </trans-unit>
        <trans-unit id="83157225247456f23e8d3702295867eda13efdd9" translate="yes" xml:space="preserve">
          <source>A compiler is required to catch the error when instantiating &lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt;. So you get the best of the two worlds: &quot;Delayed&quot; lookup protecting you if you could get in trouble with dependent base classes, and also &quot;Immediate&quot; lookup that frees you from &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;.</source>
          <target state="translated">Компилятор должен перехватить ошибку при создании экземпляра &lt;code&gt;D&amp;lt;int&amp;gt;::f&lt;/code&gt; . Таким образом, вы получаете лучшее из двух миров: поиск с &amp;laquo;задержкой&amp;raquo;, защищающий вас, если у вас могут возникнуть проблемы с зависимыми базовыми классами, а также поиск &amp;laquo;немедленный&amp;raquo;, который освобождает вас от имени &lt;code&gt;typename&lt;/code&gt; и &lt;code&gt;template&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c035f4cd7ec02fdb2cd82af3dcd6cec12757cd6b" translate="yes" xml:space="preserve">
          <source>A name is a use of an identifier (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1)</source>
          <target state="translated">Имя-это использование идентификатора (2.11),идентификатора оператора-функции (13.5),идентификатора функции-преобразования (12.3.2)или идентификатора шаблона (14.2),который обозначает сущность или метку (6.6.4,6.1).</target>
        </trans-unit>
        <trans-unit id="23519716491bc53d4e57fd893f7debfe498cf6c9" translate="yes" xml:space="preserve">
          <source>A name used in a template declaration or definition and that is dependent on a template-parameter is
  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified
  by the keyword typename.</source>
          <target state="translated">Имя,используемое в шаблонной декларации или определении и зависящее от шаблона-параметра,предполагается не называть тип,если только соответствующий поиск имени не найдет имя типа или имя не будет определено по ключевому слову &quot;type name&quot; (имя).</target>
        </trans-unit>
        <trans-unit id="1ad1d6ae245142dbfde495564ae1bd48307233e1" translate="yes" xml:space="preserve">
          <source>A similar gotcha exists for names that denote templates, as hinted at by the introductory text.</source>
          <target state="translated">Похожая логика существует и для имен,обозначающих шаблоны,на что указывает вводный текст.</target>
        </trans-unit>
        <trans-unit id="2f4d2698ac7315f563034d04e68543b3fea1b1a3" translate="yes" xml:space="preserve">
          <source>A value dependent expression &lt;code&gt;1 + N&lt;/code&gt; is not a name, but &lt;code&gt;N&lt;/code&gt; is. The subset of all dependent constructs that are names is called &lt;em&gt;dependent name&lt;/em&gt;. Function names, however, may have different meaning in different instantiations of a template, but unfortunately are not caught by this general rule.</source>
          <target state="translated">Зависимое от значения выражение &lt;code&gt;1 + N&lt;/code&gt; - это не имя, а &lt;code&gt;N&lt;/code&gt; . Подмножество всех зависимых конструкций, которые являются именами, называется &lt;em&gt;зависимым именем&lt;/em&gt; . Однако имена функций могут иметь разное значение в разных экземплярах шаблона, но, к сожалению, это общее правило не учитывается.</target>
        </trans-unit>
        <trans-unit id="d79f149012b5db95c6057f7219f9674ae527d19b" translate="yes" xml:space="preserve">
          <source>Additional notes and examples</source>
          <target state="translated">Дополнительные примечания и примеры</target>
        </trans-unit>
        <trans-unit id="d4dd3f21f569a21f8954d6bcd851637c10de00d5" translate="yes" xml:space="preserve">
          <source>Additionally there are contexts where &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are &lt;strong&gt;explicitly&lt;/strong&gt; disallowed:</source>
          <target state="translated">Кроме того, существуют контексты, в которых &lt;code&gt;typename&lt;/code&gt; и &lt;code&gt;template&lt;/code&gt; &lt;strong&gt;явно&lt;/strong&gt; запрещены:</target>
        </trans-unit>
        <trans-unit id="c219dd2dca62ca1f2584c5024fdf659813719f8e" translate="yes" xml:space="preserve">
          <source>After name lookup (3.4) finds that a name is a template-name, if this name is followed by a &amp;lt;, the &amp;lt; is
  always taken as the beginning of a template-argument-list and never as a name followed by the less-than
  operator.</source>
          <target state="translated">После того, как name lookup (3.4) обнаружит, что имя является шаблоном-именем, если за этим именем следует символ &amp;lt;, то &amp;lt;всегда берется как начало списка аргументов шаблона, а не как имя, за которым следует меньше чем оператор.</target>
        </trans-unit>
        <trans-unit id="b108398247f2fde4538343d83b5bd97b8ad56a6f" translate="yes" xml:space="preserve">
          <source>An identifier is just a plain sequence of characters / digits, while the next two are the &lt;code&gt;operator +&lt;/code&gt; and &lt;code&gt;operator type&lt;/code&gt; form. The last form is &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt;. All these are names, and by conventional use in the Standard, a name can also include qualifiers that say what namespace or class a name should be looked up in.</source>
          <target state="translated">Идентификатор - это просто последовательность символов / цифр, а следующие два - &lt;code&gt;operator +&lt;/code&gt; и форма &lt;code&gt;operator type&lt;/code&gt; . Последняя форма - это &lt;code&gt;template-name &amp;lt;argument list&amp;gt;&lt;/code&gt; . Все это имена, и при стандартном использовании в Стандарте имя может также включать квалификаторы, которые говорят, в каком пространстве имен или классе следует искать имя.</target>
        </trans-unit>
        <trans-unit id="81c49b052d928be1082ab24b20ce2665f9580dc8" translate="yes" xml:space="preserve">
          <source>As can be seen, we need the disambiguation keyword even if the compiler could perfectly figure out itself that &lt;code&gt;A::result_type&lt;/code&gt; can only be &lt;code&gt;int&lt;/code&gt; (and is hence a type), and &lt;code&gt;this-&amp;gt;g&lt;/code&gt; can only be the member template &lt;code&gt;g&lt;/code&gt; declared later (even if &lt;code&gt;A&lt;/code&gt; is explicitly specialized somewhere, that would not affect the code within that template, so its meaning cannot be affected by a later specialization of &lt;code&gt;A&lt;/code&gt;!).</source>
          <target state="translated">Как можно видеть, нам нужно ключевое слово устранения неоднозначности, даже если компилятор может сам понять, что &lt;code&gt;A::result_type&lt;/code&gt; может быть только &lt;code&gt;int&lt;/code&gt; (и, следовательно, является типом), а &lt;code&gt;this-&amp;gt;g&lt;/code&gt; может быть только шаблоном-членом &lt;code&gt;g&lt;/code&gt; , объявленным позже. (даже если &lt;code&gt;A&lt;/code&gt; где-то явно специализирован, это не повлияет на код в этом шаблоне, поэтому его специализация не может быть затронута последующей специализацией &lt;code&gt;A&lt;/code&gt; !).</target>
        </trans-unit>
        <trans-unit id="79ce6d8e6b3913b7a546df762dbeaed29ea26d47" translate="yes" xml:space="preserve">
          <source>Attempting to access &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; from inside the function will result in an error:</source>
          <target state="translated">Попытка доступа к &lt;code&gt;t.get&amp;lt;int&amp;gt;()&lt;/code&gt; из функции приведет к ошибке:</target>
        </trans-unit>
        <trans-unit id="81a893e4a9fabef8c12fe3918ba674192fd36862" translate="yes" xml:space="preserve">
          <source>Based on this notion, the language says that &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt;, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; (such as &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt;) are all &lt;em&gt;member of the current instantiation&lt;/em&gt;&lt;strong&gt;if&lt;/strong&gt; they are found to be members of a class that is the current instantiation or one of its non-dependent base classes (by just doing the name lookup immediately).</source>
          <target state="translated">Основываясь на этом понятии, язык говорит, что &lt;code&gt;CurrentInstantiation::Foo&lt;/code&gt; , &lt;code&gt;Foo&lt;/code&gt; и &lt;code&gt;CurrentInstantiationTyped-&amp;gt;Foo&lt;/code&gt; (например, &lt;code&gt;A *a = this; a-&amp;gt;Foo&lt;/code&gt; ) являются &lt;em&gt;членами текущего экземпляра,&lt;/em&gt; &lt;strong&gt;если&lt;/strong&gt; обнаружено, &lt;strong&gt;что&lt;/strong&gt; они являются членами класс, который является текущим экземпляром или одним из его независимых классов (просто выполняя поиск по имени).</target>
        </trans-unit>
        <trans-unit id="aa182f32a2b889bab8bb654d1c6efd34ac494dd1" translate="yes" xml:space="preserve">
          <source>C++11</source>
          <target state="translated">C++11</target>
        </trans-unit>
        <trans-unit id="7ec9396ea07c3217ea09c65fdc1877acc2f3a1f2" translate="yes" xml:space="preserve">
          <source>CAN I JUST STICK THE &lt;em&gt;KEYWORDS&lt;/em&gt; IN FRONT OF ANY NAME?</source>
          <target state="translated">Могу ли я просто вставлять &lt;em&gt;ключевые слова&lt;/em&gt; перед любым именем?</target>
        </trans-unit>
        <trans-unit id="7938dcdba09fa9194d35fd38e5e702630c956dfa" translate="yes" xml:space="preserve">
          <source>Current instantiation</source>
          <target state="translated">текущая инстанциация</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="864f4fdedd9126fb15ad913ea1c7d58bd7e1d941" translate="yes" xml:space="preserve">
          <source>Dependent function names</source>
          <target state="translated">Имена зависимых функций</target>
        </trans-unit>
        <trans-unit id="3f049d4603c79ebaec4e70cfb62ab63cfc6422b2" translate="yes" xml:space="preserve">
          <source>Dependent names</source>
          <target state="translated">Зависимые имена</target>
        </trans-unit>
        <trans-unit id="80e115f1bc8f5f6dc0f1430fb858a5daba5e52c8" translate="yes" xml:space="preserve">
          <source>Dependent types (e.g: a type template parameter &lt;code&gt;T&lt;/code&gt;)</source>
          <target state="translated">Зависимые типы (например, параметр шаблона типа &lt;code&gt;T&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8a421fb1c98aa08853006608fca450d4e2f3b469" translate="yes" xml:space="preserve">
          <source>Different &lt;code&gt;T&lt;/code&gt;s can drastically change the semantics involved.</source>
          <target state="translated">Различные &lt;code&gt;T&lt;/code&gt; могут радикально изменить семантику.</target>
        </trans-unit>
        <trans-unit id="f6504f0366c5e84396e1494226e00641b0cd0668" translate="yes" xml:space="preserve">
          <source>During the first phase, the parser needs to know if a dependant name is the name of a type or the name of a non-type. By default, a dependant name is assumed to be the name of a non-type. The typename keyword before a dependant name specifies that it is the name of a type.</source>
          <target state="translated">На первом этапе синтаксический анализатор должен знать,является ли зависимое имя именем типа или нет.По умолчанию зависимое имя принимается как имя нетипа.Ключевое слово типа перед зависимым именем указывает,что это имя типа.</target>
        </trans-unit>
        <trans-unit id="26e6a98595822c3428f17426deccc9b966757d5a" translate="yes" xml:space="preserve">
          <source>Every name written in a derived class's &lt;em&gt;base-specifier-list&lt;/em&gt; is already treated as a &lt;em&gt;type-name&lt;/em&gt;, explicitly specifying &lt;code&gt;typename&lt;/code&gt; is both ill-formed, and redundant.</source>
          <target state="translated">Каждое имя, записанное в списке &lt;em&gt;базовых спецификаторов&lt;/em&gt; производного класса, уже обрабатывается как &lt;em&gt;имя типа,&lt;/em&gt; поскольку явное указание &lt;code&gt;typename&lt;/code&gt; является некорректным и избыточным.</target>
        </trans-unit>
        <trans-unit id="9f84d1c16d0d0893c80abb26baf74107ad6ba732" translate="yes" xml:space="preserve">
          <source>Every time a &lt;em&gt;name&lt;/em&gt; denotes a type, &lt;strong&gt;all&lt;/strong&gt;&lt;em&gt;names&lt;/em&gt; involved must be either &lt;em&gt;type-names&lt;/em&gt; or &lt;em&gt;namespaces&lt;/em&gt;, with this in mind it's quite easy to see that we apply &lt;code&gt;typename&lt;/code&gt; at the beginning of our fully &lt;em&gt;qualified name&lt;/em&gt;.</source>
          <target state="translated">Каждый раз, когда &lt;em&gt;имя&lt;/em&gt; обозначает тип, &lt;strong&gt;все&lt;/strong&gt; задействованные &lt;em&gt;имена&lt;/em&gt; должны быть либо &lt;em&gt;именами типов,&lt;/em&gt; либо &lt;em&gt;пространствами имен&lt;/em&gt; , с учетом этого довольно легко увидеть, что мы применяем &lt;code&gt;typename&lt;/code&gt; в начале нашего полностью &lt;em&gt;определенного имени&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="47adaec317f0a9d2c7134ea1f923781d1c12aa2f" translate="yes" xml:space="preserve">
          <source>Examples and trivia</source>
          <target state="translated">Примеры и мелочи</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="499e8a71311f5b45ef7b0868a6f17f4d3544aaaf" translate="yes" xml:space="preserve">
          <source>For the people that have thick Standardese books on their shelf and that want to know what exactly I was talking about, I'll talk a bit about how this is specified in the Standard.</source>
          <target state="translated">Для людей,у которых на полке толстые книги Стандарта и которые хотят знать,о чем именно я говорил,я расскажу немного о том,как это указано в Стандарте.</target>
        </trans-unit>
        <trans-unit id="f6354646d0660057dd162dd60312a9d32319c52e" translate="yes" xml:space="preserve">
          <source>Given this struct and function:</source>
          <target state="translated">Учитывая эту структуру и функцию:</target>
        </trans-unit>
        <trans-unit id="71ddfb234bd60ba03d2e2d6677b4bbff9c588208" translate="yes" xml:space="preserve">
          <source>HOW TO HANDLE &lt;em&gt;DEPENDENT NAMES&lt;/em&gt;?</source>
          <target state="translated">КАК РАБОТАТЬ С &lt;em&gt;ЗАВИСИМЫМИ ИМЕНАМИ&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="3b8fb374b67841bad50ca4fcb74ac158a7ee5ef1" translate="yes" xml:space="preserve">
          <source>How should this be parsed? For many languages a compiler doesn't need to know the meaning of a name in order to parse and basically know what action a line of code does. In C++, the above however can yield vastly different interpretations depending on what &lt;code&gt;t&lt;/code&gt; means. If it's a type, then it will be a declaration of a pointer &lt;code&gt;f&lt;/code&gt;. However if it's not a type, it will be a multiplication. So the C++ Standard says at paragraph (3/7):</source>
          <target state="translated">Как это должно быть проанализировано? Для многих языков компилятору не нужно знать значение имени для анализа и, в основном, знать, какое действие выполняет строка кода. Однако в C ++ вышеприведенное может дать совершенно разные интерпретации в зависимости от того, что означает &lt;code&gt;t&lt;/code&gt; . Если это тип, то это будет объявление указателя &lt;code&gt;f&lt;/code&gt; . Однако, если это не тип, это будет умножение. Таким образом, стандарт C ++ говорит в пункте (3/7):</target>
        </trans-unit>
        <trans-unit id="82496a0ea3b6f2d8e59d952d53e9a80c47b69040" translate="yes" xml:space="preserve">
          <source>How will the compiler find out what a name &lt;code&gt;t::x&lt;/code&gt; refers to, if &lt;code&gt;t&lt;/code&gt; refers to a template type parameter? &lt;code&gt;x&lt;/code&gt; could be a static int data member that could be multiplied or could equally well be a nested class or typedef that could yield to a declaration. If a name has this property - that it can't be looked up until the actual template arguments are known - then it's called a &lt;em&gt;dependent name&lt;/em&gt; (it &quot;depends&quot; on the template parameters).</source>
          <target state="translated">Как компилятор узнает, на что ссылается имя &lt;code&gt;t::x&lt;/code&gt; , если &lt;code&gt;t&lt;/code&gt; ссылается на параметр типа шаблона? &lt;code&gt;x&lt;/code&gt; может быть статическим элементом данных int, который может быть умножен, или в равной степени может быть вложенным классом или typedef, который может уступить объявлению. Если у имени есть это свойство - его нельзя найти, пока фактические аргументы шаблона не известны - тогда оно называется &lt;em&gt;зависимым именем&lt;/em&gt; (оно &amp;laquo;зависит&amp;raquo; от параметров шаблона).</target>
        </trans-unit>
        <trans-unit id="80310f20942c0583891a7f45d0eb6646c9e2f39b" translate="yes" xml:space="preserve">
          <source>However, I'm not sure you're implementation of inUnion is correct. If I understand correctly, this class is not supposed to be instantiated, therefore the &quot;fail&quot; tab will never avtually fails. Maybe it would be better to indicates whether the type is in the union or not with a simple boolean value.</source>
          <target state="translated">Однако,я не уверен,что вы внедряете inUnion правильно.Если я правильно понимаю,этот класс не должен быть инстанцирован,поэтому вкладка &quot;fail&quot; никогда на самом деле не даст сбой.Может быть,было бы лучше указать,является ли тип в союзе или нет,с простым значением булева.</target>
        </trans-unit>
        <trans-unit id="ffcbdb8addba9bcaec3d37e740ec726d7b74fdad" translate="yes" xml:space="preserve">
          <source>I am placing JLBorges's excellent &lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot;&gt;response&lt;/a&gt; to a similar question verbatim from cplusplus.com, as it is the most succinct explanation I've read on the subject.</source>
          <target state="translated">Я помещаю превосходный &lt;a href=&quot;http://www.cplusplus.com/forum/general/122765/#msg669061&quot;&gt;ответ&lt;/a&gt; JLBorges на аналогичный дословный вопрос от cplusplus.com, так как это самое краткое объяснение, которое я читал по этому вопросу.</target>
        </trans-unit>
        <trans-unit id="9afbd33d83b082c42724dd2a0954b2a5084a9c0e" translate="yes" xml:space="preserve">
          <source>If nothing is stated, the &lt;em&gt;dependent-name&lt;/em&gt; will be considered to be either a variable, or a function.</source>
          <target state="translated">Если ничего не указано, &lt;em&gt;зависимое имя&lt;/em&gt; будет считаться либо переменной, либо функцией.</target>
        </trans-unit>
        <trans-unit id="248aa3b12203e10552b3af6c402294330055100c" translate="yes" xml:space="preserve">
          <source>If this was a Hollywood film, &lt;em&gt;dependent-names&lt;/em&gt; would be the disease that spreads through body contact, instantly affects its host to make it confused. Confusion that could, possibly, lead to an ill-formed perso-, erhm.. program.</source>
          <target state="translated">Если бы это был голливудский фильм, &lt;em&gt;зависимые имена&lt;/em&gt; были бы болезнью, которая распространяется через телесный контакт, мгновенно воздействуя на его хозяина, чтобы запутать его. Путаница, которая может, возможно, привести к плохо сформированной персо-, эээ ... программе.</target>
        </trans-unit>
        <trans-unit id="0bd90018a85e97f771d15515f6a3373c341702f0" translate="yes" xml:space="preserve">
          <source>If we instantiate the function-template with type &lt;em&gt;X&lt;/em&gt;, as in (&lt;em&gt;C&lt;/em&gt;), we will have a declaration of a &lt;em&gt;pointer-to int&lt;/em&gt; named &lt;em&gt;x&lt;/em&gt;, but;</source>
          <target state="translated">Если мы создадим экземпляр функции-шаблона с типом &lt;em&gt;X&lt;/em&gt; , как в ( &lt;em&gt;C&lt;/em&gt; ), у нас будет объявление &lt;em&gt;указателя на int с&lt;/em&gt; именем &lt;em&gt;x&lt;/em&gt; , но;</target>
        </trans-unit>
        <trans-unit id="ef47c5e71f44563ae042e5301468f27ca3a50614" translate="yes" xml:space="preserve">
          <source>Imagine what happens if we had a member function &lt;code&gt;h&lt;/code&gt; within the above defined &lt;code&gt;A&lt;/code&gt; class template</source>
          <target state="translated">Представьте, что произойдет, если у нас будет функция-член &lt;code&gt;h&lt;/code&gt; в определенном выше шаблоне класса &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="231bd1ef6bfd0592631e7e9517ce774ad2be57d2" translate="yes" xml:space="preserve">
          <source>In C++03, the language allowed to catch this error because there could never be a valid way to instantiate &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; (whatever argument you give to &lt;code&gt;T&lt;/code&gt;). In C++11, the language now has a further check to give more reason for compilers to implement this rule. Since &lt;code&gt;A&lt;/code&gt; has no dependent base classes, and &lt;code&gt;A&lt;/code&gt; declares no member &lt;code&gt;questionable_type&lt;/code&gt;, the name &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; is &lt;em&gt;neither&lt;/em&gt; a member of the current instantiation &lt;em&gt;nor&lt;/em&gt; a member of an unknown specialization. In that case, there should be no way that that code could validly compile at instantiation time, so the language forbids a name where the qualifier is the current instantiation to be neither a member of an unknown specialization nor a member of the current instantiation (however, this violation is still not required to be diagnosed).</source>
          <target state="translated">В C ++ 03 язык позволял отлавливать эту ошибку, потому что никогда не было правильного способа создания экземпляра &lt;code&gt;A&amp;lt;T&amp;gt;::h&lt;/code&gt; (какой бы аргумент вы не указали для &lt;code&gt;T&lt;/code&gt; ). В C ++ 11 у языка теперь есть дополнительная проверка, чтобы дать больше оснований для компиляторов реализовать это правило. Поскольку &lt;code&gt;A&lt;/code&gt; не имеет зависимых базовых классов, а &lt;code&gt;A&lt;/code&gt; не объявляет члена &lt;code&gt;questionable_type&lt;/code&gt; , имя &lt;code&gt;A&amp;lt;T&amp;gt;::questionable_type&lt;/code&gt; является &lt;em&gt;ни&lt;/em&gt; членом текущей реализации, &lt;em&gt;ни&lt;/em&gt; членом неизвестной специализации. В этом случае не должно быть способа, чтобы этот код мог корректно компилироваться во время создания экземпляра, поэтому язык запрещает имени, в котором квалификатор является текущим экземпляром, не быть ни членом неизвестной специализации, ни членом текущего экземпляра (однако это нарушение до сих пор не требуется для диагностики).</target>
        </trans-unit>
        <trans-unit id="0883b2e93b7c95f02702247700ebd9bfd0ecb687" translate="yes" xml:space="preserve">
          <source>In a template that we write, there are two kinds of names that could be used - dependant names and non- dependant names. A dependant name is a name that depends on a template parameter; a non-dependant name has the same meaning irrespective of what the template parameters are.</source>
          <target state="translated">В шаблоне,который мы пишем,есть два типа имен,которые можно использовать-зависимые и не зависимые имена.Зависимое имя-это имя,которое зависит от параметра шаблона;не зависимое имя имеет одинаковое значение независимо от того,что является параметром шаблона.</target>
        </trans-unit>
        <trans-unit id="55037dd35e4322e33ec43f44ef797ca6cfa06004" translate="yes" xml:space="preserve">
          <source>In enough cases we need both of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;. Your code should look like the following</source>
          <target state="translated">В достаточном количестве случаев нам нужны как &lt;code&gt;typename&lt;/code&gt; ,так и &lt;code&gt;template&lt;/code&gt; . Ваш код должен выглядеть следующим образом</target>
        </trans-unit>
        <trans-unit id="e25768be4a82668492653e98728599e15bc1b3b6" translate="yes" xml:space="preserve">
          <source>In order to parse a C++ program, the compiler needs to know whether certain names are types or not. The following example demonstrates that:</source>
          <target state="translated">Чтобы разобрать программу на Си++,компилятору необходимо знать,являются ли определенные имена типами или нет.Следующий пример демонстрирует это:</target>
        </trans-unit>
        <trans-unit id="723e24157fedb66459b8cb1e919fabf2d210f132" translate="yes" xml:space="preserve">
          <source>In some cases, the keywords are forbidden, as detailed below</source>
          <target state="translated">В некоторых случаях ключевые слова запрещены,как подробно описано ниже.</target>
        </trans-unit>
        <trans-unit id="6ff2869a81645404d269012800fd47e944df1110" translate="yes" xml:space="preserve">
          <source>In template declarations some constructs have different meanings depending on what template arguments you use to instantiate the template: Expressions may have different types or values, variables may have different types or function calls might end up calling different functions. Such constructs are generally said to &lt;em&gt;depend&lt;/em&gt; on template parameters.</source>
          <target state="translated">В объявлениях шаблона некоторые конструкции имеют разные значения в зависимости от того, какие аргументы шаблона вы используете для создания экземпляра шаблона: выражения могут иметь разные типы или значения, переменные могут иметь разные типы или вызовы функций могут в конечном итоге вызывать разные функции. Обычно говорят, что такие конструкции &lt;em&gt;зависят&lt;/em&gt; от параметров шаблона.</target>
        </trans-unit>
        <trans-unit id="607a8c1883367af22aab7a8e02fcba22f562537c" translate="yes" xml:space="preserve">
          <source>In templates, where and why do I have to put &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; on dependent names? What exactly are dependent names anyway? I have the following code:</source>
          <target state="translated">В шаблонах, где и почему я должен поставить &lt;code&gt;typename&lt;/code&gt; и &lt;code&gt;template&lt;/code&gt; на зависимые имена? Что именно являются зависимыми именами в любом случае? У меня есть следующий код:</target>
        </trans-unit>
        <trans-unit id="f50b1a4caa717e4ce30b40c50fdb5ffda75c32a7" translate="yes" xml:space="preserve">
          <source>In the code of &lt;code&gt;D&lt;/code&gt;, the name &lt;code&gt;typename D::questionable_type&lt;/code&gt; is not a member of the current instantiation. Instead the language marks it as a &lt;em&gt;member of an unknown specialization&lt;/em&gt;. In particular, this is always the case when you are doing &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; or &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; and either the dependent type is &lt;em&gt;not&lt;/em&gt; the current instantiation (in which case the compiler can give up and say &quot;we will look later what &lt;code&gt;Foo&lt;/code&gt; is) or it &lt;em&gt;is&lt;/em&gt; the current instantiation and the name was not found in it or its non-dependent base classes and there are also dependent base classes.</source>
          <target state="translated">В коде &lt;code&gt;D&lt;/code&gt; имя &lt;code&gt;typename D::questionable_type&lt;/code&gt; не является членом текущего экземпляра. Вместо этого язык помечает его как &lt;em&gt;члена неизвестной специализации&lt;/em&gt; . В частности, это всегда имеет место, когда вы выполняете &lt;code&gt;DependentTypeName::Foo&lt;/code&gt; или &lt;code&gt;DependentTypedName-&amp;gt;Foo&lt;/code&gt; , и либо зависимый тип &lt;em&gt;не&lt;/em&gt; является текущим экземпляром (в этом случае компилятор может отказаться и сказать &amp;laquo;мы посмотрим позже, что такое &lt;code&gt;Foo&lt;/code&gt; &amp;raquo; ). ) или это текущий экземпляр и имя не было найдено в нем или в его независимых классах, и существуют также зависимые базовые классы.</target>
        </trans-unit>
        <trans-unit id="a7ada29808422dbb9e24960c66d91349f17c4800" translate="yes" xml:space="preserve">
          <source>In using-declarations it's not possible to use &lt;code&gt;template&lt;/code&gt; after the last &lt;code&gt;::&lt;/code&gt;, and the C++ committee &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot;&gt;said&lt;/a&gt; not to work on a solution.</source>
          <target state="translated">В объявлениях об использовании невозможно использовать &lt;code&gt;template&lt;/code&gt; после last &lt;code&gt;::&lt;/code&gt; , и комитет C ++ &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109&quot;&gt;сказал, что&lt;/a&gt; не работает над решением.</target>
        </trans-unit>
        <trans-unit id="8421611d7923291b6537ffa9a5516e093fd2bf26" translate="yes" xml:space="preserve">
          <source>It might look obvious to a human reader. Not so for the compiler. Imagine the following arbitrary definition of &lt;code&gt;boost::function&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt;:</source>
          <target state="translated">Это может выглядеть очевидным для читателя. Не так для компилятора. Представьте себе следующее произвольное определение &lt;code&gt;boost::function&lt;/code&gt; и &lt;code&gt;f&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ef82f45cfb61fb4fecf8d59ce0e78f98cd2cc2f4" translate="yes" xml:space="preserve">
          <source>It might not be as easy as one thinks, more specifically the result of evaluating (&lt;em&gt;A&lt;/em&gt;) heavily &lt;em&gt;depends&lt;/em&gt; on the definition of the type passed as template-parameter &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Это может быть не так просто, как кажется, более конкретно, результат оценки ( &lt;em&gt;A&lt;/em&gt; ) сильно &lt;em&gt;зависит&lt;/em&gt; от определения типа, передаваемого как шаблон-параметр &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73f2eedcc9728afac38f277e768bc709f16765a2" translate="yes" xml:space="preserve">
          <source>Most of the rules are intuitive and are built up recursively: For example, a type constructed as &lt;code&gt;T[N]&lt;/code&gt; is a dependent type if &lt;code&gt;N&lt;/code&gt; is a value-dependent expression or &lt;code&gt;T&lt;/code&gt; is a dependent type. The details of this can be read in section &lt;code&gt;(14.6.2/1&lt;/code&gt;) for dependent types, &lt;code&gt;(14.6.2.2)&lt;/code&gt; for type-dependent expressions and &lt;code&gt;(14.6.2.3)&lt;/code&gt; for value-dependent expressions.</source>
          <target state="translated">Большинство правил интуитивно понятны и создаются рекурсивно: например, тип, созданный как &lt;code&gt;T[N]&lt;/code&gt; является зависимым типом, если &lt;code&gt;N&lt;/code&gt; является зависимым от значения выражением или &lt;code&gt;T&lt;/code&gt; является зависимым типом. Подробности этого можно прочитать в разделе &lt;code&gt;(14.6.2/1&lt;/code&gt; ) для зависимых типов, &lt;code&gt;(14.6.2.2)&lt;/code&gt; для зависимых от типа выражений и &lt;code&gt;(14.6.2.3)&lt;/code&gt; для зависимых от значения выражений.</target>
        </trans-unit>
        <trans-unit id="d33e5e8480f354dad4b6ad9367f25a40c9f9bdaa" translate="yes" xml:space="preserve">
          <source>Neither of statement (&lt;em&gt;E&lt;/em&gt;), (&lt;em&gt;F&lt;/em&gt;) or (&lt;em&gt;G&lt;/em&gt;) is valid if the compiler would interpret the &lt;em&gt;dependent-names&lt;/em&gt; as variables/functions (which as stated earlier is what happens if we don't explicitly say otherwise).</source>
          <target state="translated">Ни одно из утверждений ( &lt;em&gt;E&lt;/em&gt; ), ( &lt;em&gt;F&lt;/em&gt; ) или ( &lt;em&gt;G&lt;/em&gt; ) не является допустимым, если компилятор интерпретирует &lt;em&gt;зависимые имена&lt;/em&gt; как переменные / функции (что, как было сказано ранее, происходит, если мы явно не говорим иначе).</target>
        </trans-unit>
        <trans-unit id="d32a29935d2bd59d7cfd39a6135dbe57c5e8fc66" translate="yes" xml:space="preserve">
          <source>Not primarily a concern of this article, but still worth mentioning: Function names are an exception that are handled separately. An identifier function name is dependent not by itself, but by the type dependent argument expressions used in a call. In the example &lt;code&gt;f((T)0)&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt; is a dependent name. In the Standard, this is specified at &lt;code&gt;(14.6.2/1)&lt;/code&gt;.</source>
          <target state="translated">В первую очередь это не касается данной статьи, но все же стоит упомянуть: имена функций являются исключением, которые обрабатываются отдельно. Имя функции-идентификатора зависит не само по себе, а от зависимых от типа выражений аргументов, используемых в вызове. В примере &lt;code&gt;f((T)0)&lt;/code&gt; , &lt;code&gt;f&lt;/code&gt; является зависимым именем. В стандарте это указано в &lt;code&gt;(14.6.2/1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c3acfb0745ac40f78ce00a50115e3da33af5010" translate="yes" xml:space="preserve">
          <source>Note that this also applies for meta functions or things that take generic template parameters too. However, if the template parameter provided is an explicit type then you don't have to specify &lt;code&gt;typename&lt;/code&gt;, for example:</source>
          <target state="translated">Обратите внимание, что это также относится к мета-функциям или вещам, которые также принимают общие параметры шаблона. Однако, если предоставленный параметр шаблона является явным типом, вам не нужно указывать &lt;code&gt;typename&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="4a8107ce35efcfc3379410e30c887b0716e8c000" translate="yes" xml:space="preserve">
          <source>Now we are back to the same problem as with &lt;code&gt;typename&lt;/code&gt;. What if we can't know yet whether the name is a template when parsing the code? We will need to insert &lt;code&gt;template&lt;/code&gt; immediately before the template name, as specified by &lt;code&gt;14.2/4&lt;/code&gt;. This looks like:</source>
          <target state="translated">Теперь мы вернулись к той же проблеме, что и с &lt;code&gt;typename&lt;/code&gt; . Что если мы еще не можем знать, является ли имя шаблоном при разборе кода? Нам нужно будет вставить &lt;code&gt;template&lt;/code&gt; непосредственно перед именем шаблона, как указано в &lt;code&gt;14.2/4&lt;/code&gt; . Это выглядит так:</target>
        </trans-unit>
        <trans-unit id="247f001f459a71cf2ba6a5da92513d6caf7363e0" translate="yes" xml:space="preserve">
          <source>On the name of a dependent base class you are not allowed to write &lt;code&gt;typename&lt;/code&gt;. It's assumed that the name given is a class type name. This is true for both names in the base-class list and the constructor initializer list:</source>
          <target state="translated">На имя зависимого базового класса вы не можете писать &lt;code&gt;typename&lt;/code&gt; . Предполагается, что данное имя является именем типа класса. Это верно как для имен в списке базового класса, так и в списке инициализатора конструктора:</target>
        </trans-unit>
        <trans-unit id="a512f0af9594fedb9079383ef813cc685035c26f" translate="yes" xml:space="preserve">
          <source>PS2: Have a look at &lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot;&gt;typelists&lt;/a&gt;, notably in Andrei Alexandrescu's book: Modern C++ Design</source>
          <target state="translated">PS2: взгляните на &lt;a href=&quot;http://www.ddj.com/cpp/184403813&quot;&gt;списки типов&lt;/a&gt; , особенно в книге Андрея Александреску: современный дизайн C ++</target>
        </trans-unit>
        <trans-unit id="bdbe5508b19afff8cb57579196c6516007ea9aae" translate="yes" xml:space="preserve">
          <source>PS: Have a look at &lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot;&gt;Boost::Variant&lt;/a&gt;</source>
          <target state="translated">PS: Посмотрите на &lt;a href=&quot;http://www.boost.org/doc/libs/1_38_0/doc/html/variant.html&quot;&gt;Boost :: Variant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="3df155aafc1a199cca8ef6beb1b1d48c331e2365" translate="yes" xml:space="preserve">
          <source>Remember the initial quote above and how the Standard requires special handling for templates as well? Let's take the following innocent-looking example:</source>
          <target state="translated">Помните начальную цитату выше и то,как Стандарт требует особой обработки для шаблонов также? Давайте возьмем следующий невинный пример:</target>
        </trans-unit>
        <trans-unit id="6ba008a6093affa2d41cdad9748159bc5cb6d20a" translate="yes" xml:space="preserve">
          <source>So there has to be a way to tell the compiler that certain names are types and that certain names aren't.</source>
          <target state="translated">Поэтому должен быть способ сказать компилятору,что определенные имена-это типы,а определенные имена-нет.</target>
        </trans-unit>
        <trans-unit id="660674432116072d61b4a75c7efcf588fe3e6c94" translate="yes" xml:space="preserve">
          <source>Some names denote types or templates. In general, whenever a name is encountered it is necessary to determine whether that name denotes one of these entities before continuing to parse the program that contains it. The process that determines this is called name lookup.</source>
          <target state="translated">Некоторые имена обозначают типы или шаблоны.В общем,всякий раз,когда встречается имя,необходимо определить,обозначает ли это имя один из этих объектов,прежде чем продолжать разобрать программу,которая его содержит.Процесс,определяющий это,называется поиском имени.</target>
        </trans-unit>
        <trans-unit id="8d79f76b53e088ead8ed9ed664f087d2b54ea07d" translate="yes" xml:space="preserve">
          <source>THE RATIONALE</source>
          <target state="translated">РАЦИОНАЛЬНОЕ</target>
        </trans-unit>
        <trans-unit id="1e7bff13be2789a80f543841f8ca934baeda8abf" translate="yes" xml:space="preserve">
          <source>THE SOLUTION</source>
          <target state="translated">РЕШЕНИЕ</target>
        </trans-unit>
        <trans-unit id="7d4bf11f65a833a43805734fc518cd4aba4e3ae0" translate="yes" xml:space="preserve">
          <source>Template names can not only occur after a &lt;code&gt;::&lt;/code&gt; but also after a &lt;code&gt;-&amp;gt;&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; in a class member access. You need to insert the keyword there too:</source>
          <target state="translated">Имена шаблонов могут встречаться не только после &lt;code&gt;::&lt;/code&gt; , но и после &lt;code&gt;-&amp;gt;&lt;/code&gt; или &lt;code&gt;.&lt;/code&gt; в доступе члена класса. Вам также нужно вставить ключевое слово:</target>
        </trans-unit>
        <trans-unit id="7e2e37676af9900b6b7d7b80a6d076dd3efe6361" translate="yes" xml:space="preserve">
          <source>That way the compiler will parse this properly rather than &lt;code&gt;t.get &amp;lt; int&lt;/code&gt;.</source>
          <target state="translated">Таким образом, компилятор будет анализировать это правильно, а не &lt;code&gt;t.get &amp;lt; int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="836511d1cb4791ee6d0d13c95ea85a78fe3910de" translate="yes" xml:space="preserve">
          <source>That's actually a valid &lt;em&gt;expression&lt;/em&gt;! It uses the less-than operator to compare &lt;code&gt;boost::function&lt;/code&gt; against zero (&lt;code&gt;int()&lt;/code&gt;), and then uses the greater-than operator to compare the resulting &lt;code&gt;bool&lt;/code&gt; against &lt;code&gt;f&lt;/code&gt;. However as you might well know, &lt;code&gt;boost::function&lt;/code&gt;&lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot;&gt;in real life&lt;/a&gt; is a template, so the compiler knows (14.2/3):</source>
          <target state="translated">Это действительно правильное &lt;em&gt;выражение&lt;/em&gt; ! Он использует оператор меньше чем для сравнения &lt;code&gt;boost::function&lt;/code&gt; с нулем ( &lt;code&gt;int()&lt;/code&gt; ), а затем использует оператор больше чем для сравнения результирующего &lt;code&gt;bool&lt;/code&gt; с &lt;code&gt;f&lt;/code&gt; . Однако, как вы, наверное, знаете, &lt;code&gt;boost::function&lt;/code&gt; &lt;a href=&quot;http://www.boost.org/doc/libs/1_54_0/doc/html/function.html&quot;&gt;в реальной жизни&lt;/a&gt; является шаблоном, поэтому компилятор знает (14.2 / 3):</target>
        </trans-unit>
        <trans-unit id="f35b88a4738b3645c1aef372f59ad3047b158b13" translate="yes" xml:space="preserve">
          <source>That's impressive, but can we do better? The language even goes further and &lt;em&gt;requires&lt;/em&gt; that an implementation again looks up &lt;code&gt;D::result_type&lt;/code&gt; when instantiating &lt;code&gt;D::f&lt;/code&gt; (even if it found its meaning already at definition time). When now the lookup result differs or results in ambiguity, the program is ill-formed and a diagnostic must be given. Imagine what happens if we defined &lt;code&gt;C&lt;/code&gt; like this</source>
          <target state="translated">Это впечатляет, но мы можем сделать лучше? Язык даже идет дальше и &lt;em&gt;требует&lt;/em&gt; , чтобы реализация снова &lt;code&gt;D::result_type&lt;/code&gt; при создании экземпляра &lt;code&gt;D::f&lt;/code&gt; (даже если она нашла свое значение уже во время определения). Если теперь результат поиска отличается или приводит к неоднозначности, программа имеет неправильную форму и должна быть предоставлена ​​диагностика. Представьте себе, что произойдет, если мы определили &lt;code&gt;C&lt;/code&gt; так</target>
        </trans-unit>
        <trans-unit id="397b3aa358a31ed91afc3c84c5752f5669f499b0" translate="yes" xml:space="preserve">
          <source>The &quot;template&quot; keyword</source>
          <target state="translated">Ключевое слово &quot;шаблон&quot;</target>
        </trans-unit>
        <trans-unit id="ab32972d5ca051abc115a7572997071871b757ac" translate="yes" xml:space="preserve">
          <source>The &quot;typename&quot; keyword</source>
          <target state="translated">Ключевое слово &quot;имя&quot;</target>
        </trans-unit>
        <trans-unit id="059c8dc482f6fcec095abfac5e21cf05f38aaecd" translate="yes" xml:space="preserve">
          <source>The C++ Standard cares about our safety and well-being, at least in this case.</source>
          <target state="translated">Стандарт C++заботится о нашей безопасности и благополучии,по крайней мере,в этом случае.</target>
        </trans-unit>
        <trans-unit id="75d71f350625c9208a970a84d0f2647c18d12e3d" translate="yes" xml:space="preserve">
          <source>The C++11 rules make the following valid C++03 code ill-formed (which was not intended by the C++ committee, but will probably not be fixed)</source>
          <target state="translated">Правила C++11 делают следующий допустимый код на C++03 плохо оформленным (который не был задуман комитетом по C++,но,вероятно,не будет исправлен)</target>
        </trans-unit>
        <trans-unit id="d678b7bdd1a0680bb6cb738cb7515a1010d81457" translate="yes" xml:space="preserve">
          <source>The Standard defines precisely the rules by whether a construct is dependent or not. It separates them into logically different groups: One catches types, another catches expressions. Expressions may depend by their value and/or their type. So we have, with typical examples appended:</source>
          <target state="translated">Стандарт точно определяет правила по тому,является ли та или иная конструкция зависимой или нет.Он разделяет их на логически различные группы:Один ловит типы,другой-выражения.Выражения могут зависеть от их значения и или их типа.Так и есть,с добавлением типичных примеров:</target>
        </trans-unit>
        <trans-unit id="9cfd62de43ae793e4b5c0bbaea489055b29010a9" translate="yes" xml:space="preserve">
          <source>The Standard is a bit unclear about what &lt;em&gt;exactly&lt;/em&gt; is a &lt;em&gt;dependent name&lt;/em&gt;. On a simple read (you know, the principle of least surprise), all it defines as a &lt;em&gt;dependent name&lt;/em&gt; is the special case for function names below. But since clearly &lt;code&gt;T::x&lt;/code&gt; also needs to be looked up in the instantiation context, it also needs to be a dependent name (fortunately, as of mid C++14 the committee has started to look into how to fix this confusing definition).</source>
          <target state="translated">Стандарт немного неясно, что &lt;em&gt;именно&lt;/em&gt; является &lt;em&gt;зависимым именем&lt;/em&gt; . При простом прочтении (вы знаете, принцип наименьшего удивления) все, что он определяет как &lt;em&gt;зависимое имя,&lt;/em&gt; является особым случаем для имен функций ниже. Но так как явно &lt;code&gt;T::x&lt;/code&gt; также нужно искать в контексте реализации, оно также должно быть зависимым именем (к счастью, с середины C ++ 14 комитет начал искать способы исправления этого запутанного определения) ,</target>
        </trans-unit>
        <trans-unit id="eaeb296948f681fa8c069b722bff11d7272cc610" translate="yes" xml:space="preserve">
          <source>The answer is: &lt;em&gt;We&lt;/em&gt; decide how the compiler should parse this. If &lt;code&gt;t::x&lt;/code&gt; is a dependent name, then we need to prefix it by &lt;code&gt;typename&lt;/code&gt; to tell the compiler to parse it in a certain way. The Standard says at (14.6/2):</source>
          <target state="translated">Ответ таков: &lt;em&gt;мы&lt;/em&gt; решаем, как компилятор должен это проанализировать. Если &lt;code&gt;t::x&lt;/code&gt; является зависимым именем, то нам нужно добавить префикс к &lt;code&gt;typename&lt;/code&gt; , чтобы компилятор определенным образом проанализировал его. Стандарт говорит в (14,6 / 2):</target>
        </trans-unit>
        <trans-unit id="e839e7bc0fb3047c1bdf6c7dbb6e9ae237507034" translate="yes" xml:space="preserve">
          <source>The general rule for putting the &lt;code&gt;typename&lt;/code&gt; keyword is mostly when you're using a template parameter and you want to access a nested &lt;code&gt;typedef&lt;/code&gt; or using-alias, for example:</source>
          <target state="translated">Основное правило для &lt;code&gt;typename&lt;/code&gt; ключевого слова typename - это, в основном, когда вы используете параметр шаблона и хотите получить доступ к вложенному &lt;code&gt;typedef&lt;/code&gt; или using-alias, например:</target>
        </trans-unit>
        <trans-unit id="cfc3f7e0b4137c99807273a259f51ca22659ff99" translate="yes" xml:space="preserve">
          <source>The general rules for adding the &lt;code&gt;template&lt;/code&gt; qualifier are mostly similar except they typically involve templated member functions (static or otherwise) of a struct/class that is itself templated, for example:</source>
          <target state="translated">Общие правила добавления квалификатора &lt;code&gt;template&lt;/code&gt; в основном аналогичны, за исключением того, что они обычно включают шаблонные функции-члены (статические или иные) структуры / класса, который сам шаблонизирован, например:</target>
        </trans-unit>
        <trans-unit id="83fdb65b86514ecc3d94eb5034b2904b19fc4647" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; doesn't always have to appear in the last part of a name. It can appear in the middle before a class name that's used as a scope, like in the following example</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; ключевого слова не всегда должен появляться в последней части имени. Он может появляться в середине перед именем класса, которое используется в качестве области видимости, как в следующем примере</target>
        </trans-unit>
        <trans-unit id="ea5c129366ce9cd9ab21f5cd93e125ca28bbc280" translate="yes" xml:space="preserve">
          <source>The keywords &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are now not required anymore if the qualifier is a member of the current instantiation. A keypoint here to remember is that &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;em&gt;still&lt;/em&gt; a type-dependent name (after all &lt;code&gt;T&lt;/code&gt; is also type dependent). But &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; is known to be a type - the compiler will &quot;magically&quot; look into this kind of dependent types to figure this out.</source>
          <target state="translated">Ключевые слова &lt;code&gt;typename&lt;/code&gt; и &lt;code&gt;template&lt;/code&gt; больше не требуются, если классификатор является членом текущего экземпляра. Здесь следует помнить, что &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; по- &lt;em&gt;прежнему&lt;/em&gt; зависит от типа (в конце концов, &lt;code&gt;T&lt;/code&gt; также зависит от типа). Но &lt;code&gt;A&amp;lt;T&amp;gt;::result_type&lt;/code&gt; как известно, является типом - компилятор &amp;laquo;волшебным образом&amp;raquo; изучит этот тип зависимых типов, чтобы выяснить это.</target>
        </trans-unit>
        <trans-unit id="077f4f3cb3b45d6c4da04d629251c33c46d6451d" translate="yes" xml:space="preserve">
          <source>The problem I have is in the &lt;code&gt;typedef Tail::inUnion&amp;lt;U&amp;gt; dummy&lt;/code&gt; line. I'm fairly certain that &lt;code&gt;inUnion&lt;/code&gt; is a dependent name, and VC++ is quite right in choking on it. I also know that I should be able to add &lt;code&gt;template&lt;/code&gt; somewhere to tell the compiler that inUnion is a template-id. But where exactly? And should it then assume that inUnion is a class template, i.e. &lt;code&gt;inUnion&amp;lt;U&amp;gt;&lt;/code&gt; names a type and not a function?</source>
          <target state="translated">У меня проблема в &lt;code&gt;typedef Tail::inUnion&amp;lt;U&amp;gt; dummy&lt;/code&gt; строке typedef Tail :: inUnion &amp;lt;U&amp;gt; . Я вполне уверен, что &lt;code&gt;inUnion&lt;/code&gt; является зависимым именем, и VC ++ вполне прав, подавляя его. Я также знаю, что я должен иметь возможность добавить &lt;code&gt;template&lt;/code&gt; куда-нибудь, чтобы сообщить компилятору, что inUnion - это идентификатор шаблона. Но где именно? И следует ли тогда предполагать, что inUnion является шаблоном класса, то есть &lt;code&gt;inUnion&amp;lt;U&amp;gt;&lt;/code&gt; называет тип, а не функцию?</target>
        </trans-unit>
        <trans-unit id="f1c7bae603744472346dadfc7ea4dedeef3d82c9" translate="yes" xml:space="preserve">
          <source>The rules in the Standard states that you may apply the keywords as long as you are dealing with a &lt;em&gt;qualified-name&lt;/em&gt; (&lt;em&gt;K&lt;/em&gt;), but if the name isn't &lt;em&gt;qualified&lt;/em&gt; the application is ill-formed (&lt;em&gt;L&lt;/em&gt;).</source>
          <target state="translated">Правила Стандарта гласят, что вы можете применять ключевые слова до тех пор, пока вы имеете дело с &lt;em&gt;квалифицированным именем&lt;/em&gt; ( &lt;em&gt;K&lt;/em&gt; ), но если имя не является &lt;em&gt;квалифицированным,&lt;/em&gt; приложение неправильно сформировано ( &lt;em&gt;L&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="2bd5a78638dcace559982a14bbcc8b023fd7f274" translate="yes" xml:space="preserve">
          <source>The underlying purpose is the same; an explanation to &quot;When?&quot; and &quot;Why?&quot; &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; must be applied.</source>
          <target state="translated">Основная цель та же; объяснение &quot;Когда?&quot; и почему?&quot; &lt;code&gt;typename&lt;/code&gt; и &lt;code&gt;template&lt;/code&gt; должны быть применены.</target>
        </trans-unit>
        <trans-unit id="10f33cad8fd8a2837a1e5c87042e16251d5742a6" translate="yes" xml:space="preserve">
          <source>There are certain contexts in &lt;em&gt;C++&lt;/em&gt; where the compiler must explicitly be told how to treat a name, and all these contexts have one thing in common; they depend on at least one &lt;em&gt;template-parameter&lt;/em&gt;.</source>
          <target state="translated">В &lt;em&gt;C ++&lt;/em&gt; существуют определенные контексты, в которых компилятору нужно явно указывать, как обрабатывать имя, и у всех этих контекстов есть одна общая черта; они зависят как минимум от одного &lt;em&gt;шаблона-параметра&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a4b3c376a5c02c3331f13cc34e60d67e0eda12a9" translate="yes" xml:space="preserve">
          <source>There are many names for which &lt;code&gt;typename&lt;/code&gt; is not necessary, because the compiler can, with the applicable name lookup in the template definition, figure out how to parse a construct itself - for example with &lt;code&gt;T *f;&lt;/code&gt;, when &lt;code&gt;T&lt;/code&gt; is a type template parameter. But for &lt;code&gt;t::x * f;&lt;/code&gt; to be a declaration, it must be written as &lt;code&gt;typename t::x *f;&lt;/code&gt;. If you omit the keyword and the name is taken to be a non-type, but when instantiation finds it denotes a type, the usual error messages are emitted by the compiler. Sometimes, the error consequently is given at definition time:</source>
          <target state="translated">Существует много имен, для которых &lt;code&gt;typename&lt;/code&gt; не требуется, потому что компилятор может с помощью соответствующего поиска имени в определении шаблона выяснить, как анализировать саму конструкцию - например, с помощью &lt;code&gt;T *f;&lt;/code&gt; , когда &lt;code&gt;T&lt;/code&gt; является параметром шаблона типа. Но для &lt;code&gt;t::x * f;&lt;/code&gt; чтобы быть объявлением, оно должно быть записано как &lt;code&gt;typename t::x *f;&lt;/code&gt; , Если вы опускаете ключевое слово, а имя принимается как нетиповое, но когда экземпляр находит, что оно обозначает тип, компилятор выдает обычные сообщения об ошибках. Иногда ошибка, следовательно, дается во время определения:</target>
        </trans-unit>
        <trans-unit id="193f977dcab6c47bd2d6b8470ad6dcab7bd03b03" translate="yes" xml:space="preserve">
          <source>This post is meant to be an &lt;em&gt;easy-to-read&lt;/em&gt; alternative to &lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;litb's post&lt;/a&gt;.</source>
          <target state="translated">Этот пост предназначен для &lt;em&gt;удобной для чтения&lt;/em&gt; альтернативы сообщению &lt;a href=&quot;https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889&quot;&gt;Литба&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a4896926029b3eb852f0d6a106ca34a09f5713" translate="yes" xml:space="preserve">
          <source>This post will offer an explanation to the relationship between &lt;em&gt;dependent-names&lt;/em&gt;, and the two keywords.</source>
          <target state="translated">В этом посте будет дано объяснение связи между &lt;em&gt;именами-зависимостями&lt;/em&gt; и двумя ключевыми словами.</target>
        </trans-unit>
        <trans-unit id="8d3949e28211d7534133207cc300ac1efaad60d9" translate="yes" xml:space="preserve">
          <source>This valid C++03 code would bind &lt;code&gt;this-&amp;gt;f&lt;/code&gt; to &lt;code&gt;A::f&lt;/code&gt; at instantiation time and everything is fine. C++11 however immediately binds it to &lt;code&gt;B::f&lt;/code&gt; and requires a double-check when instantiating, checking whether the lookup still matches. However when instantiating &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt;, the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot;&gt;Dominance Rule&lt;/a&gt; applies and lookup will find &lt;code&gt;A::f&lt;/code&gt; instead.</source>
          <target state="translated">Этот действительный код C ++ 03 связывает &lt;code&gt;this-&amp;gt;f&lt;/code&gt; с &lt;code&gt;A::f&lt;/code&gt; во время создания экземпляра, и все в порядке. Однако C ++ 11 немедленно связывает его с &lt;code&gt;B::f&lt;/code&gt; и требует двойной проверки при создании экземпляра, проверяя, совпадает ли поиск по-прежнему. Однако, когда создается экземпляр &lt;code&gt;C&amp;lt;A&amp;gt;::g&lt;/code&gt; , применяется &lt;a href=&quot;http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)&quot;&gt;правило доминирования,&lt;/a&gt; и поиск найдет &lt;code&gt;A::f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a29f6a4158f73a5ee76b40bdb5725dddd2048562" translate="yes" xml:space="preserve">
          <source>This will work and actually is allowed by the Standard as a possible implementation approach. These compilers basically copy the template's text into an internal buffer, and only when an instantiation is needed, they parse the template and possibly detect errors in the definition. But instead of bothering the template's users (poor colleagues!) with errors made by a template's author, other implementations choose to check templates early on and give errors in the definition as soon as possible, before an instantiation even takes place.</source>
          <target state="translated">Это будет работать и фактически разрешено Стандартом в качестве возможного подхода к реализации.Эти компиляторы в основном копируют текст шаблона во внутренний буфер,и только тогда,когда требуется инстанцирование,они разбирают шаблон и,возможно,обнаруживают ошибки в определении.Но вместо того,чтобы беспокоить пользователей шаблона (бедных коллег!)ошибками,сделанными автором шаблона,другие реализации предпочитают проверять шаблоны на ранней стадии и давать ошибки в определении как можно быстрее,еще до того,как произойдет инстанцирование.</target>
        </trans-unit>
        <trans-unit id="ddec0732ccbb4210a2b6b99783ad2631b52a9cc7" translate="yes" xml:space="preserve">
          <source>Thus in this context you would need the &lt;code&gt;template&lt;/code&gt; keyword beforehand and call it like so:</source>
          <target state="translated">Таким образом, в этом контексте вам нужно заранее задать ключевое слово &lt;code&gt;template&lt;/code&gt; и назвать его так:</target>
        </trans-unit>
        <trans-unit id="3090538eec535ec4cf723c65f5b6a6ba58cdbe5b" translate="yes" xml:space="preserve">
          <source>To avoid this problem, I have resorted to a simple interpretation of the Standard text. Of all the constructs that denote dependent types or expressions, a subset of them represent names. Those names are therefore &quot;dependent names&quot;. A name can take different forms - the Standard says:</source>
          <target state="translated">Чтобы избежать этой проблемы,я прибегнул к простой интерпретации Стандартного текста.Из всех конструкций,которые обозначают зависимые типы или выражения,подмножество из них представляют имена.Поэтому эти имена являются &quot;зависимыми именами&quot;.Имя может принимать различные формы-говорит Стандарт:</target>
        </trans-unit>
        <trans-unit id="7698fca51994ddc6c138471b88e06e7c83afdd2d" translate="yes" xml:space="preserve">
          <source>To improve the situation, in C++11 the language tracks when a type refers to the enclosing template. To know that, the type must have been formed by using a certain form of name, which is its own name (in the above, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt;). A type referenced by such a name is known to be  the &lt;em&gt;current instantiation&lt;/em&gt;. There may be multiple types that are all the current instantiation if the type from which the name is formed is a member/nested class (then, &lt;code&gt;A::NestedClass&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are both current instantiations).</source>
          <target state="translated">Чтобы улучшить ситуацию, в C ++ 11 язык отслеживает, когда тип ссылается на включающий шаблон. Чтобы знать это, тип должен быть сформирован с использованием определенной формы имени, которая является его собственным именем (в приведенном выше примере &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;::A&amp;lt;T&amp;gt;&lt;/code&gt; ). Тип, на который ссылается такое имя, известен как &lt;em&gt;текущий экземпляр&lt;/em&gt; . Может быть несколько типов, которые являются текущими экземплярами, если тип, из которого сформировано имя, является классом member / nested (тогда &lt;code&gt;A::NestedClass&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; являются текущими экземплярами).</target>
        </trans-unit>
        <trans-unit id="f8b8473f52f5d48a53b82b2e364a8ed8725c5fd0" translate="yes" xml:space="preserve">
          <source>To make &lt;code&gt;g_tmpl&lt;/code&gt; have a valid definition we must explicitly tell the compiler that we expect a type in (&lt;em&gt;E&lt;/em&gt;), a &lt;em&gt;template-id&lt;/em&gt; and a &lt;em&gt;type&lt;/em&gt; in (&lt;em&gt;F&lt;/em&gt;), and a &lt;em&gt;template-id&lt;/em&gt; in (&lt;em&gt;G&lt;/em&gt;).</source>
          <target state="translated">Чтобы &lt;code&gt;g_tmpl&lt;/code&gt; имел правильное определение, мы должны явно указать компилятору, что мы ожидаем тип в ( &lt;em&gt;E&lt;/em&gt; ), &lt;em&gt;идентификатор шаблона&lt;/em&gt; и &lt;em&gt;тип&lt;/em&gt; в ( &lt;em&gt;F&lt;/em&gt; ), а также &lt;em&gt;идентификатор шаблона&lt;/em&gt; в ( &lt;em&gt;G&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="af6ebf3891ffb2ee30f2bf8858408c64c95c34f1" translate="yes" xml:space="preserve">
          <source>To prevent an implementation from potentially suffering from nasty surprises, the Standard mandates that we sort out the ambiguity of a &lt;em&gt;dependent-name&lt;/em&gt; by &lt;em&gt;explicitly&lt;/em&gt; stating the intent anywhere we'd like to treat the name as either a &lt;em&gt;type-name&lt;/em&gt;, or a &lt;em&gt;template-id&lt;/em&gt;.</source>
          <target state="translated">Чтобы предотвратить потенциальную реализацию реализации неприятных сюрпризов, Стандарт обязывает нас разобраться с неоднозначностью &lt;em&gt;зависимого имени&lt;/em&gt; , &lt;em&gt;явно&lt;/em&gt; указав намерение везде, где мы хотим, чтобы имя воспринималось как имя &lt;em&gt;типа&lt;/em&gt; или как &lt;em&gt;шаблон. идентификатор&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29862938e768a917aab1960c6bbb6ae497b193e9" translate="yes" xml:space="preserve">
          <source>Try to explain what is going on in the following &lt;em&gt;function-template&lt;/em&gt;, either to yourself, a friend, or perhaps your cat; what is happening in the statement marked (&lt;em&gt;A&lt;/em&gt;)?</source>
          <target state="translated">Попытайтесь объяснить, что происходит в следующем &lt;em&gt;шаблоне функции&lt;/em&gt; , для себя, друга или, возможно, вашей кошки; что происходит в выражении ( &lt;em&gt;A&lt;/em&gt; )?</target>
        </trans-unit>
        <trans-unit id="87061df8bae25712e416ad7d53765e98b6719bd8" translate="yes" xml:space="preserve">
          <source>Type-dependent expressions (e.g: a cast to a type template parameter &lt;code&gt;(T)0&lt;/code&gt;)</source>
          <target state="translated">Типозависимые выражения (например: приведение к параметру шаблона типа &lt;code&gt;(T)0&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="689c51725b427087666b6048cec59bcb29fcbece" translate="yes" xml:space="preserve">
          <source>Unknown specializations</source>
          <target state="translated">Неизвестные специализации</target>
        </trans-unit>
        <trans-unit id="6026daccdfec39543979697858424c64ff4ef007" translate="yes" xml:space="preserve">
          <source>Use the keyword typename only in template declarations and definitions provided you have a qualified name that refers to a type and depends on a template parameter.</source>
          <target state="translated">Используйте ключевое имя типа только в шаблонных декларациях и определениях при условии,что у Вас есть квалифицированное имя,которое относится к типу и зависит от параметра шаблона.</target>
        </trans-unit>
        <trans-unit id="763d8d416b60f842f2c2cc144e23011113e885a1" translate="yes" xml:space="preserve">
          <source>Value-dependent expressions (e.g: a non-type template parameter &lt;code&gt;N&lt;/code&gt;)</source>
          <target state="translated">Выражения, зависящие от значения (например, нетипичный параметр шаблона &lt;code&gt;N&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ceaafeab5b0bb21207a924ae3fb0e737282cd5e7" translate="yes" xml:space="preserve">
          <source>We have four &lt;em&gt;dependent&lt;/em&gt; names in the above snippet:</source>
          <target state="translated">У нас есть четыре &lt;em&gt;зависимых&lt;/em&gt; имени в приведенном выше фрагменте:</target>
        </trans-unit>
        <trans-unit id="526f7334186e1b9227cf705c33b09999cd0d98e8" translate="yes" xml:space="preserve">
          <source>We refer to such names, where there can be an ambiguity in interpretation, as; &quot;&lt;em&gt;dependent names&lt;/em&gt;&quot;.</source>
          <target state="translated">Мы ссылаемся на такие имена, где может быть неоднозначность в интерпретации, как; &amp;laquo; &lt;em&gt;зависимые имена&lt;/em&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="bbecf5660dbaf8d8ded1b52887f0ecd3180d34c3" translate="yes" xml:space="preserve">
          <source>What a dependant name refers to could be something different for each different instantiation of the template. As a consequence, C++ templates are subject to &quot;two-phase name lookup&quot;. When a template is initially parsed (before any instantiation takes place) the compiler looks up the non-dependent names. When a particular instantiation of the template takes place, the template parameters are known by then, and the compiler looks up dependent names.</source>
          <target state="translated">То,к чему относится зависимое имя,может быть чем-то различным для каждого различного воплощения шаблона.Как следствие,шаблоны C++подвержены &quot;двухфазному поиску имени&quot;.При первоначальном разборе шаблона (до того,как произойдет его инстанцирование)компилятор ищет не зависящие друг от друга имена.Когда происходит конкретное инстанцирование шаблона,параметры шаблона к этому времени известны,и компилятор ищет зависимые имена.</target>
        </trans-unit>
        <trans-unit id="b8f6499ca71be3c23ce33c1b2a9f5b83685a4750" translate="yes" xml:space="preserve">
          <source>What's the purpose of &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt;?</source>
          <target state="translated">Какова цель &lt;code&gt;typename&lt;/code&gt; и &lt;code&gt;template&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="bc52aff94964c77dc3a3b4fa138bce704fae73f4" translate="yes" xml:space="preserve">
          <source>Where and why do I have to put the “template” and “typename” keywords</source>
          <target state="translated">Где и почему я должен ставить ключевые слова &quot;шаблон&quot; и &quot;имя&quot;.</target>
        </trans-unit>
        <trans-unit id="552a23a5cb320222a24f1cb81b66e05f546ad95e" translate="yes" xml:space="preserve">
          <source>While the rules in C++03 about when you need &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; are largely reasonable, there is one annoying disadvantage of its formulation</source>
          <target state="translated">В то время как правила в C ++ 03 о том, когда вам нужно &lt;code&gt;typename&lt;/code&gt; и &lt;code&gt;template&lt;/code&gt; , в основном разумны, есть один досадный недостаток в его формулировке</target>
        </trans-unit>
        <trans-unit id="7b6897d54406a3105e58e6dc3fc5b5863dff0daa" translate="yes" xml:space="preserve">
          <source>You can try this knowledge on &lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;this answer&lt;/a&gt; and see whether the above definitions make sense for you on a real-world example (they are repeated slightly less detailed in that answer).</source>
          <target state="translated">Вы можете опробовать эти знания в &lt;a href=&quot;https://stackoverflow.com/a/14005063/34509&quot;&gt;этом ответе&lt;/a&gt; и посмотреть, имеют ли смысл приведенные выше определения для примера из реальной жизни (они повторяются чуть менее подробно в этом ответе).</target>
        </trans-unit>
        <trans-unit id="2efba1c1c4d9757ca6d366d4029d83dcd0b82fca" translate="yes" xml:space="preserve">
          <source>You might recommend to just wait till the user instantiates the template:</source>
          <target state="translated">Вы можете просто порекомендовать подождать,пока пользователь не инстанцирует шаблон:</target>
        </trans-unit>
        <trans-unit id="e48b0fa9b66fcdab66a1db676dd26515d8b3d55f" translate="yes" xml:space="preserve">
          <source>if we instantiate the template with type &lt;em&gt;Y&lt;/em&gt;, as in (&lt;em&gt;D&lt;/em&gt;), (&lt;em&gt;A&lt;/em&gt;) would instead consist of an expression that calculates the product of &lt;em&gt;123&lt;/em&gt; multiplied with some already declared variable &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">если мы создадим шаблон с типом &lt;em&gt;Y&lt;/em&gt; , как в ( &lt;em&gt;D&lt;/em&gt; ), вместо этого ( &lt;em&gt;A&lt;/em&gt; ) будет состоять из выражения, которое вычисляет произведение &lt;em&gt;123,&lt;/em&gt; умноженное на некоторую уже объявленную переменную &lt;em&gt;x&lt;/em&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
