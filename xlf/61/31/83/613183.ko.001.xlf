<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/613183">
    <body>
      <group id="613183">
        <trans-unit id="9c483d4be3d8a08fe699e69d364c831b1987c127" translate="yes" xml:space="preserve">
          <source>(People who answer &quot;It is not possible to sort a dict&quot; did not read the question! In fact, &quot;I can sort on the keys, but how can I sort based on the values?&quot; clearly means that he wants a list of the keys sorted according to the value of their values.)</source>
          <target state="translated">( &quot;dict을 정렬 할 수 없습니다&quot;라고 대답 한 사람들은 질문을 읽지 못했습니다! 사실, &quot;키를 기준으로 정렬 할 수 있지만 값을 기준으로 정렬 할 수있는 방법은 무엇입니까?&quot; 키는 해당 값의 값에 따라 정렬됩니다.)</target>
        </trans-unit>
        <trans-unit id="b1358a83c4ca5eecd5ab1c3e7cf5a028aa3553a7" translate="yes" xml:space="preserve">
          <source>(intermediate) dict storage</source>
          <target state="translated">(중급) dict 스토리지</target>
        </trans-unit>
        <trans-unit id="9fcd9b557aa59a50157b86092b80c7bc909d1021" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3.7/library/stdtypes.html#typesmapping&quot;&gt;Python 3.7 documentation&lt;/a&gt; says:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.7/library/stdtypes.html#typesmapping&quot;&gt;파이썬 3.7 문서&lt;/a&gt; 는 말합니다 :</target>
        </trans-unit>
        <trans-unit id="ec74c54e590b420a7a62f35e5c578e1cc0ca18c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/39424969/1150683&quot;&gt;As pointed out by Dilettant&lt;/a&gt;, Python 3.6 will now &lt;em&gt;keep the order&lt;/em&gt;! I thought I'd share a function I wrote that eases the sorting of an iterable (tuple, list, dict). In the latter case, you can sort either on keys or values, and it can take numeric comparison into account. &lt;strong&gt;Only for &amp;gt;= 3.6!&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/39424969/1150683&quot;&gt;Dilettant가 지적한 것처럼&lt;/a&gt; Python 3.6은 이제 &lt;em&gt;순서를 유지합니다&lt;/em&gt; ! 나는 iterable (tuple, list, dict)의 정렬을 용이하게하는 내가 작성한 함수를 공유한다고 생각했다. 후자의 경우 키 또는 값을 기준으로 정렬 할 수 있으며 숫자 비교를 고려할 수 있습니다. &lt;strong&gt;3.6 이상인 경우에만!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dce9fb42cf4701d0a8578100bb0321f09d9a70e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sorted_x&lt;/code&gt; will be a list of tuples sorted by the second element in each tuple. &lt;code&gt;dict(sorted_x) == x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sorted_x&lt;/code&gt; 는 각 튜플의 두 번째 요소별로 정렬 된 튜플 목록입니다. &lt;code&gt;dict(sorted_x) == x&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d8ff1f9032591ebf283b62753a8815882b515c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Input:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37368c978ce40b2560ff00ceca4687bf96ce3bd6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Original&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c6c60fe6197fe2f878be54d673aa3230c819f6f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rank&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Rank&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="afec97a1228becf6dc3f7caaba4540623d2dacc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rofl&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Rofl&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a80eb2aafbfee5e5c21e788960a022e85cd6810f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE: 5 DECEMBER 2015 using Python 3.5&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;업데이트 : Python 3.5를 사용하는 2015 년 12 월 5 일&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df65358c803c76e910ef5a42fb0381d832b1aef5" translate="yes" xml:space="preserve">
          <source>A list of (key, value) pairs, sorted by value:</source>
          <target state="translated">값으로 정렬 된 (키, 값) 쌍의 목록 :</target>
        </trans-unit>
        <trans-unit id="e4a4442862fdde43439113daa15c8e9e7f080fc7" translate="yes" xml:space="preserve">
          <source>A sorted list of dict values:</source>
          <target state="translated">정렬 된 dict 값 목록 :</target>
        </trans-unit>
        <trans-unit id="dbf5dda7d52d885540366a1275464bf6e980627a" translate="yes" xml:space="preserve">
          <source>Allow to output later as:</source>
          <target state="translated">나중에 다음과 같이 출력하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="ed0bb813561a8bed524a958aa483b8946fbe8eb3" translate="yes" xml:space="preserve">
          <source>And for those wishing to sort on keys instead of values:</source>
          <target state="translated">그리고 값 대신 키를 정렬하려는 사람들을 위해 :</target>
        </trans-unit>
        <trans-unit id="c486114656207e7446a90c8489bb1e93c51430c1" translate="yes" xml:space="preserve">
          <source>And maybe quite some Stack Overflow high decorated question and answer pages will receive variants of this information and many high quality answers will require a per version update too.</source>
          <target state="translated">그리고 아마도 꽤 많은 Stack Overflow 장식 질문 및 답변 페이지가이 정보의 변형을 수신 할 것이며 많은 고품질 답변은 버전 별 업데이트도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e69da0f4d69493d55947edf4eaa20f30d8100c29" translate="yes" xml:space="preserve">
          <source>As @ajcr rightfully notes: &quot;The order-preserving aspect of this new implementation is considered an implementation detail and should not be relied upon.&quot; (from the &lt;a href=&quot;https://docs.python.org/3.6/whatsnew/3.6.html&quot;&gt;whatsnew36&lt;/a&gt;) not nit picking, &lt;strong&gt;but&lt;/strong&gt; the citation was cut a bit pessimistic ;-). It continues as &quot; (this may change in the future, but it is desired to have this new dict implementation in the language for a few releases before changing the language spec to mandate order-preserving semantics for all current and future Python implementations; this also helps preserve backwards-compatibility with older versions of the language where random iteration order is still in effect, e.g. Python 3.5).&quot;</source>
          <target state="translated">@ajcr은 올바로 언급했듯이 &quot;이 새로운 구현의 순서 유지 측면은 구현 세부 사항으로 간주되며 의존해서는 안됩니다.&quot; ( &lt;a href=&quot;https://docs.python.org/3.6/whatsnew/3.6.html&quot;&gt;Whatsnew36에서&lt;/a&gt; ) nit picking이 &lt;strong&gt;아니라&lt;/strong&gt; 인용이 약간 비관적이었습니다. &quot;(이것은 미래에 변경 될 수 있지만, 현재 및 미래의 모든 파이썬 구현에 대한 순서 보존 의미를 요구하도록 언어 사양을 변경하기 전에 몇 가지 릴리스에 대해 언어로이 새로운 dict 구현을 갖는 것이 바람직합니다. &quot;임의의 반복 순서가 여전히 유효한 이전 버전의 언어 (예 : Python 3.5)와의 하위 호환성을 유지하는 데 도움이됩니다.&quot;</target>
        </trans-unit>
        <trans-unit id="52a47b1fdea635ca499ca1d09f0662aef883df43" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://docs.python.org/3.6/whatsnew/3.6.html&quot;&gt;Python 3.6&lt;/a&gt; the built-in dict will be ordered</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.6/whatsnew/3.6.html&quot;&gt;Python 3.6&lt;/a&gt; 부터 내장 dict이 주문됩니다</target>
        </trans-unit>
        <trans-unit id="b972899164820b6c0f7e9accaf856a4a0929888a" translate="yes" xml:space="preserve">
          <source>As proposed in 2012 by Raymond Hettinger (cf. mail on python-dev with subject &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2012-December/123028.html&quot;&gt;&quot;More compact dictionaries with faster iteration&quot;&lt;/a&gt;) and now (in 2016) announced in a mail by Victor Stinner to python-dev with subject &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2016-September/146327.html&quot;&gt;&quot;Python 3.6 dict becomes compact and gets a private version; and keywords become ordered&quot;&lt;/a&gt; due to the fix/implementation of issue 27350 &lt;a href=&quot;http://bugs.python.org/issue27350&quot;&gt;&quot;Compact and ordered dict&quot;&lt;/a&gt; in Python 3.6 we will now be able, to use a built-in dict to maintain insert order!!</source>
          <target state="translated">Raymond Hettinger가 2012 년에 제안한대로 ( &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2012-December/123028.html&quot;&gt;&quot;&lt;/a&gt; Python-dev의 메일은 &quot;더 빠른 반복을 가진 더 컴팩트 한 사전 &quot;이라는 제목으로), 그리고 지금 (2016 년) Victor Stinner의 메일에서 &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2016-September/146327.html&quot;&gt;&quot;Python 3.6 dict은&lt;/a&gt; Python 3.6에서 문제 27350 &lt;a href=&quot;http://bugs.python.org/issue27350&quot;&gt;&quot;Compact and ordered dict&quot;&lt;/a&gt; 의 수정 / 구현으로 인해 키워드가 정렬 됩니다. 이제 삽입 순서를 유지하기 위해 내장 dict를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d5547254dcda0df07510d9309cd9159871a8adf" translate="yes" xml:space="preserve">
          <source>As simple as: &lt;code&gt;sorted(dict1, key=dict1.get)&lt;/code&gt;</source>
          <target state="translated">다음과 같이 간단합니다. &lt;code&gt;sorted(dict1, key=dict1.get)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3797b807b9516560409c121ec971d9566f354ad2" translate="yes" xml:space="preserve">
          <source>Because of requirements to retain backward compatability with older versions of &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; I think the OrderedDict solution is very unwise. You want something that works with Python 2.7 and older versions.</source>
          <target state="translated">이전 버전의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; 과의 호환성을 유지해야하는 요구 사항 때문에 OrderedDict 솔루션이 매우 현명하지 않다고 생각합니다. Python 2.7 및 이전 버전에서 작동하는 것을 원합니다.</target>
        </trans-unit>
        <trans-unit id="7fc0dc1f68f48edeb0f785abf10d372c5da7884d" translate="yes" xml:space="preserve">
          <source>Before that, you had to use &lt;code&gt;OrderedDict&lt;/code&gt;.</source>
          <target state="translated">그 전에 &lt;code&gt;OrderedDict&lt;/code&gt; 를 사용해야했습니다.</target>
        </trans-unit>
        <trans-unit id="c22208bb5913ba1a21ed0fce5cb62a82702ac8b4" translate="yes" xml:space="preserve">
          <source>But the collections solution mentioned in another answer is absolutely superb, because you retrain a connection between the key and value which in the case of dictionaries is extremely important.</source>
          <target state="translated">그러나 다른 대답에서 언급 한 수집 솔루션은 절대적으로 훌륭합니다. 사전의 경우 매우 중요한 키와 가치 사이의 연결을 재교육하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fbb0426e443446e34151108776c55c22e8257235" translate="yes" xml:space="preserve">
          <source>Caveat Emptor (but also see below update 2017-12-15):</source>
          <target state="translated">Caveat Emptor (아래 업데이트 2017-12-15 참조) :</target>
        </trans-unit>
        <trans-unit id="9d115d8ada0328183de02344f8802046071e08b4" translate="yes" xml:space="preserve">
          <source>Changed in version 3.7: Dictionary order is guaranteed to be insertion
  order. This behavior was implementation detail of CPython from 3.6.</source>
          <target state="translated">버전 3.7으로 변경 : 사전 순서는 삽입 순서로 보장됩니다. 이 동작은 3.6의 CPython에 대한 구현 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="e19c1b8f3367d6bb8589ba3ddc967d6571b2adc1" translate="yes" xml:space="preserve">
          <source>Comments for improvement or &lt;a href=&quot;https://github.com/BramVanroy/PyLT3/blob/master/pylt3/type_helpers.py#L68-L100&quot;&gt;push requests&lt;/a&gt; welcome.</source>
          <target state="translated">개선 또는 &lt;a href=&quot;https://github.com/BramVanroy/PyLT3/blob/master/pylt3/type_helpers.py#L68-L100&quot;&gt;푸시 요청에&lt;/a&gt; 대한 의견은 환영합니다.</target>
        </trans-unit>
        <trans-unit id="1daaad0084c2604185e45c5a29dc6efeff0b7fce" translate="yes" xml:space="preserve">
          <source>Details:</source>
          <target state="translated">Details:</target>
        </trans-unit>
        <trans-unit id="5c1aa5fb50c6465a7277ccfd74b178f413c8e493" translate="yes" xml:space="preserve">
          <source>Dicts can't be sorted, but you can build a sorted list from them.</source>
          <target state="translated">딕 트는 정렬 할 수 없지만 정렬 된 목록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e40a7426836a868eacaad97b0d412b7ea487114e" translate="yes" xml:space="preserve">
          <source>Enjoy ;-)</source>
          <target state="translated">즐겨 ;-)</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="65d36a01a8f6776edbd6f75366a05b8607d1280b" translate="yes" xml:space="preserve">
          <source>For the sake of completeness, I am posting a solution using &lt;a href=&quot;http://docs.python.org/2/library/heapq.html&quot;&gt;heapq&lt;/a&gt;. Note, this method will work for both numeric and non-numeric values</source>
          <target state="translated">완벽을 기하기 위해 &lt;a href=&quot;http://docs.python.org/2/library/heapq.html&quot;&gt;heapq&lt;/a&gt; 사용하여 솔루션을 게시하고 있습니다. 이 방법은 숫자 값과 숫자가 아닌 값 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="db399e651953ade9b57a32080de18963dee9ed23" translate="yes" xml:space="preserve">
          <source>Good news, so the OP's original use case of mapping pairs retrieved from a database with unique string ids as keys and numeric values as values into a built-in Python v3.6+ dict, should now respect the insert order.</source>
          <target state="translated">희소식이므로, 고유 한 문자열 ID를 키로, 숫자 값을 내장 된 Python v3.6 + dict로 데이터베이스에서 검색 한 OP의 원래 매핑 쌍 사용 사례는 이제 삽입 순서를 존중해야합니다.</target>
        </trans-unit>
        <trans-unit id="4806c2364021b8f8145a30057c39a5142245883f" translate="yes" xml:space="preserve">
          <source>Here are the results:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="adf960a8b8a857e77270fac2da0ca550459a93d2" translate="yes" xml:space="preserve">
          <source>Here is a solution using zip on &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects&quot;&gt;&lt;code&gt;d.values()&lt;/code&gt; and &lt;code&gt;d.keys()&lt;/code&gt;&lt;/a&gt;.  A few lines down this link (on Dictionary view objects) is:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#dictionary-view-objects&quot;&gt; &lt;code&gt;d.values()&lt;/code&gt; 및 &lt;code&gt;d.keys()&lt;/code&gt; &lt;/a&gt; 에 zip을 사용하는 솔루션입니다. 이 링크 아래의 몇 줄은 (사전 뷰 객체에서) 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5553fa99d7898bf6baf1ed473e20967f3ae88ecc" translate="yes" xml:space="preserve">
          <source>Hopefully this will lead to a thin layer OrderedDict implementation as a first step. As @JimFasarakis-Hilliard indicated, some see use cases for the OrderedDict type also in the future. I think the Python community at large will carefully inspect, if this will stand the test of time, and what the next steps will be.</source>
          <target state="translated">바라건대 이것은 첫 번째 단계로 얇은 계층 OrderedDict 구현으로 이어질 것입니다. @ JimFasarakis-Hilliard가 지적했듯이 일부는 앞으로도 OrderedDict 유형의 사용 사례를 참조하십시오. 필자는 파이썬 커뮤니티가 시간의 시험을 견딜 수 있는지, 다음 단계는 무엇인지 신중하게 조사 할 것이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ec1e4c7c724bb8bea9c23a91011113e2f2dce7c1" translate="yes" xml:space="preserve">
          <source>How do I sort a dictionary by value</source>
          <target state="translated">사전을 값으로 정렬하는 방법</target>
        </trans-unit>
        <trans-unit id="2d20e1f4226bf31aba118ac772dcfafec34c1b21" translate="yes" xml:space="preserve">
          <source>I am writing this detailed explanation to illustrate what people often mean by &quot;I can easily sort a dictionary by key, but how do I sort by value&quot; - and I think the original post was trying to address such an issue. And the solution is to do sort of list of the keys, based on the values, as shown above.</source>
          <target state="translated">나는 사람들이 종종 &quot;키로 사전을 쉽게 정렬 할 수 있지만 어떻게 값으로 정렬 하는가&quot;라는 의미를 설명하기 위해이 상세한 설명을 작성하고있다. 그리고 해결책은 위에 표시된 것처럼 값을 기반으로 일종의 키 목록을 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="959049e8c5547d2bb3753b623ed264edbbd9fda4" translate="yes" xml:space="preserve">
          <source>I can sort on the keys, but how can I sort based on the values?</source>
          <target state="translated">키를 기준으로 정렬 할 수 있지만 값을 기준으로 정렬하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="cf03fa7d7a1dff31b72cb2e6339b0dd11fe1316e" translate="yes" xml:space="preserve">
          <source>I don't agree with the number one choice presented in another answer, because it throws away the keys.</source>
          <target state="translated">다른 답변에 제시된 최고의 선택에 동의하지 않습니다. 왜냐하면 키를 버리기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="19d2cfeb8686f9f94ff3c5c212c2fbe9482cc5a3" translate="yes" xml:space="preserve">
          <source>I had the same problem, and I solved it like this:</source>
          <target state="translated">나는 같은 문제가 있었고 다음과 같이 해결했다.</target>
        </trans-unit>
        <trans-unit id="5f8dfb8ec29a9b594931275862920fe35c9006d5" translate="yes" xml:space="preserve">
          <source>I have a dictionary of values read from two fields in a database: a string field and a numeric field. The string field is unique, so that is the key of the dictionary.</source>
          <target state="translated">데이터베이스의 두 필드 인 문자열 필드와 숫자 필드에서 읽은 값 사전이 있습니다. 문자열 필드는 고유하므로 사전의 키입니다.</target>
        </trans-unit>
        <trans-unit id="efe53f30fe5f776e51a72b8489c53c1531183537" translate="yes" xml:space="preserve">
          <source>I used the solution mentioned above (code shown below) and retained access to both keys and values and in my case the ordering was on the values, but the importance was the ordering of the keys after ordering the values.</source>
          <target state="translated">위에서 언급 한 솔루션 (아래에 표시된 코드)을 사용하고 키와 값 모두에 대한 액세스 권한을 유지했으며 내 경우에는 순서가 값에 있었지만 중요한 것은 값을 주문 한 후 키의 순서였습니다.</target>
        </trans-unit>
        <trans-unit id="4c8d9aebfdbaa5e8996cdbcb84a465efd240499e" translate="yes" xml:space="preserve">
          <source>If one wanted to sort the dictionary by keys, one could do something like:</source>
          <target state="translated">사전을 키별로 정렬하려면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="886372b4f6517e74b41633e914f09cd361177499" translate="yes" xml:space="preserve">
          <source>If say the resulting two column table expressions from a database query like:</source>
          <target state="translated">데이터베이스 쿼리에서 결과로 나오는 두 개의 열 테이블 표현식이 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="530ba384f53db272ae78357967535136cbbecd05" translate="yes" xml:space="preserve">
          <source>If values are numeric you may also use &lt;a href=&quot;https://docs.python.org/library/collections.html#collections.Counter&quot;&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt; from &lt;a href=&quot;https://docs.python.org/library/collections.html&quot;&gt;collections&lt;/a&gt;.</source>
          <target state="translated">값이 숫자 인 경우 &lt;a href=&quot;https://docs.python.org/library/collections.html&quot;&gt;컬렉션의&lt;/a&gt; &lt;a href=&quot;https://docs.python.org/library/collections.html#collections.Counter&quot;&gt; &lt;code&gt;Counter&lt;/code&gt; &lt;/a&gt; 를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbd7b56508ceabc7a444b4cb44034103a8911da3" translate="yes" xml:space="preserve">
          <source>If you construct a dictionary with the words as keys and the number of occurrences of each word as value, simplified here as:</source>
          <target state="translated">단어를 키로 사용하고 각 단어의 발생 횟수를 값으로 사용하여 사전을 구성하는 경우 다음과 같이 단순화하십시오.</target>
        </trans-unit>
        <trans-unit id="64ecdba5412ab42f84a81d39f72e0dd53bd25575" translate="yes" xml:space="preserve">
          <source>If you do not have Python 2.7 or higher, the best you can do is iterate over the values in a generator function. (There is an &lt;code&gt;OrderedDict&lt;/code&gt; for 2.4 and 2.6  &lt;a href=&quot;https://pypi.python.org/pypi/ordereddict&quot;&gt;here&lt;/a&gt;, but</source>
          <target state="translated">Python 2.7 이상이 없으면 생성기 함수의 값을 반복하는 것이 가장 좋습니다. (2.4 및 2.6에 대한 &lt;code&gt;OrderedDict&lt;/code&gt; 가 있지만</target>
        </trans-unit>
        <trans-unit id="278b19d2370d44e002afe3c1fc6c079884600a72" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;keys()&lt;/code&gt;, &lt;code&gt;values()&lt;/code&gt; or &lt;code&gt;items()&lt;/code&gt; then you'll iterate in sorted order by value.</source>
          <target state="translated">&lt;code&gt;keys()&lt;/code&gt; , &lt;code&gt;values()&lt;/code&gt; 또는 &lt;code&gt;items()&lt;/code&gt; 를 사용하면 값을 기준으로 정렬 된 순서대로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="8f399ae9716bd20bde525346fde7a8b306b49128" translate="yes" xml:space="preserve">
          <source>If you want the output as a dict, you can use &lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.OrderedDict&quot;&gt;&lt;code&gt;collections.OrderedDict&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">출력을 받아쓰기로하려면 &lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.OrderedDict&quot;&gt; &lt;code&gt;collections.OrderedDict&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="352391901b326f70d9722aa5957feff2e86c0255" translate="yes" xml:space="preserve">
          <source>If you want to sort the list in descending order, simply change the original sorting line to:</source>
          <target state="translated">목록을 내림차순으로 정렬하려면 원래 정렬 행을 다음과 같이 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="2f715ec4093e301ad450a610b8ed97fa6928b100" translate="yes" xml:space="preserve">
          <source>If your values are integers, and you use Python 2.7 or newer, you can use &lt;a href=&quot;http://docs.python.org/py3k/library/collections.html#collections.Counter&quot;&gt;&lt;code&gt;collections.Counter&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;dict&lt;/code&gt;. The &lt;code&gt;most_common&lt;/code&gt; method will give you all items, sorted by the value.</source>
          <target state="translated">값이 정수이고 Python 2.7 이상을 사용하는 경우 &lt;code&gt;dict&lt;/code&gt; 대신 &lt;a href=&quot;http://docs.python.org/py3k/library/collections.html#collections.Counter&quot;&gt; &lt;code&gt;collections.Counter&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다. &lt;code&gt;most_common&lt;/code&gt; 메소드는 값별로 정렬 된 모든 항목을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="118f05d8a2e734939f5c9a87703990a72f3b370f" translate="yes" xml:space="preserve">
          <source>In Python 2.7, simply do:</source>
          <target state="translated">Python 2.7에서는 간단히 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="290eeabec82e3c8aa1b1669ffc4f66d4350fb678" translate="yes" xml:space="preserve">
          <source>In Python3 since unpacking is not allowed &lt;a href=&quot;https://stackoverflow.com/a/15712231/4293057&quot;&gt;[1]&lt;/a&gt; we can use</source>
          <target state="translated">압축 풀기가 허용되지 않기 때문에 Python3에서 &lt;a href=&quot;https://stackoverflow.com/a/15712231/4293057&quot;&gt;[1]&lt;/a&gt; 우리는 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0ad5fc91cbcc7675741c91b9ee65980eb88733e8" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2017-December/151283.html&quot;&gt;mail to the python-dev list&lt;/a&gt;, Guido van Rossum declared:</source>
          <target state="translated">&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2017-December/151283.html&quot;&gt;python-dev list 로의 메일&lt;/a&gt; 에서 Guido van Rossum은 다음과 같이 선언했습니다.</target>
        </trans-unit>
        <trans-unit id="6c9df1b3e786b43b4e4309c26f53926445d92b86" translate="yes" xml:space="preserve">
          <source>In recent Python 2.7, we have the new &lt;a href=&quot;http://docs.python.org/dev/whatsnew/2.7.html#pep-372-adding-an-ordered-dictionary-to-collections&quot;&gt;OrderedDict&lt;/a&gt; type, which remembers the order in which the items were added.</source>
          <target state="translated">최근 Python 2.7에는 새로운 &lt;a href=&quot;http://docs.python.org/dev/whatsnew/2.7.html#pep-372-adding-an-ordered-dictionary-to-collections&quot;&gt;OrderedDict&lt;/a&gt; 유형이 있으며, 항목이 추가 된 순서를 기억합니다.</target>
        </trans-unit>
        <trans-unit id="f18ab52c8cda2aaae19915a2f953f63b9ac13f42" translate="yes" xml:space="preserve">
          <source>It can often be very handy to use &lt;b&gt;&lt;a href=&quot;http://docs.python.org/library/collections.html#collections.namedtuple&quot;&gt;namedtuple&lt;/a&gt;&lt;/b&gt;. For example, you have a dictionary of 'name' as keys and 'score' as values and you want to sort on 'score':</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;http://docs.python.org/library/collections.html#collections.namedtuple&quot;&gt;namedtuple&lt;/a&gt;&lt;/b&gt; 을 사용하는 것이 종종 편리 할 수 ​​있습니다. 예를 들어, 키로 'name'사전을 값으로 사용하고 'score'를 값으로 정렬하고 'score'로 정렬하려고합니다.</target>
        </trans-unit>
        <trans-unit id="82dd0273930eeb8d0cded8bf90e4f5874908aa18" translate="yes" xml:space="preserve">
          <source>It is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a list&amp;mdash;probably a list of tuples.</source>
          <target state="translated">사전을 정렬 할 수 없으며 정렬 된 사전을 표시하기 만합니다. 사전은 본질적으로 순서가 없지만 목록 및 튜플과 같은 다른 유형은 그렇지 않습니다. 따라서 정렬 된 값을 나타내는 순서화 된 데이터 유형이 필요합니다. 목록은 아마도 튜플 목록 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="f53089c5025a300c1602674ee911b01272ddb1ee" translate="yes" xml:space="preserve">
          <source>It's implemented using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot;&gt;skip list&lt;/a&gt; datastructure.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Skip_list&quot;&gt;건너 뛰기 목록&lt;/a&gt; 데이터 구조를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="8b093c2d7de28dc502a20988fff41ea9dee79fd6" translate="yes" xml:space="preserve">
          <source>Iterate through a dict and sort it by its values in descending order:</source>
          <target state="translated">dict을 반복하고 값을 내림차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="9a488d8b77c5a82e14ad0a8c7d6cee2e732d7f98" translate="yes" xml:space="preserve">
          <source>Just learned relevant skill from &lt;a href=&quot;https://www.coursera.org/learn/python-data/lecture/0ou0N/10-tuples&quot;&gt;Python for Everybody&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.coursera.org/learn/python-data/lecture/0ou0N/10-tuples&quot;&gt;Python for Everybody&lt;/a&gt; 에서 관련 기술을 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="821370123a14fead9d0d998f6afbf1d874bf9980" translate="yes" xml:space="preserve">
          <source>Keyword arguments and</source>
          <target state="translated">키워드 인수 및</target>
        </trans-unit>
        <trans-unit id="cc7cd315f64ab61fd5470b91dda121152e14fc52" translate="yes" xml:space="preserve">
          <source>Make it so. &quot;Dict keeps insertion order&quot; is the ruling. Thanks!</source>
          <target state="translated">그렇게 만들어. &quot;사전 삽입 순서 유지&quot;는 판결입니다. 감사!</target>
        </trans-unit>
        <trans-unit id="bfd1a90c4dbeb10c0b403fd2a2ae1866b05e4cb7" translate="yes" xml:space="preserve">
          <source>Note: I have read Stack Overflow question here &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/72899&quot;&gt;How do I sort a list of dictionaries by a value of the dictionary?&lt;/a&gt;&lt;/em&gt; and probably could change my code to have a list of dictionaries, but since I do not really need a list of dictionaries I wanted to know if there is a simpler solution to sort either in ascending or descending order.</source>
          <target state="translated">참고 : 스택 오버플로 질문을 읽었습니다 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/72899&quot;&gt;. 사전 값으로 사전 목록을 정렬하려면 어떻게합니까?&lt;/a&gt;&lt;/em&gt; 아마 사전 목록을 갖도록 코드를 변경할 수 있지만 실제로 사전 목록이 필요하지 않기 때문에 오름차순 또는 내림차순으로 정렬하는 더 간단한 솔루션이 있는지 알고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="408819897473bfb77d3c516efbbf8f673579b385" translate="yes" xml:space="preserve">
          <source>Now you can get the name and score of, let's say the second-best player (index=1) very Pythonically like this:</source>
          <target state="translated">이제 다음과 같이 이름과 점수를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae7aa805565edd7a15a84a8e18ac219891280628" translate="yes" xml:space="preserve">
          <source>Now your inverse has the values; each value has a list of applicable keys.</source>
          <target state="translated">이제 당신의 역은 가치가 있습니다; 각 값에는 적용 가능한 키 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aeca9101b56210db3d315f390311767a2bd5c775" translate="yes" xml:space="preserve">
          <source>Of course, remember, you need to use &lt;code&gt;OrderedDict&lt;/code&gt; because regular Python dictionaries don't keep the original order.</source>
          <target state="translated">물론, 정기적 인 파이썬 사전은 원래 순서를 유지하지 않기 때문에 &lt;code&gt;OrderedDict&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae09513ad49cfb20804117b7bfc30c26d62fef6a" translate="yes" xml:space="preserve">
          <source>Older Python</source>
          <target state="translated">오래된 파이썬</target>
        </trans-unit>
        <trans-unit id="002e9cd3e1b3bb58104645872a489641ac847e35" translate="yes" xml:space="preserve">
          <source>On the other hand, if one wanted to sort a dictionary by value (as is asked in the question), one could do the following:</source>
          <target state="translated">반면에 (질문에서 요청한대로) 값을 기준으로 사전을 정렬하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="670cf440797c924695825d054613bf9413218498" translate="yes" xml:space="preserve">
          <source>Or optimized slightly as suggested by John Fouhy:</source>
          <target state="translated">또는 John Fouhy가 제안한대로 약간 최적화되었습니다.</target>
        </trans-unit>
        <trans-unit id="53f109972bb7b732efeb6a6602aaa8aef220fa7b" translate="yes" xml:space="preserve">
          <source>Please notice that the order is not well defined (keys with the same value will be in an arbitrary order in the output list).</source>
          <target state="translated">순서가 잘 정의되어 있지 않습니다 (동일한 값을 가진 키는 출력 목록에서 임의 순서로 표시됨).</target>
        </trans-unit>
        <trans-unit id="3a83a5eb1861a79fd19fdd1708ed0b22c0422daa" translate="yes" xml:space="preserve">
          <source>Please remember to remove the parentheses after print if not using Python 3.0 or above</source>
          <target state="translated">Python 3.0 이상을 사용하지 않는 경우 인쇄 후 괄호를 제거하십시오</target>
        </trans-unit>
        <trans-unit id="c9ac9fb5a20750664c01162949392db65e25b3e8" translate="yes" xml:space="preserve">
          <source>Pretty much the same as &lt;a href=&quot;https://stackoverflow.com/a/613207/11044033&quot;&gt;Hank Gay's answer&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/613207/11044033&quot;&gt;행크 게이의 대답&lt;/a&gt; 과 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="e377e89cbd81cf623683d9ae7e1b9fe1cc7f52b8" translate="yes" xml:space="preserve">
          <source>Python 3.6+</source>
          <target state="translated">파이썬 3.6 이상</target>
        </trans-unit>
        <trans-unit id="bb66b974fdf0f8c8b76ea5f069cb666f826a5ccd" translate="yes" xml:space="preserve">
          <source>Raymond Hettinger kindly provided documentation explaining &quot;&lt;a href=&quot;https://dl.dropboxusercontent.com/u/3967849/sfmu2/_build/html/goal.html&quot;&gt;The Tech Behind Python 3.6 Dictionaries&lt;/a&gt;&quot; - from his San Francisco Python Meetup Group presentation 2016-DEC-08.</source>
          <target state="translated">Raymond Hettinger는 자신의 샌프란시스코 Python Meetup 그룹 프레젠테이션 2016-DEC-08에서 &quot; &lt;a href=&quot;https://dl.dropboxusercontent.com/u/3967849/sfmu2/_build/html/goal.html&quot;&gt;The Python Behind Python 3.6 사전&lt;/a&gt; &quot;을 설명하는 문서를 친절하게 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="b570bc1342430b1e36419ee96aa70709a1110b76" translate="yes" xml:space="preserve">
          <source>Sample Output:</source>
          <target state="translated">샘플 출력 :</target>
        </trans-unit>
        <trans-unit id="2778bde47201833596adec771077116147fdf473" translate="yes" xml:space="preserve">
          <source>So as in some human languages (e.g. German), usage shapes the language, and the will now has been declared ... in &lt;a href=&quot;https://docs.python.org/3.6/whatsnew/3.6.html&quot;&gt;whatsnew36&lt;/a&gt;.</source>
          <target state="translated">따라서 일부 인간 언어 (예 : 독일어)에서와 같이, 사용법은 언어를 형성하며, 의지는 이제 &lt;a href=&quot;https://docs.python.org/3.6/whatsnew/3.6.html&quot;&gt;whatsnew36&lt;/a&gt; 에서 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="6ee20f02ce5e51093230a6605abb3ba0ef24c9f3" translate="yes" xml:space="preserve">
          <source>So we can do the following:</source>
          <target state="translated">따라서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acda178446821b9b982130e1c2eae479224cee3a" translate="yes" xml:space="preserve">
          <source>So, the version 3.6 CPython side-effect of dict insertion ordering is now becoming part of the language spec (and not anymore only an implementation detail). That mail thread also surfaced some distinguishing design goals for &lt;code&gt;collections.OrderedDict&lt;/code&gt; as reminded by Raymond Hettinger during discussion.</source>
          <target state="translated">따라서 dict 삽입 순서의 버전 3.6 CPython 부작용은 이제 언어 사양의 일부가되었습니다 (더 이상 구현 세부 사항이 아님). 이 메일 쓰레드는 또한 &lt;code&gt;collections.OrderedDict&lt;/code&gt; 대한 독특한 디자인 목표를 보여주었습니다. 토론 중 Raymond Hettinger가 상기시킨 것처럼 DictedDict.</target>
        </trans-unit>
        <trans-unit id="e2ff0f9716602bfb0c7c228362251926e175097d" translate="yes" xml:space="preserve">
          <source>Starting from Python 3.6, &lt;code&gt;dict&lt;/code&gt; objects are now ordered by insertion order. It's officially in the specs of Python 3.7.</source>
          <target state="translated">Python 3.6부터 &lt;code&gt;dict&lt;/code&gt; 객체는 삽입 순서에 따라 정렬됩니다. 공식적으로 Python 3.7의 사양에 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd8309c1cbeeadfa4af4a1ccec904172f1e80356" translate="yes" xml:space="preserve">
          <source>The OrderedDict behaves like a normal dict:</source>
          <target state="translated">OrderedDict는 일반적인 dict처럼 행동합니다 :</target>
        </trans-unit>
        <trans-unit id="ebb83272d2dce81b6717969dfc804bf50bb3e4a4" translate="yes" xml:space="preserve">
          <source>The first because it eases dispatch in the implementation of functions and methods in some cases.</source>
          <target state="translated">첫 번째는 함수 및 메소드 구현시 디스패치를 ​​용이하게하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9d68e429e033414d865fbebd4cbdb4fe0e6b5fa4" translate="yes" xml:space="preserve">
          <source>The official &lt;strong&gt;&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.OrderedDict&quot;&gt;OrderedDict&lt;/a&gt;&lt;/strong&gt; documentation offers a very similar example too, but using a lambda for the sort function:</source>
          <target state="translated">공식 &lt;strong&gt;&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.OrderedDict&quot;&gt;OrderedDict&lt;/a&gt;&lt;/strong&gt; 문서도 비슷한 예를 제공하지만 정렬 함수에 람다를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eedd59787f2bab4913748421a0efb5693512979e" translate="yes" xml:space="preserve">
          <source>The result of this command (sorting the dictionary by value) should return the following:</source>
          <target state="translated">이 명령의 결과 (사전을 값으로 정렬)는 다음을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a73820a1781f576a897d199aa316d1226e59174" translate="yes" xml:space="preserve">
          <source>The second as it encourages to more easily use &lt;code&gt;dict&lt;/code&gt;s as intermediate storage in processing pipelines.</source>
          <target state="translated">두 번째는 &lt;code&gt;dict&lt;/code&gt; s를 파이프 라인 처리에서 중간 스토리지로보다 쉽게 ​​사용하도록 권장합니다.</target>
        </trans-unit>
        <trans-unit id="a48bd8b6729e278c7c49e866644b5cf1f3d55550" translate="yes" xml:space="preserve">
          <source>This allows the creation of (value, key) pairs using zip(): pairs = zip(d.values(), d.keys()).</source>
          <target state="translated">이렇게하면 zip ()을 사용하여 (값, 키) 쌍을 만들 수 있습니다. pairs = zip (d.values ​​(), d.keys ()).</target>
        </trans-unit>
        <trans-unit id="5a337b8a023f3824abade0a69a5fe8f99c3fed0e" translate="yes" xml:space="preserve">
          <source>This is the code:</source>
          <target state="translated">이것은 코드입니다.</target>
        </trans-unit>
        <trans-unit id="6eae14349c019a73b4592f1376a60662768f3a3d" translate="yes" xml:space="preserve">
          <source>This should return the following output:</source>
          <target state="translated">다음 출력을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="76ba6dd4c54ccf5824f678894b125a4864da152a" translate="yes" xml:space="preserve">
          <source>This will sort the dictionary by the values of each entry within the dictionary from smallest to largest.</source>
          <target state="translated">사전에서 각 항목의 값을 최소에서 최대로 정렬하여 사전을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="e0f74d83524194ea3290a4eb0ac96ada5160edc7" translate="yes" xml:space="preserve">
          <source>This works in 3.1.x:</source>
          <target state="translated">이것은 3.1.x에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="34a8b500ccfc2f1b0ebeb977ab6c04c06d1e9ee0" translate="yes" xml:space="preserve">
          <source>Time to rethink our coding habits to not miss the possibilities opened by stable ordering of:</source>
          <target state="translated">다음과 같은 안정적인 순서로 열린 가능성을 놓치지 않도록 코딩 습관을 재고 할 시간입니다.</target>
        </trans-unit>
        <trans-unit id="28c712ef2c672e8ba1a4fa22afc4900e8b5c7733" translate="yes" xml:space="preserve">
          <source>To make a new ordered dictionary from the original, sorting by the values:</source>
          <target state="translated">값을 기준으로 원본에서 새로운 순서 사전을 만들려면 :</target>
        </trans-unit>
        <trans-unit id="6d74adb4cde790b0ee66979c3f2e6cc10a1451b8" translate="yes" xml:space="preserve">
          <source>To sort it in descending order just add &lt;code&gt;reverse=True&lt;/code&gt;:</source>
          <target state="translated">내림차순으로 정렬하려면 &lt;code&gt;reverse=True&lt;/code&gt; 를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="155819aadfeae59cb9cfcd9499a8ee68174a11b1" translate="yes" xml:space="preserve">
          <source>Try the following approach. Let us define a dictionary called mydict with the following data:</source>
          <target state="translated">다음 방법을 시도하십시오. 다음 데이터를 사용하여 mydict라는 사전을 정의하겠습니다.</target>
        </trans-unit>
        <trans-unit id="4b2f710b6a34ed5590747fa3bd39096cb443feca" translate="yes" xml:space="preserve">
          <source>Update 2017-12-15:</source>
          <target state="translated">2017-12-15 업데이트 :</target>
        </trans-unit>
        <trans-unit id="fdb4a2ce501dfc70684af85d988bb2e653d52a95" translate="yes" xml:space="preserve">
          <source>Use &lt;strong&gt;ValueSortedDict&lt;/strong&gt; from &lt;a href=&quot;http://pypi.python.org/pypi/dicts&quot;&gt;dicts&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://pypi.python.org/pypi/dicts&quot;&gt;dicts&lt;/a&gt; 에서 &lt;strong&gt;ValueSortedDict&lt;/strong&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="62b01fe66c6a8fecf8cce532d69c410e89bbbdc8" translate="yes" xml:space="preserve">
          <source>Using list comprehension, the one liner would be:</source>
          <target state="translated">리스트 이해를 사용하면 하나의 라이너는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7fb9b44a3d850e5978f0baf1c7d4eaf10d6ddb7" translate="yes" xml:space="preserve">
          <source>Well, it is actually possible to do a &quot;sort by dictionary values&quot;. Recently I had to do that in a Code Golf (Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3169051/code-golf-word-frequency-chart#3170549&quot;&gt;Code golf: Word frequency chart&lt;/a&gt;&lt;/em&gt;). Abridged, the problem was of the kind: given a text, count how often each word is encountered and display a list of the top words, sorted by decreasing frequency.</source>
          <target state="translated">실제로 &quot;사전 값으로 정렬&quot;을 수행 할 수 있습니다. 최근 코드 골프 (스택 오버플로 질문 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/3169051/code-golf-word-frequency-chart#3170549&quot;&gt;코드 골프 : 단어 빈도 차트&lt;/a&gt;&lt;/em&gt; )에서 그렇게해야했습니다. 요약하면, 문제는 일종의 문제입니다 : 텍스트가 주어지면, 각 단어가 얼마나 자주 나오는지 세고, 자주 나오는 단어를 빈도를 기준으로 정렬하여 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="e541adc2d674900aa8e312e0e2e441fb8add2fc4" translate="yes" xml:space="preserve">
          <source>When you try using sorted on an iterable that holds e.g. strings as well as ints, sorted() will fail. Of course you can force string comparison with str(). However, in some cases you want to do &lt;em&gt;actual&lt;/em&gt; numeric comparison where &lt;code&gt;12&lt;/code&gt; is smaller than &lt;code&gt;20&lt;/code&gt; (which is not the case in string comparison). So I came up with the following. When you want explicit numeric comparison you can use the flag &lt;code&gt;num_as_num&lt;/code&gt; which will try to do explicit numeric sorting by trying to convert all values to floats. If that succeeds, it will do numeric sorting, otherwise it'll resort to string comparison.</source>
          <target state="translated">int뿐만 아니라 문자열을 포함하는 iterable에서 sorted를 사용하려고하면 sorted ()가 실패합니다. 물론 str ()로 문자열을 강제로 비교할 수 있습니다. 그러나 어떤 경우에는 &lt;code&gt;12&lt;/code&gt; 가 &lt;code&gt;20&lt;/code&gt; 보다 작은 &lt;em&gt;실제&lt;/em&gt; 숫자 비교를 수행하려고합니다 (문자열 비교에는 해당되지 않음). 그래서 나는 다음을 생각해 냈습니다. 명시적인 숫자 비교를 원할 경우 &lt;code&gt;num_as_num&lt;/code&gt; 플래그를 사용하면 모든 값을 부동 소수점으로 변환하여 명시적인 숫자 정렬을 시도 할 수 있습니다. 성공하면 숫자 정렬을 수행하고 그렇지 않으면 문자열 비교를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0ff5b485b3755e485f0f27c0455e42a1a34a5121" translate="yes" xml:space="preserve">
          <source>Where in the Python 3.5 install on my machine it currently yields:</source>
          <target state="translated">내 컴퓨터의 Python 3.5 설치 위치는 현재 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0dcd2e6a720561c1df622e730734fb59ebbdb067" translate="yes" xml:space="preserve">
          <source>Whilst I found the accepted answer useful, I was also surprised that it hasn't been updated to reference &lt;strong&gt;&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.OrderedDict&quot;&gt;OrderedDict&lt;/a&gt;&lt;/strong&gt; from the standard library &lt;strong&gt;collections&lt;/strong&gt; module as a viable, modern alternative - designed to solve exactly this type of problem.</source>
          <target state="translated">허용 된 답변이 유용하다는 것을 &lt;strong&gt;&lt;a href=&quot;https://docs.python.org/3/library/collections.html#collections.OrderedDict&quot;&gt;알았지 만&lt;/a&gt;&lt;/strong&gt; 표준 라이브러리 &lt;strong&gt;컬렉션&lt;/strong&gt; 모듈의 &lt;strong&gt;OrderedDict&lt;/strong&gt; 를 실행 가능한 현대적인 대안으로 참조하도록 업데이트되지 않았다는 사실에 놀랐습니다.이 유형의 문제를 정확하게 해결하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="1059a59367f309b4b55f78865a999cb543a1f136" translate="yes" xml:space="preserve">
          <source>You can also print out every value</source>
          <target state="translated">모든 값을 인쇄 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="3151f5944b8d3d80e7f39e73c10b03122061a488" translate="yes" xml:space="preserve">
          <source>You can also use custom function that can be passed to key.</source>
          <target state="translated">키에 전달할 수있는 사용자 정의 기능을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="27bd46eb9cb8a0d3c801a01821b192486f2c5fd0" translate="yes" xml:space="preserve">
          <source>You can create an &quot;inverted index&quot;, also</source>
          <target state="translated">&quot;거꾸로 된 색인&quot;을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="007ab6aff38cfad02f1f3c6d815d226b5bf12b3f" translate="yes" xml:space="preserve">
          <source>You can use a &lt;a href=&quot;https://pypi.python.org/pypi/skipdict/1.0&quot;&gt;skip dict&lt;/a&gt; which is a dictionary that's permanently sorted by value.</source>
          <target state="translated">값으로 영구적으로 정렬 된 사전 인 &lt;a href=&quot;https://pypi.python.org/pypi/skipdict/1.0&quot;&gt;건너 뛰기 dict&lt;/a&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3108b3a9adc0f05687add83a67ccd81aacce791b" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://docs.python.org/2/library/collections.html#collections.Counter&quot;&gt;collections.Counter&lt;/a&gt;. Note, this will work for both numeric and non-numeric values.</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/2/library/collections.html#collections.Counter&quot;&gt;collections.Counter&lt;/a&gt; 를 사용할 수 있습니다. 숫자 및 숫자가 아닌 값 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c532773b5fa5995d94c7324ea49825da9f88b956" translate="yes" xml:space="preserve">
          <source>You could use:</source>
          <target state="translated">당신은 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6df57e615bb0295e689e6bd74bbb12cbca93f286" translate="yes" xml:space="preserve">
          <source>You may use a temporary list to help you to sort the dictionary:</source>
          <target state="translated">사전을 정렬하는 데 도움이되도록 임시 목록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9ad3134a5822c19feae380c1e7d9d5fa9876c7" translate="yes" xml:space="preserve">
          <source>a) I don't know about how well it works</source>
          <target state="translated">a) 나는 그것이 얼마나 잘 작동하는지 모른다</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="d1a8efb81673d316b32cbbe97f95b76ebfdf49bc" translate="yes" xml:space="preserve">
          <source>b) You have to download and install it of course. If you do not have administrative access, then I'm afraid the option's out.)</source>
          <target state="translated">b) 물론 다운로드하여 설치해야합니다. 관리 액세스 권한이 없으면 옵션이 종료 될까봐 걱정됩니다.)</target>
        </trans-unit>
        <trans-unit id="74178a464783731b5d38fbd4adc3bae7678fe329" translate="yes" xml:space="preserve">
          <source>copy-paste from : &lt;a href=&quot;http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipes&quot;&gt;http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipes&lt;/a&gt;</source>
          <target state="translated">복사하여 붙여 넣기 : &lt;a href=&quot;http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipes&quot;&gt;http://docs.python.org/dev/library/collections.html#ordereddict-examples-and-recipes&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c798e426037d4b494533e05c7688caa4c6717921" translate="yes" xml:space="preserve">
          <source>in the same ordering per value of v.</source>
          <target state="translated">v의 값당 동일한 순서로</target>
        </trans-unit>
        <trans-unit id="e410766845cb84b4856929c8042ce3f998f22bde" translate="yes" xml:space="preserve">
          <source>sorting with highest score first:</source>
          <target state="translated">가장 높은 점수로 먼저 정렬 :</target>
        </trans-unit>
        <trans-unit id="39d011e92a95017607a9554d19f2a6ae86c40008" translate="yes" xml:space="preserve">
          <source>sorting with lowest score first:</source>
          <target state="translated">가장 낮은 점수로 먼저 정렬 :</target>
        </trans-unit>
        <trans-unit id="92d9544b873d56bf9d3c07f1386ce6f039a937a0" translate="yes" xml:space="preserve">
          <source>then you can get a list of the words, ordered by frequency of use with &lt;a href=&quot;https://docs.python.org/library/functions.html#sorted&quot;&gt;&lt;code&gt;sorted(d, key=d.get)&lt;/code&gt;&lt;/a&gt; - the sort iterates over the dictionary keys, using the number of word occurrences as a sort key .</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://docs.python.org/library/functions.html#sorted&quot;&gt; &lt;code&gt;sorted(d, key=d.get)&lt;/code&gt; &lt;/a&gt; 와 함께 사용 빈도에 따라 순서대로 단어 목록을 얻을 수 있습니다. 정렬은 단어 발생 횟수를 정렬 키로 사용하여 사전 키를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="1e480c669a446cd2cfa32c42668447a5643e9435" translate="yes" xml:space="preserve">
          <source>would be stored in two Python tuples, k_seq and v_seq (aligned by numerical index and with the same length of course), then:</source>
          <target state="translated">k_seq 및 v_seq (숫자 색인으로 정렬되고 물론 동일한 길이로 정렬 됨)라는 두 개의 Python 튜플에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="979077738bfbc204b3c1724499e5c0b8eb3586f4" translate="yes" xml:space="preserve">
          <source>yielding in this case (for the new Python 3.6+ built-in dict!):</source>
          <target state="translated">이 경우 새로운 파이썬 3.6 + 내장 dict!</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
