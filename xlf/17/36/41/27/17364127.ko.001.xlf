<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/17364127">
    <body>
      <group id="17364127">
        <trans-unit id="64c134d03b9bef7a1b2c4b1cc5a323435009edc5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;The Schwartzian transform&lt;/a&gt;, also referred to as the decorate-sort-undecorate idiom, effects a stable sort with an inherently unstable sorting algorithm.</source>
          <target state="translated">장식-정렬-장식-비 장식 관용구라고도하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;슈바르츠 식 변환&lt;/a&gt; 은 본질적으로 불안정한 정렬 알고리즘으로 안정적인 정렬에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="ec0b9d91e8865701f4b5b4d7b036cf124aafa4d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sort&lt;/code&gt; sorts by reference and does not return anything useful!</source>
          <target state="translated">참조로 정렬하고 유용한 것을 반환하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="5acc8ee181e8da0ea9d9be45f707be213fefa4db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strcmp&lt;/code&gt; does exactly what's expected of &lt;code&gt;cmp&lt;/code&gt; here, it returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strcmp&lt;/code&gt; 는 &lt;code&gt;cmp&lt;/code&gt; 에 대해 정확히 예상 한대로 &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6250fe13bd2141652473bccea20d7a3edc21534a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;usort&lt;/code&gt; will take two items from the array and call your &lt;code&gt;cmp&lt;/code&gt; function with them. So &lt;code&gt;cmp()&lt;/code&gt; will be called with &lt;code&gt;$a&lt;/code&gt; as &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; as another &lt;code&gt;array('foo' =&amp;gt; ..., 'baz' =&amp;gt; ...)&lt;/code&gt;. The function then returns to &lt;code&gt;usort&lt;/code&gt; which of the values was larger or whether they were equal. &lt;code&gt;usort&lt;/code&gt; repeats this process passing different values for &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; until the array is sorted. The &lt;code&gt;cmp&lt;/code&gt; function will be called many times, &lt;em&gt;at least&lt;/em&gt; as many times as there are values in &lt;code&gt;$array&lt;/code&gt;, with different combinations of values for &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; every time.</source>
          <target state="translated">&lt;code&gt;usort&lt;/code&gt; 는 배열에서 두 항목을 가져 와서 &lt;code&gt;cmp&lt;/code&gt; 함수를 호출합니다. 따라서 &lt;code&gt;cmp()&lt;/code&gt; 는 &lt;code&gt;$a&lt;/code&gt; 를 &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; , &lt;code&gt;$b&lt;/code&gt; 를 다른 &lt;code&gt;array('foo' =&amp;gt; ..., 'baz' =&amp;gt; ...)&lt;/code&gt; . 그런 다음이 함수는 어떤 값이 더 큰지 또는 동일한 지 여부를 표시합니다. &lt;code&gt;usort&lt;/code&gt; 는 배열이 정렬 될 때까지 &lt;code&gt;$b&lt;/code&gt; 및 $ b에 다른 값을 전달하여이 프로세스를 반복합니다. &lt;code&gt;cmp&lt;/code&gt; 함수는 매번 &lt;code&gt;$b&lt;/code&gt; 와 $ b 의 값 조합이 다른 &lt;code&gt;$array&lt;/code&gt; 값이있는 횟수만큼 여러 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="91a3fac04b5043f66c638448a2ec4a9d40256c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basic sorting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본 정렬&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae5cef9d3d93e404cd7eaf3cebb98381606bb57f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multidimensional sort by key value&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;키 값을 기준으로 다차원 정렬&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ad87ca1f0b6cc5122ffd4adf3852faabfb4606d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting array of objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;객체 배열 정렬&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d54d56ae70bc0bd717365af26342ff7f0609c18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting by function result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기능 결과별로 정렬&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="442b02603b1b00edd73e6ecb47de346ad50a30a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting multidimensional array&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다차원 배열 정렬&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7427550bbfea3e00b1744c697847bdfdc2887d54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting with a comparison function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;비교 기능으로 정렬&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e21f70118d196d40f3aca759ed5d74ff5bb9753d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Test case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;테스트 사례 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5043ab6424dd981758b046a437b0a3d11f0fac39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Schwartzian transform&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;슈바르츠 식 변환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c570d11b81351591dc82387e9c2d0e5c99eed9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The sort wasn't stable!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;정렬이 안정적이지 않았습니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae6f075d81fe91ec85a2cda94e88595f84602fb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What about reuse?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;재사용은 어떻습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6153e439d266c625b80b0798a43006194091e98" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;* developed by me, see readme for more details and comparison with other LINQ ports&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;* 저에 의해 개발되었습니다. 자세한 내용 및 다른 LINQ 포트와의 비교는 readme를 참조하십시오&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f9df68a046eeab006969fe2d05597fc43aedc367" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;If you have more common cases, feel free to edit this answer.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;더 일반적인 경우가 있으면이 답변을 자유롭게 편집하십시오.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d0a564f5b4042652c7506a0e980220e88741b88a" translate="yes" xml:space="preserve">
          <source>A shortcut for the first string comparison version:</source>
          <target state="translated">첫 번째 문자열 비교 버전에 대한 바로 가기 :</target>
        </trans-unit>
        <trans-unit id="1d43617dc0b5a021c31bb1e8464713303a5a922c" translate="yes" xml:space="preserve">
          <source>Afterwards, we undecorate:</source>
          <target state="translated">그 후, 우리는 장식을 해제합니다 :</target>
        </trans-unit>
        <trans-unit id="7931945cc2816f5241e83f79777cd3649fe7a700" translate="yes" xml:space="preserve">
          <source>Again, they only differ in whether they keep key-value associations and sort by values or keys. Read their documentation for details.</source>
          <target state="translated">다시 말하지만 키-값 연결을 유지하고 값 또는 키를 기준으로 정렬하는 방식 만 다릅니다. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a70cd3b3cb5f9b9f666113d7269e0526e688db81" translate="yes" xml:space="preserve">
          <source>All you did was define a custom way to compare two items, that's all you need. That works with all sorts of values.</source>
          <target state="translated">두 항목을 비교하는 사용자 정의 방법을 정의하기 만하면됩니다. 그것은 모든 종류의 값에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7e5e4131293f07cab8ee6d2fcb5a44fee49f9403" translate="yes" xml:space="preserve">
          <source>Also for all of the above, to switch between ascending and descending order simply swap the &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; arguments around. E.g.:</source>
          <target state="translated">또한 위의 모든 항목에서 오름차순과 내림차순 사이를 전환하려면 &lt;code&gt;$a&lt;/code&gt; 및 &lt;code&gt;$b&lt;/code&gt; 인수를 간단히 바꾸십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="b9601f704b51bebf86466d306bf841c6e4c693eb" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;https://stackoverflow.com/a/22812695/476&quot;&gt;this very neat shorthand version&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/22829326/476&quot;&gt;how to create such a comparison function dynamically for an arbitrary number of keys&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;https://stackoverflow.com/a/22812695/476&quot;&gt;이 매우 간결한 속기 버전&lt;/a&gt; 과 &lt;a href=&quot;https://stackoverflow.com/a/22829326/476&quot;&gt;임의의 수의 키에 대해 이러한 비교 함수를 동적으로 작성하는 방법을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8716dd3e8af6710d5fdaa991141a80734a184f4a" translate="yes" xml:space="preserve">
          <source>And now you want to sort on the first letter only:</source>
          <target state="translated">이제 첫 글자 만 정렬하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="ece93d1b3c1ff5290fd30d672442002e929ec257" translate="yes" xml:space="preserve">
          <source>And then there's the peculiar &lt;a href=&quot;http://php.net/array_multisort&quot;&gt;&lt;code&gt;array_multisort&lt;/code&gt;&lt;/a&gt;, which lets you sort one array based on another:</source>
          <target state="translated">그리고 독특한 &lt;a href=&quot;http://php.net/array_multisort&quot;&gt; &lt;code&gt;array_multisort&lt;/code&gt; &lt;/a&gt; 가 있는데,이를 통해 하나의 배열을 다른 배열을 기준으로 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7272763986e00b04cd352962090c6aeb7a8abd7" translate="yes" xml:space="preserve">
          <source>Applicable sort functions:</source>
          <target state="translated">적용 가능한 정렬 기능 :</target>
        </trans-unit>
        <trans-unit id="1f5fbafcc6b2be3e4003214daaf54304ae710e57" translate="yes" xml:space="preserve">
          <source>As of PHP 5.3 with closures it is also possible to use a closure to determine the order of your sort.</source>
          <target state="translated">클로저가있는 PHP 5.3부터 클로저를 사용하여 정렬 순서를 결정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a26da193435c50e2c23ef2300be7cff7d23086bf" translate="yes" xml:space="preserve">
          <source>As of PHP 5.5.0 you can use &lt;code&gt;array_column&lt;/code&gt; to extract a column from a multi dimensional array and sort the array on that column:</source>
          <target state="translated">PHP 5.5.0부터 &lt;code&gt;array_column&lt;/code&gt; 을 사용하여 다차원 배열에서 열을 추출하고 해당 열에서 배열을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa88f9496d79e65e1268bd5cd94428456942d7d" translate="yes" xml:space="preserve">
          <source>As of PHP 7.0.0 you can also extract properties from an array of objects.</source>
          <target state="translated">PHP 7.0.0부터는 객체 배열에서 속성을 추출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a6c74b1fb6f77c435e7654b0a2bb753b7036c67" translate="yes" xml:space="preserve">
          <source>At your own discretion, from PHP7.4 you can use arrow syntax with these anonymous functions.  &lt;a href=&quot;https://3v4l.org/N5hs1&quot;&gt;Same script with arrow syntax&lt;/a&gt;.</source>
          <target state="translated">PHP7.4부터는이 익명 함수와 함께 화살표 구문을 사용할 수 있습니다. &lt;a href=&quot;https://3v4l.org/N5hs1&quot;&gt;화살표 구문을 사용하는 동일한 스크립트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3481f742ff766b292ff10b811189b66a6a8a188" translate="yes" xml:space="preserve">
          <source>Basic one dimensional arrays</source>
          <target state="translated">기본 1 차원 배열</target>
        </trans-unit>
        <trans-unit id="1c0f6078f43ed59ef9e69be5b2d9b8ba776052ee" translate="yes" xml:space="preserve">
          <source>Basic one-dimensional arrays; Incl. Multidimensional arrays, incl. arrays of objects; Incl. Sorting one array based on another</source>
          <target state="translated">기본 1 차원 배열; 포함 다차원 배열 (포함) 객체의 배열; 포함 다른 배열을 기준으로 한 배열 정렬</target>
        </trans-unit>
        <trans-unit id="7a9564635844dbb13c650e09e6dca78deee82d44" translate="yes" xml:space="preserve">
          <source>Bubble Sort</source>
          <target state="translated">버블 정렬</target>
        </trans-unit>
        <trans-unit id="0ee0df1fe84ba4f23bf4a4787e7f2ab939905d5b" translate="yes" xml:space="preserve">
          <source>Bubble sort, sometimes incorrectly referred to as sinking sort, is a simple sorting algorithm that works by repeatedly stepping through the list to be sorted, comparing each pair of adjacent items and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm gets its name from the way smaller elements &quot;bubble&quot; to the top of the list. Because it only uses comparisons to operate on elements, it is a comparison sort. Although the algorithm is simple, most of the other sorting algorithms are more efficient for large lists.</source>
          <target state="translated">버블 정렬 (때로는 싱킹 정렬이라고 잘못 함)은 정렬 할 목록을 반복적으로 반복하여 정렬되는 인접한 정렬 항목을 비교하고 순서가 잘못된 경우 서로 바꾸어 사용하는 간단한 정렬 알고리즘입니다. 스왑이 필요하지 않을 때까지 목록 통과가 반복되어 목록이 정렬되었음을 나타냅니다. 이 알고리즘은 작은 요소가 &quot;버블 (bubble)&quot;하는 방식에서 목록의 최상위까지 이름을 가져옵니다. 비교 만 사용하여 요소를 조작하므로 비교 정렬입니다. 알고리즘은 단순하지만 다른 정렬 알고리즘은 대부분 큰 목록에 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="3f5228c2bb37ea03d02a48ced721ff6fce42582f" translate="yes" xml:space="preserve">
          <source>By the way, this works on any value, the values don't have to be complex arrays. If you have a custom comparison you want to do, you can do it on a simple array of numbers too.</source>
          <target state="translated">그건 그렇고, 이것은 모든 값에서 작동하며 값은 복잡한 배열 일 필요는 없습니다. 사용자 지정 비교를 원한다면 간단한 숫자 배열로도 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f7b5e3a07e4aa10794b25b9eb1b333d19a93959" translate="yes" xml:space="preserve">
          <source>Comb sort</source>
          <target state="translated">빗 정렬</target>
        </trans-unit>
        <trans-unit id="2a88d28be7a721a09c87fbc18b87669fb817bf11" translate="yes" xml:space="preserve">
          <source>Comb sort is a relatively simple sorting algorithm originally designed by Wlodzimierz Dobosiewicz in 1980. Later it was rediscovered by Stephen Lacey and Richard Box in 1991. Comb sort improves on bubble sort.</source>
          <target state="translated">Comb sort는 1980 년 Wlodzimierz Dobosiewicz에 의해 원래 설계된 비교적 간단한 정렬 알고리즘입니다. 나중에 1991 년 Stephen Lacey와 Richard Box에 의해 재발견되었습니다. Comb sort는 버블 정렬을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="646e0b865c714a7aff37ecc033eed142b2c958be" translate="yes" xml:space="preserve">
          <source>Comparisons can be further customized by passing a callback as a second argument, for example:</source>
          <target state="translated">콜백을 두 번째 인수로 전달하여 비교를 추가로 사용자 정의 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1dbb3512ba2c2ef412c726afc917e9ed563da64" translate="yes" xml:space="preserve">
          <source>Custom numeric comparisons</source>
          <target state="translated">맞춤 숫자 비교</target>
        </trans-unit>
        <trans-unit id="2a8dd816d14251367ee45f28876e6654657e5dc0" translate="yes" xml:space="preserve">
          <source>Demonstrations (to avoid Stackoverflow page bloat, please see &lt;a href=&quot;https://3v4l.org/2OnVs&quot;&gt;the demo link&lt;/a&gt; for the outputs):</source>
          <target state="translated">데모 (스택 오버플로 페이지 팽창을 피하려면 출력 &lt;a href=&quot;https://3v4l.org/2OnVs&quot;&gt;데모 링크&lt;/a&gt; 를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="f9aad07cf38b9608c1a59cad08fd3d2a44488a85" translate="yes" xml:space="preserve">
          <source>First, you decorate each array element with another array comprising a primary key (the value) and a secondary key (its index or position):</source>
          <target state="translated">먼저 각 배열 요소를 기본 키 (값)와 보조 키 (색인 또는 위치)로 구성된 다른 배열로 장식합니다.</target>
        </trans-unit>
        <trans-unit id="5d589d82437d73e6fc415fb3acaa13acf2e67fbc" translate="yes" xml:space="preserve">
          <source>For all the above, if you're using PHP 5.3 or higher (and you really should), use anonymous functions for shorter code and to avoid having another global function floating around:</source>
          <target state="translated">위의 모든 사항에 대해 PHP 5.3 이상을 사용하는 경우 (실제로해야하는 경우) 익명 코드를 사용하여 짧은 코드를 사용하고 다른 전역 함수가 떠 다니는 것을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="8a7d9d374259b691daf285d948859be53a0d48f4" translate="yes" xml:space="preserve">
          <source>For example assuming $array is an array of objects that contain a month property.</source>
          <target state="translated">예를 들어 $ array라고 가정하면 월 속성이 포함 된 객체의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="05c24c41a15f9e61769c627b1026c3bba5757c1a" translate="yes" xml:space="preserve">
          <source>For the practical answer using PHP's existing functions see 1., for the academic in-detail answer on sorting algorithms (which PHP's functions implement and which you &lt;em&gt;may&lt;/em&gt; need for really, really complex cases), see 2.</source>
          <target state="translated">PHP의 기존 함수를 사용한 실질적인 답변은 1을 참조하십시오. 정렬 알고리즘에 대한 학술적 세부 답변 (PHP의 함수가 구현하고 실제로 복잡한 경우에 필요할 &lt;em&gt;수&lt;/em&gt; 있음)은 2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e7e0012b84ebe1c2d6c656f0728fbc05a8b629e0" translate="yes" xml:space="preserve">
          <source>For those familiar, this is equivalent to an SQL query with &lt;code&gt;ORDER BY foo, baz&lt;/code&gt;.</source>
          <target state="translated">익숙한 사람들에게는 &lt;code&gt;ORDER BY foo, baz&lt;/code&gt; 를 사용한 SQL 쿼리와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="10713d2d5d97f92b70ceeaa1abf16e664ba19d25" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Comb_sort&quot;&gt;the Wikipedia article on Comb sort:&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Comb_sort&quot;&gt;Comb sort에 관한 Wikipedia 기사에서 :&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af6f8187ecb41c7a3a724fde62c2291f0de0c1e6" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Merge_sort&quot;&gt;the Wikipedia article on Merge sort:&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Merge_sort&quot;&gt;병합 정렬에 대한 Wikipedia 기사에서 :&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f04a70693d1fc91e698f20afedbe860f081e3080" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Quicksort&quot;&gt;the Wikipedia article on Quicksort:&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Quicksort&quot;&gt;Quicksort의 Wikipedia 기사에서 :&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="231cb574983359b4f2fc2d0eabb3cee56f18d159" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;the Wikipedia article on Radix sort:&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;기수 정렬에 대한 Wikipedia 기사에서 :&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="335cc9004b8bc9590aeeaa5f2c309c7998fffbc1" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Selection_sort&quot;&gt;the Wikipedia article on Selection sort:&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Selection_sort&quot;&gt;선택 정렬에 대한 Wikipedia 기사에서 :&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa8d636c21c2bb087af8f1c0516b00da6213c942" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort&quot;&gt;the Wikipedia article on Permutation sort:&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort&quot;&gt;순열 정렬에 대한 Wikipedia 기사에서 :&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="598734ed0e26e19f679e1e9533a6ea9144140fc1" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;Wikipedia article on Bubble Sort:&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;Bubble Sort에&lt;/a&gt; 관한 Wikipedia 기사에서 :</target>
        </trans-unit>
        <trans-unit id="e6bc71c3a10f14e6b4ea14a4d51755b852912608" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;Wikipedia article on Insertion sort:&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;삽입 정렬에&lt;/a&gt; 관한 Wikipedia 기사에서 :</target>
        </trans-unit>
        <trans-unit id="75d4de6c59d942777ba337701271351a8ba9c7bc" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://en.wikipedia.org/wiki/Shellsort&quot;&gt;Wikipedia article on Shellsort:&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Shellsort&quot;&gt;Shellsort&lt;/a&gt; 의 Wikipedia 기사에서 :</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="bc53affe93a56f0ac2327b800d76e9c76e766162" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;'$v-&amp;gt;count'&lt;/code&gt; is a shorthand for &lt;code&gt;function ($v) { return $v-&amp;gt;count; }&lt;/code&gt; (either can be used). These method chains return iterators, iterators can be transformed to arrays by adding &lt;code&gt;-&amp;gt;toArray()&lt;/code&gt; in the end if needed.</source>
          <target state="translated">여기서 &lt;code&gt;'$v-&amp;gt;count'&lt;/code&gt; 는 &lt;code&gt;function ($v) { return $v-&amp;gt;count; }&lt;/code&gt; 의 줄임말입니다. {return $ v-&amp;gt; count; } (둘 다 사용할 수 있음). 이 메소드 체인은 반복자를 리턴하며, 필요한 경우 끝에 &lt;code&gt;-&amp;gt;toArray()&lt;/code&gt; 를 추가하여 반복자를 배열로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37d11951535b9e7819e17bbaa7fa8bb897720d41" translate="yes" xml:space="preserve">
          <source>How can I sort arrays and data in PHP</source>
          <target state="translated">PHP에서 배열과 데이터를 정렬하는 방법</target>
        </trans-unit>
        <trans-unit id="59294f795e706794f92a5ab10d06ef7bfa38d205" translate="yes" xml:space="preserve">
          <source>How do I sort a &lt;em&gt;complex&lt;/em&gt; array in PHP?</source>
          <target state="translated">PHP에서 &lt;em&gt;복잡한&lt;/em&gt; 배열을 어떻게 정렬합니까?</target>
        </trans-unit>
        <trans-unit id="70590ec3e9e5b76199d05655615734e1136c5ea3" translate="yes" xml:space="preserve">
          <source>How do I sort an array in PHP?</source>
          <target state="translated">PHP에서 배열을 어떻게 정렬합니까?</target>
        </trans-unit>
        <trans-unit id="ffc8695c757dd16a946a9df92a2827b4afaac13c" translate="yes" xml:space="preserve">
          <source>How do I sort an array of objects in PHP?</source>
          <target state="translated">PHP에서 객체 배열을 어떻게 정렬합니까?</target>
        </trans-unit>
        <trans-unit id="0464412340e55485032482f66471f7409836566d" translate="yes" xml:space="preserve">
          <source>If someone wants a simpler solution to manipulate arrays, just use Laravel Collection package which has an implemented sortBy function that lets your sort by keys simply.</source>
          <target state="translated">누군가가 배열을 조작하는 더 간단한 솔루션을 원한다면 간단히 키별로 정렬 할 수있는 sortBy 함수가 구현 된 Laravel Collection 패키지를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="45bf070aff3c78274f4df26fea9e3429bf4ad3b8" translate="yes" xml:space="preserve">
          <source>If sorting descending order according their value,'arsort()' method can be used.
Suppose that you want to sort that array according their key value. In this , 'ksort()' method can be use.</source>
          <target state="translated">값에 따라 내림차순으로 정렬하면 'arsort ()'메서드를 사용할 수 있습니다. 해당 키 값에 따라 해당 배열을 정렬한다고 가정하십시오. 여기서는 'ksort ()'메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="925d0b321049ce7fba34b78caeb03d17d843dd9b" translate="yes" xml:space="preserve">
          <source>If you have an array of objects, it works the same way:</source>
          <target state="translated">객체 배열이있는 경우 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8edadb37485a056a0ba896c032254cd92d020270" translate="yes" xml:space="preserve">
          <source>If you want to order by the key value, then you can do it one line, elegant and clear.  This will order by the price ascending.  Uses array_multisort and array_column.</source>
          <target state="translated">키 값으로 주문하려면 우아하고 명확한 한 줄로 할 수 있습니다. 가격 오름차순으로 주문합니다. array_multisort 및 array_column을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6d1b10feb5169be2830f541c80ba389d86eb0388" translate="yes" xml:space="preserve">
          <source>If you want to sort &lt;code&gt;$array&lt;/code&gt; by the key 'foo' of each entry, you need a &lt;em&gt;custom comparison function&lt;/em&gt;. The above &lt;code&gt;sort&lt;/code&gt; and related functions work on simple values that they know how to compare and sort. PHP does not simply &quot;know&quot; what to do with a &lt;em&gt;complex value&lt;/em&gt; like &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; though; so you need to tell it.</source>
          <target state="translated">각 항목의 키 'foo'를 기준으로 &lt;code&gt;$array&lt;/code&gt; 를 정렬하려면 &lt;em&gt;사용자 정의 비교 함수&lt;/em&gt; 가 필요 &lt;em&gt;합니다&lt;/em&gt; . 위의 &lt;code&gt;sort&lt;/code&gt; 및 관련 함수는 비교 및 ​​정렬 방법을 알고있는 간단한 값에서 작동합니다. PHP는 단순히 &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; 와 같은 &lt;em&gt;복잡한 값으로&lt;/em&gt; 무엇을 해야할지 &quot;알지&quot;않습니다. 그래서 당신은 그것을 말해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f6716ad7296fe732de50b7dcb13b798d77ac3c5" translate="yes" xml:space="preserve">
          <source>If you want to sort by the &lt;code&gt;baz&lt;/code&gt; key, which is numeric, all you need to do is:</source>
          <target state="translated">숫자 인 &lt;code&gt;baz&lt;/code&gt; 키를 기준으로 정렬하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2d2d91011e4cafdd99a83cde167a000a3b9c397d" translate="yes" xml:space="preserve">
          <source>If you want to sort elements into a &quot;manual order&quot; like &lt;em&gt;&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;&lt;/em&gt; 와 같은 &lt;em&gt;&quot;&lt;/em&gt; 수동 순서&quot;로 요소를 정렬하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="52cc97be3f5343af977f4a56eb17cf35bc05914a" translate="yes" xml:space="preserve">
          <source>If you want to sort primarily by &lt;code&gt;foo&lt;/code&gt;, but if &lt;code&gt;foo&lt;/code&gt; is equal for two elements sort by &lt;code&gt;baz&lt;/code&gt;:</source>
          <target state="translated">주로 &lt;code&gt;foo&lt;/code&gt; 별로 정렬하고 싶지만 &lt;code&gt;foo&lt;/code&gt; 가 두 요소에 대해 동일한 경우 &lt;code&gt;baz&lt;/code&gt; 로 정렬하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af3d3d14d6ec1cb2fcbbe7eb203a079631fb777a" translate="yes" xml:space="preserve">
          <source>If your question is closed as a duplicate of this one, please ask for your question to be reopened only if you can explain why it differs markedly from all of the below.</source>
          <target state="translated">귀하의 질문이이 질문과 중복되는 경우, 아래 질문과 다른 이유를 설명 할 수있는 경우에만 질문을 다시 열도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="582175a51757c187ebe0a614be085ee5195af579" translate="yes" xml:space="preserve">
          <source>In .NET, LINQ is frequently used for sorting, which provides a much nicer syntax over comparison functions, especially when objects need to be sorted by multiple fields. There're several ports of LINQ to PHP, including &lt;a href=&quot;https://github.com/Athari/YaLinqo&quot;&gt;YaLinqo&lt;/a&gt; library*. With it, arrays can be sorted with a single line without writing complex comparison functions.</source>
          <target state="translated">.NET에서 LINQ는 정렬에 자주 사용되며, 특히 여러 필드로 개체를 정렬해야하는 경우 비교 기능보다 훨씬 뛰어난 구문을 제공합니다. &lt;a href=&quot;https://github.com/Athari/YaLinqo&quot;&gt;YaLinqo&lt;/a&gt; 라이브러리 *를 포함하여 LINQ to PHP의 여러 포트가 있습니다. 이를 통해 복잡한 비교 함수를 작성하지 않고도 한 줄로 배열을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ad5247ca5515c6c34dc526808eb4006a03baba" translate="yes" xml:space="preserve">
          <source>In computer science, a merge sort (also commonly spelled mergesort) is an O(n log n) comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the implementation preserves the input order of equal elements in the sorted output</source>
          <target state="translated">컴퓨터 과학에서, 병합 정렬 (일반적으로 철자 된 병합 정렬)은 O (n log n) 비교 기반 정렬 알고리즘입니다. 대부분의 구현은 안정적인 정렬을 생성하므로 정렬 된 출력에서 ​​동일한 요소의 입력 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="fd773dac0cce1b252cddef9fa0e747f7ecda84a9" translate="yes" xml:space="preserve">
          <source>In computer science, radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value.</source>
          <target state="translated">컴퓨터 과학에서 기수 정렬은 동일한 중요한 위치와 값을 공유하는 개별 숫자로 키를 그룹화하여 정수 키로 데이터를 정렬하는 비 비교적 정수 정렬 알고리즘입니다.</target>
        </trans-unit>
        <trans-unit id="2bebc9e7fd3f70ecd7761684ac68e27bf4d9b7a7" translate="yes" xml:space="preserve">
          <source>In computer science, selection sort is a sorting algorithm, specifically an in-place comparison sort. It has O(n2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited.</source>
          <target state="translated">컴퓨터 과학에서 선택 정렬은 정렬 알고리즘, 특히 내부 비교 정렬입니다. O (n2) 시간 복잡도를 가지므로 큰 목록에서는 비효율적이며 일반적으로 유사한 삽입 정렬보다 성능이 떨어집니다. 선택 정렬은 단순성으로 유명하며, 특히 보조 메모리가 제한되는 특정 상황에서 더 복잡한 알고리즘에 비해 성능 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5bbc46810b022a4f9a43546060c63f13368908b" translate="yes" xml:space="preserve">
          <source>Insertion sort</source>
          <target state="translated">삽입 정렬</target>
        </trans-unit>
        <trans-unit id="8a2aef5e40c2233bb33a10c7a43749ed88dbbd60" translate="yes" xml:space="preserve">
          <source>Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, insertion sort provides several advantages:</source>
          <target state="translated">삽입 정렬은 한 번에 한 항목 씩 최종 정렬 된 배열 (또는 목록)을 작성하는 간단한 정렬 알고리즘입니다. 빠른 정렬, 힙 정렬 또는 병합 정렬과 같은 고급 알고리즘보다 큰 목록에서 훨씬 덜 효율적입니다. 그러나 삽입 정렬에는 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="09dfd03d9fa968a44a324d9a9670952800b1a369" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;orderBy&lt;/code&gt; and related methods call appropriate array sorting functions (&lt;code&gt;uasort&lt;/code&gt;, &lt;code&gt;krsort&lt;/code&gt;, &lt;code&gt;multisort&lt;/code&gt;, &lt;code&gt;usort&lt;/code&gt; etc.).</source>
          <target state="translated">내부적으로 &lt;code&gt;orderBy&lt;/code&gt; 및 관련 메소드는 적절한 배열 정렬 함수 ( &lt;code&gt;uasort&lt;/code&gt; , &lt;code&gt;krsort&lt;/code&gt; , &lt;code&gt;multisort&lt;/code&gt; , &lt;code&gt;usort&lt;/code&gt; 등)를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="da1531a814d65a809aa862e5d5c336dc8e0042a7" translate="yes" xml:space="preserve">
          <source>It is very convenient to sort arrays with &lt;a href=&quot;https://github.com/ihor/Nspl#sortedarray-array-reversed--false-key--null-cmp--null&quot;&gt;sorted&lt;/a&gt; function from &lt;a href=&quot;https://github.com/ihor/Nspl&quot;&gt;Nspl&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ihor/Nspl&quot;&gt;Nspl&lt;/a&gt; 에서 &lt;a href=&quot;https://github.com/ihor/Nspl#sortedarray-array-reversed--false-key--null-cmp--null&quot;&gt;정렬 된&lt;/a&gt; 함수로 배열을 정렬 하는 것이 매우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="667a4c437c43ca4427c06a7c18f482d831ef30ee" translate="yes" xml:space="preserve">
          <source>LINQ</source>
          <target state="translated">LINQ</target>
        </trans-unit>
        <trans-unit id="d7b23de8effd125677df7440a79328060cc5e033" translate="yes" xml:space="preserve">
          <source>LINQ contains many more methods inspired by SQL: filtering, grouping, joining, aggregating etc. It's best suited for cases when complex transformations on arrays and objects need to be performed without relying on databases.</source>
          <target state="translated">LINQ에는 필터링, 그룹화, 조인, 집계 등 SQL에서 영감을 얻은 더 많은 메서드가 포함되어 있습니다. 데이터베이스에 의존하지 않고 배열과 개체에 대한 복잡한 변환을 수행해야하는 경우에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f64a19aa28fb1c68abbaec37b0257c0dcb685d6c" translate="yes" xml:space="preserve">
          <source>Let's say you have an array like this:</source>
          <target state="translated">다음과 같은 배열이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="c6e2b023f3c4383d2cf7c27139646fae922e2b4a" translate="yes" xml:space="preserve">
          <source>Let's write the sort step using this function:</source>
          <target state="translated">이 함수를 사용하여 정렬 단계를 작성해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="67151004822cc885e4122a06e2904151a40b8599" translate="yes" xml:space="preserve">
          <source>Merge sort</source>
          <target state="translated">정렬 병합</target>
        </trans-unit>
        <trans-unit id="a90731fa64d2eaebed1e787a4012ebb1d3ba50b7" translate="yes" xml:space="preserve">
          <source>Multi dimensional arrays, including arrays of objects</source>
          <target state="translated">객체 배열을 포함한 다차원 배열</target>
        </trans-unit>
        <trans-unit id="6e0c416675708d317f2b07de659b4ababe413cc0" translate="yes" xml:space="preserve">
          <source>Natural sort of a multidimensional array by a key value and also keep the original order(do not shuffle the main keys):</source>
          <target state="translated">키 값으로 다차원 배열을 자연스럽게 정렬하고 원래 순서를 유지하십시오 (기본 키를 섞지 마십시오).</target>
        </trans-unit>
        <trans-unit id="1b9453aa0a00bdf9f4d988745a47066a5de0f25b" translate="yes" xml:space="preserve">
          <source>Note that the array sorts &lt;em&gt;in place&lt;/em&gt;, you do not need to assign the return value to anything. &lt;code&gt;$array = sort($array)&lt;/code&gt; will replace the array with &lt;code&gt;true&lt;/code&gt;, not with a sorted array. Just &lt;code&gt;sort($array);&lt;/code&gt; works.</source>
          <target state="translated">배열 &lt;em&gt;이 제자리에&lt;/em&gt; 정렬되므로 리턴 값을 아무것도 지정할 필요가 없습니다. &lt;code&gt;$array = sort($array)&lt;/code&gt; 는 정렬 된 배열이 아니라 배열을 &lt;code&gt;true&lt;/code&gt; 로 바꿉니다. 그냥 &lt;code&gt;sort($array);&lt;/code&gt; 공장.</target>
        </trans-unit>
        <trans-unit id="975c9470ca30f7d2e09bf09a076cb2fa5788f53e" translate="yes" xml:space="preserve">
          <source>Note that this won't work well for &lt;code&gt;float&lt;/code&gt; values, since they'll be reduced to an &lt;code&gt;int&lt;/code&gt; and lose precision. Use explicit &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; return values instead.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 값은 &lt;code&gt;int&lt;/code&gt; 로 줄이고 정밀도가 떨어지기 때문에 잘 작동하지 않습니다. 대신 명시적인 &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;1&lt;/code&gt; 반환 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9480ac07046c735f2fecfd2332cb6f82d4b86385" translate="yes" xml:space="preserve">
          <source>Now array is sorted according their key value.If You want to sort the array in descending order according their key value,'krsort()' method can be used.</source>
          <target state="translated">이제 배열은 키 값에 따라 정렬됩니다. 배열을 키 값에 따라 내림차순으로 정렬하려면 'krsort ()'메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6954657f48f6b7ff5d7802374273a3999c5374ed" translate="yes" xml:space="preserve">
          <source>Now array is sorted in descending order.Ok, Let's consider an associative array.I will give an associative array(Associative array means that, An array whose each index has unique key value.) like this,</source>
          <target state="translated">이제 배열은 내림차순으로 정렬됩니다 .Ok, associative array. Associative array (Associative array는 각 인덱스에 고유 한 키 값을 갖는 배열을 의미 함)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8ae68b7f9f856327cadf4b20822beefd6eed6802" translate="yes" xml:space="preserve">
          <source>Now associative array is sorted in descending order according their key value.Look at the output.</source>
          <target state="translated">이제 연관 배열이 키 값에 따라 내림차순으로 정렬됩니다. 출력을보십시오.</target>
        </trans-unit>
        <trans-unit id="72ee2e304658dc96b31d0a5b7baf0c4b1799c99d" translate="yes" xml:space="preserve">
          <source>Now consider the output of that,</source>
          <target state="translated">이제 그 결과를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d827a6d027f57d096cc39d07e7c52f06a4bc5370" translate="yes" xml:space="preserve">
          <source>Now consider the output.</source>
          <target state="translated">이제 출력을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bb53e72bba70d545e597e3fd609e9845c180b9b2" translate="yes" xml:space="preserve">
          <source>Now, we adjust the comparison step; we compare the first letter again, but if they're the same, the secondary key is used to retain the original ordering:</source>
          <target state="translated">이제 비교 단계를 조정합니다. 첫 글자를 다시 비교하지만, 동일한 경우 보조 키는 원래 순서를 유지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="e39453d0bca511e0ba4ab9de0245d522eae2bb85" translate="yes" xml:space="preserve">
          <source>Often, you will want to use an &lt;a href=&quot;http://php.net/manual/en/functions.anonymous.php&quot;&gt;anonymous function&lt;/a&gt; as the callback. If you want to use a method or static method, see the &lt;a href=&quot;http://php.net/manual/en/language.types.callable.php&quot;&gt;other ways of specifying a callback in PHP&lt;/a&gt;.</source>
          <target state="translated">종종 &lt;a href=&quot;http://php.net/manual/en/functions.anonymous.php&quot;&gt;익명 함수&lt;/a&gt; 를 콜백으로 사용하려고합니다. 메소드 또는 정적 메소드를 사용하려면 &lt;a href=&quot;http://php.net/manual/en/language.types.callable.php&quot;&gt;PHP에서 콜백을 지정하는 다른 방법을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c35d83d789a540e6897531d14c6254373ce83781" translate="yes" xml:space="preserve">
          <source>Other Types of Sort</source>
          <target state="translated">다른 종류의 정렬</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="b0267e700c88a37263a43b92d7a395bce05551fd" translate="yes" xml:space="preserve">
          <source>PHP 7 introduced the &lt;a href=&quot;https://stackoverflow.com/a/31298778/476&quot;&gt;spaceship operator&lt;/a&gt;, which unifies and simplifies equal/smaller/larger than comparisons across types:</source>
          <target state="translated">PHP 7은 &lt;a href=&quot;https://stackoverflow.com/a/31298778/476&quot;&gt;우주선 연산자를&lt;/a&gt; 도입했습니다.이 연산자 는 유형 간 비교보다 동일 / 소규모 / 대형을 통합하고 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="3f2d32e9b9fcccd95d471d74d44aa03d86740971" translate="yes" xml:space="preserve">
          <source>Permutation sort</source>
          <target state="translated">순열 정렬</target>
        </trans-unit>
        <trans-unit id="c173eb402711aa25b0f47a3eba4637bd8ca240a3" translate="yes" xml:space="preserve">
          <source>Permutation sort, which proceeds by generating the possible permutations of the input array/list until discovering the sorted one.</source>
          <target state="translated">순열 정렬-정렬 된 항목을 발견 할 때까지 입력 배열 / 목록의 가능한 순열을 생성하여 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="d44cb3d8ba3820f721444056407b199d364b0108" translate="yes" xml:space="preserve">
          <source>Quicksort</source>
          <target state="translated">Quicksort</target>
        </trans-unit>
        <trans-unit id="4e2f2ccda2d141cdb71813f9ece456d6058909d2" translate="yes" xml:space="preserve">
          <source>Quicksort, or partition-exchange sort, is a sorting algorithm developed by Tony Hoare that, on average, makes O(n log n) comparisons to sort n items. In the worst case, it makes O(n2) comparisons, though this behavior is rare.</source>
          <target state="translated">Quicksort (파티션 교환 정렬)는 Tony Hoare가 개발 한 정렬 알고리즘으로 평균적으로 n (n log n)을 비교하여 n 개의 항목을 정렬합니다. 최악의 경우,이 동작은 드물지만 O (n2) 비교를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bff4909dacd843638a143efdc8a9f26a73d4d021" translate="yes" xml:space="preserve">
          <source>Radix sort</source>
          <target state="translated">기수 정렬</target>
        </trans-unit>
        <trans-unit id="c7ffa0f7b8c42b69643661d77faa8591b90c537c" translate="yes" xml:space="preserve">
          <source>Sample data for my demonstrations:</source>
          <target state="translated">내 데모에 대한 샘플 데이터 :</target>
        </trans-unit>
        <trans-unit id="e3cdf383e3767cd3d19172cf65aee5ac75789a6a" translate="yes" xml:space="preserve">
          <source>Selection sort</source>
          <target state="translated">선택 정렬</target>
        </trans-unit>
        <trans-unit id="5b80873e838a3de2e0b8501112112c5e85d97341" translate="yes" xml:space="preserve">
          <source>Shellsort</source>
          <target state="translated">Shellsort</target>
        </trans-unit>
        <trans-unit id="7f8c6841ac8c565f0f59479a33bf5e67aeff1fd7" translate="yes" xml:space="preserve">
          <source>Shellsort, also known as Shell sort or Shell's method, is an in-place comparison sort. It generalizes an exchanging sort, such as insertion or bubble sort, by starting the comparison and exchange of elements with elements that are far apart before finishing with neighboring elements.</source>
          <target state="translated">Shell sort 또는 Shell의 방법으로도 알려진 Shellsort는 전체 비교 정렬입니다. 인접한 요소로 마무리하기 전에 멀리 떨어진 요소와 요소를 비교하고 교환하기 시작하여 삽입 또는 버블 정렬과 같은 교환 정렬을 일반화합니다.</target>
        </trans-unit>
        <trans-unit id="c72db2b9bd5162f4ee3192fa5a58bf805b06a3e0" translate="yes" xml:space="preserve">
          <source>So ,Now I want to sort this array in ascending order according their value.'asort()' method can be used for that.</source>
          <target state="translated">이제이 배열을 값에 따라 오름차순으로 정렬하고 싶습니다 .'asort () '메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6deb74510a05647499e115f644b036d0c78033e2" translate="yes" xml:space="preserve">
          <source>Sorting by multiple fields</source>
          <target state="translated">여러 필드로 정렬</target>
        </trans-unit>
        <trans-unit id="0abc6fe29f723ac5ab847735d61a3e848b86510b" translate="yes" xml:space="preserve">
          <source>Sorting into a manual, static order</source>
          <target state="translated">수동 정적 순서로 정렬</target>
        </trans-unit>
        <trans-unit id="6ae7466fd879afa82cce3b8c69fc1d7a38b8457b" translate="yes" xml:space="preserve">
          <source>Sorting logic:</source>
          <target state="translated">정렬 로직 :</target>
        </trans-unit>
        <trans-unit id="5828996ad33961b80dd02a99ba31c274af774b8c" translate="yes" xml:space="preserve">
          <source>Sorting one array based on another</source>
          <target state="translated">다른 배열을 기준으로 한 배열 정렬</target>
        </trans-unit>
        <trans-unit id="dc76f608fa88e8b8d88d502255d84d79946a6d0f" translate="yes" xml:space="preserve">
          <source>Sorting with SPL</source>
          <target state="translated">SPL로 정렬</target>
        </trans-unit>
        <trans-unit id="33e63fd49e04368d0c74d40d9016c5e47c3d84bc" translate="yes" xml:space="preserve">
          <source>Spaceship operator</source>
          <target state="translated">우주선 운영자</target>
        </trans-unit>
        <trans-unit id="b18198f5f9f57564c4ac888b338ec7bdf4bd8815" translate="yes" xml:space="preserve">
          <source>Stable sort</source>
          <target state="translated">안정적인 정렬</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="be8b35a38597692f15ee011684c538a2449fccf4" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;strong&gt;The PoWEr oF MATH&lt;/strong&gt; this returns a value &amp;lt; 0, 0 or &amp;gt; 0 depending on whether &lt;code&gt;$a&lt;/code&gt; is lower than, equal to or larger than &lt;code&gt;$b&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;PoWEr oF MATH&lt;/strong&gt; 덕분에 &lt;code&gt;$a&lt;/code&gt; 가 &lt;code&gt;$b&lt;/code&gt; 보다 작거나 같거나 더 큰지 여부에 따라 &amp;lt;0, 0 또는&amp;gt; 0 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18b26e687c8060faed4b3283538901d99924da0c" translate="yes" xml:space="preserve">
          <source>That's how simple sorting a complex multi-dimensional array can be. Again, just think in terms of &lt;em&gt;teaching PHP how to tell which of two items is &quot;greater&quot;&lt;/em&gt;; let PHP do the actual sorting.</source>
          <target state="translated">이것이 복잡한 다차원 배열을 얼마나 간단하게 정렬 할 수 있는가입니다. 다시 한 번, &lt;em&gt;PHP&lt;/em&gt; 를 &lt;em&gt;가르치는&lt;/em&gt; 관점 &lt;em&gt;에서 두 항목 중 어느 것이 &quot;더 큰&quot;항목인지 구별하는 방법을&lt;/em&gt; 생각해 &lt;em&gt;보십시오&lt;/em&gt; . PHP가 실제 정렬을 수행하게하십시오.</target>
        </trans-unit>
        <trans-unit id="12c288ba8b61fad8ca7f16d60422336faa5fe119" translate="yes" xml:space="preserve">
          <source>The SplMaxHeap class provides the main functionalities of a heap, keeping the maximum on the top.</source>
          <target state="translated">SplMaxHeap 클래스는 최대 값을 유지하면서 힙의 주요 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="054693f687dcbdc3235c558c02357cafa6badd3e" translate="yes" xml:space="preserve">
          <source>The SplMinHeap class provides the main functionalities of a heap, keeping the minimum on the top.</source>
          <target state="translated">SplMinHeap 클래스는 최소값을 유지하면서 힙의 주요 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d4d87b5e9fc3737c7e81b15ed8aa38249fbcf373" translate="yes" xml:space="preserve">
          <source>The difference between those is merely whether key-value associations are kept (the &quot;&lt;code&gt;a&lt;/code&gt;&quot; functions), whether it sorts low-to-high or reverse (&quot;&lt;code&gt;r&lt;/code&gt;&quot;), whether it sorts values or keys (&quot;&lt;code&gt;k&lt;/code&gt;&quot;) and how it compares values (&quot;&lt;code&gt;nat&lt;/code&gt;&quot; vs. normal). See &lt;a href=&quot;http://php.net/manual/en/array.sorting.php&quot;&gt;http://php.net/manual/en/array.sorting.php&lt;/a&gt; for an overview and links to further details.</source>
          <target state="translated">이들의 차이점은 단지 키-값 연관이 유지되는지 ( &quot; &lt;code&gt;a&lt;/code&gt; &quot;기능), 로우에서 하이로 또는 반대로 정렬하는지 ( &quot; &lt;code&gt;r&lt;/code&gt; &quot;), 값 또는 키를 정렬하는지 ( &quot; &lt;code&gt;k&lt;/code&gt; &quot;) 여부와 방법입니다. 값을 비교합니다 ( &quot; &lt;code&gt;nat&lt;/code&gt; &quot;대 정상). 개요 및 자세한 내용에 대한 링크는 &lt;a href=&quot;http://php.net/manual/en/array.sorting.php&quot;&gt;http://php.net/manual/en/array.sorting.php&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="725e8396ee12340d6238f40e07cd4a73b61075ce" translate="yes" xml:space="preserve">
          <source>The elements from both sides of the operator will be traversed left to right, one at a time, and returning the evaluation as soon as a non-tie is encountered or when the elements have all been compared.</source>
          <target state="translated">작업자 양쪽의 요소는 한 번에 한 개씩 왼쪽에서 오른쪽으로 이동하며, 타이가 발생하지 않거나 요소가 모두 비교되면 평가를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b2f20e21a299cb112503b754502d1f181c00b06" translate="yes" xml:space="preserve">
          <source>The expected result here would be:</source>
          <target state="translated">여기에 예상되는 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="953adeb96e5f44095ec62a8ec7fb264aa7f1685a" translate="yes" xml:space="preserve">
          <source>The final result:</source>
          <target state="translated">최종 결과 :</target>
        </trans-unit>
        <trans-unit id="c0657eaaa8eae57d4b0859d34d3f627d4a16f08b" translate="yes" xml:space="preserve">
          <source>The keen observer may have noticed that the array sorting algorithm (QuickSort) didn't produce a stable outcome and that the original order between words of the same first letter wasn't preserved. This case is trivial and we should have compared the whole string, but let's assume your use-case is more complicated, such as two consecutive sorts on different fields that shouldn't cancel out each other's work.</source>
          <target state="translated">예리한 관찰자는 배열 정렬 알고리즘 (QuickSort)이 안정적인 결과를 얻지 못했으며 동일한 첫 글자의 단어 사이의 원래 순서가 유지되지 않았 음을 알 수 있습니다. 이 사례는 사소한 것이며 전체 문자열을 비교해야하지만 서로 다른 작업을 취소하지 않아야하는 서로 다른 필드에 대한 두 개의 연속 정렬과 같이 사용 사례가 더 복잡하다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="40557e3db4165270942853579e99a47f46705025" translate="yes" xml:space="preserve">
          <source>The outcome is this:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ab3b917f6b1d0b8f5cf7e5e7047d13f590ba823" translate="yes" xml:space="preserve">
          <source>The simplest is to use usort function to sort array without any looping :
Below is an example :</source>
          <target state="translated">가장 간단한 방법은 usort 함수를 사용하여 루핑없이 배열을 정렬하는 것입니다. 아래는 예입니다.</target>
        </trans-unit>
        <trans-unit id="b2b8e2cb335886e04d4d752fe8fe7627299eacc6" translate="yes" xml:space="preserve">
          <source>There are several ways to sort an array.I will mention some methods for doing that task.fist of all , I will give an integer array which is called as '$numbers'.</source>
          <target state="translated">배열을 정렬하는 방법에는 여러 가지가 있습니다. 나는 그 task.fist를 수행하는 몇 가지 방법을 언급 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f08a86bb02cd3d4e2099033080e2835aae6d74dd" translate="yes" xml:space="preserve">
          <source>These are the some methods for sorting an array in ascending or descending order in php.I hope to you could get an idea.Thank you!</source>
          <target state="translated">다음은 PHP에서 오름차순 또는 내림차순으로 배열을 정렬하는 몇 가지 방법입니다. 아이디어를 얻을 수 있기를 바랍니다. 감사합니다!</target>
        </trans-unit>
        <trans-unit id="8c2be70445cb54d01611838358190c3a777e3184" translate="yes" xml:space="preserve">
          <source>This is the normal way to creating an array. Suppose that , I want to sort that array in ascending order.For that, 'sort()' method can be used.</source>
          <target state="translated">이것이 배열을 만드는 일반적인 방법입니다. , 배열을 오름차순으로 정렬하고 싶다고 가정하면 'sort ()'메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dde20aef894f0fb7fd0addad9c8e2eca69acf984" translate="yes" xml:space="preserve">
          <source>This makes great strides in reducing code bloat and improving readability.</source>
          <target state="translated">이것은 코드 팽창을 줄이고 가독성을 향상시키는 데 큰 진전을 이룹니다.</target>
        </trans-unit>
        <trans-unit id="8ae5faa04b7f0b4ab713cf58213e707e0e5433a0" translate="yes" xml:space="preserve">
          <source>This page is very comprehensive, but I want to add a bit more about the awesome utility of the spaceship operator (three way comparison operator) -- a beautiful child of PHP7+.</source>
          <target state="translated">이 페이지는 매우 포괄적이지만 PHP7 +의 아름다운 자식 인 우주선 연산자 (3 방향 비교 연산자)의 멋진 유틸리티에 대해 조금 더 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="d2aa926b92b550aa69143e32375772daf3d60b1a" translate="yes" xml:space="preserve">
          <source>This question is intended as a reference for questions about sorting arrays in PHP. It is easy to think that your particular case is unique and worthy of a new question, but most are actually minor variations of one of the solutions on this page.</source>
          <target state="translated">이 질문은 PHP에서 배열 정렬에 대한 질문에 대한 참조로 사용됩니다. 특정 사례가 독특하고 새로운 질문에 합당하다고 생각하기는 쉽지만 실제로는이 페이지의 솔루션 중 하나를 약간 변형 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f80d90d89f72bcf9b275cd7306e8e7131a2b8842" translate="yes" xml:space="preserve">
          <source>This syntax allows you to sort values, functional outcomes, deep-nested data, and sorting direction in a elegant fashion.  This is definitely worth putting in your php toolbelt ...for cases when you are processing non-database data -- because of course SQL would be a much more sensible technique.</source>
          <target state="translated">이 구문을 사용하면 값, 기능적 결과, 중첩 된 데이터 및 정렬 방향을 우아한 방식으로 정렬 할 수 있습니다. 이것은 데이터베이스가 아닌 데이터를 처리하는 경우 PHP 툴 벨트에 넣을 가치가 있습니다. 물론 SQL은 훨씬 합리적인 기술이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="71b460d3c37c7ce78ce6b0d6df859d807f5083db" translate="yes" xml:space="preserve">
          <source>This transforms the array into this:</source>
          <target state="translated">그러면 배열이 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="0402d6569e261eb376cd0e0480149c110dfe7e44" translate="yes" xml:space="preserve">
          <source>This will sort in asending order :</source>
          <target state="translated">오름차순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="973b5f203a597863c3416acc2681e81c4c38e982" translate="yes" xml:space="preserve">
          <source>This will sort in desending order :</source>
          <target state="translated">이것은 desending 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="ec3712d52e6639c57acc511c0d5bd37714eb0283" translate="yes" xml:space="preserve">
          <source>To do that, you need to create a &lt;em&gt;comparison function&lt;/em&gt;. That function takes two elements and must return &lt;code&gt;0&lt;/code&gt; if these elements are considered equal, a value lower than &lt;code&gt;0&lt;/code&gt; if the first value is lower and a value higher than &lt;code&gt;0&lt;/code&gt; if the first value is higher. That's all that's needed:</source>
          <target state="translated">그러기 위해서는 &lt;em&gt;비교 함수&lt;/em&gt; 를 만들어야 &lt;em&gt;합니다&lt;/em&gt; . 이 함수는 두 개의 요소를 취하며 이러한 요소가 동일한 것으로 간주되면 &lt;code&gt;0&lt;/code&gt; 을 리턴해야합니다. 첫 번째 값이 낮은 경우 &lt;code&gt;0&lt;/code&gt; 보다 작은 값, 첫 번째 값이 높은 경우 0 보다 큰 값. 그게 전부입니다.</target>
        </trans-unit>
        <trans-unit id="9ff58a12c33c24d9444fe3d80dd760a502773162" translate="yes" xml:space="preserve">
          <source>To get used to this idea, try this:</source>
          <target state="translated">이 아이디어에 익숙해 지려면 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="4d7fc375f7c2d29c511ad47f3b0427f8fe029dc7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;array_multisort&lt;/code&gt; to get there:</source>
          <target state="translated">&lt;code&gt;array_multisort&lt;/code&gt; 를 사용하여 도착하십시오.</target>
        </trans-unit>
        <trans-unit id="cc8255a05e0c9e77bc8b8f60a36e1a52dda63dbb" translate="yes" xml:space="preserve">
          <source>Using the spaceship operator to implement multiple sort conditions</source>
          <target state="translated">우주선 연산자를 사용하여 여러 정렬 조건 구현</target>
        </trans-unit>
        <trans-unit id="01ba4a7aa0b09c32b597708fbf029367d4fc4548" translate="yes" xml:space="preserve">
          <source>Voila! Your pristine comparison code is back.</source>
          <target state="translated">짜잔! 원래 비교 코드가 돌아 왔습니다.</target>
        </trans-unit>
        <trans-unit id="4081ff83370ff929f9d82da1aa8c8026b891606f" translate="yes" xml:space="preserve">
          <source>Well most basic methods are already covered by &lt;a href=&quot;https://stackoverflow.com/a/17364128&quot;&gt;deceze&lt;/a&gt; I would try to look at other types of sort</source>
          <target state="translated">글쎄, 가장 기본적인 방법은 이미 다른 종류의 유형을 보려고 시도하는 &lt;a href=&quot;https://stackoverflow.com/a/17364128&quot;&gt;deceze로&lt;/a&gt; 덮여 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a5e3a6448c0eea877c84b7a66986dbba7567544" translate="yes" xml:space="preserve">
          <source>When writing your custom sort (&lt;code&gt;usort()&lt;/code&gt;/&lt;code&gt;uasort()&lt;/code&gt;/&lt;code&gt;uksort()&lt;/code&gt;) function to process a multiple conditions, you only need to write balanced arrays on either side of the operator and return the outcome. &lt;strong&gt;No more nested condition blocks or multiple returns.&lt;/strong&gt;</source>
          <target state="translated">여러 조건을 처리하기 위해 사용자 정의 정렬 ( &lt;code&gt;usort()&lt;/code&gt; / &lt;code&gt;uasort()&lt;/code&gt; / &lt;code&gt;uksort()&lt;/code&gt; ) 함수를 작성할 때 연산자의 양쪽에 균형 배열을 작성하고 결과 만 반환하면됩니다. &lt;strong&gt;더 이상 중첩 된 조건 블록 또는 다중 리턴이 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6ab42d0070bc672b70cc0b562ef5caca83182c66" translate="yes" xml:space="preserve">
          <source>You can do anything you need inside a comparison function, including calling functions:</source>
          <target state="translated">함수 호출을 포함하여 비교 함수 내에서 필요한 모든 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2598758b7b8e523ec8fa99a6fb1a68f431a6a36" translate="yes" xml:space="preserve">
          <source>You can see all these examples &lt;a href=&quot;https://github.com/ihor/Nspl/blob/master/examples/a_sorted.php&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 모든 예제를 &lt;a href=&quot;https://github.com/ihor/Nspl/blob/master/examples/a_sorted.php&quot;&gt;여기서&lt;/a&gt; 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c73513599241b3ce7f8138e76771704dbf6c490" translate="yes" xml:space="preserve">
          <source>You can see printed number array is sorted. If you want to that number array to be sort is descending order, 'rsort()' method can be use for that task.</source>
          <target state="translated">인쇄 번호 배열이 정렬되어 있음을 알 수 있습니다. 해당 숫자 배열을 정렬 순서로 내림차순으로 지정하려면 해당 작업에 'rsort ()'메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9fa873c922dd4519bb3310f2049638099570603" translate="yes" xml:space="preserve">
          <source>You had to rewrite your comparison function to work with the transformed array elements; you may not want to edit your delicate comparison functions, so here's a wrapper for the comparison function:</source>
          <target state="translated">변환 된 배열 요소에 대해 작업하려면 비교 함수를 다시 작성해야했습니다. 섬세한 비교 함수를 편집하고 싶지 않을 수 있으므로 비교 함수의 래퍼는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f693970746f4c98af758145696b3f03075e624fd" translate="yes" xml:space="preserve">
          <source>You then use one of these functions:</source>
          <target state="translated">그런 다음 다음 기능 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6dc10b51f4ac19dc7e1c1bf1c90cd2514ff5fda" translate="yes" xml:space="preserve">
          <source>boolean ASC</source>
          <target state="translated">부울 ASC</target>
        </trans-unit>
        <trans-unit id="011f88a6deac532999df9a4bf406f2452a5e4ec2" translate="yes" xml:space="preserve">
          <source>boolean DESC (false = 0, true = 1, so trues before falses)</source>
          <target state="translated">부울 DESC (false = 0, true = 1이므로 false 전에 true)</target>
        </trans-unit>
        <trans-unit id="51aa2637eade754937f7d4b54457cc38ed3ebe0d" translate="yes" xml:space="preserve">
          <source>consider the output..</source>
          <target state="translated">출력을 고려하십시오 ..</target>
        </trans-unit>
        <trans-unit id="435226da679aca3541980cba99db2b6a022eb075" translate="yes" xml:space="preserve">
          <source>float ASC</source>
          <target state="translated">플로트 ASC</target>
        </trans-unit>
        <trans-unit id="2d71871d1b3a78e77346189fe7602ee55e8ea317" translate="yes" xml:space="preserve">
          <source>i.e., in order to sort first by a, then b, then c, the correct clause would be</source>
          <target state="translated">즉, 먼저 a, b, c를 기준으로 정렬하려면 올바른 절이됩니다.</target>
        </trans-unit>
        <trans-unit id="b13b3070cef0cf3ace0f7f9a184ef548be1c6c51" translate="yes" xml:space="preserve">
          <source>iterability of mixed DESC</source>
          <target state="translated">혼합 DESC의 반복성</target>
        </trans-unit>
        <trans-unit id="acb5e075da5022ac6ab70076026e7f717ee2621a" translate="yes" xml:space="preserve">
          <source>mixed ASC</source>
          <target state="translated">혼합 ASC</target>
        </trans-unit>
        <trans-unit id="641c176e662a04a9783622e92508da3d59203cd6" translate="yes" xml:space="preserve">
          <source>natString ASC</source>
          <target state="translated">natString ASC</target>
        </trans-unit>
        <trans-unit id="92be7e45d7a0699bc3a9c9723e9cb645e47c33fd" translate="yes" xml:space="preserve">
          <source>natString length ASC</source>
          <target state="translated">natString 길이 ASC</target>
        </trans-unit>
        <trans-unit id="d4a4c6438367ffdd711c2e9f3c7389c021225aed" translate="yes" xml:space="preserve">
          <source>object ASC</source>
          <target state="translated">객체 ASC</target>
        </trans-unit>
        <trans-unit id="678cf1c73e8c23cc8b56f38065ff425f1804790c" translate="yes" xml:space="preserve">
          <source>property count of object ASC</source>
          <target state="translated">객체 ASC의 속성 수</target>
        </trans-unit>
        <trans-unit id="2c81b69885c711d3fc704aa7da591bfb0542dc5e" translate="yes" xml:space="preserve">
          <source>to produce</source>
          <target state="translated">생산하는</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
