<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/17364127">
    <body>
      <group id="17364127">
        <trans-unit id="64c134d03b9bef7a1b2c4b1cc5a323435009edc5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;The Schwartzian transform&lt;/a&gt;, also referred to as the decorate-sort-undecorate idiom, effects a stable sort with an inherently unstable sorting algorithm.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Преобразование Шварца&lt;/a&gt; , также называемое идиомой decorate-sort-undecorate, обеспечивает устойчивую сортировку с помощью изначально нестабильного алгоритма сортировки.</target>
        </trans-unit>
        <trans-unit id="ec0b9d91e8865701f4b5b4d7b036cf124aafa4d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sort&lt;/code&gt; sorts by reference and does not return anything useful!</source>
          <target state="translated">&lt;code&gt;sort&lt;/code&gt; сортируется по ссылке и не возвращает ничего полезного!</target>
        </trans-unit>
        <trans-unit id="5acc8ee181e8da0ea9d9be45f707be213fefa4db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strcmp&lt;/code&gt; does exactly what's expected of &lt;code&gt;cmp&lt;/code&gt; here, it returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strcmp&lt;/code&gt; делает именно то, что ожидается от &lt;code&gt;cmp&lt;/code&gt; , он возвращает &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6250fe13bd2141652473bccea20d7a3edc21534a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;usort&lt;/code&gt; will take two items from the array and call your &lt;code&gt;cmp&lt;/code&gt; function with them. So &lt;code&gt;cmp()&lt;/code&gt; will be called with &lt;code&gt;$a&lt;/code&gt; as &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; as another &lt;code&gt;array('foo' =&amp;gt; ..., 'baz' =&amp;gt; ...)&lt;/code&gt;. The function then returns to &lt;code&gt;usort&lt;/code&gt; which of the values was larger or whether they were equal. &lt;code&gt;usort&lt;/code&gt; repeats this process passing different values for &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; until the array is sorted. The &lt;code&gt;cmp&lt;/code&gt; function will be called many times, &lt;em&gt;at least&lt;/em&gt; as many times as there are values in &lt;code&gt;$array&lt;/code&gt;, with different combinations of values for &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; every time.</source>
          <target state="translated">&lt;code&gt;usort&lt;/code&gt; возьмет два элемента из массива и вызовет с ними вашу &lt;code&gt;cmp&lt;/code&gt; . Таким образом, &lt;code&gt;cmp()&lt;/code&gt; будет вызываться с &lt;code&gt;$a&lt;/code&gt; &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; как другим &lt;code&gt;array('foo' =&amp;gt; ..., 'baz' =&amp;gt; ...)&lt;/code&gt; Затем функция возвращает &lt;code&gt;usort&lt;/code&gt; , какое из значений было больше или равны ли они. &lt;code&gt;usort&lt;/code&gt; повторяет этот процесс, передавая разные значения для &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; пока массив не будет отсортирован. Функция &lt;code&gt;cmp&lt;/code&gt; будет вызываться много раз, &lt;em&gt;по крайней&lt;/em&gt; мере, столько раз, сколько есть значений в &lt;code&gt;$array&lt;/code&gt; , с разными комбинациями значений для &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; каждый раз.</target>
        </trans-unit>
        <trans-unit id="91a3fac04b5043f66c638448a2ec4a9d40256c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basic sorting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Базовая сортировка&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae5cef9d3d93e404cd7eaf3cebb98381606bb57f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multidimensional sort by key value&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Многомерная сортировка по значению ключа&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ad87ca1f0b6cc5122ffd4adf3852faabfb4606d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting array of objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сортировка массива объектов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d54d56ae70bc0bd717365af26342ff7f0609c18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting by function result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сортировка по результату функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="442b02603b1b00edd73e6ecb47de346ad50a30a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting multidimensional array&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сортировка многомерного массива&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7427550bbfea3e00b1744c697847bdfdc2887d54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting with a comparison function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сортировка с функцией сравнения&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e21f70118d196d40f3aca759ed5d74ff5bb9753d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Test case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Прецедент:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5043ab6424dd981758b046a437b0a3d11f0fac39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Schwartzian transform&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Преобразование Шварца&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c570d11b81351591dc82387e9c2d0e5c99eed9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The sort wasn't stable!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сорт не был стабильным!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae6f075d81fe91ec85a2cda94e88595f84602fb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What about reuse?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как насчет повторного использования?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6153e439d266c625b80b0798a43006194091e98" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;* developed by me, see readme for more details and comparison with other LINQ ports&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;* разработанный мной, см. readme для более подробной информации и сравнения с другими портами LINQ&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f9df68a046eeab006969fe2d05597fc43aedc367" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;If you have more common cases, feel free to edit this answer.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Если у вас есть более распространенные случаи, не стесняйтесь редактировать этот ответ.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d0a564f5b4042652c7506a0e980220e88741b88a" translate="yes" xml:space="preserve">
          <source>A shortcut for the first string comparison version:</source>
          <target state="translated">Ярлык для первой версии сравнения строк:</target>
        </trans-unit>
        <trans-unit id="1d43617dc0b5a021c31bb1e8464713303a5a922c" translate="yes" xml:space="preserve">
          <source>Afterwards, we undecorate:</source>
          <target state="translated">После этого мы расстёгиваем декорации:</target>
        </trans-unit>
        <trans-unit id="7931945cc2816f5241e83f79777cd3649fe7a700" translate="yes" xml:space="preserve">
          <source>Again, they only differ in whether they keep key-value associations and sort by values or keys. Read their documentation for details.</source>
          <target state="translated">Опять же,они отличаются только тем,хранят ли они ассоциации значений ключей и сортируют ли они по значениям или ключам.Ознакомьтесь с их документацией для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="a70cd3b3cb5f9b9f666113d7269e0526e688db81" translate="yes" xml:space="preserve">
          <source>All you did was define a custom way to compare two items, that's all you need. That works with all sorts of values.</source>
          <target state="translated">Все,что вы сделали,это определили пользовательский способ сравнения двух элементов,это все,что вам нужно.Это работает со всевозможными значениями.</target>
        </trans-unit>
        <trans-unit id="7e5e4131293f07cab8ee6d2fcb5a44fee49f9403" translate="yes" xml:space="preserve">
          <source>Also for all of the above, to switch between ascending and descending order simply swap the &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; arguments around. E.g.:</source>
          <target state="translated">Также для всего вышеперечисленного, чтобы переключаться между возрастающим и нисходящим порядком, просто поменяйте местами аргументы &lt;code&gt;$a&lt;/code&gt; и &lt;code&gt;$b&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b9601f704b51bebf86466d306bf841c6e4c693eb" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;https://stackoverflow.com/a/22812695/476&quot;&gt;this very neat shorthand version&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/22829326/476&quot;&gt;how to create such a comparison function dynamically for an arbitrary number of keys&lt;/a&gt;.</source>
          <target state="translated">Также посмотрите &lt;a href=&quot;https://stackoverflow.com/a/22812695/476&quot;&gt;эту очень аккуратную сокращенную версию&lt;/a&gt; и &lt;a href=&quot;https://stackoverflow.com/a/22829326/476&quot;&gt;как динамически создать такую ​​функцию сравнения для произвольного числа ключей&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8716dd3e8af6710d5fdaa991141a80734a184f4a" translate="yes" xml:space="preserve">
          <source>And now you want to sort on the first letter only:</source>
          <target state="translated">А теперь ты хочешь разобраться только с первой буквой:</target>
        </trans-unit>
        <trans-unit id="ece93d1b3c1ff5290fd30d672442002e929ec257" translate="yes" xml:space="preserve">
          <source>And then there's the peculiar &lt;a href=&quot;http://php.net/array_multisort&quot;&gt;&lt;code&gt;array_multisort&lt;/code&gt;&lt;/a&gt;, which lets you sort one array based on another:</source>
          <target state="translated">И еще есть своеобразный &lt;a href=&quot;http://php.net/array_multisort&quot;&gt; &lt;code&gt;array_multisort&lt;/code&gt; &lt;/a&gt; , который позволяет сортировать один массив на основе другого:</target>
        </trans-unit>
        <trans-unit id="a7272763986e00b04cd352962090c6aeb7a8abd7" translate="yes" xml:space="preserve">
          <source>Applicable sort functions:</source>
          <target state="translated">Применимые функции сортировки:</target>
        </trans-unit>
        <trans-unit id="1f5fbafcc6b2be3e4003214daaf54304ae710e57" translate="yes" xml:space="preserve">
          <source>As of PHP 5.3 with closures it is also possible to use a closure to determine the order of your sort.</source>
          <target state="translated">Начиная с PHP 5.3 с закрытием можно также использовать закрытие,чтобы определить порядок вашего вида.</target>
        </trans-unit>
        <trans-unit id="a26da193435c50e2c23ef2300be7cff7d23086bf" translate="yes" xml:space="preserve">
          <source>As of PHP 5.5.0 you can use &lt;code&gt;array_column&lt;/code&gt; to extract a column from a multi dimensional array and sort the array on that column:</source>
          <target state="translated">Начиная с PHP 5.5.0, вы можете использовать &lt;code&gt;array_column&lt;/code&gt; для извлечения столбца из многомерного массива и сортировки массива по этому столбцу:</target>
        </trans-unit>
        <trans-unit id="3aa88f9496d79e65e1268bd5cd94428456942d7d" translate="yes" xml:space="preserve">
          <source>As of PHP 7.0.0 you can also extract properties from an array of objects.</source>
          <target state="translated">Начиная с версии PHP 7.0.0 вы также можете извлекать свойства из массива объектов.</target>
        </trans-unit>
        <trans-unit id="3a6c74b1fb6f77c435e7654b0a2bb753b7036c67" translate="yes" xml:space="preserve">
          <source>At your own discretion, from PHP7.4 you can use arrow syntax with these anonymous functions.  &lt;a href=&quot;https://3v4l.org/N5hs1&quot;&gt;Same script with arrow syntax&lt;/a&gt;.</source>
          <target state="translated">По вашему усмотрению, с PHP7.4 вы можете использовать синтаксис стрелок с этими анонимными функциями. &lt;a href=&quot;https://3v4l.org/N5hs1&quot;&gt;Тот же скрипт с синтаксисом стрелок&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3481f742ff766b292ff10b811189b66a6a8a188" translate="yes" xml:space="preserve">
          <source>Basic one dimensional arrays</source>
          <target state="translated">Базовые одномерные массивы</target>
        </trans-unit>
        <trans-unit id="1c0f6078f43ed59ef9e69be5b2d9b8ba776052ee" translate="yes" xml:space="preserve">
          <source>Basic one-dimensional arrays; Incl. Multidimensional arrays, incl. arrays of objects; Incl. Sorting one array based on another</source>
          <target state="translated">Базовые одномерные массивы;Вкл.Многомерные массивы,включая массивы объектов;Вкл.Сортировка одного массива на основе другого</target>
        </trans-unit>
        <trans-unit id="7a9564635844dbb13c650e09e6dca78deee82d44" translate="yes" xml:space="preserve">
          <source>Bubble Sort</source>
          <target state="translated">Сорт пузырьков</target>
        </trans-unit>
        <trans-unit id="0ee0df1fe84ba4f23bf4a4787e7f2ab939905d5b" translate="yes" xml:space="preserve">
          <source>Bubble sort, sometimes incorrectly referred to as sinking sort, is a simple sorting algorithm that works by repeatedly stepping through the list to be sorted, comparing each pair of adjacent items and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm gets its name from the way smaller elements &quot;bubble&quot; to the top of the list. Because it only uses comparisons to operate on elements, it is a comparison sort. Although the algorithm is simple, most of the other sorting algorithms are more efficient for large lists.</source>
          <target state="translated">Сортировка пузырьков,иногда ошибочно называемая сортировкой опускания,представляет собой простой алгоритм сортировки,который работает путем многократного прохождения по сортируемому списку,сравнения каждой пары соседних элементов и замены их,если они находятся в неправильном порядке.Проход по списку повторяется до тех пор,пока свопы не понадобятся,что говорит о том,что список отсортирован.Алгоритм получает свое название от способа &quot;пузырька&quot; мелких элементов к вершине списка.Так как он использует сравнения только для работы с элементами,то это и есть сортировка по сравнению.Хотя алгоритм прост,большинство других алгоритмов сортировки более эффективны для больших списков.</target>
        </trans-unit>
        <trans-unit id="3f5228c2bb37ea03d02a48ced721ff6fce42582f" translate="yes" xml:space="preserve">
          <source>By the way, this works on any value, the values don't have to be complex arrays. If you have a custom comparison you want to do, you can do it on a simple array of numbers too.</source>
          <target state="translated">Кстати,это работает на любом значении,значения не обязательно должны быть сложными массивами.Если у вас есть пользовательское сравнение,которое вы хотите сделать,вы можете сделать это и на простом массиве чисел.</target>
        </trans-unit>
        <trans-unit id="1f7b5e3a07e4aa10794b25b9eb1b333d19a93959" translate="yes" xml:space="preserve">
          <source>Comb sort</source>
          <target state="translated">Комбинированная сортировка</target>
        </trans-unit>
        <trans-unit id="2a88d28be7a721a09c87fbc18b87669fb817bf11" translate="yes" xml:space="preserve">
          <source>Comb sort is a relatively simple sorting algorithm originally designed by Wlodzimierz Dobosiewicz in 1980. Later it was rediscovered by Stephen Lacey and Richard Box in 1991. Comb sort improves on bubble sort.</source>
          <target state="translated">Комбинированная сортировка является относительно простым алгоритмом сортировки,первоначально разработанным Влодзимежем Добосьевичем в 1980 году.Позже он был заново открыт Стивеном Лейси и Ричардом Боксом в 1991 году.Комбинированная сортировка улучшает сортировку пузырьков.</target>
        </trans-unit>
        <trans-unit id="646e0b865c714a7aff37ecc033eed142b2c958be" translate="yes" xml:space="preserve">
          <source>Comparisons can be further customized by passing a callback as a second argument, for example:</source>
          <target state="translated">Сравнения можно дополнительно настроить,например,передав обратный вызов в качестве второго аргумента:</target>
        </trans-unit>
        <trans-unit id="a1dbb3512ba2c2ef412c726afc917e9ed563da64" translate="yes" xml:space="preserve">
          <source>Custom numeric comparisons</source>
          <target state="translated">Пользовательские численные сравнения</target>
        </trans-unit>
        <trans-unit id="2a8dd816d14251367ee45f28876e6654657e5dc0" translate="yes" xml:space="preserve">
          <source>Demonstrations (to avoid Stackoverflow page bloat, please see &lt;a href=&quot;https://3v4l.org/2OnVs&quot;&gt;the demo link&lt;/a&gt; for the outputs):</source>
          <target state="translated">Демонстрации (чтобы избежать раздувания страницы Stackoverflow, см. &lt;a href=&quot;https://3v4l.org/2OnVs&quot;&gt;Демонстрационную ссылку&lt;/a&gt; для выходов):</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">Пример использования:</target>
        </trans-unit>
        <trans-unit id="f9aad07cf38b9608c1a59cad08fd3d2a44488a85" translate="yes" xml:space="preserve">
          <source>First, you decorate each array element with another array comprising a primary key (the value) and a secondary key (its index or position):</source>
          <target state="translated">Сначала каждый элемент массива украшается другим массивом,состоящим из первичного ключа (значение)и вторичного ключа (его индекс или позиция):</target>
        </trans-unit>
        <trans-unit id="5d589d82437d73e6fc415fb3acaa13acf2e67fbc" translate="yes" xml:space="preserve">
          <source>For all the above, if you're using PHP 5.3 or higher (and you really should), use anonymous functions for shorter code and to avoid having another global function floating around:</source>
          <target state="translated">Для всего вышеперечисленного,если вы используете PHP 5.3 или выше (и вам действительно стоит это сделать),используйте анонимные функции для более короткого кода и чтобы избежать плавания еще одной глобальной функции:</target>
        </trans-unit>
        <trans-unit id="8a7d9d374259b691daf285d948859be53a0d48f4" translate="yes" xml:space="preserve">
          <source>For example assuming $array is an array of objects that contain a month property.</source>
          <target state="translated">Например,предполагая,что $array-это массив объектов,которые содержат свойство месяц.</target>
        </trans-unit>
        <trans-unit id="05c24c41a15f9e61769c627b1026c3bba5757c1a" translate="yes" xml:space="preserve">
          <source>For the practical answer using PHP's existing functions see 1., for the academic in-detail answer on sorting algorithms (which PHP's functions implement and which you &lt;em&gt;may&lt;/em&gt; need for really, really complex cases), see 2.</source>
          <target state="translated">Для практического ответа с использованием существующих функций PHP см. 1., для академического подробного ответа об алгоритмах сортировки (которые реализуют функции PHP и которые вам &lt;em&gt;могут&lt;/em&gt; понадобиться в действительно очень сложных случаях), см. 2.</target>
        </trans-unit>
        <trans-unit id="e7e0012b84ebe1c2d6c656f0728fbc05a8b629e0" translate="yes" xml:space="preserve">
          <source>For those familiar, this is equivalent to an SQL query with &lt;code&gt;ORDER BY foo, baz&lt;/code&gt;.</source>
          <target state="translated">Для тех, кто знаком, это эквивалентно запросу SQL с &lt;code&gt;ORDER BY foo, baz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10713d2d5d97f92b70ceeaa1abf16e664ba19d25" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Comb_sort&quot;&gt;the Wikipedia article on Comb sort:&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;http://en.wikipedia.org/wiki/Comb_sort&quot;&gt;статьи в Википедии о сортировке Расчески:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af6f8187ecb41c7a3a724fde62c2291f0de0c1e6" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Merge_sort&quot;&gt;the Wikipedia article on Merge sort:&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;http://en.wikipedia.org/wiki/Merge_sort&quot;&gt;статьи в Википедии о сортировке слиянием:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f04a70693d1fc91e698f20afedbe860f081e3080" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Quicksort&quot;&gt;the Wikipedia article on Quicksort:&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;http://en.wikipedia.org/wiki/Quicksort&quot;&gt;статьи Википедии о быстрой сортировке:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="231cb574983359b4f2fc2d0eabb3cee56f18d159" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;the Wikipedia article on Radix sort:&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;статьи в Википедии о сортировке Radix:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="335cc9004b8bc9590aeeaa5f2c309c7998fffbc1" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Selection_sort&quot;&gt;the Wikipedia article on Selection sort:&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;http://en.wikipedia.org/wiki/Selection_sort&quot;&gt;статьи Википедии о сортировке выбора:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa8d636c21c2bb087af8f1c0516b00da6213c942" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort&quot;&gt;the Wikipedia article on Permutation sort:&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort&quot;&gt;статьи Википедии о перестановочной сортировке:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="598734ed0e26e19f679e1e9533a6ea9144140fc1" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;Wikipedia article on Bubble Sort:&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;статьи Википедии о Bubble Sort:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6bc71c3a10f14e6b4ea14a4d51755b852912608" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;Wikipedia article on Insertion sort:&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;статьи Википедии о сортировке вставок:&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75d4de6c59d942777ba337701271351a8ba9c7bc" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://en.wikipedia.org/wiki/Shellsort&quot;&gt;Wikipedia article on Shellsort:&lt;/a&gt;</source>
          <target state="translated">Из &lt;a href=&quot;http://en.wikipedia.org/wiki/Shellsort&quot;&gt;статьи&lt;/a&gt; в Википедии о Shellsort:</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="bc53affe93a56f0ac2327b800d76e9c76e766162" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;'$v-&amp;gt;count'&lt;/code&gt; is a shorthand for &lt;code&gt;function ($v) { return $v-&amp;gt;count; }&lt;/code&gt; (either can be used). These method chains return iterators, iterators can be transformed to arrays by adding &lt;code&gt;-&amp;gt;toArray()&lt;/code&gt; in the end if needed.</source>
          <target state="translated">Здесь &lt;code&gt;'$v-&amp;gt;count'&lt;/code&gt; является сокращением для &lt;code&gt;function ($v) { return $v-&amp;gt;count; }&lt;/code&gt; } (может использоваться любой). Эти цепочки методов возвращают итераторы, итераторы могут быть преобразованы в массивы путем добавления &lt;code&gt;-&amp;gt;toArray()&lt;/code&gt; в конце, если это необходимо.</target>
        </trans-unit>
        <trans-unit id="37d11951535b9e7819e17bbaa7fa8bb897720d41" translate="yes" xml:space="preserve">
          <source>How can I sort arrays and data in PHP</source>
          <target state="translated">Как я могу сортировать массивы и данные в PHP</target>
        </trans-unit>
        <trans-unit id="59294f795e706794f92a5ab10d06ef7bfa38d205" translate="yes" xml:space="preserve">
          <source>How do I sort a &lt;em&gt;complex&lt;/em&gt; array in PHP?</source>
          <target state="translated">Как отсортировать &lt;em&gt;сложный&lt;/em&gt; массив в PHP?</target>
        </trans-unit>
        <trans-unit id="70590ec3e9e5b76199d05655615734e1136c5ea3" translate="yes" xml:space="preserve">
          <source>How do I sort an array in PHP?</source>
          <target state="translated">Как отсортировать массив в PHP?</target>
        </trans-unit>
        <trans-unit id="ffc8695c757dd16a946a9df92a2827b4afaac13c" translate="yes" xml:space="preserve">
          <source>How do I sort an array of objects in PHP?</source>
          <target state="translated">Как отсортировать массив объектов в PHP?</target>
        </trans-unit>
        <trans-unit id="0464412340e55485032482f66471f7409836566d" translate="yes" xml:space="preserve">
          <source>If someone wants a simpler solution to manipulate arrays, just use Laravel Collection package which has an implemented sortBy function that lets your sort by keys simply.</source>
          <target state="translated">Если кому-то нужно более простое решение для управления массивами,просто воспользуйтесь пакетом Laravel Collection,в котором реализована функция sortBy,позволяющая сортировать по клавишам просто.</target>
        </trans-unit>
        <trans-unit id="45bf070aff3c78274f4df26fea9e3429bf4ad3b8" translate="yes" xml:space="preserve">
          <source>If sorting descending order according their value,'arsort()' method can be used.
Suppose that you want to sort that array according their key value. In this , 'ksort()' method can be use.</source>
          <target state="translated">При сортировке нисходящего порядка по их значению можно использовать метод 'arsort()'.Предположим,что вы хотите отсортировать этот массив по их ключевому значению.В этом методе можно использовать метод 'ksort()'.</target>
        </trans-unit>
        <trans-unit id="925d0b321049ce7fba34b78caeb03d17d843dd9b" translate="yes" xml:space="preserve">
          <source>If you have an array of objects, it works the same way:</source>
          <target state="translated">Если у вас есть массив объектов,то он работает точно так же:</target>
        </trans-unit>
        <trans-unit id="8edadb37485a056a0ba896c032254cd92d020270" translate="yes" xml:space="preserve">
          <source>If you want to order by the key value, then you can do it one line, elegant and clear.  This will order by the price ascending.  Uses array_multisort and array_column.</source>
          <target state="translated">Если вы хотите заказать по ключевому значению,то вы можете сделать это одной строкой,элегантно и ясно.Это будет заказывать по возрастающей цене.Использует array_multisort и array_column.</target>
        </trans-unit>
        <trans-unit id="6d1b10feb5169be2830f541c80ba389d86eb0388" translate="yes" xml:space="preserve">
          <source>If you want to sort &lt;code&gt;$array&lt;/code&gt; by the key 'foo' of each entry, you need a &lt;em&gt;custom comparison function&lt;/em&gt;. The above &lt;code&gt;sort&lt;/code&gt; and related functions work on simple values that they know how to compare and sort. PHP does not simply &quot;know&quot; what to do with a &lt;em&gt;complex value&lt;/em&gt; like &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; though; so you need to tell it.</source>
          <target state="translated">Если вы хотите отсортировать &lt;code&gt;$array&lt;/code&gt; по ключу 'foo' каждой записи, вам нужна &lt;em&gt;специальная функция сравнения&lt;/em&gt; . Вышеуказанная &lt;code&gt;sort&lt;/code&gt; и связанные с ней функции работают с простыми значениями, которые они умеют сравнивать и сортировать. PHP не просто &amp;laquo;знает&amp;raquo;, что делать со &lt;em&gt;сложным значением, таким&lt;/em&gt; как &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; ; так что вы должны сказать это.</target>
        </trans-unit>
        <trans-unit id="9f6716ad7296fe732de50b7dcb13b798d77ac3c5" translate="yes" xml:space="preserve">
          <source>If you want to sort by the &lt;code&gt;baz&lt;/code&gt; key, which is numeric, all you need to do is:</source>
          <target state="translated">Если вы хотите отсортировать по числовому ключу &lt;code&gt;baz&lt;/code&gt; , все, что вам нужно сделать, это:</target>
        </trans-unit>
        <trans-unit id="2d2d91011e4cafdd99a83cde167a000a3b9c397d" translate="yes" xml:space="preserve">
          <source>If you want to sort elements into a &quot;manual order&quot; like &lt;em&gt;&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;&lt;/em&gt;:</source>
          <target state="translated">Если вы хотите отсортировать элементы в &amp;laquo;ручной порядок&amp;raquo;, например, &lt;em&gt;&amp;laquo;foo&amp;raquo;, &amp;laquo;bar&amp;raquo;, &amp;laquo;baz&amp;raquo;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="52cc97be3f5343af977f4a56eb17cf35bc05914a" translate="yes" xml:space="preserve">
          <source>If you want to sort primarily by &lt;code&gt;foo&lt;/code&gt;, but if &lt;code&gt;foo&lt;/code&gt; is equal for two elements sort by &lt;code&gt;baz&lt;/code&gt;:</source>
          <target state="translated">Если вы хотите отсортировать в основном по &lt;code&gt;foo&lt;/code&gt; , но если &lt;code&gt;foo&lt;/code&gt; равно двум элементам, &lt;code&gt;baz&lt;/code&gt; по baz :</target>
        </trans-unit>
        <trans-unit id="af3d3d14d6ec1cb2fcbbe7eb203a079631fb777a" translate="yes" xml:space="preserve">
          <source>If your question is closed as a duplicate of this one, please ask for your question to be reopened only if you can explain why it differs markedly from all of the below.</source>
          <target state="translated">Если ваш вопрос закрыт как дубликат этого вопроса,пожалуйста,попросите,чтобы ваш вопрос был открыт заново только в том случае,если вы сможете объяснить,почему он заметно отличается от всех приведенных ниже.</target>
        </trans-unit>
        <trans-unit id="582175a51757c187ebe0a614be085ee5195af579" translate="yes" xml:space="preserve">
          <source>In .NET, LINQ is frequently used for sorting, which provides a much nicer syntax over comparison functions, especially when objects need to be sorted by multiple fields. There're several ports of LINQ to PHP, including &lt;a href=&quot;https://github.com/Athari/YaLinqo&quot;&gt;YaLinqo&lt;/a&gt; library*. With it, arrays can be sorted with a single line without writing complex comparison functions.</source>
          <target state="translated">В .NET LINQ часто используется для сортировки, что обеспечивает гораздо более приятный синтаксис по сравнению с функциями сравнения, особенно когда объекты должны быть отсортированы по нескольким полям. Существует несколько портов LINQ to PHP, включая библиотеку &lt;a href=&quot;https://github.com/Athari/YaLinqo&quot;&gt;YaLinqo&lt;/a&gt; *. С его помощью массивы можно сортировать одной строкой без написания сложных функций сравнения.</target>
        </trans-unit>
        <trans-unit id="f9ad5247ca5515c6c34dc526808eb4006a03baba" translate="yes" xml:space="preserve">
          <source>In computer science, a merge sort (also commonly spelled mergesort) is an O(n log n) comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the implementation preserves the input order of equal elements in the sorted output</source>
          <target state="translated">В компьютерной науке сортировка по слияниям (также обычно пишется как &quot;слияние&quot;)-это алгоритм сортировки на основе сравнения O(n log n).Большинство реализаций производят стабильную сортировку,что означает,что реализация сохраняет порядок ввода одинаковых элементов в отсортированном выводе</target>
        </trans-unit>
        <trans-unit id="fd773dac0cce1b252cddef9fa0e747f7ecda84a9" translate="yes" xml:space="preserve">
          <source>In computer science, radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value.</source>
          <target state="translated">В информатике сортировка radix-это несравнимый алгоритм сортировки целых чисел,который сортирует данные с целыми ключами,группируя ключи по отдельным цифрам,которые имеют одинаковую значительную позицию и значение.</target>
        </trans-unit>
        <trans-unit id="2bebc9e7fd3f70ecd7761684ac68e27bf4d9b7a7" translate="yes" xml:space="preserve">
          <source>In computer science, selection sort is a sorting algorithm, specifically an in-place comparison sort. It has O(n2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited.</source>
          <target state="translated">В информатике сортировка-это алгоритм сортировки,в частности,сортировка сравнения на месте.Он имеет временную сложность O(n2),что делает его неэффективным в больших списках,и обычно работает хуже,чем аналогичная сортировка вставок.Сортировка отличается простотой и имеет преимущества в производительности перед более сложными алгоритмами в определенных ситуациях,в частности,когда вспомогательная память ограничена.</target>
        </trans-unit>
        <trans-unit id="a5bbc46810b022a4f9a43546060c63f13368908b" translate="yes" xml:space="preserve">
          <source>Insertion sort</source>
          <target state="translated">Вставлять</target>
        </trans-unit>
        <trans-unit id="8a2aef5e40c2233bb33a10c7a43749ed88dbbd60" translate="yes" xml:space="preserve">
          <source>Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, insertion sort provides several advantages:</source>
          <target state="translated">Сортировка по вставке-это простой алгоритм сортировки,который строит конечный отсортированный массив (или список)по одному элементу за раз.Он гораздо менее эффективен в больших списках,чем более продвинутые алгоритмы,такие как quicksort,heapsort или сортировка слияний.Однако,сортировка по вставке дает несколько преимуществ:</target>
        </trans-unit>
        <trans-unit id="09dfd03d9fa968a44a324d9a9670952800b1a369" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;orderBy&lt;/code&gt; and related methods call appropriate array sorting functions (&lt;code&gt;uasort&lt;/code&gt;, &lt;code&gt;krsort&lt;/code&gt;, &lt;code&gt;multisort&lt;/code&gt;, &lt;code&gt;usort&lt;/code&gt; etc.).</source>
          <target state="translated">Внутренне, &lt;code&gt;orderBy&lt;/code&gt; и связанные методы вызывают соответствующие функции сортировки массива ( &lt;code&gt;uasort&lt;/code&gt; , &lt;code&gt;krsort&lt;/code&gt; , &lt;code&gt;multisort&lt;/code&gt; , &lt;code&gt;usort&lt;/code&gt; и т. Д.).</target>
        </trans-unit>
        <trans-unit id="da1531a814d65a809aa862e5d5c336dc8e0042a7" translate="yes" xml:space="preserve">
          <source>It is very convenient to sort arrays with &lt;a href=&quot;https://github.com/ihor/Nspl#sortedarray-array-reversed--false-key--null-cmp--null&quot;&gt;sorted&lt;/a&gt; function from &lt;a href=&quot;https://github.com/ihor/Nspl&quot;&gt;Nspl&lt;/a&gt;:</source>
          <target state="translated">Сортировать массивы с помощью &lt;a href=&quot;https://github.com/ihor/Nspl#sortedarray-array-reversed--false-key--null-cmp--null&quot;&gt;отсортированной&lt;/a&gt; функции из &lt;a href=&quot;https://github.com/ihor/Nspl&quot;&gt;Nspl&lt;/a&gt; очень удобно:</target>
        </trans-unit>
        <trans-unit id="667a4c437c43ca4427c06a7c18f482d831ef30ee" translate="yes" xml:space="preserve">
          <source>LINQ</source>
          <target state="translated">LINQ</target>
        </trans-unit>
        <trans-unit id="d7b23de8effd125677df7440a79328060cc5e033" translate="yes" xml:space="preserve">
          <source>LINQ contains many more methods inspired by SQL: filtering, grouping, joining, aggregating etc. It's best suited for cases when complex transformations on arrays and objects need to be performed without relying on databases.</source>
          <target state="translated">LINQ содержит множество других методов,вдохновленных SQL:фильтрация,группировка,присоединение,агрегация и т.д.Он лучше всего подходит для случаев,когда необходимо выполнять сложные преобразования на массивах и объектах,не полагаясь на базы данных.</target>
        </trans-unit>
        <trans-unit id="f64a19aa28fb1c68abbaec37b0257c0dcb685d6c" translate="yes" xml:space="preserve">
          <source>Let's say you have an array like this:</source>
          <target state="translated">Скажем так,у тебя есть такой массив:</target>
        </trans-unit>
        <trans-unit id="c6e2b023f3c4383d2cf7c27139646fae922e2b4a" translate="yes" xml:space="preserve">
          <source>Let's write the sort step using this function:</source>
          <target state="translated">Давайте напишем шаг сортировки с помощью этой функции:</target>
        </trans-unit>
        <trans-unit id="67151004822cc885e4122a06e2904151a40b8599" translate="yes" xml:space="preserve">
          <source>Merge sort</source>
          <target state="translated">Сортировка по типу слияния</target>
        </trans-unit>
        <trans-unit id="a90731fa64d2eaebed1e787a4012ebb1d3ba50b7" translate="yes" xml:space="preserve">
          <source>Multi dimensional arrays, including arrays of objects</source>
          <target state="translated">Многомерные массивы,в том числе массивы объектов</target>
        </trans-unit>
        <trans-unit id="6e0c416675708d317f2b07de659b4ababe413cc0" translate="yes" xml:space="preserve">
          <source>Natural sort of a multidimensional array by a key value and also keep the original order(do not shuffle the main keys):</source>
          <target state="translated">Естественный вид многомерного массива по значению ключа,а также сохранение исходного порядка (не тасуйте основные ключи):</target>
        </trans-unit>
        <trans-unit id="1b9453aa0a00bdf9f4d988745a47066a5de0f25b" translate="yes" xml:space="preserve">
          <source>Note that the array sorts &lt;em&gt;in place&lt;/em&gt;, you do not need to assign the return value to anything. &lt;code&gt;$array = sort($array)&lt;/code&gt; will replace the array with &lt;code&gt;true&lt;/code&gt;, not with a sorted array. Just &lt;code&gt;sort($array);&lt;/code&gt; works.</source>
          <target state="translated">Обратите внимание, что массив сортируется &lt;em&gt;на месте&lt;/em&gt; , вам не нужно присваивать возвращаемое значение чему-либо. &lt;code&gt;$array = sort($array)&lt;/code&gt; заменит массив на &lt;code&gt;true&lt;/code&gt; , а не на отсортированный массив. Просто &lt;code&gt;sort($array);&lt;/code&gt; работает.</target>
        </trans-unit>
        <trans-unit id="975c9470ca30f7d2e09bf09a076cb2fa5788f53e" translate="yes" xml:space="preserve">
          <source>Note that this won't work well for &lt;code&gt;float&lt;/code&gt; values, since they'll be reduced to an &lt;code&gt;int&lt;/code&gt; and lose precision. Use explicit &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; return values instead.</source>
          <target state="translated">Обратите внимание, что это не будет хорошо работать для значений с &lt;code&gt;float&lt;/code&gt; , так как они будут уменьшены до значения типа &lt;code&gt;int&lt;/code&gt; и потеряют точность. Вместо этого используйте явные &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; возвращаемые значения.</target>
        </trans-unit>
        <trans-unit id="9480ac07046c735f2fecfd2332cb6f82d4b86385" translate="yes" xml:space="preserve">
          <source>Now array is sorted according their key value.If You want to sort the array in descending order according their key value,'krsort()' method can be used.</source>
          <target state="translated">Если вы хотите отсортировать массив в порядке убывания в соответствии со значением ключа,то можно использовать метод krsort()'.</target>
        </trans-unit>
        <trans-unit id="6954657f48f6b7ff5d7802374273a3999c5374ed" translate="yes" xml:space="preserve">
          <source>Now array is sorted in descending order.Ok, Let's consider an associative array.I will give an associative array(Associative array means that, An array whose each index has unique key value.) like this,</source>
          <target state="translated">Теперь массив отсортирован в порядке убывания.Хорошо,рассмотрим ассоциативный массив,дадим ассоциативный массив (Ассоциативный массив означает,что массив,каждый индекс которого имеет уникальное значение ключа),</target>
        </trans-unit>
        <trans-unit id="8ae68b7f9f856327cadf4b20822beefd6eed6802" translate="yes" xml:space="preserve">
          <source>Now associative array is sorted in descending order according their key value.Look at the output.</source>
          <target state="translated">Теперь ассоциативный массив сортируется в порядке убывания в соответствии с их ключевым значением.Посмотрите на вывод.</target>
        </trans-unit>
        <trans-unit id="72ee2e304658dc96b31d0a5b7baf0c4b1799c99d" translate="yes" xml:space="preserve">
          <source>Now consider the output of that,</source>
          <target state="translated">Теперь рассмотрим результат,</target>
        </trans-unit>
        <trans-unit id="d827a6d027f57d096cc39d07e7c52f06a4bc5370" translate="yes" xml:space="preserve">
          <source>Now consider the output.</source>
          <target state="translated">Теперь рассмотрим выход.</target>
        </trans-unit>
        <trans-unit id="bb53e72bba70d545e597e3fd609e9845c180b9b2" translate="yes" xml:space="preserve">
          <source>Now, we adjust the comparison step; we compare the first letter again, but if they're the same, the secondary key is used to retain the original ordering:</source>
          <target state="translated">Теперь мы корректируем шаг сравнения;мы снова сравниваем первую букву,но если они одинаковые,то для сохранения исходного заказа используется вторичный ключ:</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="e39453d0bca511e0ba4ab9de0245d522eae2bb85" translate="yes" xml:space="preserve">
          <source>Often, you will want to use an &lt;a href=&quot;http://php.net/manual/en/functions.anonymous.php&quot;&gt;anonymous function&lt;/a&gt; as the callback. If you want to use a method or static method, see the &lt;a href=&quot;http://php.net/manual/en/language.types.callable.php&quot;&gt;other ways of specifying a callback in PHP&lt;/a&gt;.</source>
          <target state="translated">Часто вы захотите использовать &lt;a href=&quot;http://php.net/manual/en/functions.anonymous.php&quot;&gt;анонимную функцию&lt;/a&gt; в качестве обратного вызова. Если вы хотите использовать метод или статический метод, посмотрите &lt;a href=&quot;http://php.net/manual/en/language.types.callable.php&quot;&gt;другие способы указания обратного вызова в PHP&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c35d83d789a540e6897531d14c6254373ce83781" translate="yes" xml:space="preserve">
          <source>Other Types of Sort</source>
          <target state="translated">Другие типы Сорт</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="b0267e700c88a37263a43b92d7a395bce05551fd" translate="yes" xml:space="preserve">
          <source>PHP 7 introduced the &lt;a href=&quot;https://stackoverflow.com/a/31298778/476&quot;&gt;spaceship operator&lt;/a&gt;, which unifies and simplifies equal/smaller/larger than comparisons across types:</source>
          <target state="translated">В PHP 7 появился &lt;a href=&quot;https://stackoverflow.com/a/31298778/476&quot;&gt;оператор космического корабля&lt;/a&gt; , который объединяет и упрощает равные / меньшие / большие, чем сравнения по типам:</target>
        </trans-unit>
        <trans-unit id="3f2d32e9b9fcccd95d471d74d44aa03d86740971" translate="yes" xml:space="preserve">
          <source>Permutation sort</source>
          <target state="translated">сорт пермутации</target>
        </trans-unit>
        <trans-unit id="c173eb402711aa25b0f47a3eba4637bd8ca240a3" translate="yes" xml:space="preserve">
          <source>Permutation sort, which proceeds by generating the possible permutations of the input array/list until discovering the sorted one.</source>
          <target state="translated">Сортировка пермутаций,которая происходит путем генерации возможных перестановок входного массива до тех пор,пока не будет найдена отсортированная.</target>
        </trans-unit>
        <trans-unit id="d44cb3d8ba3820f721444056407b199d364b0108" translate="yes" xml:space="preserve">
          <source>Quicksort</source>
          <target state="translated">Quicksort</target>
        </trans-unit>
        <trans-unit id="4e2f2ccda2d141cdb71813f9ece456d6058909d2" translate="yes" xml:space="preserve">
          <source>Quicksort, or partition-exchange sort, is a sorting algorithm developed by Tony Hoare that, on average, makes O(n log n) comparisons to sort n items. In the worst case, it makes O(n2) comparisons, though this behavior is rare.</source>
          <target state="translated">Quicksort,или сортировка по обмену разделами,-это алгоритм сортировки,разработанный Тони Хоаром,который в среднем сравнивает O(n log n)для сортировки n элементов.В худшем случае он производит O(n2)сравнение,хотя такое поведение встречается редко.</target>
        </trans-unit>
        <trans-unit id="bff4909dacd843638a143efdc8a9f26a73d4d021" translate="yes" xml:space="preserve">
          <source>Radix sort</source>
          <target state="translated">Radix выходит</target>
        </trans-unit>
        <trans-unit id="c7ffa0f7b8c42b69643661d77faa8591b90c537c" translate="yes" xml:space="preserve">
          <source>Sample data for my demonstrations:</source>
          <target state="translated">Образцы данных для моих демонстраций:</target>
        </trans-unit>
        <trans-unit id="e3cdf383e3767cd3d19172cf65aee5ac75789a6a" translate="yes" xml:space="preserve">
          <source>Selection sort</source>
          <target state="translated">Сортировка по выбору</target>
        </trans-unit>
        <trans-unit id="5b80873e838a3de2e0b8501112112c5e85d97341" translate="yes" xml:space="preserve">
          <source>Shellsort</source>
          <target state="translated">Shellsort</target>
        </trans-unit>
        <trans-unit id="7f8c6841ac8c565f0f59479a33bf5e67aeff1fd7" translate="yes" xml:space="preserve">
          <source>Shellsort, also known as Shell sort or Shell's method, is an in-place comparison sort. It generalizes an exchanging sort, such as insertion or bubble sort, by starting the comparison and exchange of elements with elements that are far apart before finishing with neighboring elements.</source>
          <target state="translated">Shellsort,также известный как сорт Shell или метод Shell's,является внутренним сортом сравнения.Он обобщает обменный сорт,например,сорт вставки или сорт пузырьков,начиная сравнение и обмен элементов с элементами,которые находятся на большом расстоянии друг от друга,прежде чем закончить соседними элементами.</target>
        </trans-unit>
        <trans-unit id="c72db2b9bd5162f4ee3192fa5a58bf805b06a3e0" translate="yes" xml:space="preserve">
          <source>So ,Now I want to sort this array in ascending order according their value.'asort()' method can be used for that.</source>
          <target state="translated">Итак,теперь я хочу отсортировать этот массив по возрастанию в соответствии с их значением.Для этого можно использовать метод asort()'.</target>
        </trans-unit>
        <trans-unit id="6deb74510a05647499e115f644b036d0c78033e2" translate="yes" xml:space="preserve">
          <source>Sorting by multiple fields</source>
          <target state="translated">Сортировка по нескольким полям</target>
        </trans-unit>
        <trans-unit id="0abc6fe29f723ac5ab847735d61a3e848b86510b" translate="yes" xml:space="preserve">
          <source>Sorting into a manual, static order</source>
          <target state="translated">Сортировка по ручному,статическому порядку</target>
        </trans-unit>
        <trans-unit id="6ae7466fd879afa82cce3b8c69fc1d7a38b8457b" translate="yes" xml:space="preserve">
          <source>Sorting logic:</source>
          <target state="translated">Логика сортировки:</target>
        </trans-unit>
        <trans-unit id="5828996ad33961b80dd02a99ba31c274af774b8c" translate="yes" xml:space="preserve">
          <source>Sorting one array based on another</source>
          <target state="translated">Сортировка одного массива на основе другого</target>
        </trans-unit>
        <trans-unit id="dc76f608fa88e8b8d88d502255d84d79946a6d0f" translate="yes" xml:space="preserve">
          <source>Sorting with SPL</source>
          <target state="translated">Сортировка с SPL</target>
        </trans-unit>
        <trans-unit id="33e63fd49e04368d0c74d40d9016c5e47c3d84bc" translate="yes" xml:space="preserve">
          <source>Spaceship operator</source>
          <target state="translated">Оператор космического корабля</target>
        </trans-unit>
        <trans-unit id="b18198f5f9f57564c4ac888b338ec7bdf4bd8815" translate="yes" xml:space="preserve">
          <source>Stable sort</source>
          <target state="translated">Стабильный сорт</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="be8b35a38597692f15ee011684c538a2449fccf4" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;strong&gt;The PoWEr oF MATH&lt;/strong&gt; this returns a value &amp;lt; 0, 0 or &amp;gt; 0 depending on whether &lt;code&gt;$a&lt;/code&gt; is lower than, equal to or larger than &lt;code&gt;$b&lt;/code&gt;.</source>
          <target state="translated">Благодаря &lt;strong&gt;PoWEr oF MATH&lt;/strong&gt; это возвращает значение &amp;lt;0, 0 или&amp;gt; 0 в зависимости от того, &lt;code&gt;$a&lt;/code&gt; меньше, равно или больше, чем &lt;code&gt;$b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b26e687c8060faed4b3283538901d99924da0c" translate="yes" xml:space="preserve">
          <source>That's how simple sorting a complex multi-dimensional array can be. Again, just think in terms of &lt;em&gt;teaching PHP how to tell which of two items is &quot;greater&quot;&lt;/em&gt;; let PHP do the actual sorting.</source>
          <target state="translated">Вот как может быть проста сортировка сложного многомерного массива. Опять же, просто подумайте с точки зрения &lt;em&gt;обучения PHP, как определить, какой из двух пунктов является &amp;laquo;большим&amp;raquo;&lt;/em&gt; ; позвольте PHP сделать фактическую сортировку.</target>
        </trans-unit>
        <trans-unit id="12c288ba8b61fad8ca7f16d60422336faa5fe119" translate="yes" xml:space="preserve">
          <source>The SplMaxHeap class provides the main functionalities of a heap, keeping the maximum on the top.</source>
          <target state="translated">Класс SplMaxHeap обеспечивает основные функциональные возможности кучи,сохраняя максимум на вершине.</target>
        </trans-unit>
        <trans-unit id="054693f687dcbdc3235c558c02357cafa6badd3e" translate="yes" xml:space="preserve">
          <source>The SplMinHeap class provides the main functionalities of a heap, keeping the minimum on the top.</source>
          <target state="translated">Класс SplMinHeap обеспечивает основные функциональные возможности кучи,сохраняя минимум на вершине.</target>
        </trans-unit>
        <trans-unit id="d4d87b5e9fc3737c7e81b15ed8aa38249fbcf373" translate="yes" xml:space="preserve">
          <source>The difference between those is merely whether key-value associations are kept (the &quot;&lt;code&gt;a&lt;/code&gt;&quot; functions), whether it sorts low-to-high or reverse (&quot;&lt;code&gt;r&lt;/code&gt;&quot;), whether it sorts values or keys (&quot;&lt;code&gt;k&lt;/code&gt;&quot;) and how it compares values (&quot;&lt;code&gt;nat&lt;/code&gt;&quot; vs. normal). See &lt;a href=&quot;http://php.net/manual/en/array.sorting.php&quot;&gt;http://php.net/manual/en/array.sorting.php&lt;/a&gt; for an overview and links to further details.</source>
          <target state="translated">Разница между ними заключается лишь в том, сохраняются ли ассоциации ключ-значение (функции &amp;laquo; &lt;code&gt;a&lt;/code&gt; &amp;raquo;), сортирует ли он низкий-высокий или обратный (&amp;laquo; &lt;code&gt;r&lt;/code&gt; &amp;raquo;), сортирует ли он значения или ключи (&amp;laquo; &lt;code&gt;k&lt;/code&gt; &amp;raquo;) и как он сравнивает значения (&amp;laquo; &lt;code&gt;nat&lt;/code&gt; &amp;raquo; против нормального). Смотрите &lt;a href=&quot;http://php.net/manual/en/array.sorting.php&quot;&gt;http://php.net/manual/en/array.sorting.php&lt;/a&gt; для обзора и ссылки на дополнительную информацию.</target>
        </trans-unit>
        <trans-unit id="725e8396ee12340d6238f40e07cd4a73b61075ce" translate="yes" xml:space="preserve">
          <source>The elements from both sides of the operator will be traversed left to right, one at a time, and returning the evaluation as soon as a non-tie is encountered or when the elements have all been compared.</source>
          <target state="translated">Элементы с обеих сторон оператора будут перемещаться слева направо,по одному,и возвращать оценку,как только будет обнаружено отсутствие связи или когда все элементы будут сравниваться.</target>
        </trans-unit>
        <trans-unit id="0b2f20e21a299cb112503b754502d1f181c00b06" translate="yes" xml:space="preserve">
          <source>The expected result here would be:</source>
          <target state="translated">Ожидаемый результат здесь будет:</target>
        </trans-unit>
        <trans-unit id="953adeb96e5f44095ec62a8ec7fb264aa7f1685a" translate="yes" xml:space="preserve">
          <source>The final result:</source>
          <target state="translated">Окончательный результат:</target>
        </trans-unit>
        <trans-unit id="c0657eaaa8eae57d4b0859d34d3f627d4a16f08b" translate="yes" xml:space="preserve">
          <source>The keen observer may have noticed that the array sorting algorithm (QuickSort) didn't produce a stable outcome and that the original order between words of the same first letter wasn't preserved. This case is trivial and we should have compared the whole string, but let's assume your use-case is more complicated, such as two consecutive sorts on different fields that shouldn't cancel out each other's work.</source>
          <target state="translated">Увлеченный наблюдатель,возможно,заметил,что алгоритм сортировки массивов (QuickSort)не дал стабильного результата и что исходный порядок между словами одной и той же первой буквы не сохранился.Этот случай тривиален,и мы должны были сравнить всю строку,но предположим,что ваш вариант использования более сложный,например,два последовательных сортировки по разным полям,которые не должны отменять работу друг друга.</target>
        </trans-unit>
        <trans-unit id="40557e3db4165270942853579e99a47f46705025" translate="yes" xml:space="preserve">
          <source>The outcome is this:</source>
          <target state="translated">Результат такой:</target>
        </trans-unit>
        <trans-unit id="8ab3b917f6b1d0b8f5cf7e5e7047d13f590ba823" translate="yes" xml:space="preserve">
          <source>The simplest is to use usort function to sort array without any looping :
Below is an example :</source>
          <target state="translated">Самое простое-это использовать функцию usort для сортировки массива без зацикливания:Ниже приведен пример :</target>
        </trans-unit>
        <trans-unit id="b2b8e2cb335886e04d4d752fe8fe7627299eacc6" translate="yes" xml:space="preserve">
          <source>There are several ways to sort an array.I will mention some methods for doing that task.fist of all , I will give an integer array which is called as '$numbers'.</source>
          <target state="translated">Есть несколько способов сортировки массива,я упомяну некоторые методы для выполнения этой задачи.первым делом,я дам целочисленный массив,который называется '$numbers'.</target>
        </trans-unit>
        <trans-unit id="f08a86bb02cd3d4e2099033080e2835aae6d74dd" translate="yes" xml:space="preserve">
          <source>These are the some methods for sorting an array in ascending or descending order in php.I hope to you could get an idea.Thank you!</source>
          <target state="translated">Вот некоторые методы сортировки массива в порядке возрастания или убывания в php.я надеюсь,что у вас есть идея.Спасибо!</target>
        </trans-unit>
        <trans-unit id="8c2be70445cb54d01611838358190c3a777e3184" translate="yes" xml:space="preserve">
          <source>This is the normal way to creating an array. Suppose that , I want to sort that array in ascending order.For that, 'sort()' method can be used.</source>
          <target state="translated">Это обычный способ создания массива.Предположим,что я хочу отсортировать этот массив в порядке возрастания,для этого можно использовать метод 'sort()'.</target>
        </trans-unit>
        <trans-unit id="dde20aef894f0fb7fd0addad9c8e2eca69acf984" translate="yes" xml:space="preserve">
          <source>This makes great strides in reducing code bloat and improving readability.</source>
          <target state="translated">Это делает большие успехи в уменьшении разбухания кода и улучшении читабельности.</target>
        </trans-unit>
        <trans-unit id="8ae5faa04b7f0b4ab713cf58213e707e0e5433a0" translate="yes" xml:space="preserve">
          <source>This page is very comprehensive, but I want to add a bit more about the awesome utility of the spaceship operator (three way comparison operator) -- a beautiful child of PHP7+.</source>
          <target state="translated">Эта страница очень полная,но я хочу добавить немного больше об удивительной утилите оператора spacehip (трехходовой оператор сравнения)--прекрасном детище PHP7+.</target>
        </trans-unit>
        <trans-unit id="d2aa926b92b550aa69143e32375772daf3d60b1a" translate="yes" xml:space="preserve">
          <source>This question is intended as a reference for questions about sorting arrays in PHP. It is easy to think that your particular case is unique and worthy of a new question, but most are actually minor variations of one of the solutions on this page.</source>
          <target state="translated">Этот вопрос предназначен в качестве справочной информации для вопросов о сортировке массивов в PHP.Легко подумать,что ваш конкретный случай уникален и достоин нового вопроса,но на самом деле большинство из них являются незначительными вариациями одного из решений на этой странице.</target>
        </trans-unit>
        <trans-unit id="f80d90d89f72bcf9b275cd7306e8e7131a2b8842" translate="yes" xml:space="preserve">
          <source>This syntax allows you to sort values, functional outcomes, deep-nested data, and sorting direction in a elegant fashion.  This is definitely worth putting in your php toolbelt ...for cases when you are processing non-database data -- because of course SQL would be a much more sensible technique.</source>
          <target state="translated">Этот синтаксис позволяет элегантно сортировать значения,функциональные результаты,глубоко вложенные данные и направление сортировки.Это определенно стоит поместить в ваш пояс php для случаев,когда вы обрабатываете небазовые данные-потому что,конечно,SQL был бы гораздо более разумной техникой.</target>
        </trans-unit>
        <trans-unit id="71b460d3c37c7ce78ce6b0d6df859d807f5083db" translate="yes" xml:space="preserve">
          <source>This transforms the array into this:</source>
          <target state="translated">Это превращает массив в это:</target>
        </trans-unit>
        <trans-unit id="0402d6569e261eb376cd0e0480149c110dfe7e44" translate="yes" xml:space="preserve">
          <source>This will sort in asending order :</source>
          <target state="translated">Это будет отсортировано в порядке убывания :</target>
        </trans-unit>
        <trans-unit id="973b5f203a597863c3416acc2681e81c4c38e982" translate="yes" xml:space="preserve">
          <source>This will sort in desending order :</source>
          <target state="translated">Это будет отсортировано в убывающем порядке:</target>
        </trans-unit>
        <trans-unit id="ec3712d52e6639c57acc511c0d5bd37714eb0283" translate="yes" xml:space="preserve">
          <source>To do that, you need to create a &lt;em&gt;comparison function&lt;/em&gt;. That function takes two elements and must return &lt;code&gt;0&lt;/code&gt; if these elements are considered equal, a value lower than &lt;code&gt;0&lt;/code&gt; if the first value is lower and a value higher than &lt;code&gt;0&lt;/code&gt; if the first value is higher. That's all that's needed:</source>
          <target state="translated">Для этого вам нужно создать функцию &lt;em&gt;сравнения&lt;/em&gt; . Эта функция принимает два элемента и должна возвращать &lt;code&gt;0&lt;/code&gt; , если эти элементы считаются равными, значение ниже &lt;code&gt;0&lt;/code&gt; , если первое значение ниже, и значение выше &lt;code&gt;0&lt;/code&gt; , если первое значение выше. Вот и все, что нужно:</target>
        </trans-unit>
        <trans-unit id="9ff58a12c33c24d9444fe3d80dd760a502773162" translate="yes" xml:space="preserve">
          <source>To get used to this idea, try this:</source>
          <target state="translated">Чтобы привыкнуть к этой идее,попробуй:</target>
        </trans-unit>
        <trans-unit id="4d7fc375f7c2d29c511ad47f3b0427f8fe029dc7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;array_multisort&lt;/code&gt; to get there:</source>
          <target state="translated">Используйте &lt;code&gt;array_multisort&lt;/code&gt; , чтобы попасть туда:</target>
        </trans-unit>
        <trans-unit id="cc8255a05e0c9e77bc8b8f60a36e1a52dda63dbb" translate="yes" xml:space="preserve">
          <source>Using the spaceship operator to implement multiple sort conditions</source>
          <target state="translated">Использование оператора космического корабля для реализации нескольких условий сортировки</target>
        </trans-unit>
        <trans-unit id="01ba4a7aa0b09c32b597708fbf029367d4fc4548" translate="yes" xml:space="preserve">
          <source>Voila! Your pristine comparison code is back.</source>
          <target state="translated">Вуаля! Ваш первозданный сравнительный код вернулся.</target>
        </trans-unit>
        <trans-unit id="4081ff83370ff929f9d82da1aa8c8026b891606f" translate="yes" xml:space="preserve">
          <source>Well most basic methods are already covered by &lt;a href=&quot;https://stackoverflow.com/a/17364128&quot;&gt;deceze&lt;/a&gt; I would try to look at other types of sort</source>
          <target state="translated">Ну, большинство базовых методов уже охвачены &lt;a href=&quot;https://stackoverflow.com/a/17364128&quot;&gt;deceze,&lt;/a&gt; я бы попробовал взглянуть на другие типы сортировки.</target>
        </trans-unit>
        <trans-unit id="3a5e3a6448c0eea877c84b7a66986dbba7567544" translate="yes" xml:space="preserve">
          <source>When writing your custom sort (&lt;code&gt;usort()&lt;/code&gt;/&lt;code&gt;uasort()&lt;/code&gt;/&lt;code&gt;uksort()&lt;/code&gt;) function to process a multiple conditions, you only need to write balanced arrays on either side of the operator and return the outcome. &lt;strong&gt;No more nested condition blocks or multiple returns.&lt;/strong&gt;</source>
          <target state="translated">При написании пользовательской функции сортировки ( &lt;code&gt;usort()&lt;/code&gt; / &lt;code&gt;uasort()&lt;/code&gt; / &lt;code&gt;uksort()&lt;/code&gt; ) для обработки нескольких условий вам нужно только написать сбалансированные массивы по обе стороны от оператора и вернуть результат. &lt;strong&gt;Нет больше вложенных блоков условий или множественных возвратов.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6ab42d0070bc672b70cc0b562ef5caca83182c66" translate="yes" xml:space="preserve">
          <source>You can do anything you need inside a comparison function, including calling functions:</source>
          <target state="translated">Внутри функции сравнения можно делать все,что угодно,в том числе вызывать функции:</target>
        </trans-unit>
        <trans-unit id="c2598758b7b8e523ec8fa99a6fb1a68f431a6a36" translate="yes" xml:space="preserve">
          <source>You can see all these examples &lt;a href=&quot;https://github.com/ihor/Nspl/blob/master/examples/a_sorted.php&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Вы можете увидеть все эти примеры &lt;a href=&quot;https://github.com/ihor/Nspl/blob/master/examples/a_sorted.php&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c73513599241b3ce7f8138e76771704dbf6c490" translate="yes" xml:space="preserve">
          <source>You can see printed number array is sorted. If you want to that number array to be sort is descending order, 'rsort()' method can be use for that task.</source>
          <target state="translated">Вы можете видеть,что массив распечатанных номеров отсортирован.Если вы хотите,чтобы массив номеров для сортировки располагался в порядке убывания,то для этой задачи можно использовать метод 'rsort()'.</target>
        </trans-unit>
        <trans-unit id="f9fa873c922dd4519bb3310f2049638099570603" translate="yes" xml:space="preserve">
          <source>You had to rewrite your comparison function to work with the transformed array elements; you may not want to edit your delicate comparison functions, so here's a wrapper for the comparison function:</source>
          <target state="translated">Вам пришлось переписать вашу функцию сравнения для работы с преобразованными элементами массива;возможно,вы не захотите редактировать ваши хрупкие функции сравнения,поэтому вот обёртка для функции сравнения:</target>
        </trans-unit>
        <trans-unit id="f693970746f4c98af758145696b3f03075e624fd" translate="yes" xml:space="preserve">
          <source>You then use one of these functions:</source>
          <target state="translated">Затем вы используете одну из этих функций:</target>
        </trans-unit>
        <trans-unit id="d6dc10b51f4ac19dc7e1c1bf1c90cd2514ff5fda" translate="yes" xml:space="preserve">
          <source>boolean ASC</source>
          <target state="translated">логический ASC</target>
        </trans-unit>
        <trans-unit id="011f88a6deac532999df9a4bf406f2452a5e4ec2" translate="yes" xml:space="preserve">
          <source>boolean DESC (false = 0, true = 1, so trues before falses)</source>
          <target state="translated">булева DESC (false=0,true=1,так что верно до фальсификаций)</target>
        </trans-unit>
        <trans-unit id="51aa2637eade754937f7d4b54457cc38ed3ebe0d" translate="yes" xml:space="preserve">
          <source>consider the output..</source>
          <target state="translated">Рассмотрим выход...</target>
        </trans-unit>
        <trans-unit id="435226da679aca3541980cba99db2b6a022eb075" translate="yes" xml:space="preserve">
          <source>float ASC</source>
          <target state="translated">плавучая АСК</target>
        </trans-unit>
        <trans-unit id="2d71871d1b3a78e77346189fe7602ee55e8ea317" translate="yes" xml:space="preserve">
          <source>i.e., in order to sort first by a, then b, then c, the correct clause would be</source>
          <target state="translated">т.е.для того,чтобы отсортировать сначала по a,затем b,затем c,правильным было бы следующее положение</target>
        </trans-unit>
        <trans-unit id="b13b3070cef0cf3ace0f7f9a184ef548be1c6c51" translate="yes" xml:space="preserve">
          <source>iterability of mixed DESC</source>
          <target state="translated">итерабельность смешанного DESC</target>
        </trans-unit>
        <trans-unit id="acb5e075da5022ac6ab70076026e7f717ee2621a" translate="yes" xml:space="preserve">
          <source>mixed ASC</source>
          <target state="translated">смешанный ASC</target>
        </trans-unit>
        <trans-unit id="641c176e662a04a9783622e92508da3d59203cd6" translate="yes" xml:space="preserve">
          <source>natString ASC</source>
          <target state="translated">natString ASC</target>
        </trans-unit>
        <trans-unit id="92be7e45d7a0699bc3a9c9723e9cb645e47c33fd" translate="yes" xml:space="preserve">
          <source>natString length ASC</source>
          <target state="translated">длина натСтринг ASC</target>
        </trans-unit>
        <trans-unit id="d4a4c6438367ffdd711c2e9f3c7389c021225aed" translate="yes" xml:space="preserve">
          <source>object ASC</source>
          <target state="translated">объект ASC</target>
        </trans-unit>
        <trans-unit id="678cf1c73e8c23cc8b56f38065ff425f1804790c" translate="yes" xml:space="preserve">
          <source>property count of object ASC</source>
          <target state="translated">подсчёт имущества объекта ASC</target>
        </trans-unit>
        <trans-unit id="2c81b69885c711d3fc704aa7da591bfb0542dc5e" translate="yes" xml:space="preserve">
          <source>to produce</source>
          <target state="translated">производить</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
