<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/17364127">
    <body>
      <group id="17364127">
        <trans-unit id="64c134d03b9bef7a1b2c4b1cc5a323435009edc5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;The Schwartzian transform&lt;/a&gt;, also referred to as the decorate-sort-undecorate idiom, effects a stable sort with an inherently unstable sorting algorithm.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian变换&lt;/a&gt; （也称为decorate-sort-unecorate惯用语）通过固有的不稳定排序算法实现稳定的排序。</target>
        </trans-unit>
        <trans-unit id="ec0b9d91e8865701f4b5b4d7b036cf124aafa4d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sort&lt;/code&gt; sorts by reference and does not return anything useful!</source>
          <target state="translated">&lt;code&gt;sort&lt;/code&gt; 按引用排序 ，不返回任何有用的信息！</target>
        </trans-unit>
        <trans-unit id="5acc8ee181e8da0ea9d9be45f707be213fefa4db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strcmp&lt;/code&gt; does exactly what's expected of &lt;code&gt;cmp&lt;/code&gt; here, it returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strcmp&lt;/code&gt; 确实执行了 &lt;code&gt;cmp&lt;/code&gt; 的预期操作，它返回 &lt;code&gt;-1&lt;/code&gt; ,0或 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6250fe13bd2141652473bccea20d7a3edc21534a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;usort&lt;/code&gt; will take two items from the array and call your &lt;code&gt;cmp&lt;/code&gt; function with them. So &lt;code&gt;cmp()&lt;/code&gt; will be called with &lt;code&gt;$a&lt;/code&gt; as &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; as another &lt;code&gt;array('foo' =&amp;gt; ..., 'baz' =&amp;gt; ...)&lt;/code&gt;. The function then returns to &lt;code&gt;usort&lt;/code&gt; which of the values was larger or whether they were equal. &lt;code&gt;usort&lt;/code&gt; repeats this process passing different values for &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; until the array is sorted. The &lt;code&gt;cmp&lt;/code&gt; function will be called many times, &lt;em&gt;at least&lt;/em&gt; as many times as there are values in &lt;code&gt;$array&lt;/code&gt;, with different combinations of values for &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; every time.</source>
          <target state="translated">&lt;code&gt;usort&lt;/code&gt; 将从数组中获取两项，并使用它们调用您的 &lt;code&gt;cmp&lt;/code&gt; 函数。 因此，将使用 &lt;code&gt;$a&lt;/code&gt; 作为 &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 作为另一个 &lt;code&gt;array('foo' =&amp;gt; ..., 'baz' =&amp;gt; ...)&lt;/code&gt; 。 然后，函数返回 &lt;code&gt;usort&lt;/code&gt; 中哪个值较大或它们是否相等。 &lt;code&gt;usort&lt;/code&gt; 重复此过程，为 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 传递不同的值，直到对数组进行排序为止。 &lt;code&gt;cmp&lt;/code&gt; 函数将被调用多次， &lt;em&gt;至少&lt;/em&gt;与 &lt;code&gt;$array&lt;/code&gt; 中的值调用次数相同，并且每次都会使用 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 值的不同组合。</target>
        </trans-unit>
        <trans-unit id="91a3fac04b5043f66c638448a2ec4a9d40256c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Basic sorting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;基本分类&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae5cef9d3d93e404cd7eaf3cebb98381606bb57f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multidimensional sort by key value&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;按键值多维排序&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ad87ca1f0b6cc5122ffd4adf3852faabfb4606d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting array of objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;排序对象数组&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d54d56ae70bc0bd717365af26342ff7f0609c18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting by function result&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;按功能结果排序&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="442b02603b1b00edd73e6ecb47de346ad50a30a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting multidimensional array&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;排序多维数组&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7427550bbfea3e00b1744c697847bdfdc2887d54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorting with a comparison function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用比较功能排序&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e21f70118d196d40f3aca759ed5d74ff5bb9753d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Test case:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;测试用例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5043ab6424dd981758b046a437b0a3d11f0fac39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Schwartzian transform&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;施瓦兹变换&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c570d11b81351591dc82387e9c2d0e5c99eed9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The sort wasn't stable!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;排序不稳定！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ae6f075d81fe91ec85a2cda94e88595f84602fb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What about reuse?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;那么重用呢？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6153e439d266c625b80b0798a43006194091e98" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;* developed by me, see readme for more details and comparison with other LINQ ports&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;*由我开发，请参阅自述文件以了解更多详细信息并与其他LINQ端口进行比较&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f9df68a046eeab006969fe2d05597fc43aedc367" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;If you have more common cases, feel free to edit this answer.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;如果您遇到更常见的情况，请随时编辑此答案。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="d0a564f5b4042652c7506a0e980220e88741b88a" translate="yes" xml:space="preserve">
          <source>A shortcut for the first string comparison version:</source>
          <target state="translated">第一条字符串比较版的捷径。</target>
        </trans-unit>
        <trans-unit id="1d43617dc0b5a021c31bb1e8464713303a5a922c" translate="yes" xml:space="preserve">
          <source>Afterwards, we undecorate:</source>
          <target state="translated">之后,我们解开装饰。</target>
        </trans-unit>
        <trans-unit id="7931945cc2816f5241e83f79777cd3649fe7a700" translate="yes" xml:space="preserve">
          <source>Again, they only differ in whether they keep key-value associations and sort by values or keys. Read their documentation for details.</source>
          <target state="translated">同样,它们只是在是否保留键-值关联和按值或键排序上有区别。请阅读它们的文档以了解详情。</target>
        </trans-unit>
        <trans-unit id="a70cd3b3cb5f9b9f666113d7269e0526e688db81" translate="yes" xml:space="preserve">
          <source>All you did was define a custom way to compare two items, that's all you need. That works with all sorts of values.</source>
          <target state="translated">你所做的只是定义一个自定义的方法来比较两个项目,这就是你所需要的。这对各种值都适用。</target>
        </trans-unit>
        <trans-unit id="7e5e4131293f07cab8ee6d2fcb5a44fee49f9403" translate="yes" xml:space="preserve">
          <source>Also for all of the above, to switch between ascending and descending order simply swap the &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; arguments around. E.g.:</source>
          <target state="translated">同样对于以上所有内容，要在升序和降序之间切换，只需在 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 参数之间进行交换。 例如：</target>
        </trans-unit>
        <trans-unit id="b9601f704b51bebf86466d306bf841c6e4c693eb" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;https://stackoverflow.com/a/22812695/476&quot;&gt;this very neat shorthand version&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/22829326/476&quot;&gt;how to create such a comparison function dynamically for an arbitrary number of keys&lt;/a&gt;.</source>
          <target state="translated">另请参阅&lt;a href=&quot;https://stackoverflow.com/a/22812695/476&quot;&gt;此非常简洁的速记版本，&lt;/a&gt;以及&lt;a href=&quot;https://stackoverflow.com/a/22829326/476&quot;&gt;如何为任意数量的键动态创建这样的比较函数&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="8716dd3e8af6710d5fdaa991141a80734a184f4a" translate="yes" xml:space="preserve">
          <source>And now you want to sort on the first letter only:</source>
          <target state="translated">而现在你只想在第一个字母上分类。</target>
        </trans-unit>
        <trans-unit id="ece93d1b3c1ff5290fd30d672442002e929ec257" translate="yes" xml:space="preserve">
          <source>And then there's the peculiar &lt;a href=&quot;http://php.net/array_multisort&quot;&gt;&lt;code&gt;array_multisort&lt;/code&gt;&lt;/a&gt;, which lets you sort one array based on another:</source>
          <target state="translated">然后是奇特的&lt;a href=&quot;http://php.net/array_multisort&quot;&gt; &lt;code&gt;array_multisort&lt;/code&gt; &lt;/a&gt; ，它使您可以根据另一个数组对一个数组进行排序：</target>
        </trans-unit>
        <trans-unit id="a7272763986e00b04cd352962090c6aeb7a8abd7" translate="yes" xml:space="preserve">
          <source>Applicable sort functions:</source>
          <target state="translated">适用的分类功能。</target>
        </trans-unit>
        <trans-unit id="1f5fbafcc6b2be3e4003214daaf54304ae710e57" translate="yes" xml:space="preserve">
          <source>As of PHP 5.3 with closures it is also possible to use a closure to determine the order of your sort.</source>
          <target state="translated">从PHP5.3版本开始,使用闭包也可以用闭包来确定你的排序。</target>
        </trans-unit>
        <trans-unit id="a26da193435c50e2c23ef2300be7cff7d23086bf" translate="yes" xml:space="preserve">
          <source>As of PHP 5.5.0 you can use &lt;code&gt;array_column&lt;/code&gt; to extract a column from a multi dimensional array and sort the array on that column:</source>
          <target state="translated">从PHP 5.5.0开始，您可以使用 &lt;code&gt;array_column&lt;/code&gt; 从多维数组中提取列并对该列进行排序：</target>
        </trans-unit>
        <trans-unit id="3aa88f9496d79e65e1268bd5cd94428456942d7d" translate="yes" xml:space="preserve">
          <source>As of PHP 7.0.0 you can also extract properties from an array of objects.</source>
          <target state="translated">从PHP 7.0.0.0开始,你也可以从对象的数组中提取属性。</target>
        </trans-unit>
        <trans-unit id="3a6c74b1fb6f77c435e7654b0a2bb753b7036c67" translate="yes" xml:space="preserve">
          <source>At your own discretion, from PHP7.4 you can use arrow syntax with these anonymous functions.  &lt;a href=&quot;https://3v4l.org/N5hs1&quot;&gt;Same script with arrow syntax&lt;/a&gt;.</source>
          <target state="translated">从PHP7.4起，您可以自行决定将箭头语法与这些匿名函数一起使用。 &lt;a href=&quot;https://3v4l.org/N5hs1&quot;&gt;带有箭头语法的相同脚本&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3481f742ff766b292ff10b811189b66a6a8a188" translate="yes" xml:space="preserve">
          <source>Basic one dimensional arrays</source>
          <target state="translated">基本的一维数组</target>
        </trans-unit>
        <trans-unit id="1c0f6078f43ed59ef9e69be5b2d9b8ba776052ee" translate="yes" xml:space="preserve">
          <source>Basic one-dimensional arrays; Incl. Multidimensional arrays, incl. arrays of objects; Incl. Sorting one array based on another</source>
          <target state="translated">基本的一维数组;包括多维数组,包括对象的数组;包括基于另一个数组的排序;包括基于另一个数组的排序</target>
        </trans-unit>
        <trans-unit id="7a9564635844dbb13c650e09e6dca78deee82d44" translate="yes" xml:space="preserve">
          <source>Bubble Sort</source>
          <target state="translated">泡沫分类</target>
        </trans-unit>
        <trans-unit id="0ee0df1fe84ba4f23bf4a4787e7f2ab939905d5b" translate="yes" xml:space="preserve">
          <source>Bubble sort, sometimes incorrectly referred to as sinking sort, is a simple sorting algorithm that works by repeatedly stepping through the list to be sorted, comparing each pair of adjacent items and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm gets its name from the way smaller elements &quot;bubble&quot; to the top of the list. Because it only uses comparisons to operate on elements, it is a comparison sort. Although the algorithm is simple, most of the other sorting algorithms are more efficient for large lists.</source>
          <target state="translated">泡泡排序,有时被错误地称为下沉式排序,是一种简单的排序算法,其工作原理是通过反复踏过要排序的列表,对相邻的每一对项进行比较,如果相邻项的顺序不对,则对其进行交换。反复通过列表,直到不需要交换,这表明列表已被排序。该算法的名字来自于较小的元素 &quot;泡 &quot;到列表顶部的方式。因为它只使用比较法对元素进行操作,所以它是一种比较排序。虽然该算法很简单,但其他大多数排序算法对于大的列表来说,效率更高。</target>
        </trans-unit>
        <trans-unit id="3f5228c2bb37ea03d02a48ced721ff6fce42582f" translate="yes" xml:space="preserve">
          <source>By the way, this works on any value, the values don't have to be complex arrays. If you have a custom comparison you want to do, you can do it on a simple array of numbers too.</source>
          <target state="translated">顺便说一下,这个方法可以在任何值上运行,值不一定是复杂的数组。如果你想做一个自定义的比较,你也可以在一个简单的数组上做。</target>
        </trans-unit>
        <trans-unit id="1f7b5e3a07e4aa10794b25b9eb1b333d19a93959" translate="yes" xml:space="preserve">
          <source>Comb sort</source>
          <target state="translated">梳子分类</target>
        </trans-unit>
        <trans-unit id="2a88d28be7a721a09c87fbc18b87669fb817bf11" translate="yes" xml:space="preserve">
          <source>Comb sort is a relatively simple sorting algorithm originally designed by Wlodzimierz Dobosiewicz in 1980. Later it was rediscovered by Stephen Lacey and Richard Box in 1991. Comb sort improves on bubble sort.</source>
          <target state="translated">梳子排序是一种相对简单的排序算法,最初是由Wlodzimierz Dobosiewicz在1980年设计的。后来,它在1991年被Stephen Lacey和Richard Box重新发现。梳子排序是在气泡排序的基础上进行了改进。</target>
        </trans-unit>
        <trans-unit id="646e0b865c714a7aff37ecc033eed142b2c958be" translate="yes" xml:space="preserve">
          <source>Comparisons can be further customized by passing a callback as a second argument, for example:</source>
          <target state="translated">例如,可以通过传递一个回调作为第二个参数来进一步定制比较。</target>
        </trans-unit>
        <trans-unit id="a1dbb3512ba2c2ef412c726afc917e9ed563da64" translate="yes" xml:space="preserve">
          <source>Custom numeric comparisons</source>
          <target state="translated">自定义数字比较</target>
        </trans-unit>
        <trans-unit id="2a8dd816d14251367ee45f28876e6654657e5dc0" translate="yes" xml:space="preserve">
          <source>Demonstrations (to avoid Stackoverflow page bloat, please see &lt;a href=&quot;https://3v4l.org/2OnVs&quot;&gt;the demo link&lt;/a&gt; for the outputs):</source>
          <target state="translated">演示（为避免Stackoverflow页面膨胀，请查看&lt;a href=&quot;https://3v4l.org/2OnVs&quot;&gt;演示链接&lt;/a&gt;以获取输出）：</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">用例:</target>
        </trans-unit>
        <trans-unit id="f9aad07cf38b9608c1a59cad08fd3d2a44488a85" translate="yes" xml:space="preserve">
          <source>First, you decorate each array element with another array comprising a primary key (the value) and a secondary key (its index or position):</source>
          <target state="translated">首先,你用另一个由一个主键(值)和一个次要键(其索引或位置)组成的数组元素来装饰每个数组元素。</target>
        </trans-unit>
        <trans-unit id="5d589d82437d73e6fc415fb3acaa13acf2e67fbc" translate="yes" xml:space="preserve">
          <source>For all the above, if you're using PHP 5.3 or higher (and you really should), use anonymous functions for shorter code and to avoid having another global function floating around:</source>
          <target state="translated">对于上述的所有问题,如果你使用的是 PHP 5.3 或更高版本(你真的应该这样做),请使用匿名函数来缩短代码,避免另一个全局函数浮动。</target>
        </trans-unit>
        <trans-unit id="8a7d9d374259b691daf285d948859be53a0d48f4" translate="yes" xml:space="preserve">
          <source>For example assuming $array is an array of objects that contain a month property.</source>
          <target state="translated">例如,假设$array是一个包含月份属性的对象数组。</target>
        </trans-unit>
        <trans-unit id="05c24c41a15f9e61769c627b1026c3bba5757c1a" translate="yes" xml:space="preserve">
          <source>For the practical answer using PHP's existing functions see 1., for the academic in-detail answer on sorting algorithms (which PHP's functions implement and which you &lt;em&gt;may&lt;/em&gt; need for really, really complex cases), see 2.</source>
          <target state="translated">有关使用PHP现有功能的实用答案，请参见1 .；有关排序算法的学术详细答案（PHP函数实现的，以及对于真正非常复杂的情况&lt;em&gt;可能&lt;/em&gt;需要的算法），请参见2。</target>
        </trans-unit>
        <trans-unit id="e7e0012b84ebe1c2d6c656f0728fbc05a8b629e0" translate="yes" xml:space="preserve">
          <source>For those familiar, this is equivalent to an SQL query with &lt;code&gt;ORDER BY foo, baz&lt;/code&gt;.</source>
          <target state="translated">对于熟悉的人，这等效于使用 &lt;code&gt;ORDER BY foo, baz&lt;/code&gt; 的SQL查询。</target>
        </trans-unit>
        <trans-unit id="10713d2d5d97f92b70ceeaa1abf16e664ba19d25" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Comb_sort&quot;&gt;the Wikipedia article on Comb sort:&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;http://en.wikipedia.org/wiki/Comb_sort&quot;&gt;维基百科上有关梳子的文章进行排序：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af6f8187ecb41c7a3a724fde62c2291f0de0c1e6" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Merge_sort&quot;&gt;the Wikipedia article on Merge sort:&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;http://en.wikipedia.org/wiki/Merge_sort&quot;&gt;维基百科上有关合并的文章进行排序：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f04a70693d1fc91e698f20afedbe860f081e3080" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Quicksort&quot;&gt;the Wikipedia article on Quicksort:&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;http://en.wikipedia.org/wiki/Quicksort&quot;&gt;Quicksort上的Wikipedia文章中：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="231cb574983359b4f2fc2d0eabb3cee56f18d159" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;the Wikipedia article on Radix sort:&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;http://en.wikipedia.org/wiki/Radix_sort&quot;&gt;Radix上的Wikipedia文章进行排序：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="335cc9004b8bc9590aeeaa5f2c309c7998fffbc1" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://en.wikipedia.org/wiki/Selection_sort&quot;&gt;the Wikipedia article on Selection sort:&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;http://en.wikipedia.org/wiki/Selection_sort&quot;&gt;Wikipedia上有关Selection的文章进行排序：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa8d636c21c2bb087af8f1c0516b00da6213c942" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort&quot;&gt;the Wikipedia article on Permutation sort:&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort&quot;&gt;维基百科有关排列的文章中进行排序：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="598734ed0e26e19f679e1e9533a6ea9144140fc1" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;Wikipedia article on Bubble Sort:&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;http://en.wikipedia.org/wiki/Bubble_sort&quot;&gt;维基百科上有关冒泡排序的文章：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6bc71c3a10f14e6b4ea14a4d51755b852912608" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;Wikipedia article on Insertion sort:&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;维基百科上有关插入的文章进行排序：&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75d4de6c59d942777ba337701271351a8ba9c7bc" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;http://en.wikipedia.org/wiki/Shellsort&quot;&gt;Wikipedia article on Shellsort:&lt;/a&gt;</source>
          <target state="translated">从&lt;a href=&quot;http://en.wikipedia.org/wiki/Shellsort&quot;&gt;Shellsort上&lt;/a&gt;的Wikipedia文章：</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="bc53affe93a56f0ac2327b800d76e9c76e766162" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;'$v-&amp;gt;count'&lt;/code&gt; is a shorthand for &lt;code&gt;function ($v) { return $v-&amp;gt;count; }&lt;/code&gt; (either can be used). These method chains return iterators, iterators can be transformed to arrays by adding &lt;code&gt;-&amp;gt;toArray()&lt;/code&gt; in the end if needed.</source>
          <target state="translated">在这里， &lt;code&gt;'$v-&amp;gt;count'&lt;/code&gt; 是 &lt;code&gt;function ($v) { return $v-&amp;gt;count; }&lt;/code&gt; 的简写。 {return $ v-&amp;gt; count; } （都可以使用）。 这些方法链返回迭代器，如果需要，可以通过在最后添加 &lt;code&gt;-&amp;gt;toArray()&lt;/code&gt; 将迭代器转换为数组。</target>
        </trans-unit>
        <trans-unit id="37d11951535b9e7819e17bbaa7fa8bb897720d41" translate="yes" xml:space="preserve">
          <source>How can I sort arrays and data in PHP</source>
          <target state="translated">如何在PHP中对数组和数据进行排序?</target>
        </trans-unit>
        <trans-unit id="59294f795e706794f92a5ab10d06ef7bfa38d205" translate="yes" xml:space="preserve">
          <source>How do I sort a &lt;em&gt;complex&lt;/em&gt; array in PHP?</source>
          <target state="translated">如何在PHP中对&lt;em&gt;复杂&lt;/em&gt;数组进行排序？</target>
        </trans-unit>
        <trans-unit id="70590ec3e9e5b76199d05655615734e1136c5ea3" translate="yes" xml:space="preserve">
          <source>How do I sort an array in PHP?</source>
          <target state="translated">如何在PHP中对数组进行排序?</target>
        </trans-unit>
        <trans-unit id="ffc8695c757dd16a946a9df92a2827b4afaac13c" translate="yes" xml:space="preserve">
          <source>How do I sort an array of objects in PHP?</source>
          <target state="translated">如何在PHP中对数组对象进行排序?</target>
        </trans-unit>
        <trans-unit id="0464412340e55485032482f66471f7409836566d" translate="yes" xml:space="preserve">
          <source>If someone wants a simpler solution to manipulate arrays, just use Laravel Collection package which has an implemented sortBy function that lets your sort by keys simply.</source>
          <target state="translated">如果有人想要一个更简单的解决方案来操作数组,只需使用Laravel Collection包,它有一个实现的sortBy函数,可以让你简单的按键排序。</target>
        </trans-unit>
        <trans-unit id="45bf070aff3c78274f4df26fea9e3429bf4ad3b8" translate="yes" xml:space="preserve">
          <source>If sorting descending order according their value,'arsort()' method can be used.
Suppose that you want to sort that array according their key value. In this , 'ksort()' method can be use.</source>
          <target state="translated">如果根据它们的值进行降序排序,可以使用'rsort()'方法。假设你想根据它们的键值对数组进行排序,那么可以使用'ksort()方法。这时,可以使用'ksort()'方法。</target>
        </trans-unit>
        <trans-unit id="925d0b321049ce7fba34b78caeb03d17d843dd9b" translate="yes" xml:space="preserve">
          <source>If you have an array of objects, it works the same way:</source>
          <target state="translated">如果你有一个数组对象,它的工作原理是一样的。</target>
        </trans-unit>
        <trans-unit id="8edadb37485a056a0ba896c032254cd92d020270" translate="yes" xml:space="preserve">
          <source>If you want to order by the key value, then you can do it one line, elegant and clear.  This will order by the price ascending.  Uses array_multisort and array_column.</source>
          <target state="translated">如果你想按键值排序,那么你可以单行进行排序,优雅而清晰。这将按价格升序排序。使用array_multisort和array_column。</target>
        </trans-unit>
        <trans-unit id="6d1b10feb5169be2830f541c80ba389d86eb0388" translate="yes" xml:space="preserve">
          <source>If you want to sort &lt;code&gt;$array&lt;/code&gt; by the key 'foo' of each entry, you need a &lt;em&gt;custom comparison function&lt;/em&gt;. The above &lt;code&gt;sort&lt;/code&gt; and related functions work on simple values that they know how to compare and sort. PHP does not simply &quot;know&quot; what to do with a &lt;em&gt;complex value&lt;/em&gt; like &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; though; so you need to tell it.</source>
          <target state="translated">如果要按每个条目的键'foo'对 &lt;code&gt;$array&lt;/code&gt; 进行排序，则需要一个&lt;em&gt;自定义比较函数&lt;/em&gt; 。 上面的 &lt;code&gt;sort&lt;/code&gt; 和相关函数在它们知道如何比较和排序的简单值上工作。 但是，PHP不会简单地&amp;ldquo;知道&amp;rdquo;如何处理 &lt;code&gt;array('foo' =&amp;gt; 'bar', 'baz' =&amp;gt; 42)&lt;/code&gt; 这样的&lt;em&gt;复杂值&lt;/em&gt; ； 所以你需要告诉它。</target>
        </trans-unit>
        <trans-unit id="9f6716ad7296fe732de50b7dcb13b798d77ac3c5" translate="yes" xml:space="preserve">
          <source>If you want to sort by the &lt;code&gt;baz&lt;/code&gt; key, which is numeric, all you need to do is:</source>
          <target state="translated">如果要按数字的 &lt;code&gt;baz&lt;/code&gt; 键排序，您需要做的是：</target>
        </trans-unit>
        <trans-unit id="2d2d91011e4cafdd99a83cde167a000a3b9c397d" translate="yes" xml:space="preserve">
          <source>If you want to sort elements into a &quot;manual order&quot; like &lt;em&gt;&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;&lt;/em&gt;:</source>
          <target state="translated">如果要将元素按&amp;ldquo;手动顺序&amp;rdquo;排序，例如&lt;em&gt;&amp;ldquo; foo&amp;rdquo;，&amp;ldquo; bar&amp;rdquo;，&amp;ldquo; baz&amp;rdquo;&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="52cc97be3f5343af977f4a56eb17cf35bc05914a" translate="yes" xml:space="preserve">
          <source>If you want to sort primarily by &lt;code&gt;foo&lt;/code&gt;, but if &lt;code&gt;foo&lt;/code&gt; is equal for two elements sort by &lt;code&gt;baz&lt;/code&gt;:</source>
          <target state="translated">如果要主要按 &lt;code&gt;foo&lt;/code&gt; 排序，但如果 &lt;code&gt;foo&lt;/code&gt; 对于两个元素相等， &lt;code&gt;baz&lt;/code&gt; 排序：</target>
        </trans-unit>
        <trans-unit id="af3d3d14d6ec1cb2fcbbe7eb203a079631fb777a" translate="yes" xml:space="preserve">
          <source>If your question is closed as a duplicate of this one, please ask for your question to be reopened only if you can explain why it differs markedly from all of the below.</source>
          <target state="translated">如果你的问题是作为这个问题的重复而被关闭的,请你的问题只有在你能解释为什么与下面所有的问题有明显区别的情况下,才可以要求重新打开。</target>
        </trans-unit>
        <trans-unit id="582175a51757c187ebe0a614be085ee5195af579" translate="yes" xml:space="preserve">
          <source>In .NET, LINQ is frequently used for sorting, which provides a much nicer syntax over comparison functions, especially when objects need to be sorted by multiple fields. There're several ports of LINQ to PHP, including &lt;a href=&quot;https://github.com/Athari/YaLinqo&quot;&gt;YaLinqo&lt;/a&gt; library*. With it, arrays can be sorted with a single line without writing complex comparison functions.</source>
          <target state="translated">在.NET中，LINQ通常用于排序，它提供了比比较函数更好的语法，尤其是当对象需要按多个字段排序时。 LINQ to PHP有多个端口，包括&lt;a href=&quot;https://github.com/Athari/YaLinqo&quot;&gt;YaLinqo&lt;/a&gt;库*。 有了它，数组可以用一行进行排序，而无需编写复杂的比较函数。</target>
        </trans-unit>
        <trans-unit id="f9ad5247ca5515c6c34dc526808eb4006a03baba" translate="yes" xml:space="preserve">
          <source>In computer science, a merge sort (also commonly spelled mergesort) is an O(n log n) comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the implementation preserves the input order of equal elements in the sorted output</source>
          <target state="translated">在计算机科学中,合并排序(通常也被称为mergesort)是一种基于O(n log n)的比较排序算法。大多数实现都会产生一个稳定的排序,这意味着该实现在排序后的输出中保留了相等元素的输入顺序</target>
        </trans-unit>
        <trans-unit id="fd773dac0cce1b252cddef9fa0e747f7ecda84a9" translate="yes" xml:space="preserve">
          <source>In computer science, radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value.</source>
          <target state="translated">在计算机科学中,radix sort是一种非比较性的整数排序算法,它是通过对具有整数的数据进行整数排序,通过对具有相同显著性位置和值的单个数字进行键的分组来对数据进行排序。</target>
        </trans-unit>
        <trans-unit id="2bebc9e7fd3f70ecd7761684ac68e27bf4d9b7a7" translate="yes" xml:space="preserve">
          <source>In computer science, selection sort is a sorting algorithm, specifically an in-place comparison sort. It has O(n2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited.</source>
          <target state="translated">在计算机科学中,选择排序是一种排序算法,具体来说是一种插入式比较排序。它具有O(n2)的时间复杂度,使得它在大的列表上效率低下,一般来说,它的性能比类似的插入式排序要差。选择排序以其简单性而著称,在某些情况下,特别是在辅助内存有限的情况下,它比更复杂的算法具有性能优势。</target>
        </trans-unit>
        <trans-unit id="a5bbc46810b022a4f9a43546060c63f13368908b" translate="yes" xml:space="preserve">
          <source>Insertion sort</source>
          <target state="translated">插入</target>
        </trans-unit>
        <trans-unit id="8a2aef5e40c2233bb33a10c7a43749ed88dbbd60" translate="yes" xml:space="preserve">
          <source>Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. However, insertion sort provides several advantages:</source>
          <target state="translated">Insertion sort是一种简单的排序算法,它一次一个项目建立最终排序的数组(或列表)。它在大型列表上的效率比更高级的算法(如quicksort、heapsort或merge sort)要低得多。然而,插入式排序有几个优点。</target>
        </trans-unit>
        <trans-unit id="09dfd03d9fa968a44a324d9a9670952800b1a369" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;orderBy&lt;/code&gt; and related methods call appropriate array sorting functions (&lt;code&gt;uasort&lt;/code&gt;, &lt;code&gt;krsort&lt;/code&gt;, &lt;code&gt;multisort&lt;/code&gt;, &lt;code&gt;usort&lt;/code&gt; etc.).</source>
          <target state="translated">在内部， &lt;code&gt;orderBy&lt;/code&gt; 和相关方法调用适当的数组排序函数（ &lt;code&gt;uasort&lt;/code&gt; ， &lt;code&gt;krsort&lt;/code&gt; ， &lt;code&gt;multisort&lt;/code&gt; ， &lt;code&gt;usort&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="da1531a814d65a809aa862e5d5c336dc8e0042a7" translate="yes" xml:space="preserve">
          <source>It is very convenient to sort arrays with &lt;a href=&quot;https://github.com/ihor/Nspl#sortedarray-array-reversed--false-key--null-cmp--null&quot;&gt;sorted&lt;/a&gt; function from &lt;a href=&quot;https://github.com/ihor/Nspl&quot;&gt;Nspl&lt;/a&gt;:</source>
          <target state="translated">使用&lt;a href=&quot;https://github.com/ihor/Nspl&quot;&gt;Nspl的&lt;/a&gt; &lt;a href=&quot;https://github.com/ihor/Nspl#sortedarray-array-reversed--false-key--null-cmp--null&quot;&gt;sorted&lt;/a&gt;函数对数组进行排序非常方便：</target>
        </trans-unit>
        <trans-unit id="667a4c437c43ca4427c06a7c18f482d831ef30ee" translate="yes" xml:space="preserve">
          <source>LINQ</source>
          <target state="translated">LINQ</target>
        </trans-unit>
        <trans-unit id="d7b23de8effd125677df7440a79328060cc5e033" translate="yes" xml:space="preserve">
          <source>LINQ contains many more methods inspired by SQL: filtering, grouping, joining, aggregating etc. It's best suited for cases when complex transformations on arrays and objects need to be performed without relying on databases.</source>
          <target state="translated">LINQ包含了更多受SQL启发的方法:过滤、分组、加入、聚合等。它最适合在不依赖数据库的情况下,对数组和对象进行复杂的转换。</target>
        </trans-unit>
        <trans-unit id="f64a19aa28fb1c68abbaec37b0257c0dcb685d6c" translate="yes" xml:space="preserve">
          <source>Let's say you have an array like this:</source>
          <target state="translated">假设你有一个像这样的数组。</target>
        </trans-unit>
        <trans-unit id="c6e2b023f3c4383d2cf7c27139646fae922e2b4a" translate="yes" xml:space="preserve">
          <source>Let's write the sort step using this function:</source>
          <target state="translated">让我们用这个函数来写排序步骤。</target>
        </trans-unit>
        <trans-unit id="67151004822cc885e4122a06e2904151a40b8599" translate="yes" xml:space="preserve">
          <source>Merge sort</source>
          <target state="translated">合并排序</target>
        </trans-unit>
        <trans-unit id="a90731fa64d2eaebed1e787a4012ebb1d3ba50b7" translate="yes" xml:space="preserve">
          <source>Multi dimensional arrays, including arrays of objects</source>
          <target state="translated">多维数组,包括对象数组的数组</target>
        </trans-unit>
        <trans-unit id="6e0c416675708d317f2b07de659b4ababe413cc0" translate="yes" xml:space="preserve">
          <source>Natural sort of a multidimensional array by a key value and also keep the original order(do not shuffle the main keys):</source>
          <target state="translated">按键值对多维数组进行自然排序,并保持原来的顺序(不洗牌主键)。</target>
        </trans-unit>
        <trans-unit id="1b9453aa0a00bdf9f4d988745a47066a5de0f25b" translate="yes" xml:space="preserve">
          <source>Note that the array sorts &lt;em&gt;in place&lt;/em&gt;, you do not need to assign the return value to anything. &lt;code&gt;$array = sort($array)&lt;/code&gt; will replace the array with &lt;code&gt;true&lt;/code&gt;, not with a sorted array. Just &lt;code&gt;sort($array);&lt;/code&gt; works.</source>
          <target state="translated">请注意，数组&lt;em&gt;在适当位置&lt;/em&gt;排序，您无需将返回值分配给任何对象。 &lt;code&gt;$array = sort($array)&lt;/code&gt; 会将数组替换为 &lt;code&gt;true&lt;/code&gt; ，而不是已排序的数组。 只是 &lt;code&gt;sort($array);&lt;/code&gt; 作品。</target>
        </trans-unit>
        <trans-unit id="975c9470ca30f7d2e09bf09a076cb2fa5788f53e" translate="yes" xml:space="preserve">
          <source>Note that this won't work well for &lt;code&gt;float&lt;/code&gt; values, since they'll be reduced to an &lt;code&gt;int&lt;/code&gt; and lose precision. Use explicit &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; return values instead.</source>
          <target state="translated">请注意，这对于 &lt;code&gt;float&lt;/code&gt; 值将不能很好地工作，因为它们会被简化为 &lt;code&gt;int&lt;/code&gt; 并失去精度。 改用显式 &lt;code&gt;-1&lt;/code&gt; ,0和 &lt;code&gt;1&lt;/code&gt; 返回值。</target>
        </trans-unit>
        <trans-unit id="9480ac07046c735f2fecfd2332cb6f82d4b86385" translate="yes" xml:space="preserve">
          <source>Now array is sorted according their key value.If You want to sort the array in descending order according their key value,'krsort()' method can be used.</source>
          <target state="translated">现在数组是根据它们的key值进行排序,如果你想根据它们的key值按降序排序,可以使用'krsort()方法。</target>
        </trans-unit>
        <trans-unit id="6954657f48f6b7ff5d7802374273a3999c5374ed" translate="yes" xml:space="preserve">
          <source>Now array is sorted in descending order.Ok, Let's consider an associative array.I will give an associative array(Associative array means that, An array whose each index has unique key value.) like this,</source>
          <target state="translated">现在数组是按降序排序的,好吧,让我们考虑一个关联数组,我将给出一个关联数组(关联数组的意思是,一个数组的每个索引都有唯一的键值),就像这样。</target>
        </trans-unit>
        <trans-unit id="8ae68b7f9f856327cadf4b20822beefd6eed6802" translate="yes" xml:space="preserve">
          <source>Now associative array is sorted in descending order according their key value.Look at the output.</source>
          <target state="translated">现在,联想数组按照键值降序排序。</target>
        </trans-unit>
        <trans-unit id="72ee2e304658dc96b31d0a5b7baf0c4b1799c99d" translate="yes" xml:space="preserve">
          <source>Now consider the output of that,</source>
          <target state="translated">现在考虑一下这一点的输出。</target>
        </trans-unit>
        <trans-unit id="d827a6d027f57d096cc39d07e7c52f06a4bc5370" translate="yes" xml:space="preserve">
          <source>Now consider the output.</source>
          <target state="translated">现在考虑一下输出。</target>
        </trans-unit>
        <trans-unit id="bb53e72bba70d545e597e3fd609e9845c180b9b2" translate="yes" xml:space="preserve">
          <source>Now, we adjust the comparison step; we compare the first letter again, but if they're the same, the secondary key is used to retain the original ordering:</source>
          <target state="translated">现在,我们调整比较的步骤;我们再次比较第一个字母,但如果它们是一样的,就用次要的键来保留原来的排序。</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="e39453d0bca511e0ba4ab9de0245d522eae2bb85" translate="yes" xml:space="preserve">
          <source>Often, you will want to use an &lt;a href=&quot;http://php.net/manual/en/functions.anonymous.php&quot;&gt;anonymous function&lt;/a&gt; as the callback. If you want to use a method or static method, see the &lt;a href=&quot;http://php.net/manual/en/language.types.callable.php&quot;&gt;other ways of specifying a callback in PHP&lt;/a&gt;.</source>
          <target state="translated">通常，您将需要使用&lt;a href=&quot;http://php.net/manual/en/functions.anonymous.php&quot;&gt;匿名函数&lt;/a&gt;作为回调。 如果要使用方法或静态方法，请参见&lt;a href=&quot;http://php.net/manual/en/language.types.callable.php&quot;&gt;在PHP中指定回调&lt;/a&gt;的其他方法 。</target>
        </trans-unit>
        <trans-unit id="c35d83d789a540e6897531d14c6254373ce83781" translate="yes" xml:space="preserve">
          <source>Other Types of Sort</source>
          <target state="translated">其他类型的分类</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="b0267e700c88a37263a43b92d7a395bce05551fd" translate="yes" xml:space="preserve">
          <source>PHP 7 introduced the &lt;a href=&quot;https://stackoverflow.com/a/31298778/476&quot;&gt;spaceship operator&lt;/a&gt;, which unifies and simplifies equal/smaller/larger than comparisons across types:</source>
          <target state="translated">PHP 7引入了&lt;a href=&quot;https://stackoverflow.com/a/31298778/476&quot;&gt;spaceship运算符&lt;/a&gt; ，该运算符统一并简化了与不同类型的比较相比相等/较小/​​较大的操作：</target>
        </trans-unit>
        <trans-unit id="3f2d32e9b9fcccd95d471d74d44aa03d86740971" translate="yes" xml:space="preserve">
          <source>Permutation sort</source>
          <target state="translated">递增排序</target>
        </trans-unit>
        <trans-unit id="c173eb402711aa25b0f47a3eba4637bd8ca240a3" translate="yes" xml:space="preserve">
          <source>Permutation sort, which proceeds by generating the possible permutations of the input array/list until discovering the sorted one.</source>
          <target state="translated">发散式排序,通过生成输入数组列表的可能的permutation排序,直到发现被排序的那一个。</target>
        </trans-unit>
        <trans-unit id="d44cb3d8ba3820f721444056407b199d364b0108" translate="yes" xml:space="preserve">
          <source>Quicksort</source>
          <target state="translated">Quicksort</target>
        </trans-unit>
        <trans-unit id="4e2f2ccda2d141cdb71813f9ece456d6058909d2" translate="yes" xml:space="preserve">
          <source>Quicksort, or partition-exchange sort, is a sorting algorithm developed by Tony Hoare that, on average, makes O(n log n) comparisons to sort n items. In the worst case, it makes O(n2) comparisons, though this behavior is rare.</source>
          <target state="translated">Quicksort,即分区交换排序,是由Tony Hoare开发的一种排序算法,平均来说,它对n个项目进行O(n log n)的比较排序。在最坏的情况下,它可以进行O(n2)次比较,不过这种行为很少见。</target>
        </trans-unit>
        <trans-unit id="bff4909dacd843638a143efdc8a9f26a73d4d021" translate="yes" xml:space="preserve">
          <source>Radix sort</source>
          <target state="translated">Radix要出来了</target>
        </trans-unit>
        <trans-unit id="c7ffa0f7b8c42b69643661d77faa8591b90c537c" translate="yes" xml:space="preserve">
          <source>Sample data for my demonstrations:</source>
          <target state="translated">我演示的样本数据。</target>
        </trans-unit>
        <trans-unit id="e3cdf383e3767cd3d19172cf65aee5ac75789a6a" translate="yes" xml:space="preserve">
          <source>Selection sort</source>
          <target state="translated">选择排序</target>
        </trans-unit>
        <trans-unit id="5b80873e838a3de2e0b8501112112c5e85d97341" translate="yes" xml:space="preserve">
          <source>Shellsort</source>
          <target state="translated">Shellsort</target>
        </trans-unit>
        <trans-unit id="7f8c6841ac8c565f0f59479a33bf5e67aeff1fd7" translate="yes" xml:space="preserve">
          <source>Shellsort, also known as Shell sort or Shell's method, is an in-place comparison sort. It generalizes an exchanging sort, such as insertion or bubble sort, by starting the comparison and exchange of elements with elements that are far apart before finishing with neighboring elements.</source>
          <target state="translated">Shellsort,又称Shell sort或Shell排序法,是一种就地比较排序。它是对交换式排序(如插入式或气泡式排序)的概括,它是将交换式排序(如插入式或气泡式排序)进行了概括,先用相距较远的元素进行比较和交换,然后再用相邻的元素进行比较和交换。</target>
        </trans-unit>
        <trans-unit id="c72db2b9bd5162f4ee3192fa5a58bf805b06a3e0" translate="yes" xml:space="preserve">
          <source>So ,Now I want to sort this array in ascending order according their value.'asort()' method can be used for that.</source>
          <target state="translated">所以,现在我想把这个数组按照它们的值按升序排序,可以用'asort()'方法来实现。</target>
        </trans-unit>
        <trans-unit id="6deb74510a05647499e115f644b036d0c78033e2" translate="yes" xml:space="preserve">
          <source>Sorting by multiple fields</source>
          <target state="translated">按多个字段分类</target>
        </trans-unit>
        <trans-unit id="0abc6fe29f723ac5ab847735d61a3e848b86510b" translate="yes" xml:space="preserve">
          <source>Sorting into a manual, static order</source>
          <target state="translated">分类为手动、静态订单</target>
        </trans-unit>
        <trans-unit id="6ae7466fd879afa82cce3b8c69fc1d7a38b8457b" translate="yes" xml:space="preserve">
          <source>Sorting logic:</source>
          <target state="translated">分选逻辑。</target>
        </trans-unit>
        <trans-unit id="5828996ad33961b80dd02a99ba31c274af774b8c" translate="yes" xml:space="preserve">
          <source>Sorting one array based on another</source>
          <target state="translated">根据另一个数组进行排序</target>
        </trans-unit>
        <trans-unit id="dc76f608fa88e8b8d88d502255d84d79946a6d0f" translate="yes" xml:space="preserve">
          <source>Sorting with SPL</source>
          <target state="translated">用SPL进行分选</target>
        </trans-unit>
        <trans-unit id="33e63fd49e04368d0c74d40d9016c5e47c3d84bc" translate="yes" xml:space="preserve">
          <source>Spaceship operator</source>
          <target state="translated">飞船操作员</target>
        </trans-unit>
        <trans-unit id="b18198f5f9f57564c4ac888b338ec7bdf4bd8815" translate="yes" xml:space="preserve">
          <source>Stable sort</source>
          <target state="translated">稳定型</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="be8b35a38597692f15ee011684c538a2449fccf4" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;strong&gt;The PoWEr oF MATH&lt;/strong&gt; this returns a value &amp;lt; 0, 0 or &amp;gt; 0 depending on whether &lt;code&gt;$a&lt;/code&gt; is lower than, equal to or larger than &lt;code&gt;$b&lt;/code&gt;.</source>
          <target state="translated">多亏了&lt;strong&gt;数学运算法则，&lt;/strong&gt;它返回值&amp;lt;0、0或&amp;gt; 0，具体取决于 &lt;code&gt;$a&lt;/code&gt; 小于，等于还是大于 &lt;code&gt;$b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18b26e687c8060faed4b3283538901d99924da0c" translate="yes" xml:space="preserve">
          <source>That's how simple sorting a complex multi-dimensional array can be. Again, just think in terms of &lt;em&gt;teaching PHP how to tell which of two items is &quot;greater&quot;&lt;/em&gt;; let PHP do the actual sorting.</source>
          <target state="translated">这就是对复杂的多维数组进行排序的简单方式。 再说一遍，只需要考虑&lt;em&gt;教PHP如何分辨两个项目中的哪个&amp;ldquo;更大&amp;rdquo;即可&lt;/em&gt; ； 让PHP进行实际排序。</target>
        </trans-unit>
        <trans-unit id="12c288ba8b61fad8ca7f16d60422336faa5fe119" translate="yes" xml:space="preserve">
          <source>The SplMaxHeap class provides the main functionalities of a heap, keeping the maximum on the top.</source>
          <target state="translated">SplMaxHeap类提供了一个堆的主要功能,将最大的功能保持在最上面。</target>
        </trans-unit>
        <trans-unit id="054693f687dcbdc3235c558c02357cafa6badd3e" translate="yes" xml:space="preserve">
          <source>The SplMinHeap class provides the main functionalities of a heap, keeping the minimum on the top.</source>
          <target state="translated">SplMinHeap类提供了一个堆的主要功能,将最小值保留在最上面。</target>
        </trans-unit>
        <trans-unit id="d4d87b5e9fc3737c7e81b15ed8aa38249fbcf373" translate="yes" xml:space="preserve">
          <source>The difference between those is merely whether key-value associations are kept (the &quot;&lt;code&gt;a&lt;/code&gt;&quot; functions), whether it sorts low-to-high or reverse (&quot;&lt;code&gt;r&lt;/code&gt;&quot;), whether it sorts values or keys (&quot;&lt;code&gt;k&lt;/code&gt;&quot;) and how it compares values (&quot;&lt;code&gt;nat&lt;/code&gt;&quot; vs. normal). See &lt;a href=&quot;http://php.net/manual/en/array.sorting.php&quot;&gt;http://php.net/manual/en/array.sorting.php&lt;/a&gt; for an overview and links to further details.</source>
          <target state="translated">两者之间的区别仅在于是否保留键值关联（&amp;ldquo; &lt;code&gt;a&lt;/code&gt; &amp;rdquo;函数），是否按从低到高或反向排序（&amp;ldquo; &lt;code&gt;r&lt;/code&gt; &amp;rdquo;），对值或键进行排序（&amp;ldquo; &lt;code&gt;k&lt;/code&gt; &amp;rdquo;）以及如何它比较值（&amp;ldquo; &lt;code&gt;nat&lt;/code&gt; &amp;rdquo;与正常值）。 有关概述以及指向更多详细信息的链接，请参见&lt;a href=&quot;http://php.net/manual/en/array.sorting.php&quot;&gt;http://php.net/manual/zh-CN/array.sorting.php&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="725e8396ee12340d6238f40e07cd4a73b61075ce" translate="yes" xml:space="preserve">
          <source>The elements from both sides of the operator will be traversed left to right, one at a time, and returning the evaluation as soon as a non-tie is encountered or when the elements have all been compared.</source>
          <target state="translated">从运算器的两边的元素从左到右逐一进行遍历,一旦遇到非尾数或元素全部比较过后,立即返回评价。</target>
        </trans-unit>
        <trans-unit id="0b2f20e21a299cb112503b754502d1f181c00b06" translate="yes" xml:space="preserve">
          <source>The expected result here would be:</source>
          <target state="translated">这里的预期结果是:</target>
        </trans-unit>
        <trans-unit id="953adeb96e5f44095ec62a8ec7fb264aa7f1685a" translate="yes" xml:space="preserve">
          <source>The final result:</source>
          <target state="translated">最终的结果。</target>
        </trans-unit>
        <trans-unit id="c0657eaaa8eae57d4b0859d34d3f627d4a16f08b" translate="yes" xml:space="preserve">
          <source>The keen observer may have noticed that the array sorting algorithm (QuickSort) didn't produce a stable outcome and that the original order between words of the same first letter wasn't preserved. This case is trivial and we should have compared the whole string, but let's assume your use-case is more complicated, such as two consecutive sorts on different fields that shouldn't cancel out each other's work.</source>
          <target state="translated">敏锐的观察者可能已经注意到,数组排序算法(QuickSort)并没有产生稳定的结果,同一个首字母的单词之间的原始顺序没有被保留。这种情况很琐碎,我们应该对整个字符串进行比较,但我们假设你的用例更复杂,比如在不同的字段上有两个连续的排序,不应该互相抵消对方的工作。</target>
        </trans-unit>
        <trans-unit id="40557e3db4165270942853579e99a47f46705025" translate="yes" xml:space="preserve">
          <source>The outcome is this:</source>
          <target state="translated">结果是这样的。</target>
        </trans-unit>
        <trans-unit id="8ab3b917f6b1d0b8f5cf7e5e7047d13f590ba823" translate="yes" xml:space="preserve">
          <source>The simplest is to use usort function to sort array without any looping :
Below is an example :</source>
          <target state="translated">最简单的方法是使用usort函数对数组进行排序,不需要任何循环:下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="b2b8e2cb335886e04d4d752fe8fe7627299eacc6" translate="yes" xml:space="preserve">
          <source>There are several ways to sort an array.I will mention some methods for doing that task.fist of all , I will give an integer array which is called as '$numbers'.</source>
          <target state="translated">有几种方法可以对数组进行排序,我将提到一些做这个任务的方法。</target>
        </trans-unit>
        <trans-unit id="f08a86bb02cd3d4e2099033080e2835aae6d74dd" translate="yes" xml:space="preserve">
          <source>These are the some methods for sorting an array in ascending or descending order in php.I hope to you could get an idea.Thank you!</source>
          <target state="translated">以上是一些在php中按升序或降序排序数组的方法,希望大家能有所启发。</target>
        </trans-unit>
        <trans-unit id="8c2be70445cb54d01611838358190c3a777e3184" translate="yes" xml:space="preserve">
          <source>This is the normal way to creating an array. Suppose that , I want to sort that array in ascending order.For that, 'sort()' method can be used.</source>
          <target state="translated">这就是创建数组的正常方法。假设,我想对数组进行升序排序,为此,可以使用'sort()方法。</target>
        </trans-unit>
        <trans-unit id="dde20aef894f0fb7fd0addad9c8e2eca69acf984" translate="yes" xml:space="preserve">
          <source>This makes great strides in reducing code bloat and improving readability.</source>
          <target state="translated">这在减少代码臃肿和提高可读性方面有了很大的进步。</target>
        </trans-unit>
        <trans-unit id="8ae5faa04b7f0b4ab713cf58213e707e0e5433a0" translate="yes" xml:space="preserve">
          <source>This page is very comprehensive, but I want to add a bit more about the awesome utility of the spaceship operator (three way comparison operator) -- a beautiful child of PHP7+.</source>
          <target state="translated">这个页面非常全面,但我想再补充一点关于飞船操作器(三路比较操作器)的强大实用性--PHP7+的一个美丽的孩子,我想再补充一点。</target>
        </trans-unit>
        <trans-unit id="d2aa926b92b550aa69143e32375772daf3d60b1a" translate="yes" xml:space="preserve">
          <source>This question is intended as a reference for questions about sorting arrays in PHP. It is easy to think that your particular case is unique and worthy of a new question, but most are actually minor variations of one of the solutions on this page.</source>
          <target state="translated">这个问题的目的是作为PHP中关于排序数组的问题的参考。很容易认为你的特殊情况是独特的,值得新问题,但实际上大多数都是本页面上的某个解决方案的小变种。</target>
        </trans-unit>
        <trans-unit id="f80d90d89f72bcf9b275cd7306e8e7131a2b8842" translate="yes" xml:space="preserve">
          <source>This syntax allows you to sort values, functional outcomes, deep-nested data, and sorting direction in a elegant fashion.  This is definitely worth putting in your php toolbelt ...for cases when you are processing non-database data -- because of course SQL would be a much more sensible technique.</source>
          <target state="translated">这个语法允许你以一种优雅的方式对值、功能结果、深度嵌套数据和排序方向进行排序。这绝对值得放在你的php工具箱里...........当你处理非数据库数据的时候,当然SQL会是一个更合理的技术。</target>
        </trans-unit>
        <trans-unit id="71b460d3c37c7ce78ce6b0d6df859d807f5083db" translate="yes" xml:space="preserve">
          <source>This transforms the array into this:</source>
          <target state="translated">这就把数组转化成了这个。</target>
        </trans-unit>
        <trans-unit id="0402d6569e261eb376cd0e0480149c110dfe7e44" translate="yes" xml:space="preserve">
          <source>This will sort in asending order :</source>
          <target state="translated">这将按递增顺序排序。</target>
        </trans-unit>
        <trans-unit id="973b5f203a597863c3416acc2681e81c4c38e982" translate="yes" xml:space="preserve">
          <source>This will sort in desending order :</source>
          <target state="translated">这将按顺序依次排序。</target>
        </trans-unit>
        <trans-unit id="ec3712d52e6639c57acc511c0d5bd37714eb0283" translate="yes" xml:space="preserve">
          <source>To do that, you need to create a &lt;em&gt;comparison function&lt;/em&gt;. That function takes two elements and must return &lt;code&gt;0&lt;/code&gt; if these elements are considered equal, a value lower than &lt;code&gt;0&lt;/code&gt; if the first value is lower and a value higher than &lt;code&gt;0&lt;/code&gt; if the first value is higher. That's all that's needed:</source>
          <target state="translated">为此，您需要创建一个&lt;em&gt;比较函数&lt;/em&gt; 。 该函数接受两个元素，如果这些元素被认为相等，则必须返回 &lt;code&gt;0&lt;/code&gt; ;如果第一个值较低，则返回小于 &lt;code&gt;0&lt;/code&gt; 的值；如果第一个值较高，则返回大于 &lt;code&gt;0&lt;/code&gt; 的值。 这就是所需要的：</target>
        </trans-unit>
        <trans-unit id="9ff58a12c33c24d9444fe3d80dd760a502773162" translate="yes" xml:space="preserve">
          <source>To get used to this idea, try this:</source>
          <target state="translated">要习惯这个想法,可以试试这个。</target>
        </trans-unit>
        <trans-unit id="4d7fc375f7c2d29c511ad47f3b0427f8fe029dc7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;array_multisort&lt;/code&gt; to get there:</source>
          <target state="translated">使用 &lt;code&gt;array_multisort&lt;/code&gt; 到达那里：</target>
        </trans-unit>
        <trans-unit id="cc8255a05e0c9e77bc8b8f60a36e1a52dda63dbb" translate="yes" xml:space="preserve">
          <source>Using the spaceship operator to implement multiple sort conditions</source>
          <target state="translated">使用飞船操作符来实现多个排序条件</target>
        </trans-unit>
        <trans-unit id="01ba4a7aa0b09c32b597708fbf029367d4fc4548" translate="yes" xml:space="preserve">
          <source>Voila! Your pristine comparison code is back.</source>
          <target state="translated">瞧瞧!你的原始对比码又回来了 你的原始对比码又回来了。</target>
        </trans-unit>
        <trans-unit id="4081ff83370ff929f9d82da1aa8c8026b891606f" translate="yes" xml:space="preserve">
          <source>Well most basic methods are already covered by &lt;a href=&quot;https://stackoverflow.com/a/17364128&quot;&gt;deceze&lt;/a&gt; I would try to look at other types of sort</source>
          <target state="translated">好吧，大多数基本方法已经包含在&lt;a href=&quot;https://stackoverflow.com/a/17364128&quot;&gt;deceze中，&lt;/a&gt;我将尝试查看其他类型的排序</target>
        </trans-unit>
        <trans-unit id="3a5e3a6448c0eea877c84b7a66986dbba7567544" translate="yes" xml:space="preserve">
          <source>When writing your custom sort (&lt;code&gt;usort()&lt;/code&gt;/&lt;code&gt;uasort()&lt;/code&gt;/&lt;code&gt;uksort()&lt;/code&gt;) function to process a multiple conditions, you only need to write balanced arrays on either side of the operator and return the outcome. &lt;strong&gt;No more nested condition blocks or multiple returns.&lt;/strong&gt;</source>
          <target state="translated">编写自定义排序（ &lt;code&gt;usort()&lt;/code&gt; / &lt;code&gt;uasort()&lt;/code&gt; / &lt;code&gt;uksort()&lt;/code&gt; ）函数以处理多个条件时，只需要在运算符的任一侧写平衡数组并返回结果即可。 &lt;strong&gt;没有更多的嵌套条件块或多次返回。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6ab42d0070bc672b70cc0b562ef5caca83182c66" translate="yes" xml:space="preserve">
          <source>You can do anything you need inside a comparison function, including calling functions:</source>
          <target state="translated">你可以在比较函数里面做任何你需要的事情,包括调用函数。</target>
        </trans-unit>
        <trans-unit id="c2598758b7b8e523ec8fa99a6fb1a68f431a6a36" translate="yes" xml:space="preserve">
          <source>You can see all these examples &lt;a href=&quot;https://github.com/ihor/Nspl/blob/master/examples/a_sorted.php&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">您可以&lt;a href=&quot;https://github.com/ihor/Nspl/blob/master/examples/a_sorted.php&quot;&gt;在此处&lt;/a&gt;查看所有这些示例。</target>
        </trans-unit>
        <trans-unit id="0c73513599241b3ce7f8138e76771704dbf6c490" translate="yes" xml:space="preserve">
          <source>You can see printed number array is sorted. If you want to that number array to be sort is descending order, 'rsort()' method can be use for that task.</source>
          <target state="translated">你可以看到打印出来的数字数组被排序了。如果你想将数字数组按降序排序,可以使用'rsort()'方法进行排序。</target>
        </trans-unit>
        <trans-unit id="f9fa873c922dd4519bb3310f2049638099570603" translate="yes" xml:space="preserve">
          <source>You had to rewrite your comparison function to work with the transformed array elements; you may not want to edit your delicate comparison functions, so here's a wrapper for the comparison function:</source>
          <target state="translated">你必须重写你的比较函数来处理转换后的数组元素;你可能不想编辑你精致的比较函数,所以这里有一个比较函数的包装器。</target>
        </trans-unit>
        <trans-unit id="f693970746f4c98af758145696b3f03075e624fd" translate="yes" xml:space="preserve">
          <source>You then use one of these functions:</source>
          <target state="translated">然后你就可以使用这些功能中的一个。</target>
        </trans-unit>
        <trans-unit id="d6dc10b51f4ac19dc7e1c1bf1c90cd2514ff5fda" translate="yes" xml:space="preserve">
          <source>boolean ASC</source>
          <target state="translated">布尔恩ASC</target>
        </trans-unit>
        <trans-unit id="011f88a6deac532999df9a4bf406f2452a5e4ec2" translate="yes" xml:space="preserve">
          <source>boolean DESC (false = 0, true = 1, so trues before falses)</source>
          <target state="translated">boolean DESC (false=0,true=1,所以在falses之前为true)</target>
        </trans-unit>
        <trans-unit id="51aa2637eade754937f7d4b54457cc38ed3ebe0d" translate="yes" xml:space="preserve">
          <source>consider the output..</source>
          <target state="translated">考虑到输出.....</target>
        </trans-unit>
        <trans-unit id="435226da679aca3541980cba99db2b6a022eb075" translate="yes" xml:space="preserve">
          <source>float ASC</source>
          <target state="translated">浮动ASC</target>
        </trans-unit>
        <trans-unit id="2d71871d1b3a78e77346189fe7602ee55e8ea317" translate="yes" xml:space="preserve">
          <source>i.e., in order to sort first by a, then b, then c, the correct clause would be</source>
          <target state="translated">也就是说,要先按A、B、C排序,正确的句子应该是</target>
        </trans-unit>
        <trans-unit id="b13b3070cef0cf3ace0f7f9a184ef548be1c6c51" translate="yes" xml:space="preserve">
          <source>iterability of mixed DESC</source>
          <target state="translated">混合型DESC的可重复性</target>
        </trans-unit>
        <trans-unit id="acb5e075da5022ac6ab70076026e7f717ee2621a" translate="yes" xml:space="preserve">
          <source>mixed ASC</source>
          <target state="translated">混合ASC</target>
        </trans-unit>
        <trans-unit id="641c176e662a04a9783622e92508da3d59203cd6" translate="yes" xml:space="preserve">
          <source>natString ASC</source>
          <target state="translated">natString ASC</target>
        </trans-unit>
        <trans-unit id="92be7e45d7a0699bc3a9c9723e9cb645e47c33fd" translate="yes" xml:space="preserve">
          <source>natString length ASC</source>
          <target state="translated">natString length ASC</target>
        </trans-unit>
        <trans-unit id="d4a4c6438367ffdd711c2e9f3c7389c021225aed" translate="yes" xml:space="preserve">
          <source>object ASC</source>
          <target state="translated">对象ASC</target>
        </trans-unit>
        <trans-unit id="678cf1c73e8c23cc8b56f38065ff425f1804790c" translate="yes" xml:space="preserve">
          <source>property count of object ASC</source>
          <target state="translated">物体属性数</target>
        </trans-unit>
        <trans-unit id="2c81b69885c711d3fc704aa7da591bfb0542dc5e" translate="yes" xml:space="preserve">
          <source>to produce</source>
          <target state="translated">以生产</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
