<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1711631">
    <body>
      <group id="1711631">
        <trans-unit id="cdefc7d8d0f502ac2649cb2130333beb8e549c0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SQLITE_STATIC&lt;/code&gt; tells it that the memory address you gave it will be valid until the query has been performed (which in this loop is always the case). This will save you several allocate, copy and deallocate operations per loop. Possibly a large improvement.</source>
          <target state="translated">&lt;code&gt;SQLITE_STATIC&lt;/code&gt; le dice que la direcci&amp;oacute;n de memoria que le proporcion&amp;oacute; ser&amp;aacute; v&amp;aacute;lida hasta que se haya realizado la consulta (que en este bucle siempre es el caso). Esto le ahorrar&amp;aacute; varias operaciones de asignaci&amp;oacute;n, copia y desasignaci&amp;oacute;n por ciclo. Posiblemente una gran mejora.</target>
        </trans-unit>
        <trans-unit id="dc841631c7f8778b9620c5a6aebf79da39172daf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SQLITE_TRANSIENT&lt;/code&gt; will cause SQLite to copy the string data before returning.</source>
          <target state="translated">&lt;code&gt;SQLITE_TRANSIENT&lt;/code&gt; har&amp;aacute; que SQLite copie los datos de la cadena antes de regresar.</target>
        </trans-unit>
        <trans-unit id="8e0bb93e0bdc0ef4869a544f1ec90a67170531be" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;I hope you're still with me!&lt;/em&gt; The reason we started down this road is that bulk-insert performance varies so wildly with SQLite, and it's not always obvious what changes need to be made to speed-up our operation. Using the same compiler (and compiler options), the same version of SQLite and the same data we've optimized our code and our usage of SQLite to go &lt;strong&gt;from a worst-case scenario of 85 inserts per second to over 96,000 inserts per second!&lt;/strong&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iexcl;Espero que sigas conmigo!&lt;/em&gt; La raz&amp;oacute;n por la que comenzamos en este camino es que el rendimiento de la inserci&amp;oacute;n masiva var&amp;iacute;a enormemente con SQLite, y no siempre es obvio qu&amp;eacute; cambios deben hacerse para acelerar nuestra operaci&amp;oacute;n. Usando el mismo compilador (y opciones de compilador), la misma versi&amp;oacute;n de SQLite y los mismos datos hemos optimizado nuestro c&amp;oacute;digo y nuestro uso de SQLite para pasar &lt;strong&gt;del peor de los casos de 85 inserciones por segundo a m&amp;aacute;s de 96,000 inserciones por segundo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="651a2b8d1ad8078419cf895a15b4c0df27a8c401" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Let's write some code!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;iexcl;Escribamos un c&amp;oacute;digo!&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b76b98300a521ccc66355329ebd7994a2475558c" translate="yes" xml:space="preserve">
          <source>&lt;s&gt;&lt;a href=&quot;https://github.com/rdpoor/CreateOrUpdate&quot;&gt;https://github.com/rdpoor/CreateOrUpdate&lt;/a&gt;&lt;/s&gt;</source>
          <target state="translated">&lt;s&gt;&lt;a href=&quot;https://github.com/rdpoor/CreateOrUpdate&quot;&gt;https://github.com/rdpoor/CreateOrUpdate&lt;/a&gt;&lt;/s&gt;</target>
        </trans-unit>
        <trans-unit id="7ff38676434e7065905a1e026ab3bdabb754fafc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Avoid &lt;a href=&quot;https://www.sqlite.org/c3ref/clear_bindings.html&quot;&gt;&lt;code&gt;sqlite3_clear_bindings(stmt)&lt;/code&gt;&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Evite &lt;a href=&quot;https://www.sqlite.org/c3ref/clear_bindings.html&quot;&gt; &lt;code&gt;sqlite3_clear_bindings(stmt)&lt;/code&gt; &lt;/a&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b52454c570dc6b7585dff89d6bafeb4102012edb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Background:&lt;/strong&gt; We are using SQLite as part of a desktop application. We have large amounts of configuration data stored in XML files that are parsed and loaded into an SQLite database for further processing when the application is initialized. SQLite is ideal for this situation because it's fast, it requires no specialized configuration, and the database is stored on disk as a single file.</source>
          <target state="translated">&lt;strong&gt;Antecedentes:&lt;/strong&gt; estamos usando SQLite como parte de una aplicaci&amp;oacute;n de escritorio. Tenemos grandes cantidades de datos de configuraci&amp;oacute;n almacenados en archivos XML que se analizan y cargan en una base de datos SQLite para su posterior procesamiento cuando se inicializa la aplicaci&amp;oacute;n. SQLite es ideal para esta situaci&amp;oacute;n porque es r&amp;aacute;pido, no requiere una configuraci&amp;oacute;n especializada y la base de datos se almacena en el disco como un solo archivo.</target>
        </trans-unit>
        <trans-unit id="270000b21d15ce5fe27f22341bb7e2a04b3d7f99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Create Index then Insert Data&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Crear &amp;iacute;ndice y luego insertar datos&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c801cbf9bc118950e73a5431424c376f22274ca3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Insert Data then Create Index&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Insertar datos y luego crear &amp;iacute;ndice&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbe1b95758ace93ba6c358fe7b1aa18db2be2a7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: We are back to using a real database file. In-memory databases are fast, but not necessarily practical&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Nota: Volvemos a usar un archivo de base de datos real.&lt;/strong&gt; &lt;strong&gt;Las bases de datos en memoria son r&amp;aacute;pidas, pero no necesariamente pr&amp;aacute;cticas.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26ea07b172d510db473fb482ce4002bc7313046a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rationale:&lt;/strong&gt;&lt;em&gt;Initially I was disappointed with the performance I was seeing.&lt;/em&gt; It turns-out that the performance of SQLite can vary significantly (both for bulk-inserts and selects) depending on how the database is configured and how you're using the API. It was not a trivial matter to figure out what all of the options and techniques were, so I thought it prudent to create this community wiki entry to share the results with Stack&amp;nbsp;Overflow readers in order to save others the trouble of the same investigations.</source>
          <target state="translated">&lt;strong&gt;Justificaci&amp;oacute;n:&lt;/strong&gt; &lt;em&gt;Inicialmente estaba decepcionado con el rendimiento que estaba viendo.&lt;/em&gt; Resulta que el rendimiento de SQLite puede variar significativamente (tanto para inserciones masivas como para selecciones) dependiendo de c&amp;oacute;mo est&amp;eacute; configurada la base de datos y de c&amp;oacute;mo est&amp;eacute; utilizando la API. No era un asunto trivial descubrir cu&amp;aacute;les eran todas las opciones y t&amp;eacute;cnicas, por lo que pens&amp;eacute; que era prudente crear esta entrada de la wiki comunitaria para compartir los resultados con los lectores de Stack Overflow para salvar a otros el problema de las mismas investigaciones.</target>
        </trans-unit>
        <trans-unit id="a76bacf9fc05e4ab73ba39928377f27b7df97668" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Code:&lt;/strong&gt; A simple C program that reads the text file line-by-line, splits the string into values and then inserts the data into an SQLite database. In this &quot;baseline&quot; version of the code, the database is created, but we won't actually insert data:</source>
          <target state="translated">&lt;strong&gt;El C&amp;oacute;digo:&lt;/strong&gt; un programa simple en C que lee el archivo de texto l&amp;iacute;nea por l&amp;iacute;nea, divide la cadena en valores y luego inserta los datos en una base de datos SQLite. En esta versi&amp;oacute;n &quot;b&amp;aacute;sica&quot; del c&amp;oacute;digo, se crea la base de datos, pero en realidad no insertaremos datos:</target>
        </trans-unit>
        <trans-unit id="2dfc837caac3acc0839eec2ba05612c43327300d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Experiment:&lt;/strong&gt; Rather than simply talking about performance tips in the general sense (i.e. &lt;em&gt;&quot;Use a transaction!&quot;&lt;/em&gt;), I thought it best to write some C code and &lt;em&gt;actually measure&lt;/em&gt; the impact of various options. We're going to start with some simple data:</source>
          <target state="translated">&lt;strong&gt;El experimento: en&lt;/strong&gt; lugar de simplemente hablar sobre consejos de rendimiento en el sentido general (es decir, &lt;em&gt;&quot;&amp;iexcl;Use una transacci&amp;oacute;n!&quot;&lt;/em&gt; ), Pens&amp;eacute; que era mejor escribir un c&amp;oacute;digo C y &lt;em&gt;medir&lt;/em&gt; el impacto de varias opciones. Vamos a comenzar con algunos datos simples:</target>
        </trans-unit>
        <trans-unit id="28ff78fa5b07af5d0e3d7492a98d06fe91ed622f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="d11a8e1d536d373238c3435a955657ece24fd305" translate="yes" xml:space="preserve">
          <source>A 28 MB TAB-delimited text file (approximately 865,000 records) of the &lt;a href=&quot;http://www.toronto.ca/open/datasets/ttc-routes&quot;&gt;complete transit schedule for the city of Toronto&lt;/a&gt;</source>
          <target state="translated">Un archivo de texto delimitado por TAB de 28 MB (aproximadamente 865,000 registros) del &lt;a href=&quot;http://www.toronto.ca/open/datasets/ttc-routes&quot;&gt;horario de tr&amp;aacute;nsito completo para la ciudad de Toronto&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a43bd3a7ef7eab400ead152ddcab810fb34cbd0" translate="yes" xml:space="preserve">
          <source>A little slower than the previous optimization at &lt;strong&gt;64,000 inserts per second.&lt;/strong&gt;</source>
          <target state="translated">Un poco m&amp;aacute;s lento que la optimizaci&amp;oacute;n anterior a &lt;strong&gt;64,000 inserciones por segundo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f763d7016e134b7f26a749db3a5f6f6a28b8a9b" translate="yes" xml:space="preserve">
          <source>A slight refactoring to the string processing code used in our parameter binding has allowed us to perform &lt;strong&gt;96,700 inserts per second.&lt;/strong&gt; I think it's safe to say that this is &lt;em&gt;plenty fast&lt;/em&gt;. As we start to tweak other variables (i.e. page size, index creation, etc.) this will be our benchmark.</source>
          <target state="translated">Una ligera refactorizaci&amp;oacute;n del c&amp;oacute;digo de procesamiento de cadenas utilizado en nuestro enlace de par&amp;aacute;metros nos ha permitido realizar &lt;strong&gt;96,700 inserciones por segundo.&lt;/strong&gt; Creo que es seguro decir que esto es &lt;em&gt;bastante r&amp;aacute;pido&lt;/em&gt; . A medida que comencemos a ajustar otras variables (es decir, tama&amp;ntilde;o de p&amp;aacute;gina, creaci&amp;oacute;n de &amp;iacute;ndice, etc.), este ser&amp;aacute; nuestro punto de referencia.</target>
        </trans-unit>
        <trans-unit id="8df6f713ac0e07c6021d93f5e0c15401d3336b1d" translate="yes" xml:space="preserve">
          <source>After reading this tutorial, I tried to implement it to my program.</source>
          <target state="translated">Después de leer este tutorial,intenté implementarlo en mi programa.</target>
        </trans-unit>
        <trans-unit id="ea6e032fcc1739cdfb3de8cd3a6c6dfc44b90167" translate="yes" xml:space="preserve">
          <source>After two weeks of research and checking multiple resources: Hard Drive, Ram, Cache, I found out that some settings on your hard drive can affect the I/O rate. By clicking properties on your desired output drive you can see two options in the general tab. Opt1: Compress this drive, Opt2: Allow files of this drive to have contents indexed.</source>
          <target state="translated">Después de dos semanas de investigación y comprobación de múltiples recursos:Disco Duro,Ram,Cache,descubrí que algunos ajustes en el disco duro pueden afectar la tasa de IO.Al hacer clic en las propiedades de la unidad de salida deseada,puedes ver dos opciones en la pestaña general.Opción 1:Comprimir esta unidad,Opt2:Permitir que los archivos de esta unidad tengan contenidos indexados.</target>
        </trans-unit>
        <trans-unit id="123802917e1e1b5959658891a69eb20a10c75487" translate="yes" xml:space="preserve">
          <source>Also for us, SHAREDCACHE made the performance slower, so I manually put PRIVATECACHE (cause it was enabled globally for us)</source>
          <target state="translated">También para nosotros,SHAREDCACHE hizo que la actuación fuera más lenta,así que puse manualmente PRIVATECACHE (porque se habilitó globalmente para nosotros)</target>
        </trans-unit>
        <trans-unit id="4583ff4050220eaa4631bc21a580cf8fe41b8f3b" translate="yes" xml:space="preserve">
          <source>Although not specifically an SQLite improvement, I don't like the extra &lt;code&gt;char*&lt;/code&gt; assignment operations in the &lt;code&gt;while&lt;/code&gt; loop. Let's quickly refactor that code to pass the output of &lt;code&gt;strtok()&lt;/code&gt; directly into &lt;code&gt;sqlite3_bind_text()&lt;/code&gt;, and let the compiler try to speed things up for us:</source>
          <target state="translated">Aunque no es espec&amp;iacute;ficamente una mejora de SQLite, no me gustan las operaciones adicionales de asignaci&amp;oacute;n de &lt;code&gt;char*&lt;/code&gt; en el ciclo while. Refactoricemos r&amp;aacute;pidamente ese c&amp;oacute;digo para pasar la salida de &lt;code&gt;strtok()&lt;/code&gt; directamente a &lt;code&gt;sqlite3_bind_text()&lt;/code&gt; , y dejemos que el compilador intente acelerar las cosas por nosotros:</target>
        </trans-unit>
        <trans-unit id="26e259678078857d966992a8f6abac77d4d0cd86" translate="yes" xml:space="preserve">
          <source>As expected, bulk-inserts are slower if one column is indexed, but it does make a difference if the index is created after the data is inserted. Our no-index baseline is 96,000 inserts per second. &lt;strong&gt;Creating the index first then inserting data gives us 47,700 inserts per second, whereas inserting the data first then creating the index gives us 63,300 inserts per second.&lt;/strong&gt;</source>
          <target state="translated">Como se esperaba, las inserciones masivas son m&amp;aacute;s lentas si se indexa una columna, pero s&amp;iacute; hace una diferencia si el &amp;iacute;ndice se crea despu&amp;eacute;s de insertar los datos. Nuestra l&amp;iacute;nea de base sin &amp;iacute;ndice es de 96,000 insertos por segundo. &lt;strong&gt;Crear el &amp;iacute;ndice primero y luego insertar datos nos da 47,700 inserciones por segundo, mientras que insertar los datos primero y luego crear el &amp;iacute;ndice nos da 63,300 inserciones por segundo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="087e0edf98958c039e2818a7fb1853f6115bf21c" translate="yes" xml:space="preserve">
          <source>Before we start measuring &lt;code&gt;SELECT&lt;/code&gt; performance, we know that we'll be creating indices. It's been suggested in one of the answers below that when doing bulk inserts, it is faster to create the index after the data has been inserted (as opposed to creating the index first then inserting the data). Let's try:</source>
          <target state="translated">Antes de comenzar a medir el rendimiento de &lt;code&gt;SELECT&lt;/code&gt; , sabemos que crearemos &amp;iacute;ndices. Se ha sugerido en una de las respuestas a continuaci&amp;oacute;n que cuando se realizan inserciones masivas, es m&amp;aacute;s r&amp;aacute;pido crear el &amp;iacute;ndice despu&amp;eacute;s de que se hayan insertado los datos (en lugar de crear el &amp;iacute;ndice primero y luego insertar los datos). Intentemos:</target>
        </trans-unit>
        <trans-unit id="872e67d1abe340cdbf86668e654d983f7d5c9e25" translate="yes" xml:space="preserve">
          <source>Bulk imports seems to perform best if you can chunk your &lt;strong&gt;INSERT/UPDATE&lt;/strong&gt; statements.  A value of 10,000 or so has worked well for me on a table with only a few rows, YMMV...</source>
          <target state="translated">Las importaciones masivas parecen funcionar mejor si puede fragmentar sus &lt;strong&gt;instrucciones INSERT / UPDATE&lt;/strong&gt; . Un valor de aproximadamente 10.000 me ha funcionado bien en una mesa con solo unas pocas filas, YMMV ...</target>
        </trans-unit>
        <trans-unit id="671341a42a7c965624dd8daf9888d2a9ef366288" translate="yes" xml:space="preserve">
          <source>By default, SQLite will evaluate every INSERT / UPDATE statement within a unique transaction. If performing a large number of inserts, it's advisable to wrap your operation in a transaction:</source>
          <target state="translated">Por defecto,SQLite evaluará cada declaración de INSERTAR ACTUALIZACIÓN dentro de una transacción única.Si se realiza un gran número de inserciones,es aconsejable envolver la operación en una transacción:</target>
        </trans-unit>
        <trans-unit id="bbd325acdd91b4ca873182b6a019ce434225ae43" translate="yes" xml:space="preserve">
          <source>By default, SQLite will pause after issuing a OS-level write command. This guarantees that the data is written to the disk. By setting &lt;code&gt;synchronous = OFF&lt;/code&gt;, we are instructing SQLite to simply hand-off the data to the OS for writing and then continue. There's a chance that the database file may become corrupted if the computer suffers a catastrophic crash (or power failure) before the data is written to the platter:</source>
          <target state="translated">Por defecto, SQLite har&amp;aacute; una pausa despu&amp;eacute;s de emitir un comando de escritura a nivel del sistema operativo. Esto garantiza que los datos se escriban en el disco. Al establecer &lt;code&gt;synchronous = OFF&lt;/code&gt; , le estamos ordenando a SQLite que simplemente entregue los datos al sistema operativo para escribir y luego continuar. Existe la posibilidad de que el archivo de la base de datos se corrompa si la computadora sufre un bloqueo catastr&amp;oacute;fico (o falla de energ&amp;iacute;a) antes de que los datos se escriban en la bandeja:</target>
        </trans-unit>
        <trans-unit id="9021172ebb7b79e513f34761501efc24dc16188c" translate="yes" xml:space="preserve">
          <source>By disabling these two options all 3 PCs now take approximately the same time to finish (1hr and 20 to 40min). If you encounter slow inserts check whether your hard drive is configured with these options. It will save you lots of time and headaches trying to find the solution</source>
          <target state="translated">Desactivando estas dos opciones los 3 PCs ahora tardan aproximadamente el mismo tiempo en terminar (1hr y 20 a 40min).Si encuentra inserciones lentas,compruebe si su disco duro está configurado con estas opciones.Le ahorrará mucho tiempo y dolores de cabeza tratando de encontrar la solución</target>
        </trans-unit>
        <trans-unit id="b433a2b1f636acc88cf161d1b849771010a891d6" translate="yes" xml:space="preserve">
          <source>CREATE INDEX then INSERT vs. INSERT then CREATE INDEX</source>
          <target state="translated">CREAR ÍNDICE luego INSERTAR vs.INSERTAR luego CREAR ÍNDICE</target>
        </trans-unit>
        <trans-unit id="3a324f600d2cc2caa3c71c2e0bb04baf34e8a893" translate="yes" xml:space="preserve">
          <source>Call bulkInsert method :</source>
          <target state="translated">Llama al método de inserción masiva:</target>
        </trans-unit>
        <trans-unit id="bcdd9e61da1685f26f0ee4233e52764e50d2bfe3" translate="yes" xml:space="preserve">
          <source>Consider storing the rollback journal in memory by evaluating &lt;code&gt;PRAGMA journal_mode = MEMORY&lt;/code&gt;. Your transaction will be faster, but if you lose power or your program crashes during a transaction you database could be left in a corrupt state with a partially-completed transaction:</source>
          <target state="translated">Considere almacenar el diario de reversi&amp;oacute;n en la memoria evaluando &lt;code&gt;PRAGMA journal_mode = MEMORY&lt;/code&gt; . Su transacci&amp;oacute;n ser&amp;aacute; m&amp;aacute;s r&amp;aacute;pida, pero si pierde energ&amp;iacute;a o su programa se bloquea durante una transacci&amp;oacute;n, su base de datos podr&amp;iacute;a quedar en un estado corrupto con una transacci&amp;oacute;n parcialmente completada:</target>
        </trans-unit>
        <trans-unit id="9f72f2c529b0b1804a0aaf2ee6c8d2facf67621b" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;!feof(file)&lt;/code&gt;!</source>
          <target state="translated">&amp;iexcl;No uses &lt;code&gt;!feof(file)&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="4326aa174e0a3d69e5993b7a70921bb5ff0f2f6e" translate="yes" xml:space="preserve">
          <source>Fantastic! We're able to do &lt;strong&gt;72,000 inserts per second.&lt;/strong&gt;</source>
          <target state="translated">&amp;iexcl;Fant&amp;aacute;stico! Podemos hacer &lt;strong&gt;72,000 inserciones por segundo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bfc83a3f5364bbc68fa36baf227468de56749928" translate="yes" xml:space="preserve">
          <source>First find the items, in the table:</source>
          <target state="translated">Primero encuentra los artículos,en la mesa:</target>
        </trans-unit>
        <trans-unit id="090aa308f4299a2ee89598663268aa093622fa6a" translate="yes" xml:space="preserve">
          <source>For older versions of SQLite - Consider a less paranoid journal mode (&lt;code&gt;pragma journal_mode&lt;/code&gt;). There is &lt;code&gt;NORMAL&lt;/code&gt;, and then there is &lt;code&gt;OFF&lt;/code&gt;, which can significantly increase insert speed if you're not too worried about the database possibly getting corrupted if the OS crashes. If your application crashes the data should be fine. Note that in newer versions, the &lt;code&gt;OFF/MEMORY&lt;/code&gt; settings are not safe for application level crashes.</source>
          <target state="translated">Para versiones anteriores de SQLite: considere un modo de diario menos paranoico ( &lt;code&gt;pragma journal_mode&lt;/code&gt; ). Hay &lt;code&gt;NORMAL&lt;/code&gt; , y luego est&amp;aacute; &lt;code&gt;OFF&lt;/code&gt; , lo que puede aumentar significativamente la velocidad de inserci&amp;oacute;n si no est&amp;aacute; demasiado preocupado por la posibilidad de que la base de datos se corrompa si el sistema operativo falla. Si su aplicaci&amp;oacute;n falla, los datos deber&amp;iacute;an estar bien. Tenga en cuenta que en las versiones m&amp;aacute;s recientes, la configuraci&amp;oacute;n de &lt;code&gt;OFF/MEMORY&lt;/code&gt; no es segura para bloqueos de nivel de aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2195eed65de850d03a01f0bdc090231f2d372a07" translate="yes" xml:space="preserve">
          <source>For our small (200mb) db this made 50-75% speed-up (3.8.0.2 64-bit on Windows 7). Our tables are heavily non-normalized (1000-1500 columns, roughly 100,000 or more rows).</source>
          <target state="translated">Para nuestro pequeño (200mb)db esto hizo 50-75% de aceleración (3.8.0.2 64-bit en Windows 7).Nuestras tablas están muy poco normalizadas (1000-1500 columnas,aproximadamente 100.000 o más filas).</target>
        </trans-unit>
        <trans-unit id="76b075177903579178f27a07d252a978c4cb462b" translate="yes" xml:space="preserve">
          <source>Great! We can do 920,000 inserts per second, provided we don't actually do any inserts :-)</source>
          <target state="translated">¡Grandioso! Podemos hacer 920.000 inserciones por segundo,siempre que no hagamos ninguna inserción :-)</target>
        </trans-unit>
        <trans-unit id="6f22b5c109f71a3ddf56af02c88cbacffcd2a204" translate="yes" xml:space="preserve">
          <source>Here is where your suggestion fails. You use a single transaction for all the records and a single insert with no errors/fails. Let's say that you are splitting each record into multiple inserts on different tables. What happens if the record is broken?</source>
          <target state="translated">Aquí es donde su sugerencia falla.Utiliza una sola transacción para todos los registros y una sola inserción sin errores.Digamos que estás dividiendo cada registro en múltiples inserciones en diferentes tablas.¿Qué sucede si se rompe el registro?</target>
        </trans-unit>
        <trans-unit id="026af1bc2703948250f4b6f33ec6faec09054f5b" translate="yes" xml:space="preserve">
          <source>I coudn't get any gain from transactions until I raised cache_size to a higher value i.e.  &lt;code&gt;PRAGMA cache_size=10000;&lt;/code&gt;</source>
          <target state="translated">No pude obtener ninguna ganancia de las transacciones hasta que aument&amp;eacute; cache_size a un valor m&amp;aacute;s alto, es decir, &lt;code&gt;PRAGMA cache_size=10000;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8eecbe52b4dec4bfb03e25ab1108fd0f15070e96" translate="yes" xml:space="preserve">
          <source>I have 4-5 files that contain addresses. Each file has approx 30 million records. I am using the same configuration that you are suggesting but my number of INSERTs per second is way low (~10.000 records per sec).</source>
          <target state="translated">Tengo 4-5 archivos que contienen direcciones.Cada archivo tiene aproximadamente 30 millones de registros.Estoy usando la misma configuración que estás sugiriendo,pero mi número de INSERTOS por segundo es muy bajo (~10.000 registros por segundo).</target>
        </trans-unit>
        <trans-unit id="11917b0c226929497af8ba620faa1e4b102c1e64" translate="yes" xml:space="preserve">
          <source>I'd gladly take suggestions for other scenarios to try... And will be compiling similar data for SELECT queries soon.</source>
          <target state="translated">Con gusto aceptaría sugerencias para otros escenarios para intentar......y pronto recopilaré datos similares para las consultas de SELECT.</target>
        </trans-unit>
        <trans-unit id="5172e4b2cd07b7be64b179445d83376ec1008f29" translate="yes" xml:space="preserve">
          <source>I'm using it in production code where I frequently need to import large datasets, and I'm pretty happy with it.</source>
          <target state="translated">Lo estoy usando en código de producción donde frecuentemente necesito importar grandes conjuntos de datos,y estoy bastante contento con ello.</target>
        </trans-unit>
        <trans-unit id="3ac5e5ce6fc4a6695514c6dae964ca288c928cef" translate="yes" xml:space="preserve">
          <source>I'm using the SQLite &quot;Amalgamation&quot;, compiled directly into my test application. The SQLite version I happen to have is a bit older (3.6.7), but I suspect these results will be comparable to the latest release (please leave a comment if you think otherwise).</source>
          <target state="translated">Estoy usando la &quot;Amalgama&quot; de SQLite,compilada directamente en mi aplicación de prueba.La versión de SQLite que tengo es un poco más antigua (3.6.7),pero sospecho que estos resultados serán comparables a los de la última versión (por favor,deje un comentario si piensa lo contrario).</target>
        </trans-unit>
        <trans-unit id="46f70793f4a5cfd620882059cb0f77361cfd03c5" translate="yes" xml:space="preserve">
          <source>I've also asked similar questions &lt;a href=&quot;https://stackoverflow.com/questions/784173/what-are-the-performance-characteristics-of-sqlite-with-very-large-database-files&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/768708/are-there-known-issues-with-using-sqlite-and-file-locking-on-different-platforms&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n he hecho preguntas similares &lt;a href=&quot;https://stackoverflow.com/questions/784173/what-are-the-performance-characteristics-of-sqlite-with-very-large-database-files&quot;&gt;aqu&amp;iacute;&lt;/a&gt; y &lt;a href=&quot;https://stackoverflow.com/questions/768708/are-there-known-issues-with-using-sqlite-and-file-locking-on-different-platforms&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfe5fd5527d0cb852bc797c4c3ee406f746ecc8c" translate="yes" xml:space="preserve">
          <source>If anyone has any other ideas on how to speed it up, I am open to suggestions.</source>
          <target state="translated">Si alguien tiene alguna otra idea de cómo acelerarlo,estoy abierto a sugerencias.</target>
        </trans-unit>
        <trans-unit id="7d973398e85df8aa77d57e79abb3b81143a022d7" translate="yes" xml:space="preserve">
          <source>If you are using multiple threads, you can try using the &lt;a href=&quot;http://sqlite.org/c3ref/enable_shared_cache.html&quot;&gt;shared page cache&lt;/a&gt;, which will allow loaded pages to be shared between threads, which can avoid expensive I/O calls.</source>
          <target state="translated">Si est&amp;aacute; utilizando varios subprocesos, puede intentar usar la &lt;a href=&quot;http://sqlite.org/c3ref/enable_shared_cache.html&quot;&gt;memoria cach&amp;eacute; de p&amp;aacute;gina compartida&lt;/a&gt; , lo que permitir&amp;aacute; que las p&amp;aacute;ginas cargadas se compartan entre subprocesos, lo que puede evitar costosas llamadas de E / S.</target>
        </trans-unit>
        <trans-unit id="9909caa1776cc754ea391a5613c40fbd59f9912b" translate="yes" xml:space="preserve">
          <source>If you care only about reading, somewhat faster (but might read stale data) version is to read from multiple connections from multiple threads (connection per-thread).</source>
          <target state="translated">Si sólo te preocupa la lectura,una versión algo más rápida (pero que podría leer datos obsoletos)es la de leer de múltiples conexiones de múltiples hilos (conexión por hilo).</target>
        </trans-unit>
        <trans-unit id="0b5e37f7ae64ee540105a2d6879bb33438066595" translate="yes" xml:space="preserve">
          <source>If you have indices, consider calling &lt;code&gt;CREATE INDEX&lt;/code&gt; after doing all your inserts. This is significantly faster than creating the index and then doing your inserts.</source>
          <target state="translated">Si tiene &amp;iacute;ndices, considere llamar a &lt;code&gt;CREATE INDEX&lt;/code&gt; despu&amp;eacute;s de hacer todas sus inserciones. Esto es significativamente m&amp;aacute;s r&amp;aacute;pido que crear el &amp;iacute;ndice y luego hacer sus inserciones.</target>
        </trans-unit>
        <trans-unit id="050d6cf06387f361bcb1b0a00b8117a50e73b6db" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 0.94
  seconds</source>
          <target state="translated">Importó 864913 registros en 0,94 segundos</target>
        </trans-unit>
        <trans-unit id="ffb4f30cad268801a7084f86177635a7739c17eb" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 10.94
  seconds</source>
          <target state="translated">Importó 864913 registros en 10,94 segundos</target>
        </trans-unit>
        <trans-unit id="ad66121de714d2631e9f96a8c355fd562e17c3d9" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 12.00
  seconds</source>
          <target state="translated">Importó 864913 registros en 12.00 segundos</target>
        </trans-unit>
        <trans-unit id="7581475071859f0e2df5c5baa78a47d7b29eb343" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 12.41
  seconds</source>
          <target state="translated">Importó 864913 registros en 12,41 segundos</target>
        </trans-unit>
        <trans-unit id="1fb6a8f5771eb996d9c96dec9c9972b1f7a9e674" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 13.50
  seconds</source>
          <target state="translated">Importó 864913 registros en 13,50 segundos</target>
        </trans-unit>
        <trans-unit id="d736e88540c433cf8f1e9c878c95b8f56e1ea201" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 13.66
  seconds</source>
          <target state="translated">Importó 864913 registros en 13,66 segundos</target>
        </trans-unit>
        <trans-unit id="9cf20009ccbdebfe12b3df7ef0636a31ba57d3da" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 16.27
  seconds</source>
          <target state="translated">Importó 864913 registros en 16,27 segundos</target>
        </trans-unit>
        <trans-unit id="8df99d63ed560901211f5c08656f730de84694b0" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 18.13
  seconds</source>
          <target state="translated">Importó 864913 registros en 18,13 segundos</target>
        </trans-unit>
        <trans-unit id="1c548ea621ed72950e828c5b68b12bf11f6ff451" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 38.03
  seconds</source>
          <target state="translated">Importó 864913 registros en 38,03 segundos</target>
        </trans-unit>
        <trans-unit id="154309e441b9898bacf87ed35cc90b6b605fec43" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 8.94
  seconds</source>
          <target state="translated">Importó 864913 registros en 8,94 segundos</target>
        </trans-unit>
        <trans-unit id="e912b781943a231d89776110872a3ee052f22c58" translate="yes" xml:space="preserve">
          <source>Imported 864913 records in 9933.61
  seconds</source>
          <target state="translated">Importó 864913 registros en 9933,61 segundos</target>
        </trans-unit>
        <trans-unit id="5c0542021a1c71e3d1128b2a31c3b68cde8950f7" translate="yes" xml:space="preserve">
          <source>Improve INSERT-per-second performance of SQLite</source>
          <target state="translated">Mejorar el rendimiento de INSERTAR-por-segundo de SQLite</target>
        </trans-unit>
        <trans-unit id="437377a502bface456863ef3ef3ca4aa7c7b5e37" translate="yes" xml:space="preserve">
          <source>In Addition to my answer above, you should keep in mind that inserts per second depending on the hard drive you are using too. I tested it on 3 different PCs with different hard drives and got massive differences in times. PC1 (1hr 30m), PC2 (6hrs) PC3 (14hrs), so I started wondering why would that be.</source>
          <target state="translated">Además de mi respuesta anterior,debe tener en cuenta que las inserciones por segundo dependen del disco duro que esté usando también.Lo probé en 3 PC diferentes con diferentes discos duros y obtuve diferencias masivas en los tiempos.PC1 (1hr 30m),PC2 (6hrs)PC3 (14hrs),así que empecé a preguntarme por qué sería eso.</target>
        </trans-unit>
        <trans-unit id="084c1b49fd936281f7874c2b66922cccc3363366" translate="yes" xml:space="preserve">
          <source>Inspired by this post and by the Stack Overflow question that led me here -- &lt;a href=&quot;https://stackoverflow.com/questions/1609637/is-it-possible-to-insert-multiple-rows-at-a-time-in-an-sqlite-database&quot;&gt;Is it possible to insert multiple rows at a time in an SQLite database?&lt;/a&gt; -- I've posted my first &lt;a href=&quot;http://en.wikipedia.org/wiki/Git_%28software%29&quot;&gt;Git&lt;/a&gt; repository:</source>
          <target state="translated">Inspirado en esta publicaci&amp;oacute;n y en la pregunta de desbordamiento de pila que me llev&amp;oacute; aqu&amp;iacute;: &lt;a href=&quot;https://stackoverflow.com/questions/1609637/is-it-possible-to-insert-multiple-rows-at-a-time-in-an-sqlite-database&quot;&gt;&amp;iquest;es posible insertar varias filas a la vez en una base de datos SQLite?&lt;/a&gt; - Publiqu&amp;eacute; mi primer repositorio de &lt;a href=&quot;http://en.wikipedia.org/wiki/Git_%28software%29&quot;&gt;Git&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c680b9c6bf7b7bee16783907b9286d2edf9090e1" translate="yes" xml:space="preserve">
          <source>It's not super-practical to store our database in RAM, but it's impressive that we can perform &lt;strong&gt;79,000 inserts per second.&lt;/strong&gt;</source>
          <target state="translated">No es muy pr&amp;aacute;ctico almacenar nuestra base de datos en RAM, pero es impresionante que podamos realizar &lt;strong&gt;79,000 inserciones por segundo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a48a72fa6f2a189900ebabff54aef564cc57e5d1" translate="yes" xml:space="preserve">
          <source>Just for kicks, let's build upon all of the previous optimizations and redefine the database filename so we're working entirely in RAM:</source>
          <target state="translated">Sólo por diversión,construyamos sobre todas las optimizaciones anteriores y redefinamos el nombre del archivo de la base de datos para que trabajemos completamente en la RAM:</target>
        </trans-unit>
        <trans-unit id="def03dbbcc838f12adc51dd0a6831295811e8a51" translate="yes" xml:space="preserve">
          <source>Let's combine the previous two optimizations. It's a little more risky (in case of a crash), but we're just importing data (not running a bank):</source>
          <target state="translated">Combinemos las dos optimizaciones anteriores.Es un poco más arriesgado (en caso de accidente),pero sólo estamos importando datos (no dirigiendo un banco):</target>
        </trans-unit>
        <trans-unit id="fff50fdf32382d53297912d58830059c40882d48" translate="yes" xml:space="preserve">
          <source>Link: &lt;a href=&quot;https://www.vogella.com/tutorials/AndroidSQLite/article.html&quot;&gt;https://www.vogella.com/tutorials/AndroidSQLite/article.html&lt;/a&gt;
check Using ContentProvider Section for more details</source>
          <target state="translated">Enlace: &lt;a href=&quot;https://www.vogella.com/tutorials/AndroidSQLite/article.html&quot;&gt;https://www.vogella.com/tutorials/AndroidSQLite/article.html&lt;/a&gt; consulte Uso de la secci&amp;oacute;n ContentProvider para obtener m&amp;aacute;s detalles</target>
        </trans-unit>
        <trans-unit id="cef93c612411b122f72e46695577441dc0b9538a" translate="yes" xml:space="preserve">
          <source>More detail: &lt;a href=&quot;http://www.hoogli.com/blogs/micro/index.html#Avoid_sqlite3_clear_bindings%28%29&quot;&gt;Avoid_sqlite3_clear_bindings()&lt;/a&gt;</source>
          <target state="translated">M&amp;aacute;s detalles: &lt;a href=&quot;http://www.hoogli.com/blogs/micro/index.html#Avoid_sqlite3_clear_bindings%28%29&quot;&gt;Evite_sqlite3_clear_bindings ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd6066b18d7c77401d867d16f3862c393664eb4f" translate="yes" xml:space="preserve">
          <source>My solution was to use &lt;strong&gt;multiple&lt;/strong&gt; transactions. I begin and end a transaction every 10.000 records (Don't ask why that number, it was the fastest one I tested). I created an array sized 10.000 and insert the successful records there. When the error occurs, I do a rollback, begin a transaction, insert the records from my array, commit and then begin a new transaction after the broken record.</source>
          <target state="translated">Mi soluci&amp;oacute;n fue usar &lt;strong&gt;m&amp;uacute;ltiples&lt;/strong&gt; transacciones. Comienzo y finalizo una transacci&amp;oacute;n cada 10.000 registros (no pregunte por qu&amp;eacute; ese n&amp;uacute;mero, fue el m&amp;aacute;s r&amp;aacute;pido que prob&amp;eacute;). Cre&amp;eacute; una matriz de 10.000 e inserto los registros exitosos all&amp;iacute;. Cuando se produce el error, hago una reversi&amp;oacute;n, comienzo una transacci&amp;oacute;n, inserto los registros de mi matriz, me comprometo y luego comienzo una nueva transacci&amp;oacute;n despu&amp;eacute;s del registro roto.</target>
        </trans-unit>
        <trans-unit id="6b739c10e74293364ba0d24439f65294b7e5a99a" translate="yes" xml:space="preserve">
          <source>My test machine is a 3.60 GHz P4 running Windows XP.</source>
          <target state="translated">Mi máquina de pruebas es una P4 de 3.60 GHz con Windows XP.</target>
        </trans-unit>
        <trans-unit id="725b0e5796b8baedf9846345cfd466c118fc41d9" translate="yes" xml:space="preserve">
          <source>Nice! There's a little bit more code (don't forget to call &lt;code&gt;sqlite3_clear_bindings&lt;/code&gt; and &lt;code&gt;sqlite3_reset&lt;/code&gt;), but we've more than doubled our performance to &lt;strong&gt;53,000 inserts per second.&lt;/strong&gt;</source>
          <target state="translated">&amp;iexcl;Agradable! Hay un poco m&amp;aacute;s de c&amp;oacute;digo (no olvide llamar a &lt;code&gt;sqlite3_clear_bindings&lt;/code&gt; y &lt;code&gt;sqlite3_reset&lt;/code&gt; ), pero hemos m&amp;aacute;s que duplicado nuestro rendimiento a &lt;strong&gt;53,000 inserciones por segundo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71cb481da4769935c7cb6729efb5b6f47e162d66" translate="yes" xml:space="preserve">
          <source>On bulk inserts</source>
          <target state="translated">En los insertos a granel</target>
        </trans-unit>
        <trans-unit id="23976e24ccb5c88d260af95f9f2b0d95e8f2c905" translate="yes" xml:space="preserve">
          <source>Optimizing SQLite is tricky. Bulk-insert performance of a C application can vary from 85 inserts per second to over 96,000 inserts per second!</source>
          <target state="translated">La optimización de SQLite es difícil.El rendimiento de las inserciones de una aplicación C puede variar desde 85 inserciones por segundo hasta más de 96.000 inserciones por segundo.</target>
        </trans-unit>
        <trans-unit id="b15b2b66aeaf59f9d4af467b7dce9e1e809af568" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_mode = MEMORY</source>
          <target state="translated">PRAGMA log_mode=MEMORIA</target>
        </trans-unit>
        <trans-unit id="03a9d7f69c55c2b9bb13076c851bb0c196528d38" translate="yes" xml:space="preserve">
          <source>PRAGMA synchronous = OFF</source>
          <target state="translated">PRAGMA síncrono=OFF</target>
        </trans-unit>
        <trans-unit id="e1c75641cd03f3af313aee27467012f92b04b104" translate="yes" xml:space="preserve">
          <source>PRAGMA synchronous = OFF &lt;em&gt;and&lt;/em&gt; PRAGMA journal_mode = MEMORY</source>
          <target state="translated">PRAGMA s&amp;iacute;ncrono = APAGADO &lt;em&gt;y&lt;/em&gt; PRAGMA journal_mode = MEMORIA</target>
        </trans-unit>
        <trans-unit id="847bfcdea40fa982b77f7b8713d9d1c6b544bfb7" translate="yes" xml:space="preserve">
          <source>Playing with page sizes makes a difference as well (&lt;code&gt;PRAGMA page_size&lt;/code&gt;). Having larger page sizes can make reads and writes go a bit faster as larger pages are held in memory. Note that more memory will be used for your database.</source>
          <target state="translated">Jugar con tama&amp;ntilde;os de p&amp;aacute;gina tambi&amp;eacute;n hace la diferencia (tama&amp;ntilde;o de p&amp;aacute;gina &lt;code&gt;PRAGMA page_size&lt;/code&gt; ). Tener tama&amp;ntilde;os de p&amp;aacute;gina m&amp;aacute;s grandes puede hacer que las lecturas y escrituras sean un poco m&amp;aacute;s r&amp;aacute;pidas a medida que las p&amp;aacute;ginas m&amp;aacute;s grandes se guardan en la memoria. Tenga en cuenta que se usar&amp;aacute; m&amp;aacute;s memoria para su base de datos.</target>
        </trans-unit>
        <trans-unit id="e22067ebafc73b20c18e9861a705da211f5109b2" translate="yes" xml:space="preserve">
          <source>Prior to calling &lt;a href=&quot;https://www.sqlite.org/c3ref/step.html&quot;&gt;sqlite3_step()&lt;/a&gt; for the first time or immediately
  after &lt;a href=&quot;https://www.sqlite.org/c3ref/reset.html&quot;&gt;sqlite3_reset()&lt;/a&gt;, the application can invoke the
  &lt;a href=&quot;https://www.sqlite.org/c3ref/bind_blob.html&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces to attach values to the parameters. Each
  call to &lt;a href=&quot;https://www.sqlite.org/c3ref/bind_blob.html&quot;&gt;sqlite3_bind()&lt;/a&gt; overrides prior bindings on the same parameter</source>
          <target state="translated">Antes de llamar a &lt;a href=&quot;https://www.sqlite.org/c3ref/step.html&quot;&gt;sqlite3_step ()&lt;/a&gt; por primera vez o inmediatamente despu&amp;eacute;s de &lt;a href=&quot;https://www.sqlite.org/c3ref/reset.html&quot;&gt;sqlite3_reset ()&lt;/a&gt; , la aplicaci&amp;oacute;n puede invocar las interfaces &lt;a href=&quot;https://www.sqlite.org/c3ref/bind_blob.html&quot;&gt;sqlite3_bind ()&lt;/a&gt; para adjuntar valores a los par&amp;aacute;metros. Cada llamada a &lt;a href=&quot;https://www.sqlite.org/c3ref/bind_blob.html&quot;&gt;sqlite3_bind ()&lt;/a&gt; anula los enlaces anteriores en el mismo par&amp;aacute;metro</target>
        </trans-unit>
        <trans-unit id="d1dc6289bf46af7ecb10109083938ec233b12f44" translate="yes" xml:space="preserve">
          <source>Put inserts/updates in a transaction.</source>
          <target state="translated">Poner inserciones-actualizaciones en una transacción.</target>
        </trans-unit>
        <trans-unit id="9d00bcd205db77802eec1f76d0bfc2a4e82e6fe2" translate="yes" xml:space="preserve">
          <source>Refactoring C Code</source>
          <target state="translated">Refactorización Código C</target>
        </trans-unit>
        <trans-unit id="b25e791003c46490e0166b007c32a101c17271c5" translate="yes" xml:space="preserve">
          <source>Running the code as-is doesn't actually perform any database operations, but it will give us an idea of how fast the raw C file I/O and string processing operations are.</source>
          <target state="translated">Ejecutar el código tal cual no realiza ninguna operación en la base de datos,pero nos dará una idea de lo rápido que son las operaciones de IO y de procesamiento de cadenas del archivo C en bruto.</target>
        </trans-unit>
        <trans-unit id="7801bb5ecd32d8d6426f3434d9102bfe5f65316d" translate="yes" xml:space="preserve">
          <source>Several tips:</source>
          <target state="translated">Varios consejos:</target>
        </trans-unit>
        <trans-unit id="bf198eba07fea151a8fb44062f5cf968092033e2" translate="yes" xml:space="preserve">
          <source>So here is where the rollback comes. The only issue with the rollback is that you lose all your inserts and start from the top. How can you solve this?</source>
          <target state="translated">Así que aquí es donde viene el retroceso.El único problema con el retroceso es que pierdes todas las plantillas y empiezas desde arriba.¿Cómo puedes resolver esto?</target>
        </trans-unit>
        <trans-unit id="db1afd310be73362aa7fb7a0a2c83f7cc9be9db1" translate="yes" xml:space="preserve">
          <source>Summary (so far)</source>
          <target state="translated">Resumen (hasta ahora)</target>
        </trans-unit>
        <trans-unit id="fda992cd350165c2f1d88bde9d7d98e92fe66347" translate="yes" xml:space="preserve">
          <source>Take advantage of saving space...smaller databases go faster. For instance, if you have key value pairs, try making the key an &lt;code&gt;INTEGER PRIMARY KEY&lt;/code&gt; if possible, which will replace the implied unique row number column in the table.</source>
          <target state="translated">Aproveche el ahorro de espacio ... las bases de datos m&amp;aacute;s peque&amp;ntilde;as van m&amp;aacute;s r&amp;aacute;pido. Por ejemplo, si tiene pares de valores clave, intente convertir la clave en una &lt;code&gt;INTEGER PRIMARY KEY&lt;/code&gt; si es posible, lo que reemplazar&amp;aacute; la columna del n&amp;uacute;mero de fila &amp;uacute;nico impl&amp;iacute;cito en la tabla.</target>
        </trans-unit>
        <trans-unit id="c6c60bb2b9aa2a9dcf08905210c5336ed8ba1be0" translate="yes" xml:space="preserve">
          <source>That's better. Simply wrapping all of our inserts in a single transaction improved our performance to &lt;strong&gt;23,000 inserts per second.&lt;/strong&gt;</source>
          <target state="translated">Eso es mejor. Simplemente envolviendo todos nuestros insertos en una sola transacci&amp;oacute;n mejor&amp;oacute; nuestro rendimiento a &lt;strong&gt;23,000 insertos por segundo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="017b6041e5e97ed016693e8cbc3c4c24484ab010" translate="yes" xml:space="preserve">
          <source>The &quot;Control&quot;</source>
          <target state="translated">El &quot;Control&quot;</target>
        </trans-unit>
        <trans-unit id="88cbff81bd98a7e52e52c7d398a52f2faba9c9c8" translate="yes" xml:space="preserve">
          <source>The &quot;Worst-Case-Scenario&quot;</source>
          <target state="translated">El &quot;peor de los casos&quot;</target>
        </trans-unit>
        <trans-unit id="508178fc7a6c1685a9ce3f25f29c50b86c817345" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.sqlite.org/cintro.html&quot;&gt;C API intro&lt;/a&gt; from the SQLite docs says:</source>
          <target state="translated">La &lt;a href=&quot;https://www.sqlite.org/cintro.html&quot;&gt;introducci&amp;oacute;n&lt;/a&gt; de C API de los documentos de SQLite dice:</target>
        </trans-unit>
        <trans-unit id="38372a1525b1bf61a2f5f0cc1ddbbf17915e0784" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT command does not apply, cause if you have 10 elements in a record and you need each element inserted to a different table, if element 5 gets a CONSTRAINT error, then all previous 4 inserts need to go too.</source>
          <target state="translated">El comando ON CONFLICT no se aplica,porque si tienes 10 elementos en un registro y necesitas que cada elemento se inserte en una tabla diferente,si el elemento 5 obtiene un error de CONSTRAINT,entonces las 4 inserciones anteriores tienen que ir también.</target>
        </trans-unit>
        <trans-unit id="8ea1fabbe4633c8d4db54d4c842da90c9441b97d" translate="yes" xml:space="preserve">
          <source>The algorithm I created helped me reduce my process by 2 hours. Final loading process of file 1hr 30m which is still slow but not compared to the 4hrs that it initially took. I managed to speed the inserts from 10.000/s to ~14.000/s</source>
          <target state="translated">El algoritmo que creé me ayudó a reducir mi proceso en 2 horas.El proceso de carga final del archivo 1hr 30m que sigue siendo lento pero no comparado con las 4hrs que tomó inicialmente.Me las arreglé para acelerar las inserciones de 10.000s a ~14.000s</target>
        </trans-unit>
        <trans-unit id="9f26c58828cd1c833c02f45b4f92100c4d5ab702" translate="yes" xml:space="preserve">
          <source>The answer to your question is that the newer SQLite&amp;nbsp;3 has improved performance, use that.</source>
          <target state="translated">La respuesta a su pregunta es que el nuevo SQLite 3 ha mejorado el rendimiento, &amp;uacute;selo.</target>
        </trans-unit>
        <trans-unit id="3987d3dbe6e66d288d9494f0c4a889acd57d2876" translate="yes" xml:space="preserve">
          <source>The code in the test sets the bindings every time through which should be enough.</source>
          <target state="translated">El código en la prueba establece los enlaces cada vez a través de los cuales debería ser suficiente.</target>
        </trans-unit>
        <trans-unit id="03189b3c8c0eb7bf3b9cf95a8e187e585d96d60f" translate="yes" xml:space="preserve">
          <source>The code is compiled with &lt;a href=&quot;http://en.wikipedia.org/wiki/Visual_C%2B%2B#32-bit_versions&quot;&gt;Visual C++&lt;/a&gt; 2005 as &quot;Release&quot; with &quot;Full Optimization&quot; (/Ox) and Favor Fast Code (/Ot).</source>
          <target state="translated">El c&amp;oacute;digo se compila con &lt;a href=&quot;http://en.wikipedia.org/wiki/Visual_C%2B%2B#32-bit_versions&quot;&gt;Visual C ++&lt;/a&gt; 2005 como &quot;Release&quot; con &quot;Optimizaci&amp;oacute;n completa&quot; (/ Ox) y Favorece el c&amp;oacute;digo r&amp;aacute;pido (/ Ot).</target>
        </trans-unit>
        <trans-unit id="0ea5d284cecee101861f152c707c71f8fd74f317" translate="yes" xml:space="preserve">
          <source>The improvements are now smaller, but we're up to &lt;strong&gt;69,600 inserts per second.&lt;/strong&gt;</source>
          <target state="translated">Las mejoras ahora son m&amp;aacute;s peque&amp;ntilde;as, pero tenemos hasta &lt;strong&gt;69,600 inserciones por segundo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be2689c857db56817bdb470b056a287c52a2e0c0" translate="yes" xml:space="preserve">
          <source>There is nothing in the docs for &lt;a href=&quot;https://www.sqlite.org/c3ref/clear_bindings.html&quot;&gt;&lt;code&gt;sqlite3_clear_bindings&lt;/code&gt;&lt;/a&gt; saying you must call it in addition to simply setting the bindings.</source>
          <target state="translated">No hay nada en los documentos para &lt;a href=&quot;https://www.sqlite.org/c3ref/clear_bindings.html&quot;&gt; &lt;code&gt;sqlite3_clear_bindings&lt;/code&gt; que&lt;/a&gt; diga que debe llamarlo adem&amp;aacute;s de simplemente establecer los enlaces.</target>
        </trans-unit>
        <trans-unit id="bf20f7e886b3170f117100780131fac01a688cee" translate="yes" xml:space="preserve">
          <source>This answer &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11769366/why-is-sqlalchemy-insert-with-sqlite-25-times-slower-than-using-sqlite3-directly/11769768#11769768&quot;&gt;Why is SQLAlchemy insert with sqlite 25 times slower than using sqlite3 directly?&lt;/a&gt;&lt;/em&gt; by SqlAlchemy Orm Author has 100k inserts in 0.5 sec, and I have seen similar results with python-sqlite and SqlAlchemy. Which leads me to believe that performance has improved with SQLite&amp;nbsp;3.</source>
          <target state="translated">Esta respuesta &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11769366/why-is-sqlalchemy-insert-with-sqlite-25-times-slower-than-using-sqlite3-directly/11769768#11769768&quot;&gt;&amp;iquest;Por qu&amp;eacute; la inserci&amp;oacute;n SQLAlchemy con sqlite es 25 veces m&amp;aacute;s lenta que usar sqlite3 directamente?&lt;/a&gt;&lt;/em&gt; por SqlAlchemy Orm Author tiene 100k inserciones en 0.5 segundos, y he visto resultados similares con python-sqlite y SqlAlchemy. Lo que me lleva a creer que el rendimiento ha mejorado con SQLite 3.</target>
        </trans-unit>
        <trans-unit id="c6adca7440b2ae1858c40b313a78614c3cd32177" translate="yes" xml:space="preserve">
          <source>This is going to be slow because the SQL will be compiled into VDBE code for every insert and every insert will happen in its own transaction. &lt;em&gt;How slow?&lt;/em&gt;</source>
          <target state="translated">Esto va a ser lento porque el SQL se compilar&amp;aacute; en el c&amp;oacute;digo VDBE para cada inserci&amp;oacute;n y cada inserci&amp;oacute;n ocurrir&amp;aacute; en su propia transacci&amp;oacute;n. &lt;em&gt;Que lento&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db63715f64683425fd01f5904246eab4178b65d8" translate="yes" xml:space="preserve">
          <source>This solution helped me bypass the issues I have when dealing with files containing bad/duplicate records (I had almost 4% bad records).</source>
          <target state="translated">Esta solución me ayudó a evitar los problemas que tengo al tratar con archivos que contienen registros mal duplicados (tenía casi un 4% de registros malos).</target>
        </trans-unit>
        <trans-unit id="ed7f88668556c34e922129040d0b4cb1fff93abd" translate="yes" xml:space="preserve">
          <source>Too many or too little threads won't do it, you need to benchmark and profile yourself.</source>
          <target state="translated">Demasiados o muy pocos hilos no lo harán,necesitas hacer un análisis comparativo y un perfil de ti mismo.</target>
        </trans-unit>
        <trans-unit id="5e1b2a6b6d80f8d0e183b885c337e18d7f131c6e" translate="yes" xml:space="preserve">
          <source>Try using &lt;code&gt;SQLITE_STATIC&lt;/code&gt; instead of &lt;code&gt;SQLITE_TRANSIENT&lt;/code&gt; for those inserts.</source>
          <target state="translated">Intente usar &lt;code&gt;SQLITE_STATIC&lt;/code&gt; en lugar de &lt;code&gt;SQLITE_TRANSIENT&lt;/code&gt; para esas inserciones.</target>
        </trans-unit>
        <trans-unit id="054498b4ab93a63c9779fb5e4449fc342376cebb" translate="yes" xml:space="preserve">
          <source>Use ContentProvider for inserting the bulk data in db.
The below method used for inserting bulk data in to database. This should Improve INSERT-per-second performance of SQLite.</source>
          <target state="translated">Use ContentProvider para insertar los datos de la masa en db.El siguiente método se utiliza para insertar los datos a granel en la base de datos.Esto debería mejorar el rendimiento de INSERTAR por segundo de SQLite.</target>
        </trans-unit>
        <trans-unit id="86258bb2c189f1c4b45a4e393182d5e6be34a275" translate="yes" xml:space="preserve">
          <source>Using a Prepared Statement</source>
          <target state="translated">Usando una declaración preparada</target>
        </trans-unit>
        <trans-unit id="27bfc98a791c846a44ceefffbe8088440beb0489" translate="yes" xml:space="preserve">
          <source>Using a Transaction</source>
          <target state="translated">Usando una transacción</target>
        </trans-unit>
        <trans-unit id="efa798e2337da1f597bb94d66f1cd12d1cc78d2f" translate="yes" xml:space="preserve">
          <source>Using a transaction was a huge improvement, but recompiling the SQL statement for every insert doesn't make sense if we using the same SQL over-and-over. Let's use &lt;code&gt;sqlite3_prepare_v2&lt;/code&gt; to compile our SQL statement once and then bind our parameters to that statement using &lt;code&gt;sqlite3_bind_text&lt;/code&gt;:</source>
          <target state="translated">El uso de una transacci&amp;oacute;n fue una gran mejora, pero recompilar la instrucci&amp;oacute;n SQL para cada inserci&amp;oacute;n no tiene sentido si usamos el mismo SQL una y otra vez. &lt;code&gt;sqlite3_prepare_v2&lt;/code&gt; para compilar nuestra declaraci&amp;oacute;n SQL una vez y luego vincule nuestros par&amp;aacute;metros a esa declaraci&amp;oacute;n usando &lt;code&gt;sqlite3_bind_text&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="674be12a68db41f5e65e8f6f5288f5307643a49c" translate="yes" xml:space="preserve">
          <source>Using an In-Memory Database</source>
          <target state="translated">Uso de una base de datos en memoria</target>
        </trans-unit>
        <trans-unit id="a989490dc1086fbe60acc040f2077ee40bc910a4" translate="yes" xml:space="preserve">
          <source>We're going to generate the SQL string using the values read from the file and invoke that SQL operation using sqlite3_exec:</source>
          <target state="translated">Vamos a generar la cadena SQL usando los valores leídos del archivo e invocaremos esa operación SQL usando sqlite3_exec:</target>
        </trans-unit>
        <trans-unit id="51a38e71a882481707d999fc28f7f0fcdeaf78ba" translate="yes" xml:space="preserve">
          <source>Yikes! 2 hours and 45 minutes! That's only &lt;strong&gt;85 inserts per second.&lt;/strong&gt;</source>
          <target state="translated">&amp;iexcl;Ay! &amp;iexcl;2 horas y 45 minutos! Eso es solo &lt;strong&gt;85 inserciones por segundo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cc4e57454f2e22aeb719d5949b1a38ae2ba3ce02" translate="yes" xml:space="preserve">
          <source>You have to be quite careful if you have concurrent access to SQLite, as the whole database is locked when writes are done, and although multiple readers are possible, writes will be locked out. This has been improved somewhat with the addition of a WAL in newer SQLite versions.</source>
          <target state="translated">Hay que tener mucho cuidado si se tiene acceso simultáneo a SQLite,ya que toda la base de datos se bloquea cuando se realizan las escrituras,y aunque es posible tener varios lectores,las escrituras se bloquearán.Esto se ha mejorado un poco con la adición de un WAL en las nuevas versiones de SQLite.</target>
        </trans-unit>
        <trans-unit id="f84952b103a6b1fa35391ad802ceb45691b6a3c4" translate="yes" xml:space="preserve">
          <source>for each thread:</source>
          <target state="translated">para cada hilo:</target>
        </trans-unit>
        <trans-unit id="718651ac1e4d28eed11decc1cc7b263cdac1558f" translate="yes" xml:space="preserve">
          <source>then read in pages (LIMIT/OFFSET):</source>
          <target state="translated">y luego leer en páginas (LIMITOFFSET):</target>
        </trans-unit>
        <trans-unit id="779e8933edaa2a8b59f69f6c48510a0f1a6cf67a" translate="yes" xml:space="preserve">
          <source>where  and  are calculated per-thread, like this:</source>
          <target state="translated">donde y se calculan por hilo,así:</target>
        </trans-unit>
        <trans-unit id="f4c7bc63d48e550900e1d3bed8080e1b721d1e85" translate="yes" xml:space="preserve">
          <source>which bulk loads an array of ActiveRecords into &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQL&quot;&gt;MySQL&lt;/a&gt;, SQLite or &lt;a href=&quot;http://en.wikipedia.org/wiki/PostgreSQL&quot;&gt;PostgreSQL&lt;/a&gt; databases. It includes an option to ignore existing records, overwrite them or raise an error. My rudimentary benchmarks show a 10x speed improvement compared to sequential writes -- YMMV.</source>
          <target state="translated">que carga masivamente una matriz de ActiveRecords en &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQL&quot;&gt;bases de&lt;/a&gt; datos MySQL , SQLite o &lt;a href=&quot;http://en.wikipedia.org/wiki/PostgreSQL&quot;&gt;PostgreSQL&lt;/a&gt; . Incluye una opci&amp;oacute;n para ignorar los registros existentes, sobrescribirlos o generar un error. Mis puntos de referencia rudimentarios muestran una mejora de velocidad de 10 veces en comparaci&amp;oacute;n con las escrituras secuenciales: YMMV.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
