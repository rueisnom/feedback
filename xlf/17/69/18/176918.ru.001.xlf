<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/176918">
    <body>
      <group id="176918">
        <trans-unit id="2948baef786870af8190d83cfb43d62137ad18ca" translate="yes" xml:space="preserve">
          <source>(Note: Here we are iterating using i to get the indexes, but if we need rather to focus on the items we can switch to j.)</source>
          <target state="translated">(Заметка:Здесь мы выполняем итерацию,используя i для получения индексов,но если нам нужно сконцентрироваться на элементах,мы можем переключиться на j).</target>
        </trans-unit>
        <trans-unit id="66299ebbecf7817df5176612979c8ac917033572" translate="yes" xml:space="preserve">
          <source>... like confirming the existence of the item before getting the index.  The nice thing about this approach is the function always returns a list of indices -- even if it is an empty list.  It works with strings as well.</source>
          <target state="translated">...как подтверждение существования предмета до получения индекса.Приятно,что функция всегда возвращает список индексов-даже если это пустой список.Она работает и со строками.</target>
        </trans-unit>
        <trans-unit id="134741840ad6b457f1871651f6e0da9f89505a3a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/a&gt; is a third-party library with tools to locate &lt;em&gt;multiple&lt;/em&gt; indices within an iterable.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt; &lt;code&gt;more_itertools&lt;/code&gt; &lt;/a&gt; - сторонняя библиотека с инструментами для поиска &lt;em&gt;нескольких&lt;/em&gt; индексов внутри итерируемого.</target>
        </trans-unit>
        <trans-unit id="82f08a023bee2ebc787ac15b0a3b1a5bd3141b10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index()&lt;/code&gt; returns the &lt;strong&gt;first&lt;/strong&gt; index of value!</source>
          <target state="translated">&lt;code&gt;index()&lt;/code&gt; возвращает &lt;strong&gt;первый&lt;/strong&gt; индекс значения!</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6607830e66ad80aa66ee0fb7977558ee0e94c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Given&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Given&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d12b121dd20db5c6fbdbda026bff85f6c3142492" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4854c643745651c59985c121976968eecde5e2ae" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;index&lt;/code&gt; results in a &lt;a href=&quot;https://docs.python.org/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if the item's not present.</source>
          <target state="translated">При обращении к &lt;code&gt;index&lt;/code&gt; возникает &lt;a href=&quot;https://docs.python.org/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; если элемент отсутствует.</target>
        </trans-unit>
        <trans-unit id="5ccf855ab58a5f7fb7979cad7580b6e22927f1e5" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;index&lt;/code&gt; searches through the list in order until it finds a match, and &lt;em&gt;stops there.&lt;/em&gt; If you expect to need indices of more matches, you should use a list comprehension, or generator expression.</source>
          <target state="translated">Вызов &lt;code&gt;index&lt;/code&gt; выполняет поиск в списке по порядку, пока не найдет совпадение и не &lt;em&gt;остановится на этом.&lt;/em&gt; Если вы ожидаете, что вам понадобятся индексы большего числа совпадений, вы должны использовать понимание списка или выражение генератора.</target>
        </trans-unit>
        <trans-unit id="aff4787b1edd1bd62e26a67ff0ce689898e30aa2" translate="yes" xml:space="preserve">
          <source>A comparison check will return a series of booleans:</source>
          <target state="translated">Проверка сравнения вернет серию булеонов:</target>
        </trans-unit>
        <trans-unit id="138baba7813f3759b9ca9d7e92c7d65b1bc857ca" translate="yes" xml:space="preserve">
          <source>A problem will arise if the element is not in the list. This function handles the issue:</source>
          <target state="translated">Если элемента нет в списке,возникнет проблема.Эта функция обрабатывает проблему:</target>
        </trans-unit>
        <trans-unit id="b8e635c9d99261fbe9f8c404fda7e105a7dea459" translate="yes" xml:space="preserve">
          <source>A variant on the answer from FMc and user7177 will give a dict that can return all indices for any entry:</source>
          <target state="translated">Вариант ответа с FMc и user7177 даст диктат,который может вернуть все индексы для любой записи:</target>
        </trans-unit>
        <trans-unit id="493f8b764877784751bb03986b351785842ab5f4" translate="yes" xml:space="preserve">
          <source>After another year of heads-down python development, I'm a bit embarrassed by my original answer, so to set the record straight, one can certainly use the above code; however, the &lt;em&gt;much&lt;/em&gt; more idiomatic way to get the same behavior would be to use list comprehension, along with the enumerate() function.</source>
          <target state="translated">После еще одного года бездумной разработки Python я немного смутился из-за своего первоначального ответа, так что для ясности можно использовать приведенный выше код; тем не менее, &lt;em&gt;гораздо&lt;/em&gt; более идиоматическим способом получить такое же поведение было бы использование понимания списка вместе с функцией enumerate ().</target>
        </trans-unit>
        <trans-unit id="783400a3f5b8f986154b3e2a17daf29f18a7b8f5" translate="yes" xml:space="preserve">
          <source>All indexes with the &lt;a href=&quot;https://docs.python.org/2/library/functions.html#zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Все индексы с функцией &lt;a href=&quot;https://docs.python.org/2/library/functions.html#zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="224f7aafadbfc2e2042598dd5316150dbfba5063" translate="yes" xml:space="preserve">
          <source>All of the proposed functions here reproduce inherent language behavior but obscure what's going on.</source>
          <target state="translated">Все предложенные здесь функции воспроизводят врожденное языковое поведение,но затушевывают происходящее.</target>
        </trans-unit>
        <trans-unit id="c899cdecca241309c182b8884734252d7de4e8c9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;index&lt;/code&gt; call checks every element of the list in order, until it finds a match. If your list is long, and you don't know roughly where in the list it occurs, this search could become a bottleneck. In that case, you should consider a different data structure. Note that if you know roughly where to find the match, you can give &lt;code&gt;index&lt;/code&gt; a hint. For instance, in this snippet, &lt;code&gt;l.index(999_999, 999_990, 1_000_000)&lt;/code&gt; is roughly five orders of magnitude faster than straight &lt;code&gt;l.index(999_999)&lt;/code&gt;, because the former only has to search 10 entries, while the latter searches a million:</source>
          <target state="translated">Вызов &lt;code&gt;index&lt;/code&gt; проверяет каждый элемент списка по порядку, пока не найдет совпадение. Если ваш список длинный и вы не знаете, где именно он находится, этот поиск может стать узким местом. В этом случае вы должны рассмотреть другую структуру данных. Обратите внимание, что если вы точно знаете, где найти совпадение, вы можете дать &lt;code&gt;index&lt;/code&gt; подсказке. Например, в этом фрагменте &lt;code&gt;l.index(999_999, 999_990, 1_000_000)&lt;/code&gt; примерно на пять порядков быстрее, чем прямой &lt;code&gt;l.index(999_999)&lt;/code&gt; , поскольку первый должен искать только 10 записей, а второй ищет миллион:</target>
        </trans-unit>
        <trans-unit id="f7eae91daa1d639943d459b3dbbc10cfa58431f5" translate="yes" xml:space="preserve">
          <source>And if you want them in a list or tuple, just pass them to the constructor:</source>
          <target state="translated">И если вы хотите,чтобы они были в списке или кортеже,просто передайте их конструктору:</target>
        </trans-unit>
        <trans-unit id="86e445a2158f8dd6cfa820ebb209aac73c1e5ccd" translate="yes" xml:space="preserve">
          <source>And now, after reviewing this question and all the answers, I realize that this is exactly what &lt;a href=&quot;https://stackoverflow.com/users/55857/fmc&quot;&gt;FMc&lt;/a&gt; suggested in his &lt;a href=&quot;https://stackoverflow.com/questions/176918/finding-the-index-of-an-item-given-a-list-containing-it-in-python/17300987#17300987&quot;&gt;earlier answer&lt;/a&gt;.  At the time I originally answered this question, I didn't even &lt;em&gt;see&lt;/em&gt; that answer, because I didn't understand it.  I hope that my somewhat more verbose example will aid understanding.</source>
          <target state="translated">И теперь, после рассмотрения этого вопроса и всех ответов, я понимаю, что именно это &lt;a href=&quot;https://stackoverflow.com/users/55857/fmc&quot;&gt;FMC&lt;/a&gt; предложил в своем &lt;a href=&quot;https://stackoverflow.com/questions/176918/finding-the-index-of-an-item-given-a-list-containing-it-in-python/17300987#17300987&quot;&gt;предыдущем ответе&lt;/a&gt; . В то время, когда я первоначально отвечал на этот вопрос, я даже не &lt;em&gt;видел&lt;/em&gt; этого ответа, потому что я не понимал его. Я надеюсь, что мой более подробный пример поможет понять.</target>
        </trans-unit>
        <trans-unit id="cabff39d8a2cb29ffd40a559aba15983bc0b5ded" translate="yes" xml:space="preserve">
          <source>And now, for something completely different...</source>
          <target state="translated">А теперь,для чего-то совершенно другого...</target>
        </trans-unit>
        <trans-unit id="34b2d2db99fc3c8db7a0b00fe55eb1adac107b96" translate="yes" xml:space="preserve">
          <source>And the downside of this is that you will probably have a check for if the returned value &lt;code&gt;is&lt;/code&gt; or &lt;code&gt;is not&lt;/code&gt; None:</source>
          <target state="translated">И недостатком этого является то, что вы, вероятно, будете проверять, является ли возвращаемое значение None:</target>
        </trans-unit>
        <trans-unit id="58a7124e04e8fb36f38515e8703fec6da46cd2d6" translate="yes" xml:space="preserve">
          <source>And use it like this:</source>
          <target state="translated">И используй его вот так:</target>
        </trans-unit>
        <trans-unit id="90e38a5e7a649b7c9940934affa211cd085be8a6" translate="yes" xml:space="preserve">
          <source>Another option</source>
          <target state="translated">Другой вариант</target>
        </trans-unit>
        <trans-unit id="e7ee18e7126a05ddfe444abe07b014e8864747fc" translate="yes" xml:space="preserve">
          <source>As a list comprehension:</source>
          <target state="translated">В качестве понимания списка:</target>
        </trans-unit>
        <trans-unit id="26ab018b67cb7ad280c6fa077b17af69fa564147" translate="yes" xml:space="preserve">
          <source>As indicated by @TerryA, many answers discuss how to find &lt;em&gt;one&lt;/em&gt; index.</source>
          <target state="translated">Как указывает @TerryA, многие ответы обсуждают, как найти &lt;em&gt;один&lt;/em&gt; индекс.</target>
        </trans-unit>
        <trans-unit id="7fc1f4d493aaab0be5262d781a08bb9525bc6081" translate="yes" xml:space="preserve">
          <source>Better data munging with pandas</source>
          <target state="translated">Улучшение информационного обеспечения с помощью панд</target>
        </trans-unit>
        <trans-unit id="4a61ff86e696d36fc80e2eac1c63c19d03b769e3" translate="yes" xml:space="preserve">
          <source>Caveats follow</source>
          <target state="translated">Пещеры следуют</target>
        </trans-unit>
        <trans-unit id="81d49b7f1eab63248cfe4be2a400e7c1b2f247cd" translate="yes" xml:space="preserve">
          <source>Check for it first with &lt;code&gt;item in my_list&lt;/code&gt; (clean, readable approach), or</source>
          <target state="translated">Сначала проверьте его с помощью &lt;code&gt;item in my_list&lt;/code&gt; (чистый, читабельный подход) или</target>
        </trans-unit>
        <trans-unit id="dcb72c18d397544038d81fcd4eb972a16e34d477" translate="yes" xml:space="preserve">
          <source>Find indices of multiple observations:</source>
          <target state="translated">Поиск индексов множественных наблюдений:</target>
        </trans-unit>
        <trans-unit id="5a3294db39d81a64ac4f6e8556ffc977f34dc714" translate="yes" xml:space="preserve">
          <source>Finding index of item x in list L:</source>
          <target state="translated">Поиск индекса пункта x в списке L:</target>
        </trans-unit>
        <trans-unit id="23e13cc3bff692365dfdb0e9e6068472f329a7a8" translate="yes" xml:space="preserve">
          <source>Finding the index of an item given a list containing it in Python</source>
          <target state="translated">Поиск индекса элемента списка,содержащего его на Python</target>
        </trans-unit>
        <trans-unit id="a44ef4465f839a6c49b3cf7c8be2838f115dee0f" translate="yes" xml:space="preserve">
          <source>Finding the index of an item in a list</source>
          <target state="translated">Поиск индекса элемента списка</target>
        </trans-unit>
        <trans-unit id="da07c5158f5d72ce13082d2f3b173ba41b16c672" translate="yes" xml:space="preserve">
          <source>For a list &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&lt;/code&gt; and an item in the list &lt;code&gt;&quot;bar&quot;&lt;/code&gt;, what's the cleanest way to get its index (1) in Python?</source>
          <target state="translated">Для списка &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&lt;/code&gt; и элемента в списке &lt;code&gt;&quot;bar&quot;&lt;/code&gt; , каков самый чистый способ получить его индекс (1) в Python?</target>
        </trans-unit>
        <trans-unit id="def524d82886b7d7f470d7a5c0bde3396e87b73a" translate="yes" xml:space="preserve">
          <source>For those coming from another language like me, maybe with a simple loop it's easier to understand and use it:</source>
          <target state="translated">Для тех,кто пришел с другого языка,как я,может быть,с помощью простого цикла легче понять и использовать его:</target>
        </trans-unit>
        <trans-unit id="02a53e5e1980cadf894222cd6e9f944742e7f03c" translate="yes" xml:space="preserve">
          <source>Getting all the occurrences and the position of one or more (identical) items in a list</source>
          <target state="translated">Получение всех вхождений и положения одного или нескольких (идентичных)пунктов в списке</target>
        </trans-unit>
        <trans-unit id="aa722a193799b7775f3b4d62943a0b760505a1c6" translate="yes" xml:space="preserve">
          <source>Given a list &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&lt;/code&gt; and an item in the list &lt;code&gt;&quot;bar&quot;&lt;/code&gt;, how do I get its index (&lt;code&gt;1&lt;/code&gt;) in Python?</source>
          <target state="translated">Учитывая список &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&lt;/code&gt; и элемент в списке &lt;code&gt;&quot;bar&quot;&lt;/code&gt; , как мне получить его индекс ( &lt;code&gt;1&lt;/code&gt; ) в Python?</target>
        </trans-unit>
        <trans-unit id="737107fd42248382bdf1fa923988b9ca029e7587" translate="yes" xml:space="preserve">
          <source>Here is an example of code using Python 3.8 and above syntax:</source>
          <target state="translated">Приведем пример кода,использующего синтаксис Python 3.8 и выше:</target>
        </trans-unit>
        <trans-unit id="a9a9b00bbdafcc2e9de8e4d4d330120c2d0d52c7" translate="yes" xml:space="preserve">
          <source>Here's also another small solution with &lt;a href=&quot;http://docs.python.org/library/itertools.html#itertools.count&quot;&gt;&lt;code&gt;itertools.count()&lt;/code&gt;&lt;/a&gt; (which is pretty much the same approach as enumerate):</source>
          <target state="translated">Вот еще одно небольшое решение с &lt;a href=&quot;http://docs.python.org/library/itertools.html#itertools.count&quot;&gt; &lt;code&gt;itertools.count()&lt;/code&gt; &lt;/a&gt; (которое в значительной степени совпадает с перечислением):</target>
        </trans-unit>
        <trans-unit id="01713b2f32ef2f970dbe3d6c62c59c3a4bede755" translate="yes" xml:space="preserve">
          <source>I am thankful for &lt;em&gt;&lt;a href=&quot;https://www.codecademy.com/en/forum_questions/5087f2d786a27b02000041a9&quot;&gt;So what exactly does enumerate do?&lt;/a&gt;&lt;/em&gt;. That helped me to understand.</source>
          <target state="translated">Я благодарен за &lt;em&gt;&lt;a href=&quot;https://www.codecademy.com/en/forum_questions/5087f2d786a27b02000041a9&quot;&gt;то, что именно перечисляет делать?&lt;/a&gt;&lt;/em&gt; , Это помогло мне понять.</target>
        </trans-unit>
        <trans-unit id="203da802a1f01f22eb2311502acef8849c93ba53" translate="yes" xml:space="preserve">
          <source>I do not recall needing &lt;code&gt;list.index&lt;/code&gt;, myself. However, I have looked through the Python standard library, and I see some excellent uses for it.</source>
          <target state="translated">Я не помню, чтобы мне был нужен &lt;code&gt;list.index&lt;/code&gt; . Тем не менее, я просмотрел стандартную библиотеку Python и вижу некоторые отличные варианты ее использования.</target>
        </trans-unit>
        <trans-unit id="948ae31c04ed122f8baa060d7e539757bf14a1d9" translate="yes" xml:space="preserve">
          <source>I'm usually iterating over the list anyways, so I'll usually keep a pointer to any interesting information, getting the &lt;a href=&quot;https://stackoverflow.com/q/522563/541136&quot;&gt;index with enumerate.&lt;/a&gt;</source>
          <target state="translated">В любом случае я обычно перебираю список, поэтому я обычно держу указатель на любую интересную информацию, получая &lt;a href=&quot;https://stackoverflow.com/q/522563/541136&quot;&gt;индекс с перечислением.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e734fda17824d47900b08e14372d48e0a9aeb365" translate="yes" xml:space="preserve">
          <source>If performance is of concern:</source>
          <target state="translated">Если производительность вызывает беспокойство:</target>
        </trans-unit>
        <trans-unit id="4f342de31e5fe70628440252039a22e41dd9a379" translate="yes" xml:space="preserve">
          <source>If the item might not be present in the list, you should either</source>
          <target state="translated">Если пункт может отсутствовать в списке,вы также должны</target>
        </trans-unit>
        <trans-unit id="d779cd816c85fb2f652fece6ede9b6fa5c5bacde" translate="yes" xml:space="preserve">
          <source>If the single line of code above still &lt;em&gt;doesn't&lt;/em&gt; make sense to you, I highly recommend you Google 'python list comprehension' and take a few minutes to familiarize yourself.  It's just one of the many powerful features that make it a joy to use Python to develop code.</source>
          <target state="translated">Если приведенная выше строка кода по-прежнему &lt;em&gt;не&lt;/em&gt; имеет смысла для вас, я настоятельно рекомендую вам &amp;laquo;понимание списков Python&amp;raquo; в Google и потратьте несколько минут на ознакомление. Это всего лишь одна из многих мощных функций, которые позволяют использовать Python для разработки кода.</target>
        </trans-unit>
        <trans-unit id="8f9fc72d83ef92d4e4de63383003079554ab5b84" translate="yes" xml:space="preserve">
          <source>If the value could be missing, you need to catch the &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="translated">Если значение может отсутствовать, вам нужно перехватить &lt;code&gt;ValueError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88d3340a656a30b1b41d121ca23ce804b41f4393" translate="yes" xml:space="preserve">
          <source>If the value isn't there, catching the &lt;code&gt;ValueError&lt;/code&gt; is rather verbose - and I prefer to avoid that.</source>
          <target state="translated">Если значение отсутствует, &lt;code&gt;ValueError&lt;/code&gt; довольно многословен, и я предпочитаю этого избегать.</target>
        </trans-unit>
        <trans-unit id="11e8dbae6f026cf70d8c2be2393b89a7d5b95a88" translate="yes" xml:space="preserve">
          <source>If you already know the value, why do you care where it is in a list?</source>
          <target state="translated">Если вы уже знаете ценность,почему вас волнует,где она находится в списке?</target>
        </trans-unit>
        <trans-unit id="b716a532cf74eab7c9f9f93764d519eec7b07b44" translate="yes" xml:space="preserve">
          <source>If you are going to find an index once then using &quot;index&quot; method is fine. However, if you are going to search your data more than once then I recommend using &lt;a href=&quot;https://docs.python.org/3/library/bisect.html&quot;&gt;bisect&lt;/a&gt; module. Keep in mind that using bisect module data must be sorted. So you sort data once and then you can use bisect.
Using &lt;a href=&quot;https://docs.python.org/3/library/bisect.html&quot;&gt;bisect&lt;/a&gt; module on my machine is about 20 times faster than using index method.</source>
          <target state="translated">Если вы собираетесь найти индекс один раз, тогда лучше использовать метод &amp;laquo;index&amp;raquo;. Однако, если вы собираетесь искать данные более одного раза, я рекомендую использовать модуль &lt;a href=&quot;https://docs.python.org/3/library/bisect.html&quot;&gt;bisect&lt;/a&gt; . Имейте в виду, что при использовании модуля bisect данные должны быть отсортированы. Таким образом, вы сортируете данные один раз, а затем можете использовать bisect. Использование модуля &lt;a href=&quot;https://docs.python.org/3/library/bisect.html&quot;&gt;bisect&lt;/a&gt; на моей машине примерно в 20 раз быстрее, чем при использовании метода index.</target>
        </trans-unit>
        <trans-unit id="5111bbb16b848de1e5dde35abc94e35a55c4a147" translate="yes" xml:space="preserve">
          <source>If you are sure that the items in your list are never repeated, you can easily:</source>
          <target state="translated">Если вы уверены,что элементы в вашем списке никогда не повторяются,вы можете легко:</target>
        </trans-unit>
        <trans-unit id="0cf5368fcdd44e4e20f42c0311a74e7b36f316c2" translate="yes" xml:space="preserve">
          <source>If you could have more occurrences, you'll &lt;strong&gt;not&lt;/strong&gt; get complete information with &lt;code&gt;list.index&lt;/code&gt;:</source>
          <target state="translated">Если бы вы могли иметь больше случаев, вы &lt;strong&gt;не&lt;/strong&gt; получите полную информацию с &lt;code&gt;list.index&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2bdde82f45391223710a247ef47b48fdaa1b7720" translate="yes" xml:space="preserve">
          <source>If you have no occurrences, you can check for that with boolean check of the result, or just do nothing if you loop over the results:</source>
          <target state="translated">Если у вас нет никаких вхождений,вы можете проверить это с помощью булевой проверки результата,или просто ничего не делать,если вы зацикливаете результаты:</target>
        </trans-unit>
        <trans-unit id="d4fe6fd03bfef26fd984a85874f9d638081c358d" translate="yes" xml:space="preserve">
          <source>If you have pandas, you can easily get this information with a Series object:</source>
          <target state="translated">Если у вас есть панды,вы можете легко получить эту информацию с помощью объекта Series:</target>
        </trans-unit>
        <trans-unit id="8ac98452bfa9442260e6b099ea10959b162018f4" translate="yes" xml:space="preserve">
          <source>If you may have duplicate elements, and need to return all of their indices:</source>
          <target state="translated">Если у вас есть дубликаты элементов,и вам нужно вернуть все их индексы:</target>
        </trans-unit>
        <trans-unit id="0739b51b2e7a6565b9e6493164c5956a765c3416" translate="yes" xml:space="preserve">
          <source>If you want all indexes, then you can use &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt;:</source>
          <target state="translated">Если вы хотите все индексы, то вы можете использовать &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ec27bad5ad2902ce92beaf7225be35ebefad8ffa" translate="yes" xml:space="preserve">
          <source>If you want just the indexes, the index attribute returns a series of integers:</source>
          <target state="translated">Если вам нужны только индексы,атрибут индекса возвращает ряд целых чисел:</target>
        </trans-unit>
        <trans-unit id="ec779073cf49a8d2c48920f0ea4ad6bb4931e68c" translate="yes" xml:space="preserve">
          <source>If you're munging data, you should probably be using pandas - which has far more elegant tools than the pure Python workarounds I've shown.</source>
          <target state="translated">Если вы занимаетесь обработкой данных,вам,наверное,стоит использовать панд,у которых гораздо более элегантные инструменты,чем у чистого питоновского обходного пути,который я показал.</target>
        </trans-unit>
        <trans-unit id="d5828c228aa1a6a533c392ac9513f724add63fe1" translate="yes" xml:space="preserve">
          <source>In Lib/http/cookiejar.py, seems to be used to get the next month:</source>
          <target state="translated">В Libhttpcookiejar.py,похоже,привыкли получать следующий месяц:</target>
        </trans-unit>
        <trans-unit id="041c63df7f78dfeb43c93260479759baf277d6d6" translate="yes" xml:space="preserve">
          <source>In Lib/mailbox.py it seems to be using it like an ordered mapping:</source>
          <target state="translated">В Libmailbox.py он,кажется,использует его как упорядоченную карту:</target>
        </trans-unit>
        <trans-unit id="00464d6b045eb7a0a40085474aa324598613c2b4" translate="yes" xml:space="preserve">
          <source>In Lib/pickletools.py:</source>
          <target state="translated">В Libpickletools.py:</target>
        </trans-unit>
        <trans-unit id="3204cca49e7efd3262f18a65aaa6960ce42a1670" translate="yes" xml:space="preserve">
          <source>In Lib/tarfile.py similar to distutils to get a slice up to an item:</source>
          <target state="translated">В Libtarfile.py это похоже на дистилляторы,чтобы достать кусочек до предмета:</target>
        </trans-unit>
        <trans-unit id="7ff77d5616cfab3adfdf19beff92b26e894d934f" translate="yes" xml:space="preserve">
          <source>Is this an &lt;a href=&quot;https://meta.stackexchange.com/a/66378/239121&quot;&gt;XY problem&lt;/a&gt;?</source>
          <target state="translated">Это &lt;a href=&quot;https://meta.stackexchange.com/a/66378/239121&quot;&gt;проблема XY&lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="282473616c11628dd6bad06a1adae26405ccdf85" translate="yes" xml:space="preserve">
          <source>It is clear, readable solution.</source>
          <target state="translated">Это ясное,читаемое решение.</target>
        </trans-unit>
        <trans-unit id="9d7afe81fe620fd3e92a00ed6eba8eb6fbcb10c7" translate="yes" xml:space="preserve">
          <source>It is mentioned in numerous answers that the built-in method of &lt;code&gt;list.index(item)&lt;/code&gt; method is an O(n) algorithm. It is fine if you need to perform this once. But if you need to access the indices of elements a number of times, it makes more sense to first create a dictionary (O(n)) of item-index pairs, and then access the index at O(1) every time you need it.</source>
          <target state="translated">В многочисленных ответах упоминается, что встроенный метод метода &lt;code&gt;list.index(item)&lt;/code&gt; является алгоритмом O (n). Это хорошо, если вам нужно выполнить это один раз. Но если вам нужно получить доступ к индексам элементов несколько раз, имеет смысл сначала создать словарь (O (n)) пар элементов-индексов, а затем обращаться к индексу в O (1) каждый раз, когда вам нужно Это.</target>
        </trans-unit>
        <trans-unit id="aeb13e8d213fbc96efaecdacc753eda7b589e73f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give the name &lt;code&gt;lst&lt;/code&gt; to the list that you have. One can convert the list &lt;code&gt;lst&lt;/code&gt; to a &lt;code&gt;numpy array&lt;/code&gt;. And, then use &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.where.html&quot;&gt;numpy.where&lt;/a&gt; to get the index of the chosen item in the list. Following is the way in which you will implement it.</source>
          <target state="translated">Давайте дадим имя &lt;code&gt;lst&lt;/code&gt; списку, который у вас есть. Можно преобразовать список &lt;code&gt;lst&lt;/code&gt; в &lt;code&gt;numpy array&lt;/code&gt; . А затем используйте &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.where.html&quot;&gt;numpy.where,&lt;/a&gt; чтобы получить индекс выбранного элемента в списке. Следующее - способ, которым вы будете это реализовывать.</target>
        </trans-unit>
        <trans-unit id="2081446ef7932108a0edd67d245fdd048f21a794" translate="yes" xml:space="preserve">
          <source>Let's make our function findindex</source>
          <target state="translated">Давайте сделаем так,что наша функция найдётся.</target>
        </trans-unit>
        <trans-unit id="a1f47b01540e61f942a796561a3b436133a34b00" translate="yes" xml:space="preserve">
          <source>Linear time-complexity in list length</source>
          <target state="translated">Линейная временная сложность по длине списка</target>
        </trans-unit>
        <trans-unit id="1359ef88586d9fe27b15c241f11623fc2258c6ad" translate="yes" xml:space="preserve">
          <source>More generic form:</source>
          <target state="translated">Более общая форма:</target>
        </trans-unit>
        <trans-unit id="83987e0a527d72f195324546e24dc4cc2b933602" translate="yes" xml:space="preserve">
          <source>More than one value in the list</source>
          <target state="translated">Более одного значения в списке</target>
        </trans-unit>
        <trans-unit id="6572550452d24b19c33815cd172b47811aa154db" translate="yes" xml:space="preserve">
          <source>Most places where I once would have used &lt;code&gt;index&lt;/code&gt;, I now use a list comprehension or generator expression because they're more generalizable. So if you're considering reaching for &lt;code&gt;index&lt;/code&gt;, take a look at these excellent Python features.</source>
          <target state="translated">В большинстве мест, где я когда-то использовал &lt;code&gt;index&lt;/code&gt; , я теперь использую списочное понимание или выражение генератора, потому что они более обобщаемы. Так что, если вы планируете достичь &lt;code&gt;index&lt;/code&gt; , взгляните на эти отличные возможности Python.</target>
        </trans-unit>
        <trans-unit id="6bd5a5d5c3c36f1891fc2d9066b714b4c88a3d46" translate="yes" xml:space="preserve">
          <source>No values</source>
          <target state="translated">Нет значений</target>
        </trans-unit>
        <trans-unit id="d1be3a4e9f0fcaac509766c5565988066d8b33e0" translate="yes" xml:space="preserve">
          <source>Note that while this is perhaps the cleanest way to answer the question &lt;em&gt;as asked&lt;/em&gt;, &lt;code&gt;index&lt;/code&gt; is a rather weak component of the &lt;code&gt;list&lt;/code&gt; API, and I can't remember the last time I used it in anger. It's been pointed out to me in the comments that because this answer is heavily referenced, it should be made more complete. Some caveats about &lt;code&gt;list.index&lt;/code&gt; follow. It is probably worth initially taking a look at the documentation for it:</source>
          <target state="translated">Обратите внимание, что хотя это, пожалуй, самый простой способ ответить на заданный &lt;em&gt;вопрос&lt;/em&gt; , &lt;code&gt;index&lt;/code&gt; является довольно слабым компонентом API &lt;code&gt;list&lt;/code&gt; , и я не могу вспомнить, когда в последний раз использовал его в гневе. Мне было отмечено в комментариях, что, поскольку на этот ответ часто ссылаются, его следует сделать более полным. &lt;code&gt;list.index&lt;/code&gt; следуют некоторые предостережения о list.index . Вероятно, стоит сначала взглянуть на документацию:</target>
        </trans-unit>
        <trans-unit id="a5b4066da2daa8720e525383af982d673bc2f9eb" translate="yes" xml:space="preserve">
          <source>One thing that is really helpful in learning Python is to use the interactive help function:</source>
          <target state="translated">Одна вещь,которая действительно полезна для изучения Python,-это использование интерактивной функции помощи:</target>
        </trans-unit>
        <trans-unit id="b55b6bea121061ceb81a7ee22a7772006f6e03ba" translate="yes" xml:space="preserve">
          <source>Only returns the index of the &lt;em&gt;first match&lt;/em&gt; to its argument</source>
          <target state="translated">Возвращает только индекс &lt;em&gt;первого соответствия&lt;/em&gt; своему аргументу</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="10e129969381f29fb9fe97f9d2e11962aa9ba45c" translate="yes" xml:space="preserve">
          <source>Pass that series of booleans to the series via subscript notation, and you get just the matching members:</source>
          <target state="translated">Передайте эту серию булеонов в серию через нотацию подписки,и вы получите только подходящие участники:</target>
        </trans-unit>
        <trans-unit id="c84ae2073776c46da2404f57fbc0c1d7c36730a3" translate="yes" xml:space="preserve">
          <source>Python &lt;code&gt;index()&lt;/code&gt; method throws an error if the item was not found. So instead you can make it similar to the &lt;code&gt;indexOf()&lt;/code&gt; function of JavaScript which returns &lt;code&gt;-1&lt;/code&gt; if the item was not found:</source>
          <target state="translated">Метод Python &lt;code&gt;index()&lt;/code&gt; выдает ошибку, если элемент не был найден. Таким образом, вместо этого вы можете сделать его похожим на &lt;code&gt;indexOf()&lt;/code&gt; JavaScript, которая возвращает &lt;code&gt;-1&lt;/code&gt; , если элемент не был найден:</target>
        </trans-unit>
        <trans-unit id="c5184966eda7a6fa1b21fa046f105ad1697f5e45" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://docs.python.org/tutorial/datastructures.html#more-on-lists&quot;&gt;Data Structures &amp;gt; More on Lists&lt;/a&gt;</source>
          <target state="translated">Справка: &lt;a href=&quot;https://docs.python.org/tutorial/datastructures.html#more-on-lists&quot;&gt;Структуры данных&amp;gt; Подробнее о списках&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49254481d1f23e380481e095e5d315533692e882" translate="yes" xml:space="preserve">
          <source>Return zero-based index in the list of the first item whose value is equal to &lt;em&gt;x&lt;/em&gt;. Raises a &lt;a href=&quot;https://docs.python.org/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if there is no such item.</source>
          <target state="translated">Вернуть нулевой индекс в списке первого элемента, значение которого равно &lt;em&gt;x&lt;/em&gt; . Вызывает &lt;a href=&quot;https://docs.python.org/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; если такого элемента нет.</target>
        </trans-unit>
        <trans-unit id="d2833bbff6d0d9cb8e124557809e3869860afc23" translate="yes" xml:space="preserve">
          <source>See also more options with &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.locate&quot;&gt;&lt;code&gt;more_itertools.locate&lt;/code&gt;&lt;/a&gt;.  Install via &lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Смотрите также больше опций с &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.locate&quot;&gt; &lt;code&gt;more_itertools.locate&lt;/code&gt; &lt;/a&gt; . Установить через &lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt; &lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de72ea9e60d3b0389fb7873c1d21268b088fa6d4" translate="yes" xml:space="preserve">
          <source>Simple</source>
          <target state="translated">Simple</target>
        </trans-unit>
        <trans-unit id="5f19a099f5daf4cba2f285ede196b8c8dcc971e5" translate="yes" xml:space="preserve">
          <source>Simply you can go with</source>
          <target state="translated">Просто ты можешь пойти с</target>
        </trans-unit>
        <trans-unit id="6a619efbec29e8228fb95db390a95faa0c3c06e8" translate="yes" xml:space="preserve">
          <source>Since Python lists are zero-based, we can use the zip built-in function as follows:</source>
          <target state="translated">Так как списки на Python основаны на нулях,мы можем использовать встроенную функцию zip следующим образом:</target>
        </trans-unit>
        <trans-unit id="0a8c9cecf78e1520d6f30aa06c477eda5abb1c29" translate="yes" xml:space="preserve">
          <source>Something like this:</source>
          <target state="translated">Что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="b7676ae6a860f704f1361d69d71911590b4294a1" translate="yes" xml:space="preserve">
          <source>Test multiple items:</source>
          <target state="translated">Тестировать несколько пунктов:</target>
        </trans-unit>
        <trans-unit id="c00b9915c4af1c0e3e761b8424b3dc5d41dd0e3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index()&lt;/code&gt; function only returns the first occurrence, while &lt;code&gt;enumerate()&lt;/code&gt; returns all occurrences.</source>
          <target state="translated">Функция &lt;code&gt;index()&lt;/code&gt; возвращает только первое вхождение, а &lt;code&gt;enumerate()&lt;/code&gt; возвращает все вхождения.</target>
        </trans-unit>
        <trans-unit id="533af82c7985e1e1da68be39a0be7100be17afe5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keyword&lt;/code&gt; module uses it to find comment markers in the module to automatically regenerate the list of keywords in it via metaprogramming.</source>
          <target state="translated">Модуль &lt;code&gt;keyword&lt;/code&gt; использует его для поиска маркеров комментариев в модуле, чтобы автоматически восстановить список ключевых слов в нем с помощью метапрограммирования.</target>
        </trans-unit>
        <trans-unit id="3705fe105cc047980a555a111f24244cddb92242" translate="yes" xml:space="preserve">
          <source>The XY problem is asking about your attempted solution rather than your actual problem.</source>
          <target state="translated">Проблема XY заключается в том,что вы спрашиваете о вашем попытке решения,а не о реальной проблеме.</target>
        </trans-unit>
        <trans-unit id="7cdb977223c9fd664b610a847cd9ce874cc698ac" translate="yes" xml:space="preserve">
          <source>The majority of answers explain how to find &lt;strong&gt;a single index&lt;/strong&gt;, but their methods do not return multiple indexes if the item is in the list multiple times. Use &lt;a href=&quot;https://docs.python.org/library/functions.html#enumerate&quot;&gt;&lt;code&gt;enumerate()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Большинство ответов объясняют, как найти &lt;strong&gt;один индекс&lt;/strong&gt; , но их методы не возвращают несколько индексов, если элемент находится в списке несколько раз. Используйте &lt;a href=&quot;https://docs.python.org/library/functions.html#enumerate&quot;&gt; &lt;code&gt;enumerate()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5f29b72d7f916a12c8205ab8d00a66727da6e64f" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are interpreted as in the &lt;a href=&quot;https://docs.python.org/tutorial/introduction.html#lists&quot;&gt;slice notation&lt;/a&gt; and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument.</source>
          <target state="translated">Необязательные аргументы &lt;em&gt;start&lt;/em&gt; и &lt;em&gt;end&lt;/em&gt; интерпретируются так же, как в &lt;a href=&quot;https://docs.python.org/tutorial/introduction.html#lists&quot;&gt;нотации слайса,&lt;/a&gt; и используются для ограничения поиска определенной подпоследовательностью списка. Возвращаемый индекс вычисляется относительно начала полной последовательности, а не аргумента начала.</target>
        </trans-unit>
        <trans-unit id="23ed6c68ba031e2fb0f343e2066536b8cbcbb224" translate="yes" xml:space="preserve">
          <source>There are a couple of issues with this method:</source>
          <target state="translated">Есть пара проблем с этим методом:</target>
        </trans-unit>
        <trans-unit id="d0f0d5ad2ee580d4c84695a38396f9524590232d" translate="yes" xml:space="preserve">
          <source>There are many, many uses for it in &lt;code&gt;idlelib&lt;/code&gt;, for GUI and text parsing.</source>
          <target state="translated">Есть много, много применений для этого в &lt;code&gt;idlelib&lt;/code&gt; , для графического интерфейса и анализа текста.</target>
        </trans-unit>
        <trans-unit id="e189e0c580d334b70585be6ccb6ad770994c518c" translate="yes" xml:space="preserve">
          <source>There is a more functional answer to this.</source>
          <target state="translated">Есть более функциональный ответ.</target>
        </trans-unit>
        <trans-unit id="846f71d4ddbcbba38d71a85c1e823b4638b3ac0d" translate="yes" xml:space="preserve">
          <source>This accounts for if the string is not in the list too, if it isn't in the list then &lt;code&gt;location = -1&lt;/code&gt;</source>
          <target state="translated">Это учитывает, если строки нет в списке, если ее нет в списке, то &lt;code&gt;location = -1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9eec5464d883c5746ea1d6fb365ccdd05d18464c" translate="yes" xml:space="preserve">
          <source>This function takes the item and the list as arguments and return the position of the item in the list, like we saw before.</source>
          <target state="translated">Эта функция принимает элемент и список в качестве аргументов и возвращает позицию элемента в списке,как мы видели ранее.</target>
        </trans-unit>
        <trans-unit id="2a18e2d1e4a696503611ee32d548c6aa74bd6dbb" translate="yes" xml:space="preserve">
          <source>This is more efficient for larger lists than using &lt;code&gt;enumerate()&lt;/code&gt;:</source>
          <target state="translated">Это более эффективно для больших списков, чем использование &lt;code&gt;enumerate()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="21b8992161e2b5e8e19f6b2fb7385c35645b9193" translate="yes" xml:space="preserve">
          <source>This solution is not as powerful as others, but if you're a beginner and only know about &lt;code&gt;for&lt;/code&gt;loops it's still possible to find the first index of an item while avoiding the ValueError:</source>
          <target state="translated">Это решение не такое мощное, как другие, но если вы новичок и знаете только о циклах &lt;code&gt;for&lt;/code&gt; , все равно возможно найти первый индекс элемента, избегая при этом ValueError:</target>
        </trans-unit>
        <trans-unit id="4401047efffd77dbd6aeaf37b4c9c09933d4d63a" translate="yes" xml:space="preserve">
          <source>Throws if element not present in list</source>
          <target state="translated">Броски если элемент отсутствует в списке</target>
        </trans-unit>
        <trans-unit id="f7f6f80965fb2a95d3d41d847d0370e0153285c0" translate="yes" xml:space="preserve">
          <source>To get all indexes:</source>
          <target state="translated">Чтобы получить все индексы:</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="8debd965625833a02abf017f534957fa9c920ff2" translate="yes" xml:space="preserve">
          <source>Well, sure, there's the index method, which returns the index of the first occurrence:</source>
          <target state="translated">Ну,конечно,есть метод индекса,который возвращает индекс первого происшествия:</target>
        </trans-unit>
        <trans-unit id="9feb3701a7b5e907cd77de120330d62f6fbe772d" translate="yes" xml:space="preserve">
          <source>What these usages seem to have in common is that they seem to operate on lists of constrained sizes (important because of O(n) lookup time for &lt;code&gt;list.index&lt;/code&gt;), and they're mostly used in parsing (and UI in the case of Idle).</source>
          <target state="translated">Похоже, что эти обычаи имеют общее то, что они работают со списками ограниченных размеров (важно из-за O (n) времени поиска для &lt;code&gt;list.index&lt;/code&gt; ), и они в основном используются при разборе (и пользовательском интерфейсе в случае Idle).</target>
        </trans-unit>
        <trans-unit id="c3c1d3127006853f690674b9e898879780232f1c" translate="yes" xml:space="preserve">
          <source>When pasted into an interactive python window:</source>
          <target state="translated">При вставке в интерактивное окно питона:</target>
        </trans-unit>
        <trans-unit id="04e868c4615730112b8796c82580a82b3f69dd91" translate="yes" xml:space="preserve">
          <source>Which, when pasted into an interactive python window yields:</source>
          <target state="translated">Который,при вставке в интерактивное окно питона,дает результат:</target>
        </trans-unit>
        <trans-unit id="a799097e107541e4293734d380b0049cbb4578f4" translate="yes" xml:space="preserve">
          <source>While there are use-cases for it, they are fairly uncommon. If you find yourself looking for this answer, ask yourself if what you're doing is the most direct usage of the tools provided by the language for your use-case.</source>
          <target state="translated">В то время как для этого есть чемоданы,они довольно необычны.Если вы ищете этот ответ,спросите себя,является ли то,что вы делаете,самым непосредственным использованием инструментов,предоставляемых языком для вашего случая использования.</target>
        </trans-unit>
        <trans-unit id="6544e769402a49062cf544424f2158f973601950" translate="yes" xml:space="preserve">
          <source>Why do you think you need the index given an element in a list?</source>
          <target state="translated">Как вы думаете,зачем вам нужен индекс,заданный элементом в списке?</target>
        </trans-unit>
        <trans-unit id="3c1cf64e16d0a70350a8ba0e9ce7b5459e83c74b" translate="yes" xml:space="preserve">
          <source>Why write a function with exception handling if the language provides the methods to do what you want itself?</source>
          <target state="translated">Зачем писать функцию с обработкой исключений,если язык предоставляет методы для того,чтобы делать то,что вы хотите сами?</target>
        </trans-unit>
        <trans-unit id="a840a787ebb368bc6d84e6f435c43120c05ad085" translate="yes" xml:space="preserve">
          <source>With enumerate(alist) you can store the first element (n) that is the index of the list when the element x is equal to what you look for.</source>
          <target state="translated">С помощью enumerate(alist)вы можете сохранить первый элемент (n),который является индексом списка,когда элемент x равен тому,что вы ищете.</target>
        </trans-unit>
        <trans-unit id="58004b3fdee6090f4c29533d21a33da40076b1de" translate="yes" xml:space="preserve">
          <source>Wrap the &lt;code&gt;index&lt;/code&gt; call in a &lt;code&gt;try/except&lt;/code&gt; block which catches &lt;code&gt;ValueError&lt;/code&gt; (probably faster, at least when the list to search is long, and the item is usually present.)</source>
          <target state="translated">Оберните &lt;code&gt;index&lt;/code&gt; вызов в блок &lt;code&gt;try/except&lt;/code&gt; который перехватывает &lt;code&gt;ValueError&lt;/code&gt; (возможно, быстрее, по крайней мере, когда список для поиска длинный, а элемент обычно присутствует).</target>
        </trans-unit>
        <trans-unit id="cc18f2f503924b825e088eeadfc7a83d7f6685c3" translate="yes" xml:space="preserve">
          <source>Yes, you could use a list comprehension with enumerate too, but that's just not as elegant, in my opinion - you're doing tests for equality in Python, instead of letting builtin code written in C handle it:</source>
          <target state="translated">Да,можно было бы использовать и понимание списка с перечислением,но это,на мой взгляд,не так элегантно-вы делаете тесты на равенство на Python,а не позволяете встроенному коду,написанному на Си,справляться с ним:</target>
        </trans-unit>
        <trans-unit id="d6d7ab23bae3bb30ea03eb02bb05eafd7419158b" translate="yes" xml:space="preserve">
          <source>You can do so with a reusable definition like this:</source>
          <target state="translated">Ты можешь сделать это с таким многоразовым определением,как это:</target>
        </trans-unit>
        <trans-unit id="9344b86dc9b6a3e208be80369545f27ad82257b3" translate="yes" xml:space="preserve">
          <source>You could also use this as a one liner to get all indices for a single entry. There are no guarantees for efficiency, though I did use set(a) to reduce the number of times the lambda is called.</source>
          <target state="translated">Вы также можете использовать его как один лайнер,чтобы получить все индексы для одной записи.Гарантий эффективности нет,хотя я использовал set(a),чтобы уменьшить количество раз,когда лямбда вызывается.</target>
        </trans-unit>
        <trans-unit id="1660bf3ae3a8b357a3570854bd099d55df8fe213" translate="yes" xml:space="preserve">
          <source>You have to set a condition to check if the element you're searching is in the list</source>
          <target state="translated">Вы должны задать условие,чтобы проверить,есть ли искомый элемент в списке.</target>
        </trans-unit>
        <trans-unit id="6f5f06f92705914174990429b3f3f71c96d42bf8" translate="yes" xml:space="preserve">
          <source>You might enumerate into a list comprehension the indexes:</source>
          <target state="translated">Вы можете перечислить в список,чтобы понять индексы:</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="04d2c451f757f8e156cea4edcefc038d4b9298f0" translate="yes" xml:space="preserve">
          <source>and if name wasn't at arr,the function return -1.for example:</source>
          <target state="translated">и если имя не было в arr,то функция возвращает,например,-1:</target>
        </trans-unit>
        <trans-unit id="bb7f7bc55138daa1011f117e6154bcdf8cff1f3d" translate="yes" xml:space="preserve">
          <source>and the result is:</source>
          <target state="translated">и в результате:</target>
        </trans-unit>
        <trans-unit id="a1cebe0aca9cffd65ef5e990f4cc2f2381b45601" translate="yes" xml:space="preserve">
          <source>if more than one of the value is in the list, you only get the index for the first one</source>
          <target state="translated">если в списке больше одного значения,вы получите индекс только для первого.</target>
        </trans-unit>
        <trans-unit id="ff53deb61f1b6529e54714fd7a4520a2c7117494" translate="yes" xml:space="preserve">
          <source>if the value isn't in the list, you'll get a &lt;code&gt;ValueError&lt;/code&gt;</source>
          <target state="translated">если значение отсутствует в списке, вы получите &lt;code&gt;ValueError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c32f1c2094095c52fb3c98b1d262d3c59fe93d3" translate="yes" xml:space="preserve">
          <source>in my opinion the &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;].index(&quot;bar&quot;)&lt;/code&gt; is good but it isn't enough!because if &quot;bar&quot; isn't in dictionary,&lt;code&gt;ValueError&lt;/code&gt; raised.So you can use this function:</source>
          <target state="translated">по моему мнению, &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;].index(&quot;bar&quot;)&lt;/code&gt; - это хорошо, но этого недостаточно! потому что, если &quot;bar&quot; нет в словаре, выдается &lt;code&gt;ValueError&lt;/code&gt; . Так что вы можете используйте эту функцию:</target>
        </trans-unit>
        <trans-unit id="bfeaa83f659442d7000d35cd4e69f87f6c981f62" translate="yes" xml:space="preserve">
          <source>print(find_index([&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;], &quot;fooo&quot;))</source>
          <target state="translated">print(find_index([&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;],&quot;fooo&quot;)))</target>
        </trans-unit>
        <trans-unit id="ae96157eaa6a73acc01741d4c34deda1f29a863e" translate="yes" xml:space="preserve">
          <source>using dictionary , where process the list first and then add the index to it</source>
          <target state="translated">используя словарь,где сначала обрабатывается список,а затем добавляется индекс.</target>
        </trans-unit>
        <trans-unit id="a8d3e403bcd1f6cd0c14b4ef48d7c30982248134" translate="yes" xml:space="preserve">
          <source>where &quot;haystack&quot; is the list in question and &quot;needle&quot; is the item to look for.</source>
          <target state="translated">где &quot;стог сена&quot;-это список,а &quot;игла&quot;-предмет для поиска.</target>
        </trans-unit>
        <trans-unit id="753bb33740732dd3048f5dd26ccf443da7f29592" translate="yes" xml:space="preserve">
          <source>which will often lead you to the method you are looking for.</source>
          <target state="translated">что часто приводит вас к методу,который вы ищете.</target>
        </trans-unit>
        <trans-unit id="28ca6530764be90c4d17b5dddf1693dd50b7303b" translate="yes" xml:space="preserve">
          <source>|      L.index(value, [start, [stop]]) -&amp;gt; integer -- return first index of value</source>
          <target state="translated">| L.index (value, [start, [stop]]) -&amp;gt; integer - вернуть первый индекс значения</target>
        </trans-unit>
        <trans-unit id="5d70790b5d8176367f775dae7a6fdf3f92c38331" translate="yes" xml:space="preserve">
          <source>|  index(...)</source>
          <target state="translated">В качестве понимания списка:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
