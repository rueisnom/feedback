<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/176918">
    <body>
      <group id="176918">
        <trans-unit id="2948baef786870af8190d83cfb43d62137ad18ca" translate="yes" xml:space="preserve">
          <source>(Note: Here we are iterating using i to get the indexes, but if we need rather to focus on the items we can switch to j.)</source>
          <target state="translated">(참고 : 여기서는 인덱스를 얻기 위해 i를 사용하여 반복하지만 항목에 집중 해야하는 경우 j로 전환 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="66299ebbecf7817df5176612979c8ac917033572" translate="yes" xml:space="preserve">
          <source>... like confirming the existence of the item before getting the index.  The nice thing about this approach is the function always returns a list of indices -- even if it is an empty list.  It works with strings as well.</source>
          <target state="translated">... 색인을 얻기 전에 품목의 존재를 확인하는 것과 같습니다. 이 방법의 좋은 점은 함수가 빈 목록 인 경우에도 항상 인덱스 목록을 반환한다는 것입니다. 문자열에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="134741840ad6b457f1871651f6e0da9f89505a3a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;code&gt;more_itertools&lt;/code&gt;&lt;/a&gt; is a third-party library with tools to locate &lt;em&gt;multiple&lt;/em&gt; indices within an iterable.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt; &lt;code&gt;more_itertools&lt;/code&gt; &lt;/a&gt; 는 iterable 내에서 &lt;em&gt;여러&lt;/em&gt; 색인을 찾는 도구가있는 써드 파티 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="82f08a023bee2ebc787ac15b0a3b1a5bd3141b10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index()&lt;/code&gt; returns the &lt;strong&gt;first&lt;/strong&gt; index of value!</source>
          <target state="translated">&lt;code&gt;index()&lt;/code&gt; 는 &lt;strong&gt;첫 번째&lt;/strong&gt; 값 인덱스를 반환합니다!</target>
        </trans-unit>
        <trans-unit id="178cdb76b937485781bbe6aa6f909fe9cd8d6856" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Code&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6607830e66ad80aa66ee0fb7977558ee0e94c1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Given&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Given&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d12b121dd20db5c6fbdbda026bff85f6c3142492" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4854c643745651c59985c121976968eecde5e2ae" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;index&lt;/code&gt; results in a &lt;a href=&quot;https://docs.python.org/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if the item's not present.</source>
          <target state="translated">항목이 없으면 &lt;code&gt;index&lt;/code&gt; 호출로 인해 &lt;a href=&quot;https://docs.python.org/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5ccf855ab58a5f7fb7979cad7580b6e22927f1e5" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;index&lt;/code&gt; searches through the list in order until it finds a match, and &lt;em&gt;stops there.&lt;/em&gt; If you expect to need indices of more matches, you should use a list comprehension, or generator expression.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 호출은 일치하는 것을 찾을 때까지 목록을 순서대로 검색하여 &lt;em&gt;중지합니다.&lt;/em&gt; 일치하는 인덱스가 더 필요할 것으로 예상되는 경우 목록 이해 또는 생성기 표현식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aff4787b1edd1bd62e26a67ff0ce689898e30aa2" translate="yes" xml:space="preserve">
          <source>A comparison check will return a series of booleans:</source>
          <target state="translated">비교 점검은 일련의 부울을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="138baba7813f3759b9ca9d7e92c7d65b1bc857ca" translate="yes" xml:space="preserve">
          <source>A problem will arise if the element is not in the list. This function handles the issue:</source>
          <target state="translated">요소가 목록에 없으면 문제가 발생합니다. 이 함수는 문제를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b8e635c9d99261fbe9f8c404fda7e105a7dea459" translate="yes" xml:space="preserve">
          <source>A variant on the answer from FMc and user7177 will give a dict that can return all indices for any entry:</source>
          <target state="translated">FMc 및 user7177의 답변에 대한 변형은 모든 항목에 대한 모든 색인을 반환 할 수있는 dict을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="493f8b764877784751bb03986b351785842ab5f4" translate="yes" xml:space="preserve">
          <source>After another year of heads-down python development, I'm a bit embarrassed by my original answer, so to set the record straight, one can certainly use the above code; however, the &lt;em&gt;much&lt;/em&gt; more idiomatic way to get the same behavior would be to use list comprehension, along with the enumerate() function.</source>
          <target state="translated">또 다른 해의 헤드 다운 파이썬 개발 후, 나는 원래의 대답에 약간 당황 스럽습니다. 그래서 레코드를 똑바로 세우려면 위의 코드를 확실히 사용할 수 있습니다. 그러나 동일한 동작을 얻는 &lt;em&gt;훨씬&lt;/em&gt; 더 관용적 인 방법은 enumerate () 함수와 함께 목록 이해를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="783400a3f5b8f986154b3e2a17daf29f18a7b8f5" translate="yes" xml:space="preserve">
          <source>All indexes with the &lt;a href=&quot;https://docs.python.org/2/library/functions.html#zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/library/functions.html#zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; 기능이있는 모든 인덱스 :</target>
        </trans-unit>
        <trans-unit id="224f7aafadbfc2e2042598dd5316150dbfba5063" translate="yes" xml:space="preserve">
          <source>All of the proposed functions here reproduce inherent language behavior but obscure what's going on.</source>
          <target state="translated">여기서 제안 된 모든 기능은 고유 한 언어 동작을 재현하지만 진행 상황을 모호하게합니다.</target>
        </trans-unit>
        <trans-unit id="c899cdecca241309c182b8884734252d7de4e8c9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;index&lt;/code&gt; call checks every element of the list in order, until it finds a match. If your list is long, and you don't know roughly where in the list it occurs, this search could become a bottleneck. In that case, you should consider a different data structure. Note that if you know roughly where to find the match, you can give &lt;code&gt;index&lt;/code&gt; a hint. For instance, in this snippet, &lt;code&gt;l.index(999_999, 999_990, 1_000_000)&lt;/code&gt; is roughly five orders of magnitude faster than straight &lt;code&gt;l.index(999_999)&lt;/code&gt;, because the former only has to search 10 entries, while the latter searches a million:</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 호출은 일치하는 것을 찾을 때까지 목록의 모든 요소를 ​​순서대로 확인합니다. 목록이 길고 목록의 대략적인 위치를 모르는 경우이 검색에 병목 현상이 발생할 수 있습니다. 이 경우 다른 데이터 구조를 고려해야합니다. 일치하는 위치를 대략 알면 &lt;code&gt;index&lt;/code&gt; 에 힌트를 줄 수 있습니다. 예를 들어,이 코드 조각에서 &lt;code&gt;l.index(999_999, 999_990, 1_000_000)&lt;/code&gt; 은 straight &lt;code&gt;l.index(999_999)&lt;/code&gt; 보다 대략 5 배 빠릅니다. 전자는 10 개의 항목 만 검색하고 후자는 백만을 검색하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f7eae91daa1d639943d459b3dbbc10cfa58431f5" translate="yes" xml:space="preserve">
          <source>And if you want them in a list or tuple, just pass them to the constructor:</source>
          <target state="translated">그리고 목록이나 튜플에 원하는 경우 생성자에게 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="86e445a2158f8dd6cfa820ebb209aac73c1e5ccd" translate="yes" xml:space="preserve">
          <source>And now, after reviewing this question and all the answers, I realize that this is exactly what &lt;a href=&quot;https://stackoverflow.com/users/55857/fmc&quot;&gt;FMc&lt;/a&gt; suggested in his &lt;a href=&quot;https://stackoverflow.com/questions/176918/finding-the-index-of-an-item-given-a-list-containing-it-in-python/17300987#17300987&quot;&gt;earlier answer&lt;/a&gt;.  At the time I originally answered this question, I didn't even &lt;em&gt;see&lt;/em&gt; that answer, because I didn't understand it.  I hope that my somewhat more verbose example will aid understanding.</source>
          <target state="translated">그리고 지금,이 질문과 모든 답변을 검토 한 후, 이것이 &lt;a href=&quot;https://stackoverflow.com/users/55857/fmc&quot;&gt;FMc&lt;/a&gt; 가 그의 &lt;a href=&quot;https://stackoverflow.com/questions/176918/finding-the-index-of-an-item-given-a-list-containing-it-in-python/17300987#17300987&quot;&gt;이전 답변&lt;/a&gt; 에서 제안한 것과 정확히 일치한다는 것을 알고 있습니다. 내가 원래이 질문에 대답했을 때, 나는 그것을 이해하지 못했기 때문에 그 답을 보지 못했습니다. 좀 더 장황한 예가 이해를 돕기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="cabff39d8a2cb29ffd40a559aba15983bc0b5ded" translate="yes" xml:space="preserve">
          <source>And now, for something completely different...</source>
          <target state="translated">그리고 지금, 완전히 다른 무언가를 위해 ...</target>
        </trans-unit>
        <trans-unit id="34b2d2db99fc3c8db7a0b00fe55eb1adac107b96" translate="yes" xml:space="preserve">
          <source>And the downside of this is that you will probably have a check for if the returned value &lt;code&gt;is&lt;/code&gt; or &lt;code&gt;is not&lt;/code&gt; None:</source>
          <target state="translated">그리고 이것의 단점은 반환 된 값 &lt;code&gt;is&lt;/code&gt; None인지 아닌지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="58a7124e04e8fb36f38515e8703fec6da46cd2d6" translate="yes" xml:space="preserve">
          <source>And use it like this:</source>
          <target state="translated">그리고 이것을 다음과 같이 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="90e38a5e7a649b7c9940934affa211cd085be8a6" translate="yes" xml:space="preserve">
          <source>Another option</source>
          <target state="translated">다른 옵션</target>
        </trans-unit>
        <trans-unit id="e7ee18e7126a05ddfe444abe07b014e8864747fc" translate="yes" xml:space="preserve">
          <source>As a list comprehension:</source>
          <target state="translated">목록 이해력으로 :</target>
        </trans-unit>
        <trans-unit id="26ab018b67cb7ad280c6fa077b17af69fa564147" translate="yes" xml:space="preserve">
          <source>As indicated by @TerryA, many answers discuss how to find &lt;em&gt;one&lt;/em&gt; index.</source>
          <target state="translated">@TerryA에서 알 수 있듯이 많은 답변에서 &lt;em&gt;하나의&lt;/em&gt; 색인을 찾는 방법에 대해 논의합니다.</target>
        </trans-unit>
        <trans-unit id="7fc1f4d493aaab0be5262d781a08bb9525bc6081" translate="yes" xml:space="preserve">
          <source>Better data munging with pandas</source>
          <target state="translated">팬더로 더 나은 데이터 녹기</target>
        </trans-unit>
        <trans-unit id="4a61ff86e696d36fc80e2eac1c63c19d03b769e3" translate="yes" xml:space="preserve">
          <source>Caveats follow</source>
          <target state="translated">주의 사항</target>
        </trans-unit>
        <trans-unit id="81d49b7f1eab63248cfe4be2a400e7c1b2f247cd" translate="yes" xml:space="preserve">
          <source>Check for it first with &lt;code&gt;item in my_list&lt;/code&gt; (clean, readable approach), or</source>
          <target state="translated">&lt;code&gt;item in my_list&lt;/code&gt; (깨끗하고 읽기 쉬운 접근 방식)으로 먼저 확인하거나</target>
        </trans-unit>
        <trans-unit id="dcb72c18d397544038d81fcd4eb972a16e34d477" translate="yes" xml:space="preserve">
          <source>Find indices of multiple observations:</source>
          <target state="translated">여러 관측치의 지수 찾기 :</target>
        </trans-unit>
        <trans-unit id="5a3294db39d81a64ac4f6e8556ffc977f34dc714" translate="yes" xml:space="preserve">
          <source>Finding index of item x in list L:</source>
          <target state="translated">목록 L에서 항목 x의 색인 찾기 :</target>
        </trans-unit>
        <trans-unit id="23e13cc3bff692365dfdb0e9e6068472f329a7a8" translate="yes" xml:space="preserve">
          <source>Finding the index of an item given a list containing it in Python</source>
          <target state="translated">파이썬에서 그것을 포함하는리스트가 주어진 아이템의 인덱스 찾기</target>
        </trans-unit>
        <trans-unit id="a44ef4465f839a6c49b3cf7c8be2838f115dee0f" translate="yes" xml:space="preserve">
          <source>Finding the index of an item in a list</source>
          <target state="translated">목록에서 항목의 색인 찾기</target>
        </trans-unit>
        <trans-unit id="da07c5158f5d72ce13082d2f3b173ba41b16c672" translate="yes" xml:space="preserve">
          <source>For a list &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&lt;/code&gt; and an item in the list &lt;code&gt;&quot;bar&quot;&lt;/code&gt;, what's the cleanest way to get its index (1) in Python?</source>
          <target state="translated">목록 &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&lt;/code&gt; 및 목록 &lt;code&gt;&quot;bar&quot;&lt;/code&gt; 의 항목에 대해 Python에서 색인 (1)을 얻는 가장 확실한 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="def524d82886b7d7f470d7a5c0bde3396e87b73a" translate="yes" xml:space="preserve">
          <source>For those coming from another language like me, maybe with a simple loop it's easier to understand and use it:</source>
          <target state="translated">나와 같은 다른 언어를 사용하는 사람들은 간단한 루프를 사용하여 이해하고 사용하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="02a53e5e1980cadf894222cd6e9f944742e7f03c" translate="yes" xml:space="preserve">
          <source>Getting all the occurrences and the position of one or more (identical) items in a list</source>
          <target state="translated">모든 발생 및 목록에서 하나 이상의 (동일한) 항목 위치 가져 오기</target>
        </trans-unit>
        <trans-unit id="aa722a193799b7775f3b4d62943a0b760505a1c6" translate="yes" xml:space="preserve">
          <source>Given a list &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&lt;/code&gt; and an item in the list &lt;code&gt;&quot;bar&quot;&lt;/code&gt;, how do I get its index (&lt;code&gt;1&lt;/code&gt;) in Python?</source>
          <target state="translated">목록 &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&lt;/code&gt; 및 목록 &lt;code&gt;&quot;bar&quot;&lt;/code&gt; 의 항목이 주어지면 Python에서 색인 ( &lt;code&gt;1&lt;/code&gt; )을 어떻게 얻습니까?</target>
        </trans-unit>
        <trans-unit id="737107fd42248382bdf1fa923988b9ca029e7587" translate="yes" xml:space="preserve">
          <source>Here is an example of code using Python 3.8 and above syntax:</source>
          <target state="translated">다음은 Python 3.8 이상의 구문을 사용하는 코드의 예입니다.</target>
        </trans-unit>
        <trans-unit id="a9a9b00bbdafcc2e9de8e4d4d330120c2d0d52c7" translate="yes" xml:space="preserve">
          <source>Here's also another small solution with &lt;a href=&quot;http://docs.python.org/library/itertools.html#itertools.count&quot;&gt;&lt;code&gt;itertools.count()&lt;/code&gt;&lt;/a&gt; (which is pretty much the same approach as enumerate):</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/library/itertools.html#itertools.count&quot;&gt; &lt;code&gt;itertools.count()&lt;/code&gt; &lt;/a&gt; 사용하는 또 다른 작은 솔루션이 있습니다 (이것은 열거와 거의 같은 접근법입니다).</target>
        </trans-unit>
        <trans-unit id="01713b2f32ef2f970dbe3d6c62c59c3a4bede755" translate="yes" xml:space="preserve">
          <source>I am thankful for &lt;em&gt;&lt;a href=&quot;https://www.codecademy.com/en/forum_questions/5087f2d786a27b02000041a9&quot;&gt;So what exactly does enumerate do?&lt;/a&gt;&lt;/em&gt;. That helped me to understand.</source>
          <target state="translated">감사합니다. &lt;em&gt;&lt;a href=&quot;https://www.codecademy.com/en/forum_questions/5087f2d786a27b02000041a9&quot;&gt;열거 형은 정확히 무엇을합니까?&lt;/a&gt;&lt;/em&gt; . 그것은 내가 이해하는 데 도움이되었다.</target>
        </trans-unit>
        <trans-unit id="203da802a1f01f22eb2311502acef8849c93ba53" translate="yes" xml:space="preserve">
          <source>I do not recall needing &lt;code&gt;list.index&lt;/code&gt;, myself. However, I have looked through the Python standard library, and I see some excellent uses for it.</source>
          <target state="translated">&lt;code&gt;list.index&lt;/code&gt; 필요 하다는 것을 기억하지 않습니다. 그러나 나는 파이썬 표준 라이브러리를 살펴 보았고 그것을 훌륭하게 사용하는 것을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="948ae31c04ed122f8baa060d7e539757bf14a1d9" translate="yes" xml:space="preserve">
          <source>I'm usually iterating over the list anyways, so I'll usually keep a pointer to any interesting information, getting the &lt;a href=&quot;https://stackoverflow.com/q/522563/541136&quot;&gt;index with enumerate.&lt;/a&gt;</source>
          <target state="translated">나는 일반적으로 어쨌든 목록을 반복하고 있으므로 일반적으로 흥미로운 정보에 대한 포인터를 유지하여 &lt;a href=&quot;https://stackoverflow.com/q/522563/541136&quot;&gt;색인을 열거합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e734fda17824d47900b08e14372d48e0a9aeb365" translate="yes" xml:space="preserve">
          <source>If performance is of concern:</source>
          <target state="translated">성능이 우려되는 경우 :</target>
        </trans-unit>
        <trans-unit id="4f342de31e5fe70628440252039a22e41dd9a379" translate="yes" xml:space="preserve">
          <source>If the item might not be present in the list, you should either</source>
          <target state="translated">항목이 목록에 없을 수 있으면</target>
        </trans-unit>
        <trans-unit id="d779cd816c85fb2f652fece6ede9b6fa5c5bacde" translate="yes" xml:space="preserve">
          <source>If the single line of code above still &lt;em&gt;doesn't&lt;/em&gt; make sense to you, I highly recommend you Google 'python list comprehension' and take a few minutes to familiarize yourself.  It's just one of the many powerful features that make it a joy to use Python to develop code.</source>
          <target state="translated">위의 한 줄의 코드가 여전히 이해 &lt;em&gt;가되지 않는다면&lt;/em&gt; Google 'python list comprehension'을 강력히 추천하고 몇 분 동안 익숙해 지십시오. 파이썬을 사용하여 코드를 개발하는 것을 즐겁게 만드는 많은 강력한 기능 중 하나 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="8f9fc72d83ef92d4e4de63383003079554ab5b84" translate="yes" xml:space="preserve">
          <source>If the value could be missing, you need to catch the &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="translated">값이 누락 된 경우 &lt;code&gt;ValueError&lt;/code&gt; 를 잡아야합니다.</target>
        </trans-unit>
        <trans-unit id="88d3340a656a30b1b41d121ca23ce804b41f4393" translate="yes" xml:space="preserve">
          <source>If the value isn't there, catching the &lt;code&gt;ValueError&lt;/code&gt; is rather verbose - and I prefer to avoid that.</source>
          <target state="translated">값이 없으면 &lt;code&gt;ValueError&lt;/code&gt; 를 잡는 것이 다소 장황하며 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="11e8dbae6f026cf70d8c2be2393b89a7d5b95a88" translate="yes" xml:space="preserve">
          <source>If you already know the value, why do you care where it is in a list?</source>
          <target state="translated">이미 그 가치를 알고 있다면 왜 목록의 어디에 있는지에 관심이 있습니까?</target>
        </trans-unit>
        <trans-unit id="b716a532cf74eab7c9f9f93764d519eec7b07b44" translate="yes" xml:space="preserve">
          <source>If you are going to find an index once then using &quot;index&quot; method is fine. However, if you are going to search your data more than once then I recommend using &lt;a href=&quot;https://docs.python.org/3/library/bisect.html&quot;&gt;bisect&lt;/a&gt; module. Keep in mind that using bisect module data must be sorted. So you sort data once and then you can use bisect.
Using &lt;a href=&quot;https://docs.python.org/3/library/bisect.html&quot;&gt;bisect&lt;/a&gt; module on my machine is about 20 times faster than using index method.</source>
          <target state="translated">인덱스를 한 번 찾으려면 &quot;index&quot;방법을 사용하는 것이 좋습니다. 그러나 데이터를 두 번 이상 검색하려면 &lt;a href=&quot;https://docs.python.org/3/library/bisect.html&quot;&gt;bisect&lt;/a&gt; 모듈을 사용하는 것이 좋습니다. bisect 모듈 데이터를 사용하여 정렬해야합니다. 따라서 데이터를 한 번 정렬하면 bisect를 사용할 수 있습니다. 내 컴퓨터에서 &lt;a href=&quot;https://docs.python.org/3/library/bisect.html&quot;&gt;bisect&lt;/a&gt; 모듈을 사용하는 것이 색인 방법을 사용하는 것보다 약 20 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="5111bbb16b848de1e5dde35abc94e35a55c4a147" translate="yes" xml:space="preserve">
          <source>If you are sure that the items in your list are never repeated, you can easily:</source>
          <target state="translated">목록의 항목이 반복되지 않는 것이 확실한 경우 다음을 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cf5368fcdd44e4e20f42c0311a74e7b36f316c2" translate="yes" xml:space="preserve">
          <source>If you could have more occurrences, you'll &lt;strong&gt;not&lt;/strong&gt; get complete information with &lt;code&gt;list.index&lt;/code&gt;:</source>
          <target state="translated">더 많은 경우가 발생하면 &lt;code&gt;list.index&lt;/code&gt; 와 함께 완전한 정보를 얻을 수 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2bdde82f45391223710a247ef47b48fdaa1b7720" translate="yes" xml:space="preserve">
          <source>If you have no occurrences, you can check for that with boolean check of the result, or just do nothing if you loop over the results:</source>
          <target state="translated">어커런스가 없으면 결과의 부울 검사로 검사하거나 결과를 반복하면 아무것도 수행하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4fe6fd03bfef26fd984a85874f9d638081c358d" translate="yes" xml:space="preserve">
          <source>If you have pandas, you can easily get this information with a Series object:</source>
          <target state="translated">팬더가있는 경우 Series 객체를 사용 하여이 정보를 쉽게 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac98452bfa9442260e6b099ea10959b162018f4" translate="yes" xml:space="preserve">
          <source>If you may have duplicate elements, and need to return all of their indices:</source>
          <target state="translated">중복 된 요소가있을 수 있으며 모든 인덱스를 반환해야하는 경우 :</target>
        </trans-unit>
        <trans-unit id="0739b51b2e7a6565b9e6493164c5956a765c3416" translate="yes" xml:space="preserve">
          <source>If you want all indexes, then you can use &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt;:</source>
          <target state="translated">모든 인덱스를 원하면 &lt;a href=&quot;http://en.wikipedia.org/wiki/NumPy&quot;&gt;NumPy&lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec27bad5ad2902ce92beaf7225be35ebefad8ffa" translate="yes" xml:space="preserve">
          <source>If you want just the indexes, the index attribute returns a series of integers:</source>
          <target state="translated">인덱스 만 원하는 경우 index 속성은 일련의 정수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ec779073cf49a8d2c48920f0ea4ad6bb4931e68c" translate="yes" xml:space="preserve">
          <source>If you're munging data, you should probably be using pandas - which has far more elegant tools than the pure Python workarounds I've shown.</source>
          <target state="translated">데이터를 녹이는 경우 팬더를 사용해야 할 것입니다. 팬더는 필자가 보여준 순수한 Python 해결 방법보다 훨씬 더 우아한 도구를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5828c228aa1a6a533c392ac9513f724add63fe1" translate="yes" xml:space="preserve">
          <source>In Lib/http/cookiejar.py, seems to be used to get the next month:</source>
          <target state="translated">Lib / http / cookiejar.py에서 다음 달을 얻는 데 사용되는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="041c63df7f78dfeb43c93260479759baf277d6d6" translate="yes" xml:space="preserve">
          <source>In Lib/mailbox.py it seems to be using it like an ordered mapping:</source>
          <target state="translated">Lib / mailbox.py에서는 정렬 된 매핑처럼 사용하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="00464d6b045eb7a0a40085474aa324598613c2b4" translate="yes" xml:space="preserve">
          <source>In Lib/pickletools.py:</source>
          <target state="translated">Lib / pickletools.py에서 :</target>
        </trans-unit>
        <trans-unit id="3204cca49e7efd3262f18a65aaa6960ce42a1670" translate="yes" xml:space="preserve">
          <source>In Lib/tarfile.py similar to distutils to get a slice up to an item:</source>
          <target state="translated">distutils와 비슷한 Lib / tarfile.py에서 항목까지 슬라이스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7ff77d5616cfab3adfdf19beff92b26e894d934f" translate="yes" xml:space="preserve">
          <source>Is this an &lt;a href=&quot;https://meta.stackexchange.com/a/66378/239121&quot;&gt;XY problem&lt;/a&gt;?</source>
          <target state="translated">이것은 &lt;a href=&quot;https://meta.stackexchange.com/a/66378/239121&quot;&gt;XY 문제&lt;/a&gt; 입니까?</target>
        </trans-unit>
        <trans-unit id="282473616c11628dd6bad06a1adae26405ccdf85" translate="yes" xml:space="preserve">
          <source>It is clear, readable solution.</source>
          <target state="translated">명확하고 읽기 쉬운 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="9d7afe81fe620fd3e92a00ed6eba8eb6fbcb10c7" translate="yes" xml:space="preserve">
          <source>It is mentioned in numerous answers that the built-in method of &lt;code&gt;list.index(item)&lt;/code&gt; method is an O(n) algorithm. It is fine if you need to perform this once. But if you need to access the indices of elements a number of times, it makes more sense to first create a dictionary (O(n)) of item-index pairs, and then access the index at O(1) every time you need it.</source>
          <target state="translated">&lt;code&gt;list.index(item)&lt;/code&gt; 메소드의 내장 메소드가 O (n) 알고리즘이라는 많은 답변에서 언급되었습니다. 이 작업을 한 번 수행하면 좋습니다. 그러나 요소의 인덱스에 여러 번 액세스해야하는 경우 먼저 항목 인덱스 쌍의 사전 (O (n))을 만든 다음 필요할 때마다 O (1)의 인덱스에 액세스하는 것이 더 합리적입니다. 그것.</target>
        </trans-unit>
        <trans-unit id="aeb13e8d213fbc96efaecdacc753eda7b589e73f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give the name &lt;code&gt;lst&lt;/code&gt; to the list that you have. One can convert the list &lt;code&gt;lst&lt;/code&gt; to a &lt;code&gt;numpy array&lt;/code&gt;. And, then use &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.where.html&quot;&gt;numpy.where&lt;/a&gt; to get the index of the chosen item in the list. Following is the way in which you will implement it.</source>
          <target state="translated">가지고있는 목록에 이름을 입력합시다. 리스트 &lt;code&gt;lst&lt;/code&gt; 를 &lt;code&gt;numpy array&lt;/code&gt; 로 변환 할 수 있습니다. 그런 다음 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.where.html&quot;&gt;numpy.where&lt;/a&gt; 를 사용하여 목록에서 선택한 항목의 색인을 가져옵니다. 다음은 구현 방법입니다.</target>
        </trans-unit>
        <trans-unit id="2081446ef7932108a0edd67d245fdd048f21a794" translate="yes" xml:space="preserve">
          <source>Let's make our function findindex</source>
          <target state="translated">findindex 함수를 만들어 봅시다</target>
        </trans-unit>
        <trans-unit id="a1f47b01540e61f942a796561a3b436133a34b00" translate="yes" xml:space="preserve">
          <source>Linear time-complexity in list length</source>
          <target state="translated">리스트 길이의 선형 시간 복잡성</target>
        </trans-unit>
        <trans-unit id="1359ef88586d9fe27b15c241f11623fc2258c6ad" translate="yes" xml:space="preserve">
          <source>More generic form:</source>
          <target state="translated">보다 일반적인 형태 :</target>
        </trans-unit>
        <trans-unit id="83987e0a527d72f195324546e24dc4cc2b933602" translate="yes" xml:space="preserve">
          <source>More than one value in the list</source>
          <target state="translated">목록에서 둘 이상의 값</target>
        </trans-unit>
        <trans-unit id="6572550452d24b19c33815cd172b47811aa154db" translate="yes" xml:space="preserve">
          <source>Most places where I once would have used &lt;code&gt;index&lt;/code&gt;, I now use a list comprehension or generator expression because they're more generalizable. So if you're considering reaching for &lt;code&gt;index&lt;/code&gt;, take a look at these excellent Python features.</source>
          <target state="translated">한 번 &lt;code&gt;index&lt;/code&gt; 을 사용했던 대부분의 장소에서 이제는 일반화하기 때문에 목록 이해 또는 생성기 표현식을 사용합니다. 따라서 &lt;code&gt;index&lt;/code&gt; 에 도달하는 것을 고려하고 있다면 이러한 훌륭한 Python 기능을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="6bd5a5d5c3c36f1891fc2d9066b714b4c88a3d46" translate="yes" xml:space="preserve">
          <source>No values</source>
          <target state="translated">값이 없습니다</target>
        </trans-unit>
        <trans-unit id="d1be3a4e9f0fcaac509766c5565988066d8b33e0" translate="yes" xml:space="preserve">
          <source>Note that while this is perhaps the cleanest way to answer the question &lt;em&gt;as asked&lt;/em&gt;, &lt;code&gt;index&lt;/code&gt; is a rather weak component of the &lt;code&gt;list&lt;/code&gt; API, and I can't remember the last time I used it in anger. It's been pointed out to me in the comments that because this answer is heavily referenced, it should be made more complete. Some caveats about &lt;code&gt;list.index&lt;/code&gt; follow. It is probably worth initially taking a look at the documentation for it:</source>
          <target state="translated">이것이 &lt;em&gt;요청에&lt;/em&gt; 따라 질문에 대답하는 가장 깨끗한 방법 일지 모르지만 &lt;code&gt;index&lt;/code&gt; 는 &lt;code&gt;list&lt;/code&gt; API의 약한 구성 요소이며 마지막으로 분노했을 때 기억하지 못합니다. 이 답변이 많이 언급 되었기 때문에 더 완벽하게 작성되어야한다는 의견에서 나에게 지적되었습니다. &lt;code&gt;list.index&lt;/code&gt; 에 대한 몇 가지주의 사항이 있습니다. 처음에는 문서를 살펴볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5b4066da2daa8720e525383af982d673bc2f9eb" translate="yes" xml:space="preserve">
          <source>One thing that is really helpful in learning Python is to use the interactive help function:</source>
          <target state="translated">파이썬을 배우는 데 실제로 도움이되는 한 가지는 대화 형 도움말 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b55b6bea121061ceb81a7ee22a7772006f6e03ba" translate="yes" xml:space="preserve">
          <source>Only returns the index of the &lt;em&gt;first match&lt;/em&gt; to its argument</source>
          <target state="translated">인수 &lt;em&gt;와 일치&lt;/em&gt; 하는 &lt;em&gt;첫 번째&lt;/em&gt; 색인 만 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="10e129969381f29fb9fe97f9d2e11962aa9ba45c" translate="yes" xml:space="preserve">
          <source>Pass that series of booleans to the series via subscript notation, and you get just the matching members:</source>
          <target state="translated">첨자 표기법을 통해 일련의 부울을 시리즈에 전달하면 일치하는 멤버 만 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c84ae2073776c46da2404f57fbc0c1d7c36730a3" translate="yes" xml:space="preserve">
          <source>Python &lt;code&gt;index()&lt;/code&gt; method throws an error if the item was not found. So instead you can make it similar to the &lt;code&gt;indexOf()&lt;/code&gt; function of JavaScript which returns &lt;code&gt;-1&lt;/code&gt; if the item was not found:</source>
          <target state="translated">항목을 찾지 못하면 Python &lt;code&gt;index()&lt;/code&gt; 메소드에서 오류가 발생합니다. 따라서 대신 항목을 찾을 수없는 경우 &lt;code&gt;-1&lt;/code&gt; 을 반환하는 JavaScript의 &lt;code&gt;indexOf()&lt;/code&gt; 함수와 비슷하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5184966eda7a6fa1b21fa046f105ad1697f5e45" translate="yes" xml:space="preserve">
          <source>Reference: &lt;a href=&quot;https://docs.python.org/tutorial/datastructures.html#more-on-lists&quot;&gt;Data Structures &amp;gt; More on Lists&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;https://docs.python.org/tutorial/datastructures.html#more-on-lists&quot;&gt;데이터 구조&amp;gt; 목록에 대한 추가 정보&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49254481d1f23e380481e095e5d315533692e882" translate="yes" xml:space="preserve">
          <source>Return zero-based index in the list of the first item whose value is equal to &lt;em&gt;x&lt;/em&gt;. Raises a &lt;a href=&quot;https://docs.python.org/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if there is no such item.</source>
          <target state="translated">값이 &lt;em&gt;x&lt;/em&gt; 인 첫 번째 항목 목록에서 0부터 시작하는 인덱스를 반환합니다. 그러한 항목이 없으면 &lt;a href=&quot;https://docs.python.org/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d2833bbff6d0d9cb8e124557809e3869860afc23" translate="yes" xml:space="preserve">
          <source>See also more options with &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.locate&quot;&gt;&lt;code&gt;more_itertools.locate&lt;/code&gt;&lt;/a&gt;.  Install via &lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt;&lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.locate&quot;&gt; &lt;code&gt;more_itertools.locate&lt;/code&gt; &lt;/a&gt; 와 함께 더 많은 옵션을 참조하십시오. &lt;a href=&quot;https://github.com/erikrose/more-itertools&quot;&gt; &lt;code&gt;&amp;gt; pip install more_itertools&lt;/code&gt; &lt;/a&gt; 를 통해 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="de72ea9e60d3b0389fb7873c1d21268b088fa6d4" translate="yes" xml:space="preserve">
          <source>Simple</source>
          <target state="translated">Simple</target>
        </trans-unit>
        <trans-unit id="5f19a099f5daf4cba2f285ede196b8c8dcc971e5" translate="yes" xml:space="preserve">
          <source>Simply you can go with</source>
          <target state="translated">간단히 당신은 함께 갈 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6a619efbec29e8228fb95db390a95faa0c3c06e8" translate="yes" xml:space="preserve">
          <source>Since Python lists are zero-based, we can use the zip built-in function as follows:</source>
          <target state="translated">파이썬리스트는 0부터 시작하기 때문에 다음과 같이 zip 내장 함수를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0a8c9cecf78e1520d6f30aa06c477eda5abb1c29" translate="yes" xml:space="preserve">
          <source>Something like this:</source>
          <target state="translated">이 같은:</target>
        </trans-unit>
        <trans-unit id="b7676ae6a860f704f1361d69d71911590b4294a1" translate="yes" xml:space="preserve">
          <source>Test multiple items:</source>
          <target state="translated">여러 항목을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="c00b9915c4af1c0e3e761b8424b3dc5d41dd0e3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index()&lt;/code&gt; function only returns the first occurrence, while &lt;code&gt;enumerate()&lt;/code&gt; returns all occurrences.</source>
          <target state="translated">&lt;code&gt;index()&lt;/code&gt; 함수는 첫 번째 항목 만 반환하고 &lt;code&gt;enumerate()&lt;/code&gt; 는 모든 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="533af82c7985e1e1da68be39a0be7100be17afe5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keyword&lt;/code&gt; module uses it to find comment markers in the module to automatically regenerate the list of keywords in it via metaprogramming.</source>
          <target state="translated">&lt;code&gt;keyword&lt;/code&gt; 모듈은이를 사용하여 메타 프로그래밍을 통해 키워드 목록을 자동으로 재생성하기 위해 모듈에서 주석 마커를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="3705fe105cc047980a555a111f24244cddb92242" translate="yes" xml:space="preserve">
          <source>The XY problem is asking about your attempted solution rather than your actual problem.</source>
          <target state="translated">XY 문제는 실제 문제가 아니라 시도한 솔루션에 대한 질문입니다.</target>
        </trans-unit>
        <trans-unit id="7cdb977223c9fd664b610a847cd9ce874cc698ac" translate="yes" xml:space="preserve">
          <source>The majority of answers explain how to find &lt;strong&gt;a single index&lt;/strong&gt;, but their methods do not return multiple indexes if the item is in the list multiple times. Use &lt;a href=&quot;https://docs.python.org/library/functions.html#enumerate&quot;&gt;&lt;code&gt;enumerate()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">대부분의 답변 &lt;strong&gt;은 단일 인덱스&lt;/strong&gt; 를 찾는 방법을 설명하지만 항목이 여러 번 목록에 있으면 해당 메소드는 여러 인덱스를 반환하지 않습니다. &lt;a href=&quot;https://docs.python.org/library/functions.html#enumerate&quot;&gt; &lt;code&gt;enumerate()&lt;/code&gt; &lt;/a&gt; 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="5f29b72d7f916a12c8205ab8d00a66727da6e64f" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are interpreted as in the &lt;a href=&quot;https://docs.python.org/tutorial/introduction.html#lists&quot;&gt;slice notation&lt;/a&gt; and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument.</source>
          <target state="translated">선택적 인수 &lt;em&gt;start&lt;/em&gt; 및 &lt;em&gt;end&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/tutorial/introduction.html#lists&quot;&gt;슬라이스 표기법에서&lt;/a&gt; 와 같이 해석되며 검색을 목록의 특정 하위 시퀀스로 제한하는 데 사용됩니다. 반환 된 인덱스는 시작 인수가 아닌 전체 시퀀스의 시작을 기준으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="23ed6c68ba031e2fb0f343e2066536b8cbcbb224" translate="yes" xml:space="preserve">
          <source>There are a couple of issues with this method:</source>
          <target state="translated">이 방법에는 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f0d5ad2ee580d4c84695a38396f9524590232d" translate="yes" xml:space="preserve">
          <source>There are many, many uses for it in &lt;code&gt;idlelib&lt;/code&gt;, for GUI and text parsing.</source>
          <target state="translated">&lt;code&gt;idlelib&lt;/code&gt; 에서는 GUI 및 텍스트 구문 분석에 많은 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e189e0c580d334b70585be6ccb6ad770994c518c" translate="yes" xml:space="preserve">
          <source>There is a more functional answer to this.</source>
          <target state="translated">이에 대한 더 기능적인 답변이 있습니다.</target>
        </trans-unit>
        <trans-unit id="846f71d4ddbcbba38d71a85c1e823b4638b3ac0d" translate="yes" xml:space="preserve">
          <source>This accounts for if the string is not in the list too, if it isn't in the list then &lt;code&gt;location = -1&lt;/code&gt;</source>
          <target state="translated">문자열이 목록에없는 경우, 목록에없는 경우 &lt;code&gt;location = -1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9eec5464d883c5746ea1d6fb365ccdd05d18464c" translate="yes" xml:space="preserve">
          <source>This function takes the item and the list as arguments and return the position of the item in the list, like we saw before.</source>
          <target state="translated">이 함수는 항목과 목록을 인수로 사용하여 이전에 본 것처럼 목록에서 항목의 위치를 ​​반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a18e2d1e4a696503611ee32d548c6aa74bd6dbb" translate="yes" xml:space="preserve">
          <source>This is more efficient for larger lists than using &lt;code&gt;enumerate()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;enumerate()&lt;/code&gt; 사용하는 것보다 큰 목록에 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="21b8992161e2b5e8e19f6b2fb7385c35645b9193" translate="yes" xml:space="preserve">
          <source>This solution is not as powerful as others, but if you're a beginner and only know about &lt;code&gt;for&lt;/code&gt;loops it's still possible to find the first index of an item while avoiding the ValueError:</source>
          <target state="translated">이 솔루션은 다른 솔루션만큼 강력하지는 않지만 초보자이고 &lt;code&gt;for&lt;/code&gt; 루프에 대해서만 알고 있다면 ValueError를 피하면서 항목의 첫 번째 색인을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4401047efffd77dbd6aeaf37b4c9c09933d4d63a" translate="yes" xml:space="preserve">
          <source>Throws if element not present in list</source>
          <target state="translated">요소가리스트에없는 경우 발생</target>
        </trans-unit>
        <trans-unit id="f7f6f80965fb2a95d3d41d847d0370e0153285c0" translate="yes" xml:space="preserve">
          <source>To get all indexes:</source>
          <target state="translated">모든 인덱스를 얻으려면</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="8debd965625833a02abf017f534957fa9c920ff2" translate="yes" xml:space="preserve">
          <source>Well, sure, there's the index method, which returns the index of the first occurrence:</source>
          <target state="translated">음, 첫 번째 색인을 반환하는 index 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9feb3701a7b5e907cd77de120330d62f6fbe772d" translate="yes" xml:space="preserve">
          <source>What these usages seem to have in common is that they seem to operate on lists of constrained sizes (important because of O(n) lookup time for &lt;code&gt;list.index&lt;/code&gt;), and they're mostly used in parsing (and UI in the case of Idle).</source>
          <target state="translated">이 사용법이 공통적으로 보이는 것은 제한된 크기 목록 (목록 ( &lt;code&gt;list.index&lt;/code&gt; 의 O (n) 조회 시간으로 인해 중요)으로 작동하는 것)에서 작동하는 것으로 보이며 대부분 구문 분석 (및 경우의 경우 UI)에 사용됩니다 게으른).</target>
        </trans-unit>
        <trans-unit id="c3c1d3127006853f690674b9e898879780232f1c" translate="yes" xml:space="preserve">
          <source>When pasted into an interactive python window:</source>
          <target state="translated">대화 형 파이썬 창에 붙여 넣을 때 :</target>
        </trans-unit>
        <trans-unit id="04e868c4615730112b8796c82580a82b3f69dd91" translate="yes" xml:space="preserve">
          <source>Which, when pasted into an interactive python window yields:</source>
          <target state="translated">대화 형 파이썬 창에 붙여 넣을 때</target>
        </trans-unit>
        <trans-unit id="a799097e107541e4293734d380b0049cbb4578f4" translate="yes" xml:space="preserve">
          <source>While there are use-cases for it, they are fairly uncommon. If you find yourself looking for this answer, ask yourself if what you're doing is the most direct usage of the tools provided by the language for your use-case.</source>
          <target state="translated">유스 케이스가 있지만 매우 드문 경우입니다. 이 답변을 찾고 있다면 자신이 사용하고있는 작업이 사용 사례에 맞는 언어로 제공되는 도구를 가장 직접적으로 사용하고 있는지 자문 해보십시오.</target>
        </trans-unit>
        <trans-unit id="6544e769402a49062cf544424f2158f973601950" translate="yes" xml:space="preserve">
          <source>Why do you think you need the index given an element in a list?</source>
          <target state="translated">왜 목록에 요소가 주어진 색인이 필요하다고 생각합니까?</target>
        </trans-unit>
        <trans-unit id="3c1cf64e16d0a70350a8ba0e9ce7b5459e83c74b" translate="yes" xml:space="preserve">
          <source>Why write a function with exception handling if the language provides the methods to do what you want itself?</source>
          <target state="translated">언어가 원하는 작업을 수행 할 수있는 메소드를 제공하는 경우 예외 처리를 사용하여 함수를 작성하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a840a787ebb368bc6d84e6f435c43120c05ad085" translate="yes" xml:space="preserve">
          <source>With enumerate(alist) you can store the first element (n) that is the index of the list when the element x is equal to what you look for.</source>
          <target state="translated">enumerate (alist)를 사용하면 요소 x가 찾는 것과 같을 때 목록의 색인 인 첫 번째 요소 (n)를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58004b3fdee6090f4c29533d21a33da40076b1de" translate="yes" xml:space="preserve">
          <source>Wrap the &lt;code&gt;index&lt;/code&gt; call in a &lt;code&gt;try/except&lt;/code&gt; block which catches &lt;code&gt;ValueError&lt;/code&gt; (probably faster, at least when the list to search is long, and the item is usually present.)</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 호출을 &lt;code&gt;try/except&lt;/code&gt; 블록에 래핑하여 &lt;code&gt;ValueError&lt;/code&gt; 를 잡습니다 (적어도 검색 할 목록이 길고 항목이있는 경우 더 빠름).</target>
        </trans-unit>
        <trans-unit id="cc18f2f503924b825e088eeadfc7a83d7f6685c3" translate="yes" xml:space="preserve">
          <source>Yes, you could use a list comprehension with enumerate too, but that's just not as elegant, in my opinion - you're doing tests for equality in Python, instead of letting builtin code written in C handle it:</source>
          <target state="translated">예, 열거 형과 함께 목록 이해를 사용할 수는 있지만, 제 생각에는 우아하지 않습니다 .C로 작성된 내장 코드가 처리하도록하는 대신 Python에서 평등에 대한 테스트를하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6d7ab23bae3bb30ea03eb02bb05eafd7419158b" translate="yes" xml:space="preserve">
          <source>You can do so with a reusable definition like this:</source>
          <target state="translated">다음과 같이 재사용 가능한 정의로 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9344b86dc9b6a3e208be80369545f27ad82257b3" translate="yes" xml:space="preserve">
          <source>You could also use this as a one liner to get all indices for a single entry. There are no guarantees for efficiency, though I did use set(a) to reduce the number of times the lambda is called.</source>
          <target state="translated">단일 항목에 대한 모든 지수를 얻기 위해 이것을 하나의 라이너로 사용할 수도 있습니다. 람다가 호출되는 횟수를 줄이기 위해 set (a)를 사용했지만 효율성에 대한 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1660bf3ae3a8b357a3570854bd099d55df8fe213" translate="yes" xml:space="preserve">
          <source>You have to set a condition to check if the element you're searching is in the list</source>
          <target state="translated">검색중인 요소가 목록에 있는지 확인하기위한 조건을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f5f06f92705914174990429b3f3f71c96d42bf8" translate="yes" xml:space="preserve">
          <source>You might enumerate into a list comprehension the indexes:</source>
          <target state="translated">인덱스를 목록 이해로 열거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="04d2c451f757f8e156cea4edcefc038d4b9298f0" translate="yes" xml:space="preserve">
          <source>and if name wasn't at arr,the function return -1.for example:</source>
          <target state="translated">이름이 arr에 없으면 함수는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb7f7bc55138daa1011f117e6154bcdf8cff1f3d" translate="yes" xml:space="preserve">
          <source>and the result is:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1cebe0aca9cffd65ef5e990f4cc2f2381b45601" translate="yes" xml:space="preserve">
          <source>if more than one of the value is in the list, you only get the index for the first one</source>
          <target state="translated">하나 이상의 값이 목록에 있으면 첫 번째 값에 대해서만 색인을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ff53deb61f1b6529e54714fd7a4520a2c7117494" translate="yes" xml:space="preserve">
          <source>if the value isn't in the list, you'll get a &lt;code&gt;ValueError&lt;/code&gt;</source>
          <target state="translated">값이 목록에 없으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3c32f1c2094095c52fb3c98b1d262d3c59fe93d3" translate="yes" xml:space="preserve">
          <source>in my opinion the &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;].index(&quot;bar&quot;)&lt;/code&gt; is good but it isn't enough!because if &quot;bar&quot; isn't in dictionary,&lt;code&gt;ValueError&lt;/code&gt; raised.So you can use this function:</source>
          <target state="translated">내 의견으로는 &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;].index(&quot;bar&quot;)&lt;/code&gt; 는 좋지만 충분하지 않습니다! &quot;bar&quot;가 사전에 없으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다. 이 기능을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="bfeaa83f659442d7000d35cd4e69f87f6c981f62" translate="yes" xml:space="preserve">
          <source>print(find_index([&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;], &quot;fooo&quot;))</source>
          <target state="translated">print (find_index ([ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;], &quot;fooo&quot;))</target>
        </trans-unit>
        <trans-unit id="ae96157eaa6a73acc01741d4c34deda1f29a863e" translate="yes" xml:space="preserve">
          <source>using dictionary , where process the list first and then add the index to it</source>
          <target state="translated">dictionary를 사용하여 목록을 먼저 처리 한 다음 색인을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a8d3e403bcd1f6cd0c14b4ef48d7c30982248134" translate="yes" xml:space="preserve">
          <source>where &quot;haystack&quot; is the list in question and &quot;needle&quot; is the item to look for.</source>
          <target state="translated">여기서 &quot;haystack&quot;은 문제의 목록이고 &quot;needle&quot;은 찾을 항목입니다.</target>
        </trans-unit>
        <trans-unit id="753bb33740732dd3048f5dd26ccf443da7f29592" translate="yes" xml:space="preserve">
          <source>which will often lead you to the method you are looking for.</source>
          <target state="translated">종종 당신이 찾고있는 방법으로 이어질 것입니다.</target>
        </trans-unit>
        <trans-unit id="28ca6530764be90c4d17b5dddf1693dd50b7303b" translate="yes" xml:space="preserve">
          <source>|      L.index(value, [start, [stop]]) -&amp;gt; integer -- return first index of value</source>
          <target state="translated">| L.index (value, [start, [stop]])-&amp;gt; integer-첫 번째 인덱스 값을 반환</target>
        </trans-unit>
        <trans-unit id="5d70790b5d8176367f775dae7a6fdf3f92c38331" translate="yes" xml:space="preserve">
          <source>|  index(...)</source>
          <target state="translated">| 인덱스(...)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
